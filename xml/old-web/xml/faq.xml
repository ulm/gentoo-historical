<?xml version="1.0"?>

<!DOCTYPE guide SYSTEM "../../gentoo-web/dtd/guide.dtd">

<guide>
  <title>Portage2 FAQ</title>
  <author title="Core Developer">
	<mail link="gbevin@gentoo.org">Geert Bevin</mail>
  </author>
  <author title="Core Developer">
	<mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail>
  </author>
  
  <abstract>Answers all frequently asked questions about technological
	choices, architectural decisions, and more.</abstract>
  
  <version>1.1</version>
  <date>30 Mar 2002</date>
  
  <chapter>
    <title>Architectural decisions</title>
    <section>
      <title>What advantages will Portage2 have compared to Portage1
		and which new features will be implemented?</title>
      <body>
		<p>With Portage2 we're building a world-class ports system
		  with no compromises. We're aiming for at least an order of
		  magnitude performance increase in all areas compared to
		  Portage1, while offering more advanced and more powerful
		  features</p>
		
		<p>In addition to the package management tools we're also
		  building a complete developer API for a next-generation ports
		  package management system, sporting overall consistent source
		  code and exhaustive documentation to all public
		  functionalities.</p>
		
		<p>The motivation for exposing clean and well-documented APIs
		  is of course to encourage a thriving tool community built
		  around Portage2. We have already seen the interest for this
		  with Portage1 with tools such as qpkg, pkgsearch and
		  pkg-clean.</p>

		<p>Current concepts will be extended. For example, advanced
		  dependencies and use-flag system to offer more automatic,
		  adaptive and unintrusive maintenance of package
		  installations.</p>
	
      </body>
    </section>
    
    <section>
      <title>Why is it being written from scratch?</title>
      <body>
		<p>Portage1 has been written on a feature-requirement basis:
		  when something was needed it was simply added.  This made it
		  very easy to gain quick insights into what Portage should do,
		  shouldn't do or should do differently.</p>

		<p>The fruits of that phase of exploratory programming is now
		  apparent. We have a very clear idea of where Portage2 should
		  go. This includes design for the core itself, the support
		  tools and all necessary libraries.</p>
	
		<p>The current state of portage1 makes refactoring it to a clean
		  design with associated documentation and easy to understand APIs
		  such an involving task that starting from a clean slate has been
		  deemed the best approach.</p>

		<p>Performance-wise we also think that we've touched the limit of
		  what the current architecture can offer. Since we'd like to add a
		  lot of computation intensive features while making everything even
		  faster, a radical redesign was needed.</p>

		<p>This radical redesign touches a lot more than just the choice
		  of language.</p>

      </body>
    </section>

	<section>
	  <title>Is the ebuild package format going to be 100% backwards
		compatible?</title>

	  <body>
		<p>Yes.</p>
		
		<p>Additional features will be available as extensions to
		  the current ebuild format. All current packages will
		  continue to function, but with instant and immediate
		  advantages and more powerful features.</p>

	  </body>
	</section>

    <section>
      <title>Is the package database going to be stored in a binary
		format?</title>

      <body>
		<p>Yes.</p>

		<p>The queries that portage2 has to perform are becoming
		  increasingly complex. A flat file ASCII database makes new
		  features such as the enhanced use flag system, advanced
		  dependencies, automatic package rebuilding and safe unmerging
		  extremely difficult to implement. We find ourselves faced with the
		  need of more and more database-like features that would eventually
		  come very close to what SQL-based databases currently
		  offer. Therefore we decided to opt for an existing embedded
		  database solution.</p>

		<P>This immediately offers us:</P>
		<ul>
		  <li>huge speed improvements,</li>
		  <li>true SQL queries, and no custom half-backed
			feature-lacking query language or API,</li>
		  <li>transactions,</li>
		  <li>online backups,</li>
		  <li>easy direct access to the database through SQL and the
			possibility to use any existing JDBC/ODBC tool,</li>
		  <li>optional future setup of database servers for
			centralized package management.</li>
		</ul>
      </body>
    </section>
	
    <section>
      <title>Are we still going to be able to use standard Unix tools
		to access the package database?</title>
	  
      <body>
		<p>Yes.</p>
		
		<p>Portage2 will be able to export and import information to
		  and from a directory. The directory layout and file formats
		  will be backwards compatible with portage1. This allows
		  sysadmins to continue to use existing tools and habits, while
		  it removes the burden of having to work with an ASCII
		  flat-file database for the internal queries.</p>

		<p>It is very important to note here that the new command-line
		  tools coupled with the external API and the language
		  bindings will make interfacing the the package system <b>a lot</b>
		  easier. Instead of just exposing the internal data of the package
		  system, we now also expose functionality to insure that the
		  database itself is always internally consistent.</p>

      </body>
    </section>
    
    <section>
      <title>Are there going to be bindings for other
		languages?</title>
	  
      <body>
		<p>Yes.</p>
	
		<p>We will initially develop bindings for Python to satisfy the
		  current Portage1 users. This provides the possibility to use
		  the language they're used to for extending and accessing internal
		  Portage features.</p>

		<p>Since we'll be using <uri link="http://www.swig.org">swig</uri>
		  to develop these bindings, it will be trivial to later on provide
		  additional bindings for Tcl, Perl, Ruby, Guile, Mzscheme, Eiffel,
		  Java, Javascript and PHP.</p>

		<p>It must be noted here that if any external tools are being
		  integrated into future Portage releases, they will most
		  likely be rewritten to Python, to reduce the language
		  dependencies which would otherwise become obscenely prohibitive.</p>

      </body>
    </section>
  </chapter>
  
  <chapter>
    <title>Technological choices</title>
    <section>
      <title>Why C++ and Qt?</title>
      <body>
		<p>For the language lawyers, we haven't based our choice of
		  development language by talking about how it's better or worse
		  than others. Everybody has his preferences and they are in every
		  aspect as valid as anybody else's preferences. You can't select
		  tools by debating on subjective arguments. The only real
		  comparison that can be made is to identify what's really needed
		  and to detect what offers the required features to attain those
		  goals.</p>

		<p>Therefore the core Portage2 development team has agreed
		  upon a number of critically important
		  requirements. Afterwards we evaluated a number of languages
		  and platforms by writing proof-of-concept implementations of
		  the same functionalities. We then examined those
		  implementations and objectively looked at how they related
		  to the previously established requirements.</p>

		<p>The requirements were:</p>
		<ul>
		  <li>few lines of code</li>
		  <li>easy to maintain</li>
		  <li>stable</li>
		  <li>portable</li>
		  <li>compiled</li>
		  <li>object model and object-oriented</li>
		  <li>variable declaration</li>
		  <li>type safety</li>
		  <li>small binary size</li>
		</ul>
		<p>The evaluated languages and platforms were:</p>
		<ul>
		  <li>C &amp; glib &amp; gobject</li>
		  <li>Java &amp; gcj</li>
		  <li>Python</li>
		  <li>Sather</li>
		  <li>C++ &amp; TinyQt</li>
		</ul>
	
		<p>C++ &amp; TinyQt proved to be conform to most of the
		  requirements. However we identified one major shortcoming and
		  point-of-failure. C++ is a very complex language that can only
		  be used properly with a very good understanding of <e>all</e>
		  its features. Therefore we've written a
		  <uri link="cpp_codingstandard.html">C++ Coding Standard</uri>
		  that specifies a unified coding style which encourages clear
		  code and immediate understanding of important lexical
		  differences. It also provides guidelines and best practices to
		  provide an understanding about the most common C++ pitfalls
		  and misconceptions.</p>

      </body>
    </section>

    <section>
      <title>What is TinyQt?</title>
      <body>
		<p>Since version 3, Qt has become more than a GUI
		  toolkit. It's a complete programming platform that offers
		  solutions to the most commonly used back-end
		  functionalities. TinyQt contains only these classes and
		  provides the following in a very easy to use, fast and stable
		  API:</p>

		<ul>
		  <li>UTF8 and ASCII strings,</li>
		  <li>type optimized collections (dictionary, map, cache,
			vector, list),</li>
		  <li>regular expressions,</li>
		  <li>filesystem access,</li>
		  <li>URL processing,</li>
		  <li>shared library handling,</li>
		  <li>user settings,</li>
		  <li>date and time handling,</li>
		  <li>DOM &amp;	SAX XML parsers,</li>
		  <li>optimized data and text streams,</li>
		  <li>abstract IO devices.</li>
		</ul>
	
		<p>All this is provided in a shared library that only weighs
		  570KB.</p>

		<p>You can find detailed information about TinyQt
		  <uri link="tinyqt.html">here</uri>.</p>

      </body>
    </section>
	
    <section>
      <title>Why Firebird?</title>
      <body>
		<p>We've adopted the same way of working as what has been
		  explained above for the determination of the development
		  language.</p>
		
		<p>The requirements were:</p>
		<ul>
		  <li>embeddable,</li>
		  <li>stable,</li>
		  <li>robust,</li>
		  <li>well documented,</li>
		  <li>no maintenance,</li>
		  <li>intuitive query language or API,</li>
		  <li>relational,</li>
		  <li>transactional,</li>
		  <li>small size.</li>
		</ul>

		<p>The evaluated databases were:</p>
		<ul>
		  <li>Berkeley DB,</li>
		  <li>Sqlite,</li>
		  <li>Firebird.</li>
		</ul>

		<p>Firebird clearly turned out to be the most suitable.</p>

      </body>
    </section>
	
    <section>
      <title>Why Pccts?</title>
      <body>
		<p>It was immediately clear that it would be much better to
		  use a parser generator instead of writing a custom parser
		  ourselves.</p>

		<p>Initially the lexical scanning and parsing has been implemented
		  with Flex and Bison. When the first prototype was finished a
		  number of very apparent and unsolvable shortcomings
		  appeared. The only way to resolve these was by finding
		  another tool that was more appropriate.</p>

		<p>Pccts offers the following features that made us select it:</p>

		<ul>
		  <li>generates re-enterable and embeddable parsers,</li>
		  <li>generates C++ classes instead of C functions,</li>
		  <li>generates human-readable code,</li>
		  <li> actively	maintained,</li>
		  <li>provides a tool for generating and integrating abstract
			syntax trees,</li>
		  <li>implemented in C and not in Java as is its successor
			Anltr2,</li>
		  <li>accepts a	parser specification in an extended version of
			the Backus-Naur	Form notation.</li>
		</ul>

      </body>
    </section>
  </chapter>
  
  <chapter>
    <title>Miscellaneous</title>
    <section>
      <title>Show me the source!</title>
      <body>
		<p>It's in our CVS repository, the <path>gentoo-src</path>
		  module, in <path>portage2</path></p>

		<p>The code is supposed to be clean, so anyone with cursory
		  familiarity with C-like languages should be able to peruse
		  it quite easily.</p>

		<p>Be sure to read the <uri link="howto.html">Portage2 development
			how-to</uri> before starting to commit changes!</p>

		<p>We are even going out on a limb here, and offering a lot of
		  documentation for the Portage2 end-user and
		  end-developer.</p>

		<p>If you're still dissatisfied with our efforts or are
		  disgruntled about something, mail us!</p>

      </body>
    </section>
        

  </chapter>

</guide>

