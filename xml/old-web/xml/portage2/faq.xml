<?xml version="1.0"?>

<!DOCTYPE guide SYSTEM "../../gentoo-web/dtd/guide.dtd">

<guide>
  <title>Portage2 FAQ</title>
  <author title="Core Developer">
	<mail link="gbevin@gentoo.org">Geert Bevin</mail>
  </author>
  
  <abstract>Answers all frequently asked questions about technological choices, architectural decisions, and more.</abstract>
  
  <version>1.0</version>
  <date>29 Mar 2002</date>

  <chapter>
	<title>Architectural decisions</title>
	<section>
	  <title>What advantages will Portage2 have compared to Portage1 and which new features will be implemented?</title>
	  <body>
		<p>With Portage2 we're building a world class ports system with no compromises. We're aiming for at least an order of magnitude performance increase in all areas while offering more advanced and more powerful features.</p>
		<p>In addition to the package management tools we're also building a complete developer API for a next-generation ports package management system, sporting overall consistent source code and exhaustive documentation to all public functionalities.</p>
		<p>Current concepts will be extended. For example, advanced dependencies and use-flag system to offer more automatic, adaptive and unintrusive maintenance of package installations.</p>
	  </body>
	</section>
	<section>
	  <title>Why is it being written from scratch?</title>
	  <body>
		<p>Portage1 has been written on a feature-requirement basis. Something was needed and subsequently it was added. This made it very easy to gain quick insights into what Portage should do, shouldn't do or should do differently. Now the time has come to take that experience and move on to a better design and to better tools and libraries, thus lifting portage to a next level of performance and power.</p>
		<p>The current state of portage1 makes refactoring it to a clean design with associated documentation and easy to understand apis such an involving task that starting from a clean slate might prove to be even easier.</p>
		<p>Performance-wise we also think that we've touched the limit of what the current architecture can offer. Since we'd like to add a lot of computation intensive features while making everything even faster, a radical redesign was needed.</p>
	  </body>
	</section>
	<section>
	  <title>Is the package database going to be stored in a binary format?</title>
	  <body>
		<p>Yes.</p>
		<p>The queries that portage2 has to perform are becoming increasingly complex. A flat file ASCII database makes new features such as the enhanced use flag system, advanced dependencies, automatic package rebuilding and safe unmerging extremely difficult to implement. We find ourselves faced with the need of more and more database-like features that would eventually come very close to what SQL-based databases currently offer. Therefore we decided to opt for an existing embedded database solution.</p>
		<P>This immediately offers us:</P>
		<ul>
		  <li>huge speed improvements,</li>
		  <li>true SQL queries, and no custom half-backed feature-lacking query language or api,</li>
		  <li>transactions,</li>
		  <li>online backups,</li>
		  <li>easy direct access to the database through SQL and the possibility to use any existing JDBC/ODBC tool,</li>
		  <li>optional future setup of database servers for centralized package management.</li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Are we still going to be able to use standard unix tools to access the package database?</title>
	  <body>
		<p>Yes.</p>
		<p>Portage2 will be able to export and import information to and from a directory. The directory layout and file formats will be backwards compatible with portage1. This allows sysadmins to continue to use existing tools and habits, while it removes the burden of having to work with an ASCII flat-file database for the internal queries.</p>
	  </body>
	</section>
	<section>
	  <title>Are there going to be bindings for other languages?</title>
	  <body>
		<p>Yes.</p>
		<p>We will initially develop bindings for Python to satisfy the current portage1 users. This provides the possibility to use the language they're used to for extending and accessing internal portage features.</p>
		<p>Since we'll be using <uri link="http://www.swig.org">swig</uri> to develop these bindings, it will be trivial to later on provide additional bindings for Tcl, Perl, Ruby, Guile, Mzscheme, Eiffel, Java, Javascript and Php.</p>
	  </body>
	</section>
  </chapter>
  
  <chapter>
	<title>Technological choices</title>
	<section>
	  <title>Why C++ and Qt?</title>
	  <body>
		<p>For the language lawyers, we haven't based our choice of development language by talking about how it's better or worse than others. Everybody has his preferences and they are in every aspect as valid as anybody else's preferences. You can't select tools by debating on subjective arguments. The only real comparison that can be made is to identify what's really needed and to detect what offers the required features to attain those goals.</p>
		<p>Therefore the core Portage2 development team has agreed upon a number of critically important requirements. Afterwards we evaluated a number of languages and platforms by writing proof-of-concept implementations of the same functionalities. We then examined those implementations and objectively looked at how they related to the previously established requirements.</p>
		<p>The requirements were:</p>
		<ul>
		  <li>few lines of code</li>
		  <li>easy to maintain</li>
		  <li>stable</li>
		  <li>portable</li>
		  <li>compiled</li>
		  <li>object model and object-oriented</li>
		  <li>variable declaration</li>
		  <li>type safety</li>
		  <li>small binary size</li>
		</ul>
		<p>The evaluated languages and platforms were:</p>
		<ul>
		  <li>C &amp; glib &amp; gobject</li>
		  <li>Java &amp; gcj</li>
		  <li>Python</li>
		  <li>Sather</li>
		  <li>C++ &amp; TinyQt</li>
		</ul>
		<p>C++ &amp; TinyQt proved to be conform to most of the requirements. However we identified one major shortcoming and point-of-failure. C++ is a very complex language that can only be used properly with a very good understanding of <e>all</e> its features. Therefore we've written a C++ Coding Standard that specifies a unified coding style which encourages clear code and immediate understanding of important lexical differences. It also provides guidelines and best practices to  provide an understanding about the most common C++ pitfalls and misconceptions.</p> 
	  </body>
	</section>
	<section>
	  <title>What is TinyQt?</title>
	  <body>
		<p>Since version 3, Qt has become more than a gui toolkit. It's a complete programming platform that offers solutions to the most commonly used backend functionalities. TinyQt contains only these classes and provides the following in a very easy to use, fast and stable api:</p>
		<ul>
		  <li>UTF8 and ASCII strings,</li>
		  <li>type optimised collections (dictionary, map, cache, vector, list),</li>
		  <li>regular expressions,</li>
		  <li>filesystem access,</li>
		  <li>url processing,</li>
		  <li>shared library handling,</li>
		  <li>user settings,</li>
		  <li>date and time handling,</li>
		  <li>dom &amp; sax xml parsers,</li>
		  <li>optimised data and text streams,</li>
		  <li>abstract IO devices.</li>
		</ul>
		<p>All this is provided in a shared library that only weighs 570Kb.</p>
	  </body>
	</section>
	<section>
	  <title>Why Firebird?</title>
	  <body>
		<p>We've adopted the same way of working as what has been explained above for the determination of the development language.</p>
		<p>The requirements were:</p>
		<ul>
		  <li>embeddable,</li>
		  <li>stable,</li>
		  <li>robust,</li>
		  <li>well documentated,</li>
		  <li>no maintenance,</li>
		  <li>intuitive query language or api,</li>
		  <li>relational,</li>
		  <li>transactions,</li>
		  <li>small size.</li>
		</ul>
		<p>The evaluated databases were:</p>
		<ul>
		  <li>Berkeley DB,</li>
		  <li>Sqlite,</li>
		  <li>Firebird.</li>
		</ul>
		<p>Firebird clearly turned out to be the most suitable.</p>
	  </body>
	</section>
	<section>
	  <title>Why Pccts?</title>
	  <body>
		<p>It was immediately clear that it would be much better to use a parser generator instead of writing a custom parser ourselves.</p>
		<p>Initially the lexical scanning and parsing has been implemented with Flex and Bison. When the first prototype was finished a number of very apparent and unsolvable shortcomings appeared. The only way to resolve these was by finding another tool that was more appropriate.</p>
		<p>Pccts offers the following features that made us select it:</p>
		<ul>
		  <li>generates re-enterable and embeddable parsers,</li>
		  <li>generates C++ classes instead of C functions,</li>
		  <li>generates human-readable code,</li>
		  <li> actively maintained,</li>
		  <li>provides a tool for generating and integrating abstract syntax trees,</li>
		  <li>implemented in c and not in java as is its successor: Anltr2,</li>
		  <li>accepts a parser specification in an extended version of the Backus-Naur Form notation.</li>
		</ul>
	  </body>
	</section>
  </chapter>

</guide>

