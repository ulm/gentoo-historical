<?xml version='1.0'?>

<!DOCTYPE guide SYSTEM "../../gentoo-web/dtd/guide.dtd">

<guide>
  <title>Portage2 C++ Coding Standard</title>
  <author title="Core Developer">
	<mail link="gbevin@gentoo.org">Geert Bevin</mail>
  </author>

  <abstract>Explains the C++ coding style we've adopted and lists a number of best practices that should be followed.</abstract>

  <version>1.0</version>
  <date>26 Mar 2002</date>

  <chapter>
	<title>Make Names Fit</title>
	<section>
	  <title>Introduction</title>
	  <body>
		<p>Names are the heart of programming. In the past people believed knowing someone's true name gave them magical power over that person. If you can think up the true name for something, you give yourself and the people coming after power over the code. Don't laugh!</p>
	  </body>
	</section>
	<section>
	  <title>Selecting names</title>
	  <body>
		<p>A name is the result of a long deep thought process about the ecology it lives in. Only a programmer who understands the system as a whole can create a name what "fits" with the system. If the name is appropriate everything fits together naturally, relationships are clear, meaning is derivable, and reasoning from common human expectations works as expected.</p>
		<p>If you find all your names could be <e>Thing</e> and <e>DoIt</e> then you should probably revisit your design.</p>
		<ul>
		  <li>
			<p>Class Names</p>
			<ul>
			  <li><p>Name the class after what it is. If you can't think of what it is that is a clue you have not thought through the design well enough.</p></li>
			  <li><p>Compound names of over three words are a clue your design may be confusing various entities in your system. Revisit your design. Try a CRC card session to see if your objects have more responsibilities than they should.</p></li>
			  <li><p>Avoid the temptation of bringing the name of the class a class derives from into the derived class's name. A class should stand on its own. It doesn't matter what it derives from.</p></li>
			  <li><p>Suffixes are sometimes helpful. For example, if your system uses agents then naming something DownloadAgent conveys real information.</p></li>
			</ul>
		  </li>
		  <li>
			<p>Method and Function Names</p>
			<ul>
			  <li>
				<p>Usually every method and function performs an action, so the name should make clear what it does: <e>CheckForErrors()</e> instead of <e>ErrorCheck()</e>, <e>DumpDataToFile()</e> instead of <e>DataFile()</e>. This will also make functions and data objects more distinguishable.</p>
				<p>Classes are often nouns. By making function names verbs and following other naming conventions programs can be read more naturally.</p>
			  </li>
			  <li>
				<p>Suffixes are sometimes useful:</p>
				<ul>
				  <li><e>Max</e> - to mean the maximum value something can have.</li>
				  <li><e>Cnt</e> - the current count of a running count variable.</li>
				  <li><e>Key</e> - key value.</li>
				</ul>
				<p>For example: <e>RetryMax</e> to mean the maximum number of retries, <e>RetryCnt</e> to mean the current retry count.</p>
			  </li>
			  <li><p>Prefixes are sometimes useful:</p>
				<ul>
				  <li><e>Is</e> - to ask a question about something. Whenever someone sees Is they will know it's a question.</li>
				  <li><e>Get</e> - get a value.</li>
				  <li><e>Set</e> - set a value.</li>
				</ul>
				<p>For example: <e>IsHitRetryLimit</e>.</p>
			  </li>
			</ul>
		  </li>
		  <li>
			<p>Variable Names</p>
			<ul>
			  <li>
				<p>Make every variable name descriptive, limit the use of abbreviations or letter-words. It's worth writing words completely since it makes the code much more readable. Beware however that when trying to find a good name, you don't end up with with something like 'the_variable_for_the_loop', use a proper English word for it like 'counter' or 'iterator'. English is a rich language and trying to find a correctly fitting word is important for code brevety, cleanness and variation. Whenever in doubt, just use an thesaurus like Merriam-Webster (<uri>http://www.m-w.com</uri>) or a rhyming dictionary like Rhyme (<uri>http://rhyme.sourceforge.net/</uri>).</p>
			  </li>
			</ul>
			<p><e>Exceptions</e></p>
			<p>Some standard variables are used for often recurring tasks. Below is a list of those that are accepted :</p>
			<ul>
			  <li><e>i</e> : integer counter</li>
			  <li><e>it</e> : STL-like iterator</li>
			  <li><e>&lt;type&gt;_it</e> : STL-like iterator of a certain type for differentiation amongst types</li>
			  <li><e>tmp_&lt;type&gt;</e>  : eg. tmp_qstring, tmp_int, tmp_float for variables that are solely used for the storage of temporary intermediate values</li>
			</ul>
		  </li>
		  <li>
			<p>No All Upper Case Abbreviations</p>
			<ul>
			  <li><p>When confronted with a situation where you could use an all upper case abbreviation instead use an initial upper case letter followed by all lower case letters. No matter what.</p></li>
			</ul>
			<p><e>Justification</e></p>
			<p>People seem to have very different intuitions when making names containing abbreviations. It's best to settle on one strategy so the names are absolutely predictable.</p>
			<p>Take for example NetworkABCKey. Notice how the C from ABC and K from key are confused. Some people don't mind this and others just hate it so you'll find different policies in different code so you never know what to call something.</p>
		  </li>
		</ul>
	  </body>
	</section>

	<section>
	  <title>Naming scheme</title>
	  <body>
		<p>A standard naming scheme is important to ensure that all code looks similar and that every developer can understand new code immediately without have to grasp a new naming scheme first.</p>
		<p>One of the main aspects of this naming scheme is that all names should contain key information about the type of language construct is refers to. Additionally, certain prefixes will be used to prevent common error in the use of basic c++ concepts such as pointers, references and scope. This however doesn't involve into a full-blown and difficult to understand and maintain Hongarian notation.</p>
		<ul>
		  <li>
			<p>Class Names</p>
			<ul>
			  <li>Use upper case letters as word separators, lower case for the rest of a word</li>
			  <li>First character in a name is upper case</li>
			  <li>No underbars ('_')</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>Standard naming scheme in very clean OO languages such as Java and C#.</li>
			  <li>Stands out the best amongst the other names formatting, since a class is the basic element in c++ this is a great benefit.</li>
			</ul>
			<pre caption="Class Names Example">class NameOneTwo
class Name</pre>
		  </li>
		  <li>
			<p>Class Files</p>
			<ul>
			  <li>Each class definition should be in its own file where each file is named directly after the class's name.</li>
			  <li>Source files have the .cpp extension and header files have the .h extension.</li>
			  <li>In general each class should be implemented in one source file. A common exception to this rule are inner classes that provide class specific functionality such as thread execution. Another common exception are very closely related classes such as a collection class and its iterator.</li>
			  <li>If the source file gets too large or you want to avoid compiling templates all the time then add additional files, where the section is lower case and seperated of the classname through an underscore.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>Using exactly the same name as the real class makes it easy to establish the relation.</li>
			  <li>Not implementing several classes in one source file makes it very easy to find a class implementation when looking for it.</li>
			</ul>
			<pre caption="Class Files Example">ClassName.h
ClassName.cpp
ClassName_section1.cpp
ClassName_section2.cpp</pre>
		  </li>
		  <li>
			<p>Method Names</p>
			<ul>
			  <li>Use upper case letters as word separators, lower case for the rest of a word</li>
			  <li>First character in a name is lower case</li>
			  <li>No underbars ('_')</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>Differentiates the first word part, which is often a verb. This makes it very clear what a method does.</li>
			  <li>Not exactly similar to class names and thus makes Class.doSomething() much more readable as Class.DoSomething(), cleanly indicating through case which is which.</li>
			</ul>
			<pre caption="Method Names Example">class NameOneTwo
{
public:
    int     doIt();
    void    handleError();
}</pre>
		  </li>
		  <li>
			<p>Class Member Names</p>
			<ul>
			  <li>Member names should be prepended with the character 'm'.</li>
			  <li>Member the 'm' use the same rules as for class names.</li>
			  <li>'m' always precedes other name modifiers like 'p' for pointer.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>Prepending 'm' prevents any conflict with method names. Often your methods and attribute names will be similar, especially for accessors.</li>
			</ul>
			<pre caption="Class Member Names Example">class NameOneTwo
{
public:
    int     varAbc();
    int     errorNumber();
private:
    int     mVarAbc;
    int     mErrorNumber;
    String  *mpName;
}</pre>
		  </li>
		  <li>
			<p>Method Argument Names</p>
			<ul>
			  <li>The first character should be lower case.</li>
			  <li>All word beginnings after the first letter should be upper case as with class names.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>You can always tell which variables are passed in variables.</li>
			  <li>You can use names similar to class names without conflicting with class names.</li>
			</ul>
			<pre caption="Method Argument Names Example">class NameOneTwo
{
public:
    int startYourEngines(Engine&amp; rSomeEngine, bool autoRestart);
}</pre>
		  </li>
		  <li>
			<p>Variable Names on the Stack</p>
			<ul>
			  <li>Use all lower case letters</li>
			  <li>Use '_' as the word separator.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>With this approach the scope of the variable is clear in the code.</li>
			  <li>Now all variables look different and are identifiable in the code.</li>
			</ul>
			<pre caption="Variable Names on the Stack Example">int NameOneTwo::handleError(int errorNumber)
{
    int             error = OsErr();
    Time            time_of_error;
    ErrorProcessor  error_processor;
    String          *p_tmpstring;
}</pre>
		  </li>
		  <li>
			<p>Pointer Variables</p>
			<ul>
			  <li>Pointers should be prepended with 'p'.</li>
			  <li>Place the * close to the variable name not the pointer type.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>The idea is that the difference between a pointer, object, and a reference to an object is important for understanding the code, especially in C++ where -> can be overloaded, and casting and copy semantics are important.</li>
			  <li>The * belongs near the variable name since its not cumulative to other declarations of the same line. This convention follows closely the way c++ behaves in this matter.
				<pre caption="Placement of * during pointer declarations">BAD:  int* p_var;
GOOD: int *p_var;</pre>
			  </li>
			</ul>
			<pre caption="Pointer Variables Example">QString *p_name = new QString;
QString *p_name; // note, only pName is a pointer.
QString name;
QString address;</pre>
		  </li>
		  <li>
			<p>Reference Variables and Functions Returning References</p>
			<ul>
			  <li>References should be prepended with 'r'.</li>
			  <li>Place the &amp; close to the variable name not the reference type when working with reference variables. With function declarations, the &amp; should be close to the reference type.</li>
			  <li>Functions returning non const references should be prepended with 'r' to make it clear that a modifiable is being returned.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>The difference between variable types is clarified.</li>
			  <li>It establishes the difference between a method returning a modifiable object and the same method name returning a non-modifiable object.</li>
			</ul>
			<pre caption="Reference Variables and Functions Returning References Example">class Test
{
public:
    void                doSomething(StatusInfo &amp;rStatus);
    StatusInfo&amp;         rStatus();
    const StatusInfo&amp;   status() const;

private:
    StatusInfo &amp;mrStatus;
}</pre>
		  </li>
		  <li>
			<p>Global Variables</p>
			<ul>
			  <li>Global variables should be prepended with 'g'.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>It's important to know the scope of a variable.</li>
			</ul>
			<pre caption="Global Variables Example">Logger  gLog;
Logger *gpLog;</pre>
		  </li>
		  <li>
			<p>Global Constants</p>
			<ul>
			  <li>Global constants should be all caps with '_' separators.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>It's tradition for global constants to named this way. You must be careful to not conflict with other global #defines and enum labels.</li>
			</ul>
			<pre caption="Global Constants Example">const int A_GLOBAL_CONSTANT = 5;</pre>
		  </li>
		  <li>
			<p>Static Variables</p>
			<ul>
			  <li>Static variables should be prepended with 's'.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>It's important to know the scope of a variable.</li>
			</ul>
			<pre caption="Static Variables Example">class Test
{
public:
private:
    static StatusInfo   msStatus;
}</pre>
		  </li>
		  <li>
			<p>Type Names</p>
			<ul>
			  <li>When possible for types based on native types make a typedef.</li>
			  <li>Typedef names should use the same naming policy as for a class with the word Type appended.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>Types are things so should use upper case letters. Type is appended to make it clear this is not a class.</li>
			</ul>
			<pre caption="Type Names Example">typedef uint16  ModuleType;
typedef uint32  SystemType;</pre>
		  </li>
		  <li>
			<p>Enum Names</p>
			<ul>
			  <li>Labels All Upper Case with '_' Word Separators</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>This is the standard rule for enum labels.</li>
			</ul>
			<pre caption="Enum Names Example">enum PinStateType
{
    PIN_OFF,
    PIN_ON,
};</pre>
			<p><e>Note</e></p>
			<p>It's often useful to be able to say an enum is not in any of its valid states. Make a label for an uninitialized or error state. Make it the first label if possible.</p>
			<pre caption="Invalid Enum States Example">enum { STATE_NONE, STATE_OPEN, STATE_RUNNING, STATE_DYING};</pre>
		  </li>
		  <li>
			<p>C Function Names</p>
			<ul>
			  <li>In a C++ project there should be very few C functions.</li>
			  <li>For C functions use the GNU convention of all lower case letters with '_' as the word delimiter.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>It makes C functions very different from any C++ related names.</li>
			</ul>
			<pre caption="C Function Names Example">int some_c_function()
{
}</pre>
		  </li>
		  <li>
			<p>#define and Macro Names</p>
			<ul>
			  <li>Put #defines and macros in all upper using '_' separators.</li>
			</ul>
			<p><e>Justification</e></p>
			<ul>
			  <li>This makes it very clear that the value is not alterable and in the case of macros, makes it clear that you are using a construct that requires care.</li>
			  <li>Some subtle errors can occur when macro names and enum labels use the same name.</li>
			</ul>
			<pre caption="#define and Macro Names Example">#define MAX(a,b) blah
#define IS_ERR(err) blah</pre>
			</li>

		</ul>
	  </body>
	</section>
  </chapter>

  <chapter>
	<title>Code Formatting</title>
	<section>
	  <title>Introduction</title>
	  <body>
		<p>This uniform code formatting style encreases readability, maintainability and the comprehension of the code's logic.</p>
	  </body>
	</section>
	<section>
	  <title>Braces Policy</title>
	  <body>
		<p>Place braces under and inline with keywords, like this :</p>
		<pre caption="Braces Policy Example">if (condition)        while (condition)
{                     {
    ...                   ...
}                     }</pre>
		<p><e>Justification</e></p>
		<ul>
		  <li>
			<p>If you use an editor (such as vi) that supports brace matching, this is a much better style than the default unix style where braces aren't vertically aligned. Why? Let's say you have a large block of code and want to know where the block ends. You move to the first brace hit a key and the editor finds the matching brace.</p>
			<pre caption="Braces Policy Justification">if (very_long_condition &amp;&amp; second_very_long_condition)
{
    ...
}
else if (...)
{
    ...
}</pre>
			<p>To move from block to block you just need to use cursor down and your brace matching key. No need to move to the end of the line to match a brace then jerk back and forth.</p>
		  </li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Braces Usage</title>
	  <body>
		<p>All if, while and do statements must either have braces or be on a single line.</p>
		<p>Always Uses Braces Form, even if there is only a single statement within the braces.</p>
		<p><e>Justification</e></p>
		<ul>
		  <li>Easier to read, you just have to scan for one form.</li>
		  <li>Uniform idiom for scop blocks since they are all encolsed in braces.</li>
		  <li>It provides a more consistent look.</li>
		  <li>This doesn't affect execution speed and it's easy to apply.</li>
		  <li>It ensures that when someone adds a line of code later there are already braces and they don't forget.</li>
		</ul>
		<pre caption="Brace Usage Example">if (1 == somevalue)
{
   somevalue = 2;
}</pre>
	  </body>
	</section>
	<section>
	  <title>Parenthesis Policy</title>
	  <body>
		<ul>
		  <li>Do not put parens next to keywords. Put a space between.</li>
		  <li>Do put parens next to function names.</li>
		  <li>Do not use parens in return statements when it's not necessary.</li>
		</ul>
		<p><e>Justification</e></p>
		<ul>
		  <li>Keywords are not functions. By putting parens next to keywords, keywords and function names adopt a similar look while they have completely different semantic meanings.</li>
		</ul>
		<pre caption="Parenthesis Policy Example">if (condition)
{
}
    
while (condition)
{
}
    
strcpy(s, s1);
    
return 1;</pre>
	  </body>
	</section>
  </chapter>

  <chapter>
	<title>Class Design</title>
	<section>
	  <title>Required Class Methods</title>
	  <body>
		<p>To be good citizens almost all classes should implement the following methods. If you don't have to define and implement any of the "required" methods they should still be represented in your class definition as comments. If you just let the compiler generate them without indicating through comments that you know that this is the intended behaviour, people might wonder about the possibility of an ommision or oversight.</p>
		<ul>
		  <li>
			<p><e>Default Constructor</e></p>
			<p>If your class needs a constructor, make sure to provide one. You need one if during the operation of the class it creates something or does something that needs to be undone when the object dies. This includes creating memory, opening file descriptors, opening transactions etc.</p>
			<p>If the default constructor is sufficient add a comment indicating that the compiler-generated version will be used.</p>
			<p>If your default constructor has one or more optional arguments, add a comment indicating that it still functions as the default constructor.</p>
		  </li>
		  <li>
			<p><e>Virtual Destructor</e></p>
			<p>If your class is intended to be derived from by other classes then make the destructor virtual. You should always make a destructor virtual for the sake of future extensibility. Only make it non virtual if you've got a real good reason to do so.</p>
		  </li>
		  <li>
			<p><e>Copy Constructor</e></p>
			<p>If your class is copyable, either define a copy constructor and assignment operator or add a comment indicating that the compiler-generated versions will be used.</p>
			<p>If your class objects should not be copied, make the copy constructor and assignment operator private and don't define bodies for them. If you don't know whether the class objects should be copyable, then assume not until the copy operations are needed.</p>
		  </li>
		  <li>
			<p><e>Assignment Operator</e></p>
			<p>If your class is assignable, either define a assignment operator or add a comment indicating that the compiler-generated versions will be used.</p>
			<p>If your objects should not be assigned, make the assignment operator private and don't define bodies for them. If you don't know whether the class objects should be assignable, then assume not.</p>
		  </li>
		</ul>
		<p><e>Justification</e></p>
		<ul>
		  <li>Virtual destructors ensure objects will be completely destructed regardless of inheritance depth.
			You don't have to use a virtual destructor when:
			<ul>
			  <li>You don't expect a class to have descendants.</li>
			  <li>The overhead of virtualness would be too much.</li>
			  <li>An object must have a certain data layout and size.</li>
			</ul>
		  </li>
		  <li>A default constructor allows an object to be used in an array.</li>
		  <li>The copy constructor and assignment operator ensure an object is always properly constructed. Making them private, prevents copies from objects being made without you knowing about it and thus possibly inducing an unnecessary overhead or cause for inconsistency.</li>
		</ul>
		<pre caption="Required Class Methods Example">class Planet
{
public:
    // Planet();
    Planet(int radius= 5);
    ~Planet();
    
private:
    Planet(const Planet&amp;);
    Planet&amp; operator=(const Planet&amp;);
};</pre>
	  </body>
	</section>
	<section>
	  <title>Class Layout</title>
	  <body>
		<p>A common class layout is critical from a code comprehension point of view and for automatically generating documentation. C++ programmers, through a new set of tools, can enjoy the same level generated documentation Java programmers take for granted.</p>
		<p>Following is the template that should be used to organize each class declaration.</p>
		<pre caption="Class Layout Template">/**      
 * A detailed description of the class.
 * 
 * @short A short description of the class
 * @author Name of the author
 * @version version
 * @since version
 * @see something
 */

#ifndef XX_h
#define XX_h

// SYSTEM INCLUDES
//

// PROJECT INCLUDES
//

// LOCAL INCLUDES
//

// FORWARD REFERENCES
//


class XX
{
public:
// LIFECYCLE

    /**
     * Default constructor.
     */
    XX(void);
    
    /**
     * Copy constructor.
     *
     * @param from The value to copy to this object.
     */
    XX(const XX&amp; from);
    
    /**
     * Destructor.
     */
    ~XX(void);

// OPERATORS

    /**
     * Assignment operator.
     *
     * @param from the value to assign to this object.
     *
     * @return A reference to this object.
     */
    XX&amp; operator=(XX&amp; from);  

// OPERATIONS                       
// ACCESS
// INQUIRY

protected:
private:

// MEMBER VARIABLES

};

// INLINE METHODS
//

// EXTERNAL REFERENCES
//

#endif  // XX_h</pre>
	  </body>
	</section>
	<section>
	  <title>Initialize all Variables</title>
	  <body>
		<p>You shall always initialize variables. Always. Every time.</p>
		<p><e>Justification</e></p>
		<ul>
		  <li>More problems than you can imagine are eventually traced back to a pointer or variable that was left uninitialized. C++ tends to encourage this behaviour by propagating the initialization to the constructors of the parent classes.</li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Accessor Styles</title>
	  <body>
		<p>Accessor methods provide access to the attibutes of an object. Accessing an object's attributes directly, as is commonly done in C structures, is greatly discouraged in C++. It exposes implementation details of the object and degrades encapsulation.</p>
		<p>There are two accepted ways to implement accessors, the preferable way is the following :</p>
		<ul>
		  <li>
			<p><e>Attributes as objects</e></p>
			<pre caption="Attributes as object accessor style">class X
{
public:
    int             age() const     { return mAge; }
    int&amp;            rAge()          { return mAge; } 
    
    const String&amp;   name() const    { return mName; }
    String&amp;         rName()         { return mName; }
private:
    int              mAge;
    String           mName;
}</pre>
			<p>The main weakness of this approach is that when returning a reference to basic types (as in the rAge() method), it's impossible to perform checks on the provided value. To solve this, you can either create a wrapper class or resort to the second accessor implementation style. The preferred method is of course, in this example, to create an Age class which contains all consistancy checks as class methods or statements in its constructor.</p>
			<p>The advantage of this approach is that it's more consistent with OOP : the object should do it. An object's assignment (=) operator can do all the checks for assignments. This centralizes the consistancy checks in one place, in the object, where it belongs.</p>
			<p>When possible, use this approach instead of the One method name accessor style.</p>
		  </li>
		  <li>
			<p><e>One method name</e></p>
			<pre caption="One method name accessor style">class X
{
public:
    int    age() const     { return mAge; }
    void   age(int age)    { mAge = age; }
private:
    int mAge;
}</pre>
			<p>Using this approach, it's possible to include some checks about the value provided to the age() method. However these checks make only sense when handling basic types since objects should perform their checks internally. Failing to do so would mean that every accessor has to reimplement these consistancy rules over and over again</p>
			<p>The hude drawback here is that objects aren't treated in their own right and that encapsulation somewhat fails. It is better to rely on the object's assignment operator.</p>
		  </li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Class Documentation</title>
	  <body>
		<p>For the creation of the developer API documentation we're using kdoc. Since we've selected a stripped down version of Qt as our class library it's a great asset that a documentation tool understands the concept of Qt's meta object system, slots and signals. Although this is only available in a more feature-packaged distribution of Qt, it's very probable that in the future, parts of portage will require these additional features and having support for them in the documentation tool is thus a great asset.</p>
		<p>Kdoc is very much likely to javadoc, but then for c++.</p>
		<p>A documentation comment is a C comment that immediately precedes a class, method, constant or property declaration. It takes the following form:</p>
		<pre caption="Documentation Comment Example">/**
* Documentation goes here
*/
class MyClass
{
    ...</pre>
		<p>The double asterisk at the start of the comment differentiates a documentation comment from a normal comment. To make the documentation comment blocks clearly stand out, each line can be preceded by asterisks which will be ignored when the output is generated.</p>
		<p>The documentation is a mixture of:</p>
		<ul>
		  <li>
			<p><e>Normal text</e></p>
			<p>Paragraphs must be separated by at least one blank line.</p>
		  </li>
		  <li>
			<p><e>Code fragments</e></p>
			<p>Inline code fragments have to take the following form :</p>
			<pre caption="Documentation inlined code fragment example">&lt;pre&gt;
.....code fragments....
&lt;/pre&gt;</pre>
		  </li>
		  <li>
			<p><e>Various kdoc tags</e></p>
			<p>The tags that kdoc understand are all in the following form and should be entered on one line (@ref is an exception):</p>
			<pre caption="The form of kdoc tags">@tagname [tag parameters]</pre>
		  </li>
		</ul>
		<p>The valid KDoc tags for each type of source code entity are:</p>
		<table>
		  <tr>
			<th>Classes</th>
		  </tr>
		  <tr>
			<ti>@short [one_sentence]</ti>
			<ti>A short description of the class.</ti>
		  </tr>
		  <tr>
			<ti>@author [one_sentence]</ti>
			<ti>The class's author.</ti>
		  </tr>
		  <tr>
			<ti>@version [once_sentence]</ti>
			<ti>The class's version. This can for example be set to the RCS/CVS tag $Id.</ti>
		  </tr>
		  <tr>
			<ti>@see [references_to_classes_or_methods]</ti>
			<ti>References to other related documentation.</ti>
		  </tr>
		  <tr>
			<th>Methods</th>
		  </tr>
		  <tr>
			<ti>@see</ti>
			<ti>as above</ti>
		  </tr>
		  <tr>
			<ti>@return [one_sentence]</ti>
			<ti>A sentence describing the return value.</ti>
		  </tr>
		  <tr>
			<ti>@exception [exceptions]</ti>
			<ti>List the exceptions that could be thrown by this method.</ti>
		  </tr>
		  <tr>
			<ti>@param [param_name] [param_description]</ti>
			<ti>Describe a parameter. The param description can span multiple lines and will be terminated by a blank line, the end of the comment, or another param entry. For this reason, param entries should normally be the last part of the doc comment.</ti>
		  </tr>
		  <tr>
			<th>Constants, Enums, Properties</th>
		  </tr>
		  <tr>
			<ti>@see</ti>
			<ti>as above</ti>
		  </tr>
		  <tr>
			<th>ANYWHERE</th>
		  </tr>
		  <tr>
			<ti>@ref</ti>
			<ti>As a departure from the javadoc format, the metatag @ref has the same format as @see, but can appear anywhere in the documentation (all other tags must appear on a line by themselves).</ti>
		  </tr>
		</table>
	  </body>
	</section>
  </chapter>

  <chapter>
	<title>Language Directives and Best Practices</title>
	<section>
	  <title>Be Const Correct</title>
	  <body>
		<p>C++ provides the const keyword. This makes it possible to indicate that a method doesn't modify the objects that it receives as parameters. Using const in all the right places is called "const correctness." It's hard at first, but using const really tightens up your coding style. Const correctness grows on you.</p>
		<p>If you're in the darkness about what Const Correctness exactly is, read the relevant section in the C++ FAQ</p>
	  </body>
	</section>
	<section>
	  <title>Use Streams</title>
	  <body>
		<p>Programmers that move from C to C++ find stream IO strange and prefer the familiarity of good old stdio. Printf and its derivates seem to be more convenient since they are well understood. However when you use these old idioms, you throw away one of the most powerful features of C++.</p>
		<p><e>Justification</e></p>
		<ul>
		  <li>
			<p>Type Safety</p>
			<p>Stdio is not type safe, which is one of the reasons you are using C++, right? Stream IO is type safe.</p>
		  </li>
		  <li>
			<p>Standard Interface</p>
			<p>When you want to dump an object to a stream there is a standard way of doing it: the &lt;&lt; operator. This is not true of objects and stdio.</p>
		  </li>
		  <li>
			<p>Interchangeablity of Streams</p>
			<p>One of the more advanced reasons for using streams is that once an object can dump itself to a stream it can dump itself to any stream. One stream may go to the screen, but another stream may be a serial port or network connection. Good stuff.</p>
		  </li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Commenting Out Large Code Blocks</title>
	  <body>
		<p>Sometimes large blocks of code need to be commented out for testing. You can't use /**/ style comments because these can't be nested. Surely a large block of your code will contain at least one comment, won't it?</p>
		<ul>
		  <li>
			<p><e>Use #if 0</e></p>
			<p>The easiest way to do this is with an #if 0 block. Don't use #ifdef as someone can unknowingly trigger ifdefs from the compiler command line.</p>
			<pre caption="Commenting Out Large Code Blocks Example">void example()
{
    great looking code
        
    #if 0
    lots of code
    /* a comment */
    some more code
    #endif
        
    more code
}</pre>
		  </li>
		  <li>
			<p><e>Use Descriptive Macro Names Instead of 0</e></p>
			<p>The problem with #if 0 is that a while later neither you nor someone else has any idea why this code has been commented out. Is it because a feature has been dropped? Is it because it was buggy? Didn't it compile? Can it be reinstated? It's a mystery.</p>
			<p>Therefor you can also chose to use descriptive macro names instead of #if 0.</p>
			<pre caption="Commenting With Descriptive Macro Names">void example()
{
    great looking code
        
    #if NOT_YET_IMPLEMENTED
    travel_through_air();
    #endif
    
    a bit of code

    #if OBSOLETE
    /* a comment */
    travel_by_foot();
    #endif
    
    #if TEMP_DISABLED_OUT_OF_GAS
    travel_by_car();
    #endif
}</pre>
		  </li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Uses Of The Constructor</title>
	  <body>
		<ul>
		  <li>
			<p><e>Only initialize member variables</e></p>
			<p>The constructor should only initialize the member variables and preferably not through assignment. Also, explicitely initialize all member variables even if you're just calling their default constructor. It's better to be clear from the beginning than in doubt later.</p>
		  </li>
		  <li>
			<p><e>Delegate all logic</e></p>
			<p>No real action should be done in the constructor, delegate everything to a seperate initialize() method. This will allow multiple constructors to use the shared code logic in the initialize method by passing the appropriate arguments.</p>
		  </li>
		  <li>
			<p><e>Call the parent's constructor explicitely</e></p>
			<p>If the class has been derived from another class, the constructor has to call the appropriate parent's constructor explicitely. Don't rely on the implicite calling of the default constructor since it makes code unclear. It's much better to clearly state that the use of the parent's default constructor has been examined by you and that you think it's the best course of action.</p>
		  </li>
		</ul>
		<pre caption="Uses Of The Constructor Example">class Child : public Parent
{
public:
    Child() :
        Parent(),
        mAge(),
        mName("unknown")
    {
        initialize();
    }
          
    void initialize()
    {
        /* do the real work */
    }
          
private:
    int       mAge;
    QString   mName;
}</pre>
	  </body>
	</section>
	<section>
	  <title>Prefer C++ Casts</title>
	  <body>
		<p>The traditional way of casting in C is still possible in C++, but alternative options are available which provide much better diagnoses of usage errors and are much easier to indentify and maintain.</p>
		<p>These new casts are :</p>
		<ul>
		  <li>
			<p><e>const_cast&lt;T&gt;(e)</e></p>
			<p>Casts away the const-ness of objects, variables or pointers. It gives an error when the types differ more than in const and volatile modifiers.</p>
			<p>Don't use this to cast away const-ness of objects that were originally defined as being const and on which non-const operations are being executed. Doing this, results in undefined behaviour.</p>
			<p>You typically use this when you need to access an api that incorrectly defines a function signature. When you are 100% sure that the function you want to call doesn't perform non-const operations on the argument, you can safely cast away the const-ness of the argument that was initially defined as being const.</p>
			<pre caption="const_cast Example">int countChars(char *pString, char character);
  
const char *p_somestring = "Let's make things better";
int result = countChars(const_cast&lt;char*&gt;(p_somestring), 'e');</pre>
		  </li>
		  <li>
			<p><e>dynamic_cast&lt;T&gt;(e)</e></p>
			<p>Makes it possible to safely downcast pointers and references to base classes. It thus returns the appropriate sub-object in the hierarchy chain. It returns 0 if this cast wasn't possible on pointers and throws the bad_cast exception if the cast wasn't possible on references. This effectively says "convert this Object into a Penguin or give me 0 if its not an Penguin,". This provides dynamic typing, you don't know what will happen until run-time.</p>
			<pre caption="dynamic_cast Example">class B { /* at least one virtual function */ };
class D : public B { /* ... */ };
	
B* p_b1 = new B;
B* p_b2 = new D;
	
D* p_d1 = dynamic_cast&lt;D*&gt;(p_b1);	/* will be 0 */
D* p_d2 = dynamic_cast&lt;D*&gt;(p_b2);	/* will be an object of type D* */</pre>
		  </li>
		  <li>
			<p><e>reinterprete_cast&lt;T&gt;(e)</e></p>
			<p>This type of casts treats pointers and references as incomplete types. Using the reinterprete_cast yields values that are typically not guaranteed to be usable without casting back to their orginal types. It's difficult to say more about this kind of casts since their applicability is very implementation dependent.</p>
			<pre caption="reinterprete_cast Example">void someFunction(char *p_string) { *p_string = 'x'; }
typedef void (*FPType)(const char*);
FPType p_functionpointer = static_cast&lt;FPType&gt;(&amp;someFunction);
/* calling someFunction through p_functionpointer is not guaranteed to work */</pre>
		  </li>
		  <li>
			<p><e>static_cast&lt;T&gt;(e)</e></p>
			<p>This is very similar to the old C-style casts. Only use it when none of the above seem to fit the bill. It will only succeed if there's an implicit conversion possible either from T to the type of e, or from the type of e to T.</p>
			<pre caption="static_cast Example">Fraction fraction(1,2);
double d = static_cast&lt;double&gt;(fraction);</pre>
		  </li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Prefer positive boolean comparisons</title>
	  <body>
		<p>It's much easier to think in a positive way about a situation than to be presented with the negative alternative and having to transform it in your mind by yourself to positive. People tend to have a 'logical' or 'the default behaviour' feeling about <c>true</c>, which makes it easy to think about. On the contrary, <c>false</c> is mostly regarded is the 'exception', 'the error situation' or the 'alternative way out'. Therefor we prefer constructs like this:</p>
		<pre caption="Positive boolean comparison, the right way">setup();
if (true == something)
{
    dowork();
}
cleanup();
return;</pre>
		<p>above the following negative counterpart:</p>
		<pre caption="Positive boolean comparison, the wrong way">setup();
if (false == something)
{
    cleanup();
    return;
}
dowork();
cleanup();
return;</pre>
  	  </body>
	</section>
	<section>
	  <title>Handle cleanup situations with boolean indicators</title>
	  <body>
		<p>Often you're presented with the problem that your code logic contains a series of initializations that can all potentially fail. Typically you want to interrupt any further execution, cleanup and return an error message. Such situations have been known to be resolved through the use of exceptions, gotos, large if-then-else constructs and boolean indicators. From these options, it's the last one we prefer.</p>
		<p>Below is an example of such a typical code cleanup situation:</p>
		<pre caption="Cleanup with boolean indicators">void some_function()
{
    bool file_setup = false;
    bool dir_setup = false;
  
    <comment>/* try to create a new file object and open it for reading */</comment>
    QFile *p_file = new QFile("/path/to/file");
    if (0 != p_file &amp;&amp;
        true == p_file->open(IO_ReadOnly))
    {
        file_setup = true;
    }
    
    QString dir_path("/path/to/default/dir");
    if (true == file_setup)
    {
        <comment>/* if the file was setup, read its contents and use it for */
        /* further processing */</comment>
        QTextStream textstream(p_file);
        QString dir_path = textstream.readLine();
        dir_path = textstream.readLine();
    }
    
    <comment>/* try to create a new dir object and open it for reading */</comment>
    QDir *p_dir = new QDir(dir_path);
    <comment>/* some vars that are needed by the dir logic */</comment>
    if (0 != p_dir &amp;&amp;
        true == p_dir->exists())
    {
        <comment>/* do stuff with the dir */</comment>
        dir_setup = true;
    }
    else
    {
        cout &lt;&lt; dir_path.ascii() &lt;&lt;
            " couldn't be processed" &lt;&lt; endl;
    }
    
    <comment>/* cleanup the dir setup if needed*/</comment>
    if (true == dir_setup)
    {
        <comment>/* cleanup what was done in the dir logic part */</comment>
    }
    <comment>/* cleanup the file setup if needed*/</comment>
    if (true == file_setup)
    {
        p_file->close();
    }
    
    delete p_dir;
    delete p_file;
}</pre>
		<p><e>Justification</e></p>
		<ul>
		  <li>You prevent unnecessary consecutive indentations as is the case with large if-then-else constructs.</li>
		  <li>You don't have the maintaince hassle of local gotos which could point anywhere and present a number of difficult to solve C++ issues such as accessing object whose initializations has been jumped over.</li>
		  <li>It's very easy and clear to follow the logical flow, no jumps are executed as with gotos and exceptions.</li>
		  <li>You can perform context-sensitive cleanups that combine the states of several boolean indicators.</li>
		</ul>
	  </body>
	</section>
	<section>
	  <title>Learn about enum classes</title>
	  <body>
		<p>In a lot of cases regular enumerations suffice to define a group of valid integer constants as a distinct type. A typical example follows:</p>
		<pre caption="Classic enumeration example">typedef enum
{
    ALPHA   = -4, <comment>/* this maps to the "alpha" string in the code */</comment>
    BETA    = -3, <comment>/* this maps to the "beta" string in the code */</comment>
    PRE     = -2, <comment>/* this maps to the "pre" string in the code */</comment>
    RC      = -1, <comment>/* this maps to the "rc" string in the code */</comment>
    NONE    = 0,  <comment>/* this maps to no string (or all the invalid strings) */</comment>
    P       = 1   <comment>/* this maps to the "p" string in the code */</comment>
} SuffixType;</pre>
		<p>This approach however presents a number of drawbacks:</p>
		<ul>
		  <li>The values are limited to integers.</li>
		  <li>It not possible to evolve the constants in time to provide for example custom output methods, alternative synonimous values (strings for example), conversion from and to other types, and so on...</li>
		  <li>Casting between integers and enums is very error prone, you could cast a value that's not available in the enum.</li>
		</ul>
		<p>Therefor it's often justified to write enum classes. These classes contain private constructors and initialize constant instances of themselves as static class variables.</p>
		<p>An advanced implementation example follows:</p>
		<pre caption="Enumeration Classes Example"><comment>/*
* This creates a collection of the possible suffix type instances and
* neatly maintains the textual and numerical representation together.
* No additional instance can be created through the public interface.
* The instances are registered in an internal dictionary which makes it
* very easy to retrieve the exact object that corresponds to a textual
* representation.
* The type of the enum values is a pair, composed out of a string and a
* matching integer.
*/</comment>
class SuffixType : public QPair&lt;QString, int&gt;
{
public:
    <comment>/**
    * The enumeration's values
    */</comment>
    static const SuffixType ALPHA;
    static const SuffixType BETA;
    static const SuffixType PRE;
    static const SuffixType RC;
    static const SuffixType NONE;
    static const SuffixType P;

    <comment>/**
     * Retrieve a SuffixType object instance according to its textual
     * representation.
     * 
     * @param string The string to look up.
     * @return A SuffixType that correponds to the provided string, or
     *         SuffixType::NONE if no match was found.
     */</comment>
    static const SuffixType&amp; get(QString string);

    <comment>/**
     * Outputs the textual representation to an output stream.
     */</comment>
    friend std::ostream&amp; ::operator&lt;&lt;(std::ostream &amp;rStream, const SuffixType &amp;rSuffixType);

private:
    <comment>/**
    * Private constructor that will only be called during the initialization
    * of the static class variables.
    */</comment>
    SuffixType(QString string, int value);

    <comment>/**
    * Class wide collection that maps string representations of class
    * instances to the instances themselves.
    */</comment>
    static QDict&lt;SuffixType&gt; *mpMap;
};

<comment>/* Define and initialize the enumeration values. */</comment>
const SuffixType SuffixType::ALPHA("alpha", -4);
const SuffixType SuffixType::BETA("beta", -3);
const SuffixType SuffixType::PRE("pre", -2);
const SuffixType SuffixType::RC("rc", -1);
const SuffixType SuffixType::NONE("none", 0);
const SuffixType SuffixType::P("p", 1);

<comment>/* Define the static class-wide dictionary */</comment>
QDict&lt;SuffixType&gt; *SuffixType::mpMap(0);

SuffixType::SuffixType(QString string, int value) :
    QPair&lt;QString, int&gt;(string, value)
{
    <comment>/* Initialize the class-wide dictionary if this hasn't been done yet. */</comment>
    if (0 == mpMap)
    {
        mpMap = new QDict&lt;SuffixType&gt;(7);
    }

    <comment>/* Register this class instance in the class-wide dictionary. */</comment>
    SuffixType::mpMap-&gt;insert(string, this);
}

const SuffixType&amp; SuffixType::get(QString string)
{
    const SuffixType *p_matchingsuffix = 0;

    p_matchingsuffix = SuffixType::mpMap-&gt;find(string);

    <comment>/* If no match was found, return the null suffix. */</comment>
    if (0 == p_matchingsuffix)
    {
        p_matchingsuffix = &amp;SuffixType::NONE;
    }
    return *p_matchingsuffix;
}

ostream&amp; operator&lt;&lt;(ostream &amp;rStream, const SuffixType &amp;rSuffixType)
{
    rStream &lt;&lt; rSuffixType.first.ascii();
    return rStream;
}</pre>
		<p>Although this presents quite some more code initially, it pays of immensely afterwards since you can easily access both the integer as the string value of an enumeration instance by using for example : <c>SuffixType::ALPHA.first</c> and <c>SuffixType::ALPHA.second</c>. This will provide you with <c>alpha</c> and <c>-4</c>. Also, to retrieve which enumeration instance corresponds to a given text you can simply use : <c>SuffixType::get("alpha")</c> and get a reference to the <c>SuffixType::ALPHA</c> instance in return.</p>
		<p>This approach thus neatly centralizes all enumeration logic instead of scattering it all over the code with a large number of unintuitive conditional statement blocks.</p>
	  </body>
	</section>
  </chapter>

  <chapter>
	<title>Bibliographic References</title>
	<section>
	  <body>
		<ul>
		  <li>
			<p><e>Effective C++, Scott Meyers</e></p>
			<p>Addison-Wesley ISBN 0-201-92488-9</p>
		  </li>
		  <li>
			<p><e>The Annoted C++ Reference Manual, Margaret A. Ellis &amp; Bjarne Stroustrup</e></p>
			<p>Addison-Wesley ISBN 0-201-51459-1</p>
		  </li>
		  <li>
			<p><e>Todd's C++ Coding Standard</e></p>
			<p><uri>http://www.possibility.com/Cpp/CppCodingStandard.html</uri></p>
		  </li>
		  <li>
			<p><e>Kdoc homepage</e></p>
			<p><uri>http://www.ph.unimelb.edu.au/~ssk/kde/kdoc/</uri></p>
		  </li>
		  <li>
			<p><e>How to Write Doc Comments for the Javadoc Tool</e></p>
			<p><uri>http://java.sun.com/j2se/javadoc/writingdoccomments/index.html</uri></p>
		  </li>
		  <li>
			<p><e>C++ Faq Lite</e></p>
			<p><uri>http://www.parashift.com/c++-faq-lite</uri></p>
		  </li>
		</ul>
	  </body>
	</section>
  </chapter>

  <chapter>
	<title>Todo</title>
	<section>
	  <body>
		<ul>
		  <li>exceptions &lt;&gt; return values</li>
		  <li>when to return a pointer, a value or a reference from a method</li>
		  <li>indenting of variable declarations</li>
		  <li>unit testing</li>
		  <li>no magic numbers</li>
		  <li>tabs/spaces policy</li>
		  <li>how to break lines</li>
		  <li>don't mix pointers and non-pointers on a single declaration line</li>
		  <li>use 0 instead of NULL</li>
		</ul>
	  </body>
	</section>
  </chapter>

<!-- REQUESTS FOR COMMENTS
* ??? RFC ??? (03 Mar 2002, vitaly)
  Error handling.

  We have to decide on the error handling scheme.
  The two obvious choises are Exceptions and Error codes.
  Exceptions might create us problems when wrapping the API for
  use in languages with no exception support, or when using some library
  that uses exceptions
  I propose to typedef enum for errorcodes inside the class like the above 
  enum example with success value being 0, so that error check can be 
  performed in a form 

    if (res = foo())
      return res;

  !!! COMMENT !!! (04 Mar 2002, karltk)
  As we're not going to multithread Portage 2, having a per-class errno 
  variable as is suggested here is acceptable.

  Also, exceptions in C++ are a great source for memory leaks :)

  Whatever constitues an error signal from a function would vary between
  functions, of course:

    int res = foo->getPackageCnt(); 
    if (res == -1) { cout << foo->getLastError() << endl; }

  vs

    QString *res = foo->getPackageName();
    if (res == NULL) { ... } 

-->

</guide>
