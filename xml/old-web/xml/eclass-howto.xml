<?xml version="1.0"?>
<guide><version/><title>   Gentoo Documentation - eclass HOWTO
  </title><author>Dan Armak
  </author><date>   20020330
  </date><abstract>   The eclass howto explains the idea behind eclasses, the current eclasses and their inner workings, and the proper way to write an inheriting KDE ebuild.
  </abstract><chapter><title>   Introduction to eclasses
  </title><body><p>   eclasses are parts of ebuilds. They are sourced (&quot;inherited&quot;) by ebuilds and other eclasses, to provide default settings and functions across many similar ebuilds. As in OOP, this is used to ensure maximum code reuse among similar ebuilds.
  </p><p>   This first section shows briefly how to write an eclass. The second is a detailed overview of all the existing eclasses. The third explains how to write a KDE ebuild using the kde group of eclasses.
  </p></body><section><title>    Example
   </title><body><p>    Here is a fictive sourceforge.eclass, designed to provide homepage and download locations to sourceforge.net-hosted projects:
   </p><pre># Copyright 2001-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License, v2 or later
# Author Dan Armak &lt;danarmak@gentoo.org&gt;
# $Header: /var/cvsroot/gentoo/xml/old-web/xml/Attic/eclass-howto.xml,v 1.4 2002/04/23 20:05:50 danarmak Exp $
# This eclass sets $HOMEPAGE and $SRC_URI to the standard vaules for
# sourceforge.net - hosted projects.
ECLASS=base
HOMEPAGE=&quot;http://${PN}.sourceforge.net/&quot;
SRC_URI=&quot;http://download.sourceforge.net/${PN}/${P}.tar.gz&quot;
</pre><p>    The first four lines are headers, just like those in any ebuild. The next two lines are a short description of the eclass. Line 7 sets $ECLASS to the eclass's name, which is useful for some applications not seen in this example. These are conventions you should follow.
   </p><p>    The rest of the code does the actual work - setting $SRC_URI and $HOMEPAGE.
   </p></body></section><section><title>    There you go
   </title><body><p>    This is all you need to know to actually write eclasses. Put your new eclass in /usr/portage/eclass/, and put these two lines at the beginning of your ebuild:
   </p><pre>. /usr/portage/eclass/inherit.eclass || die
inherit sourceforge
</pre><p>    The first line is only needed for backward compatibility with &lt;=portage-1.8.8, i.e. the rc6 profile. The new 1.8.9 portage tree contains an inherit() function, but the old one doesn't and so we have to manually source inherit.eclass which provides it. This backward support will be discontinued on April the 25th, one month after the release of portage-1.8.9_pre32 for the 1.0 profile (the first portage to include inherit() and some other eclass-supporting elements).
   </p><p>    Oh, and you can inherit several eclasses at the same time by saying:
   </p><pre>inherit eclass1 eclass2 ...
</pre><p>    ...but watch their order!
   </p></body></section></chapter><chapter><title>   ebuild.sh and the general framework
  </title><body/><section><title>    Note on backward compatibility
   </title><body><p>    This section details the functions provided by ebuild.sh especially for eclasses. Prior to portage-1.8.9_pre32, these functions lived in eclasses of their own. These eclasses still exist for backward compatibility with portage 1.8.8 and earlier (1.0_rc6 profile); support will be dropped a month after the 1.0 release, i.e. on April 31st.
   </p><p>    The eclasses that exist for backward compatibility only are inherit.eclass, functions.eclass and debug.eclass. inherit.eclass has a kind of #ifndef/#define command: it exports $COMPAT when compatibility mode is on. If it does not do so, the code in the old eclasses is never executed; the code in ebuild.sh is used instead.
   </p></body></section><section><title>    inherit()
   </title><body><p>    This function handles inheriting (sourcing) of eclasses. It is called like this: inherit .
   </p><p>    Right now, inherit() simply sources files from a hard-coded location. If, in the future, we will decide to move eclasses to a different location, any name-to-file resolution code will go in here.
   </p><p>    Before portage-1.8.9_pre32, inherit() lived in inherit.eclass. For backward compatibility with that, every inheriting ebuild must for now have this line before any inherit commands:
   </p><pre>. /usr/portage/eclass/inherit.eclass || die
</pre><p>    If compatibility mode is turned off, no code from inherit.eclass or the other deprecated eclasses will actually be executed.
   </p></body></section><section><title>    EXPORT_FUNCTIONS()
   </title><body><p>    Suppose that foo.eclass and bar.eclass both define src_compile. If you inherit both foo and bar you'll get a different src_compile depending on the order in which you inherit them. That's ok; you're supposed to keep track of your inheritance order. But you may want to call either of the two src_compile's explicitly.
   </p><p>    So, every eclass adds to the functions that it defines a prefix. For example, A.eclass will define A_src_compile(), and B.eclass will define a B_src_compile(). That way, the ebuild can call either function and know what it'll get.
   </p><p>    This raises a new problem: we need a function called src_compile so that the ebuild doesn't need to explicitly call something_src_compile. This is where EXPORT_FUNCTIONS() comes into play:
   </p><pre>EXPORT_FUNCTIONS() {
 
        while [ &quot;$1&quot; ]; do
            eval &quot;$1() { ${ECLASS}_$1 ; }&quot; &gt; /dev/null
        shift
        done
 
}
</pre><p>    Every eclass at its beginning sets $ECLASS to its name (e.g. &quot;A&quot; or &quot;B&quot;). Then it calls EXPORT_FUNCTIONS with the list of functions it provides. For example, if you call
   </p><pre>ECLASS=foo
EXPORT_FUNCTIONS src_unpack
</pre><p>    then EXPORT_FUNCTIONS will call eval on the following string:
   </p><pre>src_unpack() { foo_src_unpack() ; }
</pre><p>    Now, whichever eclass is inherited last defines the default src_compile() function, but both functions can be directly called by the ebuild if needed. An eclass could also define a non-default src_compile() function, but none needed to do so thus far.
   </p></body></section><section><title>    Function sections
   </title><body><p>    A good eclass's predefined functions can often be used as-is; sometimes, though, you may want to modify (&quot;extend&quot;) them.
   </p><p>    Once they have unique names (foo_src_unpack) it's easy to add code that executes before or after them. You can simply do:
   </p><pre>src_compile() {
    run_my_code
    base_src_compile
    run_my_other_code
}
</pre><p>    Function sections provide for greater flexibility. They break the functions down and allow code to execute between any two sections.
   </p><p>    The implementation is simple. Let's take as an example the src_compile() function from base.eclass. (Note: it no longer exists, but it's a good example.) It looks like this:
   </p><pre>base_src_compile() {
    ./configure || die
    emake || die
}
</pre><p>    Here is the same function, divided into sections:
   </p><pre>base_src_compile() {
 
    [ -z &quot;$1&quot; ] &amp;&amp; base_src_compile all
 
    while [ &quot;$1&quot; ]; do
        case $1 in
            configure)
                ./configure || die;;
            make)
                emake || die;;
            all)
                base_src_compile configure make;;
        esac
    shift
    done
 
}
</pre><p>    The code has been divided into two sections: <i>configure</i> and <i>make</i>. In our simple example, they correspond to the two commands in the original function.
   </p><p>    In the center of the new function is a while;case...esac;shift;done block. This block matches the parameters to the functions with the defined section names and executes the corresponding lines of code.
   </p><p>    The special case <i>all</i> calls the same function recursively with a list of sections in order. It's up to the eclass's author to maintain this list.
   </p><p>    The line before the block says that a call without parameters should be treated the same as a call with the single parameter <i>all. </i>As you see, this function recurses a lot. Note, however, that the call <i>base_src_compile configure all make </i>is also legal; it will execute <i>base_src_compile configure configure make make</i>.
   </p><p>    Now, in your ebuild (or eclass) that inherits from base.eclass, you get the stub function src_compile which calls base_src_compile without parameters. This makes base_src_compile execute <i>all</i>, that is, all its sections. You can leave it as-is. If you wish to extend it, you define a new src_compile and call base_src_compile a section at a time:
   </p><pre>src_compile() {
    run_my_code1
    base_src_compile configure
    run_my_code2
    base_src_compile make
    run_my_code3
}
</pre><p>    As you can see, the function sections add flexibility since you can now insert code between the two sections, as well as run them in a different order or run only some of the sections provided. This makes for greater code reuse overall.
   </p><p>    A final note: not all functions execute all their sections when called with <i>all</i> or without parameters. Some sections may be non-default and must be called explicitly. The only such section right now is <i>base_src_unpack patch</i>.
   </p></body></section><section><title>    The debug-print-* functions
   </title><body><p>    These functions add verbose &quot;debug&quot; output facilities. All eclasses call these functions a lot, which makes them look ugly but helps a great deal in tracing stuff, since there is no bash script debugger/ide/step-by-step interpreter AFAIK (except for bash -x).
   </p><p>    debug-print() prints its parameters with the &quot;debug: &quot; prefix. debug-print-function() prints &quot;debug: entering function $1, parameters: $2 $3 ...&quot;. debug-print-section() prints &quot;debug: now in section $1&quot;.
   </p><p>    The debug output normally goes into ${T}/eclass-debug.log. You can set the ECLASS_DEBUG_OUTPUT variable (in make.globals/conf, and ebuild/eclass, or the environment) and output will be sent there as well. You can also set it to the special value &quot;on&quot;, which echoes output to stdout together with the other emerge messages.
   </p><p>    Let's add typical debug output statements to our sample function:
   </p><pre>base_src_compile() {
 
    debug-print function $FUNCNAME $*
    [ -z &quot;$1&quot; ] &amp;&amp; base_src_compile all
 
    while [ &quot;$1&quot; ]; do
        case $1 in
            configure)
                debug-print-section configure
                ./configure || die;;
            make)
                debug-print-section make
                make || die;;
            all)
                debug-print-section all
                base_src_compile configure make;;
        esac
    shift
    done
 
    debug-print &quot;$FUNCNAME: result is $RESULT&quot;
}
</pre><p>    FYI, $FUNCNAME is a bash builtin that holds the current function's name.
   </p></body></section><section><title>    newdepend()
   </title><body><p>    This function simply adds all parameters to both DEPEND and RDEPEND, saving you the trouble of writing and maintaining two lists of dependencies.
   </p><p>    If called with a special parameter, it adds predefined dependencies. These special parameters exist as of now:
   </p><p>    newdepend /autotools: add &quot;sys-devel/autoconf sys-devel/automake sys-devel/make&quot; to DEPEND (but not RDEPEND).
   </p><p>    newdepend /c: add &quot;virtual/glibc sys-devel/ld.so&quot; to both DEPEND and RDEPEND. Also, add &quot;sys-devel/gcc&quot; to DEPEND.
   </p><p>    This function encourages developers to maintain comprehensive DEPEND strings. Especially, many ebuilds have no RDEPEND strings, which will be a problem once we have unmerge functionality that knows about dependencies.
   </p></body></section></chapter><chapter><title>   Misc eclasses
  </title><body/><section><title>    base.eclass
   </title><body><p>    This eclass defines some default variables and functions, similar to those you'd get by default in a non-inheriting ebuild (starting with a recent portage), e.g. src_unpack() { unpack ${A}; }.
   </p><p>    Eventually, it may be removed and merged with the default functions in ebuild.sh.
   </p><p>    It is inherited by higher-level eclasses like the kde ones.
   </p><p>    Note that in base_src_unpack there is one non-default section (i.e. it doesn't execute for section <i>all</i>). It is called <i>patch</i> and it looks like this:
   </p><pre>cd ${S}
patch -p0 &lt; ${FILESDIR}/${P}-gentoo.diff
</pre></body></section><section><title>    kde.eclass
   </title><body><p>    Used by all kde apps, whether directly or indirectly. (Not by apps with optional kde functionality though.) This is a higher-level eclass, which is intended to provide not only sensible defaults but functions which can be used as-is more often then not. In fact, none of the high-level kde-* eclasses which inherit from here change the functions in any way, and the ebuilds rarely do so. This eclass contains the meat of the kde eclass system, while virtual and base can be said to provide the skeleton.
   </p><p>    It inherits autoconf, base and depend.
   </p><p>    Read it to find out what it defines. It is quite self-explanatory.
   </p><p>    Briefly, it handles all standard kde apps that use GNU standard configure/make/make install cycles. It handles all the std. configure options e.g. qtmt.
   </p><p>    Note: some kde apps, like widget styles and i18n packages, do not need to compile anything. Therefore kde.eclass does not inherit c. These packages can then inherit straight from here. All other packages, which need to compile c code, should inherit from kde-base.eclass.
   </p></body></section><section><title>    cvs.eclass
   </title><body><p>    This eclass enables ebuilds to fetch sources from cvs. Because cvs ebuilds aren't yet an official feature of portage, it can only be found in my kde3pre ebuild package.
   </p></body></section><section><title>    cvsup.eclass
   </title><body><p>    Ditto for cvsup.
   </p></body></section></chapter><chapter><title>   KDE-centric eclasses
  </title><body/><section><title>    kde.eclass
   </title><body><p>    This is the main, central KDE eclass. It contains most of the KDE-related code. All KDE ebuilds inherit from it one way or another.
   </p><p>    As with the other eclasses, read it to find out what it does. Here is a short summary, with improved readability and comments after every part:
   </p><pre>inherit base kde-functions
ECLASS=kde
newdepend /autotools
HOMEPAGE=&quot;http://www.kde.org/&quot;
</pre><p>    The above should be self-obvious by now.
   </p><p>    There is no kde_src_unpack() function. The base_src_unpack() function serves admirably. Let's move on to kde_src_compile():
   </p><pre>kde_src_compile() {
    section myconf:
        myconf=&quot;$myconf --host=${CHOST} --with-x --enable-mitshm --with-xinerama \                     --with-qt-dir=${QTDIR}&quot;
       case $KDEMAJORVER in
            2) myconf=&quot;$myconf --prefix=${KDE2DIR}&quot;;;
            3) myconf=&quot;$myconf --prefix=${KDE3DIR}&quot;;;
            *) echo an error and abort (unrecognized version);;
        esac
        use qtmt &amp;&amp; myconf=&quot;$myconf --enable-mt&quot;
        [ -n &quot;$DEBUG&quot; ] &amp;&amp; myconf=&quot;$myconf --enable-debug=full --with-debug&quot; \
                        || myconf=&quot;$myconf --disable-debug --without-debug&quot;
</pre><p>    The $myconf variable holds the parameters to be passed to configure. It is never set, but always added to, so you can add to it from your own ebuild as well. The myconf section sets the default parameters.
   </p><p>    The first part of the section sets the hardcoded parameters.
   </p><p>    The second sets the prefix, based on $KDEMAJORVER which is set in set-kdedir() (see the section about kde-functions.eclass).
   </p><p>    The third adds parameters based on USE flags (qtmt) and $DEBUG.
   </p><pre>    section configure:
        # This can happen with e.g. a cvs snapshot
        if [ ! -f &quot;./configure&quot; ]; then
            for x in Makefile.cvs admin/Makefile.common; do
                if [ -f &quot;$x&quot; ] &amp;&amp; [ -z &quot;$makefile&quot; ]; then makefile=&quot;$x&quot;; fi
            done
            emake -f $makefile
            [ -f &quot;./configure&quot; ] || die &quot;no configure script found, generation unsuccessful&quot;
        fi
        export PATH=&quot;${KDEDIR}/bin:${PATH}&quot;
        ./configure ${myconf} || die &quot;died running ./configure, $FUNCNAME:configure&quot;
</pre><p>    The configure section actually runs the configure script with the parameters in $myconf. The first part of the section also runs make -f Makefile.cvs or make -f admin/Makefile.common if needed to generate the configure script.
   </p><pre>    section make:
        export PATH=&quot;${KDEDIR}/bin:${PATH}&quot;
        emake || die &quot;died running emake, $FUNCNAME:make&quot;
</pre><p>    This simple section runs make.
   </p><p>    Next is kde_src_install(). It is not much different from base_src_install, except that it adds a <i>dodoc</i> section:
   </p><pre>kde_src_install() {
    section make:
        make install DESTDIR=${D} destdir=${D} || die 
    section dodoc:
        dodoc AUTHORS ChangeLog README* COPYING NEWS TODO
}
</pre></body></section><section><title>    kde-functions.eclass
   </title><body><p>    This eclass contains all KDE-related helper functions. Some of them you should never need to use directly in an ebuild; these are not mentioned here.
   </p><subsection><title>     The current multi-kdedir scheme
    </title><body><p>     A short explanation about the current multi-kdedir scheme:
    </p><p>     $KDE{2,3}DIR and $KDELIBS{2,3}DIR are set in make.globals (and can be overridden in make.conf). Their default values are /usr/kde/{2,3}, respectively.
    </p><p>     A package that identifies itself as a kde2 package (see below) will use the kdelibs installed in $KDELIBS2DIR and install itself into $KDE2DIR. Same goes for kde3. NOTE: separating kdelibs from kde apps and any other non-default KDEDIR stuff is untested and unsupported.
    </p><p>     As for qt, the latest 2.x and 3.x versions live in /usr/qt/{2,3} respectively.
    </p></body></subsection><subsection><title>     need-kde(), need-qt(), set-kdedir(), set-qtdir()
    </title><body><p>     This eclass provides two pairs of functions: need-kde(), need-qt() and set-kdedir(), set-qtdir(). These functions handle the details of the multi-qt and multi-kdelibs schemes.
    </p><p>     The need-* functions are called with a parameter which is the version number required. They add the proper dependencies and call the set-*dir functions. If no parameter is passed, a version number of 0 (zero) is used, meaning that any version will satisfy the dependency.
    </p><p>     The set-* dir functions set KDEDIR and QTDIR, as well as KDEMAJORVER (=2 or =3). That's all your ebuild should need.
    </p><p>     It is important to call these functions from the main part of the ebuild (i.e. not from a function), so that any changes to DEPEND and RDEPEND affect emerge.
    </p></body></subsection><subsection><title>     kde_sandbox_patch()
    </title><body><p>     Some KDE makefiles are incorrectly generated. They chmod or chown files in $PREFIX when installing, but do not respect $DESTDIR ($D). Our sandbox detects these errors. This function runs a generic sed on makefiles which fixes all known cases of the problem. It is called with the directories to be processed as parameters, and processes Makefile, Makefile.in and Makefile.am in those directories. For example:
    </p><pre>src_unpack() {
    base_src_unpack
    kde_sandbox_patch ${S}/dir1 ${S}/dir2/dir3
}
 </pre></body></subsection></body></section><section><title>    kde-base.eclass
   </title><body><p>    Meant for standard kde apps; nearly all ebuilds use it. It inherits kde, calls newdepend /c, and sets HOMEPAGE=apps.kde.com.
   </p></body></section><section><title>    kde-i18n.eclass
   </title><body><p>    Meant for the kde-i18n-* packages; niche use.
   </p><p>    In fact, all kde-i18n ebuilds are completely identical and so all they have to do is inherit from this eclass. Their ${P} does the rest.
   </p></body></section><section><title>    koffice-i18n.eclass
   </title><body><p>    Meant for the koffice-i18n-* packages. Very similar to kde-i18n.eclass.
   </p><p>    All kde-i18n ebuilds are completely identical and so all they have to do is inherit from this eclass.
   </p></body></section><section><title>    kde-dist.eclass
   </title><body><p>    Meant for the core kde distribution packages in kde-base/*. Inherits kde-base, kde.org. Adds the correct DESCRIPTION and HOMEPAGE, calls need-kde ${PV} and adds the --enable-final myconf parameter. The simpler, smaller kde-base/ packages (e.g. kdetoys) don't need to make any changes to it; most of those that do only add deps.
   </p></body></section><section><title>    kde.org.eclass
   </title><body><p>    Used by the kde-base/ core packages, and the other packages hosted on ftp.kde.org and its mirrors (kdevelop, koffice, kdoc). Sets SRC_URI and adds the major ftp.kde.org mirrors.
   </p></body></section><section><title>    kde-pre.eclass
   </title><body><p>    This is only included with the kde3pre ebuilds, and doesn't live in portage.
   </p><p>    It is used for pre-release ebuilds, which have underscores in their portage names (3.0_beta1) but not in their source archives' names (3.0beta1.tar.gz). Removes any underscores from $SRC_URI and $S.
   </p></body></section><section><title>    kde-i18n-pre.eclass
   </title><body><p>    As above, for kde-i18n prereleases.
   </p></body></section><section><title>    kde-source.eclass
   </title><body><p>    As above, only available in kde3pre.
   </p><p>    Used by kde-base/* core packages to get source via cvs or cvsup; uses cvs.eclass and cvsup.eclass. The three eclasses together are so powerful that an ebuild only needs to inherit kde-source for everything to work automatically, including such goodies as automatic switching between cvs servers, cvs checkout/update/offline mode, etc. etc. But, there are no cvs ebuilds in portage yet, so these stay outside.
   </p></body></section></chapter><chapter><title>   Writing KDE ebuilds
  </title><body/><section><title>    A typical KDE ebuild
   </title><body><p>    The code below should be obvious after reading this howto:
   </p><pre>&lt;header lines&gt;
. /usr/portage/eclass/inherit.eclass || die
inherit kde-base
</pre><p>    Some ebuilds end right here. Others need some customization.
   </p><p>    Add any extra deps. Remember: *always* extend variables, never override!
   </p><pre>DEPEND=&quot;$DEPEND foo/bar&quot;
RDEPEND=&quot;$RDEPEND bar/foo&quot;
</pre><p>    This will add a dep to both DEPEND and RDEPEND:
   </p><pre>newdepend &quot;foo? ( bar )&quot;
</pre><p>    This adds extra arguments to $myconf, which are passed to configure:
   </p><pre>myconf=&quot;$myconf --with-foobar&quot;
</pre><p>    An extend src_unpack:
   </p><pre>src_unpack() {
    base_src_unpack all patch   # Patch from ${FILESDIR}/${P}-gentoo.diff
    # some more changes
    dosed -e 's:1:2:' ${S}/foobar
}
</pre></body></section><section><title>    A typical ebuild with optional KDE functionality
   </title><body><p>    Basically, prefix each kde-specific line with &quot;use kde &amp;&amp;&quot;, or create whole &quot;if [ &quot;`use kde`&quot; ]; then; fi&quot; blocks.
   </p><p>    To the general section, add the following (if USE kde is set):
   </p><pre>if [ &quot;`use kde`&quot; ]; then
    . /usr/prtage/eclass/inherit.eclass
    inherit kde-functions
    need-kde $version # minimal version of kde your app needs
fi
</pre><p>    Add any further code you want, like this:
   </p><pre>use kde &amp;&amp; myconf=&quot;$myconf --with-my-parameter&quot;
</pre><p>    Tell your app to look for KDE in the $KDEDIR that is available after calling need-kde().
   </p></body></section></chapter></guide>
