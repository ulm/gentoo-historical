<?xml version='1.0'?>
<guide>
<title>Portage2 C++ Coding Standard</title>
<author title="Core Developer"><mail link="gbevin@gentoo.org">
Geert Bevin</mail>
</author>

<abstract>Explain the C++ coding style we've adopted and lists
a number of best practices that should be followed.</abstract>

<version>1.0</version>
<date>22 Mar 2002</date>

<chapter>
<title>Make Names Fit</title>
<body>
<p>Names are the heart of programming. In the past people believed knowing
someone's true name gave them magical power over that person. If you can think
up the true name for something, you give yourself and the people coming after
power over the code. Don't laugh!</p>
</body>
<section>
<title>Selecting names</title>
<body>

<p>A name is the result of a long deep thought process about the ecology it lives
in. Only a programmer who understands the system as a whole can create a name
that "fits" with the system. If the name is appropriate everything fits
together naturally, relationships are clear, meaning is derivable, and
reasoning from common human expectations works as expected.</p>

<p>If you find all your names could be <e>Thing</e> and <e>DoIt</e> then you should probably
revisit your design.</p>

<ul>
<li><p>Class Names</p></li>

    <ul>
	<li><p>Name the class after what it is. If you can't think of what it is that
      is a clue you have not thought through the design well enough.</p></li>
    <li><p>Compound names of over three words are a clue your design may be
      confusing various entities in your system. Revisit your design. Try a
      CRC card session to see if your objects have more responsibilities
      than they should.</p></li>
    <li><p>Avoid the temptation of bringing the name of the class a class derives
      from into the derived class's name. A class should stand on its own. It
      doesn't matter what it derives from.</p></li>
    <li><p>Suffixes are sometimes helpful. For example, if your system uses agents
      then naming something DownloadAgent conveys real information.</p></li>
	</ul>

<li><p>Method and Function Names</p></li>

    <ul>
	<li><p>Usually every method and function performs an action, so the name should
      make clear what it does: <e>CheckForErrors()</e> instead of <e>ErrorCheck()</e>,
      <e>DumpDataToFile()</e> instead of <e>DataFile()</e>. This will also make functions and
      data objects more distinguishable.</p>

      <p>Classes are often nouns. By making function names verbs and following
      other naming conventions programs can be read more naturally.</p></li>

    <li><p>Suffixes are sometimes useful:</p>
          <ul>
          <li><e>Max</e> - to mean the maximum value something can have.</li>
          <li><e>Cnt</e> - the current count of a running count variable.</li>
          <li><e>Key</e> - key value.</li>
		  </ul>

      <p>For example: <e>RetryMax</e> to mean the maximum number of retries, <e>RetryCnt</e> to
      mean the current retry count.</p></li>

    <li><p>Prefixes are sometimes useful:</p>
          <ul>
          <li><e>Is</e> - to ask a question about something. Whenever someone sees Is
            they will know it's a question.</li>
          <li><e>Get</e> - get a value.</li>
          <li><e>Set</e> - set a value.</li>
          </ul>

      <p>For example: <e>IsHitRetryLimit</e>.</p></li>
	</ul>

<li><p>Variable Names</p></li>

    <ul>
	<li><p>Make every variable name descriptive, limit the use of abbreviations or
      letter-words. It's worth writing words completely since it makes the code
      much more readable. Beware however that when trying to find a good name,
      you don't end up with with something like 'the_variable_for_the_loop',
      use a proper English word for it like 'counter' or 'iterator'. English is
      a rich language and trying to find a correctly fitting word is important
      for code brevety, cleanness and variation. Whenever in doubt, just use an
      thesaurus like Merriam-Webster (<uri>http://www.m-w.com</uri>) or a rhyming
      dictionary like Rhyme (<uri>http://rhyme.sourceforge.net/</uri>).</p></li>
  

	<p><e>Exceptions</e></p>
  
      <p>Some standard variables are used for often recurring tasks. Below is a
      list of those that are accepted :</p>
      
      <ul>
	  <li><e>i</e>           : integer counter</li>
      <li><e>it</e>          : STL-like iterator</li>
      <li><e>&lt;type&gt;_it</e>   : STL-like iterator of a certain type for differentiation
                      amongst types</li>
      <li><e>tmp_&lt;type&gt;</e>  : eg. tmp_qstring, tmp_int, tmp_float for variables that
                      are solely used for the storage of temporary intermediate
                      values</li>
	  </ul>
	</ul>

<li><p>No All Upper Case Abbreviations</p></li>

    <ul>
	<li><p>When confronted with a situation where you could use an all upper case
      abbreviation instead use an initial upper case letter followed by all
      lower case letters. No matter what.</p></li>

  <p><e>Justification</e></p>

    <p>People seem to have very different intuitions when making names
      containing abbreviations. It's best to settle on one strategy so the
      names are absolutely predictable.</p>

      <p>Take for example NetworkABCKey. Notice how the C from ABC and K from key
      are confused. Some people don't mind this and others just hate it so
      you'll find different policies in different code so you never know what
      to call something.</p>
	 </ul>

</ul>
</body>
</section>

<section>
<title>Naming scheme</title>
<body>
<p>A standard naming scheme is important to ensure that all code looks similar and
that every developer can understand new code immediately without have to grasp
a new naming scheme first.</p>
<p>One of the main aspects of this naming scheme is that all names should contain
key information about the type of language construct is refers to.
Additionally, certain prefixes will be used to prevent common error in the use
of basic c++ concepts such as pointers, references and scope. This however
doesn't involve into a full-blown and difficult to understand and maintain
Hongarian notation.</p>

<ul>
<li><p>Class Names</p></li>

    <ul>
	<li>Use upper case letters as word separators, lower case for the rest of a
      word</li>
    <li>First character in a name is upper case</li>
    <li>No underbars ('_')</li>
	</ul>

  <p><e>Justification</e></p>

    <ul>
    <li>Standard naming scheme in very clean OO languages such as Java and C#.</li>
    <li>Stands out the best amongst the other names formatting, since a class is
      the basic element in c++ this is a great benefit.</li>
	</ul>

    <pre caption="Class Names Example">class NameOneTwo
class Name</pre>

<li><p>Class Files</p></li>

    <ul>
    <li>Each class definition should be in its own file where each file is named
      directly after the class's name.</li>
    <li>Source files have the .cpp extension and header files have the .h
      extension.</li>
    <li>In general each class should be implemented in one source file. A common
      exception to this rule are inner classes that provide class specific
      functionality such as thread execution. Another common exception are very
      closely related classes such as a collection class and its iterator.</li>
    <li>If the source file gets too large or you want to avoid compiling
      templates all the time then add additional files, where the section is
      lower case and seperated of the classname through an underscore.</li>
	</ul>
  
  <p><e>Justification</e></p>
  
    <ul>
    <li>Using exactly the same name as the real class makes it easy to establish
      the relation.</li>
    <li>Not implementing several classes in one source file makes it very easy to
      find a class implementation when looking for it.</li>
	</ul>
    
  <pre caption="Class Files Example">ClassName.h
ClassName.cpp
ClassName_section1.cpp
ClassName_section2.cpp</pre>

<li><p>Method Names</p></li>

    <ul>
    <li>Use upper case letters as word separators, lower case for the rest of a
      word</li>
    <li>First character in a name is lower case</li>
    <li>No underbars ('_')</li>
	</ul>

  <p><e>Justification</e></p>

    <ul>
    <li>Differentiates the first word part, which is often a verb. This makes it
      very clear what a method does.</li>
    <li>Not exactly similar to class names and thus makes Class.doSomething()
      much more readable as Class.DoSomething(), cleanly indicating through
      case which is which.</li>
	</ul>

  <pre caption="Method Names Example">class NameOneTwo
{
public:
    int     doIt();
    void    handleError();
}</pre>

<li><p>Class Member Names</p></li>

    <ul>
    <li>Member names should be prepended with the character 'm'.</li>
    <li>Member the 'm' use the same rules as for class names.</li>
    <li>'m' always precedes other name modifiers like 'p' for pointer.</li>
	</ul>

  <p><e>Justification</e></p>

    <ul>
    <li>Prepending 'm' prevents any conflict with method names. Often your
      methods and attribute names will be similar, especially for accessors.</li>
	</ul>

  <pre caption="Class Member Names Example">class NameOneTwo
{
public:
    int     varAbc();
    int     errorNumber();
private:
    int     mVarAbc;
    int     mErrorNumber;
    String  *mpName;
}</pre>

</ul>

*** unfinished ***

</body>
</section>

</chapter>

</guide>
