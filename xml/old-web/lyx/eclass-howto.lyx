#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass docbook-chapter
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Gentoo Documentation - eclass HOWTO
\layout SGML

<AUTHOR><A HREF="mailto:danarmak@gentoo.org" >Dan Armak</A></AUTHOR>
\layout Date

20020330
\layout Abstract

The eclass howto explains the idea behind eclasses, the current eclasses
 and their inner workings, and the proper way to write an inheriting KDE
 ebuild.
\layout Section

Introduction to eclasses
\layout Standard

eclasses are parts of ebuilds.
 They are sourced (
\begin_inset Quotes eld
\end_inset 

inherited
\begin_inset Quotes erd
\end_inset 

) by ebuilds and other eclasses, to provide default settings and functions
 across many similar ebuilds.
 As in OOP, this is used to ensure maximum code reuse among similar ebuilds.
\layout Standard

This first section shows briefly how to write an eclass.
 The second is a detailed overview of all the existing eclasses.
 The third explains how to write a KDE ebuild using the kde group of eclasses.
\layout Subsection

Example
\layout Standard

Here is a fictive sourceforge.eclass, designed to provide homepage and download
 locations to sourceforge.net-hosted projects:
\layout Code

# Copyright 2001-2002 Gentoo Technologies, Inc.
\layout Code

# Distributed under the terms of the GNU General Public License, v2 or later
\layout Code

# Author Dan Armak <danarmak@gentoo.org>
\layout Code

# $Header: /home/cvsroot/gentoo-x86/eclass/sourceforge.eclass,v 1.12 2002/03/27
 22:33:53 danarmak Exp $
\layout Code

\layout Code

# This eclass sets $HOMEPAGE and $SRC_URI to the standard vaules for
\layout Code

# sourceforge.net - hosted projects.
\layout Code

\layout Code

ECLASS=base
\layout Code

\layout Code

HOMEPAGE="http://${PN}.sourceforge.net/"
\layout Code

SRC_URI="http://download.sourceforge.net/${PN}/${P}.tar.gz"
\layout Standard

The first four lines are headers, just like those in any ebuild.
 The next two lines are a short description of the eclass.
 Line 7 sets $ECLASS to the eclass's name, which is useful for some applications
 not seen in this example.
 These are conventions you should follow.
\layout Standard

The rest of the code does the actual work - setting $SRC_URI and $HOMEPAGE.
\layout Subsection

There you go
\layout Standard

This is all you need to know to actually write eclasses.
 Put your new eclass in /usr/portage/eclass/, and put this line at the beginning
 of your ebuild:
\layout Code

inherit sourceforge
\layout Standard

Oh, and you can inherit several eclasses at the same time by saying:
\layout Code

inherit eclass1 eclass2 ...
\layout Standard

...but watch their order!
\layout Section

ebuild.sh and the general framework
\layout Subsection

inherit()
\layout Standard

This function handles inheriting (sourcing) of eclasses.
 It is called like this: 
\latex latex 
inherit <list of eclasses>.
\layout Standard

Right now, inherit() simply sources files from a hard-coded location.
 If, in the future, we will decide to move eclasses to a different location,
 any name-to-file resolution code will go in here.
\layout Subsection

EXPORT_FUNCTIONS()
\layout Standard

Suppose that foo.eclass and bar.eclass both define src_compile.
 If you inherit both foo and bar you'll get a different src_compile depending
 on the order in which you inherit them.
 That's ok; you're supposed to keep track of your inheritance order.
 But you may want to call either of the two src_compile's explicitly.
\layout Standard

So, every eclass adds to the functions that it defines a prefix.
 For example, A.eclass will define A_src_compile(), and B.eclass will define
 a B_src_compile().
 That way, the ebuild can call either function and know what it'll get.
\layout Standard

This raises a new problem: we need a function called src_compile so that
 the ebuild doesn't need to explicitly call something_src_compile.
 This is where EXPORT_FUNCTIONS() comes into play:
\layout Code

EXPORT_FUNCTIONS() {
\layout Code

 
\layout Code

        while [ "$1" ]; do
\layout Code

            eval "$1() { ${ECLASS}_$1 ; }" > /dev/null
\layout Code

        shift
\layout Code

        done
\layout Code

 
\layout Code

}
\layout Standard

Every eclass at its beginning sets $ECLASS to its name (e.g.
 
\begin_inset Quotes eld
\end_inset 

A
\begin_inset Quotes erd
\end_inset 

 or 
\begin_inset Quotes eld
\end_inset 

B
\begin_inset Quotes erd
\end_inset 

).
 Then it calls EXPORT_FUNCTIONS with the list of functions it provides.
 For example, if you call
\layout Code

ECLASS=foo
\layout Code

EXPORT_FUNCTIONS src_unpack
\layout Standard

then EXPORT_FUNCTIONS will call eval on the following string:
\layout Code

src_unpack() { foo_src_unpack() ; }
\layout Standard

Now, whichever eclass is inherited last defines the default src_compile()
 function, but both functions can be directly called by the ebuild if needed.
 An eclass could also define a non-default src_compile() function, but none
 needed to do so thus far.
\layout Subsection

Function sections
\layout Standard

A good eclass's predefined functions can often be used as-is; sometimes,
 though, you may want to modify (
\begin_inset Quotes eld
\end_inset 

extend
\begin_inset Quotes erd
\end_inset 

) them.
\layout Standard

Once they have unique names (foo_src_unpack) it's easy to add code that
 executes before or after them.
 You can simply do:
\layout Code

src_compile() {
\layout Code

    run_my_code
\layout Code

    base_src_compile
\layout Code

    run_my_other_code
\layout Code

}
\layout Standard

Function sections provide for greater flexibility.
 They break the functions down and allow code to execute between any two
 sections.
\layout Standard

The implementation is simple.
 Let's take as an example the src_compile() function from base.eclass.
 (Note: it no longer exists, but it's a good example.) It looks like this:
\layout Code

base_src_compile() {
\layout Code

    ./configure || die
\layout Code

    emake || die
\layout Code

}
\layout Standard

Here is the same function, divided into sections:
\layout Code

base_src_compile() {
\layout Code

 
\layout Code

    [ -z "$1" ] && base_src_compile all
\layout Code

 
\layout Code

    while [ "$1" ]; do
\layout Code

\layout Code

        case $1 in
\layout Code

            configure)
\layout Code

                ./configure || die;;
\layout Code

            make)
\layout Code

                emake || die;;
\layout Code

            all)
\layout Code

                base_src_compile configure make;;
\layout Code

        esac
\layout Code

\layout Code

    shift
\layout Code

    done
\layout Code

 
\layout Code

}
\layout Standard

The code has been divided into two sections: 
\emph on 
configure
\emph default 
 and 
\emph on 
make
\emph default 
.
 In our simple example, they correspond to the two commands in the original
 function.
\layout Standard

In the center of the new function is a while;case...esac;shift;done block.
 This block matches the parameters to the functions with the defined section
 names and executes the corresponding lines of code.
\layout Standard

The special case 
\emph on 
all
\emph default 
 calls the same function recursively with a list of sections in order.
 It's up to the eclass's author to maintain this list.
\layout Standard

The line before the block says that a call without parameters should be
 treated the same as a call with the single parameter 
\emph on 
all.
 
\emph default 
As you see, this function recurses a lot.
 Note, however, that the call 
\emph on 
base_src_compile configure all make 
\emph default 
is also legal; it will execute 
\emph on 
base_src_compile configure configure make make
\emph default 
.
\layout Standard

Now, in your ebuild (or eclass) that inherits from base.eclass, you get the
 stub function src_compile which calls base_src_compile without parameters.
 This makes base_src_compile execute 
\emph on 
all
\emph default 
, that is, all its sections.
 You can leave it as-is.
 If you wish to extend it, you define a new src_compile and call base_src_compil
e a section at a time:
\layout Code

src_compile() {
\layout Code

    run_my_code1
\layout Code

    base_src_compile configure
\layout Code

    run_my_code2
\layout Code

    base_src_compile make
\layout Code

    run_my_code3
\layout Code

}
\layout Standard

As you can see, the function sections add flexibility since you can now
 insert code between the two sections, as well as run them in a different
 order or run only some of the sections provided.
 This makes for greater code reuse overall.
\layout Standard

A final note: not all functions execute all their sections when called with
 
\emph on 
all
\emph default 
 or without parameters.
 Some sections may be non-default and must be called explicitly.
 The only such section right now is 
\emph on 
base_src_unpack patch
\emph default 
.
\layout Subsection

The debug-print-* functions
\layout Standard

These functions add verbose 
\begin_inset Quotes eld
\end_inset 

debug
\begin_inset Quotes erd
\end_inset 

 output facilities.
 All eclasses call these functions a lot, which makes them look ugly but
 helps a great deal in tracing stuff, since there is no bash script debugger/ide
/step-by-step interpreter AFAIK (except for bash -x).
\layout Standard

debug-print() prints its parameters with the 
\begin_inset Quotes eld
\end_inset 

debug: 
\begin_inset Quotes eld
\end_inset 

 prefix.
 debug-print-function() prints 
\begin_inset Quotes eld
\end_inset 

debug: entering function $1, parameters: $2 $3 ...
\begin_inset Quotes erd
\end_inset 

.
 debug-print-section() prints 
\begin_inset Quotes eld
\end_inset 

debug: now in section $1
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

The debug output normally goes into ${T}/eclass-debug.log.
 You can set the ECLASS_DEBUG_OUTPUT variable (in make.globals/conf, and
 ebuild/eclass, or the environment) and output will be sent there as well.
 You can also set it to the special value 
\begin_inset Quotes eld
\end_inset 

on
\begin_inset Quotes erd
\end_inset 

, which echoes output to stdout together with the other emerge messages.
\layout Standard

Let's add typical debug output statements to our sample function:
\layout Code

base_src_compile() {
\layout Code

 
\layout Code

    debug-print function $FUNCNAME $*
\layout Code

    [ -z "$1" ] && base_src_compile all
\layout Code

 
\layout Code

    while [ "$1" ]; do
\layout Code

\layout Code

        case $1 in
\layout Code

            configure)
\layout Code

                debug-print-section configure
\layout Code

                ./configure || die;;
\layout Code

            make)
\layout Code

                debug-print-section make
\layout Code

                make || die;;
\layout Code

            all)
\layout Code

                debug-print-section all
\layout Code

                base_src_compile configure make;;
\layout Code

        esac
\layout Code

\layout Code

    shift
\layout Code

    done
\layout Code

 
\layout Code

    debug-print "$FUNCNAME: result is $RESULT"
\layout Code

\layout Code

}
\layout Standard

FYI, $FUNCNAME is a bash builtin that holds the current function's name.
\layout Subsection

newdepend()
\layout Standard

This function simply adds all parameters to both DEPEND and RDEPEND, saving
 you the trouble of writing and maintaining two lists of dependencies.
\layout Standard

If called with a special parameter, it adds predefined dependencies.
 These special parameters exist as of now:
\layout Standard


\latex latex 
newdepend /autotools: 
\latex default 
add 
\begin_inset Quotes eld
\end_inset 

sys-devel/autoconf sys-devel/automake sys-devel/make
\begin_inset Quotes erd
\end_inset 

 to DEPEND (but not RDEPEND).
\layout Standard


\latex latex 
newdepend /c:
\latex default 
 add 
\begin_inset Quotes eld
\end_inset 

virtual/glibc sys-devel/ld.so
\begin_inset Quotes erd
\end_inset 

 to both DEPEND and RDEPEND.
 Also, add 
\begin_inset Quotes eld
\end_inset 

sys-devel/gcc
\begin_inset Quotes erd
\end_inset 

 to DEPEND.
\layout Standard

This function encourages developers to maintain comprehensive DEPEND strings.
 Especially, many ebuilds have no RDEPEND strings, which will be a problem
 once we have unmerge functionality that knows about dependencies.
\layout Section

Misc eclasses
\layout Subsection

base.eclass
\layout Standard

This eclass defines some default variables and functions, similar to those
 you'd get by default in a non-inheriting ebuild (starting with a recent
 portage), e.g.
 src_unpack() { unpack ${A}; }.
\layout Standard

Eventually, it may be removed and merged with the default functions in ebuild.sh.
\layout Standard

It is inherited by higher-level eclasses like the kde ones.
\layout Standard

Note that in base_src_unpack there is one non-default section (i.e.
 it doesn't execute for section 
\emph on 
all
\emph default 
).
 It is called 
\emph on 
patch
\emph default 
 and it looks like this:
\layout Code

cd ${S}
\layout Code

patch -p0 < ${FILESDIR}/${P}-gentoo.diff
\layout Subsection

kde.eclass
\layout Standard

Used by all kde apps, whether directly or indirectly.
 (Not by apps with optional kde functionality though.) This is a higher-level
 eclass, which is intended to provide not only sensible defaults but functions
 which can be used as-is more often then not.
 In fact, none of the high-level kde-* eclasses which inherit from here
 change the functions in any way, and the ebuilds rarely do so.
 This eclass contains the meat of the kde eclass system, while virtual and
 base can be said to provide the skeleton.
\layout Standard

It inherits autoconf, base and depend.
\layout Standard

Read it to find out what it defines.
 It is quite self-explanatory.
\layout Standard

Briefly, it handles all standard kde apps that use GNU standard configure/make/m
ake install cycles.
 It handles all the std.
 configure options e.g.
 qtmt.
\layout Standard

Note: some kde apps, like widget styles and i18n packages, do not need to
 compile anything.
 Therefore kde.eclass does not inherit c.
 These packages can then inherit straight from here.
 All other packages, which need to compile c code, should inherit from kde-base.e
class.
\layout Subsection

cvs.eclass
\layout Standard

This eclass enables ebuilds to fetch sources from cvs.
 Because cvs ebuilds aren't yet an official feature of portage, it can only
 be found in my kde3pre ebuild package.
\layout Subsection

cvsup.eclass
\layout Standard

Ditto for cvsup.
\layout Section

KDE-centric eclasses
\layout Subsection

kde.eclass
\layout Standard

This is the main, central KDE eclass.
 It contains most of the KDE-related code.
 All KDE ebuilds inherit from it one way or another.
\layout Standard

As with the other eclasses, read it to find out what it does.
 Here is a short summary, with improved readability and comments after every
 part:
\layout Code

inherit base kde-functions
\layout Code

ECLASS=kde
\layout Code

newdepend /autotools
\layout Code

HOMEPAGE="http://www.kde.org/"
\layout Standard

The above should be self-obvious by now.
\layout Standard

There is no kde_src_unpack() function.
 The base_src_unpack() function serves admirably.
 Let's move on to kde_src_compile():
\layout Code

kde_src_compile() {
\layout Code

\layout Code

    section myconf:
\layout Code

        myconf="$myconf --host=${CHOST} --with-x --enable-mitshm --with-xinerama
 
\backslash 
                     --with-qt-dir=${QTDIR}"
\layout Code

\layout Code

       case $KDEMAJORVER in
\layout Code

            2) myconf="$myconf --prefix=${KDE2DIR}";;
\layout Code

            3) myconf="$myconf --prefix=${KDE3DIR}";;
\layout Code

            *) echo an error and abort (unrecognized version);;
\layout Code

        esac
\layout Code

\layout Code

        use qtmt && myconf="$myconf --enable-mt"
\layout Code

        [ -n "$DEBUG" ] && myconf="$myconf --enable-debug=full --with-debug"
 
\backslash 

\layout Code

                        || myconf="$myconf --disable-debug --without-debug"
\layout Standard

The $myconf variable holds the parameters to be passed to configure.
 It is never set, but always added to, so you can add to it from your own
 ebuild as well.
 The myconf section sets the default parameters.
\layout Standard

The first part of the section sets the hardcoded parameters.
\layout Standard

The second sets the prefix, based on $KDEMAJORVER which is set in set-kdedir()
 (see the section about kde-functions.eclass).
\layout Standard

The third adds parameters based on USE flags (qtmt) and $DEBUG.
\layout Code

    section configure:
\layout Code

        # This can happen with e.g.
 a cvs snapshot
\layout Code

        if [ ! -f "./configure" ]; then
\layout Code

            for x in Makefile.cvs admin/Makefile.common; do
\layout Code

                if [ -f "$x" ] && [ -z "$makefile" ]; then makefile="$x";
 fi
\layout Code

            done
\layout Code

            emake -f $makefile
\layout Code

            [ -f "./configure" ] || die "no configure script found, generation
 unsuccessful"
\layout Code

        fi
\layout Code

\layout Code

        export PATH="${KDEDIR}/bin:${PATH}"
\layout Code

        ./configure ${myconf} || die "died running ./configure, $FUNCNAME:configur
e"
\layout Standard

The configure section actually runs the configure script with the parameters
 in $myconf.
 The first part of the section also runs make -f Makefile.cvs or make -f
 admin/Makefile.common if needed to generate the configure script.
\layout Code

    section make:
\layout Code

        export PATH="${KDEDIR}/bin:${PATH}"
\layout Code

        emake || die "died running emake, $FUNCNAME:make"
\layout Standard

This simple section runs make.
\layout Standard

Next is kde_src_install().
 It is not much different from base_src_install, except that it adds a 
\emph on 
dodoc
\emph default 
 section:
\layout Code

kde_src_install() {
\layout Code

\layout Code

    section make:
\layout Code

        make install DESTDIR=${D} destdir=${D} || die 
\layout Code

    section dodoc:
\layout Code

        dodoc AUTHORS ChangeLog README* COPYING NEWS TODO
\layout Code

\layout Code

}
\layout Subsection

kde-functions.eclass
\layout Standard

This eclass contains all KDE-related helper functions.
 Some of them you should never need to use directly in an ebuild; these
 are not mentioned here.
\layout Subsubsection

The current multi-kdedir scheme
\layout Standard

A short explanation about the current multi-kdedir scheme:
\layout Standard

$KDE{2,3}DIR and $KDELIBS{2,3}DIR are set in make.globals (and can be overridden
 in make.conf).
 Their default values are /usr/kde/{2,3}, respectively.
\layout Standard

A package that identifies itself as a kde2 package (see below) will use
 the kdelibs installed in $KDELIBS2DIR and install itself into $KDE2DIR.
 Same goes for kde3.
 NOTE: separating kdelibs from kde apps and any other non-default KDEDIR
 stuff is untested and unsupported.
\layout Standard

As for qt, the latest 2.x and 3.x versions live in /usr/qt/{2,3} respectively.
\layout Subsubsection

need-kde(), need-qt(), set-kdedir(), set-qtdir()
\layout Standard

This eclass provides two pairs of functions: need-kde(), need-qt() and set-kdedi
r(), set-qtdir().
 These functions handle the details of the multi-qt and multi-kdelibs schemes.
\layout Standard

The need-* functions are called with a parameter which is the version number
 required.
 They add the proper dependencies and call the set-*dir functions.
 If no parameter is passed, a version number of 0 (zero) is used, meaning
 that any version will satisfy the dependency.
\layout Standard

The set-* dir functions set KDEDIR and QTDIR, as well as KDEMAJORVER (=2
 or =3).
 That's all your ebuild should need.
\layout Standard

It is important to call these functions from the main part of the ebuild
 (i.e.
 not from a function), so that any changes to DEPEND and RDEPEND affect
 emerge.
\layout Subsubsection

kde_sandbox_patch()
\layout Standard

Some KDE makefiles are incorrectly generated.
 They chmod or chown files in $PREFIX when installing, but do not respect
 $DESTDIR ($D).
 Our sandbox detects these errors.
 This function runs a generic sed on makefiles which fixes all known cases
 of the problem.
 It is called with the directories to be processed as parameters, and processes
 Makefile, Makefile.in and Makefile.am in those directories.
 For example:
\layout Code

src_unpack() {
\layout Code

    base_src_unpack
\layout Code

    kde_sandbox_patch ${S}/dir1 ${S}/dir2/dir3
\layout Code

}
\layout Subsection

kde-base.eclass
\layout Standard

Meant for standard kde apps; nearly all ebuilds use it.
 It inherits kde, calls newdepend /c, and sets HOMEPAGE=apps.kde.com.
\layout Subsection

kde-i18n.eclass
\layout Standard

Meant for the kde-i18n-* packages; niche use.
\layout Standard

In fact, all kde-i18n ebuilds are completely identical and so all they have
 to do is inherit from this eclass.
 Their ${P} does the rest.
\layout Subsection

koffice-i18n.eclass
\layout Standard

Meant for the koffice-i18n-* packages.
 Very similar to kde-i18n.eclass.
\layout Standard

All kde-i18n ebuilds are completely identical and so all they have to do
 is inherit from this eclass.
\layout Subsection

kde-dist.eclass
\layout Standard

Meant for the core kde distribution packages in kde-base/*.
 Inherits kde-base, kde.org.
 Adds the correct DESCRIPTION and HOMEPAGE, calls need-kde ${PV} and adds
 the --enable-final myconf parameter.
 The simpler, smaller kde-base/ packages (e.g.
 kdetoys) don't need to make any changes to it; most of those that do only
 add deps.
\layout Subsection

kde.org.eclass
\layout Standard

Used by the kde-base/ core packages, and the other packages hosted on ftp.kde.org
 and its mirrors (kdevelop, koffice, kdoc).
 Sets SRC_URI and adds the major ftp.kde.org mirrors.
\layout Subsection

kde-pre.eclass
\layout Standard

This is only included with the kde3pre ebuilds, and doesn't live in portage.
\layout Standard

It is used for pre-release ebuilds, which have underscores in their portage
 names (3.0_beta1) but not in their source archives' names (3.0beta1.tar.gz).
 Removes any underscores from $SRC_URI and $S.
\layout Subsection

kde-i18n-pre.eclass
\layout Standard

As above, for kde-i18n prereleases.
\layout Subsection

kde-source.eclass
\layout Standard

As above, only available in kde3pre.
\layout Standard

Used by kde-base/* core packages to get source via cvs or cvsup; uses cvs.eclass
 and cvsup.eclass.
 The three eclasses together are so powerful that an ebuild only needs to
 inherit kde-source for everything to work automatically, including such
 goodies as automatic switching between cvs servers, cvs checkout/update/offline
 mode, etc.
 etc.
 But, there are no cvs ebuilds in portage yet, so these stay outside.
\layout Section

Writing KDE ebuilds
\layout Subsection

A typical KDE ebuild
\layout Standard

The code below should be obvious after reading this howto:
\layout Code

<header lines>
\layout Code

inherit kde-base
\layout Standard

Some ebuilds end right here.
 Others need some customization.
\layout Standard

Add any extra deps.
 Remember: *always* extend variables, never override!
\layout Code

DEPEND="$DEPEND foo/bar"
\layout Code

RDEPEND="$RDEPEND bar/foo"
\layout Standard

This will add a dep to both DEPEND and RDEPEND:
\layout Code

newdepend "foo? ( bar )"
\layout Code

\layout Standard

This adds extra arguments to $myconf, which are passed to configure:
\layout Code

myconf="$myconf --with-foobar"
\layout Standard

An extend src_unpack:
\layout Code

src_unpack() {
\layout Code

    base_src_unpack all patch   # Patch from ${FILESDIR}/${P}-gentoo.diff
\layout Code

    # some more changes
\layout Code

    dosed -e 's:1:2:' ${S}/foobar
\layout Code

}
\layout Subsection

A typical ebuild with optional KDE functionality
\layout Standard

Basically, prefix each kde-specific line with 
\begin_inset Quotes eld
\end_inset 

use kde &&
\begin_inset Quotes erd
\end_inset 

, or create whole 
\begin_inset Quotes eld
\end_inset 

if [ 
\begin_inset Quotes eld
\end_inset 

`use kde`
\begin_inset Quotes erd
\end_inset 

 ]; then; fi
\begin_inset Quotes erd
\end_inset 

 blocks.
\layout Standard

To the general section, add the following (if USE kde is set):
\layout Code

if [ "`use kde`" ]; then
\layout Code

    inherit kde-functions
\layout Code

    need-kde $version # minimal version of kde your app needs
\layout Code

fi
\layout Standard

Add any further code you want, like this:
\layout Code

use kde && myconf="$myconf --with-my-parameter"
\layout Standard

Tell your app to look for KDE in the $KDEDIR that is available after calling
 need-kde().
\the_end
