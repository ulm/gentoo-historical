<?xml version='1.0' encoding='euc-kr'?>

<!DOCTYPE guide SYSTEM "../../../dtd/guide.dtd">

<guide>
<title>Gentoo Linux Developers HOWTO</title>
<author title="Author"><mail link="woodchip@gentoo.org">Donny Davies</mail></author>
<author title="Author"><mail link="drobbins@gentoo.org">Daniel Robbins</mail></author>
<author title="Author"><mail link="pete@gentoo.org">Peter Gavin</mail></author>
<author title="Author"><mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail></author>
<author title="Author"><mail link="zhen@gentoo.org">John P. Davis</mail></author>
<author title="번역자"><mail link="nabugoon@gentoo.or.kr">나부군</mail></author>
<author title="Moderator"><mail link="seo@gentoo.or.kr">Jungmin Seo</mail></author>
<abstract>이 문서는 젠투의 포테이지 시스템에 대해서 설명하고, 젠투에서 어떻게 새로운 패키지를 생성하며, 젠투 개발자들을 위한 약간의 표준화에 대해서도 설명할 것이다. 이것은 현재 계속 작업중이며, 끊임없이 갱신되고 바뀔 것이다. 그것은 결코 완벽하지 않다.</abstract>
<version>1.3</version>
<date>24 October 2002</date>


<chapter>
<title>포테이지 트리</title>

<section>
<title>소개</title>
<body><p>
포테이지 트리는 일반적으로 <path>/usr/portage</path> 에 존재하며, 카테고리 디렉토리와 그 안의 개별적인 패키지 디렉토리들로 구성된 계층적 구조를 띄고 있다. 예를들어 여러분은 <path>util-linux-2.11g.ebuild</path> 파일을 <path>/usr/portage/sys-apps/util-linux</path> 디렉토리에서 찾을 수 있다. 아마도 <path>util-linux-2.11g.ebuild</path> 파일과 함께 또 다른 버전의 <c>util-linux</c> ebuild 파일들이 있을 것이다. 이것은 특정 패키지들은 모두 버전에 관계 없이 <path>/usr/portage</path> 밑에 같은 <path>mycat/mypkg</path> 디렉토리를 공유 한다.
</p>
</body>
</section>

<section>
<title>포테이지 트리에 포함되어야 할 것과 포함되지 말아야 할 것</title>
<body>

<p>
일반적으로 포테이지 트리안에는 오직 <path>.ebuild</path> 파일들만이 포함될 수 있고, 몇몇 패치파일들과 설정 예제파일같은 연관된 파일들은 <path>/usr/portage/mycat/mypkg/files</path> 디렉토리안에 존재해야 한다. 그것은 포테이지 트리를 명랑하게(!) 유지한다. 또한, 일반적으로 개발자들이 CVS에 바이너리(아스키 파일이 아닌 파일)을 추가하는 것은 좋은 생각이 아니다, 그러나 만약 그것이 반드시 필요하다면(예를 들어, 만약 여러분이 어떤 이유에서든 작은 PNG 그림 파일을 추가해야 할 때), 다음과 같이 <c>-kb</c> 옵션을 사용하여 CVS에 해당 파일을추가하여라.
</p>
<pre>
# <i>cvs add -kb myphoto.png</i>
</pre>

<p>
<c>-kb</c> 옵션은 CVS에게 <path>myphoto.png</path> 가 바이너리 파일이며, 특별히 다루어야 한다고 알려준다. 예를 들어, 이 파일의 서로다른 두개의 버전 사이의 차이가 합쳐지는 일이 일어나도록 하지 않아야 한다. 또한, 변경사항들을 합친다 할때, 포테이지에 추가한 어떤 패치도 압축되어서는 <e>안된다</e>. 이것은 CVS가 변경하상들을 합치고 개발자들에게 불일치에 대해 정확하게 알려줄 수 있도록 한다.
</p>

</body>
</section>

<section>
<title>files 디렉토리</title>
<body>

<p>
앞에서 언급했듯이, 각 패키지들의 하위 디렉토리는 <path>files</path>이다. 여러분의 패키지가 필요로 할 각종 패치들이나 설정 파일들, 혹은 다른 부속 파일들은 이 디렉토리에 추가되어 있어야 한다. 여러분은 <path>mypkg-1.0-gentoo.diff</path>와 같이, 빌드될 패키지의 버전에 따른 이름으로 패치의 이름을 짓고 싶어할 것입니다.
또한, <path>gentoo</path>가 붙은 패치파일은 사람들이 해당 패치가 메일링 리스트같은 곳에서 추출한 것이 아니라, 우리들, 즉, 젠투 리눅스 개발자들이 만든 것이라고 생각한다. 다시 이야기 하지만, 여러분들은 패치 파일들을 압축하지 말아야 한다. 왜냐하면, cvs는 바이너리 파일들을 잘 다루지 못하기 때문이다.
</p>

<p>
만약 여러분이 <path>files</path> 디렉토리안에 넣을 파일들이 많다면, <path>files/mypkg-1.0</path>과 같이 하위디렉토리를 만들어서 관련된 파일들을 해당하는 하위디렉토리 안에 넣는 것을 고려해 보기 바란다. 만약 여러분이 이러한 방법을 사용한다면, 여러분은 files 디렉토리 안의 파일들의 이름뒤에 접미사를 추가할 필요가 없다. 이러한 방법이 편리할 때가 있다.
</p>

</body>
</section>
</chapter>

<chapter>
<title>이빌드 스크립트들</title>
<section>
<title>소개</title>
<body>

<p>
이빌드 스크립트들은 전체 포테이지 시스템의 기본이다. 그것들은 파일을 다운로드 받고(download), 압축을 풀고(unpack), 컴파일하고(compile), 인스톨(install)하는 소스들의 모음이다. 포테이지의 대부분이 파이썬으로 쓰여진 반면, ebuild 스크립트들은 명령행으로 부터 명령들을 직접 실행 시킬 수 있기 때문에 bash로 쓰였다. ebuild 스크립트의 중요한 디자인 원리중에 하나는 만약 패키지를 수동으로 설치해야 한다면, 우리가 일반 명령행에 입력하는 명령들과 유사한 것들을 바로 사용할 수 있다는 것이다. 이런 목적들을 위해서 bash의 문법을 가지는 것은 좋은 일이다.
</p>

<p>
이빌드 스크립트들은 <c>ebuild</c>와 <c>emerge</c> 명령들에 의해서 해석된다. <c>ebuild</c> 명령은 저수준의 저작 도구로 생각하면 된다. 그것은 하나의 ebuild를 빌드하고 설치할 수 있지만, 그 이상은 아니다. <c>ebuild</c>는 의존성을 만족하는지 알아보기 위해서 검사하지만, 의존되는 패키지들을 자동으로 설치해 주지는 않는다. 반면, <c>emerge</c>는 <c>ebuild</c>를 위한 상위레벨 엔진이다. <c>emerge</c>는 필요하다면 의존성에 필요한 패키지들을 자동으로 설치할 수도 있고, 어떤 ebuild들이 시스템에 <e>병합될것인가</e> 알아보기 위해 병합하는 척(pretend) 수행할 수도 있고, 기타 여러가지 다양한 기능들이 가능하다. 일반적으로 <c>emerge</c>를 대신해서 <c>ebuild</c>를 사용하는 일은 다음의 경우를 제외하고는 없다고 할 수 있다. <c>ebuild</c>로는 패키지가 설치되는 여러가지 단계들을 나누어서 수행할 수 있다(fetching, compiling, installing, merging). 개발자들에게는 이것이 매우 유용한 디버깅 도구가 될 수 있는데, 이것을 이용해서 문제가 되는 빌드 과정을 따로 수행해 볼 수 있기 때문이다.
</p>

</body>
</section>

<section>
<title>이빌드 파일들의 이름짓기</title>
<body>

<p>
이빌드 파일이름은 네개의 논리적인 부분으로 이루어진다.
</p>

<p>
Some examples are <c>util-linux</c>, <c>sysklogd</c> and <c>glibc</c>.  
첫번째 부분은 패키지 이름으로, 오직 소문자와, 0부터 9사이의 숫자, 그리고 하이픈('-')으로만 이루어 져야 한다. 몇몇의 예는 다음과 같다. <c>util-linux</c>, <c>sysklogd</c>, <c>glibc</c>
</p>

<p>
두번째 부분은 패키지의 버전으로, 일반적으로 메인 소스 타르볼의 버전과 같아야 한다. 버전은 일반적으로, <c>1.2</c> 혹은 <c>4.5.2</c>와 같이, 마침표로 구분이 되는 두세개의 숫자로 이루어 진다(물론 더욱 <e>여러개의</e> 숫자로 이루어질 수도 있다). 그리고 버전은 마지막 숫자의 바로 뒤에 하나의 문자를 <c>1.4b</c>, <c>2.6h</c>처럼 추가할 수 있다. 패키지 버전은 패키지 이름과 하이픈으로 합쳐지며, 다음과 같은 모양을 가진다. <c>foo-1.0</c>, <c>bar-2.4.6</c>
</p>

<impo>
만약 여러분이 여러분의 버전 문자열에 이처럼 뒤에 붙는 글자를 사용할 생각이라면, 사용하려는 문자가 알파나 베타 상태의 패키지를 나타내는데 쓰이지 않는지 확인해 보아야 한다. 그것은 알파 배포판들과 베타 배포판들은 <i>배포전</i>상태이고 개정 번호를 나타내는 문자들은 <i>새로운 버전</i>을 나타내기 때문이다. 이것이 중요한 것은 같은 카테고리 디렉토리 안의 서로 다른 패키지들이 어느 것이 최근 것이고 어느 것이 예전 것인지를 구별하는데 포테이지가 이빌드의 버전을 사용하기 때문이다. 포테이지가 의존성 체크를 하는 의무를 충실히 해낼 수 있도록 패키지의 버전을 믿을 수 있게 나타내는것은 매우 중요하다.
</impo>

<p>
세번째(선택적) 부분은 <c>_alpha</c>, <c>_beta</c>, <c>_pre</c> 혹은 <c>_rc</c>같은 특별한 접미사를 포함한다. 이 접미사들은 패키지 버전 바로 뒤에 <c>linux-2.4.0_pre10</c> 같이 붙는다. <c>_alpha</c>는 <c>_beta</c>의 전 버전이고, <c>_beta</c>는 <c>_pre</c>의 전버전이며, <c>_pre</c>는 <c>_rc</c>의 전버전이다.
</p>

<note>
<c>_rc</c>는 아무것도 안붙은 버전의 전버전이다.(예: <c>linux-2.4.0</c>) 그리고, <c>linux-2.4.0</c>은 <c>linux-2.4.0b</c>처럼 뒤에 하나의 문자가 딸려오는 버전의 전버전이다. 이쯤에서 예상되겠지만, <c>linux-2.4.0b</c>는 <c>linux-2.4.0c</c>의 전버전이다. 이러한 버전 정보를 표시하는 것은 매우 중요한데, 그것은 포테이지가 같은 카테고리와 이름을 가지는 서로 다른 ebuild나 패키지들을 결정하는데 내부적으로 그것을 사용하기 때문이다.
</note>

<p>
패키지 이름의 네번째(선택적) 부분은 젠투 리눅스에서만의 <e>개정</e> 번호이다. 그것은 <c>-r#</c> 형식으로 사용되는데 #는 정수를 뜻하며, <c>package-4.5.3-r3</c> 같이 쓰인다. 이 개정 번호는 소스 타르볼의 버전에 독립적이고, 특정 패키지가 젠투 리눅스안에서 새롭게 혹은 향상되어 졌다는 것을 사람들이에게 알리기 위해서 사용된다.
</p>

<p>
만약 여러분이 현재 존재하는 ebuild 파일에 사소하지 않은 개선을 한다면, 여러분은 ebuild 파일을 개정 번호를 1증가하여 새로운 파일로 복사하여야 한다. 초기 배포본들은 일반적으로 revision 번호가 없다. <e>package-4.5.3</e> 같은 경우 포테이지에 의해서 revision 번호가 0이라고 인식이 된다. 이것은 다음과 같은 순서를 가진다는 것이다. <c>1.0</c>(초기 버전), <c>1.0-r1</c>, <c>1.0-r2</c> 등등. 여러분이 바꾼 부분에 있어서 <e>항상</e> Changelog를 작성하는 것을 기억하기 바란다. 여러분이 이것을 지키지 않았을때는, CVS 접근 권한이 취소되는 심각한 상황에 빠질 것이다.
</p>

<p>
그리고 나는 우리가 <c>.ebuild</c>라는 확장자로써 <e>다섯번재</e> ebuild 이름을 가진다고 생각한다.
</p>

</body>
</section>

<section>
<title><e>이빌드</e>파일의 내용 </title>
<body><p>1. 변수 설정</p>
<p>
모든 ebuild 파일의 첫부분은 몇몇의 변수설정으로 이루어져 있다. 여러분이 설정할 수 있는 변수들은다음과 같다.
</p>

<table>
<tr><ti><c>P</c></ti><ti>패키지의 이름과버젼; 이것은 이빌드파일 이름으로 부터 결정되기 때문에 여러분이 따로 설정해 주지 않아도 된다.</ti></tr>

<tr><ti><c>S</c></ti><ti>여러분 패키지의 소스 디렉토리; 일반적으로 $(WORKDIR)/$P</ti></tr>

<tr><ti><c>D</c></ti><ti>인스톨될 디렉토리의 최상위로 가상의 '/'로써 다루어진다.</ti></tr>

<tr><ti><c>SLOT</c></ti><ti>포테이지는 같은 패키지이면서 버전이 다른 패키지들을 다룰수 있다. 만약 여러분이 GCC 2.95와 GCC 3.x를 동시에 설치하고 싶다면 ,여러분은 각각의 ebuild에 slot을 구별지어주면 된다. 예를 들어 GCC 2.95는 slot 0, GCC 3.x는 slot 1로 설정하면 된다.
</ti></tr>

<tr><ti><c>LICENSE</c></ti><ti>이 변수는 해당 프로그램이 어떤 라이센스를 취하고 있는지를 나타낸다.
</ti></tr>

<tr><ti><c>ARCH</c></ti><ti> 이 변수는 현재 두세가지 다른 기능들을 지원한다. 우선, 이 변수는 이빌드가 수행될 아키텍쳐가 무엇인지 나타내는 변수이다. x86, ppc, alpha, sparc, sparc64 등의 키워드가 포함된다. 분명히 여러분들은 이 값을 해당 하드웨어의 아키텍처로 설정할 것이다. 포테이지는 x86 머신에서는 ARCH USE변수가 지정하는 것이 X86이 아닌것은 절대 빌드되도록 허용하지 않을 것이다. 현재 머신의 아키텍처에 해당하지 않는 패키지들을 자동적으로 포테이지로 부터 마스크 될 것이다. 만약 <c>ARCH</c> 플래그 앞에 ~가 붙어 있다면, 특정 이빌드에서는 동작하지만 ,주어진 키워드로는 불안정하다는 것을 의미한다. <c>ARCH</c>플래그 앞에 -가 붙어 있다면, 해당 패키지는 주어진 키워드로는 동작하지 않는 것이고, <c>ARCH</c>앞에 아무것도 붙어 있지 않다면, 해당 패키지는 안정하다는 것으로 간주한다. 여러분은 <path>make.conf</path>를 통해서 패키지의 서로 다른 타입들이 설치될 수 있도록 허용할 수 있다.
</ti></tr>

<tr><ti><c>DESCRIPTION</c></ti><ti>간단한, 한줄짜리 패키지 설명.
</ti></tr>

<tr><ti><c>SRC_URI</c></ti><ti>여러분의 패키지의 모든 소스 파일의 URI로, whitespace로 각각을 나누어 표기한다. 일반적으로 가장 먼저 것은 &quot;ftp://ftp.company.com/pub/somepackage/${A}&quot;와 같은 식으로 되어 있다.
</ti></tr>

<tr><ti><c>HOMEPAGE</c></ti><ti>여러분 패키지의 홈페이지
</ti></tr>

<tr><ti><c>IUSE</c></ti><ti>이것은 여러분의 패키지가 어떤 USE 플래그들을 사용할지 설정한다. 만약 여러분의 패키지가 아무것도 사용하지 않는다면, <c>IUSE=""</c> 라고 표기해야 한다.
</ti></tr>

<tr><ti><c>DEPEND</c></ti><ti>컴파일시의 의존성; <uri link="#dependencies">Package Dependencies</uri>를 참조하기 바란다.</ti></tr>

<tr><ti><c>RDEPEND</c></ti><ti>실행시의 의존성; <uri link="#dependencies">Package Dependencies</uri>를 참조하기 바란다.</ti></tr>
</table>

<p>2. 이빌드 함수들</p>
<p>
이빌드 파일들에는 여러분 패키지의 빌딩과 설치를 통재하고, 여러분이 정의해서 사용하는 함수들이 여러개 있다.</p>
<table>
<tr><ti><c>pkg_setup</c></ti><ti>이 함수는 미리 수행해야 할 여러 잡다한 일들을 수행하는데 사용된다. 이 함수는 시스템 계정들을 추가하거나, 현재 존재하는 설정 파일들을 검사해 보는 것들을 추가할 수도 있다. 이 함수는 계속 진행하기 위해 0을 반환해야 한다.
</ti></tr>

<tr><ti><c>src_unpack</c></ti><ti>이 함수는 여러분의 소스들의 압축을 풀고 만약 필요하다면, autoconf/automake등을 실행하는데 사용된다. 기본값으로 <c>${A}</c>안에 패키지들의 압축을 풀고, <c>${WORKDIR}</c>에서 시작된다.
</ti></tr>

<tr><ti><c>src_compile</c></ti><ti>이 함수는 패키지를 설치하고 빌드하는데 사용된다. 기본값으로, 시작되는 디렉토리는 <c>${S}</c>이다.
</ti></tr>

<tr><ti><c>src_install</c></ti><ti>
이 함수는 패키지를 <c>${D}</c>안에 이미지로 설치할 때 사용된다. 만약 여러분의 패키지가 automake를 사용한다면, 여러분은 <c>make DESTDIR=${D} install</c> 처럼 간단하게 수행할 수 있다. <e>여러분의 패키지가 자신의 모든 파일을 <c>${D}</c>를 최상위 디렉토리로써 사용하여 설치하는지 확인해라.</e>
</ti></tr>

<tr><ti><c>pkg_preinst</c></ti><ti>이 함수 안에 있는 명령들은 패키지 이미지들을 파일시스템 안에 합병시키기 전에 수행된다.
</ti></tr>

<tr><ti><c>pkg_postinst</c></ti><ti>이 함수 안에 있는 명령들은 패키지 이미지들을 파일시스템 안에 합별시킨 후에 수행된다.
</ti></tr>

<tr><ti><c>pkg_prerm</c></ti><ti>이 함수 안에 있는 명령들은 패키지 이미지들을 파일시스템 안에서 제거하기 전에 수행된다.
</ti></tr>

<tr><ti><c>pkg_postrm</c></ti><ti>이 함수 안에 있는 명령들은 패키지 이미지들을 파일시스템 안에서 제거한 후에 수행된다.
</ti></tr>

<tr><ti><c>pkg_config</c></ti><ti>
이 함수는 패키지가 설치된 후에 설정을 초기할때 사용할 수 있다. 이 함수 안에서 사용되는 모든 경로는 ${ROOT}를 접두사로 가져야만 한다. 이 함수는 <e>오직</e> 사용자가 <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c> 이라고 명령을 내렸을때만 실행된다.
</ti></tr>
</table>

</body>
</section>

<section>
<title>이빌드 파일을 만드는 법칙</title>
<body>
<p>
이빌드 파일들은 단지 쉘 스크립트이기 때문에, 여러분은 파일들을 편집하는기 위해서 여러분의 편집기를 쉘 스크립트 모드로 사용해야 한다. 여러분은 적절한 행비우기를 tab(스페이스가 아닌)을 이용해서 사용해야 한다. 여러분의 편집기의 tabstop이 4로 설정되어 있는지 확인해라. 항상 여러분의 환경변수에는 괄호를 치지 바란다. <c>$P</c>대신에 <c>${P}</c>처럼 쓰기 바란다.
</p>

<p>긴 줄은 '\'을 사용해서 유지할 수 있다.</p>
<pre>
./configure \
	--prefix=/usr || die "configure failed"
</pre>

<p>보다 자세한 내용은 skel.ebuild 파일을 참조해라(일반적으로 /usr/portage안에 존재한다.)</p>

<p>만약 여러분이 Vim을 사용하고 있다면, 다음 부분을 여러분의 .vimrc안에 추가하기 바란다. 이것으로 여러분은 Gentoo와 관련된 어떤 편집에서도 올바른 설정을 사용할 수 있는 것이다.
</p>

<pre>
if (getcwd() =~ 'gentoo-x86\|gentoo-src\|portage')
	set tabstop=4 shiftwidth=4 noexpandtab
endif
</pre>
<p>해야할 일 : emacs를 위한 설정을 추가한다.</p></body>
</section>

<section>
<title><c>USE</c> 변수들</title>

<body>

<p>
USE 변수들을 사용하는 목적은 여러분이 포테이지를 전체적으로 설정할 수 있고, <e>선택적으로 빌드시에</e> 특정 기능을 추가 혹은 제거하는 것을 자동적으로 할 수 있기 때문이다. 여기에 예제가 있다. 여러분이 GNOME의 팬이라고 가정하자, 그래서 여러분은 컴파일시에 GNOME을지원하는 어떤 ebuild에 GNOME을 지원하도록 하고 싶어한다. 그렇다면 여러분은 <path>/etc/make.conf</path> 파일 안의 <c>USE</c> 변수들에 <c>gnome</c>을 추가하면 된다. 그렇게 하면, 만약 GNOME을 이용해서 컴파일을 할 수 있는 모든 패키지들을 그렇게 할 것이다. 만약, 여러분이 GNOME의 선택적인 기능들을 여러분의 ebuild들에 추가하고 싶지 않다면, 단순히 <path>/etc/make.conf</path> 파일을 수정해서 <c>USE</c> 변수들에 <c>gnome</c>이 추가되지 <e>않았다는것을</e> 확인하면 된다. 젠투리눅스는 거의 모든부분에 있어서 USE 옵션들을 가지고 있다. 이것은 여러분이 여러분의 시스템을 여러분이 원하는데로 정확하게 설정할 수 있도록 도와준다.

<note>
만약 여러분이 USE 변수들을 해제한다면(예를들어 <c>USE</c> 변수들에서 <c>gnome</c>을 제거하면), 이것은 포테이지가 컴파일될 때 <e>선택적인</e> GNOME지원을 하지 못하게하는 지시일 뿐이다. 그러나, 만약 여러분이 분명하게 GNOME을 <e>필요로하는</e> ebuild를 <c>emerge</c> 하려 할 때는 포테이지는 GNOME지원을 가능하도록 한다. 이것은 만약 여러분 시스템에 GNOME이 깔려 있지 않다면, 자동으로 GNOME을 설치(의존성에 의하여)한다는 의미이다. 그러므로 여러분은 항상 새로운 패키지를 설치하기 전에 <c>emerge --pretend</c>를 수행해서 실제로 <c>emerge</c>를 할때 어떤일이 벌어질지 확인해 보는것이 좋다.</note>

여러분 자신의 ebuild들에서 여러분은 <c>use &lt;variable&gt;</c> 명령을 통해서 특정 USE 변수가 설정되었는지 확인해 볼 수 있다. <c>use</c> 명령은 <c>USE</c>와 명령행 두곳에 존재하는 모든 변수들의 이름을 출력한다. 여러분은 다음과 같이 use명령어를 사용할 수 있다.
</p>

<p><c>if [ &quot;`use X`&quot; ]; then commands; fi</c></p>


<p>
USE 변수들은 의존성을 설정하는데 사용할 수도 있다. 예를 들어, 여러분은 특정한 USE변수가 설정된 패키지들만을 필요로 할수도 있다. 이것은 여러분의 ebuild에서 DEPEND 변수안의 <c>variable? (mycat/mypackage-1.0-r1)</c>같은 문법으로 사용가능 하다. 여기에서는 <c>mycat/mypackage-1.0-r1</c> 패키지가 만약 <c>USE</c>에 <c>varialbe</c>이 존재한다면 그것을 필요로 한다는 뜻이다.
</p>

<p>
여기에 <c>USE</c>를 어떻게 사용하는지 중요한 팁이 있다. 대부분의 패키지들은 설정단계를 수행하는데 <c>./configure</c> 스크립트를 사용한다. 일반적으로, 만약 여러분의 이빌드가 <c>./configure</c>를 사용한다면, 빌드시의 부가적인 여러 기능들을 <c>./configure</c> 명령의 인자로 전달하여 설정 또는 해제 할 수 있다. 여기에 이것을 다루는 최상의 방법이 있다. 먼저 여러분이 추가하고 싶은 <c>USE</c> 지원이 <c>./configure</c> 옵션으로 기본값으로 <e>설정되어</e> 있는지 <e>해제되어</e> 있는지 알아낸다. 만약 기본값으로 설정이 되어 있다면, 다음과 같이 한다.
</p>

<pre>
DEPEND="gnome? ( &gt;=gnome-base/gnome-1.4 )
	mysql? ( &gt;=dev-db/mysql-3.23.49 )"

src_compile() {
	local myconf
	use gnome || myconf="--disable-gnome"
	use mysql || myconf="${myconf} --disable-mysql"

	./configure ${myconf} --prefix=/usr --host=${CHOST} || die
	emake || die
}
</pre>

<p>
위에서, 우리는 <c>gnome</c>과 <c>mysql</c> <c>USE</c> 변수들이 해제되어 있는지만 확인해 보았다. <c>use gnome ||</c> 부분은 <c>USE</c> 변수안에 <c>gnome</c>이 있는가 검사해 보고, 만약 그렇지 않다면, <c>myconf="--disable-gnome"</c>을 설정한다. 이 패키지는 GNOME과 MySQL이 기본값으로 설정되어 있으므로, 명시적으로 선언을 해줄 필요는 없다. 그러나, 만약 특정 기능이 기본값으로 <e>해제되어</e> 있을때는 다음과 같이 한다.
</p>

<pre>
DEPEND="gnome? ( &gt;=gnome-base/gnome-1.4 )
	mysql? ( &gt;=dev-db/mysql-3.23.49 )"

src_compile() {
	local myconf
	use gnome &amp;&amp; myconf="--enable-gnome"
	use mysql &amp;&amp; myconf="${myconf} --enable-mysql"

	./configure ${myconf} --prefix=/usr --host=${CHOST} || die
	emake || die
}
</pre>

<p>이제, 우리는 <c>USE</c> 변수가 설정되었는지에 따라서 명시적으로 GNOME과 MYSQL을 설정해 주어야 한다. <c>use mysql &amp;&amp;</c> 부분은 <c>USE</c> 변수안에 <c>mysql</c>이 있는가 검사해 보고, 만약 그렇다면, <c>myconf="${myconf} --enable-mysql"</c>을 설정한다.</p>

<p>계속 USE변수들의 목록이 갱신되는 것을 보고 싶다면,
<uri link="http://www.gentoo.org/doc/use.html">이곳</uri>으로 가기 바란다. </p>

</body>
</section>
</chapter>

<chapter>
<title>파일시스템 위치들</title>

<section>
<title>FHS 소개</title>
<body>
<p>
파일시스템 구조 표준들은 젠투에서 <e>Filesystem Hierarchy Standard</e>(이하 FHS)에 매우 근접하게 따른다. 해당 표준의 간단한 설명은 이 문서에서 제공된다. 만약 완전한 명세를 보고 싶다면, <uri>http://www.pathname.com/fhs</uri>를 참조하기 바란다.
</p>

<note>
<path>/opt</path> 계층은 FHS의 3.12절에서 언급된다. Section 4.4에서는 <path>/usr/X11R6</path> 디렉토리를 다루고 있다. KDE와 GNOME은 특별히 언급되고 있지 않은데, 이것은 최근의 FHS 버전에서 조차 언급되고 있지 못하다.
 </note>
</body>
</section>

<section>
<title>여러분의 패키지를 어떻게 파일시스템에 알맞게 설치할 것인가</title>
<body><p>
일반적으로, 만약 패키지가 autoconf아 automake를 사용한다면, 기본값으로 설정된 설치 목적지는 몇가지 예외를 제외하고는 대부분 정확하다.
</p>
<ul>

<li>만약 여러분이 프로그램을 <path>/bin</path>, <path>/sbin/</path>, <path>/usr/bin</path> 혹은 <path>/usr/sbin</path>안에 설치하고, 해당하는 프로그램의 맨페이지를 <path>/usr/share/man</path> 트리에 들어가게 된다. 이것은 가끔 ebuild안에 <c>./configure --mandir=/usr/share/man</c> 이라고 명시함으로써 이루어질 수 있다.
</li>

<li>GNU info 파일은 그것이 <e>X11, GNOME 혹은 KDE에 관련된 프로그램이나 도구들이라 할지라도</e>, <path>/usr/share/info</path>에 있어야 한다. <path>/usr/share/info</path>가 공식적인 GNU info 파일들이 존재해야할 위치라는 것을 명심해라. 대부분의 <c>./configure</c> 스크립트들이 기본값으로 GNU info 파일들을 <c>/usr/info</c>안에 설치하기 때문에, <c>./configure</c> 와 함께 <c>--infodir=/usr/share/info</c>인자를 사용해 주어야 한다.
</li>

<li>문서 파일들은 <path>/usr/share/doc</path>안의 해당 패키지 이름, 버전, 개정번호를 반영하는 하위 디렉토리에 설치된다. 이것은 GNOME, KDE, X11그리고 콘솔용 프로그램 모두에게 적용된다. 그러나 ,몇몇 프로그램들은 추가적인 문서나 필요한 파일들을 자신들만의 목적에 의해서 <path>/usr/share</path> 구조하에 설치 할 수도 있다.
</li>

<li>X11용 프로그램들과 라이브러리들은 항상 <path>/usr/X11R6</path>가 아닌, <path>/usr</path>안에 설치되어야만 한다. 우리는 <path>/usr/X11R6</path> 계층을 <e>X 윈도우 시스템 버전 11</e>을 위하여 남겨두었다.
</li>

<li>GNOME과 KDE프로그램들은 비슷한 이유로, 모두 <path>/usr</path>에 설치되어야 한다.
</li>

</ul>
<impo>몇몇 배포판들은 GNOME과 KDE를 <path>/opt</path>안에 설치하기로 선택하였다. 이러한 데스크탑 환경들이 어느 곳에 실제로 파일들이 존재해야 하는지에 대한 표준은 존재하지 않는다. 간단함과 일치성의 이점으로, 우리는 KDE와 GNOME 패키지들을 <path>/usr</path> 계층에 설치하기로 하였다.</impo>

<p>일반적으로, 여러분은 ebuild파일들이 그들의 파일을 <path>/usr</path> 트리에 설치하도록 해야한다. <e>어떤</e> 프로그램들은 GNOME, KDE그리고 X11과 함께 컴파일과 링크되기도 하고, 그것들이 필요하지 않을 수도 있는데, 그것은 혼란을 야기할 수 있다. 우리의 해결방법은 모든 것을 <path>/usr</path>에 설치하도록 해서 ebuild 제작자들에게 모호함과 쓸데없는 복잡함을 피하도록 하였다. 프로그램 파일들이 설치되는 위치는 <c>USE</c> 변수에 특정변수가 존재하던, 존재하지 않던간에 영향을 받지 <e>않는다</e>. 따라서, 포테이지 트리안의 ebuild들은 <e>거의 대부분</e>이 항상 <path>/usr</path> 계층으로만 설치가 된다.
</p>

<note><path>/opt</path> 디렉토리는 젠투리눅스에서 바이너리로만 이루어진 패키지들을 위하여 남겨졌다. mozill-bin, acroread, netscape, realplayer등이 여기에 해당한다. 여기에 설치되는 패키지들은 <path>/etc/env.d/foo</path> 토막파일을 필요로 한다. 이것은 경로들과 기타 부가적인 변수들이 그 환경안에 포함될 수 있기 때문이다.
</note>

</body>
</section>
</chapter>

<chapter>
<title>포테이지 스크립트들과 유틸리티들</title>

<section>
<title>공용 스크립트</title>
<body><p>
패키지를 설치하거나 삭제하고, 또 패키지 데이타 베이스를 유지하기 위해 시스템 관리자에 의해서사용되는 스트립트들이 존재한다.</p>
<p><c>ebuild</c>는 포테이지 시스템의 메인 엔진이다. 그것은 소스를 풀고, 컴파일하고, 설치하고, 시스템에 합치거나 시스템에서 패키지들을 제거하는는 중요한 일들을 수행한다. ebuild는 <c>ebuild path/to/package.ebuild command</c> 형식으로 명령을 수행한다. 사용가능한 명령들은 다음과 같다.
</p>
<table>
<tr><th>명령어</th><th>설명</th><th>관련된 <c>ebuild</c> 함수</th></tr>
<tr><ti>*<c>setup</c></ti><ti>이빌드가 진행될수 있기 전에 필요한 여러 기타 명령어들을 수행한다.</ti><ti><c>pkg_setup</c></ti></tr>
<tr><ti><c>depend</c></ti><ti>패키지가 빌드되는데 필요한 의존성들을 보여준다.</ti><ti>없음</ti></tr>
<tr><ti><c>check</c></ti><ti>패키지가 의존성을 만족하는지 검사한다.</ti><ti>없음</ti></tr>
<tr><ti><c>rcheck</c></ti><ti>패키지가 실행시의 의존성을 만족하는지 검사한다.</ti><ti>없음</ti></tr>
<tr><ti><c>merge</c></ti><ti>소스를 풀고, 컴파일하고, 설치하고 여러분의 파일시스템에 패키지를 병합한다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>qmerge</c></ti><ti>소스를 풀고, 컴파일하고, 설치하는 과정들이 이미 끝났다고 가정하고, 패키지를 여러분의 파일시스템에 병합한다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>unpack</c></ti><ti>작업 디렉토리안에 소스 타르볼들의 압축을 푼다.</ti><ti><c>src_unpack</c></ti></tr>
<tr><ti>*<c>compile</c></ti><ti>패키지를 컴파일 한다.</ti><ti><c>src_compile</c></ti></tr>
<tr><ti><c>rpm</c></ti><ti>패키지로부터 RPM을 만든다.</ti><ti>없음</ti></tr>
<tr><ti><c>package</c></ti><ti>패키지로부터 젠투용 <c>tbz2</c> 패키지를 만든다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>prerm</c></ti><ti>패키지의 pre-removal 과정을 실행한다.</ti><ti><c>pkg_prerm</c></ti></tr>
<tr><ti>*<c>postrm</c></ti><ti>패키지의 post-removal 과정을 실행한다.</ti><ti><c>pkg_postrm</c></ti></tr>
<tr><ti>*<c>preinst</c></ti><ti>패키지의 pre-installation 과정을 실행한다.</ti><ti><c>pkg_preinst</c></ti></tr>
<tr><ti>*<c>postinst</c></ti><ti>패키지의 post-installation 과정을 실행한다.</ti><ti><c>pkg_postinst</c></ti></tr>
<tr><ti><c>config</c></ti><ti>이미 병합된 패키지의 기본 설정을 해준다.</ti><ti><c>pkg_config</c></ti></tr>
<tr><ti>*<c>touch</c></ti><ti>패키지안의 각각의 소스 압축파일의 mtimes을 갱신한다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>clean</c></ti><ti>패키지를 설치하면서 사용했던 작업 디렉토리를 청소한다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>fetch</c></ti><ti>패키지의 소스 타르볼을 가져온다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>digest</c></ti><ti>패키지로부터 digest 파일을 생성한다.</ti><ti>없음</ti></tr>
<tr><ti>*<c>install</c></ti><ti>이미지 디렉토리로 패키지를 설치한다.</ti><ti><c>src_install</c></ti></tr>
<tr><ti><c>unmerge</c></ti><ti>여러분의 파일시스템으로부터 패키지를 제거한다.</ti><ti>없음</ti></tr>
</table>
<p>Note: 아스테리스크(*)표시가 되어 있는 명령어들은 개발자들에 의해서만 사용된다.
</p>

<p><c>emerge</c>는 해당 패키지와 그와 관련된 의존성에 걸리는 모든 패키지들을 회귀적으로 여러분의 파일시스템에 병합한다. 이 명령어는 많은 옵션들을 가지고 있는데 <c>emerge --help</c>로 그 목록들을 확인해 보기 바란다.
</p>

<p><c>env-update</c>는 설치된 패키지들의 의해서 변화된 설정파일들(<path>/etc/ld.so.conf</path>와 <path>/etc/profile.env</path>에 의해 제한되지 않은 것들만을 포함하여)을 갱신한다.
</p>
</body>
</section>

<section>
<title>사적 스크립트들과 명령들</title>
<body>

<p>이것들은 여러분의 ebuild파일안에서 일반적인 작업들을 수행할 수 있도록 사용할 수 있는 스크립트들이다.</p>

<p>명령들에 대해 보다 자세히 알고 싶다면, <path>/usr/lib/portage/bin</path>안에 있는 해당 스크립트들의 내용을 직접 보면 된다.
</p>

<table>
<tr><ti>into</ti><ti>for <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, <c>domo</c>, <c>dosbin</c>를 위한 목표경로(<path>DESTTREE</path>)를 설정한다.</ti></tr>
<tr><ti>dobin</ti><ti>지정된 바이너리 파일을 <path>DESTTREE/bin</path>에 설치한다.</ti></tr>
<tr><ti>dodoc</ti><ti> (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) where <path>DOCDESTREE</path> is settable with <c>docinto</c></ti></tr>
<tr><ti>doexe</ti><ti>지정된 파일을 <e>EXEOPTIONS</e>모드로 <path>EXEDESTTREE</path>에 설치한다. <e>EXEOPTIONS</e>의 기본값은 -m0755 이며 <c>exeopts</c>명령어를 통해 설정할 수 있다.  <path>EXEDESTTREE</path>는 <c>exeinto</c>명령어를 통해 설정할 수 있다.</ti></tr>
<tr><ti>dohard</ti><ti>하드링크를 생성하고, ${D}를 transparently하게 다룬다.</ti></tr>
<tr><ti>dohtml</ti><ti>지정된 파일과 디렉토리들을 <path>/usr/share/doc/${PF}/html</path>에 설치한다.</ti></tr>
<tr><ti>doinfo</ti><ti>지정된 파일들을 <path>/usr/share/info</path>에 설치하고, 그 파일들을 gzip으로 압축한다.</ti></tr>
<tr><ti>doins</ti><ti>지정된 파일들을 <e>INSOPTIONS</e>모드로 <path>INSDESTTREE</path>에 설치한다. <e>INSOPTIONS</e>의 기본값은 -m0644이며 <c>insopts</c>명령어를 통해 설정할 수 있다.  <path>INSDESTTREE</path>는 <c>insinto</c>명령어를 통해 설정할 수 있다.</ti></tr>
<tr><ti>dolib</ti><ti>지정된 라이브러리들을 <e>LIBOPTIONS</e>모드로 <path>DESTTREE/lib</path>에 설치한다. <e>LIBOPTIONS</e>의 기본값은 -m0644이며 <c>libopts</c>명령어를 통해 설정할 수 있다</ti></tr>
<tr><ti>dolib.a</ti><ti>지정된 라이브러리들을 <path>DESTTREE/lib</path>에 0644모드로 설치한다.</ti></tr>
<tr><ti>dolib.so</ti><ti>지정된 라이브러리들을 <path>DESTTREE/lib</path>에 0755모드로 설치한다.</ti></tr>
<tr><ti>doman</ti><ti>지정된 파일들을 X접두어에 따라 <path>/usr/share/man/manX</path>에 설치한다.</ti></tr>
<tr><ti>domo</ti><ti>지역화된 메시지 데이타들을 담고 있는 .mo 파일들을 손수 설치하는데 사용된다.</ti></tr>
<tr><ti>donewins</ti><ti><c>newins</c>과 동일하지만, 실제로 심볼릭 링크를 생성한다. 이것은 사용이 권장되지 않고, 그저 이전 버전의 이빌드들과 호환을 위해 존재한다. 대신 <c>newins</c>를 사용하기 바란다.</ti></tr>
<tr><ti>dosbin</ti><ti>바이너리를 실행가능하도록 하여, <path>DESTTREE/sbin</path>에 설치한다</ti></tr>
<tr><ti>dosed</ti><ti>removes all occurences of ${D} (the installation prefix path) in the specified files</ti></tr>
<tr><ti>dosym</ti><ti>심볼릭 링크를 생성한고, ${D}를 transparently하게 다룬다.</ti></tr>
<tr><ti>emake</ti><ti>make를 병렬적으로 수행한다. 어떤 프로젝트들은 병렬적으로 수행이 안될 수 있으므로 그럴 때는 make를 사용한다.</ti></tr>
<tr><ti>fowners</ti><ti>chown 명령어를 통해서 지정된 소유권(첫번째 인자)을 지정된 파일(두번째 인자)에 적용하고, ${D}를 transparently하게 다룬다.</ti></tr>
<tr><ti>fperms</ti><ti>chmod 명령어를 통해서 지정권 권한(첫번째 인자)을 지정된 파일(두번째 인자)에 적용하고, ${D}를 transparently하게 다룬다.</ti></tr>
<tr><ti>newbin</ti><ti><path>DESTTREE/bin</path>에 지정된 바이너리(첫번째 인자)를 설치하는 <c>dobin</c>을 감싸고 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newdoc</ti><ti><path>/usr/share/doc/${PF}/DOCDESTTREE</path>안에 지정된 파일(첫번째 인자)을 설치하는 <c>dodoc</c>를 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newexe</ti><ti><path>EXEDESTTREE</path>안에 EXEOPTIONS로 지정된 파일을 설치하는 <c>doexe</c>를 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newins</ti><ti><path>INSDESTTREE</path>안에 INSOPTIONS로 지정된 파일을 설치하는 <c>doins</c>를 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newlib.a</ti><ti><path>DESTTREE/lib</path>안에 지정된 라이브러리를 설치하는 <c>dolib.a</c>를 감싸고, 두번째 일자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newlib.so</ti><ti><path>DESTTREE/lib</path>안에 지정된 라이브러리를 설치하는 <c>dolib.so</c>를 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newman</ti><ti><path>/usr/share/man/manX</path>에 지정된 파일을 설치하는 <c>doman</c>을 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>newsbin</ti><ti><path>DESTTREE/sbin</path>에 지정된 파일을 설치하는 <c>dosbin</c>를 감싸고, 두번째 인자로 이름을 transparently하게 바꾼다.</ti></tr>
<tr><ti>pmake</ti><ti>권장되지 않음. emake를 대신 사용하기 바란다.</ti></tr>
<tr><ti>prepalldocs</ti><ti><path>/usr/share/doc</path>에 있는 모든 doc 파일들을 재귀적으로 gzip 압축을 하고, 심볼릭 링크 경로를 transparently하게 수정한다.</ti></tr>
<tr><ti>prepallinfo</ti><ti><path>/usr/share/info</path>에 있는 모든 info 파일들을 재귀적으로 gzip압축을 한다.</ti></tr>
<tr><ti>prepallman</ti><ti><path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>, <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path>에 있는 모든 맨페이지를 재귀적으로 gzip압축을 하고, 심볼릭 링크 경로를 transparently하게 수정한다.</ti></tr>
<tr><ti>prepall</ti><ti><c>prepallman</c>, <c>prepallinfo</c> and <c>prepallstrip</c>를 감싼다. 또한, <path>/opt/*/lib</path>, <path>/lib</path>, <path>/usr/lib</path> 그리고 <path>/usr/X11R6/lib</path>에 있는 파일들이 실행가능하도록 한다. 잘못 위치한 aclocal 매크로들을 <path>/usr/share/aclocal</path>로 옮긴다.</ti></tr>
<tr><ti>try</ti><ti>권장되지 않음. 대신 || die 구조를 사용하기 바란다.</ti></tr>
</table>
</body>
</section>
</chapter>

<chapter>
<title>패키지 의존성들</title>

<section>
<title>어째서 의존성이 중요한가</title>
<body>
<p>
포테이지는 단순히 소스로 부터 하나의 프로젝트(프로그램, 라이브러리)를 빌드하는 방법을 일원화 해주는 스크립트 이상의 의미가 있다. 포테이지는 만약 여러분의 ebuild에서 신경쓰고 있는 의존성들이 필요하다면 ,해당 패키지를 다운받아 설치한다.
</p>

<p>
공식적인 ebuild들에는, 모든 의존성이 이미 지정되어 있다. 그래서 여러분이 <c>emerge net-www/mozilla/mozilla-1.0</c>이라고 명령을 내리면, 포테이지는 모질라 자신을 빌드하기 전에 모질라가 빌드되고 설치되는데 필요한 모든 라이브러리들이 존재하도록 보증할 것이다.
</p>

<p>
포테이지는 심지어 빌드시의 의존성과 실행시의 의존성도 구분한다. (예고: 현재, 포테이지는 모든 빌드시 의존성과 실행시 의존성을 설치하고 그대로 둔다. 다음에는 여러분의 설치시에 필요없는 부분은 삭제 되도록 하기 위해서 오직 실행시 의존성만이 남아있도록 할 것이다.)
</p>

</body>
</section>

<section>
<title>여러분의 이빌드 파일들안에 어떻게 의존성을 선언할 것인가</title>
<body>
<p>
여러분의 <path>foo-x.y.z.ebuild</path> 파일안의 <c>DEPEND</c> 변수는 포테이지에게 <path>foo</path>를 빌드하기 위해서 필요한 패키지들에 대해서 이야기해 준다. <c>RDEPEND</c> 변수는 <path>foo</path>가 실행되기 위해서 필요한 패키지들을 지정한다.

예:</p>
<pre>
DEPEND="virtual/glibc
        sys-libs/zlib"
RDEPEND="virtual/glibc"
</pre>

<p>
이 예는 포테이지에게 <path>foo-x.y.z</path>를 필드하기 위해 <path>virtual/glibc</path>과 <path>sys-lib/zlib</path>이 필요하다고 이야기 한다. 하지만, 필요로 하는 glibc나 zlib의 버전에 대해서는 아무런 언급이 없는데, 이런경우는 "anything goes"를 의미한다.</p>

<p>
"anything goes"는 물론 조금 무섭고, 일반적으로 잘 수행되지 않는다. 그러나, glibc같은 핵심 라이브러리같은 경우는 항상 100% 바이너리 호환이 되려고 매우 열심히 노력하기 때문에, 실제로 동작한다. 물론, 다른 라이브러리들에서 우리는 의존성 패키지들의 버전을 선언할 수 있다. 다음과 같은 여러 방법들이 존재한다.</p>
<pre>
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= 과 =는 여러분이 원하는 것을 수행한다. sys-apps/bar 는 버전 1.2혹은 그 이상의 버전(sys-apps/bar-2.0도 좋다는 의미이다.)이 좋다는 뜻이고, sys-apps/baz는 오직 버전 1.0만 수락된다.</p>

<p>
포테이지는 네가지 특별한 버전 번호를 나타내는 접두사를 인식한다. <c>-rX</c>, <c>-preX</c>, -<c>alphaX</c>, <c>-betaX</c> 네가지 이며, X는 숫자가 들어간다(여러분이 원하는 만큼 많은 숫자). <c>&gt;=sys-apps/foo-1.0</c>에 대한 파일들은 다음과 같다.
</p>
<pre>
sys-apps/frob-1.0-r1
sys-apps/frob-1.0
sys-apps/frob-1.0_pre1
sys-apps/frob-1.0_beta1
sys-apps/frob-1.0_alpha1
</pre>
<p>
포테이지는 리스트를 내부적으로 정렬하고 가장 위에 것을 고른다. 이것은 <c>_alphaX</c>보다는 <c>_betaX</c>를, <c>_betaX</c>보다는 <c>_preX</c>를, <c>_prex</c>보다는 접미사가 없는 것을, 접미사가 없는것 보다는 <c>-rX</c>를 고른다는 의미이다.</p>

<p>버전 의존성을지정하는 또다른 방법은 다음과 같다.</p>
<pre>
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
</pre>

<p>~sys-apps/qux-1.0 는 qux-1.0의 최신 revision을 선택한다.</p>

<p>=sys-apps/foo-1.2* 는 1.2 시리즈의 최신 멤버를 선택하는데, 1.3이나 그 이후의 시리즈들은 무시한다. 즉, foo-1.2.3과 foo-1.2.0은 둘다 유효한 반면, foo-1.3.3과 foo-1.3.0은 그렇지 않다.</p>

</body>
</section>
</chapter>

<chapter>
<title>시험과 배치</title>

<section>
<title>ChangeLog</title>
<body>
<p>언제든지 여러분이 ebuild를 갱신(혹은 새로운 것을 만들든지)할 때, 여러분은 반드시 해당 ebuild의 ChangLog를 같이 갱신(혹은 새로운것을 만들든지)해야 한다. <path>skel.ChangeLog</path> 에는 여러분이 기본적으로 사용할 수 있는 ChangeLog의 예제이다.
</p>

<p>ChangeLog의 목적은 해당 버전에서 <i>무엇</i>이 이루어졌고, 그것이 <i>왜</i> 되었으며, <i>누구</i>에 의해 되었는지 문서화하기 위한 것이다. 이것은 개발자와 사용자 모두가 개발과정의 변화를 추적해 보는것을 쉽게 해준다.</p>

<p>ChangeLog는 기본적으로 사용자를 목표로 한다. 따라서 간단하고, 핵심만을 짚어서, 내부적인 기술에 대해 상세히 설명하는 것을 피해서 작성해야 한다.</p>
</body>
</section>

<section>
<title>쓸만한 시험 도구들</title>
<body>
<p>우리는 여러분들의 이빌드들을 작성하고 유지하는데 도움이 될만한 몇가지 도구들을 가지고 있다.</p>

<warn><c>libtool</c>에 대한 또다른 경고로, 현재 사용할 수가 없으므로, repoman을 대신 사용하기 바란다.
</warn>
<ul>
<li><c>lintool</c> - ebuil들과 ChangeLog들, 그리고 digest파일들의 문법이 정확한지를 검사한다.
</li>
<li><c>change</c> - 새로운 ChangeLog파일을 만들거나 이미 존재하는 파일에 내용을 추가할수 있다.</li>
<li><c>gentool-bump-revision</c> - 개정 번호를 교체하는 개발자 전용 툴로써, CVS에 새로운 개정판을 추가하고, 이전 개정판을 삭제한 후 ChangeLOg를 갱신한다.
</li>
<li><c>repoman</c> - CVS checkin 수행을 도와주는 개발자 전용 툴이다.
</li>
</ul>
</body>
</section>
</chapter>
</guide>
