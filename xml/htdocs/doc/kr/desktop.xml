<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/kr/desktop.xml">
	<title>젠투 리눅스 데스크탑 설정 가이드
	</title>
		<author title="Author"><mail link="zhen@gentoo.org">John P. Davis</mail></author>
		<author title="Author"><mail link="g2boojum@gentoo.org">Grant Goodyear</mail></author>
		<author title="번역"><mail link="sarang4u@empal.com">이만우(나빌레라)</mail></author>
                <author title="Moderator"><mail link="seo@gentoo.org">Jungmin Seo</mail></author>

	<abstract>
		이 문서는 젠투 리눅스를 전천후로 사용가능한 데스크톱 시스템으로 설정하는 과정을 보여준다.
		자세히 말해서, X , KDE, GNOME, OSS(소리드라이버), postfix(이메일프로그램), samba 등을 인스톨하고 설정하게 될것이다.
		
	</abstract>

	<version>1.0</version>
	<date>21 November 2002</date>

	<chapter>
		<title>Preliminaries</title>
			<section>
			
				<body>
			
				<p>
				데스크탑을 설정하려면, 우선 젠투를 설정해야한다.(역주: 당연하지..-.-;)
				<uri>http://www.gentoo.org/doc/kr/build.xml</uri> 을 참조해서 설치한다.
				즐거운(?) 설치가 끝나고 나면, <e>포테이지</e>트리를 다운로드 해야 한다.
				포테이지 유저 가이드 (<uri>http://www.gentoo.org/doc/kr/portage-user.xml</uri>)를 읽어보는것이 좋을것이다.
				포테이지 가이드를 읽기 전에 먼저 아래와 같이 타이핑 해놓고 읽어라.
				
				</p>
			
				<pre caption = "Getting Current">
# <c>emerge sync</c>
				</pre>

				<p>
				간단하게, 필요한 몇몇 패키지에 대해서 설명을 하자면. 젠투 리눅스는 상당히 훌륭한 패키지 매니저를 가지고 있다. 이메일 에이전트 같은 프로그램들을 아주 쉽게 인스톨 할 수 있다. 여기서 설명하는 특정한 패키지들은 젠투 리눅스에서 우선적으로 설치해야할것들이 아니라, 필자가 쉽게 설정할 수 있는 단순한 패키지들이다. 
				다시말해서, 이 문서의 데스크탑 설정은 저자 특유의 데스크탑 설정법이다.
				(역주: 즉, 데스크탑 설정은 여러분의 취향에 따라서 아주 다양하게 할 수 있다는 말 이다.)

				</p>

				<impo>
				인스톨을 할때의 의존선 설정이나, 여러분이 설치하면서 패키지의 다른 지원 내용을 설정해제 하고 싶을때, <path>/etc/make.conf</path> 의 <i>USE</i> 섹션을 수정해주면 된다. 예를 들어서 KDE를 쓰고 싶으면 <e>-gnome -gtk</e> 라고 추가하고, 그놈을 쓰고 싶으면 <e>-kde -qt</e> 라고 추가 한다. (역주: 자세한 내용은 USE 사용 가이드를 참고하기 바란다.)

				</impo>

			</body>
		</section>
	</chapter>

	<chapter>
	<title>Installing XFree86</title>
		<section>
			<title>Installation</title>

			<body>

			<p>
			X 를 빌드 하는 과정은, 매우 빠른 시스템에서도 얼마간의 시간이 걸린다. X 자체가 상당히 크므로, 미리 책을 준비해 두던지, 잠을자던지 하는것이 좋겠다.

			</p>

			<p>
			X를 emerge 하는데 필요한 명령은 아래 한줄이 전부 다 이다.^^;

			</p>

			<pre caption = "Emerging XFree86">
# <c>emerge xfree</c>
			</pre>

			<p>
			이 긴 과정이 끝나면 비로소, 데스크탑 설정이 시작된다.

			</p>

			</body>
		</section>

		<section>
			<title>Configuring X</title>

			<body>

			<p>
			이 문서의 저자는 콘솔 기반의 <c>xf86config</c> 를 이용해 X 를 설정하는 것을 즐긴다고 한다. 하지만, 생성되는 <path>/etc/X11/XF86Config</path> 파일의 내용이 그렇게 세련되지 않다. <uri link="http://www-105.ibm.com/developerworks/education.nsf/
			linux-onlinecourse-bytitle/3100FF4795B3F31F86256AF70056FDB3?OpenDocument"> tutorial</uri> 을 참조해서 X 설정을 좀더 철저하게 하기 바란다. 
			설정을 시작하기 전에, 여러분의 모니터의 수직/수평주파수와 주사율등을 미리 알아둘 필요가 있다. (저자의 G773모니터의 경우에는 수평주파수:30-69, 수직주파수 55-90 이라고 한다.)그리고, 여러분의 비디오카드의 비디오램과 여러분의 마우스 종류등을 알아둘 필요가 있다.

			
			</p>

			<pre caption = "Running xf86config">
# <c>/usr/X11R6/bin/xf86config</c>
			</pre>

			<p>
			저자의 경우 세버튼 마우스를 사용하기때문에, 3-button emulation 기능을 활성화 할필요는 없었다. XKB 지원은 여러분의 키보드로 여러 언어를 지원할 수 있게 해준다. 
			여러분은 모니터 해상도와 pixel depth등을 미리 생각해둘 필요가 있다. 저자의 경우 1280x1024해상도에 24dpp 로 설정을 했다. <c>xf86config</c> 는 여러가지 경우로 설정할 수 있다.

			</p>

			<note>
			여러분의 모니터에 대한 주사율등을 모른다면, 구글<uri>http://www.google.com</uri> 에서 검색해서 모델 번호나 모델 이름을 보고, 관련 정보를 찾으면 된다. 주사율등은 보통 모델의 스펙문서등에 나와 있다.

			</note>

			<p>
			만약 여러분이 X-설정의 베테랑이라면, <path>/dev/mouse</path> 에 여러분이 사용하는 마우스 종류에 맞는 장치를 심볼릭 링크 걸어 놨을 것이다. 이 심볼릭 링크가 틀릴경우, devfs를 사용한다면, 재부팅후에, 맛이가버리는 현상이 발생한다. <path>/dev</path> 안의 심볼릭 링크들은 정확히 걸어야 한다. <path>/dev/mouse</path> 를 <c>ln -s</c> 를 이용해 만든다.

			</p>

			<pre caption = "Testing your Configuration">
# <c>startx</c>
			</pre>
			
			<p>
			X의 각종 설정을 마치고, <c>startx</c> 를 실행해보면, 여러분은 놀랍도록 못생긴 X 윈도우 메니저(twm..-.-)를 보게 될것이다. X 가 뜬 다음에는 <c>&lt;ctrl&gt;&lt;alt&gt;&lt;backspace&gt;</c> 를 눌러서 X 를 죽이고 콘솔로 갈 수 있다.

			</p>

			<p>
			<c>xf86config</c> 는 기본적인 설정 사항들만으로 만들어 진다. NVIDIA 카드나, USB 장치들은 수동으로 장치를 설정해 주어야 한다. 이제부터 이 옵션들에 대해 하나씩 설명을 하겠다. <i>XF86Config</i> 파일은 그렇게 어렵지 않으니 용기를 가져라. 이 파일은 암호화 되어 있지도 않을 뿐더러 여러분은 세팅하면서 흥미있는것들을 발견하게 될것이다. <uri link = "http://www.tldp.org/HOWTO/mini/FDU/">여기</uri>를 보면 아주 좋은 정보를 얻을 수 있을 것이다.

			</p>

			</body>
		</section>

			<section>
				<title>Configuring a PS/2 Mouse</title>

				<body>
				
				<p>
				만약 휠마우스를 가지고 있다면, 아래와 같이 설정한다. 

							</p>
				
				<pre caption = "Editing XF86Config">
# <i>cp /etc/X11/XF86Config /etc/X11/XF86Config.working</i>
# <i>vim /etc/X11/XF86Config</i>
				</pre>
				
				<pre caption="Pointer section of XF86Config">
Section "InputDevice"

#Identifier and driver

Identifier	"Mouse1"
Driver	"mouse"
<i>Option "Protocol"    "IMPS/2" </i>
Option "Device"      "/dev/psaux"
<i>Option "ZAxisMapping"	"4 5"</i>
				
				</pre>
				
				<p>
				"PS/2"를 "IMPS/2"로 바꾼것은 인텔리 마우스를 쓰기 때문이다. (역주: 사실 휠을 쓰기 위해선 IMPS/2 로 해야 한다.) 'Option "ZAxisMapping" "4 5"' 은 휠로 스크롤할때 필요한 옵션이다. '4'와 '5'는 휠을 올리거나 내릴때의 속도를 설정한다.

				</p>
				
				<note>
				넷츠케이프 4.x 버전에서는 기본으로 휠 스크롤을 지원하지 않는다.(역주: 요즘도 넷츠4.x쓰는 사람 있나?-.-) 여러분은 .Xdefaults파일을 먼저 만들어야 한다. <uri link="http://www-sop.inria.fr/koala/colas/mouse-wheel-scroll/">여기</uri>를 참조해라. 더 좋은 방법은 <c>konqueror</c>, <c>opera</c>,
				<c>mozilla</c>, <c>galeon</c> 를 사용하는 것이다.

				</note>

				<p>
				<c>startx</c>를 다시 실행하면 X 가 뜬다.

				</p>

			</body>
		</section>

		<section>
			<title>Configuring a USB Mouse</title>

			<body>
			
			<p>
			USB마우스는 고해상도 스크린에 어울린다. 커널에서 자동으로 비율을 맞춰주기 때문에, 여러분은 모니터를 가로질러 갈때, 마우스를 패드에서 다섯번씩 긁어대지 않아도 된다.

			</p>

			<p>
			먼저 해야 할일은, 커널 모듈을 인스톨 하는 일이다. <i>usbmouse</i>, <i>mousedev</i>, <i>hid</i>, 
			<i>usbcore</i>, <i>usb-uhci</i>, <i>input</i> 의 모듈들을 인스톨하면 된다. 필요한 커널 설정이 끝나고 나면 <i>insmod</i> 명령으로 모듈을 올린다.

			</p>

			<note>
			커널에서 Input Core support for the mouse 를 설정하면, X 에서 사용할 해상도를 정해줘야 한다. 이 해상도를 이용해 나중에 마우스 커서의 정확한 비율을 계산해준다. 

		</note>

			<p>
			마우스를 올렸다가, 다시 내리고 나서, 커널 로그 메시지가 제대로 기록되었는지를 확인 해 본다. 

			</p>

			<pre caption = "Kernel Message">
hub.c: USB new device connect on bus1/1, assigned device number 2
input0,hiddev0: USB HID v1.00 Mouse [Microsoft Microsoft IntelliMouse Optical] on usb1:2.0
			</pre>

			<p>
			마우스를 찾고 나면, <path>/dev/input</path> 를 확인해서 여러분의 마우스가 제대로 찾아졌는지, 제대로 작동하는지를 본다.

			</p>

			<pre caption = "Checking for USB Mouse">
# <c>cd /dev/input</c>
# <c>cat mouse0</c>
<comment><i>cat</i> 명령으로 디바이스를 확인할때 마우스를 움직이면, 여러분은 엄청나게 많은 쓰레기 메시지를 보게 될것이다. </comment>
			</pre>

			<p>
			마우스가 적절하게 찾아졌고, 설치되었으면, 우리는 X를 USB마우스를 이용해서 사용할 수 있다. X에서 해야하는 일은 X가 USB마우스를 이용할 수 있도록 설정하는 일이 전부이다.

			</p>

			<pre caption = "Editing XF86Config">
# <c>cp /etc/X11/XF86Config /etc/X11/XF86Config.working</c>
# <c>vim /etc/X11/XF86Config</c>
			</pre>

			<pre caption="Pointer section of XF86Config">
Section "InputDevice"

# Identifier and driver

Identifier	"Mouse1"
Driver	"mouse"
<i>Option "Protocol"    "IMPS/2" </i>
Option "Device"      "/dev/input/mouse0"
<i>Option "ZAxisMapping"	"4 5"</i>

			</pre>

			<p>
			X를 재시작하면, 마우스가 움직일것이다.

			</p>
			<p>
			<i>modules.autoload</i> 에 모듈을 등록하는걸 잊으면 안된다.

			</p>

			<pre caption = "Adding entries to modules.autoload">
# <c>echo $'/n'usbmouse $'/n'mousedev $'/n'hid #'/n'usbcore $'/n'input >> /etc/modules.autoload</c>
			</pre>

			</body>
		</section>

		<section>
			<title>Configuring your NVIDIA Card</title>
			
			<body>
			<p>
			만약 NVIDIA 카드를 가지고 있을 경우, NVIDIA 가속 드라이버를 설치한다.

			</p>

			<note>
			만약 커널 컴파일을 다시한다면, <i>nvidia-kernel</i> 도 다시 컴파일 해야 한다. 왜냐면 커널컴파일을 다시 하면 모듈인스톨 과정에서 기존의 nvidia드라이버를 지워버리기 때문이다.

			</note>
			
			<pre caption="NVIDIA owners only">
# <c>emerge nvidia-glx</c>
# <c>emerge nvidia-kernel</c>
# <c>nano -w /etc/X11/XF86Config</c>
			</pre>
			
			<pre caption="Enabling GLX in /etc/X11/XF86Config">
Section "Module"

# This loads the GLX module
#    Load       "glx" <comment>(Uncomment this line)</comment>
			</pre>
			
			<pre caption="Tell X to use the NVIDIA driver in /etc/X11/XF86Config">
Section "Device"
	Identifier  "NVIDIA GeForce"
	#Driver      "nv"
	Driver      "nvidia"
	#VideoRam    32768
	# Insert Clocks lines here if appropriate
EndSection
			</pre>

			<p>
			<c>startx</c> 해서 X를 다시 실행하면, NVIDIA 스플래시 화면이 먼저 뜬다. 그럼 설치가 완료 된것이다.

			</p>

			</body>
		</section>
	</chapter>

	<chapter>	
		<title>Window Managers</title>

		<section>
			<title>Introduction</title>
			<body>

			<p>
			일반적으로, X를 인스톨 하고나면 가장 먼저하는 일이 이쁜 윈도우 메니저를 인스톨 하는 일이다. 물론 당신이 정말로 못생긴 윈도우매니저를 원한다면 tvm을 그대로 쓸 수도 있다. 
			단지 윈도우 매니저의 기능만을 사용할 뿐이라면 tvm도 괜찮다.

			</p>

			<p>
			윈도우 매니저는 그 종류가 매우 많다. KDE,
			GNOME, Fluxbox, Blackbox, *box가 들어간것들, 'es 인애들, Windowmaker, Sawfish, 등등.
			보시다시피, 젠투에서는 이 모든 윈도우매니저들을 선택해서 사용할 수 있다.

			</p>
		
			</body>
		</section>
	
		<section>
			<title>KDE</title>
			<body>

			<p>
			이 섹션을 읽고 있다면 당연히 여러분들은 KDE를 설치하려 할것이다. 젠투에서는 KDE의 모든것을 지원한다. 그러려면 KDE를 emerge하기 전에 아래 두가지 일을 해주어야 한다.

			</p>
			
			<li>
			<i>make.conf</i> 파일안에 "qt" 와 "kde" 를 USE 변수로 추가한다. 
			</li>
			<li>
			<i>make.conf</i> 안에 "-gnome" 과 "-gtk" 를 USE 변수로 추가한다. (선택사항) 
			</li>
			
			<p>
			두개의 과정을 모두 거치고 나면 <path>/etc/make.conf</path>파일은 아래처럼 고쳐질것이다.

			</p>

			<pre caption = "Editing make.conf">
# <c>vim /etc/make.conf </c>
<comment><i>make.conf</i>안에..</comment>

USE="qt kde -gnome -gtk"
				
			</pre>

			<p>
			보다 많은 USE변수를 알고 싶으면 <uri link="http://www.gentoo.org/doc/kr/use-howto.xml">USE HOWTO</uri> 레퍼런스를 보기 바란다.

			</p>
			
			<p>
			<c>emerge</c> 를 하기전엔 언제나 <c>--pretend</c> 를 하는것이 좋다. 그러면 해당 패키지에 의존성이 걸린 패키지들의 목록을 볼 수 있다. KDE를 빌드하는 경우에는 상당히 많은 분량의 의존성 패키지들이 검출된다.

			</p>

			<pre caption = "Looking at KDE Packages/Deps">
# <c>emerge --pretend kde</c>
# <c>emerge kde</c>
			</pre>

			<note>
			<i>emerge kde-base</i> 를 할때는 상당히 조심하기 바란다. 이렇게 하면 오로지 KDE 베이스 패키지만을 인스톨한다. 다른 KDE관련 어플리케이션은 설치되지 않는다.

			</note>

			<note>
			만약 CUPS를 사용할 생각이라면, emerge 하기 전에 <path>/etc/make.conf</path> 파일의 USE 변수에 "cups"를 추가 한다. 이것은 커맨드 라인에서 <i>USE="cups" emerge kde </i> 라고 하는것과 같은 효과를 준다. Gentoo Print Guide for a complete CUPS 를 보면 인스톨에 대한 설명이 나온다.

			</note>

			<p>
			낮잠한숨 자고 나면 빌드가 될것이다.

			</p>

			<note>
			만약 젠투 바이이너리 CD로 설치한다면, CD에서 바로 인스톨 할 수도 있다.

			</note>
			
			<pre caption="Installing binary packages from the CD">
# <c>export PKGDIR=/mnt/cdrom/gentoo/packages</c>
<comment>
일반적인 경우라면, /usr/portage/package 에서 eubild를 찾는다.

</comment>
# <c>emerge --usepkg /mnt/cdrom/gentoo/packages/All/kdebase-x.y.z.tbz2</c>
<comment>
<c>--usepkg</c> 플래그는 바이너리패키지안에서 의존성을 검사하도록 해준다. (가능하다면)

</comment>
			</pre>

			</body>
		</section>

		<section>
			<title>Configuring KDM</title>
			<body>
			
			<p>
			KDE를 인스톨하고 나면, 보다 예쁜 로그인매니저를 사용하는것이 좋다. KDE login manager의 약자로 KDM이라고 불리우는 것인데, KDE패키지안에 포함되어 있다. 아래와 같은 명령으로 실행한다.

			</p>
			
			<pre caption = "Running KDM">
# <c>kdm</c>
			</pre>
			
			<p>
			모든 작업을 마치고, KDE에 로그인하면, KDE를 볼 수 있다.
			물론 아직 소리는 나지 않는다. 그래서 아직 KDE의 시작소리를 들을 수 없다. 그러나
			잠시후에 그것에 대한 수정작업을 할 것이다.(역주: 기다리시라..). konsole 을 열고,
			<c>ls /usr/bin</c> 이라고 입력하고서 마우스의 휠을 움직이면, 화면이 따라서 스크롤 되는것을 볼 수 있다. (그외에도 콘솔에서 동작하는 모든 명령이 다 제대로 동작한다.)
			모든것이 제대로 동작하는 것이다!

			</p>
			
			<note>
			<c>kdm</c> 를 실행했을때, "command not found" 가 떨어지면, $PATH환경변수를 손보기 바란다. <c>source
			<path>/etc/profile</path></c> 라고 입력하면, 수정될것이다.

			</note>

			<p>
			젠투가 부팅할때 X 가 시작되게 하려면, <path>/etc/rc.conf</path> 에
			<e>DISPLAYMANAGER="kdm"</e> 를 입력하면 된다.
			</p>
			
			<pre caption = "Editing /etc/rc.conf">
# <c>vim /etc/rc.conf</c>
			</pre>
			
			<pre caption="/etc/rc.conf -- setting DISPLAYMANAGER">
# What display manager do you use ?  [ xdm | gdm | kdm ]
DISPLAYMANAGER=kdm
			</pre>
			
			<p>
			단지 <e>xdm</e> 만 시작 스크립트에 추가하면 된다. 

			</p>
			
			<pre caption = "Adding XDM script to default runlevel">
# <c>rc-update add xdm default</c>
			</pre>
			
			<p>
			재부팅하고 나면 X/KDE 가 띄워진걸 볼 수 있다.

			</p>
			
			<impo>
			<c>rc-update</c> 명령은 유서깊은(?) <c>chkconfig</c> 명령을 젠투리눅스에서 발전시킨 init스크립트 관리 명령어 이다. <c>rc-update</c>만 입력하면, 사용할 수 있는 옵션의 목록이 출력된다.

			</impo>
		
			</body>
		</section>
	</chapter>

	<chapter>
		<title>GNOME</title>

		<section>
			<title>Installation</title>
			<body>

			<p>
			GNOME패키지를 인스톨 하기 전에, USE 변수를 수정해야 한다. 그래야만 GNOME 을 지원하는 어플리케이션을 컴파일할때, GNOME이 있다는걸 알려줄 수 있다.

			</p>
			
			<li>
			<i>make.conf</i> 파일에 "gtk"와 "gnome"을 USE 변수안에 넣는다.

			</li>
			<li>
			<i>make.conf</i> 파일에 "-kde" "-qt" 를 USE 변수에 넣는다.

			</li>
			
			<p>
			두단계를모두 거치고 나면 <path>/etc/make.conf</path> 는 아래처럼 된다.

			</p>

			<pre caption = "Editing make.conf">
# <c>vim /etc/make.conf </c>
<comment><i>make.conf</i>파일 안에...</comment>

USE="gnome gtk -kde -qt"
				
			</pre>

			<p>
			보다 많은 USE변수를 알고 싶으면 <uri link="http://www.gentoo.org/doc/kr/use-howto.xml">USE HOWTO</uri> 레퍼런스를 보기 바란다.

			</p>

			<p>
			GNOME 패키지를 인스톨 한다.

			</p>

			<pre caption = "Installing the GNOME Packages">
# <c>emerge --pretend gnome</c>
# <c>emerge gnome</c>
			</pre>

			<p>
			이 작업이 잘 돌아가고 있는 동안에, 돌려차기나(?) 영화를 감상하면 된다.
			저자는 Pulp Fiction(역주: 영화제목인가?) 을 추천한다.

			</p>

			<p>
			GNOME 의 설정은 기본적으로 KDE와 비슷하다.
			GNOME의 특별한 설정파일은 없고, GDM (GNOME login manager) 정도만 셋업하면 된다.

			</p>

			</body>
		</section>

		<section>
			<title>Configuring GDM</title>
			<body>

			<p>
			GNOME을 인스톨하고 나면, 보다 예쁜 로그인매니저를 사용하는것이 좋다. GNOME login manager의 약자로 GDM이라고 불리우는 것인데, GDE패키지안에 포함되어 있다. 아래와 같은 명령으로 실행한다.

			</p>
			
			<pre caption = "Running GDM">
# <c>gdm</c>
			</pre>
			
			<p>
			모든 작업을 마치고 나면 GDM을 볼 수 있다.
			물론 아직 소리는 나지 않는다. 그래서 아직 GNOME의 시작소리를 들을 수 없다. 그러나
			잠시후에 그것에 대한 수정작업을 할 것이다.(역주: 기다리시라..). console 을 열고,
			<c>ls /usr/bin</c> 이라고 입력하고서 마우스의 휠을 움직이면, 화면이 따라서 스크롤 되는것을 볼 수 있다. (그외에도 콘솔에서 동작하는 모든 명령이 다 제대로 동작한다.)
			모든것이 제대로 동작하는 것이다!

						</p>
			
			<note>
			<c>gdm</c> 를 실행했을때, "command not found" 가 떨어지면, $PATH환경변수를 손보기 바란다. <c>source
			<path>/etc/profile</path></c> 라고 입력하면, 수정될것이다.

			</note>

			<p>
			젠투가 부팅할때 X 가 시작되게 하려면, <path>/etc/rc.conf</path> 에
			<e>DISPLAYMANAGER="gdm"</e> 를 입력하면 된다.

			</p>
			
			<pre caption = "Editing /etc/rc.conf">
# <c>vim /etc/rc.conf</c>
			</pre>
			
			<pre caption="/etc/rc.conf -- setting DISPLAYMANAGER">
# What display manager do you use ?  [ xdm | gdm | kdm ]
DISPLAYMANAGER=gdm
			</pre>
			
			<p>
			단지 <e>xdm</e> 만 시작 스크립트에 추가하면 된다.

			</p>
			
			<pre caption = "Adding XDM script to default runlevel">
# <c>rc-update add xdm default</c>
			</pre>
			
			<p>
			재부팅하고 나면 X/GNOME이 띄워진걸 볼 수 있다.

			</p>
			
			<impo>
			<c>rc-update</c> 명령은 유서깊은(?) <c>chkconfig</c> 명령을 젠투리눅스에서 발전시킨 init스크립트 관리 명령어 이다. <c>rc-update</c>만 입력하면, 사용할 수 있는 옵션의 목록이 출력된다.

			</impo>
		
			</body>
		</section>
	</chapter>

	<chapter>
		<title>Sound Configuration</title>
			<section>
				<title>Alsa</title>
				<body>

				<p>
				ALSA를 인스톨 하려면, <uri link = "http://www.gentoo.org/doc/kr/alsa-guide.xml">여기</uri> 젠투 리눅스 ALSA 셋업 가이드 를 읽으면 된다.

				</p>

				</body>
			</section>

			<section>
				<title>KDE and sound</title>
				<body>
				
				<p>
				KDE는 KDE 사운드 믹서 같은 아주 훌륭한 사운드 유틸리티를 가지고 있다. 

				</p>

				<note>
				만약 kmix가 mixer를 못찾는다면, kmix가 사운드 설정이 안되어 있다고 인식하는 것이다.
				로그 아웃 하고, <path>~/.kde/share/config/kmixrc</path> 와 <path>~/.kde/share/config/kmix:*</path> 를 지우고 다시 로그인한다.
				그럼, 아마 사운드 믹서를 찾을 것이다.
				
				</note>
				
				</body>
			</section>

			<section>
				<title>GNOME and sound</title>
				<body>

				<p>
				다음번 개정에 추가 예정
				
				</p>

				</body>
			</section>
	</chapter>

	<chapter>
		<title>Mail</title>
			<section>
				<title>Postfix -- Install and Configure</title>
				<body>
				
				<p>
				이문서의 저자는 <c>postfix</c> 메일 시스템을 좋아한다. 왜냐면, 이게 <c>sendmail</c> 을 에뮬레이트 해주는데, <c>sendmail</c> 설정파일의 압박에서 벋어나게 해준댄다. (역주: 센드메일설정파일은 엄청나게 복잡하다. 하지만, 실제로 수정하는건 얼마 안된다.^^; 이 문서의 저자는 그것도 싫은가보다.^^;)
				<c>mutt</c> 메일클라이언트를 인스톨한다음에, <c>postfix</c> 의 설정을 테스트해볼 것이다.

				</p>

				<pre caption = "Emerging postfix and mutt">
# <c>emerge postfix mutt</c>
				</pre>

				<p>
				만약 여러분이 여러분의 메일 서버를 오로지 메일을 보내는데만 사용할것이라면, postfix는 이미 그것을 위해 세팅이 되어 있다. 하지만 그렇지 않다면, 여러분은 <path>/etc/postfix/main.cf</path> 파일을 수정해야 할것이다.
				<path>main.cf</path> 파일은 잘만들어진 문서이다. 그리고 기본적인 세팅사항은 스탠드얼론(standalon) 머신에 맞게 만들어져 있다. 만약 여러분의 머신이 인터넷에 직접 연결(사설아이피를 쓰지 않는) 되어 있다면, 여러분은 postfix를 메일을 받을 수도 있게끔 설정할 수 있다.

				</p>

				<pre caption="Turning on mail reception in main.cf">
# RECEIVING MAIL

# The inet_interfaces parameter specifies the network interface
# addresses that this mail system receives mail on.  By default,
# the software claims all active interfaces on the machine. The
# parameter also controls delivery of mail to user@[ip.address].
#
#inet_interfaces = all
#inet_interfaces = $myhostname
#inet_interfaces = $myhostname, localhost
<i>inet_interfaces = $myhostname, localhost</i>
<i>mydestination = $myhostname, localhost.$mydomain</i>
				</pre>


				</body>
			</section>

			<section>
				<title>Postfix Testing (with Mutt)</title>
				<body>
				
				<p>
				작동하는지 보자~.

				</p>

				<pre caption = "Testing Postfix">
# <c>postfix check</c>
# <c>newaliases</c>
# <c>postfix start</c>
postfix-script: starting the Postfix mail system
# <c>mutt -x root</c>
/root/.maildir does not exist. Create it? ([y]/n): <comment>[answer y]</comment>
To:  &lt;root&gt;
Subject: test
(End message with a . on a line by itself)
test
.

# <c>mutt</c>
<comment>[You should see your message]</comment>
				</pre>
			
				<p>
				<c>postfix check</c> 를 하면, <path>main.cf</path> 를 적절하게 파싱하고, 
				중요한 디렉토리 몇개를 생성한다. <c>newaliases</c> 를 실행하면, 시스템 메일 alias를 세팅하고, <c>postfix start</c> 를 하면 메일데몬이 작동한다. <c>mutt</c> 를 이용해서, 자기가 자기한테 로컬머신으로 메시지를 보자. <c>mutt</c> 는 유저의 메일 스풀 디렉토리를 <path>~/.maildir</path>에 생성한다. <c>mutt</c> 를 full interactive 모드로 실행하면, 내가 보내는 메시지를 볼수 있다. 외부의 주소로 이메일을 보내고, 메일이 도착한걸 확인한다.
				

				</p>
				
				<warn>
					만약 기본 설정된 <path>main.cf</path> 로 사설 네트웍상에서 메일을 보내게 되면,
					그 메일을 다시 못볼수도 있다. 많은 메일 서버들은 reverse-DNS에 의해 접근이 되지 않는
					주소로부터의 메일은 자동으로 거부하게 되어 있다.
					
				</warn>

				<p>
					모든것이 잘 작동한다고 가정했을때, postfix는 부팅할때 실행된다.
					
				</p>

				<pre caption = "Configuring Postfix to start at boot">
# <c>postfix stop</c>
postfix-script: starting the Postfix mail system
# <c>rc-update add postfix default</c>
 * postfix added to runlevel default...
 * Caching service dependencies...          [ ok ] 
 * rc-update complete.
# <c>/etc/init.d/postfix start</c>
Starting postfix......     [  ok  ]
				</pre>
				
				<impo>
					베테랑 <c>sendmail</c> 이나 <c>postfix</c> 고수들은 유저디렉토리 보다는, <path>/var/spool/mail</path>
					에, <e>mbox</e> 형식으로 보관을 한다. 
					<path>/etc/postfix/main.cf</path> 파일의 <i>home_mailbox</i> 부분을 주석처리 하고, 
					<i>mail_spool_directory = /var/spool/mail</i> 의 주석을 푼다.
					<c>mkdir -p /var/spool/mail</c> 명령으로 메일 스풀 디렉토리를 생성하고, postfix를 재실행한다.
					<c>mutt</c> 에서는  <path>/etc/mutt/Muttrc</path> 파일만 고치면 된다. <i>set mbox_type = mbox</i>
					라고 추가하고, <i>set spoolfile=/var/spool/mail</i> 도 추가하면 된다.

				</impo>
				
				<p>
					만약에 GUI기반의 메일 클라이언트나 웹 기반의 메일서버인 Squirrelmail 을 더 
					선호한다면, 그것에 대한 내용은 이 문서의 끝에서 다루겠다. 추가로 
					다니엘 로빈은 IMAP과 KDE의  <c>kmail</c> 의 사용을 강력추천한다.
					kmail은 <path>kde-base/kdenetwork</path> 에 포함되어 있다.
					
				</p>
	
				<p>
					 아래에서 Ximian의 <e>Evolution</e> 를 인스톨할것이다. 이 프로그램은 훌륭한
					 PIMS (Personal Information Management software)이다. 또한 팜파일럿을 지원한다.
					 그리고, 매우 훌륭한 메일 클라이언트이기도 하다.
					 
				</p>
			
			</body>
		</section>
	</chapter>

	<chapter>
		<title>Samba</title>
			
			<section>
				<title>Installing/Configuring Samba</title>
				<body>
			
					<p>
						삼바는 여러분의 리눅스박스로 ms의 윈도우즈와 파일 공유와 프린트 공유를 
						하기 위해 사용하는 프로그램이다. 
						보다 자세한 정보는  <uri>http://www.ibm.com/developerworks</uri> 의
						다이엘 로빈이 작성한 Samba articles 를 읽어보기 바란다.
						
				</p>

				<pre caption = "Installing Samba">
# <c>emerge samba</c>
# <c>rc-update add samba default</c>
# <c>cd /etc/samba</c>
# <c>cp smb.conf.example smb.conf</c>
					# <c>nano -w smb.conf</c>
				</pre>
				
				<pre caption="smb.conf -- workgroup">
# workgroup = NT-Domain-Name or Workgroup-Name, eg: REDHAT4
workgroup = MYGROUP <comment>[change to match your workgroup]</comment>
				</pre>
				
				<pre caption="smb.conf -- printing with cups">
# It should not be necessary to specify the print system type unless
# it is non-standard. Currently supported print systems include:
# bsd, sysv, plp, lprng, aix, hpux, qnx
;   printing = bsd
printing = cups
				</pre>
				
				<pre caption="smb.conf -- encryption">
# You may wish to use password encryption. Please read
# ENCRYPTION.txt, Win95.txt and WinNT.txt in the Samba documentation.
# Do not enable this option unless you have read those documents
encrypt passwords = yes
				</pre>
				
				<p>
					삼바의 최소한의 기능만 필요했기에, 윈도우와 리눅스간의 파일 공유와 프린터 서버 공유(CUPS를 이용한)
					만 설정했다.
					인스톨후에, <path>/etc/samba/smb.conf</path> 를 살짝 수정해준다.
					<e>workgroup</e> 은 윈도우 네트웍의 workgroup을 설정하기 위함이다. 
					<e>printing</e> 은 <e>bsd</e> 대신에  <e>cups</e> 를 사용한다. 그리고,
					 <e>encrypt passwords = yes</e> 는 주석을 해제한다.
					 윈도 머신은 기본으로 암호화된 비밀번호를 사용한다.
					 그래서 여러분이 윈도우 레지스트리의 <comment>[not recommended]</comment> 를
					 해킹하지 않는다면, 마지막으로 수정한것이 기본값이 된다.
					 불행히도, 윈도우는 리눅스와 다른 암호화방식을 사용하기에, 삼바를 위한 다른 패스워드를 
					 관리해야 한다.
					 
				</p>

				<pre caption = "Adding users in Samba">
# <i>smbpasswd -a grant</i> <comment>[Replace "grant" with your user name]</comment>
New SMB password:
Retype new SMB password:
Added user grant.
				</pre>

				<note>
					삼바의 패스워드는 우선 <path>/etc/passwd</path> 의 패스워드가 먼저 고려되어 작성된다.
					
				</note>

				<p>
					윈도우 머신에서 삼바를 사용하기 원하는 유저는 먼저 <c>smbpasswd</c> 명령을 실행해야 한다.
					삼바는 <c>smbpasswd</c> 를 실행하면, 삼바의 비밀번호를 <path>/etc/samba/private/smbpasswd</path>
					에 보관한다.
					
				</p>
				
				<pre caption = "Starting Samba">
# <c>/etc/init.d/samba start</c>
Starting samba...        [  ok  ]
				</pre>

				<p>
					삼바를 시작하고, 윈도우즈 머신에서 젠투리눅스로 연결을 하고, 
					다른 유저들의 접속과 프린터를 셋업하기 위해, 홈디렉토리를 본다.
					만약 접속이 안된다면, <path>/usr/share/doc/samba-2.2.5-r1/full_docs/textdocs/DIAGNOSIS.txt.gz</path>
					에 추가적인 도움말들이 있다.
					
				</p>
				
				</body>
			</section>
		</chapter>

		<chapter>
			<title>Apache and Squirrelmail Webmail</title>
			<section>
				<title>Apache with SSL and PHP</title>
				
				<body>
				
					<p>
						고정 IP가 있다는 가정하에서 여러분은 집밖에서 효율적인 이메일 체크를 
						하고 싶을 것이다.
						해결방법이라면, 웹메일 서버를 사용하는 방법이 있다.
						Squirrelmail을 사용하면 원격지에서 웹 브라우저를 사요해 접속할 수 있다.
						
				</p>
				
				<p>
					먼저 웹서버를 인스톨 해야 한다.
					대부분의 경우 아파치를 사용한다.
					그리고 우리는 php도 인스톨할것이다. Squirrelmail이 php프로그램이기 때문이다.
					프로그램으의 버전 번호는 여러분이 이 문서를 읽고 있는 시점에서 다를 수도 있기 때문에,
					아래 명령어를 단순히 여러분의 터미널로 긁어 붙이기 해서는 안될 것이다.
					
				</p>

				<pre caption = "Installing and configuring Apache">
# <c>emerge apache php mod_php mod_ssl</c>
# <c>ebuild /var/db/pkg/dev-php/mod_php-4.2.2-r1/mod_php-4.2.2-r1.ebuild config</c>
# <c>ebuild /var/db/pkg/net-www/mod_ssl-2.8.10/mod_ssl-2.8.10.ebuild config</c>
				</pre>
				
				<impo>
					아파치의 SSL 지원기능을 사용하고 싶다면, mod_ssl을 인스톨한다.
					원격지에서 여러분의 이메일을 검사하면서, 여러분의 비밀번호가 암호화되지 않은채,
					흘러나가는것을 원치 않는다면 SSL을 꼭 설치해야 할것이다.
					
			</impo>
				
			<p>
				여러분은 <path>/etc/apache/conf/apache.conf</path> 을 봐야 할것이다.
				아파치는 커스터마이징에 매우 높은 유연성을 보여준다.
				
				</p>
				
				<pre caption="/etc/apache/conf/apache.conf">
# Do NOT add a slash at the end of the directory path.
#
DocumentRoot "/home/httpd/htdocs" <comment>(edit this line if desired)</comment>
				</pre>
				
				<pre caption = "Making Apache start at boot">
# <c>rc-update add apache default</c>
 * apache added to runlevel default...
 * Caching service dependencies...               [ ok ]
 * rc-update complete.
# <c>nano -w /etc/conf.d/apache</c>
				</pre>
				
				<p>
					<c>rc-update</c> 를 이용해서 아파치를 default 런레벨에 포함시키고,
					<path>/etc/conf.d/apache</path> 를 수정해서 다음 라인을 추가해서 아파치가
					자동으로 SSL과 PHP모듈을 올리게끔 한다.
					
			</p>
			
			<pre caption="/etc/conf.d/apache">
APACHE_OPTS="-D SSL -D PHP4"
			</pre>

			<pre caption = "Restarting Apache">
# <c>/etc/init.d/apache start</c>
 * Starting Apache...                            [ OK ]
# <c>lynx localhost</c>
			</pre>
			
			<p>
				아파치 웹 서버가 제대로 동작하는 확인해보려면 localhost로 웹브라우저를 이용해
				직접 접속해보면 된다.
				SSL 지원 기능이 작동하려면 <uri>http<comment>s</comment>://localhost</uri> 라고 입력하면 된다.
				<c>https</c> 는 브라우저에게 SSL을 이용한 보안접속을 하려 함을 알려준다.
				GUI웹 브라우저의 경우 좌물쇠 아이콘소프트 웨어가 나타나면서, 보안접속을 했음을 알려준다.
				
			</p>
			
			<note>
				여러분의 서버에 보안 접속을 했을때, 대부분의 경우 사이트의 인증서가 인증되지 않았다는
				경고 메시지를 받게 될것이다.
				mod_ssl ebuild 는 일부러 테스팅을 하기 위한 목적으로 self-sigend 인증서를 인스톨한다.
				<path>/usr/share/doc/mod_ssl-2.8.10</path> 에 있는 <c>mod_ssl</c> 메뉴얼을 보면,
				self-signed 인증서는 개인적 사용을 위해 적합하다.
				
		</note>
			
		<p>
			php도 제대로 동작하게 한다.
			먼저 간단한 php파일을 아파치의 DocumanetRoot 디렉토리에 넣는다.
			</p>

			<pre caption = "Testing PHP">
# <c>echo "&lt;? phpinfo(); ?&gt;" > /home/httpd/htdocs/test.php</c>
# <c>lynx http://localhost/test.php</c>
			</pre>

			<pre caption="working Apache + PHP">
             	                                              phpinfo() (p1 of 26)
               	                  PHP Logo
 	
   	                         PHP Version 4.0.6
 
     System Linux my.server.edu 2.4.10 #1 Tue Oct 9 16:33:50 Local
 	        time zone must be set--see zic manuali686 i686 unknown
   	                       Build Date Oct 16 2001
			</pre>
			
			<p>
				위에랑 비슷하게 출력이 되었다면, 아파치가 성공적으로 php코드를 수행한것이다.
				
			</p>
		
			<warn>
				위의 결과의 완전한 실행결과를 보면  <path>test.php</path> 는 여러분의 시스템에 대한
				매우 많은 정보를 보여준다. 여러분은 이것을 php가 돌아가고 있는 동안에는 없애야 할것이다.
				아니면, <c>mv test.php test.phps</c> 로, 확장자를 바꾼다. 아파치는 <path>test.phps</path>는
				스크립트의 실행 결과 대신에, php의 소스파일을 뿌려준다.
				
			</warn>

			</body>
		</section>
	
		<section>
			<title>Courier IMAP</title>
			<body>
			
				<p>
					Squirrelmail 은 php 어플리케이션이다. 그러나 IMAP서버와 웹서와 이메일 서버등이
					있어야 동작한다.
					젠투 리눅스는 메일폴더를 Maildir 로 기본 설정되어 있다. Courier IMAP은 좋은 선택이 된다.
					
		</p>
			
			<pre caption = "Emerging/testing Courier-imap">
# <c>emerge courier-imap</c>
# <c>rc-update add courier-imapd default</c>
 * courier-imapd added to runlevel default...
 * Caching service dependencies...                        [ ok ]
 * rc-update complete.
# <c>nano -w /etc/courier-imap/authdaemonrc</c>
# <c>/etc/init.d/courier-imapd start</c>
# <c>telnet localhost 143</c>
Trying 127.0.0.1...
Connected to localhost.localdomain.
Escape character is '^]'.
* OK Courier-IMAP ready. Copyright 1998-2001 Double Precision, Inc.  
See COPYING for distribution information.
1 LOGIN grant passwd <comment>(&lt;-- replace "grant" w/ your username 
and "passwd" w/ your password)</comment>
1 OK LOGIN OK
<comment>(Hit &lt;ctrl&gt;-"]" and type "quit" to exit)</comment>
			</pre>
			
			<pre caption="Correct authorization in /etc/courier-imap/authdaemonrc">
##NAME: authmodulelist:0
#
# The authentication modules that are linked into authdaemond.  The
# default list is installed.  You may selectively disable modules simply
# by removing them from the following list.  The available modules you
# can use are: authcustom authcram authuserdb authpam

#authmodulelist="authcustom authcram authuserdb authpam"
authmodulelist="authpam"
			</pre>
			
			<impo>
				Courier IMAP 는 <path>/usr/lib/courier-imap/imapd.rc</path> 의 rc start-up script 에서 
				사용하는 사용자의 Maildir-type inbox디렉토리가 <path>$HOME/Maildir</path> 로 고정되어 있다.
				그러나 젠투리눅스에서는  $HOME/.maildir 이 대신 사용된다. 왜냐하면 courier-imap ebuild가 
				<path>imapd.rc</path> 파일을 수정해서 <e>$MAILDIR</e> 을 사용하게 한다. 이 작업은 젠투 init 스크립트인
				 <path>/etc/init.d/courier-imap</path> 에 의해 실행된다.
				 만약 사용자가 <path>.maildir</path> 이외의 걸 선택하고자 함이면, 여러분은 <e>MAILDIR=.maildir</e> 부분을
				 전체 courier-imap 의 init script에서 수정해야 한다.
				
		</impo>
			
		<p>
			Courier IMAP 에서 SSL을 지원하게 하려면 IMAP SSL 인증서를 만들어야 한다.
			
			</p>
			
			<pre caption = "Making SSL Certs for IMAP">
# <i>/usr/sbin/mkimapdcert</i> 
			</pre>
			
			<p>
				그리고 imap-ssl 을 실행한다.
				
			</p>

			<pre caption = "Adding Courier IMAP to default">
# <c>rc-update add courier-imapd-ssl default</c>
# <c>/etc/init.d/courier-imapd-ssl start</c>
			</pre>
			
			<p>
				imap이 여러 IMAP 호환 메일 클라이언트에서 동작하는걸 확인 할 수 있다.
				(넷츠케이프나, kmail, mutt같은것들)
				
			</p>

			<pre caption = "Checking your IMAP Server">
# <c>mutt -f imap://localhost</c>
			</pre>
		</body>
	</section>

	<section>
		<title>Squirrelmail</title>
		<body>
		
			<p>
				Squirrelmail 의 인스톨과 설정은 한개의 콤포넌트에 의해서
				한방에 해결된다.
				
		</p>

		<pre caption = "Emerging Squirrelmail">
# <c>emerge squirrelmail</c>
# <c>cd /home/httpd/htdocs</c>
# <c>cd squirrelmail</c>
# <c>./configure</c>
		</pre>
		
		<note>
			아파치의 DocumentRoot 가 <path>/home/httpd/htdocs</path> 가 아니라면, 
			<path>net-mail/squirrelmail</path> 의 ebuild를 수정해야 한다.
			
	</note>

	<p>
		squirrelmail 이 정확히 동작하려면, 모든 파일들이 아파치의 실행권한으로 되어 있어야 한다.
		 <c>./configure</c> 에서 <e>2</e> 번을 선택한다.
		
	</p>

		<pre caption="Squirrelmail configuration -- Server settings">
SquirrelMail Configuration : Read: config.php
---------------------------------------------------------
Server Settings
1.  Domain               : my.server.edu
2.  IMAP Server          : localhost
3.  IMAP Port            : 143
4.  Use Sendmail/SMTP    : SMTP
6.    SMTP Server        : localhost
7.    SMTP Port          : 25
8.    Authenticated SMTP : false
9.  Server               : courier
10. Invert Time          : false
11. Delimiter            : detect

R   Return to Main Menu
C.  Turn color off
S   Save data
Q   Quit
 
Command >>
		</pre>

		<p>
			<e>Server</e> 는 <e>courier</e> 로 설정한다.
			메인메뉴로 돌아가서 <e>4</e> 를 선택해 일반적 옵션을 세팅한다.
		</p>

		<pre caption="Squirrelmail configuration -- General options">
SquirrelMail Configuration : Read: config.php
---------------------------------------------------------
General Options
1.  Default Charset        : iso-8859-1
2.  Data Directory         : ../data/
3.  Attachment Directory   : /tmp/
4.  Default Left Size      : 150
5.  Usernames in Lowercase : false
 
R   Return to Main Menu
C.  Turn color off
S   Save data
Q   Quit
 
Command >>
		</pre>
		
		<p>
			패키지의 데이타 디렉토리를 사요했지만, 아파치 도큐먼트 트리 밖의
			디렉토리를 이용하는 것이 보안상 더 낫다.
			그리고 부가적으로 <path>/tmp</path>를 사용한다.
			
		</p>

		<p>
			아파치를 재시작 하면, 준비가 다 된것이다.
			
		</p>
		
		<pre caption = "Restarting Apache">
# <c>/etc/init.d/apache restart</c>
		</pre>

		<p>
			<uri>https://localhost/squirrelmail/src/login.php</uri> 를 브라우저에 입력하면,
			동작하게 된다.
			
		</p>

		<pre caption = "Testing Squirrelmail">
# <c>lynx https://localhost/squirrelmail/</c>
		</pre>

		<pre caption="Squirrelmail login page">
                                           SquirrelMail - Login
   	                           [sm_logo.jpg]

       	              SquirrelMail version 1.2.0 [rc2]
           	        By the SquirrelMail Development Team
 
               	             SquirrelMail Login
 
       Name: ____________________
 Password: ____________________
 
   	                               Login
		</pre>

		
		</body>
	</section>
</chapter>

	<chapter>
		<title>Personal Information Management</title>
		
		<section>
			<title>Evolution with Palm support</title>
			<body>

				<p>
					Evolution 은 팜파일럿과 아주 잘 싱크되는 매우 훌륭한 PIMS 프로그램이다.
					evolution을 emerge하는 첫번째 단계는 일단 팜파일럿 싱크를 사용하기 위해,
					USE에 pda라고 USE변수를 하나 추가하는 것이다. 
					(USE는 <path>/etc/make.conf</path> 에 추가한다.)
					
			</p>

			<pre caption = "Emerging Evolution">
# <c>emerge --pretend evolution</c>
# <c>emerge evolution</c> 
			</pre>

			<p>
				불행히도, 에볼루션은 빌드하는데 꽤 긴시간이 걸린다. (왜냐면, <c>mozilla</c> 에 
				의존성이 걸린다.) 몇잔의 커피/ 차 나 마시면서 기다리자.
				
			</p>

			<p>
				<c>evolution</c> 이 빌드 되는 동안에, 필요한 팜 파일럿 툴들도 잘 빌드 될것이다.
				일반 사용자들의 팜파일럿의 싱크를 위해서 시리얼 포트의 퍼미션을 수정해야 한다.
				팜 파일럿의 크래들이 첫번째 시리얼 포트에 연결된다고 가정한다.(/dev/ttyS0 이나 
				"devfs"의 경우 /dev/tts/0)
				
			</p>

			<pre caption = "Adding serial device">
# <c>groupadd serial</c>
# <c>chown root.serial /dev/tts/0</c>
# <c>chmod g+rw /dev/tts/0</c>
# <c>ls -l /dev/tts/0</c>
crw-rw----    1 root     serial     4,  64 Dec 31  1969 /dev/tts/0
# <c>ln -s /dev/tts/0 /dev/pilot</c>
# <c>nano -w /etc/group</c> <comment>(add appropriate users to the serial group)</comment>
			</pre>

			<p>
				"serial"그룹을 시스템에 만들고, 팜파일럿 유저들을 serial 그룹에 추가한다. 
				<path>/dev/tts/0</path> 에 대해 serial그룹의 사용자들에게 "rw"의 권한을 주고,
				나중을 위해서,  <path>/dev/tts/0</path> 를 <path>/dev/pilot</path> 로 심볼릭 링크 걸어둔다.
				리부팅하고 나면, devfs 가 수정된 사항을 인식할 것이다.
				
			</p>

			<note>
				pre-rc6-r13이전 버전 사용자들은 <path>sys-apps/baselayout</path> 와 <path>sys-apps/devfsd</path>
				를 업그레이드 할 수 있다. 아니면 간단하게 특별한 퍼미션을 주고, <path>/etc/devfsd.conf</path> 를
				심볼릭 링크를 건다.
				
			</note>

			<p>
				사용자들은 에볼루션의 메뉴 옵션에서 <path>tools/Pilot settings</path> 를 이용해 
				그놈 파일럿 소프트웨어를 셋업하길 원할것이다. "Pilot Conduits" 를 셋업하는 일은
				그놈 컨트롤 센터의 "Pilot Link" 만큼 중요하다.
				
			</p>

			</body>
		</section>
	</chapter>
</guide>
