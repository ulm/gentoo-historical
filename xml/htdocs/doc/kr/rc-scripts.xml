<?xml version='1.0' encoding='euc-kr'?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/kr/rc-scripts.xml">
	<title>젠투 리눅스 1.0 Init System</title>
	<author title="Author"><mail link="azarah@gentoo.org">Martin Schlemmer</mail></author>
	<author title="Proof-reader"><mail link="seemant@gentoo.org">Seemant Kulleen</mail></author>
	<author title="번역자"><mail link="killyourgod@hanmail.net">폐인의속도</mail></author>
        <author title="Moderator"><mail link="seo@gentoo.or.kr">Jungmin Seo</mail></author>
	<abstract>
		본 문서는 <uri link="http://www.gentoo.org">www.gentoo.org</uri>의 <uri link="http://www.gentoo.org/doc/en/rc-scripts.xml">'Gentoo rc-scripts Guide'</uri>를 번역한 문서임.
	</abstract>
	<version>0.0.1</version>
	<date>2002.06.21</date>
	
	<!--본문 시작-->
	
	<chapter>
		<title>도입</title>
			<section>
				<body>
					<p>젠투 리눅스는 의존성을 통해 제어되는 initsystem을 사용한다. 이것은 유지하기 쉬우면서도, 어떤 종류의 셋업에서도 강력하고 유동적이어야 한다. 이것은 복잡한 내부 작용에 대한 설명이 아니라, 젠투의 initsystem을 시작하고 굴리는 데에 대한 빠른 가이드가 되어야 한다. 내부 작용이 궁금한 사람들은... 소스를 보라 ;-)</p>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>런레벨</title>
			<section>
				<body>
					<p>다른 initsystem들과 달리, 젠투의 런레벨은 엄격한 이름이나 숫자를 갖고 있지는 않지만, 다소 특성화된 이름들이 표준 init의 런레벨에 대응하고 있다.</p>
					<note>기본적으로 세가지 런레벨이 있는데, 각각 <e>"boot"</e>, <e>"default"</e> 그리고 <e>"nonetwork"</e> 이다.</note>
					<p>"boot" 런레벨은 대부분의 셋업에서 표준이어야 하며, 이름이 알려주듯이 부트 타임에 가장 먼저 실행되는 런레벨이다. 다음의 "default"는, 이름이 암시하듯이, 부팅 후에 실행되는 메인 런레벨이다. 마지막의 "nonetwork"은 순수히 예의 역할을 한다.</p>
					<p>런레벨들은 <path>/etc/runlevels</path> 안의 각 런레벨 이름을 딴 하부 디렉토리 안에 들어 있다. 이 하부 디렉토리들은 런레벨이 소유하는 서비스들에 대한 심볼릭 링크로 채워져 있다.</p>
					<note>서비스를 추가하거나 제거하는 방법들은 "rc-update에 대하여" 섹션에 언급되어 있다.</note>
					<p>앞서 언급했듯이, 런레벨의 이름은 기본 런레벨의 새 이름을 반영하도록 <path>/etc/inittab</path>를 수정함으로써, 사용자 입맛에 맛춰 무엇으로든 바꿀 수 있다.</p>
					<impo>규칙에 예외가 하나 있는데, 그것은 <e>"boot"</e> 런레벨이다.</impo>
					<warn><e>"boot"</e> 런레벨의 이름은 바꾸지 마라 - 여러가지를 멈추게 할 것이다</warn>
					<p><path>/sbin/rc</path> 스크립트는 이 모든 작업을 하며, 가상 런레벨들 사이에서 전환을 하기 위해 그때그때 불러질 수 있다.</p>
				</body>
			</section>
			<section>
				<title>가상 런레벨들</title>
				<body>
					<p>런레벨들이 init의 것들에 정적으로 매핑되어 있지 않으므로, init이 지원하는 런레벨 갯수보다 더 많은 런레벨이 있을 수 있다. 이것은 사용자들이 필요에 따라 profiles나 가상 런레벨들을 생성할 수 있게 해준다.</p>
					<p>예를 들어, 노트북 사용자는 "online"과 "offline"이라 불리는 두개의 기본 런레벨을 가질 수 있다. 이것은 PCMCIA NIC가 꼽혀 있을 때의 활성화된 런레벨과, 그렇지 않은 때의 활성화된 런레벨을 가능하게 한다. PCMCIA 스크립트들은 PCMCIA NIC의 상태에 따라 알맞은 서비스를 시작하고 정지하기 위해 <c>"/sbin/rc online"</c> 이나 <c>"/sbin/rc offline"</c>을 적당히 불러올 수 있다.</p>
				</body>
			</section>
			<section>
				<title>런레벨과 XFree86</title>
				<body>
					젠투에는 X에 할당된 런레벨은 따로 없지만, 스타트업 스크립트가 있다. 이것은 "xdm"이라고 불리며, 사용자가 원한다면 어떠한 런레벨에도 추가될 수 있다.
					<note>사용자가 원하는 런레벨은 메인 런레벨이어야 한다.</note>
					<warn>boot 런레벨에 추가하면 원치 않은 부작용이 발생할 수 있다.</warn>
					<p>기본으로, xdm, gdm이나 kdm을 당신의 getty가 시작하기 전에 실행하길 원한다면, X는 다음 사용가능한 콘솔에서 시작될 것이다. 데스크탑 매니저가 런레벨의 init 프로세스의 끝에 실행되는 느린 머신에서는 문제가 없다. getty는 X가 뜨기 전에 시작될 것이며, 그것은 원래 그래야하는 것처럼 7번째 콘솔에서 시작될 것이다. 하지만, 속도가 빠른 머신에서는 그렇지 않다. X는 보통 2번 콘솔에서 시작되는 getty보다 먼저 시작될 것이다. getty가 시작되면, 그것은 키보드의 컨트롤을 갖게 되므로, 데스크탑 매니저는 키보드 지원을 얻지 못하 것이다.</p>
					<p>이것은 데스크탑의 스타트업 스크립트를 init의 추가 런레벨(예를 들어 'a'라 이름 짓자)에 놓음으로써 해결할 수 있다. 'a' 런레벨은 실제 런레벨이 아니므로, "xdm" 스크립트는 그저 <i>"telinit a"</i>를 부른다. 이것은 'a' 런레벨에 있는 모든 서비스들이 현재의 런레벨 이후에 실행되게 함으로써, gettys가 뜬 이후에 X가 뜨게 할 수 있다.</p>
					<note>'a' 런레벨에 대한 더 자세한 정보는 init의 맨페이지에서 얻을 수 있다.</note>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>RC-Scripts</title>
			<section>
				<body>
					RC-Script들은 각 서비스의 기본 기능들 뿐 아니라, 스타트업 시의 의존성들을 정의해 주는 스크립트들이다. 이것은 <path>/etc/init.d/</path>에 들어 있다.
				</body>
			</section>
			<section>
				<title>rc-script의 기본 레이아웃</title>
				<body>
					<pre caption="rc-script 레이아웃">
#!/sbin/runscript
 
depend() {
    need bar
}
	 
start() {
	ebegin "Starting foo"
	/sbin/foo
	eend $? "Failed to start foo"
}
				 
stop() {
	ebegin "Stopping foo"
	kill $(cat /var/run/foo.pid)
	eend $? "Failed to stop foo"
}							
					</pre>
					<note>해석기는 "/sbin/runscript" 이다.</note>
					<note>"depend" 함수는 옵션이다.</note>
					<note>어떠한 rc-script라도 최소한 "start" 함수를 갖고 있어야 한다.</note>
				</body>
			</section>
			<section>
				<title>스타트업 제어하기</title>
				<body>
					<p>런레벨의 서비스들의 일반적인 스타트업 순서는 알파벳 순이다. 이것은 <path>/bin/ls</path>의 출력상의 순서 때문이다.</p>
					<p>이 스타트업 순서를 벗어나는 주된 방법은 의존성이다. 만약 서비스들 간에 관련이 없으면, 순서 타입(order types)이 사용될 수 있다.</p>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>의존성 타입들</title>
			<section>
				<body>
					<p>대부분의 서비스들은 다른 서비스와 연관이 있거나, 의존하는 관계에 있다.</p>
					<p>예를 들어, postfix는 네트웍 뿐 아니라 system logger가 올라와 돌고 있어야 한다.</p>
					<p>반면, samba는 네트웍이 올라와 있어야 한다. 하지만, 만약 cups가 프린팅을 위해 사용되고 있었다면, cupsd 또한 samba보다 먼저 시작되어야 한다. cups가 samba를 시작하는데 있어서 필수적이진 않다는 것을 알아두라.</p>
					<p>그리하여, 우리는 다른 서비스간의 의존성 관계를 표현하는 두가지 방법을 갖게 된다. 이 의존성들은 런레벨이 바뀌거나, 부팅 후에 수동으로 서비스가 시작되거나 멈추는지의 여부에 관계없이 언제나 유효하다.</p>
				</body>
			</section>
			<section>
				<title>NEED 의존성 타입</title>
				<body>
					<p>이것은 현재 서비스의 스타트업 시에 꼭 필요한 서비스가 있을 시에 사용된다.</p>
					<pre caption="logger와 net을  NEED 의존성으로 추가">
depend()	{
	need net logger
}
					</pre>
					<note><e>NEED</e> 뒤에 언급된 서비스들은 현재 서비스를 시작하기 위해 필수적이다. 그러므로, 이 서비스들 중 어느 하나라도 시작하는데 실패하면 현재 서비스는 시작되지 못할 것이다.</note>
					<impo><e>NEED</e> 행에 있는 모든 서비스는 설령 현재 런레벨이나 <e>"boot"</e> 런레벨에 추가되어 있지 않더라도 시작될 것이다.</impo>
				</body>
			</section>
			<section>
				<title>USE 의존성 타입</title>
				<body>
					<p>현재 서비스를 시작하는데 필수적이진 않지만, 만약 그것이 사용된다면 현재 서비스보다 먼저 시작되어야 한다.</p>
					<pre caption="portmap을 USE 의존성으로 netmount에 추가">
depend()	{
	use portmap
}
					</pre>
					<p>netmount는 기본으로 NFS 마운트들을 다룰 수 있지만, 만약 portmap이 현재 런레벨, 또는 boot 런레벨에 추가 되어 있다면 그것에만 의존하게 될 것이다. NFS 마운트를 사용하는 유저들은, netmount가 portmap을 USE 의존성으로 보고 먼저 시작하도록 하기 위해, 기본적으로 portmap을 기본 런레벨에 추가해야 한다.</p>
					<impo><e>USE</e> 행에 있는 모든 서비스는 유효한 <e>USE</e> 의존성으로 여겨지도록 하기 위해 <e>"반드시"</e> 현재, 또는 boot 런레벨에 추가되어야 한다.</impo>
					<p>그러므로 <e>USE</e>는 "약한" 의존성이다.</p>
					<note><e>USE</e> 행의 서비스 중 시작하는데 실패하는 것이 있더라도, <e>USE</e> 행의 것들이 스타트업을 위해 필수적은 아니기 때문에, 현재 서비스는 여전히 시작될 것이다.</note>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>의존성이 없을 때 순서 제어하기</title>
			<section>
				<body>
					<p>만약 두 서비스들 간에 의존 관계는 없지만, 한 서비스를 다른 서비스 다음에 시작시켜야 할 필요가 있을 경우, <e>AFTER</e>와 <e>BEFORE</e>관계가 사용된다.</p>
					<note>이 두 타입은 런레벨 전환시에만 유효하다.</note>
					<p>옵션으로, 이 두 관계는 다른 모든 서비스를 포함하기 위해 "*" 와일드카드를 지원한다.</p>
					<pre caption="AFTER의 포괄적인 예">
depend()	{
	after *
}
					</pre>
					<p>이것은 local이 다른 모든 서비스 이후에 <e>"after"</e>를 시작하게 한다.</p>
				</body>
			</section>
			<section>
				<title>BEFORE 순서 타입</title>
				<body>
					<p>현재 서비스는 <e>BEFORE</e>행의 서비스들 <e>"전에"</e> 시작된다.</p>
					<pre caption="foo를 bar 전에 시작하게 한다 (foo의 부분)">
depend()	{
	before bar
}
					</pre>
				</body>
			</section>
			<section>
				<title>AFTER 순서 타입</title>
				<body>
					<p>현재 서비스는 <e>AFTER</e>행의 서비스들 <e>"후에"</e> 시작된다.</p>
					<pre caption="bar를 foo 다음에 시작하게 한다 (bar의 부분)">
depend()	{
	after foo
}
					</pre>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>가상 서비스들</title>
			<section>
				<body>
					<p>오늘날 유닉스 세계의 대부분의 것들처럼, 서비스들은 여러 입맛과 색깔로 제공되고 있다. 어떤 것을 고를 것인가는 대부분 유저/관리자의 선택에 따른다.</p>
					<p>system logger들이 한 예이다. 이 글을 쓰는 현재, 젠투 리눅스 유저들은 4가지 다른 종류의 system logger를 고를 수 있다. 스타트업 전에 system logger가 돌고 있어야 하는 모든 서비스들은 이제 그들 4개 모두를 <e>필요(NEED)</e>로 할 수 없다. 그들을 <e>사용(USE)</e>하는 것 역시 너무 약하다.</p>
					<p>이곳이 바로 가상 서비스와 <e>PROVIDE</e> 타입이 힘을 쓰는 부분이다.</p>
				</body>
			</section>
			<section>
				<title>PROVIDE 타입</title>
				<body>
					<p><e>PROVIDE</e> 타입은 다른 서비스가 <e>필요(NEED)</e>로 하거나 <e>사용(USE)</e>하는 가상 서비스를 정의한다.</p>
					<pre caption="logger를 제공하는 sysklogd">
depend()	{
	provide logger
}
					</pre>
				</body>
			</section>
			<section>
				<title>LOGGER 가상 서비스</title>
				<body>
					<p><e>LOGGER</e>는 모든 system logger가 제공하는 미리 정의된 가상 서비스이다. 이것은 <e>NEED</e>나 <e>USE</e> 의존 타입과 함께 쓰일 수 있다.</p>
				</body>
			</section>
			<section>
				<title>NET 가상 서비스</title>
				<body>
					<p><e>NET</e> 서비스는 또다른 가상 서비스이지만, <e>LOGGER</e>와 달리, 명확하게 서비스를 <e>제공(PROVIDE)</e>하진 않는다.</p>
					<impo><e>NET</e>을 가상으로 제공하기 위해, 서비스는 반드시 :<ul><li>현재 또는 boot 런레벨에 추가되어야 한다.</li><li>"net."을 앞에 달고 있어야 한다.</li><li>"net." 다음 부분은 반드시 실제 네트웍 인터페이스의 이름(예를 들어 net.eth0 또는 net.ppp1)이어야 한다.</li></ul></impo>
					<p>유효한 모든 net.* 서비스의 $IFACE 값은 네트웍 인터페이스(예를 들어, net.eth0에는 "eth0")의 이름을 값으로 갖게 될 것이다.</p>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>기본 명령행 옵션들</title>
			<section>
				<body>
					<p>어떤 서비스든지 기본 옵션으로 불려질 수 있다. 사용자가 자신의 rc-script에 정의해야 하는 함수인 <e>START</e>와 <e>STOP</e>을 제외한, 언급된 모든 것들은 이미 정의 되어 있다.</p>
					<impo>start() 함수는 <e>반드시</e> 정의되어야 한다.</impo>
					<note>stop() 함수는 덜 중요하므로, 남겨둬도 된다.</note>
					<note>일반적으로, 사용자는 단지 <e>start(), stop(), restart()</e> 만을 정의하게 될 것이다. 나머지는 내부적인 것이므로, 내버려 둬야 한다.</note>
					<pre caption="httpd 서비스를 시작">
# /etc/init.d/httpd start
					</pre>
					<note>명령행 옵션은 쌓일(stacked) 수 있다.</note>
					<pre caption="net.eth0을 일시정지/시작">
# /etc/init.d/net.eth0 pause start
					</pre>
				</body>
			</section>
			<section>
				<title>START/STOP 옵션</title>
				<body>
					<p>서비스를, 그것이 의존하는 모든 서비스를 포함하여, <e>시작(START)</e>한다.</p>
					<p>서비스를, 그것이 의존하는 모든 서비스를 포함하여, <e>정지(STOP)</e>한다.</p>
				</body>
			</section>
			<section>
				<title>RESTART 옵션</title>
				<body>
					<p>서비스는 <e>RESTART</e>가 작동하기 위해 시작되어야만 한다. 그것은 그 서비스 뿐만 아니라 그것이 의존하는 모든 서비스를 재시작할 것이다.</p>
					<impo>만약 커스텀 <e>restart()</e> 함수가 정의되어 있다면, 사용자는 <e>"svc_start()"</e>와 <e>"svc_stop()"</e>을 사용하여 서비스를 시작하고 멈추어야 한다.</impo>
					<note>이것은 모든 의존적인 서비스들을 올바르게 다루기 위하여 행해진다.</note>
				</body>
			</section>
			<section>
				<title>PAUSE 옵션</title>
				<body>
					<p>이것은 서비스를 멈추지만, <e>STOP</e>과 다르게, 의존적인 서비스들을 멈추게 하지 않는다.</p>
				</body>
			</section>
			<section>
				<title>ZAP 옵션</title>
				<body>
					<p>서비스의 상태를 멈춘 상태(stopped)로 reset 한다.</p>
					<note><e>stop()</e> 함수 안의 명령들은 실행되지 않음을 알아두라. 그러므로 사용자는 cleanup이 필요하다면 직접 해야 한다.</note>
				</body>
			</section>
			<section>
				<title>INEED/NEEDSME 옵션</title>
				<body>
					<p><e>INEED</e>은 이 서비스<i>가</i> <e>필요(NEED)</e>로 하는 서비스들을 나열한다.</p>
					<p><e>NEEDSME</e>는 이 서비스<i>를</i> <e>필요(NEED)</e>로 하는 서비스들을 나열한다.</p>
					
				</body>
			</section>
			<section>
				<title>IUSE/USEME 옵션</title>
				<body>
					<p><e>IUSE</e>는 이 서비스<i>가</i> <e>사용(USE)</e>하는 서비스들을 나열한다.</p>
					<p><e>USEME</e>는 이 서비스<i>를</i> <e>사용(USE)</e>하는 서비스들을 나열한다.</p>
				</body>
			</section>
			<section>
				<title>BROKEN 옵션</title>
				<body>
					<p>이것은 (만약 있다면) 이 서비스가 <e>필요(NEED)</e>로 하는 서비스들 중 빠진 서비스들을 나열한다.</p>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>커스텀 명령행 옵션 추가하기</title>
			<section>
				<body>
					<p>커스텀 명령행 옵션을 추가하는 것은 비교적 쉽다. 아래 보이는 것처럼, 옵션 이름을 가진 함수가 rc-script 안에 정의되고, <e>$opts</e> 변수에 추가되어야 한다.</p>
					<pre caption="커스텀 옵션 foo">
opts="${opts} foo"
foo() {
	...............
}
					</pre>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>설정</title>
			<section>
				<body>
					<p>설정은 보통 환경 변수를 통해 이루어 져야 한다. 그러나 이것들은, rc-script가 아닌 3개의 설정 파일들 중 하나에 정의되어 있어야 한다.</p>
					<p>하나는 rc-script에 한정적인 설정파일이며, 둘은 전체적인 설정파일이다.</p>
					<pre caption="rc-script들을 위한 설정 파일들">
<path>/etc/conf.d/&lt;name of rc-script&gt;</path>
<path>/etc/conf.d/basic</path>
<path>/etc/rc.conf</path>
					</pre>
					<note>이 세 설정 파일들은 자동적으로 위에 나열된 순서대로 참조된다.</note>
					<impo>모든 <e>NET</e> 서비스들은 또한 <path>/etc/conf.d/net</path>를 참조한다.</impo>
				</body>
			</section>
	</chapter>
	<chapter>
		<title>유틸리티들/도우미 스크립트들</title>
			<section>
				<title>rc-update 유틸리티</title>
				<body>
					<p>rc-update는 런레벨에 서비스를 추가하거나 제거하는데 쓰는 주된 도구이다. 이것은 또한 "depscan.sh"를 불러 의존성 캐시를 갱신할 것이다.</p>
					<pre caption="default 런레벨에 metalog 추가">
# rc-update add metalog default
					</pre>
					<pre caption="default 런레벨에서 metalog 제거">
# rc-update del metalog default
					</pre>
					<note>인수 없이 rc-update를 실행하면 더 많은 도움말을 얻을 수 있다.</note>
				</body>
			</section>
			<section>
				<title>도우미 스크립트 depscah.sh</title>
				<body>
					<p>완전히 하기 위해, 여기서 depscan.sh를 언급한다. 그것은 기본적으로 서비스들 간 의존성의 맵이 되는 의존성 캐시를 생성하는데 사용된다.</p>
					<p>이것은 새 rc-script가 <path>/etc/init.d/</path>에 추가될 때 마다 실행되어야 하지만, rc-update가 자동으로 그것을 실행하므로, 대부분의 사용자들은 그것을 실행할 필요가 없을 것이다.</p>
				</body>
			</section>
	</chapter>
	
	<!--본문 끝  -->
	
</guide>
