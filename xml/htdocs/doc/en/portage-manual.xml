<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/Attic/portage-manual.xml,v 1.36 2004/09/14 01:33:55 vapier Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/en/portage-manual.xml">
<title>Portage Manual</title>

<author title="Author and Editor">
  <mail link="blocke@shivan.org">Bruce A. Locke</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Editor">
  <mail link="g.guidi@sns.it">Gregorio Guidi</mail>
</author>

<abstract>
This manual provides a general overview of Portage, detailed
configuration information and an end user guide to installing
and maintaining packages using the Portage system.
</abstract>

<license/>

<version>0.11</version>
<date>August 29, 2004</date>

<chapter>
<title>Portage: An Overview</title>
<section>
<title>Overview</title>
<body>

<warn>
The contents of this document has been moved into the <uri
link="/doc/en/handbook/handbook-x86.xml?part=2">Gentoo Handbook</uri>. Therefore
this document is now obsoleted and only available for historical reasons. Please
use the <uri link="/doc/en/handbook/handbook-x86.xml?part=2">Gentoo
Handbook</uri> instead. If you believe the <uri
link="/doc/en/handbook/handbook-x86.xml?part=2">Gentoo Handbook</uri> is missing
crucial information, please <uri link="http://bugs.gentoo.org">bugreport</uri>
it.
</warn>

<p>
Portage is a very powerful advanced package management system.  Its
flexibility and its ability to serve as either a simple build engine
or to form the heart of a cutting edge Linux distribution earns it
the title of a Meta-distribution Engine.  The Gentoo Linux distribution 
is built around Portage.
</p>

<p>
Gentoo Linux itself is often referred to as a Meta-distribution.  It 
consists of Portage and more than 8000 sets of package build recipes 
called  <e>ebuilds</e>.  These <e>ebuilds</e> tell the Portage 
engine how to compile and install a software package.  Through the
information stored in a <e>profile</e> and the directives passed to the
command-line utility called <c>emerge</c>, users and developers can use
Portage to install and maintain the packages that make up the system,
from its core elements up to the most complex applications.
</p>

<p>
A Gentoo Linux system is "compiled on the fly".  The act of installing
Gentoo Linux does not need any tool other than a working compiler and 
a suitable build environment, through which Portage can download source
code from the Internet and build the rest of the system.  Portage does
support premade binary packages too, but their main purpose is to speed
up the installation process on slow machines, and not to distribute
software updates: through the Portage tree developers can make new
software available to users in a very fast and easy way. Binary packages
can be used also to quickly replicate the installation of an application,
or to distribute software across a cluster of machines.
</p>

<p>
Due to these properties, and the fact that Portage is highly configurable 
in the way it handles compiling and installing packages, very few Gentoo 
Linux installations are identical.  In essence, when a user installs Gentoo 
Linux, the Portage system compiles a customized Linux distribution 
conforming to the options that he specified.
</p>

<p>
At first glance the idea behind Portage may seem similar to the
traditional BSD ports system.  They both compile packages from source
and allow users to safely install and uninstall software from a system
and both automatically handle dependencies.  Many ideas for Portage
are borrowed from the BSD ports system but Portage is definitely not
just another "ports ripoff".
</p>

<p>
The Portage system is a merge of a Python core with Bash script
based <e>Ebuilds</e>.  Instead of dealing with Makefiles and the
<c>make</c> command, Portage leverages the power of Python and the
ease of use of shell scripting with some object oriented
characteristics to make a uniquely powerful system we dare think
puts Portage ahead of all current ports systems.
</p>

<p>
Some of the advanced features Portage offers are the ability
to have multiple versions and revisions of the same package in
the tree, conditional dependency resolution, fine-grained package
management, sandboxed safe installation, configuration file
protection, and much more.  Many of these features are discussed in
detail later in this manual.
</p>

</body>
</section>
<section>
<title>Conditional Dependency Resolution and Slots</title>
<body>

<p>
Portage, as any other package management system, can resolve dependencies;
but one feature that makes it different is the fact that it also supports
conditional dependencies.  Portage has a powerful concept called the
<e>USE setting</e>.  By changing one variable in a Portage configuration
file you can disable optional support (and thus the need to depend on it)
for particular features or libraries at compile time. This is a very
flexible and powerful system which is further explained in the next chapter.
</p>

<p>
In addition Portage supports the concept of <e>SLOT</e>s.  Working on
Gentoo Linux its developers often found that they needed to have multiple
versions of certain packages (such as libraries) installed to satisfy the
demands of other packages. The traditional approach to this problem has
been to treat different versions of the same package as different packages
with slightly different names.
</p>

<p>
Instead of treating certain versions as separate packages, the developers
taught Portage how to handle and maintain several versions of the same package
through the use of <e>SLOT</e>s.  An example comes from the common library
known as freetype.  The 1.x branch of freetype is incompatible with the 2.x
branch but both versions are needed to satisfy the dependencies of various
packages.  Most distributions and ports systems tend to have a "freetype"
package for freetype 1.x and "freetype2" for 2.x.  We consider this approach
a sign of a fundamentally broken package management system.  We simply assigned
the <c>SLOT</c> number 1 to the first and number 2 to the second.  With 
this information Portage can track both versions and upgrade them if updates
to the respective upstream branches are made.
</p>

<p>
Currently, slots cannot be used to install multiple instances of the same
version of a package.  When it will be possible, one could even install the
same version of gcc multiple times (for instance to build cross-compilers for
different architectures). 
</p>

<p>
There are other areas where the support for slots can improve. At the moment
Portage is not able to automatically work out if different versions of a
package can coexist, it must be explicited in ebuilds.  Sometimes Portage
forces users to upgrade their applications to the most recent version even if
the version they have installed is in a different slot.  Moreover, for those
who write ebuilds it is not possible to express the dependency on a specific
slot of a package.
</p>

</body>
</section>
<section>
<title>Profiles</title>
<body>

<p>
A profile contains a list of package names and a set of default configuration
options to be used by Portage. Those files tell Portage which packages
and which specific versions of those packages to allow, disallow, or
treat as required.  Users can switch profiles by changing a single symlink 
(<path>/etc/make.profile</path>). 
</p>

<p>
A profile defines which packages are considered
"core" packages vital to the operation of a system. It
also allows developers to block and unblock specific packages
and versions to temporarily disable broken packages, and more.
With the information in the profile, Portage can choose the ebuild
files to use to actually build and install the main components of the system.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configuring Portage</title>
<section>
<title>Overview</title>
<body>

<p>
The following chapter covers the various aspect of Portage
configuration important to both users and developers.  Portage
is a very flexible system and you will need to understand how
to configure Portage to be in charge of your system and optimize
it for your needs.
</p>

<p>
Please note that the use of "users" in this document means
persons with administrative rights to use Portage and change the
systems configuration.  You must have root access to change
Portage's configuration and to merge and unmerge packages.
</p>

</body>
</section>
<section>
<title>Portage Configuration Files</title>
<body>

<p>
Most of Portage configuration options are expressed by simple variables, which
can be found in <path>/etc/make.conf</path>, <path>/etc/make.conf.example</path>,
<path>/etc/make.profile/make.defaults</path> and <path>/etc/make.globals</path>.
Portage will use the value defined by the current environment variables for
these settings first.  If a setting is not found in the environment, Portage
then checks <path>/etc/make.conf</path>.  If it is not found there, Portage
checks <path>/etc/make.profile/make.defaults</path>.  If the setting is not yet
specified, the default setting is grabbed from <path>/etc/make.globals</path>.
Please note that all user settings should be made in the environment or in
<path>/etc/make.conf</path>, which is intended to be customized.  It is
important to note that any setting defined in <path>/etc/make.conf</path> will
almost always override any setting made in <path>/etc/make.globals</path>.
Everything in <path>/etc/make.conf</path> and <path>/etc/make.globals</path>
can be considered a system-wide global setting as far as Portage is concerned.
</p>

<p>
Portage behaviour is also affected by the content of some files in the
<path>/etc/portage</path> directory. These files are all optional, Portage will
check for their existence and consider them in case.  We will cover some of
these files, such as <path>/etc/portage/package.use</path> and
<path>/etc/portage/package.keywords</path>, later in this guide; for more
information you are encouraged to run <c>man portage</c>: the Portage manual
page includes detailed descriptions for all these files.
</p>

</body>
</section>
<section>
<title>USE settings</title>
<body>

<p>
The USE settings system is a flexible way to enable or disable
various features at package build-time on a global level and for
individual packages.  This allows an administrator control over how 
packages are built in regards to the optional features which can be 
compiled into those packages.  For instance packages with optional
GNOME support can have this support disabled at compile time by 
disabling the <c>gnome</c> USE setting.  Enabling the <c>gnome</c>
USE setting would enable GNOME support in these same packages.
</p>

<p>
The effect of USE settings on packages is dependent on whether both
the software itself and the package ebuild supports the USE setting
as an optional feature.  If the software does not have support for
an optional feature then its corresponding USE setting will obviously
have no effect.  Also many package dependencies are not considered
optional by the software and thus USE settings will have no effect
on those mandatory dependencies.  The list of USE keywords that affect
the compilation and installation af a package can be examined by running
the <c>emerge</c> command with the <c>--verbose</c> flag in addition to
<c>--pretend</c> (See <uri link="#doc_chap3_sect2">Merging Packages</uri>
in <uri link="#doc_chap3">Package Management</uri>).  To see what each
flag does in detail, you can use the <c>equery</c> command (in
<c>app-portage/gentoolkit</c>).
</p>

<p>
The complete list of global USE settings used by Gentoo Linux, along
with their description, can be found in
<path>/usr/portage/profiles/use.desc</path>.  Occasionally, an ebuild
can be affected by USE settings which are specific to that single
package and that are not present in <path>use.desc</path>.  These
settings are called local USE flags and are listed in
<path>/usr/portage/profiles/use.local.desc</path>.
</p>

<p>
Portage determines if a USE setting is enabled or disabled by checking the
USE variable in four different locations, and also looking at the entries in
<path>/etc/portage/package.use</path>, if present.  These locations change
USE settings in a way that "stacks".  Portage passes through each location and 
remembers if a previous location enabled or disabled a setting.
USE setting changes are cumulative during Portage's pass through
each location.
</p>

<p>
The variables checked in USE setting calculation and the order in which
Portage checks them is set by <c>USE_ORDER</c> in 
<path>/etc/make.globals</path>. To disable a variable you can simply remove it 
from <c>USE_ORDER</c>.
</p>

<p>
The following is a description of each location listed in the order
defined by <c>USE_ORDER</c> in Portage's default configuration.
</p>

<p>
<b>Defaults</b>
</p>

<p>
Portage profiles can define a set of default USE keywords.  This 
is defined in the <path>make.defaults</path> file in any Portage profile.
Since <path>/etc/make.profile</path> serves as a link to the currently used
Portage profile, <path>/etc/make.profile/make.defaults</path> is the set 
of defaults in effect.  It is recommended that you do not edit this file 
as future profile changes may overwrite your changes.
</p>

<p>
<b>Auto</b>
</p>

<p>
These are defined in the <path>use.defaults</path> file in the Portage profile 
(<path>/etc/make.profile/use.defaults</path>).  Each entry consists of a USE
setting and a corresponding package.  If the package listed for
a USE keyword is currently installed, then that USE setting is
considered enabled.  Thus, for instance, if you installed
<c>dev-db/mysql</c> and did not explicitly disable the <e>mysql</e> USE
setting in a later pass location then the <e>mysql</e> keyword is enabled
globally while that package is installed.  It is recommended that
you do not edit this file as future profile changes may overwrite
your changes.
</p>

<p>
<b>Conf</b>
</p>

<p>
If a <c>USE</c> configuration option is defined in 
<path>/etc/make.conf</path> the USE settings defined are included.  If 
there is no <c>USE</c> setting in <path>make.conf</path> then 
<path>/etc/make.globals</path> is checked.  This entry could look something
like the following:
</p>

<pre caption="USE entry">
USE="slang readline gpm berkdb gdbm tcpd pam libwww ssl gb tk
lm_sensors lvm ldap tex bonobo sdl gtk xfs evo pda ldap
mmx mitshm perl python guile ruby postgres dvd 3dnow tcl
lcms gif sdl vorbis ogg oss libg++ directfb decss snmp
gnome X opengl mozilla pdflib gpg -nls gd xface jpilot
-kde -qt -esd -motif -alsa oggvorbis"
</pre>

<p>
USE settings are enabled by simply listing the setting name.  USE
settings are disabled by placing a <c>-</c> character before the
setting name.  For instance, <c>gnome</c> enables the GNOME keyword
while <c>-motif</c> disables the motif keyword.
</p>

<p>
The <c>USE</c> setting in <path>/etc/make.conf</path> is the recommended 
place in which to explicitly enable and disable keywords.  This file will
not be overwritten automatically by Portage.  It is recommended
that you specifically enable and disable USE keywords that you
do not want to be disabled or enabled by the previous two locations.
</p>

<p>
<b>Env</b>
</p>

<p>
USE keyword settings can be overrode manually using a shell
environment setting.
</p>

<pre caption = "Overriding USE keywords">
# <i>export USE="-gnome"</i>
# <i>emerge net-im/gaim</i>
</pre>

<p>
This allows the use of a certain set of USE settings for the merging
of one or more specific packages.  Any invocation of emerge after
setting USE in the shell environment will be in effect as long as
emerge is run from that shell and USE is still set.
</p>

<note>
The special keyword <c>-*</c> can be used to disable all USE settings.
For instance setting <c>USE="-* ssl"</c> on the command line or in
<path>/etc/make.conf</path> has the effect of disabling every USE
setting except <c>ssl</c>.
</note>

<p>
Note that if the package is remerged or upgraded in the future it will use
the USE keywords currently in effect and not the USE settings defined
when it was first merged.  To specify an USE setting relative to a specific
package in a persistent way, you can add an entry to
<path>/etc/portage/package.use</path> as shown in the example below.
That entry will assure that each time <c>net-im/gaim</c> is built, the
<c>gnome</c> setting is disabled.
</p>

<pre caption = "Using /etc/portage/package.use">
<comment>add this line to /etc/portage/package.use:</comment>
net-im/gaim -gnome
</pre>

</body>
</section>
<section>
<title>Compiler Options</title>
<body>

<p>
The compiler options used by Portage to compile packages can be set
in <path>/etc/make.conf</path> by editing <c>CHOST</c>, <c>CFLAGS</c>, and 
<c>CXXFLAGS</c>. The <c>CHOST</c> setting specifies which platform
you are compiling for and <c>CFLAGS</c> and <c>CXXFLAGS</c> settings
specify compiler flags to be used while compiling C and C++
respectively.
</p>

<p>
Several sets of default settings are offered with comments on which
platforms they are to be used with.  These provided defaults are 
considered stable and tested.  Changing them may uncover compile 
errors and bugs in both the compiler and in the software being 
compiled.  Please be careful if you decide to customize a default 
setting as you may end up with an unusable system.
</p>

<p>
Users with multiprocessor systems may benefit by modifying the
<c>MAKEOPTS</c> option found in <path>/etc/make.globals</path>.  This option
is passed to the <c>make</c> command during package compilation
to enable multiple gcc instances.
</p>

</body>
</section>
<section>
<title>Directory Locations</title>
<body>

<p>
Portage allows you to configure the directories it uses 
to build packages and where it stores various files.  Most users
will have no need to change these locations.  The following
options can be set:
</p>

<ul>
  <li>
    <c>PORTDIR</c> - Location of the Portage tree.
  </li>
  <li>
    <c>DISTDIR</c> - Local cache of downloaded archives.
  </li>
  <li>
    <c>PKGDIR</c> - Location of locally generated tbz2 packages.
  </li>
  <li>
    <c>PORTAGE_TMPDIR</c> - Temporary space used for package compilation.
  </li>
  <li>
    <c>PORT_LOGDIR</c> - Location used to store log files from individual merges.
    Logging is disabled if this variable is not set.
  </li>
  <li>
    <c>PORTDIR_OVERLAY</c> - Location used to hold a local customized portage tree.
    Portage looks here before searching in PORTDIR.
  </li>
</ul>

</body>
</section>
<section>
<title>Configuration File Protection</title>
<body>

<p>
Portage allows for the protection of all configuration files in
specified directories.  Portage will not overwrite files in protected
directories.  If a package tries to install a file that already
exists, it will be renamed to something like <path>._cfg0000_name</path>.
This is done so that users can later look at the new file and 
manually merge the differences between the two themselves.
</p>

<p>
Protected directories can be set by <c>CONFIG_PROTECT</c> in either
<path>/etc/make.conf</path> or <path>/etc/make.globals</path>.  Specific 
files and subdirectories under protected directories can be made 
unprotected by setting <c>CONFIG_PROTECT_MASK</c>.
</p>

<p>
The following is an example and should not be blindly copied:
</p>

<pre caption = "Protecting certain directories or files">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/2/share/config"
CONFIG_PROTECT_MASK="/etc/gconf /etc/init.d /etc/pam.d"
</pre>

<p>
Users may request more information on how Configuration File 
Protection works by issuing the following command in a shell:
</p>

<pre caption = "More information about Configuration File Protection">
# <i>emerge --help config</i>
</pre>

</body>
</section>
<section>
<title>FEATURES</title>
<body>

<p>
Portage offers a number of options geared towards developers
that govern how Portage behaves and cleans up after itself during
various stages of a package merge.  These options should only
be of interest to developers and may cause problems for users.
</p>

<p>
A list of features to enable can be set by <c>FEATURES</c> in
either <path>/etc/make.conf</path> or <path>/etc/make.globals</path>. The 
following is a list of the most important options, see
<path>/etc/make.conf.example</path> for details.
</p>

<ul>
  <li><c>buildpkg</c> : Create binary packages for every ebuild you merge.</li>
  <li>
    <c>ccache</c> : Enables support for compiler cache if <c>dev-util/ccache</c>
    is installed.
  </li>
  <li>
    <c>collision-protect</c> : Makes Portage fail if a package tries to
    overwrite a file owned by another package or by no package at all.
  </li>
  <li><c>digest</c> : Automatically create a digest for new ebuilds.</li>
  <li>
    <c>distcc</c> : Use the distributed compiling offered by
    <c>sys-devel/distcc.</c>
  </li>
  <li><c>keeptemp</c> : Do not remove the temporary files after a merge.</li>
  <li><c>keepwork</c> : Do not remove the sources used for compilation.</li>
  <li><c>noauto</c> : Do not execute prior ebuild steps automatically.</li>
  <li><c>noclean</c> : Portage never cleans up after itself.</li>
  <li><c>nostrip</c> : Prevents stripping of binaries.</li>
  <li><c>notitles</c> : Disables xterm titlebar updates.</li>
  <li><c>sandbox</c> : Enables "sandbox" for safe merges.</li>
  <li><c>strict</c> : Be strict when checking the digest and Manifest files.</li>
  <li><c>userpriv</c> : Drop root privileges during compilation.</li>
  <li><c>usersandbox</c> : Use sandboxing when <c>userpriv</c> is activated.</li>
</ul>

</body>
</section>
<section>
<title>Portage SYNC settings</title>
<body>

<p>
Portage has the ability to update the Portage tree through rsync or cvs.
The protocol used for communication and the server to contact to perform
the sync are defined via the <c>SYNC</c> setting in
<path>/etc/make.conf</path>.
</p>

<p>
<b>RSYNC</b>
</p>

<p>
rsync is the most common way to keep your Portage
tree up to date. The rsync method is set in <path>/etc/make.conf</path> as
follows (only one entry is allowed):
</p>

<pre caption = "Setting the SYNC variable">
SYNC="rsync://rsync.gentoo.org/gentoo-portage"
</pre>

<note>
The rsync method will blindly overwrite any changes you make
to your local copy of the Portage tree.  If you need to keep
local changes, use <c>PORTDIR_OVERLAY="/some/dir/where/you/keep-your-tree"</c>
to protect your own changes.
</note>

<note>
See <path>/etc/make.conf.example</path> for how to set <c>SYNC</c> to retrieve
a localized rsync mirror rotation.  This will select servers that are 
geographically closer to you, which usually translates to higher transfer 
speeds.  It will also help to distribute the load over a number of servers.
</note>

<p>
There are a number of variables that affect the way Portage does the sync and
that can be set in <path>/etc/make.conf</path>:
</p>

<ul>
  <li>
    <c>RSYNC_RETRIES</c> - The number of times to try the sync before giving up.
  </li>
  <li>
    <c>RSYNC_TIMEOUT</c> - Number of seconds to wait before dropping the
    connection.
  </li>
  <li>
    <c>RSYNC_EXCLUDEFROM</c> - Specifies a file that lists paths that should not
    be retrieved from the rsync server. Be careful as you risk to break
    dependencies when using this option.
  </li>
</ul>

<p>
<b>Developer CVS</b>
</p>

<p>
Developers with full access to the CVS tree can also have
<c>emerge</c> sync the local tree against a CVS repository that
they can access through SSH.
</p>

<p>
Simply check out a CVS tree using your account, move it to 
/usr/portage, and use the following <c>SYNC</c> option:
</p>

<pre caption = "Using CVS for your Portage tree">
SYNC="cvs://youraccount@cvs.gentoo.org:/var/cvsroot"
</pre>

</body>
</section>
<section>
<title>Mirrors</title>
<body>

<p>
The Gentoo Project keeps a local mirror of all archive files
referenced in ebuilds in the Portage tree.  Often upstream source
tarballs are kept on slow servers that may often be down.  Also
upstream developers will remove older versions of software from an 
ftp site when new versions are released.  To make life easier for people
using the Gentoo distribution (and reduce the upstream source site's 
bandwidth usage) we mirror these files.  This allows for faster and 
more reliable downloading of these archive files from one of many 
mirror sites close to your physical location.
</p>

<p>
Whenever you attempt to merge a package, Portage will first check
our mirror sites for the needed archives.  If the mirror sites do not
have the needed files then Portage tries to download them from the
HTTP or FTP server specified in the package ebuild.
</p>

<p>
The mirrors Portage uses can be specified by <c>GENTOO_MIRRORS</c> 
in <path>/etc/make.conf</path> (as a space separated list).  The
following is the current default setting:
</p>

<pre caption = "Declaring a mirror">
GENTOO_MIRRORS="http://www.ibiblio.org/gentoo"
</pre>

<p>
To find a Gentoo mirror closer to your location please check the
Gentoo web site or ask your local friendly mailing list. You can
also install <c>mirrorselect</c> to automatically find the closest
mirror. Please see the installation guide for more information on
how to use <c>mirrorselect</c>.
</p>

</body>
</section>
<section>
<title>Downloading Program</title>
<body>

<p>
The program which Portage uses to download archive files can
be specified by setting the <c>FETCHCOMMAND</c> and 
<c>RESUMECOMMAND</c> settings.  Several examples are shown
in <path>/etc/make.conf.example</path> and <path>/etc/make.globals</path>.  
Portage uses <c>wget</c> by default which should serve most users needs.
</p>

</body>
</section>
<section>
<title>Proxies</title>
<body>

<p>
Portage can be instructed to use both HTTP and FTP proxies
when downloading files.  The proxies can be specified by setting 
<c>HTTP_PROXY</c> and <c>FTP_PROXY</c> in either <path>/etc/make.conf</path>
or <path>/etc/make.globals</path>.  If both HTTP and FTP are served from the
same proxy, you can set <c>PROXY</c> instead.
</p>

<p>
The following is an example:
</p>

<pre caption = "Setting proxies">
HTTP_PROXY="http://192.168.1.1:8080"
FTP_PROXY="http://192.168.1.1:8080"
<comment>or</comment>
PROXY="http://192.168.1.1:8080"
</pre>

<p>
Portage can also be instructed to use an HTTP proxy for use
with RSYNC.  RSYNC proxy use can be configured by setting the
RSYNC_PROXY option in <path>/etc/make.conf</path> or by setting it as 
an environment variable.
</p>

<p>
The following is an example:
</p>

<pre caption = "Setting RSYNC proxy">
RSYNC_PROXY="192.168.1.1:8080"
</pre>

<note>
If you are firewalled from the outside world and rsync
seems unable to use your HTTP proxy, you can update your Portage
tree using a snapshot tarball.  See our <uri
link="/doc/en/faq.xml#norsync">FAQ</uri> for more information.
</note>

</body>
</section>
<section>
<title>Other Options</title>
<body>

<p>
The options explained above do not complete the list of what you can tweak in
<path>/etc/make.conf</path>. These are some other options that may be useful
for you:
</p>

<ul>
  <li>
    <c>NOCOLOR</c> : Allows users to disable the use of colors in output from 
    the emerge tool.
  </li>
  <li>
    <c>CLEAN_DELAY</c> : Portage delays unmerging of a package by a defined 
    number of seconds to give users time to cancel.  This specifies the number 
    of seconds to wait and can be disabled by setting it to "0".
  </li>
  <li>
    <c>PORTAGE_NICENESS</c> : The value of this variable is added to the nice
    value which emerge uses when running.
  </li>
  <li>
    <c>PORTAGE_BINHOST</c> : This variable stores a remote location (http or
    ftp) where Portage tries to find precompiled binary packages. It is useful
    to distribute binary packages across a cluster of machines. At the moment
    there are no official Gentoo servers providing binary packages.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Package Management</title>
<section>
<title>Updating The Portage Tree</title>
<body>

<p>
The Portage tree, located within <path>/usr/portage</path>, contains the library
of build instructions for various packages (called <e>ebuilds</e>).
The tree also contains profile and masking information which
is vital for keeping your system up to date.  It is important to keep 
this tree updated and in sync with the official Portage tree in order
to have the newest versions of packages and bug fixes available to you.
You can update the Portage tree by issuing the following command:
</p>

<pre caption = "Updating Portage Tree">
# <i>emerge sync</i>
</pre>

<p>
The method emerge uses to update the local Portage tree can be 
changed.  See <uri link="#doc_chap2_sect8">Portage SYNC settings</uri> in the 
<uri link="#doc_chap2">Configuring Portage</uri> chapter for more information.
</p>

</body>
</section>
<section>
<title>Merging Packages</title>
<body>

<p>
The act of compiling and installing a package through Portage
is referred to as <e>merging</e>.  Portage compiles packages
and temporarily installs them to an "image" directory where it 
records the files to be installed.  These files are then moved from
the image directory and merged with the real / filesystem. 
</p>

<p>
The <c>emerge</c> command serves as the front-end of the Portage
system.  The installation and removal of packages is controlled
by using this command and its various command-line arguments.
</p>

<p>
To install the newest version of a given package simply specify the
package name like the following:
</p>

<pre caption = "Installing a package">
# <i>emerge galeon</i>
</pre>

<p>
The command will compile and install any needed dependencies (taking 
into account any USE settings) and then compile and install the 
newest available version of galeon (see the
<uri link="#doc_chap4">Package Availability</uri> chapter below to find out
when packages are available).  Galeon could also have been referred to
using fully qualified name with category: <c>net-www/galeon</c>.
</p>

<p>
Portage also allows for a specific versions of a package to be merged.
This is done by defining a <e>range</e> of versions, among which Portage will
select the best match available. Ranges are specified using the operators
<c>=</c> (exact version), <c>&lt;</c> (less then), <c>&gt;</c> (greater than),
<c>&lt;=</c> (less then or equal to), and <c>&gt;=</c> (greater than or equal
to).  The following would merge tha best version of galeon older than or equal
version 1.3:
</p>

<pre caption = "Defining a range of packages">
# <i>emerge "&lt;=net-www/galeon-1.3"</i>
</pre>

<p>
When specifying package ranges it is important to quote <c>&gt;</c>
and <c>&lt;</c> characters so your shell does not interpret them.
Also you will need to specify the category in the package name as 
shown in the example.  For another example of how package
range specifications work see <c>emerge --help</c>.
</p>

<p>
In addition to selecting the package name and version to be merged,
<c>emerge</c> supports several very useful command line arguments.
Of these arguments <c>--pretend</c> is perhaps the most useful.  When
this argument is used the intended action is not performed.  Instead
Portage displays a list of packages that would have been installed
or updated while performing the action.  The following is an example
listing of what would have been merged during the installation
of the latest version of the kdevelop package:
</p>

<pre caption = "Checking what emerge will do">
# <i>emerge --pretend kdevelop</i>

These are the packages that I would merge, in order.

Calculating dependencies ...done!
[ebuild  N   ] kde-base/kdelibs-2.2.2-r4 to /
[ebuild  N   ] dev-util/kdbg-1.2.2 to /
[ebuild   U  ] app-text/psutils-1.17 to /
[ebuild   U  ] app-text/a2ps-4.13b-r3 to /
[ebuild   U  ] app-text/jadetex-2.20 to /
[ebuild  N   ] app-text/sgmltools-lite-3.0.3-r2 to /
[ebuild  N   ] kde-base/kdoc-2.2.2-r1 to /
[ebuild  N   ] net-www/htdig-3.1.5-r2 to /
[ebuild  N   ] app-text/enscript-1.6.3-r1 to /
[ebuild  N   ] kde-base/kdebase-2.2.2-r2 to /
[ebuild  N   ] app-doc/qt-docs-2.3.1 to /
[ebuild  N   ] dev-util/kdevelop-2.0.2 to /
</pre>

<p>
In the above listing, packages marked with a <c>N</c> are
packages which have not yet been installed and would be installed
during this action.  Packages marked with a <c>U</c> indicate
that an older version of the package was already installed and the
action would upgrade the package.
</p>

<p>
Other common options are:
</p>

<p>
<c>--update</c> : Updates packages with their direct dependencies to
the best version available.
</p>

<p>
<c>--ask</c> : Before performing the merge, display what ebuilds and
binary packages will be installed, in the same format as when using
--pretend; then ask whether to continue with the merge or abort.
</p>

<p>
<c>--fetchonly</c> : Downloads the needed archive files for compiling
the package to be installed and any dependencies that need to be met.
</p>

<p>
<c>--emptytree</c> : This option makes Portage pretend that none of the
dependencies of this package or the packages it depends upon are 
installed.  This is useful with <c>--pretend</c> to display a complete
tree of dependencies for any particular package.  
</p>

<p>
<c>--nodeps</c> : Portage attempts to merge only the specified
packages and ignores any dependencies.  If you do not have the 
appropriate dependencies already installed then compilation may
fail.
</p>

<p>
<c>--onlydeps</c> : Only dependencies for a given package are
merged.  The specified package is <b>not</b> merged.
</p>

<p>
<c>--noreplace</c> : Skips the merge of specified packages if they
are already installed.
</p>

<p>
<c>--deep</c> : When used in conjunction with <c>--update</c>, this flag
forces emerge to update the entire dependency tree of packages,
instead of checking only the immediate dependencies of the packages.
</p>

<p>
<c>--usepkg</c> : Instead of compiling the specified packages
Portage will attempt to use pre-compiled tbz2 packages from a specified
location.  The location is specified by the <c>PKGDIR</c> variable.
</p>

<p>
<c>--usepkgonly</c> : Like <c>--usepkg</c> above, except this only allows the
use of binary packages, and it will abort the emerge if the package is
not available at the time of dependency calculation.
</p>

<p>
<c>--buildpkg</c> : Tell emerge to build binary packages for all ebuilds
processed.
</p>

<p>
<c>--buildpkgonly</c> : Tell emerge to build binary packages without
merging the ebuilds.
</p>

<p>
<c>--oneshot</c> : Emerge as normal, but don't add packages to the world
file.
</p>

<p>
<c>--debug</c> : The ebuild environment is instructed to become 
much more verbal.  This is useful for developers trying to track 
down syntax errors in bash script based ebuild files.
</p>

<p>
<c>--tree</c> : Shows the dependency tree using indentation for dependencies.
</p>

<p>
<c>--verbose</c> : Tells <c>emerge</c> to run in verbose mode.
When used in conjunction with <c>--pretend</c> it shows the USE
flags that a certain package uses.
</p>

</body>
</section>
<section>
<title>Unmerging Packages</title>
<body>

<p>
The act of "unmerging" is to remove the files associated with
an installed package from the filesystem.  The software in the package
is removed from the system and can no longer be used until it is 
remerged.
</p>

<p>
Packages are removed by invoking the <c>emerge</c> command and
specifying the <c>--unmerge</c> argument followed by the name of the
package to be removed.  The following example would unmerge all
installed versions of the <c>ltrace</c> package:
</p>

<pre caption = "Unmerging packages">
# <i>emerge --unmerge ltrace</i>
<comment>or</comment>
# <i>emerge --unmerge dev-util/ltrace</i>
</pre>

<p>
You can also specify a range of packages using the same syntax seen
for merging. The following would unmerge all versions of ltrace equal
to version 0.3.15 and older:
</p>

<pre caption = "Unmerging specific versions of a package">
# <i>emerge --unmerge "&lt;=dev-utils/ltrace-0.3.15"</i>
</pre>

<warn>
Unmerging packages can be dangerous.  If you remove any
core packages your system may cease to function and 
the removal of various libraries may cause software to fail.
<b>Portage does not warn you if you are removing core packages
or dependencies for other packages.</b>
</warn>

<p>
Remember to use the <c>--pretend</c> option to see what is going
to happen before you actually unmerge something. For further safety,
when you run the unmerge command Portage will wait a few seconds
before the unmerge begins.  During this waiting period you may press
Control-C to interrupt the operation.
</p>

<p>
Once the unmerge begins you will see a long list of filenames 
belonging to the package displayed.  Some of these filenames
will have a flag displayed to the left of the filename.
The flags <c>!mtime</c>, <c>!empty</c>, and <c>cfgpro</c> specify
reasons why certain files were not removed when this package
was unmerged.  Files listed without any of these three flags
were removed from the filesystem successfully.
</p>

<p>
The <c>!mtime</c> flag means the file was modified after this specific 
version of the package was installed.  This means that someone
edited this file after the package was installed or some other package
overwrote the file at a later time.  This allows for packages to be
updated to newer versions without fear that unmerging the older
installed version will remove vital files.  
</p>

<p>
The <c>!empty</c> flag refers to directories which Portage refuses 
to remove due to the directory not being empty (multiple packages 
often claim ownership to the same directories).  Configuration File 
protection kicks in when you see the <c>cfgpro</c> flag.  This means 
a newer installed package is claiming ownership of this particular
configuration file and Portage refuses to remove it.
</p>

</body>
</section>
<section>
<title>System Update</title>
<body>

<p>
Portage supports the ability to upgrade installed packages
automatically with a single command.  The system update feature
allows users to update the "core" packages to versions recommended
by Gentoo core developers as being important to the operation
of any Gentoo Linux system.  A system update does not update
nonessential packages, only those packages defined in the Portage
profile as being essential for the operation and maintaince of 
a system.
</p>

<p>
To perform a system update issue the following command:
</p>

<pre caption = "Updating your system">
# <i>emerge --update system</i>
</pre>

<p>
Portage will then compile and install updates depending on
what versions and packages you have installed and what is recommended
by the current Portage profile.  Users can use the <c>--pretend</c>
argument with the above example to get a list of what would be
installed and upgraded during this action.
</p>

<note>
You will notice in the install instructions that one of the
first steps is to run <c>emerge system</c> to install the base
(or "core") packages.  <c>emerge --update system</c> updates
those base packages to the latest recommended versions.
</note>

</body>
</section>
<section>
<title>World Update</title>
<body>

<p>
Portage also supports the ability to automatically upgrade
selected non-essential packages with a single command.  The portage
system has a degree of intelligence built into it to allow for the 
safe upgrading of a system where multiple versions of conflicting 
packages may be available.
</p>

<p>
When doing a world update, Portage tries to upgrade all packages mentioned
in the <path>world</path> file to the newest version available, assuring that
each dependency listed in the ebuild files associated to these packages is
satisfied (taking in accout ranges of versions, if necessary).  If Portage is
run with the <c>--deep</c> option it will also consider all these dependencies
and will try to upgrade them, too.  The dependency resolution also takes into
consideration <c>SLOTS</c> as mentioned in a previous chapter.
</p>

<p>
The heart of Portage's world update is the <path>world</path> file.  Unlike
the system profile which is usually defined by developers and never
touched by users, the <path>world</path> file is generated indirectly
over time by actions performed by the user.
The <path>world</path> file operates much like a "favorites list".
Packages that are manually installed by the user through use of the
<c>emerge</c> command are recorded in the file located at
<path>/var/lib/portage/world</path>.  Portage assumes that if you took
the effort to install the package, then you must have some interest in keeping
it up to date.
</p>

<p>
The <path>world</path> file consists of one package name with category per
line and may look something like the following:
</p>

<pre caption = "/var/lib/portage/world example">
net-im/gaim
net-www/skipstone
net-www/galeon
app-editors/vim
app-text/ispell
net-mail/evolution
dev-util/ltrace
sys-fs/xfsprogs
sys-apps/attr
sys-apps/dmapi
sys-kernel/linux-sources
sys-apps/acl
app-office/gnucash
app-cdr/xcdroast
</pre>

<p>
Almost all of the entries in this example file were added 
automatically by Portage when the user manually merged the specific 
packages.  These packages will be upgraded if a newer version is 
available.
</p>

<note>
To save time and make sure your favorite packages are kept updated
you may manually edit the <path>world</path> file and add entries for these
packages.  You can also add entries to the <path>world</path> file in the form of ranges
of packages.
</note>

<p>
World updates are done using the following command:
</p>

<pre caption = "Updating everything">
# <i>emerge --update world</i>
</pre>

<warn>
Portage will not overwrite files in directories protected
by Configuration File Protection.  You will need to manually
merge the differences between your current configuration files
and the new versions Portage saved for you.  If you do not
update your configuration files installed software may stop 
functioning.  Please see <uri link="#doc_chap2_sect6">Configuration File 
Protection</uri> in the <uri link="#doc_chap2">Configuring Portage</uri> 
chapter or use the command <c>emerge --help config</c> for more information.
</warn> 

<p>
To view a list of what would be updated or installed during 
a world update, you can use the <c>--pretend</c> argument as 
mentioned in previous sections of this chapter.
</p>

<note>
A world update also performs a system update automatically.  
</note>

<p>
An interesting side effect of how world update works can
be exploited by users wishing to recompile all installed software
on a system.  Since world update will try to update all packages
mentioned in the <path>world</path> file and their dependencies, the use
of the argument <c>--emptytree</c> is a way of forcing the recompile
of these packages and every dependency.
This can be useful for users wishing to change their compiler options
or USE keyword settings and want these changes to be used by all
the software they use without manually remerging every package.
Simply populate the <path>world</path> file with all your commonly used
applications and issue the following command: 
</p>

<pre caption = "Recompile all dependencies too">
# <i>emerge --emptytree world</i>
</pre>

<p>
You can add the <c>--pretend</c> argument to this command to get a 
list of packages that would be recompiled as a result of this action.
</p>

</body>
</section>
<section>
<title>Cleaning System</title>
<body>

<p>
Portage supports the ability to install multiple versions
of the same package on top of each other.  However, when a newer
version of a package is installed Portage automatically removes
the old version (unless it has a different SLOT).
</p>

<p>
This behaviour can be turned off by setting <c>AUTOCLEAN=no</c>
in <path>/etc/make.conf</path>.  If you do so, you can manually clean your
system from old version of installed packages using the <c>--clean</c> action
of emerge:
</p>

<pre caption = "Remove older versions of packages">
# <i>emerge --clean</i>
</pre>

<p>
<c>emerge</c> will then display a list of package revisions and 
versions to be removed, the versions that will remain, and give
the user time to cancel out of the action by pressing Control-C.
</p>

<p>
Unless specified, Portage assumes the clean action is to be
performed for the <path>world</path> (all installed packages).  You can
narrow the scope of the clean action by using options such as 
<c>world</c>, <c>system</c>, a list of package names, and package 
version ranges as mentioned at the beginning of this chapter.
</p>

<p>
When considering which package versions should be removed the 
Portage system considers the various profiles, the needs of other
installed packages, and packages SLOT.  Assuming dependencies
are correctly defined for all packages, the clean action will
safely remove old packages from system and should not remove any
functionality or prevent the system from functioning.
</p>

<p>
Portage has also a more aggressive way to clean the system: with
the <c>--depclean</c> action of emerge you can find and remove all
those packages that are currently installed but that are not needed
anymore, in other words, Portage will remove packages that are not
listed in the <path>world</path> file and that are not dependencies
of other packages.
</p>

<p>
The <c>--depclean</c> option can be dangerous, remember to always use
<c>--pretend</c> and to double check what Portage is going to do.
</p>

<pre caption = "Finding useless packages">
# <i>emerge --pretend --depclean</i>
</pre>

<p>
Portage also supports a package <c>--prune</c> action.   The prune
action is an unsafe form of the clean.  It removes all versions
of all packages except for the last installed version.  It does
not perform many of the checks <c>--clean</c> performs and can
remove essential dependencies from your system.  Users of this 
option can easily break their systems and its use is not recommended
except in specific specialized circumstances.
</p>

<p>
The <c>--prune</c> action accepts the same list of options as the
<c>--clean</c> action and can be used like the following:
</p>

<pre caption = "Pruning the system">
# <i>emerge --prune</i>
</pre>

</body>
</section>
<section>
<title>Searching The Portage Tree</title>
<body>

<p>
Portage Trees such as the one that forms the heart of the Gentoo
Linux distribution can be quite large.  The <c>emerge</c> command
provides a search feature which accepts a search string in the form
of a regular expression contained in quotes.  Regular expressions
are very complicated beasts so it is recommended you find a good book
on the topic if you are interested in fully using regular expressions.
</p>

<p>
Most simple searches can be done without knowing how to form
regular expressions.  The following is an example of a simple search 
for a package either named "gcc" or having "gcc" as part of its name:
</p>

<pre caption = "Searching for a regexp">
# <i>emerge --search gcc</i>
</pre>

<p>
For each match the search action lists the package name, newest 
available version, newest version installed, its home page, and
a description of the software contained in the package.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Package Availability</title>
<section>
<title>Introduction</title>
<body>

<p>
As you probably already noticed, there is a large number of ebuild files in the
Portage tree that correspond to package versions not appearing when you
issue the <c>emerge</c> command: all these ebuild files are unavailable for
some reason.  The different reasons that can make an abuild unavailable are
discussed in the following sections.
</p>

</body>
</section>
<section>
<title>Keywords</title>
<body>

<p>
Each ebuild file in the Portage tree includes the definition of a variable
named <c>KEYWORDS</c>. This variable stores a list of strings, for instance
<c>"x86 ~amd64 -ppc"</c>. Taking as an example the <c>x86</c>
arch, let us explain what each keyword means.
</p>

<ul>
  <li>
    <c>x86</c> : if this keyword is present, the ebuild is stable and available
    (for the x86 architecture).
  </li>
  <li>
    <c>~x86</c> : if this keyword is present, the ebuild is in testing phase
    (for the x86 architecture).
  </li>
  <li>
    <c>-x86</c> : if this keyword is present, the ebuild is known to not work
    on the x86 architecture.
  </li>
</ul>

<p>
If no keyword is present related to an architecture, it means that the ebuild
has never been tested on that architecture.  The special keyword <c>-*</c> is
used to point out that the ebuild cannot work on any arch except those
explicitely added to <c>KEYWORDS</c>.
</p>

<p>
By default, Portage will only consider packages that are marked stable on the
architecture of the host machine, ignoring all the other ebuilds.  As a result,
users are presented with updates for new software only when the ebuilds for
that software exit the testing phase and are assigned the stable keyword.
</p>

<p>
To override this behaviour, experienced users can set the
<c>ACCEPT_KEYWORDS</c> variable in <path>/etc/make.conf</path> specifying a
list of keywords that Portage should consider.  Usually daring users on x86 (or
amd64, ppc, ...) let Portage consider all the ebuilds that are being currently
tested adding ~x86 (or ~amd64, ~ppc, ...) to <c>ACCEPT_KEYWORDS</c>.
</p>

<pre caption = "Setting ACCEPT_KEYWORDS">
ACCEPT_KEYWORDS="~x86"
</pre>

<p>
In this way all the software installed is kept in sync with the most recent
updates, at the price of risking to install a not well-tested package that
can occasionally disrupt the entire system.
</p>

<p>
A safer way to stay current is to manually tell Portage to take into
consideration all testing ebuilds of a specific package.  This can be done
using the <path>/etc/portage/package.keywords</path> file: for instance if we
want Portage to give us access to the ~x86 version of gimp, we just add an
entry in <path>/etc/portage/package.keywords</path> as follows:
</p>

<pre caption = "Using /etc/portage/package.keywords">
<comment>add this line to /etc/portage/package.keywords:</comment>
media-gfx/gimp ~x86
</pre>

</body>
</section>
<section>
<title>Maskings</title>
<body>

<p>
When a package is known to create problems, because it is not functioning
well or because of bad or dangerous interaction with the rest of the system,
there's a stricter way to prevent it from being installed by users.  This
way consist in listing the offending package (or range of package versions)
in one of some special <e>masking</e> files. 
</p>

<p>
Apart from <path>/etc/make.profile/packages</path>, which holds some ranges of
versions that packages should fall into be considered acceptable, Portage
looks for maskings in <path>/usr/portage/profiles/package.mask</path> (which is
updated at each sync) and in <path>/etc/portage/package.mask</path> (which can
be filled by the user with customized maskings).  So, if portage finds a
package listed in one of these files, it will absolutely ignore it.
</p>

<p>
If you want to override a masking in
<path>/usr/portage/profiles/package.mask</path>, you are adviced to not
directly modify that file, since the modification will be lost at the next
sync.  Instead, Portage provides a simple method of ignoring a masking through
the use of <path>/etc/portage/package.unmask</path>.  For example, if there's
an experimental version of portage that is currently masked and you want to try
it out, just add an entry to <path>/etc/portage/package.unmask</path> as
follows.
</p>

<pre caption = "Using /etc/portage/package.unmask">
<comment>add this line to /etc/portage/package.unmask:</comment>
sys-apps/portage
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Resources</title>
<section>
<title>Getting Help</title>
<body>

<p>
More information on the many options and actions <c>emerge</c>
supports can be found by issuing the following commands:
</p>

<pre caption = "Getting help">
# <i>emerge --help</i>
# <i>man emerge</i>
# <i>man make.conf</i>
</pre>

<p>
Other useful informations about Portage can be found in the portage man page:
</p>

<pre caption = "Viewing the portage man page">
# <i>man portage</i>
</pre>


</body>
</section>
<section>
<title>Useful Utilities</title>
<body>

<p>
Several utilities have been developed over time
to make life easier.  Some of them are installed with Portage itself, while
some other are available as external packages.
</p>

<ul>
  <li>
    <c>etc-update</c> : shell script used to assist with the
    merging of <path>/etc</path> files (can be dangerous if used incorrectly).
  </li>
  <li>
    <c>dispatch-conf</c> : feature-rich replacement for <c>etc-update</c>.
  </li>
  <li>
    <c>equery</c> (in app-portage/gentoolkit): this is the main tool to
    extract information from portage, such as which files a package owns,
    which package owns a given file, and much more.
  </li>  
  <li>
    <c>qpkg</c> and <c>etcat</c> (in app-portage/gentoolkit): they are the
    ancestors of <c>equery</c>.  Their functionalities are being migrated to
    <c>equery</c>.
  </li>
  <li>
    <c>revdep-rebuild</c> (in app-portage/gentoolkit): rebuild packages that
    were broken when updating libraries that have incompatible binary APIs.
  </li>
  <li>
    <c>epm</c> (app-portage/epm): a package database query tool with RPM
    like syntax.
  </li>
  <li>
    <c>esearch</c> (app-portage/esearch): replacement for 'emerge --search'
    with search-index.
  </li>
  <li>
    <c>ufed</c> (app-portage/ufed): graphical tool to edit USE settings.
  </li>
  <li>
    <c>splat</c> (app-portage/splat) and <c>genlop</c> (app-portage/genlop):
    analyzers for emerge log files.
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
