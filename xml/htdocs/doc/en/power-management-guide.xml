<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/power-management-guide.xml,v 1.15 2005/10/28 14:48:06 so Exp $ -->
<guide link="/doc/en/power-management-guide.xml">
<title>Power Management Guide</title>

<author title="Author">
  <mail link="fragfred@gmx.de">Dennis Nienh√ºser</mail>
</author>

<abstract>
Power Management is the key to extend battery run time on mobile systems like
laptops. This guide assists you setting it up on your laptop.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.25</version>
<date>2005-10-02</date>

<chapter>
<title>Introduction</title>
<section>
<title>Why Power Management?</title>
<body>

<p>
Capacity and lifetime of laptop batteries have improved much in the last years.
Nevertheless modern processors consume much more energy than older ones and
each laptop generation introduces more devices hungry for energy. That's why
Power Management is more important than ever. Increasing battery run time
doesn't necessarily mean buying another battery. Much can be achieved applying
intelligent Power Management policies.
</p>

</body>
</section>

<section>
<title>A quick overview</title>
<body>

<p>
Please notice that this guide describes Power Management for <e>laptops</e>.
While some sections might also suite for <e>servers</e>, others do not and may
even cause harm. Please do not apply anything from this guide to a server
unless you really know what you are doing.
</p>

<p>
As this guide has become rather long, here's a short overview helping you to
find your way through it.
</p>

<p>
The <e>Prerequisites</e> chapter talks about some requirements that should be
met before any of the following device individual sections will work. This
includes BIOS settings, kernel configuration and some simplifications in user
land. The following three chapters focus on devices that typically consume
most energy - processor, display and hard drive. Each can be configured
seperately.  <e>CPU Power Management</e> shows how to adjust the processor's
frequency to save a maximum of energy whithout losing too much performance. A
few different tricks prevent your hard drive from working unnecessarily often
in <e>Disk Power Management</e> (decreasing noise level as a nice side
effect). Some notes on graphics cards, Wireless LAN and USB finish the device
section in <e>Power Management for other devices</e> while another chapter is
dedicated to the (rather experimental) <e>sleep states</e>. Last not least
<e>Troubleshooting</e> lists common pitfalls.
</p>

</body>
</section>

<section>
<title>Power Budget for each component</title>
<body>

<figure link="/images/energy-budget.png" short="Which component consumes how
much energy?" caption="Power budget for each component"/>

<p>
Nearly every component can operate in different states - off, sleep, idle,
active to name a few - consuming a different amount of energy. Major parts are
consumed by the LCD display, CPU, chipset and hard drives. Often one is able to
activate OS-independent Power Management in the BIOS, but an intelligent setup
in the operating system adapting to different situations can achieve much more.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisites</title>
<section>
<title>What has to be done first</title>
<body>

<p>
Before going into the details on making individual devices Power Management
aware, make sure certain requirements are met. After controlling the BIOS
settings, some kernel options want to be enabled - these are in short ACPI,
sleep states and CPU frequency scaling. As power saving most of the time comes
along with performance loss or increased latency, it should only be enabled
when running on batteries. That's where a new runlevel <e>battery</e> comes in
handy.
</p>

</body>
</section>
<section>
<title>The BIOS part</title>
<body>

<p>
First have a look into your BIOS Power Management settings. The best way is to
combine BIOS and operating system policies, but for the moment it's better to
disable most of the BIOS part. This makes sure it doesn't interfere with your
policies. Don't forget to re-check BIOS settings after you configured
everything else.
</p>

</body>
</section>
<section>
<title>Configuring the kernel</title>
<body>

<p>
ACPI (Advanced Configuration and Power Interface) support in the kernel is
still work in progress. Using a recent kernel will make sure you'll get the
most out of it.
</p>

<p>
There are different kernel sources in Portage. I'd recommend using 
<c>gentoo-sources</c> or <c>suspend2-sources</c>. The latter contains patches
for Software Suspend 2, see the chapter about sleep states for details. When
configuring the kernel, activate at least these options:
</p>

<pre caption="Minimum kernel setup for Power Management (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservative' cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Decide yourself whether you want to enable Software Suspend, and Sleep States
(see below). If you own an ASUS, Medion, IBM Thinkpad or Toshiba laptop, enable
the appropriate section.
</p>

<p>
The kernel has to know how to enable CPU frequency scaling on your processor. As
each type of CPU has a different interface, you've got to choose the right
driver for your processor. Be careful here - enabling <e>Intel Pentium 4 clock
modulation</e> on a Pentium M system will lead to strange results for example.
Consult the kernel documentation if you're unsure which one to take.
</p>

<p>
Compile your kernel, make sure the right modules get loaded at startup and boot
into your new ACPI-enabled kernel. Next run <c>emerge sys-power/acpid</c> to get
the acpi daemon. This one informs you about events like switching from AC to
battery or closing the lid. Make sure the modules are loaded if you didn't
compile them into the kernel and start acpid by executing
<c>/etc/init.d/acpid start</c>. Run <c>rc-update add acpid default</c> to load
it on startup. You'll soon see how to use it.
</p>

<pre caption="Installing acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creating a "battery" runlevel</title>
<body>

<p>
The default policy will be to enable Power Management only when needed -
running on batteries. To make the switch between AC and battery convenient,
create a runlevel <e>battery</e> that holds all the scripts starting and
stopping Power Management.
</p>

<note>
You can safely skip this section if you don't like the idea of having another
runlevel. However, skipping this step will make the rest a bit trickier to set
up. The next sections assume a runlevel <e>battery</e> exists.
</note>

<pre caption="Creating a battery runlevel">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finished. Your new runlevel <e>battery</e> contains everything like
<e>default</e>, but there is no automatic switch between both yet. Time to
change it.
</p>

</body>
</section>
<section>
<title>Reacting on ACPI events</title>
<body>

<p>
Typical ACPI events are closing the lid, changing the power source or pressing
the sleep button. An important event is changing the power source, which should
cause a runlevel switch. A small script will take care of it.
</p>

<p>
First you need a script which changes the runlevel to <c>default</c>
respectively <c>battery</c> depending on the power source. The script uses the
<c>on_ac_power</c> command from <c>sys-power/powermgmt-base</c> - make sure the
package is installed on your system.
</p>

<pre caption="Installing powermgt-base">
<i># emerge powermgmt-base</i>
</pre>

<p>
You are now able to determine the power source by executing
<c>on_ac_power &amp;&amp; echo AC available || echo Running on batteries</c> in
a shell. The script below is responsible for changing runlevels. Save it as
<path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>.
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># BEGIN configuration</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># END configuration</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
Dont forget to run <c>chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</c> to
make the script executable. The last thing that needs to be done is calling the
script whenever the power source changes. That's done by catching ACPI events
with the help of <c>acpid</c>. First you need to know which events are
generated when the power source changes. The events are called
<e>ac_adapter</e> and <e>battery</e> on most laptops, but it might be different
on yours.
</p>

<pre caption="Determining ACPI events for changing the power source">
<i># tail -f /var/log/acpid | grep "received event"</i>
</pre>

<p>
Run the command above and pull the power cable. You should see something
like this:
</p>

<pre caption="Sample output for power source changes">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
The interesting part is the quoted string after <e>received event</e>. It will
be matched by the event line in the files you are going to create below. Don't
worry if your system generates multiple events or always the same. As long as
any event is generated, runlevel changing will work.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># replace "ac_adapter" below with the event generated on your laptop</comment>
<comment># For example, ac_adapter.* will match ac_adapter AC 00000080 00000000</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># replace "battery" below with the event generated on your laptop</comment>
<comment># For example, battery.* will match battery BAT0 00000080 00000001</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Finally acpid has to be restarted to recognize the changes.
</p>

<pre caption="Finishing runlevel switching with acpid">
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Give it a try: Plug AC in and out and watch syslog for the "Switching to AC
mode" or "Switching to battery mode" messages. See the Troubleshooting
section if the script is not able to detect the power source correctly.
</p>

<p>
Due to the nature of the event mechanism, your laptop will boot into runlevel
<e>default</e> regardless of the AC/battery state. This is fine when running
from AC, but we'd like to boot into the battery runlevel otherwise. One 
solution would be to add another entry to the boot loader with the parameter 
<c>softlevel=battery</c>, but it's likely to forget choosing it. A better way
is faking an ACPI event in the end of the boot process and letting 
<path>pmg_switch_runlevel.sh</path> script decide whether a
runlevel change is necessary. Open <path>/etc/conf.d/local.start</path> in your
favourite editor and add these lines:
</p>

<pre caption="Runlevel adjustment at boot time by editing local.start">
<comment># Fake acpi event to switch runlevel if running on batteries</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Prepared like this you can activate Power Management policies for individual 
devices.
</p>

</body>
</section>
</chapter>

<chapter>
<title>CPU Power Management</title>
<section>
<title>Some technical terms</title>
<body>

<p>
CPU frequency scaling brings up some technical terms that might be unknown to
you. Here's a quick introduction.
</p>

<p>
First of all, the kernel has to be able to change the processor's frequency.
The <e>CPUfreq processor driver</e> knows the commands to do it on your CPU.
Thus it's important to choose the right one in your kernel. You should
already have done it above. Once the kernel knows how to change frequencies,
it has to know which frequency it should set. This is done according to the
<e>policy</e> which consists of a <e>CPUfreq policy</e> and a
<e>governor</e>. A CPUfreq policy are just two numbers which define a range
the frequency has to stay between - minimal and maximal frequency. The
governor now decides which of the available frequencies in between minimal
and maximal frequency to choose. For example, the <e>powersave governor</e>
always chooses the lowest frequency available, the <e>performance
governor</e> the highest one. The <e>userspace governor</e> makes no decision
but chooses whatever the user (or a program in userspace) wants - which means
it reads the frequency from
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
This doesn't sound like dynamic frequency changes yet and in fact it isn't.
Dynamics however can be accomplished with various approaches. For example,
the <e>ondemand governor</e> makes its decisions depending on the current CPU
load. The same is done by various userland tools like <c>cpudyn</c>,
<c>cpufreqd</c>, <c>powernowd</c> and many more. ACPI events can be used to
enable or disable dynamic frequency changes depending on power source.
</p>

</body>
</section>
<section>
<title>Setting the frequency manually</title>
<body>

<p>
Decreasing CPU speed and voltage has two advantages: On the one hand less
energy is consumed, on the other hand there is thermal improvement as your
system doesn't get as hot as running on full speed. The main disadvantage is
obviously the loss of performance. Decreasing processor speed is a trade off
between performance loss and energy saving.
</p>

<note>
Not every laptop supports frequency scaling. If unsure, have a look at the list
of supported processors in the <e>Troubleshooting</e> section to verify your's 
is supported.
</note>

<p>
It's time to test whether CPU frequency changing works. Let's install another
tool which is very handy for debugging purposes: <c>sys-power/cpufrequtils</c>
</p>

<pre caption="Checking CPU frequency">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Here is an example output:
</p>

<pre caption="Sample output from cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: conservative, ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz.
</pre>

<p>
Now play around with <c>cpufreq-set</c> to make sure frequency switching works.
Run <c>cpufreq-set -g ondemand</c> for example to activate the ondemand
governor and verify the change with <c>cpufreq-info</c>. If it doesn't work as
expected, you might find help in the Troubleshooting section in the end of this
guide.
</p>

</body>
</section>
<section>
<title>Automated frequency adaption</title>
<body>

<p>
The above is quite nice, but not doable in daily life. Better let your system
set the appropriate frequency automatically. There are many different
approaches to do this. The following table gives a quick overview to help you
decide on one of them. It's roughly seperated in three categories
<e>kernel</e> for approaches that only need kernel support, <e>daemon</e> for
programs that run in the background and <e>graphical</e> for programs that
provide a GUI for easy configuration and changes.
</p>

<table>
<tr>
  <th>Name</th>
  <th>Category</th>
  <th>Switch decision</th>
  <th>Kernel governors</th>
  <th>Further governors</th>
  <th>Comments</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>CPU load</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Chooses maximal frequency on CPU load and slowly steps down when the CPU is
    idle. Further tuning through files in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Still requires
    userland tools (programs, scripts) if governor switching or similar is
    desired.
  </ti>
</tr>
<tr>
  <ti>'conservative' governor</ti>
  <ti>Kernel</ti>
  <ti>CPU load</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
		Unlike the ondemand governor, conversative doesn't jump to maximum
		frequency when CPU load is high, but increases the frequency step by
		step. Further tuning through files in
		<path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Still
		requires userland tools (programs, scripts) if governor switching or
		similar is desired.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>Performance, powersave</ti>
  <ti>Dynamic</ti>
  <ti>
    Also supports disk standby - notice however that <e>laptop mode</e> in most
    cases will do a better job.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Daemon</ti>
  <ti>Battery state, CPU load, temperature, running programs</ti>
  <ti>All available</ti>
  <ti>None</ti>
  <ti>
    Sophisticated (but also complicated) setup.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>None</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>
    Supports SMP.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://fatcat.ftj.agh.edu.pl/~nelchael/index.php?cat=projs&amp;subcat=ncpufreqd&amp;language=en">ncpufreqd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Temperature</ti>
  <ti>None</ti>
  <ti>Powersave, performance</ti>
  <ti>
    Toggles the used governor between performance and powersave depending on
    system temperature. Very useful on laptops with notorious heat problems.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>None</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Easy to configure with a nice client/server interface. Requires a 2.6
    kernel. Unmaintained, broken and thus removed from Portage. Please switch
    to cpufreqd if you're still using it.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Graphical</ti>
  <ti>None</ti>
  <ti>None</ti>
  <ti>None</ti>
  <ti>
    Gnome application, a graphical tool to set CPU frequency manually. It does
    not offer any automation.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Graphical</ti>
  <ti>Battery state</ti>
  <ti>All available</ti>
  <ti>None</ti>
  <ti>
    KDE only, 'ondemand' governor required for dynamic frequency scaling.
  </ti>
</tr>
</table>

<p>
While adjusting the frequency to the current load looks simple at a first
glance, it's not such a trivial task. A bad algorithm can cause switching
between two frequencies all the time or wasting energy when setting frequency
to an unnecessary high level. 
</p>

<p>
Which one to choose? If you have no idea about it, try <c>cpufreqd</c>:
</p>

<pre caption="Installing cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> can be configured by editing <path>/etc/cpufreqd.conf</path>.
The default one that ships with cpufreqd may look a bit confusing. I recommend
replacing it with the one from Gentoo developer Henrik Brix Andersen (see
below).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=conservative

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=ondemand
</pre>

<p>
Now you can start the cpufreqd daemon. Add it to the <e>default</e> and
<e>battery</e> runlevel as well.
</p>

<pre caption="Starting cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<warn>
Do not run more than one of the above programs at the same time. It may cause
confusion like switching between two frequencies all the time.
</warn>

</body>
</section>

<section>
<title>Verifying the result</title>

<body>

<p>
The last thing to check is that your new policies do a good job. An easy way to
do so is monitoring CPU speed while working with your laptop:
</p>

<pre caption="Monitoring CPU speed">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
If <path>/proc/cpuinfo</path> doesn't get updated (see Troubleshooting),
monitor the CPU frequency with:
</p>

<pre caption="Alternative CPU speed monitoring">
# <i>watch x86info -mhz</i>
</pre>

<p>
Depending on your setup, CPU speed should increase on heavy load, decrease on
no activity or just stay at the same level. When using cpufreqd and verbosity
set to 5 or higher in <path>cpufreqd.conf</path> you'll get additional
information about what's happening reported to syslog.
</p>

</body>
</section>
</chapter>

<chapter>
<title>LCD Power Management</title>
<section>
<title>Energy consumer no. 1</title>
<body>

<p>
As you can see in  <uri link="#doc_chap1_fig1">figure 1.1</uri>, the LCD display
consumes the biggest part of energy (might not be the case for non-mobile
CPU's). Thus it's quite important not only to shut the display off when not
needed, but also to reduce it's backlight if possible. Most laptops offer the
possibility to control the backlight dimming. 
</p>

<p>
First thing to check is the standby/suspend/off timings of the display. As this
depends heavily on your windowmanager, I'll let you figure it out yourself.
Just two common places: Blanking the terminal can be done with <c>setterm
-blank &lt;number-of-minutesM&gt;</c>, <c>setterm -powersave on</c> and
<c>setterm -powerdown &lt;number-of-minutesM&gt;</c>.
For X.org, modify <path>/etc/X11/xorg.conf</path> similar to this:
</p>

<pre caption="LCD suspend settings in X.org and XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Blank the screen after 5 minutes (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># Turn off screen after 10 minutes (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Full suspend after 20 minutes</comment>
  Option  "OffTime"  "30"  <comment># Turn off after half an hour</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
This is the same for XFree86 and <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probably more important is the backlight dimming. If you have access to the
dimming settings via a tool, write a small script that dims the backlight in
battery mode and place it in your <e>battery</e> runlevel. The following script
should work on most IBM Thinkpads. It needs the <c>app-laptop/ibm-acpi</c>
package or the appropriate option in your kernel has to be enabled.
</p>

<warn>
Support for setting brightness is marked experimental in ibm-acpi. It accesses
hardware directly and may cause severe harm to your system. Please read the
<uri link="http://ibm-acpi.sourceforge.net/">ibm-acpi website</uri>
</warn>

<p>
To be able to set the brightness level, the ibm_acpi module has to be loaded
with the experimental parameter.
</p>

<pre caption="automatically loading the ibm_acpi module">
<comment>(Please read the warnings above before doing this!)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
This should work without error messages and a file
<path>/proc/acpi/ibm/brightness</path> should be created after loading the
module. An init script will take care of choosing the brightness according
to the power source.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># See /proc/acpi/ibm/brightness for available values</comment>
<comment># Please read /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># brigthness level in ac mode. Default is 7.</comment>
BRIGHTNESS_AC=7

<comment># brightness level in battery mode. Default is 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "Check that ibm_acpi is loaded into the kernel"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
When done, make sure brightness is adjusted automatically by adding it to the
battery runlevel.
</p>

<pre caption="Enabling automatic brightness adjustment">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Disk Power Management</title>
<section>
<title>Sleep when idle</title>
<body>

<p>
Let's bring the hard disk to sleep as early as possible whenever it is not
needed. I'll show you two possibilities to do it. First <c>cpudyn</c> supports
Disk Power Management. Uncomment the lines in the "Disk Options" section in
<path>/etc/conf.d/cpudyn</path>. To put your first disk to sleep after 60
seconds of no activity, you would modify it like this:
</p>

<pre caption="Using cpudyn for disk standby">
<comment>################################################
# DISK OPTIONS
# (disabled by default)
################################################

#
# Timeout to put the disk in standby mode if there was no
# io during that period (in seconds)
#
</comment>
TIMEOUT=60
<comment>
#
# Specified disks to spindown (comma separated devices)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
The second possibility is using a small script and hdparm. Create
<path>/etc/init.d/pm.hda</path> like this:
</p>

<pre caption="Using hdparm for disk standby">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
See <c>man hdparm</c> for the options. If your script is ready, add it to the
battery runlevel.
</p>

<pre caption="Automate disk standby settings">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Be careful with sleep/spin down settings of your hard drive. Setting it to
small values might wear out your drive and lose warranty.
</impo>

</body>
</section>
<section>
<title>Increasing idle time - laptop-mode</title>
<body>

<p>
Recent kernels (2.6.6 and greater, recent 2.4 ones and others with patches)
include the so-called <e>laptop-mode</e>. When activated, dirty buffers are
written to disk on read calls or after 10 minutes (instead of 30 seconds). This
minimizes the time the hard disk needs to be spun up.
</p>

<pre caption="Automated start of laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> has it's configuration file in
<path>/etc/laptop-mode/laptop-mode.conf</path>. Adjust it the way you like it,
it's well commented. Run <c>rc-update add laptop_mode battery</c> to start it
automatically.
</p>

</body>
</section>
<section>
<title>Other tricks</title>
<body>

<p>
Besides putting your disk to sleep state as early as possible, it is a good
idea to minimize disk accesses. Have a look at processes that write to your
disk frequently - the syslogd is a good candidate. You probably don't want to
shut it down completely, but it's possible to modify the config file so that
"unnecessary" things don't get logged and thus don't create disk traffic. Cups
writes to disk periodically, so consider shutting it down and only enable it
manually when needed.
</p>

<pre caption="Disabling cups in battery mode">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Another possibility is to deactivate swap in battery mode. Before writing a
swapon/swapoff switcher, make sure there is enough RAM and swap isn't used
heavily, otherwise you'll be in big problems.
</p>

<p>
If you don't want to use laptop-mode, it's still possible to minimize disk
access by mounting certain directories as <e>tmpfs</e> - write accesses are not
stored on a disk, but in main memory and get lost with unmounting. Often it's
useful to mount <path>/tmp</path> like this - you don't have to pay special
attention as it gets cleared on every reboot regardless whether it was mounted
on disk or in RAM. Just make sure you have enough RAM and no program (like a
download client or compress utility) needs extraordinary much space in
<path>/tmp</path>. To activate this, enable tmpfs support in your kernel and
add a line to <path>/etc/fstab</path> like this:
</p>

<pre caption="Editing /etc/fstab to make /tmp even more volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Pay attention to the size parameter and modify it for your system. If you're
unsure, don't try this at all, it can become a perfomance bottleneck easily. In
case you want to mount <path>/var/log</path> like this, make sure to merge the
log files to disk before unmounting. They are essential. Don't attempt to mount
/var/tmp like this. Portage uses it for compiling...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Power Management for other devices</title>
<section>
<title>Graphics cards</title>
<body>

<p>
In case you own an ATI graphics card supporting PowerPlay (dynamic clock
scaling for the the graphics processing unit GPU), you can activate this
feature in X.org. Open <path>/etc/X11/xorg.conf</path> and add (or enable)
the <c>DynamicClocks</c> option in the Device section. Please notice that 
this feature will lead to crashes on some systems.
</p>

<pre caption="Enabling ATI PowerPlay support in X.org">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>

</body>
</section>
<section>
<title>Wireless Power Management</title>
<body>

<p>
Wireless LAN cards consume quite a few energy. Put them in Power Management
mode in analogy to the pm.hda script.
</p>

<pre caption="WLAN Power Management automated">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Starting this script will put wlan0 in Power Management mode, going to sleep at
the latest three seconds after no traffic.
Save it as <path>/etc/init.d/pm.wlan0</path> and add it to the battery runlevel
like the disk script above. See <c>man iwconfig</c> for details and more
options. If your driver and access point support changing the beacon time, this
is a good starting point to save even more energy.
</p>

<pre caption="Power Management for WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>USB Power Management</title>
<body>

<p>
There are two problems with USB devices regarding energy consumption: First,
devices like USB mice, digital cameras or USB sticks consume energy while
plugged in. You cannot avoid this (nevertheless remove them in case they're not
needed). Second, when there are USB devices plugged in, the USB host controller
periodically accesses the bus which in turn prevents the CPU from going into
sleep mode. The kernel offers an experimental option to enable suspension of 
USB devices through driver calls or one of the <path>power/state</path> files
in <path>/sys</path>.
</p>

<pre caption="Enabling USB suspend support in the kernel">
Device Drivers
  USB support
    [*]   Support for Host-side USB
      [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Sleep states: sleep, standby, suspend to disk</title>
<section>
<title>Overview</title>
<body>

<p>
ACPI defines different sleep states. The more important ones are
</p>

<ul> 
  <li>S1 aka Standby</li>
  <li>S3 aka Suspend to RAM aka Sleep</li>
  <li>S4 aka Suspend to Disk aka Hibernate</li>
</ul>

<p>
They can be called whenever the system is not in use, but a shutdown is not
wanted due to the long boot time.
</p>

</body>
</section>
<section>
<title>Sleep (S3)</title>
<body>

<p>
The ACPI support for these sleep states is marked experimental for good reason.
APM sleep states seem to be more stable, however you can't use APM and ACPI
together.
</p>

<pre caption="Kernel configuration for the various suspend types">
  Power Management Options ---&gt;
    [*]  Power Management support
      ACPI (Advanced Configuration and Power Interface) Support ---&gt;
        [*]  ACPI Support
          [*]   Sleep States
</pre>

<p>
Once your kernel is prepared like above, you can use the
<c>hibernate-script</c> to activate suspend or sleep mode. Let's install that
first.
</p>

<pre caption="Installing the hibernate-script">
<i># emerge hibernate-script</i>
</pre>

<p>
Some configuration has to be done in <path>/etc/hibernate</path> The default
package introduces two configuration files <path>hibernate.conf</path> and
<path>ram.conf</path>.
</p>

<p>
To configure sleep, edit <path>ram.conf</path> in <path>/etc/hibernate</path>.
<c>UseSysfsPowerState mem</c> is already setup correctly, but you have to go
through the rest of the configuration file and set it up for your system. The
comments and option names will guide you. If you use nfs or samba shares over
the network, make sure to shutdown the appropriate init scripts to avoid
timeouts.
</p>

<p>
Ready? Now is the last chance to backup any data you want to keep after
executing the next command. Notice that you probably have to hit a special key
like <e>Fn</e> to resume from sleep.
</p>

<pre caption="Calling sleep">
<i># hibernate-ram</i>
</pre>

<p>
If you're still reading, it seems to work. You can also setup standby (S1) in
a similar way by copying <path>ram.conf</path> to <path>standby.conf</path>
and creating a symlink <path>/usr/sbin/hibernate-standby</path> pointing to
<path>/usr/sbin/hibernate</path>. S3 and S4 are the more interesting sleep
states due to greater energy savings however.
</p>

</body>
</section>
<section>
<title>Hibernate (S4)</title>
<body>

<p>
This section introduces hibernation, where a snapshot of the running system is
written to disk before powering off. On resume, the snapshot is loaded and you
can go on working at exactly the point you called hibernate before.
</p>

<warn>
Don't exchange non hot-pluggable hardware when suspended. Don't attempt to load
a snapshot with a different kernel image than the one it was created with.
Shutdown any NFS or samba server/client before hibernating.
</warn>

<p>
There are two different implementations for S4. The original one is swsusp,
then there is the newer suspend2 with a nicer interface (including
fbsplash support). A <uri link="http://suspend2.net/features.html#compare">
feature comparison</uri> is available at the <uri link="http://suspend2.net">
suspend2 Homepage</uri>. There used to be Suspend-to-Disk (pmdisk), a fork of
swsusp, but it has been merged back.
</p>

<p>
Suspend2 is not included in the mainline kernel yet, therefore you either have
to patch your kernel sources with the patches provided by 
<uri link="http://suspend2.net">suspend2.net</uri> or use
<c>sys-kernel/suspend2-sources</c>.
</p>

<p>
The kernel part for both swusp and suspend2 is as follows:
</p>

<pre caption="Kernel configuration for the various suspend types">
Power Management Options ---&gt;
  <comment>(hibernate with swsusp)</comment>
  [*] Software Suspend
      <comment>(replace /dev/SWAP with your swap partition)</comment>
      (/dev/SWAP)      Default resume partition
  
  <comment>(hibernate with suspend2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]     File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(replace /dev/SWAP with your swap partition)</comment>
    (swap:/dev/SWAP)   Default resume device name
    [ ]     Allow Keep Image Mode
</pre>

<p>
The configuration for swsusp is rather easy. If you didn't store the location
of your swap partition in the kernel config, you can also pass it as a
parameter with the <c>resume=/dev/SWAP</c> directive. If booting is not
possible due to a broken image, use the <c>noresume</c> kernel parameter. The
<c>hibernate-cleanup</c> init script invalidates swsusp images during the
boot process.
</p>

<pre caption="Invalidating swsusp images during the boot process">
<i># rc-update add hibernate-cleanup boot</i>
</pre>

<p>
To activate hibernate with swsusp, use the hibernate script and set
<c>UseSysfsPowerState disk</c> in <path>/etc/hibernate/hibernate.conf</path>.
</p>

<warn>
Backup your data before doing this. Run <c>sync</c> before executing one of the
commands to have cached data written to disk. First try it outside of X, then
with X running, but not logged in.
</warn>
 
<p>
If you experience kernel panics due to uhci or similar, try to compile USB
support as module and unload the modules before sending your laptop to sleep
mode. There are configuration options for this in <path>hibernate.conf</path>
</p>

<pre caption="Hibernating with swsusp">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Make sure you have a backup of your data)</comment>
<i># hibernate</i>
</pre>

<p>
The following section discusses the setup of suspend2 including fbsplash
support for a nice graphical progress bar during suspend and resume.
</p>

<p>
The first part of the configuration is similar to the configuration of
swsusp.  In case you didn't store the location of your swap partition in the
kernel config, you have to pass it as a kernel parameter with the
<c>resume2=swap:/dev/SWAP</c> directive. If booting is not possible due to a
broken image, append the <c>noresume2</c> parameter. Additionally, the
<c>hibernate-cleanup</c> init script invalidates suspend2 images during the
boot process.
</p>

<pre caption="Invalidating suspend2 images during the boot process">
<i># rc-update add hibernate-cleanup boot</i>
</pre>

<p>Now edit <path>/etc/hibernate/hibernate.conf</path>, enable the
<e>suspend2</e> section and comment everything in the <e>sysfs_power_state</e>
and <e>acpi_sleep</e> sections. Do not enable the fbsplash part in global
options yet.
</p>

<pre caption="Hibernating with suspend2">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Make sure you have a backup of your data)</comment>
<i># hibernate</i>
</pre>

<p>
Please configure fbsplash now if you didn't do already. To enable fbsplash
support during hibernation, the <c>sys-apps/suspend2-userui</c> package is
needed. Additionally, you've got to enable the <e>fbsplash</e> USE flag.
</p>

<pre caption="Installing suspend2-userui">
<i># mkdir -p /etc/portage</i>
<i># echo sys-apps/suspend2-userui fbsplash >> /etc/portage/package.use</i>
<i># emerge suspend2-userui</i>
</pre>

<p>
The ebuild tells you to make a symlink to the theme you want to use. For
example, to use the <c>livecd-2005.1</c> theme, run the following command:
</p>

<pre caption="Using the livecd-2005.1 theme during hibernation">
<i># ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
If you don't want a black screen in the first part of the resume process, you
have to add the <c>suspend2ui_fbsplash</c> tool to your initrd image. Assuming
you created the initrd image with <c>splash_geninitramfs</c> and saved it as
<path>/boot/fbsplash-emergence-1024x768</path>, here's how to do
that.
</p>

<pre caption="Adding suspend2ui_fbsplash to an initrd image">
<i># mount /boot</i>
<i># mkdir ~/initrd.d</i>
<i># cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
<i># cd ~/initrd.d</i>
<i># gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
<i># rm fbsplash-emergence-1024x768</i>
<i># cp /usr/sbin/suspend2ui_fbsplash sbin/</i>
<i># find . | cpio --quiet --dereference -o -H newc | gzip -9 > /boot/fbsplash-suspend2-emergence-1024x768</i>
</pre>

<p>
Afterwards adjust <path>grub.conf</path> respectively <path>lilo.conf</path>
so that your suspend2 kernel uses
<path>/boot/fbsplash-suspend2-emergence-1024x768</path> as initrd image. You
can now test a dry run to see if everything is setup correctly.
</p>

<pre caption="Test run for fbsplash hibernation">
<i># suspend2ui_fbsplash -t</i>
</pre>

<p>
Afterwards open <path>/etc/hibernate/hibernate.conf</path> again and activate
the fbsplash options. Execute <c>hibernate</c> and enjoy.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Troubleshooting</title>
<section>
<title>If things go wrong...</title>
<body>

<p>
<e>Q:</e> I'm trying to change the CPU frequency, but
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> does not
exist.
</p>

<p>
<e>A:</e> Make sure your processor supports CPU frequency scaling and you chose
the right CPUFreq driver for your processor. Here is a list of processors that
are supported by cpufreq (kernel 2.6.7): ARM Integrator, ARM-SA1100,
ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD
mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII and Intel mobile PIII-M on certain chipsets, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, several
"PowerBook" and "iBook2" and various processors on some ACPI 2.0-compatible
systems (only if "ACPI Processor Performance States" are available to the
ACPI/BIOS interface).
</p>

<p>
<e>Q:</e> My laptop supports frequency scaling, but
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> is empty.
</p>

<p>
<e>A:</e> Look for ACPI related error messages with <c>dmesg | grep ACPI</c>.
Try to update the BIOS, especially if a broken DSDT is reported. You can also
try to fix it yourself (which is beyond the scope of this guide).
</p>

<p>
<e>Q:</e> My laptop supports frequency scaling, but according to /proc/cpuinfo
the speed never changes.
</p>

<p>
<e>A:</e> Probably you have activated symmetric multiprocessing support
(CONFIG_SMP) in your kernel. Deactivate it and it should work. Some older
kernels had a bug causing this. In that case, run <c>emerge x86info</c>,
update your kernel as asked and check the current frequency with
<c>x86info -mhz</c>.
</p>

<p>
<e>Q:</e> I can change the CPU frequency, but the range is not as wide as in
another OS.
</p>

<p>
<e>A:</e> You can combine frequency scaling with ACPI throttling to get a lower
minimum frequency. Notice that throttling doesn't save much energy and is
mainly used for thermal management (keeping your laptop cool and quiet). You
can read the current throttling state with <c>cat
/proc/acpi/processor/CPU/throttling</c> and change it with <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, where x is one of the Tx states listed in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>Q:</e> When configuring the kernel, powersave, performance and userspace
governors show up, but that ondemand thing is missing. Where do I get it?
</p>

<p>
<e>A:</e> The ondemand governor is only included in recent kernel sources. Try
updating them.
</p>

<p>
<e>Q:</e> Battery life time seems to be worse than before.
</p>

<p>
<e>A:</e> Check your BIOS settings. Maybe you forgot to re-enable some of the
settings.
</p>

<p>
<e>Q:</e> My battery is charged, but KDE reports there would be 0% left and
immediately shuts down.
</p>

<p>
<e>A:</e> Check that battery support is compiled into your kernel. If you use
it as a module, make sure the module is loaded.
</p>

<p>
<e>Q:</e> I have a Dell Inspiron 51XX and I don't get any ACPI events.
</p>

<p>
<e>A:</e> This seems to be a kernel bug. Read on <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">here</uri>.
</p>

<p>
<e>Q:</e> I activated the DynamicClocks option in <path>xorg.conf</path> and
now X.org crashes / the screen stays black / my laptop doesn't shutdown
properly.
</p>

<p>
<e>A:</e> This happens on some systems. You have to disable DynamicClocks.
</p>

<p>
<e>Q:</e> I want to use suspend2, but it tells me my swap partition is too
small. Resizing is not an option.
</p>

<p>
<e>A:</e> If there is enough free space on your system, you can use the 
filewriter instead of the swapwriter. The <c>hibernate-script</c> supports it
as well. More information can be found in
<path>/usr/src/linux/Documentation/power/suspend2.txt</path>.
</p>

<p>
<e>Q:</e> I just bought a brand new battery, but it only lasts for some
minutes! What am I doing wrong?
</p>

<p>
<e>A:</e> First follow your manufacturer's advice on how to charge the battery
correctly. 
</p>

<p>
<e>Q:</e> The above didn't help. What should I do then?
</p>

<p>
<e>A:</e> Some batteries sold as "new" are in fact old ones. Try the following:
</p>

<pre caption="Querying battery state">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
If the "last full capacity" differs significantly from the design capacity,
your battery is probably broken. Try to claim your warranty.
</p>

<p>
<e>Q:</e> My problem is not listed above. Where should I go next?
</p>

<p>
<e>A:</e> Don't fear to contact me, <mail link="fragfred@gmx.de">Dennis
Nienh√ºser</mail>, directly.
</p>

</body>
</section>
</chapter>
</guide>
