<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/power-management-guide.xml,v 1.10 2005/03/19 16:48:25 yoswink Exp $ -->
<guide link="power-management-guide.xml">
<title>Power Management Guide</title>

<author title="Author">
  <mail link="fragfred@gmx.de">Dennis Nienh√ºser</mail>
</author>

<abstract>
Power Management is the key to extend battery run time on mobile systems like
laptops. This guide assists you setting it up on your laptop.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.20</version>
<date>2005-03-19</date>

<chapter>
<title>Introduction</title>

<section>
<title>Why Power Management?</title>

<body>

<p>
Capacity and lifetime of laptop batteries has improved much in the last years.
Nevertheless modern processors consume much more energy than older ones and
each laptop generation introduces more devices hungry for energy. That's why
Power Management is more important than ever. Increasing battery run time
doesn't necessarily mean buying another battery. Much can be achieved applying
intelligent Power Management policies.
</p>

</body>
</section>

<section>
<title>A quick overview</title>
<body>

<p>
Please notice that this guide describes Power Management for <e>laptops</e>.
While some sections might also suite for <e>servers</e>, others do not and may
even cause harm. Please do not apply anything from this guide to a server
unless you really know what you are doing.
</p>

<p>
As this guide has become rather long, here's a short overview helping you to
find your way through it.
</p>

<p>
The <e>Prerequisites</e> chapter talks about some requirements that should be
met before any of the following device individual sections will work. This
includes BIOS settings, kernel configuration and some simplifications in user
land. The following three chapters focus on devices that typically consume most
energy - processor, display and hard drive. Each can be configured seperately.
<e>CPU Power Management</e> shows how to adjust the processor's frequency to
save a maximum of energy whithout losing too much performance. A few different
tricks prevent your hard drive from working unnecessarily often in <e>Disk Power
Management</e> (decreasing noise level as a nice side effect). Some notes on
Wireless LAN and USB finish the device section in <e>Power Management for other
devices</e> while another chapter is dedicated to the (rather experimental)
<e>sleep states</e>. Last not least <e>Troubleshooting</e> lists common
pitfalls.
</p>

</body>
</section>

<section>
<title>Power Budget for each component</title>
<body>

<figure link="/images/energy-budget.png" short="Which component consumes how
much energy?" caption="Power budget for each component"/>

<p>
Nearly every component can operate in different states - off, sleep, idle,
active to name a few - consuming a different amount of energy. Major parts are
consumed by the LCD display, CPU, chipset and hard drives. Often one is able to
activate OS-independent Power Management in the BIOS, but an intelligent setup
in the operating system adapting to different situations can achieve much more.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisites</title>
<section>
<title>What has to be done first</title>
<body>

<p>
Before going into the details on making individual devices Power Management
aware, make sure certain requirements are met. After controlling the BIOS
settings, some kernel options want to be enabled - these are in short ACPI,
sleep states and CPU frequency scaling. As power saving most of the time comes
along with performance loss or increased latency, it should only be enabled
when running on batteries. That's where a new runlevel <e>battery</e> comes in
handy.
</p>

</body>
</section>
<section>
<title>The BIOS part</title>
<body>

<p>
First have a look into your BIOS Power Management settings. The best way is to
combine BIOS and operating system policies, but for the moment it's better to
disable most of the BIOS part. This makes sure it doesn't interfere with your
policies. Don't forget to re-check BIOS settings after you configured
everything else.
</p>

</body>
</section>
<section>
<title>Configuring the kernel</title>
<body>

<p>
ACPI (Advanced Configuration and Power Interface) support in the kernel is
still work in progress. Using a recent kernel will make sure you'll get the
most out of it.
</p>

<p>
In kernel config, activate at least these options:
</p>

<pre caption="Minimum kernel setup for Power Management (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    &lt;M&gt;   AC Adapter
    &lt;M&gt;   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Decide yourself whether you want to enable Software Suspend, Suspend-to-Disk and
Sleep States (see below). If you own an ASUS, Medion or Toshiba laptop, enable
the appropriate section. Recent kernel versions (2.6.9 and later) include an
<e>'ondemand' governor</e> for CPU Frequency Scaling, activate it as well when
using such a kernel.
</p>

<p>
The kernel has to know how to enable CPU frequency scaling on your processor. As
each type of CPU has a different interface, you've got to choose the right
driver for your processor. Be careful here - enabling <e>Intel Pentium 4 clock
modulation</e> on a Pentium M system will lead to strange results for example.
Consult the kernel documentation if you're unsure which one to take.
</p>

<p>
Compile your kernel, make sure the right modules get loaded at startup and boot
into your new ACPI-enabled kernel. Next run <c>emerge sys-power/acpid</c> to get
the acpi daemon. This one informs you about events like switching from AC to
battery or closing the lid. Make sure the module <e>button</e> is loaded if you
didn't compile it into the kernel and start acpid with <c>/etc/init.d/acpid
start</c>. Run <c>rc-update add acpid default</c> to load it on startup. You'll
soon see how to use it.
</p>

<pre caption="Installing acpid">
# <i>emerge sys-power/acpid</i>
# <i>modprobe button</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creating a "battery" runlevel</title>
<body>

<p>
The default policy will be to enable Power Management only when needed -
running on batteries. To make the switch between AC and battery convenient,
create a runlevel <e>battery</e> that holds all the scripts starting and
stopping Power Management.
</p>

<note>
You can safely skip this section if you don't like the idea of having another
runlevel. However, skipping this step will make the rest a bit trickier to set
up. The next sections assume a runlevel <e>battery</e> exists.
</note>

<pre caption="Creating a battery runlevel">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finished. Your new runlevel <e>battery</e> contains everything like
<e>default</e>, but there is no automatic switch between both yet. Time to
change it.
</p>

</body>
</section>
<section>
<title>Reacting on ACPI events</title>
<body>

<p>
Typical ACPI events are closing the lid, changing the power source or pressing
the sleep button. An important event is changing the power source, which should
cause a runlevel switch. Create the following files to switch between
<e>default</e> and <e>battery</e> runlevel depending on the power source:
</p>

<pre caption="/etc/acpi/switch_runlevel.sh">
#!/bin/bash

RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"

function on_ac () {
    if which on_ac_power &amp;> /dev/null
    then
        on_ac_power
    else
        grep --quiet on-line /proc/acpi/ac_adapter/*/state
    fi
}

function SwitchRunlevel () {

    if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
    then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
    fi


    if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
    then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
    fi

    if on_ac
    then if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
    elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
  then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
  fi
}
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
event=ac_adapter.*
action=/etc/acpi/actions/pmg_ac_adapter.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
event=battery.*
action=/etc/acpi/actions/pmg_battery.sh %e
</pre>

<pre caption="/etc/acpi/actions/pmg_ac_adapter.sh">
#!/bin/bash

source /etc/acpi/switch_runlevel.sh
SwitchRunlevel
</pre>

<pre caption="/etc/acpi/actions/pmg_battery.sh">
#!/bin/bash

source /etc/acpi/switch_runlevel.sh
SwitchRunlevel
</pre>

<p>
Some of these files must be executable. Last not least restart acpid to have
it recognize the changes.
</p>

<pre caption="Finishing runlevel switching with acpid">
<i># chmod +x /etc/acpi/switch_runlevel.sh</i>
<i># chmod +x /etc/acpi/actions/pmg_*</i>
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Give it a try: Plug AC in and out and watch syslog for the "Switching to AC
mode" or "Switching to battery mode" messages. See the Troubleshooting
section if the script is not able to detect the power source correctly.
</p>

<p>
Due to the nature of the event mechanism, your laptop will boot into runlevel
<e>default</e> regardless of the AC/battery state. You can add another entry
to the boot loader with <c>softlevel=battery</c>, but it's likely to forget
choosing it. A better way is faking an ACPI event in the end of the boot
process and let the <path>/etc/acpi/default.sh</path> script decide whether a
runlevel change is necessary. Open <path>/etc/conf.d/local.start</path> in your
favourite editor and add these lines:
</p>

<pre caption="Runlevel switch at boot time by editing local.start">
<comment># Fake acpi event to switch runlevel if running on batteries</comment>
/etc/acpi/actions/pmg_battery.sh "battery/battery"
</pre>

<p>
Prepared like this you can activate Power Management policies for individual 
devices.
</p>

</body>
</section>
</chapter>

<chapter>
<title>CPU Power Management</title>
<section>
<title>Some technical terms</title>
<body>

<p>
CPU frequency scaling brings up some technical terms that might be unknown to
you. Here's a quick introduction.
</p>

<p>
First of all, the kernel has to be able to change the processor's frequency. The
<e>CPUfreq processor driver</e> knows the commands to do it on your CPU. Thus
it's important to choose the right one in your kernel. You should already have
done it above. Once the kernel knows how to change frequencies, it has to know
which frequency it should set. This is done according to the <e>policy</e> which
consists of <e>CPUfreq policy</e> and a <e>governor</e>. A CPUfreq policy are
just two numbers which define a range the frequency has to stay between -
minimal and maximal frequency. The governor now decides which of the available
frequencies in between minimal and maximal frequency to choose. For example, the
<e>powersave governor</e> always chooses the lowest frequency available, the
<e>performance governor</e> the highest one. The <e>userspace governor</e> makes
no decision but chooses whatever the user (or a program in userspace) wants -
which means it reads the frequency from
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
This doesn't sound like dynamic frequency changes yet and in fact it isn't.
Dynamics however can be accomplished with various approaches. For example,
the <e>ondemand governor</e> makes its decisions depending on the current CPU
load. The same is done by various userland tools like <c>cpudyn</c>,
<c>speedfreq</c>, <c>powernowd</c> and many more. ACPI events can be used to
enable or disable dynamic frequency changes depending on power source.
</p>

</body>
</section>
<section>
<title>Setting the frequency manually</title>
<body>

<p>
Decreasing CPU speed and voltage has two advantages: On the one hand less
energy is consumed, on the other hand there is thermal improvement as your
system doesn't get as hot as running on full speed. The main disadvantage is
obviously the loss of performance. Decreasing processor speed is a trade off
between performance loss and energy saving.
</p>

<note>
Not every laptop supports frequency scaling. If unsure, have a look at the list
of supported processors in the <e>Troubleshooting</e> section to verify your's 
is supported.
</note>

<p>
It's time to test whether CPU frequency changing works. To get comfortable with
the interface to the kernel, first do some manual speed modifications. To set
another CPU speed, use:
</p>

<pre caption="Manual CPU speed modifications">
<comment>(Get current frequency)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>

<comment>(Lists supported frequencies. This might fail.)</comment>
# <i>cd /sys/devices/system/cpu/cpu0/cpufreq/</i>
# <i>cat scaling_available_frequencies</i>

<comment>(Change frequency to 1 GHz (1000000 KHz)
Replace with a frequency your laptop supports.)</comment>
# <i>echo -n userspace > scaling_governor</i>
# <i>echo -n 1000000 > scaling_setspeed</i>

<comment>(Verify frequency was changed)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
If you are getting error messages, please refer to the <e>Troubleshooting</e>
chapter in the end of this guide.
</p>

<p>
You can also write to <path>scaling_max_freq</path> and
<path>scaling_min_freq</path> to set boundaries the frequency should stay in
between.
</p>

<note>
Some kernel seem to be buggy about updating <path>/proc/cpuinfo</path>. If you
don't see any change there, this doesn't neccessarily mean the CPU frequency
wasn't changed. If this happens to you, run <c>emerge x86info</c>, update your
kernel as asked and check the current frequency with <c>x86info -mhz</c>.
</note>

</body>
</section>
<section>
<title>Automated frequency adaption</title>
<body>

<p>
The above is quite nice, but not doable in daily life. Better let your system
set the appropriate frequency automatically. There are many different approaches
to do this. The following table gives a quick overview to help you decide on one
of them. It's roughly seperated in three categories <e>kernel</e> for approaches
that only need kernel support, <e>daemon</e> for programs that run in the
background and <e>graphical</e> for programs that provide a GUI for easy
configuration and changes.
</p>

<table>
<tr>
  <th>Name</th>
  <th>Category</th>
  <th>Switch decision</th>
  <th>Kernel governors</th>
  <th>Further governors</th>
  <th>Comments</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>CPU load</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Further tuning through files in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Still requires
    userland tools (programs, scripts) if governor switching or similar is
    desired.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>None</ti>
  <ti>Dynamic</ti>
  <ti>
    Also supports disk standby - notice however that <e>laptop mode</e> in most
    cases will do a better job.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Daemon</ti>
  <ti>Battery state, CPU load, running programs</ti>
  <ti>All available</ti>
  <ti>None</ti>
  <ti>
    Sophisticated (but also complicated) setup. An optimal configuration
    requires detailed knowledge of your system.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>None</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>
    Supports SMP.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Daemon</ti>
  <ti>CPU load</ti>
  <ti>None</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Small yet powerful with an useful client/server interface. Requires a 2.6
    kernel.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Graphical</ti>
  <ti>None</ti>
  <ti>None</ti>
  <ti>None</ti>
  <ti>
    Gnome application, a graphical tool to set CPU frequency manually. It does
    not offer any automation and is mainly listed for the sake of completeness.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Graphical</ti>
  <ti>Battery state</ti>
  <ti>All available</ti>
  <ti>None</ti>
  <ti>
    KDE only, 'ondemand' governor required for dynamic frequency scaling.
  </ti>
</tr>
</table>

<p>
While adjusting the frequency to the current load looks simple on the first
view, it's not such a trivial task. A bad algorithm can cause switching between
two frequencies all the time or wasting energy when setting frequency to an
unnecessary high level. 
</p>

<p>
Which one to choose? If you have no idea about it, first try <c>speedfreq</c>:
</p>

<pre caption="Installing speedfreq">
# <i>emerge speedfreq</i>
# <i>rc-update add speedfreq battery</i>
</pre>

<p>
<c>speedfreq</c> can be configured by editing
<path>/etc/conf.d/speedfreq</path>. For example, if you like users to be able
to change the policy, modify <c>SPEEDFREQ_OPTS=""</c> to
<c>SPEEDFREQ_OPTS="-u"</c>. Having done your changes, start the daemon.
</p>

<pre caption="Starting speedfreq">
# <i>/etc/init.d/speedfreq start</i>
</pre>

<p>
Setting up cpufreqd is a little bit more complicated.
</p>

<warn>
Do not run more than one of the above programs at the same time. It may cause
confusion like switching between two frequencies all the time. If you just
installed speedfreq, skip cpufreqd now.
</warn>

<pre caption="Installing cpufreqd">
# <i>emerge cpufreqd</i>
# <i>rc-update add cpufreqd battery</i>
</pre>

<p>
<c>cpufreqd</c> comes with a default configuration in
<path>/etc/cpufreqd.conf</path>.
Change the config file to fit your needs. The following will save more energy
than the default one - at the cost of less performance, of course.
</p>

<pre caption="A sample cpufreqd config file">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
<comment># Uncomment the following line to enable ACPI workaround (see cpufreqd.conf(5))
# acpi_workaround=1</comment>
verbosity=4 <comment>#(if you want a minimal logging set to 5)</comment>

<comment># Full performance</comment>
[Profile]
name=ac
minfreq=600000
maxfreq=1400000
policy=performance

<comment># Maximum power saving</comment>
[Profile]
name=battery
minfreq=600000
maxfreq=900000
policy=powersave

<comment># Constant frequency</comment>
[Profile]
name=dvd
minfreq=900000
maxfreq=1100000
policy=powersave

<comment># Full performance when running on AC</comment>
[Rule]
name=ac_on
ac=on
profile=ac

<comment># Compiling should be fast if battery state is ok</comment>
[Rule]
name=compiling
ac=off
battery_interval=30-100
programs=emerge,make,gcc,cpp
cpu_interval=0-100
profile=ac

<comment># watching DVD's gets sluggish with slow CPU frequency
# Can also be used for games etc.</comment>
[Rule]
name=dvd_watching
ac=off
battery_interval=15-100
programs=xine,mplayer,avidemux,kaffeine,kmplayer
cpu_interval=0-100
profile=dvd

<comment># If above doesn't apply, maximise power saving</comment>
[Rule]
name=battery_on
ac=off
battery_interval=0-100
cpu_interval=0-100
profile=battery
</pre>

<p>
<c>cpudyn</c> and <c>powernowd</c> are installed in the same way as
<c>speedfreq</c>.
</p>

</body>
</section>

<section>
<title>Verifying the result</title>

<body>

<p>
The last thing to check is that your new policies do a good job. An easy way to
do so is monitoring CPU speed while working with your laptop:
</p>

<pre caption="Monitoring CPU speed">
# <i>watch -n 1 'grep "cpu MHz" /proc/cpuinfo'</i>
</pre>

<p>
If <path>/proc/cpuinfo</path> doesn't get updated (see above), monitor the CPU
frequency with:
</p>

<pre caption="Alternative CPU speed monitoring">
# <i>watch -n 1 x86info -mhz</i>
</pre>

<p>
Depending on your setup, CPU speed should increase on heavy load, decrease on
no activity or just stay at the same level.
</p>

</body>
</section>
</chapter>

<chapter>
<title>LCD Power Management</title>
<section>
<title>Energy consumer no. 1</title>
<body>

<p>
As you can see in  <uri link="#doc_chap1_fig1">figure 1.1</uri>, the LCD display
consumes the biggest part of energy (might not be the case for non-mobile
CPU's). Thus it's quite important not only to shut the display off when not
needed, but also to reduce it's backlight if possible. Most laptops offer the
possibility to control the backlight dimming. 
</p>

<p>
First thing to check is the standby/suspend/off timings of the display. As this
depends heavily on your windowmanager, I'll let you figure it out yourself.
Just two common places: Blanking the terminal can be done with <c>setterm
-blank &lt;number-of-minutesM&gt;</c>, <c>setterm -powersave on</c> and
<c>setterm -powerdown &lt;number-of-minutesM&gt;</c>.
For Xorg, modify <path>/etc/X11/xorg.conf</path> similar to this:
</p>

<pre caption="LCD suspend settings in Xorg and XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Blank the screen after 5 minutes (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># Turn off screen after 10 minutes (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Full suspend after 20 minutes</comment>
  Option  "OffTime"  "30"  <comment># Turn off after half an hour</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
This is the same for XFree86 and <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probably more important is the backlight dimming. If you have access to the
dimming settings via a tool, write a small script that dims the backlight in
battery mode and place it in your <e>battery</e> runlevel.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Disk Power Management</title>
<section>
<title>Sleep when idle</title>
<body>

<p>
Let's bring the hard disk to sleep as early as possible whenever it is not
needed. I'll show you two possibilities to do it. First <c>cpudyn</c> supports
Disk Power Management. Uncomment the lines in the "Disk Options" section in
<path>/etc/conf.d/cpudyn</path>. To put your first disk to sleep after 60
seconds of no activity, you would modify it like this:
</p>

<pre caption="Using cpudyn for disk standby">
<comment>################################################
# DISK OPTIONS
# (disabled by default)
################################################

#
# Timeout to put the disk in standby mode if there was no
# io during that period (in seconds)
#
</comment>
TIMEOUT=60
<comment>
#
# Specified disks to spindown (comma separated devices)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
The second possibility is using a small script and hdparm. Create
<path>/etc/init.d/pm.hda</path> like this:
</p>

<pre caption="Using hdparm for disk standby">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
See <c>man hdparm</c> for the options. If your script is ready, add it to the
battery runlevel.
</p>

<pre caption="Automate disk standby settings">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Be careful with sleep/spin down settings of your hard drive. Setting it to
small values might wear out your drive and lose warranty.
</impo>

</body>
</section>
<section>
<title>Increasing idle time - laptop-mode</title>
<body>

<p>
Recent kernels (2.6.6 and greater, recent 2.4 ones and others with patches)
include the so-called <e>laptop-mode</e>. When activated, dirty buffers are
written to disk on read calls or after 10 minutes (instead of 30 seconds). This
minimizes the time the hard disk needs to be spun up.
</p>

<p>
<!-- TODO: bug #45593 -->
Besides kernel support you also need a script that controls starting and
stopping of laptop-mode. You kernel documentation in
<path>/usr/src/linux/Documentation/laptop-mode.txt</path> contains one as well
as the package <c>laptop-mode-tools</c>. None of them is easy to install
though.
</p>

<p>
Ebuilds for laptop-mode-tools are not in Portage, because Gentoo developers
don't think they are production ready yet. Take that into consideration
before using the ebuilds which can be found in <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=45593">Bugzilla</uri>. The Gentoo
Handbook tells you how to use external ebuilds if you don't know where to put
them. Once your PORTDIR_OVERLAY contains the ebuilds, install the
script:
</p>

<warn>
This package is not seen as production ready and installing custom ebuilds from
Bugzilla is not recommended. Please don't use laptop-mode-tools if you're
unsure.
</warn>

<pre caption="Automated start of laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> has it's configuration file in
<path>/etc/laptop-mode/laptop-mode.conf</path>. Adjust it the way you like it,
it's well commented. If you have <e>apm</e> or <e>acpi</e> in your USE flags,
laptop-mode will be started automatically in battery mode. Otherwise you can
automate it by running <c>rc-update add laptop-mode battery</c>.
</p>

</body>
</section>
<section>
<title>Other tricks</title>
<body>

<p>
Besides putting your disk to sleep state as early as possible, it is a good
idea to minimize disk accesses. Have a look at processes that write to your
disk frequently - the syslogd is a good candidate. You probably don't want to
shut it down completely, but it's possible to modify the config file so that
"unnecessary" things don't get logged and thus don't create disk traffic. Cups
writes to disk periodically, so consider shutting it down and only enable it
manually when needed.
</p>

<pre caption="Disabling cups in battery mode">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Another possibility is to deactivate swap in battery mode. Before writing a
swapon/swapoff switcher, make sure there is enough RAM and swap isn't used
heavily, otherwise you'll be in big problems.
</p>

<p>
If you don't want to use laptop-mode, it's still possible to minimize disk
access by mounting certain directories as <e>tmpfs</e> - write accesses are not
stored on a disk, but in main memory and get lost with unmounting. Often it's
useful to mount <path>/tmp</path> like this - you don't have to pay special
attention as it gets cleared on every reboot regardless whether it was mounted
on disk or in RAM. Just make sure you have enough RAM and no program (like a
download client or compress utility) needs extraordinary much space in
<path>/tmp</path>. To activate this, enable tmpfs support in your kernel and
add a line to <path>/etc/fstab</path> like this:
</p>

<pre caption="Editing /etc/fstab to make /tmp even more volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Pay attention to the size parameter and modify it for your system. If you're
unsure, don't try this at all, it can become a perfomance bottleneck easily. In
case you want to mount <path>/var/log</path> like this, make sure to merge the
log files to disk before unmounting. They are essential. Don't attempt to mount
/var/tmp like this. Portage uses it for compiling...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Power Management for other devices</title>
<section>
<title>Wireless Power Management</title>
<body>

<p>
Wireless LAN cards consume quite a few energy. Put them in Power Management
mode in analogy to the pm.hda script.
</p>

<pre caption="WLAN Power Management automated">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Starting this script will put wlan0 in Power Management mode, going to sleep at
the latest three seconds after no traffic.
Save it as <path>/etc/init.d/pm.wlan0</path> and add it to the battery runlevel
like the disk script above. See <c>man iwconfig</c> for details and more
options. If your driver and access point support changing the beacon time, this
is a good starting point to save even more energy.
</p>

<pre caption="Power Management for WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>USB Power Management</title>
<body>

<p>
There are two problems with USB devices regarding energy consumption: First,
devices like USB mice, digital cameras or USB sticks consume energy while
plugged in. You cannot avoid this (nevertheless remove them in case they're not
needed). Second, when there are USB devices plugged in, the USB host controller
periodically accesses the bus which in turn prevents the CPU from going into
C3/4 sleep mode. The OS answer to this problem is the so called "USB selective
suspend", which has not yet been implemented in the kernel. USB selective
suspend only allows bus accesses in case the device is in use. The cruel
workaround until it's implemented is as following: Compile USB support and
devices as modules and remove them via a script while they are not in use (e.g.
when closing the lid).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sleep states: sleep, standby, suspend to disk</title>
<section>
<title>Overview</title>
<body>

<p>
ACPI defines different sleep states. The more important ones are
</p>

<ul> 
  <li>S1 aka Standby</li>
  <li>S3 aka Suspend to RAM aka Sleep</li>
  <li>S4 aka Suspend to Disk aka Hibernate</li>
</ul>

<p>
They can be called whenever the system is not in use, but a shutdown is not
wanted due to the long boot time.
</p>

</body>
</section>
<section>
<title>Sleep, Standby &amp; Hibernate</title>
<body>

<p>
The ACPI support for these sleep states is marked as experimental for good
reason. APM sleep states seem to be more stable, however you can't use APM and
ACPI together.
</p>

<warn>
Altough sleep state support is improving much, it's still rather experimental.
At last I got swsusp2 and suspend to RAM to work, but be warned: This will very
likely not work but damage your data/system.
</warn>

<p>
There are currently three implementations for S4. The original one is swsusp,
then there is swsusp2 which has the nicest interface (including bootsplash
support), but requires manual kernel patching. Last not least we have
Suspend-to-Disk, a fork of swsusp.
</p>

<p>
If this confused you, have a look at a <uri
link="http://softwaresuspend.berlios.de/features.html#compare">feature
comparison</uri>. If you still are confused and don't know which one to choose,
first give swsusp2 a try, it looks most promising.
</p>

<p>
The kernel part for this is as following:
</p>

<pre caption="Kernel configuration for the various suspend types">
Power Management Options ---&gt;

  <comment>(sleep and standby)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernate with swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)
  
  <comment>(hibernate with swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"your-swap-here")    Default resume device name

  <comment>(hibernate with Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"your-swap-here") Default resume partition
</pre>

<p>
Compile your kernel with the appropriate options enabled and issue <c>cat
/proc/acpi/sleep</c> for 2.4 series respectively <c>cat /sys/power/state</c>
for 2.6 to find out what is supported. The latter gives me <c>standby mem
disk</c>. For swsusp, the kernel parameter <c>resume=/dev/"your-swap-here"</c>
has to be appended. If booting is not possible due to a broken image, use
<c>noresume</c> for swsusp, <c>pmdisk=off</c> for Suspend-to-Disk and
<c>noresume2</c> for swsusp2.
</p>

<p>
To put your system in one of the sleep states, use
</p>

<pre caption="Activating sleep states">
<comment>(kernel 2.4 series)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>(standby)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(sleep)</comment>

<comment>(kernel 2.6 series)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>(standby)</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(sleep)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(hibernate)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(hibernate)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                   <comment>(hibernate, see below)</comment>
</pre>

<warn>
Backup your data before doing this. Run <c>sync</c> before executing one of the
commands to have cached data written to disk. First try it outside of X, then
with X running, but not logged in.
</warn>
 
<p>
If you experience kernel panics due to uhci or similar, try to compile USB
support as module and unload the modules before sending your laptop to sleep
mode.
</p>

<p>
While the above should be sufficient to get swsusp and Suspend-to-Disk running
(I didn't say working), swsusp2 needs special care. 
The first thing to do is patching the kernel with the patches provided at <uri
link="http://softwaresuspend.berlios.de/">
http://softwaresuspend.berlios.de/</uri>. Additionally you've got to emerge
<c>hibernate-script</c>. Once it is installed, configure
<path>/etc/hibernate/hibernate.conf</path> and try whether it works:
</p>

<pre>
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Last chance to backup any data)</comment>
<i># hibernate</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Troubleshooting</title>
<section>
<title>If things go wrong...</title>
<body>

<p>
<e>Q:</e> I'm trying to change the CPU frequency, but
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> does not
exist.
</p>

<p>
<e>A:</e> Make sure your processor supports CPU frequency scaling and you chose
the right CPUFreq driver for your processor. Here is a list of processors that
are supported by cpufreq (kernel 2.6.7): ARM Integrator, ARM-SA1100,
ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD
mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII and Intel mobile PIII-M on certain chipsets, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, several
"PowerBook" and "iBook2" and various processors on some ACPI 2.0-compatible
systems (only if "ACPI Processor Performance States" are available to the
ACPI/BIOS interface).
</p>

<p>
<e>Q:</e> My laptop supports frequency scaling, but
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> is empty.
</p>

<p>
<e>A:</e> Look for ACPI related error messages with <c>dmesg | grep ACPI</c>.
Try to update the BIOS, especially if a broken DSDT is reported. You can also
try to fix it yourself (which is beyond the scope of this guide).
</p>

<p>
<e>Q:</e> My laptop supports frequency scaling, but according to /proc/cpuinfo
the speed never changes.
</p>

<p>
<e>A:</e> Probably you have activated symmetric multiprocessing support
(CONFIG_SMP) in your kernel. Deactivate it and it should work. Some older
kernels had a bug causing this. In that case, run <c>emerge x86info</c>,
update your kernel as asked and check the current frequency with
<c>x86info -mhz</c>.
</p>

<p>
<e>Q:</e> I can change the CPU frequency, but the range is not as wide as in
another OS.
</p>

<p>
<e>A:</e> You can combine frequency scaling with ACPI throttling to get a lower
minimum frequency. Notice that throttling doesn't save much energy and is
mainly used for thermal management (keeping your laptop cool and quiet). You
can read the current throttling state with <c>cat
/proc/acpi/processor/CPU/throttling</c> and change it with <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, where x is one of the Tx states listed in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>Q:</e> When configuring the kernel, powersave, performance and userspace
governors show up, but that ondemand thing is missing. Where do I get it?
</p>

<p>
<e>A:</e> The ondemand governor is only included in recent kernel sources. Try
updating them.
</p>

<p>
<e>Q:</e> Runlevel switching doesn't work - the script is not able to determine
the power source correctly.
</p>

<p>
<e>A:</e> On some systems, the power source can't be determined by reading
<path>/proc/acpi/ac_adapter/*/state</path>. If it fails for you, create a
custom script <c>on_ac_power</c> or use the one from <c>powermgmt-base</c>.
An ebuild can be found in <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=76516">Bug #76516</uri>. You
only have to emerge it, it works transparently with the above script.
</p>

<p>
<e>Q:</e> Battery life time seems to be worse than before.
</p>

<p>
<e>A:</e> Check your BIOS settings. Maybe you forgot to re-enable some of the
settings.
</p>

<p>
<e>Q:</e> My battery is charged, but KDE reports there would be 0% left and
immediately shuts down.
</p>

<p>
<e>A:</e> Check that battery support is compiled into your kernel. If you use
it as a module, make sure the module is loaded.
</p>

<p>
<e>Q:</e> I have a Dell Inspiron 51XX and I don't get any ACPI events.
</p>

<p>
<e>A:</e> This seems to be a kernel bug. Read on <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">here</uri>.
</p>

<p>
<e>Q:</e> I just bought a brand new battery, but it only lasts for some
minutes! What am I doing wrong?
</p>

<p>
<e>A:</e> First follow your manufacturer's advice on how to charge the battery
correctly. 
</p>

<p>
<e>Q:</e> The above didn't help. What should I do then?
</p>

<p>
<e>A:</e> Some batteries sold as "new" are in fact old ones. Try the following:
</p>

<pre caption="Querying battery state">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
If the "last full capacity" differs significantly from the design capacity,
your battery is probably broken. Try to claim your warranty.
</p>

<p>
<e>Q:</e> My problem is not listed above. Where should I go next?
</p>

<p>
<e>A:</e> Don't fear to contact me, <mail link="fragfred@gmx.de">Dennis
Nienh√ºser</mail>, directly.
</p>

</body>
</section>
</chapter>
</guide>
