<section>
<subsection>
<title>Choosing the Right Stage</title>
<body>

<p>
When we asked you to choose for an installation medium (LiveCDs, existing
distribution etc.) we explained you what the pros and cons are. One of those was
choosing your stage: do you go for a full compilation (<e>stage1</e>), skip the
bootstrapping (<e>stage2</e>) or start from a precompiled stade (<e>stage3</e>)?
</p>

<p>
Depending on your installation medium, you can still make your choice. Others
will already have made the choice at the beginning of the installation. It is
now time to install your choice of stage. But first we'll configure Portage with
the compiler optimizations you want and feature support you need.
</p>

</body>
</subsection>
<subsection>
<title>Configuring the Compile Options</title>
<subsubsection>
<title>Introduction</title>
<body>

<p>
To optimize Gentoo, you can set a couple of variables which impact Portage 
behaviour. All those variables can be set as environment variables (using
<c>export</c>) but that isn't permanent. To keep your settings, Portage provides
you with <path>/etc/make.conf</path>, a configuration file for Portage. It is
this file we will edit now. 
</p>

<p>
Fire up your favorite editor (in this guide we use <c>nano</c>) so we can alter
the optimization variables we will discuss hereafter.
</p>

<pre caption="Opening /etc/make.conf">
# <i>nano -w /etc/make.conf</i>
</pre>

<p>
As you probably notice now, the <path>make.conf</path> file is structured in a
generic way: commented lines start with "#", other lines define variables using
the <c>VARIABLE="content"</c> syntax. Several of those variables are discussed
next. 
</p>

</body>
</subsubsection>
<subsubsection>
<title>CHOST</title>
<body>

<warn>
Although it might be interesting for non-stage1 users, they should <e>not</e>
change the <c>CHOST</c> setting in <path>make.conf</path>. Doing so might render
their system unusable. Again: only change this variable if you use a
<e>stage1</e> installation.
</warn>

<p>
The <c>CHOST</c> variable defines what architecture <c>gcc</c> has to
compile programs for. The possibilities are:
</p>

<table>
<tr>
  <th>Architecture</th>
  <th>Subarchitecture</th>
  <th>CHOST Setting</th>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i386</ti>
  <ti>i386-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i486</ti>
  <ti>i486-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i586</ti>
  <ti>i586-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i686 and above (incl. athlon)</ti>
  <ti>i686-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>alpha</ti>
  <ti></ti>
  <ti>alpha-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>ppc</ti>
  <ti></ti>
  <ti>powerpc-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>sparc</ti>
  <ti></ti>
  <ti>sparc-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>hppa</ti>
  <ti></ti>
  <ti></ti>
</tr>
</table>

</body>
</subsubsection>
<subsubsection>
<title>CFLAGS and CXXFLAGS</title>
<body>

<p>
The <c>CFLAGS</c> and <c>CXXFLAGS</c> variables define the optimization flags 
for the <c>gcc</c> C and C++ compiler respectively. Although we define those
generally here, you will only have maximum performance if you optimize these
flags for each program seperately. The reason for this is because every program
is different.
</p>

<p>
In <path>make.conf</path> you should define the optimization flags you think
will make your system the most responsive <e>generally</e>. Don't place
experimental settings in this variable; too much optimization can make 
programs behave bad (crash, or even worse, malfunction).
</p>

<p>
We will not explain all possible optimization options. If you want to know
them all, read the <uri link="http://www.gnu.org/software/gcc/onlinedocs/">GNU
Online Manual(s)</uri> or the <c>gcc</c> info page (<c>info gcc</c> -- only
works on a working Linux system). 
</p>

<p>
A first setting is the <c>-march=</c> flag, which specifies the name of the
target architecture. Possible options are described in the
<path>make.conf</path> file (as comments). For instance, for the x86 Athlon XP
architecture:
</p>

<pre caption="The GCC march setting">
-march=athlon-xp
</pre>

<p>
A second one is the <c>-O</c> flag, which specifies the <c>gcc</c> optimization
collection flag. Possible collections are <c>s</c> (for size-optimized),
<c>0</c> (for no optimizations), <c>1</c>, <c>2</c> or <c>3</c> for more
speed-optimization flags (every class has the same flags as the one before, plus
some extras). For instance, for a class-2 optimization collection:
</p>

<pre caption="The GCC O setting">
-O2
</pre>

<p>
Other popular optimization flags are <c>-pipe</c> (use pipes rather than
temporary files for communication between the various stages of compilation) and
<c>-fomit-frame-pointer</c> (which doesn't keep the frame pointer in a register
for functions that don't need one).
</p>

<p>
When you define the <c>CFLAGS</c> and <c>CXXFLAGS</c>, you should combine
several optimization flags, like in the following example:
</p>

<pre caption="Defining the CFLAGS and CXXFLAGS variable">
CFLAGS="-march=athlon-xp -pipe -O3"
CXXFLAGS="${CFLAGS}"                  <comment># Use the same settings for both variables</comment>
</pre>

</body>
</subsubsection>
<subsubsection>
<title>USE</title>
<body>

</body>
</subsubsection>
<subsubsection>
<title>ACCEPT_KEYWORDS</title>
<body>

</body>
</subsubsection>
<subsubsection>
<title>MAKEOPTS</title>
<body>

</body>
</subsubsection>
<subsubsection>
<title>FEATURES</title>
<body>

</body>
</subsubsection>
</subsection>
<subsection>
<title>Default: Downloading from the Internet</title>
<body>

<p>
Warn that you need networking. Download the required stage. Unpack on
the mounted system.
</p>

</body>
</subsection>
<subsection>
<title>Alternative: Using a Stage from the LiveCD</title>
<body>

<p>
Warn that you need LiveCD. Unpack stage on the mounted system.
</p>

</body>
</subsection>
</section>
