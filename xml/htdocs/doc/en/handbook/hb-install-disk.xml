<sections>
<section>
<title>Introduction to Block Devices</title>
<subsection>
<title>Block Devices</title>
<body>

<p>
We'll take a good look at disk-oriented aspects of Gentoo Linux
and Linux in general, including Linux filesystems, partitions and block devices.
Then, once you're familiar with the ins and outs of disks and filesystems,
you'll be guided through the process of setting up partitions and filesystems
for your Gentoo Linux installation.
</p>

<p>
To begin, we'll introduce <e>block devices</e>. The most famous block device is
probably the one that represents the first IDE drive in a Linux system, namely
<path>/dev/hda</path>. If your system uses SCSI drives, then your first hard
drive would be <path>/dev/sda</path>.
</p>

<p>
The block devices above represent an abstract interface to the disk. User
programs can use these block devices to interact with your disk without worrying
about whether your drives are IDE, SCSI or something else. The program can
simply address the storage on the disk as a bunch of contiguous,
randomly-accessible 512-byte blocks.
</p>

</body>
</subsection>
<subsection>
<title>Partitions and Slices</title>
<body>

<p>
Although it is theoretically possible to use a full disk to house your Linux
system, this is almost never done in practice. Instead, full disk block devices
are split up in smaller, more manageable block devices. On x86-based systems,
these are called <e>partitions</e>. Other architectures call those
<e>slices</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partitions</title>
<body>

<p>
Partitions are divided in three types:
<e>primary</e>, <e>extended</e> and <e>logical</e>.
</p>

<p>
A <e>primary</e> partition is a partition of which the information is stored in
the MBR (master boot record). As an MBR is very small (512 bytes) only four
primary partitions can be defined (for instance, <path>/dev/hda1</path> to
<path>/dev/hda4</path>).
</p>

<p>
An <e>extended</e> partition is a special primary partition (meaning the
extended partition must be one of the four possible primary partitions) which
contains more partitions. Such a partition didn't exist in the beginning, but as
four partitions is too little, it is brought to life to extend this formatting
scheme without loosing backwards compatibility.
</p>

<p>
A <e>logical</e> partition is a partition inside the extended partition. Their
definitions aren't placed inside the MBR, but are declared inside the extended
partition. 
</p>

</body>
</subsection>
<subsection>
<title>Logical Volumes</title>
<body>

<p>
Some people might find partitions and slices too restrictive. If you feel the
same way, you should take a look at LVM -- the <e>Logical Volume Manager</e>.
</p>

<p>
With LVM, you create partitions (or slices) the normal way, but you won't use
them to house your Linux system. Instead, you add another layer of storage
(namely the LVM layer) on which you install Gentoo. But what are the benefits of
LVM?
</p>

<p>
With LVM you can easily resize the volumes on which you have installed Gentoo.
You can also take a snapshot of a volume without freezing the system, making
your backup strategy more transparent for the users (and less troublesome).
Another advantage is that you can add several disks to a single volume (meaning
if one of your volumes is low on free space, you can extend it without having to
copy over files). 
</p>

<p>
An LVM is structured in three abstract items. You have a <e>physical volume</e>,
which is a partitions, slice or disk you want to use to store the LVM layer on.
Then you have a <e>volume group</e> to which you assign certain physical
volumes. This volume group contains several <e>logical volumes</e> which are 
some sort of virtual partitions.
</p>

<p>
These logical volumes are used as regular partitions; however, if a logical
volume requires more space, it can use the available space in the volume group
to extend itself. If the volume group doesn't have sufficient available space,
you can add more physical volumes to it, fully transparent to the user (i.e. no
need to copy over data, freeze the system etc.). This makes LVM very flexible.
</p>

</body>
</subsection>
</section>
<section>
<title>Designing a Partitioning Scheme</title>
<subsection>
<title>Default Partitioning Scheme</title>
<body>

<p>
If you are not interesting in drawing up a partitioning scheme for your system,
you can use the partitioning scheme we use throughout this book:
</p>

<p>
For x86:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
For ppc:
</p>

<table>
<tr>
  <th>Partition NewWorld</th>
  <th>Partition OldWorld</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Not needed)</ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Bootstrap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
For Sparc:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Full disk</ti>
  <ti>Sun Disk Label (required)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
However, if you are interested in knowing what filesystem to choose and how big
a partition should be, or even how many partitions you need, read on. Otherwise
continue now with partitioning your disk (the "<e>Using ... to Partition your
Disk</e>" for your architecture).
</p>

</body>
</subsection>
<subsection>
<title>How Many and How Big?</title>
<body>

</body>
</subsection>
<subsection>
<title>Filesystems?</title>
<body>

<p>
Several filesystems are available. Some of them are found stable on all
architectures, others only on a few. The following table lists the available
filesystems and the architectures they are known to work on:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Journaled</th>
  <th>Architectures</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>All architectures</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>yes</ti>
  <ti>All</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>yes</ti>
  <ti>x86, hppa, alpha</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>yes</ti>
  <ti>x86, hppa, alpha</ti>
</tr>
<tr>
  <ti>xjfs</ti>
  <ti>yes</ti>
  <ti>x86, hppa, alpha</ti>
</tr>
</table>

<p>
ext2 is the tried and true Linux filesystem but doesn't have metadata
journaling, which means that routine ext2 filesystem checks at startup time can
be quite time-consuming. There is now quite a selection of newer-generation
journaled filesystems that can be checked for consistency very quickly and are
thus generally preferred over their non-journaled counterparts. Journaled
filesystems prevent long delays when you boot your system and your filesystem
happens to be in an inconsistent state.
</p>

<p>
ext3 is the journaled version of the ext2 filesystem, providing metadata
journaling for fast recovery in addition to other enhanced journaling modes like
full data and ordered data journaling. ext3 is a very good and reliable
filesystem. It offers generally decent performance under most conditions.
Because it does not extensively employ the use of "trees" in its internal
design, it doesn't scale very well, meaning that it is not an ideal choice for
very large filesystems, or situations where you will be handling very large
files or large quantities of files in a single directory. But when used within
its design parameters, ext3 is an excellent filesystem.
</p>

<p>
ReiserFS is a B*-tree based filesystem that has very good overall performance
and greatly outperforms both ext2 and ext3 when dealing with small files (files
less than 4k), often by a factor of 10x-15x. ReiserFS also scales extremely well
and has metadata journaling. As of kernel 2.4.18+, ReiserFS is now rock-solid
and highly recommended for use both as a general-purpose filesystem and for
extreme cases such as the creation of large filesystems, the use of many small
files, very large files and directories containing tens of thousands of files.
ReiserFS is the filesystem we recommend by default for all non-boot partitions.
</p>

<p>
XFS is a filesystem with metadata journaling that is fully supported under
Gentoo Linux's xfs-sources kernel. It comes with a robust feature-set and is
optimized for scalability. We only recommend using this filesystem on Linux
systems with high-end SCSI and/or fibre channel storage and a uninterruptible
power supply. Because XFS aggressively caches in-transit data in RAM, improperly
designed programs (those that don't take proper precautions when writing files
to disk and there are quite a few of them) can lose a good deal of data if the
system goes down unexpectedly.
</p>

<p>
JFS is IBM's high-performance journaling filesystem. It has recently become
production-ready and there hasn't been a sufficient track record to comment
positively nor negatively on its general stability at this point.
</p>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on x86 to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>x86</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example partition layout described
previously, namely:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
Change your partition layout according to your own will.
</p>

</body>
</subsection>
<subsection>
<title>Viewing the Current Partition Layout</title>
<body>

<p>
<c>fdisk</c> is a popular and powerful tool to split your disk into partitions.
Fire up <c>fdisk</c> on your disk (in our example, we use
<path>/dev/hda</path>):
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Once in <c>fdisk</c>, you'll be greeted with a prompt that looks like this:
</p>

<pre caption="fdisk prompt">
Command (m for help): 
</pre>

<p>
Type <c>p</c> to display your disk's current partition configuration:
</p>

<pre caption="An example partition configuration">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
This particular disk is configured to house seven Linux filesystems (each with a
corresponding partition listed as "Linux") as well as a swap partition (listed
as "Linux swap"). 
</p>

</body>
</subsection>
<subsection>
<title>Removing all Partitions</title>
<body>

<p>
We will first remove all existing partitions from the disk. Type <c>d</c> to
delete a partition. For instance, to delete an existing <path>/dev/hda1</path>:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
The partition has been scheduled for deletion. It will no longer show up if you
type <c>p</c>, but it will not be erased until your changes have been saved. If
you made a mistake and want to abort without saving your changes, type <c>q</c>
immediately and hit enter and your partition will not be deleted.
</p>

<p>
Now, assuming that you do indeed want to wipe out all the partitions on your
system, repeatedly type <c>p</c> to print out a partition listing and then type
<c>d</c> and the number of the partition to delete it. Eventually, you'll end 
up with a partition table with nothing in it:
</p>

<pre caption="An empty partition table">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Now that the in-memory partition table is empty, we're ready to create the
partitions. We will use a default partitioning scheme as discussed previously.
Ofcourse, don't follow these instructions to the letter if you don't want the
same partitioning scheme!
</p>

</body>
</subsection>
<subsection>
<title>Creating the Boot Partition</title>
<body>

<p>
We first create a small boot partition. Type <c>n</c> to create a new partition,
then <c>p</c> to select a primary partition, followed by <c>1</c> to select the
first primary partition. When prompted for the first cylinder, hit enter. When
prompted for the last cylinder, type <c>+32M</c> to create a partition 32 Mbyte
in size:
</p>

<pre caption="Creating the boot partition">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition printout:
</p>

<pre caption="Created boot partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Swap Partition</title>
<body>

<p>
Let's now create the swap partition. To do this, type <c>n</c> to create a new 
partition, then <c>p</c> to tell fdisk that you want a primary partition. Then 
type <c>2</c> to create the second primary partition, <path>/dev/hda2</path> in
our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After
you've done this, type <c>t</c> to set the partition type, <c>2</c> to select 
the partition you just created and then type in <c>82</c> to set the partition 
type to "Linux Swap". After completing these steps, typing <c>p</c> should
display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating a swap partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Root Partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then <c>p</c> to tell fdisk that you want a primary partition. 
Then type <c>3</c> to create the third primary partition, <path>/dev/hda3</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for
the last cylinder, hit enter to create a partition that takes up the rest of the
remaining space on your disk. After completing these steps, typing <c>p</c> 
should display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating the root partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Saving the Partition Layout</title>
<body>

<p>
To save the partition layout and exit <c>fdisk</c>, type <c>x</c>.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>x</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on Alpha to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>Alpha</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example slice layout described
previously, namely:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Full disk (required)</ti>
</tr>
</table>

<p>
Change your slice layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Identifying Available Disks</title>
<body>

<p>
To figure out what disks you have running, use the following commands:
</p>

<pre caption="Identifying available disks">
<comment>(For IDE disks)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(For SCSI disks)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
From this output you should be able to see what disks were detected and their
respective <path>/dev</path> entry. In the following parts we assume that the
disk is a SCSI disk on <path>/dev/sda</path>.
</p>

<p>
Now fire up <c>fdisk</c>:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Deleting All Slices</title>
<body>

<p>
We start with deleting all slices <e>except</e> the 'c'-slice. The following
shows how to delete a slice (in the example we use 'a'). Repeat the process to
delete all other slices (again, except the 'c'-slice).
</p>

<p>
Use <c>p</c> to view all existing slices. <c>d</c> is used to delete a slice.
</p>

<pre caption="Deleting a slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
After repeating this process for all slices, a listing should show you something
similar to this:
</p>

<pre caption="Viewing an empty scheme">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Swap Slice</title>
<body>

<p>
On Alpha based systems you don't need a seperate boot partition. However, the
first cylinder cannot be used as the <c>aboot</c> image will be placed there.
</p>

<p>
We will create a swap slice starting at the third cylinder, with a total
size of 1 Gbyte. Use <c>n</c> to create a new slice. After creating the slice,
we will change its type to <c>1</c>, meaning <e>swap</e>.
</p>

<pre caption="Creating the swap slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
After these steps you should see a layout similar to the following:
</p>

<pre caption="Slice layout after creating the swap slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Create the Root Slice</title>
<body>

<p>
We will now create the root slice, starting from the first cylinder <e>after</e>
the swap slice. Use the <c>p</c> command to view where the swap slice ends. In
our example, this is at 1003, making the root partition start at 1004.
</p>

<p>
Another problem is that there is currently a bug in <c>fdisk</c> making it think
the number of available cylinders is one above the real number of cylinders. In
other words, when you are asked for the last cylinder, decrease the cylinder
number (in this example: 5290) with one.
</p>

<p>
When the partition is created, we change the type to <c>8</c>, for <e>ext2</e>.
</p>

<pre caption="Creating the root slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Your slice layout should now be similar to this:
</p>

<pre caption="Viewing the slice layout">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Save the Slice Layout and Exit</title>
<body>

<p>
Save <c>fdisk</c> by typing <c>x</c>. This will also save your slice layout.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>x</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on SPARC to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>SPARC</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example partition layout described
previously, namely:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (required)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
Change your partition layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Firing up fdisk</title>
<body>

<p>
Start <c>fdisk</c> with your disk as argument:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
You should be greeted with the fdisk prompt:
</p>

<pre caption="The fdisk prompt">
Command (m for help):
</pre>

<p>
To view the available partitions, type in <c>p</c>:
</p>

<pre caption="Listing available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Deleting Existing Partitions</title>
<body>

<p>
It's time to delete any existing partitions. To do this, type <c>d</c> and hit 
Enter. You will then be prompted for the partition number you would like to 
delete. To delete a pre-existing <path>/dev/hda1</path>, you would type:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Assuming you want to remove all existing partitions, press <c>p</c> to view the
available partitions, and <c>d</c> to delete those one by one. If you feel like
you made an error, press <c>q</c> immediately -- <c>fdisk</c> doesn't
immediately change the partitions but keeps the changes in memory. Only when you
press <c>x</c> are the partitions saved.
</p>

<p>
After deleting all partitions, you should have a partition layout similar to the
following:
</p>

<pre caption="View an empty partition scheme">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Create the Sun Disk Label</title>
<body>

<p>
Now that the in-memory partition table is empty, we're ready to create the Sun
Disk Label partition. To do this, type <c>n</c> to create a new partition, then 
type <c>3</c> to create the partition. When prompted for the first cylinder, 
hit enter. When prompted for the last cylinder, hit enter. After you've done 
this, type <c>t</c> to set the partition type, and then type in <c>5</c> to set
the partition type to "Whole disk".
</p>

<pre caption="Steps to create a Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Press Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
After completing these steps, typing <c>p</c> should display a partition table 
that looks similar to this:
</p>

<pre caption="View the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Boot Partition</title>
<body>

<p>
We're ready to create a boot partition. To do this, type <c>n</c> to create a 
new partition, then type <c>1</c> to create the partition. When prompted for the
first cylinder, hit enter. When prompted for the last cylinder, type <c>+32M</c>
to create a partition <c>32MB</c> in size. You can see output from these steps 
below:
</p>

<pre caption="Creating a boot partition">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Press Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition printout:
</p>

<pre caption="Listing the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Creating a swap partition</title>
<body>

<p>
Next, let's create the swap partition. To do this, type <c>n</c> to create a new
partition, then <c>2</c> to create the second partition, <path>/dev/hda2</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After 
you've done this, type <c>t</c> to set the partition type, and then type in 
<c>82</c> to set the partition type to "Linux Swap". After completing these 
steps, typing <c>p</c> should display a partition table that looks similar to 
this:
</p>

<pre caption="Listing of available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the root partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then type <c>4</c> to create the third partition, 
<path>/dev/hda4</path> in our case. When prompted for the first cylinder, hit 
enter. When prompted for the last cylinder, hit enter to create a partition 
that takes up the rest of the remaining space on your disk. After completing 
these steps, typing <c>p</c> should display a partition table that looks similar
to this:
</p>

<pre caption="Listing complete partition table">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Save and Exit</title>
<body>

<p>
To save your partition layout and exit <c>fdisk</c>, type <c>x</c>:
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>x</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Using mac-fdisk on PPC to Partition your Disk</title>
<body>

<p>
At this point, create your partitions using <c>mac-fdisk</c>:
</p>

<pre caption="Starting mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
You will need to make at a minimum a bootstrap partition (b in mac-fdisk) (New 
World users only), a swap partition (generally 1,5* ram in your box is good, h
owever I would recommend at least 512MB swap partition if you plan on compiling 
any large packages), and a root partition. ? at the prompt of mac-fdisk will 
give you a list of options.
</p>

</body>
</section>
<section>
<title>Using fdisk on HPPA to Partition your Disk</title>
<body>

<p>
Use <c>fdisk</c> to create the partitions you want:
</p>

<pre caption="Partitioning the disk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO needs a special partition to work. You have to create a partition of at
least 16Mb at the beginning of your disk. The partition type must be of type
<e>f0</e> (Linux/PA-RISC boot).
</p>

<p>
Also, if your disk is larger than 2Gb, make sure that the boot partition is in
the first 2Gb of your disk. PALO is unable to read a kernel after the 2Gb limit.
</p>

</body>
</section>
<section>
<title>Optional: Using LVM</title>
<subsection>
<title>Initialising the Partitions</title>
<body>

<p>
To use LVM, you first need to initialise your created partitions. To do so, use
<c>pvcreate</c>. In this example, we assume that <path>/dev/hda1</path> is a
regular boot partition, <path>/dev/hda3</path> a regular (but small) root 
partition, <path>/dev/hda2</path> a regular swap partition, and 
<path>/dev/hda4</path> &amp; <path>/dev/hdb1</path> two available partitions for
the LVM.
</p>

<pre caption="Initialising LVM partitions">
# <i>pvcreate /dev/hda4</i>
# <i>pvcreate /dev/hdb1</i>
</pre>

</body>
</subsection>
<subsection>
<title>Set up the Volume Group</title>
<body>

<p>
Now we need to setup the volume group. We will use <c>vgcreate</c> to do so, but
<c>vgcreate</c> needs the full (DevFS-style) path to the device file. So we
first find out where these devices files are located:
</p>

<pre caption="Getting to know the full location">
# <i>ls -l /dev/hda4</i>
lr-xr-xr-x    1 root     root           33 Oct 21  2003 /dev/hda4 -&gt; ide/host0/bus0/target0/lun0/part4
</pre>

<p>
Now we create the volume group called "vg":
</p>

<pre caption="Create the VG group">
# <i>vgcreate vg /dev/ide/host0/bus0/target0/lun0/part4 /dev/ide/host0/bus0/target1/lun0/part1</i>
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Logical Volumes</title>
<body>

<p>
Now we create the logical volumes. In this example, we create a seperate
<path>usr/</path> (10 Gb), <path>home/</path> (5 Gb) and <path>var/</path> (5
Gb):
</p>

<pre caption="Creating the logical volumes">
# <i>lvcreate -L10G -nusr vg</i>
# <i>lvcreate -L5G -nhome vg</i>
# <i>lvcreate -L5G -nvar vg</i>
</pre>

<p>
As of now, the logical volumes are created and usable as it were regular
partitions:
</p>

<pre caption="Listing the logical volumes">
# <i>ls /dev/vg</i>
home   usr    var
</pre>

</body>
</subsection>
</section>
<section>
<title>Creating Filesystems</title>
<subsection>
<title>Applying a Filesystem to a Partition</title>
<body>

<p>
To create a filesystem on a partition, there are tools available for each
possible filesystem:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Creation Command</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
For instance, to have the boot partition (<path>/dev/hda1</path> in our
example) in ext2 and the root partition (<path>/dev/hda3</path> in our example)
in ext3 (as in our example), you would use:
</p>

<pre caption="Applying a filesystem on a partition">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Now create the filesystems on your newly created partitions (or logical
volumes).
</p>

</body>
</subsection>
<subsection>
<title>Activating the Swap Partition</title>
<body>

<p>
<c>mkswap</c> is the command that is used to initialize swap partitions:
</p>

<pre caption="Creating a Swap signature">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
To activate the swap partition, use <c>swapon</c>:
</p>

<pre caption="Activating the swap partition">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Create and activate the swap now.
</p>

</body>
</subsection>
</section>
<section>
<title>Mounting</title>
<body>

<p>
Now that your partitions are initialised and are housing a filesystem, it is
time to mount those partitions. Use the <c>mount</c> command. Don't forget to
create the necessary mount directories:
</p>

<pre caption="Mounting partitions">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<p>
We also need to mount the proc filesystem (a virtual interface with the kernel)
on <path>/proc</path>:
</p>

<pre caption="Mounting the proc filesystem">
# <i>mkdir /mnt/gentoo/proc</i>
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>
</body>
</section>
</sections>
