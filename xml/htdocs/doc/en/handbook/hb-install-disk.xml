<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/handbook/Attic/hb-install-disk.xml,v 1.26 2003/12/17 05:29:14 swift Exp $ -->

<sections>
<section>
<title>Introduction to Block Devices</title>
<subsection>
<title>Block Devices</title>
<body>

<p>
We'll take a good look at disk-oriented aspects of Gentoo Linux
and Linux in general, including Linux filesystems, partitions and block devices.
Then, once you're familiar with the ins and outs of disks and filesystems,
you'll be guided through the process of setting up partitions and filesystems
for your Gentoo Linux installation.
</p>

<p>
To begin, we'll introduce <e>block devices</e>. The most famous block device is
probably the one that represents the first IDE drive in a Linux system, namely
<path>/dev/hda</path>. If your system uses SCSI drives, then your first hard
drive would be <path>/dev/sda</path>.
</p>

<p>
The block devices above represent an abstract interface to the disk. User
programs can use these block devices to interact with your disk without worrying
about whether your drives are IDE, SCSI or something else. The program can
simply address the storage on the disk as a bunch of contiguous,
randomly-accessible 512-byte blocks.
</p>

</body>
</subsection>
<subsection>
<title>Partitions and Slices</title>
<body>

<p>
Although it is theoretically possible to use a full disk to house your Linux
system, this is almost never done in practice. Instead, full disk block devices
are split up in smaller, more manageable block devices. On most systems,
these are called <e>partitions</e>. Other architectures use a similar technique,
called <e>slices</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partitions</title>
<body>

<p>
Partitions are divided in three types:
<e>primary</e>, <e>extended</e> and <e>logical</e>.
</p>

<p>
A <e>primary</e> partition is a partition of which the information is stored in
the MBR (master boot record). As an MBR is very small (512 bytes) only four
primary partitions can be defined (for instance, <path>/dev/hda1</path> to
<path>/dev/hda4</path>).
</p>

<p>
An <e>extended</e> partition is a special primary partition (meaning the
extended partition must be one of the four possible primary partitions) which
contains more partitions. Such a partition didn't exist originally, but as
four partitions is too little, it is brought to life to extend the formatting
scheme without loosing backwards compatibility.
</p>

<p>
A <e>logical</e> partition is a partition inside the extended partition. Their
definitions aren't placed inside the MBR, but are declared inside the extended
partition. 
</p>

</body>
</subsection>
<subsection>
<title>Logical Volumes</title>
<body>

<p>
Some people might find partitions and slices too restrictive. If you feel the
same way, you should take a look at LVM -- the <e>Logical Volume Manager</e>.
</p>

<p>
With LVM, you create partitions (or slices) the normal way, but you won't use
them to house your Linux system. Instead, you add another layer of storage
(namely the LVM layer) on which you install Gentoo. But what are the benefits of
LVM?
</p>

<p>
With LVM you can easily resize the volumes on which you have installed Gentoo.
You can also take a snapshot of a volume without freezing the system, making
your backup strategy more transparent for the users (and less troublesome).
Another advantage is that you can add several disks to a single volume (meaning
if one of your volumes is low on free space, you can extend it without having to
copy over files). 
</p>

<p>
An LVM is structured in three abstract items. You have a <e>physical volume</e>,
which is a partition, slice or disk you want to use to store the LVM layer on.
Then you have a <e>volume group</e> to which you assign certain physical
volumes. This volume group contains several <e>logical volumes</e> which are 
some sort of virtual partitions.
</p>

<p>
These logical volumes are used as regular partitions; however, if a logical
volume requires more space, it can use the available space in the volume group
to extend itself. If the volume group doesn't have sufficient available space,
you can add more physical volumes to it, fully transparent to the user (i.e. no
need to copy over data, freeze the system etc.). This makes LVM very flexible.
</p>

<p>
If you want to use LVM, you are advised to keep your root filesystem
(<path>/</path>) and your boot filesystem (<path>/boot</path>) outside the LVM.
If you want to place most of your files in a logical volume (<path>/home</path>,
<path>/usr</path>, <path>/tmp</path>, <path>/opt</path> and <path>/var</path> 
are used in this handbook) your root filesystem doesn't need to be very big 
(a mere 150 Mb will do just fine).
</p>

</body>
</subsection>
</section>
<section>
<title>Designing a Partitioning Scheme</title>
<subsection>
<title>Default Partitioning Scheme</title>
<body>

<p>
If you are not interesting in drawing up a partitioning scheme for your system,
you can use the (non-LVM) partitioning scheme we use throughout this book:
</p>

<p>
For x86:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
For ppc:
</p>

<table>
<tr>
  <th>Partition NewWorld</th>
  <th>Partition OldWorld</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Not needed)</ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Bootstrap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
For Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>Filesystem</th>
  <th>Size</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Full disk</ti>
  <ti>Sun Disk Label (required)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Rest of the disk</ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
If you want to use LVM, you should create a small root partition instead of a
big one, ignore the swap partition and create a big partition as you will make 
the individual separation later when you define the logical volumes). Then mark 
this big partition of type "Linux LVM" or "LVM" (8e).
</p>

<p>
If you are installing Gentoo from an existing distribution, you should first
resize your existing partitions (if you don't have any spare room left) to be
able to install Gentoo. You can use <uri 
link="http://www.gnu.org/software/parted">GNU/Parted</uri> to resize your
partitions.
</p>

<p>
If you are interested in knowing how big a partition (or logical 
volume) should be, or even how many partitions (or volumes) you need, read on. 
Otherwise continue now with partitioning your disk:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Using fdisk on x86 to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap4">Using fdisk on Alpha to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap5">Using fdisk on SPARC to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap6">Using mac-fdisk on PPC to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap7">Using fdisk on HPPA to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap8">Using fdisk on MIPS to Partition your Disk</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>How Many and How Big?</title>
<body>

<p>
The number of partitions (or logical volumes in case you want to use LVM) is 
highly dependent on your environment. For instance,
if you have lots of users, you will most likely want to have your
<path>/home</path> separate as it increases security and makes backups more
easy. If you are installing Gentoo to perform as a mailserver, your 
<path>/var</path> should be separate as all mails are stored inside 
<path>/var</path>. A good choice of filesystem will then maximise your 
performance. Gameservers will have a separate <path>/opt</path> as most gaming 
servers are installed there. The reason is similar for <path>/home</path>: 
security and backups.
</p>

<p>
As you can see, it very much depends on what you want to achieve. Separate
partitions or volumes have the following advantages:
</p>

<ul>
<li>
  You can choose the most performant filesystem for each partition or volume
</li>
<li>
  Your entire system cannot run out of free space if one defunct tool is
  continuously writing files to a partition or volume
</li>
<li>
  If necessary, file system checks are reduced in time, as multiple checks can
  be done in parallel (although this advantage is more with multiple disks than
  it is with multiple partitions)
</li>
<li>
  Security can be enhanced by mounting some partitions or volumes read-only, 
  nosuid (setuid bits are ignored), noexec (executable bits are ignored) etc.
</li>
</ul>

<p>
However, multiple partitions have one big disadvantage (if you're not using
LVM): if not configured properly, you might result in having a system with lots
of free space on one partition and none on another.
</p>

<p>
As an example partitioning, we show you one for a 20Gb disk, used as a
demonstration laptop (containing webserver, mailserver, gnome, ...):
</p>

<pre caption="Filesystem usage example">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Unpartitioned space for future usage: 2 Gb)</comment>
</pre>

<p>
<path>/usr</path> is rather full (83% used) here, but once
all software is installed, <path>/usr</path> doesn't tend to grow that much.
For <path>/var</path>, people might think the assigned
space is too much. However, Gentoo compiles all programs inside
<path>/var/tmp/portage</path>, so you should have <path>/var</path> with at
least 1G free if you don't want to compile big programs, up to 3G free if 
compiling KDE and OpenOffice.org at the same time is no big deal for you.
</p>

<p>
Now partition your disk(s) using the instructions available for your
architecture as an example:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Using fdisk on x86 to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap4">Using fdisk on Alpha to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap5">Using fdisk on SPARC to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap6">Using mac-fdisk on PPC to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap7">Using fdisk on HPPA to Partition your Disk</uri>
</li>
<li>
  <uri link="#doc_chap8">Using fdisk on MIPS to Partition your Disk</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on x86 to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>x86</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example non-LVM partition layout 
described previously, namely:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
Change your partition layout according to your own will.
</p>

</body>
</subsection>
<subsection>
<title>Viewing the Current Partition Layout</title>
<body>

<p>
<c>fdisk</c> is a popular and powerful tool to split your disk into partitions.
Fire up <c>fdisk</c> on your disk (in our example, we use
<path>/dev/hda</path>):
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Once in <c>fdisk</c>, you'll be greeted with a prompt that looks like this:
</p>

<pre caption="fdisk prompt">
Command (m for help): 
</pre>

<p>
Type <c>p</c> to display your disk's current partition configuration:
</p>

<pre caption="An example partition configuration">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
This particular disk is configured to house seven Linux filesystems (each with a
corresponding partition listed as "Linux") as well as a swap partition (listed
as "Linux swap"). 
</p>

</body>
</subsection>
<subsection>
<title>Removing all Partitions</title>
<body>

<p>
We will first remove all existing partitions from the disk. Type <c>d</c> to
delete a partition. For instance, to delete an existing <path>/dev/hda1</path>:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
The partition has been scheduled for deletion. It will no longer show up if you
type <c>p</c>, but it will not be erased until your changes have been saved. If
you made a mistake and want to abort without saving your changes, type <c>q</c>
immediately and hit enter and your partition will not be deleted.
</p>

<p>
Now, assuming that you do indeed want to wipe out all the partitions on your
system, repeatedly type <c>p</c> to print out a partition listing and then type
<c>d</c> and the number of the partition to delete it. Eventually, you'll end 
up with a partition table with nothing in it:
</p>

<pre caption="An empty partition table">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Now that the in-memory partition table is empty, we're ready to create the
partitions. We will use a default partitioning scheme as discussed previously.
Of course, don't follow these instructions to the letter if you don't want the
same partitioning scheme!
</p>

</body>
</subsection>
<subsection>
<title>Creating the Boot Partition</title>
<body>

<p>
We first create a small boot partition. Type <c>n</c> to create a new partition,
then <c>p</c> to select a primary partition, followed by <c>1</c> to select the
first primary partition. When prompted for the first cylinder, hit enter. When
prompted for the last cylinder, type <c>+32M</c> to create a partition 32 Mbyte
in size:
</p>

<pre caption="Creating the boot partition">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition printout:
</p>

<pre caption="Created boot partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
We need to make this partition bootable. Type <c>a</c> to toggle the bootable
flag on this partition. If you press <c>p</c> again, you will notice that an
<path>*</path> is placed in the "Boot" column.
</p>

</body>
</subsection>
<subsection>
<title>Creating the Swap Partition</title>
<body>

<p>
Let's now create the swap partition. To do this, type <c>n</c> to create a new 
partition, then <c>p</c> to tell fdisk that you want a primary partition. Then 
type <c>2</c> to create the second primary partition, <path>/dev/hda2</path> in
our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After
you've done this, type <c>t</c> to set the partition type, <c>2</c> to select 
the partition you just created and then type in <c>82</c> to set the partition 
type to "Linux Swap". After completing these steps, typing <c>p</c> should
display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating a swap partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Root Partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then <c>p</c> to tell fdisk that you want a primary partition. 
Then type <c>3</c> to create the third primary partition, <path>/dev/hda3</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for
the last cylinder, hit enter to create a partition that takes up the rest of the
remaining space on your disk. After completing these steps, typing <c>p</c> 
should display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating the root partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Saving the Partition Layout</title>
<body>

<p>
To save the partition layout and exit <c>fdisk</c>, type <c>w</c>.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your partitions are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on Alpha to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>Alpha</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example slice layout described
previously, namely:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Full disk (required)</ti>
</tr>
</table>

<p>
Change your slice layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Identifying Available Disks</title>
<body>

<p>
To figure out what disks you have running, use the following commands:
</p>

<pre caption="Identifying available disks">
<comment>(For IDE disks)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(For SCSI disks)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
From this output you should be able to see what disks were detected and their
respective <path>/dev</path> entry. In the following parts we assume that the
disk is a SCSI disk on <path>/dev/sda</path>.
</p>

<p>
Now fire up <c>fdisk</c>:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Deleting All Slices</title>
<body>

<p>
We start with deleting all slices <e>except</e> the 'c'-slice. The following
shows how to delete a slice (in the example we use 'a'). Repeat the process to
delete all other slices (again, except the 'c'-slice).
</p>

<p>
Use <c>p</c> to view all existing slices. <c>d</c> is used to delete a slice.
</p>

<pre caption="Deleting a slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
After repeating this process for all slices, a listing should show you something
similar to this:
</p>

<pre caption="Viewing an empty scheme">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Swap Slice</title>
<body>

<p>
On Alpha based systems you don't need a separate boot partition. However, the
first cylinder cannot be used as the <c>aboot</c> image will be placed there.
</p>

<p>
We will create a swap slice starting at the third cylinder, with a total
size of 1 Gbyte. Use <c>n</c> to create a new slice. After creating the slice,
we will change its type to <c>1</c>, meaning <e>swap</e>.
</p>

<pre caption="Creating the swap slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
After these steps you should see a layout similar to the following:
</p>

<pre caption="Slice layout after creating the swap slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Create the Root Slice</title>
<body>

<p>
We will now create the root slice, starting from the first cylinder <e>after</e>
the swap slice. Use the <c>p</c> command to view where the swap slice ends. In
our example, this is at 1003, making the root partition start at 1004.
</p>

<p>
Another problem is that there is currently a bug in <c>fdisk</c> making it think
the number of available cylinders is one above the real number of cylinders. In
other words, when you are asked for the last cylinder, decrease the cylinder
number (in this example: 5290) with one.
</p>

<p>
When the partition is created, we change the type to <c>8</c>, for <e>ext2</e>.
</p>

<pre caption="Creating the root slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Your slice layout should now be similar to this:
</p>

<pre caption="Viewing the slice layout">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Save the Slice Layout and Exit</title>
<body>

<p>
Save <c>fdisk</c> by typing <c>w</c>. This will also save your slice layout.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your slices are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on SPARC to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>SPARC</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example partition layout described
previously, namely:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (required)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
Change your partition layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Firing up fdisk</title>
<body>

<p>
Start <c>fdisk</c> with your disk as argument:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
You should be greeted with the fdisk prompt:
</p>

<pre caption="The fdisk prompt">
Command (m for help):
</pre>

<p>
To view the available partitions, type in <c>p</c>:
</p>

<pre caption="Listing available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Note the <c>Sun disk label</c> in the output. If this is missing, the disk is
using the DOS-partitioning, not the Sun partitioning. In this case, use <c>s</c>
to ensure that the disk has a sun partition table.
</p>

</body>
</subsection>
<subsection>
<title>Deleting Existing Partitions</title>
<body>

<p>
It's time to delete any existing partitions. To do this, type <c>d</c> and hit 
Enter. You will then be prompted for the partition number you would like to 
delete. To delete a pre-existing <path>/dev/hda1</path>, you would type:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Assuming you want to remove all existing partitions, press <c>p</c> to view the
available partitions, and <c>d</c> to delete those one by one. If you feel like
you made an error, press <c>q</c> immediately -- <c>fdisk</c> doesn't
immediately change the partitions but keeps the changes in memory. Only when you
press <c>w</c> are the partitions saved.
</p>

<p>
After deleting all partitions, you should have a partition layout similar to the
following:
</p>

<pre caption="View an empty partition scheme">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Create the Sun Disk Label</title>
<body>

<p>
Now that the in-memory partition table is empty, we're ready to create the Sun
Disk Label partition. To do this, type <c>n</c> to create a new partition, then 
type <c>3</c> to create the partition. When prompted for the first cylinder, 
hit enter. When prompted for the last cylinder, hit enter. After you've done 
this, type <c>t</c> to set the partition type, and then type in <c>5</c> to set
the partition type to "Whole disk".
</p>

<pre caption="Steps to create a Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Press Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
After completing these steps, typing <c>p</c> should display a partition table 
that looks similar to this:
</p>

<pre caption="View the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Boot Partition</title>
<body>

<p>
We're ready to create a boot partition. To do this, type <c>n</c> to create a 
new partition, then type <c>1</c> to create the partition. When prompted for the
first cylinder, hit enter. When prompted for the last cylinder, type <c>+32M</c>
to create a partition <c>32MB</c> in size. Make sure that the entire boot
partition must be contained entirely within the first 2Gb of the disk. 
You can see output from these steps below:
</p>

<pre caption="Creating a boot partition">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Press Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition printout:
</p>

<pre caption="Listing the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Creating a swap partition</title>
<body>

<p>
Next, let's create the swap partition. To do this, type <c>n</c> to create a new
partition, then <c>2</c> to create the second partition, <path>/dev/hda2</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After 
you've done this, type <c>t</c> to set the partition type, and then type in 
<c>82</c> to set the partition type to "Linux Swap". After completing these 
steps, typing <c>p</c> should display a partition table that looks similar to 
this:
</p>

<pre caption="Listing of available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the root partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then type <c>4</c> to create the third partition, 
<path>/dev/hda4</path> in our case. When prompted for the first cylinder, hit 
enter. When prompted for the last cylinder, hit enter to create a partition 
that takes up the rest of the remaining space on your disk. After completing 
these steps, typing <c>p</c> should display a partition table that looks similar
to this:
</p>

<pre caption="Listing complete partition table">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Save and Exit</title>
<body>

<p>
To save your partition layout and exit <c>fdisk</c>, type <c>w</c>:
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your partitions are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using mac-fdisk on PPC to Partition your Disk</title>
<body>

<p>
At this point, create your partitions using <c>mac-fdisk</c>:
</p>

<pre caption="Starting mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
First delete the partitions you have cleared previously to make room for your
Linux partitions. Use <c>d</c> in <c>mac-fdisk</c> to delete those partition(s).
It will ask for the partition number to delete.
</p>

<p>
Second, create an <e>Apple_Bootstrap</e> partition by using <c>b</c>. It will
ask for what block you want to start. If you previously selected <c>3</c> as
partition number, enter <c>3p</c>.
</p>

<p>
Now create a swap partition by pressing <c>c</c>. Again <c>mac-fdisk</c> will
ask for what block you want to start this partition from. As we used <c>3</c>
before to create the Apple_Bootstrap partition, you now have to enter
<c>4p</c>. When you're asked for the size, enter <c>512M</c> (or whatever size
you want -- 512 is recommended though). When asked for a name, enter <c>swap</c>
(mandatory).
</p>

<p>
To create the root partition, enter <c>c</c>, followed by <c>5p</c> to select
from what block the root partition should start. When asked for the size, enter
<c>5p</c> again. <c>mac-fdisk</c> will interprete this as "Use all available
space". When asked for the name, enter <c>root</c> (mandatory).
</p>

<p>
To finish up, write the partition to the disk using <c>w</c> and <c>q</c> to
quit <c>mac-fdisk</c>.
</p>

<p>
Now that your partitions are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</section>
<section>
<title>Using fdisk on HPPA to Partition your Disk</title>
<body>

<p>
Use <c>fdisk</c> to create the partitions you want:
</p>

<pre caption="Partitioning the disk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO needs a special partition to work. You have to create a partition of at
least 16Mb at the beginning of your disk. The partition type must be of type
<e>f0</e> (Linux/PA-RISC boot).
</p>

<impo>
If you ignore this and continue without a special PALO partition, your system
will stop loving you and fail to start.
</impo>

<p>
Also, if your disk is larger than 2Gb, make sure that the boot partition is in
the first 2Gb of your disk. PALO is unable to read a kernel after the 2Gb limit.
</p>

<p>
Now that your partitions are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</section>
<section>
<title>Using fdisk on MIPS to Partition your Disk</title>
<!-- This entire section is copy/pasted from Kumba's original text. It should
     probably be rewritten, but it seems a bit complicated.
     Someone donate me a MIPS? :) 

       ~SwifT
-->
<subsection>
<title>Creating an SGI Disk Label</title>
<body>

<p>
All disks in an SGI System require an <e>SGI Disk Label</e>, which serves a 
similar function as Sun &amp; MS-DOS disklabels -- It stores information about 
the disk partitions. Creating a new SGI Disk Label will create two special 
partitions on the disk:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (9th partition): This partition is important. It
    is where the kernel images will go. To store kernel images, you will utilize
    the tool known as <c>dvhtool</c> to copy kernel images to this partition. 
    You will then be able to boot kernels from this partition via the SGI PROM 
    Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (11th partition): This partition is similar in purpose to
    the Sun Disklabel's third partition of "Whole Disk". This partition spans
    the entire disk, and should be left untouched. It serves no special purpose
    other than to assist the PROM in some undocumented fashion (or it is used by
    IRIX in some way).
  </li>
</ul>

<warn>
The SGI Volume Header <e>must</e> begin at cylinder 0. Failure to do so means
you won't be able to boot from the disk.
</warn>

<p>
The following is an example excerpt from an <c>fdisk</c> session. Read and
tailor it to your needs...
</p>

<pre caption="Creating an SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
If your disk already has an existing SGI Disklabel, then fdisk will not allow
the creation of a new label. There are two ways around this. One is to create a
Sun or MS-DOS disklabel, write the changes to disk, and restart fdisk. The
second is to overwrite the partition table with null data via the following
command: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Getting the SGI Volume Header to just the right size</title>
<body>

<p>
Now that an SGI Disklabel is created, partitions may now be defined. In the
above example, there are already two partitions defined for you. These are the
special partitions mentioned above and should not normally be altered. However,
for installing Gentoo, we'll need to load multiple kernel images directly into
the volume header, as there is no supported SGI Bootloader available in Portage
yet. The volume header itself can hold up to <e>eight</e> images of any size, 
with each image allowed eight-character names.
</p>

<p>
The process of making the volume header larger isn't exactly straight-forward --
there's a bit of a trick to it. One cannot simply delete and re-add the volume
header due to odd fdisk behavior. In the example provided below, we'll create a
50MB Volume header in conjunction with a 50MB /boot partition. The actual layout
of your disk may vary, but this is for illustrative purposes only.
</p>

<pre caption="Resizing the SGI Volume Header correctly">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Notice how fdisk only allows Partition #1 to be re-created starting at a minimum of cylinder 5)</comment>
<comment>(Had you attempted to delete &amp; re-create the SGI Volume Header this way, this is the same issue
 you would have encountered.)</comment>
<comment>(In our example, we want /boot to be 50MB, so we start it at cylinder 51 (the Volume Header needs to 
 start at cylinder 0, remember?), and set its ending cylinder to 101, which will roughly be 50MB (+/- 1-5MB))</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Delete Partition #9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Re-Create Partition #9, ending just before Partition #1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Final partition layout</title>
<body>

<p>
Once this is done, you are safe to create the rest of your partitions as you see
fit. After all your partitions are laid out, make sure you set the partition ID
of your swap partition to <c>82</c>, which is Linux Swap. By default, it will be
<c>83</c>, Linux Native. 
</p>

<p>
Now that your partitions are created, you can now continue with <uri
link="#filesystems">Creating Filesystems</uri>, unless you have chosen to use 
LVM in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section id="lvm">
<title>Optional: Using LVM</title>
<subsection>
<title>Initialising the Partitions</title>
<body>

<p>
To use LVM, you first need activate LVM and initialize your created partitions. 
To do so, use <c>vgscan</c> (activate LVM) and <c>pvcreate</c> (initialize 
partitions). In this example, we assume that <path>/dev/hda1</path> is a
regular boot partition, <path>/dev/hda2</path> a regular (but small) root 
partition and <path>/dev/hda3</path> a big partition for the LVM.
</p>

<pre caption="Activating and Initialising LVM partitions">
# <i>vgscan</i>
# <i>pvcreate /dev/hda3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Set up the Volume Group</title>
<body>

<p>
Now we need to setup the volume group. We will use <c>vgcreate</c> to do so, but
<c>vgcreate</c> needs the full (DevFS-style) path to the device file. So we
first find out where these devices files are located:
</p>

<pre caption="Getting to know the full location">
# <i>ls -l /dev/hda3</i>
lr-xr-xr-x    1 root     root           33 Oct 21  2003 /dev/hda3 -&gt; ide/host0/bus0/target0/lun0/part3
</pre>

<p>
Now we create the volume group called "vg":
</p>

<pre caption="Create the VG group">
# <i>vgcreate vg /dev/ide/host0/bus0/target0/lun0/part3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Logical Volumes</title>
<body>

<p>
Now we create the logical volumes. In this example, we create a separate
<path>usr/</path> (10 Gb), <path>home/</path> (5 Gb), <path>opt/</path> (2 Gb),
<path>tmp/</path> (2 Gb), <path>var/</path> (5 Gb) and a swap of 512 Mb.
</p>

<pre caption="Creating the logical volumes">
# <i>lvcreate -L10G -nusr vg</i>
# <i>lvcreate -L5G -nhome vg</i>
# <i>lvcreate -L2G -nopt vg</i>
# <i>lvcreate -L2G -ntmp vg</i>
# <i>lvcreate -L5G -nvar vg</i>
# <i>lvcreate -L512M -nswap vg</i>
</pre>

<p>
As of now, the logical volumes are created and usable as they were regular
partitions:
</p>

<pre caption="Listing the logical volumes">
# <i>ls /dev/vg</i>
home     opt      swap     tmp     usr      var
</pre>

<p>
<e>These</e> files are now your "partitions" (logical volumes).
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Creating Filesystems</title>
<subsection>
<title>Introduction</title>
<body>

<p>
Now that your partitions (and logical volumes if you use LVM) are created, it is
time to place a filesystem on them. If you don't care about what filesystem to
choose and are happy with what we use default in this handbook, continue with 
<uri link="#filesystems-apply">Applying a Filesystem to a Partition</uri>.
Otherwise read on to learn about the available filesystems...
</p>

</body>
</subsection>
<subsection>
<title>Filesystems?</title>
<body>

<p>
Several filesystems are available. Some of them are found stable on all
architectures, others only on a few. The following table lists the available
filesystems and the architectures they are known to work on. If an architecture
is contained within "(...)" then the filesystem should work but is untested.
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Journaled</th>
  <th>Architectures</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>All architectures</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>yes</ti>
  <ti>All architectures</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>yes</ti>
  <ti>x86, hppa, alpha, (mips)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>yes</ti>
  <ti>x86, alpha</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>yes</ti>
  <ti>x86, alpha, (mips)</ti>
</tr>
</table>

<p>
<b>ext2</b> is the tried and true Linux filesystem but doesn't have metadata
journaling, which means that routine ext2 filesystem checks at startup time can
be quite time-consuming. There is now quite a selection of newer-generation
journaled filesystems that can be checked for consistency very quickly and are
thus generally preferred over their non-journaled counterparts. Journaled
filesystems prevent long delays when you boot your system and your filesystem
happens to be in an inconsistent state.
</p>

<p>
<b>ext3</b> is the journaled version of the ext2 filesystem, providing metadata
journaling for fast recovery in addition to other enhanced journaling modes like
full data and ordered data journaling. ext3 is a very good and reliable
filesystem. It offers generally decent performance under most conditions.
Because it does not extensively employ the use of "trees" in its internal
design, it doesn't scale very well, meaning that it is not an ideal choice for
very large filesystems, or situations where you will be handling very large
files or large quantities of files in a single directory. But when used within
its design parameters, ext3 is an excellent filesystem.
</p>

<p>
<b>ReiserFS</b> is a B*-tree based filesystem that has very good overall 
performance and greatly outperforms both ext2 and ext3 when dealing with small 
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales 
extremely well and has metadata journaling. As of kernel 2.4.18+, ReiserFS is 
now rock-solid and highly recommended for use both as a general-purpose 
filesystem and for extreme cases such as the creation of large filesystems, the 
use of many small files, very large files and directories containing tens of 
thousands of files. 
</p>

<p>
<b>XFS</b> is a filesystem with metadata journaling that is fully supported 
under Gentoo Linux's xfs-sources kernel. It comes with a robust feature-set and
is optimized for scalability. We only recommend using this filesystem on Linux
systems with high-end SCSI and/or fibre channel storage and a uninterruptible
power supply. Because XFS aggressively caches in-transit data in RAM, improperly
designed programs (those that don't take proper precautions when writing files
to disk and there are quite a few of them) can lose a good deal of data if the
system goes down unexpectedly.
</p>

<p>
<b>JFS</b> is IBM's high-performance journaling filesystem. It has recently 
become production-ready and there hasn't been a sufficient track record to 
comment positively nor negatively on its general stability at this point.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Applying a Filesystem to a Partition</title>
<body>

<p>
To create a filesystem on a partition or volume, there are tools available for 
each possible filesystem:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Creation Command</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
For instance, to have the boot partition (<path>/dev/hda1</path> in our
example) in ext2 and the root partition (<path>/dev/hda3</path> in our example)
in ext3 (as in our example), you would use:
</p>

<pre caption="Applying a filesystem on a partition">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Now create the filesystems on your newly created partitions (or logical
volumes).
</p>

</body>
</subsection>
<subsection>
<title>Activating the Swap Partition</title>
<body>

<p>
<c>mkswap</c> is the command that is used to initialize swap partitions:
</p>

<pre caption="Creating a Swap signature">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
To activate the swap partition, use <c>swapon</c>:
</p>

<pre caption="Activating the swap partition">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Create and activate the swap now.
</p>

</body>
</subsection>
</section>
<section>
<title>Mounting</title>
<body>

<p>
Now that your partitions are initialized and are housing a filesystem, it is
time to mount those partitions. Use the <c>mount</c> command. Don't forget to
create the necessary mount directories:
</p>

<pre caption="Mounting partitions">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<p>
We also need to mount the proc filesystem (a virtual interface with the kernel)
on <path>/proc</path>. We first create the <path>/mnt/gentoo/proc</path> 
mountpoint:
</p>

<pre caption="Creating the /mnt/gentoo/proc mountpoint">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
If you are installing Gentoo from a LiveCD, you just need to mount
<path>proc</path>:
</p>

<pre caption="Mounting proc">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
If you are not installing Gentoo from a Gentoo LiveCD, you need to
bindmount <path>/proc</path>:
</p>

<pre caption="Bind-mounting proc and dev">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
</pre>

<p>
Now continue with <uri link="?part=1&amp;chap=5">Installing the Gentoo
Installation Files</uri>.
</p>

</body>
</section>
</sections>
