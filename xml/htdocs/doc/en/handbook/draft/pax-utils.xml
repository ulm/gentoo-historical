<?xml version='1.0' encoding="UTF-8"?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/handbook/draft/Attic/pax-utils.xml,v 1.1 2005/06/08 19:09:16 swift Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/pax-utils.xml">
<title>Gentoo Pax Utils</title>

<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="solar@gentoo.org">Ned Ludd</mail>
</author>

<abstract>

</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>0.1</version>
<date>2005-01-01</date>

<chapter>
<title>What is this guide about?</title>
<section>
<title>Introduction</title>
<body>

<p>
The security of a system goes beyond firewalling and good service
configurations. The binaries you run, the libraries you load, might also be
vulnerable against attacks. Although the exact vulnerabilities are not known
until they are discovered, there are ways to prevent them from happening.
</p>

<p>
One possible attack vector is to make advantage of writeable <e>and</e>
executable segments in a program or library, allowing malafide users to run
their own code using the vulnerable application or library.
</p>

<p>
This guide will inform you how to use the <c>pax-utils</c> package to find
and identify problematic binaries. We will also cover the use of <c>pspax</c> (a
tool to view PAX-specific capabilities) and <c>dumpelf</c> (a tool that prints
out a C structure containing a workeable copy of a given object).
</p>

<p>
But before we start with that, some information on <e>objects</e> is in place.
Users familiar with segments and dynamic linking will not learn anything from
this and can immediately continue with <uri link="#scanelf">Extracting ELF
Information from Binaries</uri>.
</p>

</body>
</section>
<section>
<title>ELF objects</title>
<body>

<p>
Every executable binary on your system is structured in a specific way,
allowing the Linux kernel to load and execute the file. Actually, this goes 
beyond plain executable binaries: this also holds for shared objects; more 
about those later.
</p>

<p>
The structure of such a binary is defined in the ELF standard. ELF stands for
<e>Executable and Linkable Format</e>. If you are really interested in the gory
details, check out the <c>elf</c> man page.
</p>

<p>
An executable ELF file has the following parts:
</p>

<ul>
  <li>
    The <e>ELF header</e> contains information on the <e>type</e> of file (is it
    an executable, a shared library, ...), the target architecture, the
    location of the Program Header, Section Header and String Header in the
    file and the location of the first executable instruction
  </li>
  <li>
    The <e>Program Header</e> informs the system how to create a process from
    the binary file. It is actually a table consisting of entries for each
    segment in the program. Each entry contains the type, addresses (fysical and
    virtual), size, ...
  </li>
  <li>
    The <e>Section Header</e> is a table consisting of entries for each section
    in the program. Each entry contains the name, type, size, ... and also
    <e>what</e> information the section holds.
  </li>
  <li>
    Data, containing the sections and segments mentioned previously.
  </li>
</ul>

<p>
A <e>section</e> is a small unit consisting of specific data: instructions,
variable data, symbol table, relocation information, and so on. A <e>segment</e>
is a collection of sections; segments are the units that are actually
transferred to memory.
</p>

</body>
</section>
<section>
<title>Shared Objects</title>
<body>

<p>
Originally, every application binary contained <e>everything</e> it needed to
operate correctly. Such binaries are called <e>statically linked</e> binaries.
They are however space consuming since many applications use the same functions
over and over again. 
</p>

<p>
A <e>shared object</e> contains the definition and instructions for such
functions. Every application that wants can <e>dynamically</e> link against such
a shared object so that it can benefit from the already existing functionality.
</p>

<p>
An application that is dynamically linked to a shared object contains
<e>symbols</e>, substitutes for the real functionality. When such an application
is loaded in memory, it will first ask the runtime linker to resolve each and
every symbol it has. The runtime linker will load the appropriate shared objects
in memory and return their location to the application.
</p>

</body>
</section>
<section>
<title>Segments</title>
<body>

<p>
An application (or shared object) has several predefined segments. Summing them
all up is beyond the scope of this document, but a few do need to be mentioned
as they are used further in this guide:
</p>

<ul>
  <li>The <c>text</c> segment contains executable code</li>
  <li>The <c>data</c> segment contains program data</li>
  <li>
    The <c>dynamic</c> segment contains information relevant to dynamic
    linking
  </li>
</ul>

</body>
</section>
</chapter>

<chapter id="scanelf">
<title>Extracting ELF Information from Binaries</title>
<section>
<title>The scanelf Application</title>
<body>

<p>
The <c>scanelf</c> application is part of the <c>app-misc/pax-utils</c> package.
With this application you can print out information specific to the ELF
structure of a binary. The following table sums up the various options.
</p>

<table>
<tr>
  <th>Option</th>
  <th>Long Option</th>
  <th>Description</th>
</tr>
<tr>
  <ti>-p</ti>
  <ti>--path</ti>
  <ti>Scan all directories in the PATH environment</ti>
</tr>
<tr>
  <ti>-l</ti>
  <ti>--ldpath</ti>
  <ti>Scan all directories mentioned in <path>/etc/ld.so.conf</path></ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>--recursive</ti>
  <ti>Scan directories recursively</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>--mount</ti>
  <ti>Stay within the same mount (do not jump to other file systems)</ti>
</tr>
<tr>
  <ti>-y</ti>
  <ti>--symlink</ti>
  <ti>Ignore symbolic links</ti>
</tr>
<tr>
  <th>Option</th>
  <th>Long Option</th>
  <th>Description</th>
</tr>
<tr>
  <ti>-x</ti>
  <ti>--pax</ti>
  <ti>Print PaX markings</ti>
</tr>
<tr>
  <ti>-e</ti>
  <ti>--header</ti>
  <ti>Print GNU_STACK / PT_LOAD markings</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>--textrel</ti>
  <ti>Print TEXTREL information</ti>
</tr>
<tr>
  <ti>-r</ti>
  <ti>--rpath</ti>
  <ti>Print RPATH information</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>--needed</ti>
  <ti>Print NEEDED information</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>--interp</ti>
  <ti>Print INTERP information</ti>
</tr>
<tr>
  <ti>-b</ti>
  <ti>--bind</ti>
  <ti>Print BIND information</ti>
</tr>
<tr>
  <ti>-s [arg]</ti>
  <ti>--symbol [arg]</ti>
  <ti>Find a specific symbol</ti>
</tr>
<tr>
  <ti>-N [arg]</ti>
  <ti>--lib [arg]</ti>
  <ti>Find a specific library</ti>
</tr>
<tr>
  <ti>-a</ti>
  <ti>--all</ti>
  <ti>Print all scanned info (-xetrnib)</ti>
</tr>
<tr>
  <th>Option</th>
  <th>Long Option</th>
  <th>Description</th>
</tr>
<tr>
  <ti>-q</ti>
  <ti>--quiet</ti>
  <ti>Only output 'bad' things</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>--verbose</ti>
  <ti>Be verbose (can be specified multiple times)</ti>
</tr>
<tr>
  <ti>-F [arg]</ti>
  <ti>--format [arg]</ti>
  <ti>Use specified format for output</ti>
</tr>
<tr>
  <ti>-f [arg]</ti>
  <ti>--from [arg]</ti>
  <ti>Read input from a given file name instead of stdin</ti>
</tr>
<tr>
  <ti>-o [arg]</ti>
  <ti>--file [arg]</ti>
  <ti>Write output to a given file instead of stdout</ti>
</tr>
<tr>
  <ti>-B</ti>
  <ti>--nobanner</ti>
  <ti>Do not display the header</ti>
</tr>
<tr>
  <ti>-h</ti>
  <ti>--help</ti>
  <ti>Print the program help and exit</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>--version</ti>
  <ti>Print the program version and exit</ti>
</tr>
</table>

<p>
The format specifiers for the <c>-F</c> option are fiven in the following table.
Prefix each specifier with <c>%</c> (verbose) or <c>#</c> (silent) accordingly.
</p>

<table>
<tr>
  <th>Specifier</th>
  <th>Full Name</th>
  <th>Specifier</th>
  <th>Full Name</th>
</tr>
<tr>
  <ti>F</ti>
  <ti>Filename</ti>
  <ti>x</ti>
  <ti>PaX Flags</ti>
</tr>
<tr>
  <ti>e</ti>
  <ti>STACK/RELRO</ti>
  <ti>t</ti>
  <ti>TEXTREL</ti>
</tr>
<tr>
  <ti>r</ti>
  <ti>RPATH</ti>
  <ti>n</ti>
  <ti>NEEDED</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>INTERP</ti>
  <ti>b</ti>
  <ti>BIND</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>Symbol</ti>
  <ti>N</ti>
  <ti>Library</ti>
</tr>
<tr>
  <ti>o</ti>
  <ti>Type</ti>
  <ti>p</ti>
  <ti>File name</ti>
</tr>
<tr>
  <ti>f</ti>
  <ti>Base file name</ti>
  <ti></ti>
  <ti></ti>
</tr>
</table>

</body>
</section>
<section>
<title>Using scanelf for Text Relocations</title>
<body>

<p>
As an example, we will use <c>scanelf</c> to find binaries containing text
relocations.
</p>

<p>
A relocation is an operation that rewrites an address in a loaded segment. Such
an address rewrite can happen when a segment has references to a shared object
and that shared object is loaded in memory. In this case, the references are
substituted with the real address values. Similar events can occur inside the 
shared object itself.
</p>

<p>
A text relocation is a relocation in the text segment. Since text segments
contain executable code, system administrators might prefer not to have these
segments writeable. This is perfectly possible, but since text relocations
actually write in the text segment, it is not always feasible. 
</p>

<p>
If you do not want text relocations to be possible, you will need to make sure
that the application and shared object is built with <e>Position Independent
Code</e> (PIC), making references obsolete. This not only increases security,
but also increases the performance in case of shared objects (allowing writes in
the text segment requires a swap space reservation and a private copy of the
shared object for each application that uses it).
</p>

<p>
The following example will search your library paths recursively, without
leaving the mounted file system and ignoring symbolic links, for any ELF binary
containing a text relocation:
</p>

<pre caption="Scanning the system for text relocation binaries">
# <i>scanelf -lqtmyR</i>
</pre>

<p>
If you want to scan your entire system for <e>any</e> file containing text
relocations:
</p>

<pre caption="Scanning the entire system for text relocation files">
# <i>scanelf -tqRmy</i>
</pre>

</body>
</section>
<section>
<title>Using scanelf for Specific Segment Markings</title>
<body>

<p>
Each segment has specific flags assigned to it in the Program Header of the
binary. One of those flags is the type of the segment. Interesting values are
PT_LOAD (the segment must be loaded in memory from file), PT_DYNAMIC (the
segment contains dynamic linking information), PT_INTERP (the segment 
contains the name of the program interpreter) and PT_GNU_STACK (a GNU extension
for the ELF format, used by some stack protection mechanisms).
</p>

<p>
If we want to scan all executables in the current working directory, PATH
environment and library paths and report those who have a writeable and
executable PT_LOAD or PT_GNU_STACK marking, you could use the following command:
</p>

<pre caption="Scanning for Write/eXecute flags for PT_LOAD and PT_GNU_STACK">
# <i>scanelf -lpqe .</i>
</pre>

</body>
</section>
<section>
<title>Using scanelf's Format Modifier Handler</title>
<body>

<p>
A very useful feature of the <c>scanelf</c> utility is the format modifier
handler. With this option you can control the output of <c>scanelf</c> making it
useful for scripting purposes.
</p>

<p>
As an example, we will use <c>scanelf</c> to print the file names that contain
text relocations:
</p>

<pre caption="Example of the scanelf format modifier handler">
# <i>scanelf -l -p -R -q -F "%F #t"</i>
</pre>

</body>
</section>
</chapter>

</guide>
