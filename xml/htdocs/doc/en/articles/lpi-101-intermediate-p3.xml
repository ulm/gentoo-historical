<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/articles/lpi-101-intermediate-p3.xml,v 1.4 2011/09/04 17:53:41 swift Exp $ -->

<guide disclaimer="articles">
<title>LPI certification 101 (release 2) exam prep, Part 3</title>

<author title="Author">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Author">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Author">
  <mail link="agriffis@gentoo.org">Aron Griffis</mail>
</author>

<abstract>
In this tutorial we'll introduce you the Linux system documentation. We will
teach you how to change permissions and how to manage with Linux accounts. At
the end you'll learn how to tune your enviroment.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This
document is an updated version of the original article, and contains
various improvements made by the Gentoo Linux Documentation team -->

<version>1.1</version>
<date>2007-06-20</date>

<chapter>
<title>Before You Start</title>
<section>
<title>About this tutorial</title>
<body>

<p>
Welcome to "Intermediate administration," the third of four tutorials designed
to prepare you for the Linux Professional Institute's 101 (release 2) exam.
This tutorial (Part 3) is ideal for those who want to improve their knowledge
of fundamental Linux administration skills. We'll cover a variety of topics,
including system and Internet documentation, the Linux permissions model, user
account management, and login environment tuning.
</p>

<p>
If you are new to Linux, we recommend that you start with <uri
link="/doc/en/articles/lpi-101-fundamentals-p1.xml">Part 1</uri> and <uri
link="/doc/en/articles/lpi-101-administration-p2.xml">Part 2</uri>. For some,
much of this material will be new, but more experienced Linux users may
find this tutorial to be a great way of "rounding out" their foundational Linux
system administration skills.
</p>
        
<p>
By the end of this series of tutorials (eight in all covering the LPI 101 and
102 exams), you will have the knowledge you need to become a Linux Systems
Administrator and will be ready to attain an LPIC Level 1 certification from
the Linux Professional Institute if you so choose.
</p>

<p>
For those who have taken the <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxlpi3-i.html">release
1 version</uri> of this tutorial for reasons other than LPI exam preparation,
you probably don't need to take this one. However, if you do plan to take the
exams, you should strongly consider reading this revised tutorial.
</p>

</body>
</section>
<section>
<title>About the authors</title>
<body>

<p>
For technical questions about the content of this tutorial, contact the
authors:
</p>

<ul>
  <li>Daniel Robbins, at <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, at <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, at<mail>agriffis@gentoo.org</mail>.</li>
</ul>

<p>
Residing in Albuquerque, New Mexico, Daniel Robbins is the Chief Architect of
<uri link="http://www.gentoo.org/">Gentoo Linux</uri> an advanced ports-based
Linux metadistribution. Besides writing articles, tutorials, and tips for the
developerWorks Linux zone and Intel Developer Services, he has also served as a
contributing author for several books, including Samba Unleashed and SuSE Linux
Unleashed. Daniel enjoys spending time with his wife, Mary, and his daughter,
Hadassah. You can contact Daniel at <mail>drobbins@gentoo.org</mail>.
</p>

<p>
Chris Houser, known to his friends as "Chouser," has been a UNIX proponent
since 1994 when he joined the administration team for the computer science
network at Taylor University in Indiana, where he earned his Bachelor's degree
in Computer Science and Mathematics. Since then, he has gone on to work in Web
application programming, user interface design, professional video software
support, and now Tru64 UNIX device driver programming at <uri
link="http://www.compaq.com/">Compaq</uri>. He has also contributed to various
free software projects, most recently to <uri
link="http://www.gentoo.org/">Gentoo Linux</uri>).  He lives with his wife and
two cats in New Hampshire. You can contact Chris at
<mail>chouser@gentoo.org</mail>.
</p>

<p>
Aron Griffis graduated from Taylor University with a degree in Computer Science
and an award that proclaimed, "Future Founder of a Utopian UNIX Commune."
Working towards that goal, Aron is employed by <uri
link="http://www.compaq.com/">Compaq</uri> writing network drivers for Tru64
UNIX, and spending his spare time plunking out tunes on the piano or developing
<uri link="http://www.gentoo.org/">Gentoo Linux</uri>. He lives with his wife
Amy (also a UNIX engineer) in Nashua, New Hampshire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>System and network documentation</title>
<section>
<title>Types of Linux system documentation</title>
<body>

<p>
There are essentially three sources of documentation on a Linux system: manual
pages, info pages, and application-bundled documentation in
<path>/usr/share/doc</path>. In this section, we'll explore each of these
sources before looking "outside the box" for more information.
</p>

</body>
</section>
<section>
<title>Manual pages</title>
<body>

<p>
Manual pages, or "man pages", are the classic form of UNIX and Linux reference
documentation. Ideally, you can look up the man page for any command,
configuration file, or library routine. In practice, Linux is free software,
and some pages haven't been written or are showing their age. Nonetheless, man
pages are the first place to look when you need help.
</p>

<p>
To access a man page, simply type <c>man</c> followed by your topic of inquiry.
A pager will be started, so you will need to press <c>q</c> when you're done
reading. For example, to look up information about the <c>ls</c> command, you
would type:
</p>

<pre caption="Searching in man page">
$ <i>man ls</i>
</pre>

<p>
Knowing the layout of a man page can be helpful to jump quickly to the
information you need. In general, you will find the following sections in a
<c>man</c> page:
</p>

<table>
<tr>
  <ti>NAME</ti>
  <ti>Name and one-line description of the command</ti>
</tr>
<tr>
  <ti>SYNOPSIS</ti>
  <ti>How to use the command</ti>
</tr>
<tr>
  <ti>DESCRIPTION</ti>
  <ti>In-depth discussion on the functionality of the command</ti>
</tr>
<tr>
  <ti>EXAMPLES</ti>
  <ti>Suggestions for how to use the command</ti>
</tr>
<tr>
  <ti>SEE ALSO</ti>
  <ti>Related topics (usually man pages)</ti>
</tr>
</table>

</body>
</section>
<section>
<title>man page sections</title>
<body>

<p>
The files that comprise manual pages are stored in <path>/usr/share/man</path>
(or in <path>/usr/man</path> on some older systems). Inside that directory, you
will find that the manual pages are organized into the following sections:
</p>

<table>
<tr>
  <ti>man1</ti>
  <ti>User programs</ti>
</tr>
<tr>
  <ti>man2</ti>
  <ti>System calls</ti>
</tr>
<tr>
  <ti>man3</ti>
  <ti>Library functions</ti>
</tr>
<tr>
  <ti>man4</ti>
  <ti>Special files</ti>
</tr>
<tr>
  <ti>man5</ti>
  <ti>File formats</ti>
</tr>
<tr>
  <ti>man6</ti>
  <ti>Games</ti>
</tr>
<tr>
  <ti>man7</ti>
  <ti>Miscellaneous</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Multiple man pages</title>
<body>

<p>
Some topics exist in more than one section. To demonstrate this, let's use the
<c>whatis</c> command, which shows all the available man pages for a topic:
</p>

<pre caption="Using whatis command">
$ <i>whatis printf</i>
printf               (1)  - format and print data
printf               (3)  - formatted output conversion
</pre>

<p>
In this case, <c>man printf</c> would default to the page in section 1 ("User
Programs"). If we were writing a C program, we might be more interested in the
page from section 3 ("Library functions"). You can call up a man page from a
certain section by specifying it on the command line, so to ask for
<e>printf(3)</e>, we would type:
</p>

<pre caption="Specifying section in man command">
$ <i>man 3 printf</i>
</pre>

</body>
</section>
<section>
<title>Finding the right man page</title>
<body>

<p>
Sometimes it's hard to find the right man page for a given topic. In that case,
you might try using <c>man -k</c> to search the NAME section of the man pages.
Be warned that it's a substring search, so running something like <c>man -k
ls</c> will give you a lot of output! Here's an example using a more specific
query:
</p>

<pre caption="Searching man using man -k command">
$ <i>man -k whatis</i>
apropos              (1)  - search the whatis database for strings
makewhatis           (8)  - Create the whatis database
whatis               (1)  - search the whatis database for complete words
</pre>

</body>
</section>
<section>
<title>All about apropos</title>
<body>

<p>
The example on the previous panel brings up a few more points. First, the
<c>apropos</c> command is exactly equivalent to <c>man -k</c>. (In fact, I'll
let you in on a little secret. When you run <c>man -k</c>, it actually runs
<c>apropos</c> behind the scenes.) The second point is the <c>makewhatis</c>
command, which scans all the man pages on your Linux system and builds the
database for <c>whatis</c> and <c>apropos</c>. Usually this is run periodically
by root to keep the database updated:
</p>

<pre caption="Building whatis and apropos database">
# <i>makewhatis</i>
</pre>

<p>
For more information on "man" and friends, you should start with its man page:
</p>

<pre caption="Starting man page for man">
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>The MANPATH</title>
<body>

<p>
By default, the <c>man</c> program will look for man pages in
<path>/usr/share/man</path>, <path>/usr/local/man</path>,
<path>/usr/X11R6/man</path>, and possibly <path>/opt/man</path>. Sometimes, you
may find that you need to add an additional item to this search path. If so,
simply edit <path>/etc/man.conf</path> in a text editor and add a line that
looks like this:
</p>

<pre caption="/etc/man.conf">
MANPATH /opt/man
</pre>

<p>
From that point forward, any man pages in the <path>/opt/man/man*</path>
directories will be found. Remember that you'll need to rerun <c>makewhatis</c>
to add these new man pages to the whatis database.
</p>

</body>
</section>
<section>
<title>GNU info</title>
<body>

<p>
One shortcoming of man pages is that they don't support hypertext, so you can't
jump easily from one to another. The GNU folks recognized this shortcoming, so
they invented another documentation format: "info" pages. Many of the GNU
programs come with extensive documentation in the form of info pages. You can
start reading info pages with the <c>info</c> command:
</p>

<pre caption="Using info command">
$ <i>info</i>
</pre>

<p>
Calling <c>info</c> in this way will bring up an index of the available pages
on the system. You can move around with the arrow keys, follow links (indicated
with a star) using the Enter key, and quit by pressing <c>q</c>. The keys are
based on Emacs, so you should be able to navigate easily if you're familiar
with that editor. For an intro to the Emacs editor, see the developerWorks
tutorial, <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">Living
in Emacs</uri>.
</p>

<p>
You can also specify an info page on the command line:
</p>

<pre caption="Specifying info command">
$ <i>info diff</i>
</pre>

<p>
For more information on using the <c>info</c> reader, try reading its info
page. You should be able to navigate primitively using the few keys I've
already mentioned:
</p>

<pre caption="Reading info info page">
$ <i>info info</i>
</pre>

</body>
</section>
<section>
<title>/usr/share/doc</title>
<body>

<p>
There is a final source for help within your Linux system. Many programs are
shipped with additional documentation in other formats: text, PDF, PostScript,
HTML, to name a few. Take a look in <path>usr/share/doc</path> (or
<path>/usr/doc</path> on older systems). You'll find a long list of
directories, each of which came with a certain application on your system.
Searching through this documentation can often reveal some gems that aren't
available as man pages or info pages, such as tutorials or additional technical
documentation. A quick check reveals there's a lot of reading material
available:
</p>

<pre caption="/usr/share/doc/">
$ <i>cd /usr/share/doc</i>
$ <i>find . -type f | wc -l</i>
7582
</pre>

<p>
Whew! Your homework this evening is to read just half (3791) of those
documents. Expect a quiz tomorrow. ;-)
</p>

</body>
</section>
<section>
<title>The Linux Documentation Project</title>
<body>

<p>
In addition to system documentation, there are a number of excellent Linux
resources on the Internet. The <uri link="http://www.tldp.org/">Linux
Documentation Project</uri> is a group of volunteers who are working on putting
together the complete set of free Linux documentation. This project exists to
consolidate various pieces of Linux documentation into a location that is easy
to search and use.
</p>

</body>
</section>
<section>
<title>An LDP overview</title>
<body>

<p>
The LDP is made up of the following areas:
</p>

<ul>
  <li>
    Guides - longer, more in-depth books, such as <uri
    link="http://www.tldp.org/LDP/lpg/index.html">The Linux Programmer's
    Guide</uri>
  </li>
  <li>
    HOWTOs - subject-specific help, such as the <uri
    link="http://www.tldp.org/HOWTO/DSL-HOWTO/index.html">DSL HOWTO</uri>
  </li>
  <li>
    FAQs - Frequently Asked Questions with answers, such as the <uri
    link="http://www.tldp.org/FAQ/faqs/BLFAQ">Brief Linux FAQ</uri>
  </li>
  <li>
    Man pages - help on individual commands (these are the same manual pages
    you get on your Linux system when you use the <c>man</c> command).
  </li>
</ul>

<p>
If you aren't sure which section to peruse, you can take advantage of the
search box, which allows you to find things by topic.
</p>

<p>
The LDP additionally provides a list of Links and Resources such as <uri
link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri> (see links in
<uri link="#resources">Resources</uri>) and <uri
link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>, as well
links to mailing lists and news archives.
</p>

</body>
</section>
<section>
<title>Mailing lists</title>
<body>

<p>
Mailing lists provide probably the most important point of collaboration for
Linux developers. Often projects are developed by contributors who live far
apart, possibly even on opposite sides of the globe. Mailing lists provide a
method for each developer on a project to contact all the others, and to hold
group discussions via e-mail. One of the most famous development mailing lists
is the <uri link="http://www.tux.org/lkml/">Linux Kernel Mailing List</uri>.
</p>

</body>
</section>
<section>
<title>More about mailing lists</title>
<body>

<p>
In addition to development, mailing lists can provide a method for asking
questions and receiving answers from knowledgeable developers, or even other
users. For example, individual distributions often provide mailing lists for
newcomers. You can check your distribution's Web site for information on the
mailing lists it provides.
</p>

<p>
If you took the time to read the LKML FAQ at the link on the previous panel,
you might have noticed that mailing list subscribers often don't take kindly to
questions being asked repeatedly. It's always wise to search the archives for a
given mailing list before writing your question. Chances are, it will save you
time, too!
</p>

</body>
</section>
<section>
<title>Newsgroups</title>
<body>

<p>
Internet "newsgroups" are similar to mailing lists, but are based on a protocol
called NNTP ("Network News Transfer Protocol") instead of e-mail. To
participate, you need to use an NNTP client such as <c>slrn</c> or <c>pan</c>.
The primary advantage is that you only take part in the discussion when you
want, instead of having it continually arrive in your inbox. :-)
</p>

<p>
The newsgroups of primary interest start with comp.os.linux. You can browse the
<uri link="http://www.tldp.org/links/#ng">list on the LDP site</uri>.
</p>

<p>
As with mailing lists, newsgroup discussion is often archived. A popular
newsgroup archiving site is <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

</body>
</section>
<section>
<title>Vendor and third-party Web sites</title>
<body>

<p>
Web sites for the various Linux distributions often provide updated
documentation, installation instructions, hardware
compatibility/incompatibility statements, and other support such as a knowledge
base search tool. For example:
</p>

<ul>
  <li><uri link="http://www.redhat.com/">Redhat Linux</uri></li>
  <li><uri link="http://www.debian.org/">Debian Linux</uri></li>
  <li><uri link="http://www.gentoo.org/">Gentoo Linux</uri></li>
  <li><uri link="http://www.suse.com/">SuSE Linux</uri></li>
  <li><uri link="http://www.caldera.com/">Caldera</uri></li>
  <li><uri link="http://www.turbolinux.com/">Turbolinux</uri></li>
</ul>

</body>
</section>
<section>
<title>Hardware and software vendors</title>
<body>

<p>
Many hardware and software vendors have added Linux support to their products
in recent years. At their sites, you can find information about which hardware
supports Linux, software development tools, released sources, downloads of
Linux drivers for specific hardware, and other special Linux projects. For
example:
</p>

<ul>
  <li><uri link="http://www.ibm.com/linux/">IBM and Linux</uri></li>
  <li>
    <uri link="http://www.compaq.com/products/software/linux/">Compaq and
    Linux</uri>
  </li>
  <li>
    <uri link="http://www.sgi.com/developers/technology/linux/">SGI and
    Linux</uri>
  </li>
  <li><uri link="http://www.hp.com/products1/linux/">HP and Linux</uri></li>
  <li><uri link="http://www.sun.com/linux/">Sun and Linux</uri></li>
  <li>
    <uri link="http://technet.oracle.com/tech/linux/content.html">Oracle and
    Linux</uri>.
  </li>
</ul>

</body>
</section>
<section>
<title>Developer resources</title>
<body>

<p>
In addition, many hardware and software vendors have developed wonderful
resources for Linux developers and administrators. At the risk of sounding
self-promoting, one of the most valuable Linux resources run by a
hardware/software vendor is the <uri
link="http://www.ibm.com/developerworks/linux/">IBM developerWorks Linux
zone</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>The Linux permissions model</title>
<section>
<title>One user, one group</title>
<body>

<p>
In this section, we'll take a look at the Linux permissions and ownership
model. We've already seen that every file is owned by one user and one group.
This is the very core of the permissions model in Linux. You can view the user
and group of a file in a <c>ls -l</c> listing:
</p>

<pre caption="Listing files">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
In this particular example, the <path>/bin/bash</path> executable is owned by
root and is in the wheel group. The Linux permissions model works by allowing
three independent levels of permission to be set for each filesystem object --
those for the file's owner, the file's group, and all other users.
</p>

</body>
</section>
<section>
<title>Understanding "ls -l"</title>
<body>

<p>
Let's take a look at our <c>ls -l</c> output and inspect the first column of
the listing:
</p>

<pre caption="Inspecting ls -l command">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
This first field <e>-rwxr-xr-</e> contains a symbolic representation of this
particular files' permissions. The first character (-) in this field specifies
the type of this file, which in this case is a regular file. Other possible
first characters:
</p>

<pre caption="First characters">
'd' directory
'l' symbolic link
'c' character special device 
'b' block special device
'p' fifo
's' socket
</pre>

</body>
</section>
<section>
<title>Three triplets</title>
<body>

<pre caption="ls -l /bin/bash">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
The rest of the field consists of three character triplets. The first triplet
represents permissions for the owner of the file, the second represents
permissions for the file's group, and the third represents permissions for all
other users:
</p>

<pre caption="Triplets in ls -l command">
"rwx"
"r-x"
"r-x"
</pre>

<p>
Above, the r means that reading (looking at the data in the file) is allowed,
the w means that writing (modifying the file, as well as deletion) is allowed,
and the x means that "execute" (running the program) is allowed. Putting
together all this information, we can see that everyone is able to read the
contents of and execute this file, but only the owner (root) is allowed to
modify this file in any way. So, while normal users can copy this file, only
root is allowed to update it or delete it.
</p>

</body>
</section>
<section>
<title>Who am I?</title>
<body>

<p>
Before we take a look at how to change the user and group ownership of a file,
let's first take a look at how to learn your current user id and group
membership. Unless you've used the <c>su</c> command recently, your current
user id is the one you used to log in to the system. If you use <c>su</c>
frequently, however, you may not remember your current effective user id. To
view it, type <c>whoami</c>:
</p>

<pre caption="Using whoami command">
# <i>whoami</i>
root
# <i>su drobbins</i>
$ <i>whoami</i>
drobbins
</pre>

</body>
</section>
<section>
<title>What groups am I in?</title>
<body>

<p>
To see what groups you belong to, use the <c>groups</c> command:
</p>

<pre caption="Using groups command">
$ <i>groups</i>
drobbins wheel audio
</pre>

<p>
In the above example, I'm a member of the drobbins, wheel, and audio groups.
If you want to see what groups other user(s) are in, specify their usernames as
arguments:
</p>

<pre caption="Specifying user argument">
$ <i>groups root daemon</i>
root : root bin daemon sys adm disk wheel floppy dialout tape video
daemon : daemon bin adm
</pre>

</body>
</section>
<section>
<title>Changing user and group ownership</title>
<body>

<p>
To change the owner or group of a file or other filesystem object, use
<c>chown</c> or <c>chgrp</c>, respectively. Each of these commands takes a name
followed by one or more filenames.
</p>

<pre caption="Using chown and chgrp commands">
# <i>chown root /etc/passwd</i>
# <i>chgrp wheel /etc/passwd</i>
</pre>

<p>
You can also set the owner and group simultaneously with an alternate form of
the <c>chown</c> command:
</p>

<pre caption="Setting owner and group simultaneously">
# <i>chown root:wheel /etc/passwd</i>
</pre>

<p>
You may not use <c>chown</c> unless you are the superuser, but <c>chgrp</c> can
be used by anyone to change the group ownership of a file to a group to which
they belong.
</p>

</body>
</section>
<section>
<title>Recursive ownership changes</title>
<body>

<p>
Both <c>chown</c> and <c>chgrp</c> have a -R option that can be used to tell
them to recursively apply ownership and group changes to an entire directory
tree. For example:
</p>

<pre caption="Using chown and chgrp with -R option">
# <i>chown -R drobbins /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Introducing chmod</title>
<body>

<p>
<c>chown</c> and <c>chgrp</c> can be used to change the owner and group of a
filesystem object, but another program -- called <c>chmod</c> -- is used to
change the rwx permissions that we can see in an <c>ls -l</c> listing.
<c>chmod</c> takes two or more arguments: a "mode", describing how the
permissions should be changed, followed by a file or list of files that should
be affected:
</p>

<pre caption="Adding x permission with chmod">
$ <i>chmod +x scriptfile.sh</i>
</pre>

<p>
In the above example, our "mode" is +x. As you might guess, a +x mode tells
<c>chmod</c> to make this particular file executable for both the user and
group and for anyone else.
</p>

<p>
If we wanted to remove all execute permissions of a file, we'd do this:
</p>

<pre caption="Removing x permission with chmod">
$ <i>chmod -x scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>User/group/other granularity</title>
<body>

<p>
So far, our <c>chmod</c> examples have affected permissions for all three
triplets -- the user, the group, and all others. Often, it's handy to modify
only one or two triplets at a time. To do this, simply specify the symbolic
character for the particular triplets you'd like to modify before the + or -
sign. Use u for the "user" triplet, g for the "group" triplet, and o for the
"other/everyone" triplet:
</p>

<pre caption="Using triplets">
$ <i>chmod go-w scriptfile.sh</i>
</pre>

<p>
We just removed write permissions for the group and all other users, but left
"owner" permissions untouched.
</p>

</body>
</section>
<section>
<title>Resetting permissions</title>
<body>

<p>
In addition to flipping permission bits on and off, we can also reset them
altogether. By using the = operator, we can tell <c>chmod</c> that we want the
specified permissions and no others:
</p>

<pre caption="Flipping permission bits">
$ <i>chmod =rx scriptfile.sh</i>
</pre>

<p>
Above, we just set all "read" and "execute" bits, and unset all "write" bits.
If you just want to reset a particular triplet, you can specify the symbolic
name for the triplet before the = as follows:
</p>

<pre caption="Reseting triplet">
$ <i>chmod u=rx scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>Numeric modes</title>
<body>

<p>
Up until now, we've used what are called symbolic modes to specify permission
changes to <c>chmod</c>. However, there's another common way of specifying
permissions: using a 4-digit octal number. Using this syntax, called numeric
permissions syntax, each digit represents a permissions triplet. For example,
in 1777, the 777 sets the "owner", "group", and "other" flags that we've been
discussing in this section. The 1 is used to set the special permissions bits,
which we'll cover later (see "<uri
link="https://www6.software.ibm.com/developerworks/education/l-lpir23/l-lpir23-3-23.html">The
elusive first digit</uri>" at the end of this section). This chart shows how
the second through fourth digits (777) are interpreted:
</p>

<table>
<tr>
  <th>Mode</th>
  <th>Digit</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Numeric permission syntax</title>
<body>

<p> 
Numeric permission syntax is especially useful when you need to specify all
permissions for a file, such as in the following example:
</p>

<pre caption="Adding numeric permission">
$ <i>chmod 0755 scriptfile.sh</i>
$ <i>ls -l scriptfile.sh</i>
-rwxr-xr-x    1 drobbins drobbins        0 Jan  9 17:44 scriptfile.sh
</pre>

<p>
In this example, we used a mode of 0755, which expands to a complete
permissions setting of -rwxr-xr-x.
</p>

</body>
</section>
<section>
<title>The umask</title>
<body>

<p>
When a process creates a new file, it specifies the permissions that it would
like the new file to have. Often, the mode requested is 0666 (readable and
writable by everyone), which is more permissive that we would like.
Fortunately, Linux consults something called a "umask" whenever a new file is
created. The system uses the umask value to reduce the originally specified
permissions to something more reasonable and secure. You can view your current
umask setting by typing umask at the command line:
</p>

<pre caption="Viewing current umask">
$ <i>umask</i>
0022
</pre>

<p>
On Linux systems, the umask normally defaults to 0022, which allows others to
read your new files (if they can get to them) but not modify them.
</p>

<p>
To make new files more secure by default, you can change the umask setting:
</p>

<pre caption="Changing umask setting">
$ <i>umask 0077</i>
</pre>

<p>
This umask will make sure that the group and others will have absolutely no
permissions for any newly created files. So, how does the umask work? Unlike
"regular" permissions on files, the umask specifies which permissions should be
turned off. Let's consult our mode-to-digit mapping table so that we can
understand what a umask of 0077 means:
</p>

<table>
<tr>
  <th>Mode</th>
  <th>Digit</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

<p>
Using our table, the last three digits of 0077 expand to ---rwxrwx. Now,
remember that the <c>umask</c> tells the system which permissions to disable.
Putting two and two together, we can see that all "group" and "other"
permissions will be turned off, while "user" permissions will remain untouched.
</p>

</body>
</section>
<section>
<title>Introducing suid and sgid</title>
<body>

<p>
When you initially log in, a new shell process is started. You already know
that, but you may not know that this new shell process (typically bash) runs
using your user id. As such, the bash program can access all files and
directories that you own. In fact, we as users are totally dependent on other
programs to perform operations on our behalf. Because the programs you start
inherit your user id, they cannot access any filesystem objects for which you
haven't been granted access.
</p>

<p>
For example, the passwd file cannot be changed by normal users directly,
because the "write" flag is off for every user except root:
</p>

<pre caption="ls -l /etc/passwd">
$ <i>ls -l /etc/passwd</i>
-rw-r--r--    1 root     wheel        1355 Nov  1 21:16 /etc/passwd
</pre>

<p>
However, normal users do need to be able to modify /etc/passwd (at least
indirectly) whenever they need to change their password. But, if the user is
unable to modify this file, how exactly does this work?
</p>

</body>
</section>
<section>
<title>suid</title>
<body>

<p>
Thankfully, the Linux permissions model has two special bits called <c>suid</c>
and <c>sgid</c>. When an executable program has the <c>suid</c> bit set, it
will run on behalf of the owner of the executable, rather than on behalf of the
person who started the program.
</p>

<p>
Now, back to the <path>/etc/passwd</path> problem. If we take a look at the
<c>passwd</c> executable, we can see that it's owned by root:
</p>

<pre caption="Checking owner of /usr/bin/passwd file">
$ <i>ls -l /usr/bin/passwd</i>
-rwsr-xr-x    1 root     wheel       17588 Sep 24 00:53 /usr/bin/passwd
</pre>

<p>
You'll also note that in place of an x in the user's permission triplet,
there's an s. This indicates that, for this particular program, the <c>suid</c>
and executable bits are set. Because of this, when <c>passwd</c> runs, it will
execute on behalf of the root user (with full superuser access) rather than
that of the user who ran it. And because <c>passwd</c> runs with root access,
it's able to modify the <path>/etc/passwd</path> file with no problem.
</p>

</body>
</section>
<section>
<title>suid/sgid caveats</title>
<body>

<p>
We've seen how <c>suid</c> works, and <c>sgid</c> works in a similar way. It
allows programs to inherit the group ownership of the program rather than that
of the current user.
</p>

<impo>
Here's some miscellaneous yet important information about <c>suid</c> and
<c>sgid</c>. First, <c>suid</c> and <c>sgid</c> bits occupy the same space as
the x bits in a ls -l listing. If the x bit is also set, the respective bits
will show up as s (lowercase). However, if the x bit is not set, it will show
up as a S (uppercase).
</impo>

<impo>
Another important note: suid and sgid come in handy in many circumstances, but
improper use of these bits can allow the security of a system to be breached.
It's best to have as few suid programs as possible. The passwd command is one
of the few that must be suid.
</impo>

</body>
</section>
<section>
<title>Changing suid and sgid</title>
<body>

<p>
Setting and removing the <c>suid</c> and <c>sgid</c> bits is fairly
straightforward. Here, we set the suid bit:
</p>

<pre caption="Setting suid bit">
# <i>chmod u+s /usr/bin/myapp</i>
</pre>

<p>
And here, we remove the <c>sgid</c> bit from a directory. We'll see how the
<c>sgid</c> bit affects directories in just a few panels:
</p>

<pre caption="Removing sgid bit">
# <i>chmod g-s /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Permissions and directories</title>
<body>

<p>
So far, we've been looking at permissions from the perspective of regular
files. When it comes to directories, things are a bit different. Directories
use the same permissions flags, but they are interpreted to mean slightly
different things.
</p>

<p>
For a directory, if the "read" flag is set, you may list the contents of the
directory; "write" means you may create files in the directory; and "execute"
means you may enter the directory and access any sub-directories inside.
Without the "execute" flag, the filesystem objects inside a directory aren't
accessible. Without a "read" flag, the filesystem objects inside a directory
aren't viewable, but objects inside the directory can still be accessed as long
as someone knows the full path to the object on disk.
</p>

</body>
</section>
<section>
<title>Directories and sgid</title>
<body>

<p>
And, if a directory has the "sgid" flag enabled, any filesystem objects created
inside it will inherit the group of the directory. This particular feature
comes in handy when you need to create a directory tree to be used by a group
of people that all belong to the same group. Simply do this:
</p>

<pre caption="Creating directory for a group of people">
# <i>mkdir /home/groupspace</i>
# <i>chgrp mygroup /home/groupspace</i>
# <i>chmod g+s /home/groupspace</i>
</pre>

<p>
Now, any users in the group mygroup can create files or directories inside
<path>/home/groupspace</path>, and they will be automatically assigned a group
ownership of mygroup as well. Depending on the users' umask setting, new
filesystem objects may or may not be readable, writable, or executable by other
members of the mygroup group.
</p>

</body>
</section>
<section>
<title>Directories and deletion</title>
<body>

<p>
By default, Linux directories behave in a way that may not be ideal in all
situations. Normally, anyone can rename or delete a file inside a directory, as
long as they have write access to that directory. For directories used by
individual users, this behavior is usually just fine.
</p>

<p>
However, for directories that are used by many users, especially
<path>/tmp</path> and <path>/var/tmp</path>, this behavior can be bad news.
Since anyone can write to these directories, anyone can delete or rename anyone
else's files -- even if they don't own them! Obviously, it's hard to use
<path>/tmp</path> for anything meaningful when any other user can type <c>rm
-rf /tmp/*</c> at any time and destroy everyone's files.
</p>

<p>
Thankfully, Linux has something called the sticky bit. When <path>/tmp</path>
has the sticky bit set (with a <c>chmod +t</c>), the only people who are able
to delete or rename files in <path>/tmp</path> are the directory's owner
(typically root), the file's owner, or root. Virtually all Linux distributions
enable <path>/tmp</path>'s sticky bit by default, but you may find that the
sticky bit comes in handy in other situations.
</p>

</body>
</section>
<section>
<title>The elusive first digit</title>
<body>

<p>
And to conclude this section, we finally take a look at the elusive first digit
of a numeric mode. As you can see, this first digit is used for setting the
sticky, <c>suid</c>, and <c>sgid</c> bits:
</p>

<table>
<tr>
  <th>suid</th>
  <th>sgid</th>
  <th>sticky</th>
  <th>mode digit</th>
</tr>
<tr>
  <ti>on</ti>
  <ti>on</ti>
  <ti>on</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>on</ti>
  <ti>off</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>off</ti>
  <ti>on</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>off</ti>
  <ti>off</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>on</ti>
  <ti>on</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>on</ti>
  <ti>off</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>off</ti>
  <ti>on</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>off</ti>
  <ti>off</ti>
  <ti>0</ti>
</tr>
</table>

<p>
Here's an example of how to use a 4-digit numeric mode to set permissions for a
directory that will be used by a workgroup:
</p>

<pre caption="Setting numeric permissions">
# <i>chmod 1775 /home/groupfiles</i>
</pre>

<p>
As homework, figure out the meaning of the 1755 numeric permissions setting. :)
</p>

</body>
</section>
</chapter>

<chapter>
<title>Linux account managment</title>
<section>
<title>Introducing /etc/passwd</title>
<body>

<p>
In this section, we'll look at the Linux account management mechanism, starting
with the <path>/etc/passwd</path> file, which defines all the users that exist
on a Linux system. You can view your own <path>/etc/passwd</path> file by
typing less <path>/etc/passwd</path>.
</p>

<p>
Each line in <path>/etc/passwd</path> defines a user account. Here's an example
line from my <path>/etc/passwd</path> file:
</p>

<pre caption="/etc/passwd">
drobbins:x:1000:1000:Daniel Robbins:/home/drobbins:/bin/bash
</pre>

<p>
As you can see, there is quite a bit of information on this line. In fact, each
<path>/etc/passwd</path> line consists of multiple fields, each separated by a
:.
</p>

<p>
The first field defines the username (drobbins)), and the second field contains
an x. On ancient Linux systems, this field contained an encrypted password to
be used for authentication, but virtually all Linux systems now store this
password information in another file.
</p>

<p>
The third field (1000) defines the numeric user id associated with this
particular user, and the fourth field (1000) associates this user with a
particular group; in a few panels, we'll see where group 1000 is defined.
</p>

<p>
The fifth field contains a textual description of this account -- in this case,
the user's name. The sixth field defines this user's home directory, and the
seventh field specifies the user's default shell -- the one that will be
automatically started when this user logs in.
</p>

</body>
</section>
<section>
<title>/etc/passwd tips and tricks</title>
<body>

<p>
You've probably noticed that there are many more user accounts defined in
<path>/etc/passwd</path> than actually log in to your system. This is because
various Linux components use user accounts to enhance security. Typically,
these system accounts have a user id ("uid") of under 100, and many of them
will have something like /bin/false listed as a default shell. Since the
<path>/bin/false</path> program does nothing but exit with an error code, this
effectively prevents these accounts from being used as login accounts -- they
are for internal use only.
</p>

</body>
</section>
<section>
<title>/etc/shadow</title>
<body>

<p>
So, user accounts themselves are defined in <path>/etc/passwd</path>. Linux
systems contain a companion file to <path>/etc/passwd</path> that's called
<path>/etc/shadow</path>. This file, unlike <path>/etc/passwd</path>, is
readable only by root and contains encrypted password information. Let's look
at a sample line from <path>/etc/shadow</path>:
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Each line defines password information for a particular account, and again,
each field is separated by a :. The first field defines the particular user
account with which this shadow entry is associated. The second field contains
an encrypted password. The remaining fields are described in the following
table:
</p>

<table>
<tr>
  <ti>field 3</ti>
  <ti># of days since 1/1/1970 that the password was modified</ti>
</tr>
<tr>
  <ti>field 4</ti>
  <ti>
    # of days before password will be allowed to be changed (0 for "change
    anytime")
  </ti>
</tr>
<tr>
  <ti>field 5</ti>
  <ti>
    # of days before system will force user to change to a new password (-1
    for "never")
  </ti>
</tr>
<tr>
  <ti>field 6</ti>
  <ti>
    # of days before password expires that user will be warned about
    expiration (-1 for "no warning")
  </ti>
</tr>
<tr>
  <ti>field 7</ti>
  <ti>
    # of days after password expiration that this account is automatically
    # disabled by the system (-1 for "never disable")
  </ti>
</tr>
<tr>
  <ti>field 8</ti>
  <ti>
    # of days that this account has been disabled (-1 for "this account is
    enabled")
  </ti>
</tr>
<tr>
  <ti>field 9</ti>
  <ti>Reserved for future use</ti>
</tr>
</table>

</body>
</section>
<section>
<title>/etc/group</title>
<body>

<p>
Next, we take a look at the <path>/etc/group</path> file, which defines all the
groups on a Linux system. Here's a sample line:
</p>

<pre caption="/etc/group">
drobbins:x:1000:
</pre>

<p>
The <path>/etc/group</path> field format is as follows. The first field defines
the name of the group; the second field is a vestigial password field that now
simply holds an x, and the third field defines the numeric group id of this
particular group. The fourth field (empty in the above example) defines any
users that are members of this group.
</p>

<p>
You'll recall that our sample <path>/etc/passwd</path> line referenced a group
id of 1000. This has the effect of placing the drobbins user in the drobbins
group, even though the drobbins username isn't listed in the fourth field of
<path>/etc/group</path>. 
</p>

</body>
</section>
<section>
<title>Group notes</title>
<body>

<p>
A note about associating users with groups: on some systems, you'll find that
every new login account is associated with an identically named (and usually
identically numbered) group. On other systems, all login accounts will belong
to a single users group. The approach that you use on the system(s) you
administrate is up to you. Creating matching groups for each user has the
advantage of allowing users to more easily control access to their own files by
placing trusted friends in their personal group.
</p>

</body>
</section>
<section>
<title>Adding a user and group by hand</title>
<body>

<p>
Now, I'll show you how to create your own user and group account. The best way
to learn how to do this is to add a new user to the system manually. To begin,
first make sure that your EDITOR environment variable is set to your favorite
text editor:
</p>

<pre caption="Checking favorite text editor variable">
# <i>echo $EDITOR</i>
vim
</pre>

<p>
If it isn't, you can set EDITOR by typing something like:
</p>

<pre caption="Setting EDITOR variable">
# <i>export EDITOR=/usr/bin/emacs</i>
# <i>vipw</i>
</pre>

<p>
You should now find yourself in your favorite text editor with the
<path>/etc/passwd</path> file loaded up on the screen. When modifying system
<path>passwd</path> and <path>group</path> files, it's very important to use
the <c>vipw</c> and <c>vigr</c> commands. They take extra precautions to ensure
that your critical <path>passwd</path> and <path>group</path> files are locked
properly so they don't become corrupted.
</p>

</body>
</section>
<section>
<title>Editing /etc/passwd</title>
<body>

<p>
Now that you have the <path>/etc/passwd</path> file up, go ahead and add the
following line:
</p>

<pre caption="/etc/passwd">
testuser:x:3000:3000:LPI tutorial test user:/home/testuser:/bin/false
</pre>

<p>
We've just added a "testuser" user with a UID of 3000. We've added him to a
group with a GID of 3000, which we haven't created just yet. Alternatively, we
could have assigned this user to the GID of the users group if we wanted. This
new user has a comment that reads LPI tutorial test user; the user's home
directory is set to <path>/home/testuser</path>, and the user's shell is set to
<path>/bin/false</path> for security purposes. If we were creating an non-test
account, we would set the shell to <path>/bin/bash</path>. OK, go ahead and
save your changes and exit.
</p>

</body>
</section>
<section>
<title>Editing /etc/shadow</title>
<body>

<p>
Now, we need to add an entry in <path>/etc/shadow</path> for this particular
user. To do this, type <c>vipw -s</c>. You'll be greeted with your favorite
editor, which now contains the <path>/etc/shadow</path> file. Now, go ahead and
copy the line of an existing user account (one that has a password and is
longer than the standard system account entries):
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Now, change the username on the copied line to the name of your new user, and
ensure that all fields (particularly the password aging ones) are set to your
liking:
</p>

<pre caption="Modifed /etc/shadow">
testuser:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Now, save and exit.
</p>

</body>
</section>
<section>
<title>Setting a password</title>
<body>

<p>
You'll be back at the prompt. Now, it's time to set a password for your new
user:
</p>

<pre caption="Setting password for new user">
# <i>passwd testuser</i>
Enter new UNIX password: <comment>(enter a password for testuser)</comment>
Retype new UNIX password: <comment>(enter testuser's new password again)</comment>
</pre>

</body>
</section>
<section>
<title>Editing /etc/group</title>
<body>

<p>
Now that <path>/etc/passwd</path> and <path>/etc/shadow</path> are set up, it's
now time to get <path>/etc/group</path> configured properly. To do this, type:
</p>

<pre caption="Configuring /etc/group">
# <i>vigr</i>
</pre>

<p>
Your <path>/etc/group</path> file will appear in front of you, ready for
editing. Now, if you chose to assign a default group of users for your
particular test user, you do not need to add any groups to
<path>/etc/groups</path>. However, if you chose to create a new group for this
user, go ahead and add the following line:
</p>

<pre caption="Adding new group manually">
testuser:x:3000:
</pre>

<p>
Now save and exit.
</p>

</body>
</section>
<section>
<title>Creating a home directory</title>
<body>

<p>
We're nearly done. Type the following commands to create testuser's home
directory:
</p>

<pre caption="Creating home directory">
# <i>cd /home</i>
# <i>mkdir testuser</i>
# <i>chown testuser.testuser testuser</i>
# <i>chmod o-rwx testuser</i>
</pre>

<p>
Our user's home directory is now in place and the account is ready for use.
Well, almost ready. If you'd like to use this account, you'll need to use vipw
to change testuser's default shell to <path>/bin/bash</path> so that the user
can log in.
</p>

</body>
</section>
<section>
<title>Account admin utils</title>
<body>

<p>
Now that you know how to add a new account and group by hand, let's review the
various time-saving account administration utilities available under Linux. Due
to space constraints, we won't cover a lot of detail describing these commands.
Remember that you can always get more information about a command by viewing
the command's man page. If you are planning to take the LPIC 101 exam, you
should spend some time getting familiar with each of these commands.
</p>

<p>
newgrp
</p>

<p> 
By default, any files that a user creates are assigned to the user's group
specified in <path>/etc/passwd</path>. If the user belongs to other groups, he
or she can type newgrp thisgroup to set current default group membership to the
group thisgroup. Then, any new files created will inherit thisgroup membership.
</p>

<table>
<tr>
  <ti><c>chage</c></ti>
  <ti>
    The <c>chage</c> command is used to view and change the password aging
    setting stored in <path>/etc/shadow</path>.
  </ti>
</tr>
<tr>
  <ti><c>gpasswd</c></ti>
  <ti>A general-purpose group administration tool.</ti>
</tr>
<tr>
  <ti><c>groupadd</c>/<c>groupdel</c>/<c>groupmod</c></ti>
  <ti>Used to add/delete/modify groups in <path>/etc/group</path></ti>
</tr>
<tr>
  <ti><c>useradd</c>/<c>userdel</c>/<c>usermod</c></ti>
  <ti>
    Used to add/delete/modify users in <path>/etc/passwd</path>. These commands
    also perform various other convenience functions. See the man pages for
    more information.
  </ti>
</tr>
<tr>
  <ti><c>pwconv</c>/<c>grpconv</c></ti>
  <ti>
    Used to convert <path>passwd</path> and <path>group</path> files to
    "new-style" shadow passwords.  Virtually all Linux systems already use
    shadow passwords, so you should never need to use these commands.
  </ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Tuning the user environment</title>
<section>
<title>Introducing "fortune"</title>
<body>

<p>
Your shell has many useful options that you can set to fit your personal
preferences. So far, however, we haven't discussed any way to have these
settings set up automatically every time you log in, except for re-typing them
each time. In this section we will look at tuning your login environment by
modifying startup files.
</p>

<p>
First, let's add a friendly message for when you first log in. To see an
example message, run <c>fortune</c>:
</p>

<pre caption="Running fortune command">
$ <i>fortune</i>
No amount of careful planning will ever replace dumb luck.
</pre>

</body>
</section>
<section>
<title>.bash_profile</title>
<body>

<p>
Now, let's set up <c>fortune</c> so that it gets run every time you log in. Use
your favorite text editor to edit a file named <path>.bash_profile</path> in
your home directory. If the file doesn't exist already, go ahead and create it.
Insert a line at the top:
</p>

<pre caption="~/.bash_profile">
fortune
</pre>

<p>
Try logging out and back in. Unless you're running a display manager like xdm,
gdm, or kdm, you should be greeted cheerfully when you log in:
</p>

<pre caption="Results of fortune command in .bash_profile file">
mycroft.flatmonk.org login: chouser
Password:
Freedom from incrustations of grime is contiguous to rectitude.
$
</pre>

</body>
</section>
<section>
<title>The login shell</title>
<body>

<p>
When bash started, it walked through the <path>.bash_profile</path> file in
your home directory, running each line as though it had been typed at a bash
prompt. This is called sourcing the file.
</p>

<p>
Bash acts somewhat differently depending on how it is started. If it is started
as a login shell, it will act as it did above -- first sourcing the system-wide
<path>/etc/profile</path>, and then your personal <path>~/.bash_profile</path>.
</p>

<p>
There are two ways to tell bash to run as a login shell. One way is used when
you first log in: bash is started with a process name of -bash. You can see
this in your process listing:
</p>

<pre caption="Process listing">
$ <i>ps u</i>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
chouser    404  0.0  0.0  2508  156 tty2     S     2001   0:00 -bash
</pre>

<p>
You will probably see a much longer listing, but you should have at least one
COMMAND with a dash before the name of your shell, like -bash in the example
above. This dash is used by the shell to determine if it's being run as a login
shell.
</p>

</body>
</section>
<section>
<title>Understanding --login</title>
<body>

<p>
The second way to tell bash to run as a login shell is with the <c>--login</c>
command-line option. This is sometimes used by terminal emulators (like xterm)
to make their bash sessions act like initial login sessions.
</p>

<p>
After you have logged in, more copies of your shell will be run. Unless they
are started with <c>--login</c> or have a dash in the process name, these
sessions will not be login shells. If they give you a prompt, however, they are
called interactive shells. If bash is started as interactive, but not login, it
will ignore <path>/etc/profile</path> and <path>~/.bash_profile</path> and will
instead source <path>~/.bashrc</path>.
</p>

<table>
<tr>
  <th>interactive</th>
  <th>login</th>
  <th>profile</th>
  <th>rc</th>
</tr>
<tr>
  <ti>yes</ti>
  <ti>yes</ti>
  <ti>source</ti>
  <ti>ignore</ti>
</tr>
<tr>
  <ti>yes</ti>
  <ti>no</ti>
  <ti>ignore</ti>
  <ti>source</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>yes</ti>
  <ti>source</ti>
  <ti>ignore</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>no</ti>
  <ti>ignore</ti>
  <ti>ignore</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Testing for interactivity</title>
<body>

<p>
Sometimes bash sources your <path>~/.bashrc</path>, even though it isn't really
interactive, such as when using commands like rsh and scp. This is important to
keep in mind because printing out text, like we did with the fortune command
earlier, can really mess up these non-interactive bash sessions. It's a good
idea to use the PS1 variable to detect whether the current shell is truly
interactive before printing text from a startup file:
</p>

<pre caption="Testing PS1 varibale">
if [ -n "$PS1" ]; then
fortune
fi
</pre>

</body>
</section>
<section>
<title>/etc/profile and /etc/skel</title>
<body>

<p>
As a system administrator, you are in charge of <path>/etc/profile</path>.
Since it is sourced by everyone when they first log in, it is important to keep
it in working order. It is also a powerful tool in making things work correctly
for new users as soon as they log into their new account.
</p>

<p>
However, there are some settings that you may want new users to have as
defaults, but also allow them to change easily. This is where the
<path>/etc/skel</path> directory comes in. When you use the <c>useradd</c>
command to create a new user account, it copies all the files from
<path>/etc/skel</path> into the user's new home directory. That means you can
put helpful <path>.bash_profile</path> and <path>.bashrc</path> files in
<path>/etc/skel</path> to get new users off to a good start.
</p>

</body>
</section>
<section>
<title>export</title>
<body>

<p>
Variables in bash can be marked so that they are set the same in any new shells
that it starts; this is called being marked for export. You can have bash list
all of the variables that are currently marked for export in your shell
session:
</p>

<pre caption="results of export command">
$ <i>export</i>
declare -x EDITOR="vim"
declare -x HOME="/home/chouser"
declare -x MAIL="/var/spool/mail/chouser"
declare -x PAGER="/usr/bin/less"
declare -x PATH="/bin:/usr/bin:/usr/local/bin:/home/chouser/bin"
declare -x PWD="/home/chouser"
declare -x TERM="xterm"
declare -x USER="chouser"
</pre>

</body>
</section>
<section>
<title>Marking variables for export</title>
<body>

<p>
If a variable is not marked for export, any new shells that it starts will not
have that variable set. However, you can mark a variable for export by passing
it to the <c>export</c> built-in:
</p>

<pre caption="Marking variable for export">
$ <i>FOO=foo</i>
$ <i>BAR=bar</i>
$ <i>export BAR</i>
$ <i>echo $FOO $BAR</i>
foo bar
$ <i>bash</i>
$ <i>echo $FOO $BAR</i>
bar
</pre>

<p>
In this example, the variables FOO and BAR were both set, but only BAR was
marked for export. When a new bash was started, it had lost the value for FOO.
If you exit this new bash, you can see that the original one still has values
for both FOO and BAR:
</p>

<pre caption="Checking settings in original bash">
$ <i>exit</i>
$ <i>echo $FOO $BAR</i>
foo bar
</pre>

</body>
</section>
<section>
<title>Export and set -x</title>
<body>

<p>
Because of this behavior, variables can be set in <path>~/.bash_profile</path>
or <path>/etc/profile</path> and marked for export, and then never need to be
set again. There are some options that cannot be exported, however, and so they
must be put in put in your <path>~/.bashrc</path> and your <e>profile</e> in
order to be set consistently. These options are adjusted with the set built-in:
</p>

<pre caption="Using set command">
$ <i>set -x</i>
</pre>

<p>
The <c>-x</c> option causes bash to print out each command it is about to run:
</p>

<pre caption="Checking results of -x option">
$ <i>echo $FOO</i>
$ <i>echo foo</i>
foo
</pre>

<p>
This can be very useful for understanding unexpected quoting behavior or
similar strangeness. To turn off the <c>-x</c> option, do <c>set +x</c>. See
the bash man page for all of the options to the set built-in.
</p>

</body>
</section>
<section>
<title>Setting variables with "set"</title>
<body>

<p>
The <c>set</c> built-in can also be used for setting variables, but when used
that way, it is optional. The bash command <c>set FOO=foo</c> means exactly the
same as <c>FOO=foo</c>. Un-setting a variable is done with the <c>unset</c>
built-in:
</p>

<pre caption="Un-setting variable">
$ <i>FOO=bar</i>
$ <i>echo $FOO</i>
bar
$ <i>unset FOO</i>
$ <i>echo $FOO</i>
</pre>

</body>
</section>
<section>
<title>Unset vs. FOO=</title>
<body>

<p>
This is <e>not</e> the same as setting a variable to nothing, although it is
sometimes hard to tell the difference. One way to tell is to use the <c>set</c>
built-in with no parameters to list all current variables:
</p>

<pre caption="Comparison of unset and FOO=">
$ <i>FOO=bar</i>
$ <i>set | grep ^FOO</i>
FOO=bar
$ <i>FOO=</i>
$ <i>set | grep ^FOO</i>
FOO=
$ <i>unset FOO</i>
$ <i>set | grep ^FOO</i>
</pre>

<p>
Using <c>set</c> with no parameters like this is similar to using the
<c>export</c> built-in, except that <c>set</c> lists all variables instead of
just those marked for export.
</p>

</body>
</section>
<section>
<title>Exporting to change command behavior</title>
<body>

<p>
Often, the behavior of commands can be altered by setting environment
variables. Just as with new bash sessions, other programs that are started from
your bash prompt will only be able to see variables that are marked for export.
For example, the command <c>man</c> checks the variable PAGER to see what
program to use to step through the text one page at a time.
</p>

<pre caption="Exporting PAGER variable">
$ <i>PAGER=less</i>
$ <i>export PAGER</i>
$ <i>man man</i>
</pre>

<p>
With PAGER set to <c>less</c>, you will see one page at a time, and pressing
the space bar moves on to the next page. If you change PAGER to <c>cat</c>, the
text will be displayed all at once, without stopping.
</p>

<pre caption="Setting PAGER variable to cat">
$ <i>PAGER=cat</i>
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>Using "env"</title>
<body>

<p>
Unfortunately, if you forget to set PAGER back to <c>less</c>, <c>man</c> (as
well as some other commands) will continue to display all their text without
stopping. If you wanted to have PAGER set to <c>cat</c> just once, you could
use the <c>env</c> command:
</p>

<pre caption="Using env command to set variable">
$ <i>PAGER=less</i>
$ <i>env PAGER=cat man man</i>
$ <i>echo $PAGER</i>
less
</pre>

<p>
This time, PAGER was exported to <c>man</c> with a value of <c>cat</c>, but the
PAGER variable itself remained unchanged in the bash session.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Summary and resources</title>
<section>
<title>Summary</title>
<body>

<p>
Congratulations on finishing Part 3 of this tutorial series! At this point, you
should know how to locate information in system and Internet documentation, and
you should have a good grasp of the Linux permissions model, user account
management, and login environment tuning.
</p>

</body>
</section>
<section id="resources">
<title>Resources</title>
<body>

<p>
Be sure to check out the various Linux documentation resources covered in this
tutorial -- particularly the <uri link="http://www.tldp.org/">Linux
Documentation Project</uri>. You'll find its collection of guides, HOWTOs,
FAQs, and man pages to be invaluable. Be sure to check out <uri
link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri> and <uri
link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri> as well.
</p>

<p>
The <uri link="http://www.tldp.org/guides.html">Linux System Administrators
guide</uri> (available from the "Guides" section at www.tldp.org) is a good
complement to this series of tutorials -- give it a read! You may also find
Eric S. Raymond's <uri
link="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix and
Internet Fundamentals HOWTO</uri> to be helpful.
</p>

<p>
You can read the GNU Project's online documentation for the GNU info system
(also called "texinfo") at <uri
link="http://www.gnu.org/manual/texinfo/index.html">GNU's texinfo documentation
page</uri>.
</p>

<p>
Browse the <uri link="http://www.tldp.org/links/#ng">Linux newsgroup list</uri>
on the LDP site, and the newsgroup archives at <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

<p>
In the Bash by example article series on developerWorks, Daniel shows you how
to use bash programming constructs to write your own bash scripts. This bash
series (particularly Parts 1 and 2) is good preparation for the LPIC Level 1
exam and reinforces the concepts covered in this tutorial's "Tuning the user
environment" section:
</p>

<ul>
  <li>
    <uri link="/doc/en/articles/bash-by-example-p1.xml">Bash by example, Part
    1: Fundamental programming in the Bourne-again shell</uri>
  </li>
  <li>
    <uri link="/doc/en/articles/bash-by-example-p2.xml">Bash by example, Part
    2: More bash programming fundamentals</uri>
  </li>
  <li>
    <uri link="/doc/en/articles/bash-by-example-p3.xml">Bash by example, Part
    3: Exploring the ebuild system.</uri>
  </li>
</ul>

<p>
We highly recommend the <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/">Technical FAQ
by Linux Users</uri> by Mark Chapman, a 50-page in-depth list of
frequently-asked Linux questions, along with detailed answers. The FAQ itself
is in PDF (Adobe Acrobat) format. If you're a beginning or intermediate Linux
user, you really owe it to yourself to check this FAQ out. We also recommend
the <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-gloss/index.html">Linux
glossary for Linux users</uri>, also from Mark.
</p>

<p>
If you're not familiar with the vi editor, check out Daniel's <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">Vi intro
-- the cheat sheet method tutorial</uri>. This tutorial will give you a gentle
yet fast-paced introduction to this powerful text editor. Consider this
must-read material if you don't know how to use vi.
</p>

<p>
For an intro to the Emacs editor, see the developerWorks tutorial, <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">Living
in Emacs</uri>.
</p>

</body>
</section>
<section>
<title>Feedback</title>
<body>

<p>
Please let us know whether this tutorial was helpful to you and how we could
make it better. We'd also like to hear about other tutorial topics you'd like
to see covered in developerWorks tutorials.
</p>

<p>
For questions about the content of this tutorial, contact the authors:
</p>

<ul>
  <li>Daniel Robbins, at <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, at <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, at <mail>agriffis@gentoo.org</mail>.</li>
</ul>

</body>
</section>
</chapter>
</guide>
