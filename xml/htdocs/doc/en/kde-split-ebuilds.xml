<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/Attic/kde-split-ebuilds.xml,v 1.4 2005/06/17 10:26:07 swift Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/kde-split-ebuilds.xml">

<title>The KDE Split Ebuilds HOWTO</title>

<author title="Author">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>

<abstract>
With KDE 3.4, the 'split ebuilds' were introduced into Portage. This page
documents the reasons behind the transition and the features made available by
it.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.3</version>
<date>2005-06-17</date>

<chapter>
<title>The Split KDE Ebuilds</title>
<section>
<title>What they are</title>
<body>

<p>
Until January 2005, the only KDE ebuilds in Portage were 'monolithic' ones. That
is to say, there were only 15 ebuilds, and each one installed many applications
that did not, in fact, depend on one another. This was clearly a suboptimal
situation, and not very Gentoo-ish, but it was tolerated for a long time.
</p>

<p>
The new 'split' ebuilds rectified the situation by providing separate ebuilds
for all the separate KDE applications. This gave us a grand total of about 330
new ebuilds in the kde-base category.
</p>

<p>
We still provide monolithic ebuilds for KDE 3.4 and they are cleanly
interoperable with the split ones. However, the split ebuilds are the new
default, and there will be no monolithic ebuilds for KDE 4.0.
</p>

<p>
Finally, it should be mentioned that there are split ebuilds for Koffice as
well. These provide kword, kugar etc. as separate packages.
</p>

</body>
</section>
<section>
<title>How to use them</title>
<body>

<p>
The latest KDE 3.4.0 pre-release, as of this writing, is 3.4.0_beta1. Masked
split (and monolithic) ebuilds for it are present in Portage.
</p>

<ul>
  <li>
    To emerge a particular package, such as kmail, simply <c>emerge
    kmail</c>.
  </li>
  <li>
    To emerge the basic KDE environment allowing you to login into a
    minimalistic KDE session, <c>emerge kdebase-startkde</c>.
  </li>
  <li>
    Finally, for the exact equivalent of one of the monolithic packages - for
    instance, to get all the applications included in <c>kdebase</c> using
    split ebuilds - you can <c>emerge kdebase-meta</c> (or kdepim-meta, etc.)
    To get absolutely all KDE split ebuilds, <c>emerge kde-meta</c>.
  </li>
</ul>

</body>
</section>
<section>
<title>Advantages of the split ebuilds</title>
<body>

<p>
Here's a brief list of what we gain from switching to the split ebuilds:
</p>

<ul>
  <li>
    Most KDE packages aren't changed at all between minor KDE releases. For
    example, the update from 3.3.1 to 3.3.2 changed fewer than 100 packages out
    of 320. Split packages allow us to create new ebuilds only for the packages
    that are actually changed, saving (in this example) more than two-thirds of
    the compilation time on an upgrade.
  </li>
  <li>
    Patches usually affect a specific package. With split ebuilds, they can be
    tested, approved and committed faster, and the developers have less to do;
    and, as above, the user will spend less time upgrading. This is especially
    important for security updates.
  </li>
  <li>
    Users of other desktops and leaner WMs can emerge a few KDE apps they like
    without the (quite big) overhead of the rest of, say, kdebase or kdepim.
  </li>
  <li>
    Users can fine-tune the packages they have installed. Reasons you might
    want this include:
    
    <ul>
      <li>
        You care about compilation time. <c>emerge kdebase kdepim kdenetwork</c>
        takes far too long when what you really need is konqueror, kmail
        and kopete. Besides, CPU time is money... somewhere.
      </li>
      <li>
        You care about disk usage. Every unused package is that many megabytes
        blocking the pores between your disk's sectors. A disk with more free
        space breathes freely; it's a fast, happy disk.
      </li>
      <li>
        You care about system security. All installed software is a potential
        source of vulnerabilities, and there's no excuse for unused software
        left lying around.
      </li>
      <li>
        You faithfully adhere to the <uri link="/main/en/philosophy.xml">Gentoo
        Way</uri>, and can't stand packages being bundled together and forced
        on the user. (Neither could we.)
      </li>
    </ul>
  </li>
  <li>
    Finally, the split ebuilds also allow more compile-time flexibility with 
    USE flags.
  </li>
</ul>

</body>
</section>
<section>
<title>Split and monolithic ebuild interoperability</title>
<body>

<p>
Split and monolithic ebuilds can be mixed freely. The only restriction is that
a monolithic ebuild can't be installed at the same time as a split ebuild
deriving from it. There are blocking deps in the ebuilds that enforce this, so
you can do anything emerge allows you to do.
</p>

<p>
Ordinarily, however, there's no reason to use such a mixed configuration. In
fact, except for special cases like very slow-compiling boxes (mips), you should
use the split ebuilds for all your needs.
</p>

<p>
The split ebuilds are also the default ebuilds. This means that when some other
ebuild depends on a KDE application, it will want to install a split ebuild.
However, the matching monolithic ebuild will also satisfy that dep, so you can
emerge the monolithic ebuild manually and then emerge the ebuild that depended
on it.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Performance issues</title>
<section>
<title>Why split ebuilds are slow</title>
<body>

<p>
It's been <uri link="http://bugs.gentoo.org/show_bug.cgi?id=11123">said</uri>
before that split ebuilds would take much more time to emerge than the
monolithic ones, due to the overhead of unpacking and running configure for
every package. A complete <c>emerge kde-meta</c> could take 20-30% longer than a
classic <c>emerge kde</c>, unacceptable in an already long compile. 
</p>

<p>
Moreover, at present the split ebuilds always run <c>make -f
admin/Makefile.cvs</c> (this means running autoconf, automake, etc. and several
related kde-specific scripts). This adds an additional slowdown of
approximately the same order as a configure run.
</p>

<p>
On the face of it, this analysis looks bleak. However, several factors which
offset this slowdown will be detailed in the next sections.
</p>

<p>
It is worth reiterating here that with the split ebuilds a KDE upgrade's
compilation time can be cut by half - and in some cases by a factor of ten or
more - by only upgrading the packages that actually changed. The benefit from a
single such update often overshadows the overhead incurred during the original
installation.
</p>

<p>
Finally, installing all of KDE makes sense if you want to explore the available
packages or are setting up a multi-user environment; however, most people
use only some of the 300+ KDE apps available. Anyone who really cares about
compilation time, such as owners of older boxen, can gain more time by
selectively installing packages than they might lose by the overhead incurred.
</p>

</body>
</section>
<section>
<title>How split ebuilds will be made faster</title>
<body>

<p>
The most obvious improvement would be to distribute separate tarballs for the
split ebuilds, instead of unpacking pieces of the monolithic tarballs (kdebase
etc.) distributed by upstream. This would eliminate two of the three
overhead factors slowing down the split ebuilds: repeated extraction of the
large tarballs and makefile regeneration (the <c>make -f
admin/Makefile.cvs</c> phase mentioned above).
</p>

<p>
This leaves us with the issue of repeatedly running configure. The proper
solution to this is confcache: a configure cache shared between emerge runs. An
implementation already exists in the development branch of portage (the tool,
not the package tree); a stable release with confcache is expected in half a
year or so.
</p>

</body>
</section>
<section>
<title>Other factors offsetting split ebuilds slowdown</title>
<body>

<p>
The previous section listed methods of improving the performance of the
split ebuilds specifically. Next we will briefly mention some future speedups
which are equally applicable to the monolithic ebuilds. Such speedups help
make the split ebuilds 'fast enough', apart from comparisons with less
featureful solutions such as the monolithic ebuilds.
</p>

<ul>
  <li>
    KDE 4.0 should be able to use <uri
    link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri>
    instead of automake, which speeds up compilation in some scenarios; our KDE
    3.4 ebuilds may eventually use unsermake as well.
  </li>
  <li>
    The split ebuilds support the kdexdeltas USE flag, which allows downloading
    binary diffs between release tarballs to save on bandwidth usage.
  </li>
  <li>
    All the other tools involved in the build also generally get faster with
    time, or enable various KDE-related compilation speedups. The new
    visibility=hidden (GCC 3.4) and precompiled headers (GCC 4.0) features
    are two recent examples. They aren't direct payoffs from the switch to split
    ebuilds; they just mean we can afford more CPU-intensive compilations now.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Split ebuilds FAQ</title>
<section>
<title>Can't we do this already with DO_NOT_COMPILE?</title>
<body>

<p>
DO_NOT_COMPILE is an environment variable internal to the KDE build system. It
allows selectively disabling subdirectories from compilation. Some people used
to use it to compile subsets of the monolithic KDE ebuilds. For instance,
running <c>DO_NOT_COMPILE=konqueror emerge kdebase</c> would install a kdebase
without the konqueror application.
</p>

<p>
However, DO_NOT_COMPILE was never intended to be used to interfere with the
operation of a package manager's automated builds. It does not work, it can
break your system, and it was never supported. We request everyone to refrain
from using it.
</p>

<p>
Here is a partial list of the problems with DO_NOT_COMPILE:
</p>

<ul>
  <li>
    It completely breaks portage's dependency tracking. Portage does not know
    about DO_NOT_COMPILE, and thinks the entire monolithic package has been
    installed and can satisfy other packages' deps. This can cause other
    packages not to emerge or not to run.
  </li>
  <li>
    It forces the user to know the names and meanings of all the different
    existing subdirs of the KDE modules. Very few users do know this, unless
    they're KDE developers, so they can't use DO_NOT_COMPILE properly.
  </li>
  <li>
    KDE module subdirs can have interdependencies between them, require a
    particular build order, require another dir to be present even if it does
    not have to be installed, and so forth. We put a lot of work into the split
    ebuilds to make them work properly in this regard. DO_NOT_COMPILE is not
    nearly a fine enough tool to achieve the same results, even given
    sufficient knowledge on the user's part. The only thing you can do with it
    is disable a few applications from compiling. It is practically impossible
    to use it to install only a few selected applications from modules like
    kdebase or kdepim.
  </li>
  <li>
    If I installed kmail yesterday and want to add korn today, using
    DO_NOT_COMPILE, it entails recompiling kmail as well. This means
    DO_NOT_COMPILE is always much slower than split ebuilds.
  </li>
  <li>
    DO_NOT_COMPILE can't be used to make precompiled packages (such as the GRP)
    containing individual KDE apps.
  </li>
</ul>

</body>
</section>
<section>
<title>Aren't you putting too big a load on the Gentoo KDE maintainers?</title>
<body>

<p>
Surprisingly, this question gets asked a lot. I'm glad users are so
considerate of us maintainers. Let me take this opportunity to assure you that
we're taking on the split ebuilds of our own free will; that we believe we'll
be able to continue maintaining them well; and that there's no chance of
talking us out of it :-)
</p>

<p>
For completeness' sake, I should mention that maintainers from other archs
have in fact complained about the increased workload of testing and keywording
so many separate ebuilds. We're working to resolve this and it's a major reason
why monolithic ebuilds are in fact still available for KDE 3.4.
</p>

</body>
</section>
<section>
<title>Are you going to remove the old-style (monolithic) ebuilds?</title>
<body>

<p>
We intend to so eventually. However, there will be both monolithic and split
ebuilds for all the KDE 3.4 releases.
</p>

<p>
If you prefer the monolithic ebuilds over the split ones, please
<uri link="http://bugs.gentoo.org">tell us</uri> your reasons.
</p>

</body>
</section>
<section>
<title>There are too many ebuilds! How am I going to find the one I need?</title>
<body>

<p>
Well, first of all, if you know the package you're looking for came with
kdebase, you can still <c>emerge kdebase-meta</c>, with much the same results
as if you emerged the monolithic <c>kdebase</c>. So things haven't actually
become any worse due to the split ebuilds.
</p>

<p>
Of course, all the usual ways of locating a package also apply. How would you
find your ebuild if it was a Gnome application? As a minimum, you do have to
know the name of the application you're looking for.
</p>

<p>
The situation could, perhaps, be improved by introducing some more -meta
ebuilds. They are merely lists of dependencies, so they don't cost us anything.
This hasn't been decided yet. Also, it would be nice to have Portage sets
functionality before we do this extensively.
</p>

</body>
</section>
<section>
<title>How can I unmerge an older KDE?</title>
<body>

<p>
Suppose KDE 4.0 comes out and you want to unmerge the split ebuilds for KDE
3.4. Because they belong to different slots, emerge won't do this for you, so
another way is needed.
</p>

<p>
A proper solution to this problem requires modifications to portage. One such
solution is described in
<uri link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>.
Until that is implemented, however, we must resort to scripts like the one
given below.
</p>

<p>
Fortunately, all KDE ebuilds belong to the kde-base directory (and all ebuilds
in the kde-base category come from kde.org). So the following code works:
</p>

<pre caption="Removing KDE 3.4 from the system">
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
The above looks a bit hackish, but ultimately it's not a hack because all
we really need is a list of ebuilds from kde-base. That's a very simple task
and so there will always be easy ways to accomplish it.
</p>

</body>
</section>
<section>
<title>How can I list/unmerge all split ebuilds derived from a given package?</title>
<body>

<p>
The objective here is to list all split kde ebuilds derived from, say, the
kdebase monolithic ebuild. Once again, the proper implementation (such as <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>)
would make this trivial. Today, however, you must become involved in the
KDE eclasses' implementation details to some degree. So, if you use any of
these approaches in a script that's not for private use, tell us about it.
</p>

<p>
kde-functions.eclass defines functions called get-parent-package() and
get-child-packages() which do the translation for you. These two functions are
the correct way to accomplish this task from an ebuild or an external bash
script. Here is an example:
</p>

<pre>
$ <i>function die() { echo $@; } # called to report errors</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # won't work, you must specify full name</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug # error printed</i>
$ <i>get-parent-package kde-base/konqueror # fully qualified package name</i>
<i>kde-base/kdebase # result printed</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (long list of packages printed here)</i>
</pre>

<p>
If your script isn't in bash, you can grep kde-functions.eclass to extract the
(multiline) definition of the variable KDE_DERIVATION_MAP, which the
aforementioned functions use. This variable contains a whitespace-separated
list of words, and each two consecutive words map a parent package to a child
split ebuild.
</p>

</body>
</section>
</chapter>
</guide>
