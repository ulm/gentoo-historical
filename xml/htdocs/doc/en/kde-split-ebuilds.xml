<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/Attic/kde-split-ebuilds.xml,v 1.11 2006/09/28 11:40:41 nightmorph Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/kde-split-ebuilds.xml">

<title>The KDE Split Ebuilds HOWTO</title>

<author title="Author">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Editor">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>

<abstract>
With KDE 3.4, the 'split ebuilds' were introduced into Portage. This page
documents the reasons behind the transition, the new features it brings and the
way to upgrade from the old-style 'monolithic' ebuilds.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.8</version>
<date>2006-09-28</date>

<chapter>
<title>The Split KDE Ebuilds</title>
<section>
<title>What they are</title>
<body>

<p>
Until January 2005, the only KDE ebuilds in Portage were 'monolithic' ones.
That is to say, there were only 15 ebuilds (<c>kdebase</c>, <c>kdenetwork</c>,
...), and each one installed many applications that did not, in fact, depend on
one another. This was clearly a suboptimal situation, and not very Gentoo-ish,
but it was tolerated for a long time.
</p>

<p>
The new 'split' ebuilds (for <c>konqueror</c>, <c>kmail</c>, ...) rectified the
situation by providing separate ebuilds for all the separate KDE applications.
This gave us a grand total of about 330 new ebuilds in the kde-base category.
</p>

<p>
We still provide monolithic ebuilds for 3.5 and they are cleanly interoperable
with the split ones. However, the split ebuilds are the new default, and there
will be no monolithic ebuilds for KDE 4.0.
</p>

<p>
Finally, it should be mentioned that there are split ebuilds for Koffice as
well. These provide <c>kword</c>, <c>kugar</c>, etc. as separate packages.
</p>

</body>
</section>
<section>
<title>How to install the split ebuilds</title>
<body>

<p>
The latest stable KDE release, as of this writing, is 3.5.2. The latest
unstable (~arch) is 3.5.4. Split and monolithic ebuilds for both releases are
present in Portage.
</p>

<ul>
  <li>
    To emerge a particular package, such as kmail, simply <c>emerge
    kmail</c>.
  </li>
  <li>
    To emerge the basic KDE environment allowing you to login into a
    minimalistic KDE session, <c>emerge kdebase-startkde</c>.
  </li>
  <li>
    Finally, for the exact equivalent of one of the monolithic packages - for
    instance, to get all the applications included in <c>kdebase</c> using
    split ebuilds - you can <c>emerge kdebase-meta</c> (or <c>kdepim-meta</c>,
    etc.) To get absolutely all KDE split ebuilds, <c>emerge kde-meta</c>.
  </li>
</ul>

</body>
</section>
<section>
<title>How to upgrade from the monolithic to the split ebuilds</title>
<body>

<p>
If you have KDE 3.3.x installed, you can simply <c>emerge kde-meta</c> to
install the 3.5.x split ebuilds without disturbing your existing installation.
</p>

<p>
If you have the KDE 3.4.x or 3.5.x monolithic ebuilds installed, you must
unmerge them before emerging the split ebuilds. However, this process can be
done for each monolithic ebuild in turn; you don't have to unmerge all of KDE
at once.
</p>

<p>
If you're in doubt, remember there are blocking dependencies in place between
each monolithic ebuild and the split ebuilds derived from it. Portage won't
allow an illegal state to be created, so any emerge or unmerge it allows is
OK.
</p>

</body>
</section>
<section>
<title>Advantages of the split ebuilds</title>
<body>

<p>
Here's a brief list of what we gain from switching to the split ebuilds:
</p>

<ul>
  <li>
    Most KDE packages aren't changed at all between minor KDE releases. For
    example, the update from 3.3.1 to 3.3.2 changed fewer than 100 packages out
    of 320. Split packages allow us to create new ebuilds only for the packages
    that are actually changed, saving (in this example) more than two-thirds of
    the compilation time on an upgrade.
  </li>
  <li>
    Patches usually affect a specific package. With split ebuilds, they can be
    tested, approved and committed faster, and the developers have less to do;
    and, as above, the user will spend less time upgrading. This is especially
    important for security updates.
  </li>
  <li>
    Users of other desktops and leaner WMs can emerge a few KDE apps they like
    without the (quite big) overhead of the rest of, say, <c>kdebase</c> or
    <c>kdepim</c>.
  </li>
  <li>
    Users can fine-tune the packages they have installed. Reasons you might
    want this include:
    
    <ul>
      <li>
	You care about compilation time. <c>emerge kdebase kdepim
	kdenetwork</c> takes far too long when what you really need is
	<c>konqueror</c>, <c>kmail</c> and <c>kopete</c>. Besides, CPU time is
	money... somewhere.
      </li>
      <li>
        You care about disk usage. Every unused package is that many megabytes
        blocking the pores between your disk's sectors. A disk with more free
        space breathes freely; it's a fast, happy disk.
      </li>
      <li>
        You care about system security. All installed software is a potential
        source of vulnerabilities, and there's no excuse for unused software
        left lying around.
      </li>
      <li>
        You faithfully adhere to the <uri link="/main/en/philosophy.xml">Gentoo
        Way</uri>, and can't stand packages being bundled together and forced
        on the user. (Neither could we.)
      </li>
    </ul>
  </li>
  <li>
    Finally, the split ebuilds also allow more compile-time flexibility with
    USE flags.
  </li>
</ul>

</body>
</section>
<section>
<title>Split and monolithic ebuild interoperability</title>
<body>

<p>
Split and monolithic ebuilds can be mixed freely. The only restriction is that
a monolithic ebuild can't be installed at the same time as a split ebuild
deriving from it. There are blocking dependencies in the ebuilds that enforce
this, so you can do anything emerge allows you to do.
</p>

<p>
Ordinarily, however, there's no reason to use such a mixed configuration. In
fact, except for special cases like very slow-compiling boxes (mips), you should
use the split ebuilds for all your needs.
</p>

<p>
The split ebuilds are also the default ebuilds. This means that when some other
ebuild depends on a KDE application, it will want to install a split ebuild.
However, the matching monolithic ebuild will also satisfy that dependency, so
you can emerge the monolithic ebuild manually and then emerge the ebuild that
depended on it.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Performance issues</title>
<section>
<title>Why split ebuilds are slow</title>
<body>

<p>
It's been <uri link="http://bugs.gentoo.org/show_bug.cgi?id=11123">said</uri>
before that split ebuilds would take much more time to emerge than the
monolithic ones, due to the overhead of unpacking and running configure for
every package. A complete <c>emerge kde-meta</c> could take 20-30% longer
than a classic <c>emerge kde</c>, unacceptable in an already long compile. 
</p>

<p>
Moreover, at present the split ebuilds always run <c>make -f
admin/Makefile.cvs</c> (this means running autoconf, automake, etc. and several
related kde-specific scripts). This adds an additional slowdown of
approximately the same order as a configure run.
</p>

<p>
Finally, a split ebuild needs to extract specific files out of a large tarball.
This is slower than extracting a dedicated, small tarball. However, creating
such small tarballs for the autotools-based build system of KDE 3.x is
difficult.
</p>

<p>
It is worth reiterating here that with the split ebuilds a KDE upgrade's
compilation time can be greatly reduced by only upgrading the packages that
actually changed. The benefit from a single such update often overshadows the
overhead incurred during the original installation.
</p>

<p>
Finally, installing all of KDE makes sense if you want to explore the available
packages or are setting up a multi-user environment; however, most people use
only some of the 300+ KDE apps available. Anyone who really cares about
compilation time, such as owners of older boxes, can gain more time by
selectively installing packages than they might lose by the overhead incurred.
</p>

</body>
</section>
<section>
<title>How split ebuilds will be made faster</title>
<body>

<p>
Most or even all of the split ebuilds' performance issues are tied to autotools
- autoconf, automake and other tools which manage the <c>./configure;make;make
install</c> build system used in KDE 3.x. 
</p>

<p>
KDE 4 will (as far as we can tell now) adopt a completely new build system,
which among other things will greatly reduce the time its equivalent of a
<c>make -f admin/Makefile.common; ./configure</c> will take. Hopefully, it will
also make it much easier to create a small tarball for each split ebuild by
lowering the cost of generating its equivalent of configure scripts (if any).
</p>

<p>
Previously, <c>confcache</c> had been considered as a way to lower the cost of
repeatedly running autoconf-generated configure scripts. <c>Confcache</c> is a
method of caching the results of configure tests. However, there is still no
<c>confcache</c> implementation in the stable (2.1) Portage tree. Even if one
is added in the future, it may not come soon enough for us to work on using it
in the KDE ebuilds; we may elect to wait for KDE 4.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Split ebuilds FAQ</title>
<section>
<title>Why are some split packages missing the newest ebuild versions?</title>
<body>

<p>
As explained above, not all applications are really updated between minor KDE
releases, and so not all applications receive new ebuild versions. For
instance, libkdenetwork wasn't updated in 3.5.0_beta2, so the latest ebuild
available with that release was 3.5_beta1.
</p>

<p>
This is done purely to reduce compilation time during an upgrade. If we had
made a libkdenetwork-3.5.0_beta2 ebuild, it would have installed precisely the
same files as the 3.5_beta1 ebuild. The various dependencies are updated to
work correctly (i.e. no ebuild will depend on libkdenetwork-3.5.0_beta2).
</p>

</body>
</section>
<section>
<title>Can't we do this already with DO_NOT_COMPILE?</title>
<body>

<p>
DO_NOT_COMPILE is an environment variable internal to the KDE build system. It
allows selectively disabling subdirectories from compilation. Some people used
to use it to compile subsets of the monolithic KDE ebuilds. For instance,
running <c>DO_NOT_COMPILE=konqueror emerge kdebase</c> would install a kdebase
without the <c>konqueror</c> application.
</p>

<p>
However, DO_NOT_COMPILE was never intended to be used to interfere with the
operation of a package manager's automated builds. It does not work, it can
break your system, and it was never supported. We request everyone to refrain
from using it.
</p>

<p>
Here is a partial list of the problems with DO_NOT_COMPILE:
</p>

<ul>
  <li>
    It completely breaks Portage's dependency tracking. Portage does not know
    about DO_NOT_COMPILE, and thinks the entire monolithic package has been
    installed and can satisfy other packages' deps. This can cause other
    packages not to emerge or not to run.
  </li>
  <li>
    It forces the user to know the names and meanings of all the different
    existing subdirs of the KDE modules. Very few users do know this, unless
    they're KDE developers, so they can't use DO_NOT_COMPILE properly.
  </li>
  <li>
    KDE module subdirs can have interdependencies between them, require a
    particular build order, require another dir to be present even if it does
    not have to be installed, and so forth. We put a lot of work into the split
    ebuilds to make them work properly in this regard. DO_NOT_COMPILE is not
    nearly a fine enough tool to achieve the same results, even given
    sufficient knowledge on the user's part. The only thing you can do with it
    is disable a few applications from compiling. It is practically impossible
    to use it to install only a few selected applications from modules like
    <c>kdebase</c> or <c>kdepim</c>.
  </li>
  <li>
    If I installed kmail yesterday and want to add korn today, using
    DO_NOT_COMPILE, it entails recompiling kmail as well. This means
    DO_NOT_COMPILE is always much slower than split ebuilds.
  </li>
  <li>
    DO_NOT_COMPILE can't be used to make precompiled packages (such as the GRP)
    containing individual KDE apps.
  </li>
</ul>

</body>
</section>
<section>
<title>Aren't you putting too big a load on the Gentoo KDE maintainers?</title>
<body>

<p>
Surprisingly, this question gets asked a lot. I'm glad users are so
considerate of us maintainers. Let me take this opportunity to assure you that
we're taking on the split ebuilds of our own free will; that we believe we'll
be able to continue maintaining them well; and that there's no chance of
talking us out of it :-)
</p>

<p>
For completeness' sake, I should mention that maintainers from other archs
have in fact complained about the increased workload of testing and keywording
so many separate ebuilds. We're working to resolve this and it's a major reason
why monolithic ebuilds are in fact still available for KDE 3.5.
</p>

</body>
</section>
<section>
<title>Are you going to remove the old-style (monolithic) ebuilds?</title>
<body>

<p>
We intend to do so eventually. However, there will be both monolithic and split
ebuilds for all the KDE 3.x releases.
</p>

<p>
If you prefer the monolithic ebuilds over the split ones, please
<uri link="http://bugs.gentoo.org">tell us</uri> your reasons.
</p>

</body>
</section>
<section>
<title>There are too many ebuilds! How am I going to find the one I need?</title>
<body>

<p>
Well, first of all, if you know the package you're looking for came with
kdebase, you can still <c>emerge kdebase-meta</c>, with much the same results
as if you emerged the monolithic <c>kdebase</c>. So, things haven't actually
become any worse due to the split ebuilds.
</p>

<p>
Of course, all the usual ways of locating a package also apply. How would you
find your ebuild if it was a Gnome application? As a minimum, you do have to
know the name of the application you're looking for.
</p>

<p>
The situation could, perhaps, be improved by introducing some more -meta
ebuilds. They are merely lists of dependencies, so they don't cost us anything.
This hasn't been decided yet. Also, it would be nice to have Portage sets
functionality before we do this extensively.
</p>

</body>
</section>
<section>
<title>How can I list/unmerge all split ebuilds derived from a given package?</title>
<body>

<p>
The objective here is to list all split kde ebuilds derived from, say, the
<c>kdebase</c> monolithic ebuild. Once again, the proper implementation (such as <uri
link="/proj/en/glep/glep-0021.html">GLEP 21</uri>) would make this trivial.
Today, however, you must become involved in the KDE eclasses' implementation
details to some degree. So, if you use any of these approaches in a script
that's not for private use, tell us about it.
</p>

<p>
kde-functions.eclass defines functions called get-parent-package() and
get-child-packages() which do the translation for you. These two functions are
the correct way to accomplish this task from an ebuild or an external bash
script. Here is an example:
</p>

<pre caption="Example usage of the kde-functions functions">
$ <i>function die() { echo $@; } # called to report errors</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # won't work, you must specify full name</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug # error printed</i>
$ <i>get-parent-package kde-base/konqueror # fully qualified package name</i>
<i>kde-base/kdebase # result printed</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (long list of packages printed here)</i>
</pre>

<p>
If your script isn't in bash, you can grep kde-functions.eclass to extract the
(multiline) definition of the variable KDE_DERIVATION_MAP, which the
aforementioned functions use. This variable contains a whitespace-separated
list of words, and each two consecutive words map a parent package to a child
split ebuild.
</p>

</body>
</section>
</chapter>
</guide>
