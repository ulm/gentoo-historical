<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/Attic/tftp-guide.xml,v 1.2 2003/12/10 16:09:43 swift Exp $ -->

<guide link="/doc/en/tftp-guide.xml">
<title>Gentoo TFTP Guide</title>
<author title="Author">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>

<abstract>
TFTP is frequently used to transfer data to a booting system. In this guide we
explain how to configure DHCP and TFTP to be able to boot Gentoo from network.
</abstract>
<version>0.1</version>
<date>December 8, 2003</date>
<license/>
<chapter>
<title>Preliminaries</title>
<section>
<title>Introduction</title>
<body>

<p>
When wrestling with large networks, administrators frequently express the need
to centralise the workstation administration. The first item that is spotted
while auditing the workstation events is the boot procedure: the workstations
start a bootloader that loads a kernel which mounts the filesystems and hands
over the job to the <c>init</c> process. All these items are static, but in case
of an error (or security issue), <e>all</e> workstations need to be updated.
</p>

<p>
By using TFTP and DHCP, you can administer the kernel images (and, if necessary,
initial root disks) on a single system and have all workstations boot from
network. If most (or all) workstations have identical hardware, one kernel can
be used for all workstations, improving the response time in case a kernelupdate
is imminent.
</p>

</body>
</section>
<section>
<title>Requirements</title>
<body>

<p>
In order to use the TFTP/DHCP functionality at boot-time, your network cards
must support PXE booting as well as your BIOS/PROM. 
</p>

</body>
</section>
</chapter>
<chapter>
<title>Dynamic Host Configuration Protocol</title>
<section>
<title>Installing a DHCP Server</title>
<body>

<p>
When a workstation requests to boot from network, it searches for an active DHCP
server. Such a server provides the workstation with all necessary information,
such as its IP address and the location of the files it needs to boot. Even
though these two are completely separate (i.e. the DHCP server and the server
providing the files do not need to be one and the same) this guide will assume
you configure both services on a single system.
</p>

<p>
To begin the DHCP configuration, you need to install a DHCP server. You can opt
to use the ISC DHCP server (recommended) called <c>dhcp</c>, the udhcp server
(<c>udhcp</c>) and the IPv6-supporting DHCP server (<c>dhcpv6</c>). In the
following example, we will install the ISC DHCP server.
</p>

<pre caption="Installing a DHCP server">
# <i>emerge dhcp</i>
</pre>

</body>
</section>
<section>
<title>Setting up DHCP</title>
<body>

<p>
The default DHCP service configuration file is called
<path>/etc/dhcp/dhcp.conf</path> (configuration files can vary depending on the
installed DHCP server). To have the workstations succesfully boot from network,
they must receive an IP address and the location of their bootfiles from the
DHCP server. You can then decide wether or not you want every possible
workstation to receive an IP address from a pool of available IP addresses, or
to restrict the network booting to a known subset of workstations and use
MAC-address restrictions to decide which one can use the network boot
functionality.
</p>

<p>
Below you will find a template for a <path>dhcp.conf</path>. The <c>host</c>
section can be reiterated for each host you want to give an IP address to (and
be able to boot from the network with).
</p>

<pre caption="dhcp.conf template">
ddns-update-style ad-hoc;
group {
  next-server <comment>&lt;IP address of TFTP server&gt;</comment>

  subnet <comment>&lt;subnet&gt;</comment> netmask <comment>&lt;netmask&gt;</comment> {
    allow bootp;
  }

  host <comment>&lt;hostname or IP&gt;</comment> {
    hardware ethernet <comment>&lt;MAC address&gt;</comment>;
    fixed-address <comment>&lt;IP address to assign&gt;</comment>;
    # filename "<comment>&lt;filename to send&gt;</comment>";
  }
}
</pre>

<p>
For the moment, keep the <c>filename</c> instruction commented out. We will
uncomment it later when we have finished setting up TFTP.
</p>

</body>
</section>
<section>
<title>Testing the DHCP Settings</title>
<body>

<p>
Add the <c>dhcpd</c> service to the default runlevel and start it.
</p>

<pre caption="Starting the DHCP service">
# <i>rc-update add dhcpd default</i>
# <i>/etc/init.d/dhcpd start</i>
</pre>

<p>
Now configure one of your workstations to automatically receive its IP
information. If you reboot that workstation (or restart its network settings) it
should receive its IP information from the newly configured DHCP server.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Trivial File Transfer Protocol</title>
<section>
<title>Installing a TFTP Server</title>
<body>

<p>
There are again many TFTP services you can choose from. We have <c>atftp</c>,
<c>netkit-tftp</c> and <c>tftp-hpa</c>. The latter one is the port from
OpenBSDs TFTP server and is the TFTP service we will use throughout the rest of
this document. Now start by installing the chosen TFTP server:
</p>

<pre caption="Installing tftp-hpa">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>
<section>
<title>Setting up TFTP</title>
<body>

<p>
TFTP is a simplified version of FTP. It doesn't have authentication methods or
any other features you would find in regular FTP servers. It is a plain simple
protocol to download files from and to hosts. The configuration of TFTP is
therefor very straightforward.
</p>

<p>
For <c>tftp-hpa</c>, the TFTP service we use, you need to alter the contents of
<path>/etc/conf.d/in.tftpd</path>:
</p>

<pre caption="Editing /etc/conf.d/in.tftpd">
INTFTPD_PATH="/var/tftp/all_nodes"
INTFTPD_USER="nobody"
INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"
</pre>

<p>
The first variable (INTFTPD_PATH) contains the path to the directory which will
contain the downloadable files. As this will probably be a new directory, we
need to create it too:
</p>

<pre caption="Creating /var/tftp/all_nodes">
# <i>mkdir -p /var/tftp/all_nodes</i>
</pre>

<p>
The second variable contains the username under which the TFTP service should
run. Never set this as root! The user "nobody" is a nice default setting. The
third variable states the options which the TFTP service should be started with.
</p>

</body>
</section>
<section>
<title>Activating TFTP</title>
<body>

<p>
Activate TFTP by adding it to the default runlevel and starting it:
</p>

<pre caption="Starting TFTP Service">
# <i>rc-update add tftp default</i>
# <i>/etc/init.d/tftpd start</i>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Creating a Bootable System</title>
<section>
<title>Introduction</title>
<body>

<p>
All necessary services are in place, but you can't boot the systems from the
network yet. You need to create a bootable system (kernel plus some extra
information, usually contained in a special bootloader) which will be started
when the workstation is booted.
</p>

<p>
In this chapter, we will use <c>pxelinux</c>, which is a part of
<c>syslinux</c>. So, we start by installing <c>syslinux</c>:
</p>

<pre caption="Installing SYSLinux">
# <i>emerge syslinux</i>
</pre>

<p>
Copy over the <path>pxelinux.0</path> file to <path>/var/tftp/all_nodes</path>
and create a directory called <path>/var/tftp/all_nodes/pxelinux.cfg</path>:
</p>

<pre caption="Setting up PXELinux">
# <i>cp /usr/lib/syslinux/pxelinux.0 /var/tftp/all_nodes</i>
# <i>mkdir /var/tftp/all_nodes/pxelinux.cfg</i>
</pre>

<p>
We need a separate directory for configuration files because every host can be
booted with a different configuration if you want. PXELinux' configuration
files are therefore named to the host that needs it. Because the only true
difference between all hosts is the IP address, you can probably understand that
the naming convention is based on the IP addresses.
</p>

<p>
The files inside <path>pxelinux.cfg</path> must be named after the IP address
(or IP subrange) they represent, but in hexadecimal notation. For instance,
192.168.1.100 is <path>C0A80164</path>. If multiple hosts share the same
configuration, you can use a configuration file named after the common IP
address range. For instance, all hosts with an IP address starting with
182.168.1 will use <path>C0A801</path>.
</p>

<p>
A host will therefore first look at its full IP address and then continue by
removing one hexadecimal character at a time until it finds a valid
configuration file: <path>C0A80164</path>, <path>C0A8016</path>,
<path>C0A801</path>, <path>C0A80</path>, <path>C0A8</path>, <path>C0A</path>,
<path>C0</path>, <path>C</path> and finally <path>default</path>.
</p>

</body>
</section>
<section>
<title>Writing the Configuration File</title>
<body>

<p>
The PXELinux configuration file is fairly straight-forward. On top of
the file you can define global options while beneith you are able to mention
kernel-specific options. PXELinux supports a few configuration variables.
We will mention only a couple. The first (and only) global variable that you
should know of is the <c>DEFAULT</c> instruction that informs PXELinux
which kernel to load.
</p>

<p>
The kernel-specific parts are easy and self-explanatory. A small note though
about the <c>label</c> instruction: each label can contain up to eight
characters before a period (if applicable) and three characters after the period
(the famous 8.3 DOS style).
</p>

<pre caption="An example PXELinux configuration">
default linux

label linux
  kernel  vmlinux-workstation-2.6.0
  append  root=/dev/hda1
</pre>

<p>
If you want to know more about PXE's abilities, please visit <uri
link="http://syslinux.zytor.com/pxe.php">Peter Avin's SYSLINUX Page</uri>. For
now we will leave the configuration "as is" and save the above configuration as
<path>/var/tftp/all_nodes/pxelinux.cfg/default</path>.
</p>

</body>
</section>
<section>
<title>Testing PXELinux</title>
<body>

<p>
Before we can test PXELinux, we need a kernel to boot the workstations with.
Assuming you already have a kernel, save it in <path>/var/tftp/all_nodes</path>
and rename it to what you have entered in the PXELinux configuration file
(<path>vmlinux-workstation-2.6.0</path> in the example). Then edit 
<path>dhcp.conf</path> to uncommend the <c>filename</c> instruction and have it
point to the <path>pxelinux.0</path> file. Note that <c>filename</c> is relative
to the TFTP path (<path>/var/tftp/all_nodes</path>):
</p>

<pre caption="Setting filename in /etc/dhcp.conf">
    filename "pxelinux.0";
</pre>

<p>
Now boot your workstation and watch the magic. 
</p>

</body>
</section>
</chapter>
<chapter>
<title>What are the Possibilities?</title>
<section>
<title>Introduction</title>
<body>

<p>
Now that you know how to netboot a workstation, you might wonder what the
possibilities are. The sky is the limit, but here are some interesting pointers
to possible implementations...
</p>

</body>
</section>
<section>
<title>Centralised Kernel Managment</title>
<body>

<p>
You are now able to maintain all kernels on a central server, which makes kernel
upgrades for the workstations easier. If you want you can also add initrd's to
your configurations making it easy for you to have the whole disk of the
workstation encapsulated in, for instance, EVMS.
</p>

</body>
</section>
<section>
<title>System Rescue from Network</title>
<body>

<p>
By using the files (kernel and initrd) of the <uri
link="http://www.sysresccd.org/">System Rescue CD</uri> you are able to boot any
workstation and perform full system analysis, create/replace backups using <uri
link="http://www.partimage.org">PartImage</uri> and more. 
</p>

</body>
</section>
</chapter>
</guide>
