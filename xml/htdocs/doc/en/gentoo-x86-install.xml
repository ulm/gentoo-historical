<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/en/gentoo-x86-install.xml">
<title>Gentoo Linux 1.4 Installation Instructions</title>
<author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Author">Chris Houser</author>
<author title="Author">Jerry Alexandratos</author>
<author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
</author>
<author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>
<author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
</author>
<author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
</author>
<author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
</author>
<author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
</author>
<author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
</author>
<author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
</author>
<author title="Editor">Colin Morey</author>
<author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor, Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
    <mail link="avenj@gentoo.org">Jon Portnoy</mail>
</author>
<author title="Editor">
     <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Reviewer">
    <mail link="gerrynjr@gentoo.org">Gerald J. Normandin Jr.</mail>
</author>
<author title="Reviewer">
    <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
</author>

<abstract>
These instructions step you through the process of installing Gentoo
Linux 1.4, release version (not _rc versions). The Gentoo Linux installation 
process supports various installation	approaches, depending upon how much of 
the system you want to custom-build from scratch.
</abstract>

<license/>

<version>2.6.4</version>
<date>8th of August 2003</date>

<chapter>
<title>About the Install</title>
<section>
<body>

<p>
First, if you are new to this, welcome to Gentoo Linux! Gentoo
Linux can be installed in many different ways. Those who are looking
for a rapid install can use pre-built packages, while those who want
the ultimate in customizability can compile Gentoo Linux entirely
from the original source code. The method you choose is up to
you.
</p>

<p>
One significant change in relation to the official 1.4 release is
our new 2-CD installation set, which can be ordered from <uri
link="http://store.gentoo.org">The Gentoo Linux Store</uri>, in
addition to being available on our mirrors. We currently have 2-CD
installation sets for x86 (486 and above), i686 (Pentium Pro,
Pentium II, Athlon/Duron and above), Pentium III, Pentium 4 and Athlon XP.
To see what 2-CD set is right for you, read the detailed
descriptions of each product in the <uri
link="http://store.gentoo.org">store</uri>. The store descriptions
contain fairly comprehensive CPU compatibility information.
</p>

<p>So, about the 2 CD set -- here's what's on each CD. The first
CD ("CD 1") is called "Live CD Installation" and is a bootable CD-ROM,
meaning that you can put "CD 1" in your drive and run Gentoo Linux
directly from the CD. You can then use this CD-based version of
Gentoo to install Gentoo Linux 1.4 to your hard disk. In addition
to containing a bootable Gentoo Linux environment, CD 1
contains everything you need to install Gentoo Linux quickly, even
without a connection to the Internet. In addition, several
pre-compiled packages are also included on CD 1, such as the
ever-important XFree86 X server. If you have an ISO CD-ROM image
file for CD 1, its name will end in "<path>-cd1.iso</path>".
</p>

<p>
In contrast, the second CD ("CD 2") isn't bootable and contains
lots of pre-built packages for your system. Included on this CD are
optimized versions of packages such as KDE, GNOME, OpenOffice,
Mozilla, Evolution and others. CD 2 is <e>optional</e> and is
intended for those people who are interested in installing Gentoo
Linux very quickly. The packages included on CD 2 typically take
about 36 hours to compile from source on a typical modern
single-processor system. If you have an ISO CD-ROM image file for CD
2, its name will end in "<path>-cd2.iso</path>".
</p>

<note>
A complete Gentoo Linux 2-CD set contains the Gentoo Reference
Platform, which is a complete pre-built Gentoo Linux system including GNOME,
KDE, Mozilla and OpenOffice. The Gentoo Reference Platform ("GRP")
was created to allow rapid Gentoo Linux package installations
for those who need this capability.  The "compile from
source" functionality, which is the cornerstone of Gentoo Linux,
will always be a fully-supported installation option as well. The
purpose of the GRP is to make Gentoo Linux more convenient for some
users, without impacting Gentoo's powerful "compile from source"
installation process in any way.
</note>

<p>
In addition to our 2-CD set, we also have a very small "basic"
Live CD that you can use to boot your system. Once your system has
booted, you can configure a connection to the Internet and then
install Gentoo over the network. The advantage of this "basic" CD is
that it is small and thus the ISO CD-ROM image file can be
downloaded quickly. If you're an advanced user who wants to install
the most up-to-date version of Gentoo Linux available and have a
fast network connection, then you may prefer this option. If you
have an ISO CD-ROM image file for our "basic" Live CD, its name will
end in "<path>-basic.iso</path>".
</p>
		
<p>
To use any Gentoo Linux CD-based installation method, you will
need to have a 486+ processor and ideally at least 64 Megabytes of
RAM. (Gentoo Linux has been successfully built with 64MB of RAM +
64MB of swap space, but the build process is awfully slow under
those conditions.)
</p>

<p>
Once you boot one of our Live CDs, you have even more options.
Gentoo Linux can be installed using one of three &quot;stage&quot;
tarball files. The one you choose depends on how much of the system
you want to compile yourself.  The stage1 tarball is used when you
want to bootstrap and build the entire system from scratch. The
stage2 tarball is used for building the entire system from a
bootstrapped "semi-compiled" state. The stage3 tarball already
contains a basic Gentoo Linux system that has been built for
you. If you are interested in doing a "GRP" install, then the
stage3 tarball should be used.
</p>

<p>
<b>If you're not doing a GRP install, should you start from a stage1, stage2, or
stage3 tarball?</b> Here is some information that should help you
make this decision.
</p>

<p>
Starting from a stage1 allows you to have total
control over the optimization settings and optional build-time
functionality that is initially enabled on your system. This makes
stage1 installs good for power users who know what they are doing.
It is also a great installation method for those who would like to 
know more about the inner workings of Gentoo Linux.
</p>

<p>
Stage2 installs allow you to skip the bootstrap process and doing
this is fine if you are happy with the optimization settings that we
chose for your particular stage2 tarball. 
</p>

<p>
And choosing to go with a stage3 allows for the fastest install of Gentoo 
Linux, but also means that your base system will have the optimization 
settings that we chose for you (which to be honest, are good settings and were
carefully chosen to enhance performance while maintaining
stability). Since major releases of Gentoo Linux have stage3's
specifically optimized for various popular processors, starting
from a stage3 can offer the best of all worlds -- a fast install
and a system that is well-optimized.
</p>

<p>
<b>If you're installing Gentoo Linux for the first time, consider using a 
stage3 tarball for installation, or a stage3 with GRP.</b>
</p>

<note>
<b>Advanced users:</b> If you use a stage3 install, you should not
change the default CHOST setting in <path>/etc/make.conf</path>. If you need 
to make such a change, you should start with a stage1 tarball and build up
your system with the desired CHOST setting. The CHOST setting
typically looks something like this: <c>i686-pc-linux-gnu</c>.
</note>

<impo>
If you encounter a problem with any part of the install and wish to
report it as a bug, report it to <uri>http://bugs.gentoo.org</uri>. If the bug
needs to be sent upstream to the original software developers (e.g. the KDE 
team) the <e>Gentoo Linux developers</e> will take care of that for you.
</impo>

<note>
The installation instructions in the LiveCD may not be as up-to-date as our 
Web documentation at <uri>http://www.gentoo.org/doc/en/gentoo-x86-install.xml</uri>. 
Refer to our Web documentation for the most up-to-date installation 
instructions.
</note>

<p>
Now, let us quickly review the install process. First, we will download, burn 
CD(s) and boot a LiveCD. After getting a root prompt, we will create 
partitions, create our filesystems and extract either a stage1, stage2 or 
stage3 tarball.  If we are using a stage1 or stage2 tarball, we will take 
the appropriate steps to get our system to stage3.  Once our system is at 
stage3, we can configure it (customize configuration files, install a boot 
loader, etc.), boot it and have a fully-functional Gentoo Linux system. After 
your basic Gentoo Linux system is running, you can optionally use "CD 2" of 
our 2-CD set and install any number of pre-built packages such as KDE, GNOME, 
OpenOffice, Mozilla, or others that you'd like on your system. 
</p>

<p>
Depending on what stage of the build process you're starting from, here is 
what is required for installation:
</p>

<table>
<tr>
 <th>Stage Tarball</th>
 <th>Internet Access Required</th>
 <th>Media Required</th>
 <th>Steps</th>
</tr>
<tr>
 <ti>1</ti>
 <ti>Yes</ti>
 <ti><e>basic</e> or <e>CD 1</e></ti>
 <ti>partition/filesystem setup, emerge sync, bootstrap, emerge system, final config</ti>
</tr>
<tr>
 <ti>2</ti>
 <ti>Yes</ti>
 <ti><e>basic</e> or <e>CD 1</e></ti>
 <ti>partition/filesystem setup, emerge sync, emerge system, final config</ti>
</tr>
<tr>
 <ti>3</ti>
 <ti>No if using <e>CD 1</e>, Yes otherwise</ti>
 <ti><e>basic</e> or <e>CD 1</e></ti>
 <ti>partition/filesystem setup, emerge sync (not required if using <e>CD 1</e>), final config</ti>
</tr>
<tr>
 <ti>3+GRP</ti>
 <ti>No</ti>
 <ti><e>CD 1</e>, <e>CD 2</e> optionally</ti>
 <ti>partition/filesystem setup, final config, install CD 1 pre-built packages (optional), reboot, install extra pre-built packages like KDE and GNOME (if using "CD 2")</ti>
</tr>
</table>

<note>
Hardware ATA RAID users should read the section about ATA RAID on the bottom 
of this document before proceeding.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Booting</title>
<section>
<body>

<warn>
Read this whole section before proceeding, especially the available boot 
options. Ignoring this could lead to wrong keyboard settings, unstarted 
pcmcia services etc..
</warn>

<p>
Start by booting your Live CD of choice. You should see a fancy
boot screen with the Gentoo Linux logo on it. At this screen, you
can hit Enter to begin the boot process, or boot the LiveCD with
custom boot options by specifying a kernel followed by boot options
and then hitting Enter. For example: <c>gentoo nousb nohotplug</c>.
If you are installing Gentoo Linux on a system with more than one
processor ("SMP"), then you should type <c>smp</c> instead of
<c>gentoo</c> at the prompt. This will allow the LiveCD to see all
the processors in your system, not just the first one.
</p>
		
<p>
Consult the following table for a partial list of available kernels and
options or press F2 and F3 to view the help screens.
</p>

<table>
<tr><th>Available kernels</th><th>Description</th></tr>
<tr><ti>gentoo</ti><ti>standard gentoo kernel (default)</ti></tr>
<tr><ti>nofb</ti><ti>framebuffer mode disabled</ti></tr>
<tr><ti>smp</ti><ti>loads a smp kernel in noframebuffer mode</ti></tr>
<tr><ti>acpi</ti><ti>enables acpi=on + loads acpi modules during init</ti></tr>
<tr><ti>memtest</ti><ti>boots the memory testing program</ti></tr>
</table>

<table>
<tr><th>Available boot options</th><th>Description</th></tr>
<tr><ti>doataraid</ti><ti>loads ide raid modules from initrd</ti></tr>
<tr><ti>dofirewire</ti><ti>modprobes firewire modules in initrd (for firewire cdroms,etc.)</ti></tr>
<tr><ti>dokeymap</ti><ti>enable keymap selection for non-us keyboard layouts</ti></tr>
<tr><ti>dopcmcia</ti><ti>starts pcmcia service</ti></tr>
<tr><ti>doscsi</ti><ti>scan for scsi devices (breaks some ethernet cards)</ti></tr>
<tr><ti>noapm</ti><ti>disables apm module load</ti></tr>
<tr><ti>nodetect</ti><ti>causes hwsetup/kudzu and hotplug not to run</ti></tr>
<tr><ti>nodhcp</ti><ti>dhcp does not automatically start if nic detected</ti></tr>
<tr><ti>nohotplug</ti><ti>disables loading hotplug service</ti></tr>
<tr><ti>noraid</ti><ti>disables loading of evms modules</ti></tr>
<tr><ti>nousb</ti><ti>disables usb module load from initrd, disables hotplug</ti></tr>
<tr><ti>ide=nodma</ti><ti>force disabling of dma for malfunctioning ide devices</ti></tr>
<tr><ti>cdcache</ti><ti>cache the entire runtime portion of cd in ram. This uses 40mb of RAM, but allows you to umount <path>/mnt/cdrom</path> and mount another cdrom</ti></tr>
</table>

<p>
Once you hit Enter, you will be greeted with an even fancier boot
screen and progress bar.
</p>

<!--
	<figure link="/images/install/livecd-1.4-boot.png" caption="The Gentoo
	Linux Live CD booting" />
-->

<p>
Once the boot process completes, you will be automatically logged in
to the "Live" Gentoo Linux as "<e>root</e>", the "super user". You should
have a root ("#") prompt on the current console and can also switch 
to other consoles by pressing Alt-F2, Alt-F3 and Alt-F4. Get back to the one 
you started on by pressing Alt-F1. 
</p>

<!--

	<figure link="/images/install/livecd-1.4-con.png" caption="The Gentoo
	Linux Live CD console" />
-->

<note>
<b>Advanced users:</b> When the Live CD boots, the Live CD root password is
set to a random string for security purposes. If you plan to start
<c>sshd</c> to allow remote logins to your Live CD, you should set the Live
CD root password now by typing <c>passwd</c> and following the prompts.
Otherwise, you will not know the proper password for logging into the Live
CD over the network. 
</note>

<p>
You've probably also noticed that above your # prompt is a bunch of 
help text that explains how to do things like configure your Linux networking 
and telling you where you can find the Gentoo Linux stage tarballs and packages
on your CD.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Optional hardware configuration</title>
<section>
<body>

<p>
When the Live CD boots, it tries to detect all your hardware
devices and loads the appropiate kernel modules to support your
hardware. In the vast majority of cases, it does a very good job. 
However, in some cases, it may not auto-load the kernel modules
you need. If the PCI auto-detection missed some of your system's hardware, you 
will have to load the appropriate kernel modules manually.
To view a list of all available network card modules, type <c>ls 
/lib/modules/`uname -r`/kernel/drivers/net/*</c>.  To load a particular module,
type:
</p>

<pre caption="PCI Modules Configuration">
# <i>modprobe pcnet32</i>
<comment>(replace pcnet32 with your NIC module)</comment>
</pre>

<p>
Likewise, if you want to be able to access any SCSI hardware that wasn't 
detected during the initial boot autodetection process, you will need to 
load the appropriate modules from <path>/lib/modules</path>, again using 
<c>modprobe</c>:
</p>

<pre caption="Loading SCSI Modules">
# <i>modprobe aic7xxx</i>
<comment>(replace aic7xxx with your SCSI adapter module)</comment>
# <i>modprobe sd_mod</i>
<comment>(sd_mod is the module for SCSI disk support)</comment>
</pre>

<note>
Support for SCSI CD-ROMs and disks are built-in in the kernel.
</note>

<note>
<b>Advanced users:</b> The Gentoo LiveCD should have enabled DMA
on your disks so that disk transfers are as fast as possible, but if it did not,
<c>hdparm</c> can be used to set DMA on your drives as follows:
<pre caption="Setting DMA">
<comment>(Replace hdX with your disk device)</comment>
# <i>hdparm -d 1 /dev/hdX</i> 
<comment>(Enables DMA)</comment>
# <i>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</i>
<comment>(Enables DMA and other safe performance-enhancing options)</comment>
# <i>hdparm -X66 /dev/hdX</i>
<comment>(Force-enables Ultra-DMA -- dangerous -- may cause some drives to mess up)</comment>
</pre>
</note>

			
</body>
</section>
</chapter>
<chapter>
<title>Optional Networking configuration</title>
<section>
<title>Maybe it just works?</title>
<body>

<p>
If your system is plugged into an Ethernet network, it is very
likely that your networking configuration has already been
set up automatically for you. If so, you should be able to take advantage of 
the many included network-aware commands on the LiveCD such as <c>ssh</c>, 
<c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> and <c>lynx</c>, among 
others.
</p>
	  
<p>
If networking has been configured for you, the <c>/sbin/ifconfig</c> command 
should list some internet interfaces besides lo, such as eth0:
</p>

<pre caption="/sbin/ifconfig for a working network card">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800 
</pre>

<p>
You may want to also try pinging your ISP's DNS server (found in 
<path>/etc/resolv.conf</path>) and a Web site of choice, just to make sure 
that your packets are reaching the net, DNS name resolution is working 
correctly, etc..
</p>

<pre caption="Further Network Testing">
# <i>ping -c 3 www.yahoo.com</i>
</pre>

<p>
Are you able to use your network? If so, you can skip the rest of this 
section.
</p>

</body>
</section>
<section>
<title>PPPoE configuration</title>
<body>

<p>
Assuming you need PPPoE to connect to the internet, the LiveCD (any version) 
has made things easy for you by including <c>rp-pppoe</c>. Use the provided 
<c>adsl-setup</c> script to configure your connection. You will be prompted 
for the ethernet device that is connected to your adsl modem, your username 
and password, the IPs of your DNS servers and if you need a basic firewall 
or not.
</p>

<pre caption="Configuring PPPoE">
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>

<p>
If something goes wrong, double-check that you correctly typed your username 
and password by looking at <path>/etc/ppp/pap-secrets</path> or	
<path>/etc/ppp/chap-secrets</path> and make sure you are using the right 
ethernet device.
</p>

</body>
</section>

<section>
<title>Automatic Network Configuration </title>
<body>

<p>
The simplest way to set up networking if it didn't get configured 
automatically is to run the <c>net-setup</c> script:
</p>

<pre caption="Net-Setup Script">
# <i>net-setup eth0</i>
</pre>

<p>
Of course, if you prefer, you may still set up networking manually. This is 
covered next.
</p>

</body>
</section>
<section>
<title>Manual DHCP Configuration</title>
<body>

<p>
Network configuration is simple with DHCP; If your ISP is not using
DHCP, skip down to the static configuration section below.
</p>

<pre caption="Network configuration with DHCP">
# <i>dhcpcd eth0</i>
</pre>

<note>
Some ISPs require you to provide a hostname.  To do that, add a 
<c>-h myhostname</c> flag to the dhcpcd command line above.
</note>

<p>
If you receive <e>dhcpConfig</e> warnings, don't panic; the errors are most 
likely cosmetic.  Skip down to Network testing below.
</p>

</body>
</section>
<section>
<title>Manual Static Configuration</title>
<body>

<p>
We need to setup just enough networking so that we can download	sources for 
the system build, as well as the required localhost interface. The needed 
information is explained in the next table.
</p>

<table>
<tr><th>Information</th><th>Description</th><th>Example value</th></tr>
<tr><ti>IP address</ti><ti>The IP address you want to assign to your network card</ti><ti>192.168.1.2</ti></tr>
<tr><ti>Broadcast address</ti><ti>The IP address which will broadcast the packets to all the hosts in the network</ti><ti>192.168.1.255</ti></tr>
<tr><ti>Network mask</ti><ti>The mask which is used together with the IP address to see what part of the address is for network-identification and host-identification</ti><ti>255.255.255.0</ti></tr>
<tr><ti>Gateway</ti><ti>The IP address of the computer which will forward the packets that are not meant for the local network (most of the time the computer which shares the internet connection)</ti><ti>192.168.1.1</ti></tr>
</table>

<p>
Type in the following commands, replacing <c>$IFACE</c> with your network 
interface (typically <c>eth0</c>), <c>$IPNUM</c> with your IP address, 
<c>$BCAST</c> with your broadcast address and <c>$NMASK</c> with your network 
mask.  For the <c>route</c> command, replace <c>$GTWAY</c> with your default 
gateway.
</p>

<pre caption="Static IP Network Configuration">
# <i>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</i>
</pre>

<p>
Now it is time to create the <path>/etc/resolv.conf</path> file so that name 
resolution (finding Web/FTP sites by name, rather than just by IP address) 
will work. You can use <c>nano -w /etc/resolv.conf</c> to create 
<path>/etc/resolv.conf</path>. <c>nano</c> is a small and easy-to-use 
editor.
</p>

<p>
Here is a template to follow for creating your <path>/etc/resolv.conf</path> 
file:
</p>

<pre caption="/etc/resolv.conf template">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>

<p>
Replace <c>10.0.0.1</c> and <c>10.0.0.2</c> with the IP addresses of your
primary and secondary DNS servers respectively.
</p>

</body>
</section>

<section>
<title>Proxy Configuration</title>
<body>

<p>
If you are behind a proxy, it could be necessary to configure your proxy 
before you continue. We will export some variables to set up the proxy 
accordingly.
</p>

<pre caption="Setting a Proxy">
<comment>If the proxy restricts HTTP traffic:</comment>
# <i>export http_proxy="machine.company.com:1234"</i>
<comment>If the proxy restricts FTP traffic:</comment>
# <i>export ftp_proxy="machine.company.com"</i>
<comment>If the proxy restricts RSYNC traffic:</comment>
# <i>export RSYNC_PROXY="machine.company.com"</i>
</pre>

</body>
</section>

<section>
<title>Networking is go!</title>
<body>

<p>
Networking should now be configured and usable.  You should be able to use the 
included <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> and <c>wget</c> 
commands to connect to other machines on your LAN or the Internet.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Setting your system's date and time</title>
<section>
<body>

<p>
Now you need to set your system's date and time. You can do this using the 
<c>date</c> command.
</p>

<pre caption="Setting your system's date">
# <i>date</i>
Thu Feb 27 09:04:42 CST 2003
<comment>(If your date is wrong, set your date with this next command)</comment>
# <i>date 022709042003</i>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Filesystems, partitions and block devices</title>
<section>
<title>Introduction to block devices</title>
<body>

<p>
In this section, we'll take a good look at disk-oriented aspects of Gentoo 
Linux and Linux in general, including Linux filesystems, partitions and block 
devices. Then, once you're familiar with the ins and outs of disks and 
filesystems, you'll be guided through the process of setting up partitions 
and filesystems for your Gentoo Linux installation.
</p>

<p>
To begin, I'll introduce "block devices".  The most famous block device is
probably the one that represents the first IDE drive in a Linux system:
</p>

<pre caption="/dev/hda, the block device representing the primary master IDE drive in your system">
/dev/hda
</pre>

<p>
If your system uses SCSI drives, then your first hard drive will be:
</p>

<pre caption="/dev/sda, the block device representing the first logical SCSI drive in your system">
/dev/sda
</pre>

<p>
The block devices above represent an <e>abstract</e> interface to the disk.
User programs can use these block devices to interact with your disk without
worrying about whether your drives are IDE, SCSI or something else.  The
program can simply address the storage on the disk as a bunch of contiguous,
randomly-accessible 512-byte blocks.
</p>

</body>
</section>
<section>
<title>Partitions and fdisk</title>
<body>

<p>
Under Linux, we create filesystems by using a special command called
<c>mkfs</c> (or <c>mke2fs</c>, <c>mkreiserfs</c>, etc.), specifying a particular
block device as a command-line argument.
</p>

<p>
However, although it is theoretically possible to use a "whole disk" block
device (one that represents the <e>entire</e> disk) like <path>/dev/hda</path> 
or <path>/dev/sda</path> to house a single filesystem, this is almost never 
done in practice.  Instead, full disk block devices are split up into smaller, 
more manageable block devices called "partitions".  Partitions are created 
using a tool called <c>fdisk</c>, which is used to create and edit the 
partition table that's stored on each disk.  The partition table defines 
exactly how to split up the full disk.
</p>

<p>
We can take a look at a disk's partition table by running <c>fdisk</c>,
specifying a block device that represents a full disk as an argument:
</p>

<note>
Alternate interfaces to the disk's partition table include <c>cfdisk</c>,
<c>parted</c> and <c>partimage</c>. We recommend <c>fdisk</c> because it's
more powerful and well known in the Unix/Linux world.
</note>

<pre caption="Starting up fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
or
</p>

<pre caption="Starting up fdisk to look at the partition table on /dev/sda">
# <i>fdisk /dev/sda</i>
</pre>

<impo>
Note that you should <e>not</e> save or make any changes to a disk's
partition table if any of its partitions contain filesystems that are in use or
contain important data.  Doing so will generally cause data on the disk to be
lost.
</impo>

<p>
Once in <c>fdisk</c>, you'll be greeted with a prompt that looks like this:
</p>

<pre caption="The fdisk prompt">
Command (m for help): 
</pre>

<p>
Type <c>p</c> to display your disk's current partition configuration:
</p>

<pre caption="An example partition configuration">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
This particular disk is configured to house seven Linux filesystems (each
with a corresponding partition listed as "Linux") as well as a swap partition
(listed as "Linux swap").
</p>

<p>
Notice the name of the corresponding partition block
devices on the left hand side, starting with <path>/dev/hda1</path> and going 
up to <path>/dev/hda9</path>. In the early days of the PC, partitioning 
software only allowed a maximum of four partitions (called "primary" 
partitions).  This was too limiting, so a workaround called <e>extended 
partitioning</e> was created.  An extended partition is very similar to a 
primary partition and counts towards the primary partition limit of four. 
However, extended partitions can hold any number of so-called <e>logical</e> 
partitions inside them, providing an effective means of working around the 
four partition limit.
</p>

<p>
All partitions <path>/dev/hda5</path> and higher are logical partitions. 
The numbers 1 through 4 are reserved for primary or extended partitions.
</p>

<p>
So, In our example, <path>/dev/hda1</path> through <path>/dev/hda3</path> are 
primary partitions. <path>/dev/hda4</path> is an extended partition that 
contains logical partitions <path>/dev/hda5</path> through 
<path>/dev/hda9</path>. You would never actually <e>use</e> 
<path>/dev/hda4</path> for storing any filesystems directly -- it simply
acts as a container for partitions <path>/dev/hda5</path> through 
<path>/dev/hda9</path>.
</p>

<p>
Also, notice that each partition has an "Id", also called a "partition
type".  Whenever you create a new partition, you should ensure that the
partition type is set correctly. '83' is the correct partition type for
partitions that will be housing Linux filesystems, '82' is the correct
partition type for Linux swap partitions and 'fd' is the recommended partition
type for Software RAID partitions. You set the partition type using the
<c>t</c> option in <c>fdisk</c>.  The Linux kernel uses the partition type
setting to auto-detect filesystems and swap devices on the disk at boot-time.
</p>

</body>
</section>

<section>
<title>Using fdisk to set up partitions</title>
<body>

<p>
Now that you've had your introduction to the way disk partitioning is
done under Linux, it's time to walk you through the process of setting up disk
partitions for your Gentoo Linux installation. After we walk you through the
process of creating partitions on your disk, your partition configuration will
look like this:
</p>

<pre caption="The partition configuration that you will have after following these steps">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>
In our suggested "newbie" partition configuration, we have three partitions.
The first one (<path>/dev/hda1</path>) at the beginning of the disk is a small
partition called a boot partition.  The boot partition's purpose is to hold all
the critical data related to booting -- GRUB boot loader information (if you
will be using GRUB) as well as your Linux kernel(s).  The boot partition gives
us a safe place to store everything related to booting Linux. During normal
day-to-day Gentoo Linux use, your boot partition should remain <e>unmounted</e>
for safety. If you are setting up a SCSI system, your boot partition will
likely end up being <path>/dev/sda1</path>.
</p> 

<p>
It's recommended to have boot partitions (containing everything necessary for
the boot loader to work) at the beginning of the disk.  While not necessarily
required anymore, it is a useful tradition from the days when the lilo boot
loader wasn't able to load kernels from filesystems that extended beyond disk
cylinder 1024. 
</p>

<p>
The second partition (<path>/dev/hda2</path>) is used to for swap space. The
kernel uses swap space as virtual memory when RAM becomes low. This partition,
relatively speaking, isn't very big either, typically somewhere around 512MB.
If you're setting up a SCSI system, this partition will likely end up
being called <path>/dev/sda2</path>.
</p>

<p>
The third partition (<path>/dev/hda3</path>) is quite large and takes up the 
rest of the disk. This partition is called our "root" partition and will be 
used to store your main filesystem that houses Gentoo Linux itself. On a SCSI 
system, this partition would likely end up being <path>/dev/sda3</path>.
</p>

<p>
Before we partition the disk, here's a quick technical overview of the
suggested partition and filesystem configuration to use when installing Gentoo
Linux:
</p>

<table>
<tr>
 <th>Partition</th>
 <th>Size</th>
 <th>Type</th>
 <th>example device</th>
</tr>
<tr>
 <ti>boot partition, containing kernel(s) and boot information</ti>
 <ti>32 Megabytes</ti>
 <ti>ext2/3 highly recommended (easiest); if ReiserFS then mount with <c>-o notail</c>. If you will be using ext3 or ReiserFS, you must add the size of the journal to the partitionsize; in these cases 64 Megabytes is recommended</ti>
 <ti><path>/dev/hda1</path></ti>
</tr>
<tr>
 <ti>swap partition (no longer a 128 Megabyte limit, now 2GB)</ti>
 <ti>Generally, configure a swap area that is between one and two times the size of the physical RAM in your system</ti>
 <ti>Linux swap</ti>
 <ti><path>/dev/hda2</path></ti>
</tr>
<tr>
 <ti>root partition, containing main filesystem (/usr, /home, etc.)</ti>
 <ti>&gt;=1.5 Gigabytes</ti>
 <ti>ReiserFS, ext3 recommended; ext2 ok</ti>
 <ti><path>/dev/hda3</path></ti>
</tr>
</table>

<p>
OK, now to create the partitions as in the example and table above. First,
enter fdisk by typing <c>fdisk /dev/hda</c> or <c>fdisk /dev/sda</c>,
depending on whether you're using IDE or SCSI. Then, type <c>p</c> to view your
current partition configuration.  Is there anything on the disk that you need
to keep? If so, <b>stop now</b>.  If you continue with these directions, <b>all
existing data on your disk will be erased</b>.
</p>

<impo>
Following these instructions below will cause all prior data on your disk
to <b>be erased</b>! If there is anything on your drive, please be sure that it
is non-critical information that you don't mind losing. Also make sure that you
<b>have selected the correct drive</b> so that you don't mistakenly wipe data
from the wrong drive.
</impo>

<p>
Now, it's time to delete any existing partitions. To do this, type <c>d</c>
and hit Enter. You will then be prompted for the partition number you would like
to delete. To delete a pre-existing <path>/dev/hda1</path>, you would type:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
The partition has been scheduled for deletion. It will no longer show up if
you type <c>p</c>, but it will not be erased until your changes have been
saved.  If you made a mistake and want to abort without saving your changes,
type <c>q</c> immediately and hit enter and your partition will not be
deleted.
</p>

<p>
Now, assuming that you do indeed want to wipe out all the partitions on your
system, repeatedly type <c>p</c> to print out a partition listing and then type
<c>d</c> and the number of the partition to delete it. Eventually, you'll end up
with a partition table with nothing in it:
</p>

<pre caption="An empty partition table">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Now that the in-memory partition table is empty, we're ready to create a
boot partition. To do this, type <c>n</c> to create a new partition, then
<c>p</c> to tell fdisk you want a primary partition. Then type <c>1</c> to
create the first primary partition. When prompted for the first cylinder, hit
enter. When prompted for the last cylinder, type <c>+32M</c> to create a
partition 32MB in size. You can see output from these steps below:
</p>

<note>
Journaled filesystems require extra space for their journal. Default settings 
require about 33 Megabytes of space. Therefore, if you are using a journaled 
filesystem for <path>/boot</path>, you should type <c>+64M</c> when prompted
for the last cylinder.
</note>

<pre caption="Steps to create our boot partition">
Command (m for help): <i>n</i>
Command action
e   extended
p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition 
printout:
</p>

<pre caption="Our first partition has been created">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Next, let's create the swap partition. To do this, type <c>n</c> to create a
new partition, then <c>p</c> to tell fdisk that you want a primary partition. 
Then type <c>2</c> to create the second primary partition, 
<path>/dev/hda2</path> in our case. When prompted for the first cylinder, 
hit enter. When prompted for the last cylinder, type <c>+512M</c> to create 
a partition 512MB in size. After you've done this, type <c>t</c> to set the 
partition type, <c>2</c> to select the partition you just created and then 
type in <c>82</c> to set the partition type to "Linux Swap". After completing 
these steps, typing <c>p</c> should display a partition table that looks 
similar to this:
</p>

<pre caption="Our swap partition has been created">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to
create a new partition, then <c>p</c> to tell fdisk that you want a primary
partition. Then type <c>3</c> to create the third primary partition,
<path>/dev/hda3</path> in our case.  When prompted for the first cylinder, 
hit enter. When prompted for the last cylinder, hit enter to create a 
partition that takes up the rest of the remaining space on your disk.  After 
completing these steps, typing <c>p</c> should display a partition table that 
looks similar to this:
</p>

<pre caption="Our root partition has been created">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

<p>
Finally, we need to set the "bootable" flag on our boot partition and then write
our changes to disk. To tag <path>/dev/hda1</path> as a "bootable" partition, 
type <c>a</c> at the menu and then type in <c>1</c> for the partition number. 
If you type <c>p</c> now, you'll now see that <path>/dev/hda1</path> has a 
<c>*</c> in the "Boot" column. Now, let's write our changes to disk. To do 
this, type <c>w</c> and hit enter. Your disk partitions are now properly 
configured for a Gentoo Linux install. 
</p>

<note>
If <c>fdisk</c> or <c>cfdisk</c> instruct you to do so, please reboot to
allow your system to detect the new partition configuration.
</note>

</body>
</section>

<section>
<title>Creating filesystems</title>
<body>

<p>
Now that the partitions have been created, it's time to set up filesystems on
the boot and root partitions so that they can be mounted and used to store 
data. We will also configure the swap partition to serve as swap storage.
</p>

<p>
Gentoo Linux supports a variety of different types of filesystems; each type has
its strengths and weaknesses and its own set of performance characteristics. 
Currently, we support the creation of ext2, ext3, XFS, JFS and ReiserFS 
filesystems.
</p>

<p>
ext2 is the tried and true Linux filesystem but doesn't have metadata
journaling, which means that routine ext2 filesystem checks at startup time can
be quite time-consuming. There is now quite a selection of newer-generation
<e>journaled</e> filesystems that can be checked for consistency very quickly
and are thus generally preferred over their non-journaled counterparts.
Journaled filesystems prevent long delays when you boot your system and your
filesystem happens to be in an <e>inconsistent</e> state.
</p>

<p>
ext3 is the journaled version of the ext2 filesystem, providing metadata
journaling for fast recovery in addition to other enhanced journaling modes
like full data and ordered data journaling. ext3 is a very good and reliable
filesystem. It offers generally decent performance under most conditions.
Because it does not extensively employ the use of "trees" in its internal
design, it doesn't scale very well, meaning that it is not an ideal choice for
very large filesystems, or situations where you will be handling very large
files or large quantities of files in a single directory. But when used within
its design parameters, ext3 is an excellent filesystem.
</p>

<p>
ReiserFS is a B*-tree based filesystem that has very good overall
performance and greatly outperforms both ext2 and ext3 when dealing with small
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales
extremely well and has metadata journaling.  As of kernel 2.4.18+, ReiserFS is
now rock-solid and highly recommended for use both as a general-purpose
filesystem and for extreme cases such as the creation of large filesystems, the
use of many small files, very large files and directories containing tens of
thousands of files. ReiserFS is the filesystem we recommend by default for all
non-boot partitions.
</p>

<p>
XFS is a filesystem with metadata journaling that is fully supported under
Gentoo Linux's <c>xfs-sources</c> kernel. It comes with a robust
feature-set and is optimized for scalability. We only recommend using this
filesystem on Linux systems with high-end SCSI and/or fibre channel storage and
a uninterruptible power supply. Because XFS aggressively caches in-transit data
in RAM, improperly designed programs (those that don't take proper precautions
when writing files to disk and there are quite a few of them) can lose a good
deal of data if the system goes down unexpectedly.
</p>  

<p>
JFS is IBM's high-performance journaling filesystem.  It has recently
become production-ready and there hasn't been a sufficient track record to
comment positively nor negatively on its general stability at this
point.
</p>

<p>
If you're looking for the most rugged journaling filesystem, use ext3.  If
you're looking for a good general-purpose high-performance filesystem with
journaling support, use ReiserFS;  both ext3 and ReiserFS are mature,
refined and recommended for general use.
</p>

<p>
Based on our example above, we will use the following commands to initialize
all our partitions for use:
</p>

<pre caption="Initializing our partitions (example)">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
We choose ext3 for our <path>/dev/hda1</path> boot partition because it is a
robust journaling filesystem supported by all major boot loaders. We used
<c>mkswap</c> for our <path>/dev/hda2</path> swap partition -- the choice is 
obvious here. And for our main root filesystem on <path>/dev/hda3</path> we 
choose ReiserFS, since it is a solid journaling filesystem offering excellent 
performance. Now, go ahead and initialize your partitions.
</p>

<p>
For your reference, here are the various <c>mkfs</c>-like commands available
during the installation process:
</p>

<p>
<c>mkswap</c> is the command that is used to initialize swap partitions:
</p>

<pre caption="Initializing Swap">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
You can use the <c>mke2fs</c> command to create ext2 filesystems:
</p>

<pre caption="Creating an ext2 Filesystem">
# <i>mke2fs /dev/hda1</i>
</pre>

<p>
If you would like to use ext3, you can create ext3 filesystems using
<c>mke2fs -j</c>:
</p>

<pre caption="Creating an ext3 Filesystem">
# <i>mke2fs -j /dev/hda3</i>
</pre>

<note>
You can find out more about using ext3 under Linux 2.4 at 
<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
</note>

<p>
To create ReiserFS filesystems, use the <c>mkreiserfs</c> command:
</p>

<pre caption="Creating a ReiserFS Filesystem">
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
To create an XFS filesystem, use the <c>mkfs.xfs</c> command:
</p>

<pre caption="Creating a XFS Filesystem">
# <i>mkfs.xfs /dev/hda3</i>
</pre>

<note>
You may want to add a couple of additional flags to the <c>mkfs.xfs</c> 
command: <c>-d agcount=3 -l size=32m</c>. The <c>-d agcount=3</c> command 
will lower the number of allocation groups. XFS will insist on using at 
least 1 allocation group per 4 GB of your partition, so, for example, if 
you have a 20 GB partition you will need a minimum agcount of 5. The 
<c>-l size=32m</c> command increases the journal size to 32 Mb, increasing 
performance.
</note>

<p>
To create JFS filesystems, use the <c>mkfs.jfs</c> command:
</p>

<pre caption="Creating a JFS Filesystem">
# <i>mkfs.jfs /dev/hda3</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Mount Partitions</title>
<section>
<body>

<p>
Now, we will activate our newly-initialized swap volume, since we may need 
the additional virtual memory that it provides later:
</p>

<pre caption="Activating Swap">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Next, we will create the <path>/mnt/gentoo/boot</path> mount point, 
and we will mount our filesystems to the mount points. Once our boot and 
root filesystems are mounted, any files we copy or create inside 
<path>/mnt/gentoo</path> will be placed on our new filesystems.
Note that if you are setting up Gentoo Linux with separate 
<path>/usr</path> or <path>/var</path> filesystems, these would get mounted to
<path>/mnt/gentoo/usr</path> and <path>/mnt/gentoo/var</path> respectively.
</p>

<impo>
If your <path>/boot</path> partition (the one holding the kernel) is ReiserFS, 
be sure to mount it	with the <c>-o notail</c> option so GRUB gets properly 
installed. Make sure that <c>notail</c> ends up in your new 
<path>/etc/fstab</path> boot partition entry, too.
We will get to that in a bit. If you are going to use LILO with ReiserFS, 
then the <c>-o notail</c> is not needed. It's always safe to specify the 
<c>-o notail</c> option with ReiserFS if you're not sure what to do.
</impo>

<pre caption="Creating Mount Points">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<impo>
If you are having problems mounting your boot partition with ext2, try using
<c>mount /dev/hXX /mnt/gentoo/boot -t ext2</c>
</impo>

</body>
</section>
</chapter>


<chapter>
<title>Stage tarballs and chroot</title>
<section>
<title>Selecting the desired stage tarball</title>
<body>

<p>
Now, you need to decide which one you would like to use as a
basis for the install if you haven't already. The stages on the Live CD are
in <path>/mnt/cdrom/stages/</path> and you can type <c>ls 
/mnt/cdrom/stages/</c> to see what's available on your CD.
</p>

<p>
<b>GRP users</b> should use the <path>stage3-xx-yy.tar.bz2</path> tarball.
</p>

<p>
If you would like to perform an install using a stage tarball that is
<e>not</e> on your CD (which will likely be the case if you're using our
"basic" Live CD), this is still possible, but you'll need to download the
stage you want using the following instructions. If you already have the stage
tarball you want to use (which most users will have), then proceed to the 
"Extracting the stage tarball" section.
</p>

<pre caption="Downloading Required Stages">
# <i>cd /mnt/gentoo</i>
<comment>Use lynx to get the URL for your tarball:</comment>
# <i>lynx http://gentoo.oregonstate.edu/releases/x86/1.4/</i>
<comment>Use <c>Up</c> and <c>Down</c> arrows keys (or the <c>TAB</c> key) to go to the right directory
Highlight the appropriate stage you want to download
Press <c>d</c> which will initiate the download
Save the file and quit the browser

<b>OR</b> use wget from the command line:</comment>
# <i>wget </i><comment>(insert URL to the required stage tarball here)</comment>
</pre>

</body>
</section>
<section>
<title>Extracting the stage tarball</title>
<body>

<p>
Now it is time to extract the compressed stage tarball of your choice to
<path>/mnt/gentoo/</path>. Remember, you only need to unpack <b>one</b> stage
tarball, either a stage1, stage2 or stage3.  So, if you wanted to perform a
stage3 install of Gentoo, then you would just unpack the stage3 tarball.
Unpack the stage tarball as follows:
</p>

<impo>
Be sure to use the <c>p</c> option with <c>tar</c>.  Forgetting to do this will
cause certain files to have incorrect permissions.
</impo>

<pre caption="Unpacking the Stages">
# <i>cd /mnt/gentoo</i>
<comment>Change "stage3" to "stage2" or "stage1" if you want to start from these stages instead.</comment>
<comment>If you downloaded your stage tarball, change the path below to begin with "/mnt/gentoo/"
instead of "/mnt/cdrom/stages/".</comment>
# <i>tar -xvjpf /mnt/cdrom/stages/stage3-*.tar.bz2</i>
</pre>

<p>
If you downloaded your stage tarball to <path>/mnt/gentoo</path>, you can now 
delete it by typing <c>rm /mnt/gentoo/stage*.tar.bz2</c>.
</p>

</body>
</section>

<section>
<title>GRP package/snapshot steps</title>
<body>

<impo>
The following instructions are for GRP users only.
</impo>

<p>
<b>GRP Users</b>: There is a Portage snapshot on the Live CD. You will
need to use this snapshot so that you can skip the <c>emerge sync</c> step
later in this document, since <c>emerge sync</c> requires a network
connection. Untar this snapshot as follows:
</p>

<pre caption="Using Portage snapshot">
<comment>Replace yyyymmdd with the datestamp in the filename.</comment>
# <i>tar -xvjf /mnt/cdrom/snapshots/portage-yyyymmdd.tar.bz2 -C /mnt/gentoo/usr</i>
</pre>

<p>
This will extract a snapshot of the Portage tree to your fresh Gentoo
install. Now you won't need to connect to the Internet and use <c>emerge
sync</c> to download a Portage tree. Now, copy distfiles and packages
from the Live CD into place:
</p>

<pre caption="Copying GRP files">
# <i>cp -R /mnt/cdrom/distfiles /mnt/gentoo/usr/portage/distfiles</i>
# <i>cp -a /mnt/cdrom/packages/ /mnt/gentoo/usr/portage/packages/</i>
</pre>

<p>
All relevant files are now in place for using GRP. You should now have
everything copied over and unpacked that you'll need to install Gentoo Linux
-- even without a network connection.
</p>

</body>
</section>

<section>
<title>Selecting Mirrors (Optional)</title>
<body>

<p>
<c>mirrorselect</c> is a tool designed to automatically pick the fastest
mirrors based on your location, or manually pick a mirror from a list. 
Unfortunately, <c>mirrorselect</c> does not work well behind all routers.
</p>

<pre caption="Using mirrorselect">
<comment>To select a mirror automatically:</comment>
# <i>mirrorselect -a -s4 -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
<comment>To select a mirror interactively:</comment>
# <i>mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
If for some reason <c>mirrorselect</c> fails you should be able to
continue with this guide since no changes are made.
</p>

</body>
</section>
<section>
<title>Entering the chroot</title>
<body>

<p>
Next, we will <c>chroot</c> over to the new Gentoo Linux build installation to 
"enter" the new Gentoo Linux system:
</p>

<note>
You may receive a notice during <c>env-update</c> telling you that 
<path>/etc/make.profile/make.defaults</path> isn't available: ignore it. We are 
going to issue <c>emerge sync</c> later on in this document, which will resolve 
the problem.
</note>

<pre caption="Prepping and entering the chroot environment">
# <i>mount -t proc proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
Regenerating /etc/ld.so.cache...
# <i>source /etc/profile</i>
<comment>(The above points your shell to the new paths and updated binaries)</comment>
</pre>

<p>
After you execute these commands, you will be "inside" your new Gentoo Linux 
environment in <path>/mnt/gentoo</path>. We can perform the rest of the 
installation process inside the chroot.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Getting the Current Portage Tree using sync</title>
<section>
<body>

<impo>
If you are doing a GRP install then you can ignore the following section on
<c>emerge sync</c>.
</impo>

<p>
Now, you will need to run <c>emerge sync</c>. This command tells Portage
to download the most recent copy of the Gentoo Linux Portage tree from the
Internet. If you extracted a Portage tree snapshot from <e>CD 1</e> earlier, 
you can safely skip this step.  The Portage tree contains all the scripts
(called ebuilds) used to build every package under Gentoo Linux. Currently,
we have ebuild scripts for close to 4000 packages. Once <c>emerge sync</c>
completes, you will have a complete Portage tree in
<path>/usr/portage</path>:
</p>

<pre caption="Updating Using sync">
# <i>emerge sync</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Setting Gentoo optimizations (make.conf)</title>
<section>
<body>

<p>
Now that you have a working copy of the Portage tree, it is time to
customize the optimization and optional build-time settings to use on your
Gentoo Linux system. Portage will use these settings when compiling any
programs for you. To do this, edit the file <path>/etc/make.conf</path>.  In
this file, you should set your USE flags, which specify optional
functionality that you would like to be built into packages if available;
generally, the defaults (an <e>empty</e> or unset USE variable) are
fine.  More information on USE flags can be found <uri
link="http://www.gentoo.org/doc/en/use-howto.xml">here</uri>.  A complete list
of current USE flags can be found <uri
link="http://www.gentoo.org/dyn/use-index.xml">here</uri>.  
</p>

<p>
If you are starting from a stage1 tarball, You also should set appropriate 
CHOST, CFLAGS and CXXFLAGS settings for the kind of system that you are 
creating (commented examples can be found further down in the file). If you 
are using a stage2 or stage3 tarball, these settings will already be configured
optimally and should not require any modification.
</p>

<impo>
<b>Advanced users:</b> The CFLAGS and CXXFLAGS settings are used to tell the 
C and C++ compiler how to optimize the code that is generated on your system. 
It is common for users with Athlon XP processors to specify a 
"-march=athlon-xp" setting in their CFLAGS and CXXFLAGS settings so that all 
packages built will be optimized for the instruction set and performance 
characteristics of their CPU, for example. The <path>/etc/make.conf</path>
file contains a general guide for the proper settings of CFLAGS and CXXFLAGS.
</impo>

<!-- needs qa
<note>
<b>Advanced users:</b>If you are building from a stage1 and don't want
to manually configure CFLAGS and CXXFLAGS, you can use the <c>genflags</c>
utility, which will try to guess accurate flags for your CPU architecture.
Simply type <c>emerge -O genflags</c> and then execute
<c>info2flags</c>. <c>info2flags</c> will suggest CHOST, CFLAGS and
CXXFLAGS settings, which you can then add to
<path>/etc/make.conf</path>.
</note>
-->

<p>
If necessary, you can also set proxy information here if you are behind a 
firewall. Use the following command to edit <path>/etc/make.conf</path> 
using <c>nano</c>, a simple visual editor:
</p>

<pre caption="Setting make.conf Options">
# <i>nano -w /etc/make.conf</i>
</pre>

<note>
<b>Advanced users:</b> People who need to substantially customize the build 
process should take a look at the <path>/etc/make.globals</path> file. This 
file comprises gentoo defaults and should never be touched. If the defaults 
do not suffice, then new values should be put in <path>/etc/make.conf</path>, 
as entries in <path>make.conf</path> <e>override</e> the entries 
in <path>make.globals</path>.  If you're interested in customizing USE 
settings, look in <path>/etc/make.profile/make.defaults</path>.
If you want to turn off any USE settings found here, add an appropriate 
<c>USE="-foo"</c> in <path>/etc/make.conf</path> to turn off any <c>foo</c> 
USE setting enabled by default in <path>/etc/make.globals</path> or 
<path>/etc/make.profile/make.defaults</path>.
</note>

<warn>
Make sure not to add '<c>static</c>' to your USE variables until after 
stage1.
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Starting from Stage1</title>
<section>
<body>

<note>
If you are not starting from a stage1 tarball, skip this section.
</note>

<p>
The stage1 tarball is for complete customization and optimization. If you 
have picked this tarball, you are most likely looking to have an 
uber-optimized and up-to-date system. Have fun! Installing from a stage1 
takes a lot of time, but the result is a system that has been optimized 
from the ground up for your specific machine and needs.
</p>

<p>
Now, it is time to start the "bootstrap" process.  This process takes 
about two hours on a 1200MHz AMD Athlon system. During this time, the GNU 
C library, compiler suite and other key system programs will be built. Start 
the bootstrap as follows:
</p>

<pre caption="Bootstrapping">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>

<p>
The "bootstrap" process will now begin.
</p>

<note>
<c>bootstrap.sh</c> now supports the <c>--fetchonly</c> option. Dial-up 
users will find this especially handy. It will download all bootstrap related 
files in one go for later compilation. See <c>bootstrap.sh -h</c> for more 
information.
</note>

<note>
Portage by default uses <path>/var/tmp</path> during package building, 
often using several hundred megabytes of temporary storage. If you would 
like to change where Portage stores these temporary files, set a new 
PORTAGE_TMPDIR <e>before</e> starting the bootstrap process, as follows:
<pre caption="Changing Portage's Storage Path">
# <i>export PORTAGE_TMPDIR="/otherdir/tmp"</i>
</pre>
</note>

<p>
<c>bootstrap.sh</c> will build <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,
and <c>glibc</c>, rebuilding <c>gettext</c> after <c>glibc</c>. Needless to 
say, this process takes a while. Once this process completes, your system 
will be equivalent to a "stage2" system, which means you can now move on to 
the stage2 instructions.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Starting from Stage2 and continuing Stage1</title>
<section>
<body>

<note>
This section is for those continuing a stage1 install or starting at stage2. If
this is not you (ie. you're using a stage3), then skip this section.
</note>

<warn>
If you start from stage2, don't change the CHOST variable in
<path>/etc/make.conf</path>. Doing so results in strange and
broad compilation failures.
</warn>
		
<p>
The stage2 tarball already has the bootstrapping done for you. All that you 
have to do is install the rest of the system:
</p>

<note>
If you are starting from a pre-built stage2 and want to ensure
that your compiler toolchain is fully up-to-date, add the <c>-u</c>
option to the commands below. If you don't know what this means, it's
safe to skip this suggestion.
</note>

<pre caption="Installing the rest of the system">
# <i>emerge -p system</i>
<comment>(lists the packages to be installed)</comment>
# <i>emerge system</i>
</pre>

<p>
It is going to take a while to finish building the entire base system.  
Your reward is that it will be thoroughly optimized for your system.  
The drawback is that you have to find a way to keep yourself occupied for 
some time to come.  The author suggests "Star Wars - Super Bombad Racing"
for the PS2.
</p>

<p>
Building is now complete. Go ahead and skip down to the "Setting
your time zone" section.
</p>

</body>
</section>
</chapter>


<chapter>
<title>Starting from Stage3</title>
<section>
<body>

<note>
This section is for those <b>starting</b> with stage3 and not for those who 
have started with stage1 or stage2 who should skip this section. GRP users 
should skip ahead to the next section.
</note>

<warn>
Remember, if you start from stage3, don't change the CHOST variable in
<path>/etc/make.conf</path>. Doing so can result in compilation failures.
</warn>

<p>
The stage3 tarball provides a fully-functional basic Gentoo system,
so no building is required.
</p>
	 
<note>
<b>Advanced users:</b> However, since the stage3 tarball is pre-built, it 
may be slightly out-of-date. If this is a concern for you, you can 
automatically update your existing stage3 to contain the most up-to-date 
versions of all system packages by typing <c>export CONFIG_PROTECT="-* 
/etc/make.conf" emerge -u system</c> (this requires a network connection). 
Note that this could take a long time if your stage3 is very old;
otherwise, this process will generally be quick and will allow you to benefit 
from the very latest Gentoo updates and fixes. In any case, feel free to skip 
these steps and proceed to the next section if you like.
</note>
		
</body>
</section>
</chapter>


<chapter>
<title>Setting your time zone</title>
<section>
<body>

<p>
Now you need to set your time zone.
</p>

<p>
Look for your time zone (or GMT if you are using Greenwich Mean Time)
in <path>/usr/share/zoneinfo</path>. Then, make a symbolic link to
<path>/etc/localtime</path> by typing:
</p>

<pre caption="Creating a symbolic link for time zone">
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Modifying /etc/fstab for your machine</title>
<section>
<body>

<impo>
To edit files, remember to use <c>nano -w "filename"</c>.
</impo>

<p>
Your Gentoo Linux system is almost ready for use.  All we need to do now is 
configure a few important system files and install the boot loader. 
The first file we need to configure is <path>/etc/fstab</path>.  Remember 
that you should use the <c>notail</c> option for your boot partition if 
you chose to create a ReiserFS filesystem on it. Remember to specify 
<c>ext2</c>, <c>ext3</c> or <c>reiserfs</c> filesystem types as appropriate.
</p>

<p>
Use something like the <path>/etc/fstab</path> listed below, but of course be 
sure to replace "BOOT", "ROOT" and "SWAP" with the actual block devices you 
are using (such as <c>hda1</c>, etc.):
</p>

<pre caption="Editing fstab">
<comment># /etc/fstab: static file system information.
#
# noatime turns off atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It is safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>

<warn>
Please notice that <path>/boot</path> is <e>not</e> mounted at boot time. This 
is to protect the data in <path>/boot</path> from corruption. If you need to 
access <path>/boot</path>, please mount it!
</warn>

</body>
</section>
</chapter>


<chapter>
<title>Installing the kernel and system logger</title>
<section>
<title>Kernel selections</title>
<body>
	
<p>
There are two options for installing a kernel. You can either configure your 
own kernel or use the <c>genkernel</c> utility to configure and compile your 
kernel automatically.
</p>
	
<p>
Whether configuring a kernel by hand or using <c>genkernel</c>,
you'll need to merge the Linux kernel sources you'd like to use.  
Gentoo provides several kernel ebuilds; a list can be found 
<uri link="/doc/en/gentoo-kernel.xml">here</uri>. If you are uncertain
which kernel sources to choose, we advise using <c>gentoo-sources</c>.
If you want XFS support, you should choose <c>xfs-sources</c> or 
<c>gs-sources</c>. Gentoo's LiveCD uses <c>gs-sources</c> and 
<c>xfs-sources</c>. There is also a <c>gaming-sources</c> kernel optimized 
for game-playing responsiveness that works wonderfully for this purpose when 
the "Preemptible kernel" option is enabled.
</p>

<p>
Choose a kernel and then merge as follows:
</p>

<pre caption="Emerging Kernel Sources">
# <i>emerge -k sys-kernel/gentoo-sources</i>
</pre>

<p>
The <path>/usr/src/linux</path> symbolic link will point to your
newly-installed kernel source tree. Portage uses the 
<path>/usr/src/linux</path> symbolic link for a special purpose. Any ebuilds 
you install that contain kernel modules will be configured to work with the 
kernel source tree pointed to by <path>/usr/src/linux</path>. 
<path>/usr/src/linux</path> is created when you emerge your first kernel 
source package, but after it exists, Portage does not modify this symbolic 
link.
</p>

</body>
</section>
<section>
<title>Using genkernel to compile your kernel</title>
<body>

<p>
Now that your kernel source tree is installed, it's now time to compile your 
kernel. There are two ways to do this. The first way is to use our new 
<c>genkernel</c> script to automatically build a kernel for you. 
<c>genkernel</c> works by configuring a kernel nearly identically to the way 
our LiveCD kernel is configured. This means that when you use <c>genkernel</c> 
to build your kernel, your system will generally detect all your hardware at 
boot-time, just like our Live CD does. Because genkernel doesn't require any 
manual kernel configuration, it is an ideal solution for those users who may 
not be comfortable compiling their own kernels.
</p>

<p>
Now, let's see how to use genkernel. First, emerge the genkernel ebuild:
</p>

<pre caption="Emerging genkernel">
# <i>emerge -k genkernel</i>
</pre>
		
<p>
Now, compile your kernel sources by running <c>genkernel</c>:
</p>

<note>
<b>Advanced users:</b> you can type <c>genkernel --config</c> instead,
which will cause genkernel to allow you to tweak the default kernel 
configuration before building begins.
</note>

<pre caption="Running genkernel">
<comment>If you're using genkernel 1.2 (included in the 1.4-20030803 x86/i686 GRP set), use the following:</comment>
# <i>genkernel gentoo-sources</i>
<comment>If you're using genkernel 1.4 or newer, there's no need to specify a kernel:</comment>
# <i>genkernel</i>
Gentoo Linux genkernel, version 1.4
Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
Distributed under the GNU General Public License version 2

Settings:
compile optimization: 1 processor(s)
source tree: /usr/src/linux-2.4.20-gaming-r3
config: gentoo (customized)
config loc: /etc/kernels/config-2.4.20-gaming-r3
initrd config: (default) /etc/kernels/settings

* Running "make oldconfig"...                                                                     [ ok ]
* Logging to /var/log/genkernel.log...                                                            [ ok ]
* Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
* Running "make dep"...                                                                           [ ok ]
* Running "make bzImage"...                                                                       [ ok ]
* Running "make modules"...                                                                       [ ok ]
* Running "make modules_install"...                                                               [ ok ]
* Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
* Building busybox...                                                                             [ ok ]
* Creating initrd...                                                                              [ ok ]

* Build completed successfully!

* Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
* when customizing your boot loader configuration files.
</pre>

<p>
Once <c>genkernel</c> completes, a kernel, full set of modules and 
<e>initial root disk</e> (initrd) will be created. We will use the kernel 
and initrd when configuring a boot loader later in this document. The
initrd will be started immediately after booting to perform hardware 
autodetection (just like on the Live CD) before your "real" system starts 
up.
</p>

<p>
Now, let's perform one more step to get our system to be more like the Live 
CD -- let's emerge <c>hotplug</c>. While the initrd autodetects hardware that 
is needed to boot your system, <c>hotplug</c> autodetects everything else.
To emerge and enable <c>hotplug</c>, type the following:
</p>

<pre caption="Emerging and enabling hotplug">
# <i>emerge -k hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

<p>
Finally, you should emerge ebuilds for any additional hardware that is on 
your system. Here is a list of kernel-related ebuilds that you could emerge:
</p>

<table>
<tr>
 <th>Ebuild</th>
 <th>Purpose</th>
 <th>Command</th>
</tr>
<tr>
 <ti>nvidia-kernel</ti>
 <ti>Accelerated NVIDIA graphics for XFree86</ti>
 <ti><c>emerge -k nvidia-kernel</c></ti>
</tr>
<tr>
 <ti>nforce-net</ti>
 <ti>On-board ethernet controller on NVIDIA NForce(2) motherboards</ti>
 <ti><c>emerge nforce-net</c></ti>
</tr>
<tr>
 <ti>nforce-audio</ti>
 <ti>On-board audio on NVIDIA NForce(2) motherboards</ti>
 <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
 <ti>e100</ti>
 <ti>Intel e100 Fast Ethernet Adapters</ti>
 <ti><c>emerge e100</c></ti>
</tr>
<tr>
 <ti>e1000</ti>
 <ti>Intel e1000 Gigabit Ethernet Adapters</ti>
 <ti><c>emerge e1000</c></ti>
</tr>
<tr>
 <ti>emu10k1</ti>
 <ti>Creative Sound Blaster Live!/Audigy support</ti>
 <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
 <ti>ati-drivers</ti>
 <ti>Accelerated ATI Radeon 8500+/FireGL graphics for XFree86</ti>
 <ti><c>emerge ati-drivers</c></ti>
</tr>
<tr>
 <ti>xfree-drm</ti>
 <ti>Accelerated graphics for ATI Radeon up to 9200, Rage128, Matrox, Voodoo and other cards for XFree86</ti>
 <ti><c>VIDEO_CARDS="yourcard" emerge xfree-drm</c></ti>
</tr>
</table>

<p>
The <c>nvidia-kernel</c>, <c>ati-drivers</c> and <c>xfree-drm</c> packages 
will require additional configuration to be enabled. All other ebuilds listed 
above should be auto-detected at boot-time by the <c>hotplug</c> package.
</p>
		
<p>
Now that you've run and configured your system to use <c>genkernel</c>, you 
can skip the "manual kernel configuration" section below.
</p>

</body>
</section>
<section>
<title>Manual kernel configuration</title>
<body>

<p>
If you opted not to use genkernel to compile your kernel, this section
will guide you through the process of configuring and compiling a kernel by
hand.	Please note that <path>/usr/src/linux</path> is a symlink to your
current emerged kernel source package and is set automatically by Portage at
emerge time.  If you have multiple kernel source packages, it is necessary to
set the <path>/usr/src/linux</path> symlink to the correct one before
proceeding.
</p>

<warn>
If you are configuring your own kernel, be careful with the <i>grsecurity</i> 
option. Being too aggressive with your security settings can cause certain 
programs (such as X) to not run properly. If in doubt, leave it out.
</warn>

<note>
If you want to use the same configuration as the LiveCD kernel or base
your configuration on it, you should execute <c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c>. 
If you aren't using <c>xfs-sources</c>, this will ask some questions 
about differences between your kernelchoice and <c>xfs-sources</c>.
</note>

<pre caption="Configuring the Linux Kernel">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<warn>
For your kernel to function properly, there are several options that you will
need to ensure are in the kernel proper -- that is, they should <e>be enabled 
and not compiled as modules</e>. Be sure to enable &quot;ReiserFS&quot; if you 
have any ReiserFS partitions; the same goes for &quot;Ext3&quot;.  If you're 
using XFS, enable the &quot;SGI XFS filesystem support&quot; option.  It's 
always a good idea to leave ext2 enabled whether you are using it or not.
</warn>

<p>
Below are some common options that you will need:
</p>

<pre caption="make menuconfig options">
Code maturity level options ---&gt;
[*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(You need this to enable some of the options below)</comment>
...

File systems ---&gt;
&lt;*&gt; Reiserfs support
<comment>(Only needed if you are using reiserfs)</comment>
... 
&lt;*&gt; Ext3 journalling file system support
<comment>(Only needed if you are using ext3)</comment>
...
[*] Virtual memory file system support (former shm fs)
<comment>(Required for Gentoo Linux)</comment>
...
&lt;*&gt; JFS filesystem support
<comment>(Only needed if you are using JFS)</comment>
...
[*] /proc file system support
<comment>(Required for Gentoo Linux)</comment>
[*] /dev file system support (EXPERIMENTAL)
[*]   Automatically mount at boot          
<comment>(Required for Gentoo Linux)</comment>
[ ] /dev/pts file system for Unix98 PTYs
<comment>(Uncheck this, it is NOT needed)</comment>
...
&lt;*&gt; Second extended fs support
<comment>(Only needed if you are using ext2)</comment>
...
&lt;*&gt; XFS filesystem support
<comment>(Only needed if you are using XFS)</comment>
</pre>

<p>
If you use PPPoE to connect to Internet, you will need the following
options in the kernel (built-in or as preferably as modules) : &quot;PPP 
(point-to-point protocol) support&quot;, &quot;PPP support for async serial 
ports&quot;, &quot;PPP support for sync tty ports&quot;. The two compression 
options won't harm but are not definitely needed, neither does the &quot;PPP 
over Ethernet&quot; option, that might only be used by <c>rp-pppoe</c> when 
configured to do kernel mode PPPoE.
</p>

<p>
If you have an IDE cd burner, then you need to enable SCSI emulation in the
kernel.  Turn on &quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA 
and ATAPI Block devices&quot; ---&gt; &quot;SCSI emulation support&quot; 
(I usually make it a module), then under &quot;SCSI support&quot; enable 
&quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; and &quot;SCSI 
generic support&quot; (again, I usually compile them as modules).  If you
also choose to use modules, then <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot;
&gt;&gt; /etc/modules.autoload</c> to have them automatically added at boot 
time. 
</p>

<p>
If you require it, don't forget to include support in the kernel for your 
ethernet card.
</p>

<note>
For those who prefer it, it is possible to install Gentoo Linux with a 2.2 
kernel.	However, doing this comes at a price: you will lose many of the nifty 
features that are new to the 2.4 series kernels (such as XFS and tmpfs
filesystems, iptables and more), although the 2.2 kernel sources can be
patched with ReiserFS and devfs support.  
Gentoo linux boot scripts require either tmpfs or ramdisk support in the 
kernel, so 2.2 kernel users need to make sure that ramdisk support is compiled 
in (ie, not a module). It is <comment>vital</comment> that a 
<e>gentoo=notmpfs</e> flag be added to the kernel line in 
<path>/boot/grub/grub.conf</path> or to the append line in 
<path>/etc/lilo.conf</path> for the 2.2 kernel so that a ramdisk is mounted 
for the boot scripts instead of tmpfs.  If you choose not to use devfs, then
<e>gentoo=notmpfs,nodevfs</e> should be used instead.
</note>

<pre caption = "Compiling and Installing the kernel">
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
</pre>

</body>
</section>
<section>
<title>Installing a system logger</title>
<body>

<p>
Your new custom kernel (and modules) are now installed.  Now you need to choose
a system logger that you would like to install.  We offer sysklogd, which is 
the traditional set of system logging daemons.  We also have msyslog and 
syslog-ng as well as metalog.  Power users seem to gravitate away from 
sysklogd (not very good performance) and towards the newer alternatives.  
If in doubt, you may want to try metalog, since it seems to be quite popular.
To merge your logger of choice, type <e>one</e> of the next four command
sets:
</p>

<pre caption="Emerging System Logger of Choice">
# <i>emerge -k app-admin/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>or</comment>
# <i>emerge -k app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>or</comment>
# <i>emerge -k app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>or</comment>
# <i>emerge -k app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>

<impo>
Metalog flushes output to the disk in blocks, so messages aren't immediately 
recorded into the system logs.  If you are trying to debug a daemon, this 
performance-enhancing behavior is less than helpful.  When your Gentoo Linux 
system is up and running, you can send metalog a USR1 signal to temporarily 
turn off this message buffering (meaning that <c>tail -f 
<path>/var/log/everything/current</path></c> will now work in real time, as 
expected) and a USR2 signal to turn buffering back on again. If you want to 
disable buffering permanently, you can change METALOG_OPTS="-B" to 
METALOG_OPTS="-B -s" in <path>/etc/conf.d/metalog</path>. 
<pre caption="Turning metalog buffering on/off">
<codenote>To turn the buffering off:</codenote>
# <i>killall -USR1 metalog</i>
<codenote>To turn the buffering back on:</codenote>
# <i>killall -USR2 metalog</i>
</pre>
</impo>

<p>
Now, you may optionally choose a cron package that you would like to use.
Right now, we offer dcron, fcron and vcron. If you do not know which one to 
choose, you might as well grab vcron.
</p>

<pre caption="Choosing a CRON Daemon">
# <i>emerge -k sys-apps/dcron</i>
# <i>rc-update add dcron default</i>
# <i>crontab /etc/crontab</i>
<comment>or</comment>
# <i>emerge -k sys-apps/fcron</i>
# <i>rc-update add fcron default</i>
# <i>crontab /etc/crontab</i>
<comment>or</comment>
# <i>emerge -k sys-apps/vcron</i>
# <i>rc-update add vcron default</i>
<comment>You do not need to run <i>crontab /etc/crontab</i> if using vcron.</comment>
</pre>

<p>
For more information on starting programs and daemons at startup, see the
<uri link="/doc/en/rc-scripts.xml">rc-script guide</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Installing miscellaneous necessary packages</title>
<section>
<body>

<p>
If you need rp-pppoe to connect to the net, be aware that at this point
it has not been installed. It would be the good time to do it:
</p>

<pre caption="Installing rp-pppoe">
# <i>USE="-X" emerge rp-pppoe</i>
<comment>GRP users should type the following:</comment>
# <i>USE="-X bindist" emerge -K rp-pppoe</i>
</pre>

<note>
The <i>USE="-X"</i> prevents pppoe from installing its optional X interface, 
which is a good thing, because X and its dependencies would also be emerged. 
You can always recompile <i>rp-pppoe</i> with X support later.
</note>

<note>
Please note that the rp-pppoe is built but not configured. You will have to 
do it again using <c>adsl-setup</c> when you boot into your Gentoo system 
for the first time.
</note>

<p>
You may need to install some additional packages in the Portage tree
if you are using any optional features like XFS, ReiserFS or LVM.  If you're
using XFS, you should emerge the <c>xfsprogs</c> package: 
</p>

<pre caption="Emerging Filesystem Tools">
# <i>emerge -k sys-apps/xfsprogs</i>
<comment>If you would like to use ReiserFS, you should emerge the ReiserFS tools: </comment>
# <i>emerge -k sys-apps/reiserfsprogs</i>
<comment>If you would like to use JFS, you should emerge the JFS tools: </comment>
# <i>emerge -k jfsutils</i>
<comment>If you're using LVM, you should emerge the <c>lvm-user</c> package: </comment>
# <i>emerge -k sys-apps/lvm-user</i>
</pre>

<p>
If you're a laptop user and wish to use your PCMCIA slots on your first
real reboot, you will want to make sure you install the <i>pcmcia-cs</i> 
package.
</p>

<pre caption="Emerging PCMCIA-cs">
# <i>emerge -k sys-apps/pcmcia-cs</i>
</pre>

<!-- fix the bug or fix the docs, don't send the user in circles
(drobbins)
		<warn>You will have to re-emerge <i>pcmcia-cs</i> after installation to get PCMCIA
			to work.
			</warn>
	-->

</body>
</section>
</chapter>

<chapter>
<title>User Management</title>
<section>
<title>Setting a root password</title>
<body>

<p>
Before you forget, set the root password by typing:
</p>

<pre caption="Setting the root Password">
# <i>passwd</i>
</pre>

</body>
</section>
<section>
<title>Adding a user for day-to-day use</title>
<body>

<p>
Working as root on a Unix/Linux system is <e>dangerous</e> and 
should be avoided as much as possible. Therefor it is <e>strongly</e>
recommended to add a user for day-to-day use:
</p>

<pre caption = "Adding a user">
# <i>useradd your_user -m -G users,wheel,audio -s /bin/bash</i>
# <i>passwd your_user</i>
</pre>

<p>
Substitute <c>your_user</c> with your username.
</p>

<p>
Whenever you need to perform some task that only root can handle,
use <c>su -</c> to change your privileges to root-privileges, or take
a look at the <c>sudo</c> package.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Setting your Hostname</title>
<section>
<body>

<p>
Edit <path>/etc/hostname</path> so that it contains your hostname 
on a single line, i.e. <c>mymachine</c>. 
</p>

<pre caption="Configuring Hostname">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>

<p>
Then edit <path>/etc/dnsdomainname</path> so that it contains your DNS 
domainname, i.e. <c>mydomain.com</c>.
</p>

<pre caption="Configuring Domainname">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>

<p>
If you have a NIS domain, you should set it in 
<path>/etc/nisdomainname</path>.
</p>

<pre caption="Configuring NIS Domainname">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>Modifying /etc/hosts</title>
<section>
<body>

<p>
This file contains a list of IP addresses and their associated hostnames.
It is used by the system to resolve the IP addresses of any hostnames that 
may not be in your nameservers.  Here is a template for this file:
</p>

<pre caption="Hosts Template">
127.0.0.1      localhost
<comment># the next line contains your IP for your local LAN and your associated machine name</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>

<note>
If you are on a DHCP network, it might be helpful to add your
machine's actual hostname after <i>localhost</i>. This will help 
GNOME and many other programs in name resolution.
</note>

</body>
</section>
</chapter>


<chapter>
<title>Final Network Configuration</title>
<section>
<body>

<p>
Add the names of any modules that are necessary for the proper functioning of 
your system to <path>/etc/modules.autoload</path> file (you can also add any 
options you need to the same line). When Gentoo Linux boots, these modules 
will be automatically loaded.  Of particular importance is your ethernet 
card module, if you happened to compile it as a module:
</p>

<pre caption="/etc/modules.autoload">
<comment>This is assuming that you are using a 3com card. 
Check <path>/lib/modules/`uname -r`/kernel/drivers/net</path> for your card. </comment>
3c59x
</pre>

<p>
Edit the <path>/etc/conf.d/net</path> script to get your network configured 
for your first boot:
</p>

<pre caption="Boot time Network Configuration">
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
If you have multiple network cards or tokenring interfaces, you need to create 
additional <path>net.eth<comment>x</comment></path> or 
<path>net.tr<comment>x</comment></path> scripts respectively for each one 
(<comment>x</comment> = 1, 2, ...):
</p>

<pre caption="Multiple Network Interfaces">
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment></i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>

<p>
If you have a PCMCIA card installed, have a quick look into 
<path>/etc/init.d/pcmcia</path> to verify that things seem all right for 
your setup, then add this line to the top of <path>/etc/init.d/net.ethx</path>:
</p>

<pre caption="PCMCIA depend in /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
</pre>

<p>
This makes sure that the PCMCIA drivers are autoloaded whenever your network 
is loaded.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Final steps: Configure Basic Settings (including the international keymap setting)</title>
<section>
<body>

<pre caption="Basic Configuration">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
Follow the directions in the file to configure the basic settings. All users 
will want to make sure that CLOCK is set to his/her liking.  International 
keyboard users will want to set the KEYMAP variable (browse 
<path>/usr/share/keymaps</path> to see the various possibilities).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configure a Bootloader</title>
<section>
<title>Notes</title>
<body>

<p>
In the spirit of Gentoo, users now have more than one bootloader to choose 
from. Using our virtual package system, users are now able to choose between 
both GRUB and LILO as their bootloaders. 
</p>

<p>
Please keep in mind that having both bootloaders installed is not necessary.
In fact, it can be a hindrance, so please only choose one.
</p>

<p>
In addition, you will need to configure our bootloader differently depending 
upon whether you are using <c>genkernel</c> (with kernel and initrd) or a 
kernel you compiled by hand. Be sure to take note of the important 
differences.
</p>

<impo>
If you are installing Gentoo Linux on a system with an NVIDIA nForce or 
nForce2 chipset with an integrated GeForce graphics card, you should use 
LILO and avoid GRUB. With on-board video enabled, the low memory area of your 
RAM may be used as video RAM. Since GRUB also uses low memory at boot time, 
it may experience an "out of memory" condition. So, if you have an nForce
or potentially other board with on-board video, use LILO. Even if you're using
off-board video right now, it would be nice to be able to remove the graphics 
card and use the on-board video in a pinch, wouldn't it? :)
</impo>

</body>
</section>
<section>
<title>Configuring GRUB</title>
<body>

<p>
The most critical part of understanding GRUB is getting comfortable with how 
GRUB refers to hard drives and partitions. Your Linux partition 
<path>/dev/hda1</path> is called <path>(hd0,0)</path> under GRUB.  Notice the
parenthesis around the hd0,0 - they are required. Hard drives count from zero
rather than "a" and partitions start at zero rather than one. Be aware too 
that with the hd devices, only hard drives are counted, not atapi-ide devices 
such as cdrom players, burners and that the same construct can be used with 
scsi drives. (Normally they get higher numbers than ide drives except when the 
bios is configured to boot from scsi devices.) Assuming you have a hard drive 
on <path>/dev/hda</path>, a cdrom player on <path>/dev/hdb</path>, a burner on
<path>/dev/hdc</path>, a second hard drive on <path>/dev/hdd</path> and no 
SCSI hard drive, <path>/dev/hdd7</path> gets translated to 
<path>(hd1,6)</path>. It might sound tricky and tricky it is indeed, but as 
we will see, GRUB offers a tab completion mechanism that comes handy for 
those of you having a lot of hard drives and partitions and who are a little 
lost in the GRUB numbering scheme. Having gotten the feel for that, it is 
time to install GRUB.
</p>

<p>
The easiest way to install GRUB is to simply type <c>grub</c> at your chrooted 
shell prompt:
</p>

<pre caption="Installing GRUB">
# <i>emerge -k grub</i>
# <i>grub</i>
</pre>

<p>
You will be presented with the <e>grub&gt;</e> grub command-line prompt.  
Now, you need to type in the right commands to install the GRUB boot record 
onto your hard drive.  In my example configuration, I want to install the GRUB
boot record on my hard drive's MBR (master boot record), so that the first 
thing I see when I turn on the computer is the GRUB prompt.  In my case, the 
commands I want to type are:
</p>

<pre caption="GRUB on the MBR">
grub&gt; <i>root (hd0,0)</i> <comment>(Your boot partition)</comment>
grub&gt; <i>setup (hd0)</i> <comment>(Where the boot record is installed; here, it is the MBR)</comment>
</pre>
	
<pre caption="GRUB not on the MBR">
<comment>Alternatively, if you wanted to install the bootloader somewhere other than the MBR:</comment>
grub&gt; <i>root (hd0,0)</i> <comment>(Your boot partition)</comment>
grub&gt; <i>setup (hd0,4)</i> <comment>(Where the boot record is installed; here it is /dev/hda5)</comment>
grub&gt; <i>quit</i>
</pre>

<p>
Here is how the two commands work.  The first <c>root ( )</c> command tells 
GRUB the location of your boot partition (in our example, 
<path>/dev/hda1</path> or <path>(hd0,0)</path> in GRUB terminology.  Then, the 
second <c>setup ( )</c> command tells GRUB where to install the boot record - 
it will be configured to look for its special files at the <c>root	( )</c> 
location that you specified.  In my case, I want the boot record on the MBR 
of the hard drive, so I simply specify <path>/dev/hda</path> (also known as 
<path>(hd0)</path>). If I were using another boot loader and wanted to set up 
GRUB as a secondary boot-loader, I could install GRUB to the boot record of 
a particular partition.  In that case, I would specify a particular partition 
rather than the entire disk.  Once the GRUB boot record has been successfully 
installed, you can type <c>quit</c> to quit GRUB. 
</p>

<note>
The tab completion mechanism of GRUB can be used from within GRUB, 
assuming you wrote <c> root (</c> and that you hit the TAB key, you would
be prompted with a list of the available devices (not only hard drives), 
hitting the TAB key having written <c> root (hd</c>, GRUB would print the
available hard drives and hitting the TAB key after writing <c> root (hd0,</c>
would make GRUB print the list of partitions on the first hard drive.
Checking the syntax of the GRUB location with completion should really help
to make the right choice.
</note>
			
<p>
Gentoo Linux is now installed, but we need to create the 
<path>/boot/grub/grub.conf</path> file so that we get a nice GRUB boot menu 
when the system reboots.  Here is how to do it.
</p>

<impo>
To ensure backwards compatibility with GRUB, make sure to make a link from
<path>grub.conf</path> to <path>menu.lst</path>. You can do this by typing
<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>.
</impo>

<p>
Now, create the <path>grub.conf</path> file (<c>nano -w 
/boot/grub/grub.conf</c>) and add the following to it:
</p>

<pre caption="grub.conf for GRUB">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

<comment># If you compiled your own kernel, use something like this:</comment>
title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment># If you're using genkernel, use something like this instead:</comment>
title=My example Gentoo Linux (genkernel)
root (hd0,0)
kernel (hd0,0)/boot/kernel-KV root=/dev/hda3
initrd (hd0,0)/boot/initrd-KV

<comment># Below needed only for people who dual-boot</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>

<p>
Substitute <c>KV</c> with the kernel version you have installed.
</p>

<note>
(hd0,0) should be written without any spaces inside the parentheses.
</note>

<impo>
If you set up SCSI emulation for an IDE cd burner earlier, then to get it to
actually work you need to add an <c>hdx=ide-scsi</c> fragment to the kernel
line in <path>grub.conf</path> (where "hdx" should be the device for your cd 
burner).
</impo>

<p>
After saving this file, Gentoo Linux installation is complete.  Selecting the 
first option will tell GRUB to boot Gentoo Linux without a fuss.  The second 
part of the <path>grub.conf</path> file is optional and shows you how to use 
GRUB to boot a bootable Windows partition.
</p>

<note>
Above, <path>(hd0,0)</path> should point to your "boot" partition
(<path>/dev/hda1</path> in our example config) and <path>/dev/hda3</path> 
should point to your root filesystem.  <path>(hd0,5)</path> contains the NT 
boot loader.
</note>

<note>
The path to the kernel image is relative to the boot partition. If for 
example you have separated boot partition <path>(hd0,0)</path> and root 
partition <path>(hd0,1)</path>, all paths in the <path>grub.conf</path> file 
above will become <path>/bzImage</path>.
</note>

<p>
If you need to pass any additional options to the kernel, simply add them to 
the end of the <c>kernel</c> command.  We're already passing one option 
(<c>root=/dev/hda3</c>), but you can pass others as well.  In particular, you 
can turn off devfs by default (not recommended unless you know what you're 
doing) by adding the <c>gentoo=nodevfs</c> option to the <c>kernel</c> 
command.
</p>

<note>
Unlike in earlier versions of Gentoo Linux, you no longer have to add 
<c>devfs=mount</c> to the end of the <c>kernel</c> line to enable devfs.
Now devfs is enabled by default.
</note>

</body>
</section>
<section>
<title>Configuring LILO</title>
<body>

<p>
While GRUB may be the new alternative for most people, it is not always the 
best choice. LILO, the LInuxLOader, is the tried and true workhorse of Linux 
bootloaders. Here is how to install LILO if you would like to use it instead 
of GRUB.
</p>

<p>
The first step is to emerge LILO: 
</p>

<pre caption="Emerging LILO">
# <i>emerge -k lilo</i>
</pre>

<p>
Now it is time to configure LILO. Here is a sample configuration file 
<path>/etc/lilo.conf</path>:
</p>

<pre caption="Example lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

<comment># Use something like the following 4 lines if you compiled your kernel yourself</comment>
image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3

<comment># If you used genkernel, use something like this:</comment>
image=/boot/kernel-KV
	label=gk_linux
	root=/dev/hda3
	initrd=/boot/initrd-KV
	append="root=/dev/ram0 init=/linuxrc"

	
<comment># For dual booting windows/other OS</comment>
other=/dev/hda1
	label=dos
</pre>

<p>
Substitute <c>KV</c> with the kernel version you have installed.
</p>

<ul>
<li><c>boot=/dev/hda</c> tells LILO to install itself on the first hard disk on the first IDE controller.</li>
<li><c>map=/boot/map</c> states the map file. In normal use, this should not be modified. </li>
<li><c>install=/boot/boot.b</c> tells LILO to install the specified file as the new boot sector. In normal use, this should not be altered. If the install line is missing, LILO will assume a default of <path>/boot/boot.b</path> as the file to be used. </li>
<li>The existence of <c>prompt</c> tells LILO to display the classic <e>lilo:</e> prompt at bootup. While it is not recommended that you remove the prompt line, if you do remove it, you can still get a prompt by holding down the [Shift] key while your machine starts to boot. </li>
<li><c>timeout=50</c> sets the amount of time that LILO will wait for user input before proceeding with booting the default line entry. This is measured in tenths of a second, with 50 as the default. </li>
<li><c>lba32</c> describes the hard disk geometry to LILO. Another common entry here is linear. You should not change this line unless you are very aware of what you are doing. Otherwise, you could put your system in an unbootable state. </li>
<li><c>default=linux</c> refers to the default operating system for LILO to boot from the options listed below this line. The name linux refers to the label line below in each of the boot options. </li>
<li><c>image=/boot/bzImage</c> specifies the linux kernel to boot with this particular boot option. </li>
<li><c>label=linux</c> names the operating system option in the LILO screen. In this case, it is also the name referred to by the default line. </li>
<li><c>read-only</c> specifies that the root partition (see the root line below) is read-only and cannot be altered during the boot process. </li>
<li><c>root=/dev/hda3</c> tells LILO what disk partition to use as the root partition. </li>
</ul>

<p>
After you have edited your <path>lilo.conf</path> file, it is time to run LILO 
to load the information into the MBR:
</p>

<pre caption="Running LILO">
# <i>/sbin/lilo</i>
</pre>

<p>
LILO is configured and now your machine is ready to boot into Gentoo Linux!
</p>

</body>
</section>

<section>
<title>Using framebuffer</title>
<body>

<p>
People who have selected framebuffer in their kernel should add <c>vga=xxx</c> 
to their bootloader configuration file. <c>xxx</c> is one of the values in the 
following table:
</p>

<table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>

<p>
LILO-users will have to add <c>vga=xxx</c> on top of their configuration
file.
</p>

<p>
GRUB-users will have to append <c>vga=xxx</c> to the <c>kernel
(hd0,0)...</c> line.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Creating Bootdisks</title>
<section>
<title>GRUB Bootdisks</title>
<body>

<impo>
Don't forget to insert a floppy in your floppydrive before proceeding.
</impo>

<p>
It is always a good idea to make a boot disk the first
time you install any Linux distribution. This is a security
blanket and generally not a bad thing to do. If your hardware doesn't 
let you install a working bootloader from the chrooted environment, 
you may <e>need</e> to make a GRUB boot disk. 
If you are in this camp, make a GRUB boot disk and when you reboot 
the first time you can install GRUB	to the MBR. Make your bootdisks 
like this:
</p>

<pre caption="Creating a GRUB Bootdisk">
# <i>cd /usr/share/grub/i386-pc/</i>
# <i>cat stage1 stage2 > /dev/fd0</i>
</pre>

<p>
Now reboot and load the floppy. At the floppy's <c>grub&gt;</c> prompt, you 
can now execute the necessary <c>root</c> and <c>setup</c> commands.
</p>

</body>
</section>
<section>
<title>LILO Bootdisks</title>
<body>

<impo>
Don't forget to insert a floppy in your floppydrive before proceeding.
</impo>

<p>
If you are using LILO, it is also a good idea to make a bootdisk:
</p>

<pre caption="Making a Bootdisk">
# <i>dd if=/boot/your_kernel of=/dev/fd0 </i>
<comment>(This will only work if your kernel is smaller than 1.4MB)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Using GRP</title>
<section>
<body>

<p>
GRP users can, at this point, install binary packages:
</p>

<pre caption="Installing from GRP">
# <i>USE="bindist" emerge -k xfree</i> 
<codenote>(USE="bindist" must be set while installing GRP packages that use XFree86)</codenote>
</pre>

<p>
CD 1 contains enough applications to install a working system with XFree86.
Additionally, CD2 of the 2-CD GRP set contains other applications including 
KDE, GNOME, Mozilla and others. To install these packages, you will need to 
reboot into your new Gentoo system first (covered in the "Installation 
complete!" section near the end of this document). After you are running your 
basic Gentoo system from the hard drive, you can mount the second CD and copy 
files:
</p>

<pre caption="Loading binary packages from CD2">
# <i>mount /dev/cdrom /mnt/cdrom</i>
# <i>cp -a /mnt/cdrom/packages/ /usr/portage/</i>
</pre>

<p>
Now various other applications can be installed the same way. For example:
</p>

<pre caption="Installing KDE from GRP">
# <i>USE="bindist" emerge -k kde</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Installation Complete!</title>
<section>
<body>

<p>
Now, Gentoo Linux is installed. The only remaining step is to update necessary 
configuration files, exit the chrooted shell, safely unmount your partitions
and reboot the system:
</p>

<warn>
<c>etc-update</c> can provide you with a list of configuration files
that have newer versions at your disposal. Verify that none of the
configuration files have a big impact (such as <path>/etc/fstab</path>,
<path>/etc/make.conf</path>, <path>/etc/rc.conf</path>, ...). Merge the
files that don't have such a big impact, remove the updates of the
others or view the diff and manually update the configuration file.
</warn>

<pre caption="Rebooting the System">
# <i>etc-update</i>
# <i>exit</i> 
<comment>(This exits the chrooted shell; you can also type <i>^D</i>)</comment>
# <i>cd / </i>
# <i>umount /mnt/gentoo/boot</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>umount /mnt/gentoo</i>
# <i>reboot</i>
<comment>(Don't forget to remove the bootable CD)</comment>
</pre>

<note>
After rebooting, it is a good idea to run the <c>update-modules</c> command to 
create the <path>/etc/modules.conf</path> file.  Instead of modifying this 
file directly, you should generally make changes to the files in 
<path>/etc/modules.d</path>.
</note>

<p>
If you have any questions or would like to get involved with Gentoo Linux 
evelopment, consider joining our gentoo-user and gentoo-dev mailing lists
(more information on our <uri 
link="http://www.gentoo.org/main/en/lists.xml">mailing lists</uri> page).
We also have a handy <uri 
link="http://www.gentoo.org/doc/en/desktop.xml">Desktop configuration 
guide</uri> that will help you to continue configuring your new Gentoo Linux 
system and a useful <uri 
link="http://www.gentoo.org/doc/en/portage-user.xml">Portage user guide</uri>
to help familiarize you with Portage basics. You can find the rest of the 
Gentoo Documentation <uri 
link="http://www.gentoo.org/main/en/docs.xml">here</uri>. If you have any 
other questions involving installation or anything for that matter, please 
check the Gentoo Linux <uri 
link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri>. Enjoy and welcome to 
Gentoo Linux!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gentoo-Stats</title>
<section>
<body>

<p>
The Gentoo Linux usage statistics program was started as an attempt to give 
the developers a way to find out about their user base. It collects information
about Gentoo Linux usage to help us in set priorities our development. 
Installing it is completely optional and it would be greatly appreciated if 
you decide to use it. Compiled statistics can be viewed at 
<uri>http://stats.gentoo.org/</uri>.
</p>

<p>
The gentoo-stats server will assign a unique ID to your system.
This ID is used to make sure that each system is counted only once. The ID 
will not be used to individually identify your system, nor will it be matched 
against an IP address or other personal information. Every precaution has been 
taken to assure your privacy in the development of this system. The following 
are the things that we are monitoring right now through our "gentoo-stats" 
program:
</p>

<ul>
<li>installed packages and their version numbers</li>
<li>CPU information: speed (MHz), vendor name, model name, CPU flags (like "mmx" or "3dnow")</li>
<li>memory information (total available physical RAM, total available swap space)</li>
<li>PCI cards and network controller chips</li>
<li>the Gentoo Linux profile your machine is using (that is, where the <path>/etc/make.profile</path> link is pointing to).</li>
</ul>

<p>
We are aware that disclosure of sensitive information is a threat to most 
Gentoo Linux users (just as it is to the developers).
</p>

<ul>
<li>Unless you modify the gentoo-stats program, it will never transmit sensitive information such as your passwords, configuration data, shoe size...</li>
<li>Transmission of your e-mail addresses is optional and turned off by default.</li>
<li>The IP address your data transmission originates from will never be logged in such a way that we can identify you. There are no "IP address/system ID" pairs.</li>
</ul>

<p>
The installation is easy - just run the following commands:
</p>

<pre caption="Installing gentoo-stats">
# <i>emerge gentoo-stats</i>   <comment>(Installs gentoo-stats)</comment>
# <i>gentoo-stats --new</i>    <comment>(Obtains a new system ID)</comment>
</pre>

<p>
The second command above will request a new system ID and enter it into
<path>/etc/gentoo-stats/gentoo-stats.conf</path> automatically. You can view 
this file to see additional configuration options.
</p>

<p>
After that, the program should be run on a regular schedule (gentoo-stats does 
not have to be run as root). Add this line to your <path>crontab</path>:
</p>

<pre caption="Updating gentoo-stats with cron">
0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null
</pre>

<p>
The <c>gentoo-stats</c> program is a simple perl script which can be
viewed with your favorite pager or editor: <path>/usr/sbin/gentoo-stats</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gentoo On Less-Common Hardware</title>
<section>
<title>Hardware ATA RAID</title>
<body>

<p>
Users who want to install Gentoo on Hardware ATA RAID must pay 
attention to the next steps in order for them to succesfully
install Gentoo Linux:
</p>

<ul>
<li>Be sure to start the LiveCD with the <c>doataraid</c> kerneloption.</li>
<li>If you've forgotten to select <c>doataraid</c> during bootup, or the modules mysteriously didn't load, load them as needed:
<pre caption = "Loading RAID modules">
# <i>modprobe ataraid</i>
<comment>For Promise Raid Controllers:</comment>
# <i>modprobe pdcraid</i> 
<comment>For Highpoint Raid Controllers:</comment>
# <i>modprobe hptraid</i>
</pre></li>
<li>Some ATA RAID Controllers require you to reboot after partitioning; formatting will otherwise fail.</li>
<li>Before chrooting, mount the devicetree into the new environment:
<pre caption = "Mounting /dev into /mnt/gentoo/dev">
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
</pre></li>
<li>During kernel configuration, select the required RAID options:
<pre caption = "RAID in the Linux Kernel Configuration">
<comment>For Highpoint RAID controllers:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] HPT36X/37X chipset support 
[*] Support for IDE Raid controllers
[*] Highpoint 370 software RAID
<comment>For Promise RAID controllers:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] PROMISE PDC202{46|62|65|67} support 
<comment>and/or</comment>
[*] PROMISE PDC202{68|69|70|71|75|76|77} support
[*] Support for IDE Raid controllers
[*] Support Promise software RAID (Fasttrak(tm))
</pre></li>
<li>When using GRUB add <c>--stage2=/boot/grub/stage2</c> when running <c>grub</c> to the <c>setup</c> command:
<pre caption = "Installing GRUB for Hardware RAID systems">
grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
grub&gt; <i>quit</i>
</pre>
Also, in the GRUB configuration be sure to point the <c>root</c>
to the appropriate RAID device:
<pre caption = "grub.conf for RAID">
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
</pre></li>
<li>LILO users should set the <c>root</c> option to the appropriate RAID device:
<pre caption = "lilo.conf for RAID">
image=/boot/bzImage
label=linux
read-only
root=/dev/ataraid/dXpY
</pre></li>
</ul>

<p>
If you still have problems installing Gentoo Linux on your Hardware
RAID, be sure to report them on <uri>http://bugs.gentoo.org</uri>. 
</p>

<p>
Thanks for using Gentoo Linux, and have fun with your new installation!
</p>


</body>
</section>
</chapter>
</guide>
