<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/udev-guide.xml,v 1.13 2004/07/16 13:43:34 bennyc Exp $ -->

<guide link="/doc/en/udev-guide.xml">
<title>Gentoo udev Guide</title>

<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributor">
  <mail link="g.guidi@sns.it">Gregorio Guidi</mail>
</author>

<abstract>
This document explains what udev is and how you can use udev to fit your needs.
</abstract>

<license/>

<version>0.9</version>
<date>May 27, 2004</date>

<chapter>
<title>What is udev?</title>
<section>
<title>The /dev Directory</title>
<body>

<p>
When Linux-users talk about the hardware on their system in the vicinity of
people who believe Linux is some sort of virus or brand of coffee, the use of
"slash dev slash foo" will return a strange look for sure. But for the fortunate
user (and that includes you) using <path>/dev/hda1</path> is just a fast way of
explaining that we are talking about the primary master IDE, first partition. Or
aren't we?
</p>

<p>
We all know what a device file is. Some even know why device files have special
numbers when we take a closer look at them when we issue <c>ls -l</c> in
<path>/dev</path>. But what we always take for granted is that the primary
master IDE disk is referred to as <path>/dev/hda</path>. You might not see it
this way, but this is a flaw by design.
</p>

<p>
Think about hotpluggable devices like USB, IEEE1394, hot-swappable PCI, ... What
is the first device? And for how long? What will the other devices be named when
the first one disappears? How will that affect ongoing transactions? Wouldn't it
be fun that a printing job is suddenly moved from your supernew laserprinter to 
your almost-dead matrix printer because your mom decided to pull the plug of the
inkjet which happened to be the first printer?
</p>

<p>
Enter <e>udev</e>. The goals of the udev project are both interesting and
needed:
</p>

<ul>
  <li>Runs in userspace</li>
  <li>Dynamically creates/removes device files</li>
  <li>Provides consistent naming</li>
  <li>Provides a user-space API</li>
</ul>

<p>
To provide these features, udev is developed in three separate projects:
<e>namedev</e>, <e>libsysfs</e> and, of course, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev allows you to define the device naming separately from the udev program.
This allows for flexible naming policies and naming schemes developed by
separate entities. This device naming subsystem provides a standard interface
that udev can use.
</p>

<p>
Currently only a single naming scheme is provided by namedev; the one provided
by LANANA, used by the majority of Linux systems currently and therefore very
suitable for the majority of Linux users.
</p>

<p>
Namedev uses a 5-step procedure to find out the name of a given device. If the
device name is found in one of the given steps, that name is used. The steps
are:
</p>

<ul>
  <li>label or serial number</li>
  <li>bus device number</li>
  <li>bus topology</li>
  <li>statically given name</li>
  <li>kernel provided name</li>
</ul>

<p>
The <e>label or serial number</e> step checks if the device has a unique
identifier. For instance USB devices have a unique USB serial number; SCSI
devices have a unique UUID. If namedev finds a match between this unique number
and a given configuration file, the name provided in the configuration file is
used.
</p>

<p>
The <e>bus device number</e> step checks the device bus number. For 
non-hot-swappable environments this procedure is sufficient to
identify a hardware device. For instance PCI bus numbers rarely change in the
lifetime of a system. Again, if namedev finds a match between this position and
a given configuration file, the name provided in that configuration file is
used.
</p>

<p>
Likewise the <e>bus topology</e> is a rather static way of defining devices as
long as the user doesn't switch devices. When the position of the device matches
a given setting provided by the user, the accompanying name is used.
</p>

<p>
The fourth step, <e>statically given name</e>, is a simple string replacement.
When the kernel name (the default name) matches a given replacement string, the
substitute name will be used. 
</p>

<p>
The final step (<e>kernel provided name</e>) is a catch-all: this one takes 
the default name provided by the kernel. In the majority of cases this is 
sufficient as it matches the device naming used on current Linux systems.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev interacts with the kernel through the sysfs pseudo filesystem. The libsysfs
project provides a common API to access the information given by the sysfs
filesystem in a generic way. This allows for querying all kinds of hardware
without having to make assumptions on the kind of hardware.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Every time the kernel notices an update in the device structure, it calls the
<path>/sbin/hotplug</path> program. Hotplug runs the applications linked in the
<path>/etc/hotplug.d/default</path> directory where you will also find a symlink
to the udev application. Hotplug directs the information given by the kernel to
the udev application which performs the necessary actions on the
<path>/dev</path> structure (creating or deleting device files).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Using udev on Gentoo</title>
<section>
<title>Requirements</title>
<body>

<p>
udev is meant to be used in combination with a 2.6 kernel (like
<c>development-sources</c> or <c>gentoo-dev-sources</c>). If you're using such a
kernel then you just have to make sure that you have a recent
<c>sys-apps/baselayout</c> version. That's all you need.
</p>

<pre caption="Installing udev">
# <i>emerge udev</i>
</pre>

<p>
udev will install <c>hotplug-base</c> as one of it's dependencies. If you 
intend to use hotplug to execute specific actions when you plug in your 
favorite USB or IEEE1394 device then you should also emerge the whole bunch 
of hotplug scripts.
</p>

<pre caption="Installing optional hotplug scripts">
# <i>emerge hotplug</i>
</pre>

<p>
Kernelwise, if you're using the default set by <c>genkernel</c> then you're all 
set. Otherwise be sure to activate the following options:
</p>

<pre caption="Required kernel options">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
You can leave the <c>/dev file system support (OBSOLETE)</c> active if you
wish.
</p>

</body>
</section>
<section>
<title>Configuration</title>
<body>

<p>
If you want to use the udev-tweaks Gentoo added to make your life
comfortable, then read no more. You're all set. The Gentoo init scripts won't
run the devfsd daemon and will deactivate devfs when you boot up. 
</p>

<p>
But if you are a die-hard and want to run a udev-only, no-tweaked system as is
intended by the udev development (including the difficulties of missing device
nodes because udev doesn't support them yet), by all means, read on :)
</p>

<warn>
Do <e>not</e> complain if something goes wrong. You're going to remove the hard
work of many Gentoo developers that hacked our init scripts to get udev playing 
nicely with Gentoo!
</warn>

<p>
We'll deactivate the rules that save the device file nodes: edit the 
<c>RC_DEVICE_TARBALL</c> variable in <path>/etc/conf.d/rc</path> and set it to
<c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
If you have included devfs support in your kernel, you can deactivate it in
the bootloader configuration: add <c>devfs=nomount</c> as a kernel parameter. If
you want to use devfs and deactivate udev, add <c>gentoo=noudev</c> as kernel
parameter.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Known Issues</title>
<section>
<title>Missing device node files at boot</title>
<body>

<p>
If you can't boot successfully because you get an error about
<path>/dev/null</path> not found, or because the initial console is missing, the
problem is that you lack some device files that must be available <e>before</e>
<path>/dev</path> is mounted and handled by udev. This is common on Gentoo
machines installed from old media.
</p>

<p>
If you run <c>sys-apps/baselayout-1.8.12</c> or later, this problem is
alleviated since the boot process should still manage to complete. However, to
get rid of those annoying warnings, you should create the missing device nodes
as described below.
</p>

<p>
To see which devices nodes are present before the <path>/dev</path> filesystem
is mounted, run the following commands:
</p>

<pre caption="Listing device nodes available at boot">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
The devices needed for a successful boot are <path>/dev/null</path> and
<path>/dev/console</path>. If they didn't show up in the previous test, you have
to create them manually. Issue the following commands in the
<path>test/dev/</path> directory:
</p>

<pre caption="Creating necessary device node files">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
When you're finished, don't forget to unmount the <path>test/</path> directory:
</p>

<pre caption="Unmounting the test/ directory">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev and nvidia</title>
<body>

<p>
If you use the proprietary driver from nVidia and the X server fails to start on
a udev-only system, then make sure you have:
</p>

<ul>
  <li>
    the <c>nvidia</c> module listed in
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    a version of <c>nvidia-kernel</c> equal to or greater than
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    a version of baselayout equal to or greater than
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

</body>
</section>
<section>
<title>Other issues</title>
<body>

<p>
If device nodes are not created when a module is loaded from
<path>/etc/modules.autoload.d/kernel-2.6</path> but they appear when you load
the module manually with modprobe then you should try upgrading to
<c>sys-apps/baselayout-1.8.12</c> or later.
</p>

<p>
Support for the framebuffer devices (<path>/dev/fb/*</path>) comes with the
kernel starting from version 2.6.6-rc2.
</p>

<p>
For kernels older than 2.6.4 you have to explicitly include support for the
<path>/dev/pts</path> filesystem.
</p>

<pre caption="Enabling the /dev/pts filesystem">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Resources &amp; Acknowledgements</title>
<section>
<body>

<p>
The udev talk on the Linux Symposium (Ottawa, Ontario Canada - 2003) given by
Greg Kroah-Hartman (IBM Corporation) provided a solid understanding on the udev
application.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> is an in-depth document about udev and Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri> by
fellow Gentoo developer Daniel Drake is an excellent document to learn how to
customize your udev installation.
</p>

</body>
</section>
</chapter>

</guide>
