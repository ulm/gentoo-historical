<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/udev-guide.xml,v 1.32 2006/11/27 00:08:22 nightmorph Exp $ -->

<guide link="/doc/en/udev-guide.xml">
<title>Gentoo udev Guide</title>

<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributor">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>

<abstract>
This document explains what udev is and how you can use udev to fit your needs.
</abstract>

<license/>

<version>0.25</version>
<date>2006-11-26</date>

<chapter>
<title>What is udev?</title>
<section>
<title>The /dev Directory</title>
<body>

<p>
When Linux-users talk about the hardware on their system in the vicinity of
people who believe Linux is some sort of virus or brand of coffee, the use of
"slash dev slash foo" will return a strange look for sure. But for the fortunate
user (and that includes you) using <path>/dev/hda1</path> is just a fast way of
explaining that we are talking about the primary master IDE, first partition. Or
aren't we?
</p>

<p>
We all know what a device file is. Some even know why device files have special
numbers when we take a closer look at them when we issue <c>ls -l</c> in
<path>/dev</path>. But what we always take for granted is that the primary
master IDE disk is referred to as <path>/dev/hda</path>. You might not see it
this way, but this is a flaw by design.
</p>

<p>
Think about hotpluggable devices like USB, IEEE1394, hot-swappable PCI, ... What
is the first device? And for how long? What will the other devices be named when
the first one disappears? How will that affect ongoing transactions? Wouldn't it
be fun that a printing job is suddenly moved from your supernew laserprinter to 
your almost-dead matrix printer because your mom decided to pull the plug of the
laserprinter which happened to be the first printer?
</p>

<p>
Enter <e>udev</e>. The goals of the udev project are both interesting and
needed:
</p>

<ul>
  <li>Runs in userspace</li>
  <li>Dynamically creates/removes device files</li>
  <li>Provides consistent naming</li>
  <li>Provides a user-space API</li>
</ul>

<p>
To provide these features, udev is developed in three separate projects:
<e>namedev</e>, <e>libsysfs</e> and, of course, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev allows you to define the device naming separately from the udev program.
This allows for flexible naming policies and naming schemes developed by
separate entities. This device naming subsystem provides a standard interface
that udev can use.
</p>

<p>
Currently only a single naming scheme is provided by namedev; the one provided
by LANANA, used by the majority of Linux systems currently and therefore very
suitable for the majority of Linux users.
</p>

<p>
Namedev uses a 5-step procedure to find out the name of a given device. If the
device name is found in one of the given steps, that name is used. The steps
are:
</p>

<ul>
  <li>label or serial number</li>
  <li>bus device number</li>
  <li>bus topology</li>
  <li>statically given name</li>
  <li>kernel provided name</li>
</ul>

<p>
The <e>label or serial number</e> step checks if the device has a unique
identifier. For instance USB devices have a unique USB serial number; SCSI
devices have a unique UUID. If namedev finds a match between this unique number
and a given configuration file, the name provided in the configuration file is
used.
</p>

<p>
The <e>bus device number</e> step checks the device bus number. For 
non-hot-swappable environments this procedure is sufficient to
identify a hardware device. For instance PCI bus numbers rarely change in the
lifetime of a system. Again, if namedev finds a match between this position and
a given configuration file, the name provided in that configuration file is
used.
</p>

<p>
Likewise the <e>bus topology</e> is a rather static way of defining devices as
long as the user doesn't switch devices. When the position of the device matches
a given setting provided by the user, the accompanying name is used.
</p>

<p>
The fourth step, <e>statically given name</e>, is a simple string replacement.
When the kernel name (the default name) matches a given replacement string, the
substitute name will be used. 
</p>

<p>
The final step (<e>kernel provided name</e>) is a catch-all: this one takes 
the default name provided by the kernel. In the majority of cases this is 
sufficient as it matches the device naming used on current Linux systems.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev interacts with the kernel through the sysfs pseudo filesystem. The libsysfs
project provides a common API to access the information given by the sysfs
filesystem in a generic way. This allows for querying all kinds of hardware
without having to make assumptions on the kind of hardware.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Every time the kernel notices an update in the device structure, it calls the
<path>/sbin/hotplug</path> program. Hotplug runs the applications linked in the
<path>/etc/hotplug.d/default</path> directory where you will also find a symlink
to the udev application. Hotplug directs the information given by the kernel to
the udev application which performs the necessary actions on the
<path>/dev</path> structure (creating or deleting device files).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Using udev on Gentoo</title>
<section>
<title>Requirements</title>
<body>

<p>
udev is meant to be used in combination with a 2.6 kernel (like
<c>vanilla-sources</c> or <c>gentoo-sources</c> with the default 2005.0 
profile). If you're using such a kernel then you just have to make sure that 
you have a recent <c>sys-apps/baselayout</c> version. That's all you need.
</p>

<pre caption="Installing udev">
# <i>emerge udev</i>
</pre>

<p>
udev will install <c>hotplug-base</c> as one of its dependencies. You do not
need to install <c>hotplug</c> unless you want your modules automatically
loaded when you plug devices in. <c>hotplug</c> also handles the automated
bringup of network devices and firmware downloading.
</p>

<pre caption="Installing optional hotplug scripts">
# <i>emerge hotplug</i>
</pre>

<p>
If you want modules loaded for devices that have been plugged in before you
boot, use the coldplug package:
</p>

<pre caption="Installing the coldplug package">
# <i>emerge coldplug</i>
</pre>

<p>
Don't forget to add <c>coldplug</c> to the boot runlevel:
</p>

<pre caption="Adding coldplug to the boot runlevel">
# <i>rc-update add coldplug boot</i>
</pre>

<note>
You no longer need to emerge <c>coldplug</c> if you're using udev version 103
and higher, as udev itself will handle module loading. If you are upgrading to
version 103, you must unmerge coldplug (<c>emerge -aC coldplug</c>) before
upgrading udev. Be sure to remove the coldplug init script from all runlevels
(<c>rc-update del coldplug</c>), and then delete it from
<path>/etc/init.d/</path> afterward.
</note>

<p>
Kernelwise, be sure to activate the following options:
</p>

<pre caption="Required kernel options">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
You can leave the <c>/dev file system support (OBSOLETE)</c> active if you
wish but you have to make sure that "Automatically mount at boot" is disabled:
</p>

<pre caption="Don't automatically mount devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
If you use <c>genkernel</c>, don't forget to run it with the <c>--udev</c>
option to enable all the required kernel configuration directives. The default
configuration given by this <c>genkernel</c> invocation is sufficient.
</p>

</body>
</section>
<section>
<title>Configuration</title>
<body>

<p>
If you want to use the udev-tweaks Gentoo added to make your life
comfortable, then read no more. Gentoo will use udev but keep a static
<path>/dev</path> so that you will never have any missing device nodes.
The Gentoo init scripts won't run the devfsd daemon and will deactivate devfs 
when you boot up. 
</p>

<p>
But if you are a die-hard and want to run a udev-only, no-tweaked system as is
intended by the udev development (including the difficulties of missing device
nodes because udev doesn't support them yet), by all means, read on :)
</p>

<p>
We'll deactivate the rules that save the device file nodes: edit the 
<c>RC_DEVICE_TARBALL</c> variable in <path>/etc/conf.d/rc</path> and set it to
<c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
If you have included devfs support in your kernel, you can deactivate it in
the bootloader configuration: add <c>gentoo=nodevfs</c> as a kernel parameter. 
If you want to use devfs and deactivate udev, add <c>gentoo=noudev</c> as kernel
parameter.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Known Issues</title>
<section>
<title>Missing device node files at boot</title>
<body>

<p>
If you can't boot successfully because you get an error about
<path>/dev/null</path> not found, or because the initial console is missing, the
problem is that you lack some device files that must be available <e>before</e>
<path>/dev</path> is mounted and handled by udev. This is common on Gentoo
machines installed from old media.
</p>

<p>
If you run <c>sys-apps/baselayout-1.8.12</c> or later, this problem is
alleviated since the boot process should still manage to complete. However, to
get rid of those annoying warnings, you should create the missing device nodes
as described below.
</p>

<p>
To see which devices nodes are present before the <path>/dev</path> filesystem
is mounted, run the following commands:
</p>

<pre caption="Listing device nodes available at boot">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
The devices needed for a successful boot are <path>/dev/null</path> and
<path>/dev/console</path>. If they didn't show up in the previous test, you have
to create them manually. Issue the following commands in the
<path>test/dev/</path> directory:
</p>

<pre caption="Creating necessary device node files">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
When you're finished, don't forget to unmount the <path>test/</path> directory:
</p>

<pre caption="Unmounting the test/ directory">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev and nvidia</title>
<body>

<p>
If you use the proprietary driver from nVidia and the X server fails to start on
a udev-only system, then make sure you have:
</p>

<ul>
  <li>
    the <c>nvidia</c> module listed in
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    a version of <c>nvidia-kernel</c> equal to or greater than
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    a version of baselayout equal to or greater than
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

<p>
If <c>xorg-x11</c> refuses to start, it might be because the
<path>/dev/nvidia</path> device file is missing. If that is the case, run
<path>/sbin/NVmakedevices.sh</path> to (re)create it.
</p>

</body>
</section>
<section>
<title>LVM2 Names Disappear</title>
<body>

<p>
When you use <c>udev</c> and LVM2 together, you might notice that your created
volume groups and logical volumes have disappeared. Well, they haven't, but they
are unfortunately named <path>/dev/dm-#</path> with # being 0, 1, ...
</p>

<p>
To fix this, edit <path>/etc/udev/rules.d/50-udev.rules</path> and uncomment the
following line:
</p>

<pre caption="Uncomment this line from /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
Next, install <c>sys-fs/multipath-tools</c> which contains the
<c>devmap_name</c> application.
</p>

<pre caption="Installing multipath-tools">
<comment>(At the moment of writing, multipath-tools is only available in the testing branch:)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>No Consistent Naming between DevFS and udev</title>
<body>

<p>
Even though our intention is to have a consistent naming scheme between both 
dynamical device management solutions, sometimes naming differences do occur.
</p>

<p>
One reported clash is with a HP Smart Array 5i RAID controller (more precisely
the <c>cciss</c> kernel module). With udev, the devices are named
<path>/dev/cciss/cXdYpZ</path> with X, Y and Z regular numbers. With devfs, the
devices are <path>/dev/hostX/targetY/partZ</path> or symlinked from
<path>/dev/cciss/cXdY</path>.
</p>

<p>
If this is the case, don't forget to update your <path>/etc/fstab</path> and
bootloader configuration files accordingly.
</p>

<p>
The same happens with all-round symlinks that used to exist in
<path>/dev</path>, such as <path>/dev/mouse</path>, which <c>udev</c> doesn't
create anymore. Be certain to check your X configuration file and see if the
Device rule for your mouse points to an existing device file.
</p>

<p>
Another issue is the difference in naming of terminals between devfs and udev.
While devfs calls its terminals <c>tty</c>, udev calls them <c>vc</c> and
<c>tty</c>. This could lead to a problem in case you are restricting root
logins from consoles using <path>/etc/securetty</path>. You will need to make
sure that both <c>tty1</c> and <c>vc/1</c> are listed in
<path>/etc/securetty</path> to ensure that root can login using the console.
</p>

</body>
</section>
<section>
<title>Other issues</title>
<body>

<p>
If device nodes are not created when a module is loaded from
<path>/etc/modules.autoload.d/kernel-2.6</path> but they appear when you load
the module manually with modprobe then you should try upgrading to
<c>sys-apps/baselayout-1.8.12</c> or later.
</p>

<p>
Support for the framebuffer devices (<path>/dev/fb/*</path>) comes with the
kernel starting from version 2.6.6-rc2.
</p>

<p>
For kernels older than 2.6.4 you have to explicitly include support for the
<path>/dev/pts</path> filesystem.
</p>

<pre caption="Enabling the /dev/pts filesystem">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Resources &amp; Acknowledgements</title>
<section>
<body>

<p>
The udev talk on the Linux Symposium (Ottawa, Ontario Canada - 2003) given by
Greg Kroah-Hartman (IBM Corporation) provided a solid understanding on the udev
application.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> is an in-depth document about udev and Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri> by
fellow Gentoo developer Daniel Drake is an excellent document to learn how to
customize your udev installation.
</p>

</body>
</section>
</chapter>

</guide>
