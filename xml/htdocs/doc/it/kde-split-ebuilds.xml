<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/Attic/kde-split-ebuilds.xml,v 1.2 2005/02/23 15:10:26 so Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/kde-split-ebuilds.xml" lang="it">

<title>Guida agli Split Ebuilds di KDE</title>

<author title="Autore">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Traduttore">
  <mail link="posta@massimo.biz">Massimo Canali</mail>
</author>

<abstract>
Con KDE 3.4 sono stati introdotte in Portage gli 'split ebuilds'. Questa
quida spiega i motivi di questo cambiamento e le nuove caratteristiche.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.1</version>
<date>2005-02-19</date>

<chapter>
<title>GLi Split Ebuilds di KDE</title>
<section>
<title>Di cosa si tratta?</title>
<body>

<p>
Fino a Gennaio 2005 gli unici ebuilds di KDE disponibili in Portage erano quelli
'monolitici'. Come dire, c'erano solo 15 ebuilds e ciascuno installava diverse
applicazioni che, di fatto, non dipendevano l'una dall'altra. Una situazione non
esattamente ottimale, e non in stile Gentoo, ma accettata per diverso tempo.
</p>

<p>
I nuovi ebuilds 'splittati' hanno rimediato a questa situazione introducendo
gli ebuilds per le singole applicazioni di KDE. Questo porta gli ebuilds della
categoria kde-base a un totale di 330.
</p>

<p>
GLi ebuilds monolitici di KDE sono ancora disponibili e possono interagire in
maniera trasparente con quelli splittati. Comunque gli split ebuilds sono il
nuovo standard e a partire da KDE 4.0 gli ebuilds monolitici non saranno più
disponibili.
</p>

<p>
Infine, segnaliamo che esistono split ebuilds anche per Koffice che mettono
a disposizione kword, kugar ecc. come pacchetti separati.
</p>

</body>
</section>
<section>
<title>Come si usano?</title>
<body>

<p>
Nel momento in cui scriviamo, la pre-release di KDE più recente è la 3.4.0. In
Portage sono presenti masked ebuilds nella versione splittata e in quella
monolitica.
</p>

<ul>
  <li>
    Per emergere un particolare pacchetto, diciamo kmail, è sufficiente
	eseguire <c>emerge kmail</c>.
  </li>
  <li>
    Per emergere l'ambiente base di KDE, che consente il login a una sessione
	minimale, <c>emerge kdebase-startkde</c>.
  </li>
  <li>
    Infine, per ottenere lo stesso effetto di uno dei pacchetti monolitici
	usando gli split ebuilds - diciamo, per avere tutte le applicazioni
	incluse in <c>kdebase</c> - eseguire <c>emerge kdebase-meta</c> (oppure
	kdepim-meta, ecc.). Per ottenere tutti gli split ebuilds di KDE, eseguire
	<c>emerge kde-meta</c>.
  </li>
</ul>

</body>
</section>
<section>
<title>Vantaggi degli split ebuilds</title>
<body>

<p>
Ecco un breve elenco dei vantaggi che si ottengono passando algli split ebuilds:
</p>

<ul>
  <li>
    La maggior parte dei pacchetti di KDE non subisce aggiornamentariazioni da
	una minor release all'altra. Ad esempio, l'aggiornamento dalla versione
	3.3.1 alla 3.3.2 ha coinvolto meno di 100 pacchetti su 320. I pacchetti
	splittati permettono di aggiornare gli ebuilds che sono effettivamente
	cambiati, facendo risparmiare (in questo caso) più di due terzi del tempo
	necessario all'aggiornamento.
  </li>
  <li>
    Le patch, di solito riguardano un pacchetto specifico. Con gli split ebuilds
	possono essere testate, approvate e rilasciate più rapidamente impegnando di
	meno gli sviluppatori: come sopra, l'utente impiegherà meno tempo per gli
	aggiornamenti. Questo fatto diventa ancora più importante per gli
	aggiornamenti di sicurezza.
  </li>
  <li>
    Chi usa altri ambienti desktop o Window Managers più leggeri può emergere
	solo le applicazioni di KDE che preferisce senza doversi sobbarcare il
	carico (piuttosto pesante) di tutto il resto, di kdebase o di kde pim, per
	esempio.
  </li>
  <li>
    È possibile organizzare al meglio l'installazione dei pacchetti. Per diversi
	motivi:
    
    <ul>
      <li>
	    Hai problemi di tempo. <c>emerge kdebase kdepim kdenetwork</c> richiede
		troppo tempo se tutto quello che ti occorre è konqueror, kmail e kopete.
		Inoltre, in certi casi il tempo di calcolo... è denaro.
      </li>
      <li>
	    Hai problemi di spazio. Ogni pacchetto inutilizzato va a
		intasare lo spazio tra i settori del tuo disco. Un disco con più spazio
		disponibile respira meglio: è un disco che corre felice.
      </li>
      <li>
	    Hai problemi di sicurezza. Ogni pacchetto installato è una potenziale
		falla nella sicurezza del sistema e quando i punti deboli si trovano
		nel software inutilizzato non ci sono scuse.
      </li>
      <li>
	    Sei un devoto sostenitore della
		<uri link="http://www.gentoo.org//main/en/philosophy.xml">Filosofia di
		Gentoo</uri>, e non riesci a sopportare che un povero utente sia
		costretto ad installare contro la propria volontà una serie di pacchetti
		che magari non userà. (Non lo sopportiamo neanche noi).
      </li>
    </ul>
  </li>
  <li>
    Infine, gli split ebuilds permettono una maggiore flessibilità delle flag
	USE durante la compilazione.
  </li>
</ul>

</body>
</section>
<section>
<title>Integrazione tra split ebuilds ed ebuilds monolitici</title>
<body>

<p>
Ebuilds monlitici e splittati possono essere mischiati liberamente. Con una
sola restrizione: se un ebuild monolitico dipende da uno split ebuild, questi
non possono essere installati contemporaneamente. Per questo motivo gli ebuilds
sono vincolati da blocking deps: si può fare solo ciò che emerge permette.
</p>

<p>
Di solito, però, non c'è ragione di usare una configurazione così variegata.
Infatti, si dovrebbero usare soltanto gli split ebuilds ad eccezione di
particolari casi di macchine molto lente (mips).
</p>

<p>
Inoltre gli split ebuilds sono il default. Questo significa che quando un
ebuild dipende da un'altra applicazione di KDE, cercherà di installare uno split
ebuild. Tuttavia, anche il corrispondente ebuild monolitico soddisferà quella
dipendenza, e sarà così possibile emergere manualmente l'ebuild monolitico e
quindi l'ebuild che dipende da questa.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Questione di prestazioni</title>
<section>
<title>Perchè gli split ebuilds sono lenti</title>
<body>

<p>
In precedenza è stato
<uri link="http://bugs.gentoo.org/show_bug.cgi?id=11123">detto</uri>
che gli split ebuilds avrebbero
impiegato più tempo negli emerge di quelle monolitici per il carico di lavoro
maggiore dovuto all'estrazione e alla configurazione da ripetere per ciascun
pacchetto. Un <c>emerge kde-meta</c> completo può richiedere il 20-30% del tempo
in più di un classico <c>emerge kde</c>, inaccettabile per una compilazione già
di per se lunga.
</p>

<p>
Non solo. Ora come ora gli split ebuilds eseguono sempre <c>make -f
admin/Makefile.cvs</c> (significa che verranno eseguiti autoconf, automake, ecc.
e una serie di altri script correlati a KDE). Questo comporta un ulteriore
rallentamento, paragonabile all'esecuzione di configure.
</p>

<p>
Tenuto conto di questo, l'analisi appare deprimente. Comunque, nelle prossime
sezioni verranno esposti diversi fattori che compensano in una certa misura
questo rallentamento.
</p>

<p>
Vale la pena di ripetere che con gli split ebuilds gli aggiornamenti di KDE
dimezzeranno il tempo di compilazione - in alcuni casi lo ridurranno di dieci
volte se non di più - aggiornando solo i pacchetti che sono effettivamente
cambiati. I vantaggi di uno solo di questi aggiornamenti ripaga ampiamente del
tempo richiesto dalla prima installazione.
</p>

<p>
Infine, l'installazione completa di KDE ha senso quando si vogliono valutare
tutti i pacchetti disponibili o quando si vuole configurare un ambiente
multiutente; tuttavia, molte persone usano solo una parte delle 300 e più
applicazioni offerte da KDE. Chiunque si preoccupi veramente della durata
delle compilazioni, come i possessori di macchine un po' datate, può guadagnare
più tempo con l'installazione selettiva dei pacchetti di quanto ne perda per il
carico supplementare di lavoro.
</p>

</body>
</section>
<section>
<title>Miglioramenti alle prestazioni degli split ebuilds</title>
<body>

<p>
Il miglioramento più ovvio sarà quello di distribuire tarballs separati per ogni
split ebuild invece di pezzi dei tarballs monolitici (kdebase, ecc.).
Questo eliminerebbe due dei tre fattori di rallentamento: l'estrazione ripetuta
dei tarballs e la rigenerazione dei makefile (la fase con <c>make -f
admin/Makefile.cvs</c> di cui si parlava).
</p>

<p>
Restiamo però con il problema delle esecuzioni ripetute di configure. La
soluzione più appropriata è confcache: una cache per configure condivisa tra le
esecuzioni di emerge. Esiste già una implementazione in portage (il tool,
non il package tree) in fase di sviluppo; una versione stabile con confcache
potrebbe essere rilasciata tra sei mesi o giù di lì.
</p>

</body>
</section>
<section>
<title>Altri fattori che possono compensare la lentezza degli split ebuilds</title>
<body>

<p>
Nella sezione precedente abbiamo parlato dei metodi per migliorare le prestazioni
degli split ebuilds. Ora parleremo brevemente di alcuni miglioramenti futuri
applicabili anche algli ebuilds monolitici. Questi miglioramenti aiutano a
rendere gli split ebuilds 'sufficientemente veloci' a prescindere da soluzioni
con caratteristiche meno interessanti come gli ebuilds monolitici.
</p>

<ul>
  <li>
    KDE 4.0 dovrebbe essere in grado di usare <uri
    link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri> invece
	di automake, il che, in alcune circostanze, migliora le prestazioni della
	compilazione; più avanti, anche gli ebuilds di KDE 3.4 potrebbero usare
	unsermake.
  </li>
  <li>
    Gli split ebuilds supportano la flag USE kdexdeltas, che permette di
	scaricare soltanto le differenze tra due versioni risparmiando sull'utilizzo
	di banda.
  </li>
  <li>
    Le prestazioni di tutti gli altri tools coinvolti nel processo di
	compilazione migliorano col tempo, oppure sfruttano varie
	caratteristiche correlate a KDE che migliorano le prestazioni. Due esempi
	recenti sono visibility=hidden (GCC 3.4) e gli headers precompilati
	(GCC 4.0). Certo, non dipendono direttamente dal passaggio agli split
	ebuilds ma ci consentiranno di affrontare compilazioni che richiedono
	una maggiore potenza di calcolo.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>FAQ</title>
<section>

<title>Esiste già l'opzione DO_NOT_COMPILE: non produce lo stesso effetto?</title>
<body>

<p>
DO_NOT_COMPILE è una variabile interna all'ambiente di compilazione di KDE.
Permette di scegliere quali sottoriectory non devono essere compilate. Tale
funzione viene già utilizzata per compilare solo una parte dell'ebuild
monolitico di KDE. Ad esempio con <c>DO_NOT_COMPILE=konqueror emerge kdebase</c>
si installa kdebase senza konqueror.
</p>

<p>
Ad ogni modo, l'uso di DO_NOT_COMPILE non deve interferire con le operazioni di
un tool per la gestione automatica dei pacchetti. Non funziona, può portare a
problemi di sistema e non è mai stato supportato. Vi raccomandiamo vivamente di
non usarlo.
</p>

<p>
Ecco un elenco incompleto dei problemi causati da DO_NOT_COMPILE:
</p>

<ul>
  <li>
    Distrugge completamente la gestione delle dipendenze di portage. Portage non
	è a conoscenza di DO_NOT_COMPILE e pensa che l'intero pacchetto monolitico
	sia stato installato e che possa soddisfare le dipendenze di altri
	pacchetti. Di conseguenza avremo problemi con la compilazione, via emerge,
	di altri pacchetti o il loro mancato funzionamento.
  </li>
  <li>
    Costringe l'utente a conoscere il nome e il significato di tutte le
	sottodirectory dei moduli di KDE. Pochi sono in grado di farlo, a meno che
	non siano sviluppatori di KDE: per questo è quasi impossibile fare un uso
	corretto di DO_NOT_COMPILE.
  </li>
  <li>
    Le sottodirectory dei moduli di KDE possono dipendere l'una dall'altra,
	possono richiedere un ordine di compilazione ben preciso, possono richiedere
	la presenza di un altra directory magari non effettivamente installata, e
	così via. Abbiamo fatto un gran lavoro per rendere gli split ebuild funzionanti. DO_NOT_COMPILE non raggiunge gli stessi risultati, neanche la sufficiente conoscenza da parte dell'utente. Tutto quello che puoi ottenere con questo metodo è di evitare di
	compilare solo una piccola parte delle applicazioni. È praticamente
	impossibile usarlo per installare solo kdebase e kdepim, per esempio.
  </li>
  <li>
    Se irei ho installato kmail e oggi voglio installare korn, usando
	DO_NOT_COMPILE sarò comunque costretto a ricompilare kmail. Questo significa
	che DO_NOT_COMPILE resta comunque meno prestante degli split ebuilds.
  </li>
  <li>
    DO_NOT_COMPILE non può essere usato per creare pacchetti precompilati (come
	GRP) che contengono singole applicazioni di KDE.
	</li>
</ul>

</body>
</section>

<section>
<title>Non state caricando troppo i mantainer KDE di Gentoo?</title>
<body>

<p>
È sorprendente vedere quanti pongano questa domanda. Sono felice che gli utenti
ci tengano così in considerazione. Colgo l'occasione per assicurarvi che ci
stiamo occupando degli split ebuilds per nostra libera scelta; che pensiamo di
essere in grado di continuare a migliorarli; e che non c'è alcuna possibilità di
dissuaderci :-)
</p>

<p>
Per la verità c'è da dire che i mantainer delle altre architetture si sono
lamentati per l'aumento del lavoro di test dovuto a così tanti ebuilds separati.
Stiamo lavorando per risolvere questo problema e questo è il motivo principale
per cui gli ebuilds monolitici saranno ancora disponibili per KDE 3.4.
</p>

</body>
</section>
<section>
<title>Avete intenzione di eliminare gli ebuilds vecchio stile (quelli
monolitici)?</title>
<body>

<p>
È nostra intenzione, ma più avanti. Comunque, ci saranno split ebuilds e ebuilds
monolitici per tutte le versioni 3.4 di KDE.
</p>

<p>
Se preferisci gli ebuilds monolitici a quelli splittati, per favore
<uri link="http://bugs.gentoo.org">facci sapere</uri> il motivo.
</p>

</body>
</section>
<section>
<title>Ci sono troppi ebuilds! Come faccio a trovare quello che mi serve?</title>
<body>

<p>
Prima di tutto, nel momento in cui il pacchetto che stai cercando fa
parte di kdebase, puoi ancora eseguire <c>emerge kdebase-meta</c>, con lo stesso
risultato di <c>kdebase</c> monolitico. In realtà le cose non sono peggiorate a
causa degli split ebuilds.
</p>

<p>
Naturalmente tutti i metodi tradizionali per individuare un pacchetto restano
validi. Come avresti trovato il tuo ebuild se avesse fatto parte di Gnome? Come
minimo avresti dovuto conoscerne il nome.
</p>

<p>
Forse la situazione potrebbe essere migliorata introducendo più -meta ebuilds.
Sono soltanto liste di dipendenze, e non ci costerebbe nulla. Questo non è
ancora stato deciso. Inoltre, sarebbe meglio avere la funzionalità delle
impostazioni di Portage prima che sia reso estensivo.
</p>

</body>
</section>
<section>
<title>Come posso eseguire l'unmerge di un vecchio KDE?</title>
<body>

<p>
Supponi che venga rilasciato KDE 4.0 e che tu voglia eseguire l'unmerge di KDE
3.4. Siccome appartengono a slot differenti, emerge non lo potrà fare, così è
necessario trovare un altro metodo.
</p>

<p>
Una soluzione appropriata a questo problema richiede modifiche a portage. Un
esempio si può trovare in
<uri link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>.
Comunque, finchè tali modifiche non saranno presenti, dovremo usare script come
quello indicato più avanti.
</p>


<p>
Fortunatamente tutti gli ebuilds di KDE appartengono alla directory kde-base (e
tutti gli ebuilds nella categoria kde-base provengono da kde.org). Così è
possibile usare il codice che segue:
</p>

<pre>
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
Può sembrare un hack ma in fin dei conti non lo è visto che tutto ciò che ci
occorre è una lista delle ebuilds di kde-base. Non è una cosa difficile da fare,
così ci sarà sempre un modo semplice per riuscirci.
</p>

</body>
</section>
<section>
<title>Come posso elencare oppure eseguire l'unmerge di tutti gli split ebuilds
che derivano da un determinato pacchetto?</title>
<body>

<p>
L'obiettivo è elencare tutti gli split ebuilds di KDE che derivano, diciamo,
dall'ebuild monolitico kdebase. L'implementazione più corretta (come <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>) può
essere banale. Tuttavia potresti essere in qualche modo ferrato
sull'implementazione delle eclasses di KDE, così, se per caso utilizzi uno di
questi approcci in qualche script che non sia per uso privato, faccelo sapere.
</p>

<p>
kde-functions.eclass definisce delle funzioni chiamate get-parent-package() e
get-child-packages(); saranno loro ad eseguire il lavoro altuo posto. Queste
due funzioni sono il modo corretto per eseguire quanto detto prima a
partire da una ebuild o da uno script bash esterno. Ecco un esempio:
</p>

<pre>
$ <i>function die() { echo $@; } # invocato per riportare eventuali errori</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # così non funziona: devi specificare il nome
completo</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug #
l'errore viene riportato</i>
$ <i>get-parent-package kde-base/konqueror # il nome è stato indicato
correttamente</i>
<i>kde-base/kdebase # viene riportato il risultato</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (segue l'elenco dei pacchetti)</i>
</pre>

<p>
Se non stai usando uno script bash, puoi passare kde-functions.eclasses a grep
per estrarre la definizione (multilinea) della variabile KDE_DERIVATION_MAP,
usata dalla funzione di cui sopra. Questa variabile contiene una lista di parole
separate da spazi: ogni coppia di parole lega un pacchetto padre allo split
ebuild figlio.
</p>

</body>
</section>
</chapter>
</guide>
