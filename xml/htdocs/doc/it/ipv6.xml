<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/ipv6.xml,v 1.22 2010/08/25 21:02:16 scen Exp $ -->

<guide lang="it">
<title>Guida al routing IPv6 con Gentoo</title>

<author title="Autore">
  <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Redazione">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Redazione, Revisione">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Redazione">
  <mail link="cam@gentoo.org">Camille Huot</mail>
</author>
<author title="Redazione">
  <mail link="okun@hack.fi">Pasi Valminen</mail>
</author>
<author title="Redazione">
  <mail link="nightmorph"/>
</author>
<author title="Traduzione">
  <mail link="gentoo@virgilio.it">Shev</mail>
</author>
<author title="Traduzione">
  <mail link="rtorsoli@aboutnet.it">Riccardo Torsoli</mail>
</author>
<author title="Traduzione">
  <mail link="isit81@fastwebnet.it">Alfonso Tarantini</mail>
</author>

<abstract>
Questa guida mostra come impostare IPv6 su un sistema Gentoo. La trattazione
comprende l'instaurazione di un tunnel tramite un tunnel broker, alcune
configurazioni di base di DNS e come impostare i client affinchè utilizzino
il sistema per connettersi a indirizzi IPv6.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>3</version>
<date>2010-08-11</date>

<chapter>
<title>Preliminari</title>
<section>
<title>Configurazione di base del kernel</title>
<body>

<p>
Tutti i kernel tree presenti in Gentoo supportano facilmente le connessioni
IPv6. Il nuovo stack IPv6 USAGI è integrato direttamente nel kernel a partire
dalle versioni Linux 2.6.0.
</p>

<pre caption="Installare un kernel">
# <i>emerge gentoo-sources</i>
</pre>

<p>
Ora si è pronti per entrare nella directory dei sorgenti del kernel e iniziarne
la nuova configurazione.
</p>

<pre caption="Configurare il kernel Linux">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<note>
Questo presuppone che il collegamento <path>/usr/src/linux</path> punti ai
sorgenti che si ha intenzione di utilizzare.
</note>

<pre caption="opzioni di 'make menuconfig'">
Device Drivers ---&gt;
Networking support ---&gt;
Networking options ---&gt;
   &lt;*&gt; The IPv6 protocol (EXPERIMENTAL)

<comment>(Le opzioni IPv6 sotto questa voce potrebbero essere utili per diverse applicazioni,)</comment>
<comment>(ma non dovrebbero essere necessarie per una configurazione di base)</comment>
<comment>(Questa opzione è necessaria solo se viene utilizzato ptrtd per la conversione 6to4)</comment>
[*] Network device support
   &lt;*&gt; Universal TUN/TAP device driver support
</pre>

</body>
</section>
<section>
<title>Verificare il supporto IPv6</title>
<body>

<p>
Dopo aver abilitato le opzioni raccomandate, ricompilare il kernel e riavviare
servendosi del nuovo kernel con supporto IPv6.
</p>

<p>
Se non è già stato installato <b>iproute2</b>, è importante farlo ora. iproute2
è una suite di programmi per la configurazione di rete che contiene <c>ip</c>,
il celebre sostituto di <c>ifconfig</c>, <c>route</c>, <c>iptunnel</c> e
altri...
</p>

<pre caption="Installare iproute2">
# <i>emerge sys-apps/iproute2</i>
</pre>

<warn>
L'uso di ifconfig può causare seri problemi se sono attivi tunnel multipli.
Bisogna rimuovere infatti i tunnel in ordine inverso, quindi l'ultimo che è
stato creato deve essere rimosso per primo.
</warn>

<p>
Se IPv6 è attivo, il dispositivo di loopback dovrebbe mostrare un indirizzo
IPv6:
</p>


<pre caption="Controllare il dispositivo di loopback">
# <i>ip -6 addr show lo</i>
1: lo: &lt;LOOPBACK,UP&gt; mtu 16436
     inet6 ::1/128 scope host
        valid_lft forever preferred_lft forever
<comment>(La precedente riga dimostra che tutto sta funzionando)</comment>
</pre>

<p>
Prima di proseguire, assicurarsi di aggiungere <e>ipv6</e> alla propria lista
nella variabile USE in <path>make.conf</path>, in modo tale che i futuri emerge
di pacchetti includeranno il supporto a IPv6.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione di Tunnel</title>
<section>
<title>Configurazione di base</title>
<body>

<p>
La maggior parte degli ISP (ndt, fornitori del servizio Internet) non offre
nessuna connessione IPv6 nativa. Per aggirare questa limitazione, esistono
diversi "tunnel brokers" in giro per il mondo che offrono gratuitamente dei
tunnel IPv6. Questo permetterà  di creare, per le proprie connessioni IPv6, un
tunnel attraverso una connessione IPv4.
</p>

<table>
<tr><th>Broker</th><th>Località </th></tr>
<tr>
  <ti><uri link="http://tunnelbroker.net">Hurricane Electric</uri></ti>
  <ti>Nord America, Europa, Asia</ti>
</tr>
<tr>
  <ti><uri link="http://gogonet.gogo6.com/">Freenet6</uri></ti>
  <ti>Stati Uniti</ti>
</tr>
<tr>
  <ti><uri link="http://www.sixxs.net/">Sixxs</uri></ti>
  <ti>Europa</ti>
</tr>
<tr>
  <ti><uri link="http://tunnel-broker.singnet.com.sg/">Singnet</uri></ti>
  <ti>Singapore</ti>
</tr>
<tr>
  <ti><uri link="http://broker.aarnet.net.au/">Aarnet</uri></ti>
  <ti>Australia/Pacifico Meridionale</ti>
</tr>
</table>

<p>
Di seguito vengono proposti due esempi per impostare un tunnel con due popolari
broker del Nord America, Hurricane Electric e Freenet6.
</p>

</body>
</section>
<section>
<title>Hurricane Electric</title>
<body>

<p>
Hurricane Electric (in breve HE) offre tunnel IPv6 gratuiti e alloca per
l'utente blocchi di indirizzi /64. Inoltre permette la configurazione del
reverse DNS (DNS inverso). Ottenere un tunnel da HE è facile: basta andare su
<uri>http://www.tunnelbroker.net</uri> e compilare una pagina con i propri dati.
</p>

<note>
La registrazione richiede informazioni quali il proprio indirizzo e numero di
telefono.
</note>

<p>
Dopo aver ottenuto un tunnel riconosciuto e allocato un blocco /64, è possibile
configurare la propria Gentoo box. HE fornisce una semplice configurazione
basata sui comandi ifconfig e iproute. I due esempi seguenti presuppongono di
avere una configurazione di questo tipo:
</p>

<table>
<tr>
  <ti>Indirizzo IPv4 locale (eth0)</ti>
  <ti>68.36.91.195</ti>
</tr>
<tr>
  <ti>Indirizzo IPv4 HE</ti>
  <ti>64.71.128.82</ti>
</tr>
<tr>
  <ti>Indirizzo del tunnel IPv6 locale</ti>
  <ti>2001:470:1F00:FFFF::189</ti>
</tr>
<tr>
  <ti>Blocco IPv6</ti>
  <ti>2001:470:1F00:296::/64</ti>
</tr>
</table>

<p>
Usando il pacchetto iproute2 e il comando <c>ip</c>, dare le seguenti
istruzioni:
</p>

<pre caption="Configurazione di un tunnel IPv6">
<comment>(Crea un tunnel tra gli indirizzi IPv4 locale (eth0) e quello remoto di HE)</comment>
# <i>ip tunnel add sixbone mode sit remote 64.71.128.82 local 68.36.91.195 ttl 64 dev eth0</i>
<comment>(Sottrae l'overhead del tunnel dalla MTU)</comment>
# <i>ip link set sixbone mtu 1280 </i>
<comment>(Attiva il tunnel)</comment>
# <i>ip link set sixbone up</i>
<comment>(Assegna l'indirizzo IPv6)</comment>
# <i>ip addr add 2001:470:1F00:FFFF::189 dev sixbone</i>
<comment>(Instrada ogni indirizzo IPv6 attraverso il dispositivo tunnel 'sixbone'</comment>
# <i>ip route add 2003::/3 dev sixbone</i>
</pre>

</body>
</section>
<section>
<title>Freenet6</title>
<body>

<p>
<uri link="http://gogonet.gogo6.com/">Freenet6</uri> è un altro tunnel broker
gratuito. La registrazione richiede soltanto un nome uten ed un indirizzo email
valido. Hanno scelto di gestire il tunnel attraverso un'impostazione
client/server ed hanno creato il client <c>gateway6</c>. Questo client è
disponibile in Portage. Per installarlo eseguire:
</p>

<pre caption="Installare il client Freenet6">
# <i>emerge gateway6</i>
</pre>

<p>
Ora se si ha scelto di connettersi tramite autenticazione bisogna configurare
<c>gateway6</c> modificando <path>/etc/gateway6/gw6c.conf</path>. Bisogna
cambiare soltanto i campi <e>userid</e> e <e>passwd</e> facendoli corrispondere
ai valori assegnati da Freenet6. Segue un semplice e completo esempio di file di
configurazione:
</p>

<pre caption="esempio di gw6c.conf">
auth_method=any
<i>userid=anonymous</i>
<i>passwd=foobar</i>
template=linux
server=broker.freenet6.net
</pre>

</body>
</section>
<section>
<title>Provare la propria connessione</title>
<body>

<p>
Ora che il proprio tunnel è configurato, è possibile provare la connessione. Il
modo più facile per farlo è utilizzare il comando <c>ping6</c> e provare a
pingare un host IPv6.
</p>

<pre caption="Provare la connessione">
# <i>emerge iputils</i>
# <i>ping6 www.kame.net</i>
PING www.kame.net(orange.kame.net) 56 data bytes
64 bytes from orange.kame.net: icmp_seq=1 ttl=52 time=290 ms
64 bytes from orange.kame.net: icmp_seq=2 ttl=52 time=277 ms
64 bytes from orange.kame.net: icmp_seq=3 ttl=52 time=280 ms
64 bytes from orange.kame.net: icmp_seq=4 ttl=52 time=279 ms
64 bytes from orange.kame.net: icmp_seq=5 ttl=52 time=277 ms

--- www.kame.net ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4038ms
rtt min/avg/max/mdev = 277.040/281.041/290.046/4.699 ms
</pre>

<p>
Sono attualmente in corso ulteriori lavori per migliorare il supporto IPv6 negli
script init di rete. Se si vuole conoscere lo stato dei lavori e/o dare una
mano, scrivere a <mail link="latexer@gentoo.org">latexer@gentoo.org</mail>.
</p>

</body>
</section>

</chapter>
<chapter>
<title>Supporto IPv6 nelle applicazioni</title>
<section>
<title>Ri-emergere i pacchetti</title>
<body>

<p>
A meno che non si abbia già impostato in precedenza <e>USE="ipv6"</e> nel
proprio <path>/etc/make.conf</path>, probabilmente bisognerà
ri-effettuare l'operazione di emerge per un certo numero di pacchetti in modo da
ricompilarli con il supporto IPv6 attivo. Per ottenere una lista di tutti i
pacchetti installati che sono influenzati dai cambiamenti della flag USE
<e>ipv6</e>, usare l'opzione del Portage <c>--newuse</c> (<c>-N</c>) :
</p>

<pre caption="Candidati per il re-emerging">
# <i>emerge -uDNav world</i>
</pre>

<p>
Se sono state cambiate molte flag USE, la lista potrebbe essere molto lunga. È
quindi consigliato di mantenere il proprio sistema aggiornato, per evitare
problemi nel caso si decida di ricompilare tutti i pacchetti influenzati dai
cambiamenti alle flag USE.
</p>

<note>
Alcuni pacchetti rilevano automaticamente il supporto a IPv6 e quindi non
possiedono una flag USE ipv6. Quindi non tutti i pacchetti che dovrebbero
supportare IPv6 lo supporteranno, se sono stati compilati in presenza di un
kernel con IPv6 non attivato.
</note>

</body>
</section>
<section>
<title>Pacchetti specifici per IPv6</title>
<body>

<p>
Ci sono diversi pacchetti che si occupano nello specifico delle caratteristiche
di IPv6. La maggior parte di essi è situata in
<path>/usr/portage/net-misc</path>.
</p>

<table>
<tr>
  <th>Pacchetto</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>net-misc/ipv6calc</ti>
  <ti>Converte un indirizzo IPv6 in un formato compresso</ti>
</tr>
<tr>
  <ti>net-misc/netcat6</ti>
  <ti>versione di netcat che supporta IPv6 e IPv4</ti>
</tr>
<tr>
  <ti>dev-perl/Socket6</ti>
  <ti>
    Parte relativa ad IPv6 delle definizioni e dei manipolatori di strutture del
    C socket.h
  </ti>
</tr>
</table>
</body>
</section>
</chapter>

<chapter>
<title>Impostazioni del DNS</title>
<section>
<title>IPv6 e DNS</title>
<body>

<p>
Mentre un DNS per IPv4 usa i record A, il DNS per IPv6 usa i record AAAA.
(questo perchè IPv4 possiede uno spazio di indirizzamento di 2^32 contro lo
spazio di indirizzamento di IPv6 pari a 2^128). Per il reverse DNS (DNS
inverso), lo standard INT è deprecato ma ancora ampiamente supportato. ARPA è
il formato più recente. Qui verrà descritto il supporto per il formato ARPA.
</p>

</body>
</section>
<section>
<title>Configurazione di BIND</title>
<body>

<p>
Le versioni più recenti di BIND includono un eccellente supporto per IPv6. In
questa sezione si assumerà che il lettore possieda almeno le conoscenze minime
necessarie per configurare e utilizzare BIND. Si assumerà inoltre che bind non
giri in un chroot. In caso contrario, appendere semplicemente il prefisso del
chroot nella maggior parte dei percorsi nella sezione seguente.
</p>

<p>
Prima di tutto bisogna aggiungere nei file di zona le impostazioni sia per il
forward che il reverse DNS, in <path>/etc/bind/named.conf</path>.
</p>

<pre caption="Impostazioni di named.conf">
<comment>(Mettere bind in ascolto di indirizzi IPv6.</comment>
<comment>Usare 'any' è l'unico modo per farlo prima di bind-9.3)</comment>
options {
        [...]
        listen-on-v6 { any; }
        [...]
};
<comment>(Questo fornirà  il forward DNS per il dominio 'ipv6-rules.com':)</comment>
zone "ipv6-rules.com" IN {
        type master;
        file "pri/ipv6-rules.com";
};
<comment>(Il formato per il reverse DNS è il "bitwise." È ottenuto prendendo il prefisso IPv6,</comment>
<comment>invertendo l'ordine dei numeri e aggiungendo un punto fra ogni numero)</comment>
zone "6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa" {
        type master;
        file "pri/rev-ipv6-rules.com.arpa";
};
</pre>

<p>
Ora bisogna creare per ognuno dei propri host i file di zona e aggiungervi le
impostazioni necessarie:
</p>

<pre caption="pri/ipv6-rules.com">
$TTL    2h
@       IN      SOA     ipv6-rules.com. webmaster.ipv6-rules.com.  (
                                2003052501 ; Serial
                                28800      ; Refresh
                                14400      ; Retry
                                3600000    ; Expire
                                86400 )    ; Minimum
                                NS      ns1.ipv6-rules.com

        IN      AAAA    2001:470:1f00:296::1 ; address for ipv6-rules.com
host1   IN      AAAA    2001:470:1f00:296::2 ; address for host1.ipv6-rules.com
host2   IN      AAAA    2001:470:1f00:296::3:3 ; address for host2.ipv6-rules.com
</pre>

<pre caption="pri/rev-ipv6-rules.com.arpa">
$TTL 3d ; Default TTL (bind 8 needs this, bind 9 ignores it)
@       IN SOA ipv6-rules.com. webmaster.ipv6-rules.com. (
                        2003052501      ; Serial number (YYYYMMdd)
                        24h             ; Refresh time
                        30m             ; Retry time
                        2d              ; Expire time
                        3d )            ; Default TTL
        IN      NS     ns1.ipv6-rules.com.
; IPv6 PTR entries
$ORIGIN 6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int.

1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     ipv6-rules.com.
2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host1.ipv6-rules.com.
3.0.0.0.3.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host2.ipv6-rules.com.
</pre>

</body>
</section>
<section>
<title>Configurazione di DJBDNS</title>
<body>

<p>
Attualmente esistono diverse patch di terze parti per DJBDNS, disponibili su
<uri>http://www.fefe.de/dns/"</uri>, che gli permettono di funzionare anche con
IPv6. DJBDNS può essere installato con queste patch installandolo con la flag
<e>ipv6</e> impostata nella propria variabile USE.
</p>

<warn>
Tuttavia anche con queste patch non sono supportati tutti i tipi di record. In
particolare, non sono supportati i record NS e MX.
</warn>

<pre caption="Installare djbdns">
# <i>emerge djbdns</i>
</pre>

<p>
Dopo che djbdns è stato installato, può essere configurato dando
<c>tinydns-setup</c> e rispondendo alle poche domande circa a quale indirizzo
legarlo, dove installare tinydns, ecc.
</p>

<pre caption="Impostare tinydns">
# <i>tinydns-setup</i>
</pre>

<p>
Asummendo di aver installato <c>tinydns</c> in <path>/var/tinydns</path>, ora si
può modificare <path>/var/tinydns/root/data</path>. Questo file conterrà tutti i
dati necessari per far sì che tinydns gestisca il DNS per la propria delegazione
IPv6.
</p>

<pre caption="File d'esempio">
<comment>(*.ipv6-rules.com è autoritativamente gestito da 192.168.0.1)</comment>
.ipv6-rules.com:192.168.0.1:a:259200
<comment>(Reverse DNS autoritativo per 2001:470:1f00:296::/64)</comment>
.6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa:192.168.0.1:a
<comment>(Specifica gli IP per host1 e host2)</comment>
6host1.ipv6-rules.com:200104701f0002960000000000000001:86400
6host2.ipv6-rules.com:200104701f0002960000000000000002:86400
<comment>(Fa puntare www a host1)</comment>
3www.ipv6-rules.com:200104701f0002960000000000000002:86400
</pre>

<p>
Le linee con prefisso <c>6</c> avranno impostato sia un record AAAA che PTR.
Quelle con prefisso <c>3</c> avranno impostato soltanto un record AAAA. Oltre a
modificare manualmente il file <path>data</path>, è possibile utilizzare gli
script <c>add-host6</c> e <c>add-alias6</c> per aggiungere nuove voci. Dopo
aver fatto i cambiamenti al file <path>data</path>, basta dare il comando
<c>make</c> da <path>/var/tinydns/root</path>. Questo creerà
<path>/var/tinydns/root/data.cfb</path>, che tinydns userà  come fonte di
informazione per le richieste di DNS.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Router IPv6</title>
<section>
<title>Configurare il routing (instradamento)</title>
<body>

<p>
Se si desidera utilizzare il proprio sistema come router per gli altri client
che vogliono collegarsi al mondo esterno con IPv6, sono necessarie ulteriori
configurazioni. Bisogna abilitare il forwarding dei pacchetti IPv6, e lo si può
fare in uno dei due seguenti modi.
</p>

<pre caption="Abilitare il forwarding">
# <i>echo 1 > /proc/sys/net/ipv6/conf/all/forwarding</i>
o
# <i>sysctl -w net.ipv6.conf.all.forwarding=1</i>
</pre>

<warn>
Lo script di init <c>radvd</c> abilita (e disabilita) il forwarding, rendendo
inutile il passo seguente.
</warn>

<p>
Per abilitare il forwarding al boot, bisogna modificare
<path>/etc/sysctl.conf</path> e aggiungere la seguente linea.
</p>

<pre caption="Aggiunta a sysctl.conf">
<comment>(Se verrà usato radvd, questo passo non sarà necessario)</comment>
net.ipv6.conf.default.forwarding=1
</pre>

<p>
Il traffico dovrebbe essere ora inviato da questa macchina attraverso il tunnel
stabilito con il proprio broker.
</p>

<p>
Per assegnare gli indirizzi IPv6 ai client, la specifica di IPv6 permette sia
l'assegnazione IP stateless (senza stati) che statefull (con stati).
L'assegnazione stateless utilizza un processo chiamato Router Advertisement e
permette ai client di ottenere un IP e una route predefinita semplicemente
attivando un'interfaccia. È chiamato "stateless" poichè non viene registrata
l'assegnazione degli IP e a quali host sono stati attribuiti. L'assegnazione
stateful è gestita tramite DHCPv6. Questo metodo è "stateful" poichè il server
mantiene uno stato dei client che hanno richiesto e ricevuto un IP.
</p>

</body>
</section>
<section>
<title>Configurazione Stateless</title>
<body>

<p>
La configurazione Stateless è facilmente ottenibile utilizzando il Router
Advertisement Daemon, o <c>radvd</c>.
</p>

<pre caption="Configurare radvd">
# <i>emerge radvd</i>
</pre>

<p>
Dopo aver emerso <c>radvd</c>, bisogna creare <path>/etc/radvd/radvd.conf</path>
che contiene le informazioni circa quali blocchi IP utilizzare per assegnare gli
indirizzi. Di seguito viene offerto un semplice file <path>radvd.conf</path> che
utilizza il prefisso assegnato dal proprio tunnel broker.
</p>

<pre caption="radvd.conf d'esempio">
interface eth1
{

        <comment>(Invia un messaggio d'avviso agli altri hosts)</comment>
        AdvSendAdvert on;
        <comment>(La frammentazione è un male(tm))</comment>
        AdvLinkMTU 1280;
        MaxRtrAdvInterval 300;
        <comment>(Il prefisso della sottorete IPv6 viene assegnato dal proprio PoP)</comment>
        prefix 2001:470:1F00:296::/64
        {
                AdvOnLink on;
                AdvAutonomous on;
        };
};
</pre>

<warn>
Assicurarsi che l'interfaccia indicata nella prima linea sia corretta in modo da
trasmettere gli advertisement del proprio router alla propria rete e non al
proprio ISP!
</warn>

<p>
Altre informazioni sono disponibili su <c>man radvd.conf</c>. Ora si può avviare
<c>radvd</c> e impostarlo affinchè venga avviato al boot.
</p>

<pre caption="Attivare radvd">
# <i>/etc/init.d/radvd start</i>
# <i>rc-update add radvd default</i>
</pre>

</body>
</section>
<section>
<title>Configurazione Stateful</title>
<body>

<p>
Nel caso si voglia servirsi della configurazione stateful, bisogna installare e
configurare dhcpv6.
</p>

<pre caption="Installare dhcpv6">
# <i>emerge dhcpv6</i>
</pre>

<p>
Configurare qundi il server DHCPv6 modificando <path>/etc/dhcp6s.conf</path>.
</p>

<pre caption="dhcp6s.conf d'esempio">
prefer-life-time 10000;
valid-life-time 20000;
renew-time 5000;
rebind-time 8000;
interface eth1 {
        link AAA {
                allow unicast;
                send unicast;
                allow rapid-commit;
                send server-preference 5;
                renew-time 1000;
                rebind-time 2400;
                prefer-life-time 2000;
                valid-life-time 3000;
                pool{
                range 2001:470:1f00:296::10 to 2001:470:1f00:296::110/64;
                prefix 2001:470:1f00:296::/64;
                };
        };
};
</pre>

<p>
È ora possibile avviare dhcp6s e configurarlo perchè venga avviato al boot.
</p>

<pre caption="Attivare dhcp6s">
# <i>/etc/init.d/dhcp6s start</i>
# <i>rc-update add dhcp6s default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Client IPv6</title>
<section>
<title>Usando radvd</title>
<body>

<p>
I client dietro questo router dovrebbero potersi ora connettere al resto della
rete tramite IPv6. Se si usa radvd, configurare gli host dovrebbe essere facile
come attivarne le interfacce (questo sarà  probabilmente già stato fatto dai
propri script init net.ethX).
</p>

<pre caption="Connettersi attraverso IPv6">
# <i>ip link set eth0 up</i>
# <i>ip addr show eth0</i>
1: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1400 qdisc pfifo_fast qlen 1000
    link/ether 00:01:03:2f:27:89 brd ff:ff:ff:ff:ff:ff
    inet6 2001:470:1f00:296:209:6bff:fe06:b7b4/128 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::209:6bff:fe06:b7b4/64 scope link
       valid_lft forever preferred_lft forever
    inet6 ff02::1/128 scope global
       valid_lft forever preferred_lft forever
</pre>

</body>
</section>
<section>
<title>Usare DHCPv6</title>
<body>

<p>
Se il proprio router è impostato per utilizzare DHCPv6, anche i propri client
dovranno avere installato il pachetto <c>net-misc/dhcpv6</c>. Dopo aver
provveduto all'installazione, si dovranno configurare i client modificando
<path>/etc/dhcp6c.conf</path>.
</p>

<pre caption="dhcp6c.conf d'esempio">
interface eth0 {
        send rapid-commit;
        request domain-name-servers;
        iaid 11111;
        renew-time 11000;
};
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Usare la conversione 6to4</title>
<section>
<title>Principi di base</title>
<body>

<p>
La conversione 6to4 può essere utilizzata qualora si vogliano avere host
comunicanti con altri host IPv4 puramente attraverso connessioni IPv6. In questo
modo sarà possibile avere una rete interna esclusivamente IPv6, con un solo host
che si occupi della connessione con il mondo esterno IPv4/IPv6.
</p>

</body>
</section>
<section>
<title>Configurazione del DNS</title>
<body>

<p>
Per ottenere una conversione 6to4 funzionante, deve essere configurato un proxy
DNS, <c>totd</c>, affinchè trasmetta alla rete interna record AAAA per quei siti
che in realtà possiedono solo records A. Questi records AAAA punteranno a
indirizzi IPv6 che sono attualmente inesistenti, ma che saranno convertiti in
destinazioni valide attraverso l'instradamento del proxy 6to4.
</p>

<p>
Per prima cosa, installare <c>totd</c>:
 </p>

<pre caption="Installare totd">
# <i>emerge totd</i>
</pre>

<p>
Adesso bisogna impostare <path>/etc/totd.conf</path> con alcune informazioni di
configurazione di base.
</p>

<pre caption="/etc/totd.conf d'esempio">
<comment>(Punta al vero nameserver DNS)</comment>
forwarder 192.168.0.2 port 53
<comment>(Quale prefisso mettere prima del record falso AAAA)</comment>
prefix 3ffe:abcd:1234:9876::
<comment>(Su quale porta far girare totd)</comment>
port 5005
<comment>(Quale file PID usare)</comment>
pidfile /var/run/totd.pid
<comment>(Fa la funzione 6to4)</comment>
stf
</pre>

<note>
<c>totd</c> deve essere regolato affinchè si serva di una porta differente dalla
53 qualora sulla stessa macchina giri un altro nameserver.
</note>

</body>
</section>
<section>
<title>Proxy 6to4</title>
<body>

<p>
<c>ptrtd</c> sarà utilizzato come proxy 6to4, abilitando le connessioni tra gli
host IPv6 interni e quelli IPv4 esterni.
</p>

<pre caption="Installare ptrtd">
# <i>emerge ptrtd</i>
</pre>

<p>
Ora bisogna configurare <c>ptrtd</c>, dicendogli quale prefisso simulato (quello
utilizzato per impostare <c>totd</c>) creare per le connessioni proxy.
Modificare <path>/etc/conf.d/ptrtd</path> ed impostare <c>IPV6_PREFIX</c>.
Questo dovrebbe essere lo stesso prefisso che è stato configurato con
<c>totd</c>.
</p>

<pre caption="/etc/ptrtd.conf d'esempio">
IPV6_PREFIX="3ffe:abcd:1234:9876::"
</pre>

<p>
Ora è possibile avviare totd ed impostare che venga avviato al boot.
</p>

<pre caption="Avviare totd">
# <i>/etc/init.d/totd start</i>
# <i>rc-update add totd default</i>
</pre>

</body>
</section>
<section>
<title>Configurazione e prova del client</title>
<body>

<p>
I client possono ora essere configurati per collegarsi a host sia IPv4 che
IPv6 attraverso una sola connessione IPv6. Supponendo che i client abbiamo già
ricevuto un indirizzo IP da radvd, bisogna semplicemente aggiungere una nuova
voce di risoluzione DNS e aggiungere una default route per gli indirizzi
"simulati" (falsi, fake). Prima di tutto aggiungere una voce in cima al proprio
<path>/etc/resolv.conf</path> che punti alla macchina sulla quale gira
<c>totd</c>.
</p>

<pre caption="/etc/resolv.conf d'esempio">
nameserver 2001:470:1f00:296::1 <comment>(Il server su cui gira totd)</comment>
</pre>

<p>
Per provare la risoluzione dei nomi, richiedere un record AAAA per un sito
conosciuto (che sia solo IPv4).
</p>

<pre caption="Provare la risoluzione dei nomi">
# <i>dig aaaa google.com</i>
;; ANSWER SECTION:
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3364
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3564
</pre>

<p>
si dovrà ora aggiungere una route predefinita per tutti gli indirizzi preceduti
dal prefisso simulato che è stato scelto.
</p>

<pre caption="Aggiungere la route di default">
<comment>(Si assume che l'interfaccia IPv6 sia eth0)</comment>
# <i>ip route add 3ffe:abcd:1234:9876::/64 via 2001:470:1f00:296::1 dev eth0</i>
</pre>

<p>
Infine, usare <c>ping6</c> per pingare google.com nella sua versione IPv6
simulata.
</p>

<pre caption="Provare 6to4">
# <i>ping6 -c 2 google.com</i>
PING 3ffe:abcd:1234:9876::d8ef:3364(3ffe:abcd:1234:9876::d8ef:3364) 56 data bytes
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=1 ttl=54 time=0.106 ms
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=2 ttl=54 time=0.090 ms

--- 3ffe:abcd:1234:9876::d8ef:3364 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.090/0.098/0.106/0.008 ms
</pre>

<note>
Il router su cui gira <c>ptrtd</c> sta realmente rispondendo, ma questo basta
per capire se le cose stanno funzionando o meno.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Altre risorse</title>
<section>
<body>
<p>
Ci sono online molte eccellenti risorse riguardanti IPv6.
</p>

<table>
<tr>
  <th>Sito Web</th>
  <th>Risorse</th>
</tr>
<tr>
  <ti><uri link="http://www.ipv6.org/">www.ipv6.org</uri></ti>
  <ti>Informazioni generali su IPv6</ti>
</tr>
<tr>
  <ti><uri link="http://www.linux-ipv6.org/">www.linux-ipv6.org/</uri></ti>
  <ti>Progetto USAGI</ti>
</tr>
<tr>
  <ti><uri link="http://www.deepspace6.net/">www.deepspace6.net</uri></ti>
  <ti>Sito su Linux/IPv6</ti>
</tr>
<!-- dead, was hacked<tr>
  <ti><uri link="http://www.hs247.com/">www.hs247.com</uri></ti>
  <ti>Tutto su IPv6</ti>
</tr>-->
<!-- dead, not responding<tr>
  <ti><uri link="http://www.ipv6-net.org/">www.ipv6-net.org</uri></ti>
  <ti>Sito tedesco su IPv6</ti>
</tr>-->
<tr>
  <ti><uri link="http://www.kame.net/">www.kame.net</uri></ti>
  <ti>Implementazione *BSD</ti>
</tr>
</table>

<p>
In IRC, si può provare ad entrare in <c>#ipv6</c> o <c>#ipv6</c> su <uri
link="http://www.freenode.net">Freenode</uri>. È possibile connettersi ai server
Freenode utilizzando un client con supporto IPv6 connettendosi a
<b>irc.ipv6.freenode.net</b>.
</p>

</body>
</section>
</chapter>
</guide>
