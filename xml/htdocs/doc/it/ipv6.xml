<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/ipv6.xml,v 1.5 2004/02/17 18:00:31 mush Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/ipv6.xml">

<title>Gentoo IPv6 Router Guide</title>
<author title="Autore originale">
    <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Aggiornamento">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Redattore, revisore">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Traduttore">
    <mail link="gentoo@virgilio.it">Shev</mail>
</author>
<author title="Traduttore">
    Team Italiano
</author>

<license/>

<abstract>
Questa guida mostra come impostare IPv6 su un sistema Gentoo. La trattazione comprende
l'instaurazione di un tunnel tramite un tunnel broker (un mediatore di tunnel), 
alcune configurazioni di base di DNS e come impostare i clients affinchè utilizzino
il sistema per connettersi a indirizzi IPv6.
</abstract>

<version>1.0.3</version>
<date>9 Febbraio 2004</date>

<chapter>

<title>Impostazioni del Kernel</title>

<section>
<title>Configurazione di base del kernel</title>
<body>
<p>
Tutti i kernel appartenenti al ramo 2.4 presenti in Gentoo supporteranno
facilmente le connessioni IPv6. In più, sia <c>sys-kernel/gentoo-sources</c> che 
<c>sys-kernel/pfeifer-sources</c> possono avere opzionalmente applicate le patch USAGI.
L'insieme di patch USAGI non è indispensabile, ma è in fase d'attivo sviluppo
e implementa diversi elementi di IPv6 altrimenti non presenti nel kernel.
</p>

<pre caption="Emergere un kernel">
# <i>emerge gentoo-sources</i>
<comment>o</comment>
# <i>emerge pfeifer-sources</i>
</pre>

<p>
Ora siete pronti per entrare nella directory dei sorgenti del kernel
e iniziarne la nuova configurazione.
</p>

<pre caption="Configurare il kernel Linux">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<note>
Questo presuppone che il symlink <path>/usr/src/linux</path> punti ai sorgenti
che avete intenzione di utilizzare.
</note>

<note>
Assicuratevi di avere abilitato nella vostra configurazione del kernel la voce
<path>Prompt for development and/or incomplete code/drivers</path>.
</note>

<pre caption = "opzioni di 'make menuconfig'">
Networking options ---&gt;
   &lt;*&gt; IP: tunneling
   ...
   &lt;*&gt; The IPv6 protocol (EXPERIMENTAL) ---&gt;

<codenote>Le opzioni IPv6 sotto questa voce potrebbero essere utili per diverse applicazioni,</codenote>
<codenote>ma non dovrebbero essere necessarie per una configurazione di base</codenote>

Network device support ---&gt;
   &lt;*&gt; Universal TUN/TAP device driver support
<codenote>Questa opzione è necessaria solo se utilizzate ptrtd per la conversione 6to4</codenote>
</pre>

</body>
</section>

<section>
<title>Verificare il supporto IPv6</title>
<body>

<p>
Dopo aver abilitato le opzioni raccomandate, ricompilate il vostro kernel e
riavviate servendovi del nuovo kernel con supporto IPv6. Se IPv6 è attivo,
il dispositivo di loopback dovrebbe mostrare un indirizzo IPv6.
</p>

<pre caption = "Controllare il dispositivo di loopback">
# <i>ifconfig lo</i>
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
	  inet6 addr: ::1/128 Scope:Host
	  <codenote>La precedente riga mostra se le cose stanno funzionando</codenote>
	  UP LOOPBACK RUNNING  MTU:16436  Metric:1
	  RX packets:6 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
	  collisions:0 txqueuelen:0
	  RX bytes:456 (456.0 b)  TX bytes:456 (456.0 b)
</pre>

<p>
Prima di proseguire, assicuratevi di aggiungere "ipv6" alla vostra lista nella variabile USE
in make.conf, in modo tale che i futuri emerge di pacchetti includeranno il supporto a IPv6
</p>

</body>
</section>

</chapter>
<chapter>

<title>Configurazione di Tunnel</title>

<section>
<title>Configurazione di base</title>
<body>

<p>
La maggior parte degli ISP (ndt, fornitori del servizio Internet) non offre nessuna
connessione IPv6 nativa. Per aggirare questa limitazione, esistono diversi "tunnel brokers"
in giro per il mondo che offrono gratuitamente dei tunnel IPv6. Questo vi permetterà di
di creare, per le vostre connessioni IPv6, un tunnel attraverso una connessione IPv4.
</p>

<table>
<tr><th>Broker</th><th>Località</th></tr>
<tr><ti><uri link="http://tunnelbroker.net">Hurricane Electric</uri></ti><ti>US/Canada</ti></tr>
<tr><ti><uri link="http://www.freenet6.net">Freenet6</uri></ti><ti>US</ti></tr>
<tr><ti><uri link="http://ipng.org.uk">IPnG</uri></ti><ti>UK</ti></tr>
<tr><ti><uri link="http://tb.ipv6.btexact.com">BTExact</uri></ti><ti>Europe</ti></tr>
</table>

<p>
Di seguito trovate due esempi per impostare un tunnel con due popolari
broker del Nord America, Hurricane Electric e Freenet6.
</p>
</body>
</section>

<section>
<title>Hurricane Electric</title>
<body>

<p>
Hurricane Electric (in breve HE) offre tunnel IPv6 gratuiti e alloca per voi
blocchi di indirizzi /64. Inoltre permette la configurazione del
reverse DNS (DNS inverso). Ottenere un tunnel da HE è facile come andare
su <uri>http://www.tunnelbroker.net</uri> e compilare una pagina con i propri
dati.
</p>

<note>
La registrazione richiede informazioni quali il vostro indirizzo e numero
di telefono.
</note>

<warn>
I tunnel ottenuti da HE richiedono 24 ore per essere attivati. Ciò per porre un
freno all'abuso di tale servizio.
</warn>

<p>
Dopo aver ottenuto un tunnel riconosciuto e allocato un blocco /64, potete
configurare la vostra Gentoo box. HE fornisce una semplice configurazione basata
sui comandi ifconfig e iproute. I due esempi seguenti presuppongono che abbiate una
configurazione di questo tipo:
</p>

<table>
<tr><ti>Indirizzo IPv4 locale</ti><ti>68.36.91.195</ti></tr>
<tr><ti>Indirizzo IPv4 HE</ti><ti>64.71.128.82</ti></tr>
<tr><ti>Indirizzo del tunnel IPv6 locale</ti><ti>2001:470:1F00:FFFF::189</ti></tr>
<tr><ti>Blocco IPv6</ti><ti>2001:470:1F00:296::/64</ti></tr>
</table>

<p>
Se utilizzate i net-tools e <c>ifconfig</c>, date i comandi che seguono:
</p>

<pre caption="Configurazione con ifconfig">
# <i>ifconfig sit0 up</i>
# <i>ifconfig sit0 inet6 tunnel ::64.71.128.82 </i>
<codenote>Aggiunge un tunnel all'indirizzo IPv4 di HE</codenote>
# <i>ifconfig sit1 up</i>
# <i>ifconfig sit1 inet6 add 2001:470:1F00:FFFF::189/127</i>
# <i>route -A inet6 add ::/0 dev sit1</i>
<codenote>Instrada tutto il traffico IPv6 attraverso il dispositivo 'sit1'</codenote>
</pre>

<p>
Se preferite il pacchetto iproute e il comando <c>ip</c>, date le seguenti istruzioni:
</p>

<pre caption="Configurazione con ip">
# <i>ip tunnel add sixbone mode sit remote 64.71.128.82 local 68.36.91.195 ttl 255</i>
<codenote>Crea un tunnel tra gli indirizzi IPv4 locale e quello remoto di HE</codenote>
# <i>ip link set sixbone up</i>
# <i>ip addr add 2001:470:1F00:FFFF::189/127 dev sixbone</i>
<codenote>Attiva il tunnel e assegna ad esso l'indirizzo IPv6</codenote>
# <i>ip route add ::/0 dev sixbone</i>
<codenote>Instrada ogni indirizzo IPv6 attraverso il vostro dispositivo tunnel 'sixbone'</codenote>
</pre>

</body>
</section>

<section>
<title>Freenet6</title>
<body>

<p>
<uri link="http://www.freenet6.net">Freenet6</uri> è un altro tunnel broker gratuito.  
La registrazione richiede soltanto uno username e un indirizzo email valido.
Hanno scelto di gestire il tunnel attraverso un'impostazione client/server ed
hanno creato il client <c>tscp</c>. Questo client è disponibile nel portage.
Per installarlo date:
</p>

<pre>
# <i>emerge freenet6</i>
</pre>

<p>
Ora dovete configurare freenet6 modificando 
<path>/etc/freenet6/tspc.conf</path>. Dovrete cambiare soltanto i campi
<path>userid</path> e <path>passwd</path> facendoli corrispondere ai valori
assegnati da Freenet6. Segue un semplice e completo esempio di file
di configurazione:
</p>

<pre caption="esempio di tspc.conf">
tsp_version=1.0.1
tsp_dir=/etc/freenet6
auth_method=any
client_v4=auto
<i>userid=anonymous</i>
<i>passwd=foobar</i>
template=gentoo
server=tsps1.freenet6.net
retry_delay=0
if_tunnel=sit3
</pre>

</body>
</section>

<section>
<title>Provare la vostra connessione</title>
<body>

<p>
Ora che il vostro tunnel è configurato, potete provare la connessione. Il 
modo più facile per farlo è utilizzare il comando <c>ping6</c> e provare
a pingare un host IPv6.
</p>

<pre caption = "Provare la connessione">
# <i>emerge iputils</i>
# <i>ping6 www.kame.net</i>
PING www.kame.net(orange.kame.net) 56 data bytes
64 bytes from orange.kame.net: icmp_seq=1 ttl=52 time=290 ms
64 bytes from orange.kame.net: icmp_seq=2 ttl=52 time=277 ms
64 bytes from orange.kame.net: icmp_seq=3 ttl=52 time=280 ms
64 bytes from orange.kame.net: icmp_seq=4 ttl=52 time=279 ms
64 bytes from orange.kame.net: icmp_seq=5 ttl=52 time=277 ms

--- www.kame.net ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4038ms
rtt min/avg/max/mdev = 277.040/281.041/290.046/4.699 ms
</pre>

<p>
Sono attualmente in corso ulteriori lavori per migliorare il supporto
IPv6 negli script init di rete. Se volete conoscere lo stato dei lavori
e/o dare una mano, scrivete a <mail link="latexer@gentoo.org">latexer@gentoo.org</mail>.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Supporto IPv6 nelle applicazioni</title>

<section>
<title>Ri-emergere i pacchetti</title>
<body>

<p>
A meno che aveste impostato in precedenza USE="ipv6" nel vostro <path>/etc/make.conf</path>,
dovrete probabilmente ri-emergere un certo numero di pacchetti per ricompilarli
con il supporto IPv6 attivo. Per ottenere una lista di tutti i pacchetti installati
che potrebbero fare uso della variabile USE 'ipv6', potete eseguire il seguente comando.
</p>

<pre caption="Candidati per il re-emerging">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | cut -d' ' -f1</i>
</pre>

<p>
Per poter ri-emergere più facilmente la maggior parte dei pacchetti selezionati, date:
</p>

<pre caption="Candidati per il re-emerging">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | \</i>
&gt; <i>cut -d' ' -f1 > packages</i>
</pre>

<p>
Adesso modificate il file <path>packages</path> ottenuto, rimuovendo tutti quei 
pacchetti che non volete siano ricompilati in questo momento. Infine date semplicemente:
</p>

<pre>
# <i>emerge `cat packages`</i>
</pre>

</body>
</section>

<section>
<title>Pacchetti specifici per IPv6</title>
<body>

<p>
Ci sono diversi pacchetti che si occupano nello specifico delle caratteristiche di IPv6.
La maggior parte di essi è situata in <path>/usr/portage/net-misc</path>.
</p>

<table>
<tr><th>Pacchetto</th><th>Descrizione</th></tr>
<tr><ti>net-misc/ipv6calc</ti><ti>Converte un indirizzo IPv6 in un formato compresso</ti></tr>
<tr><ti>net-misc/nc6</ti><ti>versione di netcat che supporta IPv6 e IPv4</ti></tr>
<tr><ti>dev-perl/Socket6</ti><ti>Parte relativa ad IPv6 delle definizioni e dei manipolatori di strutture del C socket.h
</ti></tr>
</table>
</body>
</section>

</chapter>
<chapter>

<title>Impostazioni del DNS</title>

<section>
<title>IPv6 e DNS</title>
<body>

<p>
Mentre un DNS per IPv4 usa i record A, il DNS per IPv6 usa i record AAAA.
(questo perchè IPv4 possiede uno spazio di indirizzamento di 2^32 contro
lo spazio di indirizzamento di IPv6 pari a 2^128). Per il reverse DNS (DNS inverso),
è supportato l'INT standard. ARPA è il formato più recente, ma non è molto diffuso
come invece lo è INT. Qui verrà descritto il supporto per il formato INT. 
</p>

</body>
</section>

<section>
<title>Configurazione di BIND</title>
<body>

<p>
Le versioni più recenti di BIND includono un eccellente supporto per IPv6.
In questa sezione assumeremo che possediate almeno le conoscenze minime necessarie
per configurare e utilizzare BIND. Assumeremo inoltre che bind non giri in un chroot.
In caso contrario, semplicemente appendete il prefisso del chroot nella maggior parte
dei cammini (path) nella sezione seguente. 
</p>

<p>
Prima di tutto dovete aggiungere nei file di zona le impostazioni sia per il forward 
che il reverse DNS, in <path>/etc/bind/named.conf</path>.
</p>

<pre caption="impostazioni di named.conf">
zone "ipv6-rules.com" IN {
	type master;
	file "pri/ipv6-rules.com";
};
<codenote>Questo fornirà il forward DNS per il dominio 'ipv6-rules.com'</codenote>
zone "6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int" {
	type master;
	file "pri/rev-ipv6-rules.com.int";
};
<codenote>Il formato per il reverse DNS è il "bitwise." E' ottenuto prendendo il prefisso IPv6,</codenote>
<codenote>invertendo l'ordine dei numeri e aggiungendo un punto fra ogni numero</codenote>
</pre>

<p>
Ora dobbiamo creare per ognuno dei nostri host i file di zona e aggiungervi
le impostazioni necessarie:
</p>

<pre caption="pri/ipv6-rules.com">
$TTL    2h
@       IN      SOA     ipv6-rules.com. webmaster.ipv6-rules.com.  (
                                2003052501 ; Serial
				28800      ; Refresh
				14400      ; Retry
				3600000    ; Expire
				86400 )    ; Minimum
			NS      ns1.ipv6-rules.com

	IN	AAAA	2001:470:1f00:296::1 ; address for ipv6-rules.com
host1	IN	AAAA	2001:470:1f00:296::2 ; address for host1.ipv6-rules.com
host2	IN	AAAA	2001:470:1f00:296::3:3 ; address for host2.ipv6-rules.com
</pre>

<pre caption="pri/rev-ipv6-rules.com.int">
$TTL 3d ; Default TTL (bind 8 needs this, bind 9 ignores it)
@       IN SOA ipv6-rules.com. webmaster.ipv6-rules.com. (
                        2003052501      ; Serial number (YYYYMMdd)
			24h             ; Refresh time
			30m             ; Retry time
			2d              ; Expire time
			3d )            ; Default TTL
	IN      NS     ns1.ipv6-rules.com.
; IPv6 PTR entries
$ORIGIN 6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int.

1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     ipv6-rules.com.
2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host1.ipv6-rules.com.
3.0.0.0.3.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host2.ipv6-rules.com.
</pre>

</body>
</section>

<section>
<title>Configurazione di DJBDNS</title>
<body>

<p>
Attualmente esistono diverse patches di terze parti per DJBDNS, disponibili su 
<uri link="http://www.fefe.de/dns/">http://www.fefe.de/dns/</uri>, che gli 
permettono di funzionare anche con IPv6. DJBDNS può essere installato con 
queste patch emergendolo con la flag "ipv6" impostata nella vostra variabile USE.
</p>

<warn>
Tuttavia anche con queste patch non sono supportati tutti i tipi di record.
In particolare, non sono supportati i record NS e MX.
</warn>

<pre>
# <i>USE="ipv6" emerge djbdns</i>
</pre>

<p>
Dopo che djbdns è installato, può essere configurato dando
<c>tinydns-setup</c> e rispondendo alle poche domande circa
a quale indirizzo legarlo, dove installare tinydns, ecc.
</p>

<pre caption = "Impostare tinydns">
# <i>tinydns-setup</i>
</pre>

<p>
Asummendo di aver installato <c>tinydns</c> in <path>/var/tinydns</path>, 
possiamo ora modificare <path>/var/tinydns/root/data</path>. Questo file 
conterrà tutti i dati necessari per ottenere che tinydns gestisca il DNS
per la vostra delegazione IPv6.
</p>

<pre caption="file con dati d'esempio">
.ipv6-rules.com:192.168.0.1:a:259200
<codenote>*.ipv6-rules.com è autoritativamente gestito da 192.168.0.1</codenote>
.6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int:192.168.0.1:a
<codenote>Reverse DNS autoritativo per 2001:470:1f00:296::/64</codenote>
6host1.ipv6-rules.com:200104701f0002960000000000000001:86400
6host2.ipv6-rules.com:200104701f0002960000000000000002:86400
<codenote>Specifica gli IP per host1 e host2</codenote>
3www.ipv6-rules.com:200104701f0002960000000000000002:86400
<codenote>Fa puntare www a host1</codenote>
</pre>

<p>
Le linee con prefisso <c>6</c> avranno impostato sia un record AAAA che PTR.
Quelle con prefisso <c>3</c> avranno impostato soltanto un record AAAA.
Oltre a modificare manualmente il file <path>data</path>, potete utilizzare
gli scripts <c>add-host6</c> e <c>add-alias6</c> per aggiungere nuove voci.
Dopo aver fatto i cambiamenti al file <path>data</path>, dovete semplicemente
dare il comando <c>make</c> da <path>/var/tinydns/root</path>. Questo creerà
<path>/var/tinydns/root/data.cfb</path>, che tinydns userà come fonte di informazione
per le richieste di DNS.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Router IPv6</title>

<section>
<title>Configurare il routing (instradamento)</title>
<body>

<p>
Se desideriamo utilizzare il nostro sistema come router per gli altri clients che 
vogliono collegarsi al mondo esterno con IPv6, sono necessarie ulteriori configurzioni.
Dobbiamo abilitare il forwarding dei pacchetti IPv6. Possiamo fare ciò in uno dei due
seguenti modi.
</p>

<pre caption="Abilitare il forwarding">
# <i>echo 1 > /proc/sys/net/ipv6/conf/all/forwarding</i>
o
# <i>sysctl -w net.ipv6.conf.all.forwarding=1</i>
</pre>

<warn>
Lo script initi radvd abilita il forwarding, rendendo inutile il passo
seguente.
</warn>

<p>
Per abilitare il forwarding al boot, dovete modificare 
<path>/etc/sysctl.conf</path> e aggiungere la seguente linea.
</p>

<pre caption="Aggiunta a sysctl.conf">
net.ipv6.conf.default.forwarding=1
</pre>

<p>
Il traffico dovrebbe essere ora inviato da questa macchina attraverso il
tunnel che abbiamo stabilito con il nostro broker.
</p>

<p>
Per assegnare gli indirizzi IPv6 ai clients, la specifica di IPv6 permette
sia l'assegnazione IP stateless (senza stati) che statefull (con stati).
L'assegnazione stateless utilizza un processo chiamato Router Advertisement e
permette ai clients di ottenere un IP e una default route semplicemente attivando
un'interfaccia. E' chiamato "stateless" poichè non viene registrata 
l'assegnazione degli IP e a quali host sono stati attribuiti. L'assegnazione stateful
è gestita tramite DHCPv6. Questo metodo è "stateful" poichè il server mantiene 
uno stato dei clients che hanno richiesto e ricevuto un IP.
</p>

</body>
</section>

<section>
<title>Configurazione Stateless</title>
<body>

<p>
La configurazione Stateless è facilmente ottenibile utilizzando il 
Router Advertisement Daemon, o radvd.
</p>

<pre caption="Configurare radvd">
# <i>emerge radvd</i>
</pre>

<p>
Dopo aver emerso radvd, dobbiamo creare <path>/etc/radvd/radvd.conf</path>
che contiene le informazioni circa quali blocchi IP utilizzare per assegnare
gli indirizzi. Qui trovate un semplice file <path>radvd.conf</path> 
che utilizza il prefisso che ci è stato assegnato dal nostro tunnel broker.
</p>

<pre caption="radvd.conf d'esempio">
interface eth0
{
        AdvSendAdvert on;
	<codenote>Invia un messaggio d'avviso agli altri hosts</codenote>
	AdvLinkMTU 1280;
	MaxRtrAdvInterval 300;
	prefix 2001:470:1F00:296::/64
	<codenote>Il gruppo di IP che abbiamo a nostra disposizione</codenote>
	{
		AdvOnLink on;
		AdvAutonomous on;
	};
};
</pre>

<p>
Altre informazioni sono disponibili su <c>man radvd.conf</c>. Ora possiamo avviare
radvd e impostarlo affinchè venga avviato al boot.
</p>

<pre caption = "Attivare radvd">
# <i>/etc/init.d/radvd start</i>
# <i>rc-update add radvd default</i>
</pre>

</body>
</section>

<section>
<title>Configurazione Stateful</title>
<body>

<p>
Nel caso vogliate servirvi della configurazione stateful, dovrete installare
e configurare dhcpv6.
</p>

<pre caption = "Installare dhcpv6">
# <i>emerge dhcpv6</i>
</pre>

<p>
Adesso dobbiamo configurare il server DHCPv6 modificando
<path>/etc/dhcp6s.conf</path>.
</p>

<pre caption="dhcp6s.conf d'esempio">
prefer-life-time 10000;
valid-life-time 20000;
renew-time 5000;
rebind-time 8000;
interface eth1 {
	link AAA {
		allow unicast;
		send unicast;
		allow rapid-commit;
		send server-preference 5;
		renew-time 1000;
		rebind-time 2400;
		prefer-life-time 2000;
		valid-life-time 3000;
		pool{
		range 2001:470:1f00:296::10 to 2001:470:1f00:296::110/64;
		prefix 2001:470:1f00:296::/64;
		};
	};
};
</pre>

<p>
Possiamo ora avviare dhcp6s e configurarlo perchè venga avviato al boot.
</p>

<pre caption = "Attivare dhcp6s">
# <i>/etc/init.d/dhcp6s start</i>
# <i>rc-update add dhcp6s default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Clients IPv6</title>
<section>
<title>Usando radvd</title>
<body>

<p>
I clients dietro questo router dovrebbero potersi ora connettere al resto
della rete tramite IPv6. Se usate radvd, configurare gli hosts dovrebbe 
essere facile come attivarne le interfacce (questo sarà probabilmente
già stato fatto dai vostri script init net.ethX).
</p>

<pre caption = "Connettersi attraverso IPv6">
# <i>ifconfig eth0 up</i>
# <i>ifconfig eth0</i>
eth0      Link encap:Ethernet  HWaddr 00:09:6B:06:B7:B4
          inet6 addr: fe80::209:6bff:fe06:b7b4/64 Scope:Link
          inet6 addr: 2001:470:1f00:296:209:6bff:fe06:b7b4 Scope:Global
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:100
          RX bytes:0 (0.0 b)  TX bytes:828 (828.0 b)
          Interrupt:11 Base address:0x8400 Memory:d0204000-d0204038
</pre>

</body>
</section>

<section>
<title>Usando DHCPv6</title>
<body>

<p>
Se il vostro router è impostato per utilizzare DHCPv6, anche i vostri clients
dovranno avere installato il pachetto dhcpv6. Dopo aver provveduto a ciò, 
dovrete configurare i vostri clients modificando <path>/etc/dhcp6c.conf</path>.
</p>

<pre caption="dhcp6c.conf d'esempio">
interface eth0 {
	send rapid-commit;
	request prefix-delegation;
	request domain-name-servers;
	request temp-address;
	iaid 11111;
	renew-time 11000;
	rebind-time 21000;
};
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Usare la conversione 6to4</title>
<section>
<title>Principi di base</title>
<body>

<p>
La conversione 6to4 può essere utilizzata qualora vogliate avere hosts
che comunichino con altri host IPv4 puramente attraverso connessioni IPv6.
In questo modo potrete avere una rete interna esclusivamente IPv6, con un solo
host che si occupi della connessione con il mondo esterno IPv4/IPv6.
</p>

</body>
</section>

<section>
<title>Configurazione del DNS</title>
<body>

<p>
Per ottenere una conversione 6to4 funzionante, deve essere configurato
un proxy DNS, <c>totd</c>, affinchè vi trasmetta records AAAA per quei siti
che in realtà possiedono solo records A. Questi records AAAA punteranno a indirizzi
IPv6 che sono attualmente inesistenti, ma che saranno convertiti in destinazioni
valide attraverso l'instradamento del proxy 6to4. 
<c>totd</c> è attualmente mascherato come <c>~x86</c> poichè richiede ulteriori
test.
</p>

<pre caption = "Installare totd">
# <i>ACCEPT_KEYWORDS="~x86" emerge totd</i>
</pre>

<p>
Adesso dobbiamo impostare <path>/etc/totd.conf</path> con alcune informazioni
di configurazione di base.
</p>

<pre caption="/etc/totd.conf d'esempio">
forwarder 192.168.0.2 port 53
<codenote>Punta al vero nameserver DNS</codenote>
prefix 3ffe:abcd:1234:9876::
<codenote>Quale prefisso mettere prima del record AAAA fake (falso, simulato)</codenote>
port 5005
<codenote>Su quale porta far girare totd</codenote>
pidfile /var/run/totd.pid
<codenote>Quale file PID usare</codenote>
stf
<codenote>Fa la funzione 6to4</codenote>
</pre>

<note>
<c>totd</c> deve essere regolato affinchè si serva di una porta differente dalla 53
qualora sulla stessa macchina giri un altro nameserver.
</note>

</body>
</section>

<section>
<title>Proxy 6to4</title>
<body>

<p>
<c>ptrtd</c> sarà utilizzato come proxy 6to4, abilitando le connessioni tra
gli host IPv6 interni e quelli IPv4 esterni.
</p>

<pre caption = "Installare ptrtd">
# <i>ACCEPT_KEYWORDS="~x86" emerge ptrtd</i>
</pre>

<p>
Dobbiamo ora configurare <c>ptrtd</c>, dicendogli quale prefisso simulato 
(quello che abbiamo utilizzato per impostare <c>totd</c>) creare per le connessioni
proxy. Modificate <path>/etc/conf.d/ptrtd</path> e impostate <c>IPV6_PREFIX</c>.
Questo dovrebbe essere lo stesso prefisso che è stato configurato con <c>totd</c>.
</p>

<pre caption="/etc/ptrtd.conf d'esempio">
IPV6_PREFIX="3ffe:abcd:1234:9876::"
</pre>

<p>
Potete ora avviare totd e impostare che venga avviato al boot.
</p>

<pre caption = "Avviare totd">
# <i>/etc/init.d/totd start</i>
# <i>rc-update add totd default</i>
</pre>

</body>
</section>

<section>
<title>Configurazione e prova del client</title>
<body>

<p>
I clients possono ora essere configurati per collegarsi a hosts, sia IPv4 che
IPv6, esterni attraverso una sola connesione IPv6. Supponendo che i clients
abbiamo già ricevuto un indirizzo IP da radvd, dobbiamo semplicemente
aggiungere una nuova voce di risoluzione DNS e aggiungere una default route per
gli indirizzi "simulati" (falsi, fake).
Prima di tutto aggiungete una voce in cima al vostro <path>/etc/resolv.conf</path> 
che punti alla macchina sulla quale gira <c>totd</c>.
</p>

<pre caption="/etc/resolv.conf d'esempio">
nameserver 2001:470:1f00:296::1
<codenote>Il server su cui gira totd</codenote>
</pre>

<p>
Per provare la risoluzione dei nomi, richiedete un record AAAA per un 
sito conosciuto (che sia solo IPv4). 
</p>

<pre caption = "Provare la risoluzione dei nomi">
# <i>host -t aaaa google.com</i>
google.com has AAAA address 3ffe:abcd:1234:9876::d8ef:3364
google.com has AAAA address 3ffe:abcd:1234:9876::d8ef:3564
</pre>

<p>
Dovremo ora aggiungere una default route per tutti gli indirizzi preceduti
dal prefisso simulato che abbiamo scelto.
</p>

<pre caption="Usando l'utility route">
# <i>route -A inet6 add 3ffe:abcd:1234:9876::/64 gw 2001:470:1f00:296::1</i>
</pre>

<pre caption="Usando iproute">
# <i>ip route add 3ffe:abcd:1234:9876::/64 via 2001:470:1f00:296::1 dev eth0</i>
</pre>

<p>
Infine, usate <c>ping6</c> per pingare google.com nella sua versione IPv6 simulata.
</p>

<pre caption="Provare 6to4">
# <i>ping6 -c 2 google.com</i>
PING 3ffe:abcd:1234:9876::d8ef:3364(3ffe:abcd:1234:9876::d8ef:3364) 56 data bytes
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=1 ttl=255 time=0.106 ms
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=2 ttl=255 time=0.090 ms

--- 3ffe:abcd:1234:9876::d8ef:3364 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.090/0.098/0.106/0.008 ms
</pre>

<note>
Il router su cui gira <c>ptrtd</c> sta realmente rispondendo, ma questo ci basta per capire
se le cose stanno funzionando o meno.
</note>

</body>
</section>

</chapter>

<chapter>
<title>Altre risorse</title>
<section>
<body>
<p>
Ci sono online molte eccellenti risorse riguardanti IPv6.
</p>

<table>
<tr><th>Sito Web</th><th>Risorse</th></tr>
<tr><ti><uri link="http://www.ipv6.org/">www.ipv6.org</uri></ti><ti>Informazioni generali su IPv6</ti></tr>
<tr><ti><uri link="http://www.linux-ipv6.org/">www.linux-ipv6.org/</uri></ti><ti>Progetto USAGI</ti></tr>
<tr><ti><uri link="http://www.deepspace6.net/">www.deepspace6.net</uri></ti><ti>Sito su Linux/IPv6</ti></tr>
<tr><ti><uri link="http://www.hs247.com/">www.hs247.com</uri></ti><ti>Tutto su IPv6</ti></tr>
<tr><ti><uri link="http://www.ipv6-net.org/">www.ipv6-net.org</uri></ti><ti>Sito tedesco su IPv6</ti></tr>
<tr><ti><uri link="http://www.kame.net/">www.kame.net</uri></ti><ti>Implementazione *BSD</ti></tr>
</table>

<p>
In IRC, potete provare <c>#gentoo-ipv6</c> o <c>#ipv6</c> su 
<uri link="http://www.freenode.net">Freenode</uri>. Potete connettervi ai server
Freenode utilizzando un client con supporto IPv6 connettendovi a 
<b>irc.ipv6.freenode.net</b>.
</p>

</body>
</section>
</chapter>


</guide>
