<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/ipv6.xml,v 1.8 2004/09/06 20:30:19 mush Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/ipv6.xml" lang="it">

<title>Gentoo IPv6 Router Guide</title>
<author title="Autore">
    <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Aggiornamento">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Redazione">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Redazione">
    <mail link="cam@gentoo.org">Camille Huot</mail>
</author>
<author title="Redazione">
    <mail link="okun@hack.fi">Pasi Valminen</mail>
</author>
<author title="Traduzione">
    <mail link="gentoo@virgilio.it">Shev</mail>
</author>

<abstract>
Questa guida mostra come impostare IPv6 su un sistema Gentoo. La trattazione comprende
l'instaurazione di un tunnel tramite un tunnel broker (un mediatore di tunnel), 
alcune configurazioni di base di DNS e come impostare i clients affinchè utilizzino
il sistema per connettersi a indirizzi IPv6.
</abstract>

<license/>

<version>1.1.2</version>
<date>27 Luglio 2004</date>

<chapter>

<title>Preliminari</title>

<section>
<title>Configurazione di base del kernel</title>
<body>
<p>
Tutti i kernel appartenenti ai rami 2.4 e 2.6 presenti in Gentoo supporteranno
facilmente le connessioni IPv6. Il nuovo stack IPv6 USAGI è integrato direttamente nel 
kernel a partire dalle versioni Linux 2.4.22 e Linux 2.6.0. Oltre a ciò, i vecchi kernel
<c>alpha-sources-2.4.21</c> e <c>gentoo-sources-2.4.20</c> possono avere applicate le 
patch USAGI se avete correttamente impostato la flag <e>usagi</e> nella vostra variabile
USE.
</p>

<pre caption="Emergere un kernel">
<comment>(per kernel 2.6)</comment>
# <i>emerge gentoo-dev-sources</i>
<comment>(per kernel 2.4)</comment>
# <i>emerge gentoo-sources</i>
</pre>

<p>
Ora siete pronti per entrare nella directory dei sorgenti del kernel
e iniziarne la nuova configurazione.
</p>

<pre caption="Configurare il kernel Linux">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<note>
Questo presuppone che il symlink <path>/usr/src/linux</path> punti ai sorgenti
che avete intenzione di utilizzare.
</note>

<note>
Assicuratevi di avere abilitato nella vostra configurazione del kernel la voce
<path>Prompt for development and/or incomplete code/drivers</path>.
</note>

<pre caption = "opzioni di 'make menuconfig'">
Device Drivers ---&gt;
Networking support ---&gt;
Networking options ---&gt;
   &lt;*&gt; The IPv6 protocol (EXPERIMENTAL)

<codenote>Le opzioni IPv6 sotto questa voce potrebbero essere utili per diverse applicazioni,</codenote>
<codenote>ma non dovrebbero essere necessarie per una configurazione di base</codenote>
<codenote>Questa opzione è necessaria solo se utilizzate ptrtd per la conversione 6to4</codenote>
[*] Network device support
   &lt;*&gt; Universal TUN/TAP device driver support
</pre>

</body>
</section>

<section>
<title>Verificare il supporto IPv6</title>
<body>

<p>
Dopo aver abilitato le opzioni raccomandate, ricompilate il vostro kernel e
riavviate servendovi del nuovo kernel con supporto IPv6.
</p>

<p>
Se non avete già installato <b>iproute2</b>, è importante che lo facciate ora. iproute2
è una suite di programmi per la configurazione di rete che contiene <c>ip</c>, il celebre
sostituto di <c>ifconfig</c>, <c>route</c>, <c>iptunnel</c> e altri...
</p>
  	 
<pre caption="Installare iproute2">
# <i>emerge sys-apps/iproute2</i>
</pre>
  	 
<warn>
L'uso di ifconfig può causare seri problemi se avete attivi tunnel multipli. Dovete
rimuovere infatti i tunnel in ordine inverso, quindi l'ultimo che avete creato deve 
essere rimosso per primo. Siete avvisati!
</warn>
  	 
<p>
Se IPv6 è attivo, il dispositivo di loopback dovrebbe mostrare un indirizzo IPv6:
 </p>


<pre caption = "Controllare il dispositivo di loopback">
# <i>ip -6 addr show lo</i>
1: lo: &lt;LOOPBACK,UP&gt; mtu 16436
     inet6 ::1/128 scope host
        valid_lft forever preferred_lft forever
	     <comment>(La precedente riga dimostra che tutto sta funzionando)</comment>
</pre>

<p>
Prima di proseguire, assicuratevi di aggiungere <e>ipv6</e> alla vostra lista nella 
variabile USE in <path>make.conf</path>, in modo tale che i futuri emerge di pacchetti 
includeranno il supporto a IPv6.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Configurazione di Tunnel</title>

<section>
<title>Configurazione di base</title>
<body>

<p>
La maggior parte degli ISP (ndt, fornitori del servizio Internet) non offre nessuna
connessione IPv6 nativa. Per aggirare questa limitazione, esistono diversi "tunnel brokers"
in giro per il mondo che offrono gratuitamente dei tunnel IPv6. Questo vi permetterà di
di creare, per le vostre connessioni IPv6, un tunnel attraverso una connessione IPv4.
</p>

<table>
<tr><th>Broker</th><th>Località</th></tr>
<tr>
  <ti><uri link="http://tunnelbroker.net">Hurricane Electric</uri></ti>
  <ti>US/Canada</ti>
</tr>
<tr>
  <ti><uri link="http://www.freenet6.net">Freenet6</uri></ti>
  <ti>US</ti>
</tr>
<tr>
  <ti><uri link="http://www.sixxs.net/">Sixxs</uri></ti>
  <ti>Europe</ti>
</tr>
<tr>
  <ti><uri link="http://tunnel-broker.singnet.com.sg/">Singnet</uri></ti>
  <ti>Singapore</ti>
</tr>
<tr>
  <ti><uri link="http://broker.aarnet.net.au/">Aarnet</uri></ti>
  <ti>Australia/South Pacific</ti>
</tr>

<tr>
  <ti><uri link="http://ipng.org.uk">IPnG</uri></ti>
  <ti>UK</ti>
</tr>
<tr>
  <ti><uri link="http://tb.ipv6.btexact.com">BTExact</uri></ti>
  <ti>Europe</ti>
</tr>
</table>

<p>
Di seguito trovate due esempi per impostare un tunnel con due popolari
broker del Nord America, Hurricane Electric e Freenet6.
</p>
</body>
</section>

<section>
<title>Hurricane Electric</title>
<body>

<p>
Hurricane Electric (in breve HE) offre tunnel IPv6 gratuiti e alloca per voi
blocchi di indirizzi /64. Inoltre permette la configurazione del
reverse DNS (DNS inverso). Ottenere un tunnel da HE è facile come andare
su <uri>http://www.tunnelbroker.net</uri> e compilare una pagina con i propri
dati.
</p>

<note>
La registrazione richiede informazioni quali il vostro indirizzo e numero
di telefono.
</note>

<warn>
I tunnel ottenuti da HE richiedono 24 ore per essere attivati. Ciò per porre un
freno all'abuso di tale servizio.
</warn>

<p>
Dopo aver ottenuto un tunnel riconosciuto e allocato un blocco /64, potete
configurare la vostra Gentoo box. HE fornisce una semplice configurazione basata
sui comandi ifconfig e iproute. I due esempi seguenti presuppongono che abbiate una
configurazione di questo tipo:
</p>

<table>
<tr>
  <ti>Indirizzo IPv4 locale (eth0)</ti>
  <ti>68.36.91.195</ti>
</tr>
<tr>
  <ti>Indirizzo IPv4 HE</ti>
  <ti>64.71.128.82</ti>
</tr>
<tr>
  <ti>Indirizzo del tunnel IPv6 locale</ti>
  <ti>2001:470:1F00:FFFF::189</ti>
</tr>
<tr>
  <ti>Blocco IPv6</ti>
  <ti>2001:470:1F00:296::/64</ti>
</tr>
</table>

<p>
Usando il pacchetto iproute2 e il comando <c>ip</c>, date le seguenti istruzioni:
</p>

<pre caption="Configurazione di un tunnel IPv6">
<comment>(Crea un tunnel tra gli indirizzi IPv4 locale (eth0) e quello remoto di HE)</comment>
# <i>ip tunnel add sixbone mode sit remote 64.71.128.82 local 68.36.91.195 ttl 64 dev eth0</i>
<comment>(Sottrae l'overhead del tunnel dalla MTU)</comment>
# <i>ip link set sixbone mtu 1280 </i>
<comment>(Attiva il tunnel)</comment>
# <i>ip link set sixbone up</i>
<comment>(Assegna l'indirizzo IPv6)</comment>
# <i>ip addr add 2001:470:1F00:FFFF::189 dev sixbone</i>
<comment>(Instrada ogni indirizzo IPv6 attraverso il dispositivo tunnel 'sixbone'</comment>
# <i>ip route add 2003::/3 dev sixbone</i>
</pre>

</body>
</section>

<section>
<title>Freenet6</title>
<body>

<p>
<uri link="http://www.freenet6.net">Freenet6</uri> è un altro tunnel broker gratuito.  
La registrazione richiede soltanto uno username e un indirizzo email valido.
Hanno scelto di gestire il tunnel attraverso un'impostazione client/server ed
hanno creato il client <c>tscp</c>. Questo client è disponibile nel portage.
Per installarlo date:
</p>

<pre caption="Installare il client Freenet6">
# <i>emerge freenet6</i>
</pre>

<p>
Ora dovete configurare freenet6 modificando 
<path>/etc/freenet6/tspc.conf</path>. Dovrete cambiare soltanto i campi
<e>userid</e> e <e>passwd</e> facendoli corrispondere ai valori
assegnati da Freenet6. Segue un semplice e completo esempio di file
di configurazione:
</p>

<pre caption="esempio di tspc.conf">
tsp_version=1.0.1
tsp_dir=/etc/freenet6
auth_method=any
client_v4=auto
<i>userid=anonymous</i>
<i>passwd=foobar</i>
template=gentoo
server=tsps1.freenet6.net
retry_delay=0
if_tunnel=sit3
</pre>

</body>
</section>

<section>
<title>Provare la vostra connessione</title>
<body>

<p>
Ora che il vostro tunnel è configurato, potete provare la connessione. Il 
modo più facile per farlo è utilizzare il comando <c>ping6</c> e provare
a pingare un host IPv6.
</p>

<pre caption = "Provare la connessione">
# <i>emerge iputils</i>
# <i>ping6 www.kame.net</i>
PING www.kame.net(orange.kame.net) 56 data bytes
64 bytes from orange.kame.net: icmp_seq=1 ttl=52 time=290 ms
64 bytes from orange.kame.net: icmp_seq=2 ttl=52 time=277 ms
64 bytes from orange.kame.net: icmp_seq=3 ttl=52 time=280 ms
64 bytes from orange.kame.net: icmp_seq=4 ttl=52 time=279 ms
64 bytes from orange.kame.net: icmp_seq=5 ttl=52 time=277 ms

--- www.kame.net ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4038ms
rtt min/avg/max/mdev = 277.040/281.041/290.046/4.699 ms
</pre>

<p>
Sono attualmente in corso ulteriori lavori per migliorare il supporto
IPv6 negli script init di rete. Se volete conoscere lo stato dei lavori
e/o dare una mano, scrivete a <mail link="latexer@gentoo.org">latexer@gentoo.org</mail>.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Supporto IPv6 nelle applicazioni</title>

<section>
<title>Ri-emergere i pacchetti</title>
<body>

<p>
A meno che aveste impostato in precedenza <e>USE="ipv6"</e> nel vostro <path>/etc/make.conf</path>,
dovrete probabilmente ri-emergere un certo numero di pacchetti per ricompilarli
con il supporto IPv6 attivo. Per ottenere una lista di tutti i pacchetti installati
che potrebbero fare uso della variabile USE <e>ipv6</e>, potete eseguire il seguente comando.
</p>

<pre caption="Candidati per il re-emerging">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | cut -d' ' -f1</i>
</pre>

<p>
Per poter ri-emergere più facilmente la maggior parte dei pacchetti selezionati, date:
</p>

<pre caption="Candidati per il re-emerging">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | \</i>
&gt; <i>cut -d' ' -f1 > packages</i>
</pre>

<p>
Adesso modificate il file <path>packages</path> ottenuto, rimuovendo tutti quei 
pacchetti che non volete siano ricompilati in questo momento. Infine date semplicemente:
</p>

<pre>
# <i>emerge `cat packages`</i>
</pre>

<note>
Alcuni pacchetti rilevano automaticamente il supporto a IPv6 e quindi non possiedono una
flag USE ipv6. Quindi non tutti i pacchetti che dovrebbero supportare IPv6 lo supporteranno,
se sono stati compilati in presenza di un kernel con IPv6 non attivato.
</note>

</body>
</section>

<section>
<title>Pacchetti specifici per IPv6</title>
<body>

<p>
Ci sono diversi pacchetti che si occupano nello specifico delle caratteristiche di IPv6.
La maggior parte di essi è situata in <path>/usr/portage/net-misc</path>.
</p>

<table>
<tr><th>Pacchetto</th><th>Descrizione</th></tr>
<tr>
  <ti>net-misc/ipv6calc</ti>
  <ti>Converte un indirizzo IPv6 in un formato compresso</ti>
</tr>
<tr>
  <ti>net-misc/nc6</ti>
  <ti>versione di netcat che supporta IPv6 e IPv4</ti>
</tr>
<tr>
  <ti>dev-perl/Socket6</ti>
  <ti>Parte relativa ad IPv6 delle definizioni e dei manipolatori di strutture del C socket.h</ti>
</tr>
</table>
</body>
</section>

</chapter>
<chapter>

<title>Impostazioni del DNS</title>

<section>
<title>IPv6 e DNS</title>
<body>

<p>
Mentre un DNS per IPv4 usa i record A, il DNS per IPv6 usa i record AAAA.
(questo perchè IPv4 possiede uno spazio di indirizzamento di 2^32 contro
lo spazio di indirizzamento di IPv6 pari a 2^128). Per il reverse DNS (DNS inverso),
lo standard INT è deprecato ma è ancora ampiamente supportato. ARPA è il formato più recente.
Qui descriveremo il supporto per il formato ARPA. 
</p>

</body>
</section>

<section>
<title>Configurazione di BIND</title>
<body>

<p>
Le versioni più recenti di BIND includono un eccellente supporto per IPv6.
In questa sezione assumeremo che possediate almeno le conoscenze minime necessarie
per configurare e utilizzare BIND. Assumeremo inoltre che bind non giri in un chroot.
In caso contrario, semplicemente appendete il prefisso del chroot nella maggior parte
dei cammini (path) nella sezione seguente. 
</p>

<p>
Prima di tutto dovete aggiungere nei file di zona le impostazioni sia per il forward 
che il reverse DNS, in <path>/etc/bind/named.conf</path>.
</p>

<pre caption="Impostazioni di named.conf">
<comment>(Mettiamo bind ad ascoltare indirizzi IPv6.</comment>
<comment>Usare 'any' è l'unico modo per farlo prima di bind-9.3)</comment>
options {
        [...]
        listen-on-v6 { any; }
        [...]
};
<comment>(Questo fornirà il forward DNS per il dominio 'ipv6-rules.com':)</comment>
zone "ipv6-rules.com" IN {
	type master;
	file "pri/ipv6-rules.com";
};
<comment>(Il formato per il reverse DNS è il "bitwise." E' ottenuto prendendo il prefisso IPv6,</comment>
<comment>invertendo l'ordine dei numeri e aggiungendo un punto fra ogni numero)</comment>
zone "6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa" {
	type master;
	file "pri/rev-ipv6-rules.com.arpa";
};
</pre>

<p>
Ora dobbiamo creare per ognuno dei nostri host i file di zona e aggiungervi
le impostazioni necessarie:
</p>

<pre caption="pri/ipv6-rules.com">
$TTL    2h
@       IN      SOA     ipv6-rules.com. webmaster.ipv6-rules.com.  (
                                2003052501 ; Serial
				28800      ; Refresh
				14400      ; Retry
				3600000    ; Expire
				86400 )    ; Minimum
			NS      ns1.ipv6-rules.com

	IN	AAAA	2001:470:1f00:296::1 ; address for ipv6-rules.com
host1	IN	AAAA	2001:470:1f00:296::2 ; address for host1.ipv6-rules.com
host2	IN	AAAA	2001:470:1f00:296::3:3 ; address for host2.ipv6-rules.com
</pre>

<pre caption="pri/rev-ipv6-rules.com.arpa">
$TTL 3d ; Default TTL (bind 8 needs this, bind 9 ignores it)
@       IN SOA ipv6-rules.com. webmaster.ipv6-rules.com. (
                        2003052501      ; Serial number (YYYYMMdd)
			24h             ; Refresh time
			30m             ; Retry time
			2d              ; Expire time
			3d )            ; Default TTL
	IN      NS     ns1.ipv6-rules.com.
; IPv6 PTR entries
$ORIGIN 6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int.

1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     ipv6-rules.com.
2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host1.ipv6-rules.com.
3.0.0.0.3.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host2.ipv6-rules.com.
</pre>

</body>
</section>

<section>
<title>Configurazione di DJBDNS</title>
<body>

<p>
Attualmente esistono diverse patches di terze parti per DJBDNS, disponibili su 
<uri link="http://www.fefe.de/dns/">http://www.fefe.de/dns/</uri>, che gli 
permettono di funzionare anche con IPv6. DJBDNS può essere installato con 
queste patch emergendolo con la flag <e>ipv6</e> impostata nella vostra variabile USE.
</p>

<warn>
Tuttavia anche con queste patch non sono supportati tutti i tipi di record.
In particolare, non sono supportati i record NS e MX.
</warn>

<pre caption="Installare djbdns">
# <i>emerge djbdns</i>
</pre>

<p>
Dopo che djbdns è installato, può essere configurato dando
<c>tinydns-setup</c> e rispondendo alle poche domande circa
a quale indirizzo legarlo, dove installare tinydns, ecc.
</p>

<pre caption = "Impostare tinydns">
# <i>tinydns-setup</i>
</pre>

<p>
Asummendo di aver installato <c>tinydns</c> in <path>/var/tinydns</path>, 
possiamo ora modificare <path>/var/tinydns/root/data</path>. Questo file 
conterrà tutti i dati necessari per ottenere che tinydns gestisca il DNS
per la vostra delegazione IPv6.
</p>

<pre caption="File d'esempio">
<codenote>*.ipv6-rules.com è autoritativamente gestito da 192.168.0.1</codenote>
.ipv6-rules.com:192.168.0.1:a:259200
<codenote>Reverse DNS autoritativo per 2001:470:1f00:296::/64</codenote>
.6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa:192.168.0.1:a
<codenote>Specifica gli IP per host1 e host2</codenote>
6host1.ipv6-rules.com:200104701f0002960000000000000001:86400
6host2.ipv6-rules.com:200104701f0002960000000000000002:86400
<codenote>Fa puntare www a host1</codenote>
3www.ipv6-rules.com:200104701f0002960000000000000002:86400
</pre>

<p>
Le linee con prefisso <c>6</c> avranno impostato sia un record AAAA che PTR.
Quelle con prefisso <c>3</c> avranno impostato soltanto un record AAAA.
Oltre a modificare manualmente il file <path>data</path>, potete utilizzare
gli scripts <c>add-host6</c> e <c>add-alias6</c> per aggiungere nuove voci.
Dopo aver fatto i cambiamenti al file <path>data</path>, dovete semplicemente
dare il comando <c>make</c> da <path>/var/tinydns/root</path>. Questo creerà
<path>/var/tinydns/root/data.cfb</path>, che tinydns userà come fonte di informazione
per le richieste di DNS.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Router IPv6</title>

<section>
<title>Configurare il routing (instradamento)</title>
<body>

<p>
Se desideriamo utilizzare il nostro sistema come router per gli altri clients che 
vogliono collegarsi al mondo esterno con IPv6, sono necessarie ulteriori configurzioni.
Dobbiamo abilitare il forwarding dei pacchetti IPv6. Possiamo fare ciò in uno dei due
seguenti modi.
</p>

<pre caption="Abilitare il forwarding">
# <i>echo 1 > /proc/sys/net/ipv6/conf/all/forwarding</i>
o
# <i>sysctl -w net.ipv6.conf.all.forwarding=1</i>
</pre>

<warn>
Lo script init radvd abilita (e disabilita) il forwarding, rendendo inutile il passo
seguente.
</warn>

<p>
Per abilitare il forwarding al boot, dovete modificare 
<path>/etc/sysctl.conf</path> e aggiungere la seguente linea.
</p>

<pre caption="Aggiunta a sysctl.conf">
net.ipv6.conf.default.forwarding=1
</pre>

<p>
Il traffico dovrebbe essere ora inviato da questa macchina attraverso il
tunnel che abbiamo stabilito con il nostro broker.
</p>

<p>
Per assegnare gli indirizzi IPv6 ai clients, la specifica di IPv6 permette
sia l'assegnazione IP stateless (senza stati) che statefull (con stati).
L'assegnazione stateless utilizza un processo chiamato Router Advertisement e
permette ai clients di ottenere un IP e una default route semplicemente attivando
un'interfaccia. E' chiamato "stateless" poichè non viene registrata 
l'assegnazione degli IP e a quali host sono stati attribuiti. L'assegnazione stateful
è gestita tramite DHCPv6. Questo metodo è "stateful" poichè il server mantiene 
uno stato dei clients che hanno richiesto e ricevuto un IP.
</p>

</body>
</section>

<section>
<title>Configurazione Stateless</title>
<body>

<p>
La configurazione Stateless è facilmente ottenibile utilizzando il 
Router Advertisement Daemon, o radvd.
</p>

<pre caption="Configurare radvd">
# <i>emerge radvd</i>
</pre>

<p>
Dopo aver emerso radvd, dobbiamo creare <path>/etc/radvd/radvd.conf</path>
che contiene le informazioni circa quali blocchi IP utilizzare per assegnare
gli indirizzi. Qui trovate un semplice file <path>radvd.conf</path> 
che utilizza il prefisso che ci è stato assegnato dal nostro tunnel broker.
</p>

<pre caption="radvd.conf d'esempio">
interface eth1
{
       
	<codenote>Invia un messaggio d'avviso agli altri hosts</codenote>
	AdvSendAdvert on;
	<codenote>La frammentazione è un male(tm)</codenote>
	AdvLinkMTU 1280;
	MaxRtrAdvInterval 300;
	<codenote>Il prefisso della sottorete IPv6 ci viene assegnato dal nostro PoP</codenote>
	prefix 2001:470:1F00:296::/64
	{
		AdvOnLink on;
		AdvAutonomous on;
	};
};
</pre>

<warn>
Assicuratevi che l'interfaccia indicata nella prima linea sia corretta in modo da trasmettere gli 
advertisement del vostro router alla vostra rete e non al vostro ISP!
</warn>

<p>
Altre informazioni sono disponibili su <c>man radvd.conf</c>. Ora possiamo avviare
radvd e impostarlo affinchè venga avviato al boot.
</p>

<pre caption = "Attivare radvd">
# <i>/etc/init.d/radvd start</i>
# <i>rc-update add radvd default</i>
</pre>

</body>
</section>

<section>
<title>Configurazione Stateful</title>
<body>

<p>
Nel caso vogliate servirvi della configurazione stateful, dovrete installare
e configurare dhcpv6.
</p>

<pre caption = "Installare dhcpv6">
# <i>emerge dhcpv6</i>
</pre>

<p>
Adesso dobbiamo configurare il server DHCPv6 modificando
<path>/etc/dhcp6s.conf</path>.
</p>

<pre caption="dhcp6s.conf d'esempio">
prefer-life-time 10000;
valid-life-time 20000;
renew-time 5000;
rebind-time 8000;
interface eth1 {
	link AAA {
		allow unicast;
		send unicast;
		allow rapid-commit;
		send server-preference 5;
		renew-time 1000;
		rebind-time 2400;
		prefer-life-time 2000;
		valid-life-time 3000;
		pool{
		range 2001:470:1f00:296::10 to 2001:470:1f00:296::110/64;
		prefix 2001:470:1f00:296::/64;
		};
	};
};
</pre>

<p>
Possiamo ora avviare dhcp6s e configurarlo perchè venga avviato al boot.
</p>

<pre caption = "Attivare dhcp6s">
# <i>/etc/init.d/dhcp6s start</i>
# <i>rc-update add dhcp6s default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Clients IPv6</title>
<section>
<title>Usando radvd</title>
<body>

<p>
I clients dietro questo router dovrebbero potersi ora connettere al resto
della rete tramite IPv6. Se usate radvd, configurare gli hosts dovrebbe 
essere facile come attivarne le interfacce (questo sarà probabilmente
già stato fatto dai vostri script init net.ethX).
</p>

<pre caption = "Connettersi attraverso IPv6">
# <i>ip link set eth0 up</i>
# <i>ip addr show eth0</i>
1: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1400 qdisc pfifo_fast qlen 1000
    link/ether 00:01:03:2f:27:89 brd ff:ff:ff:ff:ff:ff
    inet6 2001:470:1f00:296:209:6bff:fe06:b7b4/128 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::209:6bff:fe06:b7b4/64 scope link
       valid_lft forever preferred_lft forever
    inet6 ff02::1/128 scope global
       valid_lft forever preferred_lft forever
</pre>

</body>
</section>

<section>
<title>Usando DHCPv6</title>
<body>

<p>
Se il vostro router è impostato per utilizzare DHCPv6, anche i vostri clients
dovranno avere installato il pachetto dhcpv6. Dopo aver provveduto a ciò, 
dovrete configurare i vostri clients modificando <path>/etc/dhcp6c.conf</path>.
</p>

<pre caption="dhcp6c.conf d'esempio">
interface eth0 {
	send rapid-commit;
	request prefix-delegation;
	request domain-name-servers;
	request temp-address;
	iaid 11111;
	renew-time 11000;
	rebind-time 21000;
};
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Usare la conversione 6to4</title>
<section>
<title>Principi di base</title>
<body>

<p>
La conversione 6to4 può essere utilizzata qualora vogliate avere hosts
che comunichino con altri host IPv4 puramente attraverso connessioni IPv6.
In questo modo potrete avere una rete interna esclusivamente IPv6, con un solo
host che si occupi della connessione con il mondo esterno IPv4/IPv6.
</p>

</body>
</section>

<section>
<title>Configurazione del DNS</title>
<body>

<p>
Per ottenere una conversione 6to4 funzionante, deve essere configurato
un proxy DNS, <c>totd</c>, affinchè vi trasmetta records AAAA per quei siti
che in realtà possiedono solo records A. Questi records AAAA punteranno a indirizzi
IPv6 che sono attualmente inesistenti, ma che saranno convertiti in destinazioni
valide attraverso l'instradamento del proxy 6to4.
</p>

<p>
Visto che <c>totd</c> è attualmente mascherato come <c>~x86</c> poichè richiede ulteriori
test, dovete smascherarlo aggiungendo "net-misc/totd&nbsp;~x86" nel vostro file
<path>/etc/portage/package.keywords</path> ("man portage" per maggiori informazioni su questo file)
</p>

<pre caption="Smascherare permanentemente totd in package.keywords">
net-misc/totd ~x86
</pre>
  	 
<p>
Quindi procedete semplicemente con l'emerge:
 </p>

<pre caption = "Installare totd">
# <i>emerge totd</i>
</pre>

<p>
Adesso dobbiamo impostare <path>/etc/totd.conf</path> con alcune informazioni
di configurazione di base.
</p>

<pre caption="/etc/totd.conf d'esempio">
<comment>(Punta al vero nameserver DNS)</comment>
forwarder 192.168.0.2 port 53
<comment>(Quale prefisso mettere prima del record falso AAAA)</comment>
prefix 3ffe:abcd:1234:9876::
<comment>(Su quale porta far girare totd)</comment>
port 5005
<comment>(Quale file PID usare)</comment>
pidfile /var/run/totd.pid
<comment>(Fa la funzione 6to4)</comment>
stf
</pre>

<note>
<c>totd</c> deve essere regolato affinchè si serva di una porta differente dalla 53
qualora sulla stessa macchina giri un altro nameserver.
</note>

</body>
</section>

<section>
<title>Proxy 6to4</title>
<body>

<p>
<c>ptrtd</c> sarà utilizzato come proxy 6to4, abilitando le connessioni tra
gli host IPv6 interni e quelli IPv4 esterni.
</p>

<pre caption = "Installare ptrtd">
# <i>emerge ptrtd</i>
</pre>

<p>
Dobbiamo ora configurare <c>ptrtd</c>, dicendogli quale prefisso simulato 
(quello che abbiamo utilizzato per impostare <c>totd</c>) creare per le connessioni
proxy. Modificate <path>/etc/conf.d/ptrtd</path> e impostate <c>IPV6_PREFIX</c>.
Questo dovrebbe essere lo stesso prefisso che è stato configurato con <c>totd</c>.
</p>

<pre caption="/etc/ptrtd.conf d'esempio">
IPV6_PREFIX="3ffe:abcd:1234:9876::"
</pre>

<p>
Potete ora avviare totd e impostare che venga avviato al boot.
</p>

<pre caption = "Avviare totd">
# <i>/etc/init.d/totd start</i>
# <i>rc-update add totd default</i>
</pre>

</body>
</section>

<section>
<title>Configurazione e prova del client</title>
<body>

<p>
I clients possono ora essere configurati per collegarsi a hosts, sia IPv4 che
IPv6, esterni attraverso una sola connesione IPv6. Supponendo che i clients
abbiamo già ricevuto un indirizzo IP da radvd, dobbiamo semplicemente
aggiungere una nuova voce di risoluzione DNS e aggiungere una default route per
gli indirizzi "simulati" (falsi, fake).
Prima di tutto aggiungete una voce in cima al vostro <path>/etc/resolv.conf</path> 
che punti alla macchina sulla quale gira <c>totd</c>.
</p>

<pre caption="/etc/resolv.conf d'esempio">
nameserver 2001:470:1f00:296::1 <comment>(Il server su cui gira totd)</comment>
</pre>

<p>
Per provare la risoluzione dei nomi, richiedete un record AAAA per un 
sito conosciuto (che sia solo IPv4). 
</p>

<pre caption = "Provare la risoluzione dei nomi">
# <i>dig aaaa google.com</i>
;; ANSWER SECTION:
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3364
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3564
</pre>

<p>
Dovremo ora aggiungere una route predefinita per tutti gli indirizzi preceduti
dal prefisso simulato che abbiamo scelto.
</p>

<pre caption="Aggiungere la route di default">
<comment>(Si assume che l'interfaccia IPv6 sia eth0)</comment>
# <i>ip route add 3ffe:abcd:1234:9876::/64 via 2001:470:1f00:296::1 dev eth0</i>
</pre>

<p>
Infine, usate <c>ping6</c> per pingare google.com nella sua versione IPv6 simulata.
</p>

<pre caption="Provare 6to4">
# <i>ping6 -c 2 google.com</i>
PING 3ffe:abcd:1234:9876::d8ef:3364(3ffe:abcd:1234:9876::d8ef:3364) 56 data bytes
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=1 ttl=54 time=0.106 ms
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=2 ttl=54 time=0.090 ms

--- 3ffe:abcd:1234:9876::d8ef:3364 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.090/0.098/0.106/0.008 ms
</pre>

<note>
Il router su cui gira <c>ptrtd</c> sta realmente rispondendo, ma questo ci basta per capire
se le cose stanno funzionando o meno.
</note>

</body>
</section>

</chapter>

<chapter>
<title>Altre risorse</title>
<section>
<body>
<p>
Ci sono online molte eccellenti risorse riguardanti IPv6.
</p>

<table>
<tr><th>Sito Web</th><th>Risorse</th></tr>
<tr><ti><uri link="http://www.ipv6.org/">www.ipv6.org</uri></ti><ti>Informazioni generali su IPv6</ti></tr>
<tr><ti><uri link="http://www.linux-ipv6.org/">www.linux-ipv6.org/</uri></ti><ti>Progetto USAGI</ti></tr>
<tr><ti><uri link="http://www.deepspace6.net/">www.deepspace6.net</uri></ti><ti>Sito su Linux/IPv6</ti></tr>
<tr><ti><uri link="http://www.hs247.com/">www.hs247.com</uri></ti><ti>Tutto su IPv6</ti></tr>
<tr><ti><uri link="http://www.ipv6-net.org/">www.ipv6-net.org</uri></ti><ti>Sito tedesco su IPv6</ti></tr>
<tr><ti><uri link="http://www.kame.net/">www.kame.net</uri></ti><ti>Implementazione *BSD</ti></tr>
</table>

<p>
In IRC, potete provare <c>#gentoo-ipv6</c> o <c>#ipv6</c> su 
<uri link="http://www.freenode.net">Freenode</uri>. Potete connettervi ai server
Freenode utilizzando un client con supporto IPv6 connettendovi a 
<b>irc.ipv6.freenode.net</b>.
</p>

</body>
</section>
</chapter>


</guide>
