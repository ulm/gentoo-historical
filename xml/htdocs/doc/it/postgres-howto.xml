<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/postgres-howto.xml,v 1.4 2008/03/06 12:43:06 scen Exp $ -->

<guide link="/doc/it/postgres-howto.xml" lang="it">
<title>Guida a PostgreSQL</title>

<author title="Autore">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Redazione">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Traduzione">
  <mail link="lucamarturana@gmail.com">Luca Marturana</mail>
</author>
<author title="Traduzione">
  <mail link="netcelli.tux@gmail.com">Davide Simoncelli</mail>
</author>

<abstract>
Questa guida è stata pensata per mostrare un'installazione e configurazione base
di PostgreSQL. Le procedure descritte qui dovrebbero essere sufficienti per
poter usare applicazioni web basilari e altri programmi che forniscono un
supporto per PostgreSQL.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.2</version>
<date>2007-04-25</date>

<chapter>
<title>Introduzione</title>
<section>
<title>Introduzione a PostgreSQL</title>
<body>

<p>
Quando tra vari sviluppatori si discute sulle differenti soluzioni database che
si possono usare, due grandi database solitamente costituiscono le risposte. Uno
sarebbe <c>MySQL</c> e l'altro è quello a cui questo documento si riferisce,
ovvero <c>PostgreSQL</c>. I vantaggi dell'uno rispetto all'altro alimentano da
sempre una lunga e sfiancante disputa, comunque c'è solo da dire che PostgreSQL
ha avuto un più fermo controllo sulle vere strutture database relazionali
rispetto a MySQL. Molte caratteristiche standard come <b>FOREIGN KEY</b> sono
state aggiunte solamente su MySQL 5. Comunque, in ogni caso questo documento
assume già che PostgreSQL sia stato già scelto dall'utente come database da
usare. Il primo passo da eseguire è il processo di <c>emerge</c>. Nella prossima
sezione, verrà descritto il processo di installazione tramite emerge, oltre che
la configurazione di base.
</p>

</body>
</section>
<section>
<title>Installazione di PostgreSQL</title>
<body>

<p>
Per iniziare, bisogna per prima cosa effettuare l'<c>emerge</c> del pacchetto
PostgreSQL. Per fare ciò, eseguire il seguente comando per assicurarsi che le
opzioni corrette siano impostate
</p>

<pre caption="Verifica delle opzioni di PostgreSQL">
# <i>emerge -pv postgresql</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +nls +pam +perl -pg-intdatetime
+python +readline (-selinux) +ssl -tcl +xml +zlib 0 kB
</pre>

<p>
La lista seguente spiega i significati delle differenti opzioni:
</p>

<table>
<tr>
  <th>Flag USE</th>
  <th>Significato</th>
</tr>
<tr>
  <ti>doc</ti>
  <ti>
    Questa flag USE abilita o disabilita l'installazione della documentazione
    extra oltre le pagine di manuale standard. È consigliabile disabilitarla
    solo se si è a corto di spazio, oppure se si hanno metodi alternativi per
    accedere ad essa (per esempio in rete).
  </ti>
</tr>
<tr>
  <ti>kerberos</ti>
  <ti>
    Durante la connessione al database, con questa opzione abilitata,
    l'amministratore ha la possibilità di usare <c>kerberos</c> per autenticare
    i propri utenti/servizi al database.
  </ti>
</tr>
<tr>
  <ti>nls</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL può utilizzare le localizzazioni
    per gli utenti non inglesi.
  </ti>
</tr>
<tr>
  <ti>pam</ti>
  <ti>
    Con questa opzione abilitata, e le corrette configurazioni da parte
    dell'amministratore, gli utenti/servizi possono effettuare il login su un
    database PostgreSQL tramite <c>PAM</c> (Pluggable Authentication Module).
  </ti>
</tr>
<tr>
  <ti>perl</ti>
  <ti>
    Con questa opzione abilitata, verranno compilati i binding a <c>perl</c>.
  </ti>
</tr>
<tr>
  <ti>pg-intdatetime</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL supporterà i tipi dato interi a 64
    bit.
  </ti>
</tr>
<tr>
  <ti>python</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL verrà compilato con i binding
    <c>python</c>.
  </ti>
</tr>
<tr>
  <ti>readline</ti>
  <ti>
    Se questa opzione viene abilitata, PostgreSQL supporterà lo stile di
    editing a linea di comando di <c>readline</c>. Ciò include lo storico dei
    comandi e l'isearch.
  </ti>
</tr>
<tr>
  <ti>selinux</ti>
  <ti>
    Con questa opzione abilitata, verranno installate le policy <c>selinux</c>
    per PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>ssl</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL utilizzerà la libreria
    <c>OpenSSL</c> per criptare la comunicazione tra client e server PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>tcl</ti>
  <ti>
     Se viene abilitata questa opzione, PostgreSQL verrà compilato con i binding
    <c>tcl</c>.
  </ti>
</tr>
<tr>
  <ti>xml</ti>
  <ti>
    Con questa opzione abilitata, verrà compilato il supporto allo stile xml
    <c>XPATH</c>. Maggiori informazioni sull'utilizzo del supporto xml con
    PostgreSQL possono essere trovate su: <uri
    link="http://www.throwingbeans.org/tech/postgresql_and_xml.html">PostgreSQL
    and XML</uri>.
  </ti>
</tr>
<tr>
  <ti>zlib</ti>
  <ti>
    Questa flag non è usata da PostgreSQL stesso, ma da <c>pg_dump</c> per
    comprimere i dump da esso prodotti.
  </ti>
</tr>
</table>

<p>
Una volta che PostgrSQL è stato personalizzato per soddisfare le proprie
esigenze, proseguire con il processo di <c>emergw</c>:
</p>

<pre caption="Effettuare l'emerge di PostgreSQL">
# <i>emerge postgresql</i>
<comment>(Output ridotto)</comment>
>>> /usr/lib/libecpg.so.5 -> libecpg.so.5.0
>>> /usr/bin/postmaster -> postgres
 * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell
 *
 * Execute the following command
 * emerge --config =postgresql-8.0.4
 * to setup the initial database environment.
 *
>>> Regenerating /etc/ld.so.cache...
>>> dev-db/postgresql-8.0.4 merged.
</pre>

<p>
Come mostrato dall'output di einfo, ci sono delle operazioni post-installazione
da fare. Il capitolo successivo si occuperà della configurazione di PostgreSQL.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Configurazione di PostgreSQL</title>
<section>
<title>Impostazione dell'ambiente iniziale per il database</title>
<body>

<p>
Come notato nel precedente output di <c>emerge</c>, bisogna impostare l'ambiente
iniziale per il database. Comunque, prima di fare ciò, bisogna tenere presente
che, diversamente da MySQL, la password di "root" di PostgreSQL è la password
dell'utente reale. Tuttavia, solo l'utente viene creato dall'ebuild, <e>non</e>
la password. Quindi, prima di cominciare, bisogna imposare la password per
l'utente postgres:
</p>

<pre caption="Impostare la password">
# <i>passwd postgres</i>
New UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</pre>

<p>
Adesso, è possibile creare l'ambiente iniziale per il database:
</p>

<pre caption="Configurazione dell'ambiente iniziale per il database tramite
emerge --config">
# <i>emerge --config =postgresql-8.0.4</i>


Configuring pkg...

 * Creating the data directory ...
 * Initializing the database ...
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale C.

fixing permissions on existing directory /var/lib/postgresql/data ... ok
creating directory /var/lib/postgresql/data/global ... ok
creating directory /var/lib/postgresql/data/pg_xlog ... ok
creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok
creating directory /var/lib/postgresql/data/pg_clog ... ok
creating directory /var/lib/postgresql/data/pg_subtrans ... ok
creating directory /var/lib/postgresql/data/base ... ok
creating directory /var/lib/postgresql/data/base/1 ... ok
creating directory /var/lib/postgresql/data/pg_tblspc ... ok
selecting default max_connections ... 100
selecting default shared_buffers ... 1000
creating configuration files ... ok
creating template1 database in /var/lib/postgresql/data/base/1 ... ok
initializing pg_shadow ... ok
enabling unlimited row size for system tables ... ok
initializing pg_depend ... ok
creating system views ... ok
loading pg_description ... ok
creating conversions ... ok
setting privileges on built-in objects ... ok
creating information schema ... ok
vacuuming database template1 ... ok
copying template1 to template0 ... ok

WARNING: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the -A option the
next time you run initdb.

Success. You can now start the database server using:

    /usr/bin/postmaster -D /var/lib/postgresql/data
or
    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start

 *
 * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.
 *
</pre>

<p>
Adesso l'ambiente iniziale per il database è stato configurato. La prossima
sezione riguarderà la verifica dell'installazione e la configurazione degli
utenti per accedere al database.
</p>

</body>
</section>
<section>
<title>Configurazione del database PostgreSQL</title>
<body>

<p>
Adesso che PostgreSQL è configurato, a questo punto è buona norma verificare
l'installazione. Per prima cosa, assicurarsi che il servizio parta regolarmente:
</p>

<pre caption="Avvio del servizio PostgreSQL">
# <i>/etc/init.d/postgresql start</i>
* Starting PostgreSQL ...                                          [ ok ]
</pre>

<p>
Dopo aver verificato il funzionamento, è consigliabile aggiungerlo al runlevel
default in modo da farlo partire all'avvio della macchina:
</p>

<pre caption="Avvio del servizio PostgreSQL">
# <i>rc-update add postgresql default</i>
* postgresql added to runlevel default
</pre>

<p>
Adesso che il servizio è attivato, è il momento di configurare un database di
test. Per iniziare, creare un database di test usando il comando
<c>createdb</c>. Passare inoltre l'opzione <c>-U</c> per selezionare l'utente
(se non viene specificato nulla utilizza l'utente corrente), e il parametro
<c>-W</c> per fargli chiedere la password creata in precedenza. Infine passare
anche il nome del database che si vuole creare:
</p>

<pre caption="Creazione di un database con createdb">
$ <i>createdb -U postgres -W test</i>
Password:
CREATE DATABASE
</pre>

<p>
Il database è stato creato con successo ed è possibile confermare che il
database può eseguire dei compiti di base. Proseguire con l'eliminazione (drop)
del database tramite il comando <c>dropdb</c>:
</p>

<pre caption="Rimozione di un database con dropdb">
$ <i>dropdb -U postgres -W test</i>
Password:
DROP DATABASE
</pre>

<p>
Al momento i comandi possono essere eseguiti solamente dall'utente postgres.
Ovviamente questo non è il tipo di configurazione adatto ad un ambiente
multi-utente, perciò la prossima sezione riguarderà la configurazione degli
account per gli utenti.
</p>

</body>
</section>
<section>
<title>Configurazione degli account utente per il database</title>
<body>

<p>
Come detto prima, loggarsi come utente postgres è una cosa sicuramente poco
adatta per un ambiente multi-utente, poichè in molti casi ci saranno vari utenti
e servizi che accederanno al server, e ognuno richiede diversi permessi. Così,
per gestire questa situazione, può essere usato il comando <c>createuser</c>,
che risulta essere una alternativa all'esecuzione di poche query SQL, ed è molto
più flessibile dal punto di vista dell'amministratore. Proseguire con la
creazione di due utenti, un 'superutentè che può aggiungere altri utenti e
amministrare il database, e un utente standard:
</p>

<pre caption="Impostare il superutente">
<comment>(sostituire chris con il nome utente che si vuole usare)</comment>
$ <i>createuser -a -d -P -E -U postgres -W chris</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Con quest'operazione è stato creato il superutente. L'opzione <c>-a</c>
specifica che l'utente può aggiungere altri utenti. <c>-d</c> indica che
l'utente può creare nuovi database. <c>-P</c> serve per ricevere la richiesta di
una password per l'utente e <c>-E</c> la cripterà per ragioni di sicurezza.
Testare ora i permessi del nuovo utente creando un nuovo utente standard:
</p>

<pre caption="Impostare l'utente standard">
<comment>(sostituire chris con il nome dell'utente creato in precedenza)</comment>
$ <i>createuser -A -D -P -E -U chris -W testuser</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Il nostro nuovo utente è stato creato con successo usando il superutente creato
precedentemente. Le opzioni <c>-A</c> e <c>-D</c> sono il contrario di <c>-a</c>
e <c>-d</c>, quindi negano all'utente la possibilità di creare altri utenti e
database. Adesso ci sono gli utenti per lavorare, il prossimo capitolo
riguarderà l'utilizzo di questo nuovo database.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Usare PostgreSQL</title>
<section>
<title>Impostare i permessi</title>
<body>

<p>
Ora è presente un utente che può creare database e aggiungere altri utenti e
l'utente postgres principale che può fare qualsiasi cosa. L'utente creato prima
può solamente loggarsi nel server. In generale, però, gli utenti hanno la
necessità di inserire e prelevare dati, e a volte anche altri tipi di
operazioni. Quindi, per permettere al nuovo utente di fare qualsiasi cosa, è
necessario impostarlo con i giusti permessi: lo si può fare facilmente passando
il parametro <c>-O</c> a <c>createdb</c>. Si comincerà col creare un nuovo
database, <b>MyDB</b> tramite il superuser il cui proprietario sarà il
precedente testuser:
</p>

<pre caption="Creare il database MyDB">
$ <i>createdb -O testuser -U chris -W MyDB</i>
Password:
CREATE DATABASE
</pre>

<p>
A questo punto è disponibile un nuovo database MyDB e un testuser che può
accedervi. Per testare il tutto, effettuare il login come testuser al nuovo
database MyDB utilizzando il programma <c>psql</c>. Questo programma è usato per
connettersi a un database PostgreSQL dalla linea di comando. Per cui la
connessione al nuovo database sarà eseguita in questo modo:
</p>

<pre caption="Login nel database MyDB come testuser">
$ <i>psql -U testuser -W MyDB</i>
Password:
Welcome to psql 8.0.4, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

MyDB=&gt;
</pre>

<p>
In questo modo, l'utente testuser è loggato nel database e può iniziare ad
avviare qualche comando. Per prendere familiarità con PostgreSQL, la prossima
sezione riguarderà l'utilizzo di alcuni comandi base navigando con il client
<c>psql</c>.
</p>

</body>
</section>
<section>
<title>Comandi base di PostgreSQL e creazione di tabelle</title>
<body>

<p>
Per coloro che sono abituati a MySQL, questa sezione è indispensabile. Questa
sezione dovrebbe illustrare il funzionamento di PostgreSQL con un occhio di
riguardo ai comandi da eseguire. Per iniziare, qui c'è una lista di alcuni
comandi che verranno trattati:
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Utilizzo</th>
  <th>Equivalente in MySQL</th>
</tr>
<tr>
  <ti>\c[onnect] [NOMEDB|- [USER]]</ti>
  <ti>Connette ad un altro database</ti>
  <ti>USE DATABASE</ti>
</tr>
<tr>
  <ti>\q</ti>
  <ti>Esce dal client <c>psql</c></ti>
  <ti>quit</ti>
</tr>
<tr>
  <ti>\i FILE</ti>
  <ti>Esegue i comandi da un <c>FILE</c></ti>
  <ti>source FILE</ti>
</tr>
<tr>
  <ti>\o [FILE]</ti>
  <ti>Invia i risultati della query su un <c>FILE</c></ti>
  <ti>INTO OUTFILE, ma invia tutto (non solo i SELECT)</ti>
</tr>
<tr>
  <ti>\d [NAME]</ti>
  <ti>Descrive un database o una tabella (assieme ad altre cose)</ti>
  <ti>DESC(RIBE)</ti>
</tr>
<tr>
  <ti>\db [PATTERN]</ti>
  <ti>
    Elenca le tabelle disponibili che rispecchiano il <c>PATTERN</c>
    specificato (le elenca tutte se non viene specificato alcun pattern)
  </ti>
  <ti>SHOW TABLES</ti>
</tr>
</table>

<p>
Con l'eccezione di <c>\c[onnect]</c>, tutti i comandi visti saranno
utilizzati successivamente in questa sezione. Per ora il database è vuoto,
quindi biusogna inserire qualche dato. Il primo passo per inserire dati,
tuttavia, è quello di inserirli in una tabella. Per ora non ci sono tabelle
nel database, quindi bisogna crearne una, e lo si può fare con il comando
<c>CREATE TABLE</c>. Verrà creata una tabella di articoli, che conterranno un
identificativo (product_id), una descrizione (description) e un prezzo (price).
</p>

<pre caption="Creare la tabella degli articoli">
MyDB=> CREATE TABLE products (
MyDB(&gt;   product_id SERIAL,
MyDB(&gt;   description TEXT,
MyDB(&gt;   price DECIMAL
MyDB(&gt; );
NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"
for serial column "products.product_id"
CREATE TABLE
</pre>

<p>
Si può tranquillamente ignorare il NOTICE, è innocuo. Guardando l'ultima riga
della funzione, <c>CREATE TABLE</c> indica che il comando è stato eseguito con
successo. Tuttavia è meglio verificare se la tabella è stata creata
correttamente con il comando <c>\d</c>:
</p>

<pre caption="Esaminare la nuova tabella creata">
MyDB=&gt; <i>\d products</i>
                                 Table "public.products"
   Column    |  Type   |                            Modifiers
-------------+---------+------------------------------------------------------------------
 product_id  | integer | not null default nextval('public.products_product_id_seq'::text)
 description | text    |
 price       | numeric |
</pre>

<p>
La tabella è stata creata correttamente. Adesso che la tabella è creata, è
il momento di riempirla con i dati. La prossima sezione riguarderà il
riempimento del database con i dati.
</p>

</body>
</section>
<section>
<title>Inserire dati nel database</title>
<body>

<p>
Questa sezione riguarda le due vie per inserire dati nella nuova tabella
creata. Prima è una buona idea vedere il comando più semplice, <c>INSERT</c>:
</p>

<pre caption="Sintassi di INSERT">
INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)
</pre>

<p>
<c>tablename</c> è il nome della tabella dove inserire i dati.
(column1,column2,column3) servono per specificare le colonne dove devono
essere inseriti i valori. VALUES(value1,value2,value3) è la lista dei valori.
I valori vengono inseriti con lo stesso ordine delle colonne (la prima colonna
riceve il primo valore, la seconda il secondo valore, etc). Il numero delle
colonne e dei rispettivi valori <e>deve</e> essere uguali. Proseguire inserendo
un articolo nella tabella:
</p>

<impo>
Avendo lavorato con i database per un lungo periodo, l'autore di questo
documento raccomanda personalmente di specificare il comando <c>INSERT</c> come
indicato qui. Gli sviluppatori spesso fanno l'errore di usare <c>INSERT INTO</c>
senza specificare le colonne. Questo comportamento non è molto produttivo,
infatti se viene inserita una nuova colonna nel database, verrà dato un errore
se il numero dei valori non corrisponde con il numero delle colonne. Conviene
quindi specificare <e>sempre</e> le colonne a meno che non abbia la certezza al
300% sul fatto che non ne verranno aggiunte di nuove.
</impo>

<pre caption="Inserire dati in una tabella">
MyDB=&gt; <i>INSERT INTO products (description,price) VALUES('A test product', 12.00);</i>
INSERT 17273 1
</pre>

<p>

L'ultima riga necessita un po' di spiegazioni. L'output riportato dal comando
insert è formato da un OID (Object Identifier) e dal numero di righe inserite.
L'OID va un po' oltre l'obiettivo di questa guida, e nel <uri
link="http://www.postgresql.org/docs/8.1/static/datatype-oid.html"> PostgreSQL
manual</uri> è possibile trovare più informazioni a riguardo. Per una situazione
dove si hanno 20.000 prodotti, questi comandi insert sono un po' fastidiosi;
tuttavia, nulla è perduto. Il comando <c>COPY</c> può essere usato per inserire
dati in una tabella da un file o dallo standard input. In questo esempio viene
usato un file csv (comma separated values), che contiene product id, description
e price. Il file avrà un contenuto simile a questo:
</p>

<pre caption="products.csv">
2,meat,6.79
3,soup,0.69
4,soda,1.79
</pre>

<p>
Adesso verrà usato il comando <c>COPY</c> per popolare la tabella:
</p>

<impo>
È usato il comando <c>COPY FROM STDIN</c> perché solo l'utente postgres può
inserire dati da un file (per ragioni di sicurezza).
</impo>

<pre caption="Usare COPY per inserire i prodotti nella tabella">
MyDB=&gt; <i>COPY products FROM STDIN WITH DELIMITER AS ',';</i>
Enter data to be copied followed by a newline.
End with a backslash and a period on a line by itself.
>> <i>2,meat,6.79</i>
>> <i>3,soup,0.69</i>
>> <i>4,soda,1.79</i>
>> <i>\.</i>
</pre>

<p>
Sfortunatamente, questa riga non restituisce le stesse informazioni date dal
comando <c>INSERT INTO</c>. Come si fa a sapere se i dati sono stati inseriti?
La prossima sezione riguarderà l'uso di query per controllare i propri dati.
</p>

</body>
</section>
<section>
<title>Usare le query PostgreSQL</title>
<body>

<p>
Questa sezione riguarda l'uso del comando <c>SELECT</c> per visionare i dati
contenuti nelle tabelle. La sintassi base di <c>SELECT</c> è la seguente:
</p>

<pre caption="Sintassi di SELECT">
SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]
</pre>

<p>
Ci sono due vie per selezionare le colonne. La prima è quella di usare <c>*</c>
per selezionare tutte le colonne, e la seconda è quella di specificare una lista
di colonne che si vogliono vedere. La seconda è abbastanza comoda quando si
vuole trovare una specifica colonna anziché una grande lista. Cominciare usando
<c>SELECT</c> con <c>*</c> per specificare tutte le colonne:
</p>

<pre caption="Visualizzare la tabella 'products'">
MyDB=&gt; <i>SELECT * FROM products;</i>
 product_id |  description   | price
------------+----------------+-------
          1 | A test product | 12.00
          2 | meat           |  6.79
          3 | soup           |  0.69
          4 | soda           |  1.79
(4 rows)
</pre>

<p>
Come si può notare, tutti i dati inseriti prima sono stati messi nella tabella.
Adesso si ipotizzi di voler mostrare solo la descrizione ed il prezzo, ignorando
l'id. In questo caso verranno specificate le colonne a SELECT in questo modo:
</p>

<pre caption="Mostrare specifiche colonne della tabella dei prodotti">
MyDB=&gt; <i>SELECT description,price FROM products;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
 soup           |  0.69
 soda           |  1.79
(4 rows)
</pre>

<p>
Adesso vengono mostrati solo la descrizione e il prezzo, pertanto lo sguardo
cade solo sui dati importanti. Adesso si ipotizzi di voler mostrare solo i
prodotti che hanno un prezzo maggiore di $2,00. In questi casi è molto comodo il
parametro <c>WHERE</c>:
</p>

<pre caption="Mostrare specifiche righe della tabella dei prodotti">
MyDB=&gt; <i>SELECT description,price FROM products WHERE price > 2.00;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
(2 rows)
</pre>

<p>
Ora viene mostrata una lista dei prodotti che hanno un prezzo maggiore di $2,00,
riducendo ancora di più la serie di dati visualizzati. Le query di questo tipo
sono molti utili e possono aiutare nella creazione di utili report.
</p>

</body>
</section>
<section>
<title>Conclusione</title>
<body>

<p>
Con ciò si conclude la guida a PostgreSQL. Un grande ringraziamento va a
Masatomo Nakano, il quale gestiva Gentoo PostgreSQL, per il suo aiuto nel
rispondere alle domande poste dall'autore di questo documento. Se si hanno
suggerimenti in merito a questa guida è possibile inviare un'email a
<mail>chriswhite@gentoo.org</mail>. Per una documentazione più estesa, dare
un'occhiata al<uri link="http://www.postgresql.org">sito web di
PostgreSQL</uri>.
</p>

</body>
</section>
</chapter>
</guide>
