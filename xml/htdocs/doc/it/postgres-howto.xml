<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/postgres-howto.xml,v 1.1 2006/06/14 21:10:26 so Exp $ -->

<guide link="/doc/it/postgres-howto.xml" lang="it">
<title>Guida a PostgreSQL</title>

<author title="Autore">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Editore">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Traduttore">
  <mail link="lucamarturana@gmail.com">Luca Marturana</mail>
</author>

<abstract>
Questa guida è stata pensata per mostrare un setup base di PostgreSQL. Il
setup descritto qui dovrebbe essere sufficiente per poter usare applicazioni
web base e altri programmi che forniscono un supporto per PostgreSQL.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2006-03-14</date>

<chapter>
<title>Introduzione</title>
<section>
<title>Introduzione a PostgreSQL</title>
<body>

<p>
Quando tra vari sviluppatori si discute sulle differenti soluzioni database
che si possono usare, due grandi database solitamente costituiscono le
risposte.  Uno potrebbe essere <c>MySQL</c> e l'altro è quello a cui questo
documento si riferisce, ovvero <c>PostgreSQL</c>. I vantaggi dell'uno
rispetto all'altro costituiscono una lunga disputa, comunque c'è solo da dire
che PostgreSQL ha avuto un più fermo controllo sulle vere strutture database
relazionali rispetto a MySQL. Molte caratteristiche standard come <b>FOREIGN
KEY</b> sono solamente state aggiunte su MySQL 5. Comunque, in ogni caso
questo documento assume già che PostgreSQL è stato già scelto dall'utente
come database da usare. Il primo passo da eseguire è il processo
<c>emerge</c>. Nella prossima sezione, verrà descritto il processo di
installazione tramite emerge, oltre che la configurazione di base.
</p>

</body>
</section>
<section>
<title>Installazione di PostgreSQL</title>
<body>

<p>
Per iniziare, dobbiamo per prima cosa <c>emergere</c> il pacchetto
PostgreSQL.  Per fare ciò, eseguiamo il seguente comando per assicurarci che
sono settate le corrette opzioni.
</p>

<pre caption="Verifica delle opzioni di PostgreSQL">
# <i>emerge -pv postgresql</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +libg++ +nls +pam +perl
-pg-hier -pg-intdatetime +python +readline (-selinux) +ssl -tcltk +xml2 +zlib 0 kB
</pre>

<p>
Qui c'è una lista di cosa indicano le differenti opzioni:
</p>

<table>
<tr>
  <th>Flag USE</th>
  <th>Significato</th>
</tr>
<tr>
  <ti>doc</ti>
  <ti>
    Questa flag USE abilita o disabilita l'installazione della documentazione
    extra oltre le pagine di manuale standard. È consigliabile disabilitarla
    solo se si è a corto di spazio, oppure se si hanno metodi alternativi per
    accedere ad essa (per esempio in rete).
  </ti>
</tr>
<tr>
  <ti>kerberos</ti>
  <ti>
		Durante la connessione al database, con questa opzione abilitata,
		l'amministratore ha la possibilità di usare <c>kerberos</c> per
		autenticare i propri utenti/servizi al database.
  </ti>
</tr>
<tr>
  <ti>libg++</ti>
  <ti>
    Con questa opzione abilitata, verranno compilati in PostgreSQL i binding
    C++. Verrano quindi compilate le librerie libpg++ per poter usare i
    programmi C++ con PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>nls</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL può utilizzare le localizzazioni
    per gli utenti non inglesi.
  </ti>
</tr>
<tr>
  <ti>pam</ti>
  <ti>
    Con questa opzione abilitata, e le corrette configurazioni da parte
    dell'amministratore, gli utenti/servizi possono effettuare il login su un
    database PostgreSQL tramite <c>PAM</c> (Pluggable Authentication Module).
  </ti>
</tr>
<tr>
  <ti>perl</ti>
  <ti>
    Con questa opzione abilitata, verranno compilati i binding <c>perl</c>.
  </ti>
</tr>
<tr>
  <ti>pg-hier</ti>
  <ti>
    Con questa opzione abilitata, sarà applicata un patch per abilitare le
    query gerarchiche, come ad esempio <c>CONNECT</c> nei server database
    <c>Oracle</c>. Maggiori informazioni sulle query gerarchiche possono essere
    trovate sull'<uri
    link="http://www.lc.leidenuniv.nl/awcourse/oracle/server.920/a96540/
    queries4a.htm">Oracle Reference Guide</uri>.
  </ti>
</tr>
<tr>
  <ti>pg-intdatetime</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL supporterà i tipi date a 64 bit.
  </ti>
</tr>
<tr>
  <ti>python</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL verrà compilato con i binding
    <c>python</c>.
  </ti>
</tr>
<tr>
  <ti>readline</ti>
  <ti>
    Se questa opzione viene abilitata, PostgreSQL supporterà lo stile di
    editing della command line <c>readline</c>. Ciò include lo storico dei
    comandi e l'isearch.
  </ti>
</tr>
<tr>
  <ti>selinux</ti>
  <ti>
    Con questa opzione abilitata, verranno installate per PostgreSQL le policy
    <c>selinux</c>.
  </ti>
</tr>
<tr>
  <ti>ssl</ti>
  <ti>
    Con questa opzione abilitata, PostgreSQL utilizzerà la libreria
    <c>OpenSSL</c> per criptare la comunicazione tra client e server
    PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>tcltk</ti>
  <ti>
		Se viene abilitata questa opzione, PostgreSQL verrà compilato con i
		binding <c>tcl/tk</c>.
  </ti>
</tr>
<tr>
  <ti>xml2</ti>
  <ti>
    Con questa opzione abilitata, verrà compilato il supporto allo stile xml
    <c>XPATH</c>. Maggiori informazioni sull'utilizzo del supporto xml con
    PostgreSQL possono essere trovate su: <uri
    link="http://www.throwingbeans.org/tech/postgresql_and_xml.html">PostgreSQL
    and XML</uri>.
  </ti>
</tr>
<tr>
  <ti>zlib</ti>
  <ti>
    Questa flag non è usata da PostgreSQL stesso, ma da <c>pg_dump</c> per
    comprimere i dump da esso prodotti.
  </ti>
</tr>
</table>

<note>
Gli autori della patch <c>pg-hier</c> hanno smesso di lavorare su di essa, e
quindi potrebbe essere rimossa nelle versioni successive.
</note>

<p>
Dopo aver personalizzato PostgreSQL per le proprie necessità, lanciare
<c>emerge</c>:
</p>

<pre caption="Compilazione di PostgreSQL">
# <i>emerge postgresql</i>
<comment>(Output tagliato)</comment>
>>> /usr/lib/libecpg.so.5 -> libecpg.so.5.0
>>> /usr/bin/postmaster -> postgres
 * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell
 *
 * Execute the following command
 * emerge --config =postgresql-8.0.4
 * to setup the initial database environment.
 *
>>> Regenerating /etc/ld.so.cache...
>>> dev-db/postgresql-8.0.4 merged.
</pre>

<p>
Come mostrato dall'output di einfo, ci sono delle operazioni post-installazione
da fare. Il capitolo successivo si occuperà della configurazione di PostgreSQL.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Configurazione di PostgreSQL</title>
<section>
<title>Impostazione dell'ambiente database iniziale</title>
<body>

<p>
Come notato nel precedente output di <c>emerge</c>, deve essere settato
l'ambiente database iniziale. Comunque, prima di fare ciò, deve tener conto di
una cosa. Diversamente da MySQL, la password di "root" di PostgreSQL è la
password dell'utente reale. Tuttavia, solo l'utente viene creato dall'ebuild,
<e>non</e> la password. Quindi, prima di cominciare, deve essere settata la
password per l'utente postgres:
</p>

<pre caption="Impostare la password">
# <i>passwd postgres</i>
New UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</pre>

<p>
Adesso, è possibile creare l'ambiente database iniziale:
</p>

<pre caption="Configurazione dell'ambiente database iniziale con emerge --config">
# <i>emerge --config =postgresql-8.0.4</i>


Configuring pkg...

 * Creating the data directory ...
 * Initializing the database ...
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale C.

fixing permissions on existing directory /var/lib/postgresql/data ... ok
creating directory /var/lib/postgresql/data/global ... ok
creating directory /var/lib/postgresql/data/pg_xlog ... ok
creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok
creating directory /var/lib/postgresql/data/pg_clog ... ok
creating directory /var/lib/postgresql/data/pg_subtrans ... ok
creating directory /var/lib/postgresql/data/base ... ok
creating directory /var/lib/postgresql/data/base/1 ... ok
creating directory /var/lib/postgresql/data/pg_tblspc ... ok
selecting default max_connections ... 100
selecting default shared_buffers ... 1000
creating configuration files ... ok
creating template1 database in /var/lib/postgresql/data/base/1 ... ok
initializing pg_shadow ... ok
enabling unlimited row size for system tables ... ok
initializing pg_depend ... ok
creating system views ... ok
loading pg_description ... ok
creating conversions ... ok
setting privileges on built-in objects ... ok
creating information schema ... ok
vacuuming database template1 ... ok
copying template1 to template0 ... ok

WARNING: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the -A option the
next time you run initdb.

Success. You can now start the database server using:

    /usr/bin/postmaster -D /var/lib/postgresql/data
or
    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start

 *
 * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.
 *
</pre>

<p>
Adesso l'ambiente database iniziale è stato configurato. La prossima sezione
riguarderà la verifica dell'installazione e la configurazione degli utenti per
accedere al database.
</p>

</body>
</section>
<section>
<title>Configurazione del database PostgreSQL</title>
<body>

<p>
Adesso che PostgreSQL è configurato, è una buona idea a questo punto
verificare l'installazione. Per prima cosa, assicurarsi che il servizio parte
regolarmente:
</p>

<pre caption="Avvio del servizio PostgreSQL">
# <i>/etc/init.d/postgresql start</i>
* Starting PostgreSQL ...                                          [ ok ]
</pre>

<p>
Dopo aver verificato il funzionamento, è pure una buona idea aggiungerlo al
runlevel default in modo da farlo partire all'avvio della macchina:
</p>

<pre caption="Aggiunta di PostgreSQL al runlevel default">
# <i>rc-update add postgresql default</i>
* postgresql added to runlevel default
</pre>

<p>
Adesso che il servizio è attivato, è il momento di configurare un database di
test. Per iniziare, creiamo un database di test usando il comando
<c>createdb</c>. Passiamo inoltre l'opzione <c>-U</c> per selezionare l'utente
(se non viene specificato nulla utilizza l'utente corrente), e il parametro
<c>-W</c> per fargli chiedere la password che abbiamo creato prima. Infine
passiamo anche il nome del database che vogliamo creare:
</p>

<pre caption="Creazione di un database con createdb">
$ <i>createdb -U postgres -W test</i>
Password:
CREATE DATABASE
</pre>

<p>
Il database è stato creato con successo e ci siamo assicurati che il server
database può eseguire i comandi base. Adesso andiamo avanti e eseguiamo il
drop del database (lo rimuoviamo) con il comando <c>dropdb</c>, ne creeremo
un altro in seguito:
</p>

<pre caption="Rimozione di un database con dropdb">
$ <i>dropdb -U postgres -W test</i>
Password:
DROP DATABASE
</pre>

<p>
Adesso, solo l'utente postgres può eseguire comandi. Evidentemente questo non
è il tipo di setup adatto ad un ambiente multi-utente. La prossima sezione
riguarderà la configurazione degli account per gli utenti.
</p>

</body>
</section>
<section>
<title>Configurazione degli account utente per il database</title>
<body>

<p>
Come detto prima, loggarsi come utente postgres è una cosa sicuramente poco
adatta per un ambiente multi-utente. In molti casi ci saranno vari utenti e
servizi che accederanno al server, e ognuno richiede diversi permessi. Così,
per gestire questa situazione, può essere usato il comando <c>createuser</c>.
Questo comando è una alternativa all'usare le query SQL, ed è molto più
flessibile dal punto di vista dell'amministratore. Andiamo avanti e creiamo due
utenti, un 'superuser' che può aggiungere altri utenti e amministrare il
database e un utente standard:
</p>

<pre caption="Configurazione del superuser">
<comment>(sostituire chris con il nome utente che si vuole usare)</comment>
$ <i>createuser -a -d -P -E -U postgres -W chris</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Adesso abbiamo creato un superuser. L'opzione <c>-a</c> specifica che l'utente
può aggiungere altri utenti. <c>-d</c> indica che l'utente può creare nuovi
database. <c>-P</c> serve per farci chiedere una password per l'utente e
<c>-E</c> la cripterà per ragioni di sicurezza. Ora, testiamo i permessi del
nuovo utente creando un nuovo utente standard:
</p>

<pre caption="Configurazione di un utente standard">
<comment>(sostituire chris con il nome dell'utente creato in precedenza)</comment>
$ <i>createuser -A -D -P -E -U chris -W testuser</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Perfetto! Il nostro nuovo utente è stato creato usando il superuser creato
precedentemente. Le opzioni <c>-A</c> e <c>-D</c> sono il contrario di
<c>-a</c> e <c>-d</c>, quindi negano all'utente la possibilità di creare altri
utenti e database. Adesso ci sono gli utenti per lavorare ed è stato creato un
nuovo database, il prossimo capitolo riguarderà l'utilizzo di questo nuovo
database.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Usare PostgreSQL</title>
<section>
<title>Impostare i permessi</title>
<body>

<p>
Con il nuovo database creato, è presente un utente che può creare database e
aggiungere altri utenti e l'utente postgres principale che può fare qualsiasi
cosa. L'utente creato prima può solamente loggarsi nel server. In generale
però, gli utenti hanno la necessità di inserire e prelevare dati, e a volte
anche altri tipi di operazioni. Quindi, per permettere al nuovo utente di fare
qualsiasi cosa, è necessario impostarlo con i giusti permessi. Ciò può fare
facilmente passando il parametro <c>-O</c> a <c>createdb</c>. Cominceremo con
il creare un nuovo database, <b>MyDB</b> con il nostro superuser il cui
proprietario sarà il precedente testuser:
</p>

<pre caption="Creare il database MyDB">
$ <i>createdb -O testuser -U chris -W MyDB</i>
Password:
CREATE DATABASE
</pre>

<p>
Adesso abbiamo un nuovo database MyDB e un testuser che può accedervi. Per
testare il tutto, effettueremo il login come testuser al nuovo database MyDB.
Per fare ciò useremo il programma <c>psql</c>. Questo programma è usato per
connettersi a un database PostgreSQL dalla linea di comando. Quindi la
connessione al nuovo database sarà eseguita in questo modo:
</p>

<pre caption="Login nel database MyDB come testuser">
$ <i>psql -U testuser -W MyDB</i>
Password:
Welcome to psql 8.0.4, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

MyDB=&gt;
</pre>

<p>
In questo modo, l'utente testuser è loggato nel database e può iniziare ad
avviare qualche comando. Per prendere familiarità con PostgreSQL, la prossima
sezione riguarderà l'utilizzo di alcuni comandi base navigando con il client
<c>psql</c>.
</p>

</body>
</section>
<section>
<title>Comandi base di PostgreSQL e creazione di tabelle</title>
<body>

<p>
Per coloro che sono abituati a MySQL, questa sezione è indispensabile. Questa
sezione dovrebbe illustrare il funzionamento di PostgreSQL con un occhio di
riguardo ai comandi da eseguire. Per iniziare, qui c'è una lista di alcuni
comandi che verranno trattati:
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Utilizzo</th>
  <th>Equivalente in MySQL</th>
</tr>
<tr>
  <ti>\c[onnect] [DBNAME|- [USER]]</ti>
  <ti>Connette ad un altro database</ti>
  <ti>USE DATABASE</ti>
</tr>
<tr>
  <ti>\q</ti>
  <ti>Esce dal client <c>psql</c></ti>
  <ti>quit</ti>
</tr>
<tr>
  <ti>\i FILE</ti>
  <ti>Esegue i comandi da un <c>FILE</c></ti>
  <ti>source FILE</ti>
</tr>
<tr>
  <ti>\o [FILE]</ti>
  <ti>Invia i risultati della query su un <c>FILE</c></ti>
  <ti>INTO OUTFILE, ma invia tutto (non solo i SELECT)</ti>
</tr>
<tr>
  <ti>\d [NAME]</ti>
  <ti>Descrive un database o una tabella (assieme ad altre cose)</ti>
  <ti>DESC(RIBE)</ti>
</tr>
<tr>
  <ti>\db [PATTERN]</ti>
  <ti>
    Elenca le tabelle disponibili che rispecchiano il <c>PATTERN</c>
    specificato (le elenca tutte se non viene specificato alcun pattern)
  </ti>
  <ti>SHOW TABLES</ti>
</tr>
</table>

<p>
Con l'eccezione di <c>\c[onnect]</c>, tutti i comandi visti saranno
utilizzati successivamente in questa sezione. Per ora il database è vuoto.
Quindi dobbiamo inserire qualche dato. Il primo passo per inserire dati,
tuttavia, è quello di inserirli in una tabella. Per ora non ci sono tabelle
nel database, quindi dobbiamo crearne una. Ciò è possibile con il comando
<c>CREATE TABLE</c>.  Creeremo quindi una tabella di articoli. Essi
conterranno un Product ID, una descrizione (Description) e un prezzo
(price).
</p>

<pre caption="Creare la tabella degli articoli">
MyDB=> CREATE TABLE products (
MyDB(&gt;   product_id SERIAL,
MyDB(&gt;   description TEXT,
MyDB(&gt;   price DECIMAL
MyDB(&gt; );
NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"
for serial column "products.product_id"
CREATE TABLE
</pre>

<p>
Si può tranquillamente ignorare il NOTICE, è innocuo. Guardando l'ultima riga
della funzione, <c>CREATE TABLE</c> ci sembra indicare che il comando è stato
eseguito con successo. Comunque, andiamo a verificare se la tabella è stata
creata correttamente con il comando <c>\d</c>:
</p>

<pre caption="Controllare la nuova tabella creata">
MyDB=&gt; <i>\d products</i>
                                 Table "public.products"
   Column    |  Type   |                            Modifiers
-------------+---------+------------------------------------------------------------------
 product_id  | integer | not null default nextval('public.products_product_id_seq'::text)
 description | text    |
 price       | numeric |
</pre>

<p>
La tabella è stata creata correttamente. Adesso che la tabella è creata, è
il momento di riempirla con i dati. La prossima sezione riguarderà il
riempimento del database con i dati.
</p>

</body>
</section>
<section>
<title>Inserire dati nel database</title>
<body>

<p>
Questa sezione riguarda le due vie per inserire dati nella nuova tabella
creata. Prima diamo un'occhiata al comando più semplice, <c>INSERT</c>:
</p>

<pre caption="Sintassi di INSERT">
INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)
</pre>

<p>
<c>tablename</c> è il nome della tabella dove dobbiamo inserire i dati.
(column1,column2,column3) servono per specificare le colonne dove devono
essere inseriti i valori. VALUES(value1,value2,value3) è la lista dei valori.
I valori vengono inseriti con lo stesso ordine delle colonne (la prima colonna
riceve il primo valore, la seconda il secondo valore, etc). Il numero delle
colonne e dei rispettivi valori <e>deve</e> essere lo stesso. Quindi andiamo a
inserire un articolo nella tabella:
</p>

<impo>
Avendo lavorato con i database per un lungo periodo, Io personalmente
raccomando di specificare il comando <c>INSERT</c> come indicato qui. Gli
sviluppatori spesso fanno l'errore di usare <c>INSERT INTO</c> senza
specificare le colonne. Questo comportamento non è molto produttivo, infatti
se viene inserita una nuova colonna nel database, verrà dato un errore se il
numero dei valori non corrisponde con il numero delle colonne. Conviene
quindi specificare <e>sempre</e> le colonne a meno che non si è certi al 300%
sul fatto che non ne verranno aggiunte di nuove.
</impo>

<pre caption="Inserire dati in una tabella">
MyDB=&gt; <i>INSERT INTO products (description,price) VALUES('A test product', 12.00);</i>
INSERT 17273 1
</pre>

<p>
L'ultima riga necessita un po' di spiegazioni. L'output riportato dal comando
insert è formato da un OID (Object Identifier) e dal numero di righe
inserite.  L'OID va un po' oltre l'obbiettivo di questa guida, e nel <uri
link="http://www.postgresql.org/docs/8.1/static/datatype-oid.html">PostgreSQL
manual</uri> è possibile trovare più informazioni a riguardo. Per una
situazione dove si hanno 20.000 prodotti, questi comandi insert sono un po'
fastidiosi. Tuttavia, nulla è perduto. Il comando <c>COPY</c> può essere
usato per inserire dati in una tabella da un file o da stdin. In questo
esempio, abbiamo un file csv (comma separated values), che contiene product
id, description e price. Il suddetto file assomiglia a qualcosa del genere:
</p>

<pre caption="products.csv">
2,meat,6.79
3,soup,0.69
4,soda,1.79
</pre>

<p>
Adesso useremo il comando <c>COPY</c> per inserire i nostri dati:
</p>

<impo>
È usato il comando <c>COPY FROM STDIN</c> perché solo l'utente postgres può
inserire dati da un file (per ragioni di sicurezza).
</impo>

<pre caption="Usare COPY per inserire i prodotti nella tabella">
MyDB=&gt; <i>COPY products FROM STDIN WITH DELIMITER AS ',';</i>
Enter data to be copied followed by a newline.
End with a backslash and a period on a line by itself.
>> <i>2,meat,6.79</i>
>> <i>3,soup,0.69</i>
>> <i>4,soda,1.79</i>
>> <i>\.</i>
</pre>

<p>
Sfortunatamente, questa riga non restituisce le stesse informazioni date dal
comando <c>INSERT INTO</c>. Come facciamo a sapere se i dati sono stati
inseriti? La prossima sezione riguarderà l'uso di query per controllare i
nostri dati.
</p>

</body>
</section>
<section>
<title>Usare le query PostgreSQL</title>
<body>

<p>
Questa sezione riguarda l'uso del comando <c>SELECT</c> per visionare i dati
contenuti nelle tabelle. La sintassi base di <c>SELECT</c> è la seguente:
</p>

<pre caption="Sintassi di SELECT">
SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]
</pre>

<p>
Ci sono due vie per selezionare le colonne. La prima è quella di usare
<c>*</c> per selezionare tutte le colonne, e la seconda è quella di
specificare una lista di colonne che si vogliono vedere. La seconda è
abbastanza comoda quando si vuole trovare una specifica colonna anziché una
grande lista. Cominciamo usando <c>SELECT</c> con <c>*</c> per specificare
tutte le colonne:
</p>

<pre caption="Mostrare la tabella dei prodotti">
MyDB=&gt; <i>SELECT * FROM products;</i>
 product_id |  description   | price
------------+----------------+-------
          1 | A test product | 12.00
          2 | meat           |  6.79
          3 | soup           |  0.69
          4 | soda           |  1.79
(4 rows)
</pre>

<p>
Come si può notare, tutti i dati inseriti prima sono stati messi nella
tabella.  Adesso immaginiamo di voler mostrare solo la descrizione ed il
prezzo, ignorando l'id. In questo caso specificheremo le colonne a SELECT in
questo modo:
</p>

<pre caption="Mostrare specifiche colonne della tabella dei prodotti">
MyDB=&gt; <i>SELECT description,price FROM products;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
 soup           |  0.69
 soda           |  1.79
(4 rows)
</pre>

<p>
Adesso vengono mostrati solo la descrizione e il prezzo, pertanto il nostro
sguardo cade solo sui dati importanti. Adesso immaginiamo di voler mostrare
solo i prodotti che hanno un prezzo maggiore di $2,00. In questi casi è molto
comodo il parametro <c>WHERE</c>:
</p>

<pre caption="Mostrare specifiche righe della tabella dei prodotti">
MyDB=&gt; <i>SELECT description,price FROM products WHERE price > 2.00;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
(2 rows)
</pre>

<p>
Ora viene mostrata una lista dei prodotti che hanno un prezzo maggiore di
$2,00, riducendo ancora di più il range di dati visualizzati. Questo tipo di
query sono molti utili e possono aiutare nella creazione di utili report.
</p>

</body>
</section>
<section>
<title>Conclusione</title>
<body>

<p>
Con ciò si conclude la guida a PostgreSQL. Un grande ringraziamento va a
Masatomo Nakano, il quale gestisce Gentoo PostgreSQL per il suo aiuto nel
rispondere alle mie domande. Se avete suggerimenti in merito a questa guida
potete inviare una email a <mail>chriswhite@gentoo.org</mail>. Per una
documentazione più estesa, dare un'occhiata al<uri
link="http://www.postgresql.org">sito web di PostgreSQL</uri>.
</p>

</body>
</section>
</chapter>
</guide>
