<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/utf-8.xml">
<title>Usare UTF-8 con Gentoo</title>

<author title="Autore">
  <mail link="slarti@gentoo.org">Thomas Martin</mail>
</author>
<author title="Collaboratore">
  <mail link="devil@gentoo.org.ua">Alexander Simonov</mail>
</author>
<author title="Editore">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Traduttore">
  <mail link="cristiano.chiucchiolo@gmail.com">Cristiano Chiucchiolo</mail>
</author>

<abstract>
Questa guida mostra come installare e utilizzare il set di caratteri Unicode
UTF-8 nel vostro sistema Gentoo Linux, dopo aver spiegato i pregi di Unicode e
più in dettaglio di UTF-8.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license />

<version>2.17</version>
<date>2006-02-11</date>

<chapter>
<title>Codifiche di caratteri</title>
<section>
<title>Che cos'è la codifica dei caratteri?</title>
<body>

<p>
I computer non comprendono il testo da soli. Perciò ogni carattere è
rappresentato da un numero. Tradizionalmente, i set di numeri usati per
rappresentare alfabeti e simboli (conosciuti come sistemi di codifica o
"character sets") erano limitati nella loro dimensione a causa dei limiti
hardware dei computer.
</p>

</body>
</section>
<section>
<title>Storia delle codifiche di caratteri</title>
<body>

<p>
Il più comune (o almeno il più largamente accettato) character set è il codice
<b>ASCII</b> (American Standard Code for Information Interchange). Molti
ritengono che ASCII sia lo standard software che abbia goduto di maggior
successo in assoluto. Il moderno ASCII fu standardizzato nel 1986 (ANSI X3.4,
RFC 20, ISO/IEC 646:1991, ECMA-6) dall'American National Standards Institute.
</p>

<p>
Il codice ASCII è a 7 bit, ovvero utilizza sequenze di bit rappresentabili con
sette cifre binarie, che corrispondono all'intervallo da 0 a 127 in numeri
decimali. Essi includono 32 caratteri di controllo non visibili, da 0 a 31, con
il carattere di controllo finale, DEL o "delete", al 127. I caratteri da 32 a
126 sono visibili: spazi, punteggiatura, lettere e numeri.
</p>

<p>
L'ottavo bit nel codice ASCII era usato in origine come parity per il controllo
degli errori. Quando tale funzione non è desiderata, esso viene lasciato a 0.
Questo significa che nel codice ASCII ogni carattere è rappresentato da un
singolo byte.
</p>

<p>
Sebbene ASCII fosse sufficiente per comunicare in inglese moderno, per altre
lingue europee che utilizzano caratteri accentati, le cose non erano così
semplici. Per venire incontro a queste esigenze furono sviluppati gli standard
ISO 8859. Essi erano compatibili a ritroso con ASCII, ma anziché lasciare
l'ottavo bit inutilizzato, lo usavano per consentire la codifica di altri 127
caratteri. Ma i limiti di ISO 8859 vennero presto alla luce, ed infatti
attualmente ci sono 15 varianti di questo standard (da 8859-1 fino a 8859-15). 
Fuori dall'intervallo di bytes compatibile con ASCII, c'è spesso conflitto tra
le lettere rappresentate da ogni byte. A complicare ulteriormente
l'interoperabiltà tra le codifiche di caratteri, Windows-1252 è utilizzato in
alcune versioni di Microsoft Windows per le lingue dell'Europa Occidentale. Esso
è un superset di ISO 8859-1, ma differisce da questo standard in diversi punti.
Ad ogni modo, tutti questi set mantengono la compatibilità con ASCII.
</p>

<p>
Il necessario sviluppo di codifiche single-byte completamente differenti, per
gli alfabeti non latini, come EUC (Extended Unix Coding), che è utilizzato per
il giapponese e per il coreano (e in misura minore per il cinese), creò una
confusione ancor maggiore, mentre sistemi operativi diversi continuavano ad
utilizzare character sets diversi per le stesse lingue, ad esempio Shift-JIS e
ISO-2022-JP.  Gli utenti che avessero voluto visualizzare caratteri cirillici
dovevano scegliere tra la codifica KOI8-R per il russo e il bulgaro, la KOI8-U
per l'ucraino, e gli altri set cirillici, come lo sfortunato ISO 8859-5 e il
comune Windows-1251. Tutti questi set di caratteri fecero venire meno quasi
totalmente la compatibilità con ASCII (tuttavia le codifiche KOI8 mettono i
caratteri cirillici nell'ordine latino, cosicché togliendo l'ottavo bit, il
testo può ancora essere decifrato in un terminale ASCII attraverso una
translitterazione case-reversed.)
</p>

<p>
Questo ha portato confusione, oltre che una quasi totale incapacità di
comunicazione tra le lingue, soprattutto se utilizzano alfabeti diversi. Ma c'è
Unicode.
</p>

</body>
</section>
<section>
<title>Che cos'è Unicode?</title>
<body>

<p>
Unicode supera il tradizionale limite del byte singolo che affligge i set di
caratteri.  Utilizza 17 "piani" di 65.536 unità di codice, per rappresentare un
massimo di 1.114.112 caratteri. Poiché il primo piano, detto anche "Basic
Multilingual Plane" o BMP, contiene praticamente tutto ciò che serve in genere a
un utente, molti ritengono erroneamente che Unicode sia un character set a 16
bit.
</p>

<p>
Unicode è stato mappato in molti modi diversi, ma i due più comuni sono
<b>UTF</b> (Unicode Transformation Format) e <b>UCS</b> (Universal Character
Set). Un numero dopo UTF indica il numero di bit in una unità, mentre il numero
dopo UCS indica il numero di byte. UTF-8 è diventato il più diffuso mezzo di
interscambio di testo Unicode, grazie alla sua natura pulita a 8 bit, ed è
proprio questo infatti l'oggetto di questo documento.
</p>

</body>
</section>
<section>
<title>UTF-8</title>
<body>

<p>
UTF-8 è una codifica di caratteri a lunghezza variabile, cioè utilizza da 1 a 4
bytes per simbolo. Così il primo byte UTF-8 è usato per codificare l'ASCII,
dando a questo set di caratteri la piena compatibilità a ritroso con ASCII. In
UTF-8 ASCII e i caratteri latini sono intercambiabili con un piccolo aumento
nella dimensione dei dati, perché solo il primo bit viene utilizzato. Gli utenti
di alfabeti orientali, ad esempio i giapponesi, ai quali è stato assegnato un
intervallo di byte più elevato, sono scontenti, poiché questo causa un 50% di
ridondanza nei loro dati.
</p>

</body>
</section>
<section>
<title>Cosa può fare per te UTF-8</title>
<body>

<p>
UTF-8 consente di lavorare in un ambiente multilingue rispettoso degli standard
e internazionalmente accettato, con una ridondanza di dati relativamente bassa.
UTF-8 è il modo migliore per trasmettere testo non ASCII via Internet, Email,
IRC e praticamente qualunque altro mezzo. Nonostante ciò molte persone
considerano l'uso di UTF-8 nelle comunicazioni online un abuso. È sempre meglio
conoscere l'opinione verso UTF-8 di uno specifico canale, mailing list o gruppo
Usenet prima di usare caratteri UTF-8 <e>non-ASCII</e>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Utilizzare UTF-8 con Gentoo Linux</title>
<section>
<title>Trovare o creare una localizzazione UTF-8</title>
<body>

<p>
Adesso che hai compreso i principi che stanno dietro a Unicode, sei pronto ad
utilizzare UTF-8 nel tuo sistema.
</p>

<p>
Il requisito preliminare per poter utilizzare UTF-8 è avere installata una
versione di glibc che abbia il supporto per la nostra lingua. Per ottenere
questo si utilizza il file <path>/etc/locales.build</path>, in combinazione con
la flag USE <c>userlocales</c>. Non è tra gli scopi di questo documento spiegare
il funzionamento di tale file, ma fortunatamente il suo uso è ben documentato
nei commenti all'interno del file stesso. Inoltre una spiegazione dettagliata si
trova nella <uri link="/doc/it/guide-localization.xml#doc_chap3_sect3"> Gentoo
Linux Localization Guide</uri>.
</p>

<p>
Fatto ciò dobbiamo vedere se è già disponibile una localizzazione UTF-8 per la
nostra lingua, e se non lo è dobbiamo crearne una.
</p>

<pre caption="Controllo dell'esistenza di una localizzazione UTF-8">
<comment>(Sostituire "it_IT" con le impostazioni locali desiderate)</comment>
# <i>locale -a | grep 'it_IT'</i>
it_IT
it_IT.UTF-8
</pre>

<p>
Dell'output della riga di comando ci interessa il risultato con un suffisso
<c>.UTF-8</c>. Se non c'è alcun risultato con un suffisso simile, dobbiamo
creare una localizzazione compatibile UTF-8.
</p>

<note>
Eseguire il seguente codice solo se non si ha una localizzazione UTF-8
disponibile per la propria lingua.
</note>

<pre caption="Creare una localizzazione UTF-8">
<comment>(Sostituire "it_IT" con le impostazioni locali desiderate)</comment>
# <i>localedef -i it_IT -f UTF-8 it_IT.UTF-8</i>
</pre>

<p>
Un altro modo per includere una localizzazione UTF-8 è aggiungerla al file
<path>/etc/locales.build</path>, ricompilando poi <c>glibc</c> con la flag USE
<c>userlocales</c> impostata.
</p>

<pre caption="Riga da aggiungere in /etc/locales.build">
it_IT.UTF-8/UTF-8
</pre>

</body>
</section>
<section>
<title>Impostare la localizzazione</title>
<body>

<p>
C'è una variabile d'ambiente che deve essere impostata per poter utilizzare la
nostra nuova localizzazione UTF-8: <c>LC_ALL</c> (essa ha la precedenza sulla
variabile <c>LANG</c>). Ci sono diversi modi per impostarla; alcune persone
preferiscono avere un ambiente UTF-8 solo per un determinato utente, e in questo
caso le variabili vanno impostate in <path>~/.profile</path> (se si utilizza
<c>/bin/sh</c>), oppure in <path>~/.bash_profile</path> o <path>~/.bashrc</path>
(se si utilizza <c>/bin/bash</c>).
</p>

<p>
Altri preferiscono impostare la localizzazione globalmente. Si raccomanda in
modo particolare questa opzione se <path>/etc/init.d/xdm</path> è in uso, in
quanto questo init script avvia il display manager e il desktop prima che i
suddetti file di avvio della shell siano esaminati, e quindi quando le variabili
non sono ancora nell'ambiente.
</p>

<p>
Si può impostare la localizzazione globalmente utilizzando
<path>/etc/env.d/02locale</path>. Il file dovrebbe apparire simile a quanto
segue:
</p>

<pre caption="Dimostrazione /etc/env.d/02locale">
<comment>(Come sempre, sostituire "it_IT.UTF-8" con la propria
localizzazione)</comment>
LC_ALL="it_IT.UTF-8"
</pre>

<p>
Fatto ciò l'ambiente deve essere aggiornato affinché la modifica sia operativa.
</p>

<pre caption="Aggiornare l'ambiente">
# <i>env-update</i>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
# <i>source /etc/profile</i>
</pre>

<p>
A questo punto, eseguiamo <c>locale</c> senza argomenti per vedere se abbiamo
nel nostro ambiente le variabili corrette:
</p>

<pre caption="Controllare la presenza nell'ambiente della nuova localizzazione">
# <i>locale</i>
LANG=
LC_CTYPE="it_IT.UTF-8"
LC_NUMERIC="it_IT.UTF-8"
LC_TIME="it_IT.UTF-8"
LC_COLLATE="it_IT.UTF-8"
LC_MONETARY="it_IT.UTF-8"
LC_MESSAGES="it_IT.UTF-8"
LC_PAPER="it_IT.UTF-8"
LC_NAME="it_IT.UTF-8"
LC_ADDRESS="it_IT.UTF-8"
LC_TELEPHONE="it_IT.UTF-8"
LC_MEASUREMENT="it_IT.UTF-8"
LC_IDENTIFICATION="it_IT.UTF-8"
LC_ALL=it_IT.UTF-8
</pre>

<p>
Questo è tutto. Ora stai usando una localizzazione UTF-8, e il prossimo passo è
la configurazione delle applicazioni che usi ogni giorno.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Supporto applicazioni</title>
<section>
<body>

<p>
Quando Unicode iniziò a prendere forza nel mondo del software, i set di
caratteri multibyte non erano adatti a linguaggi come il C, in cui sono scritti
molti programmi che la gente usa ogni giorno.  Perfino oggi, alcuni programmi
non sono in grado di gestire UTF-8 in maniera adeguata.  Fortunatamente, la gran
parte di essi non dà problemi!
</p>

</body>
</section>
<section>
<title>Nomi file, NTFS, e FAT</title>
<body>

<p>
Ci sono diverse opzioni NLS nel menù di configurazione del kernel di Linux, ma è
importante non confondersi! In genere, la sola cosa da fare è compilare il
supporto NLS per UTF-8 dentro il kernel, impostando l'opzione NLS di default a
utf8.
</p>

<pre caption="Configurazione del Kernel per UTF-8 NLS">
File Systems --&gt;
  Native Language Support --&gt;
    (utf8) Default NLS Option
    &lt;*&gt; NLS UTF8
    <comment>( &lt;*&gt; anche altri set di caratteri che sono utilizzati nei
filesystem FAT e nei CD-ROM Joilet.)</comment>
</pre>

<p>
Se prevedi di montare partizioni NTFS, potresti aver bisogno di specificare
l'opzione <c>nls=</c> nel mount. Se prevedi di montare partizioni FAT, potrebbe
servirti l'opzione <c>codepage=</c>. Se vuoi, puoi anche impostare un codepage
di default per FAT nella configurazione del kernel. Nota che l'opzione
<c>codepage</c>  nel mount ha la precedenza sulle impostazioni del kernel.
</p>

<pre caption="Impostazioni FAT nella configurazione del kernel">
File Systems --&gt;
  DOS/FAT/NT Filesystems  --&gt;
    (437) Default codepage for fat
</pre>

<p>
Dovresti evitare di impostare <c>Default iocharset for fat</c> a UTF-8, dato che
è sconsigliato. Invece, potresti voler utilizzare l'opzione utf8=true nel
montare le partizioni FAT. Per maggiori informazioni, vedi <c>man mount</c> e la
documentazione del kernel in
<path>/usr/src/linux/Documentation/filesystems/vfat.txt</path>.
</p>

<p>
Per modificare la codifica dei nomi file, può essere utilizzato
<c>app-text/convmv</c>.
</p>

<pre caption="Esempio sull'uso di convmv">
# <i>emerge --ask app-text/convmv</i>
<comment>(Sintassi del comando)</comment>
# <i>convmv -f &lt;current-encoding&gt; -t utf-8 &lt;filename&gt;</i>
<comment>(Sostituisce iso-8859-1 con il charset utf-8)</comment>
# <i>convmv -f iso-8859-1 -t utf-8 filename</i>
</pre>

<p>
Per modificare la codifica del <e>contenuto</e> dei file, utilizza l'utility
<c>iconv</c>, contenuta in <c>glibc</c>:
</p>

<pre caption="Exsempio sull'uso di iconv">
<comment>(Sostituisce iso-8859-1 con il charset utf-8)</comment>
<comment>(Controlla se l'output è corretto)</comment>
# <i>iconv -f iso-8859-1 -t utf-8 filename</i> 
<comment>(Converte il file, creando un nuovo file)</comment>
# <i>iconv -f iso-8859-1 -t utf-8 filename > newfile</i>
</pre>

<p>
A questo scopo può essere usato anche <c>app-text/recode</c>.
</p>

</body>
</section>
<section>
<title>La console di sistema</title>
<body>

<impo>
È necessario >=sys-apps/baselayout-1.11.9 per avere Unicode sulla console.
</impo>

<p>
Per abilitare UTF-8 sulla console, è necessario editare
<path>/etc/rc.conf</path> e impostare <c>UNICODE="yes"</c>, leggendo anche i
commenti in quel file: è importante avere un font che abbia un buon numero di
caratteri, se si vuole ottenere il massimo da Unicode.
</p>

<p>
La variabile <c>KEYMAP</c>, impostata in <path>/etc/conf.d/keymaps</path>,
dovrebbe avere specificata una keymap Unicode.
</p>

<pre caption="Esempio ritaglio di /etc/conf.d/keymaps">
<comment>(Cambia "it" con il tuo layout locale)</comment>
KEYMAP="it"
</pre>

</body>
</section>
<section>
<title>Ncurses e Slang</title>
<body>

<note>
Ignora ogni riferimento a Slang in questa sezione se non lo hai installato o non
lo utilizzi.
</note>

<p>
È cosa saggia aggiungere <c>unicode</c> alle flag USE globali in
<path>/etc/make.conf</path>, riemergendo poi <c>sys-libs/ncurses</c> e
<c>sys-libs/slang</c> se necessario. Portage lo farà automaticamente
all'aggiornamento del sistema:
</p>

<pre caption="Aggiornare il sistema">
# <i>emerge --update --deep --newuse world</i>
</pre>

<p>
Dobbiamo anche ricompilare i pacchetti collegati ad essi, ora che i cambiamenti
alle flag USE sono stati applicati. Il tool che utilizzeremo
(<c>revdep-rebuild</c>) è parte del pacchetto <c>gentoolkit</c>.
</p>

<pre caption="Ricompilazione dei programmi collegati a ncurses o slang">
# <i>revdep-rebuild --soname libncurses.so.5</i>
# <i>revdep-rebuild --soname libslang.so.1</i>
</pre>

</body>
</section>
<section>
<title>KDE, GNOME e Xfce</title>
<body>

<p>
Tutti i più importanti ambienti desktop supportano pienamente Unicode, e non
richiederanno nessuna ulteriore configurazione. Questo perché i toolkit grafici
alla base di essi (Qt o GTK+2) supportano UTF-8. Di conseguenza, tutte le
applicazioni che si basano su questi toolkit dovrebbero essere immediatamente
compatibili con UTF-8.
</p>

<p>
Le eccezioni a questa regola arrivano con Xlib e GTK+1. GTK+1 richiede un
FontSpec iso-10646-1 in ~/.gtkrc, per esempio
<c>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</c>. Inoltre, le applicazioni che
utilizzano Xlib or Xaw necessiteranno di un FontSpec simile, in mancanza del
quale non funzioneranno.
</p>

<note>
Se hai da qualche parte una versione del centro di controllo gnome1, usa quella.
Da lì seleziona un qualunque font iso10646-1.
</note>

<pre caption="Esempio di ~/.gtkrc (per GTK+1) che definisce un font compatibile
con Unicode">
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>

<p>
Se un'applicazione supporta sia Qt che GTK+2, l'interfaccia grafica GTK+2 GUI
darà in genere risultati migliori con Unicode.
</p>

</body>
</section>
<section>
<title>X11 e Fonts</title>
<body>

<impo>
<c>x11-base/xorg-x11</c> ha un supporto Unicode di gran lunga migliore di quello
di XFree86, ed è <e>altamente</e> raccomandato.
</impo>

<p>
I fonts TrueType hanno il supporto per Unicode, e la maggiorparte dei fonts
inclusi in Xorg hanno un ottimo supporto per i caratteri, sebbene, ovviamente,
non tutti i segni disponibili in Unicode sono stati creati per quei fonts. Per
compilare i fonts (compreso il set Bitstream Vera) con il supporto per i
caratteri dell'Asia Orientale in X, assicurati di avere impostato la flag USE
<c>cjk</c>. Molte altre applicazioni utilizzano questa flag, quindi potrebbe
valere la pena di aggiungerla come permanente.
</p>

<p>
Inoltre, diversi pacchetti di fonts in Portage sono compatibili con Unicode.
</p>

<pre caption="Opzionale: Installare alcuni fonts aggiuntivi compatibili con
Unicode">
# <i>emerge terminus-font intlfonts freefonts cronyx-fonts corefonts</i>
</pre>

</body>
</section>
<section>
<title>Window managers ed emulatori di terminale</title>
<body>

<p>
I window managers non compilati su GTK o Qt hanno generalmente un supporto
Unicode molto buono, in quanto spesso utilizzano la libreria Xft per gestire i
fonts. Se il tuo window manager non usa Xft per i fonts, puoi sempre utilizzare
come font Unicode il FontSpec menzionato nella sezione precedente.
</p>

<p>
Gli emulatori di terminale che utilizzano Xft e supportano Unicode sono più
difficili da trovare. A parte Konsole e gnome-terminal, le migliori opzioni in
Portage sono <c>x11-terms/rxvt-unicode</c>, <c>xfce-extra/terminal</c>,
<c>gnustep-apps/terminal</c>, <c>x11-terms/mlterm</c>, o il semplice
<c>x11-terms/xterm</c>, compilato con la flag USE <c>unicode</c> e avviato con
il comando <c>uxterm</c>. Anche <c>app-misc/screen</c> supporta UTF-8, se
avviato con <c>screen -U</c> o se la seguente stringa è inserita in
<path>~/.screenrc</path>:
</p>

<pre caption="~/.screenrc per UTF-8">
defutf8 on
</pre>

</body>
</section>
<section>
<title>Vim, Emacs, Xemacs e Nano</title>
<body>

<p>
Vim fornisce pieno supporto UTF-8, e inoltre rileva automaticamente i file
UTF-8. Per maggiori informazioni su Vim, usa <c>:help mbyte.txt</c>.
</p>

<p>
Anche Emacs 22.x o successivo supporta pienamente UTF-8. Xemacs 22.x non
supporta ancora la combinazione dei caratteri.
</p>

<p>
Le versioni precedenti di Emacs e/o Xemacs potrebbero richiedere l'installazione
di <c>app-emacs/mule-ucs</c> e/o di <c>app-xemacs/mule-ucs</c>, e l'aggiunta del
seguente codice in <path>~/.emacs</path> affinché si possa avere il supporto per
le lingue CJK in UTF-8:
</p>

<pre caption="Supporto CJK UTF-8 in Emacs">
(require 'un-define)
(require 'jisx0213)
(set-language-environment "Japanese")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
</pre>

<p>
Attualmente Nano non fornisce supporto per UTF-8, sebbene esso sia stato
previsto da lungo tempo. Con un po' di fortuna, la situazione cambierà in
futuro. Al momento della redazione di questo documento, il supporto UTF-8 si
trova nel CVS di Nano, e dovrebbe essere incluso nella prossima release.
</p>

</body>
</section>
<section>
<title>Shells</title>
<body>

<p>
Attualmente, <c>bash</c> fornisce il pieno supporto Unicode attraverso la
libreria GNU readline. Gli utenti Z Shell sono in una posizione in qualche modo
peggiore: nessuna parte della shell ha il supporto Unicode support, sebbene il
progetto di aggiungere il supporto dei set di caratteri multibyte sia già
operativo.
</p>

<p>
La shell C, <c>tcsh</c> e <c>ksh</c> non forniscono alcun supporto UTF-8.
</p>

</body>
</section>
<section>
<title>Irssi</title>
<body>

<p>
Irssi ha un completo supporto UTF-8, ma richiede all'utente di settare
un'opzione.
</p>

<pre caption="Abilitare UTF-8 in Irssi">
/set term_type UTF-8
</pre>

<p>
Quando caratteri non ASCII sono spesso convertiti in charsets non UTF-8, il
comando <c>/recode</c> può essere utilizzato per convertire i caratteri.
Digitare <c>/help recode</c> per maggiori informazioni.
</p>

</body>
</section>
<section>
<title>Mutt</title>
<body>

<p>
Il client di posta Mutt ha un supporto Unicode molto buono. Per usare UTF-8 con
Mutt, non è necessario editare alcun file di configurazione. Mutt lavorerà in
ambiente Unicode senza modifiche, se tutti i file di configurazione (firma
compresa) sono codificati in UTF-8.
</p>

<note>
Potresti ancora vedere '?' nella posta che leggi con Mutt. Questo è il risultato
delle persone che utilizzano un client di posta che non indica il charset usato.
Su questo non puoi farci nulla, a parte chiedere a costoro di configurare
correttamente il loro client.
</note>

<p>
Maggiori informazioni sono disponibili nella <uri
link="http://wiki.mutt.org/index.cgi?MuttFaq/Charset">Mutt Wiki</uri>.
</p>

</body>
</section>
<section>
<title>Less</title>
<body>

<p>
Si usano molto <c>more</c> o <c>less</c> insieme a <c>|</c>, per essere in grado
di vedere correttamente l'output di un comando, come ad esempio <c>dmesg |
less</c>. Mentre <c>more</c> richiede solo che la shell supporti UTF-8,
<c>less</c> ha bisogno che sia impostata una variabile d'ambiente,
<c>LESSCHARSET</c>, per assicurare che i caratteri Unicode siano visualizzati
correttamente. Essa può essere impostata in <path>/etc/profile</path> o
<path>~/.bash_profile</path>. Avvia un editor a tua scelta e aggiungi la
seguente riga ad uno dei suddetti file.
</p>

<pre caption="Impostare la variabile d'ambiente per less">
LESSCHARSET=utf-8
</pre>

</body>
</section>
<section>
<title>Man</title>
<body>

<p>
Le Man pages sono parte integrante di ogni macchina Linux. Per essere sicuro che
ogni carattere Unicode nelle tue man pages sia visualizzato correttamente, edita
<path>/etc/man.conf</path> e sostituisci una riga come mostrato qui sotto.
</p>

<pre caption="Modifiche a man.conf per il supporto Unicode">
<comment>(Questa è la vecchia riga)</comment>
NROFF           /usr/bin/nroff -Tascii -c -mandoc
<comment>(Sostituisci la riga sopra con questa)</comment>
NROFF           /usr/bin/nroff -mandoc -c
</pre>

</body>
</section>
<section>
<title>elinks e links</title>
<body>

<p>
<c>Elinks</c> e <c>links</c> sono browser testuali usati comunemente, ed ora
vedremo come possiamo abilitare il supporto UTF-8 su di essi. Ci sono due modi
per fare ciò: utilizzando l'opzione Setup all'interno del browser o modificando
il file di configurazione. Per impostare l'opzione attraverso il browser, apri
un sito con <c>elinks</c> o <c>links</c>, premi <c>Alt+S</c> per entrare nel
menù Setup, seleziona le opzioni Terminal o premi <c>T</c>. Scorri verso il
basso e seleziona l'ultima opzione, <c>UTF-8 I/O</c>, premendo Invio. Infine
salva ed esci dal menù. Su <c>links</c> potresti dover premere nuovamente
<c>Alt+S</c>, premendo poi <c>S</c> per salvare. La modifica del file di
configurazione è descritta qui sotto.
</p>

<pre caption="Abilitare UTF-8 in elinks/links">
<comment>(Per elinks, editare /etc/elinks/elinks.conf o ~/.elinks/elinks.conf e
aggiungere la seguente riga)</comment>
set terminal.linux.utf_8_io = 1

<comment>(Per links, editare ~/.links/links.cfg e aggiungere la seguente
riga)</comment>
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>

</body>
</section>
<section>
<title>Testare il tutto</title>
<body>

<p>
Ci sono numerosi siti per testare UTF-8.  <c>net-www/w3m</c>,
<c>net-www/links</c>, <c>net-www/elinks</c>, <c>net-www/lynx</c> e tutti i
browser basati su Mozilla (incluso Firefox) supportano UTF-8. Anche Konqueror e
Opera hanno il pieno supporto UTF-8.
</p>

<p>
Quando utilizzi un browser testuale, assicurati sempre di essere su un terminale
compatibile con Unicode.
</p>

<p>
Se vedi alcuni caratteri visualizzati in riquadri con lettere o numeri
all'interno, significa che il tuo font non ha un carattere per il simbolo che
UTF-8 vuole. Al suo posto, visualizza un riquadro con il codice esadecimale del
simbolo UTF-8.
</p>

<ul>
  <li>
    <uri link="http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html">Pagina di
test W3C UTF-8</uri>
  </li>
  <li>
    <uri
link="http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm">Pagina di
test UTF-8 fornita dall'Università di Francoforte</uri>
  </li>
</ul>

</body>
</section>
<section>
<title>Metodi di Input</title>
<body>

<p>
Per scrivere, all'interno di X, caratteri non contenuti sulla propria tastiera,
si possono utilizzare le <e>Dead keys</e>. Esse consistono nel premere
contemporaneamente il tasto AltGr e un tasto della sezione non alfabetica alla
tastiera, a sinistra del tasto Invio. Fatto ciò, premere una lettera e la dead
key dovrebbe modificarla. L'input può essere ulteriormente modificato
utilizzando il tasto Shift insieme ad AltGr e premendo contemporaneamente la
lettera da modificare.
</p>

<p>
Per abilitare le dead keys in X, è necessario un layout che le supporti. La
maggiorparte dei layout europei hanno già dead keys con le varianti di default.
Tuttavia, questo non avviene nei layout nordamericani. Sebbene vi sia un certo
grado di incompatibilità tra i layout, la soluzione più semplice sembra essere
quella di utilizzare un layout nella forma "en_US" anziché "us", per esempio. Il
layout è impostato in <path>/etc/X11/xorg.conf</path> in questo modo:
</p>

<pre caption="Ritaglio di /etc/X11/xorg.conf">
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" <comment># Anziché solo "us"</comment>
    <comment>(Altre opzioni Xkb vanno qui)</comment>
EndSection
</pre>

<note>
La suddetta modifica deve essere applicata solo se si sta usando un layout
nordamericano, o un altro layout in cui le dead keys non sembrano funzionare.
Gli utenti europei dovrebbero avere le dead keys immediatamente funzionanti.
</note>

<p>
Questa modifica diverrà effettiva al riavvio del server X. Per applicarla
immediatamente, usa il tool <c>setxkbmap</c>, ad esempio, <c>setxkbmap
en_US</c>.
</p>

<p>
Probabilmente è più semplice descrivere le dead keys con degli esempi. Sebbene i
risultati dipendano dalla localizzazione, i concetti dovrebbero rimanere gli
stessi qualunque essa sia. Gli esempi qui sotto contengono UTF-8, quindi per
vederli devi o impostare il tuo browser affinché visualizzi la pagina come
UTF-8, oppure avere una localizzazione UTF-8 già configurata.
</p>

<p>
Premendo contemporaneamente AltGr e [, lasciandoli, e premendo poi 'a', viene
prodotta una 'ä'. Premendo contemporaneamente AltGr e [, e premendo poi 'e',
viene prodotta una 'ë'. Premendo contemporaneamente AltGr e ';' viene prodotta
una 'á', mentre premendo contemporaneamente AltGr e  ';', lasciandoli, e
premendo poi 'e', viene prodotta una 'é'.
</p>

<p>
Premendo AltGr, Shift e '[' contemporaneamente, lasciandoli, e premendo poi 'a',
viene prodotta una 'å' scandinava. Similmente, premendo AltGr, Shift e '['
contemporaneamente, lasciando <e>solo</e> la '[', e premendola poi di nuovo,
viene prodotta una '˚'. Nonostante sembri lo stesso, questo (U+02DA) non è il
simbolo di grado (U+00B0). Esso serve per altri accenti prodotti dalle dead
keys. AltGr e '[', lasciando solo la '[' e poi premendola di nuovo, producono
una '¨'.
</p>

<p>
AltGr può essere anche usato da solo con i tasti alfabetici. Ad esempio, AltGr
ed 'm' formano una lettera mu greca minuscola: 'µ'. AltGr ed 's' formano una
'ß'. Come molti europei si aspettano (perché così è scritto sulla loro
tastiera), AltGr e '4' (o 'E', dipende dal layout della tastiera) formano il
simbolo dell'Euro, '€'.
</p>

</body>
</section>
<section>
<title>Risorse</title>
<body>

<ul>
  <li>
    <uri link="http://it.wikipedia.org/wiki/Unicode">Unicode su Wikipedia</uri>
  </li>
  <li>
    <uri link="http://it.wikipedia.org/wiki/UTF-8">UTF-8 su Wikipedia</uri>
  </li>
  <li><uri link="http://www.unicode.org">Unicode.org</uri></li>
  <li><uri link="http://www.utf-8.com">UTF-8.com</uri></li>
  <li><uri link="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629</uri></li>
  <li><uri link="http://www.ietf.org/rfc/rfc2277.txt">RFC 2277</uri></li>
  <li><uri
link="http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF">Characters vs.
Bytes</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</guide>