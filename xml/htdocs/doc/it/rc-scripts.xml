<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/it/rc-scripts.xml">
<title>Gentoo Linux 1.0 Init System</title>
<author title="Autore Originale"><mail link="azarah@gentoo.org">Martin Schlemmer</mail></author>
<author title="Correttore di bozza"><mail link="seemant@gentoo.org">Seemant Kulleen</mail></author>
<author title="Traduttore"><mail link="emorelli@gentoo.it">Enrico Morelli</mail></author>
<author title="Traduttore">Team Italiano</author>

 <abstract>
 	Questa guida è una introduzione all'init system di
	Gentoo Linux e spiega in dettaglio anche come scrivere rc-scripts.
</abstract>

<version>1.0.2</version>
<date>17 Maggio 2002</date>

<chapter>
<title>Introduzione</title>
 <section>
<body>

<p>
	Gentoo Linux usa un sistma di inzializzazione (init system) che è
	controllato attraverso dipendenze. Dovrebbe essere semplice da mantenere
	oltre che abbastanza  potente e flessibile per ogni tipo
	di setup.
	Questa guida non deve essere considerata una introduzione su come
	funziona il sistema internamente, ma come una rapida guida su come
	inizializzare e far funzionare l'init system di Gentoo Linux.
	Per i curiosi interessati all'interno del sistema...leggetevi i
	sorgenti ;-)
</p>
</body>
</section>
</chapter>

<chapter>
<title>Runlevels</title>
<section>
<body>


<p>
	A differenza di altri init systems, Gentoo non ha rigidi nomi 
	o numeri per definire i runlevels, ma piuttosto nomi comuni mappati
	nello standard runlevel di init.
	<note>
		Per default ci sono tre runlevels, chiamati <e>&quot;boot&quot;</e>,
		<e>&quot;default&quot;</e>
		e <e>&quot;nonetwork&quot;</e>.
	</note>
</p>

<p>
	Il runlevel &quot;boot&quot; dovrebbe essere lo standard per 
	molti setup e come denota il nome, è il primo runlevel ad 
	essere eseguito dopo il boot time. Quindi c'è
	il <e>&quot;default&quot;</e>  che, come indica il nome, è
	il principale runlevel ad essere eseguito dopo il boot.
	L'ultimo è <e>&quot;nonetwork&quot;</e> che serve puramente
	come esempio.
</p>

<p>
	I runlevels sono locati in <path>/etc/runlevels</path>, in 
	sottodirectory chiamate con i nomi dei runlevel dentro
	le quali si trovano dei link ai servizi che sono propri del
	runlevel corrispondente.
	<note>
		Il modo migliore per aggiungere o rimuovere servizi
		sarà discusso nella sezione &quot;Parliamo di 
		rc-update&quot;.
	</note>
</p>

<p>
	Come abbiamo già detto, il nome avrebbe potuto essere cambiato a seconda
	delle necessità dell'utente, e come regola dovrebbe essere cambiato
	anche il file <path>/etc/inittab</path> per riflettere il nuovo
	nome del runlevel di default.
	<impo>Un eccezione alla regola dovrebbe comunque essere annotata riguarda
	 il runlevel <e>&quot;boot&quot;</e> 
    </impo>

	<warn>
		NON cambiare il nome del runlevel  <e>&quot;boot&quot;</e> 
		perché potrebbe non funzionare più niente.
	</warn>
</p>

<p>
	Lo script <path>/sbin/rc</path> fa tutto il lavoro e può
	essere eseguito per cambiare il runlevel al volo.
</p>
</body>
</section>

<section>
<title>Runlevel virtuali</title>
<body>

<p>
	Dato che i runlevel non sono staticamente mappati a quelli di init,
	ci possono essere più livelli rispetto a quelli 
	supportati da init. Questo permette all'utente di creare
	profili o runlevel virtuali a seconda del bisogno.
</p>
<p>
	Per esempio, su un lapotop possiamo avere due runlevel
	di default, chiamati &quot;online&quot; e &quot;offline&quot;.
	Questo ci permetterebbe di avere un runlevel quando la scheda
	di rete PCMCIA è attiva ed uno quando non lo è.
	Lo scripts PCMCIA potrebbe essere configurato in modo da chiamare
	<c>&quot;/sbin/rc online&quot;</c> o 
	<c>&quot;/sbin/rc offline&quot;</c> in modo da far partire o
	fermare i corretti servizi a seconda dello stato della scheda
	di rete PCMCIA.
</p>

</body>
</section>

<section>
<title>Runlevel e XFree86</title>
<body>

<p>
	In Gentoo non abbiamo un runlevel dedicato a X, ma piuttosto
	uno script di startup il quale è chiamato &quot;xdm&quot;
	e può essere aggiunto a qualsiasi runlevel che vogliamo.

	<note>
		In effetti dovrebbe essere messo nel runlevel
		principale che vuoi.
	</note>

	<warn>
		Aggiungendolo al runlevel di boot i risultati
		possono essere imprevedibili.
	</warn>
</p>
<p>
	Di default se avete fatto partire xdm, gdm o kdm dopo la 
	partenza delle gettys, X probabilmente partirà
	nella prossima console disponibile. Su macchine lente non
	è un problema se il Desktop Manager parte verso la fine
	dei processi iniziali del runlevel.
	Le getty partiranno prima di X che partirà nella console 7
	come dovrebbe.
	Su macchine veloci comunque questo non è così. X parte 
	prima delle getty e quindi nella console 2, Quando getty parte 
	prende il controllo della tastiera e il Desktop Manager perde il 
	supporto della tastiera.
</p>

<p>
	Questo viene risolto avendo lo script di startup del Desktop
	Manager in un'extra init runlevel chiamato runlevel 'a'.
	Quest'ultimo non è un runlevel reale, il nostro script
	&quot;xdm&quot; richiamerà <c>&quot;telinit a&quot;</c>
	che rischedulerà tutti i servizi in runlevel 'a' perché
	siano eseguiti dopo il runlevel corrente, dopo cioè che getty
	è partito.

	<note>
		Maggiori informazioni cira il runlevel 'a'
		possono essere acquisite leggendo le man pages
		di init.
	</note>
</p>
</body>
</section>
</chapter>

<chapter>
<title>RC-Scripts</title>
<section>
<body>

<p>
	Gli RC-Scripts sono scripts che definiscono le funzioni
	di base per ogni servizio così come le sue dipendenze,
	per la partenza. La directory di riferimento è
	<path>/etc/init.d/</path>.
</p>
</body>
</section>

<section>
<title>Come si presenta un rc-script di base</title>
   
<body>
<pre caption="rc-script layout">
#!/sbin/runscript
 
depend() {
    need bar
}
 
start() {
    ebegin &quot;Starting foo&quot;
    /sbin/foo
    eend $? &quot;Failed to start foo&quot;
}
 
stop() {
    ebegin &quot;Stopping foo&quot;
    kill $(cat /var/run/foo.pid)
    eend $? &quot;Failed to stop foo&quot;
}
</pre>

<p>
	<note>
		L'interprete è &quot;/sbin/runscript&quot;.
	</note>
	<note>
		La funzione &quot;depend&quot; è opzionale.
	</note>
	<note>
		Ogni rc-script ha bisogno almeno della funzione
		&quot;start&quot;.
	</note>
</p>
</body>
</section>

<section>
<title>Controllare lo start-up</title>
<body>

<p>
	In genere l'ordine di start-up dei servizi è alfabetico.
	Questo è causato dall'output generato da <path>/bin/ls</path>.
</p>

<p>
	Il metodo primario per deviare dalla sequanza di start-up di default,
	sono le dipendenze.
	Alternativamente se non c'è relazione tra i servizi, può
	essere usata la sequenza tipo.
</p>
	
</body>
</section>
</chapter>

<chapter>
<title>Tipi di Dipendenze</title>
<section>
<body>

<p>
	Molti servizi hanno relazione o sono dipendenti da altri.
</p>

<p>
	Postfix, per esempio, ha bisogno che la rete sia funzionante,
	così come il sistema di log.
</p>

<p>
	Samba ha bisogno di una rete funzionante. Se CUPS viene 
	usato per stampare, cupsd dovrebbe partire prima di samba.
	Nota comunque che cups non è strettamente necessario a samba.
</p>

<p>
	Abbiamo così due modi per esprimere le dipendenze che 
	relazionano differenti servizi.
	Queste dipendenze sono sempre valide, sia che il runlevel sia
	cambiato per intero, sia che il servizio sia fatto partire o sia 
	fermato manualmente dopo il boot.
</p>
</body>
</section>

<section>
<title>La dipendenza di tipo  NEED</title>
<body>

<p>
	La dipendenza di tipo NEED è usata se un servizio è
	indispensabile per la corretta partenza del corrente servizio.
</p>

<pre caption="aggiungiamo logger e net come dipendenze di tipo NEED">
depend() {
    need net logger
}
</pre>

<p>
	<note>
		I servizi menzionati dopo <e>NEED</e> sono critici per
		la partenza del corrente servizio. 
		Il corrente servizio fallirà se una
		delle dipendenze non parte.
	</note>
	<impo>
		Ogni servizio nella linea <e>NEED</e> sarà fatto
		partire anche se NON è incluso nel corrente runlevel o
		in quello di <e>&quot;boot&quot;</e>.
	</impo>

	<e>NEED</e> crea così una dipendenza molto &quot;forte&quot;. 
</p>

</body>
</section>

<section>
<title>La dipendenza di tipo USE</title>
<body>


<p>
	La dipendenza di tipo USE è usata per quei
	servizi che non sono critici per la partenza del servizio corrente, 
	ma che dovrebbero partire prima di tale servizio se è usato.
</p>
<pre caption="aggiungiamo portmap come dipendenza di tipo USE a netmount">
depend() {
    use portmap
}
</pre>
<p>
	Netmount può usare mount di tipo NFS, ma questo dipende
	se il portmap è aggiunto al runlevel corrente o di boot.
    Ogni utente con mount NFS dovrebbe per default aggiungere
    portmap al runlevel di default, in modo tale che netmount veda
    portmap come una dipendenza USE e lo faccia partire prima di se stesso.
</p>
	
<p>
	<impo>
	Ogni servizio nella linea <e>USE</e> <e>*deve*</e> essere aggiunto al
	runlevel corrente o a quello di boot per essere considerato
	una dipendenza valida <e>USE</e>.
	</impo>

	<e>USE</e> è così una dipendenza &quot;debole&quot;.

</p>


<p>
	<note>
		Se ogni servizio in una linea <e>USE</e> non parte, il servizio
		corrente partirà lo stesso, come se i servizi nella linea
		<e>USE</e> non fossero critici per lo startup del corrente servizio. 
	</note>
	
</p>

</body>
</section>
</chapter>

<chapter>
<title>Controllare la sequenza di avvio senza dipendenze</title>
<section>
<body>

<p>
	Se non esistono relazioni di dipendenza tra due servizi,
	ma è necessario o si desidera far partire esplicitamente
	un servizio dopo un altro, possono essere usate le relazioni
	<e>AFTER</e> e <e>BEFORE</e>.
	<note>
		Questi due tipi sono validi solo durante un cambio 
		di runlevel.
	</note>
</p>

<p>
	Opzionalmente questi due supportano il carattere &quot;*&quot; per
	includere altri servizi:
</p>

<pre caption="un esempio di AFTER col carattere *">
depend() {
    after *
}
</pre>

<p>
	Questo causerà la partenza del servizio corrente <e>*dopo*</e>
	tutti gli altri servizi.
</p>
</body>
</section>

<section>
<title>La relazione di tipo BEFORE</title>
<body>

<p>
	Il servizio corrente partirà <e>*prima*</e> di tutti quelli elencati
	nella linea <e>BEFORE</e>.
</p>

<pre caption="il corrente servizio parte prima di bar">
depend() {
   before bar
}
</pre>

</body>
</section>

<section>
<title>La relazione di tipo AFTER</title>
<body>

<p>
	Il corrente servizio parte <e>*dopo*</e> tutti quelli 
	elencati nella linea <e>AFTER</e>.
</p>
<pre caption="il corrente servizio parte dopo foo">
depend() {
    after foo
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Servizi virtuali</title>
<section>
<body>

<p>	
	I servizi, come molte cose nell'odierno mondo unix, arrivano in
	molti gusti e colori. 
	Di solito è la scelta dell'utente/amministratore a determinare
	quelli che saranno usati.
</p>

<p>
	I sistemi di log ne sono un esempio. Al momento della scrittura di 
	questo manuale, Gentoo Linux permette di scegliere fra quattro
	differenti sistemi di log.
	Tutti i servizi che necessitano che un sistema di log sia in uso prima
	di partire, non possono aver bisogno di tutti e quattro,
	attraverso l'uso di <e>NEED</e>. D'altra parte includerli in
	<e>USE</e> è controindicato data la dipendenza &quot;debole&quot;.
</p>
<p>
	E' qui dove  i servizi virtuali e la dipendenza <e>PROVIDE</e>
	entrano in gioco.
</p>
</body>
</section>

<section>
<title>La relazione di tipo PROVIDE</title>
<body>

<p>
	La relazione di tipo <e>PROVIDE</e> definisce servizi virtuali di cui altri
	servizi necessitano. (Servizi che possono essere in relazioni di tipo <e>NEED</e>
	o <e>USE</e>).
</p>
<pre caption="sysklogd provvede servizi di logger">
depend() {
    provide logger
}
</pre>

</body>
</section>

<section>
<title>Il virtual service LOGGER</title>
<body>

<p>
	<e>LOGGER</e> è un servizio virtuale predefinito che è
	fornito da tutti i sistemi di log e può essere usato
	sia con relazioni di tipo <e>NEED</e> che con quelle di tipo <e>USE</e>.
</p>
</body>
</section>

<section>
<title>Il virtual service NET</title>
<body>


<p>
	Il servizio <e>NET</e> è un altro servizio virutale, ma a differenza
	di <e>LOGGER</e>, non provvede (<e>PROVIDE</e>) esplicitamente un servizio.
</p>

<p>
	<impo>
	Per fornire un servizio virtuale <e>NET</e>, un servizio deve:
	<ul>
	<li>essere aggiunto al runlevel corrente o di boot.</li>
	<li>avere un &quot;net.&quot; seguito dall'attuale
	interfaccia di rete (per esempio net.eth0 o net.ppp1).</li>
	</ul>
	</impo>
</p>
<p>
	Per ogni servizio valido net.*, $IFACE sarà settata col nome dell'interfaccia
	di rete. (&quot;eth0&quot; per net.eth0).
</p>
</body>
</section>
</chapter>

<chapter>
<title>Opzioni di default per la linea di comando</title>
<section>
<body>

<p>
	Ogni servizio può essere chiamato con ogni opzione di default.
	Tutte quelle menzionate sono già predefinite, eccetto che per
	<e>START</e> e <e>STOP</e> che l'utente dovrebbe definire
	come funzioni del proprio rc-script.
	<impo>
		La funzione <e>start()</e> <e>deve</e> essere definita.</impo>
	<note>
		La funzione <e>stop()</e> è meno importante e può
		essere omessa.</note>
</p>
<p>
	<note>In generale, l'utente dovrà solo definire <e>start()</e>,
	<e>stop()</e> e <e>restart()</e>. Il resto è interno e dovrebbe
	essere lasciato invariato.</note>
</p>
<pre caption="far partire il servizio httpd">
# <c>/etc/init.d/httpd start</c>
</pre>

<p>
	<note>Le opzioni sulla linea di comando possono anche essere 
	scritte una dopo l'altra.
	</note>
</p>
<pre caption="pause/start net.eth0">
# <c>/etc/init.d/net.eth0 pause start</c>
</pre>

</body>
</section>

<section>
<title>Le opzioni START/STOP</title>
<body>


<p>
	<e>START</e> fa partire il servizio e quelli dai quali dipende.
</p>

<p>	
	<e>STOP</e> ferma il servizio incluso ogni servizio che dipende da lui.
</p>
</body>
</section>

<section>
<title>L'opzione RESTART</title>
<body>

<p>
	Il servizio deve essere già; attivo perché <e>RESTART</e> funzioni.
	<e>RESTART</e> farà ripartire il servizio e quelli che dipendono da lui.

	<impo>Se è definita una funzione <e>restart()</e>, l'utente 
	dovrebbe usare <e>&quot;svc_start()&quot;</e> e <e>&quot;svc_stop()&quot;</e>
	per far partire e fermare il servizio.</impo>

	<note>Questo è fatto per maneggiare correttamente tutti i servizi 
	dipendenti. </note>
</p>

</body>
</section>

<section>
<title>L'opzione PAUSE</title>
<body>


<p>
	Questa opzione fermerà il servizio, ma a differenza di <e>STOP</e>,
	non verrà fermato nessun servizio dipendente.
</p>
</body>
</section>

<section>
<title>L'opzione ZAP</title>
<body>

<p>
	Resetta lo stato del servizio che deve essere fermato.
	<note>Nota che nessuno dei comandi nella funzione <e>stop()</e>
	sarà eseguito. L'utente dovrebbe così fare ogni
	pulizia necessaria.
	</note>
</p>
</body>
</section>

<section>
<title>Le opzioni INEED/NEEDSME</title>
<body>

<p>
	<e>INEED</e> lista i servizi <e>NEED</e> per il corrente servizio.
</p>

<p>
	<e>NEEDSME</e> lista i servizi per i quali questo servizio è
	<e>NEED</e>.
</p>
</body>
</section>

<section>
<title>Le opzioni IUSE/USESME</title>
<body>

<p>
	<e>IUSE</e> lista i servizi <e>USE</e> per il corrente servizio.
</p>


<p>
	<e>USESME</e> lista i servizi che usano (<e>USE</e>) questo servizio.
</p>
</body>
</section>

<section>
<title>L'opzione BROKEN</title>
<body>

<p>
	<e>BROKEN</e> lista i servizi omessi (se ce ne sono) dei quali il
	corrente servizio ha bisogno (<e>NEED</e>).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Aggiungere nuove opzioni per la linea di comando</title>
<section>
<body>

<p>
	E' relativamente facile aggiungere nuove opzioni per la linea di comando.
	Una funzione con una opzione ha bisogno di essere definita nell' rc-script e 
	aggiunta alla variabile <e>$opts</e>, come mostrato sotto:
</p>

<pre caption="foo come una nuova opzione">
opts=&quot;${opts} foo&quot;
 
foo() {
    ............
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione</title>
<section>
<body>

<p>
	Le configurazioni dovrebbero generalmente essere sempre fatte via variabili 
	ambiente. Queste, comunque, non dovrebbero essere definite nell' rc-script,
	ma in uno dei tre possibili files di configurazione.
</p>
<p>
	Uno che è specifico per gli rc-scripts, gli altri due sono files
	di configurazione globali:
</p>
<pre caption="files di configurazione per gli rc-scripts">
<path>/etc/conf.d/&lt;nome dell' rc-script&gt;</path>
<path>/etc/conf.d/basic</path>
<path>/etc/rc.conf</path>
</pre>

<p>
	<note>
		Questi tre files di configurazione vengono letti automaticamente
		nell'ordine che abbiamo dato.
	</note>
	<impo>
		Tutti i servizi <e>NET</e> hanno il
		loro punto di partenza in <path>/etc/conf.d/net</path>
	</impo>
</p>
</body>
</section>
</chapter>

<chapter>
<title>Scripts utilities</title>

<section>
<title>L'utility rc-update</title>
<body>

<p>
	rc-update è il tool primario per aggiungere e rimuovere 
	servizi in e da un runlevel.
	rc-update chiamerà; &quot;depscan.sh&quot; per aggiornare
	la cache delle dipendenze.
</p>
<pre caption="aggiungere metalog al runlevel di default">
# <c>rc-update add metalog default</c>
</pre>

<pre caption="rimuovere metalog dal runlevel di default">
# <c>rc-update del metalog default</c>
</pre>

<p>
<note>
	Eseguendo il comando rc-update senza argomenti
	dovrebbe darvi maggiori informazioni.
</note>
</p>

</body>
</section>

<section>
<title>Lo script depscan.sh</title>
<body>

<p>
	Per completezza, depscan.sh è menzionato qui. E' usato per
	creare una cache di dipendenze che basilarmente è una mappa
	delle dipendenze tra i servizi.
</p>

<p>
	Dovrebbe essere eseguito ogni volta che un nuovo rc-script è
	aggiunto a <path>/etc/init.d</path>, ma dato che viene automaticamente
	eseguito da rc-update, non è necessario eseguirlo nuovamente.
</p>
</body>
</section>
</chapter>
</guide>

