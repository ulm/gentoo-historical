<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/rc-scripts.xml">
<title>Gentoo Linux 1.0 Init System</title>
<author title="Autore"><mail link="azarah@gentoo.org">Martin Schlemmer</mail></author>
<author title="Revisione"><mail link="seemant@gentoo.org">Seemant Kulleen</mail></author>
<author title="Traduzione"><mail link="emorelli@gentoo.it">Enrico Morelli</mail></author>

 <abstract>
 	Questa guida è una introduzione all'init system di
	Gentoo Linux e spiega in dettaglio come scrivere rc-script.
</abstract>

<version>1.0.3</version>
<date>5 Dicembre 2003</date>

<chapter>
<title>Introduzione</title>
 <section>
<body>

<p>
	Gentoo Linux usa un sistema di inizializzazione (init system) che è
	controllato attraverso dipendenze. Dovrebbe essere semplice da mantenere
	oltre che abbastanza  potente e flessibile per ogni tipo
	di setup.
	Questa guida non deve essere considerata una introduzione su come
	funziona il sistema internamente, ma come una rapida guida su come
        I più curiosi sono invitati a leggersi i sorgenti.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Runlevel</title>
<section>
<body>


<p>
	A differenza di altri init system, Gentoo non ha rigidi nomi 
	o numeri per definire i runlevel, ma piuttosto nomi comuni mappati
	nello standard runlevel di init.
	<note>
		Per default ci sono tre runlevel, chiamati <e>&quot;boot&quot;</e>,
		<e>&quot;default&quot;</e>
		e <e>&quot;nonetwork&quot;</e>.
	</note>
</p>

<p>
	Il runlevel &quot;boot&quot; dovrebbe essere lo standard per 
	molti setup e, come denota il nome, è il primo runlevel ad 
	essere eseguito dopo il boot time. Quindi c'è
	il <e>&quot;default&quot;</e>  che, come indica il nome, è
	il principale runlevel ad essere eseguito dopo il boot.
	L'ultimo è <e>&quot;nonetwork&quot;</e> che serve puramente
	come esempio.
</p>

<p>
	I runlevel sono collocati in <path>/etc/runlevels</path>, in 
	sottodirectory chiamate con i nomi dei runlevel dentro
	le quali si trovano dei link ai servizi che sono propri del
	runlevel corrispondente.
	<note>
		Il modo migliore per aggiungere o rimuovere servizi
		sarà discusso nella sezione &quot;L'utilità
		rc-update&quot;.
	</note>
</p>

<p>
	Come abbiamo già detto, il nome avrebbe potuto essere cambiato a seconda
	delle necessità dell'utente, e come regola dovrebbe essere cambiato
	anche il file <path>/etc/inittab</path> per riflettere il nuovo
	nome del runlevel di default.
	<impo>Un eccezione alla regola riguarda  il runlevel <e>&quot;boot&quot;</e> 
    </impo>

	<warn>
		NON cambiate il nome del runlevel  <e>&quot;boot&quot;</e> 
		perché potrebbe non funzionare più niente.
	</warn>
</p>

<p>
        Tutto il lavoro è svolto dallo script <path>/sbin/rc</path>
        che può anche essere usato per cambiare il runlevel al volo.
</p>
</body>
</section>

<section>
<title>Runlevel virtuali</title>
<body>

<p>
	Dato che i runlevel non sono staticamente mappati a quelli di init,
	ci possono essere più livelli rispetto a quelli 
	supportati da init. Questo permette all'utente di creare
	profili o runlevel virtuali a seconda del bisogno.
</p>
<p>
	Per esempio, su un lapotop possiamo avere due runlevel
	di default, chiamati &quot;online&quot; e &quot;offline&quot;.
	Questo ci permetterebbe di avere un runlevel quando la scheda
	di rete PCMCIA è attiva ed uno quando non lo è.
	Lo scripts PCMCIA potrebbe essere configurato in modo da chiamare
	<c>&quot;/sbin/rc online&quot;</c> o 
	<c>&quot;/sbin/rc offline&quot;</c> in modo da far partire o
	fermare i corretti servizi a seconda dello stato della scheda
	di rete PCMCIA.
</p>

</body>
</section>

<section>
<title>Runlevel e XFree86</title>
<body>

<p>
	In Gentoo non abbiamo un runlevel dedicato a X, ma piuttosto
	uno script di startup il quale è chiamato &quot;xdm&quot;
	e può essere aggiunto a qualsiasi runlevel che vogliamo.

	<note>
		In effetti dovrebbe essere messo nel runlevel
		principale che desiderate.
	</note>

	<warn>
		Aggiungendolo al runlevel di boot i risultati
		possono essere imprevedibili.
	</warn>
</p>
<p>
	Di default se avete fatto partire xdm, gdm o kdm dopo la 
	partenza delle getty, X probabilmente partirà
	nella prossima console disponibile. Su macchine lente non
	è un problema se il Desktop Manager parte verso la fine
	dei processi iniziali del runlevel.
	Le getty partiranno prima di X che partirà nella console 7
	come dovrebbe.
	Su macchine veloci comunque questo non è così. X parte 
	prima delle getty e quindi nella console 2, Quando getty parte 
	prende il controllo della tastiera e il Desktop Manager perde il 
	supporto della tastiera.
</p>

<p>
        Per ovviare a questo problema lo script di startup del Desktop
	Manager viene posto in un'extra init runlevel chiamato runlevel 'a'.
	Quest'ultimo non è un runlevel reale, il nostro script
	&quot;xdm&quot; richiamerà <c>&quot;telinit a&quot;</c>
	che rischedulerà tutti i servizi in runlevel 'a' perché
	siano eseguiti dopo il runlevel corrente, dopo cioè che getty
	è partito.

	<note>
		Maggiori informazioni circa il runlevel 'a'
		possono essere acquisite leggendo le man pages
		di init.
	</note>
</p>
</body>
</section>
</chapter>

<chapter>
<title>rc-script</title>
<section>
<body>

<p>
	Gli rc-script sono script che definiscono le funzioni
	di base per ogni servizio, così come le sue dipendenze,
	per la partenza. La directory di riferimento è
	<path>/etc/init.d/</path>.
</p>
</body>
</section>

<section>
<title>Come si presenta un rc-script di base</title>
   
<body>
<pre caption="rc-script layout">
#!/sbin/runscript
 
depend() {
    need bar
}
 
start() {
    ebegin &quot;Starting foo&quot;
    /sbin/foo
    eend $? &quot;Failed to start foo&quot;
}
 
stop() {
    ebegin &quot;Stopping foo&quot;
    kill $(cat /var/run/foo.pid)
    eend $? &quot;Failed to stop foo&quot;
}
</pre>

<p>
	<note>
		L'interprete è &quot;/sbin/runscript&quot;.
	</note>
	<note>
		La funzione &quot;depend&quot; è opzionale.
	</note>
	<note>
		Ogni rc-script ha bisogno almeno della funzione
		&quot;start&quot;.
	</note>
</p>
</body>
</section>

<section>
<title>Controllare l'avvio dei servizi</title>
<body>

<p>
	In genere l'ordine di avvio dei servizi è alfabetico.
	Questo è causato dall'output generato da <path>/bin/ls</path>.
</p>

<p>
	Il metodo primario per deviare dalla sequenza di avvio di default,
	sono le dipendenze.
	Alternativamente se non c'è relazione tra i servizi, può
	essere usata la sequenza tipo.
</p>
	
</body>
</section>
</chapter>

<chapter>
<title>Tipi di dipendenze</title>
<section>
<body>

<p>
	Molti servizi hanno relazione o sono dipendenti da altri.
</p>

<p>
	Postfix, per esempio, ha bisogno che la rete sia funzionante,
	così come il sistema di log.
</p>

<p>
	Samba ha bisogno di una rete funzionante. Se CUPS viene 
	usato per stampare, cupsd dovrebbe partire prima di samba.
	Cups non è comunque strettamente necessario a samba.
</p>

<p>
	Abbiamo così due modi per esprimere le dipendenze che 
	relazionano differenti servizi.
	Queste dipendenze sono sempre valide, sia che il runlevel sia
	cambiato per intero, sia che il servizio sia fatto partire o sia 
	fermato manualmente dopo l'avvio della macchina.
</p>
<p>
        Quando initscript multipli forniscono una certa virtualità (
        come se avessimo script <path>net.eth*</path>
        multipli che provvedono tutti la dipendenza "net"), solo
        uno di loro sarà usato per fornire tale dipendenza.
        Così se abbiamo uno script che necessita della dipendenza net 
        (<e>need net</e>), 
        userà uno solo degli script <path>net.eth*</path> disponibile e
        non tutti.
</p>
</body>
</section>

<section>
<title>La dipendenza di tipo  NEED</title>
<body>

<p>
	La dipendenza di tipo NEED è usata se un servizio è
	indispensabile per la corretta partenza del servizio corrente.
</p>

<pre caption="aggiungiamo logger e net come dipendenze di tipo NEED">
depend() {
    need net logger
}
</pre>

<p>
	<note>
		I servizi menzionati dopo <e>NEED</e> sono critici per
		la partenza del servizio corrente la cui partenza
                fallirà se una delle dipendenze non parte.
	</note>
	<impo>
		Ogni servizio nella linea <e>NEED</e> sarà fatto
		partire anche se NON è incluso nel corrente runlevel o
		in quello di <e>&quot;boot&quot;</e>.
	</impo>

	<e>NEED</e> crea così una dipendenza molto &quot;forte&quot;. 
</p>

</body>
</section>

<section>
<title>La dipendenza di tipo USE</title>
<body>


<p>
	La dipendenza di tipo USE è usata per quei
	servizi che non sono critici per la partenza del servizio corrente, 
	ma che dovrebbero partire prima di tale servizio se è usato.
</p>
<pre caption="aggiungiamo portmap come dipendenza di tipo USE a netmount">
depend() {
    use portmap
}
</pre>
<p>
	Netmount può usare mount di tipo NFS, ma questo dipende
	se il portmap è aggiunto al runlevel corrente o di boot.
    Ogni utente con mount NFS dovrebbe per default aggiungere
    portmap al runlevel di default, in modo tale che netmount veda
    portmap come una dipendenza USE e lo faccia partire prima di se stesso.
</p>
	
<p>
	<impo>
	Ogni servizio nella linea <e>USE</e> <e>*deve*</e> essere aggiunto al
	runlevel corrente o a quello di boot per essere considerato
	una dipendenza valida <e>USE</e>.
	</impo>

	<e>USE</e> è così una dipendenza &quot;debole&quot;.

</p>


<p>
	<note>
		Se ogni servizio in una linea <e>USE</e> non parte, il servizio
		corrente partirà lo stesso, come se i servizi nella linea
		<e>USE</e> non fossero critici per l'avvio del servizio corrente. 
	</note>
	
</p>

</body>
</section>
</chapter>

<chapter>
<title>Controllare la sequenza di avvio senza dipendenze</title>
<section>
<body>

<p>
	Se non esistono relazioni di dipendenza tra due servizi,
	ma è necessario o si desidera far partire esplicitamente
	un servizio dopo un altro, possono essere usate le relazioni
	<e>AFTER</e> e <e>BEFORE</e>.
	<note>
		Questi due tipi sono validi solo durante un cambio 
		di runlevel.
	</note>
</p>

<p>
	Opzionalmente è supportato il carattere &quot;*&quot; per
	includere altri servizi:
</p>

<pre caption="un esempio di AFTER col carattere *">
depend() {
    after *
}
</pre>

<p>
	Questo causerà la partenza del servizio corrente <e>*dopo*</e>
	tutti gli altri servizi.
</p>
</body>
</section>

<section>
<title>La relazione di tipo BEFORE</title>
<body>

<p>
	Il servizio corrente partirà <e>*prima*</e> di tutti quelli elencati
	nella linea <e>BEFORE</e>.
</p>

<pre caption="il corrente servizio parte prima di bar">
depend() {
   before bar
}
</pre>

</body>
</section>

<section>
<title>La relazione di tipo AFTER</title>
<body>

<p>
	Il servizio corrente parte <e>*dopo*</e> tutti quelli 
	elencati nella linea <e>AFTER</e>.
</p>
<pre caption="il corrente servizio parte dopo foo">
depend() {
    after foo
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Servizi virtuali</title>
<section>
<body>

<p>	
	I servizi, come molte cose nell'odierno mondo unix, sono di molti tipi e generi.
	Di solito è la scelta dell'utente/amministratore a determinare
	quelli che saranno usati.
</p>

<p>
	I sistemi di log ne sono un esempio. Al momento della scrittura di 
	questo manuale, Gentoo Linux permette di scegliere fra quattro
	differenti sistemi di log.
	Tutti i servizi che necessitano che un sistema di log sia in uso prima
	di partire, non possono aver bisogno di tutti e quattro,
	attraverso l'uso di <e>NEED</e>. D'altra parte includerli in
	<e>USE</e> è controindicato data la dipendenza &quot;debole&quot;.
</p>
<p>
	E' qui dove  i servizi virtuali e la dipendenza <e>PROVIDE</e>
	entrano in gioco.
</p>
</body>
</section>

<section>
<title>La relazione di tipo PROVIDE</title>
<body>

<p>
	La relazione di tipo <e>PROVIDE</e> definisce servizi virtuali di cui altri
	servizi necessitano. (Servizi che possono essere in relazioni di tipo <e>NEED</e>
	o <e>USE</e>).
</p>
<pre caption="sysklogd provvede servizi di log">
depend() {
    provide logger
}
</pre>

</body>
</section>

<section>
<title>Il servizio virtuale LOGGER</title>
<body>

<p>
	<e>LOGGER</e> è un servizio virtuale predefinito che è
	fornito da tutti i sistemi di log e può essere usato
	sia con relazioni di tipo <e>NEED</e> che con quelle di tipo <e>USE</e>.
</p>
</body>
</section>

<section>
<title>Il servizio virtuale NET</title>
<body>


<p>
	Il servizio <e>NET</e> è un altro servizio virutale, ma a differenza
	di <e>LOGGER</e>, non provvede (<e>PROVIDE</e>) esplicitamente un servizio.
</p>

<p>
	<impo>
	Per fornire un servizio virtuale <e>NET</e>, un servizio deve:
	<ul>
	<li>essere aggiunto al runlevel corrente o di boot.</li>
	<li>avere un &quot;net.&quot; seguito dall'attuale
	interfaccia di rete (per esempio net.eth0 o net.ppp1).</li>
	</ul>
	</impo>
</p>
<p>
	Per ogni servizio valido net.*, $IFACE sarà impostata col nome dell'interfaccia
	di rete. (&quot;eth0&quot; per net.eth0).
</p>
</body>
</section>
</chapter>

<chapter>
<title>Opzioni predefinite per la linea di comando</title>
<section>
<body>

<p>
	Ogni servizio può essere chiamato con le opzioni predefinite.
	Tutte quelle menzionate sono già predefinite, eccetto che per
	<e>START</e> e <e>STOP</e> che l'utente dovrebbe definire
	come funzioni del proprio rc-script.
	<impo>
		La funzione <e>start()</e> <e>deve</e> essere definita.</impo>
	<note>
		La funzione <e>stop()</e> è meno importante e può
		essere omessa.</note>
</p>
<p>
	<note>In generale, l'utente dovrà solo definire <e>start()</e>,
	<e>stop()</e> e <e>restart()</e>. Il resto è interno e dovrebbe
	essere lasciato invariato.</note>
</p>
<pre caption="far partire il servizio httpd">
# <c>/etc/init.d/httpd start</c>
</pre>

<p>
	<note>Le opzioni sulla linea di comando possono anche essere 
	scritte una dopo l'altra.
	</note>
</p>
<pre caption="pause/start net.eth0">
# <c>/etc/init.d/net.eth0 pause start</c>
</pre>

</body>
</section>

<section>
<title>Le opzioni START/STOP</title>
<body>


<p>
	<e>START</e> fa partire il servizio e quelli dai quali dipende.
</p>

<p>	
	<e>STOP</e> ferma il servizio incluso ogni servizio che dipende da lui.
</p>
</body>
</section>

<section>
<title>L'opzione RESTART</title>
<body>

<p>
	Il servizio deve essere già attivo perché <e>RESTART</e> funzioni.
	<e>RESTART</e> farà ripartire il servizio e quelli che dipendono da lui.

	<impo>Se è definita una funzione <e>restart()</e>, l'utente 
	dovrebbe usare <e>&quot;svc_start()&quot;</e> e <e>&quot;svc_stop()&quot;</e>
	per far partire e fermare il servizio.</impo>

	<note>Questo per gestire correttamente tutti i servizi 
	dipendenti. </note>
</p>

</body>
</section>

<section>
<title>L'opzione PAUSE</title>
<body>


<p>
	Questa opzione fermerà il servizio, ma a differenza di <e>STOP</e>,
	non verrà fermato nessun servizio dipendente.
</p>
</body>
</section>

<section>
<title>L'opzione ZAP</title>
<body>

<p>
	Inizializza lo stato del servizio che deve essere fermato.
	<note>Notate che nessuno dei comandi nella funzione <e>stop()</e>
	sarà eseguito. L'utente dovrebbe fare ogni azione necessaria.
	</note>
</p>
</body>
</section>

<section>
<title>Le opzioni INEED/NEEDSME</title>
<body>

<p>
	<e>INEED</e> lista i servizi <e>NEED</e> per il corrente servizio.
</p>

<p>
	<e>NEEDSME</e> lista i servizi per i quali questo servizio è
	necessario (<e>NEED</e>).
</p>
</body>
</section>

<section>
<title>Le opzioni IUSE/USESME</title>
<body>

<p>
	<e>IUSE</e> lista i servizi <e>USE</e> per il corrente servizio.
</p>


<p>
	<e>USESME</e> lista i servizi che usano (<e>USE</e>) questo servizio.
</p>
</body>
</section>

<section>
<title>L'opzione BROKEN</title>
<body>

<p>
	<e>BROKEN</e> lista i servizi omessi (se ce ne sono) dei quali il
	corrente servizio ha bisogno (<e>NEED</e>).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Aggiungere nuove opzioni per la linea di comando</title>
<section>
<body>

<p>
	E' relativamente facile aggiungere nuove opzioni per la linea di comando.
	Una funzione con una opzione ha bisogno di essere definita nell' rc-script e 
	aggiunta alla variabile <e>$opts</e>, come mostrato di eguito:
</p>

<pre caption="foo come una nuova opzione">
opts=&quot;${opts} foo&quot;
 
foo() {
    ............
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione</title>
<section>
<body>

<p>
	Le configurazioni dovrebbero generalmente essere sempre definite attraverso variabili 
	ambiente. Queste, comunque, non dovrebbero essere definite nell' rc-script,
	ma in uno dei tre possibili file di configurazione.
</p>
<p>
	Uno è specifico per gli rc-script, gli altri due sono file
	di configurazione globali:
</p>
<pre caption="file di configurazione per gli rc-script">
<path>/etc/conf.d/&lt;nome dell' rc-script&gt;</path>
<path>/etc/conf.d/basic</path>
<path>/etc/rc.conf</path>
</pre>

<p>
	<note>
		Questi tre file di configurazione vengono letti automaticamente
		nell'ordine che abbiamo dato.
	</note>
	<impo>
		Tutti i servizi <e>NET</e> hanno il
		loro punto di partenza in <path>/etc/conf.d/net</path>
	</impo>
</p>
</body>
</section>
</chapter>

<chapter>
<title>Utilità per gli rc-script</title>

<section>
<title>L'utilità rc-update</title>
<body>

<p>
	Lo strumento primario per aggiungere e rimuovere 
	servizi in e da un runlevel è rc-update.
	Attraverso rc-update verrà eseguito &quot;depscan.sh&quot; per aggiornare
	la cache delle dipendenze.
</p>
<pre caption="aggiungere metalog al runlevel di default">
# <c>rc-update add metalog default</c>
</pre>

<pre caption="rimuovere metalog dal runlevel di default">
# <c>rc-update del metalog default</c>
</pre>

<p>
<note>
	L'esecuzione del comando rc-update senza argomenti
	dovrebbe visualizzare maggiori informazioni.
</note>
</p>

</body>
</section>

<section>
<title>Lo script depscan.sh</title>
<body>

<p>
	Per completezza, depscan.sh è menzionato qui. E' usato per
	creare una cache di dipendenze che basilarmente è una mappa
	delle dipendenze tra i servizi.
</p>

<p>
	Dovrebbe essere eseguito ogni volta che un nuovo rc-script è
	aggiunto a <path>/etc/init.d</path>, ma dato che viene automaticamente
	eseguito da rc-update, non è necessario eseguirlo nuovamente.
</p>
</body>
</section>
</chapter>
</guide>

