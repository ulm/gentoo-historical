<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/gnupg-user.xml,v 1.13 2005/10/30 20:10:45 so Exp $ -->

<guide link = "/doc/it/gnupg-user.xml" lang="it">
<title>Guida GnuPG Gentoo</title>
<author title="Autore">
  <mail link="humpback@gentoo.org">Gustavo Felisberto</mail>
</author>
<author title="Redazione">
  <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>
<author title="Redazione">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Traduzione">
<mail link="myzelf@omnidea.it">Gilberto De Faveri</mail>
</author>
<author title="Traduzione">
<mail link="doom@ngi.it">Gianmaria Visconti</mail>
</author>
<author title="Traduttore">
  <mail link="info@teknolab.net">Franco Tampieri</mail>
</author>

<abstract>
Questa piccola guida insegnerà le basi per l'utilizzo di GnuPG, uno strumento
per comunicazioni sicure.
</abstract>

<license/>

<version>1.1</version>
<date>2005-10-13</date>

<chapter>
<title>Introduzione</title>
<section>
<title>Cosa si troverà in questa guida</title>
<body>

<p>
Questa guida presuppone che l'utente abbia una certa familiarità con la
crittografia a chiave pubblica e la firma digitale.
Per un'introduzione a questi argomenti leggere il capitolo <uri
link="#doc_chap6">Crittografia a chiave pubblica</uri> o dare una occhiata al
<uri link="http://www.gnupg.org/(en)/documentation/guides.html">GnuPG handbook
</uri>, capitolo 2, e ritornare qui.
</p>

<p>
La guida descrive come installare GnuPG, come creare una coppia di chiavi,
come aggiungere delle chiavi al proprio portachiavi, come inviare la propria
chiave pubblica al KeyServer e come firmare/criptare e verificare/decriptare
i messaggi inviati/ricevuti. Si imparerà anche come criptare i file del
proprio pc per evitare che altre persone ne leggano il contenuto.
</p>

</body>
</section>
<section>
<title>Installazione del software necessario</title>
<body>

<p>
Al livello base è necessario installare il pacchetto principale con un
<c>emerge gnupg</c>. Molte applicazioni oggi hanno qualche tipo di
supporto per gpg, quindi avere <e>crypt</e> nella propria variabile USE
è probabilmente una buona idea.
Se si vuole un client email che utilizzi gnupg è possibile usare pine
(installandolo mediante <c>emerge pinepgp</c>), mutt (installandolo mediante
<c>emerge mutt</c>), Mozilla/Netscape Mail, Evolution (che è un clone di
Microsoft Outlook per GNOME) oppure il client di KDE: KMail (Kmail fa parte
del pacchetto kdepim).
</p>

<p>
Se si utilizza KDE, potrebbe interessare <c>Kgpg</c>; questo piccolo
programma permette di generare coppie di chiavi, importare chiavi da file
ASCII, firmare le chiavi importate, esportare chiavi ed altro.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Generazione della propria chiave ed aggiunta delle chiavi al proprio portachiavi pubblico</title>
<section>
<title>Creazione della propria chiave</title>
<body>

<p>
Per creare propria chiave, semplicemente basta eseguire <c>gpg --gen-key</c>.
Il comando la prima volta che viene eseguito crea alcune directory, in seguito
è necessario rilanciarlo per creare le chiavi:
</p>

<pre caption = "Processo di generazione delle chiavi" >
$ <i>gpg --gen-key</i>
gpg (GnuPG) 1.0.7; Copyright (C) 2002 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.

Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) ElGamal (sign and encrypt)
   (5) RSA (sign only)
   Your selection? <i>1</i>
</pre>

<p>
A questo punto si ha la possibilità di scegliere il tipo di chiave. La
maggior parte degli utenti può utilizzare il tipo predefinito, DSA e ElGamal.
Il punto successivo riguarda la scelta della dimensione della chiave: una
chiave grande è preferibile, ma è importante ricordare di non utilizzare
chiavi più grandi di 2048 con DSA/ElGamal. Normalmente 1024 è più che
sufficiente per una normale l'email.
</p>

<p>
Dopo la dimensione viene richiesta la data di scadenza. Una chiave di breve
durata è preferibile, ma la maggior parte degli utenti può sceglierne una
che non scade mai, oppure con scadenza di 2 o 3 anni.
</p>

<pre caption = "Scelta della dimensione della chiave" >
DSA keypair will have 1024 bits.
About to generate a new ELG-E keypair.
              minimum keysize is  768 bits
              default keysize is 1024 bits
    highest suggested keysize is 2048 bits
    What keysize do you want? (1024) <i>2048</i>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
 &lt;n&gt;= key expires in n days
 &lt;n&gt;w = key expires in n weeks
 &lt;n&gt;m = key expires in n months
 &lt;n&gt;y = key expires in n years
 Key is valid for? (0) <i>0</i>
Key does not expire at all
</pre>

<p>
Ora è necessario inserire alcune informazioni personali. Se si ha intenzione
di inviare la propria chiave pubblica ad altre persone si deve inserire qui il
proprio vero indirizzo.
</p>

<pre caption = "Inserimento informazioni utente" >
Is this correct (y/n)? <i>y</i>
                        
You need a User-ID to identify your key; the software constructs the user id
from Real Name, Comment and Email Address in this form:
"Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;"

Real name: <i>John Doe</i>
Email address: <i>john@nowhere.someplace.flick</i>
Comment: <i>The Real John Doe</i>
You selected this USER-ID:
"John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? <i>O</i> 
You need a Passphrase to protect your secret key.    

Enter passphrase: 
</pre>

<p>
Ora è necessario inserire due volte la password per la propria chiave. E'
buona norma utilizzare una password non banale. Se qualcuno dovesse mai
entrare in possesso della chiave privata e forzare la vostra password,
sarebbe in grado di inviare messaggi firmati a vostro nome, che chiunque
potrebbe ritenere spediti da voi.
</p>

<p>
GnuPG a questo punto creerà la vostra chiave. Muovere il mouse o ascoltare un
mp3 in background velocizzerà il processo di generazione poichè verranno
generati dati casuali.
</p>

</body>
</section>
<section>
<title>Creare un certificato di revoca</title>
<body>

<impo>
Questa sezione è molto importante e la si deve eseguirla <e>ORA</e>.
</impo>

<p>
Dopo la creazione delle proprie chiavi dovreste creare un certificato di
revoca. Fare questo vi permetterà di revocare le vostre chiavi nel caso in
cui capiti qualcosa di spiacevole (qualcuno è entrato in possesso della
vostra chiave/password).
</p>

<pre caption = "Generazione del certificato di revoca">
$ <i>gpg --list-keys</i>
/home/humpback/.gnupg/pubring.gpg
---------------------------------
pub  1024D/75447B14 2002-12-08 John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;
sub  2048g/96D6CDAD 2002-12-08

$ <i>gpg --output revoke.asc --gen-revoke 75447B14</i>

sec  1024D/75447B14 2002-12-08   John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;

Create a revocation certificate for this key? <i>y</i>
Please select the reason for the revocation:   
  0 = No reason specified
  1 = Key has been compromised
  2 = Key is superseded
  3 = Key is no longer used
  Q = Cancel
(Probably you want to select 1 here)
Your decision? <i>1</i>
Enter an optional description; end it with an empty line:
&gt; <i>Someone cracked me and got my key and passphrase</i>
&gt;
Reason for revocation: Key has been compromised
Someone cracked me and got my key and passphrase
Is this okay? <i>y</i>

You need a passphrase to unlock the secret key for
user: "John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;"
1024-bit DSA key, ID 75447B14, created 2002-12-08

ASCII armored output forced.
Revocation certificate created.

Please move it to a medium which you can hide away; if Mallory gets
access to this certificate he can use it to make your key unusable.
It is smart to print this certificate and store it away, just in case
your media become unreadable.  But have some caution:  The print system of
your machine might store the data and make it available to others!
</pre>

<p>
Il comando <c>gpg --list-keys</c> elenca le chiavi presenti nel proprio
portachiavi pubblico. E' possibile utilizzarlo per vedere l'ID della propria
chiave così come è necessario per creare il certificato di revoca.
Ora è una buona idea copiare l'intera directory .gnupg ed il certificato di
revoca (in ASCII criptato - <path>revoke.asc</path>) in un dispositivo sicuro
(due floppy o un CD-R da conservare in un luogo sicuro). Ricordate che
<path>revoke.asc</path> può essere utilizzato per revocare le tue chiavi
e renderle inutilizzabili in futuro.
</p>

<note>
Se si è in possesso di diversi indirizzi email che si vuole utilizzare con
questa chiave, è necessario lanciare <c>gpg --edit-key YOUR_ID</c> e usare il
comando <c>adduid</c>.
Verranno richiesti nome, email ed un commento del secondo ID che verrà
utilizzato.
</note>

</body>
</section>
<section>
<title>Esportazione delle chiavi</title>
<body>

<p>
Per esportare la propria chiave, digitate <c>gpg --armor --output john.asc
--export john@nowhere.someplace.flick</c>. Si può usare quasi sempre l'ID
della chiave o qualcos'altro che la identifichi (qui è usato un indirizzo
email). Ora John ha a disposizione un <path>john.asc</path> che può mandare
agli amici, o mettere nella sua home page in modo che le persone possano
comunicare con lui in modo sicuro.
</p>

</body>
</section>
<section>
<title>Importazione delle chiavi</title>
<body>

<p>
Per aggiungere un file al proprio portachiavi pubblico, si deve prima
importarlo, quindi controllare il fingerprint(impronta digitale) della
chiave. Dopo averlo verificato si dovrebbe validarla.
</p>

<note>
Si dovrebbe verificare con attenzione le chiavi. Questo è uno dei punti
deboli della crittografia a chiave pubblica.
</note>

<p>
Ora, come esempio, si aggiungerà la chiave pubblica di Luis Pinto (mio amico)
al nostro portachiavi pubblico. Dopo averlo contattato per ottenere da lui il
fingerprint della sua chiave, lo si confronterà con l'output del comando
<c>fpr</c>. Poichè la chiave è autentica, la si aggiungerà al portachiavi
pubblico. In questo caso, in particolare, la chiave di Luis scadrà il
2003-12-01, per cui viene richiesta la possibilità di fare in modo che la
vostra firma sulla sua chiave scada lo stesso giorno.
</p>

<pre caption = "Importare e segnare le chiavi">
$ <i>gpg --import luis.asc</i>
gpg: key 462405BB: public key imported
gpg: Total number processed: 1
gpg:               imported: 1
$ <i>gpg --list-keys</i>
/home/humpback/.gnupg/pubring.gpg
---------------------------------
pub  1024D/75447B14 2002-12-08 John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;
sub  2048g/96D6CDAD 2002-12-08

pub  1024D/462405BB 2002-12-01 Luis Pinto &lt;lmpinto@student.dei.uc.pt&gt;
uid                            Luis Pinto &lt;lmpinto@dei.uc.pt&gt;
sub  4096g/922175B3 2002-12-01 [expires: 2003-12-01]

$ <i>gpg --edit-key lmpinto@dei.uc.pt</i>
gpg (GnuPG) 1.0.7; Copyright (C) 2002 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.


gpg: checking the trustdb
gpg: checking at depth 0 signed=0 ot(-/q/n/m/f/u)=0/0/0/0/0/1
pub  1024D/462405BB  created: 2002-12-01 expires: 2003-12-01 trust: -/-
sub  4096g/922175B3  created: 2002-12-01 expires: 2003-12-01
(1)  Luis Pinto &lt;lmpinto@dei.uc.pt&gt;
(2). Luis Pinto &lt;lmpinto@student.dei.uc.pt&gt;

Command> <i>fpr</i>
pub  1024D/462405BB 2002-12-01 Luis Pinto &lt;lmpinto@dei.uc.pt&gt;
             Fingerprint: F056 3697 ADE3 CF98 B80B  8494 0AD3 E57B 4624 05BB
     
Command> <i>sign</i>
Really sign all user IDs? <i>y</i>
                           
pub  1024D/462405BB  created: 2002-12-01 expires: 2003-12-01 trust: -/-
             Fingerprint: F056 3697 ADE3 CF98 B80B  8494 0AD3 E57B 4624 05BB

     Luis Pinto &lt;lmpinto@dei.uc.pt&gt;
     Luis Pinto &lt;lmpinto@student.dei.uc.pt&gt;

This key is due to expire on 2003-12-01.
Do you want your signature to expire at the same time? (Y/n) <i>Y</i>
How carefully have you verified the key you are about to sign actually belongs
to the person named above?  If you don't know what to answer, enter "0".

   (0) I will not answer. (default)
   (1) I have not checked at all.
   (2) I have done casual checking.
   (3) I have done very careful checking.

   Your selection? <i>3</i>
Are you really sure that you want to sign this key
with your key: "John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;"

I have checked this key very carefully.

Really sign? <i>y</i>
              
You need a passphrase to unlock the secret key for
user: "John Doe (The Real John Doe) &lt;john@nowhere.someplace.flick&gt;"
1024-bit DSA key, ID 75447B14, created 2002-12-08

Command> <i>check</i>
uid  Luis Pinto &lt;lmpinto@dei.uc.pt&gt;
sig!3       462405BB 2002-12-01   [self-signature]
sig!3       75447B14 2002-12-08   John Doe (The Real John Doe) &lt;john@nowhe
uid  Luis Pinto &lt;lmpinto@student.dei.uc.pt&gt;
sig!3       462405BB 2002-12-01   [self-signature]
sig!3       75447B14 2002-12-08   John Doe (The Real John Doe) &lt;john@nowhe
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Scambiare le chiavi con i KeyServer</title>
<section>
<title>Invio delle chiavi ai KeyServer</title>
<body>

<p>
Ora che si possiede la propria chiave, è una buona idea inviarla ai KeyServer
mondiali. Ci sono molti KeyServer nel mondo e la maggior parte si scambiano
le chiavi tra loro. Ora si manderà la chiave di Luis al server
subkeys.pgp.net.  Questo server utilizza HTTP, quindi se si ha bisogno di
utilizzare un proxy per il traffico HTTP non bisogna dimenticare di
impostarlo (utilizzando il seguente comando <c>export
http_proxy=http://proxy_host:port/</c>). Il comando per inviare la chiave è
il seguente: <c>gpg --keyserver subkeys.pgp.net --keyserver-options
honor-http-proxy --send-key 75447B14</c> dove <c>75447B14</c> è l'ID della
chiave. Se non si ha bisogno di un proxy HTTP si può rimuovere l'opzione
<e>--keyserver-options honor-http-proxy</e>.
</p>

<p>
E' inoltre possibile mandare al KeyServer anche le chiavi di altre persone
dopo averle firmate. Si potrebbe mandare la chiave di Luis Pinto al KeyServer.
In questo modo qualcuno che si fida della nostra chiave potrebbe usare la
firma che è stata apposta per ritenere fidata anche la chiave di Luis.
</p>

</body>
</section>
<section>
<title>Recupero delle chiavi dai KeyServer</title>
<body>

<p>
Ora, per esempio, si andrà a cercare la chiave di Gustavo Felisberto e la si
aggiungerà al portachiavi di John Doe (nel caso in cui non lo si avesse
notato, Gustavo Felisbero è la persona che ha scritto questa guida :-) ).
</p>

<pre caption = "Ricerca delle chiavi sul KeyServer">
$ <i>gpg --keyserver subkeys.pgp.net --keyserver-options honor-http-proxy --search-keys humpback@felisberto.net</i>
gpg: searching for "humpback@felisberto.net" from HKP server subkeys.pgp.net
Keys 1-5 of 5 for "humpback@felisberto.net"
(1)Gustavo Felisberto (apt-get install anarchy) &lt;humpback@felisberto.net&gt; 1024
  created 2002-12-06, key B9F2D52A
(2)Gustavo Felisberto &lt;humpback@altavista.net&gt; 1024
  created 1999-08-03, key E97E0B46
(3)Gustavo A.S.R. Felisberto &lt;humpback@altavista.net&gt; 1024
  created 1998-12-10, key B59AB043
(4)Gustavo Adolfo Silva Ribeiro Felisberto &lt;humpback@altavista.net&gt; 1024
  created 1998-08-26, key 39EB133D
(5)Gustavo Adolfo Silva Ribeiro Felisberto &lt;humpback@altavista.net&gt; 1024
  created 1998-06-14, key AE02AF87
  Enter number(s), N)ext, or Q)uit &gt;<i>1</i>
gpg: requesting key B9F2D52A from HKP keyserver subkeys.pgp.net
gpg: key B9F2D52A: public key imported
gpg: Total number processed: 1
gpg:               imported: 1
</pre>

<p>
Come si può vedere dalla risposta del server, sono state inviate diverse
chiavi al KeyServer, ma al momento è utilizzata solo <e>B9F2D52A</e>.
Ora John Doe può scaricarla e firmarla, se la ritiene fidata.
</p>

</body>
</section>
</chapter>

<chapter id="gpg-agent">
<title>Utilizzo di un agente GPG</title>
<section>
<title>Cos'è un agente GPG?</title>
<body>

<p>
Ci sono situazioni, quando si lavora con certe applicazioni, in cui l'utilizzo 
delle chiavi GPG è assai frequente, ciò significa che si dovrebbe digitare la
propria password molto spesso. In passato molte applicazioni utilizzavano un
meccanismo di cache per salvare temporaneamente la password. Questi meccanismi
non era condivisi con le altre applicazioni per ragioni di sicurezza, e ogni
programma doveva inventarsi il proprio meccanismo.
</p> 	 

<p>
Un Agente GPG è un'applicazione separata che GPG usa per salvare la password
temporaneamente in cache in maniera standard e sicura. Esso permette a
diverse applicazioni di usare GPG contemporaneamente: se si inserisce la
password in un'applicazione non sarà necessario digitarla nuovamente per l'
altra applicazione: ovviamente se l'agente è configurato in maniera tale da
permetterlo.
</p>	 

<p>
Gentoo fornisce diversi agenti GPG. <c>app-crypt/gpg-agent</c> può essere
considerato come quello di riferimento, che verrà  illustrato in questo
documento.
</p> 	 

</body>
</section>
<section>
<title>Installazione e configurazione di gpg-agent e pinentry</title>
<body>	 

<p>
E' ovviamente necessario installare <c>gpg-agent</c>, e inoltre
<c>pinentry</c>, che è l'applicazione di supporto a gpg-agent per richiedere
la password in una finestra grafica. Può lavorare in tre modi: con una
finestra a popup che usa le librerie gtk+, le Qt, o curses (a seconda delle
flag di USE attive al momento della sua compilazione).
</p> 	 

<pre caption="Installare gpg-agent e pinentry">
# <i>emerge gpg-agent pinentry</i>
</pre> 	 

<p>
Ora bisogna creare un file <path>~/.gnupg/gpg-agent.conf</path> e inserite le
seguenti righe che definiscono il tempo di timeout della password (ad esempio
30 minuti) e l'applicazione che deve essere richiamata quando viene richiesta
la password (ad esempio la versione Qt di pinentry).
</p>  	 

<pre caption="Modificare ~/.gnupg/gpg-agent.conf">
pinentry-program /usr/bin/pinentry-qt
no-grab
default-cache-ttl 1800
</pre>	 

<p>
Ora si configuri GnuPG perchè utilizzi l'agente quando necessario. Modificare
<path>~/.gnupg/gpg.conf</path> aggiungendo la linea seguente:
</p>

<pre caption="Configurare GnuPG per l'uso di GPG Agent">
use-agent
</pre>  	 

<p>
Ora il sistema è quasi pronto per usare l'agente GPG.
</p>  	 

</body>
</section>
<section>
<title>Avvio automatico dell'agente</title>
<body>  	 

<p>Se si utilizza KDE come ambiente grafico, modificate il file
<path>/usr/kde/3.x/env/agent-startup.sh</path> (per l'intero sistema) o
<path>~/.kde/env/gpgagent.sh</path> (per il solo utente locale) e
aggiungere il seguente comando per far in modo che KDE avvii automaticamente
l'agente GPG:
</p>  	 

<pre caption="Avvio automatico dell'agente in KDE">
eval "$(gpg-agent --daemon)"
</pre>  	 

<p>
Se si utilizza un altro ambiente grafico, inserire la stessa linea sopracitata
in <path>~/.xinitrc</path> (se si utilizza <c>startx</c>) o
<path>~/.xsession</path> (se si utilizza XDM/GDM/KDM/...).
</p>  	 

</body>
</section>
</chapter>

<chapter>
<title>Lavorare con documenti</title>
<section>
<title>Criptare e firmare</title>
<body>

<p>
Adesso si supponga di avere un file che si desidera inviare a Luis. Lo si può
criptare, firmare o criptare e firmare. Criptare significa che solo Luis sarà
in grado di aprirlo. La firma conferma a Luis che siete stati proprio voi a
creare il file.
</p>

<p>
I seguenti comandi fanno esattamente questo: criptano, firmano e
criptano/firmano.
</p>

<pre caption="Encrypting and Signing files">
$ <i>gpg --output doc.gpg --encrypt --recipient lmpinto@dei.uc.pt doc_to_encrypt</i>
$ <i>gpg --output doc.gpg --sign --recipient lmpinto@dei.uc.pt doc_to_sign</i>
$ <i>gpg --output doc.gpg --encrypt --sign --recipient lmpinto@dei.uc.pt doc_to_encrypt_and_sign</i>
</pre>

<p>
Questa procedura crea file binari. Se si vuole creare file ASCII si aggiunga
<c>--clearsign</c> all'inizio del comando.
</p>

</body>
</section>
<section>
<title>Decriptare e verificare le firme</title>
<body>

<p>
Supponiamo che si abbia ricevuto un file criptato con la propria chiave
pubblica. Il comando per decriptarlo è <c>gpg --output document --decrypt
encrypted_doc.gpg</c>. Questo decripterà il documento e verificherà la firma
(se ne esiste una).
</p>

</body>
</section>
<section>
<title>Caratteristiche avanzate</title>
<body>

<p>
Ci sono alcune utili caratteristiche avazate in GnuPG. Per trovarle, si apra
il file <path>~/.gnupg/gpg.conf</path>.
</p>

<pre caption="~/.gnupg/gpg.conf">
#keyserver x-hkp://subkeys.pgp.net
#keyserver-options auto-key-retrieve include-disabled include-revoked
</pre>

<p>
Si cerchino le due linee qui sopra e le si decommentino. Con queste opzioni,
ogni volta che GnuPG dovrà verificare una firma e non troverà la
corrispondente chiave pubblica nel portachiavi locale, contatterà il
KeyServer all'indirizzo <uri
link="http://subkeys.pgp.net">subkeys.pgp.net</uri> e cercherà di recuperarne
una da quella locazione.
</p>

<p>
Un'altro comando utile è <c>gpg --refresh-keys</c>. Il programma eseguito con
tale opzione contatterà il KeyServer definito nel file di impostazioni ed
aggiornerà le chiavi pubbliche presenti nel portachiavi locale, cercando
chiavi revocate, nuovi id e nuove firme sulle chiavi.
E' opportuno eseguire questo comando una o due volte al mese, in modo da
sapere se qualcuno revoca la propria chiave.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Interfaccie a GnuPG</title>
<section>
<title>La firma nelle email</title>
<body>

<p>
Il 95% delle volte si userà GnuPG con l'email per firmare/criptare i messaggi
in uscita e per leggere messaggi firmati/criptati. Quindi è sufficiente
introdurre solo questi casi.
</p>

<p>
Esistono due modi per firmare/criptare una email con GnuPG, il vecchio modo ed
il nuovo modo :-). Con il primo metodo i messaggi appaiono in semplice testo,
senza la possibilità di formattazione e con file allegati non firmati / non
criptati. Ecco un esempio di un messaggio firmato in tale maniera:
</p>

<pre caption="Una firma di un testo semplice">
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Test message

-----BEGIN PGP SIGNATURE-----
Version: PGPfreeware 6.5.8 for non-commercial use

iQA/AwUBP8461jMX0745gR7AEQIEOwCg011GbufXO3ED3FkLWXmfzg7xm1cAoJD0
0EU3Kd2EKNCqataEqM5qjpPs
=LchZ
-----END PGP SIGNATURE-----
</pre>

<p>
Al giorno d'oggi, inviare messaggi in questo modo non è assolutamente una
buona idea, visto che esistono ottime interfacce grafiche e client email
che gestiscono i tag html.
</p>

<p>
Per risolvere il problema è stata creata un'estensione a MIME (Multipurpose
Internet Mail Extensions). Un nuovo campo dell'email indica al client che
l'intero contenuto del messaggio è firmato e/o criptato. Il problema di questa
soluzione è che non è supportata da tutti i client email: alcuni fanno persino
pasticci con il contenuto, come Outlook di Microsoft, famoso per non funzionare
bene con questo metodo.
</p>

</body>
</section>
<section>
<title>Kgpg</title>
<body>

<p>
Kpgp è una interfaccia grafica carina per GNUPG. Nella schermata principale è
possibile incollare il testo che si vuole firmare o criptare oppure incollare
il testo ASCII criptato che si vuole decriptare.
</p>

 <figure link="/images/kgpg1.png" short="kgpg main window"/>

<p>
In questa immagine si può vedere la schermata principale di Kgpg con del
testo criptato incollato. Da qui è possibile decriptarlo (sarà  richiesta la
propria password), criptare altri file, incollare dell'altro testo da
firmare...
</p>

 <figure link="/images/kgpg2.png" short="kgpg key manage window"/>
<p>
Qui si può vedere la schermata di gestione delle chiavi. Vediamo la nostra
bella chiave per John Doe, le due chiavi fidate per Gustavo e Luis e la
chiave non fidata per Daniel Robbins (non è ancora stato chiamato per
controllare il suo fingerprint :-) ).
</p>

</body>
</section>
<section>
<title>Seahorse</title>
<body>

<p>
Seahorse aspira a diventare un frontend grafico di GnuPG per Gnome. Questo
programma si sta evolvendo in fretta, ma non dispone ancora di importanti
caratteristiche presenti in Kpgp o nella versione a riga di comando.
</p>

</body>
</section>
<section>
<title>Mozilla Enigmail</title>
<body>

<p>
Mozilla dispone, dalla versione 1.0, di Enigmail, un plugin per il client
email che è molto semplice da configurare. Si deve semplicemente andare in
Preferences -&gt; Privacy &amp; Security -&gt; Enigmail, dove è necessario
inserire la propria chiave per l'email.
</p>

<p>
I messaggi che arrivano con una firma pgp o gpg non fidata vengono
contrassegnati con una penna rotta. Quelli che hanno una firma valida
appariranno con una penna tutta intera. Enigmail può anche recuperare le
chiavi dai KeyServer, ma in caso di problemi, stampa alcuni strani messaggi
di errore (ma in questo casi ci si ricorda ancora della linea di comando,
giusto?).
</p>

</body>
</section>
<section>
<title>KMail</title>
<body>

<p>
Se è stata impostata la USE flag <c>crypt</c>, KMail sarà compilato con il
supporto per gpg, e sarà pronto per crittografare e decrittografare email
con PGP automaticamente, oltre a offrire la possibilità di crittografare
email OpenPGP/MIME.
Se si vuole decrittografare email OpenPGP/MIME, si deve avere un agente GPG
configurato. (Si veda <uri link="#gpg-agent">Utilizzo di un agente GPG</uri>)
</p>

<p>
Si può verificare che KMail sia correttamente configurato entrando in
<c>Impostazioni</c>, <c>Configura KMail</c>, <c>Sicurezza</c>,
<c>Backend Crittografici</c>. Si dovrebbe vedere un backend basato su
GpgME e si dovrebbe poter attivare la casella su OpenGPG. Se il suddetto
backend è presente ma è segnato in grigio, si faccia click su
<c>Riesegui scansione</c>. Se il backend GpgME resta grigio vuole dire
che KMail non sta funzionando a dovere.
</p>


</body>
</section>
<section>
<title>Sylpheed-Claws</title>
<body>

<p>
Questo è il client email che utilizza l'autore. E' <e>molto</e> veloce con
caselle di posta grandi, dispone di tutte le caratteristiche desiderabili
in un client e funziona perfettamente con gpg. L'unico problema è dato dal
fatto che non funziona con le vecchie firme PGP, quindi se si riceve una mail
di quel tipo si dovrà verificare a mano la firma.
</p>

<p>
Per usare la propria chiave gpg con Sylpheed-Claws bisogna entrare nella
configurazione dell'account ed cliccare sulla casella privacy. Da lì è
possibile scegliere quale chiave utilizzare.
Probabilmente la maggior parte degli utenti dovrà scegliere la chiave di
default.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Crittografia a chiave pubblica</title>
<section>
<title>Le basi della crittografia a chiave pubblica</title>
<body>

<p>
Il concetto di crittografia a chiave pubblica fu originariamente dovuto a
Whitfield Diffie e Martin Hellman (1976). Quando l'autore senti per la prima
volta, nel '93, le parole "chiave pubblica" e "crittografia" nella stessa
frase, pensò che una cosa del genere fosse impossibile. A quei tempi non
esisteva Internet (in realtà esisteva, ma non era alla portata di tutti),
quindi andò in biblioteca e chiese alcuni libri sulla crittografia. All'epoca
aveva 16 anni e l'addetto allo sportello lo guardò con stupore e gli portò
alcuni libri per bambini sui cifrari per sostituzione (quelli in cui
avvengono semplici sostituzioni di lettere, come il famoso Cifrario di Cesare
o il ROT-13 (Tragbb Ebpxf, naq lbh xabj vg vf tbbq orpnhfr lbh ner ernqvat
guvf qbp.), (Si faccia emerge rotix se non si è in grado di decifrare questa
frase)).  Essendo frustrato per l'accaduto, cominciò a ricercare maggiori
informazioni.  E' bello avere matematici in famiglia, perchè appena ebbe
l'occasione di parlare con uno di loro, fu proiettato in un nuovo mondo.
</p>

<p>
Ed ora un po' di matematica:
</p>

<pre caption="Concetti matematici">
Definizioni:

1- Un numero primo è un numero intero positivo divisibile solo per se stesso e
per 1 (il resto della divisione è 0).
I primi 8 numeri primi sono 1,2,3,5,7,11,13,17

Teorema (qui senza dimostrazione)
1- Ogni numero intero positivo non primo è scomponibile in un prodotto di numeri
primi, e tale prodotto è unico.
4=2*2
6=2*3
8=2*4=2*2*2
10=2*5
12=2*6=2*2*3

"Fatti":
1- E' matematicamente facile moltiplicare due grandi interi
2- E' difficile trovare i fattori primi di un dato intero positivo.
</pre>

<p>
Se si da il numero 35 e si afferma che questo numero è il prodotto di due
numeri primi, è facile scoprire che tali numeri sono 5 e 7. Ma se si chiede
la stessa cosa per 1588522601 ci vorrà un bel po' di tempo (o di cicli di
CPU) per scoprire che si tratta del prodotto di 49811*31891. E se il numero
è davvero grande, questo compito diventa "impossibile". A questo punto se
si comunica al mondo il proprio grande numero, che si sa essere il prodotto
di due primi, si sa qualcosa di quel numero che non è noto a nessun'altro.
</p>

<p>
Questa è la base delle moderne implementazioni di Crittografia a Chiave
Pubblica (PKC). Come (irrealistico) esempio, si dia a chiunque il proprio
numero e qualcuno lo userà per cifrare un messaggio per voi. Tutti possono
vedere il messaggio cifrato perchè voi siete gli unici a conoscere la
scorciatoia per leggerlo; gli altri dovrebbero prima "scomporre" quel grande
numero per essere in grado di leggere il messaggio, ed è un "fatto"
l'impossibilità di farlo in un lasso di tempo ragionevole (con i metodi
odierni e i più veloci computer al mondo ci vorrebbero migliaia di anni).
In questa ipotesi, i due grandi numeri primi sono chiamati la CHIAVE PRIVATA,
mentre il grande numero non primo è la CHIAVE PUBBLICA.
</p>

<p>
Questo non corrisponde al 100% con quanto avviene in realtà, ma può rendere
bene l'idea ad un nuovo utente. Per maggiori informazioni si veda hack.gr per
quanto riguarda il protocollo <uri 
link="http://www.hack.gr/users/dij/crypto/overview/diffie.html">
Diffie-Hellman</uri>. Per approfondire ulteriormente andate in biblioteca e
prendete una copia di <uri link="http://www.cacr.math.uwaterloo.ca/hac/">
"Handbook of Applied Cryptography"</uri> di Alfred J. Menezes, Paul C. van
Oorschot e Scott A. Vanstone, disponibile anche gratuitamente online
all'indirizzo qui sopra.
</p>

<p>
Una conseguenza di quanto detto fino a questo punto è che se si cifra un
messaggio per voi e si perde il messaggio originale non cifrato, non si
sarà in grado di risalire all'originale dalla versione cifrata.
</p>

</body>
</section>
<section>
<title>Firme</title>
<body>

<p>
Abbiamo già visto come chiunque in possesso della nostra chiave pubblica
possa mandare un messaggio cifrato. Ma come possiamo verificare che l'autore
del messaggio è veramente chi dice di essere? O, in altre parole: se si riceve
una email da voi come si può sapere davvero che è stata inviata da voi e non
da qualcun altro che sostiene di essere voi?
</p>

<p>
Ricordate quando si è detto che la PKC non è così semplice? L'idea è che
quando si cifra un messaggio per una persona, lo si può anche firmare con
la propria chiave privata in modo che, quando lo si riceve, la persona possa
a sua volta utilizzare per prima cosa la vostra chiave pubblica per verificare
la firma e, quindi, la sua chiave privata per decifrare il messaggio.
Come si può vedere non sarebbe possibile fare questo nell'ipotesi di prima.
</p>

<p>
Altra cosa molto importate: per firmare i messaggi non è necessario cifrarli.
Si può creare un messaggio leggibile da chiunque, ma con il proprio "marchio".
E se un solo carattere del messaggio viene modificato, tale manomissione può
essere rilevata.
</p>

</body>
</section>
<section>
<title>Key Server e chiavi firmate</title>
<body>

<p>
Ora supponiamo che si non abbia avuto contatti con voi fino a quando non avete
mandato un messaggio a una persona: come può questa persona avere la vostra
chiave pubblica, e come può sapere se è veramente la vostra?
</p>

<p>
Per risolvere questo problema sono stati creati i key server pubblici. Quando
si crea la propria coppia di chiavi (pubblica e privata), si può inviare la
propria chiave pubblica al key server. A questo punto tutti possono scaricare
la vostra chiave da lì. Ma come si può sapere che quella chiave è la chiave
dell'autore del messaggio? Per questo bisogna introdurre un altro concetto: la
firma della chiave.
</p>

<p>
Firmare la chiave significa che, se si ha la chiave pubblica di un'altra
persona e si sa <e>con certezza</e> che è davvero la chiave di quella persona
(perchè è un amico, qualcuno che conosco di persona, ecc.) si può firmare
quella chiave pubblica e mandarla ai Key Kerver, in modo da dire al mondo:
"Questa chiave appartiene davvero alla persona che sostiene gli appartenga".
In questo modo le persone che hanno la vostra chiave pubblica e si fidano di
voi possono usare questa fiducia per ritenere fidate le chiavi di altri.
</p>

<p>
Questo meccanismo può confondere, quindi vediamo un esempio reale.
</p>

<p>
Immaginiamo una situazione con 3 persone: John, Mary e Lisa. John è un buon
amico di Mary, ma non conosce Lisa; Lisa è una buona amica di Mary, ma non
conosce John. Un giorno Lisa manda a John una email firmata. John recupererà
la chiave pubblica di Lisa dal KeyServer, verificherà il messaggio e, se è
tutto a posto, saprà che chiunque abbia scritto quel messaggio ha anche
creato quella chiave. Ma come può sapere che è effettivamente la persona
che dice di essere?
</p>

<p>
A questo punto John vede la firma di Mary sulla chiave, che può verificare
perchè dispone già della chiave di Mary e la ritiene fidata. Grazie a questo
anello di fiducia egli conclude che l'email ricevuta è stata realmente
scritta da Lisa.
</p>

<p>
Ora si è veramente pronti per leggere questa guida, tornate indietro al
capitolo 1 ed imparate a usare gpg.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Epilogo e ringraziamenti</title>
<section>
<title>Alcuni problemi</title>
<body>

<p>
Si sono avuti alcuni problemi con foto inserite nelle chiavi. Controllate la
versione che state utilizzando. Se si ha GnuPG 1.2.1-r1 e superiori non ci
dovrebbero essere problemi. In ogni caso, la maggior parte dei KeyServer non
gradisce chiavi con foto, quindi meglio non utilizzarle.
</p>

<p>
L'ultima versione di GnuPG sembra non funzionare con il comando <c>gpg
--send-keys</c>, che viene utilizzato per mandare tutte le chiavi presenti
nel portachiavi al server pubblico.
</p>

</body>
</section>
<section>
<title>Cosa manca</title>
<body>

<p>
<c>Gpg</c> è uno strumento molto complesso e permette di fare molto di più
rispetto a quanto è stato trattato qui. Questo documento è stato concepito
per i nuovi utenti GnuPG. Per maggiori informazioni, si veda il
<uri link="http://www.gnupg.org">sito di GnuPG</uri>.
</p>

<p>
Non sono stati trattati altri strumenti come <c>pgp4pine</c>, <c>gpgpine</c>,
<c>Evolution</c> e gli strumenti per Windows; probabilmente si amplierà questo
documento in futuro.
</p>

</body>
</section>
<section>
<title>Ringraziamenti</title>
<body>

<p>
Il <uri link="http://www.gnupg.org">GnuPG Handbook</uri> di John Michael Ashley
è un ottimo libro per i principianti.
</p>

<p>
Swift (Sven Vermeulen) per aver spinto a ri-scrivere questo documento.
</p>

<p>
I fantastici ragazzi del canale #gentoo-doc.
</p>

<p>
Tiago Serra per avermi riportato sulla via della privacy.
</p>

</body>
</section>
</chapter>
</guide> 
