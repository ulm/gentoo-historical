<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/home-router-howto.xml,v 1.2 2006/02/18 14:00:58 mascherpa Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/home-router-howto.xml" lang="it">

<title>Configurare un Router domestico</title>

<author title="Autore">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>

<author title="Traduzione">
  <mail link="alberto@lagnusi.net">Alberto Santini</mail>
</author>

<author title="Traduzione">
  <mail link="cristiano.chiucchiolo@gmail.com">Cristiano Chiucchiolo</mail>
</author>


<abstract>
In questo documento è spiegato come trasformare una vecchia macchina
con Gentoo in un router domestico per collegare tutta la casa ad
Internet
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.24</version>
<date>2005-12-20</date>

<chapter>
<title>Introduzione</title>
<section>
<body>

<p>
Costruire il proprio router partendo da vecchi pezzi di PC ha molti vantaggi
rispetto al comprare un router di marca, ad esempio un Linksys. Il primo di
questi vantaggi è l`avere un controllo completo sulla connessione. Gli altri
potrete immaginarli da soli; si può realizzare quasi qualsiasi cosa in questo
modo, se solo se ne ha la necessita'.
</p>

<p>
Questa guida mostrera' come attivare un servizio di NATting (Network Address
Translation) configurando il kernel ed iptables, come fornire ed impostare
alcuni tra i servizi piu' comuni: DNS (Domain Name System) attraverso dnsmasq,
DHCP (Dynamic Host Configuration Protocol) attraverso dhcpd, ADSL (Asymmetric
Digital Subscriber Line) attraverso rp-pppoe. Alla fine, concluderemo con
qualcosa di piu' sofisticato e divertente (port forwarding, regolazione del
traffico di dati, impostazione di proxy/caching, ecc...).
</p>

<p>
Prima di cominciare, ecco una lista di requisiti che il tuo PC deve soddisfare.
Per prima cosa, devono essere presenti almeno due schede di rete nel computer.
Successivamente, devi conoscere le impostazioni della tua connessione ad Internet
(ad esempio il tuo IP/DNS/GateWay/username/password). Infine, ti servirà un pò
di tempo libero e di amore verso Gentoo.
</p>

<p>
Questa guida si bassa sulla seguente configurazione tipo:
</p>

<ul>
 <li>eth0 - Scheda di rete connessa alla tua LAN (Local Area Network)</li>
 <li>eth1 - Scheda di rete connessa alla WAN (Wide Area Network)</li>
 <li>La LAN utilizza il set 192.168.0.??? di IP privati</li>
 <li>L`IP del router è quello standard (192.168.0.1)</li>
 <li>Sul router gira Linux 2.4/2.6 - Dovrai fare da solo con Linux 2.0/2.2</li>
</ul>

<impo>
Per motivi di sicurezza, è vivamente consigliato di disattivare sul router tutti
i servizi che non sono necessari finchè non si disporrà di un firewall ben
funzionante. Per vedere i servizi attivi, usare il comando <c>rc-status</c>.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione del Kernel (prima conoscete voi stessi)</title>
<section>
<body>

<p>
Come prima cosa, il kernel ha bisogno dei driver per entrambe le schede di rete.
Per vedere se le schede sono già state correttamente riconosciute dal Kernel, si
può usare il comando <c>ifconfig</c>. Il tuo output può essere diverso da quello
che segue, ma questo non ha importanza: quello che conta è che vi siano mostrate
entrambe le interfacce di rete.
</p>

<pre caption="Controllare le schede di rete">
# <i>ifconfig -a</i>
eth0      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B8
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x9800 

eth1      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B9
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:10 Base address:0x9400 
</pre>

<p>
Se non vedi una o entrambe le schede di rete e non sai che tipo di schede
hai, puoi provare a lanciare il comando <c>lspci</c>. Se non hai neanche
questa utility, la puoi scaricare con il comando <c>emerge pciutils</c>.
Cerca una riga contenente "Ethernet controller" nell'output di <c>lspci</c>.
Appena ottenute le informazioni necessarie, puoi ricompilare il Kernel
attivando il supporto per le tue schede di rete.
</p>

<p>
Un'altra cosa che ti servirà è il supporto per iptables, per il NAT e per il
controllo del traffico (se lo vuoi attivare). Nella lista che segue, le opzioni
sempre richieste sono segnate come (*), quelle richieste solo per l'ADSL via PPPoE sono segnate come (a), quelle consigliate come (x) e quelle per il controllo come (s). Non importa se si sceglie di compilare questi supporti
direttamente nel kernel o come moduli, perchè questi ultimi saranno comunque caricati non appena ce ne sarà bisogno.
</p>

<pre caption="Network Options">
Networking options  ---&gt;
   [*] TCP/IP networking
      [*] IP: advanced router
   [*] Network packet filtering (replaces ipchains)
<comment>If you use 2.4.x, you have to enable the following for DHCP:</comment>
   [*] Socket Filtering

   IP: Netfilter Configuration  ---&gt;
      [*] Connection tracking (required for masq/NAT)
         [x] FTP protocol support
         [x] IRC protocol support
      [*] IP tables support (required for filtering/masq/NAT)
         [*] IP range match support
         [x] MAC address match support
         [*] Multiple port match support
         [*] Packet filtering
            [*] REJECT target support
            [x] REDIRECT target support
         [*] Full NAT
            [*] MASQUERADE target support
         [s] Packet mangling
            [s] MARK target support
         [x] LOG target support

   QoS and/or fair queueing  ---&gt;
      [s] QoS and/or fair queueing
         [s] HTB packet scheduler
         [s] Ingress Qdisc
	 
      [a] PPP (point-to-point protocol) support
	 [a] PPP filtering
	 [a] PPP support for async serial ports
	 [a] PPP support for sync tty ports
	 [a] PPP Deflate compression
	 [a] PPP BSD-Compress compression
  	 [a] PPP over Ethernet
</pre>

<note>
Potete trovare qualcosa di diverso tra i kernel 2.4 e 2.6, cercate di capire
come rimediare :)
</note>

</body>
</section>
</chapter>

<chapter>
<title>Collegarsi alla WAN (ovvero ad Internet)</title>

<section>
<title>Introduzione</title>
<body>

<p>
Ci sono moltissimi modi di connettersi ad Internet, quindi questa guida tratterà
soltanto quelli usati dal suo autore, ovvero un collegamento ADSL (PPPoE) e uno
con Modem telefonico (meglio conosciuto come "il 56k").
Se conoscete altri metodi, potete mettermene al corrente inviandomi una mail.
Potete prendervi la libertà di saltare qualsiasi delle sezioni successive in questo
capitolo se non vi riguarda. Lo scopo di questo capitolo e' di connettere il router
ad Internet attraverso eth1.
</p>

</body>
</section>
<section>
<title>ADSL e PPPoE</title>
<body>

<p>
Tutto il software prodotto, che riguarda PPPoE, e' stato riunito in un solo
pacchetto chiamato <uri link="http://www.roaringpenguin.com/">Roaring Penguin
</uri>. Bastera' eseguire <c>emerge rp-pppoe</c> e saremo pronti per cominciare.
Ricordate  quando vi è stato chiesto di tenere sotto mano l'username e la
password del vostro account Internet? Beh, è venuto il momento di usare quelle
informazioni! Aprite <path>/etc/ppp/pppoe.conf</path> nel vostro editor preferito
e modificate i parametri in maniera appropriata.
</p>

<note>
È necessario avere installato baselayout-1.11.14 o superiore, per far sì che la
seguente configurazione (di net.eth1) funzioni correttamente.
</note>

<pre caption="Configurare eth1">
<comment>(Sostituire 'vla9h924' con il proprio username e 'password' con la propria password)</comment>

# <i>nano /etc/ppp/pap-secrets</i>
<comment># client    server  secret</comment>
"vla9h924" * "password"
# <i>nano /etc/conf.d/net</i>
<comment>Dire a baselayout di usare l'adsl per eth0</comment>
config_eth1=( "adsl" )
user_eth1=( "vla9h924" )
# <i>ln -s net.lo /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<warn>
Quando l'interfaccia DSL si attiva, sarà creato il device ppp0. Anche se la scheda
di rete è eth0, l`IP appartiene a ppp0. Da ora in avanti, dove vedrete esempi che
usano 'eth1', sostituitelo con 'eth1'.
</warn>

</body>
</section>

<section>
<title>Connessione attraverso linea telefonica e/o IP statico/dinamico</title>
<body>

<p>
Se possedete un IP statico, avrete bisogno di conoscere qualche dettaglio in più:
il vostro IP, il vostro gateway ed i vostri server DNS.
</p>

<pre caption="Configurare eth1">
<comment>IP dinamico:</comment>
# <i>emerge dhcpcd</i>
# <i>nano /etc/conf.d/net</i>
<comment>Dovrete inserire una riga simile a questa:</comment>
config_eth1=( "dhcp" )

<comment>IP Statico:</comment>
# <i>nano /etc/conf.d/net</i>
<comment>Dovrete inserire righe simili a queste:</comment>
ifconfig_eth1=( "66.92.78.102 broadcast 66.92.78.255 netmask 255.255.255.0" )
routes_eth1=( "default gw 66.92.78.1" )
# <i>nano /etc/resolv.conf</i>
<comment>Aggiungere una riga per il server DNS:</comment>
nameserver 123.123.123.123

<comment>Configurazione sia per l'IP dinamico che statico:</comment>
# <i>ln -s net.lo /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<p>
Ora dovrebbe essere tutto configurato.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Collegarsi alla LAN (portatevi appresso qualche amico)</title>
<section>
<body>

<p>
Questo passaggio è una bazzecola rispetto al precedente.
</p>

<pre caption="Configurare eth0">
# <i>nano /etc/conf.d/net</i>
<comment>Aggiungere una riga come questa:</comment>
ifconfig_eth0=( "192.168.0.1 broadcast 192.168.0.255 netmask 255.255.255.0" )
# <i>rc-update add net.eth0 default</i>
# <i>/etc/init.d/net.eth0 start</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Servizi LAN (perchè siamo brave persone)</title>

<section>
<title>Server DHCP</title>
<body>

<p>
Scommetto che sarebbe bello se chiunque a casa vostra potesse semplicemente
collegare i propri computer alla rete e tutto funzionasse subito. Non ci
sarebbe alcun bisogno di ricordare dettagli noiosi e difficili da memorizzare
o di inserirli in interfacce di configurazione confusionarie! Proprio una
bella vita, eh? Vi presento DHCP (Dynamic Host Configuration Protocol o
Protocollo per la Configurazione Dinamica degli Host) e vi spiego perchè vi
dovrebbe interessare :)
</p>

<p>
DHCP,come si può desumere dal nome, è un protocollo che consente di configurare
dinamicamente gli altri host in maniera del tutto automatica. Basta far girare
il server DHCP sul router, passargli tutte le informazioni sulla propria
rete (indirizzi IP validi, server DNS, gateway, ecc...) e, quando gli altri host
si connetteranno alla rete, useranno client DHCP per autoconfigurarsi. Niente
confusione, nè pasticci. Per maggiori informazioni sul DHCP, potete visitare
<uri link="http://en.wikipedia.org/wiki/DHCP">Wikipedia</uri>.
</p>

<p>
Useremo un pacchetto chiamato dnsmasq, che fornisce servizi sia DHCP che DNS. Per il momento concentriamoci sull'aspetto DHCP. Si noti che se si vuole eseguire un diversio server DHCP, è necessario guardare un altro esempio nel capitolo "Qualcosa di divertente". Inoltre, se desiderate sperimentare le opzioni del server DHCP, leggete i commenti in <path>/etc/dnsmasq.conf</path>. Ad ogni modo, le opzioni di default dovrebbero andare bene.
</p>

<pre caption="Installare un server DHCP">
# <i>emerge dnsmasq</i>
# <i>nano /etc/dnsmasq.conf</i>
<comment>Dovete solo aggiungere questa riga</comment>
dhcp-range=192.168.0.100,192.168.0.250,72h

# <i>nano /etc/conf.d/dnsmasq</i>
<comment>Aggiungere "-i eth0" a DNSMASQ_OPTS</comment>
# <i>rc-update add dnsmasq default</i>
# <i>/etc/init.d/dnsmasq start</i>
</pre>

<p>
Ora il vostro piccolo router e' un semplice server DHCP! Collegate alla rete
qualche computer ed osservate bene come.. semplicemente funziona! :) Con un
sistema MS Windows dovrete andare nel pannelo "Proprietà TCP/IP" e selezionare
le opzioni "Ottieni un indirizzo IP automaticamente" e "Ottieni l`indirizzo del
server DNS automaticamente". A volte, queste modifiche non hanno effetto
immediato e dovrete aprire una finestra di comando ed eseguire
<c>ipconfig /release</c> e <c>ipconfig /renew</c>. Ma ora basta con Windows,
torniamo al nostro pinguino preferito.
</p>

</body>
</section>

<section>
<title>Server DNS</title>
<body>

<p>
Quando qualcuno vuole visitare un sito web o raggiungere un altro host su
Internet, solitamente si ricorda del nome di quel sito, piuttosto che di
una stringa di numeri. E` più facile ricordare ebay.com che 66.135.192.87,
no? Ecco dove entra in gioco il DNS. I server DNS girano più o meno ovunque
su internet e non appena qualcuno vuole visitare ebay.com, questi server
trasformano "ebay.com" (di facile comprensione per noi) in "66.135.192.87"
(di facile comprensione per i nostri computer). Per maggiori informazioni
sul DNS, anche questa volta potete visitare <uri
link="http://en.wikipedia.org/wiki/DNS">Wikipedia</uri>.
</p>

<p>
Visto che stiamo usando dnsmasq per il nostro server DHCP, ed esso include un server DNS, non resta più niente da fare qui! Il vostro piccolo router sta già fornendo il servizio DNS ai suoi clients DHCP. Scommetto che sareste contenti se tutto fosse così facile ;).
</p>

<p>
Potete benissimo scegliere altri server DNS se vi trovate
meglio con quelli, ma il motivo per cui dnsmasq è grandioso è che fa esattamente
quello che noi vogliamo e niente di più. E` un piccolo server per reti locali
con funzionalità di caching e forwarding. Noi non vogliamo offrire un DNS per un
nostro dominio, ma soltanto offrire un servizio DNS di base a chiunque si trovi
nella nostra LAN.
</p>

</body>
</section>

<section>
<title>NAT (ovvero IP-masquerading)</title>
<body>

<p>
In questo momento, le persone nella vostra rete possono comunicare fra di loro
e possono collegarsi a degli hostname tramite DNS, ma non possono ancora
connettersi realmente ad internet. E mentre voi potete esserne felici (più
banda per voi), scommetto che loro non lo sono altrettanto.
</p>

<p>
Ecco dove entra in scena il Network Address Translation (NAT). NAT è un modo per connettere più computer in una
LAN ad Internet, quando si hanno a disposizione un numero minore di indirizzi
IP. Tipicamente, la compagnia telefonica offre ad ogni utente un solo IP, ma
noi vogliamo che tutta la casa sia connessa ad internet. NAT è la magia che
rende possibile tutto ciò. Anche in questo caso, maggiori informazioni circa
NAT possono essere trovate su <uri link="http://it.wikipedia.org/wiki/Network_address_translation">
Wikipedia</uri>
</p>

<note>
Prima di cominciare, assicuratevi di avere iptables nel vostro sistema. Nonostante
sia installato automaticamente nella maggior parte dei sistemi, potreste non averlo.
Se è così, basterà eseguire il comando <c>emerge iptables</c>.
</note>

<pre caption="Configurare iptables">
<comment>Prima di tutto eliminiamo le regole attualmente in uso</comment>
# <i>iptables -F</i>
# <i>iptables -t nat -F</i>

<comment>Configurare regole di default per gestire il traffico</comment>
# <i>iptables -P INPUT ACCEPT</i>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P FORWARD DROP</i>

<comment>Potete semplicemente copiare ed incollare questi esempi</comment>
# <i>export LAN=eth0</i>
# <i>export WAN=eth1</i>

<comment>Limitiamo i nostri servizio affinchè funzionino solo dalla LAN</comment>
# <i>iptables -I INPUT 1 -i ${LAN} -j ACCEPT</i>
# <i>iptables -I INPUT 1 -i lo -j ACCEPT</i>
# <i>iptables -A INPUT -p UDP --dport bootps -i ! ${LAN} -j REJECT</i>
# <i>iptables -A INPUT -p UDP --dport domain -i ! ${LAN} -j REJECT</i>

<comment>(Opzionale) Abilitare l'accesso al server ssh dalla WAN</comment>
# <i>iptables -A INPUT -p TCP --dport ssh -i ${WAN} -j ACCEPT</i>

<comment>Limitare i pacchetti TCP/UDP solo alle porte privilegiate (0-1023)</comment>
# <i>iptables -A INPUT -p TCP -i ! ${LAN} -d 0/0 --dport 0:1023 -j DROP</i>
# <i>iptables -A INPUT -p UDP -i ! ${LAN} -d 0/0 --dport 0:1023 -j DROP</i>

<comment>Infine abilitiamo NAT</comment>
# <i>iptables -I FORWARD -i ${LAN} -d 192.168.0.0/255.255.0.0 -j DROP</i>
# <i>iptables -A FORWARD -i ${LAN} -s 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -A FORWARD -i ${WAN} -d 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -t nat -A POSTROUTING -o ${WAN} -j MASQUERADE</i>
<comment>Comunichiamo al kernel che l`ip forwarding è funzionante</comment>
# <i>echo 1 > /proc/sys/net/ipv4/ip_forward</i>
# <i>for f in /proc/sys/net/ipv4/conf/*/rp_filter ; do echo 1 > $f ; done</i>

<comment>Evitiamo di dover riscrivere le regole di iptables ogni volta che ci connettiamo</comment>
# <i>/etc/init.d/iptables save</i>
# <i>rc-update add iptables default</i>
# <i>nano /etc/sysctl.conf</i>
<comment>Aggiungere le righe seguenti:
net.ipv4.ip_forward = 1
net.ipv4.conf.default.rp_filter = 1</comment>
</pre>

<p>
Una volta finito, il resto della vostra rete dovrebbe essere in grado di
connettersi ad internet e di usarlo come se fossero collegati direttamente
alla WAN.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Qualcosa di divertente (da fare nelle giornate di pioggia)</title>

<section>
<title>Introduzione</title>
<body>

<p>
Che ci crediate o no, avete finito :). Da qui in avanti descriveremo qualcosa
che potrebbe interessarvi e che è facile incontrare tra le funzionalità di
un router. Tutto, in questo capitolo, è completamente opzionale.
</p>

</body>
</section>

<section>
<title>Port Forwarding (Reindirizzamento delle/alle Porte)</title>
<body>

<p>
A volte si possono voler offrire alcuni servizi da computer che sono dietro il
router (ovvero all'interno della LAN) oppure semplicemente rendersi la vita
più semplice quando ci si connette da remoto. Probabilmente vorrete eseguire un
server FTP, HTTP, SSH, o VNC in una o più macchine dietro il router ed essere
in grado di connettervi a tutte. L`unico problema è che solo un servizio e solo
un computer possono essere collegati ad una specifica porta. Per esempio, non
c`è modo per installare tre server FTP dietro il router e poi connettersi a tutti
e tre tramite la porta 21; solo uno potrà ascoltare sulla porta 21, mentre gli
altri dovranno ascoltare, per esempio, sulle porte 123 e 567.
</p>

<p>
Tutte le regole di port forwarding hanno questa forma: <c>iptables -t nat -A
PREROUTING [-p protocollo] --dport [porta del router] -i ${WAN} -j DNAT --to
[ip/porta del pc nella LAN]</c>. Sfortunatamente, iptables non accetta hostname nelle regole
di port forwarding. Se state effettuando il forwarding da una porta esterna
(quella del router) uguale a quella interna (quella del pc nella LAN), potrete
omettere la porta di destinazione. Per ulteriori informazioni si può consultare
la pagina di manuale di iptables: iptables(8).
</p>

<pre caption="Eseguire iptables">
<comment>Potete semplicemente copiare ed incollare questi esempi</comment>
# <i>export LAN=eth0</i>
# <i>export WAN=eth1</i>

<comment>Reindirizzare la porta 2 a un demone ssh di un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 2 -i ${WAN} -j DNAT --to 192.168.0.2:22</i>

<comment>Reindirizzare la porta 21 (ftp) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 21 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Reindirizzare la porta 80 (http) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Reindirizzare due porte adibite a servizio VNC a due host della lan</comment>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5900 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5901 -i ${WAN} -j DNAT --to 192.168.0.3:5900</i>

<comment>Reindirizzare il range di porte 6881-6889 (bittorrent) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 6881:6889 -i ${WAN} -j DNAT --to 192.168.0.2</i>

<comment>Forwarding eDonkey/eMule</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 4662 -i ${WAN} -j DNAT --to 192.168.0.55</i>

<comment>Aggiungiamo il supporto al "Game Cube Warp"</comment>
# <i>iptables -t nat -A PREROUTING -p udp --dport 4000 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Aggiungiamo il supporto a "Playstation2 OnLine"</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 10070:10080 -i ${WAN} -j DNAT --to 192.168.0.11</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 10070:10080 -i ${WAN} -j DNAT --to 192.168.0.11</i>

<comment>Xbox Live</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 3074 -i ${WAN} -j DNAT --to 192.168.0.69</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 3074 -i ${WAN} -j DNAT --to 192.168.0.69</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 88 -i ${WAN} -j DNAT --to 192.168.0.69</i>
</pre>

<note>
Se avete altri esempi frequenti, <mail link="vapier@gentoo.org">
scrivetemi una mail.</mail>
</note>

</body>
</section>

<section>
<title>Il demone identd (per IRC)</title>
<body>

<p>
Il protocollo IRC (Internet Relay Chat) utilizza molto spesso il servizio
ident. Ora che i client IRC sono dietro il router, abbiamo bisogno di un
modo per raccogliere gli "ident" sia del router che dei client. Per fare
ciò è stato creato un server chiamato <c>midentd</c>
</p>

<pre caption="Configurare ident">
# <i>emerge midentd</i>
# <i>rc-update add midentd default</i>
# <i>/etc/init.d/midentd start</i>
</pre>

<p>
Ci sono alcuni altri server ident nel portage di Gentoo. A secondo dei
vostri bisogni, potete dare anche un`occhiata ad <c>oidentd</c> e
<c>fakeidentd</c>.
</p>

</body>
</section>


<!--***********************************************************************************************
     La parte commentata non è stata tradotta. Mandate una mail al traduttore (cristiano.chiucchiolo@gmail.com)
     se avete assoluta necessità di una traduzione di questa parte
************************************************************************************************-->

<!--
<section>
<title>Traffic Shaping</title>
<body>
<p>
This is an attempt to simply and Gentooify the <uri link="http://www.tldp.org/HOWTO/ADSL-Bandwidth-Management-HOWTO/">ADSL Bandwidth Management HOWTO</uri> 
found over at the TLDP.  Feel free to refer to the original document 
for more details.
</p>

<p>
Here we will be setting up what some people refer to as a "Packet Shaper", 
<uri link="http://en.wikipedia.org/wiki/Traffic_shaping">"Traffic Shaping"</uri>, 
or <uri link="http://en.wikipedia.org/wiki/QoS">"Quality of Service"</uri>.  
Simply put, we want to setup rules on our router that will slow down 
certain activities (like sending large e-mails or downloading from P2P 
networks) while keeping other activities (like browsing the web or playing 
online video games) reasonably fast.  A 30 second difference in a video 
game is a lot worse than a 30 second difference in downloading large 
files :).
</p>

<p>
The first thing is to make sure your kernel has all the features added to 
it.  See the chapter on <uri link="#doc_chap2">Kernel setup</uri> for more 
information.  Next, you will need to <c>emerge iptables iputils</c> so that 
you will have access to the <c>iptables</c>, <c>ip</c>, and <c>tc</c> 
commands.
</p>

<p>
Before we jump into the commands, let's cover a little of the theory.  The 
way this whole system works is to classify common network streams and then 
to prioritize them.  You use iptables to classify network streams, iputils 
to define the different priority levels, and the kernel to adjust speeds.  
Just remember that although you can control outbound traffic pretty tightly 
(from the LAN to the WAN), your ability to control inbound traffic (from 
the WAN to the LAN) is somewhat limited.  Just remember that the following 
examples are to get your feet wet; if you want more then I'd suggest 
reading up on the subject.  In this example, we will be using the 
<uri link="http://luxik.cdi.cz/~devik/qos/htb/">Hierarchical Token Buckets (HTB)</uri> 
packet scheduling algorithm.  Still with me?  Great, let's start shaping :).
</p>

<pre caption="Setup">
DEV=eth1 <comment>NIC connected to WAN</comment>
RATE_OUT=100 <comment>Available outbound bandwidth (in kilobits [kb])</comment>
RATE_IN=1400 <comment>Available inbound bandwidth (in kb)</comment>

<comment>Here we initialize the priority system.  The 45 is used to set the default classification level.</comment>
ip link set dev ${DEV} qlen 30
tc qdisc add dev ${DEV} root handle 1: htb default 45
tc class add dev ${DEV} parent 1: classid 1:1 htb rate ${RATE_OUT}kbit
</pre>

<p>
Here we initialized the system which will be used to prioritize all of 
our network traffic.  We created our queue, told it to use the HTB 
algorithm, and set the default classification level to '45'.  The 
default is completely arbitrary, as are the levels we choose from 
here on out.  The only thing that matters is how the levels compare 
relatively; a level '10' packet will be given preference over a 
level '45' packet.  Let's move on to declaring different levels.
</p>

<pre caption="Declaring levels">
tc class add dev $DEV parent 1:1 classid 1:10 htb rate $rkbit ceil $tkbit prio $p
tc qdisc add dev $DEV parent 1:10 handle 10: sfq
</pre>
</body>
</section>
-->

<section>
<title>Time Server</title>
<body>

<p>
Avere sempre un orologio di sistema sincronizzato è essenziale per mantenere
un sistema correttamente. Uno dei modi più comuni per farlo è usare il
Network Time Protocol (NTP) e il pacchetto "ntp", che fornisce sia
l'implementazione lato client che quella lato server.
</p>

<p>
Molte persone usano dei client ntp nei loro pc. Ovviamente, più client ci sono,
più grandi sono i carichi di lavoro che i server devono gestire. In situazioni
come quella di una rete casalinga però, è possibile diminuire questo carico di
lavoro ai server pubblici pur fornendo un risultato accurato e veloce ai nostri
host. Tutto quello che dobbiamo fare è eseguire nel router un server ntp che si
sincronizza con un server pubblico e poi fornisce l`ora esatta al resto degli
host nella LAN. Per cominciare, diamo il comando <c>emerge ntp</c>.
</p>

<pre caption="Configurare il server NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Potete configurarlo, ma i valori di default dovrebbero essere corretti</comment>
# <i>rc-update add ntp-client default</i>

# <i>nano /etc/ntp.conf</i>
<comment>Aggiungete queste righe:</comment>
restrict default ignore
restrict 192.168.0.0 mask 255.255.255.0 notrust nomodify notrap
<comment>Questo permettera di accedere al vostro server solo dagli host della LAN</comment>
# <i>nano /etc/conf.d/ntpd</i>
<comment>Potete configurarlo, ma i valori di default dovrebbero essere corretti</comment>
# <i>rc-update add ntpd default</i>

# <i>/etc/init.d/ntp-client start</i>
# <i>/etc/init.d/ntpd start</i>
</pre>

<note>
Assicuratevi che avete abilitato il traffico in entrata ed in uscita alla porta
ntp (123/udp) del server. Per i client sarà sufficiente l'abilitazione per il
traffico in uscita, sempre sulla stessa porta.
</note>

<p>
Ora, date il comando <c>emerge ntp</c> anche sui pc client. In questo caso la
configurazione dovrebbe essere più semplice, perchè abiliterete soltanto il client
</p>

<pre caption="Configurare un client NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Cambiate il nome del server da 'pool.ntp.org' a '192.168.0.1' nella variabile NTPCLIENT_OPTS</comment>
# <i>rc-update add ntp-client default</i>
# <i>/etc/init.d/ntp-client start</i>
</pre>

</body>
</section>

<section>
<title>Server Rsync</title>
<body>

<p>
Per reti in cui c`è più di una macchina con Gentoo, vi potrà capitare
spesso di usare il comando <c>emerge sync</c> con un server remoto.
Potrete risparmiare la vostra banda e quella dei server di Gentoo usando
un singolo server rsync locale. E` davvero semplice farlo.
</p>
<note>
Per una guida più approfondita su rsync, consultate la
<uri link="/doc/it/rsync.xml#doc_chap4">guida su rsync</uri> ufficiale.
</note>

<p>
Dal momento che ogni pc con Gentoo richiede rsync nativamente, non c`è
bisogno di emergerlo. Basterà cambiare il file di configurazione
<path>/etc/rsyncd.conf</path>, rimuovendo i commenti dalla sezione
<c>[gentoo-portage]</c> ed assicurandosi di aggiungere un`opzione
<c>address</c>. Tutte le altre impostazioni di default dovrebbero andare
bene.
</p>

<pre caption="File di configurazione del server rsync">
pid file = /var/run/rsyncd.pid
use chroot = yes
read only = yes
address = 192.168.0.1

[gentoo-portage]
	path = /mnt/space/portage
	comment = Gentoo Linux Portage tree
	exclude = /distfiles /packages
</pre>

<p>
Ora dovrete avviare il servizio.
</p>

<pre caption="Avviare il server rsync">
# <i>/etc/init.d/rsyncd start</i>
# <i>rc-update add rsyncd default</i>
</pre>

<p>
L`unica cosa che rimane da fare è configurare i client affinchè si
colleghino all`IP del router.
</p>

<pre caption="Configurazione dei client in make.conf">
SYNC="rsync://192.168.0.1/gentoo-portage"
</pre>

</body>
</section>

<section>
<title>Server Mail</title>
<body>

<p>
A volte può essere utile avere un proprio semplice server SMTP (Simple Mail
Transfer Protocol) che gira sul router. Potreste avere qualsiasi ragione per
farlo, ma io lo faccio perchè gli utenti vedano la loro mail come inviata
instantaneamente, mentre tutto il lavoro è lasciato al server mail.
Oltretutto, alcuni ISP, come Verizon, non accettano mail relaying (ovvero non
vi permettono di usare i loro server smtp) se non avete un account della loro
rete. Ancora, potrete regolare l`invio della mail in modo che gli allegati
grandi non creino ritardo nella vostra connessione per mezz`ora.
</p>

<pre caption="Configurare SMTP">
# <i>emerge qmail</i>
<comment>Assicurarsi che l`output di 'hostname' sia corretto</comment>
# <i>ebuild /var/db/pkg/*-*/qmail-1.03-r*/*.ebuild config</i>
# <i>iptables -I INPUT -p tcp --dport smtp -i ! ${LAN} -j REJECT</i>
# <i>ln -s /var/qmail/supervise/qmail-send /service/qmail-send</i>
# <i>ln -s /var/qmail/supervise/qmail-smtpd /service/qmail-smtpd</i>
<!--
# <i>cd /etc/tcprules.d</i>
# <i>nano tcp.qmail-smtp</i>
-->
# <i>cd /etc</i>
# <i>nano tcp.smtp</i>
<comment>Aggiungere una riga come questa alla sezione "Allow":</comment>
192.168.0.:allow,RELAYCLIENT=""
<!--
# <i>tcprules tcp.qmail-qmtp.cdb rules.tmp &lt; tcp.qmail-smtp</i>
-->
# <i>tcprules tcp.smtp.cdb rules.tmp &lt; tcp.smtp</i>
# <i>rc-update add svscan default</i>
# <i>/etc/init.d/svscan start</i>
</pre>

<p>
Io sono un grande fan di qmail, ma siete liberi di scegliere un altro mta :).
Quando configurate gli account e-mail negli host della vostra rete, impostate
il server SMTP in modo che sia 192.168.0.1 e tutto dovrebbe funzionare. Per
ulteriore documentazione, potete visitare <uri link="http://qmail.org/">
l`homepage di qmail</uri>.
</p>

</body>
</section>

<!--***********************************************************************************************
     La parte commentata non è stata tradotta. Mandate una mail al traduttore (cristiano.chiucchiolo@gmail.com)
     se avete assoluta necessità di una traduzione di questa parte
************************************************************************************************-->

<!--
<section>
<title>E-mail Virus Scanning</title>
<body>
<p>
If you'd like to provide e-mail virus scanning for your users, but 
don't want to have to install a virus scanner on every single machine, 
then <c>pop3vscan</c> may just be the thing for you; a transparent 
Post Office Protocol (POP) scanner.
</p>

<pre caption="Setting up pop3vscan">
TODO
</pre>

</body>
</section>
-->

<section>
<title>Server DHCP Completo</title>
<body>
	
<p>
Prima abbiamo usato dnsmasq per fornire il servizio DHCP a tutti i nostri client. Per la maggiorparte delle persone con una semplice, piccola LAN, questa soluzione è perfetta. Tuttavia, potreste anche avere bisogno di qualcosa con più funzioni. Per questo ci spostiamo a un server DHCP completo in tutto, fornito dal team <uri link="http://www.isc.org/products/DHCP">ISC</uri>.
</p>

<pre caption="Installare dhcpd">
	# <i>emerge dhcp</i>
	# <i>nano /etc/dhcp/dhcpd.conf</i>
	<comment>(Ecco un esempio di file di configurazione:)</comment>
	authoritative;
	ddns-update-style interim;
	subnet 192.168.0.0 netmask 255.255.255.0 {
	range 192.168.0.100 192.168.0.250;
	default-lease-time 259200;
	max-lease-time 518400;
	option subnet-mask 255.255.255.0;
	option broadcast-address 192.168.0.255;
	option routers 192.168.0.1;
	option domain-name-servers 192.168.0.1;
	}
	# <i>nano /etc/conf.d/dhcp</i>
	<comment>(Impostare IFACE="eth0")</comment>
	# <i>rc-update add dhcp default</i>
	# <i>/etc/init.d/dhcp start</i>
  	 </pre>
	 
<p>
Questa è la configurazione minima richiesta per rimpiazzare le funzioni DHCP di dnsmasq che abbiamo usato prima. A proposito, vi siete ricordati di disattivare le funzioni DHCP in dnsmasq, vero? Se non lo avete fatto, dovreste farlo ora (basta commentare l'impostazone <c>dhcp-range</c> in <path>/etc/dnsmasq.conf</path> e riavviare il servizio).
</p>

</body>
</section>

<section>
<title>Connettere un'altra LAN (o due, tre,...)</title>
<body>
	
<p>
A volte potreste avere la necessità di connettere il vostro router ad un'altra LAN. Potreste volervi collegare temporaneamente ad un gruppo di amici, oppure potreste essere degli smanettoni che vogliono sezionare gruppi diversi di computer, o forse siete solo molto annoiati. Qualunque siano le ragioni, estendere il router ad un'altra LAN dovrebbe essere abbastanza semplice. Negli esempi seguenti, daremo per scontato che questa nuova rete sia collegata attraverso una terza scheda ethernet, che chiameremo <c>eth2</c>.
</p>

<p>
Per prima cosa, dovete configurare l'interfaccia. Usate le istrizioni nel<uri link="#doc_chap4_pre1">listato di codice 4.1</uri>, sostituendo <c>eth0</c> con <c>eth2</c> e <c>192.168.0</c> con <c>192.168.1</c>.
</p>

<p>
Fatto ciò, dovete configurare dnsmasq affinché fornisca i suoi servizi alla nuova interfaccia. Editate di nuovo il file <path>/etc/conf.d/dnsmasq</path>, aggiungendo <c>-i eth2</c> a DNSMASQ_OPTS; si può usare -i più volte. Poi editate <path>/etc/dnsmasq.conf</path> e aggiungete un'altra riga come quella del dhcp-range nel <uri link="#doc_chap5_pre1">listato di codice 5.1</uri>, sostituendo <c>192.168.0</c> con <c>192.168.1</c>. Si possiono avere anche più righe dhcp-range.
</p>

<p>
Per finire, guardate le regole nel <uri link="#doc_chap5_pre2">listato di codice 5.2</uri>, e duplicate le regole che contengono <c>-i ${LAN}</c>. Per rendere le cose più semplici potreste creare un'altra variabile, chiamandola ad esempio <c>LAN2</c>.
</p>

</body>
</section>

</chapter>

<chapter>
<title>Risoluzione dei problemi</title>

<section>
<title>Strumenti utili</title>
<body>

<p>
Se state avendo qualche problema nel mettere in comunicazione i vostri
computer, potreste trovare utili i seguenti strumenti (possono essere trovati
tutti nella categoria <c>net-analyzer</c> di portage):
</p>

<table>
<tr>
  <th>Strumento</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>ethereal</ti>
  <ti>Strumento grafico per visualizzare tutto il traffico di rete grezzo secondo alcuni filtri</ti>
</tr>
<tr>
  <ti>tcpdump</ti>
  <ti>Uno strumento da consolle per intercettare il traffico di rete grezzo secondo alcuni filtri</ti>
</tr>
<tr>
  <ti>iptraf</ti>
  <ti>Monitor IP per la LAN, basato su le librerie ncurses</ti>
</tr>
<tr>
  <ti>ettercap</ti>
  <ti>Monitor/Controllore di rete, bassato sulle librerie ncurses</ti>
</tr>
</table>

</body>
</section>

<section>
<title>DHCP non parte</title>
<body>

<p>
Quando lanciate lo script init.d di dhcp per la prima volta, potrebbe fallire
nel caricarsi senza fornire alcuna informazione utile.
</p>

<pre caption="Esempio di fallimento di DHCP">
# <i>/etc/init.d/dhcp start</i>
 * Setting ownership on dhcp.leases ...          [ ok ]
 * Starting dhcpd ...                            [ !! ]
</pre>

<p>
Il trucco sta nello scoprire dove il demone dhcpd invii il suo output. Basta
semplicemente posizionarsi su <path>/var/log</path> e leggere i file di log.
Dal momento che il file dipende da quale syslog si sta usando, lanciare il
comando <c>grep -Rl dhcpd /var/log</c> per trovare il file esatto. La causa
che ha generato l`errore probabilmente è un errore nel file di configurazione.
Potete anche provare a lanciare <c>dhcpd -d -f</c> ed effettuare il debug
degli errori basandovi sull`output.
</p>

</body>
</section>

<section>
<title>Valore dell`MTU sbagliato</title>
<body>

<p>
Se occasionalmente vi si presentano degli errori (come il non visualizzare
alcune pagine web, mentre altre si visualizzano correttamente), si
potrebbero avere problemi di "Path MTU Discovery". Il modo più veloce per
scoprirlo è lanciare iptables:
</p>

<pre caption="Impedire problemi di MTU">
# <i>iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</i>
</pre>

<p>
Questo avrà effetto solo sulle nuove connessioni, quindi ricaricate la
pagina web che presentava problemi per verificare. Nel caso sia d`aiuto,
il valore MTU standard per connessioni ethernet a 100Mb è <c>1500</c>,
mentre per le connessioni PPPoE è <c>1492</c>. Per ulteriori informazioni
si può consultare il capitolo 15 della guida
"<uri link="http://lartc.org/howto/">Linux Advanced Routing &amp; Traffic
Control HOWTO</uri>.
</p>

</body>
</section>

</chapter>

<chapter>
<title>Note Finali</title>
<section>
<body>

<p>
Non ci sono note finali, tranne una. Se avete qualsiasi problema con la guida, per
favore contattate <mail link="vapier@gentoo.org">me</mail> o segnalate un bug
<uri link="http://bugs.gentoo.org/">qui</uri>. Se avete qualche pezzo
interessante che credete possa migliorare questa guida, mandatemelo per vederlo
incluso.
</p>

</body>
</section>
</chapter>
</guide>