<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/home-router-howto.xml,v 1.11 2009/09/29 19:30:18 scen Exp $ -->

<guide link="/doc/it/home-router-howto.xml" lang="it">
<title>Configurare un Router domestico</title>

<author title="Autore">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Traduzione">
  <mail link="alberto@lagnusi.net">Alberto Santini</mail>
</author>
<author title="Traduzione">
  <mail link="cristiano.chiucchiolo@gmail.com">Cristiano Chiucchiolo</mail>
</author>
<author title="Traduzione">
  <mail link="menegolo_andrea@yahoo.it">Andrea Menegolo</mail>
</author>

<abstract>
In questo documento viene spiegato come trasformare una vecchia macchina, su cui
è installato Gentoo, in un router domestico per collegare tutta la casa ad
Internet.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.40</version>
<date>2009-09-18</date>

<chapter>
<title>Introduzione</title>
<section>
<body>

<p>
Costruire il proprio router partendo da vecchi pezzi di PC ha molti vantaggi
rispetto al comprare un router di marca, ad esempio un Linksys. Il primo di
questi vantaggi è l'avere un controllo completo sulla connessione. Gli altri si
possono immaginare; si può realizzare praticamente qualsiasi cosa in questo
modo, basta ve ne sia la necessità.
</p>

<p>
Questa guida mostrerà come attivare un servizio di NAT ("Network Address
Translation" - ndT: "Traduzione Indirizzo di Rete") configurando il kernel ed
iptables, come fornire ed impostare alcuni tra i servizi più comuni: DNS (Domain
Name System) attraverso dnsmasq, DHCP (Dynamic Host Configuration Protocol)
attraverso dhcpd, ADSL (Asymmetric Digital Subscriber Line) attraverso ppp. Alla
fine, si concluderà con qualcosa di più sofisticato e divertente (port
forwarding, regolazione del traffico di dati, impostazione di proxy/caching,
ecc...).
</p>

<p>
Prima di cominciare, è bene assicurarsi che il proprio PC soddisfi una serie di
requisiti. Innanzitutto devono essere presenti almeno due schede di rete nel
computer. Inoltre bisogna conoscere le impostazioni della propria connessione ad
Internet (ad esempio gli indirizzi IP/DNS/GateWay e username/password). Infine,
c'è bisogno di un po' di tempo libero e di simpatia verso Gentoo.
</p>

<p>
Questa guida si basa sulla seguente configurazione tipo:
</p>

<ul>
  <li>eth0 - Scheda di rete connessa alla propria LAN (Local Area Network)</li>
  <li>eth1 - Scheda di rete connessa alla WAN (Wide Area Network)</li>
  <li>La LAN utilizza il set 192.168.0.xxx di IP privati</li>
  <li>L'IP del router è quello standard (192.168.0.1)</li>
  <li>Sul router viene eseguito Linux 2.4 o 2.6 - Con Linux 2.0 o 2.2 bisogna
    fare da sé
  </li>
</ul>

<impo>
Per motivi di sicurezza, si consiglia vivamente di disattivare sul router tutti
i servizi che non sono necessari finché non si disporrà di un firewall
configurato e attivo. Per vedere i servizi attivi, usare il comando
<c>rc-status</c>.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione del kernel</title>
<section>
<body>

<p>
Come prima cosa, il kernel ha bisogno dei driver per entrambe le schede di rete.
Per vedere se le schede sono già state correttamente riconosciute dal kernel, si
può usare il comando <c>ifconfig</c>. Il proprio output può essere diverso da
quello che segue, ma questo non ha importanza: quello che conta è che siano
mostrate entrambe le interfacce di rete.
</p>

<pre caption="Controllare le schede di rete">
# <i>ifconfig -a</i>
eth0      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B8
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x9800

eth1      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B9
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:10 Base address:0x9400
</pre>

<p>
Se non si vede una o entrambe le schede di rete e non si sa che tipo di schede
sono, si può provare a lanciare il comando <c>lspci | grep Ethernet</c>. Nel
caso in cui <c>lspci</c> non sia installato nel proprio sistema, eseguire il
comando <c>emerge pciutils</c>. Appena ottenute le informazioni necessarie,
ricompilare il kernel attivando il supporto per le proprie schede di rete.
</p>

<p>
Il secondo requisito è il supporto ad iptables, per il NAT e per il controllo
del traffico (se lo si vuole attivare). Nella lista che segue le opzioni sempre
richieste sono segnate con (*), quelle richieste solo per l'ADSL via PPPoE sono
segnate con (a), quelle consigliate a tutti con (x) e quelle per il controllo
del traffico con (s). Non importa se si sceglie di compilare questi supporti
direttamente nel kernel o come moduli, purché questi ultimi siano comunque
caricati non appena ce ne sia bisogno.
</p>

<pre caption="Opzioni di rete">
Networking options  ---&gt;
   [*] TCP/IP networking
      [*] IP: advanced router
   [*] Network packet filtering (replaces ipchains)
<comment>Se si usa un kernel 2.4.x., per DHCP bisogna abilitare la seguente voce:</comment>
   [*] Socket Filtering

   IP: Netfilter Configuration  ---&gt;
      [*] Connection tracking (required for masq/NAT)
         [x] FTP protocol support
         [x] IRC protocol support
      [*] IP tables support (required for filtering/masq/NAT)
         [*] IP range match support
         [x] MAC address match support
         [*] Multiple port match support
         [*] Packet filtering
            [*] REJECT target support
            [x] REDIRECT target support
         [*] Full NAT
            [*] MASQUERADE target support
         [s] Packet mangling
            [s] MARK target support
         [x] LOG target support

   QoS and/or fair queueing  ---&gt;
      [s] QoS and/or fair queueing
         [s] HTB packet scheduler
         [s] Ingress Qdisc

      [a] PPP (point-to-point protocol) support
         [a] PPP filtering
         [a] PPP support for async serial ports
         [a] PPP support for sync tty ports
         [a] PPP Deflate compression
         [a] PPP BSD-Compress compression
         [a] PPP over Ethernet
</pre>

<note>
È possibile che vi siano differenze tra i kernel 2.4 e 2.6, ma si dovrebbe
essere in grado di venirne a capo da soli senza difficoltà. Inoltre, per il
kernel 2.6, queste opzioni hanno la tendenza ad essere spostate
frequentemente. Buona fortuna!
</note>

</body>
</section>
</chapter>

<chapter>
<title>Collegarsi alla WAN (ovvero ad Internet)</title>

<section>
<title>Introduzione</title>
<body>

<p>
Ci sono moltissimi modi di connettersi ad Internet, quindi questa guida tratterà
soltanto quelli usati dall'autore ovvero un collegamento ADSL (PPPoE) e uno con
modem telefonico (con IP statico o dinamico). Se si conoscono altri metodi,
mettere al corrente l'autore inviandogli una mail. Saltare senza problemi
qualsiasi delle seguenti sezioni di questo capitolo, se non sono di
interesse. Lo scopo di questo capitolo è di connettere il router ad Internet
attraverso eth1.
</p>

</body>
</section>
<section>
<title>ADSL e PPPoE</title>
<body>

<p>
Tutto il software prodotto riguardante PPPoE che era fornito dal pacchetto
rp-pppoe (<uri link="http://www.roaringpenguin.com/">Roaring Penguin</uri>) è
stato integrato nel <uri link="http://samba.org/ppp/">pacchetto standard di
PPP</uri>. Quindi basta eseguire il comando <c>emerge ppp</c> per avere tutto il
necessario. Adesso è necessario recuperare le informazioni relative a username e
password, come annunciato in precedenza. Aprire il file
<path>/etc/conf.d/net</path> nel proprio editor preferito e modificare i
parametri in maniera appropriata.
</p>

<note>
È necessario sia installato baselayout-1.12.9 o superiore per far sì che la
seguente configurazione funzioni correttamente.
</note>

<pre caption="Configurare eth1">
<comment>(Sostituire 'pluto' con il proprio username e 'pippo' con la propria password)</comment>

# <i>nano /etc/conf.d/net</i>
<comment>Dire a baselayout di usare l'ADSL attraverso eth1 per ppp0</comment>
config_ppp0=( "ppp" )
link_ppp0="eth1"
plugins_ppp0=( "pppoe" )
pppd_ppp0=(
        "defaultroute"
        "usepeerdns"
        <comment>Per eventuali altre impostazioni, vedere il file /etc/conf.d/net.example per maggiori dettagli.</comment>
)
username_ppp0="pluto"
password_ppp0="pippo"

# <i>ln -s net.lo /etc/init.d/net.ppp0</i>
# <i>rc-update add net.ppp0 default</i>
# <i>/etc/init.d/net.ppp0 start</i>
</pre>

<warn>
Quando l'interfaccia DSL si attiva, sarà creato il device ppp0. Anche se la
scheda di rete è eth1, l'IP appartiene a ppp0. Da ora in avanti, negli esempi
che usano 'eth1', sostituire quest'ultima voce con 'ppp0'.
</warn>

<warn>
Assicurarsi di aver cambiato i permessi del file /etc/conf.d/net in modo che
solo root possa leggere/scrivere su di esso: in quel file infatti ci sono i
propri username e password.
</warn>

<warn>
Chi sta effettuando il passaggio dal pacchetto <c>rp-pppoe</c> e chi è vittima
di misteriose cadute della connessione, dovrebbe dare un'occhiata alla sezione
su MTU del capitolo sulla Risoluzione dei problemi.
</warn>

</body>
</section>

<section>
<title>Connessione attraverso linea telefonica e/o IP statico/dinamico</title>
<body>

<p>
Se si possiede un IP statico, ci sarà bisogno di conoscere qualche dettaglio in
più: il proprio indirizzo IP, il proprio gateway ed i server DNS.
</p>

<pre caption="Configurare eth1">
<comment>IP dinamico:</comment>
# <i>emerge dhcpcd</i>
# <i>nano /etc/conf.d/net</i>
<comment>Inserire una riga come questa:</comment>
config_eth1=( "dhcp" )

<comment>IP Statico:</comment>
# <i>nano /etc/conf.d/net</i>
<comment>Inserire delle righe come queste:</comment>
config_eth1=( "66.92.78.102 broadcast 66.92.78.255 netmask 255.255.255.0" )
routes_eth1=( "default gw 66.92.78.1" )
# <i>nano /etc/resolv.conf</i>
<comment>Aggiungere una riga per il server DNS:</comment>
nameserver 123.123.123.123

<comment>Configurazione sia per l'IP dinamico che statico:</comment>
# <i>ln -s net.lo /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<p>
Ora dovrebbe essere tutto configurato.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Collegarsi alla LAN</title>
<section>
<body>

<p>
Questo passaggio è molto più facile rispetto al precedente.
</p>

<pre caption="Configurare eth0">
# <i>nano /etc/conf.d/net</i>
<comment>Aggiungere una riga come questa:</comment>
config_eth0=( "192.168.0.1 broadcast 192.168.0.255 netmask 255.255.255.0" )
# <i>rc-update add net.eth0 default</i>
# <i>/etc/init.d/net.eth0 start</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Servizi LAN</title>
<section>
<title>Server DHCP</title>
<body>


<p>
<!-- Paragrafo ri-tradotto completamente, per dargli un tono maggiormente "im
personale"-->
<!--Scommetto che sarebbe bello se chiunque a casa tua potesse semplicemente
collegare i propri computer alla rete e tutto funzionasse subito. Non ci sarebbe
alcun bisogno di ricordare dettagli noiosi e difficili da memorizzare o di
inserirli in interfacce di configurazione confusionarie! Proprio una bella vita,
eh? Ti presento DHCP (Dynamic Host Configuration Protocol o Protocollo per la
Configurazione Dinamica degli Host) e vi spiego perché vi dovrebbe
interessare.-->
Un servizio molto utile, che evita di ricordare dettagli noiosi e difficili da
memorizzare o di doverli inserire in interfacce di configurazione confusionarie
è DHCP ("Dynamic Host Configuration Protocol" - ndT: "Protocollo per la
Configurazione Dinamica degli Host"), che permette un funzionamento immediato
dei computer non appena li si collega alla rete.
</p>

<p>
DHCP, come si può desumere dal nome, è un protocollo che consente di configurare
in modo dinamico gli altri host in maniera del tutto automatica. Basta far
girare il server DHCP sul router, passargli tutte le informazioni sulla propria
rete (indirizzi IP validi, server DNS, gateway, ecc...) e, quando gli altri host
si connetteranno alla rete, useranno il client DHCP per autoconfigurarsi. Niente
confusione né pasticci. Per maggiori informazioni sul DHCP, visitare
<uri link="http://it.wikipedia.org/wiki/DHCP">Wikipedia</uri>.
</p>

<p>
Verrà usato un pacchetto chiamato dnsmasq, che fornisce sia il servizio DHCP che
DNS. Per il momento ci si concentrerà sull'aspetto DHCP. Tenere presente che se
si vuole eseguire un diverso server DHCP, è possibile guardare un altro esempio
nel capitolo "Qualcosa di divertente". Inoltre, se si desiderano sperimentare le
opzioni del server DHCP, leggere i commenti del file
<path>/etc/dnsmasq.conf</path>. Ad ogni modo, le opzioni predefinite dovrebbero
andare bene.
</p>

<pre caption="Installare un server DHCP">
# <i>emerge dnsmasq</i>
# <i>nano /etc/dnsmasq.conf</i>
<comment>Aggiungere questa riga per attivare dhcp:</comment>
dhcp-range=192.168.0.100,192.168.0.250,72h
<comment>Restringere dnsmasq alla sola interfaccia LAN</comment>
interface=eth0

# <i>rc-update add dnsmasq default</i>
# <i>/etc/init.d/dnsmasq start</i>
</pre>

<p>
Ora il proprio router è un piccolo e affidabile server DHCP! Collegare alla rete
qualche computer ed osservare attentamente come tutto funziona in modo semplice!
Con un sistema MS Windows bisognerà andare nel pannello "Proprietà TCP/IP" e
selezionare le opzioni "Ottieni un indirizzo IP automaticamente" e "Ottieni
l'indirizzo del server DNS automaticamente". A volte queste modifiche non hanno
effetto immediato e si dovrà aprire una finestra di comando ed eseguire
<c>ipconfig /release</c> e <c>ipconfig /renew</c>. Ma ora basta con Windows, si
torna al nostro pinguino preferito.
</p>

</body>
</section>

<section>
<title>Server DNS</title>
<body>

<p>
Quando qualcuno vuole visitare un sito web o raggiungere un altro host su
Internet, solitamente si ricorda del nome di quel sito, piuttosto che di una
stringa di numeri. Dopotutto è più facile ricordare "ebay.com" o 66.135.192.87?
Ecco dove entra in gioco il DNS. I server DNS girano più o meno ovunque su
internet e non appena qualcuno vuole visitare ebay.com, questi server
trasformano "ebay.com" (di facile comprensione per l'utente) in "66.135.192.87"
(di facile comprensione per il computer). Per maggiori informazioni sul DNS,
visitare nuovamente
<uri link="http://it.wikipedia.org/wiki/DNS">Wikipedia</uri>.
</p>

<p>
Visto che si sta utilizzando dnsmasq come server DHCP ed esso include un server
DNS, non resta più niente da fare qui! Il proprio router sta già fornendo il
servizio DNS ai suoi client DHCP.
</p>

<p>
Si può benissimo scegliere altri server DNS se ci si trova meglio con quelli, ma
il motivo per cui dnsmasq è grandioso è che fa esattamente quello che si vuole e
niente di più. È un piccolo server per reti locali con funzionalità di caching e
forwarding. Non si vuole offrire un DNS per un proprio dominio, ma soltanto un
servizio DNS di base a chiunque si trovi nella vostra LAN.
</p>

</body>
</section>

<section>
<title>NAT (ovvero IP-masquerading)</title>
<body>

<p>
In questo momento, le persone nella vostra rete possono comunicare fra di loro e
possono collegarsi a degli hostname tramite DNS, ma non possono ancora
connettersi realmente ad internet.
</p>

<p>
Ecco dove entra in scena il Network Address Translation (NAT). NAT permette di
connettere più computer in una LAN ad Internet, quando si hanno a disposizione
un numero minore di indirizzi IP. Tipicamente la compagnia telefonica offre ad
ogni utente un solo IP, ma in questa situazione si vuole che tutta la casa sia
connessa ad internet. NAT è la magia che rende possibile tutto ciò. Anche in
questo caso, maggiori informazioni circa NAT possono essere trovate su
<uri link="http://it.wikipedia.org/wiki/Network_address_translation">Wikipedia</uri>
</p>

<note>
Prima di cominciare, assicurarsi che iptables sia installato nel proprio
sistema.  Potrebbe non essere presente nonostante sia installato automaticamente
nella maggior parte dei sistemi; per risolvere basterà eseguire il comando
<c>emerge iptables</c>.
</note>

<pre caption="Configurare iptables">
<comment>Prima di tutto eliminare le regole attualmente in uso</comment>
# <i>iptables -F</i>
# <i>iptables -t nat -F</i>

<comment>Configurare le regole predefinite per gestire il traffico</comment>
# <i>iptables -P INPUT ACCEPT</i>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P FORWARD DROP</i>

<comment>Si possono semplicemente copiare ed incollare questi esempi</comment>
# <i>export LAN=eth0</i>
# <i>export WAN=eth1</i>

<comment>Limitare i propri servizi affinché funzionino solo dalla LAN</comment>
# <i>iptables -I INPUT 1 -i ${LAN} -j ACCEPT</i>
# <i>iptables -I INPUT 1 -i lo -j ACCEPT</i>
# <i>iptables -A INPUT -p UDP --dport bootps ! -i ${LAN} -j REJECT</i>
# <i>iptables -A INPUT -p UDP --dport domain ! -i ${LAN} -j REJECT</i>

<comment>(Opzionale) Abilitare l'accesso al server ssh dalla WAN</comment>
# <i>iptables -A INPUT -p TCP --dport ssh -i ${WAN} -j ACCEPT</i>

<comment>Limitare i pacchetti TCP/UDP solo alle porte privilegiate (0-1023)</comment>
# <i>iptables -A INPUT -p TCP ! -i ${LAN} -d 0/0 --dport 0:1023 -j DROP</i>
# <i>iptables -A INPUT -p UDP ! -i ${LAN} -d 0/0 --dport 0:1023 -j DROP</i>

<comment>Infine abilitare il NAT</comment>
# <i>iptables -I FORWARD -i ${LAN} -d 192.168.0.0/255.255.0.0 -j DROP</i>
# <i>iptables -A FORWARD -i ${LAN} -s 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -A FORWARD -i ${WAN} -d 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -t nat -A POSTROUTING -o ${WAN} -j MASQUERADE</i>
<comment>Comunicare al kernel che l'ip forwarding è funzionante</comment>
# <i>echo 1 > /proc/sys/net/ipv4/ip_forward</i>
# <i>for f in /proc/sys/net/ipv4/conf/*/rp_filter ; do echo 1 > $f ; done</i>

<comment>Salvare le regole inserite: verranno ripristinate all'avvio del PC</comment>
# <i>/etc/init.d/iptables save</i>
# <i>rc-update add iptables default</i>
# <i>nano /etc/sysctl.conf</i>
<comment>Aggiungere/decommentare le righe seguenti:</comment>
net.ipv4.ip_forward = 1
net.ipv4.conf.default.rp_filter = 1

<comment>Se si possiede un indirizzo IP dinamico, probabilmente si vorrà questa opzione:</comment>
net.ipv4.ip_dynaddr = 1
</pre>

<p>
Una volta finito, tutti i computer della propria rete dovrebbero essere in grado
di connettersi ad internet e di usarla come se fossero collegati direttamente
alla WAN.
</p>

<p>
L'opzione ip_dynaddr è utile per sistemi con collegamento su richiesta
(on-demand) o quando il proprio ISP fornisce indirizzi dinamici. Questo risolve
il problema che si incontra quando si tenta di stabilire una connessione prima
che l'interfaccia internet sia pienamente attivata. In questo modo verrà
garantito pienamente il funzionamento della connessione per i computer connessi
al proprio router.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Qualcosa di divertente (da fare nelle giornate di pioggia)</title>

<section>
<title>Introduzione</title>
<body>

<p>
Da qui in avanti verrà descritto qualcosa che potrebbe interessare il lettore e
che è facile incontrare tra le funzionalità di un router. Tutto, in questo
capitolo, è completamente opzionale.
</p>

</body>
</section>

<section>
<title>Port Forwarding (Reindirizzamento delle/alle Porte)</title>
<body>

<p>
A volte si potrebbe voler erogare alcuni servizi dai computer che sono dietro il
router (ovvero all'interno della LAN) oppure semplicemente semplificarsi la vita
quando ci si connette da remoto. Si potrebbe voler eseguire un server FTP, HTTP,
SSH, o VNC in una o più macchine dietro il router ed essere in grado di
connettersi a tutte. L'unico problema è che solo un servizio e solo un computer
possono essere collegati ad una specifica porta. Per esempio, non c'è modo di
installare tre server FTP dietro il router e poi connettersi a tutti e tre
tramite la porta 21; solo uno potrà ascoltare sulla porta 21, mentre gli altri
dovranno ascoltare, per esempio, sulle porte 123 e 567.
</p>

<p>
Tutte le regole di port forwarding hanno questa forma: <c>iptables -t nat -A
PREROUTING [-p protocollo] --dport [porta del router] -i ${WAN} -j DNAT --to
[ip/porta del PC nella LAN]</c>. Sfortunatamente, iptables non accetta hostname
nelle regole di port forwarding. Se si sta effettuando il forwarding da una
porta esterna (quella del router) uguale a quella interna (quella del PC nella
LAN), si può omettere la porta di destinazione. Per ulteriori informazioni
consultare la pagina di manuale di iptables: iptables(8).
</p>

<pre caption="Eseguire iptables">
<comment>È sufficiente copiare ed incollare questi esempi</comment>
# <i>export LAN=eth0</i>
# <i>export WAN=eth1</i>

<comment>Reindirizzare la porta 2 a un demone ssh di un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 2 -i ${WAN} -j DNAT --to 192.168.0.2:22</i>

<comment>Reindirizzare una porta FTP (21) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 21 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Reindirizzare una porta HTTP (80) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Reindirizzare due porte per VNC a due host della LAN</comment>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5900 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5901 -i ${WAN} -j DNAT --to 192.168.0.3:5900</i>
<comment>Se si vuole stabilire una connessione VNC con 192.168.0.3 allora basta aggiungere ':1' all'hostname del router</comment>
<comment>Reindirizzare le porte SAMBA a un host della LAN (un sacco di porte per nascondere Windows)</comment>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 135 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 139 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 445 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p udp --dport 137:138 -i ${WAN} -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p udp --dport 445 -i ${WAN} -j DNAT --to 192.168.0.2</i>

<comment>Reindirizzare le porte BitTorrent (6881-6889) ad un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 6881:6889 -i ${WAN} -j DNAT --to 192.168.0.2</i>

<comment>Reindirizzare la porta eDonkey/eMule (4662) a un host della LAN</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 4662 -i ${WAN} -j DNAT --to 192.168.0.55</i>

<comment>Aggiungere il supporto al "Game Cube Warp"</comment>
# <i>iptables -t nat -A PREROUTING -p udp --dport 4000 -i ${WAN} -j DNAT --to 192.168.0.56</i>

<comment>Aggiungere il supporto a "Playstation2 OnLine"</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 10070:10080 -i ${WAN} -j DNAT --to 192.168.0.11</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 10070:10080 -i ${WAN} -j DNAT--to 192.168.0.11</i>

<comment>Xbox Live</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 3074 -i ${WAN} -j DNAT --to 192.168.0.69</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 3074 -i ${WAN} -j DNAT --to 192.168.0.69</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 88 -i ${WAN} -j DNAT --to 192.168.0.69</i>
</pre>

<note>
Se si dispone di altri esempi simpatici o frequentemente usati, <mail
link="vapier@gentoo.org">inviare una mail</mail> all'autore della guida.
</note>

</body>
</section>

<section>
<title>Il demone identd (per IRC)</title>
<body>

<p>
Il protocollo IRC (Internet Relay Chat) utilizza pesantemente il servizio ident.
Ora che i client IRC sono dietro il router, c'è bisogno di un modo per
raccogliere gli "ident" sia del router che dei client. Per fare ciò è stato
creato un server chiamato <c>midentd</c>
</p>

<pre caption="Configurare ident">
# <i>emerge midentd</i>
# <i>rc-update add midentd default</i>
# <i>/etc/init.d/midentd start</i>
</pre>

<p>
Ci sono alcuni altri server ident nel portage di Gentoo. Tenendo conto dei
propri bisogni, si consiglia di dare un'occhiata ad <c>oidentd</c> e
<c>fakeidentd</c>.
</p>

</body>
</section>


<!--***********************************************************************************************
     La parte commentata (nel testo originale) non è stata tradotta. Mandate
     una mail al traduttore (menegolo_andrea@yahoo.it)
     se avete assoluta necessità di una traduzione di questa parte
************************************************************************************************-->
<!--
<section>
<title>Traffic Shaping</title>
<body>
<p>
This is an attempt to simply and Gentooify the <uri
link="http://www.tldp.org/HOWTO/ADSL-Bandwidth-Management-HOWTO/">ADSL Bandwidth
Management HOWTO</uri> found over at the TLDP. Feel free to refer to the
original document for more details.
</p>

<p>
Here we will be setting up what some people refer to as a "Packet Shaper",
<uri link="http://en.wikipedia.org/wiki/Traffic_shaping">"Traffic
Shaping"</uri>, or <uri link="http://en.wikipedia.org/wiki/QoS">"Quality of
Service"</uri>. Simply put, we want to setup rules on our router that will slow
down certain activities (like sending large e-mails or downloading from P2P
networks) while keeping other activities (like browsing the web or playing
online video games) reasonably fast.  A 30 second difference in a video
game is a lot worse than a 30 second difference in downloading large
files :).
</p>

<p>
The first thing is to make sure your kernel has all the features added to
it.  See the chapter on <uri link="#doc_chap2">Kernel setup</uri> for more
information.  Next, you will need to <c>emerge iptables iputils</c> so that
you will have access to the <c>iptables</c>, <c>ip</c>, and <c>tc</c>
commands.
</p>

<p>
Before we jump into the commands, let's cover a little of the theory.  The
way this whole system works is to classify common network streams and then
to prioritize them.  You use iptables to classify network streams, iputils
to define the different priority levels, and the kernel to adjust speeds.
Just remember that although you can control outbound traffic pretty tightly
(from the LAN to the WAN), your ability to control inbound traffic (from
the WAN to the LAN) is somewhat limited.  Just remember that the following
examples are to get your feet wet; if you want more then I'd suggest
reading up on the subject.  In this example, we will be using the
<uri link="http://luxik.cdi.cz/~devik/qos/htb/">Hierarchical Token Buckets
(HTB)</uri> packet scheduling algorithm.  Still with me?  Great, let's start
shaping :).
</p>

<pre caption="Setup">
DEV=eth1 <comment>NIC connected to WAN</comment>
RATE_OUT=100 <comment>Available outbound bandwidth (in kilobits [kb])</comment>
RATE_IN=1400 <comment>Available inbound bandwidth (in kb)</comment>

<comment>Here we initialize the priority system.  The 45 is used to set the default classification level.</comment>
ip link set dev ${DEV} qlen 30
tc qdisc add dev ${DEV} root handle 1: htb default 45
tc class add dev ${DEV} parent 1: classid 1:1 htb rate ${RATE_OUT}kbit
</pre>

<p>
Here we initialized the system which will be used to prioritize all of
our network traffic.  We created our queue, told it to use the HTB
algorithm, and set the default classification level to '45'.  The
default is completely arbitrary, as are the levels we choose from
here on out.  The only thing that matters is how the levels compare
relatively; a level '10' packet will be given preference over a
level '45' packet.  Let's move on to declaring different levels.
</p>

<pre caption="Declaring levels">
tc class add dev $DEV parent 1:1 classid 1:10 htb rate $rkbit ceil $tkbit prio $p
tc qdisc add dev $DEV parent 1:10 handle 10: sfq
</pre>
</body>
</section>
-->

<section>
<title>Time Server</title>
<body>

<p>
Avere sempre un orologio di sistema sincronizzato è essenziale per mantenere un
sistema in salute. Uno dei modi più comuni per farlo è usare il Network Time
Protocol (NTP) e il pacchetto ntp (che fornisce sia l'implementazione lato
client che quella lato server).
</p>

<p>
Molte persone usano dei client ntp nei loro computer. Ovviamente più client ci
sono nel mondo più grandi sono i carichi di lavoro che i server ntp devono
gestire. In situazioni come quella di una rete casalinga però, è possibile
diminuire questo carico di lavoro dei server pubblici pur fornendo un risultato
accurato e veloce ai propri host. Tutto quello che bisogna fare è eseguire nel
router un server ntp che si sincronizzi con un server pubblico per poi fornire
l'ora esatta al resto degli host nella LAN. Per cominciare, eseguire il comando
<c>emerge ntp</c>.
</p>

<pre caption="Configurare il server NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Si può configurarlo, ma i valori predefiniti dovrebbero andare bene</comment>
# <i>rc-update add ntp-client default</i>

# <i>nano /etc/ntp.conf</i>
<comment>Aggiungere queste righe:</comment>
restrict default ignore
restrict 192.168.0.0 mask 255.255.255.0 notrust nomodify notrap
<comment>Questo permetterà di accedere al proprio server solo dagli host della LAN</comment>
# <i>nano /etc/conf.d/ntpd</i>
<comment>Si può configurarlo, ma i valori predefiniti dovrebbero andare bene</comment>
# <i>rc-update add ntpd default</i>

# <i>/etc/init.d/ntp-client start</i>
# <i>/etc/init.d/ntpd start</i>
</pre>

<note>
Assicurarsi di aver abilitato il traffico in entrata ed in uscita alla porta ntp
(123/udp) del server. Per i client sarà sufficiente l'abilitazione per il
traffico in uscita, sempre sulla stessa porta.
</note>

<p>
Ora dare il comando <c>emerge ntp</c> anche sui PC client. In questo caso la
configurazione dovrebbe essere più semplice perché verrà abilitato soltanto il
client.
</p>

<pre caption="Configurare un client NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Cambiare il nome del server da 'pool.ntp.org' a '192.168.0.1' nella variabile NTPCLIENT_OPTS</comment>
# <i>rc-update add ntp-client default</i>
# <i>/etc/init.d/ntp-client start</i>
</pre>

</body>
</section>

<section>
<title>Server Rsync</title>
<body>

<p>
Per reti in cui c'è più di una macchina con Gentoo, potrà capitare spesso di
usare il comando <c>emerge sync</c> con un server remoto. È possibile
risparmiare la propria banda e quella dei server di Gentoo usando un singolo
server rsync locale. È una cosa veramente semplice da fare.
</p>

<note>
Per una guida più approfondita su rsync, consultare la
<uri link="/doc/it/rsync.xml#local">guida su rsync</uri> ufficiale.
</note>

<p>
Dal momento che ogni computer con Gentoo richiede rsync nativamente, non c'è
bisogno di installarlo. Basterà modificare il file di configurazione
<path>/etc/rsyncd.conf</path> decommentando la sezione <c>[gentoo-portage]</c>
ed assicurandosi di aggiungere un'opzione <c>address</c>. Tutte le altre
impostazioni predefinite dovrebbero andare bene.
</p>

<pre caption="File di configurazione del server rsync">
pid file = /var/run/rsyncd.pid
use chroot = yes
read only = yes
address = 192.168.0.1

[gentoo-portage]
  path = /mnt/space/portage
  comment = Gentoo Linux Portage tree
  exclude = /distfiles /packages
</pre>

<p>
Avviare infine il servizio.
</p>

<pre caption="Avviare il server rsync">
# <i>/etc/init.d/rsyncd start</i>
# <i>rc-update add rsyncd default</i>
</pre>

<p>
L'unica cosa che rimane da fare è configurare i client affinché si colleghino
all'IP del router per effettuare la sincronizzazione.
</p>

<pre caption="Configurazione della variabile SYNC nei client nel file make.conf">
SYNC="rsync://192.168.0.1/gentoo-portage"
</pre>

</body>
</section>

<section>
<title>Server Mail</title>
<body>

<p>
A volte può essere utile avere un proprio semplice server SMTP (Simple Mail
Transfer Protocol) che gira sul router. Si potrebbe avere qualsiasi ragione per
farlo; l'autore di questa guida ha attivato questo servizio di modo che gli
utenti vedano la propria mail come inviata istantaneamente, mentre tutto il
lavoro è lasciato al server mail.  Oltretutto alcuni ISP, come Verizon, non
accettano mail relaying (ovvero non permettono di usare i loro server SMTP) se
non si possiede un account della loro rete. Ancora, si potrà limitare la banda
per l'invio delle mail di modo che gli allegati grandi non creino rallentamenti
della propria connessione per ore ed ore.
</p>

<pre caption="Configurare SMTP">
# <i>emerge netqmail</i>
<comment>Assicurarsi che l'output di 'hostname' sia corretto</comment>
# <i>emerge --config netqmail</i>
# <i>iptables -I INPUT -p tcp --dport smtp ! -i ${LAN} -j REJECT</i>
# <i>ln -s /var/qmail/supervise/qmail-send /service/qmail-send</i>
# <i>ln -s /var/qmail/supervise/qmail-smtpd /service/qmail-smtpd</i>
# <i>cd /etc/tcprules.d</i>
# <i>nano tcp.qmail-smtp</i>
<!--
# <i>cd /etc</i>
# <i>nano tcp.smtp</i>
-->
<comment>Aggiungere una riga come questa alla sezione "Allow":</comment>
192.168.0.:allow,RELAYCLIENT=""
<!--
# <i>tcprules tcp.qmail-qmtp.cdb rules.tmp &lt; tcp.qmail-smtp</i>
# <i>tcprules tcp.smtp.cdb rules.tmp &lt; tcp.smtp</i>
-->
# <i>make</i>
# <i>rc-update add svscan default</i>
# <i>/etc/init.d/svscan start</i>
</pre>

<p>
Chi scrive è un grande fan di qmail, ma il lettore è libero di scegliere un
altro MTA. Quando si configurano gli account e-mail negli host della propria
rete, impostare il server SMTP su di essi in modo che sia 192.168.0.1 e tutto
dovrebbe funzionare. Per ulteriore documentazione, visitare
<uri link="http://netqmail.org/">l'homepage di netqmail</uri>.
</p>

</body>
</section>

<!--***********************************************************************************************
     La parte commentata non è stata tradotta. Mandate una mail al traduttore (menegolo_andrea@yahoo.it)
     se avete assoluta necessità di una traduzione di questa parte
************************************************************************************************-->

<!--
<section>
<title>E-mail Virus Scanning</title>
<body>
<p>
If you'd like to provide e-mail virus scanning for your users, but
don't want to have to install a virus scanner on every single machine,
then <c>pop3vscan</c> may just be the thing for you; a transparent
Post Office Protocol (POP) scanner.
</p>

<pre caption="Setting up pop3vscan">
TODO
</pre>

</body>
</section>
-->

<section>
<title>Server DHCP completo</title>
<body>

<p>
Prima si è usato dnsmasq per fornire il servizio DHCP a tutti i client. Per la
maggior parte delle persone con una semplice, piccola LAN, questa soluzione è
perfetta. Tuttavia, potrebbe esserci la necessità di qualcosa con più funzioni.
Per questo ci si affida ad un server DHCP completo in tutto, fornito dal team
<uri link="http://www.isc.org/products/DHCP">ISC</uri>.
</p>

<pre caption="Installare dhcpd">
# <i>emerge dhcp</i>
# <i>nano /etc/dhcp/dhcpd.conf</i>
<comment>(Ecco un esempio per il file di configurazione:)</comment>
authoritative;
ddns-update-style interim;
subnet 192.168.0.0 netmask 255.255.255.0 {
        range 192.168.0.100 192.168.0.250;
        default-lease-time 259200;
        max-lease-time 518400;
        option subnet-mask 255.255.255.0;
        option broadcast-address 192.168.0.255;
        option routers 192.168.0.1;
        option domain-name-servers 192.168.0.1;
}
# <i>nano /etc/conf.d/dhcpd</i>
<comment>(Impostare IFACE="eth0")</comment>
# <i>rc-update add dhcpd default</i>
# <i>/etc/init.d/dhcpd start</i>
</pre>

<p>
Questa è la configurazione minima richiesta per rimpiazzare le funzioni DHCP di
dnsmasq usato in precedenza. A tal proposito, bisogna ricordarsi di disattivare
le funzioni DHCP in dnsmasq (basta commentare l'impostazone <c>dhcp-range</c> in
<path>/etc/dnsmasq.conf</path> e riavviare il servizio).
</p>

</body>
</section>

<section>
<title>Connettere un'altra LAN (o due o tre o...)</title>
<body>

<p>
A volte potrebbe esserci la necessità di connettere il proprio router ad
un'altra LAN. Magari per collegarsi temporaneamente ad un gruppo di amici oppure
il lettore potrebbe essere uno smanettone e voler sezionare gruppi diversi di
computer o forse è solamente una persona solo molto, molto annoiata.  Qualunque
sia la ragione, estendere il router ad un'altra LAN dovrebbe essere abbastanza
semplice. Negli esempi seguenti si darà per scontato che questa nuova rete sia
collegata attraverso una terza scheda Ethernet chiamata <c>eth2</c>.
</p>

<p>
Per prima cosa, configurare l'interfaccia. Usare le istruzioni nel
<uri link="#doc_chap4_pre1">listato di codice 4.1</uri>,
sostituendo <c>eth0</c> con <c>eth2</c> e <c>192.168.0</c> con <c>192.168.1</c>.
</p>

<p>
Fatto ciò, configurare dnsmasq affinché fornisca i suoi servizi alla nuova
interfaccia. Modificare di nuovo il file <path>/etc/conf.d/dnsmasq</path>,
aggiungendo <c>-i eth2</c> a DNSMASQ_OPTS; si può usare -i più volte. Poi
modificare <path>/etc/dnsmasq.conf</path> e aggiungere un'altra riga come quella
del dhcp-range nel <uri link="#doc_chap5_pre1">listato di codice 5.1</uri>,
sostituendo <c>192.168.0</c> con <c>192.168.1</c>. Si possono avere anche più
righe dhcp-range.
</p>

<p>
Per finire, guardare le regole nel <uri link="#doc_chap5_pre2">listato di codice
5.2</uri> e duplicare le regole che contengono <c>-i ${LAN}</c>. Per rendere le
cose più semplici si potrebbe creare un'altra variabile, chiamandola ad esempio
<c>LAN2</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Risoluzione dei problemi</title>

<section>
<title>Strumenti utili</title>
<body>

<p>
Se si riscontrano problemi nel cercare di mettere in comunicazione i propri
computer, i seguenti strumenti potrebbero risultare utili (sono tutti contenuti
nella categoria <c>net-analyzer</c> di portage):
</p>

<table>
<tr>
  <th>Strumento</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>wireshark</ti>
  <ti>
    Strumento grafico per visualizzare tutto il traffico di rete grezzo secondo
    alcuni filtri
  </ti>
</tr>
<tr>
  <ti>tcpdump</ti>
  <ti>
    Uno strumento da console per intercettare il traffico di rete grezzo secondo
    alcuni filtri
  </ti>
</tr>
<tr>
  <ti>iptraf</ti>
  <ti>Monitor IP per la LAN basato sulle librerie ncurses</ti>
</tr>
<tr>
  <ti>ettercap</ti>
  <ti>Monitor/Controllore di rete basato sulle librerie ncurses</ti>
</tr>
</table>

</body>
</section>

<section>
<title>DHCP non parte</title>
<body>

<p>
Quando viene lanciato lo script init.d di dhcp per la prima volta, potrebbe non
caricarsi senza fornire alcuna informazione utile.
</p>

<pre caption="Esempio di fallimento di DHCP">
# <i>/etc/init.d/dhcp start</i>
 * Setting ownership on dhcp.leases ...          [ ok ]
 * Starting dhcpd ...                            [ !! ]
</pre>

<p>
Il trucco sta nello scoprire dove il demone dhcpd invia il suo output. Basta
semplicemente posizionarsi su <path>/var/log</path> e leggere i file di log. Dal
momento che il file dipende da quale syslog si sta usando, si può lanciare il
comando <c>grep -Rl dhcpd /var/log</c> per trovare il file esatto. La causa che
ha generato il mancato avvio di dhcpd è probabilmente un errore nel file di
configurazione. Si può anche provare a lanciare <c>dhcpd -d -f</c> ed effettuare
il debug degli errori basandosi sull'output.
</p>

</body>
</section>

<section>
<title>Valore dell'MTU sbagliato</title>
<body>

<p>
Se occasionalmente si presentano degli errori (come il non riuscire a
visualizzare alcune pagine web, mentre altre si visualizzano correttamente),
potrebbero esserci dei problemi con il "Path MTU Discovery". Il modo più veloce
per scoprirlo è lanciare iptables:
</p>

<pre caption="Impedire problemi di MTU">
# <i>iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</i>
</pre>

<p>
Questo avrà effetto solo sulle nuove connessioni, per cui ricaricare la pagina
web che presentava problemi per verificare se tutto è a posto. Potrebbe far
comodo sapere che il valore MTU standard per connessioni ethernet a 100Mb è
<c>1500</c>; questo valore va bene anche per quanto riguarda PPPoA. Per le
connessioni PPPoE è invece <c>1492</c>. Per ulteriori informazioni consultare il
capitolo 15 della guida <uri link="http://lartc.org/howto/">Linux Advanced
Routing &amp; Traffic Control HOWTO</uri>.
</p>

<p>
Nel caso in cui questo comando non funzioni, si può provare ad inserire la
regola nella tabella mangle. Per fare ciò basta aggiungere <c>-t mangle</c> al
comando.
</p>

</body>
</section>
<section>
<title>Impossibile connettere direttamente due computer</title>
<body>

<p>
Se (per qualche ragione) si vogliono connettere due macchine direttamente senza
usare un hub o uno switch, un normale cavo ethernet non funzionerà, a meno che
non si possieda una scheda di rete Auto MDI/MDI-X (chiamate anche
"autosensing"). Ci sarà bisogno di un altro tipo di cavo che viene chiamato cavo
incrociato (crossover). Su <uri
link="http://en.wikipedia.org/wiki/Ethernet_crossover_cable">Wikipedia</uri> si
possono trovare tutti i dettagli su questo argomento (la pagina di Wikipedia in
Italiano è <uri
link="http://it.wikipedia.org/wiki/Cavo_ethernet_incrociato">qui</uri>).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Note Finali</title>
<section>
<body>

<p>
Non ci sono note finali, tranne una. Se si riscontra qualsiasi problema con la
guida, si prega di <mail link="vapier@gentoo.org">contattare</mail> l'autore o
segnalare un bug <uri link="http://bugs.gentoo.org/">qui</uri>. Se si possiede
qualche pezzo interessante che si pensa possa migliorare questa guida, inviarlo
tranquillamente all'autore, che provvederà ad includerlo.
</p>

</body>
</section>
</chapter>
</guide>
