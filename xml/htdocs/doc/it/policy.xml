<?xml version='1.0' encoding="UTF-8"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link = "/doc/it/policy.xml" lang="it">
<title>Politica di sviluppo di Gentoo</title>
<author title="Autore originale">Owen Stampflee</author>
<author title="Autore"><mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail></author>
<author title="Autore"><mail link="drobbins@gentoo.org">Daniel Robbins</mail></author>
<author title="Redazione"><mail link="seemant@gentoo.org">Seemant Kulleen</mail></author>
<author title="Redazione"><mail link="avenj@gentoo.org">Jon Portnoy</mail></author>
<author title="Redazione"><mail link="vapier@gentoo.org">Mike Frysinger</mail></author>
<author title="Redazione"><mail link="carl@gentoo.org">Carl Anderson</mail></author>
<author title="Redazione"><mail link="liquidx@gentoo.org">Alastaire Tse</mail></author>
<author title="Redazione"><mail link="swift@gentoo.org">Sven Vermeulen</mail></author>
<author title="Traduzione"><mail link="sogentoo@katamail.com">sogentoo</mail></author>

<abstract>
Questa guida è intesa per essere l'autorevole riferimento scritto per la politica di sviluppo di Gentoo Linux.
Sarà aggiornata periodicamente per rispecchiare le nuove procedure di sviluppo.
</abstract>

<license/>

<version>1.1.0</version>
<date>16 Ottobre 2004</date>

<chapter>
<title>Guide di riferimento generali</title>
<section>
<body>
<p>Qui ci sono alcune guide di riferimento generali di sviluppo da seguire:</p>
<ul>

<li>Controllate sempre i vostri cambiamenti con repoman; usate repoman commit invece del cvs commit.</li>

<li>Se un pacchetto o è rotto nella versione corrente o ha un processo davvero brutto di costruzione/installazione, date un'occhiata a come fanno altre distribuzioni: <ul>
<li><uri>http://cvs.mandrakesoft.com/cgi-bin/cvsweb.cgi/SPECS/</uri></li>
<li><uri>http://www.debian.org/distrib/packages</uri></li> </ul> </li>
   
<li>Il vostro pacchetto, una volta completo ed unmasked, è supposto essere un "lavoro esatto" per l'utente finale. Forzare il prodotto installato per convincerlo a funzionare dovrebbe essere opzionale; così dovete installare il pacchetto con i ragionevoli settings di default.</li>

<li>Non siate spaventati a consultare la nostra documentazione on-line e gli ebuilds scritti e mantenuti dai maggiori sviluppatori. Sentitevi liberi di mettervi in contatto con gli sviluppatori riguardo tutte le domande tecniche e politiche.</li>

<li>Siate prudenti a cosa commettete. Ricordate che le vostre iniziative possono nuocere a migliaia di utenti. Se le vostre azioni causano una rottura nel tree, devono essere aggiustate in modo tempestivo.</li>

<li>Ogni pacchetto deve essere accompagnato da un file <uri link="metadata.xml">metadata.xml</uri>, che elenca, tra le altre informazioni, quale gruppo (e/o singolo mantenitore) è incaricato del pacchetto.</li>

</ul>
</body>
</section>
</chapter>

<chapter>
<title>Guide di riferimento specifiche</title>
<section>
<title>Copyright</title>
<body>
<p>Il copyright negli ebuilds (e nella documentazione) dovrebbe essere sempre assegnato a Gentoo Foundation. Gli sviluppatori non devono mai mettere i loro nomi nelle linee del copyright. Per ulteriori informazioni, si prega di vedere <uri>http://www.gentoo.org/proj/en/devrel/copyright-assignment.xml</uri>.
</p>
</body>
</section>

<section>
<title>fPIC</title>
<body>
<p>Su alcune architetture, le librerie condivise devono essere compilate con -fPIC. Su x86 e altre architetture, le librerie condivise sono compilate senza -fPIC, ma ciò è dispendioso e indurrà un abbassamento della prestazione. Se incontrate un pacchetto che non compila le librerie condivise con -fPIC, modificate il Makefile per compilare <b>solo</b> le librerie con -fPIC. Ulteriori informazioni su PIC sono disponibili su <uri>http://www.gentoo.org/proj/en/hardened/pic-internals.xml</uri>.
</p>
</body>
</section>

<section>
<title>Temi Gentoo</title>
<body>
<p>Mentre includere i temi Gentoo è altamente consigliato, il tema di default (skin/graphics/feel/etc...) non deve essere cambiato. Il supporto grafico di default dovrebbe seguire i desideri dello sviluppatore.</p>
</body>
</section>

<section>
<title>Perl</title>
<body>

<p>
I nuovi moduli di Perl devono essere aggiunti al portage solo quando si incontra una delle seguenti condizioni:
</p>

<ul>
<li>Il/i modulo/i corrispondono a una dipendenza</li>
<li>Il/i modulo/i non possono essere trattati da <c>g-cpan</c></li>
<li>Il/i modulo/i aggiungono funzionalità agli ebuild esistenti</li>
<li>Il/i modulo/i forniscono tools, applicazioni o altre caratteristiche (per esempio,
più che il loro .PM offre)</li>
</ul>

<p>
Per favore assicuratevi che almeno un membro dei perl herders approvi la vostra aggiunta.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Politica di ebuild</title>
<section>
<title>Politica del nome</title>
<body>

<p>I nomi dei file ebuild consistono di quattro sezioni logiche:</p>

<p><c>pkg-ver{_suf{#}}{-r#}.ebuild</c></p>

<note>Le graffe (<c>{}</c>) delineano campi opzionali e non compaiono nel nome letterale del pacchetto. <c>#</c> rappresenta qualsiasi numero non-zero intero positivo.</note>

<p>
La prima sezione, <c>pkg</c>, è il nome del pacchetto, che dovrebbe contenere soltanto le lettere minuscole, le cifre 0-9, e qualsiasi numero di singoli caratteri di trattino (<c>-</c>), underscore (<c>_</c>) o più (<c>+</c>. Esempi: <c>util-linux</c>,
<c>sysklogd</c>, <c>glibc</c>. Noi abbiamo alcuni pacchetti in Portage che non seguono queste regole, ma i <e>vostri</e> pacchetti dovrebbero seguirle.
</p>

<p>
La seconda sezione, <c>ver</c>, è la versione del pacchetto, che normalmente dovrebbe essere la stessa della versione sul principale tarball sorgente. La versione si compone normalmente di due o tre (o più) numeri separati da punti, così come <c>1.2</c> o <c>4.5.2</c>, e può avere una singola lettera subito dopo l'ultima cifra; per esempio, <c>1.4b</c> o <c>2.6h</c>. La versione del pacchetto è unita al nome con un trattino. Esempi:
<c>foo-1.0</c>, <c>bar-2.4.6</c>.
</p>

<p>
La terza sezione, <c>{_suf{#}}</c>, è opzionale può contenere uno di questi suffissi predefiniti, elencati in ordine dal meno recente al più recente:
</p>

<table>
 <tr><th>Suffisso</th><th>Significato</th></tr>
 <tr><ti><c>_alpha</c></ti><ti>Rilascio alpha</ti></tr>
 <tr><ti><c>_beta</c></ti><ti>Rilascio beta</ti></tr>
 <tr><ti><c>_pre</c></ti><ti>Prerilascio</ti></tr>
 <tr><ti><c>_rc</c></ti><ti>Release candidate</ti></tr>
 <tr><ti>(nessuno)</ti><ti>Rilascio normale</ti></tr>
 <tr><ti><c>_p</c></ti><ti>Patch level (accompagnato normalmente da un numero intero)</ti></tr>
</table>

<p> 
Questi suffissi possono immediatamente essere seguiti da un numero non-zero intero positivo, per esempio, <c>linux-2.4.0_pre10</c>. Assumendo una identica versione, i suffissi sono ordinati come segue (i più bassi sono i più vecchi): <c>_alpha</c> &lt;
<c>_beta</c> &lt; <c>_pre</c> &lt; <c>_rc</c> &lt; (nessun suffisso) &lt;
<c>_p</c>.
</p>
       
<p>
Quando paragoniamo i suffissi identici con numeri interi, quello con il numero intero più grande sarà considerato più recente. Esempio: <c>foo-1.0_alpha4</c>
è più recente di <c>foo-1.0_alpha3</c>.
</p>

<p>
La quarta sezione del nome del pacchetto è il numero di revisione specifico di Gentoo Linux (<c>{-r#}</c>). Questa sezione, come il suffisso, è opzionale.
<c>#</c> è un numero non-zero intero positivo; per esempio, <c>package-4.5.3-r3</c>.
</p>

<p>
Questo numero di revisione è indipendente dalla versione del tarball sorgente ed è usata per informare la gente che una nuova e migliorata revisione Gentoo Linux di un particolare pacchetto è disponibile. I rilasci iniziali degli ebuilds non devono avere numero di revisione; per esempio, <c>package-4.5.3</c> e sono considerati da Portage come se avessero numero di revisione pari a zero. Ciò significa che la numerazione va come segue: <c>1.0</c> (versione iniziale), <c>1.0-r1</c>, <c>1.0-r2</c>,
etc.
</p>

</body>
</section>

<section>
<title>Versioni e revisioni modificate</title>
<body>

<p>
I numeri di revisione del pacchetto dovrebbero essere incrementati dagli sviluppatori Gentoo Linux, quando l'ebuild è cambiato a tal punto che gli utenti desidererebbero aggiornarlo.
Tipicamente questo è il caso in cui gli aggiustamenti sono fatti ad un ebuild che interessa i risultanti files installati, ma l'ebuild usa lo stesso tarball sorgente del precedente rilascio. Se fate un cambiamento interno, stilistico, che non cambia nessuno dei files installati, allora non c'è bisogno di modificare il numero di revisione. Inoltre, se riparate un problema di compilazione che sta interessando alcuni utenti, non c'è bisogno di modificare il numero di revisione, poichè a coloro i quali ha funzionato perfettamente, non vedrebbero il beneficio di installare una nuova revisione, e quelli che hanno avuto il problema non hanno il pacchetto installato (poichè la compilazione è fallita) e così non vi è  necessità di un nuovo numero di revisione per forzare un aggiornamento. Una modifica di revisione non è necessaria anche se una minoranza di utenti sarà affetta e il pacchetto ha un tempo medio di compilazione non insignificante; usate il vostro miglior giudizio in queste circostanze.
</p>

<impo>
Ogni volta che create una nuova revisione di un ebuild, assicuratevi di aggiornare il file
<path>ChangeLog</path> nella directory dell'ebuild. Non fare così, è considerato disprezzabile e può provocare un'azione disciplinare.
</impo>

<p>
Gli ebuilds dovrebbero essere basati sulla versione precedente degli stessi per accertarsi che le correzioni non sono state fatte casualmente. Le correzioni dovrebbero includere appropriate osservazioni nell'ebuild per spiegare che cosa sono e perchè sono necessarie. Se non siete esperti con le riparazioni, o non siete capaci di determinare se sono ancora necessarie, non dovreste aggiornare l'ebuild.
</p>

</body> 
</section> 

<section>
<title>Virtuali</title>
<body>

<p>
Portage supporta un concetto chiamato pacchetti "virtuali". Usando i pacchetti virtuali, è possibile dare una particolare categoria/pacchetto name map ad un altro.
</p>

<p>
Qui c'è un esempio di come usare i pacchetti virtuali. Create un nuovo pacchetto cron chiamato <c>foocron</c>. Gentoo Linux attualmente è settato in modo che le cose che hanno bisogno di un pacchetto cron di qualsiasi genere dipendano dal pacchetto
<c>virtual/cron</c>. Questo permette che gli ebuilds si accertino che ci sia un certo genere di cron disponibile mentre concede agli utenti la flessibilità di installare il pacchetto cron che preferiscono. Inserito il vostro <path>foocron-1.0.ebuild</path> in questo sistema, dovete aggiungere una riga all'ebuild:
</p>

<pre>
PROVIDE="virtual/cron"
</pre>

<p>
Ora, quando <c>foocron-1.0</c> è installato, il pacchetto <c>virtual/cron</c>
sarà registrato. Se non avete installato prima nessun pacchetto cron, ciò significherebbe che tutto il pacchetto <e>dipendente</e> da <c>virtual/cron</c> avrebbe la dipendenza completamente soddisfatta. Notate che è possibile specificare un
<c>PROVIDE</c> valore per qualsiasi tipo di pacchetto -- non deve cominciare con
<c>virtual/</c>. Tuttavia, <e>dovreste</e> usare la categoria <c>virtual/</c>
a meno che non state usando la funzionalità <c>PROVIDE</c> per trattare pacchetti che sono stati rinominati.
</p>

<p>
C'è un secondo componente all'implementazione dei pacchetti virtuali di Gentoo Linux.
Che cosa accadrebbe se non ci fosse nessun pacchetto installato che ha fornito
<c>virtual/cron</c>? Come Portage sceglierebbe il "corretto" cron da installare per soddisfare la dipendenza di <c>virtual/cron</c>? Portage si prende cura di questa situazione usando un file virtuale tracciato specifico del profilo chiamato
<path>virtuals</path> che è presente nella directory
<path>/etc/make.profile</path>. Se date un'occhiata al vostro file
<path>virtuals</path>, troverete che il contenuto assomiglia a qualcosa come questo:
</p>

<pre caption="Sample virtuals file">
virtual/lpr             net-print/cups
virtual/python          dev-lang/python
virtual/mta             net-mail/ssmtp
</pre>

<p>
La prima riga di questo file dice a Portage che se un pacchetto dipende da
<c>virtual/lpr</c> e nessun <c>virtual/lpr</c> è installato e nessun pacchetto
<c>virtual/lpr</c> è disponibile nel Portage tree, allora
<c>net-print/cups</c> dovrebbe essere installato per soddisfare questa dipendenza.
<c>net-print/cups</c> contiene una riga che dice <c>PROVIDE="virtual/lpr"</c>
in modo che le dipendenze future da <c>virtual/lpr</c> siano soddisfatte.
</p>

<p>
Ora per le guide di riferimento di sviluppo. Se doveste aggiungere il pacchetto <c>foocron</c> , vorreste ovviamente accertarvi che tutti i programmi che dipendono da
<c>virtual/cron</c> possano funzionare correttamente con esso. E se doveste aggiungere un pacchetto chiamato <c>foobarosity</c> che dipendeva da <c>virtual/cron</c>, vi accertereste similarmente che tutti i pacchetti che forniscono <c>virtual/cron</c> saranno soddisfacenti per il perfetto funzionamento di <c>foobarosity</c>.
</p>

<p>
Prima di creare nuovi pacchetti virtuali, per favore cominciate una discussione sulla mailing list interna di sviluppo sui pacchetti virtuali. Tenere gli sviluppatori informati di nuovi pacchetti virtuali è essenziale per accertare il loro uso uniforme.
</p>

</body>
</section>

<section>
<title>Politica dei sorgenti del CVS</title>
<body>

<p>
Ci sono due modi differenti per costruire un ebuild basato su sorgenti da un tree di sviluppo del CVS. Il primo e tradizionale modo è creare un ebuild "CVS snapshot" creando il vostro tarball snapshot dell'upstream CVS tree,
scaricando i sorgenti sul nostro ufficiale distfile repository, e scrivendo un ebuild per usare specificamente questo tarball snapshot. Questi tipi di ebuilds del CVS saranno chiamati, sotto, "CVS snapshot ebuilds".
</p>

<p>
L'altro metodo di creare un ebuild basato sul CVS è di usare <path>cvs.eclass</path> per creare un "live" ebuild CVS. Un tale ebuild prenderà dinamicamente gli ultimi sorgenti di sviluppo dal CVS repository, accertandosi che i sorgenti siano aggiornati più possibile. Questi tipi di ebuilds di CVS saranno chiamati, sotto, "'live' ebuilds".
</p>

<p>
I seguenti paragrafi dettagliano la politica concernente l'uso degli ebuilds basati su CVS. Si noti che ci sono regole rigorose in relazione all'aggiunta di tali ebuilds nel Portage tree.
</p>

<p>
Gli ebuilds snapshot CVS sono notevolmente preferiti ai "live" <path>cvs.eclass</path>
ebuilds cvs.
</p> 

<p>
Gli ebuilds snapshot cvs sono permessi se un cvs snapshot contiene le riparazioni conosciute che sono necessarie per il funzionamento adeguato di un pacchetto di programmi, o se la versione cvs di un particolare pacchetto di programmi è conosciuta o si è dimostrata semplicemente "funzionare meglio" di una normale versione di rilascio.
</p>

<p>
I "live" <path>cvs.eclass</path> ebuilds sono generalmente intesi soltanto per aiutare gli sviluppatori e dovrebbero essere resi masked con un <c>~[arch]</c>. E' impossibile garantire l'affidabiltà di un "live"
<path>cvs.eclass</path> ebuild poichè l'upstream cvs tree può cambiare in qualunque momento, è questo il motivo del perchè dovrebbero essere sempre masked.
</p>

<p>
Sia per un "live" cvs ebuild sia per un ebuild "snapshot" CVS, <b>voi sviluppatori siete responsabili di assicurarvi che l'ebuild funzioni correttamente</b>.
Questo è particolarmente difficile da fare con il "live" cvs ebuild per ovvi motivi.
</p>

<p>
Se gli ebuilds (di ogni genere) non funzionano correttamente o sono sfaldati, dovrebbero essere riparati o rimossi dal Portage tree. Se sono "live" ebuilds, possono essere resi masked <c>~[arch]</c> per la loro durata (questa speciale eccezione è dettagliata sotto).
</p>

<p>
Se un utente o utenti richiedeno specificamente un "live" cvs ebuild, potete aggiungerne uno per loro. Dovrebbe avere <c>~[arch]</c> in modo che altri utenti non lo emergano.
</p>

<p>
L'utente o gli utenti che li richiedono (probabilmente sviluppatori) possono installarli ma altri utenti saranno protetti dall'emergerli accidentalmente.
Di nuovo, questo si applica soltanto alle situazioni in cui un utente o utenti
chiedono un "live" <path>cvs.eclass</path> CVS ebuild. Gli ebuilds snapshot dovrebbero soltanto essere aggiunti al Portage tree con l'intenzione di essere stabili e fornire migliori funzionalità rispetto alle normali versioni di rilascio.
</p>

<impo>
Gli ebuilds snapshot dei <e>pre-rilasciati</e> sorgenti CVS dovrebbero essere chiamati
come segue: <path>foo-x.y_preYYYYMMDD.ebuild</path>. <c>foo</c> è il nome del pacchetto, <c>x.y</c> è il numero della versione dell'<e>imminente</e> rilascio,
<c>_pre</c> è una stringa letterale, e <c>YYYYMMDD</c> è un timestamp del giorno in cui è stato preso lo snapshot CVS. Usate questa convenzione del nome per accertare
che una versione di rilascio <c>x.y.1</c> non sarà considerata più vecchia di uno snapshot <c>x.y</c>, mentre si accerta allo stesso tempo che l'ufficiale rilascio <c>x.y</c>
sarà considerato <e>più nuovo</e> della vostra versione dello snapshot CVS. Per lo snapshot CVS di <e>già-rilasciati</e> sorgenti CVS, usate il formato
<path>foo-x.y_pYYYYMMDD.ebuild</path> (notate la <c>_p</c> per "patchlevel.")
Ciò assicurerà che il vostro ebuild CVS sarà considerato <e>più nuovo</e> del rilascio standard <c>x.y</c>.
</impo>

<impo>
Attualmente, la politica di chiamare "live" cvs ebuilds è per accertare che il nome del pacchetto finisca con <c>-cvs</c>. In futuro, un <c>_cvs</c> suffisso di versione
sarà probabilmente aggiunto a Portage e questa politica sarà aggiornata.
</impo>

</body>
</section>

<section>
<title>Ebuilds sottoposti dall'utente</title>
<body>

<p>
Degli ebuilds sottoposti dall'utente non ci si dovrebbe mai fidare ciecamente e dovrebbero essere sempre ben-testati e verificati prima di essere mandati al CVS. <b>Se un ebuild sottoposto da un utente ha problemi, sarete ritenuti responsabili.</b> Nel mandarlo al CVS, siete garantiti che l'ebuild risponde a tutti gli standard di sviluppo di Gentoo Linux.
</p>

<p>Assicuratevi che un ebuild presentato da un utente non contiene intestazioni come queste:</p>

<pre caption="A custom header that should be transferred to the ChangeLog">
# Ebuild updated by: me &lt;me@me.com&gt;
</pre>

<p>
Questa informazione dovrebbe essere aggiunta al <path>ChangeLog</path> usando una sintassi di commento adeguata di ChangeLog. <b>Accertatevi sempre che il ChangeLog dia adeguato credito all'utente che ha presentato l'ebuild. Queste informazioni dovrebbero comparire nella prima voce del ChangeLog.</b>
</p>

<p>Inoltre accertatevi che tutti i nuovi ebuilds che mandate contengano la seguente riga:</p>
<pre>
# &#36;Header: &#36;
</pre>
<p>Alcuni ebuilds presentati dall'utente sono basati sui files da rsync, che possono contenere righe errate d'intestazione.</p>

<p>
Consigliamo agli utenti di mettere le differenze agli ebuilds attuali, se stanno presentando un aggiornamento. Così facendo, possiamo contribuire ad evitare la reintroduzione di bugs precedentemente riparati nei nostri "nuovi" ebuilds. Se non state lavorando su una differenza presentata da un utente ma su un ebuild completo, allora usate il comando <c>diff</c> per vedere cosa è cambiato, mantenendo un occhio aperto per qualsiasi cosa che dal nostro ebuild corrente dovrebbe comparire nel nuovo ebuild, o per qualsiasi cosa che nel nuovo ebuild dovrebbe essere riparata o rimossa.
</p>

<p>
In generale, lasciamo che l'utente faccia il suo lavoro per ottenere il suo ebuild, a meno che voi non <e>vogliate</e> mettere in ordine l'ebuild in suo nome. Nondimeno, spesso è meglio avere utenti che fanno il lavoro in modo da poter imparare dai propri errori e in futuro presentare ebuilds più ordinati. Bisogna essere riconoscenti per ogni presentazione, anche se non è molto buona. E' gentile ma onesto -- se un ebuild non è utilizzabile, l'utente può essere riconosciuto in un modo che non insulti la sua attuale abilità di scrivere ebuild. Si ricorda che l'utente che ha presentato l'ebuild rotto, in futuro potrà essere un membro esperto e produttivo del nostro progetto -- cioè, se ricevono il giusto incoraggiamento e sostegno e continuano a migliorare nelle loro capacità.
</p>

</body>
</section>


</chapter> 

<chapter>
<title>Politica QA</title>
<section>
<title>Politica di rilascio di Portage</title>
<body>
<note>Dal 17 Dicembre 2002, Nick Jones (carpaski) è il Mantenitore di Portage.</note>

<p>
Soltanto il Mantenitore di Portage ha l'autorità di presentare nuovi rilasci di Portage ad uso degli utenti, sia versioni masked che unmasked. A <b>nessun'altro</b> è permesso presentare nuovi rilasci di Portage.
</p>

<p>
L'unica eccezione a questa regola è per situazioni in cui il Mantenitore di Portage può essere non disponibile per periodi di tempo prolungati e c'è un errore importante nel Portage. In questa situazione di emergenza, a uno svilupatore maggiore sarebbe permesso di testare la riparazione e poi presentare un nuovo rilascio.
</p>

<p>
Prima di usare questa "scappatoia", ci si deve chiedere: è veramente non disponibile il Mantenitore di Portage? E' veramente così importante questa difficoltà che si ottiene sul nostro Portage tree entro un'ora? Avete esaminato <e>tutto</e> del vostro nuovo codice per assicurarvi che funzioni bene? <b>Questo è importante!</b> Ricordate che se la vostra versione del Portage è rotta, creerà <e>problemi maggiori</e> a tutti i nostri utenti, <e>specialmente</e> se è unmasked. Per favore usate questa "scappatoia" soltanto quando <e>assolutamente</e> necessario -- quando le conseguenze del <e>non</e> usare il rimedio sono troppo alte.
</p>

<p>
E se fate come sopra, la riparazione di emergenza dovrebbe essere uno sforzo coordinato fra tutti gli sviluppatori attualmente disponibili on-line (per testare la nuova versione, etc) e non essere un "ranger solitario" impegnato. Ci dovrebbe essere un post nella mailing list del gentoo-core sulla nuova versione "di emergenza" per mantenere tutto nel ciclo e per spiegare perchè era necessario, e perchè aspettare il Mantenitore di Portage non era un'opzione.
</p>

<p>
Il Mantenitore di Portage <e>permette</e> che determinate persone speciali si impegnino al Portage cvs tree.
Tuttavia, anche se siete una di queste persone, questo privilegio non vi autorizza a presentare un nuovo rilascio di Portage. Questo è il lavoro del Mantenitore di Portage. Questa persona rivedrà e correttamente testerà i vostri cambiamenti prima di presentare un nuovo rilascio di Portage. Per favore permettete che questo lavoro sia fatto dal Mantenitore di Portage -- non infrangete queste regole. E' la nostra speranza che questa politica chiara contribuirà a impedire futuri problemi di Portage QA.
</p>

</body>
</section>

<section>
<title>Pacchetti masked</title>
<body>

<p>
<path>/usr/portage/profiles/package.mask</path>  contiene una lista di pacchetti che non dovrebbero essere emergiati dagli utenti e osservazioni dettagliate del perchè. Package.mask è usato per prevenire il merging di pacchetti che sono rotti, che si rompa qualche altra cosa, o che bisogna testarli prima di entrare in ~ARCH KEYWORDS nel tree. Quando integrate package.mask, affidatevi sempre ad esso prima di mandare l'ebuild masked. Ciò impedisce che l'ebuild riguardi gli utenti prima che il package.mask sia aggiornato.
</p>

<p>
Grande cura deve essere presa ogni volta che un pacchetto è rimosso da <path>package.mask</path>.
Tenete in mente che se un ebuild è in <path>package.mask</path>, c'è una ragione.
Se non riuscite a rendere masked l'ebuild, contattate sempre lo sviluppatore elencato nelle osservazioni di  <path>package.mask</path> prima di intraprendere qualsiasi azione. Ulteriormente, se l'ebuild masked è un pacchetto core, una dipendenza del pacchetto core, o l'unmasking porta a effetti contrari, il cambiamento deve essere discusso internamente sulla mailing list di sviluppo.
</p>

</body>
</section>

<section>
<title>~ARCH</title>
<body>
<p>
Lo scopo di ~arch è di testare i nuovi pacchetti aggiunti a Portage.
</p>
<p>
C'è una differenza tra usare <path>package.mask</path> e ~arch per gli ebuilds. L'uso di ~arch denota un <b>ebuild</b> che richiede fasi di testing. L'uso di <path>package.mask</path> denota che l'applicazione o la libreria è ritenuta instabile. Per esempio, se <c>gimp-1.2.0</c> è il rilascio stabile degli sviluppatori di Gimp, e un nuovo rilascio che ha corretto un bug è disponibile come 1.2.1, allora uno sviluppatore dovrebbe contrassegnare l'ebuild come ~arch per testarlo in portage perchè il rilascio è ritenuto stabile. Un'altro esempio, se Gimp decide di rilasciare una serie instabile/di sviluppo chiamata 1.3.0, allora questi ebuilds dovrebbero essere messi in <path>package.mask</path> perchè il software è di sviluppo e non è raccomandato dagli sviluppatori per la distribuzione.
</p>
<p>
Ogni pacchetto nuovo che entra in Portage deve essere contrassegnato da ~arch per l'architettura o le architetture per le quali questa versione è conosciuta funzionare. Lo sviluppatore che manda l'ebuild deve verificare che è funzionante, e che le KEYWORDS
sono corrette.
</p>
</body>
</section>

<section>
<title>Spostare le versioni dei pacchetti da ~ARCH a ARCH</title>
<body>
<p>
Quando una versione di un pacchetto ha dimostrato di essere stabile per un tempo sufficiente ed il mantenitore di Gentoo del pacchetto è sicuro che l'aggiornamento non romperà la macchina di un utente normale di Gentoo, allora può essere spostato da ~ARCH a ARCH. Un'indicazione della stabilità del pacchetto sarebbe un rapporto per un mese di errore non verificato e quindi non risolto, dopo l'introduzione della versione.
</p>
<p>
Spetta al mantenitore del pacchetto ritenere quali versioni siano stabili o se versioni di sviluppo dovrebbero essere messe in <path>package.mask</path> o lasciate in ~arch.
</p>
<p>
Dovete anche accertarvi che tutte le dipendenze di una versione del pacchetto siano inoltre in ARCH.
</p>
<warn>
Il punto ~ARCH può essere <e>solo</e> ignorato <e>se e solo se</e> la versione interessata del pacchetto contiene una riparazione di sicurezza o è necessario riparare un importante errore nel sistema di Gentoo.
</warn>
</body>
</section>
</chapter>

<chapter>
<title>Variabili</title>

<section>
<title>Variabili richieste</title>
<body>
<p>
La politica di Gentoo Linux richiede che tutti gli ebuilds contengano le variabili <c>KEYWORDS</c>, <c>LICENSE</c>,
e <c>SLOT</c>. Anche <c>HOMEPAGE</c>, <c>SRC_URI</c> e <c>DESCRIPTION</c> dovrebbero essere inclusi tranne circostanze speciali. <c>DEPEND</c> (e se necessario, <c>RDEPEND</c>) dovrebbe essere incluso se il vostro pacchetto ha qualunque dipendenza rispettivamente di tempo di esecuzione o di configurazione.
</p>
</body>
</section>

<section>
<title>DEPEND e RDEPEND</title>
<body>

<p>
Usate <c>DEPEND</c> per definire le dipendenze richieste per lo sviluppo di un pacchetto particolare, e regolate <c>RDEPEND</c> alle dipendenze richieste per <e>far funzionare</e> un pacchetto particolare. Dovete soltanto specificare <c>RDEPEND</c> se le dipendenze runtime dell'ebuild sono differenti rispetto a cosa avete specificato in <c>DEPEND</c>; se non specificato, <c>RDEPEND</c> si stabilizzerà ai vostri setting di <c>DEPEND</c>. Non regolate <b>mai</b>, voi stessi, <c>RDEPEND</c> al vostro <c>DEPEND</c> in un ebuild.
</p>
<pre>
# Acceptable:
RDEPEND="${DEPEND}
	net-ftp/curl
	virtual/glibc"
# Not acceptable:
RDEPEND="${DEPEND}"
</pre>

<p>
Inoltre è importante notare che soltanto le dipendenze di <c>RDEPEND</c> sono soddisfatte quando si installa un pacchetto binario <c>.tbz2</c>; usate queste informazioni per aiutarvi a scegliere le corrette dipendenze di <c>RDEPEND</c>. Se non definiti, i settings di <c>RDEPEND</c> dell'ebuild si stabilizzeranno a <c>DEPEND</c>.
</p>

<p> 
Un pacchetto dovrebbe dipendere dalla versione più vecchia che soddisfa la dipendenza. Se funziona con <c>libfoo-1.2.x</c>, non dipende da <c>libfoo-2.x</c> solo pechè questo è quello che avete installato.
</p>

<p>
In generale, i pacchetti dovrebbero dipendere da <c>=libfoo-1.2*</c> anziche da <c>&gt;=libfoo-1.2</c>. Altrimenti, le cose possono cominciare a rompersi orribilmente quando si mette <c>libfoo-2.0</c>.
</p>

<p>
Dipendendo da un entrata di un pacchetto virtuale come <c>virtual/foo</c> funzionerà soltanto quando i pacchetti differenti che forniscono <c>virtual/foo</c> hanno dentiche interfacce. Si consideri <c>virtual/jdk-1.3</c> per esempio. Alcuni pacchetti non funzionano con <c>ibm-jdk-1.3</c> mentre funzionano con <c>sun-jdk-1.3</c>. Per questa ragione, assicuratevi che il vostro paccheto sia esaminato contro tutti i providers virtuali prima dell'unmasking.  Può essere possibile che dipenda soltanto da un sottoinsieme di quei pacchetti nel pacchetto virtuale piuttosto che dal pacchetto virtuale stesso.
</p>

</body>
</section>

</chapter>

<chapter>
<title>Spostare pacchetti</title>
<section>
<title>Spostare pacchetti fra le categorie</title>
<body>

<p>
Di tanto in tanto, il Portage tree può aver bisogno di essere riorganizzato per dividere le categorie in eccesso in categorie specifiche più piccole. Per esempio, se ci sono un gran numero di pacchetti relativi a firewall in <c>net-misc</c>, la divisione di questi in una categoria più piccola sarebbe una riorganizzazione utile, considerando che la divisione di
<c>dev-perl</c> avrebbe un significato improbabile.
</p>

<p>
Questo genere di decisioni non è un qualcosa che dovrebbe essere preso da un singolo sviluppatore. Dovrebbe essere prima discussa sulla mailing list interna cosi possiamo condividere idee su soluzioni potenzialmente superiori.
</p>

<p>
Precedentemente, i pacchetti si spostavano aggiungendo <c>PROVIDE</c> a una riga del nuovo ebuild, che indurrebbe il pacchetto a soddisfare i settings di <c>DEPEND</c> degli ebuilds che sono ignari della nuova posizione del pacchetto. Il nuovo e corretto modo di spostare i pacchetti è di aggiungere una voce al file adatto in <path>profiles/updates/</path> nel Portage tree. La disposizione è come segue:
</p>

<pre>
move net-misc/fwbuilder net-firewall/fwbuilder
</pre>

<p>
In questo caso, stiamo spostando il pacchetto <c>fwbuilder</c> dalla categoria <c>net-misc</c> a <c>net-firewall</c>.
</p>

</body>
</section>
</chapter>

</guide>
