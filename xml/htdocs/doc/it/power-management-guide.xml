<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/power-management-guide.xml,v 1.8 2006/02/18 14:02:01 mascherpa Exp $ -->
<guide link="/doc/it/power-management-guide.xml">
<title>Guida alla Gestione Energetica</title>

<author title="Autore">
  <mail link="earthwings@gentoo.org">Dennis Nienhüser </mail>
</author>
<author title="Traduzione">
  <mail link="frgrieco@alice.it">Francesco Grieco</mail>
</author>

<abstract>
La gestione energetica è l'unica soluzione per estendere la durata della batteria
sui sistemi mobile come i notebook. Questa guida ne illustra la sua configurazione.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.27</version>
<date>2006-02-16</date>

<chapter>
<title>Introduzione</title>

<section>
<body>

<p>
Capacità e durata delle batterie dei notebook sono migliorate molto nel corso
degli ultimi anni. Tuttavia i moderni processori consumano molta più energia dei
vecchi e ad ogni nuova generazione di notebook si aggiungono nuove periferiche
"affamate" di energia. Ecco il perchè dell'importanza della gestione energetica.
Applicando buone politiche di risparmio energetico non sarà sempre necessario
acquistare un'altra batteria.
</p>

</body>
</section>

<section>
<title>Breve panoramica</title>
<body>

<p>
Questa guida tratta della gestione energetica per i <e>notebook</e>.
Alcune sezioni potrebbero essere valide anche per i <e>server</e>, altre
non lo sono sicuramente e potrebbero causare problemi. Si consiglia
fortemente di non applicare niente di quello contenuto in questa guida
a macchine server a meno che non si sappia veramente quello che si
sta facendo.
</p>

<p>
Poichè questa guida diventa sempre più lunga, segue una breve panoramica di 
ciò che sarà trattato.
</p>

<p>
La sezione <e>Prerequisiti</e> tratta di alcuni requisiti di base necessari
per tutte le sezioni a seguire della guida. Include settaggi del BIOS e 
particolari configurazioni nel kernel. I seguenti tre capitoli pongono 
l'attenzione sui componenti che tipicamente consumano maggiore energia - 
il processore, il display e l'hard disk. Ognuno di essi pùo essere configurato
separatamente. <e>Power Management della CPU</e> mostra come modificare la frequenza del
processore al fine di risparmiare energia senza un eccessivo calo delle performance.
Alcuni stratagemmi in <e>Power Management dell'Hard Disk</e> permettono di
allegerire il carico di lavoro del disco (avendo come effetto anche una 
riduzione del livello di rumore). Indicazioni anche per le card Wireless LAN e
per le periferiche USB in <e>Power Management delle altre periferiche</e> mentre
un altro intero capitolo è dedicato agli (ancora sperimentali) <e>Stati di Sleep</e>.
Infine un ultimo capitolo dedicato ai <e>Problemi</e> più comuni in cui 
è possibile incorrere.
</p>

</body>
</section>

<section>
<title>Bilancio energetico per ogni componente</title>
<body>

<figure link="/images/energy-budget.png" short="Quale componente consuma quanta 
energia?" caption="Peso energetico per ogni componente"/>

<p>
Quasi tutti i componenti possono funzionare in differenti stati - off, sleep, idle, active -
consumando a seconda dei casi diverse quantità di energia. La maggior parte dell'energia
viene consumata dal display LCD, dalla CPU e dagli hard disk. Spesso alcuni di essi
sono in grado di attivare politiche di gestione energetica attraverso il BIOS, ma
una configurazione intelligente del proprio sistema operativo adattabile
a diverse situazioni può ottenere molto di più.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisiti</title>
<section>
	
<body>

<p>Prima di trattare i dettagli della gestione energetica per le singole periferiche,
vi sono alcuni requisiti. Dopo aver controllato i settaggi del BIOS, è necessario 
attivare alcune opzioni del kernel - in breve ACPI, sleep states e CPU frequency scaling.
Poichè il risparmio energetico comporta una perdita delle prestazioni o un aumento
della latenza, deve essere attivato, naturalmente, solamente in assenza di una
connessione a rete elettrica. Da qui la necessità di un nuovo runlevel <e>battery</e>.
</p>

</body>
</section>
<section>
<title>Il BIOS</title>
<body>

<p>
Per prima cosa è necessario controllare i settaggi relativi al Power Management
nel BIOS. Di solito la soluzione migliore è combinare i settaggi del BIOS alle
politiche del sistema operativo, ma per il momento è meglio disabilitare le
funzioni del BIOS. In questo modo niente interferisce con le nuove politiche
imposte dal sistema operativo. Dopo aver configurato tutto per bene, sarà
necessario riabilitare tutte le funzioni del BIOS.
</p>

</body>
</section>
<section>
<title>Impostazione delle USE flag</title>	
<body>	

<p>
E' importante verificare che la USE flag <c>acpi</c> sia attivata
in <path>/etc/make.conf</path>. Altre USE flag che potrebbero interessare
il proprio sistema sono <c>apm</c>, <c>lm_sensors</c>, <c>nforce2</c>, <c>nvidia</c>,	
<c>pmu</c>. Per informazioni su queste ultime è possibile consultare
i file <path>/usr/portage/profiles/use*.desc</path>. Se, in qualsiasi momento,
ci si accorge della mancanza di una qualsiasi di queste flag, è possibile
ricompilare i pacchetti interessati con l'opzione <c>--newuse</c> di <c>emerge</c>;
maggiori informazioni con <c>man 1 emerge</c>.
</p>

</body>	
</section>	
<section>

<title>Configurazione del Kernel</title>
<body>

<p>
Il supporto dell'ACPI (Advanced Configuration and Power Interface) nel kernel
è ancora in fase di sviluppo. Pertanto è consigliabile usare sempre il kernel
più recente.
</p>

<p>
In Portage ci sono differenti versioni del kernel. Quelle consigliate
sono <c>gentoo-sources</c> e <c>suspend2-sources</c>. La seconda, in particolare,
contiene le ultime patch per il supporto Software Suspend 2; si veda la sezione
sugli stati di sleep per maggiori dettagli. Nelle opzioni di configurazione del 
kernel vanno, in ogni caso, attivate le opzioni seguenti:
</p>

<pre caption="Settaggi minimi del kernel per il Power Management (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservative' cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>driver CPUFreq a seconda del processore</i>
</pre>

<p>
E' possibile attivare, a propria discrezione, Software Suspend e Sleep States.
I possessori di notebook ASUS, Medion, Thinkpad IBM o Toshiba devono attivare i relativi 
moduli specifici. 
</p>

<p>
Il kernel deve essere in grado di attivare il CPU frequency scaling (cambio di frequenza della CPU) sul processore. Poichè ogni CPU presenta una interfaccia differente dalle altre, è necessario scegliere il driver giusto per il proprio processore. Si presti attenzione - ad esempio attivando 
<e>Intel Pentium 4 clock modulation</e> su un Pentium M, si otterà molto probabilmente un sistema poco stabile. La documentazione del kernel può chiarire qualsiasi dubbio in proposito.
</p>

<p>
Dopo la compilazione del kernel bisogna assicurarsi del corretto caricamento dei moduli
all'avvio e riavviare il notebook con il nuovo kernel con ACPI abilitato. Per installare il demone acpi,
da riga di comando <c>emerge sys-power/acpid</c>. Il suddetto demone gestisce
eventi quali il passaggio da corrente a batteria o la chiusura del lid. E' necessario
assicurarsi che i moduli siano caricatici se non compilati direttamente
all'interno del proprio kernel. Ora si avvii il demone acpid con <c>/etc/init.d/acpid
start</c> e si esegua <c>rc-update add acpid default</c> per caricarlo all'avvio. Il suo
utilizzo verrà spiegato in seguito.
</p>

<pre caption="Installazione di acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creazione del runlevel "battery"</title>
<body>

<p>
La configurazione di default attiverà il risparmio energetico solo quando
necessario - in pratica quando il notebook funziona con la propria
batteria. Per effettuare il passaggio fra stato di corrente e di batteria,
sarà necessario creare un runlevel <e>battery</e> in grado di gestire
l'avvio e il blocco degli script di risparmio energetico.
</p>

<note>
Se l'idea di avere un ulteriore runlevel non convince, è possibile saltare
questa sezione. Naturalmente ciò renderà tutto un pò più complicato. La
sezione seguente considera l'esistenza di un runlevel <e>battery</e>.
</note>

<pre caption="Creazione di un runlevel battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finito. Il nuovo runlevel <e>battery</e> contiene tutto come <e>default</e>, ma 
non c'è ancora nessun cambio automatico tra i due livelli.
</p>

</body>
</section>
<section>
<title>Risposta agli eventi ACPI</title>
<body>

<p>
Di solito gli eventi ACPI sono la chiusura del lid, il cambio della sorgente
energetica e il bottone di sleep. Il cambio di sorgente energetica è un evento
importante e deve necessariamente generare un cambio di runlevel. Di questo
si occuperà un piccolo script.
</p>

<p>
E' necessario uno script in grado di cambiare il runlevel fra <c>default</c>
e <c>battery</c> a seconda della sorgente energetica utilizzata. Lo
script utilizzata il comando <c>on_ac_power</c> fornito da
<c>sys-power/powermgmt-base</c> - ci si assicuri dell'installazione di tale
pacchetto nel proprio sistema.
</p>

<pre caption="Installazione di powermgt-base">
<i># emerge powermgmt-base</i>
</pre>

<p>
Ora, tramite il comando <c>on_ac_power &amp;&amp; echo AC available || echo Running on batteries</c> eseguito in shell è possibile determinare la sorgente energetica
in uso.
Lo script seguente è responsabile del cambio di runlevel.
Va salvato come <path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># INIZIO configurazione</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># FINE configurazione</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
	logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
	exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
	logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
	exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
	    logger "Switching to ${RUNLEVEL_AC} runlevel"
	    /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
	logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
	/sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
Con il comando <c>chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</c> si
rende lo script eseguibile. Infine è necessario che lo script venga eseguito
ad ogni cambio di sorgente energetica dal demone <c>acpid</c>. Bisogna, però,
sapere quali eventi vengono generati al cambio di sorgente energetica. Gli
eventi vengono chiamati <e>ac_adapter</e> e <e>battery</e> sulla maggior parte
dei notebook, ma si potrebbero avere delle eccezioni.
</p>

<pre caption="Determinazione degli eventi ACPI al cambio di sorgente energetica">
<i># tail -f /var/log/acpid | grep "received event"</i>
</pre>

<p>
Si esegua il comando sopra indicato e si stacchi il cavo di alimentazione dal
proprio notebook.
</p>

<pre caption="Esempio di output al cambio di sorgente energetica">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
La parte interessante di questo output è quella che segue <e>received event</e>
fra le virgolette. Sarà necessario inserire queste stringhe nello script che segue.
In caso il proprio notebook dovesse generare più eventi o sempre lo stesso evento,
non c'è da preoccuparsi.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Si sostituisca "ac_adapter" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Ad esempio ac_adapter.* sarà sostituito da ac_adapter AC 00000080 00000000</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Si sostituisca "battery" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Ad esempio battery.* sarà sostituito da battery BAT0 00000080 00000001</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Sarà necessario riavviare il demone acpid per rendere attivi i cambiamenti
apportati.
</p>

<pre caption="Riavvio del demone acpid">
<i># /etc/init.d/acpid restart</i>
</pre>


<p>
Provando ora ad attaccare e staccare l'alimentazione a corrente, nei log di
sistema dovrebbero apparire a seconda dei casi i messaggi "Switching to AC
mode" o "Switching to battery mode".
Se lo script non è in grado di rilevare correttamente la sorgente di energia
utilizzata, è possibile consultare la sezione Problemi.
</p>

<p>
A causa della natura del meccanismo degli eventi, il notebook, al boot,
passa al runlevel default che sia o meno collegato alla rete elettrica.
Questo va bene se si è collegati direttamente a rete elettrica,
certamente no quando si avvia da batteria.
Una soluzione potrebbe essere l'aggiunta di un parametro del tipo
<c>softlevel=battery</c> al proprio boot loader, ma ci si potrebbe dimenticare
di selezionarlo. Una soluzione migliore è sicuramente quella di generare
un finto evento ACPI alla fine del processo di boot e lasciare che lo script
<path>pmg_switch_runlevel.sh</path> decida quale runlevel utilizzare.
Si apra con il proprio editor il file <path>/etc/conf.d/local.start</path>
e si aggiungano le linee:
</p>

<pre caption="Cambio del runlevel al boot del notebook con la modifica di local.start">
<comment># Finto evento acpi per cambiare runlevel se scollegati da rete elettrica</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Conclusa questa parte preparativa, è ora possibile attivare le politiche di
gestione energetica per ogni singolo componente.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management della CPU</title>
<section>
	
<body>	

<p>
I processori <e>mobile</e> possono operare a frequenze differenti. Alcuni di
essi permettono il cambio del proprio voltaggio. In molte situazioni, la CPU
non lavora a pieno carico e quindi abbassandone la frequenza, si otterrà un
notevole risparmio energetico, spesso senza nemmeno un decremento prestazione.
</p>	

</body>	
</section>

<section>
<title>Terminologia tecnica</title>
<body>

<p>
Il CPU frequency scaling introduce alcuni termini tecnici che potrebbero
essere non conosciuti. Segue, per questo motivo, una breve introduzione.
</p>

<p>
Prima di tutto, il kernel deve essere in grado di cambiare la frequenza
di funzionamento della CPU. Il <e>CPUfreq processor driver</e> contiene
i comandi per effettuare questa operazione su ogni tipo di CPU. Per questo motivo è importante
indicare il driver giusto da utilizzare nel proprio kernel (operazione già
effettuata precedentemente). Inoltre, il kernel deve anche scegliere la
frequenza corretta di funzionamento da utilizzare nelle diverse situazioni. Questa viene
fissata in base ad una <e>policy</e> (politica di gestione) che consiste in
una <e>CPUfreq policy</e> e in un <e>governor</e> (regolatore).
Una CPUfreq policy non è altro che un insieme di due numeri che definiscono
un campo all'interno del quale la frequenza può oscillare - un valore minimo e
uno massimo. Il governor, invece, decide quale delle frequenze disponibili fra la
minima e la massima utilizzare. Ad esempio, il <e>powersave governor</e> utilizza
sempre la frequenza più bassa disponibile, il <e>performance governor</e>, invece,
la più alta. L'<e>userspace governor</e> non sceglie nessuna frequenza in particolare
ma utilizza quella indicata dall'utente (o da un programma in
userspace); il valore della frequenza viene letto da 
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Questo può non sembrare un cambiamento dinamico della frequenza e in effetti non lo
è. La dinamicità può essere realizzata con diversi approcci.
Ad esempio, <e>ondemand governor</e> prende le sue decisioni in
base al carico di lavoro della CPU. La stessa cosa viene fatta
da utility come <c>cpudyn</c>, <c>cpufreqd</c>, <c>powernowd</c> e
molte altre. Gli eventi ACPI possono essere utilizzati per attivare o
disattivare i cambi dinamici della frequenza a seconda della sorgente energetica utilizzata.
</p>

</body>
</section>

<section>
<title>Settaggio manuale della frequenza</title>
<body>

<p>
Diminuendo la velocità e il voltaggio della CPU si hanno due vantaggi: viene
consumata meno energia e il notebook non si riscalda eccessivamente. Il grande
svantaggio, naturalmente, è una perdita di performance. La diminuzione della
velocità del processore resta in ogni caso un buon compromesso fra calo di
performance e risparmio energetico.
</p>

<note>
Non tutti i notebook supportano il frequency scaling. In caso di dubbi, una lista
dei processori supportati si trova nella sezione <e>Problemi</e>.
</note>

<p>
E' ora di provare il corretto funzionamento del cambio di frequenza della CPU.
<c>sys-power/cpufrequtils</c> è un programmino molto utile per effettuare un semplice debug.
</p>

<pre caption="Controllo della frequenza della CPU">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Ecco un esempio di quello che si ottiene:
</p>

<pre caption="Output di esempio di cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
 driver: centrino
 CPUs which need to switch frequency at the same time: 0
 hardware limits: 600 MHz - 1.40 GHz
 available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
 available cpufreq governors: conservative, ondemand, powersave, userspace, performance
 current policy: frequency should be within 924 MHz and 1.40 GHz.
  The governor "performance" may decide which speed to use
  within this range.
 current CPU frequency is 1.40 GHz.
</pre>

<p>
Si utilizzi <c>cpufreq-set</c> per assicurarsi che il cambio di frequenza funzioni.
Il comando <c>cpufreq-set -g ondemand</c>, ad esempio, attiva l'ondemand governor;
lo si esegua e si verifichi il cambiamento con <c>cpufreq-info</c>. Se non funziona
come dovrebbe, la sezione Problemi alla fine di questa guida potrebbe essere d'aiuto.
</p>

</body>
</section>
<section>
<title>Adattamento automatico della frequenza</title>
<body>

<p>
Tutto questo è molto semplice, ma scomodo da effettuare tutti i giorni. Meglio lasciare che sia
il proprio sistema a settare automaticamente la frequenza appropriata. 
La tabella seguente presenta una panoramica delle utility necessarie a questo compito. E' suddivisa
in tre categorie: <e>kernel</e> per soluzioni che hanno bisogno solo
del supporto del kernel, <e>demone</e> per programmi che lavorano in
background e <e>GUI</e> per programmi che forniscono una interfaccia
grafica per una configurazione più semplice.
</p>

<table>
<tr>
  <th>Nome</th>
  <th>Categoria</th>
  <th>Causa cambio</th>
  <th>Governor del kernel</th>
  <th>Governor supportati</th>
  <th>Note</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>Carico della CPU</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
	Scegle la frequenza massima in caso di carico della CPU e frequenze
	man mano più basse in caso di CPU libera.
    Configurazione attraverso i file presenti in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>.
    Richiede ancora tool in userspace (programmi, script) in caso
    di utilizzo del cambio di governor.
  </ti>
</tr>
<tr>
	<ti>'conservative' governor</ti>
	<ti>Kernel</ti>
	<ti>Carico della CPU</ti>
	<ti>N.A.</ti>
	<ti>N.A.</ti>
	<ti>
	A differenza dell'ondemand governor, il conservative non salta alla massima
	frequenza quando il carico della CPU cresce, ma aumenta poco alla volta
	la frequenza. Configurazione attraverso i file presenti in
	<path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Richiede ancora
	tool in userspace (programmi, script) in caso di utilizzo del cambio di
	governor.
	</ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Performance, powersave</ti>
  <ti>Dynamic</ti>
  <ti>
    Supporta anche lo standby dei dischi - si noti, però, che il <e>laptop mode</e>
    in molti casi funziona decisamente meglio.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demone</ti>
  <ti>Stato della batteria, Carico della CPU, Temperatura, Programmi in
  esecuzione e altro</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Configurazioni sofisticate (ma anche piuttosto complesse). Estendibile tramite plugin
	per il monitoraggio sensori (lm_sensors) oppure per schede grafiche NVidia. Cpufreqd 
	supporta SMP e può essere controllato manualmente durante la propria esecuzione.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>
    Supporta SMP.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://fatcat.ftj.agh.edu.pl/~nelchael/index.php?cat=projs&amp;subcat=ncpufreqd&amp;language=en">ncpufreqd</uri>
  </ti>
	<ti>Demone</ti>
	<ti>Temperatura</ti>
	<ti>Nessuno</ti>
	<ti>Powersave, performance</ti>
	<ti>
	Passa da modalità performance a powersave a seconda della temperatura del sistema.
	Molto utile su notebook con noti problemi di surriscaldamento.
	</ti>
</tr>
  	 <tr>	
	
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Semplice da configurare con una interfaccia client/server. Richiede un 
    kernel della serie 2.6. Il suo sviluppo è stato interrotto, non è più funzionante
	e per questo motivo è stato rimosso da Portage.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>GUI</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>
    Applicazione per Gnome, utility grafica per configurare manualmente la
    frequenza della CPU. Non offre nessun tipo di automazione.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>GUI</ti>
  <ti>Stato della batteria</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Solamente per KDE, 'ondemand' governor necessario per il cambio dinamico della
    frequenza.
  </ti>
</tr>
</table>

<p>
L'adattamento della frequenza della CPU al carico di lavoro corrente del notebook
può sembrare semplice da attuare ad una prima occhiata, ma in realtà non lo è.
Un algoritmo errato può causare cambi continui fra due frequenze o
spreco di energia quando la frequenza viene portata inutilmente a valori troppo alti.
</p>

<p>
Quale scegliere? Se si è indecisi, un'ottima scelta è <c>cpufreqd</c>:
</p>

<pre caption="Installazione di cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
La configurazione di <c>cpufreqd</c> avviene attraverso il file <path>/etc/cpufreqd.conf</path>.
Quella di default fornita con cpufreqd sembra leggermente confusionaria. Si raccomanda
di sostituirla con quella fornita dallo sviluppatore Gentoo, Henrik Brix Andersen (si guardi di seguito).
E' necessaria almeno la versione 2.0.0 di cpufreqd. Le versioni precedenti presentano
una sintassi differente per il file di configurazione.
</p>

<pre caption="/etc/cpufreqd.conf (versione 2.0.0 e superiori)">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=3
enable_plugins=acpi_ac, acpi_battery	
enable_remote=1	
remote_group=wheel
verbosity=5
[/General]
	
[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand
[/Profile]

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative
[/Profile]

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave
[/Profile]

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance
[/Profile]

[Rule]
name=battery
ac=off
profile=conservative
[/Rule]

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave
[/Rule]

[Rule]
name=ac
ac=on
profile=ondemand
[/Rule]
</pre>

<p>
Ora si può avviare il demone cpufreqd. Lo si aggiunga ai runlevel <e>default</e> e
<e>battery</e> come mostrato di seguito.
</p>

<pre caption="Avvio di cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<p>	
Alcune volte può essere opportuno selezionare un'altra politica di gestione rispetto
a quella scelta dal demone, ad esempio quando la batteria è quasi scarica, ma si
è certi dell'imminente connessione a rete elettrica. In questo caso è possibile
attivare la modalità manuale di cpufreqd con il comando <c>cpufreqd-set manual</c>
selezionando una delle proprie politiche configurate (elencate tramite
<c>cpufreqd-get</c>). Si può abbandonare la modalità manuale con il comando
<c>cpufreqd-set dynamic</c>.	
</p>	


<warn>
Non si esegua più di uno dei programmi sopra citati contemporaneamente. Potrebbero, infatti, esserci problemi come un cambio continuo fra due frequenze.
</warn>

</body>
</section>

<section>
<title>Verifica di funzionamento a seguito delle modifiche apportate</title>

<body>

<p>
L'ultima cosa da controllare è che le nuove politiche di risparmio energetico
facciano bene il loro lavoro. Un modo semplice per verificare ciò è il 
monitoraggio della velocità della CPU mentre è al lavoro sul notebook:
</p>

<pre caption="Monitoraggio della velocità della CPU">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Se <path>/proc/cpuinfo</path> non dovesse venire aggiornato (sezione Problemi), si provi a monitorare 
la frequenza della CPU con:
</p>

<pre caption="Monitoraggio alternativo della velocità della CPU">
# <i>watch x86info -mhz</i>
</pre>

<p>
A seconda dei settaggi, la velocità della CPU dovrebbe aumentare in caso di richieste
d'uso, diminuire in mancanza di attività o, semplicemente, rimanere costante. Quando
si utilizza cpufreqd e la voce verbosity è impostata ad un valore di 5 o più in <path>cpufreqd.conf</path>,
nei syslog si otterrano maggiori informarzioni su quello che accade.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management del display LCD</title>
<section>
<body>

<p>
Come si può vedere dalla <uri link="#doc_chap1_fig1">figura 1.1</uri>, il display
LCD consuma la maggior parte dell'energia (questo potrebbe non valere nel caso
di CPU non mobile). Per questo non solo è importante spegnere il display quando
non utilizzato, ma anche ridurre il backlight (retroilluminazione) se possibile.
Molti notebook offrono la possibilità di regolare il backlight.
</p>

</body>	
</section>	
<section>	
<title>Configurazione Standby</title>	
<body>

<p>
La prima cosa da controllare sono i settaggi di standby/suspend/off del display.
Questi sono tutti valori che dipendono dal windowmanager. L'oscuramento del
terminale può essere effettuato con <c>setterm -blank &lt;numero-di-minutiM&gt;</c>,
<c>setterm -powersave on</c> e <c>setterm -powerdown &lt;numero-di-minutiM&gt;</c>.
Per X.org, si può editare <path>/etc/X11/xorg.conf</path> come di seguito riportato:
</p>

<pre caption="Settaggi dell'LCD suspend in X.org e in XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Oscura lo schermo dopo cinque minuti (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># Spegne lo schermo dopo 10 minuti (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Suspend dopo 20 minuti</comment>
  Option  "OffTime"  "30"  <comment># Spegne dopo mezz'ora</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Vale lo stesso per XFree86 e <path>/etc/X11/XF86Config</path>.
</p>

</body>	
</section>	
<section>	
<title>Backlight</title>	
<body>	

<p>
Probabilmente la gestione del backlight (retroilluminazione) è il punto più importante.
Se si è in grado di accedere al controllo tramite un tool, bisogna scrivere un piccolo
script in grado di settare il backlight nella modalità batteria e inserirlo nel
runlevel <e>battery</e>. Lo script seguente dovrebbe funzionare sulla maggior parte
dei notebook IBM Thinkpad e Toshiba. Per gli IBM Thinkpad bisogna attivare le opzioni
appropriate nel kernel. Per i notebook Toshiba è sufficiente l'installazione del pacchetto
<c>app-laptop/acpitool</c> (non sono necessarie le istruzioni seguenti ibm_acpi).
</p>

<warn>
Il supporto per la regolazione della luminosità è sperimentale nel pacchetto
ibm-acpi. L'accesso diretto all'hardware di questa utility potrebbe provocare blocchi inaspettati del sistema.
Si legga a tale proposito il <uri link="http://ibm-acpi.sourceforge.net/">sito ufficiale</uri> del pacchetto ibm-acpi.
</warn>

<p>
Per essere in grado di regolare il livello di lumonisità, il modulo ibm_acpi deve essere
caricato con il paramentro sperimentale.
</p>

<pre caption="Caricamento automatico del modulo ibm_acpi">
<comment>(Prima di proseguire si legga l'avviso sopra riportato circa l'instabilità di questa opzione)</comment>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
Queste operazioni non dovrebbero produrre messaggi di errore e, 
dopo il caricamento del modulo, dovrebbe essere creato il file  <path>/proc/acpi/ibm/brightness</path>.
Uno script di avvio avrà il compito di scegliere il miglior livello di luminosità
in base alla sorgente energetica disponibile.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Si legga /proc/acpi/ibm/brightness per i valori disponibili</comment>
<comment># Per altre informazioni /usr/src/linux/Documentation/ibm-acpi.txt</comment>

<comment># Livello di lumonisità in modalità corrente. Di default 7.</comment>
BRIGHTNESS_AC=7

<comment># Livello di luminosità in modalità batteria. Di default 4..</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
	if on_ac_power
	then
            LEVEL=${BRIGHTNESS_AC:-7}
	else
            LEVEL=${BRIGHTNESS_BATTERY:-4}
	fi

	if [ -f /proc/acpi/ibm/brightness ]
	then
	    ebegin "Setting LCD brightness"
	    echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
	    eend $?
	elif [[ -e /usr/bin/acpitool &amp;&amp; -n $(acpitool -T | grep "LCD brightness") ]]	
	then	
		ebegin "Setting LCD brightness"	
		acpitool -l $LEVEL >/dev/null || ewarn "Unable to set lcd brightness"	
 	    eend $?
	else
	    ewarn "Setting LCD brightness is not supported."
		ewarn "For IBM Thinkpads, check that ibm_acpi is loaded into the kernel"	
 	    ewarn "For Toshiba laptops, you've got to install app-laptop/acpitool"
	fi
}
	
start() {
	set_brightness
}

stop () {
	set_brightness
}
</pre>

<p>
Una volta finito, bisogna assicurarsi che la luminosità sia regolata automaticamente
aggiungendo lo script al runlevel battery.
</p>

<pre caption="Regolazione automatica della luminosità">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>


</body>
</section>
</chapter>

<chapter>
<title>Power Management dell'Hard Disk</title>
<section>
<body>
	
<p>	
Gli Hard Disk consumano meno energia in modalità sleep. Quindi ha senso
attivare la modalità risparmio energetico ogni qual volta l'hard disk non
viene utilizzato per un certo intervallo di tempo. Ci sono due metodi
per questo. Il laptop-mode, il primo, permette un risparmio energetico
grazie ad alcune misure che prevengono o al massimo ritardano gli accessi
in scrittura. Lo svantaggio è dato dal fatto che uno sbalzo energetico
o un crash del kernel potrebbero portare a perdite di dati.
Se si vogliono evitare queste situazioni, sarà bene accertarsi che non
siano attivi processi che necessitano di scritture frequenti.
Il secondo metodo è l'attivazione dell'opzione risparmio energetico
del proprio hard disk tramite hdparm.
</p>	
	
</body>	
</section>	

<section>	
<title>Aumento del tempo di idle - laptop-mode</title>	
<body>	

<p>
Gli ultimi kernel (2.6.6 e maggiori, gli ultimi della serie 2.4 e altri con alcune patch)
includono il così detto <e>laptop-mode</e>. Quando attivato, i buffer vengono scritti sul
disco alle chiamate read oppure dopo 10 minuti (invece di 30 secondi). Questo fà si che l'hard disk
non lavori in maniera continuativa.
</p>
	
<pre caption="Avvio automatico del laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>
	
<p>
I <c>laptop-mode-tools</c> hanno la propria configurazione in 
<path>/etc/laptop-mode/laptop-mode.conf</path>. E' possibile
adattarla alle proprie esigenze; la documentazione è presente nel file di configurazione stesso.
Per rendere automatico l'avvio <c>rc-update add laptop_mode battery</c>.
</p>
		
<p>	
Le ultime versioni (dalla 1.11 in avanti) dei laptop-mode-tools includono
<c>lm-profiler</c>. Questo tool effettuerà un monitoraggio dell'utilizzo
del disco del proprio sistema e dei servizi di rete in esecuzione consigliando
la disabilitazione di quelli non necessari. Sarà possibile disattivarli
attraverso il supporto runlevel integrato nei laptop-mode-tools (sostituiti
da <c>/sbin/rc</c> di Gentoo) o attraverso i propri runlevel
<e>default</e>/<e>battery</e> (raccomandato).
</p>	
		
<pre caption="Output d'esempio dell'esecuzione di lm-profiler">	
# lm-profiler	
Profiling session started.	
Time remaining: 600 seconds	
[4296896.602000] amarokapp	
Time remaining: 599 seconds	
[4296897.714000] sort	
[4296897.970000] mv	
Time remaining: 598 seconds	
Time remaining: 597 seconds	
[4296900.482000] reiserfs/0	
</pre>

<p>
A seguito del monitoraggio di dieci minuti, lm-profiler mostrerà un elenco di servizi
responsabili di accessi al disco durante il tempo di osservazione.
</p>

<pre caption="Richiesta di disabilitazione servizi di lm-profiler">
Program:     "atd"	
Reason:      standard recommendation (program may not be running)	
Init script: /etc/init.d/atd (GUESSED)	

Do you want to disable this service in battery mode? [y/N]: n	
</pre>	

<p>	
Per disabilitare atd come suggerito dall'esempio sopra riportato, sarà necessario
il comando <c>rc-update del atd battery</c>. Si presti attenzione a non disabilitare
servizi essenziali al corretto funzionamento del proprio sistema - lm-profiler genera
facilmente falsi positivi.
</p>	

</body>	
</section>
<section>
<title>Limiting write accesses</title>
<body>
<p>	
Se non si vuole utilizzare il laptop-mode, sarà necessario prestare maggiore
attenzione nel disattivare servizi che accedono frequentemente al disco - 
<c>syslogd</c> è un buon candidato ad esempio. Probabilmente non lo si vorrà
bloccare completamente, ma una modifica al suo file di configurazione al fine
di evitare un logging eccessivo sarà una soluzione migliore. Cups scrive su 
disco periodicamente, quindi si consideri l'idea di bloccarlo definitivamente
così da attivarlo solo quando effettivamente necessario.
</p>	
	
<pre caption="Disattivazione di cups nella modalità batteria">	
# <i>rc-update del cupsd battery</i>
</pre>

<p>
E' anche possibile utilizzare <c>lm-profiler</c> dei laptop-mode-tools (si legga
sopra) per cercare servizi da disabilitare. Una volta eliminati tutti quelli interessati,
si può passare alla configurazione di hdparm.
</p>	

</body>	
</section>	

<section>	
<title>hdparm</title>	
<body>	

<p>	
La seconda possibilità è l'utilizzo di un piccolo script e di hdparm.
Se si è scelto l'utilizzo del laptop-mode, si salti questa parte.
Si crei il file <path>/etc/init.d/pmg_hda</path>:
</p>

<pre caption="Uso di hdparm per lo standby dell'hard disk">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Con <c>man hdparm</c> è possibile avere informazioni sulle varie opzioni.
Una volta pronto, è necessario aggiungere lo script al runlevel battery.
</p>

<pre caption="Configurazione per lo standby automatico del disco">
# <i>chmod +x /etc/init.d/pmg_hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pmg_hda battery</i>
</pre>

<impo>
Si presti molta attenzione ai settaggi di sleep e di spin down del proprio hard disk.
Settaggi troppo spinti (valori molto piccoli) possono danneggiare l'hardware e invalidare
la garanzia.
</impo>

</body>
</section>
<section>
<title>Altri consigli</title>
<body>

<p>
Un'altra possibilità è la disattivazione dello swap nella modalità batteria.
Prima di scrivere qualcosa che attivi e disattivi lo swap, bisogna assicurarsi
che ci sia abbastanza RAM e che lo swap non sia usato pesantemente, altrimenti
si potrebbero avere problemi.
</p>

<p>
Se non si vuole utilizzare il laptop-mode, è sempre possibile minimizzare gli
accessi al disco montando alcune directory come <e>tmpfs</e> - gli accessi in
scrittura non avvengono sul disco, ma nella memoria principale e vengono
persi con l'operazione di unmount. Spesso è utile montare <path>/tmp</path>
allo stesso modo - il suo contenuto viene in ogni caso perso ad ogni reboot
che sia montato o meno sul disco o in RAM. Bisogna solo essere certi
di avere RAM a sufficienza e nessun programma (come un client per i download o
un programma di compressione) che abbia bisogno di molto spazio in <path>/tmp</path>.
Per usare questa soluzione è necessario avere il supporto tmpfs abilitato
nel kernel e  aggiungere una linea come la seguente in <path>/etc/fstab</path>:
</p>

<pre caption="Modifica di /etc/fstab per rendere /tmp volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Si presti attenzione al parametro size e lo si modifichi per il proprio sistema.
Se non si è sicuri, non lo si modifichi, in quanto si creerebbero facilmente
grossi cali di performance (effetto collo di bottiglia). Se si volesse montare
<path>/var/log</path> nello stesso modo, non bisogna dimenticare di unire i file
di log al disco prima di effettuare l'unmounting. Sono essenziali. Montare anche
/var/tmp allo stesso modo è inutile. Portage usa questa directory per la compilazione...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Power Management per altre periferiche</title>
<section>
<title>Schede grafiche</title>
<body>
	
<p>
Se si è in possesso di una scheda grafica ATI con supporto PowerPlay (dynamic
clock scaling per le GPU, graphic processing unit), in X.org è possibile
abilitare questa caratteristica. Bisogna aprire il file 
<path>/etc/X11/xorg.conf</path> e aggiungere (oppure attivare) l'opzione
<c>DynamicClocks</c> nella sezione Device. Questa opzione attivita su alcuni
sistemi può provocare blocchi o crash.
</p>
	
<pre caption="Attivazione del supporto PowerPlay per le schede grafiche ATI in X.org">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>
	
</body>
</section>
<section>
<title>Power Management del Wireless</title>
<body>

<p>
Le card Wireless LAN consumano poca energia. E' possibile inserirle nella modalità
risparmio energetico in analogia allo script pmg_hda.
</p>

<note>	
Questo script considera la propria interfaccia wireless come <c>wlan0</c>;
si sostituisca questo valore con il nome della propria.
</note>

<pre caption="Power Management automatico per le WLAN">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
L'esecuzione di questo script attiverà il risparmio energetico per la wlan0.
Lo si salvi come <path>/etc/init.d/pmg_wlan0</path> e lo si aggiunga al runlevel
battery come gli altri. Per dettagli e maggiori opzioni come il periodo di
wakeup e impostazioni del timeout <c>man iwconfig</c>.
Se i propri driver oppure l'access point supportano il cambio del beacon time,
questo può essere un altro modo per risparmiare ancora più energia.
</p>

<pre caption="Power Management for WLAN">
# <i>chmod +x /etc/init.d/pmg_wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pmg_wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>USB Power Management</title>
<body>

<p>
Ci sono due problemi riguardo il consumo di energia delle periferiche USB: 
primo, periferiche come i mouse USB, le fotocamere digitali o le USB stick consumano
energia appena inserite. Non si può ovviare in nessun modo a questo problema 
(a meno che non vengano rimosse se non necessarie). Secondo, quando ci sono
periferiche USB collegate, l'USB host controller accede periodicamente al bus
non permettendo alla CPU di passare nella modalità sleep.
Il kernel presenta una opzione sperimentale per attivare la sospensione delle 
periferiche USB tramite le chiamate al driver oppure tramite uno dei file
<path>power/state</path> in <path>/sys</path>.
</p>

<pre caption="Attivazione del supporto USB suspend nel kernel">
Device Drivers
 USB support
  [*]   Support for Host-side USB
    [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Stati di Sleep: sleep, standby, suspend to disk</title>
<section>
<body>

<p>
L'ACPI definisce differenti stati di sleep. I più importanti sono
</p>

<ul> 
  <li>S1 ossia Standby</li>
  <li>S3 ossia Suspend to RAM ossia Sleep</li>
  <li>S4 ossia Suspend to Disk ossia Hibernate</li>
</ul>

<p>
Possono essere chiamati quando il sistema non è in uso, ma non si vuole
effettuare lo shutdown a causa del lungo tempo di boot.
</p>

</body>
</section>
<section>
<title>Sleep (S3)</title>
<body>
<p>
Il supporto ACPI per questi stati di spleep è considerato sperimentale per
delle buone ragioni. Gli stati di sleep APM sembrano essere più stabili, purtroppo
non è possibile utilizzare contemporaneamente APM e ACPI.
</p>
		
<pre caption="Configurazione del kernel per il supporto agli stati di sleep">
 Power Management Options ---&gt;
  [*]  Power Management support
     ACPI (Advanced Configuration and Power Interface) Support ---&gt;
      [*]  ACPI Support
        [*]   Sleep States
</pre>
		
<p>
Compilato il kernel con le opzioni sopra considerate, è possibile utilizzare
l'<c>hibernate-script</c> per attivare la sospensione o una modalità di sleep.
</p>
		
<pre caption="Installazione dell'hibernate-script">
<i># emerge hibernate-script</i>
</pre>
		
<p>
Sono ora necessarie alcune configurazioni in <path>/etc/hibernate</path>.
Di default, il pacchetto appena installato contiene due file di configurazione:
<path>hibernate.conf</path> e <path>ram.conf</path>.
</p>
		
<p>
Per configurare lo sleep, bisogna modificare <path>ram.conf</path> in 
<path>/etc/hibernate</path>. 
<c>UseSysfsPowerState mem</c> è settato correttamente, ma sarà necessario scorrere
il resto del file di configurazione e modificarlo secondo il proprio sistema.
I commenti e i nomi delle opzioni saranno di aiuto. In caso di condivisioni
samba o nfs in una rete, bisognerà assicurarsi di bloccare gli script init per
evitare errori di timeout.
</p>
		
<p>
Giunti a questo punto, questa sarà l'ultima occasione per effettuare un backup dei
propri dati prima dell'esecuzione del prossimo comando. Probabilmente per tornare
indietro dallo stato di sleep, occorrerà premere un tasto speciale come <e>Fn</e>.
</p>
		
<pre caption="Chiamata di sleep">
<i># hibernate-ram</i>
</pre>
	
<p>
Se si sta ancora leggendo questa guida, sarà segno di un corretto funzionamento.
Sarà possibile anche configurare lo standby (S1) in maniera simile copiando
<path>ram.conf</path> in <path>standby.conf</path> e creando un link simbolico 
a <path>/usr/sbin/hibernate</path> chiamato <path>/usr/sbin/hibernate-standby</path>.
S3 e S4 sono gli stati di sleep più importanti poichè permetteno un grande
risparmio di energia.
</p>
		
</body>
</section>
<section>
<title>Hibernate (S4)</title>
<body>

<p>
Questa sezione tratta dell'ibernazione; un'immagine del sistema in esecuzione
viene scritta sul disco prima dello spegnimento. Alla riaccensione (resume), 
l'immagine viene caricata ed è possibile riprendere il proprio lavoro dal 
punto esatto in cui lo si è interrotto prima dell'ibernazione.
</p>

<warn>
Nessuna periferica hot-plug va cambiata o scambiata in stato di sospensione.
Non si carichi un'immagine con un kernel differente rispetto a quello con cui
la si è creata.
Ogni client/server samba o nfs va bloccato prima dell'ibernazione.
</warn>

<p>
Attualmente ci sono due implementazioni per S4. Quella originale è swsusp,
poi c'è la più nuova suspend2 con un'interfaccia carina (supporto fbsplash
incluso). E' possibile trovare
<uri link="http://suspend2.net/features.html#compare">un'analisi comparativa</uri>
alla <uri link="http://suspend2.net">homepage di suspend2</uri>.
Suspend-to-Disk (pmdisk), un fork di swsusp, è stato riunito al progetto
originale.
</p>

<p>
Suspend2 non è ancora incluso nel kernel ufficiale, per questo motivo sarà
necessario applicare una patch, disponibile all'indirizzo 
<uri link="http://suspend2.net">suspend2.net</uri>, ai sorgenti del kernel oppure
utilizzare <c>sys-kernel/suspend2-sources</c>.
</p>

<p>
La sezione del kernel necessaria sia a swsusp che a suspen2 è la seguente:
</p>

<pre caption="Configurazione del kernel per i vari stati di sospensione">
Power Management Options ---&gt;
  <comment>(hibernate con swsusp)</comment>
  [*] Software Suspend
      <comment>(sostituire /dev/SWAP con la propria partizione di swap)</comment>
      (/dev/SWAP)      Default resume partition
 
  <comment>(hibernate con suspend2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(sostituire /dev/SWAP con la propria partizione di swap)</comment>
    (swap:/dev/SWAP)   Default resume device name
    [ ]    Allow Keep Image Mode
	
	
</pre>

<p>
La configurazione di swsusp è piuttosto semplice. Se non si è indicata la giusta 
locazione della partizione di swap nella configurazione del kernel, è possibile
passarla come parametro con la direttiva <c>resume=/dev/SWAP</c>. Se non è possibile
effettuare l'avvio a causa di un'immagine rovinata, si può utilizzare il 
parametro del kernel <c>noresume</c>. Lo script di avvio <c>hibernate-cleanup</c>
invaliderà l'immagine rovinata durante il processo di boot.
</p>

<pre caption="Invalidamento dell'immagine swsusp durante il processo di avvio">
<i># rc-update add hibernate-cleanup boot</i>
</pre>
	 
<p>
Per attivare l'ibernazione con swsusp, si utilizza lo script hibernate dopo aver
settato <c>UseSysfsPowerState disk</c> in <path>/etc/hibernate/hibernate.conf</path>.
</p>

<warn>
E' consigliabile effettuare un backup dei propri dati. Eseguendo <c>sync</c> prima
dell'esecuzione di uno dei comandi, i dati di cache verranno scritti sul disco.
Provare il tutto al di fuori dell'ambiente grafico X e, in seguito, con X in 
esecuzione senza essere loggati al suo interno.
</warn>
 
<p>
Se dovesse capitare un kernel panic a causa di uhci o simili, è utile provare
a compilare il supporto USB come modulo per poterlo eventualmente "scaricare" 
prima che il laptop vada nello stato di sleep. Ci sono opzioni di configurazione
a proposito in <path>hibernate.conf</path>.
</p>

<pre caption="Ibernazione con swsusp">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Assicurarsi di avere un backup dei propri dati)</comment>
<i># hibernate</i>
</pre>

<p>
La sezione seguente tratta della configurazione di suspend2 con il supporto
fbsplash per avere una "progress bar" (barra di avanzamento) grafica durante
la sospensione e il ripristino.
</p>

<p>
La prima parte della configurazione è simile alla configurazione di swsusp.
Se non si è indicata la giusta locazione della partizione di swap nella 
configurazione del kernel, è possibile passarla come parametro con la 
direttiva <c>resume2=swap:/dev/SWAP</c>. Se non è possibile
effettuare l'avvio, si può utilizzare il parametro <c>noresume2</c>.
Inoltre, lo script di avvio <c>hibernate-cleanup</c>
invaliderà l'immagine di suspend2 rovinata durante il processo di boot.
</p>

<pre caption="Invalidamento dell'immagine suspend2 durante il processo di avvio">
<i># rc-update add hibernate-cleanup boot</i>
</pre>
	
<p>
Ora è necessario modificare il file <path>/etc/hibernate/hibernate.conf</path>,
attivando la sezione <e>suspend2</e> e commentando tutte le linee nelle sezioni
<e>sysfs_power_state</e> e <e>acpi_sleep</e>. Per il momento la parte fbsplash
non va attivata nelle opzioni globali.
</p>

<pre caption="Ibernazione con suspend2">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Assicurarsi di avere un backup dei propri dati)</comment>
<i># hibernate</i>
</pre>

<p>
Ora è il momento di configurare fbsplash. Per attivare il supporto fbsplash
durante l'ibernazione, è necessario il pacchetto <c>sys-apps/suspend2-userui</c>
con la USE flag <e>fbsplash</e> attivata.
</p>

<pre caption="Installazione di suspend2-userui">
<i># mkdir -p /etc/portage</i>
<i># echo sys-apps/suspend2-userui fbsplash >> /etc/portage/package.use</i>
<i># emerge suspend2-userui</i>
</pre>

<p>
L'ebuild richiede la creazione di un link simbolico al tema da utilizzare.
Ad esempio, per utilizzare il tema <c>livecd-2005.1</c>, sarà necessario il comando:
</p>

<pre caption="Utilizzo del tema livecd-2005.1 durante l'ibernazione">
<i># ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
Se non si vuole uno schermo nero nella prima parte del processo di ripristino,
bisognerà aggiungere <c>suspend2ui_fbsplash</c> alla propria immagine initrd.
Se si è creata la propria immagine initrd con <c>splash_geninitramfs</c> e la 
si è salvata come <path>/boot/fbsplash-emergence-1024x768</path>, i passi
da seguire sono i seguenti:
</p>

<pre caption="Aggiunta di suspend2ui_fbsplash alla immagine initrd">
<i># mount /boot</i>
<i># mkdir ~/initrd.d</i>
<i># cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
<i># cd ~/initrd.d</i>
<i># gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
<i># rm fbsplash-emergence-1024x768</i>
<i># cp /usr/sbin/suspend2ui_fbsplash sbin/</i>
<i># find . | cpio --quiet --dereference -o -H newc | gzip -9 > /boot/fbsplash-suspend2-emergence-1024x768</i>
</pre>

<p>
In seguito vanno modificati <path>grub.conf</path> oppure <path>lilo.conf</path>
a seconda del boot manager utilizzato per fare in modo che il proprio kernel suspend2
utilizzi <path>/boot/fbsplash-suspend2-emergence-1024x768</path> come immagine
initrd. Ora è possibile effettuare un test per verificare il corretto funzionamento.
</p>

<pre caption="Test di ibernazione con fbsplash">
<i># suspend2ui_fbsplash -t</i>
</pre>

<p>
Ora, si apra ancora una volta il file <path>/etc/hibernate/hibernate.conf</path>
e si attivino le opzioni fbsplash. Si esegua <c>hibernate</c>, tutto dovrebbe
funzionare in maniera corretta.
</p>


</body>
</section>
</chapter>

<chapter>
<title>Problemi</title>
<section>
<body>

<p>
<e>D:</e> Sto cercando di cambiare la frequenza della CPU, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> non esiste.
</p>

<p>
<e>R:</e> Assicurati che il tuo processore supporti il frequency scaling e di 
aver scelto il driver giusto. Ecco una lista di processori supportati dal cpufreq
(kernel 2.6.7): ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII e Intel mobile PIII-M su alcuni chipset, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, alcuni
"PowerBook" e "iBook2" e vari processori su alcuni sistemi compatibili ACPI 2.0 (solo se
gli "ACPI Processor Performance States" sono disponibili attraverso l'interfaccia
ACPI/BIOS).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> è vuoto.
</p>

<p>
<e>R:</e> Cerca messaggi d'errore relativi all'ACPI con <c>dmesg | grep ACPI</c>.
Prova ad aggiornare il BIOS, specialmente se vedi errori riguardo il DSDT.
Puoi anche provare a corregge il problema manualmente (ma ciò è al di fuori degli 
scopi di questa guida).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma secondo /proc/cpuinfo
la velocità non cambia mai.
</p>

<p>
<e>R:</e> Probabilmente hai attivato il supporto al symmetric multiprocessing 
nel kernel (CONFIG_SMP). Disattivalo e dovrebbe funzionare. Alcune vecchie versioni
del kernel presentano un bug al riguardo. In questo caso, esegui <c>emerge x86info</c>,
aggiorna il tuo kernel come richiesto e controlla il valore della frequenza con
<c>x86info -mhz</c>.
</p>

<p>
<e>D:</e> Posso cambiare la frequenza della CPU, ma la scelta non è così ampia come
quella disponibile in un altro OS.
</p>

<p>
<e>R:</e> Puoi combinare il frequency scaling con l'ACPI throttoling per ottenere
frequenza minori. Ricorda comunque che il throttoling non risparmia molta energia
e viene usato solo per una gestione termica (mantiene il notebook freddo). Puoi
leggere lo stato attuale del throttoling con <c>cat
/proc/acpi/processor/CPU/throttling</c> a cambiarlo con <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, dove la x è una degli stati Tx elencati in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>


<p>
<e>D:</e> Nella configurazione del kernel powersave, performance e userspace
governors vengono mostrati, ma non vedo la voce ondemand. Dove la trovo?
</p>

<p>
<e>R:</e> Ondemand governor è incluso solamente nelle ultime versioni del kernel. Prova
ad aggiornarlo.
</p>

<p>
<e>D:</e> La durata della batteria sembra essere peggiorata rispetto a prima.
</p>

<p>
<e>R:</e> Controlla i settaggi del tuo BIOS. Potresti aver dimenticato di riattivare
alcuni settaggi.
</p>

<p>
<e>D:</e> La mia batteria è carica, ma per KDE è del tutto scarica (riporta 0%) e,
quindi, viene avviato la sequenza di shutdown.
</p>

<p>
<e>R:</e> Controlla che il supporto batteria sia attivato nel tuo kernel. Se lo hai compilato
come modulo, assicurati di averlo caricato correttamente.
</p>

<p>
<e>D:</e> Nei miei log di sistema leggo cose del tipo "logger: ACPI group battery / action	
battery is not defined".	
</p>	

<p>	
<e>R:</e> Questo messaggio viene generato dallo script /etc/acpi/default.sh incluso con acpid.
Puoi tranquillamente ignorarlo. Se ti crea fastidio, puoi commentare la riga appropriata in
/etc/acpi/default.sh come mostrato di seguito:
</p>	

<pre caption="Disabilitazione dei warning per eventi acpi sconosciuti">	
	*)      # logger "ACPI action $action is not defined"	
</pre>	

<p>
<e>D:</e> Ho un Dell Inspiron 51XX e non riesco ad ottenere eventi ACPI.
</p>

<p>
<e>R:</e> Sembra essere un bug del kernel. Leggi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">qui</uri>.
</p>

<p>
<e>D:</e> Ho attivato l'opzione DynamicClocks in <path>xorg.conf</path>
e ora ottengo crash / lo schermo rimane nero / il mio notebook non 
effettua correttamente lo shutdown (spegnimento).
</p>

<p>
<e>R:</e> Questo accade purtroppo su alcuni sistemi. L'unica soluzione 
è la disattivazione dell'opzione DynamicClocks.
</p>

<p>
<e>D:</e> Voglio utilizzare suspend2, ma la mia partizione di swap viene
indicata come troppo piccola. Non posso effettuare un suo ridimensionamento.
</p>

<p>
<e>R:</e> Se non c'è abbastanza spazio libero sul tuo sistema, è possibile
utilizzare il filewriter al posto dello swapwriter. <c>hibernate-script</c>
lo supporta bene. Maggiori informazioni nel file
<path>/usr/src/linux/Documentation/power/suspend2.txt</path>.
</p>

<p>	
<e>D:</e> Ho appena comprato una nuova batteria, ma dura solo per pochi minuti! Cosa faccio 
di sbagliato?
</p>

<p>
<e>R:</e> Prima di tutto segui le istruzioni del venditore su come caricare correttamente la batteria.
</p>

<p>
<e>D:</e> Niente, è inutile. Cosa faccio ora?
</p>

<p>
<e>R:</e> Alcune batterie vendute come "nuove" sono in realtà vecchie. Prova questo:
</p>

<pre caption="Stato della batteria">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Se il valore di "last full capacity" differisce di molto da quello di design capacity,
la tua batteria è probabilmente rotta. Usa la garanzia.
</p>

<p>
<e>D:</e> Non ho trovato una soluzione al mio problema. Cosa faccio?
</p>

<p>
<e>R:</e> Prova a contattarmi direttamente, <mail link="earthwings@gentoo.org">Dennis
Nienhüser</mail>. I <uri link="http://forums.gentoo.org">forum di Gentoo</uri> sono 
un ottimo posto in cui chiedere e trovare aiuto. Se preferisci IRC, prova il canale
<e>#gentoo-laptop</e> su <e>irc.freenode.net</e>.
</p>


</body>
</section>
</chapter>
</guide>
