<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/power-management-guide.xml,v 1.14 2007/10/04 21:47:31 scen Exp $ -->

<guide link="/doc/it/power-management-guide.xml" lang="it">
<title>Guida alla Gestione Energetica</title>

<author title="Autore">
  <mail link="earthwings@gentoo.org">Dennis Nienhüser</mail>
</author>
<author title="Redazione">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Redazione">
  <mail link="nightmorph@gentoo.org">Joshua Saddler</mail>
</author>
<author title="Traduzione">
  <mail link="frgrieco@alice.it">Francesco Grieco</mail>
</author>

<abstract>
La gestione energetica è l'unica soluzione per estendere la durata della
batteria sui sistemi mobile come i notebook. Questa guida ne illustra la sua
configurazione.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.36</version>
<date>2007-10-03</date>

<chapter>
<title>Introduzione</title>
<section>
<body>

<p>
Capacità e durata delle batterie dei notebook sono migliorate molto nel corso
degli ultimi anni. Tuttavia i moderni processori consumano molta più energia dei
vecchi e ad ogni nuova generazione di notebook si aggiungono nuove periferiche
"affamate" di energia. Ecco il perchè dell'importanza della gestione energetica.
Applicando buone politiche di risparmio energetico non sarà sempre necessario
acquistare un'altra batteria.
</p>

</body>
</section>
<section>
<title>Breve Panoramica</title>
<body>

<p>
Questa guida tratta della gestione energetica per i <e>notebook</e>. Alcune
sezioni potrebbero essere valide anche per i <e>server</e>, altre non lo sono
sicuramente e potrebbero causare problemi. Si consiglia fortemente di non
applicare niente di quello contenuto in questa guida a macchine server a meno
che non si sappia veramente quello che si sta facendo.
</p>

<p>
Poichè questa guida diventa sempre più lunga, segue una breve panoramica di
ciò che sarà trattato.
</p>

<p>
La sezione <uri link="#doc_chap2">Prerequisiti</uri> tratta di alcuni requisiti
di base necessari per tutte le sezioni a seguire della guida. Include
impostazioni del BIOS e particolari configurazioni nel kernel. I seguenti tre
capitoli pongono l'attenzione sui componenti che tipicamente consumano maggiore
energia: il processore, il display e l'hard disk. Ognuno di essi pùo essere
configurato separatamente. <uri link="#doc_chap3">Gestione Energetica della
CPU</uri> mostra come modificare la frequenza del processore al fine di
risparmiare energia senza un eccessivo calo delle prestazioni. Alcuni
stratagemmi in <uri link="#doc_chap5">Gestione Energetica dell'Hard Disk</uri>
permettono di alleggerire il carico di lavoro del disco (avendo come effetto
anche una riduzione del livello di rumore). Indicazioni anche per le schede
Wireless LAN e per le periferiche USB concludono la sezione dei dispositivi in
<uri link="#doc_chap6">Gestione Energetica delle altre periferiche</uri> mentre
un altro intero capitolo è dedicato agli (ancora sperimentali) <uri
link="#doc_chap7">Stati di Sleep</uri>. L'ultimo capitolo (ma non come
importanza) denominato <uri link="#doc_chap8">Risoluzione dei problemi</uri>
elenca i problemi più comuni in cui è possibile incorrere.
</p>

</body>
</section>
<section>
<title>Bilancio Energetico Per Ogni Componente</title>
<body>

<figure link="/images/energy-budget.png" short="Quale componente consuma quanta
energia?" caption="Peso energetico per ogni componente"/>

<p>
Quasi tutti i componenti possono funzionare in differenti stati, ovvero off
(spento), sleep (a riposo), idle (inattivo), active (attivo), consumando a
seconda dei casi diverse quantità di energia. La maggior parte dell'energia
viene consumata dal display LCD, dalla CPU e dagli hard disk. Spesso alcuni di
essi sono in grado di attivare politiche di gestione energetica attraverso il
BIOS, ma una configurazione intelligente del proprio sistema operativo
adattabile a diverse situazioni può ottenere molto di più.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisiti</title>
<section>
<body>

<p>
Prima di trattare i dettagli della gestione energetica per le singole
periferiche, vi sono alcuni requisiti. Dopo aver controllato le impostazioni del
BIOS, è necessario attivare alcune opzioni del kernel, che in breve sono ACPI,
sleep states e CPU frequency scaling. Poichè il risparmio energetico comporta
una perdita delle prestazioni o un aumento della latenza, deve essere attivato,
naturalmente, solamente in assenza di una connessione a rete elettrica. Da qui
la necessità di un nuovo runlevel <e>battery</e>.
</p>

</body>
</section>
<section>
<title>Il BIOS</title>
<body>

<p>
Per prima cosa è necessario controllare le impostazioni relative alla Gestione
Energetica nel BIOS. Di solito la soluzione migliore è combinare le impostazioni
del BIOS alle politiche del sistema operativo, ma per il momento è meglio
disabilitare le funzioni del BIOS. In questo modo niente interferisce con le
nuove politiche imposte dal sistema operativo. Dopo aver configurato tutto per
bene, sarà necessario riabilitare tutte le funzioni del BIOS.
</p>

</body>
</section>
<section>
<title>Impostazione Delle flag USE</title>
<body>

<p>
È importante verificare che la flag USE <c>acpi</c> sia attivata in
<path>/etc/make.conf</path>. Altre flag USE che potrebbero interessare il
proprio sistema sono <c>apm</c>, <c>lm_sensors</c>, <c>nforce2</c>,
<c>nvidia</c>, <c>pmu</c>. Per informazioni su queste ultime è possibile
consultare i file <path>/usr/portage/profiles/use*.desc</path>. Se, in qualsiasi
momento, ci si accorge della mancanza di una qualsiasi di queste flag, è
possibile ricompilare i pacchetti interessati con l'opzione <c>--newuse</c> di
<c>emerge</c>; maggiori informazioni con <c>man 1 emerge</c>.
</p>

</body>
</section>
<section>
<title>Configurazione Del Kernel</title>
<body>

<p>
Il supporto dell'ACPI (Advanced Configuration and Power Interface) nel kernel è
ancora in fase di sviluppo. Pertanto è consigliabile usare sempre il kernel più
recente.
</p>

<p>
In Portage ci sono differenti versioni del kernel. Quelle consigliate sono
<c>gentoo-sources</c> e <c>suspend2-sources</c>. La seconda, in particolare,
contiene le ultime patch per il supporto Software Suspend 2; vedere la sezione
sugli <uri link="#doc_chap7">stati di sleep</uri> per maggiori dettagli. Nelle
opzioni di configurazione del kernel vanno, in ogni caso, attivate le opzioni
seguenti:
</p>

<pre caption="Configurazione minimale del kernel per la Gestione Energetica
(Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performancÈ governor
    &lt;*&gt;   'powersavÈ governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservativÈ cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>driver CPUFreq a seconda del processore</i>
</pre>

<p>
È possibile attivare, a propria discrezione, Software Suspend e Sleep States. I
possessori di notebook ASUS, Medion, Thinkpad IBM o Toshiba devono attivare i
relativi moduli specifici.
</p>

<p>
Il kernel deve essere in grado di attivare il CPU frequency scaling (cambio di
frequenza della CPU) sul processore. Poichè ogni CPU presenta un'interfaccia
differente dalle altre, è necessario scegliere il driver giusto per il proprio
processore. Prestare attenzione a queesto passaggio perchè, ad esempio,
attivando <c>Intel Pentium 4 clock modulation</c> su un Pentium M si otterrà
molto probabilmente un sistema poco stabile. La documentazione del kernel può
chiarire qualsiasi dubbio in proposito.
</p>

<p>
Dopo la compilazione del kernel bisogna assicurarsi del corretto caricamento dei
moduli all'avvio e riavviare il notebook con il nuovo kernel con ACPI abilitato.
Successivamente eseguire <c>emerge sys-power/acpid</c> per installare il demone
acpi. Il suddetto demone gestisce eventi quali il passaggio da corrente a
batteria o la chiusura del lid. È necessario assicurarsi che i moduli siano
caricati se non compilati direttamente all'interno del proprio kernel. A questo
punto avviare il demone acpid con <c>/etc/init.d/acpid start</c> ed eseguire
<c>rc-update add acpid default</c> per caricarlo all'avvio. Il suo utilizzo
verrà spiegato in seguito.
</p>

<pre caption="Installazione di acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creazione Del Runlevel "battery"</title>
<body>

<p>
La configurazione predefinita attiverà il risparmio energetico solo quando
necessario, praticamente quando il notebook funziona con la propria batteria.
Per effettuare il passaggio fra stato di corrente e di batteria, sarà necessario
creare un runlevel <c>battery</c> in grado di gestire l'avvio e il blocco degli
script di risparmio energetico.
</p>

<note>
Se l'idea di avere un ulteriore runlevel non convince, è possibile saltare
questa sezione. Naturalmente ciò renderà tutto un pò più complicato. La sezione
seguente considera l'esistenza di un runlevel <c>battery</c>.
</note>

<pre caption="Creazione di un runlevel battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finito. Il nuovo runlevel <c>battery</c> contiene tutto come <c>default</c>, ma
non c'è ancora nessun cambio automatico tra i due livelli.
</p>

</body>
</section>
<section>
<title>Risposta Agli Eventi ACPI</title>
<body>

<p>
Di solito gli eventi ACPI sono la chiusura del lid, il cambio della sorgente
energetica e il bottone di sleep. Il cambio di sorgente energetica è un evento
importante e deve necessariamente generare un cambio di runlevel. Di questo
si occuperà un piccolo script.
</p>

<p>
È necessario uno script in grado di cambiare il runlevel fra <c>default</c> e
<c>battery</c> a seconda della sorgente energetica utilizzata. Lo script
utilizzata il comando <c>on_ac_power</c> fornito da
<c>sys-power/powermgmt-base</c>: assicurarsi dell'installazione di tale
pacchetto nel proprio sistema.
</p>

<pre caption="Installazione di powermgt-base">
# <i>emerge powermgmt-base</i>
</pre>

<p>
Ora, tramite il comando <c>on_ac_power &amp;&amp; echo AC available || echo
Running on batteries</c> eseguito in shell è possibile determinare la sorgente
energetica in uso. Lo script seguente è responsabile del cambio di runlevel.
Va salvato come <path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># INIZIO configurazione</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># FINE configurazione</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
  if [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
  fi
elif [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
Con il comando <c>chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</c> si rende
lo script eseguibile. Infine è necessario che lo script venga eseguito ad ogni
cambio di sorgente energetica dal demone <c>acpid</c>. Bisogna però sapere quali
eventi vengono generati al cambio di sorgente energetica. Gli eventi vengono
chiamati <c>ac_adapter</c> e <c>battery</c> sulla maggior parte dei notebook, ma
si potrebbero avere delle eccezioni.
</p>

<pre caption="Determinazione degli eventi ACPI al cambio di sorgente
energetica">
# <i>tail -f /var/log/acpid | grep "received event"</i>
</pre>

<p>
Eseguire il comando sopra indicato e staccare il cavo di alimentazione dal
proprio notebook.
</p>

<pre caption="Esempio di output al cambio di sorgente energetica">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
La parte interessante di questo output è quella che segue <c>received event</c>
fra le virgolette. Sarà necessario inserire queste stringhe nello script che
segue. In caso il proprio notebook dovesse generare più eventi o sempre lo
stesso evento, non c'è da preoccuparsi.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Sostituire "ac_adapter" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Ad esempio ac_adapter.* sarà sostituito da ac_adapter AC 00000080 00000000</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Sostituire "battery" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Ad esempio battery.* sarà sostituito da battery BAT0 00000080 00000001</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Sarà necessario riavviare il demone acpid per rendere attivi i cambiamenti
apportati.
</p>

<pre caption="Riavvio del demone acpid">
# <i>/etc/init.d/acpid restart</i>
</pre>


<p>
Provando ora ad attaccare e staccare l'alimentazione a corrente, nei log di
sistema dovrebbero apparire a seconda dei casi i messaggi "Switching to AC
mode" o "Switching to battery mode". Se lo script non è in grado di rilevare
correttamente la sorgente di energia utilizzata, è possibile consultare la
sezione <uri link="#doc_chap8">Risoluzione dei problemi</uri>.
</p>

<p>
A causa della natura del meccanismo degli eventi, il notebook, al boot, passa al
runlevel <c>default</c> che sia o meno collegato alla rete elettrica. Questo va
bene se si è collegati direttamente a rete elettrica, certamente no quando si
avvia da batteria. Una soluzione potrebbe essere l'aggiunta di un parametro del
tipo <c>softlevel=battery</c> al proprio boot loader, ma ci si potrebbe
dimenticare di selezionarlo. Una soluzione migliore è sicuramente quella di
generare un finto evento ACPI alla fine del processo di boot e lasciare che lo
script <path>pmg_switch_runlevel.sh</path> decida quale runlevel utilizzare.
Aprire con il proprio editor il file <path>/etc/conf.d/local.start</path> e
aggiungere le linee:
</p>

<pre caption="Cambio del runlevel al boot del notebook con la modifica di local.start">
<comment># Finto evento acpi per cambiare runlevel se scollegati da rete elettrica</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Conclusa questa parte preparativa, è ora possibile attivare le politiche di
gestione energetica per ogni singolo componente.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestione Energetica della CPU</title>
<section>
<body>

<p>
I processori per i sistemi mobili possono operare a frequenze differenti. Alcuni
di essi permettono il cambio del proprio voltaggio. In molte situazioni, la CPU
non lavora a pieno carico e quindi abbassandone la frequenza, si otterrà un
notevole risparmio energetico, spesso senza nemmeno un decremento prestazione.
</p>

</body>
</section>
<section>
<title>Terminologia Tecnica</title>
<body>

<p>
Il CPU frequency scaling introduce alcuni termini tecnici che potrebbero non
essere conosciuti. Segue, per questo motivo, una breve introduzione.
</p>

<p>
Prima di tutto, il kernel deve essere in grado di cambiare la frequenza di
funzionamento della CPU. Il <b>CPUfreq processor driver</b> contiene i comandi
per effettuare questa operazione su ogni tipo di CPU. Per questo motivo è
importante indicare il driver giusto da utilizzare nel proprio kernel
(operazione già effettuata precedentemente). Inoltre, il kernel deve anche
scegliere la frequenza corretta di funzionamento da utilizzare nelle diverse
situazioni. Questa viene fissata in base ad una <b>policy</b> (politica di
gestione) che consiste in una <b>CPUfreq policy</b> e in un <b>governor</b>
(regolatore). Una CPUfreq policy non è altro che un insieme di due numeri che
definiscono un campo all'interno del quale la frequenza può oscillare, ovvero un
valore minimo e uno massimo. Il governor, invece, decide quale delle frequenze
disponibili fra la minima e la massima utilizzare. Ad esempio, il <b>powersave
governor</b> utilizza sempre la frequenza più bassa disponibile, il
<b>performance governor</b>, invece, la più alta. L'<b>userspace governor</b>
non sceglie nessuna frequenza in particolare ma utilizza quella indicata
dall'utente (o da un programma in userspace); il valore della frequenza viene
letto da <path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Questo può non sembrare un cambiamento dinamico della frequenza e in effetti non
lo è. La dinamicità può essere realizzata con diversi approcci. Ad esempio,
<b>ondemand governor</b> prende le sue decisioni in base al carico di lavoro
della CPU. La stessa cosa viene fatta da utility come <c>cpudyn</c>,
<c>cpufreqd</c>, <c>powernowd</c> e molte altre. Gli eventi ACPI possono essere
utilizzati per attivare o disattivare i cambi dinamici della frequenza a seconda
della sorgente energetica utilizzata.
</p>

</body>
</section>
<section>
<title>Impostazione Manuale Della Frequenza</title>
<body>

<p>
Diminuendo la velocità e il voltaggio della CPU si hanno due vantaggi: viene
consumata meno energia e il notebook non si riscalda eccessivamente. Il grande
svantaggio, naturalmente, è una perdita di prestazioni. La diminuzione della
velocità del processore resta in ogni caso un buon compromesso fra calo di
prestazioni e risparmio energetico.
</p>

<note>
Non tutti i notebook supportano il frequency scaling. In caso di dubbi, una
lista dei processori supportati si trova nella sezione <uri
link="#doc_chap8">Risoluzione dei problemi</uri>.
</note>

<p>
È ora di provare il corretto funzionamento del cambio di frequenza della CPU.
<c>sys-power/cpufrequtils</c> è un programmino molto utile per effettuare un
semplice debug.
</p>

<pre caption="Controllo della frequenza della CPU">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Ecco un esempio di quello che si ottiene:
</p>

<pre caption="Output di esempio di cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
 driver: centrino
 CPUs which need to switch frequency at the same time: 0
 hardware limits: 600 MHz - 1.40 GHz
 available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
 available cpufreq governors: conservative, ondemand, powersave, userspace,
performance
 current policy: frequency should be within 924 MHz and 1.40 GHz.
  The governor "performance" may decide which speed to use
  within this range.
 current CPU frequency is 1.40 GHz.
</pre>

<p>
Utilizzare <c>cpufreq-set</c> per assicurarsi che il cambio di frequenza
funzioni. Il comando <c>cpufreq-set -g ondemand</c>, ad esempio, attiva il
governor ondemand; eseguirlo e verificare il cambiamento con
<c>cpufreq-info</c>. Se non funziona come dovrebbe, la sezione <uri
link="#doc_chap8">Risoluzione dei problemi</uri> alla fine di questa guida
potrebbe essere d'aiuto.
</p>

</body>
</section>
<section>
<title>Adattamento automatico della frequenza</title>
<body>

<p>
Tutto questo è molto semplice, ma scomodo da effettuare tutti i giorni. Meglio
lasciare che sia il proprio sistema ad impostare automaticamente la frequenza
appropriata. La tabella seguente presenta una panoramica delle utilità
necessarie a questo compito. È suddivisa in tre categorie: <b>kernel</b> per
soluzioni che hanno bisogno solo del supporto del kernel, <b>demone</b> per
programmi che lavorano in background e <b>GUI</b> per programmi che forniscono
una interfaccia grafica per una configurazione più semplice.
</p>

<table>
<tr>
  <th>Nome</th>
  <th>Categoria</th>
  <th>Causa cambio</th>
  <th>Governor del kernel</th>
  <th>Governor supportati</th>
  <th>Note</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>Carico della CPU</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Sceglie la frequenza massima in caso di carico della CPU e frequenze man
    mano più basse in caso di CPU libera. Configurazione attraverso i file
    presenti in <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>.
    Richiede ancora strumenti in userspace (programmi, script) in caso di
    utilizzo del cambio di governor.
  </ti>
</tr>
<tr>
  <ti>'conservative' governor</ti>
  <ti>Kernel</ti>
  <ti>Carico della CPU</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    A differenza dell'ondemand governor, il conservative non salta alla massima
    frequenza quando il carico della CPU cresce, ma aumenta poco alla volta la
    frequenza. Configurazione attraverso i file presenti in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Richiede ancora
    strumenti in userspace (programmi, script) in caso di utilizzo del cambio di
    governor.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Performance, powersave</ti>
  <ti>Dynamic</ti>
  <ti>
    Supporta anche lo standby dei dischi: notare, però, che il <e>laptop
    mode</e> in molti casi funziona decisamente meglio.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demone</ti>
  <ti>
    Stato della batteria, Carico della CPU, Temperatura, Programmi in esecuzione
    e altro
  </ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Configurazioni sofisticate (ma anche piuttosto complesse). Estendibile
    tramite plugin per il monitoraggio sensori (lm_sensors) oppure per schede
    grafiche NVidia. Cpufreqd supporta SMP e può essere controllato manualmente
    durante la propria esecuzione.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.deater.net/john/powernowd.html">powernowd</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>Supporta SMP.</ti>
</tr>
<tr>
  <ti>
    <uri
    link="http://projects.simpledesigns.com.pl/project/ncpufreqd/">ncpufreqd
    </uri>
  </ti>
  <ti>Demone</ti>
  <ti>Temperatura</ti>
  <ti>Nessuno</ti>
  <ti>Powersave, performance</ti>
  <ti>
    Passa da modalità performance a powersave a seconda della temperatura del
    sistema. Molto utile su notebook con noti problemi di surriscaldamento.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Semplice da configurare con una interfaccia client/server. Richiede un
    kernel della serie 2.6. Il suo sviluppo è stato interrotto, non è più
    funzionante e per questo motivo è stato rimosso da Portage.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>GUI</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>
    Applicazione per Gnome, utility grafica per configurare manualmente la
    frequenza della CPU. Non offre nessun tipo di automazione.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>GUI</ti>
  <ti>Stato della batteria</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Solamente per KDE, 'ondemand' governor necessario per il cambio dinamico
    della frequenza.
  </ti>
</tr>
</table>

<p>
L'adattamento della frequenza della CPU al carico di lavoro corrente del
notebook può sembrare semplice da attuare ad una prima occhiata, ma in realtà
non lo è. Un algoritmo errato può causare cambi continui fra due frequenze o
spreco di energia quando la frequenza viene portata inutilmente a valori troppo
alti.
</p>

<p>
Quale scegliere? Se si è indecisi, un'ottima scelta è <c>cpufreqd</c>:
</p>

<pre caption="Installazione di cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
La configurazione di <c>cpufreqd</c> avviene attraverso il file
<path>/etc/cpufreqd.conf</path>. Quella predefinita fornita con cpufreqd sembra
leggermente confusionaria. Si raccomanda di sostituirla con quella fornita
dall'ex sviluppatore Gentoo, Henrik Brix Andersen (vedere successivamente). È
necessaria almeno la versione 2.0.0 di cpufreqd. Le versioni precedenti
presentano una sintassi differente per il file di configurazione.
</p>

<pre caption="/etc/cpufreqd.conf (versione 2.0.0 e superiori)">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=3
enable_plugins=acpi_ac, acpi_battery
enable_remote=1
remote_group=wheel
verbosity=5
[/General]

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand
[/Profile]

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative
[/Profile]

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave
[/Profile]

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance
[/Profile]

[Rule]
name=battery
ac=off
profile=conservative
[/Rule]

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave
[/Rule]

[Rule]
name=ac
ac=on
profile=ondemand
[/Rule]
</pre>

<p>
Ora si può avviare il demone cpufreqd. Aggiungerlo ai runlevel <c>default</c> e
<c>battery</c> come mostrato di seguito.
</p>

<pre caption="Avvio di cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<p>
Alcune volte può essere opportuno selezionare un'altra politica di gestione
rispetto a quella scelta dal demone, ad esempio quando la batteria è quasi
scarica, ma si è certi dell'imminente connessione a rete elettrica. In questo
caso è possibile attivare la modalità manuale di cpufreqd con il comando
<c>cpufreqd-set manual</c> selezionando una delle proprie politiche configurate
(elencate tramite <c>cpufreqd-get</c>). Si può abbandonare la modalità manuale
con il comando <c>cpufreqd-set dynamic</c>.
</p>

<warn>
Non eseguire più di uno dei programmi sopra citati contemporaneamente.
Potrebbero, infatti, esserci problemi come un cambio continuo fra due frequenze.
</warn>

</body>
</section>
<section>
<title>Verifica di funzionamento a seguito delle modifiche apportate</title>
<body>

<p>
L'ultima cosa da controllare è che le nuove politiche di risparmio energetico
facciano bene il loro lavoro. Un modo semplice per verificare ciò è il
monitoraggio della velocità della CPU mentre è al lavoro sul notebook:
</p>

<pre caption="Monitoraggio della velocità della CPU">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Se <path>/proc/cpuinfo</path> non dovesse venire aggiornato (sezione <uri
link="#doc_chap8">Risoluzione dei problemi</uri>), provare a monitorare la
frequenza della CPU con:
</p>

<pre caption="Monitoraggio alternativo della velocità della CPU">
# <i>watch x86info -mhz</i>
</pre>

<p>
A seconda delle impostazioni, la velocità della CPU dovrebbe aumentare in caso
di richieste d'uso, diminuire in mancanza di attività o, semplicemente, rimanere
costante. Quando si utilizza <c>cpufreqd</c> e la voce verbosity è impostata ad
un valore di 5 o più in <path>cpufreqd.conf</path>, nel <c>syslog</c> si
otterrano maggiori informarzioni su quello che accade.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestione Energetica del display LCD</title>
<section>
<body>

<p>
Come si può vedere dalla <uri link="#doc_chap1_fig1">figura 1.1</uri>, il
display LCD consuma la maggior parte dell'energia (questo potrebbe non valere
nel caso di CPU non mobile). Per questo non solo è importante spegnere il
display quando non utilizzato, ma anche ridurre il backlight
(retroilluminazione), se possibile. Molti notebook offrono la possibilità di
regolare il backlight.
</p>

</body>
</section>
<section>
<title>Configurazione Standby</title>
<body>

<p>
La prima cosa da controllare sono le impostazioni di standby/suspend/off del
display. Questi sono tutti valori che dipendono dal windowmanager. L'oscuramento
del terminale può essere effettuato con <c>setterm -blank
&lt;numero-di-minutiM&gt;</c>, <c>setterm -powersave on</c> e <c>setterm
-powerdown &lt;numero-di-minutiM&gt;</c>. Per X.org, si può modificare
<path>/etc/X11/xorg.conf</path> come di seguito riportato:
</p>

<pre caption="Impostazioni dell'LCD suspend in X.org e in XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Oscura lo schermo dopo cinque minuti (Finto)</comment>
  Option  "StandbyTime"  "10"  <comment># Spegne lo schermo dopo 10 minuti (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Sospensione dopo 20 minuti</comment>
  Option  "OffTime"  "30"  <comment># Spegnere dopo mezz'ora</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Vale lo stesso per XFree86 e <path>/etc/X11/XF86Config</path>
</p>

</body>
</section>
<section>
<title>Backlight (Retroilluminazione)</title>
<body>

<p>
Probabilmente la gestione del backlight (retroilluminazione) è il punto più
importante. Se si è in grado di accedere al controllo tramite uno strumento,
bisogna scrivere un piccolo script in grado di impostare il backlight nella
modalità batteria e inserirlo nel runlevel <c>battery</c>. Lo script seguente
dovrebbe funzionare sulla maggior parte dei notebook IBM Thinkpad e Toshiba. Per
gli IBM Thinkpad bisogna attivare le opzioni appropriate nel kernel. Per i
notebook Toshiba è sufficiente l'installazione del pacchetto
<c>sys-power/acpitool</c> (non sono necessarie le istruzioni seguenti relative a
<c>ibm_acpi</c>).
</p>

<warn>
Il supporto per la regolazione della luminosità è sperimentale nel pacchetto
ibm-acpi. L'accesso diretto all'hardware di questa utilità potrebbe provocare
blocchi inaspettati del sistema. Leggere a tal proposito il
<uri link="http://ibm-acpi.sourceforge.net/">sito ufficiale</uri>del pacchetto
ibm-acpi.
</warn>

<p>
Per essere in grado di regolare il livello di lumonisità, il modulo ibm_acpi
deve essere caricato con il paramentro sperimentale.
</p>

<pre caption="Caricamento automatico del modulo ibm_acpi">
<comment>(Prima di proseguire leggere l'avviso sopra riportato circa l'instabilità di questa opzione)</comment>
# <i>echo "options ibm_acpi experimental=1" &gt;&gt; /etc/modules.d/ibm_acpi</i>
# <i>/sbin/update-modules</i>
# <i>echo ibm_acpi &gt;&gt; /etc/modules.autoload.d/kernel-2.6</i>
# <i>modprobe ibm_acpi</i>
</pre>

<p>
Queste operazioni non dovrebbero produrre messaggi di errore e, dopo il
caricamento del modulo, dovrebbe essere creato il file
<path>/proc/acpi/ibm/brightness</path>. Uno script di avvio avrà il compito di
scegliere il miglior livello di luminosità in base alla sorgente energetica
disponibile.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Vedere /proc/acpi/ibm/brightness per i valori disponibili</comment>
<comment># Si prega di leggere /usr/src/linux/Documentation/ibm-acpi.txt</comment>

<comment># Livello di luminosità in modalità corrente. Predefinito 7.</comment>
BRIGHTNESS_AC=7

<comment># Livello di luminosità in modalità batteria. Predefinito 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
        if on_ac_power
        then
            LEVEL=${BRIGHTNESS_AC:-7}
        else
            LEVEL=${BRIGHTNESS_BATTERY:-4}
        fi

        if [ -f /proc/acpi/ibm/brightness ]
        then
            ebegin "Setting LCD brightness"
            echo "level ${LEVEL}" &gt; /proc/acpi/ibm/brightness
            eend $?
        elif [[ -e /usr/bin/acpitool &amp;&amp; -n $(acpitool -T | grep "LCD brightness") ]]
        then
                ebegin "Setting LCD brightness"
                acpitool -l $LEVEL &gt;/dev/null || ewarn "Unable to set lcd brightness"
            eend $?
        else
            ewarn "Setting LCD brightness is not supported."
            ewarn "For IBM Thinkpads, check that ibm_acpi is loaded into the kernel"
            ewarn "For Toshiba laptops, you've got to install sys-power/acpitool"
        fi
}

start() {
        set_brightness
}

stop () {
        set_brightness
}
</pre>

<p>
Una volta finito, bisogna assicurarsi che la luminosità sia regolata
automaticamente aggiungendo lo script al runlevel battery.
</p>

<pre caption="Regolazione automatica della luminosità">
# <i>chmod +x /etc/init.d/lcd-brightness</i>
# <i>rc-update add lcd-brightness battery</i>
# <i>rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Gestione Energetica dell'Hard Disk</title>
<section>
<body>

<p>
Gli Hard Disk consumano meno energia in modalità sleep. Quindi ha senso attivare
la modalità risparmio energetico ogni qual volta l'hard disk non viene
utilizzato per un certo intervallo di tempo. Ci sono due metodi per questo. Il
laptop-mode, il primo, permette un risparmio energetico grazie ad alcune misure
che prevengono o al massimo ritardano gli accessi in scrittura. Lo svantaggio è
dato dal fatto che uno sbalzo energetico o un crash del kernel potrebbero
portare a perdite di dati. Se si vogliono evitare queste situazioni, sarà bene
accertarsi che non siano attivi processi che necessitano di scritture frequenti.
Il secondo metodo è l'attivazione dell'opzione risparmio energetico del proprio
hard disk tramite <c>hdparm</c>.
</p>

</body>
</section>
<section>
<title>Aumento del tempo di idle - laptop-mode</title>
<body>

<p>
Tutti i kernel recenti includono il così detto <c>laptop-mode</c>. Quando
attivato, i buffer vengono scritti sul disco alle chiamate read oppure dopo 10
minuti (invece di 30 secondi). Questo fà si che l'hard disk non lavori in
maniera continuativa.
</p>

<pre caption="Avvio automatico del laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
I <c>laptop-mode-tools</c> hanno la propria configurazione in
<path>/etc/laptop-mode/laptop-mode.conf</path>. È possibile adattarla alle
proprie esigenze; la documentazione è presente nel file di configurazione
stesso. Per rendere automatico l'avvio <c>rc-update add laptop_mode battery</c>.
</p>

<p>
Le ultime versioni (dalla 1.11 in avanti) dei laptop-mode-tools includono
<c>lm-profiler</c>. Questo tool effettuerà un monitoraggio dell'utilizzo del
disco del proprio sistema e dei servizi di rete in esecuzione consigliando la
disabilitazione di quelli non necessari. Sarà possibile disattivarli attraverso
il supporto runlevel integrato nei laptop-mode-tools (sostituiti da
<c>/sbin/rc</c> di Gentoo) o attraverso i propri runlevel
<c>default</c>/<c>battery</c> (raccomandato).
</p>

<pre caption="Output d'esempio dell'esecuzione di lm-profiler">
# <i>lm-profiler</i>
Profiling session started.
Time remaining: 600 seconds
[4296896.602000] amarokapp
Time remaining: 599 seconds
[4296897.714000] sort
[4296897.970000] mv
Time remaining: 598 seconds
Time remaining: 597 seconds
[4296900.482000] reiserfs/0
</pre>

<p>
A seguito del monitoraggio di dieci minuti, lm-profiler mostrerà un elenco di
servizi responsabili di accessi al disco durante il tempo di osservazione.
</p>

<pre caption="Richiesta di disabilitazione servizi di lm-profiler">
Program:     "atd"
Reason:      standard recommendation (program may not be running)
Init script: /etc/init.d/atd (GUESSED)

Do you want to disable this service in battery mode? [y/N]: <i>n</i>
</pre>

<p>
Per disabilitare atd come suggerito dall'esempio sopra riportato, sarà
necessario il comando <c>rc-update del atd battery</c>. Prestare attenzione a
non disabilitare servizi essenziali al corretto funzionamento del proprio
sistema, in quanto <c>lm-profiler</c> genera facilmente falsi positivi.
</p>

</body>
</section>
<section>
<title>Limitazione degli accessi in scrittura</title>
<body>

<p>
Se non si vuole utilizzare il laptop-mode, sarà necessario prestare maggiore
attenzione nel disattivare servizi che accedono frequentemente al disco;
<c>syslogd</c> è un buon candidato, ad esempio. Probabilmente non lo si vorrà
bloccare completamente, ma una modifica al suo file di configurazione al fine di
evitare un logging eccessivo sarà una soluzione migliore. <c>Cups</c> scrive su
disco periodicamente, quindi si consideri l'idea di bloccarlo definitivamente
così da attivarlo solo quando effettivamente necessario.
</p>

<pre caption="Disattivazione di cups nella modalità batteria">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
È anche possibile utilizzare <c>lm-profiler</c> dei laptop-mode-tools (leggere
sopra) per cercare servizi da disabilitare. Una volta eliminati tutti quelli
interessati, si può passare alla configurazione di hdparm.
</p>

</body>
</section>
<section>
<title>hdparm</title>
<body>

<p>
La seconda possibilità è l'utilizzo di <c>hdparm</c>. Se si utilizza il
laptop-mode è possibile saltare questa sezione. Altrimenti, sarà necessario
modificare il file <path>/etc/conf.d/hdparm</path> per aggiungere i valori
seguenti a secondo dei proprio dischi. In questo esempio il disco fisso è
associato ad <b>hda</b>:
</p>

<pre caption="Utilizzo di /etc/conf.d/hdparm per lo standby dell'hard disk">
hda_args="-q -S12"
</pre>

<p>
Questa stringa attiverà il risparmio energetico per il proprio hard disk. Se in
futuro si volesse disattivarlo, basterà modificare ancora una volta il file
/etc/conf.d/hdparm cambiando i valori in <c>-q -S0</c> o, in altro modo,
eseguire il comando <c>hdparm -q -S0 /dev/hda</c>.
</p>

<p>
Per informazioni sulle opzioni, consultare il manuale con <c>man hdparm</c>.
Benchè sia sempre possibile avviare <c>hdparm</c> manualmente quando si è
collegati a batteria con <c>/etc/init.d/hdparm start</c>, è molto più semplice
automatizzarne l'esecuzione e la terminazione. Per fare questo, bisogna
aggiungere <c>hdparm</c> al runlevel battery così che attivi automaticamente
il risparmio energetico.
</p>

<pre caption="Configurazione per lo standby automatico del disco">
# <i>rc-update add hdparm battery</i>
</pre>

<impo>
Prestare molta attenzione alle impostazioni di sleep e di spin down del proprio
hard disk. Impostazioni troppo spinte (valori molto piccoli) possono danneggiare
l'hardware e invalidare la garanzia.
</impo>

</body>
</section>
<section>
<title>Altri consigli</title>
<body>

<p>
Un'altra possibilità è la disattivazione dello swap nella modalità batteria.
Prima di scrivere qualcosa che attivi e disattivi lo swap, bisogna assicurarsi
che ci sia abbastanza RAM e che lo swap non sia usato pesantemente, altrimenti
si potrebbero avere problemi.
</p>

<p>
Se non si vuole utilizzare il laptop-mode, è sempre possibile minimizzare gli
accessi al disco montando alcune directory come <c>tmpfs</c>, in modo che gli
accessi in scrittura non avvengano sul disco ma nella memoria principale, con
la conseguenza di perderli con l'operazione di unmount. Spesso è utile montare
<path>/tmp</path> allo stesso modo, in quanto il suo contenuto viene in ogni
caso perso ad ogni reboot che sia montato o meno sul disco o in RAM. Bisogna
solo essere certi di avere RAM a sufficienza e nessun programma (come un client
per i download od un programma di compressione) che abbia bisogno di molto
spazio in <path>/tmp</path>. Per usare questa soluzione è necessario avere il
supporto tmpfs abilitato nel kernel ed aggiungere una linea come la seguente in
<path>/etc/fstab</path>:
</p>

<pre caption="Modifica di /etc/fstab per rendere /tmp volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Prestare attenzione al parametro size e modificarlo per il proprio sistema. Se
non si è sicuri non modificarlo, in quanto si creerebbero facilmente grossi cali
di prestazione (effetto collo di bottiglia). Se si volesse montare
<path>/var/log</path> nello stesso modo, non bisogna dimenticare di unire i file
di log al disco prima di effettuare l'unmounting, poichè sono essenziali.
Montare anche <path>/var/tmp</path> allo stesso modo è inutile. Portage usa
questa directory per la compilazione...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Gestione Energetica per Altre Periferiche</title>
<section>
<title>Schede Grafiche</title>
<body>

<p>
Se si è in possesso di una scheda grafica ATI con supporto PowerPlay (dynamic
clock scaling per le GPU, graphic processing unit), in X.org è possibile
abilitare questa caratteristica. Bisogna aprire il file
<path>/etc/X11/xorg.conf</path> e aggiungere (oppure attivare) l'opzione
<c>DynamicClocks</c> nella sezione Device. Questa opzione attiva su alcuni
sistemi può provocare blocchi o crash.
</p>

<pre caption="Attivazione del supporto PowerPlay per le schede grafiche ATI in
X.org">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>

</body>
</section>
<section>
<title>Gestione Energetica del Wireless</title>
<body>

<p>
Le schede Wireless LAN consumano poca energia. È possibile inserirle nella
modalità risparmio energetico nello stesso modo dei propri hard disk.
</p>

<note>
Questo script considera la propria interfaccia wireless come <c>wlan0</c>;
sostituire questo valore con il nome della propria.
</note>

<p>
Per attivare in maniera automatica il risparmio energetico della propria scheda
wireless è necessario aggiungere l'opzione seguente al file
<path>/etc/conf.d/net</path>:
</p>

<pre caption="Attivazione automatica del risparmio energetico per le WLAN">
iwconfig_wlan0="power on"
</pre>

<p>
Per maggiori informazioni e altre opzioni come la configurazione del timeout e
del tempo tra i wakeup, è possibile consultare il manuale con
<c>man iwconfig</c>. Se i propri driver oppure l'access point supportano il
cambio del beacon time, questo può essere un altro modo per risparmiare ancora
più energia.
</p>

</body>
</section>
<section>
<title>Gestione Energetica per USB</title>
<body>

<p>
Ci sono due problemi riguardo il consumo di energia delle periferiche USB:
primo, periferiche come i mouse USB, le fotocamere digitali o le USB stick
consumano energia appena inserite. Non si può ovviare in nessun modo a questo
problema (a meno che non vengano rimosse se non necessarie). Secondo, quando ci
sono periferiche USB collegate, l'USB host controller accede periodicamente al
bus non permettendo alla CPU di passare nella modalità sleep. Il kernel presenta
una opzione sperimentale per attivare la sospensione delle periferiche USB
tramite le chiamate al driver oppure tramite uno dei file
<path>power/state</path> in <path>/sys</path>.
</p>

<pre caption="Attivazione del supporto USB suspend nel kernel">
Device Drivers
 USB support
  [*]   Support for Host-side USB
    [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Stati di Sleep: sleep, standby, suspend to disk</title>
<section>
<body>

<p>
L'ACPI definisce differenti stati di sleep. I più importanti sono
</p>

<ul>
  <li>S1 ossia Standby</li>
  <li>S3 ossia Suspend to RAM ossia Sleep</li>
  <li>S4 ossia Suspend to Disk ossia Hibernate</li>
</ul>

<p>
Possono essere chiamati quando il sistema non è in uso, ma non si vuole
effettuare lo shutdown a causa del lungo tempo di boot.
</p>

</body>
</section>
<section>
<title>Sleep (S3)</title>
<body>

<p>
Il supporto ACPI per questi stati di sleep è considerato sperimentale per delle
buone ragioni. Gli stati di sleep APM sembrano essere più stabili, purtroppo non
è possibile utilizzare contemporaneamente APM e ACPI.
</p>

<pre caption="Configurazione del kernel per il supporto agli stati di sleep">
 Power Management Options ---&gt;
  [*]  Power Management support
     ACPI (Advanced Configuration and Power Interface) Support ---&gt;
      [*]  ACPI Support
        [*]   Sleep States
</pre>

<p>
Compilato il kernel con le opzioni sopra considerate, è possibile utilizzare
l'<c>hibernate-script</c> per attivare la sospensione o una modalità di sleep.
</p>

<pre caption="Installazione dell'hibernate-script">
# <i>emerge hibernate-script</i>
</pre>

<p>
Sono ora necessarie alcune configurazioni in <path>/etc/hibernate</path>. In
modo predefinito, il pacchetto appena installato contiene alcuni file di
configurazione per ogni stato di sleep. In <path>common.conf</path> ci sono le
opzioni comuni a tutti i metodi di sospensione; assicurarsi che tali opzioni
siano corrette per il proprio sistema.
</p>

<p>
Per configurare lo sleep, bisogna modificare <path>sysfs-ram.conf</path> in
<path>/etc/hibernate</path>. <c>UseSysfsPowerState mem</c> è già configurato
correttamente ma se più avanti fosse necessario effettuare cambiamenti a questo
stato di sleep (o anche a qualsiasi altro stato), tali cambiamenti andrebbero
aggiunti al file <path>/etc/hibernate/hibernate.conf</path>. I commenti e i nomi
delle opzioni faranno da guida. Se si utilizzano condivisioni nfs o samba,
bisognerà assicurarsi di bloccare gli script init appropriati per evitare
timeout.
</p>

<note>
Per ulteriori informazioni sulla configurazione degli stati di sleep, vedere
<c>man hibernate.conf</c>.
</note>

<p>
Giunti a questo punto, questa sarà l'ultima occasione per effettuare un backup
dei propri dati prima dell'esecuzione del prossimo comando. Probabilmente per
tornare indietro dallo stato di sleep, occorrerà premere un tasto speciale come
<c>Fn</c>.
</p>

<pre caption="Chiamata di sleep">
# <i>hibernate-ram</i>
</pre>

<p>
Se si sta ancora leggendo questa guida, sarà segno di un corretto funzionamento.
Sarà possibile anche configurare lo standby (S1) in maniera simile modificando
il file <path>sysfs-ram.conf</path> e cambiando "UseSysfsPowerState mem" in
"UseSysfsPowerState standby". S3 e S4 sono gli stati di sleep più importanti
poichè permetteno un grande risparmio di energia.
</p>

</body>
</section>
<section>
<title>Hibernate (S4)</title>
<body>

<p>
Questa sezione tratta dell'ibernazione; un'immagine del sistema in esecuzione
viene scritta sul disco prima dello spegnimento. Alla riaccensione (resume),
l'immagine viene caricata ed è possibile riprendere il proprio lavoro dal punto
esatto in cui lo si è interrotto prima dell'ibernazione.
</p>

<warn>
Nessuna periferica hot-plug va cambiata o scambiata in stato di sospensione. Non
caricare un'immagine con un kernel differente rispetto a quello con cui la si è
creata. Ogni client/server samba o nfs va bloccato prima dell'ibernazione.
</warn>

<p>
Attualmente ci sono due implementazioni per S4. Quella originale è swsusp, poi
c'è la più nuova suspend2 con un'interfaccia carina (supporto fbsplash incluso).
È possibile trovare <uri
link="http://suspend2.net/features.html#compare">un'analisi comparativa</uri>
nell'<uri link="http://suspend2.net">homepage di suspend2</uri>. Suspend-to-Disk
(pmdisk), un fork di swsusp, è stato riunito al progetto originale.
</p>

<p>
Suspend2 non è ancora incluso nel kernel ufficiale, per questo motivo sarà
necessario applicare una patch, disponibile all'indirizzo <uri
link="http://suspend2.net">suspend2.net</uri>, ai sorgenti del kernel oppure
utilizzare <c>sys-kernel/suspend2-sources</c>.
</p>

<p>
La sezione del kernel necessaria sia a swsusp che a suspen2 è la seguente:
</p>

<pre caption="Configurazione del kernel per i vari stati di sospensione">
Power Management Options ---&gt;
  <comment>(hibernate con swsusp)</comment>
  [*] Software Suspend
      <comment>(sostituire /dev/SWAP con la propria partizione di swap)</comment>
      (/dev/SWAP)      Default resume partition

  <comment>(hibernate con suspend2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(sostituire /dev/SWAP con la propria partizione di swap)</comment>
    (swap:/dev/SWAP)   Default resume device name
    [ ]    Allow Keep Image Mode

</pre>

<p>
La configurazione di swsusp è piuttosto semplice. Se non si è indicata la giusta
locazione della partizione di swap nella configurazione del kernel, è possibile
passarla come parametro con la direttiva <c>resume=/dev/SWAP</c>. Se non è
possibile effettuare l'avvio a causa di un'immagine rovinata, si può utilizzare
il parametro del kernel <c>noresume</c>. Lo script di avvio
<c>hibernate-cleanup</c> invaliderà l'immagine rovinata durante il processo di
boot.
</p>

<pre caption="Invalidamento dell'immagine swsusp durante il processo di avvio">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Per attivare l'ibernazione con swsusp, si utilizza lo script hibernate dopo aver
impostato <c>UseSysfsPowerState disk</c> in
<path>/etc/hibernate/sysfs-disk</path>.
</p>

<warn>
È consigliabile effettuare un backup dei propri dati. Eseguendo <c>sync</c>
prima dell'esecuzione di uno dei comandi, i dati di cache verranno scritti sul
disco. Provare il tutto al di fuori dell'ambiente grafico X e, in seguito, con
X in esecuzione senza essere loggati al suo interno.
</warn>

<p>
Se dovesse capitare un kernel panic a causa di uhci o simili, è utile provare
a compilare il supporto USB come modulo per poterlo eventualmente "scaricare"
prima che il laptop vada nello stato di sleep. Ci sono opzioni di
configurazione a proposito in <path>common.conf</path>.
</p>

<pre caption="Ibernazione con swsusp">
# <i>nano -w /etc/hibernate/common.conf</i>
<comment>(Assicurarsi di avere un backup dei propri dati)</comment>
# <i>hibernate</i>
</pre>

<p>
La sezione seguente tratta della configurazione di suspend2 con il supporto
fbsplash per avere una "progress bar" (barra di avanzamento) grafica durante la
sospensione e il ripristino.
</p>

<p>
La prima parte della configurazione è simile alla configurazione di swsusp. Se
non si è indicata la giusta locazione della partizione di swap nella
configurazione del kernel, è possibile passarla come parametro con la direttiva
<c>resume2=swap:/dev/SWAP</c>. Se non è possibile effettuare l'avvio, si può
utilizzare il parametro <c>noresume2</c>. Inoltre, lo script di avvio
<c>hibernate-cleanup</c> invaliderà l'immagine di suspend2 rovinata durante il
processo di boot.
</p>

<pre caption="Invalidamento dell'immagine suspend2 durante il processo di avvio">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Ora è necessario modificare il file <path>/etc/hibernate/suspend2.conf</path>,
attivando la opzioni <c>suspend2</c> necessarie. Per il momento non attivare le
opzioni <c>fbsplash</c> in <c>common.conf</c>.
</p>

<pre caption="Ibernazione con suspend2">
# <i>nano -w /etc/hibernate.conf</i>
<comment>(Assicurarsi di avere un backup dei propri dati)</comment>
# <i>hibernate</i>
</pre>

<p>
Ora è il momento di configurare <c>fbsplash</c>. Per attivare il supporto
fbsplash durante l'ibernazione, è necessario il pacchetto
<c>sys-apps/suspend2-userui</c> con la flag USE <c>fbsplash</c> attivata.
</p>

<pre caption="Installazione di suspend2-userui">
# <i>echo sys-apps/suspend2-userui fbsplash &gt;&gt; /etc/portage/package.use</i>
<comment>(Dovrebbe essere necessario anche eseguire il comando seguente)</comment>
# <i>echo "sys-apps/suspend2-userui" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge suspend2-userui</i>
</pre>

<p>
L'ebuild richiede la creazione di un link simbolico al tema da utilizzare. Ad
esempio, per utilizzare il tema <c>livecd-2005.1</c>, sarà necessario il
comando:
</p>

<pre caption="Utilizzo del tema livecd-2005.1 durante l'ibernazione">
# <i>ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
Se non si vuole uno schermo nero nella prima parte del processo di ripristino,
bisognerà aggiungere <c>suspend2ui_fbsplash</c> alla propria immagine initrd. Se
si è creata la propria immagine initrd con <c>splash_geninitramfs</c> e la si è
salvata come <path>/boot/fbsplash-emergence-1024x768</path>, i passi da seguire
sono i seguenti:
</p>

<pre caption="Aggiunta di suspend2ui_fbsplash alla immagine initrd">
# <i>mount /boot</i>
# <i>mkdir ~/initrd.d</i>
# <i>cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
# <i>cd ~/initrd.d</i>
# <i>gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
# <i>rm fbsplash-emergence-1024x768</i>
# <i>cp /usr/sbin/suspend2ui_fbsplash sbin/</i>
# <i>find . | cpio --quiet --dereference -o -H newc | gzip -9 &gt; /boot/fbsplash-suspend2-emergence-1024x768</i>
</pre>

<p>
In seguito vanno modificati <path>grub.conf</path> (oppure
<path>lilo.conf</path>) a seconda del boot manager utilizzato per fare in modo
che il proprio kernel suspend2 utilizzi
<path>/boot/fbsplash-suspend2-emergence-1024x768</path> come immagine initrd.
Ora è possibile effettuare un test per verificare il corretto funzionamento.
</p>

<pre caption="Test di ibernazione con fbsplash">
# <i>suspend2ui_fbsplash -t</i>
</pre>

<p>
A questo punto aprire ancora una volta il file
<path>/etc/hibernate/common.conf</path> e attivare le opzioni fbsplash. Eseguire
<c>hibernate</c>, tutto dovrebbe funzionare in maniera corretta.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Risoluzione dei problemi</title>
<section>
<body>

<p>
<e>D:</e> Sto cercando di cambiare la frequenza della CPU, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> non esiste.
</p>

<p>
<e>R:</e> Assicurati che il tuo processore supporti il frequency scaling e di
aver scelto il driver giusto. Ecco una lista di processori supportati dal
cpufreq (kernel 2.6.7): ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan
- SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD
mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm, Intel mobile PIII
e Intel mobile PIII-M su alcuni chipset, Intel Pentium 4, Intel Xeon, Intel
Pentium M (Centrino), National Semiconductors Geode GX, Transmeta Crusoe, VIA
Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, alcuni "PowerBook" e "iBook2" e
vari processori su alcuni sistemi compatibili ACPI 2.0 (solo se gli "ACPI
Processor Performance States" sono disponibili attraverso l'interfaccia
ACPI/BIOS).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> è vuoto.
</p>

<p>
<e>R:</e> Cerca messaggi d'errore relativi all'ACPI con <c>dmesg | grep
ACPI</c>. Prova ad aggiornare il BIOS, specialmente se vedi errori riguardo il
DSDT. Puoi anche provare a corregge il problema manualmente (ma ciò è al di
fuori degli scopi di questa guida).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma secondo
<path>/proc/cpuinfo</path> la velocità non cambia mai.
</p>

<p>
<e>R:</e> Probabilmente hai attivato il supporto al symmetric multiprocessing
nel kernel (CONFIG_SMP). Disattivalo e dovrebbe funzionare. Alcune vecchie
versioni del kernel presentano un bug al riguardo. In questo caso, esegui
<c>emerge x86info</c>, aggiorna il tuo kernel come richiesto e controlla il
valore della frequenza con <c>x86info -mhz</c>.
</p>

<p>
<e>D:</e> Posso cambiare la frequenza della CPU, ma la scelta non è così ampia
come quella disponibile in un altro sistema operativo.
</p>

<p>
<e>R:</e> Puoi combinare il frequency scaling con l'ACPI throttling per ottenere
frequenze minori. Ricorda comunque che il throttling non risparmia molta energia
e viene usato solo per una gestione termica (mantiene il notebook freddo). Puoi
leggere lo stato attuale del throttling con <c>cat
/proc/acpi/processor/CPU/throttling</c> e cambiarlo con <c>echo -n "0:x" &gt;
/proc/acpi/processor/CPU/limit</c>, dove la x è una degli stati Tx elencati in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>D:</e> Nella configurazione del kernel powersave, performance e userspace
governors vengono mostrati, ma non vedo la voce ondemand. Dove la trovo?
</p>

<p>
<e>R:</e> Ondemand governor è incluso solamente nelle ultime versioni del
kernel. Prova ad aggiornarlo.
</p>

<p>
<e>D:</e> La durata della batteria sembra essere peggiorata rispetto a prima.
</p>

<p>
<e>R:</e> Controlla le impostazioni del tuo BIOS. Potresti aver dimenticato di
riattivarne alcune.
</p>

<p>
<e>D:</e> La mia batteria è carica, ma per KDE è del tutto scarica (riporta 0%)
e, quindi, viene avviato la sequenza di shutdown.
</p>

<p>
<e>R:</e> Controlla che il supporto batteria sia attivato nel tuo kernel. Se lo
hai compilato come modulo, assicurati di averlo caricato correttamente.
</p>

<p>
<e>D:</e> Nei miei log di sistema leggo cose del tipo "logger: ACPI group
battery / action battery is not defined".
</p>

<p>
<e>R:</e> Questo messaggio viene generato dallo script
<path>/etc/acpi/default.sh</path> incluso con acpid. Puoi tranquillamente
ignorarlo. Se ti crea fastidio, puoi commentare la riga appropriata in
<path>/etc/acpi/default.sh</path> come mostrato di seguito:
</p>

<pre caption="Disabilitazione degli avvisi per eventi acpi sconosciuti">
        *)      # logger "ACPI action $action is not defined"
</pre>

<p>
<e>D:</e> Ho un Dell Inspiron 51XX e non riesco ad ottenere eventi ACPI.
</p>

<p>
<e>R:</e> Sembra essere un bug del kernel. Leggi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">qui</uri>.
</p>

<p>
<e>D:</e> Ho attivato l'opzione <c>DynamicClocks</c> in <path>xorg.conf</path>
e ora ottengo crash / lo schermo rimane nero / il mio notebook non effettua
correttamente lo shutdown (spegnimento).
</p>

<p>
<e>R:</e> Questo accade purtroppo su alcuni sistemi. L'unica soluzione è la
disattivazione dell'opzione <c>DynamicClocks</c>.
</p>

<p>
<e>D:</e> Voglio utilizzare suspend2, ma la mia partizione di swap viene
indicata come troppo piccola. Non posso effettuare un suo ridimensionamento.
</p>

<p>
<e>R:</e> Se non c'è abbastanza spazio libero sul tuo sistema, è possibile
utilizzare il filewriter al posto dello swapwriter. <c>hibernate-script</c>
lo supporta bene. Maggiori informazioni nel file
<path>/usr/src/linux/Documentation/power/suspend2.txt</path>.
</p>

<p>
<e>D:</e> Ho appena comprato una nuova batteria, ma dura solo per pochi minuti!
Cosa faccio di sbagliato?
</p>

<p>
<e>R:</e> Prima di tutto segui le istruzioni del venditore su come caricare
correttamente la batteria.
</p>

<p>
<e>D:</e> Niente, è inutile. Cosa faccio ora?
</p>

<p>
<e>R:</e> Alcune batterie vendute come "nuove" sono in realtà vecchie. Prova
questo:
</p>

<pre caption="Stato della batteria">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Se il valore di "last full capacity" differisce di molto da quello di design
capacity, la tua batteria è probabilmente rotta. Usa la garanzia.
</p>

<p>
<e>D:</e> Non ho trovato una soluzione al mio problema. Cosa faccio?
</p>

<p>
<e>R:</e> Prova a contattarmi direttamente, <mail link="earthwings@gentoo.org">
Dennis Nienhüser</mail>. I <uri link="http://forums.gentoo.org">forum di
Gentoo</uri> sono un ottimo posto in cui chiedere e trovare aiuto. Se preferisci
IRC, prova il canale <e>#gentoo-laptop</e> su <uri
link="irc://irc.freenode.net">irc.freenode.net</uri>.
</p>

</body>
</section>
</chapter>
</guide>
