<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/power-management-guide.xml,v 1.5 2005/06/16 16:52:03 so Exp $ -->
<guide link="power-management-guide.xml" lang="it">
<title>Guida alla Gestione Energetica</title>

<author title="Autore">
  <mail link="fragfred@gmx.de">Dennis Nienhüser </mail>
</author>
<author title="Traduzione">
  <mail link="frgrieco@aliceposta.it">Francesco Grieco</mail>
</author>

<abstract>
La gestione energetica è l'unica soluzione per estendere la durata della batteria
sui sistemi mobile come i notebook. Questa guida ne illustra la sua configurazione.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.23</version>
<date>2005-05-28</date>

<chapter>
<title>Introduzione</title>
<section>
<title>A cosa serve la Gestione Energetica?</title>
<body>

<p>
Capacità e durata delle batterie dei notebook sono migliorate molto nel corso
degli ultimi anni. Tuttavia i moderni processori consumano molta più energia dei
vecchi e ad ogni nuova generazione di notebook si aggiungono nuove periferiche
"affamate" di energia. Ecco il perchè dell'importanza della gestione energetica.
Applicando buone politiche di risparmio energetico non sarà sempre necessario
acquistare un'altra batteria.
</p>

</body>
</section>

<section>
<title>Breve panoramica</title>
<body>

<p>
Questa guida tratta della gestione energetica per i <e>notebook</e>.
Alcune sezioni potrebbero essere valide anche per i <e>server</e>, altre
non lo sono sicuramente e potrebbero causare problemi. Si consiglia
fortemente di non applicare niente di quello contenuto in questa guida
a macchine server a meno che non si sappia veramente quello che si
sta facendo.
</p>

<p>
Poichè questa guida diventa sempre più lunga, segue una breve panoramica di 
ciò che sarà trattato.
</p>

<p>
La sezione <e>Prerequisiti</e> tratta di alcuni requisiti di base necessari
per tutte le sezioni a seguire della guida. Include settaggi del BIOS e 
particolari configurazioni nel kernel. I seguenti tre capitoli pongono 
l'attenzione sui componenti che tipicamente consumano maggiore energia - 
il processore, il display e l'hard disk. Ognuno di essi pùo essere configurato
separatamente. <e>Power Management della CPU</e> mostra come modificare la frequenza del
processore al fine di risparmiare energia senza un eccessivo calo delle performance.
Alcuni stratagemmi in <e>Power Management dell'Hard Disk</e> permettono di
allegerire il carico di lavoro del disco (avendo come effetto anche una 
riduzione del livello di rumore). Indicazioni anche per le card Wireless LAN e
per le periferiche USB in <e>Power Management delle altre periferiche</e> mentre
un altro intero capitolo è dedicato agli (ancora sperimentali) <e>Stati di Sleep</e>.
Infine un ultimo capitolo dedicato ai <e>Problemi</e> più comuni in cui 
è possibile incorrere.
</p>

</body>
</section>

<section>
<title>Bilancio energetico per ogni componente</title>
<body>

<figure link="/images/energy-budget.png" short="Quale componente consuma quanta 
energia?" caption="Peso energetico per ogni componente"/>

<p>
Quasi tutti i componenti possono funzionare in differenti stati - off, sleep, idle, active -
consumando a seconda dei casi diverse quantità di energia. La maggior parte dell'energia
viene consumata dal display LCD, dalla CPU e dagli hard disk. Spesso alcuni di essi
sono in grado di attivare politiche di gestione energetica attraverso il BIOS, ma
una configurazione intelligente del proprio sistema operativo adattabile
a diverse situazioni può ottenere molto di più.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisiti</title>
<section>
<title>Prima di tutto</title>
<body>

<p>Prima di entrare nei dettagli della gestione energetica per le singole periferiche,
vi sono alcuni requisiti. Dopo aver controllato i settaggi del BIOS, è necessario 
attivare alcune opzioni del kernel - in breve ACPI, sleep states e CPU frequency scaling.
Poichè il risparmio energetico comporta una perdita delle prestazioni o un aumento
della latenza, deve essere attivato, naturalmente, solamente in assenza di una
connessione a rete elettrica. Da qui la necessità di un nuovo runlevel <e>battery</e>.
</p>

</body>
</section>
<section>
<title>Il BIOS</title>
<body>

<p>
Per prima cosa è necessario controllare i settaggi relativi al Power Management
nel BIOS. Di solito la soluzione migliore è combinare i settaggi del BIOS alle
politiche del sistema operativo, ma per il momento è meglio disabilitare le
funzioni del BIOS. In questo modo niente interferisce con le nuove politiche
imposte dal sistema operativo. Dopo aver configurato tutto per bene, sarà
necessario riabilitare tutte le funzioni del BIOS.
</p>

</body>
</section>
<section>
<title>Configurazione del Kernel</title>
<body>

<p>
Il supporto dell'ACPI (Advanced Configuration and Power Interface) nel kernel
è ancora in fase di sviluppo. Pertanto è consigliabile usare sempre il kernel
più recente.
</p>

<p>
Nella configurazione del kernel si devono attivare le seguenti opzioni:
</p>

<pre caption="Settaggi minimi del kernel per il Power Management (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>driver CPUFreq a seconda del processore</i>
</pre>

<p>
E' possibile anche attivare, a propria discrezione, Software Suspend, Suspend-to-Disk e Sleep States.
I possessori di notebook ASUS, Medion o Toshiba devono attivare i relativi 
moduli specifici. 
</p>

<p>
Il kernel deve essere in grado di attivare il CPU frequency scaling (cambio di frequenza della CPU) sul processore. Poichè ogni CPU presenta una interfaccia differente dalle altre, è necessario scegliere il driver giusto per il proprio processore. Si presti attenzione - ad esempio attivando 
<e>Intel Pentium 4 clock modulation</e> su un Pentium M, si otterà molto probabilmente un sistema poco stabile. La documentazione del kernel può chiarire qualsiasi dubbio in proposito.
</p>

<p>
Dopo la compilazione del kernel bisogna assicurarsi del corretto caricamento dei moduli
all'avvio e riavviare il notebook con il nuovo kernel con ACPI abilitato. Per installare il demone acpi,
da riga di comando <c>emerge sys-power/acpid</c>. Il suddetto demone gestisce
eventi quali il passaggio da corrente a batteria o la chiusura del lid. E' necessario
assicurarsi che i moduli siano caricatici se non compilati direttamente
all'interno del proprio kernel. Ora si avvii il demone acpid con <c>/etc/init.d/acpid
start</c> e si esegua <c>rc-update add acpid default</c> per caricarlo all'avvio. Il suo
utilizzo verrà spiegato in seguito.
</p>

<pre caption="Installazione di acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creazione del runlevel "battery"</title>
<body>

<p>
La configurazione di default attiverà il risparmio energetico solo quando
necessario - in pratica quando il notebook funziona con la propria
batteria. Per effettuare il passaggio fra stato di corrente e di batteria,
sarà necessario creare un runlevel <e>battery</e> in grado di gestire
l'avvio e il blocco degli script di risparmio energetico.
</p>

<note>
Se l'idea di avere un ulteriore runlevel non convince, è possibile saltare
questa sezione. Naturalmente ciò renderà tutto un pò più complicato. La
sezione seguente considera l'esistenza di un runlevel <e>battery</e>.
</note>

<pre caption="Creazione di un runlevel battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finito. Il nuovo runlevel <e>battery</e> contiene tutto come <e>default</e>, ma 
non c'è ancora nessun cambio automatico tra i due livelli.
</p>

</body>
</section>
<section>
<title>Risposta agli eventi ACPI</title>
<body>

<p>
Di solito gli eventi ACPI sono la chiusura del lid, il cambio della sorgente
energetica e il bottone di sleep. Il cambio di sorgente energetica è un evento
importante e deve necessariamente generare un cambio di runlevel. La creazione dei file
seguenti permetterà un cambio fra i runlevel <e>default</e> e <e>battery</e>
a seconda del tipo di sorgente energetica utilizzata.
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># INIZIO configurazione</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># FINE configurazione</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
	logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
	exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
	logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
	exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
	    logger "Switching to ${RUNLEVEL_AC} runlevel"
	    /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
	logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
	/sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Si sostituisca "ac_adapter" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Per conoscere il nome dell'evento si legga /var/log/acpid</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Si sostituisca "battery" indicato di seguito con l'evento generato dal proprio notebook</comment>
<comment># Per conoscere il nome dell'evento si legga /var/log/acpid</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Ora è necessario il pacchetto sys-power/powermgmt-base che contiene l'utility
<c>on_ac_power</c>. Il file <path>pmg_switch_runlevel.sh</path>
deve essere eseguibile.
</p>

<pre caption="Cambio dei runlevel con acpid">
<i># emerge powermgmt-base</i>
<i># chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</i>
<i># /etc/init.d/acpid restart</i>
</pre>


<p>
Provando ora ad attaccare e staccare l'alimentazione a corrente, nei log di
sistema dovrebbero apparire a seconda dei casi i messaggi "Switching to AC
mode" o "Switching to battery mode".
Se lo script non è in grado di rilevare correttamente la sorgente di energia
utilizzata, è possibile consultare la sezione Problemi.
</p>

<p>
A causa della natura del meccanismo degli eventi, il notebook, al boot,
passa al runlevel default che sia o meno collegato alla rete elettrica.
E' necessario aggiungere, per questo, una nuova entry al boot
loader con l'opzione <c>softlevel=battery</c>; soluzione scomoda. Una soluzione
migliore è quella di creare un evento ACPI finto alla fine del processo di boot
e lasciare che lo script <path>/etc/acpi/default.sh</path> decida quale
runlevel utilizzare. Si apra con il proprio editor il file <path>/etc/conf.d/local.start</path>
e si aggiungano le linee:
</p>

<pre caption="Cambio del runlevel al boot del notebook con la modifica di local.start">
<comment># Finto evento acpi per cambiare runlevel se scollegati da rete elettrica</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Conclusa questa parte preparativa, è ora possibile attivare le politiche di
gestione energetica per ogni singolo componente.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management della CPU</title>
<section>
<title>Terminologia tecnica</title>
<body>

<p>
Il CPU frequency scaling introduce alcuni termini tecnici che potrebbero
essere non conosciuti. Segue, per questo motivo, una breve introduzione.
</p>

<p>
Prima di tutto, il kernel deve essere in grado di cambiare la frequenza
di funzionamento della CPU. Il <e>CPUfreq processor driver</e> contiene
i comandi per effettuare questa operazione su ogni tipo di CPU. Per questo motivo è importante
indicare il driver giusto da utilizzare nel proprio kernel (operazione già
effettuata precedentemente). Inoltre, il kernel deve anche scegliere la
frequenza corretta di funzionamento da utilizzare nelle diverse situazioni. Questa viene
fissata in base ad una <e>policy</e> (politica di gestione) che consiste in
una <e>CPUfreq policy</e> e in un <e>governor</e> (regolatore).
Una CPUfreq policy non è altro che un insieme di due numeri che definiscono
un campo all'interno del quale la frequenza può oscillare - un valore minimo e
uno massimo. Il governor, invece, decide quale delle frequenze disponibili fra la
minima e la massima utilizzare. Ad esempio, il <e>powersave governor</e> utilizza
sempre la frequenza più bassa disponibile, il <e>performance governor</e>, invece,
la più alta. L'<e>userspace governor</e> non sceglie nessuna frequenza in particolare
ma utilizza quella indicata dall'utente (o da un programma in
userspace); il valore della frequenza viene letto da 
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Questo può non sembrare un cambiamento dinamico della frequenza e in effetti non lo
è. La dinamicità può essere realizzata con diversi approcci.
Ad esempio, <e>ondemand governor</e> prende le sue decisioni in
base al carico di lavoro della CPU. La stessa cosa viene fatta
da utility come <c>cpudyn</c>, <c>cpufreqd</c>, <c>powernowd</c> e
molte altre. Gli eventi ACPI possono essere utilizzati per attivare o
disattivare i cambi dinamici della frequenza a seconda della sorgente energetica utilizzata.
</p>

</body>
</section>

<section>
<title>Settaggio manuale della frequenza</title>
<body>

<p>
Diminuendo la velocità e il voltaggio della CPU si hanno due vantaggi: viene
consumata meno energia e il notebook non si riscalda eccessivamente. Il grande
svantaggio, naturalmente, è una perdita di performance. La diminuzione della
velocità del processore resta in ogni caso un buon compromesso fra calo di
performance e risparmio energetico.
</p>

<note>
Non tutti i notebook supportano il frequency scaling. In caso di dubbi, una lista
dei processori supportati si trova nella sezione <e>Problemi</e>.
</note>

<p>
E' ora di provare il corretto funzionamento del cambio di frequenza della CPU.
<c>sys-power/cpufrequtils</c> è un programmino molto utile per effettuare un semplice debug.
</p>

<pre caption="Controllo della frequenza della CPU">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Ecco un esempio di quello che si ottiene:
</p>

<pre caption="Output di esempio di cpufreq-info">
cpufrequtils 0.2: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
 driver: centrino
 CPUs which need to switch frequency at the same time: 0
 hardware limits: 600 MHz - 1.40 GHz
 available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
 available cpufreq governors: ondemand, powersave, userspace, performance
 current policy: frequency should be within 924 MHz and 1.40 GHz.
  The governor "performance" may decide which speed to use
  within this range.
 current CPU frequency is 1.40 GHz (asserted by call to hardware).
</pre>

<p>
Si utilizzi <c>cpufreq-set</c> per assicurarsi che il cambio di frequenza funzioni.
Il comando <c>cpufreq-set -g ondemand</c>, ad esempio, attiva l'ondemand governor;
lo si esegua e si verifichi il cambiamento con <c>cpufreq-info</c>. Se non funziona
come dovrebbe, la sezione Problemi alla fine di questa guida potrebbe essere d'aiuto.
</p>

</body>
</section>
<section>
<title>Adattamento automatico della frequenza</title>
<body>

<p>
Tutto questo è molto semplice, ma scomodo da effettuare tutti i giorni. Meglio lasciare che sia
il proprio sistema a settare automaticamente la frequenza appropriata. 
La tabella seguente presenta una panoramica delle utility necessarie a questo compito. E' suddivisa
in tre categorie: <e>kernel</e> per soluzioni che hanno bisogno solo
del supporto del kernel, <e>demone</e> per programmi che lavorano in
background e <e>GUI</e> per programmi che forniscono una interfaccia
grafica per una configurazione più semplice.
</p>

<table>
<tr>
  <th>Nome</th>
  <th>Categoria</th>
  <th>Causa cambio</th>
  <th>Governor del kernel</th>
  <th>Governor supportati</th>
  <th>Note</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>Carico della CPU</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Configurazione attraverso i file presenti in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>.
    Richiede ancora tool in userspace (programmi, script) in caso
    di utilizzo del cambio di governor.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Performance, powersave</ti>
  <ti>Dynamic</ti>
  <ti>
    Supporta anche lo standby dei dischi - si noti, però, che il <e>laptop mode</e>
    in molti casi funziona decisamente meglio.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demone</ti>
  <ti>Stato della batteria, Carico della CPU, Programmi in esecuzione</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Configurazioni sofisticata (ma anche complesse). 
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>
    Supporta SMP.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Piccola ma efficace con una utile interfaccia client/server. Richiede un 
    kernel della serie 2.6. Il suo sviluppo sembra non continuare e a breve
    dovrebbe essere rimossa dal Portage.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>GUI</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>
    Applicazione per Gnome, utility grafica per configurare manualmente la
    frequenza della CPU. Non offre nessun tipo di automazione.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>GUI</ti>
  <ti>Stato della batteria</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Solamente per KDE, 'ondemand' governor necessario per il cambio dinamico della
    frequenza.
  </ti>
</tr>
</table>

<p>
L'adattamento della frequenza della CPU al carico di lavoro corrente del notebook
può sembrare semplice da attuare ad una prima occhiata, ma in realtà non lo è.
Un algoritmo errato può causare cambi continui fra due frequenze o
spreco di energia quando la frequenza viene portata inutilmente a valori troppo alti.
</p>

<p>
Quale scegliere? Se si è indecisi, un'ottima scelta è <c>cpufreqd</c>:
</p>

<pre caption="Installazione di cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
La configurazione di <c>cpufreqd</c> avviene attraverso il file <path>/etc/cpufreqd.conf</path>.
Quella di default fornita con cpufreqd sembra leggermente confusionaria. Si raccomanda
di sostituirla con quella fornita dallo sviluppatore Gentoo, Henrik Brix Andersen (si guardi di seguito).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5
	
[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=ondemand

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=performance
</pre>

<p>
Se si sta utilizzando un kernel 2.6 con interfaccia sysfs (e per la maggior parte dei casi è così), 
non è possibile utilizzare valori in percentuale come riportato appena sopra. Le percentuali devono
essere sostituite con i valori minimi e massimi di frequenza come riportato da <c>cpufreq-info
--hwlimits</c>. Ad esempio, per un Pentium M 1.4 GHz si ottengono i valori:
</p>

<pre caption="Esempi di valori di minfreq e maxfreq">
minfreq=600000
maxfreq=1400000
</pre>

<p>
Infine bisogna avviare il demone.
</p>

<pre caption="Avvio di cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<warn>
Non si esegua più di uno dei programmi sopra citati contemporaneamente. Potrebbero, infatti, esserci problemi come un cambio continuo fra due frequenze.
</warn>

</body>
</section>

<section>
<title>Verifica di funzionamento a seguito delle modifiche apportate</title>

<body>

<p>
L'ultima cosa da controllare è che le nuove politiche di risparmio energetico
facciano bene il loro lavoro. Un modo semplice per verificare ciò è il 
monitoraggio della velocità della CPU mentre è al lavoro sul notebook:
</p>

<pre caption="Monitoraggio della velocità della CPU">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Se <path>/proc/cpuinfo</path> non dovesse venire aggiornato (sezione Problemi), si provi a monitorare 
la frequenza della CPU con:
</p>

<pre caption="Monitoraggio alternativo della velocità della CPU">
# <i>watch x86info -mhz</i>
</pre>

<p>
A seconda dei settaggi, la velocità della CPU dovrebbe aumentare in caso di richieste
d'uso, diminuire in mancanza di attività o, semplicemente, rimanere costante. Quando
si utilizza cpufreqd e la voce verbosity è impostata ad un valore di 5 o più in <path>cpufreqd.conf</path>,
nei syslog si otterrano maggiori informarzioni su quello che accade.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management del display LCD</title>
<section>
<title>Il maggior consumatore di energia</title>
<body>

<p>
Come si può vedere dalla <uri link="#doc_chap1_fig1">figura 1.1</uri>, il display
LCD consuma la maggior parte dell'energia (questo potrebbe non valere nel caso
di CPU non mobile). Per questo non solo è importante spegnere il display quando
non utilizzato, ma anche ridurre il backlight (retroilluminazione) se possibile.
Molti notebook offrono la possibilità di regolare il backlight.
</p>

<p>
La prima cosa da controllare sono i settaggi di standby/suspend/off del display.
Questi sono tutti valori che dipendono dal windowmanager. L'oscuramento del
terminale può essere effettuato con <c>setterm -blank &lt;numero-di-minutiM&gt;</c>,
<c>setterm -powersave on</c> e <c>setterm -powerdown &lt;numero-di-minutiM&gt;</c>.
Per Xorg, si può editare <path>/etc/X11/xorg.conf</path> come di seguito riportato:
</p>

<pre caption="Settaggi dell'LCD suspend in Xorg e in XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Oscura lo schermo dopo cinque minuti (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># Spegne lo schermo dopo 10 minuti (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Suspend dopo 20 minuti</comment>
  Option  "OffTime"  "30"  <comment># Spegne dopo mezz'ora</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Vale lo stesso per XFree86 e <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probabilmente la gestione del backlight (retroilluminazione) è il punto più importante.
Se si è in grado di accedere al controllo tramite un tool, bisogna scrivere un piccolo
script in grado di settare il backlight nella modalità batteria e inserirlo nel
runlevel <e>battery</e>. Lo script seguente dovrebbe funzionare sulla maggior parte
dei notebook IBM Thinkpad. Necessita del pacchetto <c>app-laptop/ibm-acpi</c>
oppure dell'opzione appropriata selezionata nel kernel.
</p>

<warn>
Il supporto per la regolazione della luminosità è sperimentale nel pacchetto
ibm-acpi. L'accesso diretto all'hardware di questa utility potrebbe provocare blocchi inaspettati del sistema.
Si legga a tale proposito il <uri link="http://ibm-acpi.sourceforge.net/">sito ufficiale</uri> del pacchetto ibm-acpi.
</warn>

<p>
Per essere in grado di regolare il livello di lumonisità, il modulo ibm_acpi deve essere
caricato con il paramentro sperimentale.
</p>

<pre caption="Caricamento automatico del modulo ibm_acpi">
<comment>(Prima di proseguire si legga l'avviso sopra riportato circa l'instabilità di questa opzione)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
Queste operazioni non dovrebbero produrre messaggi di errore e, 
dopo il caricamento del modulo, dovrebbe essere creato il file  <path>/proc/acpi/ibm/brightness</path>.
Uno script di avvio avrà il compito di scegliere il miglior livello di luminosità
in base alla sorgente energetica disponibile.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Si legga /proc/acpi/ibm/brightness per i valori disponibili</comment>
<comment># Per altre informazioni /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># Livello di lumonisità in modalità corrente. Di default 7.</comment>
BRIGHTNESS_AC=7

<comment># Livello di luminosità in modalità batteria. Di default 4..</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
	if on_ac_power
	then
            LEVEL=${BRIGHTNESS_AC:-7}
	else
            LEVEL=${BRIGHTNESS_BATTERY:-4}
	fi

	if [ -f /proc/acpi/ibm/brightness ]
	then
	    ebegin "Setting LCD brightness"
	    echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
	    eend $?
	else
	    ewarn "Setting LCD brightness is not supported."
	    ewarn "Check that ibm_acpi is loaded into the kernel"
	fi
}
	
start() {
	set_brightness
}

stop () {
	set_brightness
}
</pre>

<p>
Una volta finito, bisogna assicurarsi che la luminosità sia regolata automaticamente
aggiungendo lo script al runlevel battery.
</p>

<pre caption="Regolazione automatica della luminosità">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>


</body>
</section>
</chapter>

<chapter>
<title>Power Management dell'Hard Disk</title>
<section>
<title>Sleep quando in idle</title>
<body>

<p>
L'obiettivo è portare l'hard disk nello stato di sleep il prima possibile
quando non viene utilizzato. Verranno analizzate due possibilità. La prima
è <c>cpudyn</c>. Bisogna decommentare le linee nella sezione "Disk Options" in
<path>/etc/conf.d/cpudyn</path>. Per portare l'hard disk in sleep dopo 60 secondi
di inattività si deve agire nel modo seguente:
</p>

<pre caption="Uso di cpudyn per lo standby dell'hard disk">
<comment>################################################
# DISK OPTIONS
# (opzioni disabilitate di default)
################################################

#
# Tempo dopo il quale porre il disco in modalità standby
# in mancanza di operazioni IO (in secondi)
#
</comment>
TIMEOUT=60
<comment>
#
# Dischi sui quali effettuare lo spindown (separati da virgole)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
La seconda possibilità è quella di usare un piccolo script e hdparm.
Si crei <path>/etc/init.d/pm.hda</path> come riportato di seguito:
</p>

<pre caption="Uso di hdparm per lo standby dell'hard disk">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Con <c>man hdparm</c> è possibile avere informazioni sulle varie opzioni.
Una volta pronto, è necessario aggiungere lo script al runlevel battery.
</p>

<pre caption="Configurazione per lo standby automatico del disco">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Si presti molta attenzione ai settaggi di sleep e di spin down del proprio hard disk.
Settaggi troppo spinti (valori molto piccoli) possono danneggiare l'hardware e invalidare
la garanzia.
</impo>

</body>
</section>
<section>
<title>Aumento del tempo di idle - laptop-mode</title>
<body>

<p>
Gli ultimi kernel (2.6.6 e maggiori, gli ultimi della serie 2.4 e altri con alcune patch)
includono il così detto <e>laptop-mode</e>. Quando attivato, le operazioni 
di scrittura avvengono ogni 10 minuti (invece di 30 secondi). Questo fà si che l'hard disk
non lavori in maniera continuativa.
</p>

<pre caption="Avvio automatico del laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
I <c>laptop-mode-tools</c> hanno la propria configurazione in 
<path>/etc/laptop-mode/laptop-mode.conf</path>. E' possibile
adattarla alle proprie esigenze; la documentazione è presente nel file di configurazione stesso.
Per rendere automatico l'avvio <c>rc-update add laptop_mode battery</c>.
</p>

</body>
</section>
<section>
<title>Altri consigli</title>
<body>

<p>
Oltre a portare il proprio hard disk nello stato di sleep il prima possibile,
una buona idea è minimizzare gli accessi al disco. Si osservino i processi che
scrivono sul disco frequentemente - syslogd è un buon candidato. Non sarà necessario
fermarlo completamente, ma è possibile modificare il suo file di configurazione in
modo tale che non tutto venga loggato, riducendo in questo modo gli accessi al disco.
Cups scrive sul disco periodicamente, quindi fermarlo e attivarlo manualmente
solo quando necessario è una buona idea.
</p>

<pre caption="Disattivare cups nella modalità batteria">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Un'altra possibilità è la disattivazione dello swap nella modalità batteria.
Prima di scrivere qualcosa che attivi e disattivi lo swap, bisogna assicurarsi
che ci sia abbastanza RAM e che lo swap non sia usato pesantemente, altrimenti
si potrebbero avere problemi.
</p>

<p>
Se non si vuole utilizzare il laptop-mode, è sempre possibile minimizzare gli
accessi al disco montando alcune directory come <e>tmpfs</e> - gli accessi in
scrittura non avvengono sul disco, ma nella memoria principale e vengono
persi con l'operazione di unmount. Spesso è utile montare <path>/tmp</path>
allo stesso modo - il suo contenuto viene in ogni caso perso ad ogni reboot
che sia montato o meno sul disco o in RAM. Bisogna solo essere certi
di avere RAM a sufficienza e nessun programma (come un client per i download o
un programma di compressione) che abbia bisogno di molto spazio in <path>/tmp</path>.
Per usare questa soluzione è necessario avere il supporto tmpfs abilitato
nel kernel e  aggiungere una linea come la seguente in <path>/etc/fstab</path>:
</p>

<pre caption="Modifica di /etc/fstab per rendere /tmp volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Si presti attenzione al parametro size e lo si modifichi per il proprio sistema.
Se non si è sicuri, non lo si modifichi, in quanto si creerebbero facilmente
grossi cali di performance (effetto collo di bottiglia). Se si volesse montare
<path>/var/log</path> nello stesso modo, non bisogna dimenticare di unire i file
di log al disco prima di effettuare l'unmounting. Sono essenziali. Montare anche
/var/tmp allo stesso modo è inutile. Portage usa questa directory per la compilazione...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Power Management delle altre periferiche</title>
<section>
<title>Power Management del Wireless</title>
<body>

<p>
Le card Wireless LAN consumano poca energia. E' possibile inserirle nella modalità
risparmio energetico in analogia allo script pm.hda.
</p>

<pre caption="Power Management automatico per le WLAN">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
L'esecuzione di questo script porta la wlan0 in modalità risparmio energetico
ponendola in stato di sleep dopo tre secondi di assenza di traffico.
Lo si salvi come <path>/etc/init.d/pm.wlan0</path> e lo si aggiunga al runlevel
battery come gli altri. Per dettagli e maggiori opzioni <c>man iwconfig</c>.

Se i propri driver oppure l'access point supportano il cambio del beacon time,
questo può essere un altro modo per risparmiare ancora più energia.
</p>


<pre caption="Power Management for WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>USB Power Management</title>
<body>

<p>
Ci sono due problemi riguardo il consumo di energia delle periferiche USB: 
primo, periferiche come i mouse USB, le fotocamere digitali o le USB stick consumano
energia appena inserite. Non si può ovviare in nessun modo a questo problema 
(a meno che non vengano rimosse se non necessarie). Secondo, quando ci sono
periferiche USB collegate, l'USB host controller accede periodicamente al bus
non permettendo alla CPU di passare nelle modalità sleep C3/4. Il Sistema 
Operativo risolve questo problema attraverso l' "USB selective
suspend", non ancora implementato nel kernel. L'USB selective suspend permette
l'accesso al bus solo quando la periferica è in uso. L'unico modo, al momento,
per aggirare questo problema (fino alla sua implementazione nel kernel) è
compilare il supporto USB e le sue periferiche come moduli e rimuoverli attraverso
uno script quando non utilizzati (ad esempio alla chiusura del lid).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Stati di Sleep: sleep, standby, suspend to disk</title>
<section>
<title>Cosa sono</title>
<body>

<p>
L'ACPI definisce differenti stati di sleep. I più importanti sono
</p>

<ul> 
  <li>S1 ossia Standby</li>
  <li>S3 ossia Suspend to RAM ossia Sleep</li>
  <li>S4 ossia Suspend to Disk ossia Hibernate</li>
</ul>

<p>
Possono essere chiamati quando il sistema non è in uso, ma non si vuole
effettuare lo shutdown a causa del lungo tempo di boot.
</p>

</body>
</section>
<section>
<title>Sleep, Standby &amp; Hibernate</title>
<body>

<p>
Il supporto ACPI per questi stati di sleep è instabile per alcune buone ragioni. 
Gli stati di sleep APM sembrano più stabili, ma non è possibile utilizzare 
contemporaneamente l'APM e l'ACPI.
</p>

<warn>
Nonostante il supporto agli stati di sleep vada continuamente migliorando, resta
tuttora in una fase sperimentale. Swsusp2 e Suspend to Ram sembrano funzionare bene ma
è necessario prestare attenzione: si potrebbe facilmente andare incontro a perdita dati.
</warn>

<p>
Attualmente ci sono tre implementazioni per S4. Quella originale è swsusp,
a seguire swsusp2 che ha l'interfaccia più carina (include il supporto del
bootsplash), ma richiede l'applicazione manuale di una patch al kernel. Ed
infine Suspend-to-Disk, un fork di swsusp.
</p>

<p>
Per un'analisi comparativa delle caratteristiche si veda <uri
link="http://softwaresuspend.berlios.de/features.html#compare"> qui</uri>.
Se non si dovesse ancora sapere quale scegliere, swsusp2
sembra al momento la soluzione più promettente.
</p>

<p>
La sezione del kernel a riguardo è la seguente:
</p>

<pre caption="Configurazione del kernel per i vari stati di sospensione">
Power Management Options ---&gt;

  <comment>(sleep e standby)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernate con swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)
  
  <comment>(hibernate con swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"your-swap-here")    Default resume device name

  <comment>(hibernate con Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"your-swap-here") Default resume partition
</pre>

<p>
Si compili il kernel con le appropriate opzioni abilitate e si controlli, tramite 
<c>cat /proc/acpi/sleep</c> per il 2.4 e <c>cat /sys/power/state</c> per il 2.6,
ciò che si ha di supportato. Per swsusp è necessario passare al kernel il parametro
<c>resume=/dev/"propria-partizione-di-swap"</c>. Se questo non fosse possibile,
si usi <c>noresume</c> per swsusp, <c>pmdisk=off</c> per Suspend-to-Disk e
<c>noresume2</c> per swsusp2.
</p>

<p>
Per portare il proprio sistema in uno degli stati di sleep:
</p>

<pre caption="Attivazione degli stati di sleep">
<comment>(per i kernel 2.4)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>(standby)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(sleep)</comment>

<comment>(per i kernel 2.6)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>(standby)</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(sleep)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(hibernate)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(hibernate)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                   <comment>(hibernate, si legga di seguito)</comment>
</pre>

<warn>
E' consigliabile effettuare un backup dei propri dati. Eseguendo <c>sync</c> prima
dell'esecuzione di uno dei comandi, i dati di cache verranno scritti sul disco.
Provare il tutto al di fuori dell'ambiente grafico X e, in seguito, con X in 
esecuzione senza essere loggati al suo interno.
</warn>
 
<p>
Se dovesse capitare un kernel panic a causa di uhci o simili, è utile provare
a compilare il supporto USB come modulo per poterlo eventualmente "scaricare" 
prima che il laptop vada nello stato di sleep.
</p>

<p>
Mentre tutto ciò che si è visto fino ad ora è sufficiente per eseguire
swsusp e Suspend-to-Disk (non si è detto funzionare!), swsusp2 richiede
maggiori attenzioni. La prima cosa da fare è applicare la patch fornita da
<uri link="http://softwaresuspend.berlios.de/">http://softwaresuspend.berlios.de/</uri>
al kernel. In seguito sarà necessario installare l'<c>hibernate-script</c>.
Una volta installato, si passerà alla sua configurazione tramite il file
<path>/etc/hibernate/hibernate.conf</path> e a provare a vedere se funziona:
</p>

<pre>
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Ultima occasione per effettuare un backup dei propri dati)</comment>
<i># hibernate</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Problemi</title>
<section>
<title>Se qualcosa dovesse andare male...</title>
<body>

<p>
<e>D:</e> Sto cercando di cambiare la frequenza della CPU, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> non esiste.
</p>

<p>
<e>R:</e> Assicurati che il tuo processore supporti il frequency scaling e di 
aver scelto il driver giusto. Ecco una lista di processori supportati dal cpufreq
(kernel 2.6.7): ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII e Intel mobile PIII-M su alcuni chipset, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, alcuni
"PowerBook" e "iBook2" e vari processori su alcuni sistemi compatibili ACPI 2.0 (solo se
gli "ACPI Processor Performance States" sono disponibili attraverso l'interfaccia
ACPI/BIOS).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> è vuoto.
</p>

<p>
<e>R:</e> Cerca messaggi d'errore relativi all'ACPI con <c>dmesg | grep ACPI</c>.
Prova ad aggiornare il BIOS, specialmente se vedi errori riguardo il DSDT.
Puoi anche provare a corregge il problema manualmente (ma ciò è al di fuori degli 
scopi di questa guida).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma secondo /proc/cpuinfo
la velocità non cambia mai.
</p>

<p>
<e>R:</e> Probabilmente hai attivato il supporto al symmetric multiprocessing 
nel kernel (CONFIG_SMP). Disattivalo e dovrebbe funzionare. Alcune vecchie versioni
del kernel presentano un bug al riguardo. In questo caso, esegui <c>emerge x86info</c>,
aggiorna il tuo kernel come richiesto e controlla il valore della frequenza con
<c>x86info -mhz</c>.
</p>

<p>
<e>D:</e> Posso cambiare la frequenza della CPU, ma la scelta non è così ampia come
quella disponibile in un altro OS.
</p>

<p>
<e>R:</e> Puoi combinare il frequency scaling con l'ACPI throttoling per ottenere
frequenza minori. Ricorda comunque che il throttoling non risparmia molta energia
e viene usato solo per una gestione termica (mantiene il notebook freddo). Puoi
leggere lo stato attuale del throttoling con <c>cat
/proc/acpi/processor/CPU/throttling</c> a cambiarlo con <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, dove la x è una degli stati Tx elencati in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>


<p>
<e>D:</e> Nella configurazione del kernel powersave, performance e userspace
governors vengono mostrati, ma non vedo la voce ondemand. Dove la trovo?
</p>

<p>
<e>R:</e> Ondemand governor è incluso solamente nelle ultime versioni del kernel. Prova
ad aggiornarlo.
</p>

<p>
<e>D:</e> La durata della batteria sembra essere peggiorata rispetto a prima.
</p>

<p>
<e>R:</e> Controlla i settaggi del tuo BIOS. Potresti aver dimenticato di riattivare
alcuni settaggi.
</p>

<p>
<e>D:</e> La mia batteria è carica, ma per KDE è del tutto scarica (riporta 0%) e,
quindi, viene avviato la sequenza di shutdown.
</p>

<p>
<e>R:</e> Controlla che il supporto batteria sia attivato nel tuo kernel. Se lo hai compilato
come modulo, assicurati di averlo caricato correttamente.
</p>

<p>
<e>D:</e> Ho un Dell Inspiron 51XX e non riesco ad ottenere eventi ACPI.
</p>

<p>
<e>R:</e> Sembra essere un bug del kernel. Leggi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">qui</uri>.
</p>

<p>
<e>D:</e> Ho appena comprato una nuova batteria, ma dura solo per pochi minuti! Cosa faccio 
di sbagliato?
</p>

<p>
<e>R:</e> Prima di tutto segui le istruzioni del venditore su come caricare correttamente la batteria.
</p>

<p>
<e>D:</e> Niente, è inutile. Cosa faccio ora?
</p>

<p>
<e>R:</e> Alcune batterie vendute come "nuove" sono in realtà vecchie. Prova questo:
</p>

<pre caption="Stato della batteria">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Se il valore di "last full capacity" differisce di molto da quello di design capacity,
la tua batteria è probabilmente rotta. Usa la garanzia.
</p>

<p>
<e>D:</e> Non ho trovato una soluzione al mio problema. Cosa faccio?
</p>

<p>
<e>R:</e> Prova a contattarmi direttamente, <mail link="fragfred@gmx.de">Dennis
Nienhüser</mail>.
</p>


</body>
</section>
</chapter>
</guide>
