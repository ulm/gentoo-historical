<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/power-management-guide.xml,v 1.4 2005/04/03 20:00:30 so Exp $ -->
<guide link="power-management-guide.xml">
<title>Guida alla Gestione Energetica</title>

<author title="Autore">
  <mail link="fragfred@gmx.de">Dennis Nienhüser </mail>
</author>
<author title="Traduzione">
  <mail link="frgrieco@aliceposta.it">Francesco Grieco</mail>
</author>

<abstract>
La gestione energetica è l'unica soluzione per estendere la durata della batteria
sui sistemi mobile come i notebook. Questa guida ne illustra la sua configurazione.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.20</version>
<date>2005-03-19</date>

<chapter>
<title>Introduzione</title>

<section>
<title>A cosa serve la Gestione Energetica?</title>

<body>

<p>
Capacità e durata delle batterie dei notebook sono migliorate molto nel corso
degli ultimi anni. Tuttavia i moderni processori consumano molta più energia dei
vecchi e ad ogni nuova generazione di notebook si aggiungono nuove periferiche
"affamate" di energia. Ecco il perchè dell'importanza della gestione energetica.
Applicando buone politiche di risparmio energetico non sarà sempre necessario
acquistare un'altra batteria.
</p>

</body>
</section>

<section>
<title>Breve panoramica</title>
<body>

<p>
Questa guida tratta della gestione energetica per i <e>notebook</e>.
Alcune sezioni potrebbero essere valide anche per i <e>server</e>, altre
non lo sono sicuramente e potrebbero causare problemi. Si consiglia
fortemente di non applicare niente di quello contenuto in questa guida
a macchine server a meno che non si sappia veramente quello che si
sta facendo.
</p>

<p>
Poichè questa guida diventa sempre più lunga, segue una breve panoramica di 
ciò che sarà trattato.
</p>

<p>
La sezione <e>Prerequisiti</e> tratta di alcuni requisiti di base necessari
per tutte le sezioni a seguire della guida. Include settaggi del BIOS e 
particolari configurazioni nel kernel. I seguenti tre capitoli pongono 
l'attenzione sui componenti che tipicamente consumano maggiore energia - 
il processore, il display e l'hard disk. Ognuno di essi pùo essere configurato
separatamente. <e>Power Management della CPU</e> mostra come modificare la frequenza del
processore al fine di risparmiare energia senza un eccessivo calo delle performance.
Alcuni stratagemmi in <e>Power Management dell'Hard Disk</e> permettono di
allegerire il carico di lavoro del disco (avendo come effetto anche una 
riduzione del livello di rumore). Indicazioni anche per le card Wireless LAN e
per le periferiche USB in <e>Power Management delle altre periferiche</e> mentre
un altro intero capitolo è dedicato agli (ancora sperimentali) <e>Stati di Sleep</e>.
Infine un ultimo capitolo dedicato ai <e>Problemi</e> più comuni in cui 
è possibile incorrere.
</p>

</body>
</section>

<section>
<title>Bilancio energetico per ogni componente</title>
<body>

<figure link="/images/energy-budget.png" short="Quale componente consuma quanta 
energia?" caption="Peso energetico per ogni componente"/>

<p>
Quasi tutti i componenti possono funzionare in differenti stati - off, sleep, idle, active -
consumando a seconda dei casi diverse quantità di energia. La maggior parte dell'energia
viene consumata dal display LCD, dalla CPU e dagli hard disk. Spesso alcuni di essi
sono in grado di attivare politiche di gestione energetica attraverso il BIOS, ma
una configurazione intelligente del proprio sistema operativo adattabile
a diverse situazioni può ottenere molto di più.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prerequisiti</title>
<section>
<title>Prima di tutto</title>
<body>

<p>Prima di entrare nei dettagli della gestione energetica per le singole periferiche,
vi sono alcuni requisiti. Dopo aver controllato i settaggi del BIOS, è necessario 
attivare alcune opzioni del kernel - in breve ACPI, sleep states e CPU frequency scaling.
Poichè il risparmio energetico comporta una perdita delle prestazioni o un aumento
della latenza, deve essere attivato, naturalmente, solamente in assenza di una
connessione a rete elettrica. Da qui la necessità di un nuovo runlevel <e>battery</e>.
</p>

</body>
</section>
<section>
<title>Il BIOS</title>
<body>

<p>
Per prima cosa è necessario controllare i settaggi relativi al Power Management
nel BIOS. Di solito la soluzione migliore è combinare i settaggi del BIOS alle
politiche del sistema operativo, ma per il momento è meglio disabilitare le
funzioni del BIOS. In questo modo niente interferisce con le nuove politiche
imposte dal sistema operativo. Dopo aver configurato tutto per bene, sarà
necessario riabilitare tutte le funzioni del BIOS.
</p>

</body>
</section>
<section>
<title>Configurazione del Kernel</title>
<body>

<p>
Il supporto dell'ACPI (Advanced Configuration and Power Interface) nel kernel
è ancora in fase di sviluppo. Pertanto è consigliabile usare sempre il kernel
più recente.
</p>

<p>
Nella configurazione del kernel si devono attivare le seguenti opzioni:
</p>

<pre caption="Settaggi minimi del kernel per il Power Management (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    &lt;M&gt;   AC Adapter
    &lt;M&gt;   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>driver CPUFreq a seconda del processore</i>
</pre>

<p>
E' possibile anche attivare Software Suspend, Suspend-to-Disk e Sleep States.
I possessori di notebook ASUS, Medion o Toshiba devono anche attivare i relativi 
moduli specifici. Le ultime versioni del kernel (dalla 2.6.9 in avanti) includono una nuova sottovoce <e>'ondemand' governor</e> per il CPU Frequency Scaling. Anche questa opzione è da attivare.
</p>

<p>
Il kernel deve essere in grado di attivare il CPU frequency scaling (cambio di frequenza della CPU) sul processore. Poichè ogni CPU presenta una interfaccia differente dalle altre, è necessario scegliere il driver giusto per il proprio processore. Si presti attenzione - ad esempio attivando 
<e>Intel Pentium 4 clock modulation</e> su un Pentium M, si otterà molto probabilmente un sistema poco stabile. La documentazione del kernel può chiarire qualsiasi dubbio in proposito.
</p>

<p>
Dopo la compilazione del kernel bisogna assicurarsi del corretto caricamento dei moduli
all'avvio e riavviare il notebook con il nuovo kernel. Per installare il demone acpi,
da riga di comando <c>emerge sys-power/acpid</c>. Il suddetto demone gestisce
eventi quali il passaggio da corrente a batteria o la chiusura del lid. E' necessario
assicurarsi che il modulo <e>button</e> sia caricato se non compilato direttamente
all'interno del proprio kernel. Ora si avvii il demone acpid con <c>/etc/init.d/acpid
start</c> e si esegua <c>rc-update add acpid default</c> per caricarlo all'avvio. Il suo
utilizzo verrà spiegato in seguito.
</p>

<pre caption="Installazione di acpid">
# <i>emerge sys-power/acpid</i>
# <i>modprobe button</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Creazione del runlevel "battery"</title>
<body>

<p>
La configurazione di default attiverà il risparmio energetico solo quando
necessario - in pratica quando il notebook funziona con la propria
batteria. Per effettuare il passaggio fra stato di corrente e di batteria,
sarà necessario creare un runlevel <e>battery</e> in grado di gestire
l'avvio e il blocco degli script di risparmio energetico.
</p>

<note>
Se l'idea di avere un ulteriore runlevel non convince, è possibile saltare
questa sezione. Naturalmente ciò renderà tutto un pò più complicato. La
sezione seguente considera l'esistenza di un runlevel <e>battery</e>.
</note>

<pre caption="Creazione di un runlevel battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Finito. Il nuovo runlevel <e>battery</e> contiene tutto come <e>default</e>, ma 
non c'è ancora nessun cambio automatico tra i due livelli.
</p>

</body>
</section>
<section>
<title>Risposta agli eventi ACPI</title>
<body>

<p>
Di solito gli eventi ACPI sono la chiusura del lid, il cambio della sorgente
energetica e il bottone di sleep. Il cambio di sorgente energetica è un evento
importante e deve necessariamente generare un cambio di runlevel. La creazione dei file
seguenti permetterà un cambio fra i runlevel <e>default</e> e <e>battery</e>
a seconda del tipo di sorgente energetica utilizzata.
</p>

<pre caption="/etc/acpi/switch_runlevel.sh">
#!/bin/bash

RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"

function on_ac () {
    if which on_ac_power &amp;> /dev/null
    then
        on_ac_power
    else
        grep --quiet on-line /proc/acpi/ac_adapter/*/state
    fi
}

function SwitchRunlevel () {

    if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
    then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
    fi


    if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
    then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
    fi

    if on_ac
    then if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
    elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
  then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
  fi
}
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
event=ac_adapter.*
action=/etc/acpi/actions/pmg_ac_adapter.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
event=battery.*
action=/etc/acpi/actions/pmg_battery.sh %e
</pre>

<pre caption="/etc/acpi/actions/pmg_ac_adapter.sh">
#!/bin/bash

source /etc/acpi/switch_runlevel.sh
SwitchRunlevel
</pre>

<pre caption="/etc/acpi/actions/pmg_battery.sh">
#!/bin/bash

source /etc/acpi/switch_runlevel.sh
SwitchRunlevel
</pre>

<p>
Alcuni di questi file devono essere resi eseguibili. 
Inoltre, per rendere effettive le modifiche apportate, sarà necessario riavviare
il demone acpid.
</p>

<pre caption="File per il cambio dei runlevel con acpid">
<i># chmod +x /etc/acpi/switch_runlevel.sh</i>
<i># chmod +x /etc/acpi/actions/pmg_*</i>
<i># /etc/init.d/acpid restart</i>
</pre>


<p>
Provando ora ad attaccare e staccare l'alimentazione a corrente, nei log di
sistema dovrebbero apparire a seconda dei casi i messaggi "Switching to AC
mode" o "Switching to battery mode".
Se lo script non è in grado di rilevare correttamente la sorgente di energia
utilizzata, è possibile consultare la sezione Problemi.
</p>

<p>
A causa della natura del meccanismo degli eventi, il notebook, al boot,
passa al runlevel default che sia o meno collegato alla rete elettrica.
E' necessario aggiungere, per questo, una nuova entry al boot
loader con l'opzione <c>softlevel=battery</c>; soluzione scomoda. Una soluzione
migliore è quella di creare un evento ACPI finto alla fine del processo di boot
e lasciare che lo script <path>/etc/acpi/default.sh</path> decida quale
runlevel utilizzare. Si apra con il proprio editor il file <path>/etc/conf.d/local.start</path>
e si aggiungano le linee:
</p>

<pre caption="Cambio del runlevel al boot del notebook con la modifica di local.start">
<comment># Finto evento acpi per cambiare runlevel se scollegati da rete elettrica</comment>
/etc/acpi/actions/pmg_battery.sh "battery/battery"
</pre>

<p>
Conclusa questa parte preparativa, è ora possibile attivare le politiche di
gestione energetica per ogni singolo componente.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management della CPU</title>
<section>
<title>Terminologia tecnica</title>
<body>

<p>
Il CPU frequency scaling introduce alcuni termini tecnici che potrebbero
essere non conosciuti. Segue, per questo motivo, una breve introduzione.
</p>

<p>
Prima di tutto, il kernel deve essere in grado di cambiare la frequenza
di funzionamento della CPU. Il <e>CPUfreq processor driver</e> contiene
i comandi per effettuare questa operazione su ogni tipo di CPU. Per questo motivo è importante
indicare il driver giusto da utilizzare nel proprio kernel (operazione già
effettuata precedentemente). Inoltre, il kernel deve anche scegliere la
frequenza corretta di funzionamento da utilizzare nelle diverse situazioni. Questa viene
fissata in base ad una <e>policy</e> (politica di gestione) che consiste in
una <e>CPUfreq policy</e> e in un <e>governor</e> (regolatore).
Una CPUfreq policy non è altro che un insieme di due numeri che definiscono
un campo all'interno del quale la frequenza può oscillare - un valore minimo e
uno massimo. Il governor, invece, decide quale delle frequenze disponibili fra la
minima e la massima utilizzare. Ad esempio, il <e>powersave governor</e> utilizza
sempre la frequenza più bassa disponibile, il <e>performance governor</e>, invece,
la più alta. L'<e>userspace governor</e> non sceglie nessuna frequenza in particolare
ma utilizza quella indicata dall'utente (o da un programma in
userspace); il valore della frequenza viene letto da 
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Questo può non sembrare un cambiamento dinamico della frequenza e in effetti non lo
è. La dinamicità può essere realizzata con diversi approcci.
Ad esempio, <e>ondemand governor</e> prende le sue decisioni in
base al carico di lavoro della CPU. La stessa cosa viene fatta
da utility come <c>cpudyn</c>, <c>speedfreq</c>, <c>powernowd</c> e
molte altre. Gli eventi ACPI possono essere utilizzati per attivare o
disattivare i cambi dinamici della frequenza a seconda della sorgente energetica utilizzata.
</p>

</body>
</section>

<section>
<title>Settaggio manuale della frequenza</title>
<body>

<p>
Diminuendo la velocità e il voltaggio della CPU si hanno due vantaggi: viene
consumata meno energia e il notebook non si riscalda eccessivamente. Il grande
svantaggio, naturalmente, è una perdita di performance. La diminuzione della
velocità del processore resta in ogni caso un buon compromesso fra calo di
performance e risparmio energetico.
</p>

<note>
Non tutti i notebook supportano il frequency scaling. In caso di dubbi, una lista
dei processori supportati si trova nella sezione <e>Problemi</e>.
</note>

<p>
E' ora di provare il corretto funzionamento del cambio di frequenza della CPU.
Per impratichirsi con l'interfaccia del kernel, è possibile effettuare qualche
modifica manuale della velocità. Per settare un'altra velocità della CPU:
</p>

<pre caption="Modifiche manuali della velocità della CPU">
<comment>(Legge la frequenza attuale)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>

<comment>(Lista delle frequenza supportate. Potrebbe dare un errore)</comment>
# <i>cd /sys/devices/system/cpu/cpu0/cpufreq/</i>
# <i>cat scaling_available_frequencies</i>

<comment>(Cambia la frequenza ad 1 GHz (1000000 KHz)
Sostituire con una frequenza supportata dal notebook)</comment>
# <i>echo -n userspace > scaling_governor</i>
# <i>echo -n 1000000 > scaling_setspeed</i>

<comment>(Verifica che la frequenza sia stata cambiata)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
In caso di messaggi di errore, è possibile consultare la sezione <e>Problemi</e>
alla fine di questa guida.
</p>

<p>
E' possibile anche scrivere in <path>scaling_max_freq</path> e in
<path>scaling_min_freq</path> per fissare il massimo e il minimo di
un intervallo in cui far oscillare la frequenza.
</p>

<note>
Alcuni kernel sembrano avere un bug riguardo l'aggiornamento di <path>/proc/cpuinfo</path>.
Se non fosse presente il valore atteso, questo non nessariamente potrebbe indicare
che la frequenza della CPU non è stata cambiata. Se ciò dovessa avvenire, sarà
necessario eseguire un <c>emerge x86info</c>, aggiornare il proprio kernel come richiesto
e controllare l'esatta frequenza di funzionamento della CPU con <c>x86info -mhz</c>.
</note>

</body>
</section>
<section>
<title>Adattamento automatico della frequenza</title>
<body>

<p>
Tutto questo è molto semplice, ma scomodo da effettuare tutti i giorni. Meglio lasciare che sia
il proprio sistema a settare automaticamente la frequenza appropriata. 
La tabella seguente presenta una panoramica delle utility necessarie a questo compito. E' suddivisa
in tre categorie: <e>kernel</e> per soluzioni che hanno bisogno solo
del supporto del kernel, <e>demone</e> per programmi che lavorano in
background e <e>GUI</e> per programmi che forniscono una interfaccia
grafica per una configurazione più semplice.
</p>

<table>
<tr>
  <th>Nome</th>
  <th>Categoria</th>
  <th>Causa cambio</th>
  <th>Governor del kernel</th>
  <th>Governor supportati</th>
  <th>Note</th>
</tr>
<tr>
  <ti>'ondemand' governor</ti>
  <ti>Kernel</ti>
  <ti>Carico della CPU</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Configurazione attraverso i file presenti in
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>.
    Richiede ancora tool in userspace (programmi, script) in caso
    di utilizzo del cambio di governor.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Dynamic</ti>
  <ti>
    Supporta anche lo standby dei dischi - si noti, però, che il <e>laptop mode</e>
    in molti casi funziona decisamente meglio.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demone</ti>
  <ti>Stato della batteria, Carico della CPU, Programmi in esecuzione</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Configurazione sofisticata (ma anche complessa). Una configurazione ottimale
    richiede una conoscenza dettagliata del proprio sistema.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Passive, sine, aggressive</ti>
  <ti>
    Supporta SMP.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demone</ti>
  <ti>Carico della CPU</ti>
  <ti>Nessuno</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Piccola ma efficace con una utile interfaccia client/server. Richiede un 
    kernel della serie 2.6
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>GUI</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>Nessuno</ti>
  <ti>
    Applicazione per Gnome, utility grafica per configurare manualmente la
    frequenza della CPU. Non offre nessun tipo di automazione e viene elencata
    solamente per completezza.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>GUI</ti>
  <ti>Stato della batteria</ti>
  <ti>Tutti disponibili</ti>
  <ti>Nessuno</ti>
  <ti>
    Solamente per KDE, 'ondemand' governor necessario per il cambio dinamico della
    frequenza.
  </ti>
</tr>
</table>

<p>
L'adattamento della frequenza della CPU al carico di lavoro corrente del notebook
può sembrare semplice da attuare ad una prima occhiata, ma in realtà non lo è.
Un algoritmo errato può causare cambi continui fra due frequenze o
spreco di energia quando la frequenza viene portata inutilmente a valori troppo alti.
</p>

<p>
Quale scegliere? Iniziamo con <c>speedfreq</c>:
</p>

<pre caption="Installazione di speedfreq">
# <i>emerge speedfreq</i>
# <i>rc-update add speedfreq battery</i>
</pre>

<p>
<c>speedfreq</c> può essere configurato editando il file
<path>/etc/conf.d/speedfreq</path>. Ad esempio, modificando
<c>SPEEDFREQ_OPTS=""</c> in <c>SPEEDFREQ_OPTS="-u"</c>, gli utenti
saranno in grado di cambiare le politiche di gestione energetica. 
Completate le modifiche, si avvia il demone.
</p>

<pre caption="Avvio di speedfreq">
# <i>/etc/init.d/speedfreq start</i>
</pre>

<p>
Configurare cpufreqd è leggermente più complicato.
</p>

<warn>
Naturalmente bisogna evitare di eseguire più di uno dei suddetti programmi contemporaneamente.
Potrebbero, infatti, esserci problemi come un cambio continuo fra due frequenze. Se si è
installato speedfreq, si può saltare la sezione dedicata a cpufreqd.
</warn>

<pre caption="Installazione di cpufreqd">
# <i>emerge cpufreqd</i>
# <i>rc-update add cpufreqd battery</i>
</pre>

<p>
<c>cpufreqd</c> ha una configurazione di default in
<path>/etc/cpufreqd.conf</path>. Si può editare il file di configurazione a
seconda delle proprie necessità. Le modifiche seguenti porteranno un maggior
risparmio energetico rispetto alla configurazione di default - a costo, ovviamente,
di un maggior calo di performance.
</p>

<pre caption="Un esempio di file di configurazione di cpufreqd">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
<comment># Decomenttando questa linea si attiva l'ACPI workaround (leggere cpufreqd.conf(5))
# acpi_workaround=1</comment>
verbosity=4 <comment>#(per avere un minimo logging si porti questo valore a 5)</comment>

<comment># Massime performance</comment>
[Profile]
name=ac
minfreq=600000
maxfreq=1400000
policy=performance

<comment># Massimo risparmio energetico</comment>
[Profile]
name=battery
minfreq=600000
maxfreq=900000
policy=powersave

<comment># Frequenza costante</comment>
[Profile]
name=dvd
minfreq=900000
maxfreq=1100000
policy=powersave

<comment># Massime performance quando collegati a corrente</comment>
[Rule]
name=ac_on
ac=on
profile=ac

<comment># La compilazione dovrebbe essere più veloce se lo stato della batteria è ok</comment>
[Rule]
name=compiling
ac=off
battery_interval=30-100
programs=emerge,make,gcc,cpp
cpu_interval=0-100
profile=ac

<comment># Guardare film in DVD potrebbe non essere possibile con basse frequenze di CPU
# Può essere usato anche per i giochi</comment>
[Rule]
name=dvd_watching
ac=off
battery_interval=15-100
programs=xine,mplayer,avidemux,kaffeine,kmplayer
cpu_interval=0-100
profile=dvd

<comment># Se le scelte precedenti non sono applicabili, massimizza il risparmio energetico</comment>
[Rule]
name=battery_on
ac=off
battery_interval=0-100
cpu_interval=0-100
profile=battery
</pre>

<p>
<c>cpudyn</c> e <c>powernowd</c> possono essere installati allo stesso modo di
<c>speedfreq</c>.
</p>

</body>
</section>

<section>
<title>Verifica di funzionamento a seguito delle modifiche apportate</title>

<body>

<p>
L'ultima cosa da controllare è che le nuove politiche di risparmio energetico
facciano bene il loro lavoro. Un modo semplice per verificare ciò è il 
monitoraggio della velocità della CPU mentre è al lavoro sul notebook:
</p>

<pre caption="Monitoraggio della velocità della CPU">
# <i>watch -n 1 'grep "cpu MHz" /proc/cpuinfo'</i>
</pre>

<p>
Se <path>/proc/cpuinfo</path> non dovesse venire aggiornato, si provi a monitorare 
la frequenza della CPU con:
</p>

<pre caption="Monitoraggio alternativo della velocità della CPU">
# <i>watch -n 1 x86info -mhz</i>
</pre>

<p>
A seconda dei settaggi, la velocità della CPU dovrebbe aumentare in caso di richieste
d'uso, diminuire in mancanza di attività o, semplicemente, rimanere costante.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management del display LCD</title>
<section>
<title>Il maggior consumatore di energia</title>
<body>

<p>
Come si può vedere dalla <uri link="#doc_chap1_fig1">figura 1.1</uri>, il display
LCD consuma la maggior parte dell'energia (questo potrebbe non valere nel caso
di CPU non mobile). Per questo non solo è importante spegnere il display quando
non utilizzato, ma anche ridurre il backlight (retroilluminazione) se possibile.
Molti notebook offrono la possibilità di regolare il backlight.
</p>

<p>
La prima cosa da controllare sono i settaggi di standby/suspend/off del display.
Questi sono tutti valori che dipendono dal windowmanager. L'oscuramento del
terminale può essere effettuato con <c>setterm -blank &lt;numero-di-minutiM&gt;</c>,
<c>setterm -powersave on</c> e <c>setterm -powerdown &lt;numero-di-minutiM&gt;</c>.
Per Xorg, si può editare <path>/etc/X11/xorg.conf</path> come di seguito riportato:
</p>

<pre caption="Settaggi dell'LCD suspend in Xorg e in XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Oscura lo schermo dopo cinque minuti (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># Spegne lo schermo dopo 10 minuti (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Suspend dopo 20 minuti</comment>
  Option  "OffTime"  "30"  <comment># Spegne dopo mezz'ora</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Vale lo stesso per XFree86 e <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probabilmente la gestione del backlight (retroilluminazione) è il punto più importante.
Se si è in grado di accedere al controllo tramite un tool, bisogna scrivere un piccolo
script in grado di settare il backlight nella modalità batteria e inserirlo nel
runlevel <e>battery</e>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Power Management dell'Hard Disk</title>
<section>
<title>Sleep quando in idle</title>
<body>

<p>
L'obiettivo è portare l'hard disk nello stato di sleep il prima possibile
quando non viene utilizzato. Verranno analizzate due possibilità. La prima
è <c>cpudyn</c>. Bisogna decommentare le linee nella sezione "Disk Options" in
<path>/etc/conf.d/cpudyn</path>. Per portare l'hard disk in sleep dopo 60 secondi
di inattività si deve agire nel modo seguente:
</p>

<pre caption="Uso di cpudyn per lo standby dell'hard disk">
<comment>################################################
# DISK OPTIONS
# (opzioni disabilitate di default)
################################################

#
# Tempo dopo il quale porre il disco in modalità standby
# in mancanza di operazioni IO (in secondi)
#
</comment>
TIMEOUT=60
<comment>
#
# Dischi sui quali effettuare lo spindown (separati da virgole)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
La seconda possibilità è quella di usare un piccolo script e hdparm.
Si crei <path>/etc/init.d/pm.hda</path> come riportato di seguito:
</p>

<pre caption="Uso di hdparm per lo standby dell'hard disk">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Con <c>man hdparm</c> è possibile avere informazioni sulle varie opzioni.
Una volta pronto, è necessario aggiungere lo script al runlevel battery.
</p>

<pre caption="Configurazione per lo standby automatico del disco">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Si presti molta attenzione ai settaggi di sleep e di spin down del proprio hard disk.
Settaggi troppo spinti (valori molto piccoli) possono danneggiare l'hardware e invalidare
la garanzia.
</impo>

</body>
</section>
<section>
<title>Aumento del tempo di idle - laptop-mode</title>
<body>

<p>
Gli ultimi kernel (2.6.6 e maggiori, gli ultimi della serie 2.4 e altri con alcune patch)
includono il così detto <e>laptop-mode</e>. Quando attivato, le operazioni 
di scrittura avvengono ogni 10 minuti (invece di 30 secondi). Questo fà si che l'hard disk
non lavori in maniera continuativa.
</p>

<p>
<!-- TODO: bug #45593 -->
Oltre al supporto da parte del kernel, è necessario uno script in grado di
controllare l'avvio e il blocco del laptop-mode. La documentazione del kernel
in <path>/usr/src/linux/Documentation/laptop-mode.txt</path> ne contiene
uno così come i <c>laptop-mode-tools</c>. Tuttavia nessuno di essi è
semplice da installare.
</p>

<p>
Gli ebuild per i laptop-mode-tools non sono in Portage perchè gli sviluppatori
di Gentoo non li ritengono abbastanza maturi. Si consideri questo prima
di utilizzare gli ebuild presenti in <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=45593">Bugzilla</uri>. Il Manuale
Gentoo spiega come utilizzare ebuild esterni se non si è a conoscenza sul
dove installarli. Inseriti gli ebuild nel proprio PORTDIR_OVERLAY, è possibile
installare lo script con:
</p>

<warn>
Questo package non è considerato maturo e l'installazione di ebuild tratti da Bugzilla
non è raccomandata. Se non si dovesse essere sicuri, non si utilizzino i 
laptop-mode-tools.
</warn>

<pre caption="Avvio automatico del laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
I <c>laptop-mode-tools</c> hanno la propria configurazione in 
<path>/etc/laptop-mode/laptop-mode.conf</path>. E' possibile
adattarla alle proprie esigenze; la documentazione è presente nel file di configurazione stesso.
Se nelle proprie USE flag si ha <e>apm</e> oppure <e>acpi</e>, il laptop-mode
si avvierà automaticamente nella modalità batteria. In caso contrario
è possibile automatizzare questo processo eseguendo <c>rc-update add laptop-mode battery</c>.
</p>

</body>
</section>
<section>
<title>Altri consigli</title>
<body>

<p>
Oltre a portare il proprio hard disk nello stato di sleep il prima possibile,
una buona idea è minimizzare gli accessi al disco. Si osservino i processi che
scrivono sul disco frequentemente - syslogd è un buon candidato. Non sarà necessario
fermarlo completamente, ma è possibile modificare il suo file di configurazione in
modo tale che non tutto venga loggato, riducendo in questo modo gli accessi al disco.
Cups scrive sul disco periodicamente, quindi fermarlo e attivarlo manualmente
solo quando necessario è una buona idea.
</p>

<pre caption="Disattivare cups nella modalità batteria">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Un'altra possibilità è la disattivazione dello swap nella modalità batteria.
Prima di scrivere qualcosa che attivi e disattivi lo swap, bisogna assicurarsi
che ci sia abbastanza RAM e che lo swap non sia usato pesantemente, altrimenti
si potrebbero avere problemi.
</p>

<p>
Se non si vuole utilizzare il laptop-mode, è sempre possibile minimizzare gli
accessi al disco montando alcune directory come <e>tmpfs</e> - gli accessi in
scrittura non avvengono sul disco, ma nella memoria principale e vengono
persi con l'operazione di unmount. Spesso è utile montare <path>/tmp</path>
allo stesso modo - il suo contenuto viene in ogni caso perso ad ogni reboot
che sia montato o meno sul disco o in RAM. Bisogna solo essere certi
di avere RAM a sufficienza e nessun programma (come un client per i download o
un programma di compressione) che abbia bisogno di molto spazio in <path>/tmp</path>.
Per usare questa soluzione è necessario avere il supporto tmpfs abilitato
nel kernel e  aggiungere una linea come la seguente in <path>/etc/fstab</path>:
</p>

<pre caption="Modifica di /etc/fstab per rendere /tmp volatile">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Si presti attenzione al parametro size e lo si modifichi per il proprio sistema.
Se non si è sicuri, non lo si modifichi, in quanto si creerebbero facilmente
grossi cali di performance (effetto collo di bottiglia). Se si volesse montare
<path>/var/log</path> nello stesso modo, non bisogna dimenticare di unire i file
di log al disco prima di effettuare l'unmounting. Sono essenziali. Montare anche
/var/tmp allo stesso modo è inutile. Portage usa questa directory per la compilazione...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Power Management delle altre periferiche</title>
<section>
<title>Power Management del Wireless</title>
<body>

<p>
Le card Wireless LAN consumano poca energia. E' possibile inserirle nella modalità
risparmio energetico in analogia allo script pm.hda.
</p>

<pre caption="Power Management automatico per le WLAN">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
L'esecuzione di questo script porta la wlan0 in modalità risparmio energetico
ponendola in stato di sleep dopo tre secondi di assenza di traffico.
Lo si salvi come <path>/etc/init.d/pm.wlan0</path> e lo si aggiunga al runlevel
battery come gli altri. Per dettagli e maggiori opzioni <c>man iwconfig</c>.

Se i propri driver oppure l'access point supportano il cambio del beacon time,
questo può essere un altro modo per risparmiare ancora più energia.
</p>


<pre caption="Power Management for WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>USB Power Management</title>
<body>

<p>
Ci sono due problemi riguardo il consumo di energia delle periferiche USB: 
primo, periferiche come i mouse USB, le fotocamere digitali o le USB stick consumano
energia appena inserite. Non si può ovviare in nessun modo a questo problema 
(a meno che non vengano rimosse se non necessarie). Secondo, quando ci sono
periferiche USB collegate, l'USB host controller accede periodicamente al bus
non permettendo alla CPU di passare nelle modalità sleep C3/4. Il Sistema 
Operativo risolve questo problema attraverso l' "USB selective
suspend", non ancora implementato nel kernel. L'USB selective suspend permette
l'accesso al bus solo quando la periferica è in uso. L'unico modo, al momento,
per aggirare questo problema (fino alla sua implementazione nel kernel) è
compilare il supporto USB e le sue periferiche come moduli e rimuoverli attraverso
uno script quando non utilizzati (ad esempio alla chiusura del lid).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Stati di Sleep: sleep, standby, suspend to disk</title>
<section>
<title>Cosa sono</title>
<body>

<p>
L'ACPI definisce differenti stati di sleep. I più importanti sono
</p>

<ul> 
  <li>S1 ossia Standby</li>
  <li>S3 ossia Suspend to RAM ossia Sleep</li>
  <li>S4 ossia Suspend to Disk ossia Hibernate</li>
</ul>

<p>
Possono essere chiamati quando il sistema non è in uso, ma non si vuole
effettuare lo shutdown a causa del lungo tempo di boot.
</p>

</body>
</section>
<section>
<title>Sleep, Standby &amp; Hibernate</title>
<body>

<p>
Il supporto ACPI per questi stati di sleep è instabile per alcune buone ragioni. 
Gli stati di sleep APM sembrano più stabili, ma non è possibile utilizzare 
contemporaneamente l'APM e l'ACPI.
</p>

<warn>
Nonostante il supporto agli stati di sleep vada continuamente migliorando, resta
tuttora in una fase sperimentale. Swsusp2 e Suspend to Ram sembrano funzionare bene ma
è necessario prestare attenzione: si potrebbe facilmente andare incontro a perdita dati.
</warn>

<p>
Attualmente ci sono tre implementazioni per S4. Quella originale è swsusp,
a seguire swsusp2 che ha l'interfaccia più carina (include il supporto del
bootsplash), ma richiede l'applicazione manuale di una patch al kernel. Ed
infine Suspend-to-Disk, un fork di swsusp.
</p>

<p>
Per un'analisi comparativa delle caratteristiche si veda <uri
link="http://softwaresuspend.berlios.de/features.html#compare"> qui</uri>.
Se non si dovesse ancora sapere quale scegliere, swsusp2
sembra al momento la soluzione più promettente.
</p>

<p>
La sezione del kernel a riguardo è la seguente:
</p>

<pre caption="Configurazione del kernel per i vari stati di sospensione">
Power Management Options ---&gt;

  <comment>(sleep e standby)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernate con swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)
  
  <comment>(hibernate con swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"your-swap-here")    Default resume device name

  <comment>(hibernate con Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"your-swap-here") Default resume partition
</pre>

<p>
Si compili il kernel con le appropriate opzioni abilitate e si controlli, tramite 
<c>cat /proc/acpi/sleep</c> per il 2.4 e <c>cat /sys/power/state</c> per il 2.6,
ciò che si ha di supportato. Per swsusp è necessario passare al kernel il parametro
<c>resume=/dev/"propria-partizione-di-swap"</c>. Se questo non fosse possibile,
si usi <c>noresume</c> per swsusp, <c>pmdisk=off</c> per Suspend-to-Disk e
<c>noresume2</c> per swsusp2.
</p>

<p>
Per portare il proprio sistema in uno degli stati di sleep:
</p>

<pre caption="Attivazione degli stati di sleep">
<comment>(per i kernel 2.4)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>(standby)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(sleep)</comment>

<comment>(per i kernel 2.6)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>(standby)</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(sleep)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(hibernate)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(hibernate)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                   <comment>(hibernate, si legga di seguito)</comment>
</pre>

<warn>
E' consigliabile effettuare un backup dei propri dati. Eseguendo <c>sync</c> prima
dell'esecuzione di uno dei comandi, i dati di cache verranno scritti sul disco.
Provare il tutto al di fuori dell'ambiente grafico X e, in seguito, con X in 
esecuzione senza essere loggati al suo interno.
</warn>
 
<p>
Se dovesse capitare un kernel panic a causa di uhci o simili, è utile provare
a compilare il supporto USB come modulo per poterlo eventualmente "scaricare" 
prima che il laptop vada nello stato di sleep.
</p>

<p>
Mentre tutto ciò che si è visto fino ad ora è sufficiente per eseguire
swsusp e Suspend-to-Disk (non si è detto funzionare!), swsusp2 richiede
maggiori attenzioni. La prima cosa da fare è applicare la patch fornita da
<uri link="http://softwaresuspend.berlios.de/">http://softwaresuspend.berlios.de/</uri>
al kernel. In seguito sarà necessario installare l'<c>hibernate-script</c>.
Una volta installato, si passerà alla sua configurazione tramite il file
<path>/etc/hibernate/hibernate.conf</path> e a provare a vedere se funziona:
</p>

<pre>
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Ultima occasione per effettuare un backup dei propri dati)</comment>
<i># hibernate</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Problemi</title>
<section>
<title>Se qualcosa dovesse andare male...</title>
<body>

<p>
<e>D:</e> Sto cercando di cambiare la frequenza della CPU, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> non esiste.
</p>

<p>
<e>R:</e> Assicurati che il tuo processore supporti il frequency scaling e di 
aver scelto il driver giusto. Ecco una lista di processori supportati dal cpufreq
(kernel 2.6.7): ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII e Intel mobile PIII-M su alcuni chipset, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, alcuni
"PowerBook" e "iBook2" e vari processori su alcuni sistemi compatibili ACPI 2.0 (solo se
gli "ACPI Processor Performance States" sono disponibili attraverso l'interfaccia
ACPI/BIOS).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> è vuoto.
</p>

<p>
<e>R:</e> Cerca messaggi d'errore relativi all'ACPI con <c>dmesg | grep ACPI</c>.
Prova ad aggiornare il BIOS, specialmente se vedi errori riguardo il DSDT.
Puoi anche provare a corregge il problema manualmente (ma ciò è al di fuori degli 
scopi di questa guida).
</p>

<p>
<e>D:</e> Il mio notebook supporta il frequency scaling, ma secondo /proc/cpuinfo
la velocità non cambia mai.
</p>

<p>
<e>R:</e> Probabilmente hai attivato il supporto al symmetric multiprocessing 
nel kernel (CONFIG_SMP). Disattivalo e dovrebbe funzionare. Alcune vecchie versioni
del kernel presentano un bug al riguardo. In questo caso, esegui <c>emerge x86info</c>,
aggiorna il tuo kernel come richiesto e controlla il valore della frequenza con
<c>x86info -mhz</c>.
</p>

<p>
<e>D:</e> Posso cambiare la frequenza della CPU, ma la scelta non è così ampia come
quella disponibile in un altro OS.
</p>

<p>
<e>R:</e> Puoi combinare il frequency scaling con l'ACPI throttoling per ottenere
frequenza minori. Ricorda comunque che il throttoling non risparmia molta energia
e viene usato solo per una gestione termica (mantiene il notebook freddo). Puoi
leggere lo stato attuale del throttoling con <c>cat
/proc/acpi/processor/CPU/throttling</c> a cambiarlo con <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, dove la x è una degli stati Tx elencati in
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>


<p>
<e>D:</e> Nella configurazione del kernel powersave, performance e userspace
governors vengono mostrati, ma non vedo la voce ondemand. Dove la trovo?
</p>

<p>
<e>R:</e> Ondemand governor è incluso solamente nelle ultime versioni del kernel. Prova
ad aggiornarlo.
</p>

<p>
<e>D:</e> Il cambio di runlevel non funziona - lo script non è in grado di determinare correttamente
la sorgente elettrica utilizzata.
</p>

<p>
<e>R:</e> Su alcuni sistemi, la sorgente elettrica non può essere determinata dalla
lettura del file <path>/proc/acpi/ac_adapter/*/state</path>. Se dovesse essere
questo il tuo caso, crea uno script <c>on_ac_power</c> oppure utilizza quello
incluso in <c>powermgmt-base</c>. Un ebuild può essere trovato su <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=76516">Bug #76516</uri>. Basta
solamente effettuare l'emerge. Funziona in maniera trasparente con lo script
mostrato sopra.
</p>


<p>
<e>D:</e> La durata della batteria sembra essere peggiorata rispetto a prima.
</p>

<p>
<e>R:</e> Controlla i settaggi del tuo BIOS. Potresti aver dimenticato di riattivare
alcuni settaggi.
</p>

<p>
<e>D:</e> La mia batteria è carica, ma per KDE è del tutto scarica (riporta 0%) e,
quindi, viene avviato la sequenza di shutdown.
</p>

<p>
<e>R:</e> Controlla che il supporto batteria sia attivato nel tuo kernel. Se lo hai compilato
come modulo, assicurati di averlo caricato correttamente.
</p>

<p>
<e>D:</e> Ho un Dell Inspiron 51XX e non riesco ad ottenere eventi ACPI.
</p>

<p>
<e>R:</e> Sembra essere un bug del kernel. Leggi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">qui</uri>.
</p>

<p>
<e>D:</e> Ho appena comprato una nuova batteria, ma dura solo per pochi minuti! Cosa faccio 
di sbagliato?
</p>

<p>
<e>R:</e> Prima di tutto segui le istruzioni del venditore su come caricare correttamente la batteria.
</p>

<p>
<e>D:</e> Niente, è inutile. Cosa faccio ora?
</p>

<p>
<e>R:</e> Alcune batterie vendute come "nuove" sono in realtà vecchie. Prova questo:
</p>

<pre caption="Stato della batteria">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Se il valore di "last full capacity" differisce di molto da quello di design capacity,
la tua batteria è probabilmente rotta. Usa la garanzia.
</p>

<p>
<e>D:</e> Non ho trovato una soluzione al mio problema. Cosa faccio?
</p>

<p>
<e>R:</e> Prova a contattarmi direttamente, <mail link="fragfred@gmx.de">Dennis
Nienhüser</mail>.
</p>


</body>
</section>
</chapter>
</guide>
