<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/udev-guide.xml,v 1.15 2005/10/11 20:39:07 so Exp $ -->

<guide link="/doc/it/udev-guide.xml" lang="it">
<title>Guida a udev su Gentoo</title>

<author title="Autore">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributi">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Traduzione">
  <mail link="grandezot@cheapnet.it">Raffaele Camarda</mail>
</author>
<author title="Revisione">
    <mail link="posta@massimo.it">Massimo Canali</mail>
</author>

<abstract>
Questo documento spiega cos'è e come si può usare udev su Gentoo.
</abstract>

<license/>

<version>0.21</version>
<date>2005-08-12</date>

<chapter>
<title>Cos'è udev?</title>
<section>
<title>La directory /dev</title>
<body>

<p>
Quando gli utenti linux parlano del proprio hardware in presenza di persone che
pensano linux sia una sorta di strano virus od una nuova marca di caffé,
l'utilizzo di termini come "slash dev slash foo" vengono accolti con strani
sguardi. Ma alcuni fortunati utenti (che probabilmente includono anche voi)
utilizzano <path>/dev/hda1</path> per indicare velocemente il proprio HD
master sul primo controler IDE...giusto?
</p>

<p>
Noi tutti sappiamo cosa sia un file di dispositivo. Qualcuno sa anche perchè
questi file hanno diversi numeri quando quando si da  un'occhiata più
approfondita in <path>/dev</path> con un <c>ls -l</c>. Ma quello che noi tutti
diamo per scontato è che quando ci riferiamo al primo HD sul primo controler
IDE stiamo parlarlando di <path>/dev/hda</path>.
</p>

<p>
Pensate alle periferiche PlugNPlay come le penne USB, IEEE1394, periferiche
PCI hot-swappable...qual è la prima periferica? E per quanto tempo? Come si
chiameranno le altre periferiche quando la prima verrà sconnessa? Questo come
influenzerà i flussi di dati in corso? Non sarebbe divertente che il vostro
lavoro fosse stampato invece che sulla vostra nuova stampante laser sulla
vostra sgangherata stampate ad aghi, solamente perchè qualcuno ha deciso di
staccare la spina alla stampante laser che era vista dal sistema come
primaria?
</p>

<p>
Le finalità del progetto udev sono sia interessanti che necessarie:
</p>

<ul>
  <li>Gira in spazio utente</li>
  <li>Crea e rimuove dinamicamente i file di dispositivo</li>
  <li>Assegna i nomi alle periferiche</li>
  <li>Mette a disposizione un API utilizzabile nello spazio utente</li>
</ul>

<p>
Per fornire queste caratteristiche, udev è sviluppato in tre diversi progetti:
<e>namedev</e>, <e>libsysfs</e> e, ovviamente, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
namedev consente di definire i nomi delle periferiche indipendentemente dal
programma udev. Questo permette di avere uno modello di assegnamento dei nomi
molto flessibile ed uno schema dei nomi sviluppato da diverse entità. Questo
sistema per assegnare i nomi ai dispositivi offre un'interfaccia standard con
cui udev può interfacciarsi
</p>

<p>
Attualmente namedev fornisce un solo modello per l'assegnamento dei nomi ai
dispositivi, fornito da LANANA, che è quello che viene attualmente usato
dalla maggior parte dei sistemi linux e quindi piuttosto indicato per la
maggior parte degli utenti linux
</p>

<p>
namedev usa un procedimento suddiviso in cinque passi per assegnare un nome a
una data periferica. Se si trova un nome per la periferica durante uno di
questi passi, viene usato questo nome e la procedura si interrompe. I cinque
passi, nell'ordine, sono:
</p>

<ul>
  <li>etichetta o numero seriale</li>
  <li>numero della periferica sul bus</li>
  <li>topologia del bus</li>
  <li>nome assegnato staticamente</li>
  <li>nome fornito dal kernel</li>
</ul>

<p>
Il primo passaggio (<e>etichetta o numero seriale</e>) controlla se la
periferica ha un identificatore univoco.  Per esempio i dispositivi USB hanno
un numero seriale unico; le periferiche SCSI hanno un UUID unico. Se nel file
di configurazione in uso esiste una regola che assegna il nome al dispositivo
in base a questo identificatore, namedev applica la regola e assegna il nome
alla periferica.
</p>

<p>
Successivamnte (<e>numero della periferica sul bus</e>) viene controllato il
numero con cui il dispositivo viene identificato sul bus .
Per esempio i numeri assegnati ai dispositivi sul bus PCI cambiano di rado
durante il ciclo di vita di un sistema, per cui si possono considerare un buon
metodo per assegnare un nome a una periferica PCI (non-hot-swappable).
</p>

<p>
Si può assegnare un nome a un dispositivo anche sulla base di come questo è
fisicamente collegato al bus (<e>topologia del bus</e>), anche questo è un
metodo abbastanza valido per identificare univocamente una periferica, almeno
fino a quando non viene variata la disposizione fisica dei dispositivi
all'interno del sistema.
</p>

<p>
È possibile definire una regola che sostituisca staticamente (<e>nome
assegnato staticamente</e>), al nome fornito dal kernel, una stringa
arbitraria.
</p>

<p>
Se non esistono regole per assegnare un nome a un dispositivo, il comportamento
predefinito di udev è di assegnare alla periferica il nome fornito dal kernel
(<e>nome fornito dal kernel</e>). Nella maggior parte dei casi questo è
sufficiente visto che il nome corrisponde a quello assegnato.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev interagisce con il kernel tramite il filesystem sysfs. Il progetto
libsysfs mette a disposizione un API per accedere alle informazione fornite
dal filesystem sysfs. Questo consente di poter interrogare qualunque tipo di
dispositivo hardware senza doversi preoccupare di che tipo di hardware si
tratti.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Ogni volta che il kernel percepisce che sono stati collegati o rimossi dei
dispositivi, lancia il programma <path>/sbin/hotplug</path>. Hotplug a sua
volta lancia i programmi che sono stati linkati nella directory
<path>/etc/hotplug.d/default</path>, nella quale si trova anche un link
simbolico all'eseguibile udev. Hotplug invia le informazioni fornite dal
kernel al sistema udev che provvedere a aggiungere o rimuovere gli oppurtuni
file di periferica dalla directory <path>/dev</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Usare udev su Gentoo</title>
<section>
<title>Requisiti</title>
<body>

<p>
udev è stato pensato per funzionare in combinazione con i kernel 2.6 (come per
esempio <c>vanilla-sources</c> o <c>gentoo-sources</c> con il profilo di
default 2005.0). Oltre a avere installato un kernel 2.6 è necessario avere
installato sul proprio sistema anche la versione piu' recente di
<c>sys-apps/baselayout</c>.
</p>

<pre caption="Installare udev">
# <i>emerge udev</i>
</pre>

<p>
udev installa come dipendenza anche il paccheto <c>sys-apps/hotplug-base</c>.
Non é necessario installare <c>hotplug</c> a meno che non si voglia che i
moduli del kernel vengano caricati quando si collega uan periferica ala
sistema.  <c>hotplug</c> si occupa anche di attivare le interfacce di rete.
</p>

<pre caption="Installare gli script opzionali di hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Se si vuole che vengano caricati i moduli per le periferiche che sono state
collegate al sistema prima del boot é necessario installare il pacchetto
<c>sys-apps/coldplug</c>.
</p>

<pre caption="Installare il pacchetto coldplug">
# <i>emerge coldplug</i>
</pre>


<p>
Assicuratevi di aver aggiunto <c>coldplug</c> al runlevel utilizzato:
</p>

<pre caption="Aggiungere coldplug al runlevel boot">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
e ricordatevi di attivare le segueti opzioni nel kernel:
</p>

<pre caption="Required kernel options">
General setup ---&gt;
  [*] Support for hot-pluggable devices


File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Se si desidera si puo' mantenere attiva anche l'opzione <c>/dev file system
support (OBSOLETE)</c>, ma bisogna assicurarsi che l'opzione "Automatically
mount at boot" sia disattivata.
</p>

<pre caption="Disattivare l'opzione montare devfs al boot">
     File systems ---&gt;
       Pseudo Filesystems ---&gt;
         [*] /dev file system support (OBSOLETE)
           [ ]   Automatically mount at boot
</pre>

<p>
Se si utilizza <c>genkernel</c> bisogna lanciarlo con l'opzione <c>--udev</c>
per attivare tutte le opzioni del kernel necessarie al funzionamento di udev.
</p>

</body>
</section>

<section>
<title>Configurazione</title>
<body>

<p>
Se volete utilizzare la versione gentoo di udev creata per semplificarvi la
vita allora avete finito. Gentoo utilizzerà udev ma continuerà a mantenere un
link statico in <path>/dev</path> in modo che non vi macherà mai il nodo ad
un particolare dispositivo. Gli script init di Gentoo non avvieranno più il
servizio devfsd e disattiveranno devfs al boot.
</p>

<p>
Ma se siete duri a morire e volete un sistema udev puro, senza il trucchetto
precedente, cosa che peraltro è contemplata dai suoi sviluppatori (incluso il
problema dei dispositivi mancanti visto che ancora udev non li supporta),
continuate a leggere.
</p>

<p>
La prima cosa da fare è quella di distattivare la regola che salva la
struttura dei device in un tarball allo spegnimento del PC: editate la
variabile <c>RC_DEVICE_TARBALL</c> in <path>/etc/conf.d/rc</path> e
impostatela su <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Se si è lasciato attivo il supporto a devfs nel kernel lo si può disattivare
nel file di configurazione del bootloader aggiungendo il parametro del kernel
<c>gentoo=nodevfs</c>. Se invece si volesse riattivare il supporto a devfs
disabilitando udev, si dovrà passare al kernel il parametro
<c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemi Noti</title>
<section>
<title>File di dispositivo mancanti all'avvio</title>
<body>

<p>
Se non si riesce a avviare il sistema con successo perché si ottiene un errore
che dice che il file <path>/dev/null</path> non è stato trovato, o perché la
console iniziale non esiste, il problema è dovuto alla mancanza di alcuni file
che devono essere presenti nel sistema <e>prima</e> che
<path>/dev</path> venga montato e udev inizi gestirlo. Questo è un errore
piuttosto comune sui sistemi Gentoo installati usando supporti vecchi.
</p>

<p>
Avendo installato <c>sys-apps/baselayout-1.8.12</c>, o più recente, questo
incoveniente dovrebbe essere alleviato dal fatto che il sistema dovrebbe essere
comunque in grado di avviarsi. Comunque, per evitare noiosi avvisi, è
sufficiente creare i file di dispositivo mancanti, come descritto in seguito.
</p>

<p>
Per visualizzare i dispositivi che sono disponibili prima che il filesystem
<path>/dev</path> venga montato bisogna eseguire i seguenti comandi:
</p>

<pre caption="Elenco dei dispositivi disponibili all'avvio">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
I dispositivi necessari per avviare correttamente il sistema sono
<path>/dev/null</path> e <path>/dev/console</path>. Se non vengono
viasualizzati durante il test precendente vanno creati manualmente. I comandi
seguenti vanno eseguiti nella directory <path>test/dev/</path> creata
precentemente:
</p>

<pre caption="Creare i file di dispositivo mancanti">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Quando si sono impartiti questi comandi è necessario ricordarsi di smontare la
directory <path>test/</path>:
</p>

<pre caption="Smontare la directory test/">
# <i>cd ../../</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev e nvidia</title>
<body>

<p>
Nel caso si usassero i driver proprietari di nVidia e il server grafico X non
partisse, in un sistema configurato per utilizzare solo udev, bisogna
assicurarsi che:
</p>

<ul>
  <li>
    il modulo <c>nvidia</c> sia elencato nel file
<path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    sia installata una versione di <c>nvidia-kernel</c> uguale o maggiore di
<c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    sia installata una versione di <c>sys-apps/baselayout</c> uguale o maggiore
di <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

</body>
</section>

<section>
<title>I volumi LVM2 scompaiono</title>
<body>

<p>
Usando <c>udev</c> e LVM2 insieme, è possibile che che i volumi logici creati
non appaiano nella directory <path>/dev</path>. In realta' questi device si
chiamano <path>/dev/dm-#</path> dove # sta per un numero intero.
</p>

<p>
Per coreggere questo errore bisogna modificare il file
<path>/etc/udev/rules.d/50-udev.rules</path> decommentando la seguente linea:
</p>

<pre caption="Deconmmentare questa linea nel file /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k",
SYMLINK="%c"
</pre>

<p>
Dopo, installate <c>sys-fs/multipath-tools</c> che contiene le applicazioni
<c>devmap_name</c>.
</p>

<pre caption="Installazione di  multipath-tools">
<comment>(Al momento in cui scrivo multipath-tools e' disponibile solo in
testing:)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>

<section>
<title>Assegnamento dei nomi differente tra DevFS e udev</title>
<body>

<p>
Nonostante l'intento di mantere inalterati i nomi assegnati ai dispositivi da
entrambi i sistemi di gestione, in qualche caso può capitare che ci siano
delle differenze tra il nome assegnato da DevFS e quello assegnato da udev.
</p>

<p>
Un caso conosciuto riguarda il controller RAID HP Smart Array 5i (più
precisamente il modulo del kernel <c>cciss</c>). Con udev, il dispositivo viene
chiamato
<path>/dev/cciss/cXdYpZ</path> dove X, Y e Z sono numeri. Con devfs, il
dispositivo
si chiama <path>/dev/hostX/targetY/partZ</path> o é un link simbolico a
<path>/dev/cciss/cXdY</path>.
</p>

<p>
In questo caso é necessario ricordarsi di modificare il file
<path>/etc/fstab</path> e i file di
configurazione del bootloader.
</p>

<p>
La stessa cosa succede con molti dei link simbolici che venivano creati in
<path>/dev</path>, come per esempio <path>/dev/mouse</path>, che ora
<c>udev</c> non crea piu'. Assicurarsi che nel proprio file di configurazione
di X il percorso del dispositivo del mouse punti a un file esistente.
</p>

</body>
</section>

<section>
<title>Altri problemi</title>
<body>

<p>
Se il file corrispondente a un dispositivo non viene creato quando si carica
il modulo relativo tramite il file
<path>/etc/modules.autoload.d/kernel-2.6</path>, ma compare caricando
manualmente il modulo tramite modprobe si provi a installare
<c>sys-apps/baselayout-1.8.12</c>, o più recente.
</p>

<p>
Il supporto per i dispositivi framebuffer (<path>/dev/fb/*</path>) è stato
introdotto a partire dalla versione 2.6.6-rc2 del kernel.
</p>

<p>
Nel caso si usasse un kernel precendente alla versione 2.6.4 è necessario
includere esplicitamente il supporto per il filesystem <path>/dev/pts</path>.
</p>

<pre caption="Abilitare il filesystem /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Risorse &amp; Riconoscimenti</title>
<section>
<body>

<p>
La conferenza sul sistema udev tenuta da Greg Kroah-Hartman (IBM Corporation)
al Linux Symposium (Ottawa, Canada - 2003) è un ottimo punto di partenza per
una buona comprensione di udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">
Decibel's
UDEV Primer</uri> è un documento molto approfondito riguardo all'uso di udev
su Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev
rules</uri>, scritto dallo sviluppatore di Gentoo Daniel Drake, è un
documento eccellente per imparare come personalizzare la proprio
installazione di udev.
</p>

</body>
</section>
</chapter>

</guide>
