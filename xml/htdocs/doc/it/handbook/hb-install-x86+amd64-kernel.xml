<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
 
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-x86+amd64-kernel.xml,v 1.2 2006/10/29 22:21:42 so Exp $ -->

<sections>

<abstract>
Il kernel di Linux è il cuore di ogni distribuzione. Il capitolo tratta della
configurazione del Kernel.
</abstract>

<version>4.0</version>
<date>2006-08-30</date>

<section>
<title>Timezone</title>
<body>

<p>
Innanzitutto è necessario selezionare la propria timezone, in modo che il
sistema riconosca in che parte del globo è collocato. Per la propria timezone,
consultare <path>/usr/share/zoneinfo</path> e copiarla poi nel
file <path>/etc/localtime</path>. Si sconsiglia di utilizzare le
timezone<path>/usr/share/zoneinfo/Etc/GMT*</path> perchè i nomi non indicano
quello che ci si attende. Ad esempio <path>GMT-8</path> indica GMT+8:
</p>

<pre caption="Abilitare le informazioni sulla timezone">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Per esempio GMT:)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Installare i sorgenti</title>
<subsection>
<title>Scegliere un Kernel</title>
<body>

<p>
Il cuore, intorno al quale sono sviluppate tutte le distribuzioni, è il Kernel
di Linux. E' la parte di software compresa tra i programmi e l'hardware. Gentoo
dà la possibilità ai suoi utenti di scegliere tra diversi sorgenti del kernel.
Una lista completa delle descrizioni dei kernel disponibili, è consultabile
nella <uri link="/doc/it/gentoo-kernel.xml">Guida ai Kernel Gentoo</uri>.
</p>

<p test="func:keyval('arch')='x86'">
Per i sistemi basati sull'architettura x86 son disponibili, tra gli altri, i
seguenti kernel: <c>vanilla-sources</c> (il sorgente del kernel di default, così
come viene rilasciato dagli sviluppatori del kernel di linux),
<c>gentoo-sources</c> (il sorgente del kernel contenente patch per aumentarne le
performance) e altri.
</p>

<p test="func:keyval('arch')='AMD64'">
Per i sistemi AMD64 sono disponibili i <c>gentoo-sources</c> (sorgenti del
kernel v2.6 modificati con patch dedicate a amd64 con miglioramenti in sta
bilità, performance e supporto hardware).
</p>

<p>
Ora è possibile dunque scegliere ed installare i sorgenti del kernel tramite
<c>emerge</c>. L'utilizzo di <c>USE="-doc"</c> è necessario per evitare che a 
questo punto venga installato xorg-x11 o altre dipendenze. <c>USE="symlink"</c>
non è necessario per una installazione nuova ma assicura la creazione del link
simbolico <path>/usr/src/linux</path>.
</p>

<pre caption="Installare un sorgente del kernel">
# <i>USE="-doc symlink" emerge gentoo-sources</i>
</pre>

<p>
Se si dà un'occhiata a <path>/usr/src</path>, si dovrebbe vedere un link
simbolico chiamato <path>linux</path>, che punta al sorgente del kernel. In
questo caso si tratta di <c>gentoo-sources-<keyval id="kernel-version"/></c>, ma
c'è da ricordare che potrebbe essere diverso:
</p>

<pre caption="Il link simbolico al sorgente del kernel">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt;
linux-<keyval id="kernel-version"/>
</pre>

<p>
Ora si procede a configurare e compilare il sorgente del kernel. Allo scopo è
possibile utilizzare <c>genkernel</c>, che compila un kernel generico come
quello usato dal CD di Installazione. Si tratta però prima la configurazione
"manuale", poichè è il miglior modo di ottimizzare l'ambiente.</p>

<p>
Se si desidera configurare il kernel manualmente, continuare con <uri
link="#manual">Default: Configurazione manuale</uri>. Per
chi preferisce usare <c>genkernel</c>, leggere <uri
link="#genkernel">Alternativa: Usare genkernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Default: Configurazione manuale</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
La configurazione manuale del kernel è spesso considerata la parte più difficile
che ogni utente Linux incontra. Non è assolutamente vero -- dopo aver
configurato un po' di kernel, l'operazione risulta semplice.
</p>

<p>
Una cosa <e>è</e> però vera: si deve conoscere il proprio sistema quando si
comincia una configurazione manuale del kernel. La maggior parte delle
informazioni può essere raccolta installando pciutils (<c>emerge pciutils</c>)
che contiene <c>lspci</c>. E' possibile tranquillamente ignorare gli errori di
<e>pcilib</e> (ad esempio pcilib: cannot open /sys/bus/pci/devices) che a volte
<c>lspci</c> stampa a video. In alternativa è anche possibile eseguire
<c>lspci</c> dal di fuori dell'ambiente chrootato, i risultati sono i medesimi.
Si può anche eseguire <c>lsmod</c> per vedere che moduli del kernel usa il CD di
Installazione (potrebbe fornire un buon suggerimento su cosa abilitare).
</p>

<p>
Andare nella directory del sorgente del kernel, e digitare <c>make
menuconfig</c> per visualizzare un menu di configurazione basato su ncurses.
</p>

<pre caption="Aprire menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Vengono visualizzate molte sezioni di configurazione. Ecco ora alcune opzioni
che devono essere attivate (altrimenti Gentoo non può funzionare, o non funziona
correttamente senza modifiche aggiuntive).
</p>

</body>
</subsection>
<subsection>
<title>Attivare le opzioni indispensabili</title>
<body>

<p>
Prima di tutto, si deve attivare l'uso di codice/driver di sviluppo e
sperimentale. Se non lo si fa, non si ha la possibilità di utilizzare qualche
codice/driver molto importante:
</p>

<pre caption="Selezionare codice/driver sperimentale">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
E' importante verificare che ogni driver necessario  al boot della propria
macchina (ad esempio il controller SCSI, ..) sia compilato <e>nel</e> kernel e
non come modulo. In caso contrario il sistema potrebbe non funzionare
correttamente.
</p>

</body>
<body test="func:keyval('arch')='AMD64'">

<p>
Selezionare il tipo esatto di processore. Il mantenitore del kernel x86_64
raccomanda gli utenti di abilitare MCE features, così si può essere avvisati
se ci dovessero essere problemi hardware. Su x86_64, questi errori non sono
visualizzati su <c>dmesg</c> come per le altre architetture, ma su
<path>/dev/mcelog</path>, che richiede il pacchetto <c>app-admin/mcelog</c>.
</p>

<pre caption="Selezionare il tipo di processore e caratteristiche">
Processor type and features  --->
   [ ] Intel MCE Features
   [ ] AMD MCE Features
  Processor family (AMD-Opteron/Athlon64)  --->
    ( ) AMD-Opteron/Athlon64
    ( ) Intel EM64T
    ( ) Generic-x86-64
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Selezionare ora la famiglia di processori a cui i proprio appartiene:
</p>

<pre caption="Selezionare la corretta famiglia di processori">
Processor type and features ---&gt;
  <comment>(Change according to your system)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

</body>
<body>

<p>
Andare su <c>File Systems</c> e selezionare il supporto per il filesystem che si
usa. <e>Non</e> compilarlo come modulo, altrimenti Gentoo non può montare le
partizioni. Selezionare anche <c>Virtual memory</c>, <c>/proc file system</c>.
</p>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Se si sta utilizzando il kernel 2.4 è ancora necessario selezionare
<c>/dev file system</c> perchè il kernel 2.4 non supporta <c>udev</c>.
</p>

<pre caption="Selezionare il filesystem">
<comment>(per un kernel 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*]   automatically mount /dev at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(per un kernel 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [ ] /dev file system support (OBSOLETE)
    [*] Virtual memory file system support (former shm fs)

<comment>(Selezionare una o più delle seguenti, secondo necessità)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Se il proprio BIOS non è in grado di gestire i dischi grandi e il drive è stato
impostato per riportare una dimensione limitata, è necessario abilitare la
seguente opzione per poter accedere all'intera unità:
</p>

<pre caption="Selezionare il rilevamento automatico della dimensione">
<comment>(solo kernel 2.4.x)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

</body>
<body test="func:keyval('arch')='AMD64'">

<pre caption="Selezionare il filesystem">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<comment>(Selezionare una o più delle seguenti opzioni necessarie per il proprio
sistema)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

</body>
<body>

<p>
Ricordarsi di attivare il supporto DMA:
</p>

<pre caption="Attivare DMA">
Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
    [*]   Use PCI DMA by default when available
</pre>

<p>
Se si sta usando PPPoE per connettersi a Internet, si ha bisogno delle seguenti
opzioni nel kernel:
</p>

<pre caption="Selezionare i driver necessari per PPPoE"
test="func:keyval('arch')='AMD64'">
Device Drivers ---&gt;
  Networking Support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<pre caption="Selezionare i driver necessari per PPPoE"
test="func:keyval('arch')='x86'">
<comment>(per un kernel 2.4.x)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports

<comment>(per un kernel 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Le due opzioni di compressione non sono dannose, ma neppure necessarie; lo
stesso vale per <c>PPP over Ethernet</c>, che potrebbe essere usata soltanto da
<c>rp-pppoe</c> se configurato in modalità kernel.
</p>

<p>
Chi ne ha bisogno, non deve dimenticare di includere il supporto per la scheda
ethernet nel kernel.
</p>

<p test="func:keyval('arch')='x86'">
Se si è in possesso di una CPU Intel che supporta HyperThreading (tm), o si
possiede un sistema con più CPU, è possibile attivare il supporto
multiprocessore:
</p>

<p test="func:keyval('arch')='AMD64'">
Se si è in possesso di più CPU Opteron o un multi-core (es AMD64 X2), è
possibile attivare il supporto multiprocessore:
</p>

<pre caption="Attivare il supporto multiprocessore">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<note>
Nei sistemi multicore, ciascun core vale come un processore.
</note>

<p>
Se si utilizzano periferiche USB (come mouse o tastiere) è necessario
abilitarle:
</p>

<pre caption="Attivare il supporto USB per dispositivi di input">
Device Drivers ---&gt;
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Per i portatili, se si desidera il supporto PCMCIA <e>non</e> bisogna attivare i
relativi
driver per i kernel 2.4. Sono disponibili driver più recenti nel pacchetto
<c>pcmcia-cs</c> che può essere installato successivamente.
Nel kernel 2.6 possono invece essere utilizzati i driver inclusi.
</p>

<p>
Oltre a compilare il supporto PCMCIA nel kernel 2.6, non dimenticare di
abilitare
il supporto per il bridge PCMCIA di sistema:
</p>

<pre caption="Abilitare il supporto PCMCIA per il kernel 2.6">
Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
<comment>(selezionare 16 bit se si utilizzano schede vecchie, spesso è
utile.)</comment>
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
<comment>(selezionare i bridge di interesse)</comment>
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
Una volta terminata la configurazione del kernel continuare con<uri 
link="#compiling">Compilazione e Installazione</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Compilazione e Installazione</title>
<body>

<p>
Ora che il kernel è configurato, il prossimo passo è la compilazione e
l'installazione. Uscire dal menu di configurazione ed avviare la compilazione:
</p>

<pre caption="Compilare il kernel" test="func:keyval('arch')='x86'">
<comment>(Per kernel 2.4)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(Per kernel 2.6)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<pre caption="Compilare il kernel" test="func:keyval('arch')='AMD64'">
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Quando la compilazione è finita, è necessario copiare l'immagine del kernel in
<path>/boot</path>. E' possibile utilizzare qualsiasi nome per indicare il
proprio kernel, è sufficiente tenerlo a mente perchè è necessario nella
configurazione del bootoader. Ricordare di sostituire
<path><keyval id="kernel-name"/></path> con il nome e la versione del proprio
kernel.
</p>

<pre caption="Installare il kernel">
# <i>cp arch/<keyval id="arch-sub"/>/boot/bzImage /boot/<keyval
id="kernel-name"/></i>
</pre>

<p>
Adesso continuare con <uri link="#kernel_modules">i moduli del Kernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternativa: Usare genkernel</title>
<body>

<p>
Se si sta leggendo questa sezione, vuol dire che si è scelto di usare lo script
<c>genkernel</c>, che configura il kernel.
</p>

<p>
Adesso che sono stati installati i sorgenti del kernel si può utilizzare lo
script <c>genkernel</c> per configurarlo e compilarlo automaticamente.
<c>genkernel</c> configura il kernel in modo quasi identico a come è configurato
quello del CD di Installazione. Infatti quando si usa <c>genkernel</c> per
compilare il kernel, il sistema rileva tutto l'hardware al boot, proprio come il
CD di Installazione. Poichè genkernel non richiede nessuna configurazione
manuale del kernel, questa è una soluzione ideale per quegli utenti che hanno
qualche difficoltà nel compilarsi il kernel da soli.
</p>

<p>
Ecco come usare genkernel. Per prima cosa si deve emergere l'ebuild di
genkernel:
</p>

<pre caption="Emergere genkernel">
# <i>emerge genkernel</i>
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Ora, se si sta per configurare un kernel 2.6, copiare la configurazione del
kernel
del CD di Installazione nella directory dove genkernel si aspetta la
configurazione
di default per il kernel:
</p>

<pre caption="Copia della configurazione del kernel del CD di Installazione">
<comment>(Eseguire quest'operazione solo per kernel 2.6)</comment>
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

</body>
<body>

<p>
Compilare poi il kernel eseguendo <c>genkernel all</c>.
Visto che <c>genkernel</c> compila un kernel che supporta quasi tutto
l'hardware disponibile questa compilazione può essere un processo
piuttosto lungo.
</p>

<p>
E' importante sapere anche che se non si usano ext2 o ext3 come filesystem
potrebbe essere necessario
configurare manualmente il kernel usando <c>genkernel --menuconfig all</c>
e aggiungere il supporto per il filesystem scelto <e>nel</e> kernel (cioè
<e>non</e>
come modulo). Gli utenti di EVMS2 o LVM2 devono anche aggiungere
i parametri <c>--evms2</c> or <c>--lvm2</c>.
</p>

<pre caption="Esecuzione di genkernel">
# <i>genkernel all</i>
</pre>

<p>
Una volta completato <c>genkernel</c>, viene creato un kernel completo di moduli
e <e>root disk iniziale</e> (initrd). Il kernel e initrd intervengono quando si
configura un boot loader. E' consigliabile dunque annotare il nome del kernel e
del initrd, poichè servono quando si scrive il file di configurazione del
bootloader. Initrd si avvia subito dopo il boot per effettuare un rilevamento
automatico dell'hardware (come nel CD di Installazione), prima che si avvii il
sistema "reale".
</p>

<pre caption="Controllo dell'immagine del kernel e dell'initrd">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Ancora un altro passo per ottenere il sistema più simile al CD di Installazione:
emergere <c>coldplug</c>. Mentre initrd rileva automaticamente l'hardware
necessario per avviare il sistema, <c>coldplug</c> autorileva tutto il resto.
Per emergere e abilitare <c>coldplug</c>, digitare:
</p>

<pre caption="Emergere ed abilitare coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Moduli del kernel</title>
<subsection>
<title>Configurare i moduli</title>
<body>

<note test="func:keyval('arch')='x86'">
Se si è scelto un kernel 2.4, sostituire nel corso di questa sezione del 
manuale <c>2.6</c> con <c>2.4</c>.
</note>

<p>
E' possibile elencare tutti i moduli che si desidera caricare automaticamente in
<path>/etc/modules.autoload.d/kernel-2.6</path>. 
E' anche possibile specificare opzioni extra per i moduli, se si desidera.
</p>

<p>
Per vedere tutti i moduli disponibili, eseguire il comando <c>find</c>. Non
dimenticarsi di sostituire <c><keyval id="kernel-version"/></c> con la versione
del kernel che si è compilata:
</p>

<pre caption="Vedere tutti i moduli disponibili">
# <i>find /lib/modules/<keyval id="kernel-version"/>/ -type f -iname '*.o' -or
-iname
'*.ko'</i>
</pre>

<p>
Per esempio, per caricare automaticamente il modulo <c>3c59x.o</c>, modificare
il file <path>kernel-2.6</path> e inserire il nome:
</p>

<pre caption="Modificare /etc/modules.autoload.d/kernel-2.6">
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
3c59x
</pre>

<p>
Continuare l'installazione con la <uri link="?part=1&amp;chap=8">Configurazione
del sistema</uri>.
</p>

</body>
</subsection>
</section>
</sections>
