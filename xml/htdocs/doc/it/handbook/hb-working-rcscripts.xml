<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-working-rcscripts.xml,v 1.13 2007/10/15 21:51:36 scen Exp $ -->

<sections>

<abstract>
Gentoo usa un formato speciale di initscript che, tra le altre caratteristiche,
permette risoluzioni guidate delle dipendenze e initscript virtuali. Questo
capitolo spiega tutti questi aspetti e spiega come utilizzare questi script.
</abstract>

<version>1.25</version>
<date>2007-10-11</date>

<section>
<title>Runlevel</title>
<subsection>
<title>Avviare il sistema</title>
<body>

<p>
All'avvio del sistema, ci sono molte scritte che scorrono e il testo è il
medesimo ad ogni avvio. La sequenza di tutte queste azioni viene chiamata
<e>sequenza di boot</e> ed è (più o meno) definita staticamente.
</p>

<p>
Per prima cosa, il boot loader carica l'imagine del kernel, definita nella
configurazione in memoria, dopo di che dice alla CPU di eseguire il kernel.
Quando il kernel è caricato e in esecuzione, inizializza tutte le strutture e i
lavori specifici del kernel ed avvia il processo <c>init</c>.
</p>

<p>
Questo processo si assicura che tutti i filesystem (definiti in
<path>/etc/fstab</path>) siano montati e pronti per l'uso. Poi esegue alcuni
script situati in <path>/etc/init.d</path>, che avviano i servizi necessari per
un corretto avvio del sistema.
</p>

<p>
Alla fine, quando tutti gli script sono eseguiti, <c>init</c> attiva i terminali
(nella maggior parte dei casi solo le console virtuali che sono nascoste in
<c>Alt-F1</c>, <c>Alt-F2</c>, ecc.) attaccandogli un processo chiamato
<c>agetty</c>. Questo processo per prima cosa si assicura che sia possibile
eseguire il login su questi terminali eseguendo <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Init Script</title>
<body>

<p>
Ora <c>init</c> non esegue gli script in <path>/etc/init.d</path> casualmente.
Inoltre, non lancia tutti gli script in <path>/etc/init.d</path>, ma solo quelli
che gli è stato detto di eseguire. Decide che script eseguire guardando in
<path>/etc/runlevels</path>.
</p>

<p>
Prima, <c>init</c> esegue tutti gli script da <path>/etc/init.d</path> che hanno
un link simbolico in <path>/etc/runlevels/boot</path>. Solitamente, esegue gli
script in ordine alfabetico, ma alcuni di essi hanno delle informazioni di
dipendenze all'interno, che dicono al sistema che un altro script deve essere
avviato prima che possa essere avviati loro stessi.
</p>

<p>
Quando tutti gli script refenziati in <path>/etc/runlevels/boot</path> sono
stati eseguiti, <c>init</c> continua eseguendo gli script che hanno un
collegamento simbolico in <path>/etc/runlevels/default</path>. Ancora, usa
l'ordine alfabetico per decidere che script avviare prima, a meno che lo script
non abbia dipendenze, nel qual caso l'ordine viene cambiato per fornire una
valida sequenza di boot.
</p>

</body>
</subsection>
<subsection>
<title>Come lavora init</title>
<body>

<p>
Certamente <c>init</c> non decide tutto da solo. Ha bisogno di un file di
configurazione che specifica quali azioni debba eseguire. Questo file di
configurazione è <path>/etc/inittab</path>.
</p>

<p>
La prima azione di <c>init</c> è di montare tutti i filesystem. Questo è
definito nella seguente linea di <path>/etc/inittab</path>:
</p>

<pre caption="La linea di inizializzazione del sistema in /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Questa linea dice a <c>init</c>che deve eseguire <c>/sbin/rc sysinit</c> per
inizializzare il sistema. Lo script <path>/sbin/rc</path> si occupa
dell'inizializzazione, <c>init</c> infatti non fa molto: esso delega altri
compiti, come l'inizializzazione del sistema, ad un'altro processo.
</p>

<p>
In secondo luogo <c>init</c> esegue gli script che hanno un collegamento in
<path>/etc/runlevels/boot</path>. Questo è definito dalla seguente linea:
</p>

<pre caption="Inizializzazione del sistema, continua">
rc::bootwait:/sbin/rc boot
</pre>

<p>
Ancora lo script <c>rc</c> provvede ai compiti necessari. Notare che l'opzione
passata a <c>rc</c> (<e>boot</e>) è la stessa della sottodirectory
<path>/etc/runlevels</path>.
</p>

<p>
Ora <c>init</c> controlla il suo file di configurazione per vedere quale
<e>runlevel</e> deve eseguire. Per deciderlo, legge la seguente linea da
<path>/etc/inittab</path>:
</p>

<pre caption="La linea initdefault">
id:3:initdefault:
</pre>

<p>
In questo caso (che la maggioranza di utenti Gentoo usa), l'id del
<e>runlevel</e> è 3. Usando questa informazione, <c>init</c> vede che deve
avviare il <e>runlevel 3</e>:
</p>

<pre caption="La definizione del runlevel ">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
La linea che definisce il livello 3, ancora, usa lo script <c>rc</c> per avviare
il servizio (ora con argomento <e>default</e>). L'argomento di <c>rc</c> è
ancora lo stesso della sottodirectory in <path>/etc/runlevels</path>.
</p>

<p>
Quando <c>rc</c> ha finito, <c>init</c> decide quale console virtuale attivare
e quali comandi devono essere eseguiti su ciascuna console:
</p>

<pre caption="Definizione delle console virtuali">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>

</body>
</subsection>
<subsection>
<title>Cos'è un runlevel?</title>
<body>

<p>
<c>Init</c> usa uno schema numerico per decidere quale <e>runlevel</e> attivare.
Un <e>runlevel</e> è uno stato nel quale il sistema viene avviato e contiene una
collezione di script (runlevel script o <e>initscript</e>) che devono essere
eseguiti quando si entra o si lascia un runlevel.
</p>

<p>
In Gentoo, ci sono sette runlevel definiti: tre runlevel interni, e quattro
runlevel definiti dall'utente. I runlevel interni si chiamano <e>sysinit</e>,
<e>shutdown</e> e <e>reboot</e> e fanno esattamente quello che i nomi implicano:
inizializzano il sistema, spengono il sistema e riavviano il sistema.
</p>

<p>
I runlevel definiti dall'utente sono delle sottodirectory di
<path>/etc/runlevels</path>: <path>boot</path>, <path>default</path>,
<path>nonetwork</path> e <path>single</path>. Il runlevel <path>boot</path>
avvia tutti i servizi necessari al sistema che tutti gli altri runlevel
usano. I rimanenti tre differiscono per i servizi avviati: <path>default</path>
viene usato per le operazioni di tutti i giorni, <path>nonetwork</path> è usato
in caso non sia necessaria alcuna connettività, e <path>single</path> viene
usato per riparare il sistema.
</p>

</body>
</subsection>
<subsection>
<title>Lavorare con gli script di Init</title>
<body>

<p>
Gli script che il processo <c>rc</c> avvia sono chiamati <e>init script</e>.
Ogni script in <path>/etc/init.d</path> può essere eseguito con gli argomenti
<e>start</e>, <e>stop</e>, <e>restart</e>, <e>pause</e>, <e>zap</e>,
<e>status</e>, <e>ineed</e>, <e>iuse</e>, <e>needsme</e>, <e>usesme</e> o
<e>broken</e>.
</p>

<p>
Per avviare, fermare o riavviare un servizio (e tutti i servizi dipendenti),
vengono usati <c>start</c>, <c>stop</c> e <c>restart</c>:
</p>

<pre caption="Avviare Postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Solo i servizio <e>necessari</e> al servizio dato saranno fermati o riavviati.
Gli altri servizi dipendenti (quelli che <e>usa</e> ma non gli sono necessari)
non vengono toccati.
</note>

<p>
Per fermare un servizio, ma non i servizi che dipendono da lui si può usare
l'argomento <c>pause</c>:
</p>

<pre caption="Fermare Postfix ma mantenere in esecuzione i servizi dipendenti">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Per vedere un servizio in che stato si trova (started, stopped, paused, ...) si
può usare l'argomento <c>status</c>:
</p>

<pre caption="Informazioni di stato per postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Se le informazioni di stato dicono che un servizio è in esecuzione, ma non è
così, si può fare il reset delle informazioni di stato a "stopped" con
l'argomento <c>zap</c>:
</p>

<pre caption="reset delle informazioni di stato per postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Per sapere quali dipendenze ha un servizio si può usare <c>iuse</c> o
<c>ineed</c>. Con <c>ineed</c> vengono mostrati i servizi veramente necessari
per il corretto funzionamento del servizio. <c>iuse</c> invece mostra i servizi
che vengono usati ma non sono necessari al servizio per il corretto
funzionamento.
</p>

<pre caption="Richiedere la lista di tutti i servizi da cui Postfix dipende">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
In modo simile si può chiedere la lista dei servizi che dipendono da lui
(<c>needsme</c>) o possono usarlo
</p>

<pre caption="Richiedere la lista dei servizi che richiedono Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Infine, si possono chiedere quali dipendenze, richieste da un servizio, sono
mancanti:
</p>

<pre caption="Richiedere la lista delle dipendenze mancanti per Postfix">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>

<section>
<title>Lavorare con rc-update</title>
<subsection>
<title>Cos'è rc-update?</title>
<body>

<p>
Il sistema di init in Gentoo usa un albero di dipendenze per decidere quali
dipendenze vanno avviate prima. Essendo un compito tedioso da eseguire
manualmente c'è uno strumento che rende semplice l'amministrazione dei runlevel
e init script.
</p>

<p>
Con <c>rc-update</c> si possono aggiungere e rimuovere init script da un
runlevel. Lo strumento <c>rc-update</c> automaticamente interroga
<c>depscan.sh</c> per ricostruire l'albero delle dipendenze.
</p>

</body>
</subsection>
<subsection>
<title>Aggiungere e rimuovere servizi</title>
<body>

<p>
Lo script <c>rc-update</c> richiede un secondo argomento che definisce l'azione:
<e>add</e>, <e>del</e> o <e>show</e>.
</p>

<p>
Per aggiungere o rimuovere un'init script, bisogna passare a <c>rc-update</c>
l'argomento <c>add</c> o <c>del</c>, seguito dallo script di init e dal
runlevel. Per esempio:
</p>

<pre caption="Rimuovere Postfix dal runlevel default">
# <i>rc-update del postfix default</i>
</pre>

<p>
Il comando <c>rc-update -v show</c> mostra tutti gli script di init disponibili
e in quale runlevel vengono eseguiti:
</p>

<pre caption="Ricevere informazioni sugli init script">
# <i>rc-update -v show</i>
</pre>

<p>
È possibile anche usare <c>rc-update show</c> (senza <c>-v</c>) per vedere
solamente gli script di init abilitati e il loro runlevel.
</p>

</body>
</subsection>
</section>

<section>
<title>Configurare i servizi</title>
<subsection>
<title>Perchè una configurazione aggiuntiva?</title>
<body>

<p>
Gli Init script possono essere complessi. Qui non si è interessati a far
modificare direttamente gli init script, dato che sono piuttosto proni a
errori. È comunque importante saper configurare bene un servizio, ad esempio per
per dare più opzioni al servizio stesso.
</p>

<p>
Un secondo motivo è di avere la configurazione al di fuori dell'init script per
aggiornare gli init script senza preoccuparsi di perdere i cambiamenti alla
configurazione.
</p>

</body>
</subsection>
<subsection>
<title>La directory /etc/conf.d</title>
<body>

<p>
Gentoo fornisce un modo semplice per configurare i servizi: ogni init script
che può esser configurato ha un file in <path>/etc/conf.d</path>. Per esempio,
l'init script di apache2 (chiamato <path>/etc/init.d/apache2</path>) ha un file
di configurazione chiamato <path>/etc/conf.d/apache2</path>, che contiene le
opzioni che si vogliono passare al server Apache 2 quando esso viene avviato:
</p>

<pre caption="Variabili definite in /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP5"
</pre>

<p>
I file di configurazione contengono variabili e solo quello (tipo
<path>/etc/make.conf</path>), e rendono davvero facile configurare un servizio.
Permettono inoltre di aggiungere molte informazioni sulle variabili (come
commenti).
</p>

</body>
</subsection>
</section>

<section>
<title>Scrivere Init Scripts</title>
<subsection>
<title>È necessario?</title>
<body>

<p>
No. Scrivere init script non è solitamente necessario dato che Gentoo fornisce
init script pronti all'uso per ogni servizio. Comunque, si potrebbe installare
un servizio senza usare Portage, nel qual caso probabilmente è necessario creare
un init script.
</p>

<p>
È consigliabile non usare init script forniti dal servizio se non sono scritti
esplicitamente per Gentoo: gli init script di Gentoo non sono compatibili con
quelli usati dalle altre distribuzioni!
</p>

</body>
</subsection>
<subsection>
<title>Layout</title>
<body>

<p>
Il layout di base di un init script è mostrato sotto.
</p>

<pre caption="Layout di base di un init script">
#!/sbin/runscript

depend() {
  <comment>(Informazioni di dipendenza)</comment>
}

start() {
  <comment>(Comando necessario per avviare un servizio)</comment>
}

stop() {
  <comment>(Comando necessario per fermare un servizio)</comment>
}

restart() {
  <comment>(Comando necessario per riavviare un servizio)</comment>
}
</pre>

<p>
Ogni init script <e>richiede</e> che la funzione <c>start()</c> sia definita.
Tutte le altre sezioni sono opzionali.
</p>

</body>
</subsection>
<subsection>
<title>Dipendenze</title>
<body>

<p>
Ci sono due tipi di dipendenze che possono essere definite: <c>use</c> e
<c>need</c>. Come menzionato sopra, la dipendenza <c>need</c> è più restrittiva
della dipendenza <c>use</c>. Secondo questo tipo di dipendenza si definisce il
concetto di dipendenza <e>virtuale</e>.
</p>

<p>
Una dipendenza <e>virtuale</e> è una dipendenza che fornisce un servizio, ma non
è fornita solo da quel servizio. L'init script può dipendere da logger di
sistema, ma possono essercene molti altri disponibili (metalogd, syslog-ng,
sysklogd, ...). Dato che non è possibile mettere <c>need</c> per ognuno di loro
(nessun sistema ha tutti questi logger di sistema installati e in esecuzione) ci
si assicura che tutti questi servizi <c>forniscano</c> una dipendenza virtuale.
</p>

<pre caption="Informazioni di dipendenze per Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Il servizio postfix:
</p>

<ul>
  <li>
    richiede la dipendenza (virtuale) <c>net</c>(che è fornita, per esempio,
    da <path>/etc/init.d/net.eth0</path>)
  </li>
  <li>
    usa la dipendenza (virtuale) <c>logger</c> (che è fornita per esempio, da
    <path>/etc/init.d/syslog-ng</path>)
  </li>
  <li>
    usa la dipendenza (virtuale) <c>dns</c> (che è fornita, per esempio da
    <path>/etc/init.d/named</path>)
  </li>
  <li>
    fornisce la dipendenza (virtuale) <c>mta</c> (che è comune a tutti i mail
    server)
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Controllare l'ordine</title>
<body>

<p>
In alcuni casi si potrebbe non aver bisogno di un servizio, ma si può voler
avviare un servizio <c>prima</c> (o <c>dopo</c>) un'altro <e>se</e> disponibile
sul sistema (notare il condizionale:questa non è un'altra dipendenza) <e>e</e>
eseguirle nello stesso runlevel. Si possono fornire queste informazioni usando
<c>before</c> o <c>after</c>.
</p>

<pre caption="La funzione depend() nel servizio Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Si può anche usare "*" per selezionare tutti i servizi nello stesso runlevel,
ma non è consigliabile.
</p>

<pre caption="Eseguire un init script come primo script nel runlevel">
depend() {
  before *
}
</pre>

<p>
Se il servizio deve scrivere su dischi locali, dovrebbe aver bisogno di
<c>localmount</c>. Se non mette niente in <path>/var/run</path>, come un
pidfile, allora dovrebbe partire dopo <c>bootmisc</c>:
</p>

<pre caption="Esempio di funzione depend()">
depend() {
  need localmount
  after bootmisc
}
</pre>

</body>
</subsection>
<subsection>
<title>Funzioni Standard</title>
<body>

<p>
Dopo la funzione <c>depend()</c>, è necessario definire la funzione
<c>start()</c>. Questa contiene tutti i comandi necessari ad inizializzare il
servizio. È consigliabile usare le funzioni <c>ebegin</c> e <c>eend</c> per
informare l'utente su cosa sta accadendo:
</p>

<pre caption="Esempio di funzione start()">
start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --exec /path/to/my_service \
    --pidfile /path/to/my_pidfile
  eend $?
}
</pre>

<p>
Sia <c>--exec</c> che <c>--pidfile</c> dovrebbero essere usati nelle funzioni
start e stop. Se il servizio non crea un pidfile, usare se possibile
<c>--make-pidfile</c>. Altrimenti non usare pidfile. Si può anche aggiungere
<c>--quiet</c> alle opzioni <c>start-stop-daemon</c>, ma non è raccomandato.
L'uso di <c>--quiet</c> potrebbe ostacolare il debugging se il servizio non si
avvia correttamente.
</p>

<note>
Assicurarsi che <c>--exec</c> chiami un servizio e non uno script shell che
lancia servizi e esce: è a questo che serve l'init script.
</note>

<p>
Se si ha bisogno di più esempi della funzione <c>start()</c>, leggere il codice
sorgente degli init script disponibili nella propria directory
<path>/etc/init.d</path>.
</p>

<p>
Altre funzioni che si possono definire sono: <c>stop()</c> e <c>restart()</c>.
Non si è obbligati a definire queste funzioni! Il sistema di init è abbastanza
intelligente da inserire da solo queste funzioni se si usa
<c>start-stop-daemon</c>.
</p>

<p>
Sebbene non <e>occorra</e> creare una funzione <c>stop()</c>, viene fornito un
esempio:
</p>

<pre caption="Esempio funzione stop()">
stop() {
  ebegin "Stopping my_service"
  start-stop-daemon --stop --exec /path/to/my_service \
    --pidfile /path/to/my_pidfile
  eend $?
}
</pre>

<p>
Se il servizio esegue qualche altro script (per esempio bash, python o perl), e
questo script più avanti cambia i nomi (per esempio da <c>foo.py</c> a
<c>foo</c>), si deve aggiungere <c>--name</c> a <c>start-stop-daemon</c>. Si
deve specificare il nome che sarà cambiato dallo script. In questo esempio, un
servizio fa partire <c>foo.py</c>, che cambia nome in <c>foo</c>:
</p>

<pre caption="Un servizio che fa partire lo script foo">
start() {
  ebegin "Starting my_script"
  start-stop-daemon --start --exec /path/to/my_script \
    --pidfile /path/to/my_pidfile --name foo
  eend $?
}
</pre>

<p>
<c>start-stop-daemon</c> ha una eccellente pagina man per vedere maggiori
opzioni:
</p>

<pre caption="Pagina Man di start-stop-daemon">
$ <i>man start-stop-daemon</i>
</pre>

<p>
La sintassi di init script di Gentoo è basata su Bourne Again Shell (bash) così
si possono usare costrutti compatibili bash nei propri init script.
</p>

</body>
</subsection>
<subsection>
<title>Aggiungere opzioni personalizzate</title>
<body>

<p>
Se si ha bisogno di maggiori opzioni negli init script, si può aggiungere
l'opzione alla variabile <c>opts</c>, e creare una funzione con lo stesso nome
dell'opzione. Per esempio, per il supporto di un'opzione chiamata
<c>restartdelay</c>:
</p>

<pre caption="Aggiungere l'opzione restartdelay">
opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <comment># Attendere 3 secondi prima di avviarsi nuovamente</comment>
  start
}
</pre>

</body>
</subsection>
<subsection>
<title>Variabili di configurazione dei servizi</title>
<body>

<p>
Non occorre fare nulla per supportare un file di configurazione in
<path>/etc/conf.d</path>: se l'init script viene eseguito, vengono
automaticamente processati i seguenti file (e per esempio le variabili sono
pronte per essere usate):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;vostro init script&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Inoltre, se l'init script fornisce una dipendenza virtuale (come <c>net</c>),
viene processato anche il file associato a questa dipendenza (come
<path>/etc/conf.d/net</path>).
</p>

</body>
</subsection>
</section>

<section>
<title>Cambiare il comportamento del Runlevel </title>
<subsection>
<title>Può effettivamente essere utile?</title>
<body>

<p>
Molti utenti di portatili conoscono la situazione: a casa si ha bisogno di
avviare <c>net.eth0</c> ma non si vuole avviare <c>net.eth0</c> quando si è in
giro (se non c'è nessuna rete disponibile). Con Gentoo si può alterare il
comportamento del runlevel per venire incontro alle proprie esigenze.
</p>

<p>
Per esempio si può creare un secondo runlevel "default" con cui effettuare il
boot contenente altri init script assegnati ad esso. Si può selezionare al
momento del boot quale runlevel predefinito usare.
</p>

</body>
</subsection>
<subsection>
<title>Usare softlevel</title>
<body>

<p>
Per prima cosa, creare la directory di runlevel per il secondo "default"
runlevel. Per esempio per creare il runlevel <path>offline</path>:
</p>

<pre caption="Creare la directory di runlevel">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Aggiungere i necessari init script al nuovo runlevel creato. Per esempio, per
avere una copia del corrente runlevel <c>default</c> ma senza <c>net.eth0</c>:
</p>

<pre caption="Aggiungere gli init script necessari">
<comment>(Copia tutti i servizi dal runlevel default al runlevel offline)</comment>
# <i>cd /etc/runlevels/default</i>
# <i>for service in *; do rc-update add $service offline; done</i>
<comment>(Rimuove servizi non desiderati da runlevel offline)</comment>
# <i>rc-update del net.eth0 offline</i>
<comment>(Visualizza i servizi attivi per runlevel offline)</comment>
# <i>rc-update show offline</i>
<comment>(Parte di un output esempio)</comment>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre>

<p>
Anche se <c>net.eth0</c> verrà poi rimosso dal runlevel offline, <c>udev</c>
proverà ancora ad avviare ogni elemento che riesce a rilevare e invocherà i
servizi appropriati. Pertanto, sarà necessario aggiungere ogni servizio di rete
che non si vuole venga avviato (così come tutti gli altri servizi per ogni altro
componente che potrebbero essere avviati da udev) a <path>/etc/conf.d/rc</path>
come mostrato di seguito.
</p>

<pre caption="Disabilitare i servizi inizializzati per i diversi componenti in
/etc/conf.d/rc">
RC_COLDPLUG="yes"
<comment>(Di seguito, specificare i servizi che non si vuole vengano inizializzati automaticamente")</comment>
RC_PLUG_SERVICES="!net.eth0"
</pre>

<note>
Per maggiori informazioni sui servizi inizializzati per i diversi componenti, si
invita a porre attenzione nei commenti del file <path>/etc/conf.d/rc</path>.
</note>

<p>
Ora bisogna configurare il bootloader e aggiungere una nuova voce per il
runlevel <c>offline</c>. Per esempio in <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Aggiungere una voce per offline runlevel">
title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Se per il boot del sistema si seleziona la nuova voce il runlevel <c>offline</c>
viene usato al posto del <c>default</c>.
</p>

</body>
</subsection>
<subsection>
<title>Usare bootlevel</title>
<body>

<p>
Usare <c>bootlevel</c> è completamente analogo a <c>softlevel</c>. L'unica
differenza è che si sta definendo un secondo runlevel di "boot" invece di un
secondo runlevel "default".
</p>

</body>
</subsection>
</section>
</sections>