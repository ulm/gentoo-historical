<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-mips-medium.xml,v 1.5 2005/04/17 22:24:50 so Exp $ -->

<sections>

<version>1.8</version>
<date>2005-04-10</date>

<section>
<title>Richieste Hardware</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Prima ancora di cominciare vengono elencate le richieste hardware necessarie per installare Gentoo sulla propria macchina.
</p>

</body>
</subsection>
<subsection>
<title>Richieste hardware</title>
<body>

<table>
<tr>
  <th>Memoria</th>
  <ti>64 MB</ti>
</tr>
<tr>
  <th>Spazio su disco</th>
  <ti>1.5 GB (escluso lo spazio per swap)</ti>
</tr>
<tr>
  <th>Spazio per swap</th>
  <ti>Almeno 256 MB</ti>
</tr>
</table>

<p>
Si dovrebbe anche controllare <uri link="/doc/en/mips-requirements.xml">MIPS Hardware Requirements</uri> sul sito di Gentoo.
</p>

</body>
</subsection>
</section>
<!-- Only the stuff about the stages is replicated from the
     hb-install-x86-medium.xml file since MIPS uses netbooting 
     -->
<!-- START -->
<section>
<title>I metodi per l'installazione di Gentoo</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Gentoo Linux può essere installato tramite uno dei tre <e>stage</e>, che sono archivi compressi tar che contengono un ambiente minimale.
</p>

<ul>
  <li>
    Lo stage1 non contiene niente altro che un compilatore (solo C, non C++), Portage (il sistema di gestione dei pacchetti di Gentoo) e alcuni pacchetti sui quali dipende il compilatore o Portage.
  </li>
  <li>
    Lo stage2 contiene un sistema in cui si è già fatto il bootstrap, un ambiente minimale dal quale si può iniziare a compilare tutte le altre applicazioni necessarie per ottenere un ambiente completo Gentoo.
  </li>
  <li>
    Lo stage3 contiene un sistema minimale già compilato, pronto da utilizzare. Mancano le applicazioni che l'utente di Gentoo deve scegliere quali sono da installare o meno.
  </li>
</ul>

<p>
Per aiutare l'utente nella scelta dello stage da utilizzare, sotto si troveranno i principali vantaggi e svantaggi di ogni stage.
</p>

</body>
</subsection>
<subsection>
<title>Stage1</title>
<body>

<p>
Lo <e>stage1</e> viene utilizzato quando si desidera fare il bootstrap e compilare tutto il sistema da zero.
</p>

<p>
Iniziare dallo stage1 consente di avere un controllo totale sui parametri di ottimizzazione e sulle funzionalità opzionali che possono essere attivate sul sistema. Questo è ciò che rende lo <e>stage1</e> un ottimo strumento di installazione per gli utenti esperti che sanno perfettamente ciò che stanno facendo. E' anche un comodo metodo per coloro che desiderino conoscere meglio il funzionamento di Gentoo Linux.
</p>

<table>
<tr>
  <th>Stage1</th>
  <th>Pro e Contro</th>
</tr>
<tr>
  <th>+</th>
  <ti>
    Consente di avere completo controllo sulle opzioni di ottimizzazione e sull'eventuale installazione del supporto a funzionalità aggiuntive
  </ti>
</tr>
<tr>
  <th>+</th>
  <ti>Adatto ad utenti esperti che sanno ciò che stanno facendo</ti>
</tr>
<tr>
  <th>+</th>
  <ti>Consente di apprendere molto del funzionamento interno di Gentoo</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Impiega molto tempo a terminare l'installazione</ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Se non si desidera configurare le opzioni è semplicemente una perdita di tempo
  </ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Richiede una connessione a Internet durante l'installazione
  </ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Stage2</title>
<body>

<p>
Lo <e>stage2</e> serve per compilare l'intero sistema da uno stato di semi-compilazione dopo il bootstrap.
</p>

<p>
Lo stage2 evita all'utente il processo di bootstrap, il che è un vantaggio se le opzioni di ottimizzazione scelte per lo stage2
 sono già soddisfacenti per il sistema.
</p>

<table>
<tr>
  <th>Stage2</th>
  <th>Pro e Contro</th>
</tr>
<tr>
  <th>+</th>
  <ti>Non c'è bisogno di bootstrap</ti>
</tr>
<tr>
  <th>+</th>
  <ti>Più rapido dello stage1</ti>
</tr>
<tr>
  <th>+</th>
  <ti>E' ancora possibile adattare la configurazione</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Non è possibile configurare ogni parametro come nello stage1</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Non è ancora la via più rapida di installare Gentoo</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Bisogna accettare le ottimizzazioni già presenti nel bootstrap</ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Richiede una connessione a Internet durante l'installazione
  </ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Stage3</title>
<body>

<p>
Lo <e>stage3</e> contiene già un sistema Gentoo di base compilato in precedenza. Si potranno installare i pacchetti che si desiderano.
</p>

<p>
La scelta dello stage3 consente la più rapida installazione possibile di Gentoo Linux, ma implica anche l'accettazione di tutte le configurazioni di default per il sistema (che comunque sono state accuratamente selezionate per ottimizzare le performance e garantire la stabilità). Lo stage3 è necessario anche per installare Gentoo tramite pacchetti precompilati o senza connessione di rete.
</p>

<table>
<tr>
  <th>Stage3</th>
  <th>Pro e Contro</th>
</tr>
<tr>
  <th>+</th>
  <ti>E' il metodo più veloce di avere un sistema base Gentoo</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Non è possibile adattare il sistema, è già compilato</ti>
</tr>
</table>

<p>
E' interessante sapere che se si decide di utilizzare impostazioni di ottimizzazione differenti dopo l'installazione di Gentoo, è possibile ricompilare il sistema per intero con le nuove impostazioni.
</p>

</body>
</subsection>

<subsection>
<title>Una nota sui processori e sulle architetture</title>
<body>

<p>
Su molte architetture, il processore cambia spesso, e quello nuovo si costruisce sulla base di quello precedente. MIPS non fa eccezione. Ci sono molte CPU per la architettura MIPS. Per scegliere il tarball dell'immagine dello stage netboot e le <c>CFLAGS</c> appropriate, si deve conoscere il tipo di CPU che si usa. Questi tipi sono riferiti a <b>I</b>nstruction <b>S</b>et <b>A</b>rchitecture.
</p>

<table>
  <tr>
    <th>MIPS ISA</th>
    <th>32/64-bit</th>
    <th>CPU</th>
  </tr>
  <tr>
    <ti>MIPS 1</ti>
    <ti>32-bit</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R2000">R2000</uri>, 
      <uri link="http://www.linux-mips.org/wiki/index.php/R2000">R3000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 2</ti>
    <ti>32-bit</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R6000">R6000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 3</ti>
    <ti>64-bit</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4400</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4600</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4700</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 4</ti>
    <ti>64-bit</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R5000">R5000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R5000">RM5000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/RM7000">RM7000</uri>
      <uri link="http://www.linux-mips.org/wiki/index.php/R8000">R8000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R10000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R12000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R14000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R16000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 5</ti>
    <ti>64-bit</ti>
    <ti>
      Nessuna
    </ti>
  </tr>
</table>

<p>
Altro importante concetto è quello di <b>endianness</b>. Endianness si riferisce al modo in cui una CPU legge le parole dalla memoria principale. Una parola può essere letta sia con <e>big</e> endian (il bit più significativo), sia con <e>little</e> endian (il bit meno significativo). Le macchine Intel x86 sono principalmente Little endian, mentre le macchine Apple e Sparc sono Big Endian. Su MIPS, possono essere entrambi. Per separarle, si aggiunge <c>el</c> all'architettura per denotare le little endian.
</p>

<table>
  <tr>
    <th>Architettura</th>
    <th>32/64-bit</th>
    <th>Endianness</th>
    <th>Macchine</th>
  </tr>
  <tr>
    <ti><c>mips</c></ti>
    <ti>32-bit</ti>
    <ti>Big Endian</ti>
    <ti>Silicon Graphics</ti>
  </tr>
  <tr>
    <ti><c>mipsel</c></ti>
    <ti>32-bit</ti>
    <ti>Little Endian</ti>
    <ti>DECStations, Cobalt Servers, PlayStation 2</ti>
  </tr>
  <tr>
    <ti><c>mips64</c></ti>
    <ti>64-bit</ti>
    <ti>Big Endian</ti>
    <ti>Silicon Graphics</ti>
  </tr>
  <tr>
    <ti><c>mips64el</c></ti>
    <ti>64-bit</ti>
    <ti>Little Endian</ti>
    <ti>Cobalt Servers, PlayStation 2</ti>
  </tr>
</table>

<p>
Per chi volesse sapere di più su ISA, può consultare i seguenti siti.
</p>

<ul>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Instruction_Set_Architecture">
      Linux/MIPS Website: MIPS ISA
    </uri>
  </li>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Endianess">
      Linux/MIPS Website: Endianness  
    </uri>
  </li>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Processors">
      Linux/MIPS Website: Processors
    </uri>
  </li>
  <li>
    <uri link="http://en.wikipedia.org/wiki/Instruction_set">
      Wikipedia: Instruction Set
    </uri>
  </li>
</ul>

</body>
</subsection>

</section>

<section>
<title>Descrizione di Netbooting</title>
<subsection>
<body>

<p>
In questa sezione si spiega tutto ciò che è necessario per fare il network boot con una workstation Silicon Graphics o Cobalt Server. E' solo una piccola guida, per altre informazioni si consiglia <uri link="/doc/it/diskless-howto.xml">Diskless HOWTO</uri>.
</p>

<p>
Ciò che è necessario, in base alla macchina, si dovrà scegliere tra un bel pò di hardware per il netboot e per installare Linux.
</p>

<ul>
  <li>
    In generale:
    <ul>
      <li>DHCP/BOOTP server (raccomandato ISC DHCPd)</li>
      <li>Molta pazienza</li>
    </ul>
  </li>
  <li>
    Per workstation Silicon Graphics:
    <ul>
      <li>TFTP server (raccomandato tftp-hpa)</li>
      <li>
        Se si desidera o è necessario usare la console seriale:
	<ul>
          <li>MiniDIN8 --&gt; RS-232 serial cable</li>
          <li>Null-modem cable</li>
          <li>VT100 o ANSI terminale compatibile con capacità di 9600 baud</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Per Cobalt Servers (non l'originale Qube):
    <ul>
      <li>NFS server</li>
      <li>Null-modem cable</li>
      <li>VT100 o ANSI terminale compatibile con capacità di 115200 baud</li>
    </ul>
  </li>
</ul>

<note>
Le macchine SGI usano un connettore MiniDIN 8 per le porte seriali. I cavi del modem Apple funzionano bene come cavi seriali, ma per le macchine Apple che hanno USB &amp; modem interni, questi sono più difficili da trovare. Alcuni siti descrivono come si fanno questi cavi (si cerchi con Google). Il seguente sito lo descrive, è in tedesco ma ha un buon digramma da vedere. <uri link="http://www.arbeitsplatzvernichtung-durch-outsourcing.de/marty44/sgihard.html">http://www.arbeitsplatzvernichtung-durch-outsourcing.de/marty44/sgihard.html</uri>
</note>

<note>
Il terminale può essere un reale VT100/ANSI o un PC che esegue un software di emulazione terminale (come HyperTerminal, Minicom, seyon, Telex, xc, screen -- uno di questi va bene). Non è un problema quale piattaforma sia eseguita dalla macchina, basta che abbia una porta seriale RS-232 che si possa usare, e un software adatto.
</note>

<note>
Si noti che questa guida non tratta di Qube. Il server Qube non ha una porta seriale nella sua configurazione di default, e non è possibile installare Gentoo senza l'aiuto di un cacciavite e di una macchina sostitutiva per fare l'installazione. Il seguente sito ha una guida per installare Gentoo su queste macchine. <uri link="http://www.metzner.org/projects/qube/">http://www.metzner.org/projects/qube/</uri>
</note>
</body>
</subsection>
<subsection>
<title>Impostare TFTP e DHCP -- una breve guida</title>
<body>

<p>
Questa non è una guida completa, si può usare per cominciare una installazione da zero, o usare i suggerimenti per una impostazione esistente per supportare netbooting.
</p>

<p>
Si noti che i server usati non devono per forza eseguire Gentoo Linux, si può usare FreeBSD o un'altra piattaforma Unix-like. In questa guida, si assume però di usare Gentoo Linux. Se lo si desidera, si può eseguire TFTP/NFS su una macchina differente del server DHCP.
</p>

<p>
Il primo passo è configurare DHCP. Per fare rispondere il demone ISC DHCP alle richieste BOOTP (richiesto da SGI &amp; Cobalt BOOTROM), si deve abilitare il BOOTP dinamico sul range di indirizzi in uso; poi impostare una voce per ogni client che punta alla immagine boot.
</p>

<pre caption="Installare ISCs DHCP">
# <i>emerge dhcp</i>
</pre>

<p>
Si deve creare il <path>/etc/dhcp/dhcpd.conf</path>. Qui c'è un esempio di configurazione per cominciare.
</p>

<pre caption="dhcpd.conf">
<comment># Dire a dhcpd di disabilitare il DNS dinamico.</comment>
<comment># dhcpd non partirà senza averlo fatto.</comment>
ddns-update-style none;

<comment># Creare una subnet:</comment>
subnet <i>192.168.10.0</i> netmask <i>255.255.255.0</i> {
  <comment># Pool di indirizzi per i client booting. Non dimenticare 'dynamic-bootp'</comment>
  pool {
    range dynamic-bootp <i>192.168.10.1 192.168.10.254</i>;
  }

  <comment># DNS server e default gateway -- sostituire con quelli appropriati</comment>
  option domain-name-servers <i>203.1.72.96</i>, <i>202.47.56.17</i>;
  option routers <i>192.168.10.1</i>;

  <comment># Dire al server DHCP che va bene (e allora è autorevole) per questa subnet.</comment>
  authoritative;

  <comment># Permettere di usare BOOTP in questa subnet.</comment>
  allow bootp;
}
</pre>

<p>
Con questa impostazione, si può aggiungere qualsiasi numero di client nella subnet. Si vedrà più avanti cosa è necessario mettere.
</p>

<p>
Prossimo passo -- Impostare il server TFTP. E' preso in considerazione il demone TFTP tftp-hpa. Si deve installarlo:
</p>

<pre caption="Installare tftp-hpa">
# <i>emerge net-ftp/tftp-hpa</i>
</pre>

<p>
Si può spostare la directory <path>/tftpboot</path> in <path>/home</path> per avere più spazio e si può configurare con il file <path>/etc/conf.d/in.tftpd</path>. In questo manuale si assume che si è lasciata la directory nel suo percorso di default.
</p>

<p>
Alla fine si adatta la configurazione per la macchina su cui si desidera fare il netboot.
</p>

</body>
</subsection>
</section>
<section>
<title>Netbooting su workstation SGI</title>
<subsection>
<title>Scaricare una immagine netboot</title>
<body>

<p>
Ci sono molte immagini disponibili per essere scaricate, dipende su quale sistema si vogliono installare. Sono tutte etichettate per il sistema e la CPU sui quali saranno compilate. I tipi di macchine sono:
</p>

<table>
  <tr>
    <th>Codename</th>
    <th>Macchine</th>
  </tr>
  <tr>
    <ti>IP22</ti>
    <ti>Indy, *Indigo 2, **Challenge S</ti>
  </tr>
  <tr>
    <ti>IP26</ti>
    <ti>*Indigo 2 Power</ti>
  </tr>
  <tr>
    <ti>IP27</ti>
    <ti>Origin 200, Origin 2000</ti>
  </tr>
  <tr>
    <ti>IP28</ti>
    <ti>*Indigo 2 Impact</ti>
  </tr>
  <tr>
    <ti>IP30</ti>
    <ti>Octane</ti>
  </tr>
  <tr>
    <ti>IP32</ti>
    <ti>O2</ti>
  </tr>
</table>

<note>
* E' un errore comune scambiare IRIS Indigo (IP12 w/ R3000 CPU or IP20 w/ R4000 CPU, nessuna può eseguire Linux), Indigo 2 (IP22, che esegue bene Linux), R8000-based Indigo 2 Power (non esegue bene Linux) e R10000-based Indigo 2 Impact (IP28, che è in fase di sperimentazione). Tenere in mente che queste macchine sono differenti.
</note>

<note>
** Sul Challenge S, la porta di rete UTP ha una scheda WD33C95 SCSI, attualmente non supportata su Linux. Si dovrà usare un AUI--&gt;UTP ricetrasmettitore connesso alla porta AUI.
</note>

<p>
Nel filename r4k si riferisce ai processori R4000-series, r5k a R5000, rm5k a RM5200 e r10k a R10000. Le immagini disponibili si trovano in <uri link="http://dev.gentoo.org/~kumba/mips/netboot">http://dev.gentoo.org/~kumba/mips/netboot.</uri>
</p>
</body>
</subsection>

<subsection>
<title>Configurazione DHCP per un client SGI</title>
<body>

<p>
Scaricato il file, metterlo nella directory <path>/tftpboot</path>. Modificare <path>/etc/dhcp/dhcpd.conf</path> e aggiungere la voce per il client SGI.
</p>

<note>
Si dovrebbe creare la directory <path>/tftpboot</path> se non è stato già fatto.
</note>

<pre caption="dhcpd.conf per SGI Workstation">
subnet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx {
  <comment>#... le solite cose..</comment>

  <comment># SGI Workstation .. cambiare 'sgi' con il proprio hostname della macchina.</comment>
  host <i>sgi</i> {
  
    <comment># MAC Address della macchina SGI. E' scritto sul retro</comment>
    <comment># o sulla base della macchina.</comment>
    hardware ethernet <i>08:00:69:08:db:77</i>;

    <comment># TFTP Server per scaricare (di default lo stesso del server DHCP)</comment>
    next-server <i>192.168.10.1</i>;

    <comment># Indirizzo IP da dare alla macchina SGI</comment>
    fixed-address <i>192.168.10.3</i>;

    <comment># Filename del PROM da scaricare e fare boot</comment>
    filename "<i>/gentoo-r4k.img</i>";
  }
}
</pre>
</body>
</subsection>

<subsection>
<title>Opzioni del kernel</title>
<body>
<p>
E' quasi fatta, ma ci sono alcune ottimizzazioni da fare. Aprire una console con i privilegi root, e dare i seguenti comandi.
</p>

<pre caption="Alcune ottimizzazioni per macchine SGI con lo scopo di far funzionare correttamente TFTP">
<comment>(Disabilitare "Path Maximum Transfer Unit", altrimenti SGI Prom non trova il kernel)</comment>
# <i>echo 1 &gt; /proc/sys/net/ipv4/ip_no_pmtu_disc</i>
<comment>(Impostare il port range utilizzabile dal SGI Prom)</comment>
# <i>echo "2048 32767" &gt; /proc/sys/net/ipv4/ip_local_port_range</i>
</pre>

<p>
Dovrebbe essere sufficiente per fare andare il server Linux con SGI Prom.  
</p>

</body>
</subsection>
<subsection>
<title>Avviare i demoni</title>
<body>
<p>
A questo punto, si dovrebbe essere pronti a avviare i demoni. Quindi digitare i seguenti comandi:
</p>

<pre caption="Avviare i demoni DHCP e TFTP">
# <i>/etc/init.d/dhcp start</i>
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Se è andato tutto bene, si dovrebbe poter proseguire con il manuale. Se il server DHCP non si avvia, provare a eseguire 'dhcpd' da riga di comando -- se si visualizza un 'exiting', vedere sotto quali sono i problemi.
</p>

<p>
Un modo facile per verificare se il demone tftp sta funzionando, è quello di digitare il seguente comando -- se si visualizza un qualcosa come quello sotto, tutto è amdato bene.
</p>

<pre caption="Controllare che TFTPd funziona">
# <i>netstat -al | grep ^udp</i>
udp        0      0 *:bootpc                *:*
udp        0      0 *:631                   *:*
udp        0      0 *:xdmcp                 *:*
udp        0      0 *:tftp                  *:* <comment>&lt;-- (look for this line)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Netbooting su una macchina SGI</title>
<body>

<p>
E' impostato tutto, DHCP e TFTP stanno funzionando. Adesso è tempo di accendere la macchina SGI. Quando si vede sullo schermo "Running power-on diagnostics", cliccare "Stop For Maintenance" o premere ESC. Si presenta un menu come il seguente. Digitare i comandi come quelli sotto.
</p>

<pre caption="Menu Manutenzione SGI PROM">
        Running power-on diagnostics

System Maintenance Menu

1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor. Type "exit" to return to the menu.
&gt;&gt; <i>bootp(): root=/dev/ram0</i>
</pre>

<p>
La macchina dovrebbe cominciare a scaricare la immagine, dopo 20 secondi parte l'avvio di Linux. Si va alla shell Busybox <c>ash</c> come descritto quà sotto, in cui si può passare a <uri link="?part=1&amp;chap=3">Configurazione della rete</uri>.
</p>

<pre caption="Se tutto è andato bene">
init started:  BusyBox v1.00-pre10 (2004.04.27-02:55+0000) multi-call binary

Gentoo Linux; http://www.gentoo.org/
 Copyright 2001-2004 Gentoo Technologies, Inc.; Distributed under the GPL

 Gentoo/MIPS Netboot for Silicon Graphics Machines
 Build Date: April 26th, 2004

 * To configure networking, do the following:

 * For Static IP:
 * /bin/net-setup &lt;IP Address&gt; &lt;Gateway Address&gt; [telnet]

 * For Dynamic IP:
 * /bin/net-setup dhcp [telnet]

 * If you would like a telnetd daemon loaded as well, pass "telnet"
 * As the final argument to /bin/net-setup.

Please press Enter to activate this console.
</pre>

</body>
</subsection>
<subsection>
<title>Risposte ad alcuni problemi.</title>
<body>

<p>
Se la macchina si rifiuta di scaricare la sua immagine, può essere una delle due cose, (1) si è fatto un errore in qualche parte, o (2) si ha bisogno di una piccola persuasione. Una lista delle cose che si possono controllare:
</p>

<ul>
  <li>dhcpd sta dando un indirizzo IP alla macchina SGI. Si dovrebbe vedere qualche messaggio sulla richiesta BOOTP nel log di sistema. Anche <c>tcpdump</c> potrebbe essere utile.
  </li>
  <li>
    I permessi sono impostati correttamente in tftp (<path>/tftpboot</path> -- dovrebbe essere leggibile)
  </li>
  <li>
    Controllare i log del sistema per vedere cosa sta riportando il server tftp (se ci sono errori)
  </li>
<!--
  I really think this tip can go...  
  
  <li>
    Pregare un Tux plushie (questa potrebbe non funzionare, e non è supportata)
  </li>-->
</ul>

<p>
Se si è controllato tutto sul server, e si stanno ottenendo timeout, etc sulla macchina SGI, digitare quanto segue nella console.
</p>

<pre caption="Fare funzionare SGI PROM">
&gt;&gt; <i>resetenv</i>
&gt;&gt; <i>unsetenv netaddr</i>
&gt;&gt; <i>unsetenv dlserver</i>
&gt;&gt; <i>init</i>
&gt;&gt; <i>bootp(): root=/dev/ram0</i>
</pre>

</body>
</subsection>
</section>

<section>
<title>Netbooting su server Cobalt</title>
<subsection>
<body>

</body>
</subsection>

<subsection>
<title>Descrizione della procedura netboot</title>
<body>

<p>
Non come le macchine SGI, server Cobalt usano NFS per trasferire i loro kernel per l'avvio. Si avvia la macchina premendo i tasti freccia sinistra &amp; destra mentre si accende. La macchina tenterà di ottenere un numero IP via BOOTP, monta la directory <path>/nfsroot</path> dal server con NFS, cerca di scaricare e avviare il file <path>vmlinux_raq-2800.gz</path> che si assume essere un binario standard ELF.
</p>

<p>
Il Cobalt BOOTROM non da nessuna precisazione su questa procedura, così il file deve risiedere nella directory <path>/nfsroot</path>, e deve essere più piccolo di 675kB. In questo manuale si imposterà <uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> per permettere di avviare kernel più grandi. CoLo supporta embedded ramdisk, quindi non ha bisogno di filesystem totali di root in <path>/nfsroot</path>.
</p>

</body>
</subsection>

<subsection>
<title>Scaricare una immagine Netboot</title>
<body>

<p>
In <uri link="http://dev.gentoo.org/~kumba/mips/cobalt/netboot/">http://dev.gentoo.org/~kumba/mips/cobalt/netboot/</uri> si troveranno immagini boot per ottenere e eseguire Cobalt. I file di cui si ha bisogno si chiamano <path>cobalt-netboot-YYYYMMDD.img.gz</path> -- selezionare quello più recente e metterlo nella propria directory <path>/nfsroot</path>. Per convenienza rinominare il file con <path>gentoo-cobalt.img.gz</path> -- si assumerà che lo si è fatto.
</p>

<p>
Andare in <uri link="http://www.colonel-panic.org/cobalt-mips/">http://www.colonel-panic.org/cobalt-mips/</uri> e scaricare l'ultima release del bootloader CoLo. Fare untar di questo. Nella directory creata <path>colo-1.XX/binaries</path> si dovrebbe trovare un file chiamato <path>colo-chain.elf</path>. Gzippare il file e metterlo in <path>/nfsroot</path> chiamandolo <path>vmlinux_raq-2800.gz</path>. In alcuni casi si deve creare in link simbolico chiamato <path>boot</path> che punta a <path>/nfsroot</path>. Si può fare questo in una sola volta con questi comandi:
</p>

<note>
RaQ1 e Qube 2700 cercano <path>vmlinux.gz</path> non <path>vmlinux_raq-2800.gz</path>.
</note>

<pre caption="Mettere CoLo in nfsroot">
# <i>tar -xzvf colo-1.XX.tar.gz</i>
# <i>cd colo-1.XX/binaries</i>

<comment>(Per Qubte 2800, RaQ2, etc)</comment>
# <i>gzip -9vc colo-chain.elf &gt; /nfsroot/vmlinux_raq-2800.gz</i>

<comment>(Per RaQ1, Qube 2700)</comment>
# <i>gzip -9vc colo-chain.elf &gt; /nfsroot/vmlinux.gz</i>
# <i>cd /nfsroot</i>
# <i>ln . boot</i>
</pre>

<note>
Se l'ultima versione di CoLo non si avvia, si potrebbe provare con una versione precedente. La versione 1.16 e le versioni precedenti funzionano.
</note>

</body>
</subsection>

<subsection>
<title>Configurazione NFS Server</title>
<body>

<p>
Questa macchina usa NFS per scaricare la sua immagine, si ha bisogno di esportare <path>/nfsroot</path> sul server. Se non lo si è già fatto, si deve installare il pacchetto net-fs/nfs-utils.
</p>
<pre caption="Installare nfs-utils">
# <i>emerge net-fs/nfs-utils</i>
</pre>

<p>
Mettere il seguente nel file <path>/etc/exports</path>. Si possono impostare restrizioni più strette se lo si desidera.
</p>

<pre caption="Esportare la directory /nfsroot">
/nfsroot      *(ro,sync)
</pre>

<p>
Si può avviare il server NFS:
</p>

<pre caption="Avviare il server NFS">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Se il server NFS è già in esecuzione, si può dire di far prendere un'altra via al file <c>exports</c> con <c>exportfs</c>.
</p>

<pre caption="Esportare un nuovo filesystem">
# <i>exportfs -av</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configurazione DHCP per una macchina Cobalt</title>
<body>

<p>
La cosa è relativamente diretta. Aggiungere la seguente informazione al file <path>/etc/dhcp/dhcpd.conf</path>.
</p>

<pre caption="dhcpd.conf per server Cobalt">
subnet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx {
  <comment># ... le solite cose ...</comment>

  <comment># Configurazione per un Cobalt Server</comment>
  <comment># Impostare hostname:</comment>
  host <i>qube</i> {
    <comment># Percorso alla directory nfsroot.</comment>
    <comment># Questo è per quando si usa la opzione boot TFTP su CoLo</comment>
    option root-path "/nfsroot";

    <comment># Mac address ethernet di Cobalt Server</comment>
    hardware ethernet <i>00:10:e0:00:86:3d</i>;

    <comment># Server da cui si scarica la immagine</comment>
    next-server <i>192.168.10.1</i>;

    <comment># Indirizzo IP di cobalt server</comment>
    fixed-address <i>192.168.10.2</i>;

    <comment># Immagine da scaricare</comment>
    <comment># Questo anche ha a che fare con CoLo</comment>
    filename "<i>gentoo-cobalt.img.gz</i>";
  }
}
</pre>

</body>
</subsection>

<subsection>
<title>Avviare i demoni</title>
<body>

<p>
Si dovrebbe essere pronti per avviare i demoni. Digitare quanto segue:
</p>

<pre caption="Avviare i demoni DHCP e NFS">
# <i>/etc/init.d/dhcp start</i>
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Se è andato tutto bene, si dovrebbe poter proseguire con il manuale. Se il server DHCP non si avvia, provare a eseguire 'dhcpd' da riga di comando -- se si visualizza un 'exiting', vedere sotto quali sono i problemi.
</p>

</body>
</subsection>

<subsection>
<title>Netbooting sulla macchina Cobalt</title>
<body>

<p>
E' impostato tutto, DHCP e TFTP stanno funzionando. Adesso è tempo di accendere la macchina Cobalt. Collegate il cavo del modem, e impostate il terminale seriale per poter usare 115200 baud, 8 bits, nessuna parità, 1 stop bit, VT100 emulazione. Premete i tasti freccia sinistra &amp; destra mentre l'unità si accende.
</p>

<p>
Se tutto è andato bene, si dovrebbe visualizzare "Net Booting", si dovrebbero vedere alcune attività di rete, seguiti da CoLo. Andare in basso nel menu fino a trovare "Boot Shell" e premere invio. Sulla console seriale, si dovrebbe essere in un prompt come questo:
</p>

<note>
E' stato riportato che l'opzione di boot NFS sulle versioni moderne do CoLo, fa tutto questo. Se questo non funziona, vedere oltre.
</note>

<pre caption="CoLo si avvia in un prompt">
[ "CoLo" v1.13 ]
stage2: 87fb0000-88000000
pci: unit type &lt;Qube2&gt;
tulip: {00:10:e0:00:86:3d}
ide: resetting
boot: running boot menu
&gt;
</pre>

<p>
Dire alla macchina di ottenere un indirizzo con DHCP. Digitare <c>dhcp</c> al prompt.
</p>

<pre caption="Ottenere un indirizzo con DHCP">
&gt; <i>dhcp</i>
net: interface up
dhcp: DISCOVER
dhcp: OFFER 10.0.0.1 &lt;-- 192.168.10.254
dhcp: REQUEST
arp: sent request for 192.168.10.254
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
arp: resolved 192.168.10.254
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
dhcp: DISCOVER
dhcp: OFFER 10.0.0.1 &lt;-- 192.168.10.254
dhcp: REQUEST
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
dhcp: ACK
net: interface down
net: interface up
  address     10.0.0.1
  netmask     255.255.255.0
  gateway     10.0.0.254
  name server 192.168.5.1
</pre>

<p>
NOTA: Se si ha una rete Windows si potrebbero vedere messaggi tra le linee <c>udp: no matching socket</c>. Sono in risposta al broadcast di rete sulle porte che CoLo non riconosce.
</p>

<pre caption="'no matching socket' messaggi di errori">
udp: no matching socket 10.0.0.254:138 --&gt; 10.0.0.255:138
udp: no matching socket 10.0.0.254:138 --&gt; 10.0.0.255:138
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
</pre>

<p>
Si dice al server Cobalt di scaricare il suo kernel.
</p>

<pre caption="Scaricare il kernel">
&gt; <i>nfs 10.0.0.254 /nfsroot gentoo.img.gz</i>
arp: sent request for 10.0.0.254
arp: resolved 10.0.0.254
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
nfs: mounted "/nfsroot"
nfs: lookup "gentoo.img.gz"
nfs: mode &lt;0100644&gt;
4651KB loaded (1240KB/sec)
0048ada0 4763040t
</pre>

<p>
Si può cominciare ad avviare il kernel.
</p>

<pre caption="Avviare il kernel">
&gt; <i>execute</i>
elf: 80080000 &lt;-- 00001000 6586368t + 192624t
elf: entry 80328040
net: interface down
CPU revision is: 000028a0
FPU revision is: 000028a0
Primary instruction cache 32kB, physically tagged, 2-way, linesize 32 bytes.
Primary data cache 32kB 2-way, linesize 32 bytes.
Linux version 2.4.26-mipscvs-20040415 (root@khazad-dum) (gcc version 3.3.3...
Determined physical RAM map:
 memory: 08000000 @ 00000000 (usable)
Initial ramdisk at: 0x80392000 (3366912 bytes)
On node 0 totalpages: 32768
zone(0): 32768 pages.
zone(1): 0 pages.
zone(2): 0 pages.
Kernel command line: console=ttyS0,115200 root=/dev/ram0
Calibrating delay loop... 249.85 BogoMIPS
Memory: 122512k/131072k available (2708k kernel code, 8560k reserved, 3424k dat)
</pre>

<p>
Se tutto è andato bene, si va alla shell Busybox <c>ash</c> come sotto, in cui si può passare a <uri link="?part=1&amp;chap=3">Configurazione della rete</uri>.
</p>

<pre caption="Se tutto è andato bene">
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 280k freed
init started:  BusyBox v1.00-pre10 (2004.04.27-02:55+0000) multi-call binary

Gentoo Linux; http://www.gentoo.org/
 Copyright 2001-2004 Gentoo Technologies, Inc.; Distributed under the GPL

 Gentoo/MIPS Netboot for Cobalt Microserver Machines
 Build Date: April 26th, 2004

 * To configure networking, do the following:

 * For Static IP:
 * /bin/net-setup &lt;IP Address&gt; &lt;Gateway Address&gt; [telnet]

 * For Dynamic IP:
 * /bin/net-setup dhcp [telnet]

 * If you would like a telnetd daemon loaded as well, pass "telnet"
 * As the final argument to /bin/net-setup.

Please press Enter to activate this console.
</pre>

</body>
</subsection>

<subsection>
<title>Risposte ad alcuni problemi.</title>
<body>

<p>
Se la macchina si rifiuta di scaricare la sua immagine, può essere una delle due cose, (1) si è fatto un errore in qualche parte, o (2) si ha bisogno di una piccola persuasione. Una lista delle cose che si possono controllare:
</p>

<ul>
  <li>dhcpd sta dando un indirizzo IP alla macchina Cobalt. Si dovrebbe vedere qualche messaggio sulla richiesta BOOTP nel log di sistema. Anche <c>tcpdump</c> potrebbe essere utile.
  </li>
  <li>
    I permessi sono impostati correttamente in <path>/nfsroot</path>. (dovrebbe essere leggibile)
  </li>
  <li>
    Assicurarsi che il server NFS sia in esecuzione e esportare la directory <path>/nfsroot</path>. Si controlli con <c>exportfs -v</c> sul server.
  </li>
</ul>
</body>
</subsection>
</section>
<!--

  Commented Out Until Further Notice

<section>
<title>Gentoo/MIPS LiveCD</title>
<subsection>
<title>Overview</title>
<body>

<p>
On Silicon Graphics machines, it is possible to boot from a CD in order to
install operating systems.  (This is how one installs IRIX for instance)
Recently, images for such bootable CDs to install Gentoo have been made
possible.  These CDs are designed to work in the same way.
</p>

<p>
At the moment the Gentoo/MIPS Live CD will only work on the SGI Indy,
Indigo 2 and O2 workstations equipped with R4000 and R5000-series CPUs, however
other platforms may be possible in future.
</p>

<p>
You can find the Live CD images for download on your favourite Gentoo Mirror
under the <path>experimental/mips/livecd</path> directory.
</p>

<warn>
These CDs are highly experimental at this time.  They may or may not work at
this time.  You can report success or failures either on
<uri link="http://bugs.gentoo.org">Bugzilla</uri>,
<uri link="http://forums.gentoo.org/viewtopic.php?t=242518">this forum
thread</uri> or in the <c>#gentoo-mips</c>
<uri link="http://www.gentoo.org/main/en/irc.xml">IRC channel</uri>.  We would
love to hear from you.
</warn>

</body>

</subsection>

<subsection>
<title>Burning a Live CD</title>
<body>

<p>
An important thing to note, the SGI PROM does not understand the ISO9660 format,
nor does it know anything about the El Torito boot standard.  These CD images
are constructed as a SGI disklabel with the boot image in the volume header like
a hard drive.  Therefore, care must be taken when burning the CD image.
</p>

<p>
Below is an example command that assumes 24x burning speed on an IDE burner.  If
you have a SCSI burner for instance, you may want to adjust the <c>dev</c>
statement as appropriate.  Likewise with the <c>speed</c> option - if you
strike troubles, you might want to try dropping the speed.
</p>

<pre caption="Burning using cdrecord">
# <i>bzip2 -d mips-livecd-prototype-rc2-20041027.img.bz2</i>
# <i>cdrecord -vv -pad speed=24 dev=ATAPI:0,0,0 -tao mips-livecd-prototype-rc2-20041027.img</i>
</pre>

<note>
It may be possible to burn these CDs under Windows, assuming your burning
program just blindly burns the image as is.  However, no one has succeeded in
making a working CD this way to date.
</note>

<note>
If you don't know what to put as your <c>dev</c> argument, run <c>cdrecord
-scanbus</c> as root - this will tell you where your burner is located.
</note>

</body>
</subsection>
</section>
-->
</sections>
