<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<sections>
<section>
<title>Introduzione ai dispositivi a blocchi</title>
<subsection>
<title>Dispositivi a blocchi</title>
<body>

<p>
Si darà un'occhiata approfondita agli aspetti relativi ai dischi in Gentoo Linux e in Linux in generale, includendo i filesystem Linux, le partizioni e i dispositivi a blocchi. Quindi, una volta che si sarà acquisita familiarità con i dischi e i filesystem, si verrà guidati attraverso il processo di configurazione delle partizioni e dei filesystem per l'installazione di Gentoo Linux.
</p>

<p>
Per cominciare, si introduranno i <e>dispositivi a blocchi</e>. Il dispositivo a blocchi più famoso è molto probabilmente quello che rappresenta la prima unità IDE in un sistema Linux, <path>/dev/hda</path>. Se il sistema usa dischi SCSI, allora il primo disco fisso dovrebbe essere <path>/dev/sda</path>.
</p>

<p>
I dispositivi a blocchi rappresentano un'interfaccia astratta ai dischi. I programmi utente possono usare questi dispositivi a blocchi per interagire con i dischi, senza doversi chiedere se si tratta di unità IDE, SCSI o di qualsiasi altro tipo. Il programma può semplicemente indirizzare la memorizzazione su disco attraverso dei blocchi contigui, accessibili casualmente, e di dimensione pari a 512 byte ciascuno.
</p>

</body>
</subsection>
<subsection>
<title>Partizioni e slices</title>
<body>

<p>
Nonostante sia possibile usare un intero disco per il sistema Linux, ciò non è quasi mai fatto in pratica. Invece, i dispositivi a blocchi del disco sono divisi in parti più piccole e più maneggevoli. Sulla maggior parte dei sistemi, queste parti sono chiamate <e>partizioni</e>. Altre architetture usano il termine <e>slices</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partizioni</title>
<body>

<p>
Le partizioni sono divise in tre tipi: <e>primarie</e>, <e>estese</e> e <e>logiche</e>.
</p>

<p>
Una partizione <e>primaria</e> è una partizione che ha le sue informazioni memorizzate nel MBR (master boot record). Poichè MBR è molto piccolo (512 byte), possono essere definite solo quattro partizioni primarie (per esempio, da <path>/dev/hda1</path> a <path>/dev/hda4</path>).
</p>

<p>
Una partizione <e>estesa</e> è una speciale partizione primaria (cioè deve essere una delle quattro), che contiene altre partizioni. In origine non esiste una tale partizione, ma poichè quattro partizioni erano troppo poche, è stata data la possibilità di estendere lo schema di formattazione senza perdere la compatibilità.
</p>

<p>
Una partizione <e>logica</e> è una partizione che sta dentro la partizione estesa. Le loro definizioni non sono disposte nel MBR, ma sono dichiarate nella partizione estesa.
</p>

</body>
</subsection>
<!-- TODO rewrite with LVM2 instructions when appropriate
<subsection>
<title>Logical Volumes</title>
<body>

<p>
Some people might find partitions and slices too restrictive. If you feel the
same way, you should take a look at LVM - - the <e>Logical Volume Manager</e>.
</p>

<p>
With LVM, you create partitions (or slices) the normal way, but you won't use
them to house your Linux system. Instead, you add another layer of storage
(namely the LVM layer) on which you install Gentoo. But what are the benefits of
LVM?
</p>

<p>
With LVM you can easily resize the volumes on which you have installed Gentoo.
You can also take a snapshot of a volume without freezing the system, making
your backup strategy more transparent for the users (and less troublesome).
Another advantage is that you can add several disks to a single volume (meaning
if one of your volumes is low on free space, you can extend it without having to
copy over files). 
</p>

<p>
An LVM is structured in three abstract items. You have a <e>physical volume</e>,
which is a partition, slice or disk you want to use to store the LVM layer on.
Then you have a <e>volume group</e> to which you assign certain physical
volumes. This volume group contains several <e>logical volumes</e> which are 
some sort of virtual partitions.
</p>

<p>
These logical volumes are used as regular partitions; however, if a logical
volume requires more space, it can use the available space in the volume group
to extend itself. If the volume group doesn't have sufficient available space,
you can add more physical volumes to it, fully transparent to the user (i.e. no
need to copy over data, freeze the system etc.). This makes LVM very flexible.
</p>

<p>
If you want to use LVM, you are advised to keep your root filesystem
(<path>/</path>) and your boot filesystem (<path>/boot</path>) outside the LVM.
If you want to place most of your files in a logical volume (<path>/home</path>,
<path>/usr</path>, <path>/tmp</path>, <path>/opt</path> and <path>/var</path> 
are used in this handbook) your root filesystem doesn't need to be very big 
(a mere 150 Mb will do just fine).
</p>

</body>
</subsection>
-->
</section>
<section>
<title>Impostare uno schema di partizionamento</title>
<subsection>
<title>Schema di partizionamento di default</title>
<body>

<p>
Se non si è interessati a elaborare uno schema di partizionamento per il sistema, si può usare quello di questo Manuale:
</p>

<p>
Per x86 o amd64:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Per ppc:
</p>

<table>
<tr>
  <th>Partizione NewWorld</th>
  <th>Partizione OldWorld</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Non necessaria)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Per Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(nessuno)</ti>
  <ti>Disco intero</ti>
  <ti>Sun Disk Label (richiesto)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<!-- TODO rewrite with LVM2 instructions when appropriate 
<p>
If you want to use LVM, you should create a small root partition instead of a
big one, ignore the swap partition and create a big partition as you will make 
the individual separation later when you define the logical volumes). Then mark 
this big partition of type "Linux LVM" or "LVM" (8e).
</p>
-->

<p>
Se si sta installando Gentoo da una distribuzione esistente, si dovrebbero ridimensionare le partizioni esistenti per poter installare Gentoo. Per farlo, si può usare <uri link="http://www.gnu.org/software/parted">GNU/Parted</uri>.
</p>

<p>
Se si è interessati a sapere quanto dovrebbe essere grande una partizione (o il volume logico), o anche di quante partizioni si ha bisogno, si deve leggere sotto. Altrimenti continuare con il partizionamento del disco:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Usare fdisk su x86 o amd64 per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Usare fdisk su Alpha per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Usare fdisk su SPARC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Usare mac-fdisk su PPC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Usare fdisk su HPPA per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Usare fdisk su MIPS per partizionare il disco</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Quante partizioni e quanto grandi?</title>
<body>

<p>
Il numero delle partizioni è altamente dipendente sull'ambiente. Per esempio, se si hanno molti utenti su una stessa macchina, molto probabilmente si vorrà tenere separate le directory <path>/home</path>, aumentando così la sicurezza e rendendo più facile il backup. Se si sta installando Gentoo per ottenere un mailserver, <path>/var</path> dovrebbe essere separata poichè tutte le mail sono memorizzate in essa. Una buona scelta del filesystem massimizzerà le prestazioni. I gameserver avranno una separata <path>/opt</path>, visto che la maggior parte dei server di gioco sono installati là. La stessa cosa vale per <path>/home</path>: sicurezza e backup.
</p>

<p>
Come si è visto, molto dipende da cosa si deve realizzare. Partizioni o volumi separati hanno i seguenti vantaggi:
</p>

<ul>
<li>
  Si può scegliere il filesystem con maggiori prestazioni per ogni partizione o volume
</li>
<li>
  L'intero sistema non può esaurire lo spazio libero se un tool rotto sta continuamente scrivendo file su una partizione o su un volume
</li>
<li>
  Se necessario, i controlli del filesystem sono ridotti, poichè vari controlli possono essere fatti in parallelo (questo vantaggio è più per i dischi multipli che per le partizioni multiple)
</li>
<li>
  La sicurezza può essere aumentata montando alcune partizioni o volumi di sola lettura, nosuid (setuid bits sono ignorati), noexec (executable bits sono ignorati) etc.
</li>
</ul>

<p>
Le partizioni multiple hanno però un grosso svantaggio: se non sono configurate correttamente, si potrebbe avere un sistema con molto spazio libero su una partizione e nessuno spazio libero su un'altra.
</p>

<p>
Come esempio di partizionamento, si mostra quello che ha un disco da 20Gb, usato come un laptop di dimostrazione (contenente webserver, mailserver, gnome, ...):
</p>

<pre caption="Esempio di uso del filesystem">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Spazio non partizionato per uso futuro: 2 Gb)</comment>
</pre>

<p>
<path>/usr</path> è quasi pieno (usato 83%), ma una volta installato tutto il software, non tenderà a crescere molto. Per <path>/var</path> si potrà pensare che lo spazio assegnato sia troppo. Ma Gentoo compila tutti i programmi in <path>/var/tmp/portage</path>, così si dovrebbe avere <path>/var</path> con almeno 1Gb libero se non si vogliono compilare grandi programmi, oltre 3Gb liberi per compilare KDE e OpenOffice.org.
</p>

<p>
Ora si partiziona il/i disco/dischi usando le istruzioni per le diverse architetture:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Usare fdisk su x86 o amd64 per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Usare fdisk su Alpha per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Usare fdisk su SPARC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Usare mac-fdisk su PPC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Usare fdisk su HPPA per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Usare fdisk su MIPS per partizionare il disco</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su x86 o amd64 per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>x86</e> o <e>amd64</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizione di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Cambiare le partizioni in base alle proprie impostazioni.
</p>

</body>
</subsection>
<subsection>
<title>Vedere la disposizione delle partizioni</title>
<body>

<p>
<c>fdisk</c> è un tool popolare e potente per dividere il disco in partizioni. Aprire <c>fdisk</c> sul disco (nell'esempio si usa <path>/dev/hda</path>):
</p>

<pre caption="Aprire fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Si visualizzerà un prompt come questo:
</p>

<pre caption="Prompt di fdisk">
Command (m for help):
</pre>

<p>
Digitare <c>p</c> per visualizzare le attuali partizioni presenti sul disco:
</p>

<pre caption="Un esempio di partizionamento">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
Questo disco è configurato per avere sette filesystem Linux (chiamati "Linux" nelle corrispondenti partizioni), e una partizione swap (chiamata "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Rimuovere tutte le partizioni</title>
<body>

<p>
Ora si rimuoveranno dal disco tutte le partizioni esistenti. Digitare <c>d</c> per eliminare una partizione. Per esempio, per eliminare <path>/dev/hda1</path>:
</p>

<pre caption="Eliminare una partizione">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
E' stata memorizzata l'eliminazione della partizione. Non si rivedrà più se si digiterà <c>p</c>, ma non sarà eliminata fino a quando non si salveranno i cambiamenti. Se si è commesso un errore e si vuole uscire senza salvare, digitare <c>q</c> e poi enter e la partizione non sarà tolta.
</p>

<p>
Ora, assumendo che si desidera effettivamente eliminare tutte le partizioni sul sistema, digitare <c>p</c> per visualizzare l'elenco delle partizioni, e poi digitare <c>d</c> seguito dal numero della partizione, per eliminarle. Alla fine si potrà avere una tabella con nessuna partizione:
</p>

<pre caption="Tabella con nessuna partizione">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Ora che la tabela è vuota, si è pronti a creare le partizioni. Si userà lo schema di partizionamento visto precedentemente. Non si deve seguire queste istruzioni alla lettera se non si vuole lo stesso schema!
</p>

</body>
</subsection>
<subsection>
<title>Creare la partizione di boot</title>
<body>

<p>
Per prima cosa, si crei una piccola partizione di boot. Digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per selezionare una partizione primaria, seguito da <c>1</c> per selezionare la prima partizione primaria. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+32M</c> per creare una partizione di 32 Mbyte:
</p>

<pre caption="Creare la partizione di boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Premere Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Quando si digita <c>p</c>, si dovrebbe vedere la seguente partizione:
</p>

<pre caption="Partizione di boot creata">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Si ha bisogno di rendere questa partizione avviabile. Digitare <c>a</c> per inserire il segno di avviabile su questa partizione. Se si preme di nuovo <c>p</c>, si noterà che un <path>*</path> è posto nella colonna "Boot".
</p>

</body>
</subsection>
<subsection>
<title>Creare la partizione swap</title>
<body>

<p>
Si crea la partizione swap. Per farlo, digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per dire a fdisk che si vuole una partizione primaria. Digitare <c>2</c> per creare la seconda partizione primaria, <path>/dev/hda2</path>. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+512M</c> per creare una partizione di 512MB. Dopo aver fatto questo, digitare <c>t</c> per impostare il tipo di partizione, <c>2</c> per selezionare la partizione che si è creata e infine <c>82</c> per impostare il tipo di partizione a "Linux Swap". Finiti questi passaggi, digitando <c>p</c> si dovrebbe vedere una tabella partizionata simile a questa:
</p>

<pre caption="Elenco delle partizioni dopo aver creato la partizione swap">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione root</title>
<body>

<p>
Si crea la partizione root. Digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per dire a fdisk che si vuole una partizione primaria. Digitare <c>3</c> per creare la terza partizione primaria, <path>/dev/hda3</path>. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, premere enter per creare una partizione che occupa il resto dello spazio su disco. Infine, digitando <c>p</c> si dovrebbe vedere una tabella partizionata simile a questa:
</p>

<pre caption="Elenco delle partizioni dopo aver creato la partizione root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Salvare lo schema delle partizioni</title>
<body>

<p>
Per salvare lo schema delle partizioni e uscire da <c>fdisk</c>, digitare <c>w</c>.
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded 
, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su Alpha per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>Alpha</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizioni di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Intero disco (richiesto)</ti>
</tr>
</table>

<p>
Cambiare lo schema in base alle proprie impostazioni.
</p>

</body>
</subsection>
<subsection>
<title>Identificare i dischi disponibili</title>
<body>

<p>
Per identificare quali dischi stanno funzionando, usare i seguenti comandi:
</p>

<pre caption="Identificare i dischi disponibili">
<comment>(Per dischi IDE)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Per dischi SCSI)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Si dovrebbero poter vedere i dischi rilevati e le loro voci di <path>/dev</path>. Nella parte seguente si assume che il disco è SCSI su <path>/dev/sda</path>.
</p>

<p>
Aprire <c>fdisk</c>:
</p>

<pre caption="Aprire fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Eliminare tutti gli slices</title>
<body>

<p>
Si comincia con eliminare tutti gli slices <e>tranne</e> il 'c'-slice. Si mostra come eliminare uno slice (nell'esempio si usa 'a'). Ripetere il processo per eliminare tutti gli altri slices (non il 'c'-slice).
</p>

<p>
Usare <c>p</c> per vedere tutti gli slices esistenti. <c>d</c> è usato per eliminare uno slice.
</p>

<pre caption="Eliminare uno slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Dopo aver ripetuto questo processo per tutti gli slices, si dovrebbe vedere un elenco come questo:
</p>

<pre caption="Vedere uno schema vuoto">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creare lo swap slice</title>
<body>

<p>
Sui sistemi Alpha non si ha bisogno di una partizione separata di boot. Tuttavia, il primo cilindro non può essere usato poichè l'immagine di <c>aboot</c> sarà postà là.
</p>

<p>
Si creerà uno swap slice partendo dal terzo cilindro, per un totale di 1 Gbyte. Usare <c>n</c> per creare un nuovo slice. Poi si cambierà il suo tipo a <c>1</c>, cioè a <e>swap</e>.
</p>

<pre caption="Creare lo swap slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Dopo, si dovrebbe vedere uno schema simile al seguente:
</p>

<pre caption="Schema di slice dopo aver creato lo swap slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creare il root slice</title>
<body>

<p>
Si crea il root slice, partendo dal primo cilindro <e>dopo</e> lo swap slice. Usare il comando <c>p</c> per vedere dove finisce lo swap slice. Nel nostro esempio finisce a 1003, e la partizione root parte da 1004.
</p>

<p>
Un altro problema è che c'è attualmente un bug in <c>fdisk</c>, per cui il numero dei cilindri disponibili risulta uno in più del numero reale dei cilindri. In altre parole, quando viene chiesto per l'ultimo cilindro, diminuire di uno il numero del cilindro (nell'esempio 5290).
</p>

<p>
Quando è creata la partizione, si cambia il tipo a <c>8</c>, per <e>ext2</e>.
</p>

<pre caption="Creare il root slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Lo schema dello slice dovrebbe essere simile a questo:
</p>

<pre caption="Vedere lo schema dello slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Salvare lo schema dello slice e uscire</title>
<body>

<p>
Salvare <c>fdisk</c> digitando <c>w</c>. Questo salverà anche lo schema dello slice.
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che gli slices sono creati, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded
, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</subsection>
</section>
<section>
<title>Usare fdsk su SPARC per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>SPARC</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizione di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (richiesto)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Cambiare lo schema di partizione in base alle proprie impostazioni.
</p>

</body>
</subsection>
<subsection>
<title>Aprire fdisk</title>
<body>

<p>
Aprire <c>fdisk</c> con il disco come argomento:
</p>

<pre caption="Aprire fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Verrà visualizzato il prompt di fdisk:
</p>

<pre caption="Il prompt di fdisk">
Command (m for help):
</pre>

<p>
Per vedere le partizioni disponibili, digitare <c>p</c>:
</p>

<pre caption="Elenco delle partizioni disponibili">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Notare il <c>Sun disk label</c> nell'output. Se questo manca, il disco sta usando il partizionamento DOS, non quello Sun. In questo caso, usare <c>s</c> per assicurarsi che il disco abbia una tabella di partizione sun.
</p>

</body>
</subsection>
<subsection>
<title>Eliminare le partizioni esistenti</title>
<body>

<p>
E' il momento di eliminare qualsiasi partizione esistente. Digitare <c>d</c> e premere Enter. Si visualizzerà il prompt per il numero di partizione che si vuole eliminare. Per eliminare un preesistente <path>/dev/hda1</path>, digitare:
</p>

<pre caption="Eliminare una partizione">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Assumendo che si voglia rimuovere tutte le partizioni esistenti, si prema <c>p</c> per vedere tutte le partizioni disponibili, e <c>d</c> per eliminarne una per una. Se si commette un errore, premere immediatamente <c>q</c> -- <c>fdisk</c> non cambia le partizioni ma mantiene i cambiamenti in memoria. Solo quando si digita <c>w</c> le partizioni saranno salvate.
</p>

<p>
Dopo aver eliminato tutte le partizioni, si dovrebbe avere uno schema di partizione simile al seguente:
</p>

<pre caption="Vedere uno schema di partizione vuoto">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>

</body>
</subsection>
<subsection>
<title>Creare il Sun Disk Label</title>
<body>

<p>
Ora che la tabella delle partizioni è vuota, si crea la partizione per il Sun Disk Label. Digitare <c>n</c> per creare una nuova partizione, poi <c>3</c> per creare la partizione. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, premere enter. Poi digitare <c>t</c> per impostare il tipo di partizione, infine digitare <c>5</c> per impostare il tipo di partizione a "Whole disk".
</p>

<pre caption="Creare un Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Premere Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Dopo aver completato questi passaggi, digitando <c>p</c> si dovrebbe visualizzare una tabella di partizioni simile a questa:
</p>

<pre caption="Vedere lo schema delle partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione di boot</title>
<body>

<p>
Si crea la partizione di boot. Digitare <c>n</c> per creare una nuova partizione, poi <c>1</c> per creare la partizione. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+32M</c> per creare una partizione di <c>32MB</c>. Assicurarsi che la partizione di boot sia contenuta nei primi 2Gb del disco. Si può vedere l'output di questi passaggi:
</p>

<pre caption="Creare una partizione di boot">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Premere Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Ora, digitando <c>p</c> si dovrebbe vedere il seguente schema di partizioni:
</p>

<pre caption="Elenco dello schema di partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione swap</title>
<body>

<p>
Si crea la partizione swap. Digitare <c>n</c> per creare una nuova partizione, poi <c>2</c> per creare la seconda partizione, <path>/dev/hda2</path>. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+512M</c> per creare una partizione di 512MB. Dopo aver fatto questo, digitare <c>t</c> per impostare il tipo di partizione, e infine digitare <c>82</c> per impostare il tipo di partizione a "Linux Swap". Digitando <c>p</c> si dovrebbe visualizzare una tabella di partizioni simile a questa:
</p>

<pre caption="Elenco delle partizioni disponibili">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione root</title>
<body>

<p>
Si crea la partizione root. Digitare <c>n</c> per creare una nuova partizione, poi <c>4</c> per creare la terza partizione, <path>/dev/hda4</path>. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, premere enter per creare una partizione che occupi il resto dello spazio sul disco. Dopo aver completato questi passaggi, digitando <c>p</c> si dovrebbe vedere una tabella di partizioni simile a questa:
</p>

<pre caption="Elenco della tabella completa delle partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Salvare e uscire</title>
<body>

<p>
Per salvare lo schema delle partizioni e uscire da <c>fdisk</c>, digitare <c>w</c>:
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded
, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</subsection>
</section>
<section>
<title>Usare mac-fdisk su PPC per partizionare il disco</title>
<body>

<p>
A questo punto, si creano le partizioni usando <c>mac-fdisk</c>:
</p>

<pre caption="Aprire mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Si eliminano le partizioni. Usare <c>d</c> in <c>mac-fdisk</c> per eliminarle. Sarà chiesto il numero della partizione da eliminare.
</p>

<p>
Poi si crea una partizione <e>Apple_Bootstrap</e> usando <c>b</c>. Sarà chiesto da quale blocco si vuole iniziare. Se precedentemente si è selezionato come numero della partizione <c>3</c>, premere <c>3p</c>.
</p>

<p>
Si crea una partizione swap digitando <c>c</c>. Di nuovo <c>mac-fdisk</c> chiederà da quale blocco si vuole iniziare la partizione. Se si è usato <c>3</c> prima di creare la partizione Apple_Bootstrap, si deve digitare <c>4p</c>. Digitare <c>512M</c> quando sarà chiesto per la grandezza della partizione (o digitare un'altra grandezza -- 512 è quella raccomandata). Quando sarà chiesto il nome, digitare <c>swap</c> (obbligatorio).
</p>

<p>
Per creare la partizione root, digitare <c>c</c> seguito da <c>5p</c>, per selezionare da quale blocco dovrebbe partire la partizione root. Quando sarà chiesta la dimensione, digitare di nuovo <c>5p</c>. <c>mac-fdisk</c> lo interpreterà come "Use all available space". Quando sarà chiesto il nome, digitare <c>root</c> (obbligatorio).
</p>

<p>
Per finire, scrivere la partizione al disco usando <c>w</c> e <c>q</c> per uscire da <c>mac-fdisk</c>.
</p>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded 
, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</section>
<section>
<title>Usare fdisk su HPPA per partizionare il disco</title>
<body>

<p>
Usare <c>fdisk</c> per creare le partizioni che si vogliono:
</p>

<pre caption="Partizionare il disco">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO ha bisogno di una partizione speciale per funzionare. Si deve creare una partizione di almeno 16Mb all'inizio del disco. Il tipo di partizione deve essere <e>f0</e> (Linux/PA-RISC boot).
</p>

<impo>
Se si continua senza creare la partizione speciale per PALO, il sistema non funzionerà.
</impo>

<p>
Se il disco è più grande di 2Gb, assicurarsi ch la partizione di boot sia nei primi 2Gb. PALO non può leggere un kernel dopo 2Gb.
</p>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded
, unless you have chosen to use LVM
in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</section>
<section>
<title>Usare fdisk su MIPS per partizionare il disco</title>
<!-- This entire section is copy/pasted from Kumba's original text. It should
     probably be rewritten, but it seems a bit complicated.
     Someone donate me a MIPS? :) 

       ~SwifT
-->
<subsection>
<title>Creare un SGI Disk Label</title>
<body>

<p>
Tutti i dischi in un SGI System richiedono un <e>SGI Disk Label</e>, il quale ha una funzione simile a Sun &amp; MS-DOS disklabels -- Esso contiene informazioni sulle partizioni del disco. Un nuovo SGI Disk Label creerà due partizioni speciali sul disco:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (partizione 9): Questa partizione è importante. E' dove andranno le immagini del kernel. Per immagazzinare le immagini del kernel, si utilizzerà il tool <c>dvhtool</c>, per copiare le immagini del kernel in questa partizione. Sarà possibile avviare i kernel da questa partizione mediante il SGI PROM Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (partizione 11): Questa partizione è simile nello scopo alla terza partizione del Sun Disklabel di "Whole Disk". Questa partizione contiene l'intero disco, e non dovrebbe essere toccata. Non serve per nessun'altro scopo speciale, oltre a quello di assistere il PROM in qualche modo non documentato (o è usata da IRIX).
  </li>
</ul>

<warn>
Il SGI Volume Header <e>deve</e> iniziare dal cilindro 0. Altrimenti, non si potrà avviare dal disco.
</warn>

<p>
Il seguente è un esempio di una sessione di <c>fdisk</c>. Dopo averlo letto, si deve modificare in base alle proprie necessità.
</p>

<pre caption="Creare un SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Se il disco ha già un SGI Disklabel, allora fdisk non permetterà la creazione di una nuova label. Ci sono due modi per aggirare questo. Il primo è quello di creare un Sun o MS-DOS disklabel, scrivere i cambiamenti al disco, e riaprire fdisk. Il secondo è quello di sovrascrivere la tabella delle partizioni con dati nulli con il seguente comando: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Ottenere il SGI Volume Header della giusta dimensione</title>
<body>

<p>
Ora che un SGI Disklabel è creato, devono essere definite le partizioni. Nell'esempio sopra, ci sono già due partizioni definite. Sono le partizioni speciali che non dovrebbero essere alterate. Tuttavia, per installare Gentoo, si ha bisogno di caricare le varie immagini dei kernel, direttamente nel volume header, poichè non c'è ancora disponibile nessun SGI Bootloader supportato in Portage. Lo stesso volume header può sostenere <e>otto</e> immmagini di qualsiasi dimensione, e ogni immagine permette nomi con otto caratteri.
</p>

<p>
Il processo per il quale si rende più grande il volume header non è esattamente diretto -- c'è un piccolo trucco. Non si può eliminare e riaggiungere il volume header grazie al comportamento di fdisk. Nell'esempio sotto, si creerà un Volume header di 50MB insieme con una partizione di /boot di 50MB. Lo schema del proprio disco potrà essere diverso, ma l'esempio è solo a scopo illustrativo.
</p>

<pre caption="Ridimensionare il SGI Volume Header">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Notare come fdisk permetta che la Partizione #1 sia ricreata partendo da un minimo di 5 cilindri)</comment>
<comment>(Si è tentato di eliminare &amp; ricreare il SGI Volume Header, questa è la stessa conclusione che si sarebbe incontrata.)</comment>
<comment>(Nel nostro esempio, si vuole che /boot sia di 50MB, e si inizia dal cilindro 51 (il Volume Header ha bisogno di iniziare dal cilindro 0), e si imposta il cilindro finale a 101, e sarà approsimativamente 50MB)</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Eliminare la Partizione #9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Ricreare la Partizione #9, finendo prima della Partizione #1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Schema finale delle partizioni</title>
<body>

<p>
Una volta fatto questo, si è sicuri di creare il resto delle partizioni, poichè si vede la misura. Dopo aver messo tutte le partizioni, assicurarsi di impostare l'ID della partizione swap a <c>82</c>, che è Linux Swap. Di default essa sarà <c>83</c>, Linux Native.
</p>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
<!-- TODO reactivate when LVM2 instructions are boarded
, unless you have chosen to use 
LVM in which case you should first read <uri link="#lvm">Optional: Using
LVM</uri>.
-->
</p>

</body>
</subsection>
</section>
<!-- TODO rewrite with LVM2 instructions when appropriate
<section id="lvm">
<title>Optional: Using LVM</title>
<subsection>
<title>Initialising the Partitions</title>
<body>

<p>
To use LVM, you first need to activate LVM and initialize your created 
partitions. To do so, use <c>vgscan</c> (activate LVM) and <c>pvcreate</c> 
(initialize partitions). In this example, we assume that <path>/dev/hda1</path> 
is a regular boot partition, <path>/dev/hda2</path> a regular (but small) root 
partition and <path>/dev/hda3</path> a big partition for the LVM.
</p>

<pre caption="Activating and Initialising LVM partitions">
# <i>vgscan</i>
# <i>pvcreate /dev/hda3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Set up the Volume Group</title>
<body>

<p>
Now we need to setup the volume group. We will use <c>vgcreate</c> to do so, but
<c>vgcreate</c> needs the full (DevFS-style) path to the device file. So we
first find out where these device files are located:
</p>

<pre caption="Getting to know the full location">
# <i>ls -l /dev/hda3</i>
lr-xr-xr-x    1 root     root           33 Oct 21  2003 /dev/hda3 -&gt; ide/host0/bus0/target0/lun0/part3
</pre>

<p>
Now we create the volume group called "vg":
</p>

<pre caption="Create the VG group">
# <i>vgcreate vg /dev/ide/host0/bus0/target0/lun0/part3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Logical Volumes</title>
<body>

<p>
Now we create the logical volumes. In this example, we create a separate
<path>usr/</path> (10 Gb), <path>home/</path> (5 Gb), <path>opt/</path> (2 Gb),
<path>tmp/</path> (2 Gb), <path>var/</path> (5 Gb) and a swap of 512 Mb.
</p>

<pre caption="Creating the logical volumes">
# <i>lvcreate -L10G -nusr vg</i>
# <i>lvcreate -L5G -nhome vg</i>
# <i>lvcreate -L2G -nopt vg</i>
# <i>lvcreate -L2G -ntmp vg</i>
# <i>lvcreate -L5G -nvar vg</i>
# <i>lvcreate -L512M -nswap vg</i>
</pre>

<p>
As of now, the logical volumes are created and usable as they were regular
partitions:
</p>

<pre caption="Listing the logical volumes">
# <i>ls /dev/vg</i>
home     opt      swap     tmp     usr      var
</pre>

<p>
<e>These</e> files are now your "partitions" (logical volumes).
</p>

</body>
</subsection>
</section>
-->
<section id="filesystems">
<title>Crare i filesystem</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Ora che le partizioni sono create, è il momento di impostare un filesystem. Se non si hanno problemi sulla scelta del filesystem e vanno bene quelli che si useranno di default in questo Manuale, continuare con <uri link="#filesystems-apply">Applicare un filesystem a una partizione</uri>. Altrimenti si può continuare, si vedranno i filesystem disponibili.
</p>

</body>
</subsection>
<subsection>
<title>Filesystem</title>
<body>

<p>
Sono disponibili molti filesystem. Alcuni sono stabili su tutte le architetture, altri su alcune. La seguente tabella elenca i filesystem disponibili e le architetture nelle quali funzionano. Se una architettura è inserita tra le parentesi, allora il filesystem dovrebbe funzionare, ma non è testato.
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Journaled</th>
  <th>Architetture</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>Tutte le architetture</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>si</ti>
  <ti>Tutte le architetture</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>si</ti>
  <ti>x86, hppa, alpha, (mips), (pcc), (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>si</ti>
  <ti>x86, alpha, amd64, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>si</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> è il vero e proprio filesystem di Linux ma non possiede il supporto per il metadata journaling, il che significa che le routine che effettuano all'avvio i controlli sul filesystem ext2 possono occupare diverso tempo. C'è adesso una scelta abbastanza ampia di filesystem journaled di nuova generazione che sono in grado di effettuare controlli sulla consistenza molto velocemente e sono generalmente preferiti alle controparti non-journaled. I filesystem journaled prevengono i lunghi tempi di attesa che solitamente si riscotrano quando viene riavviato il sistema e il filesystem si trova in uno stato inconsistente.
</p>

<p>
<b>ext3</b> è la versione journaled del filesystem ext2, fornisce il metadata journaling per un veloce recupero dei dati in aggiunta ad altre caratteristiche di journaling avanzate come full data e ordered data journaling. ext3 è un filesystem davvero molto valido e affidabile. Offre generalmente performance accettabili in molte situazioni. Poichè non fa un uso estesivo di "trees" nel proprio design interno, non è in grado di scalare molto bene, il che significa che non rappresenta una scelta ideale per filesystem molto grandi o situazioni in cui è necessario manipolare file molto grandi o grandi quantità di file in una singola directory. Ma se usato in condizioni che sfruttino le sue caratteristiche di design, ext3 è un eccellente filesystem.
</p>

<p>
<b>ReiserFS</b> è un filesystem basato su B*-tree che offre ottime performance generali e si dimostra notevolmente superiore a ext2 e ext3 con file di piccole dimensioni (file minori di 4k), spesso di un fattore 10x-15x. ReiserFS scala inoltre molto bene e supporta il metadata journaling. Dal kernel 2.4.18+, ReiserFS ha raggiunto la solidità che lo porta a essere caldamente raccomandato sia per un uso generico che per casi estremi come la crezione di grandi filesystem, l'uso su molti file piccoli, file molto grandi e directory contenenti decine di migliaia di file.
</p>

<p>
<b>XFS</b> è un filesystem con metadata journaling che è completamente supportato in Gentoo Linux dal kernel xfs-sources. Si presenta con un robusto insieme di caratteristiche ed è ottimizzato per la scalabilità. Si raccomanda l'uso su sistemi Linux con high-end SCSI e/o unità di memorizzazione con canali in fibra e gruppi di alimentazione ininterrotti. Data l'aggressivita con la quale XFS si serve della cache in RAM per i dati in transito, programmi progettati in modo non adeguato (quelli che non prendono precauzioni quando scrivono file su disco, e ce ne sono abbastanza), possono perdere una discreta quantità di dati se il sistema si arresta in modo inaspettato.
</p>

<p>
<b>JFS</b> è il filesystem journaling ad alte prestazioni di IBM. E' stato recentemente giudicato pronto per il mercato, ma ad oggi non è stato sufficientemente testato per fare commenti positivi o negativi sulla sua stabilità generale.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Applicare un filesystem a una partizione</title>
<body>

<p>
Per creare un filesystem su una partizione o volume, sono disponibili tool per ogni filesystem possibile:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Comando per la creazione</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Per esempio, per avere la partizione di boot (<path>/dev/hda1</path>) in ext2 e la partizione root (<path>/dev/hda3</path>) in ext3, si userà:</p>

<pre caption="Applicare un filesystem su una partizione">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Ora si devono creare i filesystem sulle partizioni (o volumi logici) create recentemente.
</p>

</body>
</subsection>
<subsection>
<title>Attivare la partizione swap</title>
<body>

<p>
<c>mkswap</c> è il comando usato per inizializzare le partizioni swap:
</p>

<pre caption="Inizializzare la partizione swap">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Per attivare la partizione swap, usare <c>swapon</c>:
</p>

<note>
Gli utenti di Knoppix che hanno già una partizione swap sul loro sistema, dovrebbero saltare questa attivazione, poichè Knoppix attiva automaticamente le partizioni swap esistenti.
</note>

<pre caption="Attivare la partizione swap">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Creare e attivare swap.
</p>

</body>
</subsection>
</section>
<section>
<title>Montare</title>
<body>

<p>
Ora che le partizioni sono inizializzate e hanno un filesystem, è il momento di montarle. Usare il comando <c>mount</c>. Non dimenticarsi di creare le necessarie directory di mount:
</p>

<pre caption="Montare le partizioni">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Se si vuole che <path>/tmp</path> risieda in una partizione separata, assicurarsi di cambiare i permessi dopo il mount: <c>chmod 1777 /mnt/gentoo/tmp</c>. Questo vale anche per <path>/var/tmp</path>.
</note>

<p>
Si ha bisogno di montare il filesystem proc (una intefaccia virtuale con il kernel) su <path>/proc</path>. Si crea il mountpoint <path>/mnt/gentoo/proc</path>:
</p>

<pre caption="Creare il mountpoint /mnt/gentoo/proc">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
Se si sta installando Gentoo da un LiveCD, si deve montare <path>proc</path>:
</p>

<pre caption="Montare proc">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Se non si sta installando Gentoo da un LiveCD, si deve fare il bindmount di <path>/proc</path>:
</p>

<pre caption="Fare il bindmount di proc">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
</pre>

<p>
Ora continuare con <uri link="?part=1&amp;chap=5">Copia dei file di installazione di Gentoo</uri>.
</p>

</body>
</section>
</sections>
