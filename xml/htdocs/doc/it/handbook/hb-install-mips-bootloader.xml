<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-mips-bootloader.xml,v 1.4 2006/01/19 22:38:28 so Exp $ -->

<sections>

<version>1.8</version>
<date>2006-01-19</date>

<section id="sgi">
<title>Macchine Silicon Graphics -- Impostare Arcboot</title>
<subsection>
<title>Installare arcboot</title>
<body>

<p>
In precedenza si è visto come installare un kernel e come copiarlo
nell'intestazione del volume con <c>dvhtool</c>. Ci sono però due difetti
proncipali seguendo questo sistema:
</p>

<ul>
  <li>Non è supportato su tutti i sistemi SGI</li>
  <li>Richiede una intestazione del volume più larga</li>
</ul>

<p>
Per avviare la macchina, è stato sviluppato un bootloader, <c>arcboot</c>.
Invece di mettere il kernel nell'intestazione del volume, lo si lascia in
<path>/boot</path> (dove risiede una partizione EXT2/3), e si dice a
<c>arcboot</c> (che si trova nell'intestazione del volume al posto del
kernel) dove trovarlo. Si emergano alcuni tool che saranno usati più avanti.
</p>

<pre caption="Installare i tool richiesti">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Si dovrebbe avere installati <c>arcboot</c> che si trova nell'intestazione
del volume e carica i kernel, e <c>dvhtool</c> che aiuta a mettere
<c>arcboot</c> nella intestazione del volume.
</p>

<p>
Il binario, nascosto nel <path>/usr/lib/arcboot</path> -- su sistemi IP22
(Indy, Indigo 2, Challenge S), sarà chiamato <path>arcboot.ip22</path>. In
altri sistemi la cosa dovrebbe essere simile. Si copia questo file
nell'intestazione del volume.
</p>

<pre caption="Installare arcboot nell'intestazione del volume">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Si verifica la presenza del file nell'intestazione del volume.
</p>

<pre caption="Controllare la presenza di arcboot">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Ci sono due vecchi kernel, <path>linux</path> e <path>newlinux</path>, ma non
è un problema,l'importante è che ci sia <c>arcboot</c>.
</note>

</body>
</subsection>

<subsection>
<title>Configurare arcboot</title>
<body>

<p>
Se si è gia usato <c>lilo</c>, si troverà che entrambi usano una sintassi
simile per la configurazione. <c>arcboot</c> si aspetta di trovare il suo
file di configurazione in una partizione EXT2/3 con il nome di
<path>/etc/arcboot.conf</path>. Assicurarsi che <path>/boot</path> sia EXT2/3
e che esista un file <path>arcboot.conf</path> in <path>/boot/etc</path>. Un
esempio di configurazione si trova in <path>/etc/arcboot.conf.sample</path>.
</p>

<pre caption="Inserire arcboot">
<comment>( Creare la directory /boot/etc )</comment>
# <i>mkdir /boot/etc</i>

<comment>( Copiare il file di configurazione )</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>( Creare un symlink a /etc )</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>( ... e un symlink che punta a se stesso )</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Si può modificare <path>/etc/arcboot.conf</path> in base alle proprie
preferenze. Qui si preferisce impostare due immagini di kernel:
<path>new</path> che può non funzionare e <path>working</path> che
sicuramente funziona. <path>arcboot.conf</path> sarà più o meno così.
</p>

<pre caption="Esempio di arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># backup version</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Ci sono alcune ottimizzazioni da fare, e si trovano nella sezione <uri
link="#reboot">Riavviare il sistema</uri>.
</p>

</body>
</subsection>
</section>

<section id="cobalt">
<title>Cobalt MicroServer -- Impostare CoLo</title>
<subsection>
<title>Installare CoLo</title>
<body>

<p>
Sui server Cobalt, queste macchine hanno firmware meno capace installato sul
chip. Il Cobalt BOOTROM è primitivo rispetto al SGI PROM, ed ha alcuni
limiti.
</p>

<ul>
  <li>
		C'è un limite di 675kB sui kernel. Con l'attuale dimensione del 2.4, è
		impossibile fare un kernel di questa grandezza. Il 2.6 non è proprio
		possibile considerarlo.
  </li>
  <li>
		I kernel 64-bit non sono supportati dal firmware di riserva (sebbene
		questi siano sperimentali sulle macchine Cobalt)
  </li>
  <li>
    La shell è di base nella maggior parte dei casi
  </li>
</ul>

<p>
Per superare questi limiti, è stato sviluppato un firmware alternativo, <uri
link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> (Cobalt Loader).
E' una immagine BOOTROM che può essere sia inserita nel chip del server
Cobalt, sia essere caricata dal firmware esistente.
</p>

<note>
In questo manuale si seguirà l'impostazione di CoLo in modo che sia caricato
dal firmware di riserva. Questo è l'unico modo per avere una impostazione
sicura e raccomandata.
</note>

<warn>
Si può inserirlo nel server, e rimettere il firmware originale -- lo si fa a
proprio rischio. Potrebbe non essere sbagliato, si dovrà rimuovere il BOOTROM
e riprogrammare con il firmware di riserva. Se non si sa cosa si sta facendo,
<e>NON</e> si deve esporre a possibili rotture la macchina. Non si ha nessuna
responsibilità se si ignora questo consiglio.
</warn>

<p>
Si inizia con emergere il pacchetto.
</p>

<pre caption="Emergere colo">
# <i>emerge colo</i>
</pre>

<p>
Si dovrebbe avere la directory <path>/usr/lib/colo</path> e in essa si
dovrebbero trovare due file, <path>colo-chain.elf</path> il kernel per il
firmware di riserva da caricare, e <path>colo-rom-image.bin</path> una
immagine ROM che si inserisce nel BOOTROM. Si monta /boot, si mette una copia
compressa di <path>colo-chain.elf</path> in <path>/boot</path> dove il
sistema si aspetta di trovarla.
</p>

<pre caption="Mettere CoLo al suo posto">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configurare CoLo</title>

<body>

<p>
Quando il sistema si avvia per la prima volta, caricherà CoLo con un menu
diviso in sezioni. La prima opzione (default è dopo 5 secondi) è il boot del
disco. Il sistema tenta di montare la prima partizione Linux che trova, e
esegue lo script <path>default.colo</path>. La sintassi è bene documentata
nella documentazione di CoLo (si dia una letta a
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path> -- dove X.YY è la
versione installata),e è molto semplice.
</p>

<note>
Solo un consiglio: quando si installano i kernel, è meglio creare due
immagini dei kernel, <path>kernel.gz.working</path> -- un kernel funzionante,
e <path>kernel.gz.new</path> -- un kernel appena compilato. Si possono usare
i symlink per puntare ai kernel "new" e "working", o rinominare le immagini
dei kernel.
</note>

<pre caption="default.colo di base">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo rifiuterà di caricare uno script che non inizia con la riga
<c>#:CoLo:#</c>. E' come se fosse l'equivalente di <c>#!/bin/sh</c> negli
scripts shell.
</note>

<p>
E' anche possibile chiedere quale kernel &amp; configurazione si preferisce
bootare, con timeout di default. Questa è la configurazione usata su un
server Cobalt:
</p>

<impo>
Si deve utilizzare CoLo v1.12 o v1.13 per usare il comando <c>menu</c>.
L'esempio seguente potrebbe non funzionare con la v1.11.
</impo>

<impo>
Il comando <c>menu</c> è stato sostituito dal comando <c>select</c> in CoLo
v1.14. Se si è installata una versione successiva, si deve guardare in
<path>menu.colo</path> nella sottodirectory <path>examples</path> della
distribuzione CoLo.
</impo>

<pre caption="Configurazione basata sul menu">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
menu "Which Kernel?" 50 Working working New new
lcd "Loading Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Lo script sopra carica anche  <path>vmlinux.gz.new</path> o
<path>vmlinux.gz.working</path>, dipende dalla scelta. Se questa non è fatta
in 5 secondi, avvia la prima opzione.
</p>
</body>

</subsection>
</section>

<section>
<title>Impostare una console seriale</title>

<subsection>
<body>

<p>
Si assuma che si sia loggati in un terminale. Sulle macchine Cobalt non è una
cosa da fare.
</p>

<note>
Chi ha un framebuffer supportato può saltare questa sezione.
</note>

<p>
Si apra con un editor <path>/etc/inittab</path>. Si trova qualcosa come questo:
</p>

<pre caption="Configurazione inittab">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Non commentare la riga <c>c0</c>. Di default è impostata per usare un baud
rate terminale di 9600 bps. Sui server Cobalt, si potrebbe cambiarlo a 115200
per combinare il baud rate deciso dal BOOT ROM. Sui server Cobalt, si
raccomanda di commentare le righe locali del terminale (da <c>c1</c> a
<c>c6</c>) poichè non funzinano bene quando non possono aprire
<path>/dev/ttyX</path>.
</p>

<pre caption="Esempio da inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- These are useless on a headless qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Si deve dire al sistema che la porta locale seriale può essere considerata
come un terminale sicuro. Il file che si deve modificare è
<path>/etc/securetty</path>. Contiene un elenco di terminali sicuri per il
sistema. Si aggiungono due righe, e permette che la riga seriale sia usata
per i login da <c>root</c>.
</p>

<pre caption="Abilitare i login da root sulla console seriale">
<comment>(/dev/ttyS0 -- il nome per la prima porta seriale)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Linux la chiama anche /dev/tts/0 -- si aggiunge anche questo)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Riavviare il sistema</title>
<subsection>
<body>

<p>
Uscire dall'ambiente in cui si è fatto il chroot e smontare tutte le
partizioni montate. Poi digitare il comando <c>reboot</c>.
</p>

<pre caption="Uscire dal chroot, smontare tutte le partizioni e riavviare">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Utenti Cobalt:</e> Il resto di questo capitolo copre il setup per SGI PROM
in modo che avvi <c>arcboot</c> e carichi Linux. Non è applicabile al setup
per server Cobalt. Tutto quello che era necessario fare, è stato fatto -- non
c'è nessuna configurazione per il primo avvio, si può passare alla sezione
<uri link="?part=1&amp;chap=11">Termine dell'installazione Gentoo</uri>.
</note>

</body>
</subsection>
</section>
<section>
<title>Ottimizzare il SGI PROM</title>
<subsection>
<body>

<p>
Dopo aver riavviato, andare nel <e>System Maintenance Menu</e> e selezionare
<e>Enter Command Monitor</e> (<c>5</c>). Se si desidera fare un test della
nuova installazione Gentoo, eseguire <c>boot -f &lt;kernel name&gt;</c>. Per
ottenere un sistema che si avvii con Gentoo, si devono impostare alcune
variabili nel SGI PROM:
</p>

<pre caption="Configurare il PROM per avviare Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

<comment>(&lt;root device&gt; = partizione di root di Gentoo, per esempio /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>

<comment>(Per elencare i kernel disponibili, digitare "ls")</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>

<comment>(Dichiarare i parametri del kernel che si desiderano usare)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>

<comment>(Fornire la posizione dell'intestazione del volume)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Avviare automaticamente Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Impostare la timezone)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Usare la console seriale - gli utenti con adattatore grafico dovrebbero avere "g" invece di "d1" (uno))</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>

<p>
Ora si ha installato un sistema Gentoo. Avviare in Gentoo, e finire con <uri
link="?part=1&amp;chap=11">Termine dell'installazione Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
