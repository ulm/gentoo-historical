<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-mips-bootloader.xml,v 1.5 2006/03/13 21:29:42 so Exp $ -->

<sections>

<version>1.10</version>
<date>2006-02-27</date>

<section id="sgi">
<title>Macchine Silicon Graphics -- Impostare arcboot/arcload</title>
<subsection>
<title>Quale installare?</title>
<body>

<p>
Su sistemi SGI, si può scegliere tra due bootloaders. <c>arcboot</c> e
<c>arcload</c>. La tabella sotto elenca i pro e i contro di ognuno.
</p>

<table>
<tr>
  <th> </th>
	<th>arcboot</th>
</tr>
<tr>
  <th>+</th>
	 <ti>
	   Può caricare partizioni ext2 e ext3, e non c'è bisogno di immagazzinarle
		 nell'intestazione del volume
	 </ti>
</tr>
<tr>
  <th>-</th>
	<ti>
	  Non funziona su Octane/Octane2, Origin 200/2000 o
    Indigo2 Impact (R10000)
	</ti>
</tr>
</table>

<table>
<tr>
  <th> </th>
  <th>arcload</th>
</tr>
<tr>
  <th>+</th>
  <ti>
	  Avvia TUTTI i sistemi SGI Linux compatibili
	</ti>
</tr>
<tr>
  <th>-</th>
  <ti>
	  Non può leggere le partizioni ext2/ext3, e c'è bisogno che i kernel e i
		file di configurazione siamo posti nell'intestazione del volume
	</ti>
</tr>
</table>

<note>
I filename dell'intestazione del volume per SGI sono limitati a 8 caratteri,
e non ci possono essere più di 16 file contenuti in una intestazione di
volume.
</note>

</body>
</subsection>

<subsection>
<title>Installare arcboot</title>
<body>

<p>
In precedenza si è visto come installare un kernel e come copiarlo
nell'intestazione del volume con <c>dvhtool</c>. Ci sono però due difetti
proncipali seguendo questo sistema:
</p>

<ul>
  <li>Non è supportato su tutti i sistemi SGI</li>
  <li>Richiede una intestazione del volume più larga</li>
</ul>

<p>
Per avviare la macchina, è stato sviluppato un bootloader, <c>arcboot</c>.
Invece di mettere il kernel nell'intestazione del volume, lo si lascia in
<path>/boot</path> (dove risiede una partizione EXT2/3), e si dice a
<c>arcboot</c> (che si trova nell'intestazione del volume al posto del
kernel) dove trovarlo. Si emergano alcuni tool che saranno usati più avanti.
</p>

<pre caption="Installare i tool richiesti">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Si dovrebbe avere installati <c>arcboot</c> che si trova nell'intestazione
del volume e carica i kernel, e <c>dvhtool</c> che aiuta a mettere
<c>arcboot</c> nella intestazione del volume.
</p>

<p>
Il binario <c>arcboot</c> sta in <path>/usr/lib/arcboot</path>. Il nome del
binario dipende dal sistema su cui si sta installando.
</p>

<ul>
  <li>
		<c>arcboot.ip22</c>: Il binario per sistemi Indy, Indigo2 (R4k) e
		Challenge S
	</li>
  <li>
	  <c>arcboot.ip32</c>: Il binario per sistemi O2
	</li>
</ul>

<pre caption="Installare arcboot nell'intestazione del volume">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Si verifica la presenza del file nell'intestazione del volume.
</p>

<pre caption="Controllare la presenza di arcboot">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Ci sono due vecchi kernel, <path>linux</path> e <path>newlinux</path>, ma non
è un problema,l'importante è che ci sia <c>arcboot</c>.
</note>

<p>
Se si è gia usato <c>lilo</c>, si troverà che entrambi usano una sintassi
simile per la configurazione. <c>arcboot</c> si aspetta di trovare il suo
file di configurazione in una partizione EXT2/3 con il nome di
<path>/etc/arcboot.conf</path>. Assicurarsi che <path>/boot</path> sia EXT2/3
e che esista un file <path>arcboot.conf</path> in <path>/boot/etc</path>. Un
esempio di configurazione si trova in <path>/etc/arcboot.conf.sample</path>.
</p>

<note>
Sostituire il percorso se non si ha una partizione <path>/boot</path>
separata.
</note>

<pre caption="Inserire arcboot">
<comment>( Creare la directory /boot/etc )</comment>
# <i>mkdir /boot/etc</i>

<comment>( Copiare il file di configurazione )</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>( Creare un symlink a /etc )</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>( ... e un symlink che punta a se stesso )</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Si può modificare <path>/etc/arcboot.conf</path> in base alle proprie
preferenze. Qui si preferisce impostare due immagini di kernel:
<path>new</path> che può non funzionare e <path>working</path> che
sicuramente funziona. <path>arcboot.conf</path> sarà più o meno così.
</p>

<pre caption="Esempio di arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
<comment># versione funzionante</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># versione non testata</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Ci sono alcune ottimizzazioni da fare, e si trovano nella sezione <uri
link="#reboot">Riavviare il sistema</uri>.
</p>

</body>
</subsection>

<subsection>
<title>Installare arcload</title>
<body>

<p>
<c>arcload</c> è stato scritto per sistemi che richiedono kernel 64 bit, e
che quindi non possono usare <c>arcboot</c> (il quale non può facilmente
essere compilato come un binario 64 bit). Ha anche delle peculiarità che si
notano quando si caricano kernel dalla intestazione del volume. Si procede
con l'installazione:
</p>

<pre caption="Emergere arcload e dvhtool">
# <i>emerge arcload dvhtool</i>
</pre>

<p>
Si dovrebbe trovare il binario <c>arcload</c> in
<path>/usr/lib/arcload</path>. Ci sono due file:
</p>

<ul>
  <li>
		<c>sashARCS</c>: Il binario 32 bit per sistemi Indy, Indigo2 (R4k),
		Challenge S e O2
	</li>
  <li>
		<c>sash64</c>: Il binario 64 bit per sistemi Octane/Octane2, Origin
		200/2000 e Indigo2 Impact
	</li>
</ul>

<p>
Usare <c>dvhtool</c> per installare il binario appropriato al proprio sistema
nell'intestazione del volume:
</p>

<pre caption="Mettere arcload nell'intestazione del volume">
<comment>(Utenti Indy/Indigo2/Challenge S/O2)</comment>
# <i>dvhtool --unix-to-vh /usr/lib/arcload/sashARCS sashARCS</i>

<comment>(Utenti Indigo2 Impact/Octane/Octane2/Origin 200/Origin 2000)</comment>
# <i>dvhtool --unix-to-vh /usr/lib/arcload/sash64 sash64</i>
</pre>

<note>
Non si deve usare il nome <c>sashARCS</c> o <c>sash64</c> a meno che si sta
installando nell'intestazione del volume di un CD bootabile. Per boot normali
dall'hard disk si può nominarli in qualunque altro modo.
</note>

<p>
Usare <c>dvhtool</c> per verificare che siano nell'intestazione del volume.
</p>

<pre caption="Controllare che arcload sia presente nell'intestazione del volume">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "sash64", start 4, bytes 55859
#
</pre>

<p>
Il file <c>arc.cf</c> ha una sintassi simile a C. Per dettagli su come
configurarlo, vedere <uri
link="http://www.linux-mips.org/wiki/Arcload">pagina arcload su
Linux/MIPS wiki</uri>. In breve, si definisce un numero di opzioni, le quali
si abilitano e disabilitano al boot con la variabile <c>OSLoadFilename</c>.
</p>

<pre caption="Un esempio di arc.cf">
<comment># Configurazione ARCLoad</comment>

<comment># Alcune impostazioni di default...</comment>
append  "root=/dev/sda3";
append  "ro";
append  "console=ttyS0,9600";

<comment># Definizione principale.  ip28 può essere cambiato se lo si
desidera.</comment>
ip28 {
        <comment># Definizione per un kernel funzionante</comment>
        <comment># Selezionare questo impostando OSLoadFilename="ip28(working)"</comment>
        working {
                description     "SGI Indigo2 Impact R10000\n\r";
                image system    "/working";
        }

        <comment># Definizione per un kernel nuovo</comment>
        <comment># Selezionare questo impostando OSLoadFilename="ip28(new)"</comment>
        new {
                description     "SGI Indigo2 Impact R10000 - Testing Kernel\n\r";
                image system    "/new";
        }

        <comment># Per un kernel di debug</comment>
        <comment># Selezionare questo impostando OSLoadFilename="ip28(working,debug)"</comment>
        <comment># o OSLoadFilename="ip28(new,debug)"</comment>
        debug {
                description     "Debug console";
                append          "init=/bin/bash";
        }
}
</pre>

<p>
E' posto nell'intestazione del volume con <c>sash64</c> (o <c>sashARCS</c>)
come mostrato sotto. Anche i kernel sono posti nell'intestazione del volume.
</p>

<pre caption="Mettere arc.cf e kernel nell'intestazione del volume">
# <i>dvhtool --unix-to-vh arc.cf arc.cf</i>
# <i>dvhtool --unix-to-vh /usr/src/linux/vmlinux new</i>
</pre>

<p>
Quello che manca è impostare alcune opzioni nel PROM. Vedere la sezione <uri
link="#reboot">Riavviare il sistema</uri>.
</p>

</body>
</subsection>

</section>

<section id="cobalt">
<title>Cobalt MicroServer -- Impostare CoLo</title>
<subsection>
<title>Installare CoLo</title>
<body>

<p>
Sui server Cobalt, queste macchine hanno firmware meno capace installato sul
chip. Il Cobalt BOOTROM è primitivo rispetto al SGI PROM, ed ha alcuni
limiti.
</p>

<ul>
  <li>
		C'è un limite (approssimato) di 675kB sui kernel. Con l'attuale
		dimensione del 2.4, è impossibile fare un kernel di questa grandezza. Il
		2.6 non è proprio possibile considerarlo.
  </li>
  <li>
		I kernel 64-bit non sono supportati dal firmware di riserva (sebbene
		questi siano sperimentali sulle macchine Cobalt)
  </li>
  <li>
    La shell è di base nella maggior parte dei casi
  </li>
</ul>

<p>
Per superare questi limiti, è stato sviluppato un firmware alternativo, <uri
link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> (Cobalt Loader).
E' una immagine BOOTROM che può essere sia inserita nel chip del server
Cobalt, sia essere caricata dal firmware esistente.
</p>

<note>
In questo manuale si seguirà l'impostazione di CoLo in modo che sia caricato
dal firmware di riserva. Questo è l'unico modo per avere una impostazione
sicura e raccomandata.
</note>

<warn>
Si può inserirlo nel server, e rimettere il firmware originale -- lo si fa a
proprio rischio. Potrebbe non essere sbagliato, si dovrà rimuovere il BOOTROM
e riprogrammare con il firmware di riserva. Se non si sa cosa si sta facendo,
<e>NON</e> si deve esporre a possibili rotture la macchina. Non si ha nessuna
responsibilità se si ignora questo consiglio.
</warn>

<p>
Si inizia con emergere il pacchetto.
</p>

<pre caption="Emergere colo">
# <i>emerge colo</i>
</pre>

<p>
Si dovrebbe avere la directory <path>/usr/lib/colo</path> e in essa si
dovrebbero trovare due file, <path>colo-chain.elf</path> il kernel per il
firmware di riserva da caricare, e <path>colo-rom-image.bin</path> una
immagine ROM che si inserisce nel BOOTROM. Si monta /boot, si mette una copia
compressa di <path>colo-chain.elf</path> in <path>/boot</path> dove il
sistema si aspetta di trovarla.
</p>

<pre caption="Mettere CoLo al suo posto">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configurare CoLo</title>

<body>

<p>
Quando il sistema si avvia per la prima volta, caricherà CoLo con un menu
diviso in sezioni. La prima opzione (default è dopo 5 secondi) è il boot del
disco. Il sistema tenta di montare la prima partizione Linux che trova, e
esegue lo script <path>default.colo</path>. La sintassi è bene documentata
nella documentazione di CoLo (si dia una letta a
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path> -- dove X.YY è la
versione installata),e è molto semplice.
</p>

<note>
Solo un consiglio: quando si installano i kernel, è meglio creare due
immagini dei kernel, <path>kernel.gz.working</path> -- un kernel funzionante,
e <path>kernel.gz.new</path> -- un kernel appena compilato. Si possono usare
i symlink per puntare ai kernel "new" e "working", o rinominare le immagini
dei kernel.
</note>

<pre caption="default.colo di base">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo rifiuterà di caricare uno script che non inizia con la riga
<c>#:CoLo:#</c>. E' come se fosse l'equivalente di <c>#!/bin/sh</c> negli
scripts shell.
</note>

<p>
E' anche possibile chiedere quale kernel &amp; configurazione si preferisce
bootare, con timeout di default. Questa configurazione fa questo, chiedere
all'utente quale kernel desidera usare, e eseguire l'immagine scelta.
<path>vmlinux.gz.new</path> e <path>vmlinux.gz.working</path> possono essere
le immagini del kernel o symlink che puntano alle immagini del kernel su
questo disco. Il <c>50</c> di <c>select</c> specifica che dovrebbe procedere
con la prima opzione ("Working") dopo 50/10 secondi.
</p>

<pre caption="Configurazione basata sul menu">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
select "Which Kernel?" 50 Working New

goto {menu-option}
var image-name vmlinux.gz.working
goto 3f
@var image-name vmlinux.gz.working
goto 2f
@var image-name vmlinux.gz.new

@lcd "Loading Linux" {image-name}
load /{image-name}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Vedere la documentazione in <path>/usr/share/doc/colo-VERSION</path> per
più informazioni.

</p>

</body>

</subsection>
</section>

<section>
<title>Impostare una console seriale</title>

<subsection>
<body>

<p>
Si assuma che si sia loggati in un terminale. Sulle macchine Cobalt non è una
cosa da fare.
</p>

<note>
Chi ha un framebuffer supportato può saltare questa sezione.
</note>

<p>
Si apra con un editor <path>/etc/inittab</path>. Si trova qualcosa come questo:
</p>

<pre caption="Configurazione inittab">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Non commentare la riga <c>c0</c>. Di default è impostata per usare un baud
rate terminale di 9600 bps. Sui server Cobalt, si potrebbe cambiarlo a 115200
per combinare il baud rate deciso dal BOOT ROM. Sui server Cobalt, si
raccomanda di commentare le righe locali del terminale (da <c>c1</c> a
<c>c6</c>) poichè non funzinano bene quando non possono aprire
<path>/dev/ttyX</path>.
</p>

<pre caption="Esempio da inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- These are useless on a headless qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Si deve dire al sistema che la porta locale seriale può essere considerata
come un terminale sicuro. Il file che si deve modificare è
<path>/etc/securetty</path>. Contiene un elenco di terminali sicuri per il
sistema. Si aggiungono due righe, e permette che la riga seriale sia usata
per i login da <c>root</c>.
</p>

<pre caption="Abilitare i login da root sulla console seriale">
<comment>(/dev/ttyS0 -- il nome per la prima porta seriale)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Linux la chiama anche /dev/tts/0 -- si aggiunge anche questo)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Riavviare il sistema</title>
<subsection>
<body>

<p>
Uscire dall'ambiente in cui si è fatto il chroot e smontare tutte le
partizioni montate. Poi digitare il comando <c>reboot</c>.
</p>

<pre caption="Uscire dal chroot, smontare tutte le partizioni e riavviare">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Utenti Cobalt:</e> Il resto di questo capitolo copre il setup per SGI PROM
in modo che avvi <c>arcboot</c>/<c>arcload</c> e carichi Linux. Non è
applicabile al setup per server Cobalt. Tutto quello che era necessario fare,
è stato fatto -- non c'è nessuna configurazione per il primo avvio, si può
passare alla sezione <uri link="?part=1&amp;chap=11">Termine
dell'installazione Gentoo</uri>.
</note>

</body>
</subsection>
</section>
<section>
<title>Ottimizzare il SGI PROM</title>
<subsection>
<title>Impostazioni generiche PROM</title>
<body>

<p>
Il bootloader è installato, si è pronti per riavviare il sistema.
</p>

<pre caption="Riavviare">
<comment>(Uscire dall'ambiente in cui si è fatto il chroot)</comment>
# <i>exit</i>

<comment>(Fare unmount dei dischi)</comment>
# <i>umount /gentoo/boot</i>
# <i>umount /gentoo</i>

<comment>(Riavviare)</comment>
# <i>reboot</i>
</pre>

<p>
Dopo aver riavviato, andare nel <e>System Maintenance Menu</e> e selezionare
<e>Enter Command Monitor</e> (<c>5</c>) come quando si è fatto il netboot
al sistema.
</p>

<pre caption="Configurare il PROM per avviare Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

<comment>(Impostare alcune opzioni comuni per arcload e arcboot)</comment>

<comment>(Fornire la locazione dell'intestazione del volume)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Avviare automaticamente Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Impostare la timezone)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Usare la console seriale - utenti con adattatori grafici dovrebbero
avere "g" invece di "d1" (uno))</comment>
&gt;&gt; <i>setenv console d1</i>

<comment>(Impostare il baud rate della console seriale. Questo è opzionale,)
(9600 è il default, si può usare anche 38400.)</comment>
&gt;&gt; <i>setenv dbaud 9600</i>
</pre>

<p>
Le prossime impostazioni dipendono da come si sta avviando il sistema.
</p>

</body>
</subsection>

<subsection>
<title>Impostazioni per l'avvio diretto nell'intestazione del volume</title>
<body>

<p>
Si fa cenno a questo per completezza. E' raccomandato agli utenti di
installare <c>arcboot</c> o <c>arcload</c>.
</p>

<note>
Funziona solo su Indy, Indigo2 (R4k) e Challenge S.
</note>

<pre caption="Impostazioni PROM per avviare nell'intestazione del volume">
<comment>(&lt;root device&gt; = partizione di root di Gentoo, per esempio /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>

<comment>(Per elencare i kernel disponibili, digitare "ls")</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>

<comment>(Dichiarare i parametri del kernel che si desiderano usare)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>
</pre>

<p>
Se si desidera provare un kernel senza fare confusione con i parametri del
kernel, si può usare il comando PROM <c>boot -f</c>:
</p>

<pre caption="Avviare senza cambiare le variabili di ambiente">
<comment>(Avviare un kernel, nuovo, con altre opzioni)</comment>
# <i>boot -f new root=/dev/sda3 ro</i>
</pre>

</body>
</subsection>

<subsection>
<title>Impostazioni per arcload</title>
<body>

<p>
<c>arcload</c> usa l'opzione <c>OSLoadFilename</c> per specificare quale
opzione è da impostare da <path>arc.cf</path>. Il file di configurazione è
uno script, con i blocchi iniziali che definiscono le immagini di boot per
sistemi differenti, e dentro, le impostazioni opzionali. Così
<c>OSLoadFilename=mysys(serial)</c> si applica nelle impostazioni per il
blocco <c>mysys</c>, poi imposta varie opzioni escluse in <c>serial</c>.
</p>

<p>
Nel file di esempio già visto, si ha un blocco di sistema definito,
<c>ip28</c> con le opzioni disponibili <c>working</c>, <c>new</c> e
<c>debug</c>. Si definiscono le variabili di PROM così:
</p>

<pre caption="Impostazioni di PROM usando arcload">
<comment>(Selezionare arcload come bootloader:- sash64 o sashARCS)</comment>
&gt;&gt; setenv OSLoader sash64

<comment>(Usare l'immagine del kernel "working", definita nella sezione
"ip28" di arc.cf)</comment>
&gt;&gt; setenv OSLoadFilename ip28(working)
</pre>

</body>
</subsection>

<subsection>
<title>Impostazioni per arcboot</title>
<body>

<p>
<c>arcboot</c> carica i suoi file di configurazione e i kernel dalla
partizione <path>/boot</path>, che ha bisogno di essere formattata con ext2 o
ext3. <c>OSLoadPartition</c> deve puntare a questa partizione.
<c>OSLoader</c> dovrebbe puntare al binario <c>arcboot</c> nell'intestazione
del volume, e <c>OSLoadFilename</c> è il nome dell'immagine usata.
</p>

<pre caption="Impostazioni di PROM usando arcboot">
<comment>(Leggere la configurazione e kernel da SCSI ID# 1, partizione 0 -- sda1)</comment>
&gt;&gt; <i>setenv OSLoadPartition scsi(0)disk(1)rdisk(0)partition(0)</i>

<comment>(Usare arcboot come il bootloader)</comment>
&gt;&gt; <i>setenv OSLoader arcload</i>

<comment>(Quale immagine di boot caricare in arcboot.conf)</comment>
&gt;&gt; <i>setenv OSLoadFilename working</i>
</pre>

<p>
Quando si testano i kernel con <c>arcboot</c> si può specificare una immagine
alternativa (<c>new</c>):
</p>

<pre caption="Specificare una immagine alternativa">
# <i>boot new</i>
</pre>

</body>
</subsection>

<subsection>
<title>Tutto completato</title>
<body>

<p>
Ora si ha installato un sistema Gentoo. Avviare in Gentoo, e finire con <uri
link="?part=1&amp;chap=11">Termine dell'installazione Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
