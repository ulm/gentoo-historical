<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-mips-disk.xml,v 1.1 2004/12/16 20:46:10 mush Exp $ -->

<sections>

<version>1.6</version>
<date>2004-09-14</date>

<section>
<title>Introduzione ai dispositivi a blocchi</title>
<subsection>
<title>Dispositivi a blocchi</title>
<body>

<p>
Si dà ora un'occhiata approfondita agli aspetti relativi ai dischi in Gentoo Linux e in Linux in generale, tra cui i filesystem Linux, le partizioni e i dispositivi a blocchi. Quindi, una volta acquisita familiarità con i dischi e i filesystem, si viene guidati attraverso il processo di configurazione delle partizioni e dei filesystem per l'installazione di Gentoo Linux.
</p>

<p>
Per cominciare, si introducono i <e>dispositivi a blocchi</e>. Il dispositivo a blocchi più famoso è molto probabilmente quello che rappresenta il primo hard disk SCSI in un sistema Linux, <path>/dev/sda</path>.
</p>

<p>
I dispositivi a blocchi rappresentano un'interfaccia astratta ai dischi. I programmi utente possono usare questi dispositivi a blocchi per interagire con i dischi, senza doversi chiedere se si tratta di unità IDE, SCSI o di qualsiasi altro tipo. Il programma può semplicemente indirizzare la memorizzazione su disco attraverso dei blocchi contigui, accessibili in modalità random, e di dimensione pari a 512 byte ciascuno.
</p>

</body>
</subsection>
<subsection>
<title>Partizioni</title>
<body>

<p>
Nonostante sia possibile usare un intero disco per il sistema Linux, ciò non è quasi mai messo in pratica. Invece, i dispositivi a blocchi del disco sono divisi in parti più piccole e più maneggevoli. Queste parti sono chiamate <e>partizioni</e>.
</p>

</body>
</subsection>
</section>
<section>
<title>Impostare uno schema di partizionamento</title>
<subsection>
<title>Numero e dimensione delle partizioni</title>
<body>

<p>
Il numero delle partizioni è altamente dipendente sull'ambiente. Per esempio, se si hanno molti utenti su una stessa macchina, molto probabilmente si desidera tenere separate le directory <path>/home</path>, aumentando così la sicurezza e rendendo più facile il backup. Se si sta installando Gentoo per utilizzarlo da mailserver, <path>/var</path> dovrebbe essere separata poichè tutta la posta viene memorizzata in essa. Una buona scelta del filesystem è quella che massimizza le prestazioni. I gameserver è bene che abbiano una partizione separata per <path>/opt</path>, visto che la maggior parte dei server di gioco sono installati li. La stessa cosa vale per 
<path>/home</path>: sicurezza e backup.
</p>

<p>
Come si è visto, molto dipende da cosa si desidera realizzare. Partizioni o volumi separati hanno i seguenti vantaggi:
</p>

<ul>
<li>
  Si può scegliere il filesystem con maggiori prestazioni per ogni partizione o volume
</li>
<li>
  L'intero sistema non può esaurire lo spazio libero se un tool malfunzionante scrive all'infinito su una partizione od un volume
</li>
<li>
  Nel caso si rendano necessari, i controlli sul filesystem sono ridotti, poichè possono essere condotti in parallelo diverse analisi (questo vantaggio è più per i dischi multipli che per le partizioni multiple)
</li>
<li>
  La sicurezza può essere aumentata montando alcune partizioni o volumi in sola lettura, nosuid (i bit setuid vengono ignorati), noexec (i bit executable sono ignorati) etc.
</li>
</ul>

<p>
Le partizioni multiple hanno però un grosso svantaggio: se non sono configurate correttamente, si potrebbe avere un sistema con molto spazio libero su una partizione e poco su un'altra. C'è anche un limite di 15 partizioni per SCSI e SATA.
</p>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su MIPS per partizionare il disco</title>
<subsection>
<title>Creare un SGI Disk Label</title>
<body>

<p>
Tutti i dischi in un sistema SGI richiedono un <e>SGI Disk Label</e>, che serve per una funzione simile a quella di Sun &amp; MS-DOS disklabels -- Memorizza informazioni sulle partizioni dei dischi. Con la crezione di un nuovo SGI Disk Label si creeranno due partizioni speciali sul disco:
</p>

<ul>
  <li>
    <e>Intestazione del volume SGI</e> (9na partizione): Questa partizione è importante. E' dove ci sarà l'immagine del kernel. Per memorizzare le immagini del kernel, si userà il tool <c>dvhtool</c>, per copiarle in quella partizione. Sarà possibile avviare i kernel da questa partizione con il SGI PROM Monitor.
   </li>
   <li>
     <e>Volume SGI</e> (11ma partizione): Questa partizione è simile nello scopo alla terza partizione del Sun Disklabel di "Whole Disk". Questa partizione occupa l'intero disco, e non dovrebbe essere toccata. Non ha uno scopo speciale, tranne quello di aiutare il PROM in qualche modo non documentato (o è usata da IRIX).
   </li>
</ul>

<warn>
L'intestazione del volume SGI <e>deve</e> iniziare al cilindro 0. Altrimenti non si potrà fare il boot dal disco.
</warn>

<p>
Il seguente, è un esempio preso da <c>fdisk</c>. Dopo averlo letto, addattarlo in base alle proprie necessità.
</p>

<pre caption="Creare un SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Se il disco ha già un SGI Disklabel, allora fdisk non creerà una nuova label. Ci sono due modi per evitare questo. Il primo è quello di creare un Sun o MS-DOS disklabel, scrivere i cambiamenti sul disco, e far ripartire fdisk. Il secondo è quello di sovrascrivere la tabella di partizioni con dati vuoti, con il seguente comando: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Ottenere l'intestazione del volume SGI della giusta dimensione</title>
<body>

<p>
Ora che è creato il SGI Disklabel, le partizioni devono essere definite. Nell'esempio sopra, ci sono già due partizioni definite. Ci sono le partizioni speciali che non dovrebbero essere cambiate. Tuttavia, per installare Gentoo, si ha bisogno di caricare immagini del kernel multiple direttamente nell'intestazione del volume, poichè ancora non c'è nessun bootloader SGI disponibile in Portage. L'intestazione del volume può contenere <e>otto</e> immagini di ogni grandezza, un'immagine può avere un nome di otto caratteri.
</p>

<p>
Il processo di rendere più larga l'intestazione del volume non è esattamente diretto -- c'è un piccolo trucco per farlo. Non si può cancellare e riaggiungere l'intestazione del volume con fdisk. Nell'esempio sotto, si creerà un'intestazione del volume di 50MB insieme a una partizione di boot di 50MB. La disposizione del proprio disco può variare, ma l'esempio è solo a scopo illustrativo.
</p>

<pre caption="Ridurre l'intestazione del volume SGI">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Notare come fdisk permetta solo che la Partizione #1 sia ricreata cominciando come minimo dal cilindro 5)</comment>
<comment>(Si tenta di cancellare &amp; ricreare l'intestazione del volume SGI, è lo stesso problema che si sarebbe incontrato.)</comment>
<comment>(Nell'esempio, si desidera che /boot sia di 50MB, così si comincia al cilindro 51 (si ricordi che l'intestazione del volume deve iniziare al cilindro 0), e si imposta il cilindro finale a 101, che saranno approssimativamente 50MB (con uno scarto di 1-5MB))</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Cancellare la Partizione #9 (intestazione del volume SGI))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Ricreare la Partizione #9, finendo prima della Partizione #1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Disposizione finale delle partizioni</title>
<body>

<p>
Si può creare il resto delle partizioni, dato che se ne vede la grandezza. Dopo che tutte le partizioni sono create, assicurarsi che la partizione swap sia su <c>82</c>, Linux Swap. Di default, è <c>83</c>, Linux Native.
</p>

<p>
Ora che le partizioni sono create, si può continuare con la sezione riguardante come <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Creare i filesystem</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Ora che le partizioni sono state create, è il momento di inserire il filesystem. Se non si è interessati alla scelta del filesystem e vanno bene quelli che si usano di default in questo Manuale, continuare con la sezione su come <uri link="#filesystems-apply">Applicare un filesystem a una partizione</uri>. Altrimenti ecco una descrizione dei filesystem disponibili.
</p>

</body>
</subsection>
<subsection>
<title>Filesystem</title>
<body>

<p>
Sono disponibili molti filesystem. Ext2 e ext3 sono stabili sull'architettura MIPS, gli altri sono sperimentali.
</p>

<p>
<b>ext2</b> è il vero e proprio filesystem di Linux ma non possiede il supporto per il metadata journaling, il che significa che le routine che effettuano all'avvio i controlli sul filesystem ext2 possono impiegare diverso tempo. Al momento esiste una scelta abbastanza ampia di filesystem journaled di nuova generazione che sono in grado di effettuare controlli sulla consistenza molto velocemente e sono generalmente preferiti alle controparti non-journaled. I filesystem journaled prevengono i lunghi tempi di attesa che solitamente si riscotrano quando viene riavviato il sistema e il filesystem si trova in uno stato inconsistente.
</p>

<p>
<b>ext3</b> è la versione journaled del filesystem ext2, fornisce il metadata journaling per un veloce recupero dei dati in aggiunta ad altre caratteristiche di journaling avanzate come full data e ordered data journaling. ext3 è un filesystem davvero molto valido e affidabile. Ha un ulteriore opzione di indice hashed b-tree che abilita alte prestazioni in quasi tutte le situazioni. In poche parole, ext3 è un filesystem eccellente.
</p>

<p>
<b>ReiserFS</b> è un filesystem basato su B*-tree che offre ottime performance generali e si dimostra notevolmente superiore a ext2 e ext3 con file di piccole dimensioni (file minori di 4k), spesso di un fattore 10-15. ReiserFS scala inoltre molto bene e supporta il metadata journaling. Dal kernel 2.4.18 in poi, ReiserFS ha raggiunto la solidità che lo porta a essere caldamente raccomandato sia per un uso generico che per casi estremi come la creazione di grandi filesystem, l'uso su molti file piccoli, file molto grandi e directory contenenti decine di migliaia di file.
</p>

<p>
<b>XFS</b> è un filesystem con metadata journaling che si presenta con un robusto insieme di caratteristiche ed è ottimizzato per la scalabilità. Se ne raccomanda l'uso su sistemi Linux dotati di unità di memorizzazione con canali in fibra o high-en SCSI e alimentazione continua. Data l'aggressività con la quale XFS si serve della cache in RAM per i dati in transito, programmi progettati in modo non adeguato (quelli che non prendono precauzioni quando scrivono file su disco, e ce ne sono diversi) possono perdere una discreta quantità di dati se il sistema si arresta in modo inaspettato.
</p>

<p>
<b>JFS</b> è il filesystem con journaling ad alte prestazioni di IBM. E' stato recentemente giudicato pronto per il mercato, ma ad oggi non è stato sufficientemente testato per fare commenti positivi o negativi sulla sua stabilità generale.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Applicare un filesystem a una partizione</title>
<body>

<p>
Per creare un filesystem su una partizione o volume, sono disponibili tool per ogni filesystem possibile:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Comando per la creazione</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Per esempio, per avere la partizione di boot (<path>/dev/sda1</path>) ext2 e la partizione root (<path>/dev/sda3</path>) ext3, si usa:
</p>

<pre caption="Applicare un filesystem su una partizione">
# <i>mke2fs /dev/sda1</i>
# <i>mke2fs -j /dev/sda3</i>
</pre>

<p>
Ora si procede alla creazione dei filesystem sulle partizioni (o volumi logici) create precedentemente.
</p>

</body>
</subsection>
<subsection>
<title>Attivare la partizione swap</title>
<body>

<p>
<c>mkswap</c> è il comando usato per inizializzare le partizioni swap:
</p>

<pre caption="Inizializzare la partizione swap">
# <i>mkswap /dev/sda2</i>
</pre>

<p>
Per attivare la partizione swap, usare <c>swapon</c>:
</p>

<pre caption="Attivare la partizione swap">
# <i>swapon /dev/sda2</i>
</pre>

<p>
Creare e attivare swap subito.
</p>

</body>
</subsection>
</section>
<section>
<title>Montare</title>
<body>

<p>
Ora che le partizioni sono inizializzate e hanno un filesystem, è il momento di montarle. Usare il comando <c>mount</c>. Non dimenticarsi di creare le necessarie directory di mount per ogni partizione creata. Come esempio si monta la partizione root e boot:
</p>

<pre caption="Montare le partizioni">
# <i>mount /dev/sda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/sda1 /mnt/gentoo/boot</i>
</pre>

<note>
Se si vuole che <path>/tmp</path> risieda in una partizione separata, assicurarsi di cambiare i permessi dopo il mount: <c>chmod 1777 /mnt/gentoo/tmp</c>. Questo vale anche per <path>/var/tmp</path>.
</note>

<p>
E' necessario inoltre montare il filesystem proc (una intefaccia virtuale con il kernel) su <path>/proc</path>. Ma prima si devono mettere i file sulle partizioni.
</p>

<p>
Ora continuare con la <uri link="?part=1&amp;chap=5">Copia dei file di installazione di Gentoo</uri>.
</p>

</body>
</section>
</sections>
