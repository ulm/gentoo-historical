<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<sections>
<section>
<title>Informazioni sul filesystem</title>
<subsection>
<title>Cos'è fstab?</title>
<body>

<p>
Con Linux, tutte le partizioni usate dal sistema devono essere elencate in <path>/etc/fstab</path>. Questo è un file che contiene i mountpoints di quelle partizioni (dove sono viste nella struttura del filesystem), come dovrebbero essere montate (opzioni speciali), e quando (automaticamente o meno, se gli utenti possono montarle o meno, etc.).
</p>

</body>
</subsection>
<subsection>
<title>Creare /etc/fstab</title>
<body>

<p>
<path>/etc/fstab</path> usa una sintassi speciale. Ogni riga contiene sei parti, separate da uno spazio (spazio, tabs o entrambi). Ogni parte ha un significato:
</p>

<ul>
<li>
  La prima parte mostra la <b>partizione</b> (il percorso al file dev)
</li>
<li>
  La seconda parte mostra i <b>mountpoint</b>, nei quali dovrebbe essere montata la partizione
</li>
<li>
  La terza parte mostra il <b>filesystem</b> usato dalla partizione
</li>
<li>
  La quarta parte mostra le <b>opzioni di mount</b>, usate da <c>mount</c> quando monta la partizione. Poichè ogni filesystem ha le proprie opzioni di mount, è consigliato leggere la manpage di mount per una lista completa (<c>man mount</c>). Se ci sono varie opzioni di mount, esse sono separate da una virgola.
</li>
<li>
  La quinta parte è usata da <c>dump</c> per determinare se la partizione necessita dell'operazione di <b>dump</b> o no. Si può lasciarla come <c>0</c>.
</li>
<li>
  La sesta parte è usata da <c>fsck</c> per determinare l'ordine in cui dovrebbero essere <b>controllati</b> i filesystem, se il sistema non si è chiuso correttamente. Il filesystem di root dovrebbe avere <c>1</c>, mentre gli altri filesystem dovrebbero avere <c>2</c> (o <c>0</c> se non è necessario un controllo del filesystem).
</li>
</ul>

<p>
Aprire nano (o l'editor favorito) per creare <path>/etc/fstab</path>:
</p>

<pre caption="Aprire /etc/fstab">
# <i>nano -w /etc/fstab</i>
</pre>

<p>
Si guardi a come è scritta l'opzione per la partizione di <path>/boot</path>. Qusto è solo un esempio, se la propria architettura non richiede una partizione di <path>/boot</path>, non copiarla.
</p>

<p>
Nell'esempio, la partizione di <path>/boot</path> di una architettura x86, è la partizione <path>/dev/hda1</path>, e <c>ext2</c> è il filesystem. Non dovrebbe essere montata automaticamente (<c>noauto</c>), e non ha bisogno di essere controllata. Si scriverà:
</p>

<pre caption="Esempio di /boot per /etc/fstab">
/dev/hda1   /boot     ext2    noauto        1 2
</pre>

<p>
Per migliorare la performance, la maggior parte degli utenti potrebbe volere aggiungere l'opzione <c>noatime</c> come opzione di mount, con cui si ottiene un sistema più veloce, poichè i tempi di accesso non sono registrati (non c'è comunque bisogno dei tempi di accesso):
</p>

<pre caption="Esempio migliorato di /boot per /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
</pre>

<p>
Continuando, si inseriscono le seguenti tre righe (per <path>/boot</path>, <path>/</path> e per la partizione swap):
</p>

<pre caption="Tre righe per /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1
</pre>

<p>
Per finire, si dovrebbe aggiungere una regola per <path>/proc</path>, <c>tmpfs</c> (richiesto) e per il CD-ROM drive (e, se si hanno, anche per altre partizioni o drive):
</p>

<pre caption="Esempio completo di /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1

none        /proc     proc    defaults          0 0
none        /dev/shm  tmpfs   defaults          0 0

/dev/cdroms/cdrom0    /mnt/cdrom    auto      noauto,user    0 0
</pre>

<p>
<c>auto</c> presuppone il <c>mount</c> per il filesystem (raccomandato per i media rimovibili poichè possono essere creati con molti filesystem), e <c>user</c> rende possibile, per gli utenti che non hanno il privilegio di root, montare il CD.
</p>

<p>
Usare l'esempio sopra per creare il proprio <path>/etc/fstab</path>. Se si è utenti SPARC, si dovrebbe aggiungere la seguente riga:
</p>

<pre caption="Aggiungere il filesystem openprom a /etc/fstab">
none        /proc/openprom  openpromfs    defaults      0 0
</pre>

<p>
Se si ha bisogno di <c>usbfs</c>, aggiungere la seguente riga:
</p>

<pre caption="Aggiungere il filesystem usbfs a /etc/fstab">
none        /proc/bus/usb   usbfs         defaults      0 0
</pre>

<p>
Rileggere con attenzione <path>/etc/fstab</path>, salvarlo e uscire per continuare.
</p>

</body>
</subsection>
</section>
<section>
<title>Informazioni di rete</title>
<subsection>
<title>Hostname, Domainname etc.</title>
<body>

<p>
Una delle scelte che l'utente deve fare, è quella di dare un nome al proprio PC. Sembra facile, ma <e>molti</e> utenti hanno delle difficoltà nel trovare il nome appropriato per il loro Linux-pc. Per velocizzare le cose, si sappia che qualsiasi nome si scelga, si può in seguito cambiarlo. Si può chiamare il sistema <c>tux</c> e il dominio <c>homenetwork</c>.
</p>

<p>
Nel prossimo esempio, si usano questi due nomi. Per prima cosa settiamo hostname:
</p>

<pre caption="Settare hostname">
# <i>echo tux &gt; /etc/hostname</i>
</pre>

<p>
Poi settiamo il domainname:
</p>

<pre caption="Settare domainname">
# <i>echo homenetwork &gt; /etc/dnsdomainname</i>
</pre>

<p>
Se si ha un dominio NIS (se non si sa cos'è, allora non lo si ha), si deve definire anche quello:
</p>

<pre caption="Settare NIS domainname">
# <i>echo nis.homenetwork &gt; /etc/nisdomainname</i>
</pre>

<p>
Ora aggiungere lo script <c>domainname</c> al runlevel di default:
</p>

<pre caption="Aggiungere domainname al runlevel di default">
# <i>rc-update add domainname default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Configurare la rete</title>
<body>

<p>
Si dovrebbe ricordare che la configurazione della rete, fatta inizialmente, era solo per l'installazione di Gentoo. Adesso si dovrà configurarla per il sistema Gentoo in funzione.
</p>

<p>
Tutte le informazioni di rete sono raccolte in <path>/etc/conf.d/net</path>. Questo file usa una sintassi diretta e non molto intuitiva per chi non sa installare la rete manualmente. Ma qui si spiegherà tutto.
</p>

<p>
Per prima cosa aprire <path>/etc/conf.d/net</path> con l'editor favorito (in questo esempio si usa <c>nano</c>):
</p>

<pre caption="Aprire /etc/conf.d/net per editarlo">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
La prima variabile che si incontra è <c>iface_eth0</c>. Essa usa la seguente sintassi:
</p>

<pre caption="Sintassi di iface_eth0">
iface_eth0="<i>&lt;your ip address&gt;</i> broadcast <i>&lt;your broadcast address&gt;</i> netmask <i>&lt;your netmask&gt;</i>"
</pre>

<p>
Se si usa DHCP (recupero automatico dell'IP), si dovrebbe settare <c>iface_eth0</c> a <c>dhcp</c>. Se si usa rp-pppoe (per esempio, per ADSL), settarlo a <c>up</c>. Se si deve installare la rete manualmente e questi termini non sono familiari, è consigliata, se non è stata gia fatta, la lettura di <uri link="?part=1&amp;chap=3#doc_chap4_sect3">Comprendere la Terminologia della Rete</uri>.
</p>

<p>
Seguono due esempi: nel primo si usa DHCP; nel secondo un IP statico 192.168.0.2, netmask 255.255.255.0, broadcast 192.168.0.255 e gateway 192.168.0.1:
</p>

<pre caption="Esempi per /etc/conf.d/net">
<comment>(Per DHCP:)</comment>
iface_eth0="dhcp"

<comment>(Per IP statico:)</comment>
iface_eth0="192.168.0.2 broadcast 192.168.0.255 netmask 255.255.255.0"
gateway="eth0/192.168.0.1"
</pre>

<p>
Se si hanno molte interfacce di rete, si devono creare variabili extra di <c>iface_eth</c>, come <c>iface_eth1</c>, <c>iface_eth2</c> etc. La variabile <c>gateway</c> non deve essere riscritta, poichè si può settare un solo gateway per computer.
</p>

<p>
Salvare la configurazione e uscire per continuare.
</p>

</body>
</subsection>
<subsection>
<title>Far partire automaticamente la rete al boot</title>
<body>

<p>
Per attivare le interfacce di rete al boot, si deve aggiungerle al runlevel di default. Se si hanno le interfacce PCMCIA, si può saltare questa azione, poichè si fanno partire dallo init script PCMCIA.
</p>

<pre caption="Aggiungere net.eth0 al runlevel di default">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
Se si hanno molte interfacce di rete, si devono creare gli initscripts per <path>net.eth1</path>, <path>net.eth2</path> etc. Si può usare <c>ln</c> per farlo:
</p>

<pre caption="Creare gli initscripts extra">
# <i>cd /etc/init.d</i>
# <i>ln -s net.eth0 net.eth1</i>
# <i>rc-update add net.eth1 default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Scrivere le informazioni di rete</title>
<body>

<p>
Si devono far vedere a Linux le informazioni sulla propria rete. Queste si trovano in <path>/etc/hosts</path>, e aiutano a risolvere gli hostnames agli indirizzi IP, per gli host che non sono risolti dal nameserver. Per esempio, se la rete interna consiste di tre PC, chiamati <c>jenny</c> (192.168.0.5), <c>benny</c> (192.168.0.6) e <c>tux</c> (192.168.0.7), si dovrebbe aprire <path>/etc/hosts</path> e inserire questi valori:
</p>

<pre caption="Aprire /etc/hosts">
# <i>nano -w /etc/hosts</i>
</pre>

<pre caption="Inserire le informazioni di rete">
127.0.0.1     localhost
192.168.0.5   jenny
192.168.0.6   benny
192.168.0.7   tux
</pre>

<p>
Se è presente un solo sistema (o i nameserver hanno tutte le risoluzioni), è sufficiente una sola riga:
</p>

<pre caption="/etc/hosts per un solo PC o per un PC totalmente integrato">
127.0.0.1     localhost   tux
</pre>

<p>
Salvare e uscire per continuare
</p>

<p>
Se non si ha PCMCIA, si può continuare con <uri link="#doc_chap3">Informazione del sistema</uri>. Coloro che hanno PCMCIA dovrebbero leggere la parte seguente.
</p>

</body>
</subsection>
<subsection>
<title>Opzionale: Far funzionare PCMCIA</title>
<body>

<p>
Gli utenti PCMCIA dovrebbero installare il pacchetto <c>pcmcia-cs</c>:
</p>

<pre caption="Installare pcmcia-cs">
# <i>emerge --usepkg pcmcia-cs</i>
</pre>

<p>
Dopo aver installato <c>pcmcia-cs</c>, aggiungere <c>pcmcia</c> al runlevel di <e>default</e>:
</p>

<pre caption="Aggiungere pcmcia al runlevel di default">
# <i>rc-update add pcmcia default</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Informazioni sul sistema</title>
<body>

<p>
Gentoo usa <path>/etc/rc.conf</path> per una generale configurazione del sistema. Aprire <path>/etc/rc.conf</path> per vedere cosa c'è nel file.
</p>

<pre caption="Aprire /etc/rc.conf">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
Come si può vedere, questo file contiene le variabili di configurazione. Si guardi con attenzione <c>KEYMAP</c>: se è selezionato in maniera sbagliata, si avranno dei problemi quando si userà la tastiera.
</p>

<note>
Gli utenti di sistemi SPARC basati su USB e cloni SPARC, dovrebbero selezionare una tastiera i386 (come "us"), invece di "sunkeymap".
</note>

<p>
Dopo aver finito di configurare <path>/etc/rc.conf</path>, salvare e uscire, e continuare con <uri link="?part=1&amp;chap=9">Configurazione del Bootloader</uri>.
</p>

</body>
</section>
</sections>
