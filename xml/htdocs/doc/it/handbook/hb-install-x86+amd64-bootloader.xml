<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/handbook/hb-install-x86+amd64-bootloader.xml,v 1.6 2007/07/11 21:35:25 scen Exp $ -->

<sections>

<version>5.0</version>
<date>2007-05-07</date>

<section>
<title>La scelta</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Dopo aver configurato e compilato il kernel e inserito i necessari file di
configurazione, è venuto il momento di installare il programma che esegue il
kernel nel momento in cui si avvia il sistema. Tale programma è chiamato
<e>bootloader</e>.
</p>

<p test="func:keyval('arch')='x86'">
Per la piattaforma x86, Gentoo Linux fornisce <uri link="#grub">GRUB</uri> e
<uri link="#lilo">LILO</uri>.
</p>

<p>
Ma prima di installare uno di questi due bootloader ecco come configurare il
framebuffer (nel caso lo si desideri ovviamente). Con il framebuffer è possibile
eseguire la linea di comando Linux con alcune caratteristiche grafiche (come lo
sfondo che viene fornito da Gentoo).
</p>

</body>
</subsection>
<subsection>
<title>Opzionale: Framebuffer</title>
<body>

<p>
<e>Se</e> il kernel è stato configurato con supporto al framebuffer (o è stato
utilizzata la configurazione predefinita di <c>genkernel</c>), è possibile
attivarne l'utilizzo aggiungendo una opzione <c>vga</c> e/o <c>video</c> al file
di configurazione del bootloader.
</p>

<p test="func:keyval('arch')='x86'">
Innanzitutto è necessario sapere che tipo di periferica framebuffer si sta
utilizzando. Se si utilizza uno dei kernel patchati Gentoo (come
<c>gentoo-sources</c>) si ha la possibilità di scegliere <c>vesafb-tng</c> come
<e>VESA driver type</e> (l'impostazione predefinita per questo genere di
kernel). In questo caso si sta utilizzando <c>vesafb-tng</c> e non è necessario
impostare l'opzione <c>vga</c>. In caso contrario, se si sta utilizzando il
driver <c>vesafb</c> è <e>importante</e> impostare la variabile <c>vga</c>.
</p>

<p test="contains('AMD64 IA64',func:keyval('arch'))">
I sistemi a 64-bit devono usare il driver <c>vesafb</c> e necessitano
dell'impostazione della variabile <c>vga</c>.
</p>

<p>
L'opzione <c>vga</c> controlla la risoluzione ed il numero di colori dello
schermo framebuffer per <c>vesafb</c>. Come descritto in
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path> (che viene installato
insieme al pacchetto del kernel), è necessario passare il numero VESA
corrispondente alla risoluzione ed ai colori richiesti.
</p>

<p>
La seguente tabella elenca le risoluzioni ed i colori disponibili e li incrocia
sul numero da passare come opzione <c>vga</c>.
</p>

<table>
<tr>
  <ti></ti>
  <th>640x480</th>
  <th>800x600</th>
  <th>1024x768</th>
  <th>1280x1024</th>
</tr>
<tr>
  <th>256</th>
  <ti>0x301</ti>
  <ti>0x303</ti>
  <ti>0x305</ti>
  <ti>0x307</ti>
</tr>
<tr>
  <th>32k</th>
  <ti>0x310</ti>
  <ti>0x313</ti>
  <ti>0x316</ti>
  <ti>0x319</ti>
</tr>
<tr>
  <th>64k</th>
  <ti>0x311</ti>
  <ti>0x314</ti>
  <ti>0x317</ti>
  <ti>0x31A</ti>
</tr>
<tr>
  <th>16M</th>
  <ti>0x312</ti>
  <ti>0x315</ti>
  <ti>0x318</ti>
  <ti>0x31B</ti>
</tr>
</table>

<p>
L'opzione <c>video</c> controlla i parametri del framebuffer. Necessita di avere
il driver del framebuffer (<c>vesafb</c> per i kernel 2.6, o <c>vesa</c> per i
2.4) seguito dalle impostazioni da abilitare. Tutte le impostazioni attivabili
sono elencate in <path>/usr/src/linux/Documentation/fb/vesafb.txt</path>. Quelle
più utilizzate sono:
</p>

<table>
<tr>
  <th>Parametro</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>ywrap</ti>
  <ti>
    Assume che la scheda grafica possa accedere circolarmente alla memoria e
    continuare dall'inizio una volta arrivati alla fine
  </ti>
</tr>
<tr>
  <ti>mtrr:n</ti>
  <ti>
    Imposta i registri MTRR. <c>n</c> può essere:<br/>
      0 - disabled<br/>
      1 - uncachable<br/>
      2 - write-back<br/>
      3 - write-combining<br/>
      4 - write-through
  </ti>
</tr>
<tr test="func:keyval('arch')='x86'">
  <ti><c>mode</c></ti>
  <ti>
    (solo <c>vesafb-tng</c>)<br/>
    Imposta la risoluzione, il numero di colori e la frequenza di refresh. Ad
    esempio <c>1024x768-32@85</c> per una risoluzione di 1024x768, 32 bit di
    colori e una frequenza di refresh di 85 Hz.
  </ti>
</tr>
</table>

</body>
<body test="contains('AMD64 IA64',func:keyval('arch'))">

<p>
Il risultato di queste due impostazioni può essere del tipo <c>vga=0x318
video=vesafb:mtrr:3,ywrap</c>. E' importante ricordare questa riga perchè sarà
utile in seguito.
</p>

<p test="func:keyval('arch')='AMD64'">
Mentre LILO funziona su AMD64, Gentoo supporta solo l'utilizzo di GRUB.
Continuare ora con l'<uri link="#grub">installazione</uri> di GRUB.
</p>

<p test="func:keyval('arch')='IA64'">
Ora è necessario installare <uri link="#elilo">bootloader elilo</uri>.
</p>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Il risultato di queste due impostazioni può essere del tipo <c>vga=0x318
video=vesafb:mtrr,ywrap</c> o <c>video=vesafb:mtrr,ywrap,1024x768-32@85</c>.
E' importante ricordare questa riga perchè sarà utile in seguito.
</p>

<p>
Continuare ora con l'installazione di <uri link="#grub">GRUB</uri> <e>o</e> <uri
link="#lilo">LILO</uri>.
</p>

</body>
</subsection>
</section>

<section id="grub" test="contains('AMD64 x86',func:keyval('arch'))">
<title>Predefinito: Usare GRUB</title>
<subsection>
<title>Comprendere la terminologia di GRUB</title>
<body>

<p>
La parte più critica da capire di GRUB, è quella nella quale si deve prendere
confidenza con il modo in cui GRUB si riferisce ai dischi e alle partizioni. La
partizione di Linux <path>/dev/hda1</path> (per le periferiche IDE) o
<path>/dev/sda1</path> (per le periferiche SATA/SCSI) è probabilmente chiamata
da GRUB <path>(hd0,0)</path>. Prestare attenzione alle parentesi intorno ad
<path>hd0,0</path>, sono necessarie.
</p>

<p>
I dischi vengono contati da zero invece che da "a", e le partizioni partono da
zero invece che da uno. Prestare ancora attenzione al fatto che tra le
periferiche hd vengono inclusi solo gli hard disk e non le periferiche atapi-ide
come i lettori cdrom e i masterizzatori. Lo stesso vale per i dischi SCSI.
(Normalmente questi prendono numeri più alti rispetto a quelli ide, eccetto
quando il bios è configurato per fare il boot dai dischi SCSI.) Quando si
imposta il BIOS per fare boot da un disco diverso (ad esempio il primary slave)
<e>quel</e> disco viene visto come <path>hd0</path>.
</p>

<p>
Avendo quindi un hard disk in <path>/dev/hda</path>, un lettore cdrom in
<path>/dev/hdb</path>, un masterizzatore in <path>/dev/hdc</path>, un secondo
hard disk in <path>/dev/hdd</path> e nessun disco SCSI, <path>/dev/hdd7</path>
viene trasformato in <path>(hd1,6)</path>. Potrebbe suonare complicato e lo è in
effetti, ma come si vedrà, GRUB offre un meccanismo di completamento con il
tasto TAB che si dimostra comodo per coloro che hanno un numero elevato di hard
disk e partizioni, e per coloro che sono a disagio con lo schema numerico di
GRUB.
</p>

<p>
Dopo essere entrati nello spirito è il momento di installare GRUB.
</p>

</body>
</subsection>
<subsection>
<title>Installare GRUB</title>
<body>

<p>
Per installare GRUB, si deve prima emergerlo:
</p>

<impo test="func:keyval('arch')='AMD64'">
Se si sta utilizzando un <uri link="?part=1&amp;chap=6#doc_chap2">profilo</uri>
non multilib, <b>not</b> installare grub, ma installare <c>grub-static</c>.
</impo>

<pre caption="Installare GRUB">
# <i>emerge grub</i>
</pre>

<p>
Nonostante GRUB sia installato, si deve ancora modificare un file di
configurazione perchè GRUB venga installato nel MBR in modo che possa avviare il
nuovo kernel. Creare <path>/boot/grub/grub.conf</path> con <c>nano</c> (o con un
altro editor):
</p>

<pre caption="Creare /boot/grub/grub.conf">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
Ora è necessario modificare <path>grub.conf</path>. Seguono due possibili
<path>grub.conf</path> per l'esempio di partizione usato in questa guida. Viene
però analizzato a fondo solo il primo <path>grub.conf</path>. Assicurarsi di
personalizzare le impostazioni indicando la propria immagine del kernel e il
proprio initrd.
</p>

<ul>
  <li>
    Il primo <path>grub.conf</path> è per chi non ha usato <c>genkernel</c> per
    compilare il kernel
  </li>
  <li>Il secondo <path>grub.conf</path> è per chi ha usato <c>genkernel</c></li>
</ul>

<note>
Se il proprio filesystem root è JFS è <e>necessario</e> aggiungere "ro" alla
linea <c>kernel</c> perchè JFS ha bisogno di esaminare il proprio log prima di
concedere il mount in scrittura.
</note>

<pre caption="grub.conf per utenti che non hanno usato genkernel">
<comment># Quale opzione viene avviata in modo predefinito. 0 è la prima, 1 la seconda, ecc.</comment>
default 0
<comment># Quanti secondi attenedere prima di avviare l'opzione predefinita.</comment>
timeout 30
<comment># Un'immagine gradevole
# Da commentare se non si dispone di scheda grafica</comment>
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux <keyval id="kernel-version"/>
<comment># La partizione dove si trova l'immagine del kernel (o il sistema operativo)</comment>
root (hd0,0)
kernel /boot/<keyval id="kernel-name"/> root=/dev/hda3

title=Gentoo Linux <keyval id="kernel-version"/> (rescue)
<comment># Partizione dove si trova l'immagine del kernel o il sistema operativo</comment>
root (hd0,0)
kernel /boot/<keyval id="kernel-name"/> root=/dev/hda3 init=/bin/bb

<comment># Le prossime tre righe vanno messe solo se si ha un dualboot con Windows.</comment>
<comment># In questo caso, Windows è in /dev/hda6.</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<pre caption="grub.conf per utenti che hanno usato genkernel">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux <keyval id="kernel-version"/>
root (hd0,0)
kernel /boot/<keyval id="genkernel-name"/> root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev
initrd /boot/<keyval id="genkernel-initrd"/>

<comment># Solo nel caso si desideri il dual-boot</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<note>
L'<c>udev</c> specificato al termine della riga del kernel è necessario per
risolvere un bug presente in alcune versioni di genkernel che si verifica
<e>se</e> si utilizza subito udev, che è il comportamento predefinito.
</note>

<p>
Se si usa uno schema di partizioni e/o un'immagine del kernel differenti da
quelli dell'esempio, cambiare le impostazioni di conseguenza. Assicurarsi che
qualsiasi cosa che segue un dispositivo GRUB (come <path>(hd0,0)</path>), sia
relativa al punto di mount, e non a root. In altre parole,
<path>(hd0,0)/boot/grub/splash.xpm.gz</path> è
<path>/boot/grub/splash.xpm.gz</path> poichè <path>(hd0,0)</path> è
<path>/boot</path>.
</p>

<p>
Inoltre, se si sceglie di utilizzare uno schema di partizionamento diverso e non
si è posto <path>/boot</path> in una partizione separata l'aggiunta di
<path>/boot</path> negli esempi precedenti è davvero <e>essenziale</e>. Se
invece si è seguito lo schema suggerito l'utilizzo del prefisso
<path>/boot</path> non è richiesto ma può essere utilizzato con un link
simbolico a <path>boot</path>. In breve, gli esempi proposti sono funzionanti
sia che <path>/boot</path> sia stata definita come partizione separata sia no.
</p>

<p>
Se si ha bisogno di inserire opzioni ulteriori al kernel, si deve aggiungerle
alla fine del comando kernel. Si è già inserita una opzione
(<c>root=/dev/hda3</c> o <c>real_root=/dev/hda3</c>), ma se ne possono inserire
altre, ad esempio le istruzioni <c>vga</c> e <c>video</c> per il framebuffer, di
cui si è parlato precedentemente:
</p>

<p>
Se si utilizza un kernel successivo al 2.6.7 e il proprio BIOS non riconosce i
drive grandi è necessario aggiungere l'istruzione <c>hdx=stroke</c>.
</p>

<p>
Coloro che usano <c>genkernel</c> devono sapere che i loro kernel hanno le
stesse opzioni di boot del CD di Installazione. Per esempio, se si disponde di
un disco SCSI, si dovrebbe aggiungere <c>doscsi</c> come opzione del kernel.
</p>

<p>
Salvare ora il file <path>grub.conf</path> e uscire. Bisogna ancora installare
GRUB nel MBR (Master Boot Record) in modo che GRUB venga eseguito
automaticamente al boot del sistema.
</p>

<p>
Gli sviluppatori di GRUB raccomandano l'utilizzo di <c>grub-install</c>. In ogni
caso, se per qualche ragione <c>grub-install</c> non funzionasse è ancora
possibile installare GRUB manualmente.
</p>

<p>
Continuare la lettura con <uri link="#grub-install-auto">Predefinito: Impostare
GRUB con grub-install</uri> o <uri link="#grub-install-manual">Alternativa:
Impostare GRUB manualmente</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-auto">
<title>Predefinito: Impostare GRUB con grub-install</title>
<body>

<p>
Per installare GRUB è necessario lanciare il comando <c>grub-install</c>. In
questo caso però <c>grub-install</c> non può funzionare come al solito, perchè
siamo in un ambiente in chroot. Dobbiamo prima aggiornare <path>/etc/mtab</path>
(il file contenente le informazioni sui filesystem montati): fortunatamente c'è
un modo semplice per farlo, copiando <path>/proc/mounts</path> in
<path>/etc/mtab</path> ed escludendo <c>rootfs</c> se non è stata creata una
partizione di boot separata. Il seguente comando è valido in ogni caso:
</p>

<pre caption="Aggiornamento di /etc/mtab">
# <i>grep -v rootfs /proc/mounts &gt; /etc/mtab</i>
</pre>

<p>
Ora è possibile installare GRUB con <c>grub-install</c>:
</p>

<pre caption="Eseguire grub-install">
# <i>grub-install --no-floppy /dev/hda</i>
</pre>

<p>
Per ulteriori informazioni riguardanti GRUB consultare le <uri
link="http://www.gnu.org/software/grub/grub-faq.html">domande frequenti su GRUB
(FAQ)</uri> (in inglese, ndt) o il <uri
link="http://www.gnu.org/software/grub/manual/">Manuale di GRUB</uri>  (in
inglese, ndt).
</p>

<p>
Continuare la lettura con il <uri link="#reboot">Riavvio del sistema</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-manual">
<title>Alternativa: Impostare GRUB manualmente</title>
<body>

<p>
Per iniziare la configurazione di GRUB, digitare <c>grub</c>. Viene visualizzato
il prompt della linea di comando di grub, <path>grub&gt;</path>. Ora si può
procedere a digitare i comandi corretti per installare il boot record di GRUB
sull'hard disk.
</p>

<pre caption="Avviare la shell di GRUB">
# <i>grub --no-floppy</i>
</pre>

<note>
Se il sistema non dispone di un lettore floppy, aggiungere l'opzione
<c>--no-floppy</c> al comando precedente per evitare che grub lo cerchi.
</note>

<p>
Nella configurazione di esempio, si desidera installare GRUB in modo che legga
le proprie informazioni dalla partizione di boot <path><keyval
id="/boot"/></path> ed installare il boot record di GRUB nel MBR (master boot
record) dell'hard disk, in modo che la prima cosa che si veda, quando si accende
il computer, sia il prompt di GRUB. Se non si è seguita la configurazione di
esempio durante l'installazione, è necessario cambiare i comandi di conseguenza.
</p>

<p>
Il meccanismo di completamento con il tasto TAB, può essere usato da dentro
GRUB. Per esempio, se si digita "<c>root (</c>" seguito da TAB, viene elencata
una lista degli hard disk disponibili (come <path>hd0</path>). Se si digita
"<c>root (hd0,</c>" seguito da TAB, viene invece elencata una lista delle
partizioni disponibili nel disco (come <path>hd0,0</path>).
</p>

<p>
Con il tasto TAB non dovrebbe essere difficile impostare GRUB. Ecco ora la vera
e propria configurazione di GRUB.
</p>

<pre caption="Installare GRUB nel MBR">
grub&gt; <i>root (hd0,0)</i>          <comment>(Specifica dove è la partizione /boot)</comment>
grub&gt; <i>setup (hd0)</i>           <comment>(Installa GRUB nel MBR)</comment>
grub&gt; <i>quit</i>                  <comment>(Esce dalla shell di GRUB)</comment>
</pre>

<p>
Per ulteriori informazioni riguardanti GRUB consultare le <uri
link="http://www.gnu.org/software/grub/grub-faq.html">domande frequenti su GRUB
(FAQ)</uri> (in inglese, ndt) o il <uri
link="http://www.gnu.org/software/grub/manual/">Manuale di GRUB</uri>  (in
inglese, ndt).
</p>

<note>
Quando si reinstalla un kernel, non è più necessario copiare i file. E'
sufficiente eseguire <c>make install</c> dopo la compilazione del kernel e
automaticamente vengono copiati i file e reimpostata la configurazione di grub.
</note>

<p>
Continuare la lettura con il <uri link="#reboot">Riavvio del sistema</uri>.
</p>

</body>
</subsection>
</section>

<section id="lilo">
<title>Alternativa: Usare LILO</title>
<subsection>
<title>Installare LILO</title>
<body>

<p>
LILO, il LInuxLOader, è il più provato e il più usato tra i bootloader di Linux.
Però a LILO mancano alcune caratteristiche che non mancano a GRUB (è per questo
che GRUB sta guadagnando sempre più popolarità). Tuttavia LILO è ancora usato
perchè, su alcuni sistemi, GRUB non funziona, mentre LILO funziona. LILO è usato
anche perchè le persone che lo usano non vogliono abbandonarlo. Gentoo li
supporta entrambi: ecco come si usa LILO.
</p>

<p>
Installare LILO è veloce, utilizzare <c>emerge</c> così:
</p>

<pre caption="Installare LILO">
# <i>emerge lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>Configurare LILO</title>
<body>

<p>
Per configurare LILO si deve creare <path>/etc/lilo.conf</path>. Aprire l'editor
preferito (in questo manuale si usa <c>nano</c>) e creare il file.
</p>

<pre caption="Creare /etc/lilo.conf">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
In una sezione precedente, si è chiesto di ricordare il nome dell'immagine del
kernel che si è creata. Nel prossimo esempio di <path>lilo.conf</path> si usa lo
schema di partizioni dell'esempio precedente. Ci sono due sezioni separate:
</p>

<ul>
  <li>Una per chi non ha usato <c>genkernel</c> per compilare il kernel</li>
  <li>Una per chi ha usato <c>genkernel</c> per compilare il kernel</li>
</ul>

<p>
E' importante assicurarsi di usare la <e>propria</e> immagine del kernel ed
eventualmente il <e>proprio</e> initrd.
</p>

<note>
Se il proprio filesystem root è JFS, è <e>necessario</e> aggiungere una riga
<c>append="ro"</c> alla fine di ogni elemento boot perchè JFS deve poter
esaminare il suo log prima di concedere il mount in scrittura.
</note>

<pre caption="Esempio di /etc/lilo.conf">
boot=/dev/hda             <comment># Installa LILO nel MBR</comment>
prompt                    <comment># Dà possibilità di selezionare un'altra sezione</comment>
delay=50                  <comment># Aspetta 5 secondi prima di avviare la scelta predefinita</comment>
default=gentoo            <comment># Passato il timeout, avvia la sezione "gentoo"</comment>

<comment># Per utenti che non hanno usato genkernel</comment>
image=/boot/<keyval id="kernel-name"/>
  label=gentoo            <comment># Il nome dato alla sezione</comment>
  read-only               <comment># Avvio con root di sola lettura. Non modificare!</comment>
  root=/dev/hda3          <comment># Posizione del filesystem root</comment>

image=/boot/<keyval id="kernel-name"/>
  label=gentoo.rescue     <comment># Il nome dato alla sezione</comment>
  read-only               <comment># Avvio con root di sola lettura. Non modificare!</comment>
  root=/dev/hda3          <comment># Posizione del filesystem root</comment>
  append="init=/bin/bb"   <comment># Lancia la shell statica di emergenza</comment>

<comment># Per utenti che hanno usato genkernel</comment>
image=/boot/<keyval id="genkernel-name"/>
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"
  initrd=/boot/<keyval id="genkernel-initrd"/>

<comment># Le due righe seguenti sono necessarie solo per un dualboot con Windows.</comment>
<comment># In questo caso, Windows è in /dev/hda6.</comment>
other=/dev/hda6
  label=windows
</pre>

<note>
Il comando <c>udev</c> alla fine della linea append è necessario per risolvere
un bug di alcune versioni di genkernel che si verifica <e>se</e> si utilizza
subito udev, che è il comportamento predefinito.
</note>

<note>
Se si usa uno schema di partizioni differente e/o un'immagine del kernel non
uguale a quella dell'esempio, cambiare le impostazioni di conseguenza.
</note>

<p>
Se si ha bisogno di inserire ulteriori opzioni al kernel, si deve aggiungere
<c>append</c> alla sezione. Come esempio, si usa <c>video</c> per abilitare il
framebuffer:
</p>

<pre caption="Usare append per aggiungere opzioni al kernel">
image=/boot/<keyval id="kernel-name"/>
  label=gentoo
  read-only
  root=/dev/hda3
  <i>>append="video=vesafb:mtrr,ywrap,1024x768-32@85"</i>
</pre>

<p>
Se si utilizza un kernel successivo al 2.6.7 e il proprio BIOS non riconosce
i drive grandi è necessario aggiungere l'istruzione <c>hdx=stroke</c>.
</p>

<p>
Coloro che usano <c>genkernel</c> devono sapere che i loro kernel hanno le
stesse opzioni di boot del CD di Installazione. Per esempio, se si disponde di
un disco SCSI, si deve aggiungere <c>doscsi</c> come opzione del kernel.
</p>

<p>
Ora salvare il file e uscire. Per finire, si deve eseguire <c>/sbin/lilo</c>,
così LILO può applicare <path>/etc/lilo.conf</path> al sistema (per esempio,
installarsi sul disco). E' importante ricordare di eseguire <c>/sbin/lilo</c>
ogni volta che si installa un nuovo kernel o si cambiano le impostazioni del
menu.
</p>

<pre caption="Finire l'installazione di LILO">
# <i>/sbin/lilo</i>
</pre>

<p>
Per ulteriori dubbi o perplessità riguardanti LILO è possibile consultare la
<uri link="http://en.wikipedia.org/wiki/LILO_(boot_loader)">pagina
wikipedia dedicata</uri>
</p>

<p>
Continuare ora con il <uri link="#reboot">Riavvio del sistema</uri>.
</p>

</body>
</subsection>
</section>
<section id="elilo" test="func:keyval('arch')='IA64'">
<title>Predefinito: Installazione di elilo</title>
<body>

<p>
Sulle piattaforme IA64, il bootloader si chiama elilo. Potrebbe essere
necessario installarlo innanzitutto.
</p>

<pre caption="Installazione di elilo">
# <i>emerge elilo</i>
</pre>

<p>
E' possibile trovare il file di configurazione in <path>/etc/elilo.conf</path>
ed un file di esempio nella tipica directory dei documenti
<path>/usr/share/doc/elilo-&lt;ver&gt;/</path>. Ecco un'altra configurazione
 di esempio:
</p>

<pre caption="esempio di /etc/elilo.conf">
boot=/dev/sda1
delay=30
timeout=50
default=Gentoo
append="console=ttyS0,9600"
prompt

image=/vmlinuz
      label=Gentoo
      root=/dev/sda2
      read-only

image=/vmlinuz.old
      label=Gentoo.old
      root=/dev/sda2
      read-only
</pre>

<p>
La linea <c>boot</c> informa elilo della posizione della partizione di boot (in
questo caso, <path>/dev/sda1</path>). La linea <c>delay</c> imposta il numero di
decimi di secondo prima che venga automaticamente avviata l'opzione predefinita
quando si utilizza la modalità non interattiva. La linea <c>timeout</c> è simile
a delay ma vale per la modalità interattiva. La linea <c>default</c> definisce
quale sia il kernel predefinito tra quelli elencati in seguito. La linea
<c>append</c> aggiunge ulteriori opzioni alla linea di comando del kernel.
<c>prompt</c> imposta il comportamento predefinito di elilo ad interattivo.
</p>

<p>
Le sezioni che cominciano con <c>image</c> definiscono le varie immagini
avviabili. Ogni immagine ha una semplice <c>label</c>, un filesystem di
<c>root</c>, e monta il filesystem di root <c>read-only</c>.
</p>

<p>
Una volta terminata la configurazione è sufficiente eseguire <c>elilo
--efiboot</c>. L'opzione <c>--efiboot</c> aggiunge un elemento del menu per
Gentoo Linux nel boot manager EFI.
</p>

<pre caption="Applicazione della configurazione di elilo">
# <i>elilo --efiboot</i>
</pre>

<p>
Continuare ora con il <uri link="#reboot">Riavvio del sistema</uri>.
</p>

</body>
</section>
<section id="reboot">
<title>Riavvio del sistema</title>
<subsection>
<body>

<p>
Uscire dall'ambiente in chroot e smontare tutte le partizioni. Ed eseguire poi
l'ultimo comando, <c>reboot</c>.
</p>

<pre caption="Umount delle partizioni e reboot"
test="func:keyval('arch')='IA64'">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/sys /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<pre caption="Umount delle partizioni e reboot"
test="not(func:keyval('arch')='IA64')">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<p>
Non dimenticare di rimuovere il CD avviabile, altrimenti verrà di nuovo avviato
il CD al posto del sistema appena installato.
</p>

<p test="func:keyval('arch')='IA64'">
Durante il riavvio dovrebbe comparire una nuova opzione nel menu per Gentoo
Linux nel boot manager EFI, con essa è possibile avviare Gentoo.
</p>

<p>
Una volta effettuato il riavvio nella nuova installazione Gentoo, concludere con
<uri link="?part=1&amp;chap=11">Termine dell'installazione di Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>