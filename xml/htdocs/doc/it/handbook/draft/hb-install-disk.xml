<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<sections>
<section>
<title>Introduzione ai dispositivi a blocchi</title>
<subsection>
<title>Dispositivi a blocchi</title>
<body>

<p>
Si dà ora un'occhiata approfondita agli aspetti relativi ai dischi in Gentoo Linux e in Linux in generale, tra cui i filesystem Linux, le partizioni e i dispositivi a blocchi. Quindi, una volta acquisita familiarità con i dischi e i filesystem, si viene guidati attraverso il processo di configurazione delle partizioni e dei filesystem per l'installazione di Gentoo Linux.
</p>

<p>
Per cominciare, si introducono i <e>dispositivi a blocchi</e>. Il dispositivo a blocchi più famoso è molto probabilmente quello che rappresenta la prima unità IDE in un sistema Linux, <path>/dev/hda</path>. Se il sistema usa dischi SCSI, allora il primo disco fisso dovrebbe essere <path>/dev/sda</path>.
</p>

<p>
I dispositivi a blocchi rappresentano un'interfaccia astratta ai dischi. I programmi utente possono usare questi dispositivi a blocchi per interagire con i dischi, senza doversi chiedere se si tratta di unità IDE, SCSI o di qualsiasi altro tipo. Il programma può semplicemente indirizzare la memorizzazione su disco attraverso dei blocchi contigui, accessibili in modalità random, e di dimensione pari a 512 byte ciascuno.
</p>

</body>
</subsection>
<subsection>
<title>Partizioni e slice</title>
<body>

<p>
Nonostante sia possibile usare un intero disco per il sistema Linux, ciò non è quasi mai messo in pratica. Invece, i dispositivi a blocchi del disco sono divisi in parti più piccole e più maneggevoli. Sulla maggior parte dei sistemi, queste parti sono chiamate <e>partizioni</e>. Altre architetture usano il termine <e>slice</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partizioni</title>
<body>

<p>
Le partizioni sono divise in tre tipi: <e>primarie</e>, <e>estese</e> e <e>logiche</e>.
</p>

<p>
Una partizione <e>primaria</e> è una partizione che ha le sue informazioni memorizzate nel MBR (master boot record). Poichè MBR è molto piccolo (512 byte), possono essere definite solo quattro partizioni primarie (per esempio, da <path>/dev/hda1</path> a <path>/dev/hda4</path>).
</p>

<p>
Una partizione <e>estesa</e> è una speciale partizione primaria (cioè deve essere una delle quattro), che contiene altre partizioni. In origine non esisteva una tale partizione, ma poichè quattro partizioni erano troppo poche, è stata data la possibilità di estendere lo schema di formattazione senza perdere la compatibilità.
</p>

<p>
Una partizione (volume) <e>logica</e> è una partizione compresa dentro la partizione estesa. Le informazioni di una partizione logica non sono disposte nel MBR, ma sono dichiarate nella partizione estesa.
</p>

</body>
</subsection>
<subsection>
<title>Storage avanzato</title>
<body>

<p>
Se si è bootato da un LiveCD Gentoo c'è la possibilità di utilizzare EVMS o LVM2 per aumentare la flessibilità offerta dal proprio schema di partizioni. In queste istruzioni di installazione però ci si concentra maggiormanete sulle partizioni classiche, ma è bene sapere che sia EVMS che LVM2 sono comunque disponibili.
</p>

</body>
</subsection>
</section>
<section>
<title>Impostare uno schema di partizionamento</title>
<subsection>
<title>Schema di partizionamento di default</title>
<body>

<p>
Se non si è interessati a elaborare uno schema di partizionamento per il sistema, si può usare quello di questo Manuale:
</p>

<p>
Per x86 o amd64:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Per ppc:
</p>

<table>
<tr>
  <th>Partizione NewWorld</th>
  <th>Partizione OldWorld</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Non necessaria)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Per Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>Filesystem</th>
  <th>Grandezza</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(nessuno)</ti>
  <ti>Disco intero</ti>
  <ti>Sun Disk Label (richiesto)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Resto dello spazio su disco</ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Se si sta installando Gentoo da una distribuzione esistente, si dovrebbero ridimensionare le partizioni esistenti per poter installare Gentoo. Per farlo, si può usare <uri link="http://www.gnu.org/software/parted">GNU/Parted</uri>.
</p>

<p>
Se si è interessati ad avere informazioni su quanto dovrebbe essere grande una partizione primaria (o volume logico), o anche su quante partizioni si ha bisogno, seguono alcuni suggerimenti. Altrimenti continuare con il partizionamento del disco:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Usare fdisk su x86 o amd64 per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Usare fdisk su Alpha per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Usare fdisk su SPARC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Usare mac-fdisk su PPC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Usare fdisk su HPPA per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Usare fdisk su MIPS per partizionare il disco</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Numero e dimensione delle partizioni</title>
<body>

<p>
Il numero delle partizioni è altamente dipendente sull'ambiente. Per esempio, se si hanno molti utenti su una stessa macchina, molto probabilmente si vorrà tenere separate le directory <path>/home</path>, aumentando così la sicurezza e rendendo più facile il backup. Se si sta installando Gentoo per utilizzarlo da mailserver, <path>/var</path> dovrebbe essere separata poichè tutta la posta viene memorizzata in essa. Una buona scelta del filesystem è quella che massimizza le prestazioni. I gameserver è bene che abbiano una partizione separata per <path>/opt</path>, visto che la maggior parte dei server di gioco sono installati là. La stessa cosa vale per <path>/home</path>: sicurezza e backup.
</p>

<p>
Come si è visto, molto dipende da cosa si desidera realizzare. Partizioni o volumi separati hanno i seguenti vantaggi:
</p>

<ul>
<li>
  Si può scegliere il filesystem con maggiori prestazioni per ogni partizione o volume
</li>
<li>
  L'intero sistema non può esaurire lo spazio libero se un tool malfunzionante scrive all'infinito su una partizione od un volume
</li>
<li>
  Nel caso si rendano necessari, i controlli sul filesystem sono ridotti, poichè possono essere condotti in parallelo diverse analisi (questo vantaggio è più per i dischi multipli che per le partizioni multiple)
</li>
<li>
  La sicurezza può essere aumentata montando alcune partizioni o volumi in sola lettura, nosuid (i bit setuid vengono ignorati), noexec (i bit executable sono ignorati) etc.
</li>
</ul>

<p>
Le partizioni multiple hanno però un grosso svantaggio: se non sono configurate correttamente, si potrebbe avere un sistema con molto spazio libero su una partizione e poco su un'altra.
</p>

<p>
Come esempio di partizionamento, ecco quello di un disco da 20Gb, usato come un laptop di dimostrazione (contenente webserver, mailserver, gnome, ...):
</p>

<pre caption="Esempio di uso del filesystem">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Spazio non partizionato per uso futuro: 2 Gb)</comment>
</pre>

<p>
<path>/usr</path> è quasi pieno (83% dello spazio già in uso), ma una volta installato tutto il software, non cresce molto. Per <path>/var</path> si può pensare che lo spazio assegnato sia troppo. Ma Gentoo compila tutti i programmi in <path>/var/tmp/portage</path>, quindi si dovrebbe avere <path>/var</path> con almeno 1Gb libero se non si vogliono compilare grandi programmi e oltre 3Gb liberi per compilare KDE e OpenOffice.org.
</p>

<p>
Ora si partiziona il/i disco/dischi usando le istruzioni per le diverse architetture:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Usare fdisk su x86 o amd64 per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Usare fdisk su Alpha per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Usare fdisk su SPARC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Usare mac-fdisk su PPC per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Usare fdisk su HPPA per partizionare il disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Usare fdisk su MIPS per partizionare il disco</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su x86 o amd64 per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>x86</e> o <e>amd64</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizione di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Cambiare le partizioni in base alle proprie impostazioni.
</p>

</body>
</subsection>
<subsection>
<title>Vedere la disposizione delle partizioni</title>
<body>

<p>
<c>fdisk</c> è un tool popolare e potente per dividere il disco in partizioni. Eseguire <c>fdisk</c> per il disco (nell'esempio si usa <path>/dev/hda</path>):
</p>

<pre caption="Eseguire fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Si visualizzerà un prompt come questo:
</p>

<pre caption="Prompt di fdisk">
Command (m for help):
</pre>

<p>
Digitare <c>p</c> per visualizzare le attuali partizioni presenti sul disco:
</p>

<pre caption="Un esempio di partizionamento">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
Questo disco è configurato per avere sette filesystem Linux (chiamati "Linux" nelle corrispondenti partizioni) e una partizione swap (chiamata "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Rimuovere tutte le partizioni</title>
<body>

<p>
Si procede ora alla rimozione dal disco di tutte le partizioni esistenti. Digitare <c>d</c> per eliminare una partizione. Per esempio, per eliminare <path>/dev/hda1</path>:
</p>

<pre caption="Eliminare una partizione">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
E' stata memorizzata l'eliminazione della partizione. Non si rivedrà più se si digiterà <c>p</c>, ma non sarà eliminata fino a quando non si salveranno i cambiamenti. Se si è commesso un errore e si vuole uscire senza salvare, digitare <c>q</c> e invio e la partizione non sarà tolta.
</p>

<p>
Ora, se si desidera effettivamente eliminare tutte le partizioni sul sistema, digitare <c>p</c> per visualizzare l'elenco delle partizioni, e poi digitare <c>d</c> seguito dal numero della partizione, per eliminarle. Il risultato è una tabella con nessuna partizione:
</p>

<pre caption="Tabella con nessuna partizione">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Ora che la tabella è vuota, si è pronti a creare le partizioni. Come sempio, si fa riferimento allo schema di partizionamento visto precedentemente: non si deve seguire queste istruzioni alla lettera se non si desidera implementare lo stesso schema.
</p>

</body>
</subsection>
<subsection>
<title>Creare la partizione di boot</title>
<body>

<p>
Per prima cosa, si crei una piccola partizione di boot. Digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per selezionare una partizione primaria, seguito da <c>1</c> per selezionare la prima partizione primaria. Quando si visualizza il prompt per il primo cilindro, premere enter. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+32M</c> per creare una partizione di 32 Mbyte:
</p>

<pre caption="Creare la partizione di boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Premere Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Quando si digita <c>p</c>, si dovrebbe vedere la seguente partizione:
</p>

<pre caption="Partizione di boot creata">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
E' necessario rendere questa partizione avviabile. Digitare <c>a</c> per rendere avviabile questa partizione. Se si preme di nuovo <c>p</c>, si noterà che un <path>*</path> è posto nella colonna "Boot".
</p>

</body>
</subsection>
<subsection>
<title>Creare la partizione swap</title>
<body>

<p>
Si procede ora alla creazione della partizione swap. Per farlo, digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per dire a fdisk che si desidera creare una partizione primaria. Digitare <c>2</c> per creare la seconda partizione primaria, <path>/dev/hda2</path>. Quando si visualizza il prompt per il primo cilindro, premere invio. Quando si visualizza il prompt per l'ultimo cilindro, digitare <c>+512M</c> per creare una partizione di 512MB. Dopo aver fatto questo, digitare <c>t</c> per impostare il tipo di partizione, <c>2</c> per selezionare la partizione che si è creata e infine <c>82</c> per impostare il tipo di partizione a "Linux Swap". Finiti questi passaggi, digitando <c>p</c> si dovrebbe avere una tabella partizionata simile a questa:
</p>

<pre caption="Elenco delle partizioni dopo aver creato la partizione swap">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione root</title>
<body>

<p>
Si procede ora alla creazione della partizione root. Digitare <c>n</c> per creare una nuova partizione, poi <c>p</c> per dire a fdisk che si vuole una partizione primaria. Digitare <c>3</c> per creare la terza partizione primaria, <path>/dev/hda3</path>. Quando si visualizza il prompt per il primo cilindro, premere invio. Quando si visualizza il prompt per l'ultimo cilindro, premere enter per creare una partizione che occupi il resto dello spazio su disco. Infine, digitando <c>p</c> si dovrebbe avere una tabella partizionata simile a questa:
</p>

<pre caption="Elenco delle partizioni dopo aver creato la partizione root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Salvare lo schema delle partizioni</title>
<body>

<p>
Per salvare lo schema delle partizioni e uscire da <c>fdisk</c>, digitare <c>w</c>.
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che le partizioni sono create, si può continuare con la sezione riguardante come <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su Alpha per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>Alpha</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizioni di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Slice di Swap</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Slice di Root</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Intero disco (necessario)</ti>
</tr>
</table>

<p>
Cambiare lo schema in base alle proprie impostazioni.
</p>

</body>
</subsection>
<subsection>
<title>Identificare i dischi disponibili</title>
<body>

<p>
Per identificare quali dischi si abbiano a disposizione, usare i seguenti comandi:
</p>

<pre caption="Identificare i dischi disponibili">
<comment>(Per dischi IDE)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Per dischi SCSI)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Si dovrebbero poter vedere i dischi rilevati e il loro identificativo in <path>/dev</path>. In seguito si assume che il disco sia uno SCSI su <path>/dev/sda</path>.
</p>

<p>
Aprire <c>fdisk</c>:
</p>

<pre caption="Aprire fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Eliminare tutte le slice</title>
<body>

<p>
Si comincia con l'eleiminazione di tutte le slice <e>tranne</e> la slice 'c'. Ecco come eliminare una slice (nell'esempio si usa 'a'). Ripetere il processo per eliminare tutti gli altri slices (non la slice 'c').
</p>

<p>
Usare <c>p</c> per vedere tutti le slice esistenti. <c>d</c> si utilizza invece per eliminare una slice.
</p>

<pre caption="Eliminare una slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Dopo aver ripetuto questo processo per tutti le slice, si dovrebbe avere un elenco come il seguente:
</p>

<pre caption="Uno schema vuoto">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creare lo clice di swap</title>
<body>

<p>
Sui sistemi Alpha non si ha bisogno di una partizione separata di boot. Tuttavia, il primo cilindro non può essere usato poichè li si trova l'immagine di <c>aboot</c>.
</p>

<p>
Si procede ora alla creazione di una slice di swap partendo dal terzo cilindro, per un totale di 1 Gbyte. Usare <c>n</c> per creare una nuova slice. Cambiare poi il suo tipo a <c>1</c>, cioè a <e>swap</e>.
</p>

<pre caption="Creare la slice di swap">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Dopo, si dovrebbe avere uno schema simile al seguente:
</p>

<pre caption="Schema di slice dopo aver creato la slice di swap">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creare la slice di root</title>
<body>

<p>
Si procede ora alla creazione della slice di root, partendo dal primo cilindro <e>dopo</e> la slice di swap. Usare il comando <c>p</c> per vedere dove finisce lo swap slice. Nel nostro esempio finisce a 1003, e la partizione root parte da 1004.
</p>

<p>
Un altro problema è che al momento c'è un bug in <c>fdisk</c>, per cui il numero dei cilindri disponibili risulta uno in più del numero reale dei cilindri. In altre parole, quando viene chiesto l'ultimo cilindro, diminuire di uno il numero del cilindro (nell'esempio 5290).
</p>

<p>
Quando è creata la partizione, si cambi il tipo a <c>8</c>, <e>ext2</e>.
</p>

<pre caption="Creare la slice di root">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Lo schema delle slice dovrebbe essere simile a questo:
</p>

<pre caption="Vedere lo schema dello slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Salvare lo schema delle slice e uscire</title>
<body>

<p>
Uscire da <c>fdisk</c> digitando <c>w</c>, salvando così anche lo schema delle slice.
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che le slice sono create, si può continuare con il <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Usare fdisk su SPARC per partizionare il disco</title>
<subsection>
<body>

<impo>
Solo gli utenti con sistemi <e>SPARC</e> dovrebbero leggere questa sezione.
</impo>

<p>
La parte seguente spiega come creare lo schema di partizioni di esempio descritto precedentemente:
</p>

<table>
<tr>
  <th>Partizione</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partizione di boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partizione swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (richiesto)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Partizione root</ti>
</tr>
</table>

<p>
Cambiare lo schema delle partizioni in base alle proprie esigenze.
</p>

</body>
</subsection>
<subsection>
<title>Eseguire fdisk</title>
<body>

<p>
Eseguire <c>fdisk</c> con il disco come argomento:
</p>

<pre caption="Aprire fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Viene visualizzato il prompt di fdisk:
</p>

<pre caption="Il prompt di fdisk">
Command (m for help):
</pre>

<p>
Per vedere le partizioni disponibili, digitare <c>p</c>:
</p>

<pre caption="Elenco delle partizioni disponibili">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Notare il <c>Sun disk label</c> nell'output. Se manca, il disco sta usando il partizionamento DOS, non quello Sun. In questo caso, usare <c>s</c> per assicurarsi che il disco abbia una tabella di partizione sun.
</p>

</body>
</subsection>
<subsection>
<title>Eliminare le partizioni esistenti</title>
<body>

<p>
E' il momento di eliminare qualsiasi partizione esistente. Digitare <c>d</c> e premere invio. Al prompt si chiede il numero di partizione che si vuole eliminare. Per eliminare una partizione <path>/dev/hda1</path> preesistente, digitare:
</p>

<pre caption="Eliminare una partizione">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Per rimuovere tutte le partizioni esistenti, si prema <c>p</c> per vedere tutte le partizioni disponibili, e <c>d</c> per eliminarle una per una. Se si commette un errore, premere immediatamente <c>q</c> -- <c>fdisk</c> non cambia le partizioni ma mantiene i cambiamenti in memoria e i cambiamenti vengono salvati solo quando si digita <c>w</c>.
</p>

<p>
Dopo aver eliminato tutte le partizioni, si dovrebbe avere uno schema di partizione simile al seguente:
</p>

<pre caption="Uno schema di partizioni vuoto">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>

</body>
</subsection>
<subsection>
<title>Creare il Sun Disk Label</title>
<body>

<p>
Ora che la tabella delle partizioni è vuota, si crea la partizione per il Sun Disk Label. Digitare <c>n</c> per creare una nuova partizione, poi <c>3</c> per creare la partizione. Quando si visualizza la richiesta del primo cilindro, premere invio. Quando si visualizza la richiesta dell'ultimo cilindro, premere invio. Poi digitare <c>t</c> per impostare il tipo di partizione, infine digitare <c>5</c> per impostare il tipo di partizione a "Whole disk".
</p>

<pre caption="Creare una Disk Label Sun">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Premere Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Dopo aver completato questi passaggi, digitando <c>p</c> si dovrebbe visualizzare una tabella di partizioni simile a questa:
</p>

<pre caption="Lo schema delle partizioni ottenuto">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione di boot</title>
<body>

<p>
Si procede ora alla creazione  della partizione di boot. Digitare <c>n</c> e poi <c>1</c> per creare la partizione. Quando si visualizza la richiesta del primo cilindro, premere invio. Quando si visualizza la richiesta dell'ultimo cilindro, digitare <c>+32M</c> per creare una partizione di <c>32MB</c>. Assicurarsi che la partizione di boot sia contenuta nei primi 2Gb del disco. Ecco l'output di questi passaggi:
</p>

<pre caption="Creare una partizione di boot">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Premere Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Ora, digitando <c>p</c> si dovrebbe avere il seguente schema di partizioni:
</p>

<pre caption="Elenco dello schema di partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione di swap</title>
<body>

<p>
Si procede ora alla creazione  della partizione di swap. Digitare <c>n</c> per creare una nuova partizione, poi <c>2</c> per selezionare la seconda partizione, <path>/dev/hda2</path>. Quando si visualizza la richiesta del primo cilindro, premere invio. Quando si visualizza la rochiesta dell'ultimo cilindro, digitare <c>+512M</c> per creare una partizione di 512MB. Dopo aver fatto questo, digitare <c>t</c> per impostare il tipo di partizione, e infine digitare <c>82</c> per impostare il tipo di partizione a "Linux Swap". Digitando <c>p</c> si dovrebbe visualizzare una tabella di partizioni simile a questa:
</p>

<pre caption="Elenco delle partizioni disponibili">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creare la partizione root</title>
<body>

<p>
Si procede ora alla creazione della partizione root. Digitare <c>n</c> per creare una nuova partizione, poi <c>4</c> per creare la terza partizione, <path>/dev/hda4</path>. Quando si visualizza la richiesta del primo cilindro, premere invio. Quando si visualizza la riochiesta dell'ultimo cilindro, premere invio per creare una partizione che occupi il resto dello spazio sul disco. Dopo aver completato questi passaggi, digitando <c>p</c> si dovrebbe vedere una tabella di partizioni simile a questa:
</p>

<pre caption="Elenco della tabella completa delle partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Salvare e uscire</title>
<body>

<p>
Per salvare lo schema delle partizioni e uscire da <c>fdisk</c>, digitare <c>w</c>:
</p>

<pre caption="Salvare e uscire da fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ora che le partizioni sono create, si può continuare con la parte riguardante come <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Usare mac-fdisk su PPC per partizionare il disco</title>
<body>

<p>
Si creano ora le partizioni usando <c>mac-fdisk</c>:
</p>

<pre caption="Aprire mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Si eliminano le partizioni. Usare <c>d</c> in <c>mac-fdisk</c> per eliminarle. Alla richiesta inserire il numero della partizione da eliminare.
</p>

<p>
Poi si crea una partizione <e>Apple_Bootstrap</e> usando <c>b</c>. Alla richiesta inserire il blocco dal quale si desidera che la partizione inizi. Se precedentemente si è selezionato come numero della partizione <c>3</c>, premere <c>3p</c>.
</p>

<p>
Si crea una partizione swap digitando <c>c</c>. Di nuovo <c>mac-fdisk</c> chiede da quale blocco si vuole iniziare la partizione. Se si è usato <c>3</c> prima di creare la partizione Apple_Bootstrap, si deve digitare <c>4p</c>. Digitare <c>512M</c> alla richiesta della dimensione della partizione (o digitare un'altra dimensione -- 512 è quella raccomandata). Alla richiesta del nome, digitare <c>swap</c> (obbligatorio).
</p>

<p>
Per creare la partizione root, digitare <c>c</c> seguito da <c>5p</c>, per selezionare da quale blocco dovrebbe partire la partizione root. Alla richiesta della dimensione, digitare di nuovo <c>5p</c>. <c>mac-fdisk</c> lo interpreta come di utilizzare tutto lo spazione disponibile. Alla richiesta del nome, digitare <c>root</c> (obbligatorio).
</p>

<p>
Per finire, scrivere la partizione al disco usando <c>w</c> e <c>q</c> per uscire da <c>mac-fdisk</c>.
</p>

<p>
Ora che le partizioni sono create, si può continuare con la sezione riguardante come <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</section>
<section>
<title>Usare fdisk su HPPA per partizionare il disco</title>
<body>

<p>
Usare <c>fdisk</c> per creare le partizioni che si desiderano:
</p>

<pre caption="Partizionare il disco">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO ha bisogno di una partizione speciale per funzionare. Si deve creare una partizione di almeno 16Mb all'inizio del disco. Il tipo di partizione deve essere <e>f0</e> (Linux/PA-RISC boot).
</p>

<impo>
Se si continua senza creare la partizione speciale per PALO, il sistema non può funzionare.
</impo>

<p>
Se il disco è più grande di 2Gb, assicurarsi che la partizione di boot sia nei primi 2Gb. PALO non può leggere un kernel dopo 2Gb.
</p>

<p>
Ora che le partizioni sono create, si può continuare con la sezione riguardante come <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</section>
<section>
<title>Usare fdisk su MIPS per partizionare il disco</title>
<!-- This entire section is copy/pasted from Kumba's original text. It should
     probably be rewritten, but it seems a bit complicated.
     Someone donate me a MIPS? :) 

       ~SwifT
-->
<subsection>
<title>Creare uns Disk Label SGI</title>
<body>

<p>
Tutti i dischi in un sistema SGI richiedono una <e>Disk Label SGI</e>, che ha una funzione simile alle etichette di Sun &amp; e MS-DOS: contiene informazioni sulle partizioni del disco. Un nuova Label SGI crea due partizioni speciali sul disco:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (partizione 9): Questa partizione è importante. E' dove si inseriscono le immagini del kernel. Per immagazzinare le immagini del kernel, si utilizza il tool <c>dvhtool</c>. E' possibile avviare i kernel da questa partizione mediante il SGI PROM Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (partizione 11): Questa partizione ha scopo simile al "Whole Disk" della terza partizione della disklabel Sun. Questa partizione contiene l'intero disco, e non dovrebbe essere toccata. Non serve per nessun'altro scopo speciale, oltre a quello di assistere il PROM in qualche modo non documentato (o è usata da IRIX).
  </li>
</ul>

<warn>
Il SGI Volume Header <e>deve</e> iniziare dal cilindro 0. Altrimenti, non è possibile avviare dal disco.
</warn>

<p>
Il seguente è un esempio di una sessione di <c>fdisk</c>. Dopo averlo letto, si deve modificare in base alle proprie necessità.
</p>

<pre caption="Creare una disklabel SGI">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Se il disco ha già una Disklabel SGI, allora fdisk non permette la creazione di una nuova label. Ci sono due modi per aggirare questo problema. Il primo è quello di creare una etichetta Sun o MS-DOS, salvare i cambiamenti sul disco e riaprire fdisk. Il secondo è quello di sovrascrivere la tabella delle partizioni con dati nulli con il seguente comando: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Ottenere il SGI Volume Header della giusta dimensione</title>
<body>

<p>
Ora che si è creato un SGI Disklabel, devono essere definite le partizioni. Nell'esempio sopra, ci sono già due partizioni definite. Sono le partizioni speciali che non dovrebbero essere alterate. Tuttavia, per installare Gentoo, si ha bisogno di caricare le varie immagini dei kernel direttamente nel volume header, poichè non è ancora disponibile nessun Bootloader SGI in Portage. Lo stesso volume header può ospitare fino a <e>otto</e> immmagini di qualsiasi dimensione, ogni immagine permette nomi con otto caratteri.
</p>

<p>
Il processo per rendere più grande il volume header non è esattamente semplice, c'è un piccolo trucco. Non si può eliminare e riaggiungere il volume header a causa di un problema di fdisk. Nell'esempio seguente, si crea un Volume header di 50MB insieme con una partizione di /boot di 50MB. Lo schema del proprio disco può essere diverso, l'esempio è solo a scopo dimostrativo.
</p>

<pre caption="Ridimensionare il SGI Volume Header">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Notare come fdisk permetta che la Partizione 1 sia ricreata partendo al minimo dal cilindro 5)</comment>
<comment>(Se si fosse tentato di eliminare e ricreare il SGI Volume Header, questa è la conclusione che si sarebbe ottenuta.)</comment>
<comment>(Nel nostro esempio, si desidera che /boot sia di 50MB, quindi si inizia dal cilindro 51 (il Volume Header ha bisogno di iniziare dal cilindro 0), e si imposta il cilindro finale a 101, ottenendo approsimativamente 50MB)</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Eliminare la Partizione 9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Ricreare la Partizione 9, che finisce prima della Partizione 1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Schema finale delle partizioni</title>
<body>

<p>
Una volta fatto questo, è facile creare il resto delle partizioni. Dopo aver messo tutte le partizioni, assicurarsi di impostare l'ID della partizione di swap a <c>82</c>, Linux Swap. Di default è <c>83</c>, Linux Native.
</p>

<p>
Ora che le partizioni sono create, si può continuare con <uri link="#filesystems">Creare i filesystem</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Crare i filesystem</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Ora che le partizioni sono state create, è il momento di inserire il filesystem. Se non si è interessati alla scelta del filesystem e vanno bene quelli che si usano di default in questo Manuale, continuare con la sezione su come <uri link="#filesystems-apply">Applicare un filesystem a una partizione</uri>. Altrimenti ecco una descrizione dei filesystem disponibili.
</p>

</body>
</subsection>
<subsection>
<title>Filesystem</title>
<body>

<p>
Sono disponibili diversi filesystem. Alcuni sono stabili su tutte le architetture, altri solo su alcune. La seguente tabella elenca i filesystem disponibili e le architetture nelle quali funzionano. Se una architettura è inserita tra le parentesi, allora il filesystem dovrebbe funzionare, ma non è testato.
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Journaled</th>
  <th>Architetture</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>Tutte le architetture</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>si</ti>
  <ti>Tutte le architetture</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>si</ti>
  <ti>x86, hppa, alpha, (mips), (pcc), (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>si</ti>
  <ti>x86, alpha, amd64, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>si</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> è il vero e proprio filesystem di Linux ma non possiede il supporto per il metadata journaling, il che significa che le routine che effettuano all'avvio i controlli sul filesystem ext2 possono impiegare diverso tempo. Al momento esiste una scelta abbastanza ampia di filesystem journaled di nuova generazione che sono in grado di effettuare controlli sulla consistenza molto velocemente e sono generalmente preferiti alle controparti non-journaled. I filesystem journaled prevengono i lunghi tempi di attesa che solitamente si riscotrano quando viene riavviato il sistema e il filesystem si trova in uno stato inconsistente.
</p>

<p>
<b>ext3</b> è la versione journaled del filesystem ext2, fornisce il metadata journaling per un veloce recupero dei dati in aggiunta ad altre caratteristiche di journaling avanzate come full data e ordered data journaling. ext3 è un filesystem davvero molto valido e affidabile. Offre generalmente performance accettabili nella maggior parte delle situazioni. Poichè non fa un uso estesivo di "trees" nel proprio design interno, non è in grado di scalare molto bene, il che significa che non rappresenta una scelta ideale per filesystem molto grandi o situazioni in cui è necessario manipolare file molto grandi o grandi quantità di file in una singola directory. Ma se usato in condizioni che sfruttino le sue caratteristiche di design, ext3 è un eccellente filesystem.
</p>

<p>
<b>ReiserFS</b> è un filesystem basato su B*-tree che offre ottime performance generali e si dimostra notevolmente superiore a ext2 e ext3 con file di piccole dimensioni (file minori di 4k), spesso di un fattore 10-15. ReiserFS scala inoltre molto bene e supporta il metadata journaling. Dal kernel 2.4.18 in poi, ReiserFS ha raggiunto la solidità che lo porta a essere caldamente raccomandato sia per un uso generico che per casi estremi come la crezione di grandi filesystem, l'uso su molti file piccoli, file molto grandi e directory contenenti decine di migliaia di file.
</p>

<p>
<b>XFS</b> è un filesystem con metadata journaling che è completamente supportato in Gentoo Linux dal kernel xfs-sources. Si presenta con un robusto insieme di caratteristiche ed è ottimizzato per la scalabilità. Se ne raccomanda l'uso su sistemi Linux dotati di unità di memorizzazione con canali in fibra o high-en SCSI e alimentazione continua. Data l'aggressivita con la quale XFS si serve della cache in RAM per i dati in transito, programmi progettati in modo non adeguato (quelli che non prendono precauzioni quando scrivono file su disco, e ce ne sono diversi) possono perdere una discreta quantità di dati se il sistema si arresta in modo inaspettato.
</p>

<p>
<b>JFS</b> è il filesystem con journaling ad alte prestazioni di IBM. E' stato recentemente giudicato pronto per il mercato, ma ad oggi non è stato sufficientemente testato per fare commenti positivi o negativi sulla sua stabilità generale.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Applicare un filesystem a una partizione</title>
<body>

<p>
Per creare un filesystem su una partizione o volume, sono disponibili tool per ogni filesystem possibile:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Comando per la creazione</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Per esempio, per avere la partizione di boot (<path>/dev/hda1</path>) ext2 e la partizione root (<path>/dev/hda3</path>) ext3, si usa:</p>

<pre caption="Applicare un filesystem su una partizione">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Ora si procede alla creazione dei filesystem sulle partizioni (o volumi logici) create precedentemente.
</p>

</body>
</subsection>
<subsection>
<title>Attivare la partizione swap</title>
<body>

<p>
<c>mkswap</c> è il comando usato per inizializzare le partizioni swap:
</p>

<pre caption="Inizializzare la partizione swap">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Per attivare la partizione swap, usare <c>swapon</c>:
</p>

<note>
Gli utenti di Knoppix che hanno già una partizione swap sul loro sistema, dovrebbero saltare questa attivazione, poichè Knoppix attiva automaticamente le partizioni swap esistenti.
</note>

<pre caption="Attivare la partizione swap">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Creare e attivare swap in questo momento.
</p>

</body>
</subsection>
</section>
<section>
<title>Montare</title>
<body>

<p>
Ora che le partizioni sono inizializzate e hanno un filesystem, è il momento di montarle. Usare il comando <c>mount</c>. Non dimenticarsi di creare le necessarie directory di mount:
</p>

<pre caption="Montare le partizioni">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Se si vuole che <path>/tmp</path> risieda in una partizione separata, assicurarsi di cambiare i permessi dopo il mount: <c>chmod 1777 /mnt/gentoo/tmp</c>. Questo vale anche per <path>/var/tmp</path>.
</note>

<p>
E' necessario inoltre montare il filesystem proc (una intefaccia virtuale con il kernel) su <path>/proc</path>. Innanzitutto si crea il mountpoint <path>/mnt/gentoo/proc</path>:
</p>

<pre caption="Creare il mountpoint /mnt/gentoo/proc">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
Se si sta installando Gentoo da un LiveCD, è necessario semplicemente montare <path>proc</path>:
</p>

<pre caption="Montare proc">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Se non si sta installando Gentoo da un LiveCD, si deve fare il bindmount di <path>/proc</path>:
</p>

<pre caption="Fare il bindmount di proc">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
</pre>

<p>
Ora continuare con la <uri link="?part=1&amp;chap=5">Copia dei file di installazione di Gentoo</uri>.
</p>

</body>
</section>
</sections>
