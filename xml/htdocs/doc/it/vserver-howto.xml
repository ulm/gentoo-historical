<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/vserver-howto.xml,v 1.3 2006/10/20 14:11:10 so Exp $ -->

<guide link="/doc/it/vserver-howto.xml" lang="it">
<title>Linux-VServer con Gentoo</title>

<author title="Autore">
  <mail link="hollow@gentoo.org">Benedikt Boehm</mail>
</author>
<author title="Editore">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Traduttore">
  <mail link="swit@autistici.org">Matteo Carli</mail>
</author>

<abstract>
In questo Howto si impara a installare un virtual server di base usando
la tecnologia Linux-VServer
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.6</version>
<date>2006-10-06</date>

<chapter>
<title>Introduzione</title>
<section>
<title>Il concetto di Linux-VServer</title>
<body>

<p>
Il concetto alla base del progetto Linux-VServer è di separare l'ambiente
user-space in distinte unità (a volte chiamate Virtual Private Servers) in
modo che ogni VPS sembri e si comporti come un vero server con i processi in
esso contenuti.
</p>

</body>
</section>
<section>
<title>Termini utilizzati in questo Howto</title>
<body>

<table>
<tr>
  <th>Termine</th>
  <th>Descrizione</th>
</tr>
<tr>
  <th>Linux-VServer, VServer</th>
  <ti>
    Linux-VServer è il nome ufficiale del progetto ed è usato in questo Howto
	con il medesimo significato
  </ti>
</tr>
<tr>
  <th>virtual server, vserver, guest system</th>
  <ti>
    Tutti questi termini sono sinonimi e si riferiscono ad una instanza del
	server (ad esempio un virtual server)
  </ti>
</tr>
<tr>
  <th>host system, host</th>
  <ti>
	La macchina fisica che monta Gentoo Linux e che ospita tutti i virtual
	servers
  </ti>
</tr>
<tr>
  <th>util-vserver</th>
  <ti>
    Il pacchetto <c>util-vserver</c> contiene tutti i programmi necessari
	per la manutenzione dei virtual server
  </ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Configurazione dell'host system</title>
<section>
<title>Installare un VServer kernel</title>
<body>

<pre caption="Installare vserver-sources">
# <i>emerge vserver-sources</i>
</pre>

<p>
Dopo aver installato vserver-sources è il momento di configurarlo
usando
<c>make menuconfig</c>.
</p>

<pre caption="Configure vserver-sources">
# <i>cd /usr/src/linux-&lt;VERSIONEKERNEL&gt;-vserver-&lt;VERSIONEVSERVER&gt;</i>
# <i>make menuconfig</i>

Linux VServer ---&gt;
  [ ] Enable Legacy Kernel API
  [*] Disable Legacy Networking Kernel API
<comment>(Caldamente raccomandata)</comment>
  [*] Enable Proc Security
  [*] Enable Hard CPU Limits
  Persistent Inode Context Tagging (UID24/GID24)  ---&gt;
  [ ] Tag NFSD User Auth and Files
  [ ] Compile Debugging Code
</pre>

<note>
Se si usa reiserfs come filesystem, si deve abilitare l'opzione
per gli attributi estesi di reiserfs nella configurazione del kernel e 
successivamente aggiungere <c>attrs</c> nelle opzioni in 
<path>/etc/fstab</path>.
</note>

<pre caption="Configurare le opzioni per reiserfs">
File systems  --->
  &lt;*&gt; Reiserfs support
  [*]   ReiserFS extended attributes
</pre>

<pre caption="Esempio di fstab con gli attributi estesi attivi">
/dev/hdb /vservers reiserfs noatime,attrs 0 0
</pre>

<p>
Dopo che è stato compilato e installato il kernel, è necessario aggiornare il
boot loader ed infine controllare se il kernel riesce ad avviarsi 
correttamente.
</p>

<pre caption="Installare il kernel">
<comment>(Compilare il kernel)</comment>
# <i>make</i>
<comment>(Installarlo)</comment>
# <i>make modules_install</i>
# <i>cp arch/&lt;arch&gt;/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
<comment>(Modificare la configurazione del boot loader come richiesto e 
successivamente riavviare:)</comment>
# <i>reboot</i>
</pre>

</body>
</section>
<section>
<title>Configurare l'ambiente ospitante</title>
<body>

<p>
Per la manutenzione del virtual server è necessario il pacchetto
util-vserver il quale contiene tutti gli applicativi necessari e le
funzioni utili.
Si deve sapere anche, che esiste un pacchetto chiamato <c>vserver-utils</c>.
Quest'ultimo rappresenta l'ultima implementazione delle API per il kernel
VServer, ma non è adatto all'uso in produzione.
</p>

<note>
Gli applicativi e le caratteristiche ai quali questo howto si riferisce
richiedono <c>&gt;=sys-cluster/util-vserver-0.30.210-r6</c>. Controllare la
versione prima di continuare.
</note>

<pre caption="Installare util-vserver">
# <i>emerge util-vserver</i>
</pre>

<p>
Si deve eseguire il comando <c>vprocunhide</c> dopo ogni riavvio per settare
correttamente i permessi in <path>/proc</path> per l'uso del vserver. Uno 
script di init è stato installato da util-vserver. Per usarlo aggiungerlo al
runlevel di default:
</p>

<pre caption="vserver init script">
# <i>rc-update add vservers default</i>
# <i>/etc/init.d/vservers start</i>
</pre>

<note>
Lo script di init fa partire anche il vserver di default. Leggere sotto per
altre informazioni.
</note>

<p>
Lo script vshelper è usato per riavviare correttamente i virtual
server. Bisogna specificare al kernel il percorso dello script:
</p>

<pre caption="vshelper setup">
# <i>echo 'kernel.vshelper = /usr/lib/util-vserver/vshelper' &gt;&gt; /etc/sysctl.conf</i>
# <i>sysctl -p</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Creare un modello per il guest system</title>
<section>
<title>Installare un vserver stage3</title>
<body>

<p>
Si deve scaricare uno stage3 già pronto da uno dei <uri
link="/main/en/mirrors.xml">nostri mirrors</uri>. Questi stage si trovano
nella cartella <path>experimental/&lt;arch&gt;/vserver/</path>.  Usare
<c>vserver-new</c> per creare il primo guest system.
</p>

<p>
Si deve scegliere un "context ID" per il vserver (ID casuali sono
sconsigliati) meglio se si usano le informazioni sui dispositivi di rete
(in questo esempio eth0 è configurata con 192.168.1.253/24 e il
"connext ID" sarà equivalente agli ultimi due ottetti dell'indirizzo IP del
vserver).
</p>

<pre caption="Inizio installazione dello stage3 sul guest system">
# <i>vserver-new gentoo-template \</i>
  <i>--hostname gentoo \</i>
  <i>--context 1253 \</i>
  <i>--interface eth0:192.168.1.253/24 \</i>
 <i>stage3 /path/to/stage3-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
Per rendere effettive le configurazioni di rete si deve modificare:
<path>/etc/conf.d/hostname</path>, <path>/etc/conf.d/domainname</path> e
<path>/etc/hosts</path> all'interno del guest system . Vedere <uri
link="/doc/it/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect1">
capitolo 8.b.1</uri> e <uri
link="/doc/it/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect4">
capitolo 8.b.4</uri>. Il resto delle configurazioni del vserver saranno fatte
sull'host system.
</note>

</body>
</section>
<section>
<title>Creare un pacchetto del modello</title>
<body>

<p>
Non è necessario fare un tarball dello stage3 per ogni guest system.
Lo script <c>vserver-new</c> supporta i modelli. Per usarlo è necessario
creare il tarball dell'installazione del vserver stesso:
</p>

<pre caption="Creare il tarball del modello">
# <i>cd /vservers/gentoo-template</i>
# <i>tar cjvpf ../gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 ./</i>
</pre>

<p>
Per creare un nuovo guest system partendo dal tarball creato usare
<c>vserver-new</c>:
</p>

<pre caption="Usare il tarball del modello">
# <i>cd /vservers</i>
# <i>vserver-new myguest \</i>
  <i>--hostname myguest \</i>
  <i>--context 1252 \</i>
  <i>--interface eth0:192.168.1.252/24 \</i>
  <i>template ./gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
Si dovrebbe usare un albero di portage condiviso per mantenere i guest system
di piccole dimensioni.  Modificare <path>/etc/vservers/myguest/fstab</path> e
decommentare le linee relative a <path>/usr/portage</path> e
<path>/usr/portage/distfiles</path>.  I guest system avranno accesso di sola
lettura a <path>/usr/portage</path> e di lettura e scrittura a
<path>/usr/portage/distfiles</path>.
</note>

</body>
</section>
<section>
<title>Provare il virtual server</title>
<body>

<p>
Si dovrebbe essere in grado di far partire il vserver usando il comando sotto
riportato.  Se non si hanno comandi come <c>mount</c> o <c>dmesg</c> si
dovrebbe eseguire <c>emerge util-linux</c> all'interno del virtual server
poiché il profilo vserver non fornisce questo pacchetto nella configurazione
iniziale.
</p>

<pre caption="Provare il virtual server">
# <i>vserver myguest start</i>
# <i>vserver-stat</i>
CTX   PROC    VSZ    RSS  userTIME   sysTIME    UPTIME NAME
0       90   1.4G 153.4K  14m00s11   6m45s17   2h59m59 root server
1252     2     3M   286    0m00s45   0m00s42   0m02s91 myguest
# <i>vserver myguest enter</i>
# <i>ps ax</i>
PID   TTY      STAT   TIME COMMAND
    1 ?        S      0:00 init [3]
22887 ?        Ss     0:00 /usr/sbin/syslog-ng
20496 pts/0    S      0:00 /bin/bash -login
20508 pts/0    R+     0:00 ps ax
# <i>logout</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>Manutenzione semplificata</title>
<section>
<title>Avviare i guest system al boot</title>
<body>

<p>
Si possono avviare, in modo sicuro, i guest system al boot dell'host system.
E' possibile specificare, per ogni guest system un contrassegno chiamato MARK.
Adesso tutto quello che c'è da fare è assegnare un MARK ad ogni guest system
tramite la propria configurazione e specificare allo script di init di avviare,
ogni guest system contrassegnato, all'avvio.
</p>

<pre caption="Configurazione dei MARKs per ogni guest system">
<comment>(Ripetere questi comandi per ogni guest system da contrassegnare)</comment>
# <i>mkdir -p /etc/vservers/myguest/apps/init</i>
# <i>echo "default" > /etc/vservers/myguest/apps/init/mark</i>
</pre>

<note>
Tutti i guest system contrassegnati con "default" saranno avviati senza dover
compiere altre modifiche. Se si sono create MARKs diverse sarà necessario
aggiornare <path>/etc/conf.d/vservers</path>.
</note>

</body>
</section>
<section>
<title>Tool di Gentoo</title>
<body>

<p>
L'ebuild util-vserver ha installato alcuni tool per la gestione dei guest
system.  Si è visto <c>vserver-new</c> nello scorso paragrafo. In questo
vedremo come usare <c>vesync</c> e <c>vemerge</c> per tenere sincronizzato
portage e <c>vupdateworld</c> e <c>vdispatch-conf</c> per aggiornare i guest
system.
</p>

</body>
</section>
<section>
<title>Sincronizzare portage</title>
<body>

<p>
Lo script <c>vesync</c> aiuterà a tenere sincronizzati la cache dei metadata
con gli overlays. <c>vemerge</c> permette di usare emerge con i guest system.
</p>

<pre caption="Esempi">
<comment>(Sincronizzazione dei metadata per 'myguest')</comment>
# <i>vesync myguest</i>
<comment>(Sincronizzazione dei metadata per guests system)</comment>
# <i>vesync -a</i>
<comment>(Sincronizzazione dei metadata per tutti i guest system ad eccezione di 'myguest')</comment>
# <i>vesync -a -e myguest</i>
<comment>(Sincronizzazione dei 'myoverlay' per tutti i guest system)</comment>
# <i>vesync -a \</i>
  <i>--overlay /usr/local/overlays/myoverlay \</i>
  <i>--overlay-host rsync://rsync.myhost.com/myoverlay \</i>
  <i>--overlay-only</i>
<comment>(Installazione di app-editors/vim in 'myguest')</comment>
# <i>vemerge myguest app-editors/vim -va</i>
</pre>

<note>
Questi script richedono un albero di portage condiviso.
</note>

</body>
</section>
<section>
<title>Aggiornamento dei guest system</title>
<body>

<p>
I guest system, su Gentoo, possono condividere i pacchetti per evitare lunghi
tempi di compilazione. Per poter utilizzare la condivisione dei pacchetti è
necessario creare una cartella per centralizzare il salvataggio dei pacchetti
sull'host system. Usare <path>/var/cache/vpackages</path>, sull'host system,
montandola in <path>/usr/portage/packages</path> per ogni guest system.
</p>

<pre caption="Aggiungere l'opzione bind per il mount">
# <i>mkdir -p /var/cache/vpackages</i>
# <i>$EDITOR /etc/vservers/myguest/fstab</i>
<comment>(Aggiungere questa linea alla fine del file)</comment>
/var/cache/vpackages /usr/portage/packages none bind,rw 0 0
</pre>

<p>
Adesso si può utilizzare <c>vupdateworld</c> per aggiornare tutti i guest
system.  Il comando è equivalente a qualcosa tipo <c>emerge --deep --update
--newuse world</c> ma dipende dalle opzioni passate da riga di comando.
</p>

<pre caption="esempi con vupdateworld">
<comment>(Simulare l'aggiornamento per 'myguest')</comment>
# <i>vupdateworld -p myguest</i>
<comment>(Aggiornamento di 'myguest' usando i pacchetti binari)</comment>
# <i>vupdateworld -k myguest</i>
<comment>(Aggiornamento di tutti i guest system usando i pacchetti binari)</comment>
# <i>vupdateworld -ka</i>
</pre>

<note>
Per poter ottenere pacchetti binari è necessario utilizzare PORTAGE_BINHOST
(vedere <c>man make.conf</c>) oppure impostare FEATURES="buildpkg" in uno o
più guest system.
</note>

<p>
Dopo aver aggiornato con successo i guest system è possibile aggiornare con
semplicità i file di configurazione con <c>vdispatch-conf</c>. Questo script
permette di usare <c>dispatch-conf</c> con i guest system ereditandone le
caratteristiche.
</p>

<pre caption="esempi con vdispatch-conf">
<comment>(Aggiornare i file di configurazione di 'myguest')</comment>
# <i>vdispatch-conf myguest</i>
<comment>(Aggiornare i file di configurazione di tutti i guest system)</comment>
# <i>vdispatch-conf -a</i>
</pre>

</body>
</section>

<section>
<title>Contatti</title>
<body>

<p>
Si può contattare <mail link="hollow@gentoo.org">l'autore</mail> o aprire un
bug su <uri link="http://bugs.gentoo.org">Bugzilla</uri> in caso di
problemi.
</p>

</body>
</section>
</chapter>
</guide> 
