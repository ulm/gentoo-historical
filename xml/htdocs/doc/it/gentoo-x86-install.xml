<?xml version='1.0' encoding ="utf-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/gentoo-x86-install.xml" >
<title>Guida all'installazione di Gentoo Linux 1.4_rc4</title>
<author title="Supervisore" >
<mail link="drobbins@gentoo.org" >Daniel Robbins</mail>
</author>
<author title="Autore Originale" >Chris Houser</author>
<author title="Autore Originale" >
<mail link="jerry@gentoo.org" >Jerry Alexandratos</mail>
</author>
<author title="Revisione" >
<mail link="g2boojum@gentoo.org" >Grant Goodyear</mail>
</author>
<author title="Aggiornamento" >
<mail link="zhen@gentoo.org" >John P. Davis</mail>
</author>
<author title="Aggiornamento" >
<mail link="Pierre-Henri.Jondot@wanadoo.fr" >Pierre-Henri Jondot</mail>
</author>
<author title="Aggiornamento" >
<mail link="stocke2@gentoo.org" >Eric Stockbridge</mail>
</author>
<author title="Aggiornamento" >
<mail link="rajiv@gentoo.org" >Rajiv Manglani</mail>
</author>
<author title="Aggiornamento" >
<mail link="seo@gentoo.org" >Jungmin Seo</mail>
</author>
<author title="Aggiornamento" >
<mail link="zhware@gentoo.org" >Stoyan Zhekov</mail>
</author>
<author title="Aggiornamento" >
<mail link="jhhudso@gentoo.org" >Jared Hudson</mail>
</author>
<author title="Aggiornamento" >
<mail link="" >Colin Morey</mail>
</author>
<author title="Aggiornamento" >
<mail link="peesh@gentoo.org" >Jorge Paulo</mail>
</author>
<author title="Aggiornamento" >
<mail link="carl@gentoo.org" >Carl Anderson</mail>
</author>
<author title="Aggiornamento" >
<mail link="swift@gentoo.org" >Sven Vermeulen</mail>
</author>
<author title="Traduttore" >Enrico Morelli</author>
<author title="Traduttore" >Team Italiano</author>
<abstract>Queste instruzioni vi guideranno attraverso il processo di
installazione di Gentoo Linux 1.4_rc4. L'installazione di Gentoo Linux supporta
vari tipi di approcci a seconda di quanto volete che il vostro sistema sia
costruito da zero.</abstract><version>2.6.1</version>
<date>6 Maggio 2003</date>
<chapter>
<title> Introduzione</title>
<section>
<body>
<p>
	Questo nuovo CD di boot dovrebbe essere avviabile da tutti i moderni lettori
	CD-ROM IDE e SCSI, sempre che il vostro lettore CD e il BIOS del vostro
	computer lo supportino. Il Linux incluso nel CD-ROM riconosce periferiche IDE
	(incluse nel kernel) e SCSI (disponibili come modulo). Inoltre, sono provveduti
	i moduli per tutti i tipi di schede di rete supportate da Linux, così come
	tutti gli strumenti per la configurazione e l'accesso via ssh alla rete e il
	download dei file.</p>
<p>
	I requisiti minimi di sistema sono: processore 486+con idealmente almeno 64MB
	di RAM (Gentoo Linux è stato installato con successo anche con 64MB di RAM e
	64MB di swap, ma in queste condizioni il processo di installazione risulta essere molto lento).
</p>
<p>
	Gentoo Linux può essere installato usando uno dei tre file .tar denominati	&quot;stage&quot;
	La scelta dipende da quanta parte del sistema volete compilare. Lo stage1
	serve per compilare l'intero sistema da zero. Lo stage2 per compilare, da zero, solo
	alcune parti del sistema, mentre lo stage3 vi permetterà di risparmiare
	molto tempo dato che è già stato ottimizzato per il vostro specifico sistema e
	contiene un sistema Gentoo Linux di base.
</p>
<p>
	<b>Dovreste scegliere di partire dallo stage1, stage2 o stage3?</b>

	Se scegliete di partire dallo stage1 avrete il controllo totale delle
	ottimizzazioni e delle funzionalità opzionale usata durante la fase di
	compilazione che è inizialmente abilitata sul vostro sistema. Questo rende lo
	stage1 ideale per gli utenti smaliziati che sanno quello che stanno facendo.
	Con lo stage2 saltate il processo di bootstrap, e dovrete accontentarvi
	delle opzioni di ottimizzazione che abbiamo scelto per il vostro particolare
	file .tar dello stage2. Con lo stage3 avrete una installazione di Gentoo Linux
	molto veloce, ma anche in questo caso dovrete accontentarvi delle
	ottimizzazioni che abbiamo scelto per voi. Questo potrebbe essere sufficiente,
	dato che le versioni rilasciate di Gentoo Linux hanno lo stage3 specificamente
	ottimizzato per i più popolari tipi di processori.

	<b>Se state installando Gentoo Linux per la prima volta, il consiglio è di usare il file
	.tar dello stage3.</b>
</p>
<p>
	Bene, come facciamo a iniziare il processo di installazione? Prima dovrete
	decidere quale immagine ISO del LiveCD scaricare, su
	<uri>http://www.ibiblio.org/gentoo/releases/1.4_rc4/x86/</uri>. Il consiglio
	è di considerare l'uso di uno dei nostri mirror in modo da alleviare il carico
	di lavoro dal server principale. Una lista di server può essere trovata su
	<uri>http://www.gentoo.org/main/en/mirrors.xml</uri>.
</p>
<p>
	I LiveCD sono immagini complete per CD che dovrebbero essere masterizzate su un CDR o CD-RW
	usando un software per la masterizzazione. Al momento abbiamo due tipi di LiveCD. Il primo
	con la dicitura &quot;gentoo-basic&quot; è di approssimativamente 40MB e lo trovate nella directory
	<path>x86/livecd/</path>. Questo CD di piccole dimensioni permette un download iniziale e contiene un
	file .tar dello stage1 in <path>/mnt/cdrom/gentoo</path> dopo l'avvio dal CD.
</p>
<p>
	Il secondo LiveCD che offriamo è etichettato &quot;gentoo-3stages&quot;.
	Anche questo CD lo trovate nella directory <path>x86/livecd</path> e contiene i
	file .tar dello stage 1, 2 e 3. Usando questo CD, sarà possibile installare velocemente
	un sistema Gentoo Linux completamente funzionante. <b>Che fine hanno fatto i LiveCD
	per i686, pentium3, athlon, athlon-mp e i pacchetti GRP (Gentoo Reference Platform)?</b>
	Gentoo 1.4_rc4 è soltanto una &quot;release candidate&quot; minima. La 1.4_final tornerà
	ad essere suddivisa in architetture x86 e conterrà i pacchetti GRP. Se volete installare gli
	stage ottimizzati per queste architetture o i pacchetti GRP, usate la documentazione per
	la 1.4_rc2 che potete trovare su <uri>http://www.gentoo.org/doc/it/gentoo-x86-1.4_rc2-install.xml</uri>.
</p>
<impo>
	Se incontrate qualche problema in qualsiasi parte dell'installazione,
	potete riportarlo su <uri>http://bugs.gentoo.org</uri>. Se il bug coinvolge
	gli sviluppatori del software originale (come ad esempio il team KDE),
	sarà cura degli <e>sviluppatori di Gentoo Linux</e> occuparsi
	di farlo avere a chi di dovere.
</impo>
<p>
	Ora diamo una rapida occhiata al processo di installazione. Prima dovremo scaricare e masterizzare
	l'immagine e, quindi riavviare il nostro PC facendogli fare il boot dal LiveCD appena creato.
	Non appena raggiunto il prompt di root, creeremo le partizioni, i nostri filesystem ed estrarremo
	uno dei file .tar stageNN. Se stiamo usando i .tar dello stage1 o dello stage2, vedremo quali passi compiere
	per portare il nostro sistema allo stage3. Una volta che il sistema sarà arrivato allo stage3, potremo configurarlo
	(ottimizzando i file di configurazione, installando il bootloader, ecc.), e farlo ripartire avendo un sistema Gentoo
	Linux completamente funzionale. A seconda dello stage dal quale stiamo partendo, i requisiti per l'installazione sono i
	seguenti (N.d.T. emerge è il comando per la gestione del software in Gentoo Linux, per cui alcuni dei seguenti termini		non sono traducibili):
</p>
	<table>
		<tr>
			<th>file .tar (stage)</th>
			<th>requisiti per l'installazione</th>
		</tr>
		<tr><ti>1</ti><ti>setup di partizioni e filesystem, emerge sync, bootstrap, emerge system, emerge kernel,
		configurazione finale</ti>
		</tr>
		<tr><ti>2</ti><ti>setup di partizioni filesystem, emerge sync, emerge system, emerge kernel, configurazione
		finale</ti></tr>
		<tr><ti>3</ti><ti>setup di partizioni e filesystem, emerge sync, configurazione finale</ti></tr>
	</table>
</body>
</section>
</chapter>
<chapter>
<title> L'avvio</title>
<section>
<body>
<p>
	Fate il boot dal LiveCD.
	Dovreste vedere un testo di benvenuto con il logo di Gentoo Linux.
	In questa schermata potete semplicemente premere Enter per iniziare il processo di boot, o avviare il LiveCD
	con opzioni che usate abitualmente specificando un kernel seguito dalle opzione e quindi dalla pressione del
	tasto Enter. Per esempio <c>gentoo nousb nohotplug</c>. Consultate la seguente tabella per una lista di
	kernel e opzioni disponibili o premete F2 per avere una schermata di aiuto.
</p>
<table>
<tr>
<th>Kernel disponibili.</th>
<th>descrizione</th>
</tr>
<tr>
<ti>gentoo</ti>
<ti>Il kernel base di gentoo (predefinito)</ti>
</tr>
<tr>
<ti>800</ti>
<ti>modalità  framebuffer a 800x600</ti>
</tr>
<tr>
<ti>1024</ti>
<ti>modalità  framebuffer a 1024x768 (predefinita)</ti>
</tr>
<tr>
<ti>1280</ti>
<ti>modalità  framebuffer a 1280x1024</ti>
</tr>
<tr>
<ti>nofb</ti>
<ti>modalità  framebuffer disabilitata</ti>
</tr>
<tr>
<ti>smp</ti>
<ti>avvia un kernel smp in modalità noframebuffer</ti>
</tr>
<tr>
<ti>acpi</ti>
<ti>abilita &quot;acpi=on&quot; e carica i moduli acpi durante l'init</ti>
</tr>
<tr>
<ti>memtest</ti>
<ti>avvia il programma di controllo della memoria</ti>
</tr>
</table>
<p>
<table>
<tr>
<th>Opzioni di avvio disponibili.</th>
<th>descrizione</th>
</tr>
<tr>
<ti>doataraid</ti>
<ti>carica i moduli ide raid da initrd</ti>
</tr>
<tr>
<ti>dofirewire</ti>
<ti>fa il &quot;modprobe&quot; dei moduli firewire nel initrd (per i cdrom
firewire, ecc)</ti></tr>
<tr>
<ti>dokeymap</ti>
<ti>abilita la selezione della keymap per tastiere non americane</ti>
</tr>
<tr>
<ti>dopcmcia</ti>
<ti>esegue il servizio &quot;pcmcia&quot;</ti>
</tr>
<tr>
<ti>doscsi</ti>
<ti>ricerca le periferiche scsi (si blocca con alcune schede ethernet)</ti>
</tr>
<tr>
<ti>noapm</ti>
<ti>disabilita il caricamento del modulo &quot;apm&quot;</ti>
</tr>
<tr>
<ti>nodetect</ti>
<ti>non caricherà  &quot;hotplug&quot; e
&quot;hwsetup/kudzu&quot;</ti></tr>
<tr>
<ti>nodhcp</ti>
<ti>non sarà  fatto partire automaticamente il
dhcp	una volta rilevata la scheda di rete</ti>
</tr>
<tr>
<ti>nohotplug</ti>
<ti>disabilita il caricamento del servizio di &quot;hotplug&quot;</ti>
</tr>
<tr>
<ti>noraid</ti>
<ti>disabilita il caricamento dei moduli &quot;evms&quot;</ti>
</tr>
<tr>
<ti>nousb</ti>
<ti>disabilita il caricamento da initrd dei moduli usb, disabilita
l'&quot;hotplug&quot;</ti></tr>
<tr>
<ti>ide=nodma</ti>
<ti>disabilita il dma delle periferiche ide malfunzionanti</ti>
</tr>
<tr>
<ti>cdcache</ti>
<ti>Memorizza l'intera porzione &quot;runtime&quot; del cd nella ram. Per questo
	saranno utilizzati 40MB di RAM, ma avrete la possibilità  di fare l'&quot;unmount&quot; di
	/mnt/cdrom e montare un altro cdrom.
</ti>
</tr>
</table>
</p>
<p>
	Una volta premuto ENTER, Linux comincerà a essere caricato da CD e vedrete il classico output
	del caricamento del kernel e i messaggi di initrd.
	Al termine del boot sarete automaticamente loggati come &quot;<c>root</c>&quot;
	e per motivi di sicurezza la password di root sarà impostata ad un valore random. Dovreste ora
	avere il prompt di root (&quot;<c>#</c>&quot;) nella console corrente e poter aprire nuove
	console premendo Alt-F2, Alt-F3 e Alt-F4. Torniamo alla finestra di partenza premendo Alt-F1.
	Dovreste a questo punto scegliere una password per root e digitarla dopo il comando <c>passwd</c>.
</p>
<p>
	Avrete probabilmente notato che sopra il prompt <c>#</c> c'è un testo di aiuto che spiega alcune cose
	su come configurare la scheda di rete e dove poter trovare i file .tar degli stage e i pacchetti nel CD.
</p>
</body>
</section>
</chapter>
<chapter>
<title> Caricare i moduli del kernel</title>
<section>
<body>
<p>
	Se la rilevazione automatica del bus PCI, non funzionasse per qualche periferica, potrete comunque caricare
	i moduli appropriati manualmente. Per vedere la lista di tutte le schede di rete supportate, digitate <c>ls
	/lib/modules/*/kernel/drivers/net/*</c>.
	Per caricare un particolare modulo, digitate:
</p>
<pre caption="Configurazione dei moduli PCI" >
# <i>modprobe pcnet32</i>
<comment>(sostituendo a pcnet32 il modulo della vostra scheda di rete)</comment>
</pre>
<p>
	Se vogliamo riuscire ad accedere a ogni periferica SCSI che non è stata individuta durante il
	processo di auto-identificazione, dovremmo caricare i moduli appropriati da
	/lib/modules, usando ancora <c>modprobe</c>:
</p>
<pre caption="Caricamento dei moduli SCSI" >
# <i>modprobe aic7xxx</i>
<comment>(sostituite a aic7xxx il vostro adattatore SCSI)</comment>
# <i>modprobe sd_mod</i>
<comment>(sd_mod è il modulo per il supporto dei
dischi SCSI)</comment></pre>
<note>
    Il supporto per CD-ROM e dischi SCSI è incluso nel kernel.</note>
<p>
	Se state usando dell'hardware RAID, dovreste caricare i moduli per l'ATA-RAID
	e per il controller RAID
</p>
<pre caption="Caricamento dei moduli RAID" >
# <i>insmod ataraid</i>
# <i>insmod pdcraid</i>
<comment>(Promise Raid Controller)</comment>
# <i>insmod hptraid</i>
<comment>(Highpoint Raid Controller)</comment>
</pre>
<p>
	Il LiveCD di Gentoo dovrebbe aver abilitato il DMA per i vostri dischi.
	Se così non fosse, potete usare <c>hdparm</c> per impostare il DMA sui vostri dischi.
</p>
<pre caption="Impostare il DMA" >
<comment>Sostituite a hdX il device del vostro disco. </comment>
# <c>hdparm -d 1 /dev/hdX </c>
<comment>Abilita il DMA </comment>
# <c>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</c>
<comment>Abilita il DMA e altre opzioni per aumentarne le performance</comment>
# <c>hdparm -X66 /dev/hdX </c>
<comment>Forza/abilita l' Ultra-DMA -- pericoloso -- con alcuni drive può causare dei pasticci
</comment></pre></body>
</section>
</chapter>
<chapter>
<title> Configurare la rete</title>
<section>
<title> E' già tutto a posto?</title>
<body>
<p>
	Se state usando un liveCD 1.4_rc3 o successivo, è possibile che la rete sia già stata configurata
	automaticamente. Se è così potreste essere in grado di usare molti dei comandi orientati alla rete inclusi
	nel LiveCD come, tra gli altri, <c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c>
	e <c>lynx</c>.
</p>
<p>
	Se la configurazione della rete è andata a buon fine, il comando <c>/sbin/ifconfig</c> dovrebbe mostrarvi
	le interfacce di rete come <c>lo</c> e <c>eth0</c>:
	</p>
	<pre caption="/sbin/ifconfig per schede di rete configurate" >
eth0  Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
	inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
	inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
	RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
	TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
	collisions:1984 txqueuelen:100
	RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
	Interrupt:11
</pre>
<p>
	Potete anche provare a eseguire un ping verso il server DNS del vostro
	provider (che trovate in <path>/etc/resolv.conf</path>) e verso un sito
	web di vostra scelta, giusto per vedere che tutti i pacchetti raggiungano
	la rete e la risoluzione dei nomi DNS funzioni correttamente.
</p>
<pre caption="Test della rete" >
# <c>ping -c 3 www.gentoo.it </c>
</pre>
<p>
	Riuscite ad usare la rete? Allora potete saltare il resto di questa sezione.
</p>
</body>
</section>
<section>
<title> Configurazione del PPPoE </title>
<body>
<p>
	Assumendo che abbiate bisogno di PPPoE per connettervi a internet,
	su qualsiasi versione del livecd abbiamo cercato di rendervi le cose
	più facili includendo <i>rp-pppoe</i>. Usate lo script <i>adsl-setup</i>
	per configurare la vostra connessione. Vi verrà richiesto il device a cui
	è connesso il vostro modem adsl, il vostro username e la password,
	l'indirizzo del DNS, e se avete bisogno di un firewall minimo oppure no.
</p>
<pre caption="Configurazione di PPPoE" >
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>
<p>
	Se qualcosa andasse storto, assicuratevi che lo username e la password immessi
	siano esatti, dando un'occhiata al file <path>/etc/ppp/pap-secrets</path> o
	<path>/etc/ppp/chap-secrets</path>, e che stiate usando il corretto device ethernet.
</p>
</body>
</section>
<section>
<title> Configurazione automatica della rete</title>
<body>
<p>
	Se la configurazione automatica non è andata a buon fine, la via più semplice per configurare
	la rete è eseguire lo script <c>net-setup</c>:
</p>
<pre caption="Net-Setup Script" >
# <i>net-setup eth0</i>
</pre>
<p>
	Naturalmente se preferite, potete ancora configurare il network manualmente, come vedremo in seguito.
</p>
</body>
</section>
<section>
<title> Configurazione manuale del DHCP</title>
<body>
<p>
	Configurare una rete DHCP è semplice; se il vostro provider non usa DHCP, passate al paragrafo
	&quot;Configurazione statica&quot;.
</p>
<pre caption="Configurazione di una rete DHCP" >
# <i>dhcpcd eth0</i>
</pre>
<note>
	Alcuni provider richiedono un hostname. Per fare questo aggiungete un flag <c>-h nomehost</c>
	nella riga di comando del dhcpcd.
</note>
<p>
	Non vi spaventate se ricevete messaggi di avviso da<i>dhcpConfig</i>; niente panico;
	gli errori non sono quasi mai degni di nota.
	Potete continuare col paragrafo &quot;Test della rete&quot;.
</p>
</body>
</section>
<section>
<title> Configurazione manuale della rete</title>
<body>
<p>
	E' necessario configurare la rete per scaricare i sorgenti e compialre
	la vostra [distribuzione] Gentoo Linux.
	Digitate i seguenti comandi sostituendo a $IFACE la vostra interfaccia di rete
	(di solito <c>eth0</c>), a $IPNUM il vostro indirizzo IP,
	a $BCAST il vostro indirizzo di broadcast, e a $NMASK la vostra network mask.
	Per il comando <c>route</c>, invece, sostituite a $GTWAY l'indirizzo
	IP del vostro gateway.
</p>
<pre caption="Configurazione della rete con IP statico" >
# <i>/sbin/ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</i>
</pre>
<p>
	E' il momento di creare il file <path>/etc/resolv.conf</path> in modo
	tale che sia possibile la risoluzione dei nomi.
	(In questo modo possiamo raggiungere siti Web/FTP direttamente
	col nome piuttosto che attraverso l'indirizzo IP).
</p>
<p>Segue un esempio da seguire per la creazione del vostro /etc/resolv.conf:</p>
<pre caption="esempio di /etc/resolv.conf" >
domain miodominio.it
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
<p>
	Sostituite a <c>10.0.0.1</c> e a <c>10.0.0.2</c>
	l'indirizzo IP del vostro server DNS primario e secondario rispettivamente.
</p>
</body>
</section>
<section>
<title>Configurazione della rete con un Proxy</title>
<body>
<p>
	Se siete all'interno di un proxy, è necessario configurare
	il vostro proxy prima di continuare. Per questo dovremo esportare
	alcune variabili.
</p>
<pre caption="Configurazione di un proxy" >
# <i>export http_proxy=&quot;machine.company.com:1234&quot; </i>
# <i>export ftp_proxy=&quot;$http_proxy&quot; </i>
# <i>export RSYNC_PROXY=&quot;$http_proxy&quot; </i>
</pre>
</body>
</section>
<section>
<title> La rete funziona!</title>
<body>
<p>
	La rete dovrebbe essere ora configurata e funzionante.
	Dovreste essere in grado di usare i comandi
	<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> e <c>wget</c> per connettervi
	ad altre macchine nella vostra LAN o ad Internet.
</p>
</body>
</section>
<section>
<title> La rete non funziona!</title>
<body>Se la vostra rete non funziona, potrete trovare aiuto sui
		<uri link="http://forums.gentoo.org/" >Forum di Gentoo</uri>.
		Alcuni link utili possono essere trovati su
<uri>http://forums.gentoo.org/viewtopic.php?t=43025</uri>.
</body>
</section>
</chapter>
<chapter>
<title> Aggiorniamo la data e l'ora del nostro sistema</title>
<section>
<body>
<p>
            E' necessario aggiornare la data e l'ora del nostro sistema.
            Possiamo farlo usando il comando <c>date</c>
</p>
<pre caption="Aggiornamento della data del sistema" >
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(Se la data è sbagliata correggetela col
comando che segue)</comment>
# <c>date 022709042003</c>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>
</body>
</section>
</chapter>
<chapter>
<title> Filesystem, partizioni e device a blocchi (block devices)</title>
<section>
<title> Introduzione ai device a blocchi</title>
<body>
<p>
	In questa sezione, prenderemo in esame gli aspetti concernenti i dischi su
	Gentoo Linux e Linux in generale, includendo Linux filesystem, partizioni e
	device a blocchi. Quindi, una volta che avrete preso familarità  con tutto
	ciò che riguarda dischi e filesystem, sarete guidati attraverso il processo di
	configurazione delle partizioni e filesystem per la vostra installazione di Gentoo Linux.
</p>
<p>
	Iniziamo con l'introdurre i &quot;device a blocchi&quot;. La periferica a
	blocchi più famosa è probabilmente quella che rappresenta il primo drive
	IDE in un sistema Linux:
</p>
<pre caption="/dev/hda, il device a blocchi che rappresenta il disco master
sull'IDE primario nelvostro sistema" >
/dev/hda
</pre>
<p>
	Se il vostro sistema usa periferiche SCSI, il vostro primo disco sarà :</p>
<pre caption="/dev/sda, il device a blocchi che rappresenta il primo drive
logico SCSInel vostro sistema" >
/dev/sda
</pre>
<p>
	Il device a blocchi rappresenta una interfaccia <i>astratta</i> del disco.
	Programmi utente possono usare questi device a blocchi per interagire
	col vostro disco senza preoccuparsi se il vostro disco è IDE, SCSI o qualcos'altro.
	I programmi possono semplicemente indirizzare la scrittura su disco come un insieme
	di blocchi da 512 bytes, contigui e accessibili	in modo casuale.
</p>
</body>
</section>
<section>
<title> Partizioni e fdisk</title>
<body>
<p>
	Sotto Linux, creiamo i filesystem usando uno speciale comando
	chiamato <c>mkfs</c> (o <c>mke2fs</c>, <c>mkreiserfs</c>, ecc.)
	specificando un device a blocchi come argomento sulla linea di comando.
</p>
<p>
	Comunque, anche se è teoricamente possibile usare un intero disco
	come <c>/dev/hda</c> o <c>/dev/sda</c> per allocare un singolo
	filesystem, non è mai fatto in pratica. Al contrario, interi dischi sono
	suddivisi in piccoli e più maneggevoli device a blocchi chiamati
	&quot;partizioni&quot;. Queste partizioni sono create usando uno strumento
	chiamato <c>fdisk</c>, che è usato per creare e modificare le tabelle delle
	partizioni (partition table) memorizzate in ogni disco. La tabella della partizione
	definisce esattamente come suddividere l'intero disco.
</p>
<p>
	Possiamo dare un'occhiata a una partition table eseguendo <c>fdisk</c>,
	specificando il device a blocchi che rappresenta l'intero disco come
	argomento:
</p>
<note>Interfacce alternative per la partition table includono <c>cfdisk</c>,
<c>parted</c> e <c>partimage</c>.</note>
<pre caption="Eseguiamo fdisk" >
# <c>fdisk /dev/hda</c>
</pre>
<p> o </p>
<pre caption="Eseguiamo fdisk per vedere una partition table su /dev/sda" >
# <c>fdisk /dev/sda</c>
</pre>
<note>
<b>Nota che <i>non</i> dovreste né salvare,
né fare dei cambiamenti alla partition table del
disco se le sue partizioni contengono filesystem che sono in uso o contengono
dati importanti. Altrimenti potreste causare la perdita dei dati del disco.</b>
</note>
<p>
	Una volta all'interno di fdisk, dovreste ricevere un benvenuto attraverso un
	promptche dovrebbe assomigliare a questo:
</p>
<pre caption="Il prompt di fdisk" >
Command (m for help):
</pre>
<p>
	Digitate <c>p</c> per visualizzare la configurazione corrente delle
	partizioni del disco:
</p>
<pre caption="Un esempio di configurazione delle partizioni" >
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>
<p>
	Questo disco in particolare, è configurato per
	contenere sette filesystem Linux (ognuna con una partizione corrispondente
	elencata come &quot;Linux&quot;) così come una
	partizione di swap (elencata come &quot;Linux swap&quot;).</p>
<p>
	Notate il nome del device a blocchi corrispondente alla partizione, sulla
	prima colonna di sinistra, partendo da <c>/dev/hda1</c>, per arrivare a
	<c>/dev/hda9</c>. Ai primordi dell'era dei computer, i programmi per il
	partizionamento permettevano al massimo quattro partizioni (chiamate
	partizioni &quot;primarie&quot;). Questo era troppo limitativo,
	così fu creato un compromesso chiamato
	<i>partizione estesa</i>. Una partizione estesa è molto simile ad una primaria
	e viene contata all'interno delle quattro. Comunque, una partizione estesa può
	contenere un numero illimitato di partizioni chiamate <i>logiche</i>, provvedendo
	in modo significativo ad aggirare il limite delle quattro partizioni.
</p>
<p>
	Tutte le partizioni a partire dalla <c>hda5</c> sono partizioni logiche.
	I numeri da 1 a 4 sono riservati per partizioni primarie o estese.
</p>
<p>
	Così nel nostro esempio, <c>hda1</c> fino a <c>hda3</c> sono partizioni
	primarie. <c>hda4</c> è una partizione estesa che contiene le partizioni
	logiche da <c>hda5</c> a <c>hda9</c>. Non dovreste mai usare
	<c>/dev/hda4</c> per crearvi filesystem direttamente, è solo un contenitore
	per le partizioni da <c>hda5</c> a <c>hda9</c>.
</p>
<p>
	Nota inoltre che ogni partizione ha un &quot;Id&quot; chiamato anche
	&quot;partition type&quot; (&quot;tipo di partizione&quot;).
	Ogni volta che create una partizione, dovreste assicurarvi che il
	tipo di partizione sia configurato correttamente. '83' è il
	tipo di partizione corretto per partizioni che conterranno un filesystem
	Linux, mentre '82' è il corretto tipo per partizioni per lo swap di Linux.
	Potete impostare il tipo di partizione usando l'opzione <c>t</c> in
	<c>fdisk</c>. Il kernel di Linux usa l'impostazione del tipo di partizione per
	determinare automaticamente all'avvio i filesytem e i device di swap del disco.
</p>
</body>
</section>
<section>
<title>Usiamo fdisk per partizionare il disco</title>
<section>
<body>
<p>
	Ora che avete avuto un'introduzione sul modo in cui un disco è partizionato sotto Linux
	è il momento di configurare le partizioni del disco per la vostra [distribuzione] Gentoo Linux.
	Dopo ci sposteremo attraverso il processo di creazione delle partizioni che dovrebbero alla
	fine apparire così:
</p>
<pre caption="La configurazione delle partizione che dovreste avere al termine dei prossimi passi" >
>Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>
<p>
	In questa configurazione, abbiamo tre partizioni. La prima (<c>/dev/hda1</c>),
	all'inizio del disco, è una piccola partizione chiamata boot partition. Lo scopo della
	partizione di avvio è quello di contenere tutti i dati critici che hanno relazione col boot
	-- le informazioni per il boot loader GRUB (se userete GRUB) e i vostri kernel. La
	partizione di boot ci dà un posto sicuro dove memorizzare tutto ciò che ha
	relazione con l'avvio di Linux. Durante il normale uso di Gentoo Linux, la partizione
	di avvio dovrebbe rimanere <e>non montata</e> per sicurezza. Se state
	configurando un sistema SCSI, la vostra partizione di boot sarà <c>/dev/sda1</c>.
</p>
<p>
	E' raccomandato avere la partizione di avvio (contenente ogni cosa necesaria per il
	lavoro del boot loader) all'inizio del disco. Non è più richiesto, ma è una tradizione
	dai giorni in cui il lilo boot loader non riusciva a caricare kernel dai filesystem che
	superavano i 1024 cilindri del disco.
</p>
<p>
	La seconda partizione (<c>/dev/hda2</c>) è usata come swap space. Il kernel usa
	lo swap come memoria virtuale quando la RAM comincia a scarseggiare. Questa
	partizione, parlando relativamente, non è molto grande, di solito	attorno ai 512MB.
	Se state configurando sistemi SCSI, questa partizione sarà  chiamata <c>/dev/sda2</c>.
</p>
<p>
	La terza partizione (<c>/dev/hda3</c>) è abbastanza grande e occupa il resto del disco.
	Questa partizione è chiamata &quot;root&quot; partition e sarà  usata per memorizzare
	il filesystem principale che ospita [la distribuzione] Gentoo Linux stessa. Su sistemi SCSI,
	questa partizione sarà  <c>/dev/sda3</c>.
</p>
<p>
	Prima di partizionare il disco, ecco una veloce descrizione tecnica
	delle partizioni suggerite e dei filesystem da usare quando installate
	Gentoo Linux:
</p>
<table>
<tr>
<th>Partizione</th>
<th>Dimensione</th>
<th>Tipo</th>
<th>esempio di device</th>
</tr>
<tr>
<ti>partizione di avvio, contenente il/i kernel e informazioni per il boot</ti>
<ti>100 Megabyte</ti>
<ti>ext2/3 caldamente raccomandata; se ReiserFS montarla con <c>-o notail</c>
</ti>
<ti>/dev/hda1</ti>
</tr>
<tr>
<ti>swap partition (non più limitata a 128
Megabyte, ora 2GB)
</ti>
<ti>Generalmente, configurate un'area di swap che sia da
una a due volte la dimensione della RAM fisica sul vostro sistema.
</ti>
<ti>Linux swap</ti>
<ti>/dev/hda2</ti>
</tr>
<tr>
<ti>partizione principale (root), contenente il filesystem principale (/usr,
/home, etc)
</ti>
<ti>>=1.5 Gigabytes</ti>
<ti>ReiserFS, ext3 raccomandata; ext2 ok</ti>
<ti>/dev/hda3</ti>
</tr>
</table>
<p>
	Creiamo ora le partizioni, come nell'esempio e nella tabella precedente.
	Prima entriamo in fdisk digitando <c>fdisk /dev/hda</c> o <c>fdisk
	/dev/sda</c>, a seconda che stiamo usando dischi IDE o SCSI. Quindi digitiamo
	<c>p</c> per vedere la configurazione corrente. C'è qualcosa sul disco che
	desiderate mantenere? Se così fosse, <b>fermatevi adesso</b>. Se continuate
	in questa direzione, <b>tutti i dati esistenti sul vostro disco saranno cancellati.</b>
</p>
<impo>
	Seguendo le istruzioni che seguono, tutti i dati presenti sul vostro
	disco <b>saranno cancellati</b>! Se c'è qualcosa sul vostro disco,
	assicuratevi che non siano informazioni importanti. Assicuratevi inoltre
	di <b>avere selezionato l'unità corretta</b> in modo da non cancellare
	erroneamente dei dati da un disco sbagliato.
</impo>
<p>
	E' il momento di cancellare ogni partizione esistente. Per fare questo,
	digitate <c>d</c> e premete Enter. Vi sarà richiesto il numero di partizione
	che volete cancellare. Per cancellare la partizione pre-esistente <c>/dev/hda1</c>,
	dovreste dare i seguenti comandi:
</p>
<pre caption="Cancellare una partizione" >
Command (m for help): d
Partition number (1-4): 1
</pre>
<p>
	La partizione è stata predisposta per la cancellazione. Non la rivedrete
	se digitate <c>p</c>, ma non sarà realmente cancellata fino a quando
	non salverete le vostre modifiche. Se avete sbagliato qualcosa o volete
	uscire senza salvare le modifiche, digitate <c>q</c> immediatamente
	e premete enter e le vostre partizioni non saranno cancellate.
</p>
<p>
	Assumendo ora che la vostra intenzione sia di eliminare tutte le
	partizioni dal vostro sistema, digitate ripetutamente <c>p</c> per
	visualizzare la lista delle partizioni e quindi <c>d</c> e il numero della
	partizione da cancellare. Alla fine dovreste avere una partition table
	vuota:
</p>
<pre caption="Una partition table vuota" >
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>
<p>
	Ora che la partition table in memoria è vuota, siamo pronti per creare
	una partizione di avvio. Per questo, digitate <c>n</c> per creare una
	nuova partizione, quindi <c>p</c> per istruire fdisk che volete una partizione
	primaria. Quindi digitate <c>1</c> per creare la prima partizione primaria.
	Quando vi viene richiesto il primo cilindro, premete enter. Quando vi viene
	richiesto l'ultimo cilindro, digitate <c>+100M</c> per creare una partizione di
	100MB. Segue l'output di questi passi:
</p>
<pre caption="Passi per creare la vostra partizione di avvio" >
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +100M
</pre>
<p>Ora, quando digiterete <c>p</c>, dovreste vedere il seguente estratto:</p>
<pre caption="Our first partition has been created" >
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>
<p>
	Dopo, create la partizione di swap. Per fare questo, digitate <c>n</c> per
	creare una nuova partizione, quindi <c>p</c> per istruire fdisk che volete
	una partizione primaria. Quindi <c>2</c> per creare una seconda partizione
	primaria, <c>/dev/hda2</c> nel nostro caso. Quando vi viene richiesto il
	primo cilindro, premete enter. Quando viene richiesto l'ultimo cilindro,
	digitate <c>+512M</c> per creare una partizione di 512MB. Fatto questo,
	digitate <c>t</c> per impostare il tipo di partizione, e quindi digitate
	<c>82</c> per impostare la partition type su &quot;Linux Swap&quot;. Dopo aver
	completato questi passi, digitate <c>p</c> per avere una schermata
	della partition table che dovrebbe apparire come segue:
</p>
<pre caption="La vostra partizione di swap è
stata creata" >Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>
<p>
	Finalmente create la partizione root. Per questo, digitate <c>n</c> per
	creare una nuova partizione, quindi <c>p</c> per istruire fdisk che
	volete una partizione primaria. Quindi digitate <c>3</c> per creare la
	terza partizione primaria, <c>/dev/hda3</c> nel nostro caso.
	Quando vi viene richiesto il primo cilindro, premete enter. Stessa cosa
	quando viene richiesto l'ultimo cilindro, in modo da creare una partizione
	che usi lo spazio rimanente del disco. Dopo aver completato questi passi,
	digitate <c>p</c> per avere una schermata	della partition table che
	dovrebbe apparire come segue:
</p>
<pre caption="La vostra partizione root è stata creata" >
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>
<p>
	Avete ora bisogno di impostare il flag &quot;bootable&quot; nella
	partizione di boot a quindi scrivere le modifiche sul disco.
	Per rendere la partizione <c>/dev/hda1</c> come &quot;bootable&quot;,
	digitate <c>a</c> nel menu e quindi <c>1</c> come numero di partizione.
	Se ora digitate <c>p</c>, dovreste vedere che <c>/dev/hda1</c> ha un
	<c>*</c> nella colonna &quot;Boot&quot;. Le vostre partizioni sono
	configurate appropriatamente per l'installazione di Gentoo.
</p>
<note>Se <c>fdisk</c> o <c>cfdisk</c> richiedessero di riavviare il sistema,
fatelo,in modo da permettere al sistema di rilevare la nuova configurazione
delle partizioni.</note>
</body>
</section>
<title>Creazione dei filesystem</title>
<body>
<p>
	Ora che le partizioni sono state create, è il momento di creare i filesystem
	sulle partizioni boot e root in modo tale che possano essere montate e
	usate per la memorizzazione dei dati. Configurerete anche la partizione di swap.
</p>
<p>
	Gentoo Linux supporta una grande varietà  di tipi differenti di filesystem ognuno
	dei quali ha i propri punti di forza e debolezze e un proprio set di caratteristiche
	che riguardano le performance. Attualmente è supportata la creazione di filesystem
	ext2, ext3, XFS, JFS e ReiserFS.
</p>
<p>
	ext2 è il vero e proprio filesystem di Linux ma non ha il supporto per il &quot;metadata
	journaling&quot;, il che significa che routine che effettuano il controllo sui filesystem
	ext2 all'avvio possono sprecare diverso tempo. C'è adesso una scelta abbastanza
	varia di filesystem <i>journaled</i> di nuova generazione che possono essere scelti
	per la loro consistenza e sono generalmente preferiti alle controparti non-journaled.
	I filesystem di tipo &quot;journaled&quot; prevengono i lunghi tempi di attesa quando
	riavviate il vostro sistema e i vostri filesystem appaiono in uno stato <i>inconsistente</i>.
</p>
<p>
	ext3 è la versione &quot;journaled&quot; del filesystem ext2 e provvede il &quot;metadata
	journaling&quot; per un veloce recupero (recovery) dei dati in aggiunta ad altre caratteristiche
	di journaling avanzate come il &quot;full data&quot; e l'&quot;ordered data journaling&quot;.
	ext3 è veramente un buon filesystem oltre che affidabile. Offre generalmente performance decenti
	in molte condizioni. Dato che non impiega estensivamente l'uso di &quot;trees&quot; nel suo
	design interno, non scala molto bene, il che significa che non è una scelta ideale per filesystem
	molto grandi o situazioni dove deve manipolare grandi quantità di dati in una singola directory
	o file molto grandi. Ma se usato in un ambiente a lui congeniale per il design con cui è stato
	pensato, ext3 è un eccellente filesystem.
</p>
<p>
	ReiserFS è un filesystem basato su B*-tree che ha ottime performance su file di piccole dimensioni
	e velocità  superiori a ext2 e ext3 con file di dimensioni minori di 4k, spesso di un fattore 10x-15x.
	ReiserFS scala inoltre molto bene e supporta il metadata journaling. Dal kernel 2.4.18+, ReiserFS
	ha raggiunto la solidità che lo porta a essere raccomandato caldamente sia per un uso generico
	che per casi estremi come la creazione di grandi filesystem, l'uso su molti file piccoli, file molto grandi
	e directory contenenti decine di migliaia di file. ReiserFS è il filesystem che raccomandiamo di default per
	tutte le partizioni non boot.
</p>
<p>
	XFS è un filesystem con tecnologia meta-data journaling che è completamente supportato in Gentoo
	Linux dal kernel <path>xfs-sources</path>, arriva con un robusto set di caratteristiche ed è
	ottimizzato per la scalabilità . Ne raccomandiamo l'uso su sistemi Linux con high-end SCSI 	e/o unità
	di memorizzazione su canali in fibra e connessi a UPS. Data l'aggressività con la quale XFS fa il cache in
	RAM dei dati in transito, programmi progettati in modo non appropriato (quelli che non prendono
	precauzioni quando scrivono file su disco, e ce ne sono abbastanza) possono perdere una discreta
	quantità di dati se il sistema si arresta in modo inaspettato.
</p>
<p>
	JFS è il filesystem journaling ad alte prestazioni di IBM. E' recentemente diventato pronto per il mercato,
	ma a oggi non è stato sufficientemente provato per fare commenti positivi o negativi sulla sua generale
	stabilità .
</p>
<p>
	Se siete interessati al filesystem più robusto, usate ext3. Se siete invece interessati a un filesystem ad alte
	prestazioni con il supporto journaling, usate ReiserFS; sia ext3 che ReiserFS sono maturi e perfezionati.
</p>
<p>
	In base agli esempi e a quanto detto in precedenza, useremo i seguenti comandi
	per inizializzare tutte le nostre partizioni:
</p>
<pre caption="Inizializzazione delle partizione (esempio)" >
# <c>mke2fs -j /dev/hda1</c>
# <c>mkswap /dev/hda2</c>
# <c>mkreiserfs /dev/hda3</c>
</pre>
<p>
	Abbiamo scelto ext3 per la partizione di avvio <c>/dev/hda1</c> perché è un
	robusto filesystem con il journaling supportato dalla maggioranza dei boot loaders.
	Abbiamo usato <c>mkswap</c> per la partizione di swap	<c>/dev/hda2</c> (e qui la
	scelta è ovvia). E per il nostro filesystem principale su <c>/dev/hda3</c> abbiamo scelto
	ReiserFS, dato che è un solido filesystem con il journaling il quale offre eccellenti performance.
	Ora andate avanti e inizializzate le vostre partizioni.
</p>
<p>
	Come vostro riferimento, ecco i vari comandi <c>mkfs</c> tipo disponibili
	durante il processo di installazione:
</p>
<p>
<c>mkswap</c> è il comando usato per creare partizioni di swap:
</p>
<pre caption="Inizializzare lo Swap" >
# <c>mkswap /dev/hda2</c>
</pre>
<p>Potete usare ilcomando <c>mke2fs</c> per creare filesystem ext2:
</p>
<pre caption="Creazione di un Filesystem ext2" >
# <i>mke2fs /dev/hda1</i>
</pre>
<p>Se vi piacesse usare ext3, potrete creare filesystem ext3 usando <c>mke2fs -j</c>:
</p>
<pre caption="Creazione di un Filesystem ext3" >
# <c>mke2fs -j /dev/hda3</c>
</pre>
<note>Potete trovare maggiori informazioni sull'uso di ext3 sotto Linux 2.4 all'indirizzo
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
</note>
<p>Per creare filesystem ReiserFS, usate il comando <c>mkreiserfs</c>:
</p>
<pre caption="Creazione di un Filesystem ReiserFS" >
# <c>mkreiserfs /dev/hda3</c>
</pre>
<p>
	Per creare filesystem XFS usiamo il comando <c>mkfs.xfs</c>:
</p>
<pre caption="Creazione di un Filesystem xfs" >
# <i>mkfs.xfs /dev/hda3</i>
</pre>
<note>
	Potete voler aggiungere un paio di flag in più al comando <c>mkfs.xfs</c>:
	<c>-d agcount=3 -l size=32m</c>. Il flag <c>-d agcount=3</c> abbassa
	il numero dei gruppi di allocazione. XFS insiste usando almeno 1 gruppo di
	allocazione per ogni 4 GB di partizione, così, per esempio, se avete una
	partizione di 20GB avreste bisogno di 5 gruppi (agcount) come minimo.
	Il flag <c>-l size=32m</c> porta a 32 MB la grandezza del journal,
	incrementando le performance.
</note>
<p>
    Per creare un filesystem JFS, usate il comando <c>mkfs.jfs</c>.
</p>
<pre caption="Creazione di un Filesystem JFS" >
# <c>mkfs.jfs /dev/hda3</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Fare il &quot;mount&quot; delle partizioni</title>
<section>
<body>
<p>
	E' il momento di attivare la vostra partizione
	di swap, che vi servirà
	in seguito come memoria virtuale aggiuntiva:
</p>
<pre caption="Attiviamo lo SWAP" >
# <i>swapon /dev/hda2</i>
</pre>
<p>
	Poi, creerete i mountpoint (letteralmente: punti di montaggio)
	<path>/mnt/gentoo</path> e <path>/mnt/gentoo/boot</path>, e quindi
	vi monterete i vostri filesystem. Se avete deciso di creare <path>/usr</path>
	o <path>/var</path> come partizioni separate, dovrebbero essere
	rispettivamente montate in <path>/mnt/gentoo/usr</path> e
	<path>/mnt/gentoo/var</path>. (N.d.T. la partizione /var dovrà essere molto
	campiente in quanto conterrà la directory temporanea del sistema Portage
	per la compilazione	dei pacchetti.)
</p>
<impo>
	Se la partizione di <e>boot</e> (dove risiede il
	kernel) è ReiserFS,
	dovrete essere sicuri di montarla con
	l'opzione <c>-o notail</c> in modo tale che GRUB possa essere installato
	correttamente. Dovrete anche assicurarvi che <c>notail</c> termini la riga che
	si riferisce alla partizione di avvio in <path>/etc/fstab</path>.
	Ritorneremo brevemente su questo punto.
</impo>
<pre caption="Creazione dei mount points" >
# <i>mkdir /mnt/gentoo</i>
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>
<impo>
    Se state avendo problemi a montare la vostra partizione di boot con ext2,
    riprovate usando <c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>
</impo>
</body>
</section>
</chapter>
<chapter>
<title> I file .tar dello stage, e chroot</title>
<section>
<title> Ottenere il file .tar dello stage desiderato</title>
<body>
<p>
	Se non lo aveste ancora fatto, è il momento di decidere quale stage usare
	come base per l'installazione.
</p>
<p>
	Alternativamente, se avete il LiveCD denominato &quot;basic&quot;, il file
	.tar dello stage1 è ancora disponibile sul CD in <path>/mnt/cdrom/gentoo</path>.
	Dovrete in seguito fare comunque un download degli altri stage e metterli
	in <path>/mnt/gentoo</path>.
</p>
<p>
	Se state usando il metodo di installazione &quot;from scratch, build
	everything&quot; (&quot;costruisci tutto da zero&quot;), dovrete usare
	l'immagine <path>stage1-ix86-1.4_rc4.tbz2</path>. Se invece state
	usando uno dei CD di grosse dimensioni come la ISO &quot;3stages&quot;,
	avrete anche la possibilità di scegliere tra le immagini stage2 e stage3.
	Queste immagini vi permettono di risparmiare tempo a spesa della
	configurabilità dato che abbiamo scelto noi le ottimizzazione per il
	compilatore e le variabili USE di default. Sul CD gli stage sono accessibili
	in <path>/mnt/cdrom/gentoo</path> e puoi digitare <c>ls /mnt/cdrom/gentoo</c>
	per vedere cos'è disponibile sul vostro CD.
</p>
<p>
	Se avete scelto di eseguire l'installazione usando un file .tar di stage che
	<i>non</i> è sul nostro CD, è possibile ma avrete bisogno si scaricare lo
	stage che volete usando le seguenti istruzioni. Se, invece, avete già  lo
	stage tarball che volete usare, procedete con la sezione &quot;Scomprimere
	l'immagine che desiderate usare&quot;
</p>
<pre caption="Download degli stages richiesti" >
# <c>cd /mnt/gentoo</c>
<comment>Usate lynx per scaricare il file .tar:</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc4/x86/</c>
<comment>
	Usate i tasti cursore <c>Up</c> e <c>Down</c> (o il tasto <c>TAB</c>) per
	andare nella directory corretta ed evidenziare lo stage che volete scaricare.
	Premete <c>d</c> per iniziare il download, salvate il file e uscite dal browser.
	<b>O</b> usate wget da linea di comando:
</comment>
# <c>wget <comment>inserite qui l'URL del file .tar con lo stage che volete</comment></c>
</pre>
</body>
</section>
<title> Scomprimere l'immagine che desiderate usare</title>
<section>
<body>
<p>
	E' ora il momento di estrarre il file .tar dello stage che avete scelto
	in <path>/mnt/gentoo</path>. Dovrete estrarre solo lo stage da
	cui volete partire, se avete scelto di partire dallo stage3 dovrete
	estrarre solo il file .tar dello stage3.
	Estraete l'immagine come segue:
</p>
<impo>
	Ricordatevi di usare l'opzione <c>p</c> col comando tar.
	Altrimenti alcuni file potrebbero
	ricevere permessi errati
</impo>
<pre caption="Scomprimere lo stage" >
# <c>cd /mnt/gentoo</c>
<comment>
	Sostituite &quot;stage2&quot; o &quot;stage1&quot; a &quot;stage3&quot;
	se volete partire da uno stage diverso dal 3.
</comment>
<comment>
	Se scaricate il file .tar del vostro stage, cambiate il percorso che segue con
	&quot;/mnt/gentoo/&quot;invece di &quot;/mnt/cdrom/gentoo/&quot;.
</comment>
#<c>tar -xvjpf /mnt/cdrom/gentoo/stage3-*.tar.bz2</c>
</pre>
<p>
	Se avete scaricato il il file .tar del vostro stage in <path>/mnt/gentoo</path>,
	potrete rimuoverlo digitando <c>rm /mnt/gentoo/stage*.tar.bz2</c>.
</p>
</body>
</section>
<section>
<title>Digitiamo il &quot;chroot&quot;</title>
<body>
<p>
	Il prossimo passo sarà di &quot;entrare&quot; nel nuovo sistema Gentoo Linux tramite
	<c>chroot</c> dall'ambiente di installazione.
</p>
<note>
	Potreste ricevere notifica durante <c>env-update</c> dicendo che
	<path>/etc/make.profile/make.defaults</path> non è disponibile (isn't available): ignoratelo.
	Andrete a eseguire <c>emerge sync</c> in seguito che risolverà questo problema.
</note>
<pre caption="Preparazione ed ingresso nell'ambiente chroot" >
# <c>mount -t proc proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
<comment>I passi summenzionati aggiornano i percorsi di ricerca della shell.</comment>
</pre>
<p>
	Dopo aver eseguito questi comandi, sarete &quot;dentro&quot; il nuovo ambiente
	Gentoo Linux in <path>/mnt/gentoo</path>.
	Eseguiremo il resto dell'installazione all'interno di questo ambiente.
</p>
</body>
</section>
</chapter>
<chapter>
<title> Scarichiamo il Portage Tree corrente usando sync</title>
<section>
<body>
<p>
	Dovrete ora eseguire <c>emerge sync</c>. Questo vi assicura di avere la copia più recente
	del Portage tree. Il Portage tree contiene tutti gli script (chiamati ebuild) usati per la compilazione
	di ogni pacchetto sotto Gentoo Linux. Attualmente abbiamo script di ebuild per 4000 pacchetti.
	Una volta che <c>emerge sync</c> sia stato completato, avrete un completo Portage tree in
	<path>/usr/portage</path>.
</p>
<pre caption="Aggiornamento usando sync" >
# <c>emerge sync</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title> Impostare le ottimizzazioni di Gentoo (make.conf)</title>
<section>
<body>
<p>
	Ora che stiamo lavorando su una copia del Portage tree, coloro che usano
	lo stage1 devono effettuare il bootstrap di Gentoo Linux procedendo
	secondo le istruzioni che seguono. Primo: editare il file
	<path>/etc/make.conf</path>. In questo file dovremo impostare ad hoc
	i vari flag <c>USE</c> che servono a specificare quali funzionalità
	supplementari si vogliano includere per la compilazione dei pacchetti.
	In genere le impostazioni di default sono accettabili (ovvero un USE <e>vuoto</e>
	o non configurato).
	Maggiori informazioni sui flag di USE possono essere trovate
	<uri link="http://www.gentoo.org/doc/it/use-howto.xml" >qui</uri>.
	Una lista completa dei flag USE la potete trovare
	<uri link="http://www.gentoo.org/dyn/use-index.xml" >qui</uri>.
</p>
<p>
	Si dovrebbero definire in modo appropriato anche i flag <c>CHOST</c>, <c>CFLAGS</c>
	e <c>CXXFLAGS</c> a seconda del tipo di sistema che si vuol creare (potete trovare
	esempi documentati direttamente in questo file). Queste impostazioni saranno
	usate per dire ai compilatori C e C++ come ottimizzare il codice che deve essere
	generato per il vostro sistema. E' comune, per esempio, per utenti con processori
	Athlon XP specificare un flag &quot;-marc=athlon-xp&quot; sia in CFLAGS che in CXXFLAGS
	in tal modo tutti i pacchetti saranno compilati e ottimizzati con un set di istruzioni e performance
	caratteristiche del processore in uso. Il file <path>/etc/make.conf</path> contiene una guida
	generale riguardo le impostazioni proprie di CFLAGS e CXXFLAGS.
</p>
<p>
	Se necessario, potremmo anche impostare le informazioni sul proxy nel caso vi trovaste dietro
	un firewall. Usate il seguente comando per editare <path>/etc/make.conf</path> usando
	<c>nano</c> un semplice editor visuale.
</p>
<pre caption="Editiamo il make.conf" >
# <i>nano -w /etc/make.conf</i>
<comment>(Sistemiamo CHOST, CFLAGS, CXXFLAGS e ogni impostazione USE o proxy)</comment>
</pre>
<note>
	Coloro che hanno bisogno di personalizzare in modo sostanziale il processo di
	compilazione potrebbero dare uno sguardo al file <path>/etc/make.globals</path>.
	Questo file comprende i parametri predefiniti (default) di Gentoo e non
	dovrebbe mai essere modificato. Se i parametri di default non
	sono sufficienti, i nuovi valori dovrebbero
	essere messi in <path>/etc/make.conf</path>, i valori dei parametri
	di <path>/etc/make.conf</path> <comment>sovrascrivono</comment> gli stessi
	in <path>/etc/make.globals</path>. Se siete interessati a personalizzare le
	impostazioni di USE, guardate in <path>/etc/make.profile/make.defaults</path>.
	Se volete disabilitare alcune impostazioni di USE, aggiungete in <path>/etc/make.conf</path>
	<c>USE=&quot;-flag&quot;</c> per disabilitare i flag. (N.d.T.: p.e. USE=&quot;gnome&quot; includerà
	gnome nella compilazione di programmi che potrebbero avere qualche feature in più includendo
	gnome, ma che sostanzialmente non ne hanno bisogno per il corretto funzionamento, mentre
	USE=&quot;-gnome&quot; non includerà  gnome.)
</note>
</body>
</section>
</chapter>
<chapter>
<title> Partendo dallo Stage1</title>
<section>
<body>
<note>Se non state usando lo stage1, saltate questa sezione.</note>
<p>
	Il file .tar dello stage1 serve per compilare un sistema completamente
	personalizzato e ottimizzato. Se avete scelto questo file state probabilmente
	cercando di avere un sistema ultra ottimizzato. Buon divertimento, perché
	l'ottimizzazione è la cosa più importante di Gentoo Linux. L'installazione partendo
	dallo stage1 prende diverso tempo, ma il risultato è che il sistema verrà ottimizzato
	dalle fondamenta, a seconda della macchina e delle vostre necessità.
</p>
<p>
	Adesso è il momento di incominciare il processo di &quot;bootstrap&quot;. Tale processo
	dura circa due ore sul mio AMD 1200MHz. Durante questo tempo, la &quot;GNU C library&quot;,
	la &quot;suite&quot; del compilatore e altri programmi chiave del sistema. verranno compilati.
	Iniziate il bootstrap come segue:</p>
<pre caption="Bootstrapping" >
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>
<p>Il processo di &quot;bootstrap&quot; avrà inizio adesso.</p>
<note>
	Portage usa per default <c>/var/tmp</c> durante la
	fase di complilazione dei pacchetti, usando spesso
	centinaia di megabyte come area di memorizzazione
	temporanea. Se preferite cambiare dove Portage memorizza i propri
	file temporanei, impostate una nuova variabile PORTAGE_TMPDIR
	<e>prima</e> di far partire il processo di bootstrap
	come segue:
</note>
<pre caption="Cambiare la directory temporanea del PORTAGE" >
# <i>export PORTAGE_TMPDIR=&quot;/altradir/tmp&quot;</i>
</pre>
<p>
	Il comando <c>bootstrap.sh</c> compilerà  i
	pacchetti <c>binutils</c>, <c>gcc</c>,
	<c>gettext</c> e <c>glibc</c>, ricompilando
	<c>binutils</c>, <c>gcc</c> e <c>gettext</c> dopo la
	compilazione delle <c>glibc</c>. Inutile dirlo,
	questo processo durerà  un po' di tempo. Una volta che il processo
	sarà completato, il vostro sistema è in &quot;stage2&quot; il che
	significa che potete andare alle istruzione relative allo stage2.</p>
</body>
</section>
</chapter>
<chapter>
<title> Partendo dallo Stage2 e continuando dallo Stage1</title>
<section>
<body>
<note>
	Questa sezione è per coloro che stanno continuando l'installazione dello stage1 o che
	stanno partendo da uno stage2. Se state usando lo stage3, saltate questa sezione.
</note>
<p>
	Il file .tar dello stage2 ha già il &quot;bootstrapping&quot; fatto per voi. Tutto quello che
	dovete fare è installare il resto del sistema.
</p>
<note>
	Se state partendo da uno stage2 pre-costruito e volete essere sicuri
	che il vostro ambiente di sviluppo (compilatori, librerie, ecc.) siano
	aggiornati, aggiungete una opzione <c>-u</c> al comado che segue. Se
	non sapete cosa significa questo, non tenete in considerazione questo
	suggerimento.
</note>
<pre caption="Installazione del resto del sistema" >
# <c>emerge -p system</c>
<comment>[lista dei pacchetti che devono essere installati]</comment>
# <c>emerge system</c>
</pre>
<p>
	Questo passaggio richiederù un po' di tempo per compilare l'intero sistema di base.
	Il lato positivo è che avrete un sistema veramente ottimizzato. D'altra parte dovrete
	trovare qualcosa da fare. L'autore suggerisce "Star Wars - Super Bombard Racing"
	per la PS2.
</p>
<p>
	La compilazione è ora completa. Andate avanti e saltate alla sezione &quot;Configurazione della time
zone&quot;.
</p>
</body>
</section>
</chapter>
<chapter>
<title> Partendo dallo Stage3</title>
<section>
<body>
<note>
	Questa sezione è per coloro che <b>partono</b> dallo stage3, e non per coloro che sono partiti
	dallo stage 1 o 2 i quali dovrebbero saltare questa sezione.
</note>
<p>
	Il file .tar dello stage3 provvede un sistema Gentoo di base completamente funzionale,
	in questo caso non è necessario nessun processo di compilazione. Comunque, dato che lo
	stage3 è pre-compilato, potrebbe essere un po' datato, e se questo vi preoccupa, potrete
	automaticamente aggiornare il vostro stage3 esistente con le versioni più aggiornate di
	tutti i pacchetti eseguendo i passi che seguono. Nota che questo potrebbe richiedere
	parecchio tempo se lo stage3 è molto vecchio; altrimenti questo processo generalmente
	è veloce e vi permetterà  di beneficiare degli ultimi aggiornamenti e correzioni di bug.
	In ogni caso, sentitevi liberi di saltare questi passi e di procedere con la prossima sezione.
</p>
<pre caption="Otteniamo l'aggiornamento" >
# <c>export CONFIG_PROTECT=&quot;-*&quot;</c>
# <c>emerge -up system</c>
<comment>(lists the packages that would be installed)</comment>
# <c>emerge -u system</c>
<comment>(actually merges the packages)</comment>
# <c>unset CONFIG_PROTECT</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title> Impostare la "time zone"</title>
<section>
<body>
<p>
	E' ora necessario impostare la vostra time zone.
</p>
<p>
	Cercate la vostra Timezone ( o GMT se state usando
	il Greenwich Mean Time) in <path>/usr/share/zoneinfo</path>.
	Poi, create un link simbolico come segue:
</p>
<pre caption="Creazione di un link simbolico per la time zone" >
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>
</body>
</section>
</chapter>
<chapter>
<title> Installare il kernel e il System Logger</title>
<section>
<body>
<note>Se non l'avete ancora fatto, editate <path>/etc/make.conf</path> a vostro piacimento.</note>
<p>
	Avete ora bisogno di scaricare i sorgenti del kernel di Linux. Gentoo provvede sbariate ebuild di kernel,
	un elenco può essere trovato <uri link="/doc/en/gentoo-kernel.xml">qui</uri>. Se siete indecisi circa
	quali sorgenti del kernel scegliere, vi consigliamo il gentoo-sources o il vanilla-sources. Se volete il supporto XFS,
	dovreste scegliere l'xfs-sources.
</p>
<warn>
	Se state configurando il vostro proprio kernel, siate prudenti con l'opzione <i>grsecurity</i>. Essendo troppo
	aggressivi con le impostazioni di sicurezza si potrebbe causare a certi programmi (tipo X) di non funzionare propriamente.
	Se in dubbio, lasciate stare.
</warn>
<p>
	Sceglietene uno e unitelo (emerge) al sistema:
</p>
<pre caption="Installare i sorgenti del kernel" >
# <i>emerge sys-kernel/gentoo-sources</i>
</pre>
<p>
	una volta che il kernel è disponibile, è il momento di personalizzarlo e compilarlo:
</p>
<p>
	Notate che <path>/usr/src/linux</path> è un link simbolico ai sorgenti del kernel attualmente
	installato e che è impostato automaticamente dal Portage al momento dell'emerge. Se avete più
	di un kernel, è necessario impostare il link <path>/usr/src/linux</path> affinché punti ai sorgenti
	corretti, prima di procedere.
</p>
<pre caption="Compilazione del kernel">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
<warn>
	Affinché il vostro kernel funzioni a dovere, ci
	sono alcune opzioni che dovrete essere sicuri siano
	incluse nel kernel e non compilate come modulo.
	Assicuratevi di abilitare &quot;ReiserFS&quot; se avete partizioni
	di questo tipo; la stessa cosa vale per &quot;Ext3&quot;.
	Se state usando partizioni XFS, abilitate l'opzione &quot;SGI XFS
	filesystem support&quot;. E' sempre una buona idea
	lasciare il supporto per ext2 abilitato sia che lo
	usiate o no.
	Seguono alcune opzioni comuni di cui avrete bisogno:
</warn>
<pre caption="opzioni make menuconfig" >
Code maturity level options --->
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(Avete bisogno di questo per delle opzioni che seguono.)</comment>
     ...

File systems --->
  &lt;*> Reiserfs support
<comment>(Solo se avete partizioni ReiserFS.)</comment>
       ...
  &lt;*> Ext3 journalling file system support
<comment>(Solo se avete partizioni ext3.)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Richiesto per Gentoo Linux.)</comment>
       ...
  &lt;*> JFS filesystem support
<comment>(Solo se avete partizioni JFS.)</comment>
       ...
  [*] /proc file system support
<comment>(Richiesto per Gentoo Linux.)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
<comment>(Richiesto per Gentoo Linux.)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(Disabilitate questa, non è
necessaria.)</comment>       ...
  &lt;*> Second extended fs support
<comment>(Solo se avete partizioni ext2.)</comment>
       ...
  &lt;*> XFS filesystem support
<comment>(Solo se avete partixioni XFS.)</comment>
</pre>
<p>
	Se state usando hardware di tipo RAID avrete bisogno di abilitare un paio
	di opzioni in più nel kernel: Per i controller Highpoint RAID, abilitate il supporto
	per il chipset hpt366, per i controller IDE RAID e Highpoint 370 software RAID.
	Per i controller Promise abilitate il supporto PROMISE PDC202{46|62|65|67|68|69|70},
	per i controller IDE RAID e Support Promise software RAID (Fasttrak(tm))
</p>
<p>
	Se usate PPPoE per connettervi a internet, avrete bisogno delle seguenti
	opzioni nel kernel (preferibilmente come moduli): &quot;PPP (point-to-point protocol) support&quot;,
	&quot;PPP support for async serial ports&quot;, &quot;PPP support for sync tty ports&quot;.
	Le due opzioni relative alla compressione non sono strettamente necessarie così come &quot;PPP over Ethernet&quot;
	che potrebbe essere usata solo da <i>rp-ppoe</i> quando il kernel è in modalità PPPoE.
</p>
<p>
	Se avete un masterizzatore IDE, avrete bisogno di abilitare
	l'emulazione SCSI nel kernel. Abilitate &quot;ATA/IDE/MFM/RLL support&quot;
	---> &quot;IDE, ATA and ATAPI Block devices&quot; --->	&quot;SCSI emulation
	support&quot; (abilitato di solito come modulo), qundi sotto &quot;SCSI support&quot;,
	abilitate &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; e
	&quot;SCSI generic support&quot; (abilitati come moduli anche questi).
	Se avete scelto di usarli come moduli, allora digitate <c>echo -e
	&quot;ide-scsi/nsg/nsr_mod&quot; >> /etc/modules.autoload</c> per averli
	automaticamente al boot.
</p>
<note>
	Per coloro che lo preferiscono, è possibile installare una [distribuzione] Gentoo Linux con
	kernel 2.2. Per questo c'è da pagare un prezzo: perdere le ottime caratteristiche che sono
	prerogativa della serie 2.4 del kernel (come il supporto per i filesystem di tipo XFS e tmpfs,
	iptables, e altro), anche se Gentoo Linux con kernel 2.2 può essere aggiornato per il supporto
	a ReiserFS e a devfs. Gli script di boot di Gentoo Linux richiedono che tmpfs o ramdisk siano
	supportati dal kernel, così coloro che vogliono usare il kernel 2.2 devono essere sicuri di avere
	il support per ramdisk incluso nel kernel e non compilato come modulo.
	E' <comment>vitale</comment> che un flag <e>gentoo=notmpfs</e> sia aggiunto in
	<path>/boot/grub/menu.lst</path> nella linea del kernel per la serie 2.2 in modo tale che gli
	script di boot montino ramdisk invece di tmpfs. Se scegliete di non usare devfs, devrete
	aggiungere una riga del tipo <e>gentoo=notmpfs,nodevfs</e>.
</note>
<p>
	Il nuovo kernel e i suoi moduli sono ora
	installati. C'è ora bisogno di scegliere il
	sistema di logging che dovrà essere installato.
	E' disponibile il tradizionale sistema di
	logging sysklogd. Ma ci sono anche syslog-ng e
	metalog. Utenti che preferivano
	sysklogd (il quale non brilla per prestazioni) si
	stanno rivolgendo verso syslog-ng e metalog. Se siete
	in dubbio, potete provare metalog che sembra essere
	abbastanza popolare. Per installare il logger
	scelto, digitate <e>uno</e> dei seguenti quattro comandi:
</p>
<pre caption="Installazione di un sistema di log a scelta" >
# <i>emerge sys-apps/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>o</comment>
# <i>emerge app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>o</comment>
# <i>emerge app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>o</comment>
# <i>emerge app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>
<impo>
	Metalog scrive il suo output su disco a blocchi,
	così i messaggi non sono immediatamente
	registrati nei log di sistema. Se state tentando di
	provare un daemon, questa caratteristica (che ne
	migliora le prestazioni) potrebbe non essere la
	soluzione migliore. Una volta che il sistema è a
	regime potrete provare a mandare al daemon di metalog
	un segnale di tipo USR1 che temporaneamente dovrebbe
	disabilitare il suddetto comportamento (il buffering
	dei messaggi prima di scriverli in blocco). Questo
	significa che <i>tail -f <path>/var/log/logfile</path></i>
	dovrebbe funzionare come ci aspettiamo. Per tornare alla
	situazione standard invieremo un nuovo segnale,
	questa volta di	tipo USR2. Se voleste disabilitare permanentemente
	il buffering, potete cambiare l'opzione METALOG_OPTS da &quot;-B&quot; a
	&quot;-B -s&quot; in <path>/etc/conf.d/metalog</path>.
</impo>
<p>
	Se volete, potete ora scegliere il pacchetto cron che
	preferite. Per ora offriamo, dcron, fcron e vcron.
	Se non sapete quale scegliere tra questi, potete usare
	vcron. I pacchetti possono essere
	installati come segue:
</p>
<pre caption="Installazione di un pacchetto cron" >
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/vcron</c>
# <c>crontab /etc/crontab</c>
<comment>Non dimenticate di aggiungere il vostro *cron all'appropriato init level.</comment>
# <c>rc-update add *cron default</c>
</pre>
<p>
	Per maggiori informazioni sui programmi e daemon che partono al boot,
	date un'occhiata alla guida <uri link="http://www.gentoo.org/doc/it/rc-scripts.xml" >rc-scripts</uri>.
</p>
</body>
</section>
</chapter>
<chapter>
<title> Installazione di altri pacchetti necessari</title>
<section>
<body>
<p>
	Se avete bisogno di rp-pppoe per connettervi alla rete, siate consci che a
	questo punto non è stato ancora installato. Potrebbe essere una buona cosa farlo ora.
</p>
<pre caption="Installazione di rp-pppoe" >
# <c>USE=&quot;-X&quot; emerge rp-pppoe</c>
</pre>
<note>
	Con l'impostazione <i>USE=&quot;-X&quot;</i> impediamo che pppoe installi
	l'interfaccia grafica opzionale, il che è una buona cosa in quanto verrebbe installato
	anche l'ambiente grafico X con tutte le sue dipendenze. Potrete sempre ricompilare
	<i>rp-pppoe</i> con il supporto X in seguito.
</note>
<note>
	Notate che adesso rp-pppoe è installato ma non configurato. Dovrete
	configurarlo usando <c>adsl-setup</c> dopo aver riavviatoGentoo per la prima
	volta.
</note>
<p>
	Potreste aver bisogno di installare pacchetti
	addizionali nel Portage tree, se state usando ad
	esempio XFS, ReiserFS o LVM. Per XFS, dovreste installare
	il pacchetto <c>xfsprogs</c>:
</p>
<pre caption="Installazione dei tools per i filesystem" >
# <c>emerge sys-apps/xfsprogs</c>
<comment>Se state usando ReiserFS, dovreste installare i tool di ReiserFS:</comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>Se state usando JFS, dovreste installare i tools JFS:</comment>
# <c>emerge jfsutils</c>
<comment>Se invece state usando LVM, dovreste installare il pacchetto <c>lvm-user</c>:</comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>
<p> Se state usando un laptop e volete usare gli slot PCMCIA al vostro primo
reboot, dovrete installare il pacchetto <i>pcmcia-cs</i>.
</p>
<pre caption="Emerge pcmcia-cs" >
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
<warn>
	Dovrete reinstallare <i>pcmcia-cs</i> dopo l'installazione per far si che PCMCIA lavori correttamente.
</warn>
</body>
</section>
</chapter>
<chapter>
<title> Modifica di /etc/fstab per la vostra macchina</title>
<section>
<body>
<p>
	Il vostro sistema Gentoo Linux è ormai pronto
	all'uso. Tutto ciò di cui abbiamo bisogno
	è di configurare alcuni importanti file di
	sistema e installare il GRUB boot loader.
	Il primo file che abbiamo bisogno di configurare
	è <path>/etc/fstab</path>. Ricordate che se
	avete scelto una partizione di avvio di tipo ReiserFS dovrete
	aggiungere una opzione <c>notail</c>.
	Ricordatevi inoltre di specificare il tipo di
	filesystem appropriato per ogni partizione
	(<c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>).
</p>
<p>
	Usate qualcosa tipo l' <path>/etc/fstab</path>
	mostrato sotto, ma naturalmente sostituite &quot;BOOT&quot;,
	&quot;ROOT&quot; e &quot;SWAP&quot; con i block device che avete scelto
	di usare (<c>hda1</c>, <c>hda2</c>, ecc.).
</p>
<pre caption="Configurazione dell'fstab" >
<comment>
# /etc/fstab: static file system information.
#
# noatime turns of atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency). It's safe to drop the noatime options if you want and to
# switch between notail and tail freely.

# &lt;fs>          	&lt;mountpoint>    &lt;type>  	&lt;opts>
&lt;dump/pass>
# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT		/boot	        ext2		noauto,noatime	1 2
/dev/ROOT		/	        ext3		noatime		0 1
/dev/SWAP		none            swap		sw		0 0
/dev/cdroms/cdrom0	/mnt/cdrom	iso9660		noauto,ro	0 0
proc			/proc           proc		defaults	0 0
</pre>
<warn>
	Notate che <i>/boot</i> NON è montato al boottime. Questo per proteggere i
	dati in <i>/boot</i> dal pericolo di corruzione. Se avete bisogno di accedere
	a <i>/boot</i> ricordatevi di montarlo!
</warn>
</body>
</section>
<section>
<title> Diamo una password a root</title>
<body>
<p>
	Prima di dimenticarcene, diamo una password a root digitando:
</p>
<pre caption="Cambiamo la password di root" >
# <i>passwd</i>
</pre>
<p>
	Vorrete anche aggiungere un altro utente, oltre a root, per un uso quotidiano.
	Per questo consultate le <uri link="http://www.gentoo.org/doc/it/faq.xml">FAQ di Gentoo</uri>.
</p>
</body>
</section>
<section>
<title> Impostiamo il nome della macchina</title>
<body>
<p>
	Create questo file in modo da contenere il
	nome di dominio "fully-qualified" della vostra macchina, su una singola riga, p.e.
	<c>nomemacchina.nomedominio.it</c>.
</p>
<pre caption="Impostare l'hostname" >
# <c>echo nomemacchina.nomedominio.it > /etc/hostname</c>
</pre>
</body>
</section>
<section>
<title> Modifichiamo /etc/hosts</title>
<body>
<p>
	Questo file contiene una lista di indirizzi IP
	associati al relativo hostname. E' usato dal
	sistema per risolvere indirizzi IP di macchine che
	possono non essere sul vostro DNS server.
	Segue un esempio di questo file:
</p>
<pre caption="Editare il file /etc/hosts" >
127.0.0.1      localhost
<comment># la prossima riga contiene l'IP della vostra macchina associato al suo nome</comment>
192.168.1.1    nomemacchina.nomedomimio	 nomemacchina
</pre>
<note>
	Se siete in una rete DHCP, potrebbe essere utile impostare <i>localhost</i>
	col nome attuale della macchina. Questo aiuterà GNOME e altri programmi nella
	risoluzione dei nomi.
</note>
</body>
</section>
<section>
<title> Configurazione finale della rete</title>
<body>
<p>
	Aggiungete il nome di ogni modulo necessario per il
	corretto funzionamento del vostro sistema in
	<path>/etc/modules.autoload</path> (potete anche
	aggiungere le opzioni necessarie sulla stessa riga).
	Alla partenza di Gentoo Linux, questi moduli
	verranno automaticamente caricati. Particolarmente
	importanti sono i moduli relativi alla scheda di
	rete (naturalmente se li avete compilati come moduli
	;-)):
</p>
<pre caption="/etc/modules.autoload" >
<comment>
	Assumendo che stiate usando una scheda di rete 3COM. Controllate
	<path>/lib/modules/`uname -r`/kernel/drivers/net</path> per la
	vostra scheda.
</comment>
3c59x
</pre>
<p>
	Editate lo script <path>/etc/conf.d/net</path> affinché
	la rete sia configurata per il primo avvio:
</p>
<pre caption="Configurare la rete in modo permanente" >
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>
<p>
	Se aveste più schede di rete necessiterete di
	aggiungere altri script
	<path>net.eth<comment>x</comment></path>
	per ognuna (<comment>x</comment> = 1, 2, ...):
</p>
<pre caption="Interfacce di rete multiple" >
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment>
</i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>
<p>
	Se avete una scheda PCMCIA installata, date una rapida
	occhiata a <path>/etc/init.d/pcmcia</path> per verificare se
	è conforme alle vostre esigenze e aggiungete le righe seguenti
	in testa al file <path>/etc/init.d/net.eth<comment>x</comment></path>:
</p>
<pre caption="Aggiungiamo dipendenze PCMCIA in /etc/init.d/net.ethx" >
depend() {
	need pcmcia
}
	</pre>
<p>
	In questo modo i driver pcmcia verranno caricati automaticamente
	ogni volta che verrà avviata la rete.
</p>
</body>
</section>
</chapter>
<chapter>
<title> Ultimi passi: configurazioni di base (includendo l'impostazione per la mappatura internazionale della tastiera)</title>
<section>
<body>
<pre caption="Configurazione di base" >
# <i>nano -w /etc/rc.conf</i>
</pre>
<p>
	Dando una scorsa al file troverete diverse variabili
	che inizializzano alcune configurazioni di base.
	Vorrete essere sicuri che <c>CLOCK</c> sia quello
	voluto. Per usare tastiere con layout diverso da
	quello americano potrete impostare la variabile
	<c>KEYMAP</c> (cercate in <path>/usr/share/keymaps</path> le possibilità).
</p>
</body>
</section>
</chapter>
<chapter>
<title> Configurazione di un bootloader</title>
<section>
<title>Note</title>
<body>
<p>
	Nello spirito di Gentoo, gli utenti possono ora scegliere tra più di un bootloader.
	Usando il nostro "virtual package system", gli utenti possono scegliere sia GRUB
	che LILO come loro bootloader.
</p>
<p>
	E' chiaro che non è necessario avere entrambi i bootloader installati.
	Infatti potrebbe essere un ostacolo, vi consigliamo di sceglierne uno solo.
</p>
<impo>
	Se state installando Gentoo Linux su un sistema con una scheda video
	GeForce integrata con chipset NVIDIA nForce o nForce2, dovreste usare
	LILO ed evitare GRUB. Con l'abilitazione del video on-board, l'area di
	memoria (low memory) della vostra RAM può essere usata come RAM
	video. Dato che anche GRUB usa la stessa area di memoria al momento
	del boot, si può verificare una condizione di &quot;out of memory&quot;.
	Così se avete una nForce o potenzialmente altre schede on-board video,
	usate LILO. Oltretutto se state usando schede video off-board, potrebbe
	essere simpatico avere la possibilità di rimuovere la scheda video e usare
	quella on-board in caso di bisogno, non è vero? :)
</impo>
</body>
</section>
<section>
<title> Configurazione di GRUB</title>
<body>
<p>
	La parte più critica per capire la
	configurazione di GRUB è familiarizzare con la
	notazione che GRUB usa per definire i dischi e le
	partizioni. La partizione Linux
	<path>/dev/hda1</path> è chiamata
	<path>(hd0,0)</path> sotto GRUB.
	Nota che le parentesi che racchiudono hd0,0 sono
	richieste. I dischi vengono contati a partire da
	zero invece che da &quot;a&quot; e le partizioni partono da
	zero invece che da uno.
	Dovrete essere consapevoli che con periferiche hd sono contati solo i dischi
	rigidi e non periferiche atapi-ide come cdrom e masterizzatori e che lo
	stesso costrutto vale anche per periferiche SCSI. (Di solito queste prendono
	numeri alti rispetto a periferiche ide a eccezione di quando il bios è configurato
	per fare il boot da device SCSI).
	Così facendo finta che abbiate un disco su /dev/hda, un lettore cdrom su /dev/hdb,
	un masterizzatore su /dev/hdac e un secondo disco su /dev/hdd e nessun disco
	SCSI, la partizione <path>/dev/hdd7</path> diventa <path>(hd1,6)</path>.
	Tutto questo potrebbe suonare complicato, ed è effettivamente così, ma come
	vedrete, grub offre un meccanismo di completamento col tasto TAB, che diviene
	funzionale per coloro che hanno un notevole numero di dischi e partizioni e sono
	un po' smarriti con lo schema numerico del grub. Avendo preso coscienza di questo,
	è il momento di installare GRUB. Appena avrete preso confidenza	con questa notazione,
	potrete convertire le partizioni di boot e root in un formato comprensibile a GRUB e scriverle
	nel suo file di configurazione. Proviamo quindi a installare GRUB.
</p>
<p>
	La via più breve per installare GRUB è semplicemente digitare <c>grub</c> al prompt:
</p>
<pre caption="Installare GRUB" >
# <c>emerge grub</c>
# <c>grub</c>
</pre>
<impo>
	Questa parte non funzionerà  se state usando hardware RAID. Saltate alla sezione sulla creazione
	del file <path>grub.conf</path>. Dopodiché completerete il setup di grub per i controller RAID.
</impo>
<p>
	Vi verrà  presentato il &quot;grub command-line
	prompt: <c>grub></c>. Ora dovrete digitare i
	giusti comandi per installare il record di boot del GRUB
	nel vostro disco. Nel mio esempio, io voglio installare
	il record di boot nell'MBR (master boot record)
	del mio disco rigido, in modo tale da vedere il GRUB
	prompt a ogni riavvio del mio computer. Nel mio
	caso i comandi che devo digitare sono:
</p>
<pre caption="Installazione di GRUB nell'MBR" >
grub> <c>root (hd0,0)</c>
<codenote>La mia partizione di boot</codenote>
grub> <c>setup (hd0)</c>
<codenote>Dove viene installato il boot record, in questo caso
nell'MBR</codenote></pre>
<pre caption="Installazione di GRUB non nell'MBR" >
<comment>Alternativamente, potrete installare il grub su qualche altra partizione oltre che nell'MBR</comment>
grub> <c>root (hd0,0)</c>
<codenote>La partizione di boot</codenote>
gurb> <c>setup (hd0,4)</c>
<codenote>Dove viene installato il boot record, in questo caso la partizione /dev/hda5</codenote>
grub> <c>quit</c>
</pre>
<p>
	Come funzionano i comandi. Il primo comando <c>root (
	)</c> dice a GRUB la locazione della partizione di
	boot (nel nostro esempio <path>/dev/hda1</path> o
	<path>(hd0,0)</path> nella terminologia GRUB. Il
	secondo comando <c>setup ( )</c> dice a GRUB dove
	installare il record di boot e sarà configurato
	per cercare i suoi file di configurazione nella
	locazione <c>root ( )</c> che avete specificato.
	Nel mio caso, voglio che il record di boot sia
	installato nell'MBR del disco rigido, così
	specificherò semplicemente <path>/dev/hda</path> (anche
	conosciuto come <path>(hd0)</path>). Se sto usando
	un altro boot loader e voglio installare GRUB come
	boot loader secondario, avrei dovuto installare il
	GRUB nel record di boot di una particolare partizione.
	In questo caso avrei dovuto specificare una
	particolare partizione invece dell'intero disco. Una
	volta che il GRUB è stato installato con
	successo, potete uscire dal GRUB digitando
	<c>quit</c>.
</p>
<note>
	Il meccanismo completamento (TAB) del grub può essere usato all'interno
	del grub. Supponiamo che abbiate scritto <c> root (</c> se ora premete
	il tasto TAB, vi dovrebbe essere mostrata una lista di periferiche disponibili
	(non solo dischi), ripremendo il tasto TAB dopo aver scritto <c> root (hd</c>,
	grub vi dovrebbe mostrare solo i dischi e ripremendo il TAB dopo aver scritto
	<c> root (hd0,</c> dovreste avere la lista delle partizioni del primo disco.
	 Il controllo della sintassi con cui il grub definisce le partizioni unito al completamento
	 dovrebbe aiutarvi a fare le giuste scelte.
</note>
<p>
	L'installazione di Gentoo è ora completa, dobbiamo solo creare il file <path>/boot/grub/grub.conf</path>
	che dovrebbe mostrare un menu quando il sistema viene riavviato.
</p>
<impo>
	Per assicurare un compatibilità con le versioni precedenti, vi consigliamo di creare un link tra <i>grub.conf</i>
	e <i>menu.lst</i>. Potete farlo digitando <c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>.
</impo>
<p>
	Creiamo il file grub.conf (<c>nano -w /boot/grub/grub.conf</c>),
	e aggiungiamo le seguenti righe:
</p>
<pre caption="Esempio di grub.conf" >
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/hda3

<comment> # Seguono le instruzioni per usare l'hardware RAID</comment>
title=Gentoo Linux su RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment> # Seguono le istruzioni per coloro che necessitano di un dual-boot</comment>
title=Windows XP
root (hd0,5)
cavetenloader (hd0,5)+1
</pre>
<note>
	(hd0,0) deve essere scritto senza spazi tra
	le parentesi.
</note>
<impo>
	Se avete configurato l'emulazione SCSI per un masterizzatore
	IDE, per renderlo attivo avrete bisogno di aggiungere un &quot;hdx=ide-scsi&quot;
	alla linea del kernel nel menu.lst (dove &quot;hdx&quot; dovrebbe essere il device
	del vostro masterizzatore).
</impo>
<p>
	Dopo aver salvato il file, l'installazione di Gentoo
	Linux è completa. Selezionando la prima opzione
	diciamo al GRUB di fare il boot con Gentoo Linux. La
	seconda parte del file grub.conf è opzionale,
	mostra solo come usare GRUB per fare il boot anche
	con partizioni Windows.
</p>
<note>
	<path>(hd0,0)</path> dovrebbe puntare alla vostra
	partizione &quot;boot&quot; (<path>/dev/hda1</path> nel nostro
	esempio) e <path>/dev/hda3</path> dovrebbe puntare
	al filesystem root. La partizione <path>(hda0,5)</path> contiene il boot loader di NT.
</note>
<note>
	Il percorso dell'immagine del kernel è relativa alla partizione /boot.
	Se per esempio avete la partizione /boot <path>(hd0,0)</path>
	separata dalla root (/) <path>(hd0,1)</path>, tutti i percorsi del
	grub.conf diverrebbero <path>/bzImage</path>.
</note>
<p>
	Ancora, se avete bisogno di passare delle opzioni al
	kernel, aggiungetele semplicemente alla fine del
	comando <c>kernel</c>. Stiamo già  passandogli
	un'opzione (<c>root=/dev/hda3</c>), ma possiamo
	passargliene delle altre. In particolare potreste
	disabilitare il supporto per il devfs (non è
	raccomandato a meno che non sappiate cosa state
	facendo) aggiungendo l'opzione <c>gentoo=nodevfs</c>
	al comando <c>kernel</c>.
</p>
<note>
		A differenza delle prime versioni di Gentoo
		Linux, non è più necessario aggiungere <c>devfs=mount</c> alla fine
		della riga <c>kernel</c> per abilitare il
		devfs. Nelle nuove versioni è abilitato
		per default.
	</note>
</body>
</section>
<section>
<title> Configurare il LILO</title>
<body>
<p>
	Mentre GRUB può essere una nuova alternativa per molte persone, non è
	sempre la scelta migliore. LILO, il LInuxLOader, è il più provato e un vero cavallo da soma
	dei bootloader di Linux. Ecco come installare LILO se lo volete usare al posto di GRUB:
</p>
<p>
	Il primo passo è installarlo:
</p>
<pre caption="Emerge LILO" >
# <c>emerge lilo</c>
</pre>
<p>
	Ora è il momento di configurare LILO. Ecco qui un esempio del file di configurazione <i>lilo.conf</i>.
</p>
<pre caption="Esempio di lilo.conf" >
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	read-only
	root=/dev/hda5

#For dual booting windows/other OS
other=/dev/hda1
	label=dos

</pre>
<li>
	<i>boot=/dev/hda</i> dice a LILO di installarsi nel primo disco del primo controller IDE.
</li>
<li>
	<i>map=/boot/map</i> specifica il file di map. In un normale uso, questo non dovrebbe essere modificato.
</li>
<li>
	<i>install=/boot/boot.b</i> dice a LILO di installare il file specificato come nuovo settore di boot.
	Per un uso normale, questo non dovrebbe essere alterato. Se questa linea è omessa, LILO assumerà
	un /boot/boot.b di default come file da utilizzare.
</li>
<li>
	L'esistenza di <i>prompt</i> dice a LILO di mostrare qualsiasi cosa sia fornito nella linea message.
	Mentre non è raccomandato che rimuoviate la linea prompt, se lo doveste fare, potreste ancora
	avere un prompt premendo il tasto [Shift] mentre la vostra macchina fa il boot.
</li>
<li>
	<i>timeout=50</i> imposta il tempo durante il quale LILO aspetterà qualche input prima di procedere
	con il boot di default. Questo è misurato in decine di secondi, con 50 come default.
</li>
<li>
	<i>message=/boot/message</i> si riferisce alla shermata che LILO mostra per permetterti di selezionare
	il sistema operativo o il kernel da avviare.
</li>
<li>
	<i>lba32</i> descrive la geometria del disco. Un altro parametro comune è linear. Non dovreste cambiare
	questa linea a meno che non siate veramente sicuri di quello che state facendo. Altrimenti potreste avere
	un sistema non avviabile.
</li>
<li>
	<i>default=linux</i> si riferisce al systema operativo che il LILO avvierà di default con le opzioni che
	seguono dopo questa linea
</li>
<li>
	<i>image=/boot/vmlinuz-2.4.20</i> specifica il kernel da avviare.
</li>
<li>
	<i>label=linux</i> è il nome del sistema operativo visualizzato nella schermata di LILO.
	In questo caso è anche il nome a cui si riferisce la linea di default.
</li>
<li>
	<i>read-only</i> specifica che la partizione di root (vedi la riga seguente) è di sola lettura e non
	può essere alterata durante il processo di boot.
</li>
<li>
	<i>root=/dev/hda5</i> dice al LILO quale partizione del disco deve essere usata come partizione di root.
</li>
<note>Un ringraziamento a <uri link="http://www.redhat.com" >RedHat.com</uri> per queste informazioni.</note>
<p>
	Dopo avere editato il nostro <i>lilo.conf</i>, è il momento di eseguire LILO per caricare queste informazioni nell'MBR:
</p>
<pre caption="Eseguire LILO" >
# <c>/sbin/lilo</c>
</pre>
<p>
	LILO è configurato e ora la tua macchina è pronta per l'avvio di Gentoo Linux!
</p>
</body>
</section>
</chapter>
<chapter>
<title>Creazione dei dischi di avvio</title>
<section>
<title> I dischi di avvio di GRUB</title>
<body>
<p>
	E' sempre una buona idea creare un dischetto di avvio la prima volta che
	installiamo una qualsiasi distribuzione Linux. Questa è una sicurezza e
	generalmente non è una cattiva idea. Se state usando qualche tipo
	di hardware RAID, potreste avere <e>necessità</e> di creare un disco di avvio
	di GRUB. Con questi tipi di hardware RAID non è possibile installare grub dalla shell dalla quale si è fatto "chroot".
	Se questo è il vostro caso, create un disco di avvio di GRUB e quando riavviate la prima volta
	potrete installare GRUB nell'MBR.
	Create il vostro disco di avvio in questo modo:
</p>
<pre caption="Creare un disco di avvio di GRUB" >
# <c>mke2fs /dev/fd0</c># <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>
# <c>umount /mnt/floppy</c>
# <c>grub</c>

grub> <c>root (fd0)</c>
grub> <c>setup (fd0)</c>
grub> <c>quit</c>
</pre>
<p>
	Ora riavviate e al prompt del grub (da floppy), potrete eseguire i necessari comandi <c>root</c> e <c>setup</c>.
</p>
</body>
</section>
<section>
<title> I dischi di avvio di LILO</title>
<body>
<p>
	Anche se state usando LILO è una buona idea creare un disco di avvio:
</p>
<pre caption="Creare un disco di avvio di LILO" >
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>Questo è possibile solo con kernel più piccoli di 1.4MB</comment>
</pre>
</body>
</section>
</chapter>
<chapter>
<title> L'installazione è completa!</title>
<section>
<body>
<p>
	Gentoo Linux è installato. Rimane solo da
	uscire dalla shell, fare l'umount delle partizioni e
	riavviare il sistema:
</p>
<pre caption="Riavviare il sistema" >
# <c>etc-update</c>
# <c>exit</c>
<codenote>questo per uscire dalla shell; potreste anche digitare <c>^D</c></codenote>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
<note>
	Dopo il riavvio, è una buona idea eseguire il
	comando <c>update-modules</c> per creare il file
	<path>/etc/modules.conf</path>. Invece di modificare
	questo file direttamente, dovreste generalmente
	applicare le modifiche al file
	<path>/etc/modules.d</path>.
</note>
<impo>
	Ricordate che se state usando hardware RAID, dovreste usare il disco di avvio
	per il primo reboot e fare i passaggi per installare il grub
	nell'MBR. Se l'avete già fatto, congratulazioni.
</impo>
<p>
	Se avete qualche domanda o vi piacerebbe essere
	coinvolti con gli sviluppatori di Gentoo Linux,
	considerate di unirvi alle nostre mailing lists
	gentoo-user e gentoo-dev (c'è un link &quot;click to subscribe&quot;
	nel <uri link="http://www.gentoo.org" >sito ufficiale</uri>). Abbiamo anche una
	comoda guida <uri link="http://www.gentoo.org/doc/it/desktop.xml" >Desktop configuration
	guide</uri> che vi aiuterà a continuare nel configurare il vostro nuovo sistema Gentoo Linux per la
	parte grafica e un' utile guida <uri link="http://www.gentoo.org/doc/it/portage-user.xml" >Portage user guide</uri>
	che vi aiuterà  a familiarizzare con il sistema Portage. Potrete trovare il resto della documentazione Gentoo
	<uri link="http://www.gentoo.org/main/en/docs.xml" >qui</uri>. Se avete altre domande che riguardano
	l'installazione o qualsiasi altra cosa in merito, leggete le <uri
link="http://www.gentoo.org/doc/it/faq.xml" >FAQ</uri> di Gentoo Linux. Benvenuti in Gentoo Linux!
</p>
</body>
</section>
</chapter>
<chapter>
<title> Gentoo-Stats</title>
<section>
<body>
<p>
	Il programma per le statistiche di utilizzo di Gentoo Linux è partito come tentativo di dare agli
	sviluppatori un modo per capire chi sono gli utilizzatori di base. Il programma raccoglie informazioni
	circa l'uso di Gentoo Linux e ci aiuta a dare una priorità alle fasi di sviluppo. L'installazione è completamente
	opzionale ma vi saremmo grati se decideste di farla. Le statistiche possono essere viste su
	<uri>http://stats.gentoo.org/</uri>
</p>
<p>
	Il server gentoo-stats assegnerà  un ID univoco al vostro sistema. Questo ID sarà usato per assicurare
	che ogni sistema sia contato una sola volta. Questo ID non sarà  usato per identificare individualmente
	il vostro sistema e nemmeno per identificare il vostro IP o altre informazioni personali. E' stata presa ogni
	precauzione per assicurare la vostra privacy nel sistema di sviluppo. Ecco le cose che vengono monitorare
	dal programma &quot;gentoo-stats&quot;:
</p>
<ul>
<li>pacchetti installati e la loro versione</li>
<li>informazioni sulla CPU: velocità  (MHz), marca, modello, CPU flag (come &quot;mmx&quot; o &quot;3dnow&quot;)</li>
<li>informazioni sulla memoria (RAM fisica totale disponibile, spazio di swap totale disponibile)</li>
<li>schede PCI e chipset delle schede di rete</li>
<li>il profilo Gentoo Linux che sta usando la vostra macchina (cioè dove sta puntando il link /etc/make.profile).</li>
</ul>
<p>
	Siamo consapevoli che la conoscenza di informazioni sensibili è un pericolo per molti utenti Gentoo Linux
	(così come lo è per gli sviluppatori).
</p>
<ul>
<li>
	A meno che non lo modifichiate, il programma gentoo-stats non trasmetterà informazioni sensibili come
	password, dati di configurazione, taglia delle scarpe...
</li>
<li>
	La trasmissione del vostro indirizzo di email è opzionale ed è disabilitato di default.
</li>
<li>
	L'indirizzo IP che origina la trasmissione dei vostri dati non verrà  mai registrato per potervi identificare.
	Non c'è l'accoppiata &quot;indirizzo IP/ID del sistema&quot;.
</li>
</ul>
<p>
	L'installazione è semplice, dovete solo eseguire i seguenti comandi:
</p>
<pre caption="Installare gentoo-stats" >
# <c>emerge gentoo-stats</c>
<codenote>Installa gentoo-stats</codenote>
# <c>gentoo-stats --new</c>
<codenote>ottiene il nuovo ID del sistema</codenote>
</pre>
<p>
	Il secondo comando richiederà un nuovo ID per il vostro sistema ed entrerà automaticamente
	dentro <path>/etc/gentoo-stats/gentoo-stats.conf</path>. Potete dare un'occhiata a questo
	file per vedere le opzioni di configurazione aggiuntive.
</p>
<p>
	Il programma dovrebbe quindi essere eseguito a cadenza regolare (gentoo-stats non dovrebbe
	essere eseguito come root). Aggiungete questa riga al vostro <path>crontab</path>:
</p>
<pre caption="Aggiungere gentoo-stats al cron" >
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update > /dev/null</c>
</pre>
<p>
	Il programma <c>gentoo-stats</c> è un semplice script perl che può essere visto usando il vostro editor preferito.
</p>
</body>
</section>
</chapter>
</guide>
