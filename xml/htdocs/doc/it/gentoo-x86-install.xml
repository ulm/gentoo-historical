<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/it/gentoo-x86-install.xml">

<title>Gentoo Linux 1.4_rc2 Guida all'installazione</title>
<author title="Chief Architect"><mail link="drobbins@gentoo.org">Daniel Robbins</mail></author>
<author title="Author"><mail link="jerry@gentoo.org">Jerry Alexandratos</mail></author>
<author title="Ghost"><mail link="g2boojum@gentoo.org">Grant Goodyear</mail></author>

<abstract>Queste instruzioni ti guideranno attraverso il processo di
installazione di Gentoo Linux 1.4_rc2. L'installazione di Gentoo Linux supporta
vari tipi di approcci a seconda di quanto vuoi che il tuo sistema sia costruito da
zero.</abstract>

<version>1.0</version>
<date>4 Gennaio 2003</date>

<chapter>
<title>Introduzione</title>
<section>
<body>

<p> 
	Questo nuovo CD di boot dovrebbe partire da tutti i moderni lettori
	CD-ROM IDE e SCSI. Il Linux incluso nel CD-ROM supporta periferiche IDE 
	(incluse nel kernel) e SCSI (disponibili come modulo).
	Inoltre, sono provveduti i moduli per tutti i tipi di schede di rete 
	supportati da Linux, cos&#236; come tutti i tools per la configurazione e l'accesso
	via ssh alla rete e il download dei files.
</p>


<p>
	I requisiti minimi del sistema sono: processore 486+ con idealmente
	almeno 64MB di RAM  (Gentoo Linux &#232; stato installato con successo con
	64MB di RAM e 64MB di swap, ma in queste condizioni il processo di
	installazione &#232; molto lento). 
</p>
<p>
	Gentoo Linux pu&#242; essere installato usando uno dei tre &quot;stage&quot;
    tarball files  La scelta dipende da quanta parte del sistema vuoi compilare. Lo stage1
	&#232; per costruire l'intero sistema da zero. Lo stage2 &#232; per
	costruire alcune parti del sistema da zero mentre lo stage3 ti 
	permette di risparmiare molto tempo dato che &#232; gi&#224;
	ottimizzato per il tuo specifico sistema. 
</p>

<p>
    Bene, come facciamo ad iniziare il processo di installazione? Prima dovrai decidere
    quale immagine LiveCD ISO ti serve, al momento quelle disponibili sono le seguenti:
</p>
    <table>
    <tr>
        <th>Architettura</th>
        <th>Descrizione</th>
    </tr>
    <tr>
        <ti><uri link="http://www.gentoo.it/build/1.4_rc2/gentoo-basic-x86-1.4_rc2.iso">x86</uri></ti>
        <ti>Contiene il tarfile per lo stage 1 e una release base -- va bene per tutte le piattaforme</ti>
    </tr>
    <tr>
        <ti><uri link="http://www.gentoo.it/build/1.4_rc2/gentoo-grp-i686-1.4_rc2.iso">i686</uri></ti>
        <ti>Contiene i tarfile stage 2 e 3, pacchetti GRP e il LiveCD per CPU i686+</ti>
    </tr>
    <tr>
        <ti><uri link="http://www.gentoo.it/build/1.4_rc2/gentoo-grp-athlon-1.4_rc2.iso">athlon</uri></ti>
        <ti>Contiene i tarfile stage 2 e 3, pacchetti GRP e il LiveCD per CPU Athlon</ti>
    </tr>
    <tr>
        <ti><uri link="http://www.gentoo.it/build/1.4_rc2/gentoo-grp-athlon-xp-1.4_rc2.iso">athlon-xp</uri></ti>
        <ti>Contiene i tarfile stage 2 e 3, pacchetti GRP e il LiveCD per CPU Athlon XP</ti>
    </tr>
    <tr>
        <ti><uri link="http://www.gentoo.it/build/1.4_rc2/gentoo-grp-pentium3-1.4_rc2.iso">pentium3</uri></ti>
        <ti>Contiene i tarfile stage 2 e 3, pacchetti GRP e il LiveCD per CPU Pentium III e Pentium 4</ti>
    </tr>

    </table>
<p>
    Mentre tutti i LiveCD faranno il boot su qualsiasi architettura, i relativi tarballs sono ottimizzati
    per un particolare tipo di CPU e non lavorano su tutti i sistemi, eccetto per il 
    LiveCD &quot;gentoo-basic-x86&quot; che pu&#242; essere installato ovunque.
</p>
<p>
    I LiveCD sono immagini complete per CD che dovrebbero essere masterizzate su un CDR o CD-RW
    usando un software per la masterizzazione. Al momento abbiamo due tipi di LiveCD. Il primo
    con la dicitura &quot;gentoo-basic&quot; &#232; di approssimativamente 40MB. Questo CD di 
    piccole dimensioni permette un donwload iniziale e contiene un tarfile stage 1 in <path>/mnt/cdrom/gentoo</path>.
</p>
<p>
    Il secondo gruppo di LiveCD che offriamo &#232; etichettato   &quot;livecd-grp.&quot;.  
    Questi CD contengono i tarfile stage1, 2 e 3 oltre ad un set di pacchetti GRP ottimizzati
    per una specifica architettura. Usando questi LiveCD, sar&#224; possibile installare velocemente un
    sistema Gentoo Linux completamente funzionante. Lo svantaggio &#232; che queste immagini ISO sono
    grandi (circa 600MB) e ti ci vorr&#224; un p&#242; di tempo per scaricarle.
</p>
<info>
    Se per qualche ragione la tua installazione &#232; interrotta in qualche punto, puoi
    fare un reboot e ripartire con l'installazione. Per esempio, se hai partizionato il disco,
    installato lo stageX e sei pronto per il chroot, puoi, se necessario, ripartire con l'installazione.
    Devi solo fare un riavvio con il LiveCD inserito nel lettore CD, montare le partizioni in <path>/mnt</path>
    normalmente. Basilarmente puoi far questo in ogni punto dell'installazione, chiaramente dopo il 
    partizionamento per ovvie ragioni.
</info>
    <warn>
        Se incontri un problema in qualche parte dell'installazione e vorresti mandare un report come bug,
        riportale su <uri>http://bugs.gentoo.org</uri>.  Se il bug ha bisogno di essere mandato ai
        package maintainers, sar&#224; cura degli sviluppatori farlo.
    </warn>
    
    
<p>
	Ora diamo una rapida occhiata al processo di installazione. 
	(N.d.T. L'installazione di Gentoo prevede 3 steps che nel corso
	dell'installazione chiameremo stage.) Creeremo le partizioni, 
	i nostri filesystems ed estrarremo uno degli stageNN tar file. Se stiamo usando lo stage1 o lo stage2 tar file,
	vedremo quali passi compiere per portare il
	nostro sistema allo stage3. Una volta che il sistema
	sar&#224; arrivato allo stage3,
	potremo configurarlo (ottimizzando i files di configurazione, 
	installando il bootloader, etc.), e farlo ripartire avendo un sistema Gentoo
	Linux completamente funzionale.
	A seconda dello stage dal quale stiamo partendo, i seguenti sono i requisiti
	per l'installazione (N.d.T. emerge &#232; il comando per la
	gestione del software in Gentoo Linux, per cui alcuni dei seguenti termini
	non sono traducibili):
</p>

<table>
<tr><th>stage tar file</th><th>requisiti per l'installazione</th></tr>
<tr><ti>1</ti><ti>setup di partizioni e filesystems, emerge rsync, bootstrap, emerge system, emerge linux sources, configurazione finale</ti></tr>
<tr><ti>2</ti><ti>setup di partizioni filesystems, emerge rsync, emerge system, emerge linux sources, configurazione finale</ti></tr>
<tr><ti>3</ti><ti>setup di partizioni e filesystems, emerge rsync (opzionale), configurazione finale</ti></tr>
</table>

</body>
</section>
</chapter>
<chapter>
<title>Booting</title>
<section>
<body>

<p> 
	Riavvia il PC facendo il boot dal LiveCD.
	Dovrai vedere un testo di benvenuto con il logo di Gentoo Linux.
    In questa schermata puoi semplicemente premere Enter per iniziare il
    provesso di boot, permere F2 per visualizzare un aiuto o passare delle opzioni
    al kernel, digitando <c>gentoo opt1 opt2</c>, ecc.
	Una volta premuto ENTER, Linux comincer&#224;
	ad essere caricato da CD.
	Al termine del boot sarai automaticamente loginato come root e a scopo di sicurezza
    la password di root sar&#224; impostata ad un valore random.
	Dovresti ora avere il prompt di root (&quot;<c>#</c>&quot;) nella console corrente
	e poter aprire nuove console premendo alt-f2, alt-f3, etc, e ENTER.
</p>
<p>
    Avrai probabilmente notato che sopra il prompt <c>#</c> c'&#232; un testo di aiuto che
    spiega alcune cose su come configurare la scheda di rete e dove puoi trovare gli stage tarfile
    e i pacchetti nel CD.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Caricamento dei moduli del kernel</title>
<section>
<body>

<p>
	Se non vengono individuate tutte le periferiche automaticamente,
	puoi comunque caricare i moduli appropriati manualmente.
	Per vedere la lista di tutte le schede di rete supportate, digita
	<c>ls /lib/modules/*/kernel/drivers/net/*</c>.
	Per caricare un particolare modulo, digita:
</p>

<pre caption="Configurazione dei moduli PCI">
# <i>modprobe pcnet32</i>
	<comment>(sostituendo a pcnet32 il modulo della nostra scheda di rete)</comment>
</pre>


<p>
	Se vogliamo riuscire ad accedere ad ogni periferica
	SCSI che non &#232; stata individuta durante il processo di auto-identificazione,
	dovremo caricare i moduli appropriati da /lib/modules,
	usando ancora <c>modprobe</c>:
</p>

<pre caption="Caricamento dei moduli SCSI">
# <i>modprobe aic7xxx</i>
# <i>modprobe sr_mod</i>
# <i>modprobe sd_mod</i>
</pre>

<p>
	Con questa serie di comandi modprobe abbiamo caricato il driver per 
	lo SCSI (l' <c>aic7xxx</c>) e siamo sicuri che il supporto per CD-ROM SCSI
	(<c>sr_mod</c>) e dischi SCSI (<c>sd_mod</c>) sia stato abilitato.
</p>

<p>
	Se stai usando RAID hardware, dovrai caricare i moduli per l'ATA-RAID
	e per il tuo controller RAID
</p>
<pre caption="Caricamento dei moduli RAID">
# <i>insmod ataraid</i>    
# <i>insmod pdcraid</i>            
      <comment>(Promise Raid Controller)</comment>    
# <i>insmod hptraid</i>            
      <comment>(Highpoint Raid Controller)</comment>    
</pre>

<p>
    Il LiveCD di Gentoo dovrebbe aver abilitato il DMA per i tuoi dischi.
    Se cos&#236; non fosse, puoi usare <c>hdparm</c> per settare il DMA
    sui tuoi dischi.
</p>
<pre caption = "Settare il DMA">
<comment>Sostituisci a hdX il device del tuo disco. </comment>
# <c>hdparm -d 1 /dev/hdX </c>
<comment>Abilita il DMA </comment>
# <c>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</c>
<comment>Abilita il DNA e altre opzioni per aumentare le performance</comment>
# <c>hdparm -X66 /dev/hdX </c>
<comment>Forza/abilita l' Ultra-DMA -- pericoloso -- pu&#242; causare confusione in alcuni drives </comment>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Caricamento dei moduli PCMCIA</title>
<section>
<body>
<p>Se hai una scheda di rete PCMCIA, &#232; necessario fare qualche passo aggiuntivo.</p>
<warn>Per evitare problemi con <c>cardmgr</c>, <e>devi</e> eseguirlo <e>prima</e> di entrare
nella parte chroot dell'installazione</warn>
<pre caption="Caricamento dei moduli PCMCIA">
# <i>insmod pcmcia_core</i>
# <i>insmod i82365</i>
# <i>insmod ds</i>
# <i>cardmgr -f</i>
</pre>
<p>
	Quando cardmgr identifica che hardware &#232; presente, lo speaker 
	del PC dovrebbe emettere una serie di rassicuranti beeps 
	e la tua scheda di rete PCMCIA dovrebbe prendere vita. Puoi naturalmente
	inserire la scheda PCMCIA anche dopo il caricamento di cardmgr,
	se preferisci.
	(Tecnicamente, non &#232; necessario eseguire <i>cardmgr</i> se conosci esattamente
	il modulo che la scheda PCMCIA richiede. 
	Se invece non lo conosci, caricare tutti i moduli PCMCIA per guardare qual &#232; quello giusto non serve a niente,
	in quanto tutti i moduli PCMCIA verranno caricati e
	rimarranno in attesa di riconoscere la corrispondente
	scheda.
	<i>cardmgr</i> si occuper&#224; anche di rimuovere
	i moduli corrispondenti alle schede che
	eventualmente in fututo rimuoverete.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Configurazione e installazione della rete</title>
<section>
<title>Configurazione del PPPoE </title>
<body>
<p>
    Assumendo che tu abbia bisogno di PPPoE per connetterti a internet,
    su qualsiasi versione del livecd abbiamo cercato di renderti le cose 
    pi&#249; facili includendo <i>rp-pppoe</i>. Usa lo script <i>adsl-setup</i>
    per configurare la tua connessione. Ti verr&#224; richiesto il device a cui
    &#232; connesso il tuo modem adsl, il tuo username e la tua password,
    l'indirizzo del DNS, e se hai bisogno di un firewall minimo oppure no.
</p>
<pre caption = "Configurazione di PPPoE">
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>

<p>
    Se qualcosa andasse storto, assicurati che lo username e la password che hai
    immesso siano esatti dando un'occhiata al file <path>/etc/ppp/pap-secrets</path>
    o <path>/etc/ppp/chap-secrets</path>, e che stai usando il corretto device ethernet.
</p>
</body>
</section>
<section>
<title>Configurazione automatica della rete</title>
<body>

<p>
	Gentoo permette di configurare una rete funzionante,
	che permette l'uso di <c>ssh</c>, <c>scp</c> o <c>wget</c> 
	prima di iniziare il processo di installazione. Se non hai bisogno di usare
	questi comandi, puoi proseguire con il setup della rete. Una volta che 
	la rete funziona, Portage user&#224; la rete una volta dentro l'ambiente chroot
	(richiesto per l'installazione di Gentoo Linux).
	La via pi&#249; semplice di configurare la rete &#232; eseguire
	il nuovo script <c>net-setup</c>:
</p>
<pre caption="Net-Setup Script">
# <i>net-setup eth0</i>
</pre>
<p>
	Naturalmente se preferisci, puoi ancora configurare il network
	manualmente.
</p>
</body>
</section>

<section>
<title>Configurazione manuale del DHCP</title>
<body>

<p>Configurare una rete DHCP &#232; semplice; se il tuo provider non usa DHCP,
passa al paragrafo "Configurazione statica".
</p>
<pre caption="Configurazione di una rete DHCP">
# <i>dhcpcd eth0</i> 
</pre>

<note>Alcuni provider richiedono un hostname. Per fare questo aggiungi un flag <c>-h nomehost</c> nella riga di
comando del dhcpcd.
</note>
<p>
	Non ti spaventare se ricevi messaggi di avviso da<i>dhcpConfig</i>;
	niente panico; gli errori non sono quasi mai
	degni di nota.
	Puoi continuare col paragrafo "Test della rete".
</p>
</body>
</section>
<section>
<title>Configurazione manuale della rete</title>
<body>
<p>
	&#200; necessario configurare la rete per scaricare i sorgenti e costruire 
	la nostra Gentoo Linux.
	Digita i seguenti comandi sostituendo a $IFACE la tua interfaccia di rete 
	(di solito <c>eth0</c>), a $IPNUM il tuo indirizzo IP,
	a $BCAST il tuo indirizzo di broadcast, e a $NMASK la tua network mask.
	Per il comando <c>route</c>, invece, sostituisci a $GTWAY l'indirizzo 
	IP del tuo gateway.
</p>
<pre caption="Configurazione della rete con IP statico">
# <i>/sbin/ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</i>
</pre>

<p>
	&#200; il momento  di creare il file <path>/etc/resolv.conf</path> in modo
	tale che sia possibile la risoluzione dei nomi.
	(In questo modo possiamo raggiungere siti Web/FTP direttamente
	col nome piuttosto che attraverso l'indirizzo IP).
</p>

<p>Segue un esempio da seguire per la creazione del tuo /etc/resolv.conf:</p>

<pre caption="esempio di /etc/resolv.conf">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
<p>
	Sostituisci a <c>10.0.0.1</c> e a <c>10.0.0.2</c> 
	l'indirizzo IP del tuo server DNS primario e secondario.
</p>
</body>
</section>

<section>
<title>Configurazione della rete con un Proxy</title>
<body>
<p>
	Se sei all'interno di un proxy, &#232; necessario configurare 
	il tuo proxy prima di continuare. Dovremo esportare alcune variabili
	per configurare il proxy.
</p>
<pre caption="Configurazione di un proxy">
# <i>export http_proxy="machine.company.com:1234" </i>
# <i>export ftp_proxy="$http_proxy" </i>
# <i>export RSYNC_PROXY="$http_proxy" </i>
</pre>
</body>
</section>

<section>
<title>Test della rete</title>
<body>
<p>
	Ora che la tua rete &#232; stata configurata, il comando <c>/sbin/ifconfig -a</c>
	dovrebbe mostrarti se la tua scheda di rete sta lavorando.
	(presta attenzione a <e>UP</e> e <e>RUNNING</e> nell'output).
</p>
<pre caption="/sbin/ifconfig per una scheda di rete che sta lavorando">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
<p>Se vuoi puoi anche provare a fare un ping verso il DNS (che trovi in <path>/etc/resolv.conf</path>)
e verso un sito web a tua scelta, giusto per essere sicuro che i tuoi pacchetti raggiungano la rete e 
la risoluzione DNS funzioni correttamente.
</p>
<pre caption="Ulteriore test della rete">
# <c> ping www.qualchesito.com</c>
</pre>
</body>
</section>
<section>
<title>La rete funziona!</title>
<body>

<p>
	La rete dovrebbe essere ora configurata e funzionante.
	Dovresti essere in grado di usare i comandi
	<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> e <c>wget</c> per connetterti ad altre macchine
	nella tua LAN o ad Internet.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Partizioniamo il disco</title>
<section>
<body>

<p> 
	Ora che il kernel pu&#242; vedere la nostra scheda di rete e il 
	controller dei dischi, &#232; il momento di creare
	le partizioni del disco per la nostra Gentoo Linux.
</p>


<p>
	Facciamo ora una breve panoramica sulle partizioni standard Gentoo Linux.
	Creeremo almeno tre partizioni: una partizione di swap, una root partition
	(per contenere il grosso di Gentoo Linux), e una partizione di boot. 
	Quest'ultima &#232; disegnata per contenere le informazioni del GRUB boot loader
	e il(i) kernel(s) di Linux.  La partizione di boot ci permette di avere un posto
	sicuro dove mettere tutto ci&#242; che &#232; collegato al booting di Linux. 
	Durante il normale lavoro quotidiano col nostro Gentoo Linux, la partizione di
	boot dovrebbe rimanere <e>unmounted</e>. Questo previene che il kernel divenga
	inutilizzabile ( a causa di una corruzione del
	filesystem) nell'eventualit&#224; di un crash del sistema, prevenendo il problema del
	cane che si morde la coda, dove il GRUB non pu&#242; leggere il kernel 
	(data l'inconsistenza del filesystem) e dall'altra parte non
	si pu&#242; riportare il filesystem ad uno stato consistente
	(dato che non possiamo fare il boot!).
</p>


<p>
	Veniamo ora ai tipi di filesystem. Per ora abbiamo quattro filesystems disponibili:
	XFS, ext2, ext3 (journaling) e ReiserFS. ext2 &#232; il vero e proprio
	filesystem di Linux ma non supporta la tecnologia journaling. 
	ext3 &#232; la nuova versione di ext2 con sia la tecnologia meta-data journaling
	che l'ordered data wite.
	ReiserFS &#232; un filesystem basato su  B*-tree che promette una buona performance
	su file di piccole dimensioni e velocit&#224; superiori
	a ext2 e ext3 con file di dimensioni minori di 4k,
	spesso di un fattore 10x-15x. 
    ReiserFS scala inoltre molto bene e supporta il metadata journaling.
    Dal kernel 2.4.18+, ReiserFS ha raggiunto la solidit&#224; che lo porta ad
    essere raccomandato caldamente.
	XFS &#232; un filesystem ad alte prestazioni con
	tecnologia meta-data journaling che &#232;
	completamente supportato in Gentoo Linux col kernel <path>xfs-sources</path>,
    ma in questo momento &#232; molto instabile.
</p>
<p>
	Se sei interessato al filesystem pi&#249; standard, usa ext2.
	Se ti interessa un filesystem pi&#249; sicuro, usa ext3. Se
	sei invece interessato ad un filesystem ad alte prestazioni con il
	supporto journaling, usa ReiserFS; sia ext3 che
	ReiserFS sono maturi e raffinati. Tutti i filesystems eccetto ReiserFS sono adatti per ambienti produttivi.
    Presta attenzione con XFS; questo filesystem ha la tendenza a 'friggersi' un p&#242; di 
    dati se il systema crasha o se c'&#232; una caduta di tensione. Originariamente sembrava
    un filesystem promettente, ma questa tendenza a perdere dati sia il suo maggior tallone
    d'Achille.
	Queste sono le partizioni raccomandate e la loro dimensione:
</p>
  <table>
  <tr>
  	<th>Partizione</th>
	<th>Dimensione</th>
	<th>Tipo</th>
  	<th>esempio di device</th>
  </tr>
  <tr>
  	<ti>partizione di boot, contiene il kernel(s) e informazioni per il boot</ti>
	<ti>100 Megabytes</ti>
	<ti>ext2/3 racommandate; se scegli ReiserFS monta il filesystem con l'opzione <c>-o notail</c></ti>
  	<ti>/dev/hda1</ti>
  </tr>
   <tr>
  	<ti>partizione di swap (non ha il limite di 128 Megabyte)</ti>
	<ti>&gt;=2*Quantit&#224; di RAM &#232; raccomandata
	ma non ne &#232; richiesta di pi&#249; </ti>
	<ti>Linux swap</ti>
  	<ti>/dev/hda2</ti>
  </tr>
  <tr>
  	<ti>partizione root, contiene i principali filesystems (/usr, /home, etc)</ti>
	<ti>&gt;=1.5 Gigabytes</ti>
	<ti>ReiserFS, ext3 raccomandate; ext2 ok</ti>
  	<ti>/dev/hda3</ti>
  </tr>
 </table>

<p>
    Prima di creare le tue partizioni, &#232; veramente una buona idea inizializzare
    il tuo HD usando <c>dd</c>. Facendo questo siamo sicuri di non incontrare problemi
    con residui di partizioni <i>fat32</i> precendetemente create da noi, o dal vendor
    del disco, come <path>/boot</path> per esempio. Per questo dovrai eseguire:
</p>
<pre caption = "Initializing first 1024 Sectors of HD">
# <c>dd if=/dev/zero of=/dev/hdaBOOT bs=1024 count=1024 </c>
<comment>BOOT &#232; la partizione che contiene il tuo <path>/boot</path>.</comment>
</pre>


<p>A questo punto, creiamo le partizioni usando fdisk. Nota che le partizioni
dovrebbero essere di tipo 82
per quella swap e 83 per i filesystems regolari (sia ReiserFS <e>o</e> ext2/3).
</p>

<note><i>cfdisk</i> &#232; incluso nel CD di installazione ed &#232; *considerabilmente*
facile da usare rispetto a <i>fdisk</i>. Digita <c>cfdisk</c> per eseguirlo. Per default
cfdisk usa <b>/dev/hda</b> come disco. Se /dev/hda non &#232; il disco che vuoi partizionare,
dai a cfdisk come parametro il giusto device. Per esempio: <c>cfdisk /dev/hde</c>
</note>

<note>Se ricevi istruzioni da <c>fdisk</c> o <c>cfdisk</c> di riavviare il sistema, fallo in modo da
far scoprire al sistema le nuove partizioni.
</note>
<note>Se stai usando il RAID le tue partizioni saranno leggermente diverse.
Avrai partizioni come queste:
<path>/dev/ataraid/discX/partY</path>
X &#232; l'array che hai creato, cos&#236; se hai creato solo 1 array sar&#224;
disc0. Y &#232; il numero di partizione come in <path>/dev/hdaY</path>
</note>
<p>
	Una volta create le partizione, dobbiamo inizializzare
	i filesystems che saranno usati
	per immagazzinare i nostri dati. Inizializza la partizione di swap come segue:
</p>
<pre caption="Inizializzazione dello SWAP">
# <i>mkswap /dev/hda2</i>
</pre>
<p>
	Possiamo usare il comando <c>mke2fs</c> per creare filesystems di tipo ext2:
</p>
<pre caption="Creazione di un filesystem ext2">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>
	Per create filesystem XFS usiamo il comando <c>mkfs.xfs</c>:
</p>
<pre caption="Creazione di un filesystem xfs">
# <i>mkfs.xfs /dev/hda3</i>
</pre>
<note>
	Puoi voler aggiungere un paio di flags in pi&#249; al comando <c>mkfs.xfs</c>:
	<c>-d agcount=3 -l size=32m</c>.
	Il flag <c>-d agcount=3</c> abbassa il numero dei gruppi di allocazione.
	XFS insiste usando almeno 1 gruppo di
	allocazione per ogni 4 GB di partizione, cos&#236;, per esempio, se hai una partizione di 20GB
	avrai bisogno di 5 gruppi (agcount) come minimo. 
	Il flag <c>-l size=32m</c> porta a 32 MB la size del journal, 
	incrementando le performance.
</note>
<warn>
	Se stai installando una partizione XFS su una preesistente ReiserFS,
	il successivo tentativo di montarla
	con <c>mount -t xfs</c> pu&#242; fallire. La
	soluzione &#232; azzerare la 
	partizione prima di create il filesystem XFS:
	<c>dd if=/dev/zero of=/dev/hd<comment>x</comment> bs=1k</c>.
</warn>
<p>Se preferisci usare ext3, puoi creare la partizione usando <c>mke2fs -j</c>:</p>
<pre caption="Creazione di un filesystem ext3">
# <i>mke2fs -j /dev/hda3</i>
</pre>


<p>
	Per creare filesystem ReiserFS, usa il comando <c>mkreiserfs</c>:
</p>
<pre caption="Creazione di un filesystem ReiserFS">
# <i>mkreiserfs /dev/hda3</i>
</pre>

<note> Con la verions 2.4.18 del kernel, il supporto per ReiserFS
pu&#242; essere considerato stabile.
</note>

<note>
	Puoi trovare maggiori informazioni per l'uso di ext3 sotto Linux 2.4
	al seguente indirizzo
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
</note>

</body>
</section>
</chapter>
<chapter>
<title>Fare il mount delle partizioni</title>
<section>
<body>
<p>
	&#200; il momento di attivare la nostra partizione
	di swap, che ci servir&#224;
	in seguito come memoria virtuale aggiuntiva:
</p>
<pre caption="Attiviamo lo SWAP">
# <i>swapon /dev/hda2</i>
</pre>
<p>
	Poi, creeremo i mountpoints (letteralmente: punti di montaggio)
	<path>/mnt/gentoo</path> e <path>/mnt/gentoo/boot</path>, e quindi
	vi monteremo i nostri filesystems.
</p>
<pre caption="Creazione dei mount points">
# <i>mkdir /mnt/gentoo</i>
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>
<p>
	Se hai deciso di creare <path>/usr</path> o <path>/var</path>
	come partizioni separate, dovrebbero essere
	rispettivamente montate in <path>/mnt/gentoo/usr</path> e <path>/mnt/gentoo/var</path>.
	(N.d.T. la partizione /var dovr&#224; essere molto
	campiente in quanto conterr&#224; la directory
	temporanea del sistema Portage per la compilazione
	dei pacchetti.)
</p>

   
<impo>
	Se la partizione di <e>boot</e> (dove risiede il
	kernel) &#232; ReiserFS,
	devi essere sicuro di montarla con
	l'opzione <c>-o notail</c> in modo tale che GRUB possa essere installato correttamente.
	Devi anche assicurarti 	che <c>notail</c> termini la riga che si riferisce
	alla partizione di boot in <path>/etc/fstab</path>.
	Ritorneremo brevemente su questo punto.
</impo>
<impo>
    Se stai avendo problemi a montare la tua partizione di boot con ext2,
    riprova usando <c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Ottenere il stage-x tarfile desiderato</title>
<section>
<body>
<p>
	Se vuoi partire dal tarfile stage1 sei gi&#224; pronto per farlo;
	puoi trovare il tarfile in <path>/mnt/cdrom/gentoo/</path>.
	Se invece preferisci partire da un tarfile stage2 o stage3 che sono
	stati ottimizzati per la tua architettura, puoi scaricarli
	(in <path>/mnt/gentoo</path> &#232; la cosa pi&#249; semplice) da uno
	dei mirror di Gentoo nel seguente modo:
</p>
<pre caption="Download dei tarfile stage2 o 3">
# <c>cd /mnt/gentoo</c>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc2/x86/</c>
</pre>
<note>Se hai il liveCD con incluso gi&#224; lo stage3 puoi evitare questo passo.
</note>
</body>
</section>
</chapter>

<chapter>
    <title>Scomprimere l'immagine che desideri usare</title>
<section>
<body>

<p>
	&#200; ora il momento di estrarre il tar file dello stage che hai scelto
	in <path>/mnt/gentoo</path>.
	Quindi faremo il chroot della nuova installazione di
	Gentoo Linux.
</p>

<impo>
	Ricordati di usare l'opzione <c>p</c> col comando tar.
	Altrimenti alcuni files potrebbero
	ricevere permessi errati
.</impo>

<impo>
	Se stai usando il metodo di installazione "from scratch, build everything"
	("costruisci tutto da zero"), dovrai usare l'immagine <path>stage1-ix86-1.4_beta.tbz2</path> che trovi sotto <path>/cdroot/nocompress</path>.
    Se invece stai usando il CD con lo stage3, puoi eseguire i prossimi 
    passi e saltare  direttamente al settaggio del localtime.
</impo>
<pre caption="Scomprimere lo stage">
# <i>cd /mnt/gentoo</i>
# <i>tar -xvjpf /cdroot/nocompress/stage?-*.tbz2</i>
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
</pre>
<p>
    Se stai per usare GRP, potrebbe essere il momento per eseguire i seguenti comandi:
</p>
<pre caption="Predisponiamo il sistema per il GRP">
# <c>mkdir /mnt/gentoo/GRP</c>
# <c>mount -o bind /mnt/cdrom/gentoo/packages /mnt/gentoo/GRP</c>
</pre>

<pre caption="Chrooting">
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
Regenerating /etc/ld.so.cache...
# <i>source /etc/profile</i>
# 
</pre>

<p>
	Dopo aver eseguito questi comandi, sei 'dentro' l'ambiente Gentoo Linux. 
</p>

</body>
</section>
</chapter>

<chapter>
<title>Scarichiamo il Portage Tree corrente usando rsync</title>
<section>
<body>

<p>	Dovrai ora eseguire <c>emerge sync</c>.   
    Questo ti assicura di avere il copia pi&#249; recente del Portage tree.
</p>
	
<pre captio="Aggiorniamento usando rsync">
# <i>emerge rsync</i>
</pre>

<p>Verr&#224; scaricato il Portage Tree e memorizzato in <path>/usr/portage</path>; la sua dimensione &#232; di circa 90Mb senza tarfile.</p>

</body>
</section>
</chapter>
<chapter>
<title>Stabilire le ottimizzazioni (make.conf)</title>
<section>
<body>

<p>	Ora che stiamo lavorando su una copia del Portage, coloro che usano
	lo stage1 devono effettuare il bootstrap del Gentoo Linux procedendo
	secondo le istruzioni che seguono. Primo: editare il file 
	<path>/etc/make.conf</path>. In questo file dovremo definire ad ok 
	i vari flags <c>USE</c> che servono a specificare quali funzionalit&#232;
	supplementari si vogliono includere nella costruzione dei pacchetti.
	In genere i settaggi di default sono accettabili (ovvero un USE  <e>vuoto</e> 
	o non configurato). 
    Maggiori informazioni sui flags di USE possono essere trovate <uri link="http://www.gentoo.it/doc/use-howto-it.html">qui</uri>.
    Si dovrebbero definire in modo appropriato anche i flags 
	<c>HOST</c>, <c>CFLAGS</c> e <c>CXXFLAGS</c> a seconda dal tipo
	di sistema che si vuol creare (potete trovare esempi documentati direttamente
	in questo file). Se necessario, potremmo anche settare le informazioni sul proxy nel caso vi trovaste dietro
	un firewall.
</p> 
	

<pre caption="Editiamo il make.conf">
# <i>nano -w /etc/make.conf</i> 
</pre>
<note>
	Coloro che hanno bisogno di una 'regolazione fine' 
	del processo di costruzione potrebbero dare uno sguardo
	al file <path>/etc/make.globals</path>.
	Questo file comprende i parametri di defaults di Gentoo e non
	dovrebbe mai essere modificato. Se i parametri di defaults non 
	sono sufficienti, i nuovi valori dovrebbero
	essere messi in <path>/etc/make.conf</path>, i valori dei parametri 
	di <path>/etc/make.conf</path>
	<comment>sovrascrivono</comment> gli stessi
	in <path>/etc/make.globals</path>. Se sei interessato ad un
	aggiustamento fine dei settings di USE,
	guarda in <path>/etc/make.profile/make.defaults</path>.
	Se vuoi disabilitare alcuni settings di USE, 
	aggiungi in <path>/etc/make.conf</path> <c>USE="-flag"</c> per disabilitare flag.
	(N.d.T.:  p.e. USE="gnome" includera' gnome nella compilazione di
	programmi che potrebbero avere qualche feature in
	pi&#249;
	includendo gnome, ma che sostanzialmente non ne hanno bisogno
	per il corretto funzionamento, mentre USE="-gnome"
	non includer&#224; gnome.)
</note>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage1</title>
<section>
<body>
<p>
	&#200; giunto il momento di far partire il processo di 'bootstrap'.
	Il processo durer&#224; almento 2 ore su un AMD 1200MHz.
	Durante questo tempo, l'immagine estratta
	verr&#224; preparata per l'installazione
	del resto del sistema.
	Il compilatore GNU GCC verr&#224; compilato cos&#236;
	come le librerie GNU C. La compilazione di questi compinenti
	richiede parecchio tempo e costituisce la maggior parte
	del processo di bootstrap.
</p>
<pre caption="Bootstrapping">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>
<p>&#200; iniziato il processo di "bootstrap".</p>
<note>
	Portage usa per default <c>/var/tmp</c> durante la
	fase di complilazione dei pacchetti, usando spesso
	centinaia di megabyte come area di memorizzazione
	temporanea. &#200; possibile cambiare la
	directory dove Portage stora temporaneamente i suoi
	files, aggiustando la variabile PORTAGE_TMPDIR
	<e>prima</e> di far partire il processo di bootstrap
	come segue:
</note>
<pre caption="Cambiare la directory temporanea del PORTAGE">
# <i>export PORTAGE_TMPDIR="/otherdir/tmp"</i>
</pre>

<p>
	Il comando <c>bootstrap.sh</c> compiler&#224; i
	pacchetti <c>binutils</c>, <c>gcc</c>,
	<c>gettext</c> e <c>glibc</c>, ricompilando
	<c>binutils</c>, <c>gcc</c> e <c>gettext</c> dopo la
	costruzione delle <c>glibc</c>. Inutile dirlo,
	questo processo durer&#224; un p&#242; di tempo.
	Puoi farti un buon pisolino....Buonanotte ;-))
	Una volta che il processo &#232; completato, il tuo
	sistema &#232; in "stage2" il che significa che puoi
    saltare il resto e saltare all'installazione finale.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage2</title>
<section>
<body>
<p>
    Il tarfile stage2 ha gi&#224; il bootstrapping fatto per te. Tutto quello che devi fare
    &#232; installare il resto del sistema.
</p>
<note>
    Se non l'hai ancora fatto, edita <path>/etc/make.conf</path> a tuo piacimento.
</note>
<pre caption="Installazione del resto del sistema">
# <c>export CONFIG_PROTECT=""</c>
# <c>emerge -p system</c>
	<comment>[lista dei pacchetti che devono essere installati]</comment>
# <c>emerge system</c>
</pre>

<note>La linea <c>export CONFIG_PROTECT=""</c> assicura che ogni nuovo script
installato in <path>/etc</path> sovrascriva ogni vecchio script (memorizzati in
<path>sys-apps/baselayout</path>), bypassando il nuovo supporto per il management
dei file di configurazione del Portage.
Se vuoi maggiori dettagli esegui <c>emerge --help config</c>.
</note>
<p>Questo step prender&#224; un p&#242; di tempo per costruire l'intero sistema.
Il lato positivo &#232; che avrai un sistema veramente ottimizzato. D'altra parte
dovrai trovare qualcosa da fare. Ti suggerisco una buona lettura o un buon videogioco.
Quando <c>emerge system</c> &#232; terminato, sarai giunto nello stage3.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Partendo dallo Stage3</title>
<section>
<body>
<p>
    Il tarfile stage3 &#232; configurato per il tuo sistema. Non c'&#232; molto da fare
    per questo stage, ma &#232; una buona idea aggiornare il tuo sistema con gli
    ultimi pacchetti disponibili.
</p>
<note>
    Se non lo hai gi&#232; fatto, edita <path>/etc/make.conf</path> e adattalo alle tue esigenze.
</note>
<pre caption="Avere tutto aggiornato">
# <c>emerge sync</c>
# <c>emerge -up world</c>
<comment>lista i [<i>pacchetti</i>] che devono essere installati</comment>
# <c>emerge -u world</c>
</pre>

<p>
    Una volta che hai completato questo passo, la tua installazione di Gentoo &#232; pronta
    per il prossimo step.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Usare GRP</title>
<section>
<body>
<p>
    Puoi trarre vantaggio dai pacchetti precostruiti GRP fatti apposta per evitare di compilare
    certi pacchetti largamente usati. Correntemente provvediamo pacchetti completi per 
    ognicosa di cui hai bisogno  per <c>openoffice</c>, <c>GNOME</c>, <c>KDE</c> e <c>xfree</c>.
</p>
<p>
    Prima di tutto avrai bosogno di andare nella directory che contiene i pacchetti,
    nel LiveCD potrai trovarla in <path>/mnt/cdrom/gentoo/packages</path>. In questa
    directory troverai lo script <c>grp-install.sh</c>, una directory <i>All</i> che
    contiene tutti i pacchetti binary e una lista di pacchetti GRP disponibili.
    Per installare qualcuno o tutti questi pacchetti dovrai fare come segue:
</p>
<pre caption="Uso di GRP">
# <c>sh grp-install.sh &lt;lista dei pacchetti&gt;</c>
<comment>dove &lt;lista dei pacchetti&gt; pu&#242; essere uno dei files *-list.txt
che sono nella stessa directory.</comment>
</pre>

<p>
    <c>grp-install.sh</c> pu&#242; essere eseguito molte volte senza sovrascrivere installazioni
    esistenti. Puo eseguire <c>sh grp-install.sh</c> per avere una descrizione di base sull'uso
    se sei un p&#242; confuso.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Timezone</title>
<section>
<body>

<p>
    A questo punto dovresti avere un sistema che &#232; pronto per la configurazione finale.
    Partiremo col configurare la timezone. COnfigurare la timezone prima
    di costruire il kernel ci assicura un output ragionevole di <c>uname -a</c>.
</p>
<p>
	Cercate la vostra Timezone ( o GMT se state usando
	il Greenwich Mean Time) in <path>/usr/share/zoneinfo</path>.
	Poi, create un link simbolico come segue:
</p>

<pre caption="Selezionare la timezone">
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>
<p>
Puoi anche dare un'occhiata a <path>/etc/rc.conf</path> per essere sicuro che 
il tuo timezone sia corretto.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: kernel e system logger</title>
<section>
<body>

<note>Se non l'hai ancora fatto, edita <path>/etc/make.conf</path> a tuo piacimento.</note>
<table>
<tr><th>ebuild</th><th>descrizione</th></tr>
<tr><ti><path>gentoo-sources</path></ti>
<ti>Il nostro avanzato e performante kernel (non include il supporto per XFS)</ti></tr>
<tr><ti><path>xfs-sources</path></ti>
<ti>Il kernel di SGI con supporto XFS</ti></tr>
<tr><ti><path>openmosix-sources</path></ti>
<ti>Un classico kernel patchato per il supporto di <uri link="http://www.openmosix.com">openMosix</uri>
una tecnologia load-balancing/clustering</ti></tr>
<tr><ti><path>usermode-sources</path></ti>
<ti>Un classico kernel patchato per il supporto dello User-Mode Linux.
(tecnologia "Linux inside Linux")</ti></tr>
<tr><ti><path>vanilla-sources</path></ti>
<ti>Il classico kernel, come lo scaricheresti da kernel.org</ti></tr>
</table>

<p>
	Scegline uno e uniscilo (merge) al sistema:
</p>

<pre caption="Installare i sorgenti del kernel">
# <i>emerge sys-kernel/gentoo-sources</i>
</pre>

<p>
	una volta che il kernel &#232; disponibile, &#232;
	il momento di personalizzarlo e  compilarlo:
</p>

<pre caption="Compilazione del kernel">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>mv /boot/bzImage /boot/bzImage.orig</i> <comment>[se esiste gi&#224; bzImage]</comment>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
</pre>
<warn>
	Affinch&#233; il tuo kernel funzioni a dovere, ci
	sono alcune opzioni che dovrai essere sicuro siano
	incluse nel kernel e non compilate come modulo.
	Sar&#224; necessario abilitare l'opzione <i>"Code
	maturity level oprions --> Prompt for development
	and/or incomplete code/drives"</i>.
	Nella sezione "File systems", devi essere sicuro di
	abilitare <i>"Device File System"</i> (nota che non
	hai bisogno di abilitare l'opzione "/dev/pts
	filesystem support"). Dovrai anche abilitare
	l'opzione <i>"Virtual Memory Filesystem"</i>.
	Assicurati di abilitare "ReiserFS" se hai partizioni
	di questo tipo; la stessa cosa vale per "Ext3".
	Se stai usando partizioni XFS, abilita l'opzione "SGI XFS
	filesystem support". &#200; sempre una buona idea
	lasciare il supporto per ext2 abilitato sia che lo
	usi o no. Se usi hard drive IDE vorrai abilitare
	l'opzione "USE DMA by default", altrimenti puoi
	avere prestazioni veramente scadenti.
	Naturalmente, ricordati di abilitare il supporto per
	"IDE disk" altrimenti il tuo kernel non
	riuscir&#224; a vedere i tuoi dischi IDE.
</warn>
<p>
	Se hai un masterizzatore IDE, avrai bisogno di abilitare 
	l'emulazione SCSI nel kernel. Abilita "ATA/IDE/MFM/RLL support" ---> "IDE, ATA and ATAPI Block devices" --->
	"SCSI emulation support" (abilitato di solito come modulo), qundi 
	sotto "SCSI support", abilita "SCSI support", "SCSI CD-ROM support" e
	"SCSI generic support" (abilitati come moduli anche questi).
	Se hai scelto di usarli come moduli, allora digita <c>echo -e "ide-scsi/nsg/nsr_mod" >> /etc/modules.autoload</c> per averli automaticamente al boot.
</p>
<p>
	Se stai usando RAID hardware avrai bisogno di abilitare un paio
	di opzioni in pi&#249; nel kernel: Per controllers Highpoint RAID
	abilita il supporto per il chipset hpt366, per i controllers
	IDE RAID e Highpoint 370 software RAID.
	Per i controllers Promise abilita il supporto PROMISE PDC202{46|62|65|67|68|69|70}, 
	per i controllers IDE RAIDS e Support Promise software RAID (Fasttrak(tm))
</p>
<p>
    Se usi PPPoE per connetterti ad internet, avrai bisogno delle seguenti
    opaioni nel kernel (preferibilmente come moduli):
    "PPP (point-to-point protocol) support", "PPP support for async
    serial ports", "PPP support for sync tty ports". Le due opzioni
    relative alla compressione non sono strettamente necessarie cos&#236;
    come "PPP over Ethernet" che potrebbe essere usata solo da <i>rp-ppoe</i>
    quando il kernel &#232; in modalit&#224; PPPoE.
</p>

<note>
	Per coloro che lo preferiscono, &#232; possibile installare
	una Gentoo Linux con kernel 2.2. Per questo c'&#232;
	da pagare un prezzo: perderai le ottime features che
	sono prerogativa della serie 2.4 del kernel (come
	il support per filesystems di tipo XFS e tmpfs,
	iptables, e altro), anche se Gentoo Linux con kernel
	2.2 &#232; stato aggiornato col support ReiserFS e
	devfs. Gli scripts di  boot di Gentoo Linux richiedono
	che tmpfs o ramdisk siano supportati dal kernel,
	cos&#236; coloro che vogliono usare il kernel 2.2
	devono essere sicuri di avere il support per ramdisk
	incluso nel kernel e non compilato come modulo.
	&#200; <comment>vitale</comment> che  un flag
	<e>gentoo=notmpfs</e> sia aggiunto in
	<path>/boot/grub/menu.lst</path> nella linea del
	kernel per la serie 2.2 in modo tale che gli scripts
	di boot montino ramdisk invece di tmpfs. Se scegli
	di non usare  devfs, devi aggiungere una riga del
	tipo <e>gentoo=notmpfs,nodevfs</e>.
</note>

<p>
	Il tuo nuovo kernel e i suoi moduli sono ora
	installati. C'&#232; ora bisogno di scegliere il
	sistema di logging che dovrebbe essere installato.
	&#200; disponibile il tradizionale sistema di
	logging sysklogd. Ma ci sono anche syslog-ng e
	metalog. Utenti che preferivano
	sysklogd (che non brilla per le prestazioni) si
	stanno rivolgendo verso syslog-ng e metalog. Se sei
	in dubbio, puoi provare metalog che sembra essere
	abbastanza popolare. Per installare il logger
	scelto, digita <e>uno</e> dei seguenti tre comandi:
</p>

<pre caption="Installazione di un sistema di log">
# <i>emerge sys-apps/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>o</comment>
# <i>emerge app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>o</comment>
# <i>emerge app-admin/metalog</i>
# <i>rc-update add metalog default</i>
</pre>
<warn>
	Nel caso di syslog-ng avrai bisogno di creare
	<path>/etc/syslog-ng/suslog-ng.conf</path>.
	Puoi trovarne un esempio in
	<path>/etc/syslog-ng</path>.
</warn>
<impo>
	Metalog scrive il suo output su disco a blocchi,
	cos&#236; i messaggi non sono immediatamente
	registrati nei logs di sistema. Se stai provando a
	testare un daemon, questa caratteristica (che ne
	migliora le prestazioni) potrebbe non essere la
	soluzione migliore.  Una volta che il sistema e' a
	regime puoi provare a mandare al daemon di metalog
	un segnale di tipo USR1 che temporaneamente dovrebbe
	disabilitare il suddetto comportamento (il buffering
	dei messaggi prima discriverli in blocco). Questo
	significa che <i>tail -f
	<path>/var/log/logfile</path></i> dovrebbe
	funzionare come ci aspettiamo. Per tornare alla
	situazione standard invieremo un nuovo segnale,
	questa volta di	tipo USR2.
</impo>

<p>
	Se vuoi, puoi ora scegliere il pacchetto cron che
	preferisci. Per ora offriamo, dcron, fcron e vcron.
	Se non sai quale scegliere tra questi, puoi usare
	vcron che pu&#242;. I pacchetti possono essere
	installati come segue:
</p>
<pre caption="Installazione di un pacchetto cron">
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/vcron</c>
# <c>crontab /etc/crontab</c>
<comment>Non dimenticarti di aggiungere il tuo *cron all'appropriato init level.</comment>
# <c>rc-update add *cron default</c>
</pre>

<!-- <p>
	Per avere maggiori informazioni su come cron
	lavorano sotto Gentoo Linux puoi dare una occhiata
	al seguente annuncio
	<uri
	link="http://lists.gentoo.org/pipermail/gentoo-announce/2002-April/000151.html"></uri>.
</p> -->
<p>
	Per maggiori informazioni sui programmi e daemoni che partono al boot,
	dai un'occhiata alla guida <uri link="http://www.gentoo.it/doc/rc-scripts-it.html">rc-scripts</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: installazione di packages aggiuntivi</title>
<section>
<body>

<p> Se hai bisogno di rp-pppoe per connetterti alla rete, sii conscio che a
questo punto non &#232; stato ancora installato. Potrebbe essere una buona
cosa farlo ora.
</p>

<pre caption= "Installing rp-pppoe">
# <c>emerge rp-pppoe</c>
</pre>

<note> Nota che adesso rp-pppoe &#232; installato ma non configurato.
Dovrai configurarlo usando <c>adsl-setup</c> dopo aver riavviato
Gentoo per la prima volta.
</note>
<p>
	Puoi aver bisogno di installare pacchetti
	addizionali nel Portage tree, se stai usando ad
	esempio XFS o LVM. Per XFS, dovresti installare
	l'ebuild <c>xfsprogs</c>:
</p>

<pre caption="Installazione di xfsprogs">
# <i>emerge sys-apps/xfsprogs</i>
</pre>

<p>
	Se invece stai usando LVM, dovresti installare l'ebuild
	<c>lvm-user</c>:
</p>
<pre caption="Installazione di lvm-user">
# <i>emerge --usepkg sys-apps/lvm-user</i>
</pre>

<p> Se stai usando un laptop e vuoi usare gli slots PCMCIA al tuo primo
reboot, dovrai installare il pacchetto <i>pcmcia-cs</i>.
</p>

<pre caption = "Emerge pcmcia-cs">
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: /etc/fstab</title>
<section>
<body>
<p>
	Il tuo sistema Gentoo Linux &#232; ormai pronto
	all'uso. Tutto ci&#242; di cui abbiamo bisogno
	&#232; di configurare alcuni importanti files di
	sistema e installare il GRUB boot loader.
	Il primo file che abbiamo bisogno di configurare
	&#232; <path>/etc/fstab</path>. Ricordati che se hai
	scelto una partizione di boot di tipo ReiserFS devi
	aggiungere una opzione <c>notail</c>.
	Ricordati inoltre di specificare il tipo di
	filesystem appropriato per ogni partizione
	(<c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>).
</p>

<p>
	Usa qualcosa tipo l' <path>/etc/fstab</path>
	mostrato sotto, ma naturalmente sostituisci "BOOT",
	"ROOT" e "SWAP" con i block devices che hai scelto
	di usare (<c>hda1</c>, <c>hda2</c>, ecc.).
</p>
<pre caption="Configurazione dell'fstab">
<comment>
# /etc/fstab: static file system information.
#
# noatime turns of atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It's safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs&gt;          	&lt;mountpoint&gt;    &lt;type&gt;  	&lt;opts&gt;      		&lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT		/boot		ext2		noauto,noatime		1 2
/dev/ROOT		/		ext3		noatime			0 1
/dev/SWAP		none            swap		sw			0 0
/dev/cdroms/cdrom0	/mnt/cdrom	iso9660		noauto,ro		0 0
proc			/proc           proc		defaults		0 0
</pre>

</body>
</section>
<section>
<title>Ultimi passi: diamo una password a root</title>
<body>

<p>
	Prima di dimenticarcene, diamo una password a root
	digitando:
</p>
<pre caption="Cambiamo la password di root">
# <i>passwd</i>
</pre>
</body>
</section>
<section>
<title>Ultimi passi: /etc/hostname</title>
<body>
<p>
	Crea questo file in modo da contenere il
	fully-qualified domain name della tua macchina su
	una singola riga, p.e.
	<c>nomemacchina.nomedominio.it</c>.
</p>
</body>
</section>

<section>
<title>Ultimi passi: /etc/hosts</title>
<body>

<p>
	Questo file contiene una lista di indirizzi IP
	associati al relativo hostname. &#200; usato dal
	sistema per risolvere indirizzi IP di macchine che
	possono non essere nel tuo DNS server.
	Segue un templato di questo file:
</p>
<pre caption="Editare il file /etc/hosts">
127.0.0.1      localhost
<comment># the next line contains your IP for your local LAN, and your associated machine name</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>
</body>
</section>

<section>
<title>Configurazione finale della rete</title>
<body>
<p>
	Aggiungi il nome di ogni modulo necessario per il
	corretto funzionamento del tuo sistema in
	<path>/etc/modules.autoload</path> (puoi anche
	aggiungere le opzioni necessarie sulla stessa riga).
	Alla partenza di Gentoo Linux, questi moduli
	verranno automaticamente caricati. Particolarmente
	importanti sono i moduli relativi alla scheda di
	rete (naturalmente se li hai compilati come moduli
	;-)):
</p>
<pre caption="/etc/modules.autoload">
3c59x
</pre>
<p>
	Edita lo script <path>/etc/conf.d/net</path> per
	avere la rete configurata per il tuo primo boot:
</p>
<pre caption="Configurare la rete in modo permanente">
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>
<p>
	Se hai pi&#249; schede di rete hai bisogno di
	aggiungere altri scripts
	<path>net.eth<comment>x</comment></path> per ognuna
	(<comment>x</comment> = 1, 2, ...):
</p>
<pre caption="Interfacce di rete multiple">
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment></i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>
<p>
	Se hai una scheda PCMCIA installata, dai una rapida
	occhiata a /etc/init.d/pcmcia per verificare se
	&#232; conforme alle tue esigenze e aggiungi
	<pre caption="Aggiunte per schede di rete PCMCIA">
	depend() {
		need pcmcia
	}
	</pre>
	all'inizio del tuo
	<path>/etc/init.d/net.eth<comment>x</comment></path>,
	in modo da caricare automaticamente i driver pcmcia
	ogni volta che viene avviata la rete.
</p>
	
</body>
</section>

<section>
<title>Ultimi passi: configurazioni di base (includendo il
setting per la mappatura internazionale della tastiera)</title>
<body>
<pre caption="Configurazione di base">
# <i>nano -w /etc/rc.conf</i>
</pre>
<p>
	Dando una scorsa al file troverai diverse variabili
	che inizializzano alcune configurazioni di base. 
	Vorrai essere sicuro che <c>CLOCK</c> sia quello
	voluto. Per usare tastiere con layout diverso da
	quello americano puoi settare la variabile
	<c>KEYMAP</c> (puoi trovare le varie
	possibilit&#224; in
	<path>/usr/share/keymaps</path>).
</p>
</body>
</section>

<section>
<title>Ultimi passi: configurazione di GRUB</title>
<body>


<p>
	La parte pi&#249; critica per capire la
	configurazione di GRUB &#232; familiarizzare con la
	notazione che GRUB usa per definire i dischi e le
	partizioni. La partizione Linux
	<path>/dev/hda1</path>  &#232; chiamata
	<path>(hd0,0)</path> sotto GRUB.
	Nota che le parentesi che racchiudono hd0,0 sono
	richieste. I dischi vengono contati a partire da
	zero invece che da "a" e le partizioni partono da
	zero invece che da uno. Cos&#236;
	<path>/dev/hdb3</path> diventa <path>(hd1,2)</path>,
	e <path>/dev/hdd7</path> diventa
	<path>(hd3,6)</path>. Appena hai preso confidenza
	con questa notazione, puoi convertire le partizioni
	di boot e root in un formato comprensibile a GRUB e
	scriverle nel suo file di configurazione.
	Proviamo quindi ad installare GRUB.
</p>
<p>
	La via pi&#249; breve per installare GRUB &#232;
	semplicemente digitare <c>grub</c> al prompt:
</p>
<pre caption="GRUB">
# <i>grub</i>
</pre>

<p>
	Ti verr&#224; presentato il  "grub command-line
	prompt": <c>grub&gt;</c>. Ora dovrai digitare i
	giusti comandi per installare il GRUB boot record
	nel tuo disco. Nel mio esempio, io voglio installare
	il GRUB boot record nell'MBR (master boot record)
	del mio disco rigido, in modo tale da vedere il GRUB
	prompt ad ogni riavvio del mio computer. Nel mio
	caso i comandi che devo digitare sono:
</p>
<pre caption="Setup del grub">grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup (hd0)</i>
grub&gt; <i>quit</i>
</pre>

<p>
	Come lavorano i comandi. Il primo comando <c>root (
	)</c> dice a GRUB la locazione della partizione di
	boot (nel nostro esempio <path>/dev/hda1</path> o
	<path>(hd0,0)</path> nella terminologia GRUB. Il
	secondo comando <c>setup ( )</c> dice a GRUB dove
	installare il boot record e sar&#224; configurato
	per cercare i suoi files di configurazione nella
	locazione <c>root ( )</c> che hai specificato.
	Nel mio caso, voglio che il boot record sia
	installato nell'MBR del disco rigido, cos&#236;
	specifico semplicemente <path>/dev/hda</path> (anche
	conosciuto come <path>(hd0)</path>). Se sto usando
	un altro boot loader e voglio installare GRUB come
	boot loader secondario, avrei dovuto installare il
	GRUB nel boot record di una particolare partizione.
	In questo caso avrei dovuto specificare una
	particolare partizione invece dell'intero disco. Una
	volta che il GRUB &#232; stato installato con
	successo, puoi uscire dal GRUB digitando
	<c>quit</c>. Gentoo Linux &#232; ora installato, ma
	dobbiamo creare il file
	<path>/boot/grub/menu.lst</path> in modo tale che al
	riavvio del computer appaia il menu del GRUB.
	Vediamo come farlo.
</p>

<p>
	Creiamo il file menu.lst (<c>nano -w /boot/grub/menu.lst</c>),
	e aggiungiamo le seguenti righe:
</p>

<pre caption="Esempio di menu.lst">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux
root (hd0,0) 
kernel /boot/bzImage root=/dev/hda3 

<comment> # Seguono le instruzioni per usare RAID hardware
</comment>
title=Gentoo Linux su RAID
root (hd0,0)
kernel /boot/bzImage root=/dev/ataraid/discX/partY

<comment>
	# Seguono le istruzioni per coloro che necessitano
	di un dual-boot
</comment>
title=Windows NT Workstation
root (hd0,5) 
chainloader +1
</pre>
<note>
	L'estensione del file <path>menu.lst</path> deve
	essere "lst" come in "list", la prima lettera &#232;
	una "elle" e non un "uno" (1).
	Inoltre, (hd0,0) deve essere scritto senza spazi tra
	le parentesi.
</note>
<impo>
	Se hai configurato l'emulazione SCSI per un masterizzatore
	IDE, per renderlo attivo hai bisogno di aggiungere un "hdx=ide-scsi"
	alla linea del kernel in menu.lst (dove "hdx" dovrebbe essere 
	il device del tuo masterizzatore).
</impo>
<p>
	Dopo aver salvato il file, l'installazione di Gentoo
	Linux &#232; completa. Selezionando la prima opzione
	diciamo al GRUB di fare il boot con Gentoo Linux. La
	seconda parte del file menu.lst &#232; opzionale,
	mostra solo come usare GRUB per fare il boot anche
	con partizioni Windows.
</p>
<note>
	<path>(hd0,0)</path> dovrebbe puntare alla tua
	partizione "boot" (<path>/dev/hda1</path> nel nostro
	esempio) e <path>/dev/hda3</path> dovrebbe puntare
	al filesystem root. La partizione
	<path>(hda0,5)</path> contiene il boot loader di NT.
</note>

<p>
	Ancora, se hai bisogno di passare delle opzioni al
	kernel, aggiungile semplicemente  alla fine del
	comando <c>kernel</c>. Stiamo gi&#224; passandogli
	un'opzione (<c>root=/dev/hda3</c>), ma possiamo
	passargliene delle altre.  In particolare puoi
	disabilitare il support per il devfs (non &#232;
	raccomandato a meno che tu non sappia cosa stai
	facendo) aggiungendo l'opzione <c>gentoo=nodevfs</c>
	al comando <c>kernel</c>.
	<note>
		A differenza delle prime versioni di Gentoo
		Linux, non &#232; pi&#249; necessario
		aggiungere <c>devfs=mount</c> alla fine
		della riga <c>kernel</c> per abilitare il
		devfs. Nelle nuove versioni &#232; abilitato
		per default.
	</note>
<p>
	Se stai usando RAID hardware, devi creare un grub disk boot.
	Con RAID hardware non possiamo installare il grub per cui
	abbiamo bisogno di un grub boot disk per fare il reboot e installare
	il grub nell'MBR.
	Per creare il bootdisk:
</p>
<pre caption="Creazione di un bootdisk">
# <i>mke2fs /dev/fd0</i>
# <i>mount /dev/fd0 /mnt/floppy</i>
# <i>mkdir /mnt/floppy/boot</i>
# <i>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub</i>
# <i>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub</i>

# <i>grub</i>

grub&gt; <i>root (fd0)</i>
grub&gt; <i>setup (fd0)</i>
grub&gt; <i>quit</i>
</pre>

</p>
</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: configurare il LILO</title>
<section>
<body>
<p>
    Mentre GRUB pu&#242; essere una nuova alternativa per molte persone, non &#232;
    sempre la scelta migliore. LILO, il LInuxLOader, &#232; il pi&#249; provato e vero
    cavallo da fatica dei bootloaders di Linux. Ecco come installare LILO se lo vuoi usare
    al posto del GRUB:
</p>
<p> 
    Il primo step &#232; installarlo:
</p>
<pre caption="Emerge LILO">
# <c>emerge lilo</c>
</pre>
<p>
    Ora &#232; il momento di configurare LILO. Ti dar&#242; un piccolo <i>lilo.conf</i> da usare
    e ti spiegher&#242; le differenti parti del file.
</p>

<pre caption="Esempio di lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	initrd=/boot/initrd-2.4.20.img
	read-only
	root=/dev/hda5
	
#For dual booting windows/other OS
other=/dev/hda1
	label=dos

	</pre>
<li><i>boot=/dev/hda</i> dice a LILO di installarsi nel primo disco del primo controller IDE.</li>
<li><i>map=/boot/map</i> specifica il map file. In un normale uso, questo non dovrebbe essere modificato.</li>
<li><i>install=/boot/boot.b</i> dice a LILO di installare il file specificato come il nuovo settore di boot.
Per un uso normale, questo non dovrebbe essere alterato. Se questa line &#232; omessa, LILO assumer&#224;
un /boot/boot.b di default come file da essere usato.</li>
<li>L'esistenza di <i>prompt</i> dice a LILO di mostrare qualsiasi cosa sia fornito nella linea message.
Mentre non &#232; raccomandato che tu rimuova la linea prompt, se la devi rimuovere, puoi ancora
avere un prompt premendo il tasto [Shift] mentre la tua macchina parte per il boot.</li>
<li><i>timeout=50</i> setta il tempo durante il quale LILO aspetter&#224; qualche input
prima di procedere con il boot di default. Questo &#232; misurato in decine di secondi, con 50 come 
default.</li>
<li><i>message=/boot/message</i> si riferisce alla shermata che LILO mostra per permetterti
di selezionare il sistema operativo o il kernel da avviare.</li>
<li><i>lba32</i> descrive la geometria del disco. Un altro parametro comune &#232; linear. 
Non dovresti cambiare questa linea a meno che non sei veramente sicuro di quello che stai facendo.
Altrimenti potresti avere un sistema non bootabile.</li>
<li><i>default=linux</i> si riferisce al systema operativo che il LILO avvier&#224;
di default con le opzioni che seguono dopo questa linea</li>
<li><i>image=/boot/vmlinuz-2.4.20</i> specifica il kernel da avviare.</li>
<li><i>label=linux</i> &#232; il nome del sistema operativo visualizzato nella schermata
del LILO. In questo caso &#232; anche il nome a cui si riferisce la linea di default.</li>
<li><i>initrd=/boot/initrd-2.4.20.img</i> si riferisce all'initial ram disk image che
&#232; usata all'avvio per inizializzare e far partire i device che permetteranno il boot
del kernel. L'initial ram disk &#232; una collezione di drivers macchina-dipendenti necessari
per interagire con una scheda SCSI, dischi rigidi o qualsiasi altra periferica di cuiil
kernel ha bisogno per essere avviato. Non dovresti mai condividere un initial ram disk
tra macchine differenti.</li>
<li><i>read-only</i> specifica che la root partition (vedi la riga seguente) &#232; read-only
e non pu&#242; essere alterata durante il processo di boot.</li>
<li><i>root=/dev/hda5</i> dice al LILO quale partizione del disco deve essere usata 
come root partition.</li>
<note>Un ringraziamento a <uri link="http://www.redhat.com">RedHat.com</uri> per queste
informazioni.</note>

<p>
    Dopo avere editato il nostro <i>lilo.conf</i>, &#232; il momento di eseguire LILO per
    caricare queste informazioni nell'MBR:
</p>
<pre caption="Eseguire LILO">
# <c>/sbin/lilo</c>
</pre>
<p>
    LILO &#232; configurato e ora la tua macchina &#232; pronta per l'avvio in Gentoo Linux!
</p>

</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: Bootdisks</title>
<section>
<title>GRUB Bootdisks</title>
<body>

<p>
    &#200; sempre una buona idea creare un dischetto di boot la prima volta che
    installiamo una qualsiasi distribuzione Linux. Questa &#232; una sicurezza e
    generalmente non &#232; una cattiva idea. Se stai usando qualche tipo di hardware
    RAID, puoi avere <e>necessit&#224;</e> di creare un GRUB boot disk. Con questi tipi
    di hardware RAID non &#232; possibile installare grub dalla tua shell chrooted.
    Se questo &#232; il tuo campo crea un GRUB boot disk e quando riavii la prima volta
    potrai installare GRUB sull'MBR. Crea il tuo bootdisk in questo modo:
</p>
<pre caption="Creare un GRUB bootdisk">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>

# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
</pre>

<p>
    Ora riavvia e al prompt del grub del floppy, puoi eseguire i necessari comandi <c>root</c>
    e <c>setup</c>.
</p>
</body>
</section>
<section>
<title>LILO bootdisk</title>
<body>
<p>
    Anche se stai usando LILO &#232; una buona idea creare un bootdisk:
</p>
<pre caption="Creare un LILO Bootdisk">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>Questo &#232; possibile solo con kernel pi&#249; piccoli di 1.4MB</comment>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>L'installazione &#232; completata!</title>
<section>
<body>
<p>
	Gentoo Linux &#232; installato. Rimane solo da
	uscire dalla shell, smontare le partizioni e
	riavviare il sistema:
</p>

<pre caption="Ultimi passi">
# <i>etc-update</i>
# <i>exit</i> 
<codenote>questo per uscire dalla shell;puoi anche digitare <c>^D</c></codenote>
# <i>cd / </i>
# <i>umount /mnt/gentoo/boot</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>umount /mnt/gentoo</i>
# <i>reboot</i>
</pre>
<note>
	Dopo il riavvio, &#232; una buona idea eseguire il
	comando <c>update-modules</c> per creare il file
	<path>/etc/modules.conf</path>. Invece di modificare
	questo file direttamente, dovresti generalmente
	applicare le modifiche al file
	<path>/etc/modules.d</path>.
</note>
<impo>
	Ricordati che se stai usando RAID hardware, devi usare il bootdisk
	per il primo reboot e fare i passaggi per installare il grub
	nell'MBR. Se l'hai fatto, congratulazioni.
</impo>
<p>
	Se hai qualche domanda o ti piacerebbe essere
	coinvolto con gli sviluppatori di Gentoo Linux,
	considera di unirti alle nostre mailing lists
	gentoo-user e gentoo-dev (c'&#232; un link "click to
	subscribe" nel  <uri
	link="http://www.gentoo.org">sito ufficiale</uri>).
	Abbiamo anche una comoda guida 
	<uri link="/doc/desktop-it.html">Desktop configuration
	guide</uri> che ti aiuter&#224; a continuare a
	configurare il tuo nuovo sistema Gentoo Linux per la
	parte grafica, sonora, di posta elettronica, ecc. e
	una utile guida <uri link="/doc/portage-user-it.html">Portage user guide</uri>
	che ti aiuter&#224; a familiarizzare con il sistema
	Portage.
	Benvenuto in Gentoo Linux!
</p>

	
</body>
</section>
</chapter>
</guide>
