<?xml version='1.0' encoding="UTF-8"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">


<guide link="/doc/it/gentoo-x86-1.4_rc3-install.xml">

<title>Gentoo Linux 1.4_rc3 Guida all'installazione</title>
 <author title="Supervisore">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Autore Originale">Chris Houser</author>
  <author title="Autore Originale">
    <mail link="jerry@gentoo.org">Jerry Alexandratos</mail>
  </author>
  <author title="Revisione">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Aggiornamento">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>



<author title="Traduttore">Enrico Morelli</author>
<author title="Traduttore">Team Italiano</author>

<abstract>Queste instruzioni vi guideranno attraverso il processo di
installazione di Gentoo Linux 1.4_rc3. L'installazione di Gentoo Linux supporta
vari tipi di approcci a seconda di quanto volete che il vostro sistema sia costruito da zero.</abstract>

<version>2.3.20</version>
<date>06 Marzo 2003</date>

<chapter>
<title>Introduzione</title>
<section>
<body>

<p> 
	Questo nuovo CD di boot dovrebbe partire da tutti i moderni lettori
	CD-ROM IDE e SCSI. Il Linux incluso nel CD-ROM supporta periferiche IDE 
	(incluse nel kernel) e SCSI (disponibili come modulo).
	Inoltre, sono provveduti i moduli per tutti i tipi di schede di rete 
	supportati da Linux, così come tutti i tools per la configurazione e l'accesso
	via ssh alla rete e il download dei files.
</p>


<p>
	I requisiti minimi del sistema sono: processore 486+ con idealmente
	almeno 64MB di RAM  (Gentoo Linux stato installato con successo con
	64MB di RAM e 64MB di swap, ma in queste condizioni il processo di
	installazione è molto lento). 
</p>
<p>
	Gentoo Linux può essere installato usando uno dei tre &quot;stage&quot;
    tarball files  La scelta dipende da quanta parte del sistema volete compilare. Lo stage1
	è per costruire l'intero sistema da zero. Lo stage2 è per
	costruire alcune parti del sistema da zero mentre lo stage3 vi 
	permette di risparmiare molto tempo dato che è già
	ottimizzato per il vostro specifico sistema. 
</p>
<p>
    <b>Dovreste scegliere di partire dallo stage1, dallo stage2 o dallo stage3?</b>
    Se scegliete di partire dallo stage1 avrete il controllo totale sulle ottimizzazioni
    e sulla funzionalità opzionale usata durante la fase di compilazione che è
    inizialmente abilitata sul vostro sistema. Questo rende lo stage1 ideale per gli utenti
    smaliziati che sanno quello che stanno facendo. Con lo stage2 salti il processo di bootstrap,
    e dovrete accontentarvi delle opzioni di ottimizzazione che abbiamo scelto per il vostro
    particolare stage2 tarball. Con lo stage3 avrete una installazione molto veloce di Gentoo Linux,
    ma anche in questo caso dovete accontentarvi delle ottimizzazioni che abbiamo scelto per voi.
    Questo potrebbe essere sufficiente, dato che le versioni rilasciate di Gentoo Linux hanno
    lo stage3 specificamente ottimizzato per i più popolari tipi di processori.
    <b>Se state installando Gentoo Linux per la prima volta, il consiglio è di usare
    il tarball dello stage3.</b>
</p>
<p>
    Bene, come facciamo ad iniziare il processo di installazione? Prima dovrete decidere
    quale immagine LiveCD ISO scaricare da <uri>http://www.ibiblio.org/gentoo/releases/1.4_rc3/x86/</uri>.
</p>
<p>
    I LiveCD sono immagini complete per CD che dovrebbero essere masterizzate su un CDR o CD-RW
    usando un software per la masterizzazione. Al momento abbiamo due tipi di LiveCD. Il primo
    con la dicitura &quot;gentoo-basic&quot; è di approssimativamente 40MB e lo trovate
    nella directory <path>x86/livecd/</path>. Questo CD di 
    piccole dimensioni permette un donwload iniziale e contiene un tarfile stage 1 in <path>/mnt/cdrom/gentoo</path>.
</p>
<p>
    Il secondo gruppo di LiveCD che offriamo è etichettato   &quot;gentoo-3stages&quot;.  
    Anche questo CD lo trovate nella directory <path>x86/livecd</path> e contiene i tarball stage 1
    ,2 e 3.  Usando questo CD, sarà possibile installare velocemente un
    sistema Gentoo Linux completamente funzionante.
    <b>Che fine hanno fatto i LiveCD per i686, pentium3, athlon, athlon-mp e i pacchetti
    GRP (Gentoo Reference Platform)?</b>
    Gentoo 1.4_rc3 è solo una release candidate minima.  La 1.4_rc4 tornerà ad essere 
    suddivisa in architetture x86 e  conterrà i pacchetti GRP. Se volete installare gli stage
    ottimizzati per queste architetture o i pacchetti GRP, usate la documentazione per la 1.4_rc2
    che potete trovare su <uri>http://www.gentoo.org/doc/it/gentoo-x86-1.4_rc2-install.xml</uri>.
</p>
<impo>
    Se incontrate qualche problema in qualsiasi parte dell'installazione, potete riportarlo
    su <uri>http://bugs.gentoo.org</uri>. Se il bug coinvolge gli sviluppatori del 
    software originale (come ad esempio il team KDE), sarà cura del <e>Gentoo Linux developers</e>
    occuparsi di farlo avere a chi di dovere.
</impo>
    
<p>
	Ora diamo una rapida occhiata al processo di installazione. 
    Prima dovremo scaricare e masterizzare l'immagine, e quindi riavviare
    il nostro PC facendogli fare il boot dal LiveCD appena creato.
	Non appena raggiunto il prompt di root, creeremo le partizioni, 
	i nostri filesystems ed estrarremo uno degli stageNN tarball. Se stiamo usando lo stage1 o lo stage2 tarball,
	vedremo quali passi compiere per portare il
	nostro sistema allo stage3. Una volta che il sistema
	sarà arrivato allo stage3,
	potremo configurarlo (ottimizzando i files di configurazione, 
	installando il bootloader, etc.), e farlo ripartire avendo un sistema Gentoo
	Linux completamente funzionale.
	A seconda dello stage dal quale stiamo partendo, i seguenti sono i requisiti
	per l'installazione (N.d.T. emerge è il comando per la
	gestione del software in Gentoo Linux, per cui alcuni dei seguenti termini
	non sono traducibili):
</p>

<table>
<tr>
    <th>stage tarball</th>
    <th>requisiti per l'installazione</th>
</tr>
<tr>
    <ti>1</ti>
    <ti>setup di partizioni e filesystems, emerge sync, bootstrap, emerge system, emerge kernel, configurazione finale</ti>
    </tr>
<tr>
    <ti>2</ti>
    <ti>setup di partizioni filesystems, emerge sync, emerge system, emerge kernel, configurazione finale</ti>
</tr>
<tr>
    <ti>3</ti>
    <ti>setup di partizioni e filesystems, emerge sync (opzionale), configurazione finale</ti>
</tr>
</table>

</body>
</section>
</chapter>
<chapter>
<title>Booting</title>
<section>
<body>

<p> 
	Riavviate il PC facendo il boot dal LiveCD.
	Dovrete vedere un testo di benvenuto con il logo di Gentoo Linux.
    In questa schermata potete semplicemente premere Enter per iniziare il
    processo di boot, premere F2 per visualizzare un aiuto o passare delle opzioni
    al kernel, digitando <c>gentoo opt1 opt2</c>, ecc.
	Una volta premuto ENTER, Linux comincerà
	ad essere caricato da CD.
	Al termine del boot sarete automaticamente loginati come root e a scopo di sicurezza
    la password di root sarà impostata ad un valore random.
	Dovreste ora avere il prompt di root (&quot;<c>#</c>&quot;) nella console corrente
	e poter aprire nuove console premendo Alt-F2, Alt-F3 e Alt-F4.
    Torniamo alla finestra di partenza premendo Alt-F1.
</p>
<p>
    Avrete probabilmente notato che sopra il prompt <c>#</c> c'è un testo di aiuto che
    spiega alcune cose su come configurare la scheda di rete e dove poter trovare gli stage tarfile
    e i pacchetti nel CD.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Caricamento dei moduli del kernel</title>
<section>
<body>

<p>
	Se non vengono individuate tutte le periferiche automaticamente,
	potete comunque caricare i moduli appropriati manualmente.
	Per vedere la lista di tutte le schede di rete supportate, digitate
	<c>ls /lib/modules/*/kernel/drivers/net/*</c>.
	Per caricare un particolare modulo, digitate:
</p>

<pre caption="Configurazione dei moduli PCI">
# <i>modprobe pcnet32</i>
	<comment>(sostituendo a pcnet32 il modulo della vostra scheda di rete)</comment>
</pre>


<p>
	Se vogliamo riuscire ad accedere ad ogni periferica
	SCSI che non è stata individuta durante il processo di auto-identificazione,
	dovremo caricare i moduli appropriati da /lib/modules,
	usando ancora <c>modprobe</c>:
</p>

<pre caption="Caricamento dei moduli SCSI">
# <i>modprobe aic7xxx</i>
# <i>modprobe sd_mod</i>
</pre>

<p>
	Con questa serie di comandi modprobe abbiamo abilitato il support per il
    controller SCSI (<c>aic7xxx</c>) e per i dischi SCSI (<c>sd_mod</c>).
</p>
<note>
    Il supporto per CD-ROMs e dischi SCSI è incluso nel kernel.
</note>


<p>
	Se state usando RAID hardware, dovrete caricare i moduli per l'ATA-RAID
	e per il tuo controller RAID
</p>
<pre caption="Caricamento dei moduli RAID">
# <i>insmod ataraid</i>    
# <i>insmod pdcraid</i>            
      <comment>(Promise Raid Controller)</comment>    
# <i>insmod hptraid</i>            
      <comment>(Highpoint Raid Controller)</comment>    
</pre>

<p>
    Il LiveCD di Gentoo dovrebbe aver abilitato il DMA per i vostri dischi.
    Se così non fosse, potete usare <c>hdparm</c> per settare il DMA
    sui vostri dischi.
</p>
<pre caption = "Settare il DMA">
<comment>Sostituite a hdX il device del vostro disco. </comment>
# <c>hdparm -d 1 /dev/hdX </c>
<comment>Abilita il DMA </comment>
# <c>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</c>
<comment>Abilita il DNA e altre opzioni per aumentare le performance</comment>
# <c>hdparm -X66 /dev/hdX </c>
<comment>Forza/abilita l' Ultra-DMA -- pericoloso -- può causare confusione in alcuni drives </comment>
</pre>

</body>
</section>
</chapter>
<!--  QUESTA SEZIONE DOVREBBE ESSERE OBSOLETA CON L'HOTPLUG ABILITATA IN 1.4_rc3 (drobbins)
<title>Caricamento dei moduli PCMCIA</title>
<section>
<body>
<p>Se avete una scheda di rete PCMCIA, &#232; necessario fare qualche passo aggiuntivo.</p>
<warn>Per evitare problemi con <c>cardmgr</c>, <e>devi</e> eseguirlo <e>prima</e> di entrare
nella parte chroot dell'installazione</warn>
<pre caption="Caricamento dei moduli PCMCIA">
# <i>insmod pcmcia_core</i>
# <i>insmod i82365</i>
# <i>insmod ds</i>
# <i>cardmgr -f</i>
</pre>
<p>
	Quando cardmgr identifica che hardware &#232; presente, lo speaker 
	del PC dovrebbe emettere una serie di rassicuranti beeps 
	e la tua scheda di rete PCMCIA dovrebbe prendere vita. Puoi naturalmente
	inserire la scheda PCMCIA anche dopo il caricamento di cardmgr,
	se preferisci.
	(Tecnicamente, non &#232; necessario eseguire <i>cardmgr</i> se conosci esattamente
	il modulo che la scheda PCMCIA richiede. 
	Se invece non lo conosci, caricare tutti i moduli PCMCIA per guardare qual &#232; quello giusto non serve a niente,
	in quanto tutti i moduli PCMCIA verranno caricati e
	rimarranno in attesa di riconoscere la corrispondente
	scheda.
	<i>cardmgr</i> si occuper&#224; anche di rimuovere
	i moduli corrispondenti alle schede che
	eventualmente in futuro rimuoverete.
</p>
</body>
</section>
</chapter>
-->
<chapter>
<title>Configurazione della rete</title>
<section>
<title>E' già tutto a posto?</title>
<body>
    <p>
        Se state usando un liveCD 1.4_rc3 o successivo, è possibile che la rete sia già
        stata configurata automaticamente. Se è così potreste essere in grado di usare
        molti dei comandi orientati alla rete inclusi nel LiveCD come, tra gli altri, <c>ssh</c>,
        <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> e <c>lynx</c>.
    </p>
    <p>
        Se la configurazione della rete è andata a buon fine, il comando <c>/sbin/ifconfig</c>
        dovrebbe mostrarvi le interfacce di rete come <c>lo</c> e <c>eth0</c>:
    </p>
<pre caption="/sbin/ifconfig per schede di rete configurate">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
    <p>
        Potete anche provare ad eseguire un ping verso il DNS server del vostro provider
        (che trovate in <path>/etc/resolv.conf</path>) e verso un sito Web di vostra scelta, giusto
        per vedere che tutti i pacchetti raggiungano la rete e la risoluzione dei nomi DNS
        funzioni correttamente.
    </p>
<pre caption="Test della rete">
# <c>ping www.gentoo.com </c>
</pre>

    <p>
        Riuscite ad usare la rete? Allora potete saltare il resto di questa sezione.
    </p>
   </body>
   </section>
   <section>
<title>Configurazione del PPPoE </title>
<body>

<p>
    Assumendo che abbiate bisogno di PPPoE per connettervi a internet,
    su qualsiasi versione del livecd abbiamo cercato di rendervi le cose 
    più facili includendo <i>rp-pppoe</i>. Usate lo script <i>adsl-setup</i>
    per configurare la vostra connessione. Vi verrà richiesto il device a cui
    è connesso il vostro modem adsl, il vostro username e la password,
    l'indirizzo del DNS, e se avete bisogno di un firewall minimo oppure no.
</p>
<pre caption = "Configurazione di PPPoE">
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>

<p>
    Se qualcosa andasse storto, assicuratevi che lo username e la password che avete
    immesso siano esatti dando un'occhiata al file <path>/etc/ppp/pap-secrets</path>
    o <path>/etc/ppp/chap-secrets</path>, e che state usando il corretto device ethernet.
</p>
</body>
</section>
<section>
<title>Configurazione automatica della rete</title>
<body>

<p>
	Se la configurazione automatica non è andata a buon fine, la via più semplice
    per configurare la rete è eseguire lo script <c>net-setup</c>:
</p>
<pre caption="Net-Setup Script">
# <i>net-setup eth0</i>
</pre>
<p>
	Naturalmente se preferite, potete ancora configurare il network
	manualmente.
</p>
</body>
</section>

<section>
<title>Configurazione manuale del DHCP</title>
<body>

    <p>
        Configurare una rete DHCP è semplice; se il vostro provider non usa DHCP,
        passate al paragrafo &quot;Configurazione statica&quot;.
    </p>
<pre caption="Configurazione di una rete DHCP">
# <i>dhcpcd eth0</i> 
</pre>

    <note>
        Alcuni provider richiedono un hostname. Per fare questo aggiungete
        un flag <c>-h nomehost</c> nella riga di comando del dhcpcd.
    </note>
    <p>
	    Non vi spaventate se ricevete messaggi di avviso da<i>dhcpConfig</i>;
    	niente panico; gli errori non sono quasi mai
	    degni di nota.
    	Potete continuare col paragrafo &quot;Test della rete&quot;.
    </p>
</body>
</section>
<section>
<title>Configurazione manuale della rete</title>
<body>
<p>
	E' necessario configurare la rete per scaricare i sorgenti e costruire 
	la vostra Gentoo Linux.
	Digitate i seguenti comandi sostituendo a $IFACE la vostra interfaccia di rete 
	(di solito <c>eth0</c>), a $IPNUM il vostro indirizzo IP,
	a $BCAST il vostro indirizzo di broadcast, e a $NMASK la vostra network mask.
	Per il comando <c>route</c>, invece, sostituite a $GTWAY l'indirizzo 
	IP del vostro gateway.
</p>
<pre caption="Configurazione della rete con IP statico">
# <i>/sbin/ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</i>
</pre>

<p>
	E' il momento  di creare il file <path>/etc/resolv.conf</path> in modo
	tale che sia possibile la risoluzione dei nomi.
	(In questo modo possiamo raggiungere siti Web/FTP direttamente
	col nome piuttosto che attraverso l'indirizzo IP).
</p>

<p>Segue un esempio da seguire per la creazione del vostro /etc/resolv.conf:</p>

<pre caption="esempio di /etc/resolv.conf">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
<p>
	Sostituite a <c>10.0.0.1</c> e a <c>10.0.0.2</c> 
	l'indirizzo IP del vostro server DNS primario e secondario.
</p>
</body>
</section>

<section>
<title>Configurazione della rete con un Proxy</title>
<body>
<p>
	Se siete all'interno di un proxy, è necessario configurare 
	il vostro proxy prima di continuare. Per questo dovremo esportare alcune variabili.
</p>
<pre caption="Configurazione di un proxy">
# <i>export http_proxy=&quot;machine.company.com:1234&quot; </i>
# <i>export ftp_proxy=&quot;$http_proxy&quot; </i>
# <i>export RSYNC_PROXY=&quot;$http_proxy&quot; </i>
</pre>
</body>
</section>
<section>
<title>La rete funziona!</title>
<body>

<p>
	La rete dovrebbe essere ora configurata e funzionante.
	Dovreste essere in grado di usare i comandi
	<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> e <c>wget</c> per connettervi ad altre macchine
	nella vostra LAN o ad Internet.
</p>

</body>
</section>
</chapter>
<chapter>
    <title>Aggiorniamo la data e l'ora del nostro sistema</title>
    <section>
     <body>
        <p>
            E' necessario aggiornare la data e l'ora del nostro sistema.
            Possiamo farlo usando il comando <c>date</c>
        </p>
<pre caption="Aggiornamento della data del sistema">
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(Se la data è sbagliata correggetela col comando che segue)</comment>
# <c>date 022709042003</c>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>
     </body>
    </section>
</chapter>

<chapter>
<title>Partizioniamo il disco</title>
<section>
<body>

<p> 
	Ora che il kernel può vedere la vostra scheda di rete e il 
	controller dei dischi, è il momento di creare
	le partizioni del disco per la vostra Gentoo Linux.
</p>


<p>
	Facciamo ora una breve panoramica sulle partizioni standard Gentoo Linux.
	Creeremo almeno tre partizioni: una partizione di swap, una root partition
	(per contenere il grosso di Gentoo Linux), e una partizione di boot. 
	Quest'ultima è destinata a contenere le informazioni del GRUB boot loader
	e il(i) kernel(s) di Linux.  La partizione di boot ci permette di avere un posto
	sicuro dove mettere tutto ciò che è collegato al booting di Linux. 
	Durante il normale lavoro quotidiano col nostro Gentoo Linux, la partizione di
	boot dovrebbe rimanere <e>unmounted</e>. Questo previene che il kernel divenga
	inutilizzabile ( a causa di una corruzione del
	filesystem) nell'eventualità di un crash del sistema, prevenendo il problema del
	cane che si morde la coda, dove il GRUB non può leggere il kernel 
	(data l'inconsistenza del filesystem) e dall'altra parte non
	si può riportare il filesystem ad uno stato consistente
	(dato che non possiamo fare il boot!).
</p>


<p>
	Veniamo ora ai tipi di filesystem. Per ora abbiamo cinque filesystems disponibili:
	XFS, ext2, ext3 (journaling), jfs e ReiserFS. ext2 è il vero e proprio
	filesystem di Linux ma non supporta la tecnologia journaling. 
	ext3 è la nuova versione di ext2 con sia la tecnologia meta-data journaling
	che l'ordered data write.
	ReiserFS è un filesystem basato su  B*-tree che promette una buona performance
	su file di piccole dimensioni e velocità superiori
	a ext2 e ext3 con file di dimensioni minori di 4k,
	spesso di un fattore 10x-15x. 
    ReiserFS scala inoltre molto bene e supporta il metadata journaling.
    Dal kernel 2.4.18+, ReiserFS ha raggiunto la solidità che lo porta ad
    essere raccomandato caldamente.
	XFS è un filesystem ad alte prestazioni con
	tecnologia meta-data journaling che è
	completamente supportato in Gentoo Linux col kernel <path>xfs-sources</path>,
    ma non è generalmente raccomandato a causa della sua tendenza a perdere
    i dati che sono stati modificati recentemente se il sistema si chiude o si
    riavvia inaspettatamente (per esempio a causa di un calo di tensione elettrica).
    Veniamo alla fine al jfs, il filesystem journaling ad alte prestazioni di IBM.
    Data la sua oscurità, non possiamo fare commenti positivi o negativi sulla
    sua stabilità.
</p>
<p>
	Se siete interessati al filesystem più standard, usate ext2.
	Se siete interessati al filesystem più sicuro, usate ext3. Se
	siete invece interessati ad un filesystem ad alte prestazioni con il
	supporto journaling, usate ReiserFS; sia ext3 che
	ReiserFS sono maturi e perfezionati.
    Queste sono le partizioni raccomandate e la loro dimensione:
</p>
  <table>
  <tr>
  	<th>Partizione</th>
	<th>Dimensione</th>
	<th>Tipo</th>
  	<th>esempio di device</th>
  </tr>
  <tr>
  	<ti>partizione di boot, contiene il kernel(s) e informazioni per il boot</ti>
	<ti>100 Megabytes</ti>
	<ti>ext2/3 raccommandate; se scegliete ReiserFS montate il filesystem con l'opzione <c>-o notail</c></ti>
  	<ti>/dev/hda1</ti>
  </tr>
   <tr>
  	<ti>partizione di swap (non ha il limite di 128 Megabyte)</ti>
	<ti>Generalmente, a meno che non si tratti di un server, la dimensione dello swap space
    può essere molto flessibile. Consultate la tabella che segue per una linea guida
    sullo swap space.</ti>
	<ti>Linux swap</ti>
  	<ti>/dev/hda2</ti>
  </tr>
  <tr>
  	<ti>partizione root, contiene i principali filesystems (/usr, /home, etc)</ti>
	<ti>&gt;=1.5 Gigabytes</ti>
	<ti>ReiserFS, ext3 raccomandate; ext2 ok</ti>
  	<ti>/dev/hda3</ti>
  </tr>
 </table>
	<table>
	<tr>
	<th>RAM fisica</th>
	<th>Dimensione Swapspace</th>
	</tr>
	<tr>
	<ti>0-48MB RAM</ti>
	<ti>048-064MB RAM</ti>
	<ti>064MB-128MB RAM</ti>
	<ti>128-256MB RAM</ti>
	<ti>256-512MB RAM</ti>
	</tr>
	<tr>
	<ti>720MB</ti>
	<ti>702MB</ti>
	<ti>640MB</ti>
	<ti>256MB</ti>
	</tr>
	</table>
		

<p>
    Prima di creare le vostre partizioni, è veramente una buona idea inizializzare
    il vostro HD usando <c>dd</c>. Facendo questo siamo sicuri che i nuovi filesystem
    non saranno mal identificati dal programma di mount di Linux.
    Per questo dovrete eseguire:
</p>

<pre caption = "Inizializzare i primi 1024 settori dell'HardDisk">
# <c>dd if=/dev/zero of=/dev/hdxy bs=1K count=1 </c>
<comment>Sostituite a /dev/hdxy il device che volete &quot;pulire&quot;</comment>
</pre>
<warn>
    Il summenzionato comando distruggerà tutti i dati di <path>/dev/hdxy</path>.
    Fate attenzione e controllate due volte la partizione avete specificato per
    la pulitura. Se sbagliate, il risultato potrebbe essere la perdita di tutti i vostri dati.
</warn>

<p>A questo punto, creiamo le partizioni usando fdisk. Notate che le partizioni
dovrebbero essere di tipo 82
per lo swap e 83 per i filesystems regolari (sia ReiserFS <e>o</e> ext2/3).
</p>

<note><i>cfdisk</i> è incluso nel CD di installazione ed è *considerabilmente*
facile da usare rispetto a <i>fdisk</i>. Digitate <c>cfdisk</c> per eseguirlo. Per default
cfdisk usa <b>/dev/hda</b> come disco. Se /dev/hda non è il disco che volete partizionare,
date a cfdisk come parametro il giusto device. Per esempio: <c>cfdisk /dev/hde</c>
</note>

<note>Se ricevete istruzioni da <c>fdisk</c> o <c>cfdisk</c> di riavviare il sistema, fatelo in modo da
far scoprire al sistema le nuove partizioni.
</note>
<note>Se state usando il RAID le vostre partizioni saranno leggermente diverse.
Avrete partizioni come queste:
<path>/dev/ataraid/discX/partY</path>
X è l'array che avete creato, così se avete creato solo 1 array sarà
disc0. Y è il numero di partizione come in <path>/dev/hdaY</path>
</note>
<p>
	Una volta create le partizione, dobbiamo inizializzare
	i filesystems che saranno usati
	per immagazzinare i nostri dati. Inizializzate la partizione di swap come segue:
</p>
<pre caption="Inizializzazione dello SWAP">
# <i>mkswap /dev/hda2</i>
</pre>
<p>
	Possiamo usare il comando <c>mke2fs</c> per creare filesystems di tipo ext2:
</p>
<pre caption="Creazione di un filesystem ext2">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>
	Per create filesystem XFS usiamo il comando <c>mkfs.xfs</c>:
</p>
<pre caption="Creazione di un filesystem xfs">
# <i>mkfs.xfs /dev/hda3</i>
</pre>
<note>
	Potete voler aggiungere un paio di flags in più al comando <c>mkfs.xfs</c>:
	<c>-d agcount=3 -l size=32m</c>.
	Il flag <c>-d agcount=3</c> abbassa il numero dei gruppi di allocazione.
	XFS insiste usando almeno 1 gruppo di
	allocazione per ogni 4 GB di partizione, così, per esempio, se avete una partizione di 20GB
	avrete bisogno di 5 gruppi (agcount) come minimo. 
	Il flag <c>-l size=32m</c> porta a 32 MB la size del journal, 
	incrementando le performance.
</note>
<warn>
	Se state installando una partizione XFS su una preesistente ReiserFS,
	il successivo tentativo di montarla
	con <c>mount -t xfs</c> può fallire. La
	soluzione è azzerare la 
	partizione prima di create il filesystem XFS:
	<c>dd if=/dev/zero of=/dev/hd<comment>x</comment> bs=1k</c>.
</warn>
<p>Se preferite usare ext3, potete creare la partizione usando <c>mke2fs -j</c>:</p>
<pre caption="Creazione di un filesystem ext3">
# <i>mke2fs -j /dev/hda3</i>
</pre>
<note>
    Potete trovare maggiori informazione su come usare ext3 su Linux 2.4
    all'indirizzo <uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.

</note>
<p>
	Per creare un filesystem ReiserFS, usate il comando <c>mkreiserfs</c>:
</p>
<pre caption="Creazione di un filesystem ReiserFS">
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
    Per creare un filesystem JFS, usate il comando <c>mkfs.jfs</c>.
</p>
<pre caption="Creazione di un filesystem JFS">
# <c>mkfs.jfs /dev/hda3</c>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Fare il mount delle partizioni</title>
<section>
<body>
<p>
	E' il momento di attivare la vostra partizione
	di swap, che vi servirà
	in seguito come memoria virtuale aggiuntiva:
</p>
<pre caption="Attiviamo lo SWAP">
# <i>swapon /dev/hda2</i>
</pre>
<p>
	Poi, creerete i mountpoints (letteralmente: punti di montaggio)
	<path>/mnt/gentoo</path> e <path>/mnt/gentoo/boot</path>, e quindi
	vi monterete i vostri filesystems.
</p>
<pre caption="Creazione dei mount points">
# <i>mkdir /mnt/gentoo</i>
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>
<p>
	Se avete deciso di creare <path>/usr</path> o <path>/var</path>
	come partizioni separate, dovrebbero essere
	rispettivamente montate in <path>/mnt/gentoo/usr</path> e <path>/mnt/gentoo/var</path>.
	(N.d.T. la partizione /var dovrà essere molto
	campiente in quanto conterrà la directory
	temporanea del sistema Portage per la compilazione
	dei pacchetti.)
</p>

   
<impo>
	Se la partizione di <e>boot</e> (dove risiede il
	kernel) è ReiserFS,
	dovete essere sicuri di montarla con
	l'opzione <c>-o notail</c> in modo tale che GRUB possa essere installato correttamente.
	Dovete anche assicurarvi che <c>notail</c> termini la riga che si riferisce
	alla partizione di boot in <path>/etc/fstab</path>.
	Ritorneremo brevemente su questo punto.
</impo>
<impo>
    Se state avendo problemi a montare la vostra partizione di boot con ext2,
    riprovate usando <c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Ottenere il stage-x tarfile desiderato</title>
<section>
<body>
<p>
    Se state usando il LiveCD 3stages avete già tutti gli stage tarballs
    disponibili sul CD. In questo caso, copiate il tarball che avete scelto in <mnt>/mnt/gentoo</mnt>
</p>
<p>
    Alternativamente, se avete il basic LiveCD, il tarball stage1 è
    ancora disponibile sul CD in <path>/mnt/cdrom/gentoo</path>. Dovrete in seguito
    fare comunque un download degli altri stage e metterli in <path>/mnt/gentoo</path>.
</p>
<pre caption="Download degli stages richiesti">
# <c>cd /mnt/gentoo</c>
<comment>Usate lynx per scaricare il tarball:</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc3/x86/</c>
<comment>
    Usate i tasti cursore <c>Up</c> e <c>Down</c> (o il tasto <c>TAB</c>) per andare nella
    directory corretta ed evidenziare lo stage che volete scaricare. Premete <c>d</c> per iniziare
    il download, salvate il file e uscite dal browser.
    <b>O</b> usate wget da linea di comando:
</comment>
# <c>wget <comment>inserite qui l'URL del tarball con lo stage che volete</comment></c>

</pre>
</body>
</section>
</chapter>

<chapter>
    <title>Scomprimere l'immagine che desiderate usare</title>
<section>
<body>

<p>
	E' ora il momento di estrarre il tar file dello stage che avete scelto
	in <path>/mnt/gentoo</path>.
    Devrete estrarre solo lo stage da cui volete partire, se avete scelto di partire dallo stage3
    dovrete estrarre solo il tarball stage3.
	Quindi faremo il <c>chroot</c> della nuova installazione di
	Gentoo Linux.
</p>

<impo>
	Ricordatevi di usare l'opzione <c>p</c> col comando tar.
	Altrimenti alcuni files potrebbero
	ricevere permessi errati
.</impo>

<p>
	Se state usando il metodo di installazione &quot;from scratch, build everything&quot;
	(&quot;costruisci tutto da zero&quot;), dovrete usare l'immagine <path>stage1-ix86-1.4_rc3.tbz2</path>.
    Se invece state usando uno dei CD di grosse dimensioni, avrete anche la possibilità
    di scegliere tra le immagini stage2 e stage3.
    Queste immagini vi permettono di risparmiare tempo a spesa della configurabilità dato
    che abbiamo scelto noi le ottimizzazione per il compilatore e le variabili USE di
    default.
</p>
<pre caption="Scomprimere lo stage">
# <i>cd /mnt/gentoo</i>
# <i>tar -xvjpf /mnt/cdrom/gentoo/stage?-*.tbz2</i>
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
</pre>

<pre caption="Entriamo nell'ambiente chroot">
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
# 
<comment>I passi summenzionati aggiornano i percorsi di ricerca della shell.</comment>
</pre>

<p>
	Dopo aver eseguito questi comandi, siete &quot;dentro&quot; l'ambiente Gentoo Linux. 
</p>

</body>
</section>
</chapter>

<chapter>
<title>Scarichiamo il Portage Tree corrente usando sync</title>
<section>
<body>

<p>	Dovrete ora eseguire <c>emerge sync</c>.   
    Questo vi assicura di avere la copia più recente del Portage tree.
</p>
	
<pre caption="Aggiornamento usando sync">
# <c>emerge sync</c>
# <c>export CONFIG_PROTECT=&quot;-*&quot;</c>
# <c>export USE=&quot;-* bootstrap build&quot;</c>
# <c>emerge portage</c>
# <c>unset USE</c>

</pre>

<p>
    Verrà scaricato il Portage Tree e memorizzato in <path>/usr/portage</path>; la sua dimensione è di circa 90Mb senza tarballs.
</p>
<note>
    La linea <c>export CONFIG_PROTECT=&quot;-*&quot;</c> assicura che ogni nuovo script
    installato in <path>/etc</path> possa sovrascrivere gli script precedenti (
    memorizzati in <path>sys-apps/baselayout</path>), bypassando il supporto per
    la gestione dei file di configurazione del Portage. Digitate <c>emerge --help config</c>
    per maggiori dettagli.
</note>

</body>
</section>
</chapter>
<chapter>
<title>Stabilire le ottimizzazioni (make.conf)</title>
<section>
<body>

<p>	Ora che stiamo lavorando su una copia del Portage tree, coloro che usano
	lo stage1 devono effettuare il bootstrap del Gentoo Linux procedendo
	secondo le istruzioni che seguono. Primo: editare il file 
	<path>/etc/make.conf</path>. In questo file dovremo definire ad ok 
	i vari flag <c>USE</c> che servono a specificare quali funzionalità
	supplementari si vogliono includere nella costruzione dei pacchetti.
	In genere i settaggi di default sono accettabili (ovvero un USE  <e>vuoto</e> 
	o non configurato). 
    Maggiori informazioni sui flag di USE possono essere trovate <uri link="http://www.gentoo.org/doc/it/use-howto.xml">qui</uri>.
    Una lista completa dei flag USE la potete trovare <uri link="http://www.gentoo.org/dyn/use-index.xml">qui</uri>.

    Si dovrebbero definire in modo appropriato anche i flag
	<c>CHOST</c>, <c>CFLAGS</c> e <c>CXXFLAGS</c> a seconda dal tipo
	di sistema che si vuol creare (potete trovare esempi documentati direttamente
	in questo file).  Questi setting saranno usati per dire ai compilatori C e C++
    come ottimizzare il codice che deve essere generato per il vostro sistema. E'
    comune, per esempio, per utenti con processori Athlon XP specificare un flag &quot;-marc=athlon-xp&quot;
    sia in CFLAGS che in CXXFLAGS in tal modo tutti i pacchetti saranno compilati
    e ottimizzati per il set di istruzioni e performance caratteristiche del processore
    in uso. Il file <path>/etc/make.conf</path> contiene una guida generale per i settaggi
    propri di CFLAGS e CXXFLAGS.
</p>
<p>
    Se necessario, potremmo anche settare le informazioni sul proxy nel caso vi trovaste dietro
	un firewall.
</p> 
	

<pre caption="Editiamo il make.conf">
# <i>nano -w /etc/make.conf</i> <comment>(Aggiustiamo questi settaggi)</comment>
</pre>
<note>
	Coloro che hanno bisogno di una 'regolazione fine' 
	del processo di costruzione potrebbero dare uno sguardo
	al file <path>/etc/make.globals</path>.
	Questo file comprende i parametri di defaults di Gentoo e non
	dovrebbe mai essere modificato. Se i parametri di defaults non 
	sono sufficienti, i nuovi valori dovrebbero
	essere messi in <path>/etc/make.conf</path>, i valori dei parametri 
	di <path>/etc/make.conf</path>
	<comment>sovrascrivono</comment> gli stessi
	in <path>/etc/make.globals</path>. Se siete interessati ad un
	aggiustamento fine dei settings di USE,
	guardate in <path>/etc/make.profile/make.defaults</path>.
	Se volete disabilitare alcuni settings di USE, 
	aggiungete in <path>/etc/make.conf</path> <c>USE="-flag"</c> per disabilitare flag.
	(N.d.T.:  p.e. USE=&quot;gnome&quot; includerà gnome nella compilazione di
	programmi che potrebbero avere qualche feature in
	più
	includendo gnome, ma che sostanzialmente non ne hanno bisogno
	per il corretto funzionamento, mentre USE=&quot;-gnome&quot;
	non includerà gnome.)
</note>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage1</title>
<section>
<body>
<p>
    Il tarball stage1 è per costruire un sistema completamente personalizzato e ottimizzato.
    Se avete scelto questo tarball state probabilmente cercando di avere un sistema
    ultra ottimizzato.  Buon divertimento, perché l'ottimizzazione è 
    la cosa più importante di Gentoo  Linux. L'installazione partendo dallo stage1
    prende diverso tempo, ma il risultato è che il sistema è stato ottimizzato
    per essere un fondamento specifico per la tua macchina su cui costruire secondo le
    vostre necessità.
</p>
<p>
	E' giunto il momento di far partire il processo di 'bootstrap'.
	Il processo durerà almento 2 ore su un AMD 1200MHz.
	Durante questo tempo, l'immagine estratta
	verrà preparata per l'installazione
	del resto del sistema.
	Il compilatore GNU GCC verrà compilato così
	come le librerie GNU C. La compilazione di questi componenti
	richiede parecchio tempo e costituisce la maggior parte
	del processo di bootstrap.
</p>
<pre caption="Bootstrapping">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>
<p>E' iniziato il processo di &quot;bootstrap&quot;.</p>
<note>
	Portage usa per default <c>/var/tmp</c> durante la
	fase di complilazione dei pacchetti, usando spesso
	centinaia di megabyte come area di memorizzazione
	temporanea. E' possibile cambiare la
	directory dove Portage stora temporaneamente i suoi
	files, aggiustando la variabile PORTAGE_TMPDIR
	<e>prima</e> di far partire il processo di bootstrap
	come segue:
</note>
<pre caption="Cambiare la directory temporanea del PORTAGE">
# <i>export PORTAGE_TMPDIR=&quot;/altradir/tmp&quot;</i>
</pre>

<p>
	Il comando <c>bootstrap.sh</c> compilerà i
	pacchetti <c>binutils</c>, <c>gcc</c>,
	<c>gettext</c> e <c>glibc</c>, ricompilando
	<c>binutils</c>, <c>gcc</c> e <c>gettext</c> dopo la
	costruzione delle <c>glibc</c>. Inutile dirlo,
	questo processo durerà un pò di tempo.
	Una volta che il processo è completato, il vostro
	sistema è in &quot;stage2&quot; il che significa che potete
    andare alle istruzione relative allo stage2.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage2</title>
<section>
<body>
<p>
    Il tarfile stage2 ha già il bootstrapping fatto per voi. Tutto quello che 
    dovete fare è installare il resto del sistema.
</p>
<note>
    Se non l'avete ancora fatto, editate <path>/etc/make.conf</path> a vostro piacimento.
</note>
<pre caption="Installazione del resto del sistema">
# <c>emerge -p system</c>
	<comment>[lista dei pacchetti che devono essere installati]</comment>
# <c>emerge system</c>
</pre>

<p>
    Questo step prenderà un pò di tempo per costruire l'intero sistema di base.
    Il lato positivo è che avrete un sistema veramente ottimizzato. D'altra parte
    dovrete trovare qualcosa da fare. Vi suggerisco una buona lettura o un buon videogioco.
</p>
<p>
    Quando <c>emerge system</c> è terminato, sarete giunti in uno stadio
    equivalente allo stage3. A questo punto
    potete seguire le istruzioni per lo
    stage3 e completarlo. In questo modo avrete il vostro sistema  pronto e
    aggiornato col Portage corrente. Non è necessario, ma è raccomandato farlo.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Partendo dallo Stage3</title>
<section>
<body>
<p>
    Il tarfile stage3  è configurato per il vostro sistema. Non c'è molto da fare
    per questo stage, ma è una buona idea aggiornare il vostro sistema con gli
    ultimi pacchetti disponibili.
</p>
<note>
    Se non lo avete già fatto, editate <path>/etc/make.conf</path> e adattatelo alle vostre esigenze.
</note>
<pre caption="Avere tutto aggiornato">
# <c>emerge sync</c>
# <c>emerge -up world</c>
<comment>lista i [<i>pacchetti</i>] che devono essere installati</comment>
# <c>emerge -u world</c>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Timezone</title>
<section>
<body>

<p>
    A questo punto dovreste avere un sistema che è pronto per la configurazione finale.
    Partiremo col configurare la timezone.
</p>
<p>
	Cercate la vostra Timezone ( o GMT se state usando
	il Greenwich Mean Time) in <path>/usr/share/zoneinfo</path>.
	Poi, create un link simbolico come segue:
</p>

<pre caption="Selezionare la timezone">
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Installare il kernel e il System Logger</title>
<section>
<body>

<note>Se non l'avete ancora fatto, editate <path>/etc/make.conf</path> a vostro piacimento.</note>
<p>
    Avete ora bisogno di scaricare i sorgenti del kernel di Linux. Ecco quelli disponibili:
</p>
<table>
<tr><th>ebuild</th><th>descrizione</th></tr>
<tr><ti><path>gentoo-sources</path></ti>
<ti>Il nostro avanzato e performante kernel (non include il supporto per XFS)</ti></tr>
<tr><ti><path>xfs-sources</path></ti>
<ti>Il kernel di SGI con supporto XFS</ti></tr>
<tr><ti><path>openmosix-sources</path></ti>
<ti>Un classico kernel patchato per il supporto di <uri link="http://www.openmosix.com">openMosix</uri>
una tecnologia load-balancing/clustering</ti></tr>
<tr><ti><path>usermode-sources</path></ti>
<ti>Un classico kernel patchato per il supporto dello User-Mode Linux.
(tecnologia &quot;Linux inside Linux&quot;)</ti></tr>
<tr><ti><path>vanilla-sources</path></ti>
<ti>Il classico kernel, come lo scaricheresti da kernel.org</ti></tr>
</table>
<warn>
    Se stai configurando il tuo kernel, fai attenzione alle opzione <i>grsecurity</i>.
    Se scegli un livello di sicurezza troppo aggressivo, certi programmi (come X)
    potrebbero non funzionare correttamente. Se sei in dubbio, non selezionare
    le opzioni <i>grsecurity</i>.
</warn>
<p>
	Sceglietene uno e uniscilo (merge) al sistema:
</p>

<pre caption="Installare i sorgenti del kernel">
# <i>emerge sys-kernel/gentoo-sources</i>
</pre>

<p>
	una volta che il kernel è disponibile, è
	il momento di personalizzarlo e  compilarlo:
</p>
<p> 
    Notate che <path>/usr/src/linux</path> è un link simbolico ai sorgenti del
    kernel attualmente installato e che è settato automaticamente dal Portage
    al momento dell'emerge.
    Se avete più di un kernel, è necessario settare il link <path>/usr/src/linux</path>
    affinché punti ai sorgenti corretti prima di procedere.
</p>
<pre caption="Compilazione del kernel">
# <c>cd /usr/src/linux</c>
# <c>source /etc/profile</c>
<comment>Questo per aggiornare i vostri path. Se ottienete un errore che dice gcc not found,
questo è ciò che dovete fare.</comment>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
<warn>
	Affinché il vostro kernel funzioni a dovere, ci
	sono alcune opzioni che dovrete essere sicuri siano
	incluse nel kernel e non compilate come modulo.
	Assicuratevi di abilitare &quot;ReiserFS&quot; se avete partizioni
	di questo tipo; la stessa cosa vale per &quot;Ext3&quot;.
	Se state usando partizioni XFS, abilitate l'opzione &quot;SGI XFS
	filesystem support&quot;. E' sempre una buona idea
	lasciare il supporto per ext2 abilitato sia che lo
	usi o no. 
    Seguono alcune opzioni comuni di cui avrete bisogno:
</warn>

<pre caption="opzioni make menuconfig">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(Avete bisogno di questo per delle opzioni che seguono.)</comment>
     ...

File systems ---&gt;
  &lt;*&gt; Reiserfs support
<comment>(Solo se avete partizioni ReiserFS.)</comment>
       ... 
  &lt;*&gt; Ext3 journalling file system support
<comment>(Solo se avete partizioni ext3.)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Richiesto per Gentoo Linux.)</comment>
       ...
  &lt;*&gt; JFS filesystem support
<comment>(Solo se avete partizioni JFS.)</comment>
       ...
  [*] /proc file system support
<comment>(Richiesto per Gentoo Linux.)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot          
<comment>(Richiesto per Gentoo Linux.)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(Disabilita questa, non è necessaria.)</comment>
       ...
  &lt;*&gt; Second extended fs support
<comment>(Solo se avete partizioni ext2.)</comment>
       ...
  &lt;*&gt; XFS filesystem support
<comment>(Solo se avete partixioni XFS.)</comment>
</pre>

<p>
	Se state usando RAID hardware avrete bisogno di abilitare un paio
	di opzioni in più nel kernel: Per controllers Highpoint RAID
	abilitate il supporto per il chipset hpt366, per i controllers
	IDE RAID e Highpoint 370 software RAID.
	Per i controllers Promise abilitate il supporto PROMISE PDC202{46|62|65|67|68|69|70}, 
	per i controllers IDE RAIDS e Support Promise software RAID (Fasttrak(tm))
</p>
<p>
    Se usate PPPoE per connettervi ad internet, avrete bisogno delle seguenti
    opzioni nel kernel (preferibilmente come moduli):
    &quot;PPP (point-to-point protocol) support&quot;, &quot;PPP support for async
    serial ports&quot;, &quot;PPP support for sync tty ports&quot;. Le due opzioni
    relative alla compressione non sono strettamente necessarie così
    come &quot;PPP over Ethernet&quot; che potrebbe essere usata solo da <i>rp-ppoe</i>
    quando il kernel è in modalità PPPoE.
</p>
<p>
	Se avete un masterizzatore IDE, avrete bisogno di abilitare 
	l'emulazione SCSI nel kernel. Abilitate &quot;ATA/IDE/MFM/RLL support&quot; ---> &quot;IDE, ATA and ATAPI Block devices&quot; --->
	&quot;SCSI emulation support&quot; (abilitato di solito come modulo), qundi 
	sotto &quot;SCSI support&quot;, abilitate &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; e
	&quot;SCSI generic support&quot; (abilitati come moduli anche questi).
	Se avete scelto di usarli come moduli, allora digitate <c>echo -e &quot;ide-scsi/nsg/nsr_mod&quot; >> /etc/modules.autoload</c> per averli automaticamente al boot.
</p>

<note>
	Per coloro che lo preferiscono, è possibile installare
	una Gentoo Linux con kernel 2.2. Per questo c'è
	da pagare un prezzo: perdere le ottime features che
	sono prerogativa della serie 2.4 del kernel (come
	il support per filesystems di tipo XFS e tmpfs,
	iptables, e altro), anche se Gentoo Linux con kernel
	2.2 può essere aggiornato per il support ReiserFS e
	devfs. Gli scripts di  boot di Gentoo Linux richiedono
	che tmpfs o ramdisk siano supportati dal kernel,
	così coloro che vogliono usare il kernel 2.2
	devono essere sicuri di avere il support per ramdisk
	incluso nel kernel e non compilato come modulo.
	E' <comment>vitale</comment> che  un flag
	<e>gentoo=notmpfs</e> sia aggiunto in
	<path>/boot/grub/menu.lst</path> nella linea del
	kernel per la serie 2.2 in modo tale che gli scripts
	di boot montino ramdisk invece di tmpfs. Se scegliete
	di non usare  devfs, devrete aggiungere una riga del
	tipo <e>gentoo=notmpfs,nodevfs</e>.
</note>

<p>
	Il nuovo kernel e i suoi moduli sono ora
	installati. C'è ora bisogno di scegliere il
	sistema di logging che dovrebbe essere installato.
	E' disponibile il tradizionale sistema di
	logging sysklogd. Ma ci sono anche syslog-ng e
	metalog. Utenti che preferivano
	sysklogd (che non brilla per le prestazioni) si
	stanno rivolgendo verso syslog-ng e metalog. Se siete
	in dubbio, potete provare metalog che sembra essere
	abbastanza popolare. Per installare il logger
	scelto, digitate <e>uno</e> dei seguenti quattro comandi:
</p>

<pre caption="Installazione di un sistema di log">
# <i>emerge sys-apps/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>o</comment>
# <i>emerge app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>o</comment>
# <i>emerge app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>o</comment>
# <i>emerge app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>
<warn>
	Nel caso di syslog-ng avrete bisogno di creare
	<path>/etc/syslog-ng/syslog-ng.conf</path>.
	Potete trovarne un esempio in
	<path>/etc/syslog-ng</path>.
</warn>
<impo>
	Metalog scrive il suo output su disco a blocchi,
	così i messaggi non sono immediatamente
	registrati nei logs di sistema. Se state provando a
	testare un daemon, questa caratteristica (che ne
	migliora le prestazioni) potrebbe non essere la
	soluzione migliore.  Una volta che il sistema e' a
	regime potete provare a mandare al daemon di metalog
	un segnale di tipo USR1 che temporaneamente dovrebbe
	disabilitare il suddetto comportamento (il buffering
	dei messaggi prima discriverli in blocco). Questo
	significa che <i>tail -f
	<path>/var/log/logfile</path></i> dovrebbe
	funzionare come ci aspettiamo. Per tornare alla
	situazione standard invieremo un nuovo segnale,
	questa volta di	tipo USR2.
    Se volete disabilitare permanentemente il buffering, potete cambiare
    l'opzione METALOG_OPTS da &quot;-B&quot; a &quot;-B -s&quot; in <path>/etc/conf.d/metalog</path>.
</impo>

<p>
	Se volete, potete ora scegliere il pacchetto cron che
	preferite. Per ora offriamo, dcron, fcron e vcron.
	Se non sapete quale scegliere tra questi, potete usare
	vcron. I pacchetti possono essere
	installati come segue:
</p>
<pre caption="Installazione di un pacchetto cron">
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/vcron</c>
# <c>crontab /etc/crontab</c>
<comment>Non dimenticate di aggiungere il vostro *cron all'appropriato init level.</comment>
# <c>rc-update add *cron default</c>
</pre>

<p>
	Per maggiori informazioni sui programmi e daemon che partono al boot,
	date un'occhiata alla guida <uri link="http://www.gentoo.org/doc/it/rc-scripts.xml">rc-scripts</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Installazione di altri pacchetti necessari</title>
<section>
<body>

<p> Se avete bisogno di rp-pppoe per connettervi alla rete, siate consci che a
questo punto non è stato ancora installato. Potrebbe essere una buona
cosa farlo ora.
</p>

<pre caption= "Installazione di rp-pppoe">
# <c>USE=&quot;-X&quot; emerge rp-pppoe</c>
</pre>

<note>
    Con l'impostazione <i>USE=&quot;-X&quot;</i> impediamo che pppoe installi l'interfaccia grafica opzionale, 
    il che è una buona cosa in quanto verrebbe installato anche l'ambiente grafico X con tutte
    le sue dipendenze. Potrete sempre ricompilare <i>rp-pppoe</i> con il supporto X in seguito.
</note>

<note> Notate che adesso rp-pppoe è installato ma non configurato.
Dovrete configurarlo usando <c>adsl-setup</c> dopo aver riavviato
Gentoo per la prima volta.
</note>
<p>
	Potreste aver bisogno di installare pacchetti
	addizionali nel Portage tree, se state usando ad
	esempio XFS, ReiserFS o LVM. Per XFS, dovreste installare
	il pacchetto <c>xfsprogs</c>:
</p>

<pre caption="Installazione dei tools per i filesystem">
# <c>emerge sys-apps/xfsprogs</c>
<comment>Se state usando ReiserFS, dovreste installare i tools di ReiserFS:</comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>Se state usando JFS, dovreste installare i tools JFS:</comment>
# <c>emerge jfsutils</c>
<comment>Se invece state usando LVM, dovreste installare il pacchetto <c>lvm-user</c>:</comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>

<p> Se state usando un laptop e volete usare gli slots PCMCIA al vostro primo
reboot, dovrete installare il pacchetto <i>pcmcia-cs</i>.
</p>

<pre caption = "Emerge pcmcia-cs">
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
<warn>
    Dovrete reinstallare <i>pcmcia-cs</i> dopo l'installazione per far si che
    PCMCIA lavori correttamente.
</warn>
</body>
</section>
</chapter>
<chapter>
<title>Modifica di /etc/fstab per la vostra macchina</title>
<section>
<body>
<p>
	Il vostro sistema Gentoo Linux è ormai pronto
	all'uso. Tutto ciò di cui abbiamo bisogno
	è di configurare alcuni importanti file di
	sistema e installare il GRUB boot loader.
	Il primo file che abbiamo bisogno di configurare
	è <path>/etc/fstab</path>. Ricordate che se avete
	scelto una partizione di boot di tipo ReiserFS dovrete
	aggiungere una opzione <c>notail</c>.
	Ricordatevi inoltre di specificare il tipo di
	filesystem appropriato per ogni partizione
	(<c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>).
</p>

<p>
	Usate qualcosa tipo l' <path>/etc/fstab</path>
	mostrato sotto, ma naturalmente sostituite &quot;BOOT&quot;,
	&quot;ROOT&quot; e &quot;SWAP&quot; con i block devices che avete scelto
	di usare (<c>hda1</c>, <c>hda2</c>, ecc.).
</p>
<pre caption="Configurazione dell'fstab">
<comment>
# /etc/fstab: static file system information.
#
# noatime turns of atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It's safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs&gt;          	&lt;mountpoint&gt;    &lt;type&gt;  	&lt;opts&gt;      		&lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT		/boot		    ext2		noauto,noatime	1 2
/dev/ROOT		/		        ext3		noatime			0 1
/dev/SWAP		none            swap		sw			    0 0
/dev/cdroms/cdrom0	/mnt/cdrom	iso9660		noauto,ro		0 0
proc			/proc           proc		defaults		0 0
</pre>

<warn>
    Notate che <i>/boot</i> NON E' montato al boottime. Questo per proteggere i dati
    in <i>/boot</i> dal pericolo di corruzione. Se avete bisogno di accedere a <i>/boot</i>
    ricordati di montarlo!
</warn>
</body>
</section>
<section>
<title>Diamo una password a root</title>
<body>

<p>
	Prima di dimenticarcene, diamo una password a root
	digitando:
</p>
<pre caption="Cambiamo la password di root">
# <i>passwd</i>
</pre>
<p>
    Vorrete anche aggiungere un altro user oltre a root, per un uso quotidiano.
    Per questo consultate le <uri link="http://www.gentoo.org/doc/it/faq.xml">Gentoo FAQ</uri>.
</p>
</body>
</section>
<section>
<title>Impostimo il nome della macchina</title>
<body>
<p>
	Create questo file in modo da contenere il
	fully-qualified domain name della vostra macchina su
	una singola riga, p.e.
	<c>nomemacchina.nomedominio.it</c>.
</p>
<pre caption="Impostare l'hostname">
# <c>echo nomemacchina.nomedominio.it &gt; /etc/hostname</c>
</pre>
</body>
</section>

<section>
<title>Modifichiamo /etc/hosts</title>
<body>

<p>
	Questo file contiene una lista di indirizzi IP
	associati al relativo hostname. E' usato dal
	sistema per risolvere indirizzi IP di macchine che
	possono non essere nel tuo DNS server.
	Segue un templato di questo file:
</p>
<pre caption="Editare il file /etc/hosts">
127.0.0.1      localhost
<comment># la prossima riga contiene l'IP della vostra macchina associato al suo nome
</comment>
192.168.1.1    nomemacchina.nomedomimio	 nomemacchina
</pre>
<note>
    Se siete in una rete DHCP, potrebbe essere utile impostare <i>localhost</i> col nome del attuale
    della macchina. Questo aiuterà GNOME e altri programmi nella risoluzione dei nomi.
</note>
</body>
</section>

<section>
<title>Configurazione finale della rete</title>
<body>
<p>
	Aggiungete il nome di ogni modulo necessario per il
	corretto funzionamento del vostro sistema in
	<path>/etc/modules.autoload</path> (potete anche
	aggiungere le opzioni necessarie sulla stessa riga).
	Alla partenza di Gentoo Linux, questi moduli
	verranno automaticamente caricati. Particolarmente
	importanti sono i moduli relativi alla scheda di
	rete (naturalmente se li avete compilati come moduli
	;-)):
</p>
<pre caption="/etc/modules.autoload">
<comment>Assumendo che stiate usando una scheda di rete 3COM.
Controllate  <path>/lib/modules/`uname -r`/kernel/drivers/net</path> per la vostra scheda.
</comment>
3c59x
</pre>
<p>
	Editate lo script <path>/etc/conf.d/net</path> per
	avere la rete configurata per il  primo boot:
</p>
<pre caption="Configurare la rete in modo permanente">
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>
<p>
	Se avete più schede di rete avrete bisogno di
	aggiungere altri scripts
	<path>net.eth<comment>x</comment></path> per ognuna
	(<comment>x</comment> = 1, 2, ...):
</p>
<pre caption="Interfacce di rete multiple">
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment></i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>
<p>
	Se avete una scheda PCMCIA installata, date una rapida
	occhiata a <path>/etc/init.d/pcmcia</path> per verificare se
	è conforme alle vostre esigenze e aggiungete le righe seguenti  in testa
    al file <path>/etc/init.d/net.eth<comment>x</comment></path>:
</p>
	<pre caption="Aggiungiamo dipendenze PCMCIA in /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
	</pre>
<p>
	In questo modo i driver pcmcia verranno caricati automaticamente
	ogni volta che verrà avviata la rete.
</p>
	
</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: configurazioni di base (includendo il
setting per la mappatura internazionale della tastiera)</title>
<section>
<body>
<pre caption="Configurazione di base">
# <i>nano -w /etc/rc.conf</i>
</pre>
<p>
	Dando una scorsa al file troverete diverse variabili
	che inizializzano alcune configurazioni di base. 
	Vorrete essere sicuri che <c>CLOCK</c> sia quello
	voluto. Per usare tastiere con layout diverso da
	quello americano potete settare la variabile
	<c>KEYMAP</c> (potete trovare le varie
	possibilità in
	<path>/usr/share/keymaps</path>).
</p>
</body>
</section>
</chapter>
<chapter>
<title>Configurazione di un bootloader</title>
<section>
<title>Note</title>
<body>
<p>
    Nello spirito di Gentoo, gli utenti possono ora scegliere tra più di un bootloader.
    Usando il nostro virtual package system, gli utenti possono scegliere sia GRUB che LILO
    come loro bootloaders.
</p>
<p>
    E' chiaro che non è necessario avere entrambi i bootloader installati.
    Infatti potrebbe essere un ostacolo, vi consigliamo di sceglierne uno solo.
</p>
</body>
</section>
<section>
<title>Configurazione di GRUB</title>
<body>
<p>
	La parte più critica per capire la
	configurazione di GRUB è familiarizzare con la
	notazione che GRUB usa per definire i dischi e le
	partizioni. La partizione Linux
	<path>/dev/hda1</path>  è chiamata
	<path>(hd0,0)</path> sotto GRUB.
	Nota che le parentesi che racchiudono hd0,0 sono
	richieste. I dischi vengono contati a partire da
	zero invece che da &quot;a&quot; e le partizioni partono da
	zero invece che da uno.
    Dovete essere consapevoli che con periferiche hd sono contati solo i dischi rigidi e non
    periferiche atapi-ide come cdrom e masterizzatori e che lo stesso costrutto vale
    anche per periferiche SCSI. (Di solito queste prendono numeri alti rispetto a periferiche
    ide ad eccezione di quando il bios è configurato per fare il boot da SCSI devices). Così
    facendo finta che abbiate un disco su /dev/hda, un lettore cdrom su /dev/hdb, un masterizzatore
    su /dev/hdac e un secondo disco su /dev/hdd e nessun disco SCSI, la partizione <path>/dev/hdd7</path>
    diventa <path>(hd1,6)</path>.
    Tutto questo potrebbe suonare complicato, ed è effettivamente complicato, ma come vedrete,
    grub offre un meccanismo di completamento col tasto TAB, che diviene funzionale per coloro che
    hanno un notevole numero di dischi e partizioni e sono un pò smarriti con lo schema numerico
    del grub. Avendo preso coscienza di questo, è il momento di installare GRUB.
	 Appena avete preso confidenza
	con questa notazione, potete convertire le partizioni
	di boot e root in un formato comprensibile a GRUB e
	scriverle nel suo file di configurazione.
	Proviamo quindi ad installare GRUB.
</p>
<p>
	La via più breve per installare GRUB è
	semplicemente digitare <c>grub</c> al prompt:
</p>
<pre caption="GRUB">
# <i>grub</i>
</pre>

<impo>
    Questa parte non funzionerà se state usando hardware RAID.
    Saltate alla sezione sulla creazione del  <path>grub.conf</path>. Dopodiché
    completerete il setup di grub per i controller RAID.
</impo>
<p>
	Vi verrà presentato il  &quot;grub command-line
	prompt: <c>grub&gt;</c>. Ora dovrete digitare i
	giusti comandi per installare il GRUB boot record
	nel vostro disco. Nel mio esempio, io voglio installare
	il GRUB boot record nell'MBR (master boot record)
	del mio disco rigido, in modo tale da vedere il GRUB
	prompt ad ogni riavvio del mio computer. Nel mio
	caso i comandi che devo digitare sono:
</p>
<pre caption="Installazione di GRUB nell'MBR">
grub&gt; <c>root (hd0,0)</c><codenote>La mia partizione di boot</codenote>
grub&gt; <c>setup (hd0)</c><codenote>Dove viene installato il boot record, in questo caso nell'MBR</codenote>
</pre>

<pre caption="Installazione di GRUB non nell'MBR">
<comment>Alternativamente, potete installare il grub su qualche altra partizione oltre che nell'MBR
</comment>
grub&gt; <c>root (hd0,0)</c><codenote>La partizione di boot</codenote>
gurb&gt; <c>setup (hd0,4)</c><codenote>Dove viene installato il boot record, in questo caso la partizione /dev/hda5</codenote>
grub&gt; <c>quit</c>
</pre>
<p>
	Come lavorano i comandi. Il primo comando <c>root (
	)</c> dice a GRUB la locazione della partizione di
	boot (nel nostro esempio <path>/dev/hda1</path> o
	<path>(hd0,0)</path> nella terminologia GRUB. Il
	secondo comando <c>setup ( )</c> dice a GRUB dove
	installare il boot record e sarà configurato
	per cercare i suoi files di configurazione nella
	locazione <c>root ( )</c> che avete specificato.
	Nel mio caso, voglio che il boot record sia
	installato nell'MBR del disco rigido, così
	specifico semplicemente <path>/dev/hda</path> (anche
	conosciuto come <path>(hd0)</path>). Se sto usando
	un altro boot loader e voglio installare GRUB come
	boot loader secondario, avrei dovuto installare il
	GRUB nel boot record di una particolare partizione.
	In questo caso avrei dovuto specificare una
	particolare partizione invece dell'intero disco. Una
	volta che il GRUB è stato installato con
	successo, potete uscire dal GRUB digitando
	<c>quit</c>. 
</p>
<note>
    Il meccanismo TAB completion del grub può essere usato all'interno
    del grub. Supponiamo che abbiate scritto <c> root (</c> se ora premete il tasto TAB,
    vi dovrebbe essere mostrata una lista di periferiche disponibili (non solo dischi),
    ripremendo il tasto TAB dopo aver scritto <c> root (hd</c>, grub vi dovrebbe mostrare
    solo i dischi e ripremendo il TAB dopo aver scritto <c> root (hd0,</c> dovreste
    avere la lista delle partizioni del primo disco.
    Il controllo della sintassi con cui il grub definisce le partizioni unito al completamento
    dovrebbe aiutarvi a fare le giuste scelte.
</note>
    
<p>
    L'installazione di Gentoo è ora completa, dobbiamo solo creare 
    il file <path>/boot/grub/grub.conf</path> che dovrebbe mostrare un menu
    quando il sistema viene riavviato.
</p>
<impo>
    Per assicurare un compatibilità con le versioni precedenti, vi consigliamo
    di creare un link tra <i>grub.conf</i> e <i>menu.lst</i>.
    Potete farlo digitando <c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>.
</impo>

<p>
	Creiamo il file grub.conf (<c>nano -w /boot/grub/grub.conf</c>),
	e aggiungiamo le seguenti righe:
</p>

<pre caption="Esempio di grub.conf">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment> # Seguono le instruzioni per usare RAID hardware
</comment>
title=Gentoo Linux su RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment>
	# Seguono le istruzioni per coloro che necessitano
	di un dual-boot
</comment>
title=Windows NT Workstation
root (hd0,5) 
cavetenloader (hd0,5)+1
</pre>
<note>
	(hd0,0) deve essere scritto senza spazi tra
	le parentesi.
</note>
<impo>
	Se avete configurato l'emulazione SCSI per un masterizzatore
	IDE, per renderlo attivo avete bisogno di aggiungere un &quot;hdx=ide-scsi&quot;
	alla linea del kernel in menu.lst (dove &quot;hdx&quot; dovrebbe essere 
	il device del vostro masterizzatore).
</impo>
<p>
	Dopo aver salvato il file, l'installazione di Gentoo
	Linux è completa. Selezionando la prima opzione
	diciamo al GRUB di fare il boot con Gentoo Linux. La
	seconda parte del file grub.conf è opzionale,
	mostra solo come usare GRUB per fare il boot anche
	con partizioni Windows.
</p>
<note>
	<path>(hd0,0)</path> dovrebbe puntare alla vostra
	partizione &quot;boot&quot; (<path>/dev/hda1</path> nel nostro
	esempio) e <path>/dev/hda3</path> dovrebbe puntare
	al filesystem root. La partizione
	<path>(hda0,5)</path> contiene il boot loader di NT.
</note>
<note>
    Il percorso dell'immagine del kernel è relativa alla partizione /boot.
    Se per esempio avete la partizione /boot <path>(hd0,0)</path> separata dalla root (/)
    <path>(hd0,1)</path>, tutti i percorsi del grub.conf diverrebbero <path>/bzImage</path>.
</note>
<p>
	Ancora, se avete bisogno di passare delle opzioni al
	kernel, aggiungetele semplicemente  alla fine del
	comando <c>kernel</c>. Stiamo già passandogli
	un'opzione (<c>root=/dev/hda3</c>), ma possiamo
	passargliene delle altre.  In particolare potreste
	disabilitare il support per il devfs (non è
	raccomandato a meno che non sappiate cosa state
	facendo) aggiungendo l'opzione <c>gentoo=nodevfs</c>
	al comando <c>kernel</c>.
</p>
	<note>
		A differenza delle prime versioni di Gentoo
		Linux, non è più necessario
		aggiungere <c>devfs=mount</c> alla fine
		della riga <c>kernel</c> per abilitare il
		devfs. Nelle nuove versioni è abilitato
		per default.
	</note>
</body>
</section>
<section>
<title>Configurare il LILO</title>
<body>
<p>
    Mentre GRUB può essere una nuova alternativa per molte persone, non è
    sempre la scelta migliore. LILO, il LInuxLOader, è il più provato e vero
    cavallo da fatica dei bootloaders di Linux. Ecco come installare LILO se lo volete usare
    al posto del GRUB:
</p>
<p> 
    Il primo step è installarlo:
</p>
<pre caption="Emerge LILO">
# <c>emerge lilo</c>
</pre>
<p>
    Ora è il momento di configurare LILO. Vi darò un piccolo <i>lilo.conf</i> da usare
    e vi spiegherò le differenti parti del file.
</p>

<pre caption="Esempio di lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	read-only
	root=/dev/hda5
	
#For dual booting windows/other OS
other=/dev/hda1
	label=dos

	</pre>
    <li><i>boot=/dev/hda</i>
        dice a LILO di installarsi nel primo disco del primo controller IDE.</li>
    <li><i>map=/boot/map</i>
        specifica il map file. In un normale uso, questo non dovrebbe essere modificato.</li>
    <li><i>install=/boot/boot.b</i> 
        dice a LILO di installare il file specificato come il nuovo settore di boot.
        Per un uso normale, questo non dovrebbe essere alterato. Se questa linea è  omessa, LILO assumerà
        un /boot/boot.b di default come file da essere usato.</li>
    <li>L'esistenza di <i>prompt</i>
        dice a LILO di mostrare qualsiasi cosa sia fornito nella linea message.
        Mentre non è raccomandato che tu rimuova la linea prompt, se la devi rimuovere, puoi ancora
        avere un prompt premendo il tasto [Shift] mentre la tua macchina parte per il boot.</li>
    <li><i>timeout=50</i>
        setta il tempo durante il quale LILO aspetterà qualche input
        prima di procedere con il boot di default. Questo è misurato in decine di secondi, con 50 come 
        default.</li>
    <li><i>message=/boot/message</i>
        si riferisce alla shermata che LILO mostra per permetterti
        di selezionare il sistema operativo o il kernel da avviare.</li>
    <li><i>lba32</i> 
        descrive la geometria del disco. Un altro parametro comune è linear. 
    Non dovresti cambiare questa linea a meno che non siate veramente sicuri di quello che state facendo.
    Altrimenti potreste avere un sistema non bootabile.</li>
    <li><i>default=linux</i> 
        si riferisce al systema operativo che il LILO avvierà
        di default con le opzioni che seguono dopo questa linea</li>
    <li><i>image=/boot/vmlinuz-2.4.20</i>
        specifica il kernel da avviare.</li>
    <li><i>label=linux</i> 
        è il nome del sistema operativo visualizzato nella schermata
        del LILO. In questo caso è anche il nome a cui si riferisce la linea di default.</li>
    <li><i>read-only</i> 
        specifica che la root partition (vedi la riga seguente) è read-only
        e non può essere alterata durante il processo di boot.</li>
    <li><i>root=/dev/hda5</i>
        dice al LILO quale partizione del disco deve essere usata 
    come root partition.</li>
<note>Un ringraziamento a <uri link="http://www.redhat.com">RedHat.com</uri> per queste
informazioni.</note>

<p>
    Dopo avere editato il nostro <i>lilo.conf</i>, è il momento di eseguire LILO per
    caricare queste informazioni nell'MBR:
</p>
<pre caption="Eseguire LILO">
# <c>/sbin/lilo</c>
</pre>
<p>
    LILO è configurato e ora la tua macchina è pronta per l'avvio in Gentoo Linux!
</p>

</body>
</section>
</chapter>
<chapter>
<title>Creazione dei bootdisk</title>
<section>
<title>GRUB Bootdisks</title>
<body>

<p>
    E' sempre una buona idea creare un dischetto di boot la prima volta che
    installiamo una qualsiasi distribuzione Linux. Questa è una sicurezza e
    generalmente non è una cattiva idea. Se state usando qualche tipo di hardware
    RAID, potreste avere <e>necessità</e> di creare un GRUB boot disk. Con questi tipi
    di hardware RAID non è possibile installare grub dalla shell chrooted.
    Se questo è il vostro caso, create un GRUB boot disk e quando riavviate la prima volta
    potrete installare GRUB sull'MBR. Create il vostro bootdisk in questo modo:
</p>
<pre caption="Creare un GRUB bootdisk">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>
# <c>umount /mnt/floppy</c>
# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
</pre>

<p>
    Ora riavviate e al prompt del grub del floppy, potrete eseguire i necessari comandi <c>root</c>
    e <c>setup</c>.
</p>
</body>
</section>
<section>
<title>LILO bootdisk</title>
<body>
<p>
    Anche se state usando LILO è una buona idea creare un bootdisk:
</p>
<pre caption="Creare un LILO Bootdisk">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>Questo è possibile solo con kernel più piccoli di 1.4MB</comment>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>L'installazione è completata!</title>
<section>
<body>
<p>
	Gentoo Linux è installato. Rimane solo da
	uscire dalla shell, smontare le partizioni e
	riavviare il sistema:
</p>

<pre caption="Riavviare il sistema">
# <c>etc-update</c>
# <c>exit</c> 
<codenote>questo per uscire dalla shell; potreste anche digitare <c>^D</c></codenote>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo/dev</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
<note>
	Dopo il riavvio, è una buona idea eseguire il
	comando <c>update-modules</c> per creare il file
	<path>/etc/modules.conf</path>. Invece di modificare
	questo file direttamente, dovreste generalmente
	applicare le modifiche al file
	<path>/etc/modules.d</path>.
</note>
<impo>
	Ricordate che se state usando RAID hardware, dovete usare il bootdisk
	per il primo reboot e fare i passaggi per installare il grub
	nell'MBR. Se l'avete fatto, congratulazioni.
</impo>
<p>
	Se avete qualche domanda o vi piacerebbe essere
	coinvolti con gli sviluppatori di Gentoo Linux,
	considerate di unirvi alle nostre mailing lists
	gentoo-user e gentoo-dev (c'è un link &quot;click to
	subscribe&quot; nel  <uri
	link="http://www.gentoo.org">sito ufficiale</uri>).
	Abbiamo anche una comoda guida 
	<uri link="http://www.gentoo.org/doc/it/desktop.xml">Desktop configuration
	guide</uri> che ti aiuterà a continuare a
	configurare il vostro nuovo sistema Gentoo Linux per la
	parte grafica e
	un' utile guida <uri link="http://www.gentoo.org/doc/it/portage-user.xml">Portage user guide</uri>
	che vi aiuterà a familiarizzare con il sistema
	Portage. Potrete trovare il resto della documentazione Gentoo <uri link="http://www.gentoo.org/main/en/docs.xml">qui</uri>. Se avete altre domande che coinvolgono l'installazione
    e altre materie, date una lettura alle Gentoo Linux <uri link="http://www.gentoo.org/doc/it/faq.xml">FAQ</uri>.
	Benvenuti in Gentoo Linux!
</p>

	
</body>
</section>
</chapter>
<chapter>
<title>Gentoo-Stats</title>
<section>
<body>
    <p>
        Il programma per le statistiche d'uso di Gentoo Linux è partito come tentativo
        di dare agli sviluppatori un modo per capire chi sono gli utilizzatori di base.
        Il programma colleziona informazioni circa l'uso di Gentoo Linux e ci aiuta a 
        dare una priorità alle fasi di sviluppo. L'installazione è
        completamente opzionale ma vi saremmo grati se decideste di farla.
        Le statistiche possono essere viste su <uri>http://stats.gentoo.org/</uri>
    </p>
    <p>
        Il server gentoo-stats  assegnerà un ID univoco al vostro sistema.
        Questo ID sarà usato per assicurare che ogni sistema sia contato una sola
        volta. Questo ID non sarà usato per identificare individualmente il vostro sistema
        e nemmeno per identificare il vostro IP o altre informazioni personali.
        E' stata presa ogni precauzione per assicurare la vostra privacy nel sistema
        di sviluppo. Ecco le cose che vengono monitorare dal programma &quot;gentoo-stats&quot;:
    </p>
    <ul>
    <li>pacchetti installati e la loro versione</li>
    <li>informazioni sulla CPU: velocità (MHz), marca, modello, CPU flags (come &quot;mmx&quot; o &quot;3dnow&quot;)</li>
    <li>informazioni sulla memoria (RAM fisica disponibile in totale, swap space disponibile in totale)</li>
    <li>schede PCI e chipset delle schede di rete</li>
    <li>il profile Gentoo Linux che sta usando la vostra macchina (cioè dove sta puntando il  link /etc/make.profile).</li>
    </ul>
    <p>
        Siamo consapevoli che la conoscenza di informazioni sensibili è un pericolo
        per molti utenti Gentoo Linux (così come lo è per gli sviluppatori).
    </p>
    <ul>
    <li>
        A meno che non lo modifichiate, il programma gentoo-stats non trasmetterà
        informazioni sensibili come password, dati di configurazione, taglia delle scarpe..</li>
    <li>La trasmissione del vostro indirizzo di email è opzionale ed è
    disabilitato di default.</li>
    <li>L'indirizzo IP che origina la trasmissione dei vostri dati non verrà mai 
    registrato per potervi identificare. Non c'è l'accoppiata &quot;indirizzo IP/ID del sistema&quot;.</li>
    </ul>
    <p>L'installazione è semplice, dovete solo eseguire i seguenti comandi:
    </p>
    <pre caption="Installare gentoo-stats">
# <c>emerge gentoo-stats</c>    <codenote>Installa gentoo-stats</codenote>
# <c>gentoo-stats --new</c>     <codenote>ottiene il nuovo ID del sistema</codenote>
</pre>
<p>
    Il secondo comando richiederà  un nuovo ID per il tuo sistema ed entrerà
    automaticamente dentro <path>/etc/gentoo-stats/gentoo-stats.conf</path>.
    Potete dare un'occhiata a questo file per vedere opzioni di configurazione aggiuntive.
</p>
<p>
    Il programma dovrebbe quindi essere eseguito a cadenza regolare
    (gentoo-stats non dovrebbe essere eseguito come root).
    Aggiungete questa riga al vostro <path>crontab</path>:
</p>
<pre caption="Aggiungere gentoo-stats al cron">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
</pre>
<p>
    Il programma <c>gentoo-stats</c> è un semplice script perl che può
    essere visto usando un semplice editor.
</p>
</body>
</section>
</chapter>

</guide>
