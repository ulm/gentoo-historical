<?xml version = '1.0' encoding = 'UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/it/gentoo-install.xml" >
<title>Gentoo Linux 1.4_rc3 Guida all'installazione</title>
<author title="Supervisione" >
<mail link="drobbins@gentoo.org" >Daniel Robbins</mail>
</author>
<author title="Autore" >Chris Houser</author>
<author title="Autore" >
<mail link="jerry@gentoo.org" >Jerry Alexandratos</mail>
</author>
<author title="Revisione" >
<mail link="g2boojum@gentoo.org" >Grant Goodyear</mail>
</author>
<author title="Revisione" >
<mail link="zhen@gentoo.org" >John P. Davis</mail>
</author>
<author title="Revisione" >
<mail link="Pierre-Henri.Jondot@wanadoo.fr" >Pierre-Henri Jondot</mail>
</author>
<author title="Revisione" >
<mail link="stocke2@gentoo.org" >Eric Stockbridge</mail>
</author>
<author title="Revisione" >
<mail link="rajiv@gentoo.org" >Rajiv Manglani</mail>
</author>
<author title="Revisione" >
<mail link="seo@gentoo.org" >Jungmin Seo</mail>
</author>
<author title="Revisione" >
<mail link="zhware@gentoo.org" >Stoyan Zhekov</mail>
</author>
<author title="Traduttore" >Enrico Morelli</author>
<author title="Traduttore" >
Team Italiano
</author>

<abstract>Queste instruzioni ti guideranno attraverso il processo di
installazione di Gentoo Linux 1.4_rc3. L'installazione di Gentoo Linux supporta
vari tipi di approcci a seconda di quanto vuoi che il tuo sistema sia costruito da
zero.</abstract>
<version>2.3.20</version>
<date>06 Marzo 2003</date>
<chapter>
<title>Introduzione</title>
<section>
<body>
<p> 
	Questo nuovo CD di boot dovrebbe partire da tutti i moderni lettori
	CD-ROM IDE e SCSI. Il Linux incluso nel CD-ROM supporta periferiche IDE 
	(incluse nel kernel) e SCSI (disponibili come modulo).
	Inoltre, sono provveduti i moduli per tutti i tipi di schede di rete 
	supportati da Linux, così come tutti i tools per la configurazione e l'accesso
	via ssh alla rete e il download dei files.
</p>
<p>
	I requisiti minimi del sistema sono: processore 486+ con idealmente
	almeno 64MB di RAM  (Gentoo Linux è stato installato con successo con
	64MB di RAM e 64MB di swap, ma in queste condizioni il processo di
	installazione è molto lento). 
</p>
<p>
	Gentoo Linux può essere installato usando uno dei tre &quot;stage&quot;
    tarball files  La scelta dipende da quanta parte del sistema vuoi compilare. Lo stage1
	è per costruire l'intero sistema da zero. Lo stage2 è per
	costruire alcune parti del sistema da zero mentre lo stage3 ti 
	permette di risparmiare molto tempo dato che è già
	ottimizzato per il tuo specifico sistema. 
</p>
<p>
<b>Dovrei scegliere di partire dallo stage1, dallo stage2 o dallo stage3?</b>
    Se scegli di partire dallo stage1 avrai il controllo totale sulle ottimizzazioni
    e sulla funzionalità opzionale usata durante la fase di compilazione che è
    inizialmente abilitata sul tuo sistema. Questo rende lo stage1 ideale per gli utenti
    smaliziati che sanno quello che stanno facendo. Con lo stage2 salti il processo di bootstrap,
    e devi accontentarti delle opzioni di ottimizzazione che abbiamo scelto per il tuo
    particolare stage2 tarball. Con lo stage3 hai una installazione molto veloce di Gentoo Linux,
    ma anche in questo caso devi accontentarti delle ottimizzazioni che abbiamo scelto per te.
    Questo potrebbe essere sufficiente, dato che le versioni rilasciate di Gentoo Linux hanno
    lo stage3 specificamente ottimizzato per i più popolari tipi di processori.
    <b>Se stai installando Gentoo Linux per la prima volta, il consiglio è di usare
    il tarball dello stage3.</b>
</p>
<p>
    Bene, come facciamo ad iniziare il processo di installazione? Prima dovrai decidere
    quale immagine LiveCD ISO vuoi scaricare da <uri>http://www.ibiblio.org/gentoo/releases/1.4_rc3/x86/</uri>.
</p>
<p>
    I LiveCD sono immagini complete per CD che dovrebbero essere masterizzate su un CDR o CD-RW
    usando un software per la masterizzazione. Al momento abbiamo due tipi di LiveCD. Il primo
    con la dicitura &quot;gentoo-basic&quot; è di approssimativamente 40MB e lo trovi
    nella directory <path>x86/livecd/</path>. Questo CD di 
    piccole dimensioni permette un donwload iniziale e contiene un tarfile stage 1 in <path>/mnt/cdrom/gentoo</path>.
</p>
<p>
    Il secondo gruppo di LiveCD che offriamo è etichettato   &quot;gentoo-3stages&quot;.  
    Anche questo CD lo trovi nella directory <path>x86/livecd</path> e contiene i tarball stage 1
    ,2 e 3.  Usando questo CD, sarà possibile installare velocemente un
    sistema Gentoo Linux completamente funzionante.
    <b>Che fine hanno fatto i LiveCD per i686, pentium3, athlon, athlon-mp e i pacchetti
    GRP (Gentoo Reference Platform)?</b>
    Gentoo 1.4_rc3 è solo una release candidate minima.  La 1.4_rc4 tornerà ad essere 
    suddivisa in architetture x86 e  conterrà i pacchetti GRP. Se vuoi installare gli stage
    ottimizzati per queste architetture o i pacchetti GRP, usa la documentazione per la 1.4_rc2
    che puoi trovare su <uri>http://www.gentoo.org/doc/it/gentoo-x86-1.4_rc2-install.xml</uri>.
</p>
<impo>
    Se incontri qualche problema in qualsiasi parte dell'installazione, puoi riportarlo
    su <uri>http://bugs.gentoo.org</uri>. Se il bug coinvolge gli sviluppatori del 
    software originale (come ad esempio il team KDE), sarà cura del <e>Gentoo Linux developers</e>
    occuparsi di farlo avere a chi di dovere.
</impo>
<p>
	Ora diamo una rapida occhiata al processo di installazione. 
    Prima dovremo scaricare e masterizzare l'immagine, e quindi riavviare
    il nostro PC facendogli fare il boot dal LiveCD appena creato.
	Non appena raggiunto il prompt di root, creeremo le partizioni, 
	i nostri filesystems ed estrarremo uno degli stageNN tar file. Se stiamo usando lo stage1 o lo stage2 tar file,
	vedremo quali passi compiere per portare il
	nostro sistema allo stage3. Una volta che il sistema
	sarà arrivato allo stage3,
	potremo configurarlo (ottimizzando i files di configurazione, 
	installando il bootloader, etc.), e farlo ripartire avendo un sistema Gentoo
	Linux completamente funzionale.
	A seconda dello stage dal quale stiamo partendo, i seguenti sono i requisiti
	per l'installazione (N.d.T. emerge è il comando per la
	gestione del software in Gentoo Linux, per cui alcuni dei seguenti termini
	non sono traducibili):
</p>
<table>
<tr>
<th>stage tarball</th>
<th>requisiti per l'installazione</th>
</tr>
<tr>
<ti>1</ti>
<ti>setup di partizioni e filesystems, emerge rsync, bootstrap, emerge system, emerge kernel, configurazione finale</ti>
</tr>
<tr>
<ti>2</ti>
<ti>setup di partizioni filesystems, emerge rsync, emerge system, emerge kernel, configurazione finale</ti>
</tr>
<tr>
<ti>3</ti>
<ti>setup di partizioni e filesystems, emerge rsync (opzionale), configurazione finale</ti>
</tr>
</table>
</body>
</section>
</chapter>
<chapter>
<title>Booting</title>
<section>
<body>
<p> 
	Riavvia il PC facendo il boot dal LiveCD.
	Dovrai vedere un testo di benvenuto con il logo di Gentoo Linux.
    In questa schermata puoi semplicemente premere Enter per iniziare il
    processo di boot, premere F2 per visualizzare un aiuto o passare delle opzioni
    al kernel, digitando <c>gentoo opt1 opt2</c>, ecc.
	Una volta premuto ENTER, Linux comincerà
	ad essere caricato da CD.
	Al termine del boot sarai automaticamente loginato come root e a scopo di sicurezza
    la password di root sarà impostata ad un valore random.
	Dovresti ora avere il prompt di root (&quot;<c>#</c>&quot;) nella console corrente
	e poter aprire nuove console premendo Alt-F2, Alt-F3 e Alt-F4.
    Torniamo alla finestra di partenza premendo Alt-F1.
</p>
<p>
    Avrai probabilmente notato che sopra il prompt <c>#</c> c'è un testo di aiuto che
    spiega alcune cose su come configurare la scheda di rete e dove puoi trovare gli stage tarfile
    e i pacchetti nel CD.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Caricamento dei moduli del kernel</title>
<section>
<body>
<p>
	Se non vengono individuate tutte le periferiche automaticamente,
	puoi comunque caricare i moduli appropriati manualmente.
	Per vedere la lista di tutte le schede di rete supportate, digita
	<c>ls /lib/modules/*/kernel/drivers/net/*</c>.
	Per caricare un particolare modulo, digita:
</p>
<pre caption="Configurazione dei moduli PCI" >
# <i>modprobe pcnet32</i>
<comment>(sostituendo a pcnet32 il modulo della nostra scheda di rete)</comment>
</pre>
<p>
	Se vogliamo riuscire ad accedere ad ogni periferica
	SCSI che non è stata individuta durante il processo di auto-identificazione,
	dovremo caricare i moduli appropriati da /lib/modules,
	usando ancora <c>modprobe</c>:
</p>
<pre caption="Caricamento dei moduli SCSI" >
# <i>modprobe aic7xxx</i>
# <i>modprobe sd_mod</i>
</pre>
<p>
	Con questa serie di comandi modprobe abbiamo abilitato il support per il
    controller SCSI (<c>aic7xxx</c>) e per i dischi SCSI (<c>sd_mod</c>).
</p>
<note>
    Il supporto per CD-ROMs e dischi SCSI è incluso nel kernel.
</note>
<p>
	Se stai usando RAID hardware, dovrai caricare i moduli per l'ATA-RAID
	e per il tuo controller RAID
</p>
<pre caption="Caricamento dei moduli RAID" >
# <i>insmod ataraid</i>    
# <i>insmod pdcraid</i>
<comment>(Promise Raid Controller)</comment>    
# <i>insmod hptraid</i>
<comment>(Highpoint Raid Controller)</comment>
</pre>
<p>
    Il LiveCD di Gentoo dovrebbe aver abilitato il DMA per i tuoi dischi.
    Se così non fosse, puoi usare <c>hdparm</c> per settare il DMA
    sui tuoi dischi.
</p>
<pre caption="Settare il DMA" >
<comment>Sostituisci a hdX il device del tuo disco. </comment>
# <c>hdparm -d 1 /dev/hdX </c>
<comment>Abilita il DMA </comment>
# <c>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</c>
<comment>Abilita il DNA e altre opzioni per aumentare le performance</comment>
# <c>hdparm -X66 /dev/hdX </c>
<comment>Forza/abilita l' Ultra-DMA -- pericoloso -- può causare confusione in alcuni drives </comment>
</pre>
</body>
</section>
</chapter>
<!--  QUESTA SEZIONE DOVREBBE ESSERE OBSOLETA CON L'HOTPLUG ABILITATA IN 1.4_rc3 (drobbins)
<title>Caricamento dei moduli PCMCIA</title>
<section>
<body>
<p>Se hai una scheda di rete PCMCIA, &#232; necessario fare qualche passo aggiuntivo.</p>
<warn>Per evitare problemi con <c>cardmgr</c>, <e>devi</e> eseguirlo <e>prima</e> di entrare
nella parte chroot dell'installazione</warn>
<pre caption="Caricamento dei moduli PCMCIA">
# <i>insmod pcmcia_core</i>
# <i>insmod i82365</i>
# <i>insmod ds</i>
# <i>cardmgr -f</i>
</pre>
<p>
	Quando cardmgr identifica che hardware &#232; presente, lo speaker 
	del PC dovrebbe emettere una serie di rassicuranti beeps 
	e la tua scheda di rete PCMCIA dovrebbe prendere vita. Puoi naturalmente
	inserire la scheda PCMCIA anche dopo il caricamento di cardmgr,
	se preferisci.
	(Tecnicamente, non &#232; necessario eseguire <i>cardmgr</i> se conosci esattamente
	il modulo che la scheda PCMCIA richiede. 
	Se invece non lo conosci, caricare tutti i moduli PCMCIA per guardare qual &#232; quello giusto non serve a niente,
	in quanto tutti i moduli PCMCIA verranno caricati e
	rimarranno in attesa di riconoscere la corrispondente
	scheda.
	<i>cardmgr</i> si occuper&#224; anche di rimuovere
	i moduli corrispondenti alle schede che
	eventualmente in futuro rimuoverete.
</p>
</body>
</section>
</chapter>
--><chapter>
<title>Configurazione della rete</title>
<section>
<title>È già tutto a posto?</title>
<body>
<p>
        Se stai usando un liveCD 1.4_rc3 o successivo, è possibile che la rete sia già
        stata configurata automaticamente. Se è così, potresti essere in grado di usare
        molti dei comandi orientati alla rete inclusi nel LiveCD come, tra gli altri, <c>ssh</c>,
        <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> e <c>lynx</c>.
    </p>
<p>
        Se la configurazione della rete è andata a buon fine, il comando <c>/sbin/ifconfig</c>
        dovrebbe mostrarti le interfacce di rete come <c>lo</c> e <c>eth0</c>:
    </p>
<pre caption="/sbin/ifconfig per schede di rete configurate" >
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
<p>
        Puoi anche provare ad eseguire un ping verso il DNS server del tuo provider
        (che trovi in <path>/etc/resolv.conf</path>) e verso un sito Web di tua scelta, giusto
        per vedere che tutti i pacchetti raggiungano la rete e la risoluzione dei nomi DNS
        funzioni correttamente.
    </p>
<pre caption="Test della rete" >
# <c>ping www.gentoo.com </c>
</pre>
<p>
        Riesci ad usare la rete? Allora puoi saltare il resto di questa sezione.
    </p>
</body>
</section>
<section>
<title>Configurazione del PPPoE </title>
<body>
<p>
    Assumendo che tu abbia bisogno di PPPoE per connetterti a internet,
    su qualsiasi versione del livecd abbiamo cercato di renderti le cose 
    più facili includendo <i>rp-pppoe</i>. Usa lo script <i>adsl-setup</i>
    per configurare la tua connessione. Ti verrà richiesto il device a cui
    è connesso il tuo modem adsl, il tuo username e la tua password,
    l'indirizzo del DNS, e se hai bisogno di un firewall minimo oppure no.
</p>
<pre caption="Configurazione di PPPoE" >
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>
<p>
    Se qualcosa andasse storto, assicurati che lo username e la password che hai
    immesso siano esatti dando un'occhiata al file <path>/etc/ppp/pap-secrets</path>
    o <path>/etc/ppp/chap-secrets</path>, e che stai usando il corretto device ethernet.
</p>
</body>
</section>
<section>
<title>Configurazione automatica della rete</title>
<body>
<p>
	Se la configurazione automatica non è andata a buon fine, la via più semplice
    per configurare la rete se è eseguire lo script <c>net-setup</c>:
</p>
<pre caption="Net-Setup Script" >
# <i>net-setup eth0</i>
</pre>
<p>
	Naturalmente se preferisci, puoi ancora configurare il network
	manualmente.
</p>
</body>
</section>
<section>
<title>Configurazione manuale del DHCP</title>
<body>
<p>
        Configurare una rete DHCP è semplice; se il tuo provider non usa DHCP,
        passa al paragrafo &quot;Configurazione statica&quot;.
    </p>
<pre caption="Configurazione di una rete DHCP" >
# <i>dhcpcd eth0</i>
</pre>
<note>
        Alcuni provider richiedono un hostname. Per fare questo aggiungi
        un flag <c>-h nomehost</c> nella riga di comando del dhcpcd.
    </note>
<p>
	    Non ti spaventare se ricevi messaggi di avviso da<i>dhcpConfig</i>;
    	niente panico; gli errori non sono quasi mai
	    degni di nota.
    	Puoi continuare col paragrafo &quot;Test della rete&quot;.
    </p>
</body>
</section>
<section>
<title>Configurazione manuale della rete</title>
<body>
<p>
	È necessario configurare la rete per scaricare i sorgenti e costruire 
	la nostra Gentoo Linux.
	Digita i seguenti comandi sostituendo a $IFACE la tua interfaccia di rete 
	(di solito <c>eth0</c>), a $IPNUM il tuo indirizzo IP,
	a $BCAST il tuo indirizzo di broadcast, e a $NMASK la tua network mask.
	Per il comando <c>route</c>, invece, sostituisci a $GTWAY l'indirizzo 
	IP del tuo gateway.
</p>
<pre caption="Configurazione della rete con IP statico" >
# <i>/sbin/ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</i>
</pre>
<p>
	È il momento  di creare il file <path>/etc/resolv.conf</path> in modo
	tale che sia possibile la risoluzione dei nomi.
	(In questo modo possiamo raggiungere siti Web/FTP direttamente
	col nome piuttosto che attraverso l'indirizzo IP).
</p>
<p>Segue un esempio da seguire per la creazione del tuo /etc/resolv.conf:</p>
<pre caption="esempio di /etc/resolv.conf" >
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
<p>
	Sostituisci a <c>10.0.0.1</c> e a <c>10.0.0.2</c> 
	l'indirizzo IP del tuo server DNS primario e secondario.
</p>
</body>
</section>
<section>
<title>Configurazione della rete con un Proxy</title>
<body>
<p>
	Se sei all'interno di un proxy, è necessario configurare 
	il tuo proxy prima di continuare. Dovremo esportare alcune variabili
	per configurare il proxy.
</p>
<pre caption="Configurazione di un proxy" >
# <i>export http_proxy=&quot;machine.company.com:1234&quot; </i>
# <i>export ftp_proxy=&quot;$http_proxy&quot; </i>
# <i>export RSYNC_PROXY=&quot;$http_proxy&quot; </i>
</pre>
</body>
</section>
<section>
<title>La rete funziona!</title>
<body>
<p>
	La rete dovrebbe essere ora configurata e funzionante.
	Dovresti essere in grado di usare i comandi
	<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> e <c>wget</c> per connetterti ad altre macchine
	nella tua LAN o ad Internet.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Aggiorniamo la data e l'ora del nostro sistema</title>
<section>
<body>
<p>
            È necessario aggiornamre la data e l'ora del nostro sistema.
            Possiamo farlo usando il comando <c>date</c>
</p>
<pre caption="Aggiornamento della data del sistema" >
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(If your date is wrong, set your date with this next command)</comment>
# <c>date 022709042003</c>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Partizioniamo il disco</title>
<section>
<body>
<p> 
	Ora che il kernel può vedere la nostra scheda di rete e il 
	controller dei dischi, è il momento di creare
	le partizioni del disco per la nostra Gentoo Linux.
</p>
<p>
	Facciamo ora una breve panoramica sulle partizioni standard Gentoo Linux.
	Creeremo almeno tre partizioni: una partizione di swap, una root partition
	(per contenere il grosso di Gentoo Linux), e una partizione di boot. 
	Quest'ultima è disegnata per contenere le informazioni del GRUB boot loader
	e il(i) kernel(s) di Linux.  La partizione di boot ci permette di avere un posto
	sicuro dove mettere tutto ciò che è collegato al booting di Linux. 
	Durante il normale lavoro quotidiano col nostro Gentoo Linux, la partizione di
	boot dovrebbe rimanere <e>unmounted</e>. Questo previene che il kernel divenga
	inutilizzabile ( a causa di una corruzione del
	filesystem) nell'eventualità di un crash del sistema, prevenendo il problema del
	cane che si morde la coda, dove il GRUB non può leggere il kernel 
	(data l'inconsistenza del filesystem) e dall'altra parte non
	si può riportare il filesystem ad uno stato consistente
	(dato che non possiamo fare il boot!).
</p>
<p>
	Veniamo ora ai tipi di filesystem. Per ora abbiamo quattro filesystems disponibili:
	XFS, ext2, ext3 (journaling), jfs e ReiserFS. ext2 è il vero e proprio
	filesystem di Linux ma non supporta la tecnologia journaling. 
	ext3 è la nuova versione di ext2 con sia la tecnologia meta-data journaling
	che l'ordered data write.
	ReiserFS è un filesystem basato su  B*-tree che promette una buona performance
	su file di piccole dimensioni e velocità superiori
	a ext2 e ext3 con file di dimensioni minori di 4k,
	spesso di un fattore 10x-15x. 
    ReiserFS scala inoltre molto bene e supporta il metadata journaling.
    Dal kernel 2.4.18+, ReiserFS ha raggiunto la solidità che lo porta ad
    essere raccomandato caldamente.
	XFS è un filesystem ad alte prestazioni con
	tecnologia meta-data journaling che è
	completamente supportato in Gentoo Linux col kernel <path>xfs-sources</path>,
    ma non è generalmente raccomandato a causa della sua tendenza a perdere
    i dati che sono stati modificati recentemente se il sistema si chiude o si
    riavvia inaspettatamente (per esempio a causa di un calo di tensione elettrica).
    Veniamo alla fine al jfs, il filesystem journaling ad alte prestazioni di IBM.
    Data la sua oscurità, non possiamo fare commenti positivi o negativi sulla
    sua stabilità
</p>
<p>
	Se sei interessato al filesystem più standard, usa ext2.
	Se ti interessa un filesystem più sicuro, usa ext3. Se
	sei invece interessato ad un filesystem ad alte prestazioni con il
	supporto journaling, usa ReiserFS; sia ext3 che
	ReiserFS sono maturi e perfezionati.
    Queste sono le partizioni raccomandate e la loro dimensione:
</p>
<table>
<tr>
<th>Partizione</th>
<th>Dimensione</th>
<th>Tipo</th>
<th>esempio di device</th>
</tr>
<tr>
<ti>partizione di boot, contiene il kernel(s) e informazioni per il boot</ti>
<ti>100 Megabytes</ti>
<ti>ext2/3 raccommandate; se scegli ReiserFS monta il filesystem con l'opzione <c>-o notail</c>
</ti>
<ti>/dev/hda1</ti>
</tr>
<tr>
<ti>partizione di swap (non ha il limite di 128 Megabyte)</ti>
<ti>Generalmente, a meno che non si tratti di un server, la dimensione dello swap space
    può essere molto flessibile. Consulata la tabella che segue per una linea guida
    sullo swap space.</ti>
<ti>Linux swap</ti>
<ti>/dev/hda2</ti>
</tr>
<tr>
<ti>partizione root, contiene i principali filesystems (/usr, /home, etc)</ti>
<ti>>=1.5 Gigabytes</ti>
<ti>ReiserFS, ext3 raccomandate; ext2 ok</ti>
<ti>/dev/hda3</ti>
</tr>
</table>
<table>
<tr>
<th>RAM fisica</th>
<th>Dimensione Swapspace</th>
</tr>
<tr>
<ti>0-48MB RAM</ti>
<ti>048-064MB RAM</ti>
<ti>064MB-128MB RAM</ti>
<ti>128-256MB RAM</ti>
<ti>256-512MB RAM</ti>
</tr>
<tr>
<ti>720MB</ti>
<ti>702MB</ti>
<ti>640MB</ti>
<ti>256MB</ti>
</tr>
</table>
<p>
    Prima di creare le tue partizioni, è veramente una buona idea inizializzare
    il tuo HD usando <c>dd</c>. Facendo questo siamo sicuri che i nuovi filesystem
    non saranno mal identificati dal programma di mount di Linux.
    Per questo dovrai eseguire:
</p>
<pre caption="Inizializzare i primi 1024 settori dell'HardDisk" >
# <c>dd if=/dev/zero of=/dev/hdxy bs=1K count=1 </c>
<comment>Sostituisci a /dev/hdxy il device che vuoi &quot;pulire&quot;</comment>
</pre>
<warn>
    Il summenzionato comando distruggerà tutti i dati di <path>/dev/hdxy</path>.
    Fai attenzione e controlla due volte che partizione hai specificato per
    la pulitura. Se sbagli, il risultato potrebbe essere la perdita di tutti i tuoi dati.
</warn>
<p>A questo punto, creiamo le partizioni usando fdisk. Nota che le partizioni
dovrebbero essere di tipo 82
per lo swap e 83 per i filesystems regolari (sia ReiserFS <e>o</e> ext2/3).
</p>
<note>
<i>cfdisk</i> è incluso nel CD di installazione ed è *considerabilmente*
facile da usare rispetto a <i>fdisk</i>. Digita <c>cfdisk</c> per eseguirlo. Per default
cfdisk usa <b>/dev/hda</b> come disco. Se /dev/hda non è il disco che vuoi partizionare,
dai a cfdisk come parametro il giusto device. Per esempio: <c>cfdisk /dev/hde</c>
</note>
<note>Se ricevi istruzioni da <c>fdisk</c> o <c>cfdisk</c> di riavviare il sistema, fallo in modo da
far scoprire al sistema le nuove partizioni.
</note>
<note>Se stai usando il RAID le tue partizioni saranno leggermente diverse.
Avrai partizioni come queste:
<path>/dev/ataraid/discX/partY</path>
X è l'array che hai creato, così se hai creato solo 1 array sarà
disc0. Y è il numero di partizione come in <path>/dev/hdaY</path>
</note>
<p>
	Una volta create le partizione, dobbiamo inizializzare
	i filesystems che saranno usati
	per immagazzinare i nostri dati. Inizializza la partizione di swap come segue:
</p>
<pre caption="Inizializzazione dello SWAP" >
# <i>mkswap /dev/hda2</i>
</pre>
<p>
	Possiamo usare il comando <c>mke2fs</c> per creare filesystems di tipo ext2:
</p>
<pre caption="Creazione di un filesystem ext2" >
# <i>mke2fs /dev/hda1</i>
</pre>
<p>
	Per create filesystem XFS usiamo il comando <c>mkfs.xfs</c>:
</p>
<pre caption="Creazione di un filesystem xfs" >
# <i>mkfs.xfs /dev/hda3</i>
</pre>
<note>
	Puoi voler aggiungere un paio di flags in più al comando <c>mkfs.xfs</c>:
	<c>-d agcount=3 -l size=32m</c>.
	Il flag <c>-d agcount=3</c> abbassa il numero dei gruppi di allocazione.
	XFS insiste usando almeno 1 gruppo di
	allocazione per ogni 4 GB di partizione, così, per esempio, se hai una partizione di 20GB
	avrai bisogno di 5 gruppi (agcount) come minimo. 
	Il flag <c>-l size=32m</c> porta a 32 MB la size del journal, 
	incrementando le performance.
</note>
<warn>
	Se stai installando una partizione XFS su una preesistente ReiserFS,
	il successivo tentativo di montarla
	con <c>mount -t xfs</c> può fallire. La
	soluzione è azzerare la 
	partizione prima di create il filesystem XFS:
	<c>dd if=/dev/zero of=/dev/hd<comment>x</comment> bs=1k</c>.
</warn>
<p>Se preferisci usare ext3, puoi creare la partizione usando <c>mke2fs -j</c>:</p>
<pre caption="Creazione di un filesystem ext3" >
# <i>mke2fs -j /dev/hda3</i>
</pre>
<note>
    Puoi trovare maggiori informazione su come usare ext3 su Linux 2.4
    all'indirizzo <uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.

</note>
<p>
	Per creare un filesystem ReiserFS, usa il comando <c>mkreiserfs</c>:
</p>
<pre caption="Creazione di un filesystem ReiserFS" >
# <i>mkreiserfs /dev/hda3</i>
</pre>
<p>
    Per creare un filesystem JFS, usa il comando <c>mkfs.jfs</c>.
</p>
<pre caption="Creazione di un filesystem JFS" >
# <c>mkfs.jfs /dev/hda3</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Fare il mount delle partizioni</title>
<section>
<body>
<p>
	È il momento di attivare la nostra partizione
	di swap, che ci servirà
	in seguito come memoria virtuale aggiuntiva:
</p>
<pre caption="Attiviamo lo SWAP" >
# <i>swapon /dev/hda2</i>
</pre>
<p>
	Poi, creeremo i mountpoints (letteralmente: punti di montaggio)
	<path>/mnt/gentoo</path> e <path>/mnt/gentoo/boot</path>, e quindi
	vi monteremo i nostri filesystems.
</p>
<pre caption="Creazione dei mount points" >
# <i>mkdir /mnt/gentoo</i>
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>
<p>
	Se hai deciso di creare <path>/usr</path> o <path>/var</path>
	come partizioni separate, dovrebbero essere
	rispettivamente montate in <path>/mnt/gentoo/usr</path> e <path>/mnt/gentoo/var</path>.
	(N.d.T. la partizione /var dovrà essere molto
	campiente in quanto conterrà la directory
	temporanea del sistema Portage per la compilazione
	dei pacchetti.)
</p>
<impo>
	Se la partizione di <e>boot</e> (dove risiede il
	kernel) è ReiserFS,
	devi essere sicuro di montarla con
	l'opzione <c>-o notail</c> in modo tale che GRUB possa essere installato correttamente.
	Devi anche assicurarti 	che <c>notail</c> termini la riga che si riferisce
	alla partizione di boot in <path>/etc/fstab</path>.
	Ritorneremo brevemente su questo punto.
</impo>
<impo>
    Se stai avendo problemi a montare la tua partizione di boot con ext2,
    riprova usando <c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>
</impo>
</body>
</section>
</chapter>
<chapter>
<title>Ottenere il stage-x tarfile desiderato</title>
<section>
<body>
<p>
    Se stai usando il LiveCD 3stages hai giò tutti gli stage tarballs
    disponibili sul CD. In questo caso, copia il tarball che hai scelto in <mnt>/mnt/gentoo</mnt>
</p>
<p>
    Alternativamente, se hai il basic LiveCD, il tarball stage1 è
    ancora disponibile sul CD in <path>/mnt/cdrom/gentoo</path>. Dovrai in seguito
    fare comunque un download degli altri stage e metterli in <path>/mnt/gentoo</path>.
</p>
<pre caption="Download degli stages richiesti" >
# <c>cd /mnt/gentoo</c>
<comment>Usa lynx per scaricare il tarball:</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc3/x86/</c>
<comment>
    Usa i tasti cursore <c>Up</c> e <c>Down</c> (o il tasto <c>TAB</c>) per andare nella
    directory corretta ed evidenziare lo stage che vuoi scaricare. Premi <c>d</c> per iniziare
    il download, salva il file e esci dal browser.
    <b>O</b> usa wget da linea di comando:
</comment>
# <c>wget <comment>inserisci qui l'URL del tarball con lo stage che vuoi</comment>
</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Scomprimere l'immagine che desideri usare</title>
<section>
<body>
<p>
	È ora il momento di estrarre il tar file dello stage che hai scelto
	in <path>/mnt/gentoo</path>.
    Devi estrarre solo lo stage da cui vuoi partire, se hai scelto di partire dallo stage3
    dovrai estrarre solo il tarball stage3.
	Quindi faremo il <c>chroot</c> della nuova installazione di
	Gentoo Linux.
</p>
<impo>
	Ricordati di usare l'opzione <c>p</c> col comando tar.
	Altrimenti alcuni files potrebbero
	ricevere permessi errati
.</impo>
<p>
	Se stai usando il metodo di installazione &quot;from scratch, build everything&quot;
	(&quot;costruisci tutto da zero&quot;), dovrai usare l'immagine <path>stage1-ix86-1.4_rc3.tbz2</path>.
    Se invece stai usando uno dei CD di grosse dimensioni, avrai anche la possibilità
    di scegliere tra le immagini stage2 e stage3.
    Queste immagini ti permettono di risparmiare tempo a spesa della configurabilità dato
    che abbiamo scelto noi le ottimizzazione per il compilatore e le variabili USE di
    default.
</p>
<pre caption="Scomprimere lo stage" >
# <i>cd /mnt/gentoo</i>
# <i>tar -xvjpf /mnr/cdrom/gentoo/stage?-*.tbz2</i>
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
</pre>
<pre caption="Entriamo nell'ambiente chroot" >
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
# 
<comment>I passi summenzionati aggiornano i percorsi di ricerca della shell.</comment>
</pre>
<p>
	Dopo aver eseguito questi comandi, sei &quot;dentro&quot; l'ambiente Gentoo Linux. 
</p>
</body>
</section>
</chapter>
<chapter>
<title>Scarichiamo il Portage Tree corrente usando rsync</title>
<section>
<body>
<p>	Dovrai ora eseguire <c>emerge sync</c>.   
    Questo ti assicura di avere il copia più recente del Portage tree.
</p>
<pre captio="Aggiornamento usando rsync" >
# <c>emerge rsync</c>
# <c>export CONFIG_PROTECT=&quot;-*&quot;</c>
# <c>export USE=&quot;-* bootstrap build&quot;</c>
# <c>emerge portage</c>
# <c>unset USE</c>
</pre>
<p>
    Verrà scaricato il Portage Tree e memorizzato in <path>/usr/portage</path>; la sua dimensione è di circa 90Mb senza tarballs.
</p>
<note>
    La linea <c>export CONFIG_PROTECT=&quot;-*&quot;</c> assicura che ogni nuovo script
    installato in <path>/etc</path> possa sovrascrivere gli script precedenti (
    memorizzati in <path>sys-apps/baselayout</path>), bypassando il supporto per
    la gestione dei file di configurazione del Portage. Digita <c>emerge --help config</c>
    per maggiori dettagli.
</note>
</body>
</section>
</chapter>
<chapter>
<title>Stabilire le ottimizzazioni (make.conf)</title>
<section>
<body>
<p>	Ora che stiamo lavorando su una copia del Portage tree, coloro che usano
	lo stage1 devono effettuare il bootstrap del Gentoo Linux procedendo
	secondo le istruzioni che seguono. Primo: editare il file 
	<path>/etc/make.conf</path>. In questo file dovremo definire ad ok 
	i vari flags <c>USE</c> che servono a specificare quali funzionalitè
	supplementari si vogliono includere nella costruzione dei pacchetti.
	In genere i settaggi di default sono accettabili (ovvero un USE  <e>vuoto</e> 
	o non configurato). 
    Maggiori informazioni sui flags di USE possono essere trovate <uri link="http://www.gentoo.org/doc/it/use-howto-it.xml" >qui</uri>.
    Una lista completa dei flags USE la puoi trovare <uri link="http://www.gentoo.org/dyn/use-index.xml" >qui</uri>.

    Si dovrebbero definire in modo appropriato anche i flags 
	<c>CHOST</c>, <c>CFLAGS</c> e <c>CXXFLAGS</c> a seconda dal tipo
	di sistema che si vuol creare (potete trovare esempi documentati direttamente
	in questo file).  Questi setting saranno usati per dire ai compilatori C e C++
    come ottimizzare il codice che deve essere generato per il tuo sistema. È
    comune, per esempio, per utenti con processori Athlon XP specificare un flag &quot;-marc=athlon-xp&quot;
    sia in CFLAGS che in CXXFLAGS in tal modo tutti i pacchetti saranno compilati
    e ottimizzati per il set di istruzioni e performance caratteristiche del processore
    in uso. Il file <path>/etc/make.conf</path> contiene una guida generale per i settaggi
    propri di CFLAGS e CXXFLAGS.
</p>
<p>
    Se necessario, potremmo anche settare le informazioni sul proxy nel caso vi trovaste dietro
	un firewall.
</p>
<pre caption="Editiamo il make.conf" >
# <i>nano -w /etc/make.conf</i>
<comment>(Aggiustiamo questi settaggi)</comment>
</pre>
<note>
	Coloro che hanno bisogno di una 'regolazione fine' 
	del processo di costruzione potrebbero dare uno sguardo
	al file <path>/etc/make.globals</path>.
	Questo file comprende i parametri di defaults di Gentoo e non
	dovrebbe mai essere modificato. Se i parametri di defaults non 
	sono sufficienti, i nuovi valori dovrebbero
	essere messi in <path>/etc/make.conf</path>, i valori dei parametri 
	di <path>/etc/make.conf</path>
<comment>sovrascrivono</comment> gli stessi
	in <path>/etc/make.globals</path>. Se sei interessato ad un
	aggiustamento fine dei settings di USE,
	guarda in <path>/etc/make.profile/make.defaults</path>.
	Se vuoi disabilitare alcuni settings di USE, 
	aggiungi in <path>/etc/make.conf</path>
<c>USE=&quot;-flag&quot;</c> per disabilitare flag.
	(N.d.T.:  p.e. USE=&quot;gnome&quot; includera' gnome nella compilazione di
	programmi che potrebbero avere qualche feature in
	più
	includendo gnome, ma che sostanzialmente non ne hanno bisogno
	per il corretto funzionamento, mentre USE=&quot;-gnome&quot;
	non includerà gnome.)
</note>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage1</title>
<section>
<body>
<p>
    Il tarball stage1 è per costruire una completa personalizzazione e ottimizzazione.
    Se hai scelto questo tarball stai probabilmente cercando di avere un sistema
    ultra ottimizzato.  Buon divertimento, perché l'ottimizzazione è 
    la cosa più importante di Gentoo  Linux. L'installazione partendo dallo stage1
    prende diverso tempo, ma il risultato è che il sistema è stato ottimizzato
    per essere un fondamento specifico per la tua macchina su cui costruire secondo le
    tue necessità
</p>
<p>
	È giunto il momento di far partire il processo di 'bootstrap'.
	Il processo durerà almento 2 ore su un AMD 1200MHz.
	Durante questo tempo, l'immagine estratta
	verrà preparata per l'installazione
	del resto del sistema.
	Il compilatore GNU GCC verrà compilato così
	come le librerie GNU C. La compilazione di questi compinenti
	richiede parecchio tempo e costituisce la maggior parte
	del processo di bootstrap.
</p>
<pre caption="Bootstrapping" >
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>
<p>È iniziato il processo di &quot;bootstrap&quot;.</p>
<note>
	Portage usa per default <c>/var/tmp</c> durante la
	fase di complilazione dei pacchetti, usando spesso
	centinaia di megabyte come area di memorizzazione
	temporanea. È possibile cambiare la
	directory dove Portage stora temporaneamente i suoi
	files, aggiustando la variabile PORTAGE_TMPDIR
	<e>prima</e> di far partire il processo di bootstrap
	come segue:
</note>
<pre caption="Cambiare la directory temporanea del PORTAGE" >
# <i>export PORTAGE_TMPDIR=&quot;/altradir/tmp&quot;</i>
</pre>
<p>
	Il comando <c>bootstrap.sh</c> compilerà i
	pacchetti <c>binutils</c>, <c>gcc</c>,
	<c>gettext</c> e <c>glibc</c>, ricompilando
	<c>binutils</c>, <c>gcc</c> e <c>gettext</c> dopo la
	costruzione delle <c>glibc</c>. Inutile dirlo,
	questo processo durerà un pò di tempo.
	Una volta che il processo è completato, il tuo
	sistema è in &quot;stage2&quot; il che significa che puoi
    andare alle istruzione relative allo stage2.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage2</title>
<section>
<body>
<p>
    Il tarfile stage2 ha già il bootstrapping fatto per te. Tutto quello che devi fare
    è installare il resto del sistema.
</p>
<note>
    Se non l'hai ancora fatto, edita <path>/etc/make.conf</path> a tuo piacimento.
</note>
<pre caption="Installazione del resto del sistema" >
# <c>emerge -p system</c>
<comment>[lista dei pacchetti che devono essere installati]</comment>
# <c>emerge system</c>
</pre>
<p>
    Questo step prenderà un pò di tempo per costruire l'intero sistema di base.
    Il lato positivo è che avrai un sistema veramente ottimizzato. D'altra parte
    dovrai trovare qualcosa da fare. Ti suggerisco una buona lettura o un buon videogioco.
</p>
<p>
    Quando <c>emerge system</c> è terminato, sarai giunto in uno stadio
    equivalente allo stage3. A questo punto
    puoi seguire le istruzioni per lo
    stage3 e completarlo. In questo modo avrai il tuo sistema  pronto e
    aggiornato col Portage corrente. Non è necessario, ma è raccomandato.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Partendo dallo Stage3</title>
<section>
<body>
<p>
    Il tarfile stage3 è configurato per il tuo sistema. Non c'è molto da fare
    per questo stage, ma è una buona idea aggiornare il tuo sistema con gli
    ultimi pacchetti disponibili.
</p>
<note>
    Se non lo hai giè fatto, edita <path>/etc/make.conf</path> e adattalo alle tue esigenze.
</note>
<pre caption="Avere tutto aggiornato" >
# <c>emerge sync</c>
# <c>emerge -up world</c>
<comment>lista i [<i>pacchetti</i>] che devono essere installati</comment>
# <c>emerge -u world</c>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Timezone</title>
<section>
<body>
<p>
    A questo punto dovresti avere un sistema che è pronto per la configurazione finale.
    Partiremo col configurare la timezone.
</p>
<p>
	Cercate la vostra Timezone ( o GMT se state usando
	il Greenwich Mean Time) in <path>/usr/share/zoneinfo</path>.
	Poi, create un link simbolico come segue:
</p>
<pre caption="Selezionare la timezone" >
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Installare il kernel e il System Logger</title>
<section>
<body>
<note>Se non l'hai ancora fatto, edita <path>/etc/make.conf</path> a tuo piacimento.</note>
<p>
    Hai ora bisogno di scaricare i sorgenti del kerneldi Linux. Ecco quelli disponibili:
</p>
<table>
<tr>
<th>ebuild</th>
<th>descrizione</th>
</tr>
<tr>
<ti>
<path>gentoo-sources</path>
</ti>
<ti>Il nostro avanzato e performante kernel (non include il supporto per XFS)</ti>
</tr>
<tr>
<ti>
<path>xfs-sources</path>
</ti>
<ti>Il kernel di SGI con supporto XFS</ti>
</tr>
<tr>
<ti>
<path>openmosix-sources</path>
</ti>
<ti>Un classico kernel patchato per il supporto di <uri link="http://www.openmosix.com" >openMosix</uri>
una tecnologia load-balancing/clustering</ti>
</tr>
<tr>
<ti>
<path>usermode-sources</path>
</ti>
<ti>Un classico kernel patchato per il supporto dello User-Mode Linux.
(tecnologia &quot;Linux inside Linux&quot;)</ti>
</tr>
<tr>
<ti>
<path>vanilla-sources</path>
</ti>
<ti>Il classico kernel, come lo scaricheresti da kernel.org</ti>
</tr>
</table>
<warn>
    Se stai configurando il tuo kernel, fai attenzione alle opzione <i>grsecurity</i>.
    Se scegli un livello di sicurezza troppo aggressivo, certi programmi (come X)
    potrebbero non funzionare correttamente. Se sei in dubbio, non selezionare
    le opzioni <i>grsecurity</i>.
</warn>
<p>
	Scegline uno e uniscilo (merge) al sistema:
</p>
<pre caption="Installare i sorgenti del kernel" >
# <i>emerge sys-kernel/gentoo-sources</i>
</pre>
<p>
	una volta che il kernel è disponibile, è
	il momento di personalizzarlo e  compilarlo:
</p>
<p> 
    Nota che <path>/usr/src/linux</path> è un link simbolico ai sorgenti del
    kernel attualmente installato e che è settato automaticamente dal Portage
    al momento dell'emerge.
    Se hai più di un kernel, è necessario settare il link <path>/usr/src/linux</path>
    affinché punti ai sorgenti corretti prima di procedere.
</p>
<pre caption="Compilazione del kernel" >
# <c>cd /usr/src/linux</c>
# <c>source /etc/profile</c>
<comment>Questo per aggiornare i tuoi paths. Se ottieni un errore che dice gcc not found,
questo è ciò che devi fare.</comment>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
<warn>
	Affinché il tuo kernel funzioni a dovere, ci
	sono alcune opzioni che dovrai essere sicuro siano
	incluse nel kernel e non compilate come modulo.
	Assicurati di abilitare &quot;ReiserFS&quot; se hai partizioni
	di questo tipo; la stessa cosa vale per &quot;Ext3&quot;.
	Se stai usando partizioni XFS, abilita l'opzione &quot;SGI XFS
	filesystem support&quot;. È sempre una buona idea
	lasciare il supporto per ext2 abilitato sia che lo
	usi o no. 
    Seguono alcune opzioni comuni di ui avrai bisogno:
</warn>
<pre caption="opzioni make menuconfig" >
Code maturity level options --->
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(Hai bisogno di questo per delle opzioni che seguono.)</comment>
     ...

File systems --->
  &lt;*> Reiserfs support
<comment>(Solo se hai partizioni ReiserFS.)</comment>
       ... 
  &lt;*> Ext3 journalling file system support
<comment>(Solo se hai partizioni ext3.)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Richiesto per Gentoo Linux.)</comment>
       ...
  &lt;*> JFS filesystem support
<comment>(Solo se hai partizioni JFS.)</comment>
       ...
  [*] /proc file system support
<comment>(Richiesto per Gentoo Linux.)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot          
<comment>(Richiesto per Gentoo Linux.)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(Disabilita questa, non è necessaria.)</comment>
       ...
  &lt;*> Second extended fs support
<comment>(Solo se hai partizioni ext2.)</comment>
       ...
  &lt;*> XFS filesystem support
<comment>(Solo se hai partixioni XFS.)</comment>
</pre>
<p>
	Se stai usando RAID hardware avrai bisogno di abilitare un paio
	di opzioni in più nel kernel: Per controllers Highpoint RAID
	abilita il supporto per il chipset hpt366, per i controllers
	IDE RAID e Highpoint 370 software RAID.
	Per i controllers Promise abilita il supporto PROMISE PDC202{46|62|65|67|68|69|70}, 
	per i controllers IDE RAIDS e Support Promise software RAID (Fasttrak(tm))
</p>
<p>
    Se usi PPPoE per connetterti ad internet, avrai bisogno delle seguenti
    opaioni nel kernel (preferibilmente come moduli):
    &quot;PPP (point-to-point protocol) support&quot;, &quot;PPP support for async
    serial ports&quot;, &quot;PPP support for sync tty ports&quot;. Le due opzioni
    relative alla compressione non sono strettamente necessarie così
    come &quot;PPP over Ethernet&quot; che potrebbe essere usata solo da <i>rp-ppoe</i>
    quando il kernel è in modalità PPPoE.
</p>
<p>
	Se hai un masterizzatore IDE, avrai bisogno di abilitare 
	l'emulazione SCSI nel kernel. Abilita &quot;ATA/IDE/MFM/RLL support&quot; ---> &quot;IDE, ATA and ATAPI Block devices&quot; --->
	&quot;SCSI emulation support&quot; (abilitato di solito come modulo), qundi 
	sotto &quot;SCSI support&quot;, abilita &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; e
	&quot;SCSI generic support&quot; (abilitati come moduli anche questi).
	Se hai scelto di usarli come moduli, allora digita <c>echo -e &quot;ide-scsi/nsg/nsr_mod&quot; >> /etc/modules.autoload</c> per averli automaticamente al boot.
</p>
<note>
	Per coloro che lo preferiscono, è possibile installare
	una Gentoo Linux con kernel 2.2. Per questo c'è
	da pagare un prezzo: perderai le ottime features che
	sono prerogativa della serie 2.4 del kernel (come
	il support per filesystems di tipo XFS e tmpfs,
	iptables, e altro), anche se Gentoo Linux con kernel
	2.2 puà aggiornato col support ReiserFS e
	devfs. Gli scripts di  boot di Gentoo Linux richiedono
	che tmpfs o ramdisk siano supportati dal kernel,
	così coloro che vogliono usare il kernel 2.2
	devono essere sicuri di avere il support per ramdisk
	incluso nel kernel e non compilato come modulo.
	È <comment>vitale</comment> che  un flag
	<e>gentoo=notmpfs</e> sia aggiunto in
	<path>/boot/grub/menu.lst</path> nella linea del
	kernel per la serie 2.2 in modo tale che gli scripts
	di boot montino ramdisk invece di tmpfs. Se scegli
	di non usare  devfs, devi aggiungere una riga del
	tipo <e>gentoo=notmpfs,nodevfs</e>.
</note>
<p>
	Il tuo nuovo kernel e i suoi moduli sono ora
	installati. C'è ora bisogno di scegliere il
	sistema di logging che dovrebbe essere installato.
	È disponibile il tradizionale sistema di
	logging sysklogd. Ma ci sono anche syslog-ng e
	metalog. Utenti che preferivano
	sysklogd (che non brilla per le prestazioni) si
	stanno rivolgendo verso syslog-ng e metalog. Se sei
	in dubbio, puoi provare metalog che sembra essere
	abbastanza popolare. Per installare il logger
	scelto, digita <e>uno</e> dei seguenti quattro comandi:
</p>
<pre caption="Installazione di un sistema di log" >
# <i>emerge sys-apps/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>o</comment>
# <i>emerge app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>o</comment>
# <i>emerge app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>o</comment>
# <i>emerge app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>
<warn>
	Nel caso di syslog-ng avrai bisogno di creare
	<path>/etc/syslog-ng/syslog-ng.conf</path>.
	Puoi trovarne un esempio in
	<path>/etc/syslog-ng</path>.
</warn>
<impo>
	Metalog scrive il suo output su disco a blocchi,
	così i messaggi non sono immediatamente
	registrati nei logs di sistema. Se stai provando a
	testare un daemon, questa caratteristica (che ne
	migliora le prestazioni) potrebbe non essere la
	soluzione migliore.  Una volta che il sistema e' a
	regime puoi provare a mandare al daemon di metalog
	un segnale di tipo USR1 che temporaneamente dovrebbe
	disabilitare il suddetto comportamento (il buffering
	dei messaggi prima discriverli in blocco). Questo
	significa che <i>tail -f
	<path>/var/log/logfile</path>
</i> dovrebbe
	funzionare come ci aspettiamo. Per tornare alla
	situazione standard invieremo un nuovo segnale,
	questa volta di	tipo USR2.
    Se vuoi disabilitare permanentemente il buffering, puoi cambiare
    l'opzione METALOG_OPTS da &quot;-B&quot; a &quot;-B -s&quot; in <path>/etc/conf.d/metalog</path>.
</impo>
<p>
	Se vuoi, puoi ora scegliere il pacchetto cron che
	preferisci. Per ora offriamo, dcron, fcron e vcron.
	Se non sai quale scegliere tra questi, puoi usare
	vcron che può. I pacchetti possono essere
	installati come segue:
</p>
<pre caption="Installazione di un pacchetto cron" >
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/vcron</c>
# <c>crontab /etc/crontab</c>
<comment>Non dimenticarti di aggiungere il tuo *cron all'appropriato init level.</comment>
# <c>rc-update add *cron default</c>
</pre>
<p>
	Per maggiori informazioni sui programmi e daemon che partono al boot,
	dai un'occhiata alla guida <uri link="http://www.gentoo.org/doc/it/rc-scripts.xml" >rc-scripts</uri>.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Installazione di altri pacchetti necessari</title>
<section>
<body>
<p> Se hai bisogno di rp-pppoe per connetterti alla rete, sii conscio che a
questo punto non è stato ancora installato. Potrebbe essere una buona
cosa farlo ora.
</p>
<pre caption="Installazione di rp-pppoe" >
# <c>USE=&quot;-X&quot; emerge rp-pppoe</c>
</pre>
<note>
    Con l'impostazione <i>USE=&quot;-X&quot;</i> impediamo che pppoe installi l'interfaccia grafica opzionale, 
    il che è una buona cosa in quanto verrebbe installato anche l'ambiente grafico X con tutte
    le sue dipendenze. Puoi sempre ricompilare <i>rp-pppoe</i> con il supporto X in seguito.
</note>
<note> Nota che adesso rp-pppoe è installato ma non configurato.
Dovrai configurarlo usando <c>adsl-setup</c> dopo aver riavviato
Gentoo per la prima volta.
</note>
<p>
	Puoi aver bisogno di installare pacchetti
	addizionali nel Portage tree, se stai usando ad
	esempio XFS, ReiserFS o LVM. Per XFS, dovresti installare
	il pacchetto <c>xfsprogs</c>:
</p>
<pre caption="Installazione dei tools per i filesystem" >
# <c>emerge sys-apps/xfsprogs</c>
<comment>Se stai usando ReiserFS, dovresti installare i tools di ReiserFS:</comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>Se stai usando JFS, dovresti installare i tools JFS:</comment>
# <c>emerge jfsutils</c>
<comment>Se invece stai usando LVM, dovresti installare il pacchetto <c>lvm-user</c>:</comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>
<p> Se stai usando un laptop e vuoi usare gli slots PCMCIA al tuo primo
reboot, dovrai installare il pacchetto <i>pcmcia-cs</i>.
</p>
<pre caption="Emerge pcmcia-cs" >
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
<warn>
    Dovrai reinstallare <i>pcmcia-cs</i> dopo l'installazione per far si che
    PCMCIA lavori correttamente.
</warn>
</body>
</section>
</chapter>
<chapter>
<title>Modifica di /etc/fstab per la tua macchina</title>
<section>
<body>
<p>
	Il tuo sistema Gentoo Linux è ormai pronto
	all'uso. Tutto ciò di cui abbiamo bisogno
	è di configurare alcuni importanti files di
	sistema e installare il GRUB boot loader.
	Il primo file che abbiamo bisogno di configurare
	è <path>/etc/fstab</path>. Ricordati che se hai
	scelto una partizione di boot di tipo ReiserFS devi
	aggiungere una opzione <c>notail</c>.
	Ricordati inoltre di specificare il tipo di
	filesystem appropriato per ogni partizione
	(<c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>).
</p>
<p>
	Usa qualcosa tipo l' <path>/etc/fstab</path>
	mostrato sotto, ma naturalmente sostituisci &quot;BOOT&quot;,
	&quot;ROOT&quot; e &quot;SWAP&quot; con i block devices che hai scelto
	di usare (<c>hda1</c>, <c>hda2</c>, ecc.).
</p>
<pre caption="Configurazione dell'fstab" >
<comment>
# /etc/fstab: static file system information.
#
# noatime turns of atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It's safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs>          	&lt;mountpoint>    &lt;type>  	&lt;opts>      		&lt;dump/pass>

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT		/boot		    ext2		noauto,noatime	1 2
/dev/ROOT		/		        ext3		noatime			0 1
/dev/SWAP		none            swap		sw			    0 0
/dev/cdroms/cdrom0	/mnt/cdrom	iso9660		noauto,ro		0 0
proc			/proc           proc		defaults		0 0
</pre>
<warn>
    Nota che <i>/boot</i> NON È montato al boottime. Questo per proteggere i dati
    in <i>/boot</i> dal pericolo di corruzione. Se hai bisogno di accedere a <i>/boot</i>
    ricordati di montarlo!
</warn>
</body>
</section>
<section>
<title>Diamo una password a root</title>
<body>
<p>
	Prima di dimenticarcene, diamo una password a root
	digitando:
</p>
<pre caption="Cambiamo la password di root" >
# <i>passwd</i>
</pre>
<p>
    Vorrai anche aggiungere un altro user oltre a root, per un uso quotidiano.
    Per questo consulta le <uri link="http://www.gentoo.org/doc/it/faq.xml" >Gentoo FAQ</uri>.
</p>
</body>
</section>
<section>
<title>Impostimo il nome della macchina</title>
<body>
<p>
	Crea questo file in modo da contenere il
	fully-qualified domain name della tua macchina su
	una singola riga, p.e.
	<c>nomemacchina.nomedominio.it</c>.
</p>
<pre caption="Impostare l'hostname" >
# <c>echo nomemacchina.nomedominio.it > /etc/hostname</c>
</pre>
</body>
</section>
<section>
<title>Modifichiamo /etc/hosts</title>
<body>
<p>
	Questo file contiene una lista di indirizzi IP
	associati al relativo hostname. È usato dal
	sistema per risolvere indirizzi IP di macchine che
	possono non essere nel tuo DNS server.
	Segue un templato di questo file:
</p>
<pre caption="Editare il file /etc/hosts" >
127.0.0.1      localhost
<comment># the next line contains your IP for your local LAN, and your associated machine name</comment>
192.168.1.1    nomemacchina.nomedomimio	 nomemacchina
</pre>
<note>
    Se sei in una rete DHCP, potrebbe essere utile impostare <i>localhost</i> col nome del attuale
    della macchina. Questo aiuterò GNOME e altri programmi nella risoluzione dei nomi.
</note>
</body>
</section>
<section>
<title>Configurazione finale della rete</title>
<body>
<p>
	Aggiungi il nome di ogni modulo necessario per il
	corretto funzionamento del tuo sistema in
	<path>/etc/modules.autoload</path> (puoi anche
	aggiungere le opzioni necessarie sulla stessa riga).
	Alla partenza di Gentoo Linux, questi moduli
	verranno automaticamente caricati. Particolarmente
	importanti sono i moduli relativi alla scheda di
	rete (naturalmente se li hai compilati come moduli
	;-)):
</p>
<pre caption="/etc/modules.autoload" >
<comment>Assumendo che tu stia usando una scheda di rete 3COM.
Controlla  <path>/lib/modules/`uname -r`/kernel/drivers/net</path> per la tua scheda.
</comment>
3c59x
</pre>
<p>
	Edita lo script <path>/etc/conf.d/net</path> per
	avere la rete configurata per il tuo primo boot:
</p>
<pre caption="Configurare la rete in modo permanente" >
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>
<p>
	Se hai più schede di rete hai bisogno di
	aggiungere altri scripts
	<path>net.eth<comment>x</comment>
</path> per ognuna
	(<comment>x</comment> = 1, 2, ...):
</p>
<pre caption="Interfacce di rete multiple" >
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment>
</i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>
<p>
	Se hai una scheda PCMCIA installata, dai una rapida
	occhiata a <path>/etc/init.d/pcmcia</path> per verificare se
	è conforme alle tue esigenze e aggiungi le righe seguenti  in testa
    al file <path>/etc/init.d/net.eth<comment>x</comment>
</path>:
</p>
<pre caption="Aggiungiamo dipendenze PCMCIA in /etc/init.d/net.ethx" >
depend() {
	need pcmcia
}
	</pre>
<p>
	In questo modo i driver pcmcia vengono caricatu automaticamente
	ogni volta che viene avviata la rete.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Ultimi passi: configurazioni di base (includendo il
setting per la mappatura internazionale della tastiera)</title>
<section>
<body>
<pre caption="Configurazione di base" >
# <i>nano -w /etc/rc.conf</i>
</pre>
<p>
	Dando una scorsa al file troverai diverse variabili
	che inizializzano alcune configurazioni di base. 
	Vorrai essere sicuro che <c>CLOCK</c> sia quello
	voluto. Per usare tastiere con layout diverso da
	quello americano puoi settare la variabile
	<c>KEYMAP</c> (puoi trovare le varie
	possibilità in
	<path>/usr/share/keymaps</path>).
</p>
</body>
</section>
</chapter>
<chapter>
<title>Configurazione di un bootloader</title>
<section>
<title>Note</title>
<body>
<p>
    Nello spirito di Gentoo, gli utenti possono ora scegliere tra più di un bootloader.
    Usando il nostro virtual package system, gli utenti possono scegliere sia GRUB che LILO
    come loro bootloaders.
</p>
<p>
    È chiaro che non è necessario avere entrambi i bootloader installati.
    Infatti potrebbe essere un ostacolo, ti consigliamo ti sceglierne uno solo.
</p>
</body>
</section>
<section>
<title>Configurazione di GRUB</title>
<body>
<p>
	La parte più critica per capire la
	configurazione di GRUB è familiarizzare con la
	notazione che GRUB usa per definire i dischi e le
	partizioni. La partizione Linux
	<path>/dev/hda1</path>  è chiamata
	<path>(hd0,0)</path> sotto GRUB.
	Nota che le parentesi che racchiudono hd0,0 sono
	richieste. I dischi vengono contati a partire da
	zero invece che da &quot;a&quot; e le partizioni partono da
	zero invece che da uno.
    Devi essere consapevole che con periferiche hd sono contati solo i dischi rigidi e non
    periferiche atapi-ide come cdrom e masterizzatori e che lo stesso costrutto vale
    anche per periferiche SCSI. (Di solito queste prendono numeri alti rispetto a periferiche
    ide ad eccezione di quando il bios è configurato per fare il boot da SCSI devices). Così
    facendo finta che tu abbia un disco su /dev/hda, un lettore cdrom su /dev/hdb, un masterizzatore
    su /dev/hdac e un secondo disco su /dev/hdd e nessun disco SCSI, la partizione <path>/dev/hdd7</path>
    diventa <path>(hd1,6)</path>.
    Tutto questo potrebbe suonare complicato, ed è effettivamente complicato, ma come vedrai,
    grub offre un meccanismo di completamento col tasto TAB, che diviene funzionale per quelli che
    hanno un notevole numero di dischi e partizioni e sono un pò smarriti con lo schema numerico
    del grub. Avendo preso coscienza di questo è il momento di installare GRUB
	 Appena hai preso confidenza
	 Appena
	con questa notazione, puoi convertire le partizioni
	di boot e root in un formato comprensibile a GRUB e
	scriverle nel suo file di configurazione.
	Proviamo quindi ad installare GRUB.
</p>
<p>
	La via più breve per installare GRUB è
	semplicemente digitare <c>grub</c> al prompt:
</p>
<pre caption="GRUB" >
# <i>grub</i>
</pre>
<impo>
    Questa parte non funzionerà se stai usando hardware RAID.
    Salta alla sezione sulla creazione del tuo <path>grub.conf</path>. Dopodiché
    completerai il setup di grub per i controllers RAID.
</impo>
<p>
	Ti verrà presentato il  &quot;grub command-line
	prompt: <c>grub></c>. Ora dovrai digitare i
	giusti comandi per installare il GRUB boot record
	nel tuo disco. Nel mio esempio, io voglio installare
	il GRUB boot record nell'MBR (master boot record)
	del mio disco rigido, in modo tale da vedere il GRUB
	prompt ad ogni riavvio del mio computer. Nel mio
	caso i comandi che devo digitare sono:
</p>
<pre caption="Installazione di GRUB nell'MBR" >
grub> <c>root (hd0,0)</c>
<codenote>La tua partizione di boot</codenote>
grub> <c>setup (hd0)</c>
<codenote>Dove viene installato il boot record, in questo caso nell'MBR</codenote>
</pre>
<pre caption="Installazione di GRUB non nell'MBR" >
<comment>Alternativamente, puoi installare il grub su qualche altra partizione oltre che nell'MBR
</comment>
grub> <c>root (hd0,0)</c>
<codenote>La tua partizione di boot</codenote>
gurb> <c>setup (hd0,4)</c>
<codenote>Dove voene installato il boot record, in questo caso la partizione /dev/hda5</codenote>
grub> <c>quit</c>
</pre>
<p>
	Come lavorano i comandi. Il primo comando <c>root (
	)</c> dice a GRUB la locazione della partizione di
	boot (nel nostro esempio <path>/dev/hda1</path> o
	<path>(hd0,0)</path> nella terminologia GRUB. Il
	secondo comando <c>setup ( )</c> dice a GRUB dove
	installare il boot record e sarà configurato
	per cercare i suoi files di configurazione nella
	locazione <c>root ( )</c> che hai specificato.
	Nel mio caso, voglio che il boot record sia
	installato nell'MBR del disco rigido, così
	specifico semplicemente <path>/dev/hda</path> (anche
	conosciuto come <path>(hd0)</path>). Se sto usando
	un altro boot loader e voglio installare GRUB come
	boot loader secondario, avrei dovuto installare il
	GRUB nel boot record di una particolare partizione.
	In questo caso avrei dovuto specificare una
	particolare partizione invece dell'intero disco. Una
	volta che il GRUB è stato installato con
	successo, puoi uscire dal GRUB digitando
	<c>quit</c>. 
</p>
<note>
    Il meccanismo TAB completion del grub può essere usato all'interno
    del grub. Diciamo che tu abbia scritto <c> root (</c> se ora premi il tasto TAB,
    ti dovrebbe essere mostrata una lista di periferiche disponibili (non solo dischi),
    ripremendo il tasto TAB dopo aver scritto <c> root (hd</c>, grub ti dovrebbe mostrare
    solo i dischi e ripremendo il TAB dopo aver scritto <c> root (hd0,</c> dovresti
    avere la lista delle partizioni del primo disco.
    Il controllo della sintassi con cui il grub definisce le partizioni unito al completamento
    dovrebbe aiutarti a fare le giuste scelte.
</note>
<p>
    L'installazione di Gentoo è ora completa, dobbiamo solo creare 
    il file <path>/boot/grub/grub.conf</path> che dovrebbe mostrare un menu
    quando il sistema viene riavviato.
</p>
<impo>
    Per assicurare un compatibilità con le versioni precedenti, ti consigliamo
    di creare un link tra <i>grub.conf</i> e <i>menu.lst</i>.
    Puoi farlo digitando <c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>.
</impo>
<p>
	Creiamo il file grub.conf (<c>nano -w /boot/grub/grub.conf</c>),
	e aggiungiamo le seguenti righe:
</p>
<pre caption="Esempio di grub.conf" >
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment> # Seguono le instruzioni per usare RAID hardware
</comment>
title=Gentoo Linux su RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment>
	# Seguono le istruzioni per coloro che necessitano
	di un dual-boot
</comment>
title=Windows NT Workstation
root (hd0,5) 
chainloader (hd0,5)+1
</pre>
<note>
	(hd0,0) deve essere scritto senza spazi tra
	le parentesi.
</note>
<impo>
	Se hai configurato l'emulazione SCSI per un masterizzatore
	IDE, per renderlo attivo hai bisogno di aggiungere un &quot;hdx=ide-scsi&quot;
	alla linea del kernel in menu.lst (dove &quot;hdx&quot; dovrebbe essere 
	il device del tuo masterizzatore).
</impo>
<p>
	Dopo aver salvato il file, l'installazione di Gentoo
	Linux è completa. Selezionando la prima opzione
	diciamo al GRUB di fare il boot con Gentoo Linux. La
	seconda parte del file grub.conf è opzionale,
	mostra solo come usare GRUB per fare il boot anche
	con partizioni Windows.
</p>
<note>
<path>(hd0,0)</path> dovrebbe puntare alla tua
	partizione &quot;boot&quot; (<path>/dev/hda1</path> nel nostro
	esempio) e <path>/dev/hda3</path> dovrebbe puntare
	al filesystem root. La partizione
	<path>(hda0,5)</path> contiene il boot loader di NT.
</note>
<note>
    Il percordo dell'immagine del kernel è relativa alla partizione /boot.
    Se per esempio hai la partizione /boot <path>(hd0,0)</path> separata dalla root (/)
    <path>(hd0,1)</path>, tutti i percorsi del grub.conf diverrebbero <path>/bzImage</path>.
</note>
<p>
	Ancora, se hai bisogno di passare delle opzioni al
	kernel, aggiungile semplicemente  alla fine del
	comando <c>kernel</c>. Stiamo già passandogli
	un'opzione (<c>root=/dev/hda3</c>), ma possiamo
	passargliene delle altre.  In particolare puoi
	disabilitare il support per il devfs (non è
	raccomandato a meno che tu non sappia cosa stai
	facendo) aggiungendo l'opzione <c>gentoo=nodevfs</c>
	al comando <c>kernel</c>.
</p>
<note>
		A differenza delle prime versioni di Gentoo
		Linux, non è più necessario
		aggiungere <c>devfs=mount</c> alla fine
		della riga <c>kernel</c> per abilitare il
		devfs. Nelle nuove versioni è abilitato
		per default.
	</note>
</body>
</section>
<section>
<title>Configurare il LILO</title>
<body>
<p>
    Mentre GRUB può essere una nuova alternativa per molte persone, non è
    sempre la scelta migliore. LILO, il LInuxLOader, è il più provato e vero
    cavallo da fatica dei bootloaders di Linux. Ecco come installare LILO se lo vuoi usare
    al posto del GRUB:
</p>
<p> 
    Il primo step è installarlo:
</p>
<pre caption="Emerge LILO" >
# <c>emerge lilo</c>
</pre>
<p>
    Ora è il momento di configurare LILO. Ti darò un piccolo <i>lilo.conf</i> da usare
    e ti spiegherò le differenti parti del file.
</p>
<pre caption="Esempio di lilo.conf" >
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	read-only
	root=/dev/hda5
	
#For dual booting windows/other OS
other=/dev/hda1
	label=dos

	</pre>
<li>
<i>boot=/dev/hda</i>
        dice a LILO di installarsi nel primo disco del primo controller IDE.</li>
<li>
<i>map=/boot/map</i>
        specifica il map file. In un normale uso, questo non dovrebbe essere modificato.</li>
<li>
<i>install=/boot/boot.b</i> 
        dice a LILO di installare il file specificato come il nuovo settore di boot.
        Per un uso normale, questo non dovrebbe essere alterato. Se questa line è omessa, LILO assumerà
        un /boot/boot.b di default come file da essere usato.</li>
<li>L'esistenza di <i>prompt</i>
        dice a LILO di mostrare qualsiasi cosa sia fornito nella linea message.
        Mentre non è raccomandato che tu rimuova la linea prompt, se la devi rimuovere, puoi ancora
        avere un prompt premendo il tasto [Shift] mentre la tua macchina parte per il boot.</li>
<li>
<i>timeout=50</i>
        setta il tempo durante il quale LILO aspetterà qualche input
        prima di procedere con il boot di default. Questo è misurato in decine di secondi, con 50 come 
        default.</li>
<li>
<i>message=/boot/message</i>
        si riferisce alla shermata che LILO mostra per permetterti
        di selezionare il sistema operativo o il kernel da avviare.</li>
<li>
<i>lba32</i> 
        descrive la geometria del disco. Un altro parametro comune è linear. 
    Non dovresti cambiare questa linea a meno che non sei veramente sicuro di quello che stai facendo.
    Altrimenti potresti avere un sistema non bootabile.</li>
<li>
<i>default=linux</i> 
        si riferisce al systema operativo che il LILO avvierà
        di default con le opzioni che seguono dopo questa linea</li>
<li>
<i>image=/boot/vmlinuz-2.4.20</i>
        specifica il kernel da avviare.</li>
<li>
<i>label=linux</i> 
        è il nome del sistema operativo visualizzato nella schermata
        del LILO. In questo caso è anche il nome a cui si riferisce la linea di default.</li>
<li>
<i>read-only</i> 
        specifica che la root partition (vedi la riga seguente) è read-only
        e non può essere alterata durante il processo di boot.</li>
<li>
<i>root=/dev/hda5</i>
        dice al LILO quale partizione del disco deve essere usata 
    come root partition.</li>
<note>Un ringraziamento a <uri link="http://www.redhat.com" >RedHat.com</uri> per queste
informazioni.</note>
<p>
    Dopo avere editato il nostro <i>lilo.conf</i>, è il momento di eseguire LILO per
    caricare queste informazioni nell'MBR:
</p>
<pre caption="Eseguire LILO" >
# <c>/sbin/lilo</c>
</pre>
<p>
    LILO è configurato e ora la tua macchina è pronta per l'avvio in Gentoo Linux!
</p>
</body>
</section>
</chapter>
<chapter>
<title>Creazione dei bootdisk</title>
<section>
<title>GRUB Bootdisks</title>
<body>
<p>
    È sempre una buona idea creare un dischetto di boot la prima volta che
    installiamo una qualsiasi distribuzione Linux. Questa è una sicurezza e
    generalmente non è una cattiva idea. Se stai usando qualche tipo di hardware
    RAID, puoi avere <e>necessità</e> di creare un GRUB boot disk. Con questi tipi
    di hardware RAID non è possibile installare grub dalla tua shell chrooted.
    Se questo è il tuo campo crea un GRUB boot disk e quando riavvii la prima volta
    potrai installare GRUB sull'MBR. Crea il tuo bootdisk in questo modo:
</p>
<pre caption="Creare un GRUB bootdisk" >
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>
# <c>umount /mnt/floppy</c>
# <c>grub</c>

grub> <c>root (fd0)</c>
grub> <c>setup (fd0)</c>
grub> <c>quit</c>
</pre>
<p>
    Ora riavvia e al prompt del grub del floppy, puoi eseguire i necessari comandi <c>root</c>
    e <c>setup</c>.
</p>
</body>
</section>
<section>
<title>LILO bootdisk</title>
<body>
<p>
    Anche se stai usando LILO è una buona idea creare un bootdisk:
</p>
<pre caption="Creare un LILO Bootdisk" >
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>Questo è possibile solo con kernel più piccoli di 1.4MB</comment>
</pre>
</body>
</section>
</chapter>
<chapter>
<title>L'installazione è completata!</title>
<section>
<body>
<p>
	Gentoo Linux è installato. Rimane solo da
	uscire dalla shell, smontare le partizioni e
	riavviare il sistema:
</p>
<pre caption="Riavviare il sistema" >
# <c>etc-update</c>
# <c>exit</c>
<codenote>questo per uscire dalla shell;puoi anche digitare <c>^D</c>
</codenote>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo/dev</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
<note>
	Dopo il riavvio, è una buona idea eseguire il
	comando <c>update-modules</c> per creare il file
	<path>/etc/modules.conf</path>. Invece di modificare
	questo file direttamente, dovresti generalmente
	applicare le modifiche al file
	<path>/etc/modules.d</path>.
</note>
<impo>
	Ricordati che se stai usando RAID hardware, devi usare il bootdisk
	per il primo reboot e fare i passaggi per installare il grub
	nell'MBR. Se l'hai fatto, congratulazioni.
</impo>
<p>
	Se hai qualche domanda o ti piacerebbe essere
	coinvolto con gli sviluppatori di Gentoo Linux,
	considera di unirti alle nostre mailing lists
	gentoo-user e gentoo-dev (c'è un link &quot;click to
	subscribe&quot; nel  <uri link="http://www.gentoo.org" >sito ufficiale</uri>).
	Abbiamo anche una comoda guida 
	<uri link="http://www.gentoo.org/doc/it/desktop.xml" >Desktop configuration
	guide</uri> che ti aiuterà a continuare a
	configurare il tuo nuovo sistema Gentoo Linux per la
	parte grafica e
	un' utile guida <uri link="http://www.gentoo.org/doc/it/portage-user.xml" >Portage user guide</uri>
	che ti aiuterà a familiarizzare con il sistema
	Portage. Puoi trovare il resto della documentazione Gentoo <uri link="http://www.gentoo.org/main/en/docs.xml" >qui</uri>. Se hai altre domande che coinvolgono l'installazione
    e altre materie, dai una lettura alle Gentoo Linux <uri link="http://www.gentoo.org/doc/it/faq.xml" >FAQ</uri>.
	Benvenuto in Gentoo Linux!
</p>
</body>
</section>
</chapter>
<chapter>
<title>Gentoo-Stats</title>
<section>
<body>
<p>
        Il programma per le statistiche d'uso di Gentoo Linux è partito come tentativo
        di dare agli sviluppatori un modo per capire chi sono gli utilizzatori di base.
        Il programma colleziona informazioni circa l'uso di Gentoo Linux e ci aiuta a 
        dare una priorità alle fasi di sviluppo. L'installazione è
        completamente opzionale ma ti saremmo grati se decidi di farla.
        Le statistiche possono essere viste si <uri>http://stats.gentoo.org/</uri>
</p>
<p>
        Il server gentoo-stats  assegnerà un ID univoco al tuo sistema.
        Questo ID è usato per assicurare che ogni sistema sia contato una sola
        volta. Questo ID non sarà usato per identificare individualmente il tuo sistema
        e nemmeno per identificare il tuo IP o altre informazioni personali.
        È stata presa ogni precauzione per assicurare la tua privacy nel sistema
        di sviluppo. Ecco le cose che vengono monitorare dal programma &quot;gentoo-stats&quot;:
    </p>
<ul>
<li>pacchetti installati e la loro versione</li>
<li>informazioni sulla CPU: velocità (MHz), marca, modello, CPU flags (come &quot;mmx&quot; o &quot;3dnow&quot;)</li>
<li>informazioni sulla memoria (RAM fisica disponibile in totale, swap space disponibile in totale)</li>
<li>schede PCI e chipset delle schede di rete</li>
<li>il profile Gentoo Linux che sta usando la tua macchina (cioè dove sta puntando il  link /etc/make.profile).</li>
</ul>
<p>
        Siamo consapevoli che la conoscenza di informazioni sensibili è un pericolo
        per molti utenti Gentoo Linux (così come lo è per gli sviluppatori).
    </p>
<ul>
<li>
        A meno che tu non lo modifichi, il programma gentoo-stats non trasmetterà
        informazioni sensibili come password, dati di configurazione, taglia delle scarpe..</li>
<li>La trasmissione del tuo indirizzo di email è opzionale ed è
    disabilitato di default.</li>
<li>L'indirizzo IP che origina la trasmissione dei tuoi dati non verrà mai 
    registrato per poterti identificare. Non c'à l'accoppiata &quot;indirizzo IP/ID del sistema&quot;.</li>
</ul>
<p>L'installazione è semplice, devi solo eseguire i seguenti comandi:
    </p>
<pre caption="Installare gentoo-stats" >
# <c>emerge gentoo-stats</c>
<codenote>Installa gentoo-stats</codenote>
# <c>gentoo-stats --new</c>
<codenote>ottiene il nuovo ID del sistema</codenote>
</pre>
<p>
    Il secondo comando richiederà  un nuovo ID per il tuo sistema ed entrerà
    automaticamente dentro <path>/etc/gentoo-stats/gentoo-stats.conf</path>.
    Puoi dare un'occhiata a questo file per vedere opzioni di configurazione aggiuntive.
</p>
<p>
    Il programma dovrebbe quindi essere eseguito a cadenza regolare
    (gentoo-stats non dovrebbe essere eseguito come root).
    Aggiungi questa riga al tuo <path>crontab</path>:
</p>
<pre caption="Aggiungere gentoo-stats al cron" >
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update > /dev/null</c>
</pre>
<p>
    Il programma <c>gentoo-stats</c> è un semplice script perl che può
    essere visto usando un semplice editor.
</p>
</body>
</section>
</chapter>
</guide>
