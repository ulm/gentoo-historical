<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/en/gentoo-x86-install.xml">
  
  <title>Guida all'installazione di Gentoo Linux 1.4</title>
  
  <author title="Supervisore">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Autore originale">Chris Houser</author>
  <author title="Autore originale">Jerry Alexandratos</author>
  <author title="Revisore">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Redattore">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Redattore">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Redattore">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Redattore">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Redattore">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Redattore">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>
  <author title="Redattore">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
  </author>
  <author title="Redattore">Colin Morey
  </author>
  <author title="Redattore">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Redattore">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Redattore, revisore">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
  </author>
  <author title="Redattore">
     <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
  </author>
  <author title="Redattore">
    <mail link="avenj@gentoo.org">Jon Portnoy</mail>
  </author>
  <author title="Revisore">
    <mail link="gerrynjr@gentoo.org">Gerald J. Normandin Jr.</mail>
  </author>
  <author title="Revisore">
    <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
  </author>
  <author title="Revisore">
    <mail link="antifa@gentoo.org">Ken Nowack</mail>
  </author>
  <author title="Traduttore">
    <mail link="gentoo@virgilio.it">Shev</mail>
  </author>
   <author title="Traduttore">
    <mail link="emorelli@gentoo.it">Enrico Morelli</mail>
  </author> 
  <author title="Traduttore">Team Italiano
  </author>
  
  <abstract>
  Queste instruzioni vi guideranno attraverso il processo di installazione di Gentoo Linux 1.4, versione finale
  (non in versione _rc). L'installazione di Gentoo Linux supporta diversi tipi di approccio a seconda di quali parti
  del vostro sistema vogliate costruire da zero.
  </abstract>

  <license/>
    
<version>2.6.6</version>
 <date>25 Agosto 2003</date>
  
<chapter>
    <title>A proposito dell'installazione</title>
      <section>
	<body>
	  	<p>
		Prima di iniziare, se siete nuovi in questa comunità, benvenuti in Gentoo Linux!
		Gentoo Linux può essere installata in molti modi diversi. Coloro che desiderano
		un'installazione rapida possono servirsi dei pacchetti precompilati, mentre coloro
		che cercano l'ottimizzazione estrema possono compilare Gentoo interamente dai
		sorgenti originali. La scelta di quale metodo adottare dipende solo da voi.
		</p>

		<p>
		Un cambiamento significativo legato al rilascio ufficiale della versione 1.4
		è il nostro nuovo set d'installazione composto da 2 cd, che può essere ordinato
		al <uri	link="http://store.gentoo.org">Gentoo Linux Store</uri>, oltre ad essere 
		liberamente disponibile sui nostri mirror.
		Attualmente abbiamo i due cd d'installazione per x86 (486 e superiori), i686 (Pentium Pro,
		Pentium II, Athlon/Duron e superiori), Pentium III, Pentium 4 e Athlon XP.
		Per vedere quale set di cd fa al caso vostro, leggete le descrizioni dettagliate
		di ogni prodotto che trovate nello <uri	link="http://store.gentoo.org">Store</uri>. 
		Le descrizioni disponibili nello Store contengono informazioni piuttosto complete sulla 
		compatibilità tra CPU.
		</p>

		<p>
		Parliamo ora del set di CD -- vediamo cosa c'è su ogni CD. Il primo CD
		("CD 1") è chiamato "Live CD d'Installazione" ed è un cd avviabile, ciò significa
		che potete mettere il "CD 1" nel vostro lettore e avviare Gentoo Linux direttamente
		dal CD. Potete quindi usare questa versione di Gentoo basata su CD per installare
		Gentoo Linux sul vostro hard disk. Oltre a contenere un ambiente Gentoo Linux 
		avviabile, il "CD 1" contiene tutto ciò che potrebbe servirvi per installare 
		rapidamente Gentoo Linux, anche senza una connessione a internet. In più, parecchi
		pacchetti precompilati sono contenuti nel CD 1, quali il sempre importante server X
		XFree86. Se avete un file immagine .iso del CD 1, il suo nome finirà con "<path>-cd1.iso</path>".
		</p>

		<p>
		Al contrario, il secondo CD ("CD 2") non è avviabile e contiene buona parte dei
		pacchetti precompilati per il vostro sistema. Inclusi in questo CD ci sono versioni 
		ottimizzate dei pacchetti come KDE, GNOME, OpenOffice, Mozilla, Evolution e altri.
		Il CD 2 è <e>opzionale</e> ed è pensato per quelle persone che sono interessate 
		ad installare Gentoo Linux davvero velocemente. Su un tipico sistema moderno a singolo
		processore i pacchetti inclusi nel CD 2 impiegano solitamente circa 36 ore per essere
		interamente compilati dai sorgenti. Se avete un file immagine .iso del CD 2, il suo
		nome terminerà con "<path>-cd2.iso</path>".
		</p>

		<note>
		Un set di cd d'installazione completo contiene la Gentoo Reference Platform,
		che è un intero sistema Gentoo Linux precompilato che include GNOME,
		KDE, Mozilla e OpenOffice. La Gentoo Reference Platform ("GRP") è stata creata 
		per permettere un'installazione veloce dei pacchetti Gentoo Linux per coloro
		che necessitano di tale possibilità. La capacità di "compilazione dai sorgenti",
		il vero cuore di Gentoo Linux, sarà sempre pienamente supportata in ogni installazione.
		Lo scopo della GRP è di rendere Gentoo Linux più comoda per alcuni utenti, senza per 
		questo influire in alcun modo sul potente processo di installazione di Gentoo basato sulla
		"compilazione dai sorgenti". 
		</note>

		<p>
		Oltre al nostro set di CD, abbiamo anche un Live CD "basic" veramente molto piccolo
		che potete usare per avviare il vostro sistema. Una volta che il vostro sistema è
		avviato, potete configurare una connessione a internet e quindi installare Gentoo
		attraverso la rete. Il vantaggio principale di questo CD "basic" è che è piccolo e
		dunque il relativo file immagine può essere scaricato velocemente. Se siete utenti 
		esperti che desiderano installare la versione più aggiornata disponibile di Gentoo Linux
		e possedete una connessione di rete veloce, allora probabilmente preferirete questa
		opzione. Se avete un file immagine .iso del Live CD "basic", il suo nome finirà
		con "<path>-basic.iso</path>".
		</p>
		
		<p>
		Per utilizzare un qualsiasi metodo d'installazione di Gentoo Linux basato su CD,
		dovrete avere un processore 486+ e possibilmente almeno 64 Megabytes di RAM.
		(Gentoo Linux è stata installata con successo utilizzando 64MB di RAM +
		64MB di spazio swap, ma il processo d'installazione è veramente molto lento in
		queste condizioni).
		</p>

		<p>
		Una volta che avete avviato uno dei nostri Live CD, avrete ancor più opzioni.
		Gentoo Linux può essere installata usando uno dei tre file tarball chiamati
		&quot;stage&quot;. Quale scegliere fra i tre dipende da quali parti del vostro sistema 
		desiderate compilare da soli. Il tarball stage1 è utilizzato quando si vuole compilare
		l'intero sistema da zero. Il tarball stage2 è utilizzato per costruire l'intero sistema
		partendo però da uno stato di bootstrap "semi-compilato". Il tarball stage3 contiene già
		un sistema Gentoo Linux di base costruito per voi. Se avete intenzione di affrontare 
		un'installazione "GRP", allora il tarball stage3 è quello che fa al caso vostro.
		</p>

		<p>
		<b>Se non state facendo un'installazione GRP, dovete partire dal tarball stage1, stage2 o
		stage3?</b> 
		Trovate di seguito qualche informazione che dovrebbe aiutarvi in questa scelta.
		</p>
		
		<p>
		Partire dallo stage1 vi permette di avere il controllo totale su quali ottimizzazioni e
		funzionalità build-time opzionali devono essere inizialmente abilitate nel vostro sistema.
		Un'installazione dallo stage1 è una buona scelta per utenti esperti che sanno cosa stanno
		facendo. E' inoltre un'ottima scelta per coloro che vogliono saperne di più circa il
		funzionamento interno di Gentoo Linux.
        	</p>

		<p>
		L'installazione da stage2 vi permette di evitare il processo di bootstrap ed è
		molto comoda se vi bastano le ottimizzazioni che abbiamo scelto per il vostro particolare
		tarball stage2.
		</p>
		
		<p>
		Infine scegliere di comiciare con lo stage3 vi permetterà di fare un'installazione
		veloce di Gentoo Linux, ma anche in questo caso dovrete accontentarvi di un sistema base 
		con ottimizzazioni scelte da noi (che a voler essere sinceri sono ottime impostazioni, scelte con
		cura per migliorare le prestazioni mantenendo la stabilità).
		Poichè le release maggiori di Gentoo Linux possiedono stage3 specificatamente ottimizzati per
		i processori più popolari, partire dallo stage3 può offrire il meglio di ogni soluzione possibile 
		-- un'installazione veloce e un sistema ben ottimizzato. 
		</p>
		
		<p>
		<b>Se state installando Gentoo Linux per la prima volta, vi consigliamo di utilizzare il tarball
		stage3, o lo stage3 con GRP
		</b></p>
		
		<note><b>Utenti avanzati:</b> se utilizzate uno stage3 per l'installazione, non dovete
		modificare le impostazioni CHOST di default nel <path>make.conf</path>. Se necessitate di dover fare
		qualche cambiamento, dovete partire con un tarball stage1 e costruire il vostro sistema
		con le impostazioni CHOST che desiderate. Le impostazioni CHOST sono tipicamente simili a
		questa: <c>i686-pc-linux-gnu</c>.
		</note>

        	<impo>
		Se incontrate un problema con qualsiasi parte dell'installazione e volete segnalarlo 
		come bug, riportatelo su <uri>http://bugs.gentoo.org</uri>. 
		Se il bug coinvolge gli sviluppatori originali del software (es. il team KDE), gli 
		<e>sviluppatori Gentoo Linux</e> si prenderanno cura di comunicarlo ad essi al posto vostro.
		</impo>

		<note>
		Le istruzioni per l'installazione presenti nei Live CD potrebbero non essere 
		aggiornate come quelle riportate nella documentazione web che travte su
		<uri>http://www.gentoo.org/doc/en/gentoo-x86-install.xml</uri>. 
		Per avere informazioni sull'installazione il più aggiornate possibile fate riferimento alla
		documentazione web.
		</note>

        	<p>
		Ora, rivediamo velocemente il processo di installazione. Prima di tutto, dobbiamo scaricare
		e masterizzare i(l) CD quindi riavviare il sistema con il Live CD. Dopo aver ottenuto il prompt di root,
		dobbiamo creare le partizioni, creare i nostri filesystem ed estrarre uno tra i tarball stage1,
		stage2 o stage3. Se stiamo utilizzando un tarball stage1 o stage2 dovremo fare i passi necessari
		per portare il nostra sistema allo stage3. Una volta che il nostro sistema sarà allo stage3,
		procederemo configurandolo (personalizzando i file di configurazione, installando un boot loader,
		ecc.), riavvieremo ed avremo quindi un sistema Gentoo Linux perfettamente funzionante.
		Una volta che il vostro sistema Gentoo Linux di base starà girando, potrete facoltativamente utilizzare
		il "CD 2" del set di CD e installare ogni pacchetto precompilato che vorrete avere sul vostro sistema,
		come KDE, GNOME, OpenOffice, Mozilla o altri ancora. 
		</p>
		
		<p>
		In base allo stage dal quale stiamo partendo, i requisiti richiesti per l'installazione sono i
		seguenti:
        	</p>
		
		<table>
          	<tr>
            	<th>tarball stage</th>
		<th>Richiesto l'accesso a internet</th>
		<th>Media richiesto</th>
            	<th>Passi</th>
          	</tr>
          	<tr>
            	<ti>1</ti>
		<ti>Si</ti>
		<ti><e>basic</e> o <e>CD 1</e></ti>
            	<ti>setup di partizioni/filesystem, emerge sync, bootstrap, emerge system, configurazione finale</ti>
          	</tr>
          	<tr>
            	<ti>2</ti>
		<ti>Si</ti>
		<ti><e>basic</e> o <e>CD 1</e></ti>
            	<ti>setup di partizioni/filesystem, emerge sync, emerge system, configurazione finale</ti>
          	</tr>
          	<tr>
            	<ti>3</ti>
		<ti>No usando il <e>CD 1</e>, Si altrimenti</ti>
    		<ti><e>basic</e> o <e>CD 1</e></ti>
		<ti>setup di partizioni/filesystem, emerge sync (non richiesto usando il <e>CD 1</e>),
		configurazione finale</ti>
          	</tr>
          	<tr>
		 <ti>3+GRP</ti>
		<ti>No</ti>
		<ti><e>CD 1</e>, facoltativamente il <e>CD 2</e></ti>
		<ti>setup di partizioni/filesystem, configurazione finale, installazione dei pacchetti precompilati del
		CD 1 (opzionale), riavvio, installazione dei pacchetti extra precompilati come KDE e GNOME (usando il
		"CD 2").</ti>
		</tr>
		</table>
        
		<note>Gli utenti che possiedono hardware RAID ATA dovrebbero leggere la sezione
		riguardante il RAID ATA nella parte finale di questo documento prima di procedere.
        	</note>
	</body>
      </section>
</chapter>
  
<chapter>
    <title>Caricamento del sistema (booting)</title>
    <section>
      	<body>
        	<warn>
		Leggete interamente questa sezione prima di continuare, specialmente le
		opzioni di boot disponibili. Ignorare questa parte potrebbe portare a
		configurazioni errate della tastiera, servizi pcmcia che non partono, ecc. 
        	</warn>

		<p>
		Cominciate avviando il Live CD che avete scelto. Dovreste vedere una bella schermata
		d'avvio con il logo di Gentoo Linux. In questa schermata potete premere Invio
		per iniziare il processo di boot (ndt, avvio del sistema), o avviare il Live CD
		con opzioni di boot personalizzate specificando un kernel seguito dalle opzioni
		di boot, quindi dando Invio. Per esempio: <c>gentoo nousb nohotplug</c>.
		Se state installando Gentoo Linux su un sistema con più di un processore ("SMP"),
		allora potete digitare al prompt <c>smp</c> al posto di <c>gentoo</c>. 
		Ciò permetterà al Live CD di vedere tutti i processori presenti nel sistema, anzichè soltanto
		uno.</p>
		
		<p>
		Consultate la seguente tabella per avere una lista parziale dei kernel e delle opzioni
		disponibili, oppure premete F2 e F3 per consultare le schermate d'aiuto.
		</p>

		<table>
		<tr>
		<th>Kernel disponbili</th><th>Descrizione</th>
		</tr>
	
		<tr><ti>gentoo</ti><ti>il kernel gentoo standard (default)</ti></tr>
		<tr><ti>nofb</ti><ti>modalità framebuffer disabilitata</ti></tr>
		<tr><ti>smp</ti><ti>carica un kernel smp in modalità senza framebuffer</ti></tr>
		<tr><ti>acpi</ti><ti>abilita acpi=on + carica i moduli acpi durante l'init</ti></tr>
		<tr><ti>memtest</ti><ti>avvia il programma di controllo della memoria</ti></tr>

		</table>

		<p>
		<table>
		<tr>
		<th>Opzioni di boot disponibili</th><th>Descrizione</th>
		</tr>

		<tr><ti>doataraid</ti><ti>carica i moduli ide raid da initrd</ti></tr>
	
		<tr><ti>dofirewire</ti><ti>carica i moduli firewire in initrd (per firewire, cdroms, ecc.)</ti></tr>

		<tr><ti>dokeymap</ti><ti>abilita la selezione della keymap per tastiere non americane</ti></tr>

		<tr><ti>dopcmcia</ti><ti>avvia il servizio pcmcia</ti></tr>

		<tr><ti>doscsi</ti><ti>ricerca le periferiche scsi (si blocca con certe schede ethernet)</ti></tr>

		<tr><ti>noapm</ti><ti>disabilita il caricamento dei moduli apm</ti></tr>

		<tr><ti>nodetect</ti><ti>non avvia hwsetup/kudzu e hotplug</ti></tr>

		<tr><ti>nodhcp</ti><ti>dhcp non verrà avviato automaticamente nel caso venga rilevata una scheda di rete</ti>
		</tr>

		<tr><ti>nohotplug</ti><ti>disabilita il caricamento del servizio hotplug</ti></tr>

		<tr><ti>noraid</ti><ti>disabilita il caricamento dei moduli evms</ti></tr>

		<tr><ti>nousb</ti><ti>disabilita il caricamento dei moduli usb da initrd, disabilita hotplug</ti></tr>

		<tr><ti>ide=nodma</ti><ti>Forza la disabilitazione del dma per periferiche ide malfunzionanti</ti></tr>

		<tr><ti>cdcache</ti><ti>Memorizza nella ram l'intera porzione runtime del cd. Per questo saranno
		utilizzati 40mb di RAM, ma avrete la possibilità di smontare /mnt/cdrom e montare un altro cdrom.
		</ti></tr>

		</table></p>


		<p>Una volta che avrete premuto Invio, verrete accolti da una schermata d'avvio
		e una progress bar.
		</p>

<!--
		<figure link="/images/install/livecd-1.4-boot.png" caption="Avvio del Live CD Gentoo
		Linux" />
-->

		<p>Quando il processo di boot sarà completato, verrete automaticamente loggati nel sistema
		Gentoo Linux "Live" come "<e>root</e>", il "super utente." 
		Dovreste avere il prompt di root ("#") nella console corrente e dovreste poter
		passare alle altre console premendo Alt-F2, Alt-F3 e Alt-F4.
		Tornate in quella da cui siete partiti premendo Alt-F1.
		</p>

<!--
		<figure link="/images/install/livecd-1.4-con.png" caption="Console del Live CD Gentoo
		Linux" />
-->

		<note>
		<b>Utenti avanzati:</b> Quando si avvia il Live CD, la password di root del Live CD
		è impostata con una stringa casuale per motivi di sicurezza. Se avete intenzione di avviare
		<c>sshd</c> per abilitare il login remoto al vostro Live CD, dovrete impostare ora la passowrd
		di root del Live CD digitando <c>passwd</c> e seguendo le istruzioni.
		Altrimenti, non conoscerete la password corretta per loggarvi nel Live CD attraverso la rete.
		</note>

        	<p>
		Avrete probabilmente notato che sopra il vostro prompt # c'è un breve testo d'aiuto che
		vi spiega alcune cose quali configurare correttamente la vostra rete Linux e dove trovare i tarball
		degli stage Gentoo Linux e i pacchetti nei vostri CD.
		</p>
      	</body>
    </section>
  </chapter>
  
  <chapter>
    <title>Configurazione opzionale dell'hardware</title>
    <section>
      	<body>
        	<p>
		Quando il Live CD viene avviato, prova a individuare tutti i vostri dispositivi hardware
		e caricare gli appropriati moduli del kernel per supportare il vostro hardware. 
		Nella maggior parte dei casi, esso fa davvero un buon lavoro. 
		Tuttavia, in alcuni casi, può non caricare i moduli del kernel di cui avete bisogno.
		Se l'auto-rilevazione dei dispositivi PCI dovesse dimenticare alcune delle vostre periferiche
		hardware, potete sempre caricare manualmente i moduli del kernel necessari.
		Per vedere una lista di tutti i moduli disponibili per le schede di rete, digitate
		<c>ls /lib/modules/`uname -r`/kernel/drivers/net/*</c>.  Per caricare un particolare
		modulo date:
		</p>
		
		<pre caption="Configurare i moduli PCI">
		# <i>modprobe pcnet32</i>
		<comment>(sostituite pcnet32 con il modulo della vostra NIC)</comment>
		</pre>
        
		<p>
		Inoltre, se volete aver accesso a qualsiasi dispositivo hardware SCSI che non è stato
		rilevato durante la fase iniziale di auto-rilevazione, dovete caricare il modulo 
		appropriato da <path>/lib/modules</path>, sempre servendovi di <c>modprobe</c>:
		</p>
		
		<pre caption="Caricare i moduli SCSI">
		# <i>modprobe aic7xxx</i>
		<comment>(sostituite aic7xxx con il modulo del vostro adattatore SCSI)</comment>
		# <i>modprobe sd_mod</i>
		<comment>(sd_mod è il modulo per il supporto ai dischi SCSI)</comment>
		</pre>
		
		<note>
		Il supporto per i CD-ROM e i dischi è compilato staticamente nel kernel.
		</note>

		<note><b>Utenti avanzati:</b> Il Live CD Gentoo dovrebbe aver abilitato il DMA
		per i vostri dischi in modo che il trasferimento dei dati sia il più veloce possibile, 
		ma se così non fosse, <c>hdparm</c> può essere usato per impostare il DMA per le vostre
		periferiche come segue:
		
		<pre caption="Impostare il DMA">
		<comment>(Sostituite hdX con il vostro dispositivo)</comment>
		# <i>hdparm -d 1 /dev/hdX</i>
		<comment>Abilita il DMA </comment>
		# <i>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</i>
		<comment>(Abilita il DMA e altre opzioni sicure per incrementare le performance)</comment>
		# <i>hdparm -X66 /dev/hdX</i>
		<comment>(Forza l'abilitazione dell'Ultra-DMA -- pericoloso -- può causare danni alla periferica)</comment>
		</pre>
		</note>
	
 	    </body>
    </section>
</chapter>
  
<chapter>
    <title>Configurazione opzionale della rete</title>
	<section>
      		<title>Forse funziona già?</title>
      		<body>
		
		<p>
		Se il vostro sistema è inserito in una rete Ethernet, è molto probabile che la vostra
		configurazione di rete sia già stata impostata automaticamente per voi. In questo caso,
		dovreste già potervi servire dei molti comandi di rete inclusi nel Live CD, come <c>ssh</c>,
		<c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> e <c>lynx</c> per esempio.
		</p>
	  
        	<p>
		Se la rete è stata già configurata per voi, il comando <c>/sbin/ifconfig</c> dovrebbe
		elencarvi altre interfacce di rete oltre a lo, come eth0:
		</p>
		
		<pre caption="/sbin/ifconfig per una scheda di rete funzionante">
		eth0    Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          		inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          		inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          		UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          		RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          		TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          		collisions:1984 txqueuelen:100
          		RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
		        Interrupt:11 Base address:0xe800
		</pre>
        
		<p>
		Potreste anche provare a pingare il server DNS del vostro ISP (che trovate in 
		<path>/etc/resolv.conf</path>) e un sito web a scelta, giusto per essere sicuri che i
		vostri pacchetti raggiungano la rete, la risoluzione dei nomi di dominio fatta dai DNS
		sia corretta, ecc.
		</p>
		
		<pre caption="Altri test della rete">
		# <i>ping -c 3 www.yahoo.com </i>
		</pre>
		
		<p>
		Riuscite ad utilizzare la vostra rete? In caso affermativo potete saltare il resto
		di questa sezione.
		</p>
      		</body>
    </section>
    
    <section>
      	<title>Configurazione di PPPoE</title>
      		<body>
        	<p>
		Assumendo che abbiate bisogno di PPPoE per connettervi ad Internet, il Live CD (in qualsiasi
		versione) è stato realizzato per rendervi le cose più facili includendo <c>rp-pppoe</c>.
		Usate lo script <c>adsl-setup</c> per configurare la vostra connessione. Vi verrà richiesto
		a quale interfaccia di rete è connesso il vostro modem adsl, i vostri username e password,
		l'indirizzo dei server DNS del vostro ISP e se avete bisogno di un firewall basilare o meno.
		</p>

		<pre caption="Configurare PPPoE">
		# <i> adsl-setup </i>
		# <i> adsl-start </i>
		</pre>
		
        	<p>
		Se qualcosa andasse storto, assicuratevi di aver digitato correttamente username e password
		dando un'occhiata al file <path>/etc/ppp/pap-secrets</path> o <path>/etc/ppp/chap-secrets</path>
		e assicuratevi di stare utilizzando la corretta interfaccia di rete.
      		</p>
		</body>
    </section>
    
    <section>
      <title>Configurazione automatica della rete</title>
      		<body>
       		<p>
		Se la configurazione automatica della vostra rete non è andata a buon fine, la via più semplice
		per configurarla è eseguire lo script <c>net-setup</c>:
		</p>	
		
		<pre caption="Script Net-Setup">
		# <i>net-setup eth0</i>
		</pre>
	
		<p>
		Naturalmente, se preferite, potete configurare la rete manualmente. Ciò verrà spiegato 
		in seguito.</p>
      		</body>
    </section>
    
    <section>
      <title>Configurazione manuale del DHCP</title>
      		<body>
        	<p>
		Configurare una rete usando DHCP è davvero semplice; se il vostro ISP non usa DHCP, passate al paragrafo
		seguente, relativo alla configurazione statica.
		</p>
		
		<pre caption="Configurazione di rete con DHCP">
		# <i>dhcpcd eth0</i>
		</pre>
        
		<note>
		Alcuni ISP richiedono di fornire un hostname. Per fare questo, aggiungete la flag 
		<c>-h nomemiohost</c> alla precedente riga di comando di dhcpcd.
		</note>
        
		<p>
		Se ricevete massaggi d'avviso da <e>dhcpConfig</e>, non preoccupatevi; gli errori sono
		per lo più estetici. Potete passare al successivo paragrafo sul testing della rete.
		</p>
      	</body>
    </section>
    
    <section>
      <title>Configurazione statica manuale</title>
      		<body>
        	<p>
		E' indispensabile configurare correttamente la rete per poter scaricare i sorgenti 
		necessari alla costruzione del sistema, così come è richiesta l'interfaccia localhost.
		Le informazioni necessarie sono illustrate nella prossima tabella.
		</p>

		<table>
		<tr><th>Informazione</th><th>Descrizione</th><th>Valore d'esempio</th></tr>
		<tr><ti>Indirizzo IP</ti>
		<ti>L'indirizzo IP che volete assegnare alla vostra scheda di rete</ti>
		<ti>192.168.1.2</ti></tr>
		<tr><ti>Indirizzo Broadcast</ti>
		<ti>L'indirizzo IP che trasmetterà in broadcast i pacchetti a tutti gli host della rete</ti>
		<ti>192.168.1.255</ti></tr>
		<tr><ti>Maschera di rete (Netmask)</ti>
		<ti>La maschera che è utilizzata insieme agli indirizzi IP per individuare quale parte di tali 
		indirizzi identifica la rete e quale l'host</ti>
		<ti>255.255.255.0</ti></tr>
		<tr><ti>Gateway</ti>
		<ti>L'indirizzo IP del computer che inoltrerà all'esterno i pacchetti non indirizzati alla rete
		locale (il più delle volte il computer che condivide la connessione internet)</ti>
		<ti>192.168.1.1</ti></tr>
		</table>
        
		<p>
		Digitate i seguenti comandi, rimpiazzando
		$IFACE con la vostra interfaccia di rete (solitamente <c>eth0</c>), 
		$IPNUM con il vostro indirizzo IP, 
		$BCAST con il vostro indirizzo di broadcast e
		$NMASK con la vostra maschera di rete.
		Per il comando <c>route</c>, sostituite	$GTWAY con il vostro gateway di default.
		</p>
		
		<pre caption="Configurazione statica della rete IP">
		# <i>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
		# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</i>
		</pre>
        	
		<p>
		Adesso è il momento di creare il file <path>/etc/resolv.conf</path>
		in modo tale che funzioni la risoluzione dei nomi di dominio (cercare siti Web/FTP per nome,
		anzichè attraverso un indirizzo IP).
		Potete usare <c>nano -w	/etc/resolv.conf</c> per creare <path>/etc/resolv.conf</path>. 
        	<c>nano</c> è un editor compatto e facile da usare.
		</p>
        	
		<p>
		Segue un esempio cui ispirarsi per la creazione del vostro file /etc/resolv.conf:
		</p>
	
		<pre caption="/etc/resolv.conf d'esempio">
		domain mydomain.com
		nameserver 10.0.0.1
		nameserver 10.0.0.2
		</pre>
        	
		<p>Sostituite <c>10.0.0.1</c> e <c>10.0.0.2</c> rispettivamente con l'indirizzo IP primario
		e secondario dei vostri server DNS (ndt, solitamente quelli forniti dal proprio ISP).
		</p>
      		</body>
    </section>
    
    <section>
      <title>Configurazione del Proxy</title>
      <body>
        	<p>
		Se siete all'interno di un proxy, potrebbe essere necessario configurare il vostro proxy
		prima di continuare. Per questo dovremo esportare alcune variabili per impostarlo correttamente.
		</p>
		
		<pre caption="Impostare un Proxy">
		<comment>Se il proxy limita il traffico HTTP:</comment>
		# <i>export http_proxy="http://machine.company.com:1234"</i>
		<comment>Se il proxy limita il traffico FTP:</comment>
		# <i>export ftp_proxy="ftp://machine.company.com"</i>
		<comment>Se il proxy limita il traffico RSYNC:</comment>
		# <i>export RSYNC_PROXY="rsync://machine.company.com"</i>
		</pre>

	      </body>
    </section>
    
    <section>
      <title>La rete funziona!</title>
      		<body>
        	<p>
		La rete dovrebbe ora essere configurata ed utilizzabile. Dovreste essere in grado di usare
		i comandi <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> e <c>wget</c> per connettervi 
		ad altre macchine nella vostra LAN o ad Internet.
      		</p>
		</body>
    </section>
</chapter>

<chapter>
    <title>Impostare la data e l'ora del vostro sistema</title>
    <section>
      	<body>
        	<p>
		E' necessario ora impostare la data e l'ora del vostro sistema. 
		Potete farlo servendovi del comando <c>date</c>.
		</p>

		<pre caption="Impostare la data del vostro sistema">
		# <i>date</i>
		Thu Feb 27 09:04:42 CST 2003
		<comment>(Se la vostra data è sbagliata, correggetela con il seguente comando)</comment>
		# <i>date 022709042003</i>
		<comment>(date MMDDhhmmCCYY) (ndt, MM=mese DD=giorno hh=ora mm=minuti CCYY=anno)</comment>
		</pre>
      </body>
    </section>
</chapter>

<chapter>
    <title>Filesystems, partizioni e dispositivi a blocchi</title>
    <section>
		<title>Introduzione ai dispositivi a blocchi</title>
      <body>
		<p>
		In questa sezione daremo un'occhiata approfondita agli aspetti relativi ai dischi in
		Gentoo Linux e Linux in generale, includendo i filesystems Linux, le partizioni e i dispositivi
		a blocchi. Quindi, una volta che avrete acquisito familiarità con i dischi e i filesystems,
		verrete guidati attraverso il processo di configurazione delle partizioni e dei filesystem per
		la vostra installazione di Gentoo Linux.
		</p>
		
		<p>
		Per cominciare, introduciamo i "dispositivi a blocchi". Il dispositivo a blocchi più famoso
		è molto probabilmente quello che rappresenta la prima unità IDE in un sistema Linux:
		</p>
		
		<pre caption="/dev/hda, il dispositivo a blocchi che rappresenta il disco master sul primo canale IDE
		del vostro sistema">
		/dev/hda
		</pre>

		<p>
		Se il vostro sistema utilizza dischi SCSI, allora il vostro primo disco fisso dovrebbe essere:
		</p>

		<pre caption="/dev/sda, il dispositivo a blocchi che rappresenta il primo disco logico SCSI del vostro
		sistema">
		/dev/sda
		</pre>

		<p>
		I dispositivi a blocchi citati in precedenza rappresentano un'interfaccia <e>astratta</e> ai dischi.
		I programmi utente possono utilizzare questi dispositivi a blocchi per interagire con i
		vostri dischi senza doversi chiedere se si tratta di unita IDE, SCSI o di qualsiasi altro tipo.
		Il programma può semplicemente indirizzare la memorizzazione su disco attraverso dei blocchi contigui,
		accessibili casualmente e di dimensione pari a 512 byte ciascuno.
		</p>
	</body>
       </section>
	
       <section>
		<title>Partizioni e fdisk</title>
	<body>
		<p> 
		In Linux, possiamo creare filesystems utilizzando un comando speciale chiamato
		<c>mkfs</c> (o <c>mke2fs</c>, <c>mkreiserfs</c>, ecc.) specificando un particolare
		dispositivo a blocchi come argomento a linea di comando.
		</p>

		<p>
		Nonostante sia teoricamente possibile utilizzare il dispositivo a blocchi
		"dell'intero disco" (cioè quello che rappresenta l'<e>intero</e> hard disk) come
		<path>/dev/hda</path> o <path>/dev/sda</path> per allocare un singolo filesystem, nella pratica
		non ci si serve mai di tale metodo. Al contrario, l'intero dispositivo a blocchi rappresentante il
		disco viene suddiviso in parti più piccole, dispositivi a blocchi più maneggevoli chiamati
		"partizioni". Le partizioni vengono create utilizzando un tool chimato <c>fdisk</c>, che serve
		per creare e modificare la tabella delle partizioni scritta su ciascun disco. La tabella delle
		partizioni definisce con precisione come è stato suddiviso l'intero disco.
		</p>

		<p>
		Possiamo dare un'occhiata alla tabella delle partizioni di un disco eseguendo <c>fdisk</c>,
		specificando come argomento un dispositivo a blocchi che rappresenti un disco intero:
		</p>

		<note>
		Esistono interfacce alternative per visualizzare la tabella delle partizioni, quali <c>cfdisk</c>,
		<c>parted</c> e <c>partimage</c>. Noi raccomandiamo <c>fdisk</c> poichè nel mondo 
		Unix/Linux è certamente il più potente e conosciuto. 
		</note>

		<pre caption="Avviare fdisk">
		# <i>fdisk /dev/hda</i> 
		</pre>
		
		<p>
		o
		</p>
		
		<pre caption="Avviare fdisk per vedere la tabella delle partizioni di /dev/sda">
		# <i>fdisk /dev/sda</i>
		</pre>

		<impo>
		<b>Si noti che <e>non</e> si dovrebbe salvare o modificare in alcun modo la tabella delle
		partizioni di un disco se ognuna delle sue partizioni contiene un filesystem in uso o 
		contiene dati importanti. In caso contrario si causerà generalmente la perdita dei dati sul
		disco.</b>
		</impo>

		<p>
		Una volta avviato <c>fdisk</c>, dovreste vedere un prompt che assomiglia a questo:
		</p>
	
		<pre caption="Il prompt di fdisk">
		Command (m for help): 
		</pre>

		<p>
		Digitate <c>p</c> per visualizzare la configurazione corrente delle partizioni del vostro disco:
		</p>

		<pre caption="Un esempio di configurazione delle partizioni">
		Command (m for help): <i>p</i>

		Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
		Units = cylinders of 15120 * 512 bytes

		Device Boot    Start       End    Blocks   Id  System
		/dev/hda1             1        14    105808+  83  Linux
		/dev/hda2            15        49    264600   82  Linux swap
		/dev/hda3            50        70    158760   83  Linux
		/dev/hda4            71      2184  15981840    5  Extended
		/dev/hda5            71       209   1050808+  83  Linux
		/dev/hda6           210       348   1050808+  83  Linux
		/dev/hda7           349       626   2101648+  83  Linux
		/dev/hda8           627       904   2101648+  83  Linux
		/dev/hda9           905      2184   9676768+  83  Linux

		Command (m for help): 
		</pre>

		<p> 
		Questo disco in particolare è configurato per contenere sette filesystems Linux (ciascuno
		corrispondente ad un partizione elencata come "Linux") oltre ad una partizione di swap
		(elencata come "Linux swap").
		</p>

		<p>
		Notate il nome della corrispondente partizione del dispositivo a blocchi nella colonna di sinistra,
		che inizia con <path>/dev/hda1</path> e termina con <path>/dev/hda9</path>. Agli albori dell'era dei PC, il
		software di partizionamento poteva abilitare soltanto un massimo di quattro partizioni (chiamate
		"partizioni primarie"). Questo divenne presto un limite, quindi venne creata una soluzione chiamata
		<e>partizionamento esteso</e>. Una partizione estesa è davvero molto simile ad una partizione 
		primaria e viene contata nel numero limite di quattro partizioni primarie. Tuttavia, una partizione
		estesa può contenere al suo interno un qualsiasi numero di partizioni definite <e>logiche</e>, 
		fornendo così un metodo pratico per aggirare il limite di quattro partizioni primarie.
		</p>

		<p>
		Tutte le partizioni da <path>/dev/hda5</path> in poi sono partizioni logiche. I numeri tra 1 e 4 sono
		riservati per le partizioni primarie o quelle estese
		</p>

		<p>
		Così, nel nostro esempio, da <path>/dev/hda1</path> a <path>/dev/hda3</path> abbiamo partizioni primarie.
		<path>/dev/hda4</path> è una partizione estesa che contiene le partizioni logiche da
		<path>/dev/hda5</path> fino a <path>/dev/hda9</path>. Non dovrete quindi mai <e>utilizzare</e> 
		<path>/dev/hda4</path> per memorizzare direttamente un qualsiasi filesystem -- serve semplicemente
		per contenere le partizioni tra <path>/dev/hda5</path> e <path>/dev/hda9</path>.  
		</p>

		<p>
		Notate inoltre che ogni partizione possiede un "Id", chiamato anche "tipo di partizione".
		Quando creerete una nuova partizione, dovrete assicurarvi che il tipo di partizione sia 
		impostato correttamente. '83' è il tipo di partizione corretto per contenere un filesystem Linux,
		'82' è il tipo di partizione corretto per la partizione Linux di swap e 'fd' è il tipo di
		partizione raccomandata per le partizioni Software RAID. Potete impostare il tipo di partizione 
		usando l'opzione <c>t</c> in <c>fdisk</c>. Il kernel Linux utilizza il tipo di partizione
		impostato per rilevare automaticamente all'avvio i filesystems e il dispositivo di swap dei vari
		dischi.
		</p>
	</body>
       </section>

       <section>
		<title>Usare fdisk per impostare le partizioni</title>
	<body>

		<p>
		Ora che avete avuto la vostra introduzione ai metodi di partizionamento in ambiente Linux,
		è il momento di passare in rassegna il processo di creazione delle partizioni per 
		l'installazione del vostro sistema Gentoo Linux. Una volta che avremo concluso tale processo
		di partizionamento del disco, la vostra configurazione dovrebbe apparire simile alla seguente:
		</p>
	
		<pre caption="La configurazione delle partizioni che dovreste avere dopo aver seguito questi passi">
		Disk /dev/hda: 30.0 GB, 30005821440 bytes
		240 heads, 63 sectors/track, 3876 cylinders
		Units = cylinders of 15120 * 512 = 7741440 bytes
		
		   Device Boot    Start       End    Blocks   Id  System
		/dev/hda1   *         1        14    105808+  83  Linux
		/dev/hda2            15        81    506520   82  Linux swap
		/dev/hda3            82      3876  28690200   83  Linux

		Command (m for help):
		</pre>

		<p>
		Nella nostra configurazione delle partizioni per "newbie" (ndt, nuovi utenti, principianti), 
		ci sono tre partizioni. La prima (<path>/dev/hda1</path>) si trova all'inizio del disco ed è una piccola
		partizione chiamata partizione di boot. Lo scopo della partizione di boot è contenere tutti
		i dati critici relativi all'avvio del sistema -- informazioni del boot loader GRUB (se state
		utilizzando GRUB) come pure i vostri kernel Linux. La partizione di boot vi fornisce un luogo 
		sicuro per immagazzinare tutto ciò che è legato al processo di avvio di un sistema Linux. 
		Durante il normale uso quotidiano di Gentoo Linux, la vostra partizione di boot dovrà rimanere 
		<e>unmounted</e> (ndt, smontata) per motivi di sicurezza. Se state configurando un sistema SCSI,
		la vostra partizione di boot dovrebbe possibilmente essere <path>/dev/sda1</path>.
		</p> 

		<p>
		Si raccomanda di avere la partizione di boot (contenente tutto il necessario per il funzionamento
		del boot loader) all'inizio del disco. Benchè questo non sia più un requisito necessario,
		si tratta comunque di un'utile tradizione relativa ai tempi in cui il boot loader Lilo non era
		in grado di caricare il kernel da filesystems situati oltre il cilindro 1024 di un disco.
		</p>

		<p>
		La seconda partizione (<path>/dev/hda2</path>) è utilizzata come spazio di swap (ndt, scambio).
		Il kernel usa lo spazio di swap come memoria virtuale quando la RAM scarseggia. Questa partizione,
		parlando approssimativamente, non dovrebbe essere molto grande, tipicamente dell'ordine dei 512MB circa.
		Se state configurando un sistema SCSI, questa partizione dovrebbe chiamarsi <path>/dev/sda2</path>.  
		</p>

		<p>
		La terza partizione (<path>/dev/hda3</path>) è generalmente ampia e occupa il resto dello spazio
		su disco. Questa partizione è chiamata partizione "root" (ndt, radice) e verrà utilizzata per
		memorizzare al suo interno il filesystem principale che ospiterà il vostro sistema Gentoo Linux.
		In un sistema SCSI, questa partizione verrà probabilmente rappresentata da <path>/dev/sda3</path>.
		</p>

		<p>
		Prima di partizionare il disco, facciamo una rapida recensione tecnica delle partizioni suggerite
		e della configurazione del filesystem da utilizzare per installare Gentoo Linux:
		</p>

		<table>
		<tr>
		<th>Partizione</th>
		<th>Dimensione</th>
		<th>Tipo</th>
		<th>Dispositivo d'esempio</th>
		</tr>
		<tr>
		<ti>partizione di boot, contiene i(l) kernel e le informazioni di boot</ti>
		<ti>32 Megabytes</ti>
		<ti>ext2/3 sono caldamente raccomandati (più semplici); se usate ReiserFS montate la partizione 
		con l'opzione <c>-o notail</c>. Se volete usare ext3 o ReiserFS, dovete aggiungere la dimensione
		del journal (ndt, giornale) alla dimensione originale della partizione; in questo caso si raccomandano
		64 Megabytes</ti>
		<ti><path>/dev/hda1</path></ti>
		</tr>
		<tr>
		<ti>partizione di swap (non c'è più il limite di 128 Megabyte, ora di 2GB)</ti>
		<ti>Generalmente, si configura l'area di swap con una dimensione compresa tra una e due volte
		la dimensione della RAM fisica del proprio sistema
		</ti>
		<ti>Linux swap</ti>
		<ti><path>/dev/hda2</path></ti>
		</tr>
		<tr>
		<ti>partizione root, contiene il filesystem principale (/usr, /home, etc.)</ti>
		<ti>&gt;=1.5 Gigabytes</ti>
		<ti>ReiserFS, ext3 raccomandati; ext2 ok</ti>
		<ti><path>/dev/hda3</path></ti>
		</tr>
		</table>	

		<p>
		Ok, ora per creare le partizioni seguiamo l'esempio e la tabella precedenti.
		Prima di tutto, entriamo in fdisk digitando <c>fdisk /dev/hda</c> o <c>fdisk /dev/sda</c>,
		a seconda che stiate usando un disco IDE o SCSI. Quindi, digitiamo <c>p</c> per vedere
		la configurazione attuale delle partizioni. Sono presenti su questo disco informazioni che 
		vorreste mantenere? Se si, <b>fermatevi ora</b>. Se continuate in questa direzione, <b>tutti
		i dati esistenti sul vostro disco saranno cancellati</b>.
		</p>

		<impo>
		Seguire le istruzioni qui sotto porterà alla <b>cancellazione</b> di tutti i dati preesistenti
		sul vostro disco! Se sono presenti dati sul vostro disco, per favore assicuratevi che non siano
		informazioni critiche che non volete assolutamente perdere. Assicuratevi inoltre di <b>aver scelto
		il dispositivo corretto</b> in modo da non eliminare erroneamente i dati dal disco sbagliato.
		</impo>

		<p>
		Adesso è il momento di eliminare tutte le partizioni esistenti. Per fare ciò, digitate
		<c>d</c> e premete Invio. Dovrete a questo punto iserire al prompt il numero della partizione
		che volete eliminare. Per cancellare una preesistente <path>/dev/hda1</path>, dovete digitare:</p>

		<pre caption="Cancellare una partizione">
		Command (m for help): <i>d</i>
		Partition number (1-4): <i>1</i>
		</pre>

		<p>
		La partizione è quindi programmata per la cancellazione. Non sarà più visibile se premete
		<c>p</c>, ma non verrà cancellata finchè le vostre modifiche non verranno salvate.
		Se avete commesso qualche errore e volete abortire i vostri cambiamenti senza salvare,
		digitate <c>q</c> immediatamente e premete Invio, così la vostra partizione non verrà eliminata.
		</p>
		
		<p>
		Ora, supponendo che siate effettivamente intenzionati a cancellare ogni partizione dal vostro
		sistema, digitate ripetutamente <c>p</c> per vedere la lista delle partizioni e quindi <c>d</c>
		seguito dal numero della partizione da cancellare.
		Finalmente, vi ritroverete con una tabella delle partizioni vuota:
		</p>
	
		<pre caption="Una tabella delle partizioni vuota">
		Disk /dev/hda: 30.0 GB, 30005821440 bytes
		240 heads, 63 sectors/track, 3876 cylinders
		Units = cylinders of 15120 * 512 = 7741440 bytes
		
		   Device Boot    Start       End    Blocks   Id  System
		
		Command (m for help):
		</pre>	

		<p>
		Ora che la tabella delle partizioni in memoria è vuota, siamo pronti per creare
		una partizione di boot. Per fare questo, digitate <c>n</c> per creare una nuova partizione,
		quindi <c>p</c> per avvertire fdisk che volete una partizione primaria. Digitate adesso
		<c>1</c> per creare la prima partizione primaria. Quando vi apparirà il prompt per
		il primo cilindro, premete Invio. Quando vi verrà mostrato il prompt per l'ultimo cilindro,
		digitate <c>+32M</c> per creare una partizione della dimensione di 32MB.
		Dovreste poter vedere l'output di questi comandi come segue:
		</p>

		<note>
		I filesystems journaled richiedono uno spazio extra per il loro journal. Le impostazioni
		di default richiedono circa 32 Megabytes di spazio. Per questo, se state utilizzando un 
		filesystem journaled per <path>/boot</path>, dovrete digitare <c>+64M</c> quando vi apparirà
		il prompt per l'ultimo cilindro.
		</note>

		<pre caption="Passi per creare la partizione di boot">
		Command (m for help): <i>n</i>
		Command action
		   e   extended
		   p   primary partition (1-4)
		p
		Partition number (1-4): <i>1</i>
		First cylinder (1-3876, default 1):<comment>(Premere Invio)</comment>
		Using default value 1
		Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
		</pre>

		<p>
		Ora, quando digiterete <c>p</c>, dovreste vedere apparire il seguente output per le partizioni:</p>

		<pre caption="La prima partizione è stata creata">
		Command (m for help): <i>p</i>
		
		Disk /dev/hda: 30.0 GB, 30005821440 bytes
		240 heads, 63 sectors/track, 3876 cylinders
		Units = cylinders of 15120 * 512 = 7741440 bytes
		
		   Device Boot    Start       End    Blocks   Id  System
		/dev/hda1             1        14    105808+  83  Linux
		</pre>

		<p>
		Adesso andiamo a creare la prtizione di swap. Per fare ciò, digitate <c>n</c> 
		per creare una nuova partizione, quindi <c>p</c> per avvertire fdisk che volete una partizione
		primaria. A questo punto digitate <c>2</c> per creare la seconda partizione primaria, <path>/dev/hda2</path>
		nel nostro caso.
		Quando vedrete il prompt per il primo cilindro, premete Invio. Quando apparirà quello per
		l'ultimo cilindro, digitate <c>+512M</c> per creare una partizione di dimensione pari a 512MB.
		Dopo aver fatto tutto questo, digitate <c>t</c> per impostare il tipo di partizione, <c>2</c> 
		per selezionare la partizione appena creata e quindi digitate <c>82</c> per impostare il tipo di
		partizione a "Linux Swap". Ultimati questi passaggi, premete <c>p</c> per visualizzare la
		tabella delle partizioni che apparirà simile alla seguente:</p>

		<pre caption="La partizione di swap è stata creata">
		Command (m for help): <i>p</i>
		
		Disk /dev/hda: 30.0 GB, 30005821440 bytes
		240 heads, 63 sectors/track, 3876 cylinders
		Units = cylinders of 15120 * 512 = 7741440 bytes

		   Device Boot    Start       End    Blocks   Id  System
		/dev/hda1             1        14    105808+  83  Linux
		/dev/hda2            15        81    506520   82  Linux swap
		</pre>

		<p>
		Infine, creiamo la partizione root. Per fare questo, digitate <c>n</c> per creare
		una nuova partizione, quindi <c>p</c> per avvertire fdisk che vogliamo una partizione 
		primaria. Adesso digitate <c>3</c> per creare la terza partizione primaria,
		<path>/dev/hda3</path> nel nostro caso. Quando vi apparirà il prompt per il primo cilindro,
		premete Invio. Quando avrete quello per l'ultimo cilindro, premete Invio per creare una 
		partizione che occupi tutto lo spazio rimanente sul vostro hard disk.
		Dopo avere eseguito questi passi, digitate <c>p</c> per visualizzare la tabella delle
		partizioni, che ora apparirà simile alla seguente:
		</p>
		
		<pre caption="La partizione root è stata creata">
		Command (m for help): <i>p</i>

		Disk /dev/hda: 30.0 GB, 30005821440 bytes
		240 heads, 63 sectors/track, 3876 cylinders
		Units = cylinders of 15120 * 512 = 7741440 bytes
		
		   Device Boot    Start       End    Blocks   Id  System
		/dev/hda1             1        14    105808+  83  Linux
		/dev/hda2            15        81    506520   82  Linux swap
		/dev/hda3            82      3876  28690200   83  Linux
		</pre>
		
		<p>
		Per concludere, dobbiamo impostare la flag "bootable" (ndt, avviabile) per la nostra partizione di 
		boot e quindi scrivere tutti i cambiamenti sul disco. Per rendere <path>/dev/hda1</path>
		una partizione "bootable", digitate <c>a</c> nel menu e quindi
		premete <c>1</c> per il numero della partizione. Se ora digitate <c>p</c>, dovreste
		vedere che <c>/dev/hda1</c> possiede un <c>*</c> nella colonna "Boot".
		Adesso andiamo a scrivere i nostri cambiamenti sul disco. Per fare questo, digitate
		<c>w</c> e premete Invio. Le vostre partizioni del disco sono ora adeguatamente configurate
		per un'installazione di Gentoo Linux.
		</p>

		<note>Se <c>fdisk</c> o <c>cfdisk</c> vi dicono di farlo, per favore riavviate il sistema 
		per permettergli di identificare correttamente la nuova configurazione delle partizioni.
		</note>
	</body>
       </section>

       <section>
		<title>Creare i filesystems</title>
	<body>
		<p>
		Ora che le partizioni sono state create, è il momento di impostare i filesystem sulle
		partizioni di boot e root in modo tale che possano essere montate e usate per la 
		memorizzazione dei dati. Configureremo anche la partizione di swap affinchè funga da
		memoria di scambio.
		</p>

		<p>
		Gentoo Linux supporta una grande varietà di tipi differenti di filesystem; ciascuno di loro
		possiede i propri punti di forza e le proprie debolezze, oltre ad un proprio insieme di 
		caratteristiche relative alle performance. Attualmente, supportiamo la creazione di filesystem
		ext2, ext3, XFS, JFS e ReiserFS.
		</p>

		<p>
		ext2 è il vero e proprio filesystem di Linux ma non possiede il supporto per il 
		"metadata journaling", il che significa che le routine che effettuano all'avvio i controlli
		sul filesystem ext2 possono occupare diverso tempo. C'è adesso una scelta abbastanza ampia
		di filesystem <e>journaled</e> di nuova generazione che sono in grado di effettuare controlli 
		sulla consistenza molto velocemente e sono generalmente preferiti alle controparti non-journaled.
		I filesystem journaled prevengono i lunghi tempi di attesa che solitamente si riscontrano
		quando viene riavviato il sistema e il filesystem si trova in uno stato <e>inconsistente</e>.
		</p>

		<p>
		ext3 è la versione journaled del filesystem ext2, fornisce il "metadata journaling"
		per un veloce recupero dei dati in aggiunta ad altre caratteristiche di journaling avanzate 
		come "full data" e "ordered data journaling". 
		ext3 è un filesystem davvero molto valido e affidabile. Offre generalmente performance
		accettabili in molte situazioni. Poichè non fa un uso estensivo di "trees" nel proprio design interno, 
		non è in grado di scalare molto bene, il che significa che non rappresenta una scelta 
		ideale per filesystem molto grandi o situazioni in cui è necessario manipolare grandi quantità
		di dati o file molto grandi in una singola directory. Ma se usato in condizioni che sfruttino
		le caratteristiche di design per cui è stato creato, ext3 è un eccellente filesystem. 
		</p>
	
		<p>
		ReiserFS è un filesystem basato su B*-tree che offre ottime performance generali e
		si dimostra notevolmente superiore a ext2 e ext3 con file di piccole dimensioni (file minori
		di 4k), spesso di un fattore 10x-15x. ReiserFS scala inoltre molto bene e supporta il metadata
		journaling. Dal kernel 2.4.18+, ReiserFS ha raggiunto la solidità che lo porta a essere
		caldamente raccomandato sia per un uso generico che per casi estremi come la creazione di grandi
		filesystem, l'uso su molti file piccoli, file molto grandi e directory contenenti decine di migliaia
		di file. ReiserFS è il filesystem che raccomandiamo di default per tutte le partizioni che
		non siano quella di boot.
		</p>

		<p>
		XFS è un filesystem con tecnologia metadata journaling che è completamente supportato
		in Gentoo Linux dal kernel <c>xfs-sources</c>. Si presenta con un robusto insieme di
		caratteristiche ed è ottimizzato per la scalabilità. Ne raccomandiamo l'uso su sistemi Linux
		con high-end SCSI e/o unità di memorizzazione con canali in fibra e connessi a UPS. Data 
		l'aggressività con la quale XFS si serve della cache in RAM per i dati in transito, 
		programmi progettati in modo non adeguato (quelli che non prendono precauzioni quando scrivono 
		file su disco, e ce ne sono abbastanza) possono perdere una discreta quantità di dati se il 
		sistema si arresta in modo inaspettato.
		</p>  

		<p>
		JFS è il filesystem journaling ad alte prestazioni di IBM. E' stato recentemente giudicato pronto per
		il mercato, ma ad oggi non è stato sufficientemente testato per fare commenti positivi o negativi
		sulla sua stabilità generale.
		</p>

		<p>
		Se state cercando il filesystem journaled più robusto, usate ext3. Se state invece cercando
		un filesystem ad alte prestazioni con il supporto al journaling, usate ReiserFS; sia ext3 che
		ReiserFS sono maturi, raffinati e raccomandati per un uso generale.
		</p>

<!-- Corner case, confusing
		<p>
		Ma prima di creare i filesystems, se state usando partizioni preesistenti, già utilizzate in 
		precedenza, potreste voler azzerare la parte inziale della vostra partizione utilizzando 
		<c>dd</c>.
		Ciò risulta particolarmente utile quando state per creare un nuovo filesystem XFS in una
		partizione che precedentemente conteneva un filesystem ReiserFS. Fare ciò vi assicurerà
		che il nuovo filesystem non venga mal identificato dal codice di auto-identificazione dei
		filesystems di Linux. Questo può essere fatto come segue:	
		</p>
		
		<pre caption="Inizializzare i primi 1024 bytes di una partizione">
		# <c>dd if=/dev/zero of=/dev/hda3 bs=1k count=1</c>
		<comment>(Sostituite /dev/hda3 con la partizione che volete &quot;pulire.&quot;)</comment>
		</pre>
	
		<warn>
		Il comando precedente distruggerà tutti i dati di <path>/dev/hda3</path>. 
		Fate attenzione e controllate due volte quale partizione avete specificato per
		l'azzeramento. Se fate un errore potreste provocare la perdita di dati.
		</warn>
-->

		<p>
		In base al nostro esempio precedente, useremo i seguenti comandi per inizializzare tutte le nostre
		partizioni:</p>

		<pre caption="Inizializzare le partizioni (esempio)">
		# <i>mke2fs -j /dev/hda1</i>
		# <i>mkswap /dev/hda2</i>
		# <i>mkreiserfs /dev/hda3</i>
		</pre>

		<p>
		Abbiamo scelto ext3 per la partizione di boot <path>/dev/hda1</path> perché si tratta
		di un robusto filesystem con il journaling supportato dalla maggior parte dei boot 
		loaders. Abbiamo usato <c>mkswap</c> per la partizione di swap <path>/dev/hda2</path> -- qui la
		scelta è ovvia. Per il nostro filesystem principale root <path>/dev/hda3</path> abbiamo scelto
		ReiserFS, dato che è un solido filesystem journaled che offre eccellenti performance. 
		Ora andate avanti e inizializzate le vostre partizioni.
		</p>
		
		<p>
		Come vostro riferimento, ecco i vari comandi <c>mkfs</c>-like disponibili durante il processo
		di installazione:
		</p>

		<p>
		<c>mkswap</c> è il comando che va usato per inizializzare le partizioni di swap:
		</p>		
		
		<pre caption="Inizializzare la Swap">
		# <i>mkswap /dev/hda2</i>
		</pre>
		
		<p>
		Potete usare il comando <c>mke2fs</c> per creare un filesystem ext2:
		</p>
		
		<pre caption="Creare un filesystem ext2">
		# <i>mke2fs /dev/hda1</i>
		</pre>
		
		<p>
		Se preferite utilizzare ext3, potete creare un filesystem ext3 usando
		<c>mke2fs -j</c>:
		</p>
		
		<pre caption="Creare un filesystem ext3">
		# <i>mke2fs -j /dev/hda3</i>
		</pre>
	        
		<note>
		Potete trovare maggiori informazioni circa l'uso di ext3 in Linux 2.4 su
		<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
		</note>
	        
		<p>
		Per creare un filesystem ReiserFS, usate il comando <c>mkreiserfs</c>:
		</p>
		
		<pre caption="Creare un filesystem ReiserFS">
		# <i>mkreiserfs /dev/hda3</i>
		</pre>
	        
		<p>
		Per creare un filesystem XFS, usate il comando <c>mkfs.xfs</c>:
		</p>
		
		<pre caption="Creare un filesystem XFS">
		# <i>mkfs.xfs /dev/hda3</i>
		</pre>
        	
		<note>
		Potreste voler aggiungere un paio di flag facoltative al comando <c>mkfs.xfs</c>:
		<c>-d agcount=3 -l size=32m</c>. 
		Il comando <c>-d agcount=3</c> abbassa il numero dei gruppi di allocazione. XFS insiste
		ad usare almeno 1 gruppo di allocazione per ogni 4 GB di partizione, così, per esempio, se
		avete una partizione di 20 GB avrete bisogno di almeno 5 gruppi (agcount).
		Il comando <c>-l size=32m</c> porta a 32 MB la grandezza del journal, incrementando le performance.
		</note>

		<p>
		Per creare un filesystem JFS, usate il comando <c>mkfs.jfs</c>:
		</p>
		
		<pre caption="Creare un filesystem JFS">
		# <i>mkfs.jfs /dev/hda3</i>
		</pre>
      </body>
    </section>
</chapter>

<chapter>
    	<title>Montare le partizioni</title>
      <section>
	<body>
        	<p>
		Ora è il momento di attivare la nostra nuova partizione di swap, poichè in seguito avremo
		certamente bisogno della memoria virtuale aggiuntiva che essa ci fornirà:
		</p>
		
		<pre caption="Attivare la Swap">
		# <i>swapon /dev/hda2</i>
		</pre>

        	<p>
		Successivamente, andremo a creare i "mount points" (ndt, punti di montaggio, di innesto)
		<path>/mnt/gentoo</path> e <path>/mnt/gentoo/boot</path>, quindi vi monteremo i nostri filesystem.
		Una volta che i nostri filesystem di boot e root saranno montati, qualsiasi file copieremo o
		creeremo all'interno di <path>/mnt/gentoo</path> verrà sistemato nei nostri nuovi filesystems.
		Notate che nel caso abbiate deciso di creare per il vostro sistema Gentoo Linux <path>/usr</path>
		o <path>/var</path> come filesystem separati, dovrebbero essere rispettivamente montati in
		<path>/mnt/gentoo/usr</path> e <path>/mnt/gentoo/var</path>.
		</p>
 
		<impo>
		Se la vostra partizione <path>/boot</path> (quella in cui risiede il kernel) è ReiserFS, dovrete 
		essere sicuri di montarla con l'opzione <c>-o notail</c> in modo tale che GRUB possa essere
		installato correttamente. Assicuratevi che <c>notail</c> termini la riga riferita alla
		partizione di boot in <path>/etc/fstab</path>. Ritorneremo brevemente su questo punto.
		Se state utilizzando LILO con ReiserFS, allora l'opzione <c>-o notail</c> non è necessaria.
		E' comunque consentito specificare l'opzione <c>-o notail</c> con ReiserFS se siete incerti 
		sul da farsi.
		</impo>

		<pre caption="Creare i Mount Points (punti di montaggio, innesto)">
		# <i>mount /dev/hda3 /mnt/gentoo</i>
		# <i>mkdir /mnt/gentoo/boot</i>
		# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
		</pre>

                <impo>
		Se riscontrate problemi nel montare la vostra partizione di boot con ext2, provate utilizzando
		<c>mount /dev/hXX /mnt/gentoo/boot -t ext2</c>
		</impo>
	</body>
      </section>
</chapter>

<chapter>
	<title>I tarballs degli Stage e il chroot</title>
    <section>
	<title>Scegliere il tarball dello stage desiderato</title>
	<body>
		<p>
		Adesso, se non lo avete già fatto, dovete decidere quale tarball volete utilizzare come
		base per la vostra installazione. Gli stages presenti nel Live CD si trovano in
		<path>/mnt/cdrom/stages/</path> e potete digitare <c>ls	/mnt/cdrom/stages/</c>
		per vedere quali sono disponibili sul vostro CD.
		</p>

		<p>
		<b>Gli utenti della GRP</b> dovrebbero utilizzare il tarball <path>stage3-xx-yy.tar.bz2</path>.
		</p>
	
		<p>
		Se avete scelto di eseguire l'installazione servendovi del tarball di uno stage che <i>non</i> è 
		presente sul vostro CD (potrebbe essere il caso in cui stiate utilizzando il nostro Live CD "basic"),
		è comunque possibile procedere, ma avrete bisogno di scaricare lo stage che volete utilizzare
		seguendo le seguenti istruzioni. Se invece già possedete il tarball dello stage che volete usare
		(la maggior parte degli utenti lo possiede), allora procedete con la sezione
		"Decomprimere il tarball dello stage"
		</p>

		<pre caption="Scaricare lo Stages desiderato">
		# <i>cd /mnt/gentoo</i>
		<comment>Usate lynx per ottenere l'URL del vostro tarball:</comment>
		# <i>lynx http://gentoo.oregonstate.edu/releases/x86/1.4/</i>
		<comment>Usate i tasti freccia <c>Su</c> e <c>Giù</c> (o il tasto <c>TAB</c>) per
		andare nella directory corretta selezionando lo stage appropriato che volete scaricare.
		Premete <c>d</c> quando volete iniziare il download. Salvate il file e uscite dal browser.
		<b>O</b> utilizzate wget dalla linea di comando:</comment>
		# <i>wget <comment>inserite qui l'URL del tarball con lo stage che volete scaricare.</comment></i>
		</pre>
	</body>
     </section>
     
     <section>
		<title>Decomprimere il tarball dello stage</title>
	<body>

		<p>
		E' ora il momento di estrarre in <path>/mnt/gentoo</path> il tarball compresso dello stage
		che avete scelto. Ricordatevi che dovete estrarre soltanto <b>un</b> tarball, uno
		tra stage1, stage2 e stage3. Quindi, se avete intenzione di installare Gentoo partendo
		dallo stage3, dovrete estrarre solamente il tarball dello stage3.
		Decomprimete il tarball dello stage come segue:
		</p>

		<impo>Assicuratevi di usare l'opzione <c>p</c> con <c>tar</c>.  Dimenticarsene può portare
		ad avere permessi errati per alcuni file. 
		</impo>

		<pre caption="Decomprimere uno Stage">
		# <i>cd /mnt/gentoo</i>
		<comment>Cambiate "stage3" in "stage2" o "stage1" se volete partire con uno di questi stage.</comment>
		<comment>Se avete scaricato il vostro tarball dello stage, cambiate il percorso (path) che segue 
		in modo che inizi con "/mnt/gentoo/" al posto di "/mnt/cdrom/stages/".</comment>
		# <i>tar -xvjpf /mnt/cdrom/stages/stage3-*.tar.bz2</i>
		</pre>

		<p>
		Se avete scaricato il vostra tarball dello stage in <path>/mnt/gentoo</path>, potete ora
		cancellarlo digitando il comando <c>rm /mnt/gentoo/stage*.tar.bz2</c>.
		</p>
	</body>
      </section>
      
      <section>
	<title>Passi relativi ai pacchetti/snapshot GRP</title>
	<body>
		<impo>Le istruzioni seguenti sono rivolte soltanto agli utenti della GRP.</impo>
		
		<p>
		<b>Utenti della GRP</b>: sul Live CD è presente uno snapshot di Portage. Potete
		utilizzare questo snapshot per evitare il passo successivo di questo documento, 
		<c>emerge sync</c>, visto che <c>emerge sync</c> richiede una connessione di rete.
		Decomprimete questo snapshot come segue:
		</p>
		
		<pre caption="Usare lo snapshot di Portage">
		<comment>Sostituite yyyymmdd con la data di creazione del file (ndt, file che trovate sul Live CD).</comment>
		# <i>tar -xvjf /mnt/cdrom/snapshots/portage-yyyymmdd.tar.bz2 -C /mnt/gentoo/usr</i>
		</pre>
		
		<p>
		Questo estrarrà uno snapshot del Portage Tree (ndt, in pratica il database degli script .ebuild
		necessari per installare i pacchetti in Gentoo) nella vostra nuova installazione Gentoo.
		Adesso non sarà più necessario connettersi ad Internet e utilizzare <c>emerge
		sync</c> per scaricare il Portage tree. Dovete ora copiare i distfiles e i pacchetti dal Live CD
		in questo modo:
		</p>

		<pre caption="Copiare i file GRP">
		# <i>cp -R /mnt/cdrom/distfiles /mnt/gentoo/usr/portage/distfiles</i>
		# <i>cp -a /mnt/cdrom/packages /mnt/gentoo/usr/portage/packages</i>
		</pre>

		<p>
		Tutti i file rilevanti sono ora al loro posto per poter utilizzare GRP. A questo punto
		dovreste avere a disposizione tutto ciò che potrebbe servirvi per installare Gentoo 
		Linux -- senza bisogno di una connessione di rete. 
		</p>

	</body>
      </section>
      
      <section>
	<title>Scegliere i mirror (Facoltativo)</title>
  	 <body>
  	 
  	 	<p>
  	 	<c>mirrorselect</c> è un tool studiato per scegliere automaticamente i mirror più veloci
		in base alla vostra locazione, oppure per scegliere manualmente un mirror da una lista.
  	 	Sfortunatamente, <c>mirrorselect</c> può non funzionare correttamente se si trova dietro un
		router.
  	 	</p>
  	 
  	 	<pre caption="Usare mirrorselect">
  	 	<comment>Per scegliere automaticamente un mirror:</comment>
  	 	# <i>mirrorselect -a -s4 -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
  	 	<comment>Per scegliere interattivamente un mirror:</comment>
  	 	# <i>mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
  	 	</pre>
  	 
  	 	<p>
		Se per qualche ragione <c>mirrorselect</c> non funzionasse potrete tranquillamente
		proseguire oltre in questa guida senza effettuare nessuna modifica.
  	 	</p>
  	 
  	 </body>
      </section>
      
      <section>
	<title>Entrare nel chroot</title>
	<body>
		<p>
		Il passo successivo sarà il <c>chroot</c> dell'ambiente di installazione, che ci
		permetterà di "entrare" nel nostro nuovo sistema Gentoo Linux.
		</p>
		
		<note>
		Durante l'esecuzione di <c>env-update</c> potreste essere avvisati che 
		<path>/etc/make.profile/make.defaults</path> non è disponibile: ignoratelo. Quando eseguirete
		<c>emerge sync</c> più avanti in questo documento, questo problema verrà risolto.
		</note>

		<pre caption="Preparazione e ingresso nell'ambiente chroot">
		# <i>mount -t proc proc /mnt/gentoo/proc</i>
		# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
		# <i>chroot /mnt/gentoo /bin/bash</i>
		# <i>env-update</i>
		Regenerating /etc/ld.so.cache...
		# <i>source /etc/profile</i>
		<comment>(I passi precedenti aggiornano i percorsi di ricerca e i binari della vostra shell)</comment>
		</pre>
		
	        <p>
		Dopo aver eseguito questi comandi, sarete "dentro" il vostro nuovo ambiente Gentoo Linux
		in <path>/mnt/gentoo</path>. Eseguiremo il resto dell'installazione all'interno del chroot.
		</p>
	</body>
      </section>
</chapter>

<chapter>
    <title>Ottenere il Portage tree corrente usando sync</title>
    <section>
	<body>
		<impo>
		Se state facendo un'installazione con GRP potete ignorare la seguente sezione relativa a 
		<c>emerge sync</c>.
		</impo>

		<p>
		Ora dovrete eseguire <c>emerge sync</c>. Questo comando dice a Portage di scaricare la
		copia più recente del Portage tree di Gentoo Linux da Internet. Se avete precedentemente
		estratto lo snapshot del Portage tree dal <e>CD 1</e>, potete tranquillamente saltare questo
		passaggio. Il Portage tree contiene tutti gli scripts (chiamati ebuild) usati per la 
		compilazione di ogni pacchetto in Gentoo Linux. Attualmente abbiamo script ebuild per
		più di 4000 pacchetti. Una volta che <c>emerge sync</c> avrà terminato il suo lavoro,
		avrete un completo Portage tree in <path>/usr/portage</path>.</p>

		<pre caption="Aggiornamento usando sync">
		# <i>emerge sync</i>
		</pre>
 
      </body>
    </section>
</chapter>

<chapter>
    <title>Impostare le ottimizzazioni di Gentoo (make.conf)</title>
    <section>
      <body>

		<p>
		Ora che state lavorando su una copia del Portage tree, è giunto il momento di
		personalizzare le ottimizzazioni e le impostazioni build-time opzionali da utilizzare
		nel vostro sistema Gentoo Linux. Portage userà queste impostazioni quando compilerà un
		qualsiasi programma per voi. Per fare questo, modificate il file <path>/etc/make.conf</path>.
		In questo file, dovrete impostare le vostre flag USE, che specificano quali funzionalità
		aggiuntive si vogliono includere nella compilazione dei pacchetti, se disponibili; generalmente,
		le impostazioni di default sono accettabili (una variabile USE <e>vuota</e> o non impostata).
		Maggiori informazioni sulle flag USE possono essere trovate
		<uri link="http://www.gentoo.org/doc/en/use-howto.xml">qui</uri>. Una lista completa delle flags
		USE correnti può essere trovata <uri link="http://www.gentoo.org/dyn/use-index.xml">qui</uri>.
		</p>

		<p>
		Se state partendo dal tarball dello stage1, dovreste inoltre impostare in modo appropriato
		le variabili CHOST, CFLAGS e CXXFLAGS per farle coincidere con il
		tipo di sistema che state creando (esempi commentati possono essere trovati poco più in basso nel
		file). Se state usando un tarball stage2 o stage3, queste impostazioni saranno già state
		correttamente configurate e non dovrebbero richiedere modifica alcuna.
		</p>

		<impo>
		<b>Utenti avanzati:</b> Le impostazioni di CFLAGS e CXXFLAGS
		sono utilizzate per informare i compilatori C e C++ su come ottimizzare il codice
		che verrà generato per il vostro sistema. E' comune, per esempio, tra gli utenti con
		processori Athlon XP specificare nelle proprie variabili CFLAGS e CXXFLAGS impostazioni 
		tipo "-march=athlon-xp" in modo che tutti i pacchetti compilati vengano ottimizzati per il set
		di istruzioni e secondo le caratteristiche di performance disponibili nelle loro CPU. 
		Il file <path>/etc/make.conf</path> contiene una guida generale relativa alle impostazioni 
		più adeguate di CFLAGS e CXXFLAGS.
		</impo>

<!-- needs qa
		<note>
		<b>Utenti avanzati:</b> se state costruendo il sistema dallo stage1 e non volete
		configurare manualmente CFLAGS e CXXFLAGS, potete usare l'utility <c>genflags</c>,
		che cercherà di generare accuratamente le flags corrette per la vostra architettura
		di CPU. Digitate semplicemente <c>emerge -O genflags</c> e quindi eseguite
		<c>info2flags</c>. <c>info2flags</c> vi suggerirà le impostazioni per CHOST, CFLAGS e
		CXXFLAGS, che potrete quindi aggiungere al vostro <path>/etc/make.conf</path>.
		</note>
-->

		<p>
		Se necessario, potete impostare a questo punto annche le informazioni relative al proxy
		nel caso vi trovaste dietro un firewall. Utilizzate il seguente comando per modificare
		<path>/etc/make.conf</path> servendovi di <c>nano</c>, un semplice editor visuale:
		</p>
		
		<pre caption="Impostare le opzioni di make.conf">
		# <i>nano -w /etc/make.conf</i>
		</pre>
	        
		<note>
		<b>Utenti avanzati:</b> Coloro che necessitano di personalizzare in modo sostanziale il 
		processo di compilazione dovrebbero dare un'occhiata al file <path>/etc/make.globals</path>.
		Questo file comprende i parametri di default di Gentoo e non dovrebbe mai essere toccato.
		Se le impostazioni di default non fossero sufficienti, i nuovi valori devono essere messi
		in <path>/etc/make.conf</path>, i valori in <path>/etc/make.conf</path> 
		<e>sovrascrivono</e> infatti gli equivalenti in <path>/etc/make.globals</path>.
		Se siete interessati a personalizzare le impostazioni USE, guardate
		<path>/etc/make.profile/make.defaults</path>. Se volete disabilitare un qualsiasi valore di
		USE che avete trovato, aggiungete l'appropriato <c>USE="-foo"</c> in 
		<path>/etc/make.conf</path> per disabilitare ogni valore di USE <c>foo</c> abilitato di default 
		in <path>/etc/make.globals</path> o <path>/etc/make.profile/make.defaults</path>.
		</note>
       		
		<warn>Assicuratevi di non aggiungere '<c>static</c>' alla vostra variabile USE fin dopo lo
		stage1.</warn>
      </body>
    </section>
</chapter>

<chapter>
    <title>Partire dallo Stage1</title>
    <section>
      <body>
		<note>Se non state partendo con il tarball dello stage1, saltate questa sezione.</note>
        	
		<p>
		Il tarball dello stage1 serve per compilare un sistema completamente personalizzato e ottimizzato.
		Se avete scelto questo tarball, state probabilmente cercando di ottenere un sistema ultra ottimizzato
		e aggiornatissimo. Buon divertimento! L'installazione partendo dallo stage1 richiede diverso tempo,
		ma il risultato è un sistema ottimizzato dalle fondamenta secondo il tipo specifico di macchina e 
		secondo le vostre esigenze.
		</p>
        	
		<p>
		Adesso è il momento di avviare il processo di "bootstrap". Questo processo dura 
		circa due ore sul mio sistema AMD Athlon 1200MHz. Durante questo lasso di tempo, verranno
		compilati le librerie GNU C, la suite del compilatore e altri programmi chiave del sistema.
		Per dare il via al bootstrap fate come segue:
		</p>
		
		<pre caption="Bootstrapping">
		# <i>cd /usr/portage</i>
		# <i>scripts/bootstrap.sh</i>
		</pre>
		
	        <p>Il processo di "bootstrap" avrà ora inizio.</p>
		
		<note>
		<c>bootstrap.sh</c> adesso supporta l'opzione <c>--fetchonly</c>. Gli utenti dial-up la troveranno
		particolarmente comoda. Essa si preoccupa di scaricare da subito tutti i file legati al bootstrap 
		per poi compilarli in un secondo momento. <c>bootstrap.sh -h</c> per maggiori informazioni.
		</note>		
		
		<note>
		Portage per default si serve di <path>/var/tmp</path> durante la fase di compilazione dei pacchetti,
		usando spesso centinaia di megabyte come area di memorizzazione temporanea. Se preferite cambiare
		la directory in cui Portage memorizza i propri file temporanei, impostate una nuova variabile 
		PORTAGE_TMPDIR <e>prima</e> di far partire il processo di bootstrap, come segue:
		</note>
		
		<pre caption="Cambiare la directory temporanea di Portage">
		# <i>export PORTAGE_TMPDIR="/altradir/tmp"</i>
		</pre>
		
        	<p>
		<c>bootstrap.sh</c> compilerà <c>binutils</c>, <c>gcc</c>, <c>gettext</c> e <c>glibc</c>, 
		ricompilando nuovamente <c>gettext</c> dopo <c>glibc</c>. Inutile dirlo, questo processo durerà
		un bel po' di tempo. Una volta che questo processo sarà completato, il vostro sistema si troverà
		in uno stato equivalente allo "stage2", ciò significa che potrete proseguire
		seguendo le istruzione relative allo stage2.
		</p>
      </body>
    </section>
</chapter>

<chapter>
    <title>Partire dallo Stage2 e continuare dallo Stage1</title>
    <section>
      <body>
	  	
		<note>
		Questa sezione è rivolta a coloro che stanno proseguendo l'installazione dallo stage1 o che
		stanno iniziando dallo stage2. Se questo non è il vostro caso (pe. state usando lo stage3), 
		allora saltate questa sezione. 
		</note>

        	<warn>
        	Se state partendo dallo stage2, non cambiate la variabile CHOST in <path>/etc/make.conf</path>. 
		Farlo può portare a problemi sconosciuti ed errori di compilazione incomprensibili.
        	</warn>
		
		<p>
		Il tarball dello stage2 ha il bootstrapping già fatto per voi. Ciò che vi resta da fare
		è installare il resto del sistema.
		</p>
		
		<note>
		Se state partendo da uno stage2 precompilato e volete essere sicuri che i vostri strumenti di
		compilazione siano assolutamente aggiornati, aggiungete l'opzione <c>-u</c> al seguente comando. 
		Se non avete idea del significato di tutto questo, ignorate semplicemente il suggerimento.
		</note>

		<pre caption="Installare il resto del sistema">
		# <i>emerge -p system</i>
		<comment>(elenca i pacchetti che devono essere installati)</comment>
		# <i>emerge system</i>
		</pre>
		
		<p>
		Anche questo passaggio richiederà un bel po' di tempo per poter compilare l'intero sistema
		di base. La cosa positiva è che alla fine avrete sicuramente un sistema veramente ottimizzato. 
		L'altro lato della medaglia è che dovrete trovare qualcosa che vi tenga occupati in tutto questo
		tempo. L'autore suggerisce "Star Wars - Super Bombad Racing" per PS2. 
		</p>
		
		<p>
		La compilazione è ora completata. Proseguite oltre e saltate alla sezione "Configurazione della vostra
		time zone".
		</p>
      </body>
    </section>
</chapter>

<chapter>
    <title>Partire dallo Stage3</title>
    <section>
      <body>
  		<note>
		Questa sezione è rivolta a coloro che <b>partono</b> dallo stage3 e non per quelli che hanno
		iniziato dallo stage1 o dallo stage2, i quali dovrebbero saltare questa sezione. Gli utenti della GRP
		dovrebbero saltare alla prossima sezione.
		</note>
		
        	<warn>
		Ricordatevi, se partite dallo stage3, di non modificare la variabile CHOST in 
		<path>/etc/make.conf</path>. Farlo può causare fallimenti nella compilazione.
        	</warn>

		<p>
		Il tarball dello stage3 fornisce un sistema di base Gentoo Linux pienamente funzionante, quindi
		non è richiesta alcuna compilazione.
		</p>
	 
	 	<note>
		<b>Utenti avanzati:</b> Comunque, essendo lo stage3 precompilato, potrebbe risultare un po'
		datato. Se questo è per voi un problema, potete automaticamente aggiornare lo stage3 in vostro
		possesso con le versioni più recenti di tutti i pacchetti facendo prima un backup di 
		<path>/etc/make.conf</path>, quindi digitando 
		<c>export CONFIG_PROTECT="-* /etc/make.conf" emerge -u system</c> (richiede una connessione di
		rete) e infine rimpiazzando il backup. Notate che questa operazione potrebbe richiedere parecchio 
		tempo nel caso il vostro stage3
		sia molto vecchio; in caso contrario, questo processo è generalmente veloce e vi permette di 
		beneficiare degli ultimi aggiornamenti di Gentoo e delle correzioni dei bug. In ogni caso, sentitevi
		liberi di saltare questo passo e di procedere con la prossima sezione.
		</note>	
      </body>
    </section>
  </chapter>
  
<chapter>
    <title>Configurazione della vostra time zone</title>
    <section>
      <body>
	        <p>
		Adesso è necessario impostare la vostra time zone.
		</p>
        	
		<p>
		Cercate la vostra time zone (o GMT se state usando il Greenwich Mean Time) 
		<path>in /usr/share/zoneinfo</path>. Quindi create un link simbolico a /etc/localtime 
		digitando:
		</p>
		
		<pre caption="Creare un link simbolico per la time zone">
		# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
		</pre>
      </body>
    </section>
</chapter>


<chapter>
	<title>Modificare /etc/fstab per la vostra macchina</title>
    <section>
	<body>

		<impo>
		Per modificare i file, ricordatevi di usare <c>nano -w "filename"</c>.
		</impo>

		<p>
		Il vostro sistema Gentoo Linux è quasi pronto per l'uso. Tutto ciò che dobbiamo fare adesso
		è configurare alcuni importanti file di sistema e installare il boot loader. Il primo file che
		dobbiamo configurare è <path>/etc/fstab</path>. Ricordatevi di utilizzare l'opzione <c>notail</c>
		per la vostra partizione di boot nel caso abbiate scelto di utilizzare per essa un filesystem di 
		tipo ReiserFS. Ricordatevi inoltre di specificare appropriatamente il tipo di filesystem <c>ext2</c>,
		<c>ext3</c> o <c>reiserfs</c> per ogni partizione.
		</p>
		
		<p>
		Usate qualcosa di simile al file <path>/etc/fstab</path> mostrato qui sotto, ma naturalmente provvedete
		a sostituite "BOOT", "ROOT" e "SWAP" con i dispositivi a blocchi che avete scelto di utilizzare
		(come <c>hda1</c>, etc.):
		</p>
	
		<pre caption="Modificare fstab">
		<comment># /etc/fstab: static file system information.
		#
		# noatime turns off atimes for increased performance (atimes normally aren't
		# needed; notail increases performance of ReiserFS (at the expense of storage
		# efficiency).  It is safe to drop the noatime options if you want and to 
		# switch between notail and tail freely.
	
		# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;
	
		# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
		</comment>
		/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
		/dev/ROOT           /           ext3	 noatime         0 1
		/dev/SWAP           none        swap	 sw              0 0
		/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
		proc                /proc       proc	 defaults        0 0
		</pre>

		<warn>
		Per favore fate attenzione che <path>/boot</path> <e>NON</e> viene montata all'avvio. Questo per
		proteggere i dati contenuti in <path>/boot</path> dal pericolo di corruzione. Se avete bisogno 
		di accedere a <path>/boot</path> ricordatevi di montarla!
		</warn>

	</body>
     </section>
</chapter>



<chapter>
<title>Installare il kernel e il system logger</title>
      <section>
	<title>Scegliere il kernel</title>
	<body>
	
		<p>
		Ci sono due opzioni per installare il kernel. Potete configurare da soli il vostro kernel
		personale oppure utilizzare l'utility <c>genkernel</c> per configurare e compilare il
		kernel automaticamente.
		</p>
	
		<p>
		Sia che configuriate manualmente un kernel o che vi serviate di <c>genkernel</c>,
		avrete comunque bisogno di emergere i sorgenti del kernel Linux che avete intenzione di
		usare. Gentoo fornisce diversi ebuilds per vari tipi di kernel; potete trovarne una lista
		<uri link="/doc/en/gentoo-kernel.xml">qui</uri>. Se siete incerti su quali sorgenti del 
		kernel scegliere, vi consigliamo di utilizzare i <c>gentoo-sources</c>.
		Se desiderate il supporto a XFS, dovreste scegliere <c>xfs-sources</c> o 
		<c>gs-sources</c>. Il Live CD di Gentoo utilizza <c>gs-sources</c> e <c>xfs-sources</c>. 
		Esiste anche un kernel <c>gaming-sources</c> ottimizzato per le esigenze dei videogiocatori
		che necessitano di un sistema reattivo, a questo scopo è abilitata l'opzione
		"Preemptible kernel".
		</p>

		<p>
		Scegliete un kernel ed emergetelo come segue:
		</p>

		<pre caption="Emergere i sorgenti del kernel">
		# <i>emerge -k sys-kernel/gentoo-sources</i>
		</pre>
	
		<p>
		Il link simbolico <path>/usr/src/linux</path> punterà al vostro nuovo albero dei sorgenti del
		kernel. Portage si serve del link simbolico <path>/usr/src/linux</path> per scopi speciali.
		Ogni ebuild che installate contenete dei moduli per il kernel sarà configurato per funzionare
		con l'albero dei sorgenti del kernel puntato da <path>/usr/src/linux</path>. 
		<path>/usr/src/linux</path> è creato quando emergete il vostro primo pacchetto con i sorgenti 
		del kernel, ma dopo che esso esiste Portage non andrà più a modificare questo link simbolico (ndt,
		si dovrà provvedere manualmente a modificarlo qualora si aggiorni il kernel).
		</p>

	</body>
      </section>

      <section>
	<title>Usare genkernel per compilare il kernel</title>
	<body>

		<p>
		Ora che il vostro albero dei sorgenti del kernel è installato, è giunto il momento di 
		compilarlo. Ci sono due modi per farlo. Il primo metodo consiste 
		nell'utilizzare il nostro nuovo script <c>genkernel</c> che costruisce automaticamente un
		kernel per voi. <c>genkernel</c> opera creando una configurazione del kernel quasi identica
		a quella con cui è stato creato il kernel del nostro Live CD. Ciò significa che quando utilizzate
		<c>genkernel</c> per costruire il kernel, il vostro sistema rileverà generalmente tutto il 
		vostro hardware in fase d'avvio, come fa il nostro Live CD. Poichè genkernel non richiede alcuna
		configurazione manuale, è la soluzione ideale per quegli utenti che non si trovano
		a loro agio compilando da soli il proprio kernel.
		</p>

		<p>
		Adesso scopriamo come si usa genkernel. Prima di tutto, emergete l'ebuild genkernel:
		</p>

		<pre caption="Emergere genkernel">
		# <i>emerge -k genkernel</i>
		</pre>
				
		<p>
		Quindi compilate i sorgenti del vostro kernel eseguendo <c>genkernel</c>:
		</p>
		
		<note>
		<b>Utenti avanzati:</b> potete altrimenti digitare <c>genkernel --config</c>,
		che permetterà a genkernel di lasciarvi modificare la configurazione di default del kernel
		prima di procedere con la compilazione.
		</note>
	
		<pre caption="Eseguire genkernel">
		<comment>Se state utilizzando genkernel 1.2 (incluso nel set di CD GRP 1.4-20030803 x86/i686), 
		usate il seguente comando:</comment>
		# <i>genkernel gentoo-sources</i>
		<comment>Se state utilizzando genkernel 1.4 o successivi, non è necessario specificare il kernel:</comment>
		# <i>genkernel</i>
		Gentoo Linux genkernel, version 1.4
		Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
		Distributed under the GNU General Public License version 2

		Settings:
		compile optimization: 1 processor(s)
		source tree: /usr/src/linux-2.4.20-gaming-r3
		config: gentoo (customized)
		config loc: /etc/kernels/config-2.4.20-gaming-r3
		initrd config: (default) /etc/kernels/settings
		
		* Running "make oldconfig"...                                                                     [ ok ]
		* Logging to /var/log/genkernel.log...                                                            [ ok ]
		* Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
		* Running "make dep"...                                                                           [ ok ]
		* Running "make bzImage"...                                                                       [ ok ]
		* Running "make modules"...                                                                       [ ok ]
		* Running "make modules_install"...                                                               [ ok ]
		* Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
		* Building busybox...                                                                             [ ok ]
		* Creating initrd...                                                                              [ ok ]
		
		* Build completed successfully!
		
		* Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
		* when customizing your boot loader configuration files.
		</pre>

		<p>
		Una volta che <c>genkernel</c> avrà concluso, verranno creati il kernel, un set completo 
		di moduli e l'<e>initial root disk</e> (initrd). Utilizzeremo il kernel e l'initrd quando 
		più avanti in questo documento andremo a configurare un boot loader. Segnatevi il nome del kernel
		e dell'Initrd ottenuti poichè ne avremo bisogno quando andremo a scrivere il file di configurazione
		del bootloader. L'initrd verrà caricato immediatamente dopo l'avvio per gestire l'autorilevazione 
		dell'hardware (proprio come per il Live CD) prima che il vostro sistema "reale" venga avviato.
		</p>

		<p>
		Andiamo ora ad eseguire un altro passo per rendere il nostro sistema ancora più simile al
		Live CD -- emergendo <c>hotplug</c>. Mentre l'initrd rileva automaticamente l'hardware richiesto
		per avviare il vostro sistema, <c>hotplug</c> rileva tutto il resto. Per emergere e abilitare
		<c>hotplug</c>, scrivete ciò che segue:
		</p>
		
		<pre caption="Emergere e abilitare hotplug">
		# <i>emerge -k hotplug</i>
		# <i>rc-update add hotplug default</i>
		</pre>

		<p>
		Ora che avete eseguito e configurato il vostro sistema utilizzando <c>genkernel</c>, potete
		saltare la seguente sezione "configurazione manuale del kernel".
		</p>

	</body>	
      </section>

      <section>
	<title>Configurazione manuale del kernel</title>
	<body>

		<p>
		Se non avete optato per l'utilizzo di genkernel per compilare il vostro kernel,
		questa sezione vi guiderà attraverso il processo manuale di configurazione e compilazione.
		Notate che <path>/usr/src/linux</path> è un symlink ai sorgenti del kernel che 
		avete emerso ed è impostato automaticamente da Portage durante l'emersione del pacchetto stesso. 
		Se avete installato pacchetti con sorgenti di kernel diversi tra loro, è necessario che impostiate
		il symlink <path>/usr/src/linux</path> in modo che punti a quello corretto prima di procedere.
		</p>
		
		<warn>
		Se state configurando il vostro kernel personale, fate attenzione all'opzione
		<i>grsecurity</i>. Un'eccessiva aggressività nell'impostazione dei parametri di sicurezza
		può causare problemi nell'esecuzione di alcuni programmi (come X). Se avete dubbi, non 
		utilizzatela.
		</warn>
	
		<note>
		Se volete utilizzare la stessa configurazione del kernel presente sul Live CD o basare la vostra
		configurazione su di essa, dovete eseguire 
		<c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c>. 
		Se non state utilizzando <c>xfs-sources</c>, vi verranno poste alcune domande relative alle
		differenze tra il kernel che avete scelto e quello <c>xfs-sources</c>.
		</note>

		<pre caption="Configurare il kernel Linux">
		# <i>cd /usr/src/linux</i>
		# <i>make menuconfig</i>
		</pre>

		<warn>
		Affinché il vostro kernel funzioni correttamente, ci sono diverse opzioni che dovrete assicurarvi 
		siano integrate nel vostro kernel -- ciò vuol dire che devono <e>essere abilitate staticamente e non 
		compilate come modulo</e>. Assicuratevi di abilitare &quot;ReiserFS&quot; se avete partizioni
		ReiserFS; la stessa cosa vale per &quot;Ext3&quot;. Se state usando XFS, abilitate l'opzione 
		&quot;SGI XFS filesystem support&quot;. E' sempre una scelta saggia lasciare il supporto per ext2 
		abilitato, che lo usiate o meno.
		</warn>

		<p>
		Quelle che seguono sono opzioni comuni di cui avrete bisogno: 
		</p>

		<pre caption="Opzioni di make menuconfig">
		Code maturity level options ---&gt;
		[*] Prompt for development and/or incomplete code/drivers&quot;
		<comment>(Avrete bisogno di questa per abilitare alcune delle opzioni seguenti)</comment>
		...	

		File systems ---&gt;
		&lt;*&gt; Reiserfs support
		<comment>(Richiesta solo se state utilizzando reiserfs)</comment>
		... 
		&lt;*&gt; Ext3 journalling file system support
		<comment>(Richiesta solo se state utilizzando ext3)</comment>
		...
		[*] Virtual memory file system support (former shm fs)
		<comment>(Richiesta da Gentoo Linux)</comment>
		...
		&lt;*&gt; JFS filesystem support
		<comment>(Richiesta solo se state utilizzando JFS)</comment>
		...
		[*] /proc file system support
		<comment>(Richiesta da Gentoo Linux)</comment>
		[*] /dev file system support (EXPERIMENTAL)
		[*]   Automatically mount at boot          
		<comment>(Richiesta da Gentoo Linux)</comment>
		[ ] /dev/pts file system for Unix98 PTYs
		<comment>(Deselezionatela, NON è necessaria)</comment>
		...
		&lt;*&gt; Second extended fs support
		<comment>(Richiesta solo se state utilizzando ext2)</comment>
		...
		&lt;*&gt; XFS filesystem support
		<comment>(Richiesta solo se state utilizzando XFS)</comment>
		</pre>

		<p>
		Se usate PPPoE per connettervi a internet, avrete bisogno delle seguenti opzioni nel kernel
		(built-in o preferibilmente come moduli): &quot;PPP (point-to-point protocol) support&quot;, 
		&quot;PPP support for async serial ports&quot;, &quot;PPP support for sync tty ports&quot;. 
		Le due opzioni relative alla compressione non guastano ma non sono propriamente necessarie,
		così come l'opzione &quot;PPP over Ethernet&quot;, che potrebbe essere usata solamente da
		<c>rp-pppoe</c> quando configurate il kernel in modalità PPPoE.
		</p>

		<p>
		Se avete un masterizzatore IDE, allora avrete bisogno di abilitare l'emulazione SCSI nel 
		kernel. Abilitate &quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA and ATAPI Block devices&quot;
		---&gt; &quot;SCSI emulation support&quot; (Compilati normalmente come moduli), poi sotto 
		&quot;SCSI support&quot; abilitate &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; e 
		&quot;SCSI generic support&quot; (ancora, compilati normalmente come moduli). Se avete scelto di
		usare i moduli, allora date 
		<c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot; &gt;&gt; /etc/modules.autoload.d/kernel-2.4</c> 
		per averli aggiunti automaticamente all'avvio.
		</p>

		<p>
		Nel caso ne abbiate bisogno, non dimenticatevi di includere il supporto per la vostra scheda 
		ethernet nel kernel.
		</p>

		<note>
		Per coloro che lo preferiscono, è possibile installare Gentoo Linux con un kernel 2.2. 
		Tuttavia questa scelta ha un prezzo: perderete le ottime caratteristiche che sono prerogativa 
		della serie 2.4 del kernel (come il supporto ai filesystems XFS e tmpfs, iptables e altro), 
		anche se comunque i sorgenti del kernel 2.2 possono essere patchati con il supporto a ReiserFS e a 
		devfs. Gli script di avvio di Gentoo Linux richiedono il supporto nel kernel per tmpfs o ramdisk, così 
		coloro che vogliono usare il kernel 2.2 devono essere sicuri di avere il supporto per il ramdisk incluso 
		(non come modulo quindi) nel kernel. E' <comment>vitale</comment> che la flag <e>gentoo=notmpfs</e> 
		sia aggiunta alla linea del kernel in <path>/boot/grub/menu.lst</path> o in <path>/etc/lilo.conf</path>
		per i kernel della serie 2.2, in modo tale che gli script di avvio montino il ramdisk invece di tmpfs. 
		Se scegliete di non usare devfs, allora dovrete usare la riga <e>gentoo=notmpfs,nodevfs</e> al
		posto della precedente.
		</note>

		<pre caption = "Compilare e installare il kernel">
		# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
		# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
		</pre>

	</body>
      </section>

      <section>
	<title>Installare ebuilds addizionali per hardware specifico</title>
	<body>

		<p>
		Infine, dovrete emergere eventuali ebuilds per ogni tipo di hardware addizionale presente
		nel vostro sistema. Qui trovate una lista degli ebuilds legati al kernel che potete 
		emergere:
		</p>

		<table>
		<tr>
		<th>Ebuild</th>
		<th>Finalità</th>
		<th>Comando</th>
		</tr>
		<tr>
		<ti>nvidia-kernel</ti>
		<ti>Accelerazione grafica NVIDIA per XFree86</ti>
		<ti><c>emerge -k nvidia-kernel</c></ti>
		</tr>
		<tr>
		<ti>nforce-net</ti>
 		<ti>Controller ethernet integrato nelle schede madri con chip NVIDIA NForce(2)</ti>
 		<ti><c>emerge nforce-net</c></ti>
		</tr>
		<tr>
 		<ti>nforce-audio</ti>
 		<ti>Audio integrato nelle schede madri con chip NVIDIA NForce(2)</ti>
 		<ti><c>emerge nforce-audio</c></ti>
		</tr>
		<tr>
 		<ti>e100</ti>
 		<ti>Adattatori Intel e100 Fast Ethernet</ti>
 		<ti><c>emerge e100</c></ti>
		</tr>
		<tr>
 		<ti>e1000</ti>
 		<ti>Adattatori Intel e1000 Gigabit Ethernet</ti>
 		<ti><c>emerge e1000</c></ti>
		</tr>
		<tr>
 		<ti>emu10k1</ti>
 		<ti>Supporto per Creative Sound Blaster Live!/Audigy</ti>
 		<ti><c>emerge emu10k1</c></ti>
		</tr>
		<tr>
		<ti>ati-drivers</ti>
 		<ti>Accelerazione grafica ATI Radeon 8500+/FireGL per XFree86</ti>
 		<ti><c>emerge ati-drivers</c></ti>
		</tr>
		<tr>
		<ti>xfree-drm</ti>
 		<ti>Accelerazione grafica per ATI Radeon fino alla 9200, Rage128, Matrox, Voodoo 
		e altre schede per XFree86</ti>
 		<ti><c>VIDEO_CARDS="vostrascheda" emerge xfree-drm</c></ti>
		</tr>
		</table>

		<p>
		I pacchetti <c>nvidia-kernel</c>, <c>ati-drivers</c> e <c>xfree-drm</c> richiederanno
		una configurazione aggiuntiva per poter essere abilitati. Tutti gli altri ebuilds elencati
		in precedenza dovrebbero essere rilevati automaticamente all'avvio dal pacchetto <c>hotplug</c>.
		Se non state usando hotplug, assicuratevi di aggiungere i moduli appropriati in
		<path>/etc/modules.autoload.d/kernel-2.4</path>.
		</p>

		<p>
		Maggiori informazioni su <c>xfree-drm</c> possono essere trovate nella nostra<uri
		link="/doc/en/dri-howto.xml">Direct Rendering Guide</uri>.
		</p>

	</body>
      </section>

      <section>
	<title>Installare un system logger</title>
	<body>

		<p>
		Il vostro nuovo kernel (e i moduli) sono ora installati. Adesso vi è richiesto di scegliere il
		system logging (ndt, si occupa della gestione dei vari log del vostro sistema) che volete installare. 
		Offriamo sysklogd, che è il tradizionale insieme di demoni per il logging di sistema. Abbiamo però 
		anche msyslog e syslog-ng così come metalog. Gli utenti esperti che gravitavano attorno a sysklogd 
		(che non brilla per prestazioni) sembra si stiano spostando verso le nuove alternative. Se siete in 
		dubbio, potete provare metalog, che sembra essere abbastanza popolare. Per emergere il logger che 
		avete scelto, digitate <e>uno</e> dei seguenti quattro comandi:
		</p>

		<pre caption="Emergere il System Logger scelto">
		# <i>emerge -k app-admin/sysklogd</i>
		# <i>rc-update add sysklogd default</i>
		<comment>o</comment>
		# <i>emerge -k app-admin/syslog-ng</i>
		# <i>rc-update add syslog-ng default</i>
		<comment>o</comment>
		# <i>emerge -k app-admin/metalog</i>
		# <i>rc-update add metalog default</i>
		<comment>o</comment>
		# <i>emerge -k app-admin/msyslog</i>
		# <i>rc-update add msyslog default</i>
		</pre>

		<impo>
		Metalog scrive l'output su disco in blocchi, così i messaggi non vengono immediatamente registrati
		nei log di sistema. Se state tentando di fare il debug di un demone, questa caratteristica, volta a 
		migliorare le prestazioni, risulta più dannosa che utile. Una volta che il vostro sistema Gentoo
		Linux sta girando, potete mandare a metalog un segnale USR1 che dovrebbe temporaneamente
		disabilitare questo buffering dei messaggi (ciò significa che 
		<c>tail -f <path>/var/log/everything/current</path></c> dovrebbe ora funzionare in tempo reale,
		come ci aspetteremmo) e un segnale USR2 per ripristinare nuovamente il buffering. Se volete 
		disabilitare permanentemente il buffering, potete cambiare l'opzione METALOG_OPTS="-B" in 
		METALOG_OPTS="-B -s" in <path>/etc/conf.d/metalog</path>.
		
		<pre caption="Attivare/Disattivare il buffering di metalog">
		<codenote>Per disattivare il buffering:</codenote>
		# <i>killall -USR1 metalog</i>
		<codenote>Per attivare il buffering:</codenote>
		# <i>killall -USR2 metalog</i>
		</pre>
		</impo>

		<p>
		Adesso se volete potete facoltativamente scegliere il pacchetto cron che preferite usare. Per ora
		offriamo dcron, fcron e vcron. Se non sapete quale scegliere tra questi, potete orientarvi verso vcron.
		</p>

		<pre caption="Scegliere un demone CRON">
		# <i>emerge -k sys-apps/dcron</i>
		# <i>rc-update add dcron default</i>
		# <i>crontab /etc/crontab</i>
		<comment>o</comment>
		# <i>emerge -k sys-apps/fcron</i>
		# <i>rc-update add fcron default</i>
		# <i>crontab /etc/crontab</i>
		<comment>o</comment>
		# <i>emerge -k sys-apps/vcron</i>
		# <i>rc-update add vcron default</i>
		<comment>Non è richiesta l'esecuzione di <i>crontab /etc/crontab</i> se usate vcron.</comment>
		</pre>

		<p>
		Per maggiori informazioni sull'avvio di programmi e sui demoni da avviare, date un'occhiata alla
		<uri link="/doc/en/rc-scripts.xml">rc-script guide</uri>.
		</p>

	</body>
     </section>
</chapter>

<chapter>
	<title>Installazione di vari pacchetti necessari</title>
      <section>
	<body>

		<p>
		Se avete bisogno di rp-pppoe per connettervi alla rete, siate consapevoli che a questo punto non è 
		stato ancora installato. Potrebbe essere un buon momento per farlo:
		</p>

		<pre caption="Installare rp-pppoe">
		# <i>USE="-X" emerge rp-pppoe</i>
		<comment>Gli utenti GRP dovrebbero digitare quanto segue:</comment>
		# <i>USE="-X bindist" emerge -K rp-pppoe</i>
		</pre>

		<note>
		La variabile <i>USE="-X"</i> previene l'installazione da parte di pppoe dell'interfaccia grafica 
		per X opzionale, che è buona cosa visto che verrebbero emersi anche X e le sue dipendenze.
		Potete sempre ricompilare <i>rp-pppoe</i> con il supporto per X in seguito.
		</note>

		<note>
		Notate che rp-pppoe è installato ma non configurato. Dovrete provvedere voi a farlo usando 
		<c>adsl-setup</c> dopo aver avviato il vostro sistema Gentoo per la prima volta. 
		</note>

		<p>
		Potreste aver bisogno di installare altri pacchetti addizionali del Portage tree nel
		caso stiate usando qualsiasi funzionalità aggiuntiva come XFS, ReiserFS o LVM. Se state
		usando XFS, dovreste emerge il pacchetto <c>xfsprogs</c>:
		</p>

		<pre caption="Emergere i tools per i vari Filesystem">
		# <i>emerge -k sys-apps/xfsprogs</i>
		<comment>Se state usando ReiserFS, dovreste emergere i tool di ReiserFS: </comment>
		# <i>emerge -k sys-apps/reiserfsprogs</i>
		<comment>Se state usando JFS, dovreste emergere i tool di JFS: </comment>
		# <i>emerge -k jfsutils</i>
		<comment>Se state usando LVM, dovreste emergere il pacchetto <c>lvm-user</c>: </comment>
		# <i>emerge -k sys-apps/lvm-user</i>
		</pre>

		<p>
		Se state utilizzando un laptop e volete usare i vostri slot PCMCIA al primo vero riavvio, dovrete 
		assicurarvi di installare il pacchetto <i>pcmcia-cs</i>.
		</p>

		<pre caption="Emergere PCMCIA-cs">
		# <i>emerge -k sys-apps/pcmcia-cs</i>
		</pre>

<!-- fix the bug or fix the docs, don't send the user in circles
(drobbins)
		<warn>
		Dovrete ri-emergere <i>pcmcia-cs</i> dopo l'installazione per far si che PCMCIA
		funzioni.
		</warn>
-->

	</body>
      </section>
</chapter>

<chapter>
	<title>Gestione degli utenti</title>
      <section>
	<title>Impostare una password per root</title>
	<body>

		<p>
		Prima di dimenticarvene, impostate la password per root digitando:
		</p>
	
		<pre caption="Impostare la password per root">
		# <i>passwd</i>
		</pre>

		</body>
      </section>

      <section>
	<title>Aggiungere un utente per l'uso quotidiano</title>
	<body>

		<p>
		Lavorare come root in un sistema Unix/Linux è <e>pericoloso</e> e andrebbe evitato per
		quanto possibile. Per questo è <e>fortemente</e> raccomandata l'aggiunta di un utente
		per il normale uso quotidiano:
		</p>

		<pre caption = "Aggiungere un utente">
		# <i>useradd vostro_utente -m -G users,wheel,audio -s /bin/bash</i>
		# <i>passwd vostro_utente</i>
		</pre>
	
		<p>
		Sostituite <c>vostro_utente</c> con il vostro username.
		</p>

		<p>
		Ogni volta che dovrete eseguire un qualche task gestibile solo come root, usate
		<c>su -</c> per cambiare i vostri privilegi assumendo quelli di root, o date un'occhiata al
		pacchetto <c>sudo</c>.
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Impostare il vostro Hostname</title>
      <section>
	<body>

		<p>
		Modificate <path>/etc/hostname</path> in modo che contenga il vostro hostname 
		su una singola linea, p.e. <c>mymachine</c>. 
		</p>

		<pre caption="Configurare l'Hostname">
		# <i>echo mymachine &gt; /etc/hostname</i>
		</pre>

		<p>
		Quindi modificate <path>/etc/dnsdomainname</path> in modo che contenga il vostro nome
		di dominio DNS, p.e. <c>mydomain.com</c>.
		</p>

		<pre caption="Configurare il nome di dominio">
		# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
		</pre>

		<p>
		Se possedete un dominio NIS, dovreste impostarlo in 
		<path>/etc/nisdomainname</path>.
		</p>

		<pre caption="Configurare il nome di dominio NIS">
		# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
		</pre>

	</body>
      </section>
</chapter>


<chapter>
	<title>Modifiche a /etc/hosts</title>
      <section>
	<body>

		<p>
		Questo file contiene una lista di indirizzi IP e di hostname ad essi associati.
		E' utilizzato dal sistema per risolvere gli indirizzi IP di quelle macchine che non 
		possono trovarsi nei vostri nameservers. Segue un esempio per questo file:
		</p>

		<pre caption="Template di Hosts">
		127.0.0.1      localhost
		<comment># la prossima linea contiene il vostro IP relativo alla LAN locale in cui vi trovate e il nome 
		della macchina ad esso associato</comment>
		192.168.1.1    mymachine.mydomain.com	mymachine
		</pre>

		<note>
		Se vi trovate in una rete DHCP, potrebbe risultarvi utile aggiungere il nome
		attuale della vostra macchina dopo <i>localhost</i>. Ciò aiuterà GNOME e diversi altri
		programmi nella risoluzione dei nomi.
		</note>

	</body>
      </section>
</chapter>


<chapter>
	<title>Configurazione finale della rete</title>
      <section>
	<body>

		<p>
		Aggiungete i nomi di tutti i moduli necessari al corretto funzionamento del vostro sistema al 
		file <path>/etc/modules.autoload.d/kernel-2.4</path> (potete anche aggiungere tutte le opzioni 
		necessarie sulla stessa riga). All'avvio di Gentoo Linux, questi moduli verranno automaticamente 
		caricati. Di particolare importantanza è il modulo relativo al supporto per la vostra scheda di rete, 
		se avete scelto di compilarlo come modulo:
		</p>

		<pre caption="/etc/modules.autoload.d/kernel-2.4">
		<comment>Si assume qui che stiate utilizzando una scheda 3com. 
		Controllate <path>/lib/modules/`uname -r`/kernel/drivers/net</path> per la vostra scheda. </comment>
		3c59x
		</pre>

		<p>
		Modificate lo script <path>/etc/conf.d/net</path> per ottenere che la vostra rete venga configurata
		all'avvio:
		</p>

		<pre caption="Configurazione della rete all'avvio">
		# <i>nano -w /etc/conf.d/net</i>
		<comment>Solo per schede di rete non-PCMCIA:</comment>
		# <i>rc-update add net.eth0 default</i>
		</pre>

		<p>
		Se possedete schede di rete multiple o interfacce tokenring, avrete bisogno di creare script
		<path>net.eth<comment>x</comment></path> o <path>net.tr<comment>x</comment></path> aggiuntivi 
		per ogni scheda (con <comment>x</comment> = 1, 2, ...):
		</p>

		<pre caption="Interfacce di rete multiple">
		# <i>cd /etc/init.d</i>
		# <i>cp net.eth0 net.eth<comment>x</comment></i>
		<comment>Solo per schede di rete non-PCMCIA:</comment>
		# <i>rc-update add net.eth<comment>x</comment> default</i>
		</pre>

		<p>
		Se avete installato una scheda PCMCIA, date una rapida occhiata in 
		<path>/etc/init.d/pcmcia</path> per verificare se corrisponde alla vostra configurazione,
		quindi eseguite i seguenti comandi:
		</p>

		<pre caption = "Avere i servizi PCMCIA avviati automaticamente">
		# <i>rc-update add pcmcia boot</i>
		</pre>

		<p>
		Questo vi assicurerà che i driver PCMCIA vengano caricati automaticamente ogni volta
		che la vostra rete è attivata. I servizi <path>/etc/init.d/net.eth*</path> appropriati
		verranno avviati automaticamente dal servizio pcmcia.
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Passi finali: configurare le impostazioni di base (inclusa l'impostazione internazionale della keymap)</title>
      <section>
	<body>
	
		<pre caption="Configurazione di base">
		# <i>nano -w /etc/rc.conf</i>
		</pre>

		<p>
		Scorrendo le varie voci in questo file potrete configurare le impostazioni di base.
		Tutti gli utenti vorranno essere sicuri che la variabile CLOCK sia impostata come desiderano.
		Gli utenti con tastiere internazionali vorranno impostare correttamente la variabile KEYMAP
		(cercate in <path>/usr/share/keymaps</path> per trovare le varie possibilità).
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Configurare un Bootloader</title>
      <section>
	<title>Note</title>
	<body>

		<p>
		Nello spirito che caratterizza Gentoo, gli utenti possono ora scegliere tra più di un bootloader. 
		Utilizzando il nostro sistema di pacchetti virtuale, gli utenti possono scegliere tra GRUB e LILO 
		come loro bootloader.
		</p>

		<p>
		Tenete bene a mente che non è necessario avere installati entrambi i bootloaders. 
		A conti fatti ciò può essere d'ostacolo, quindi sceglietene uno soltanto.
		</p>

		<p>
		In più, dovrete configurare il vostro bootloader in modo differente a seconda di come
		avete compilato il vostro kernel, se utilizzando <c>genkernel</c> (con kernel e initrd)
		o manualmente. Assicuratevi di tenere nota di queste importanti differenze.
		</p>

		<impo>
		Se state installando Gentoo Linux su un sistema con scheda madre basata sul chipset
		nForce o nForce2 con scheda grafica GeForce integrata, dovreste usare LILO ed evitare GRUB. 
		Con il video on-board abilitato, l'area di memoria più bassa della vostra RAM potrebbe essere 
		usata come RAM video. Dato che anche GRUB usa la stessa area di memoria all'avvio,  si potrebbe
		verificare una condizione di "out of memory". Quindi se avete una nForce o eventualmente 
		altre schede con video integrato, usate LILO. Inoltre se adesso state usando schede grafiche
		non integrate, sarebbe carino avere la possibilità di rimuovere la scheda grafica e usare 
		quella on-board in caso di bisogno, non è vero? :)
		</impo>

	</body>
      </section>

      <section>
	<title>Configurare GRUB</title>
	<body>

		<p>
		La parte più critica da capire di GRUB è quella necessaria per prendere confidenza con la notazione 
		che GRUB usa per riferirsi ai dischi e alle partizioni. La vostra partizione Linux 
		<path>/dev/hda1</path> è chiamata da GRUB <path>(hd0,0)</path>. Notate che le parentesi 
		che racchiudono hd0,0 - sono richieste. I dischi vengono contati a partire da zero invece 
		che da "a" e le partizioni partono da zero invece che da uno. Ugualmente sappiate che 
		vengono considerati come periferiche hd solo gli hard disk e non le periferiche atapi-ide 
		come lettori cdrom, masterizzatori e che lo stesso principio vale anche per le periferiche 
		SCSI. (Normalmente queste prendono numeri alti rispetto alle periferiche ide eccetto quando 
		il bios è configurato per fare il boot da periferiche SCSI). Assumendo che abbiate un disco 
		in <path>/dev/hda</path>, un lettore cdrom in <path>/dev/hdb</path>, un masterizzatore in
		<path>/dev/hdc</path>, un secondo disco fisso in <path>/dev/hdd</path> e nessun disco SCSI, 
		<path>/dev/hdd7</path> viene trasformato in <path>(hd1,6)</path>. Potrebbe suonare complicato e
		complicato in effetti è, ma come vedrete, GRUB offre un meccanismo di completamento col tasto TAB
		che si dimostra comodo per coloro che hanno un numero notevole di hard disk e partizioni e sono 
		un po' a disagio con lo schema numerico di GRUB. Avendo preso coscienza di questo, è il momento di 
		installare GRUB.
		</p>

		<p>
		Il modo più semplice per installare GRUB è semplicemente quello di digitare <c>grub</c> al prompt
		della vostra shell chrooted:
		</p>

		<pre caption="Installare GRUB">
		# <i>emerge -k grub</i>
		# <i>grub</i>
		</pre>

		<p>
		Vi verrà presentato il prompt della linea di comando di GRUB, <e>grub&gt;</e>. 
		Ora dovrete digitare i comandi corretti per installare il boot record di GRUB sul
		vostro hard disk. Nella mia configurazione d'esempio, voglio installare il boot record
		di GRUB nell'MBR (master boot record, il primo settore del disco fisso) del mio disco rigido, 
		in modo che la prima cosa che vedo quando accendo il mio computer è il prompt di GRUB. 
		Nel mio caso, i comandi che devo digitare sono:
		</p>

		<pre caption="GRUB nell'MBR">
		grub&gt; <i>root (hd0,0)</i> <comment>(La vostra partizione di boot)</comment>
		grub&gt; <i>setup (hd0)</i> <comment>(Dove il boot record deve essere installato; in questo caso, 
		nell'MBR)</comment>
		</pre>
	
		<pre caption="GRUB non nell'MBR">
		<comment>Alternativamente, se volete installare il bootloader in qualche altro posto che non
		sia l'MBR:</comment>
		grub&gt; <i>root (hd0,0)</i> <comment>(La vostra partizione di boot)</comment>
		grub&gt; <i>setup (hd0,4)</i> <comment>(Dove il boot record deve essere installato; in questo caso
		in /dev/hda5)</comment>
		grub&gt; <i>quit</i>
		</pre>

		<p>
		Vediamo come funzionano i due comandi. Il primo comando <c>root ( )</c> dice a GRUB la 
		locazione della vostra partizione di boot (nel nostro esempio, <path>/dev/hda1</path> o 
		<path>(hd0,0)</path> nella terminologia GRUB). Quindi il secondo comando, <c>setup ( )</c>,
		dice a GRUB dove installare il boot record - sarà configurato per cercare i suoi file speciali
		nella locazione <c>root ( )</c> che avete specificato. Nel mio caso, voglio che il boot record
		venga installato nell'MBR del disco rigido, così ho semplicemente specificato <path>/dev/hda</path>
		(conosciuto anche come <path>(hd0)</path>). Se stessi usando un altro boot loader e volessi
		installare GRUB come boot loader secondario, dovrei installare GRUB nel boot record di una 
		partizione particolare. In questo caso, dovrei specificare una particolare partizione 
		invece dell'intero disco. Una volta che il boot record di GRUB è stato installato con successo, 
		potete digitare <c>quit</c> per uscire da GRUB.
		</p>

		<note>
		Il meccanismo del completamento di GRUB attraverso tab può essere usato all'interno di
		GRUB; assumiamo che abbiate scritto <c>root (</c> e che ora premiate il tasto TAB, vi dovrebbe 
		essere mostrata una lista di periferiche disponibili (non solo dischi fissi), premendo nuovamente
		il tasto TAB dopo aver scritto <c>root (hd</c>, GRUB vi dovrebbe mostrare solo gli hard disk e premendo
		ancora TAB dopo aver scritto <c>root (hd0</c>, dovreste avere la lista delle partizioni del primo
		disco. Controllare la sintassi delle locazioni con il completamento di GRUB dovrebbe veramente
		contribuire a fare la scelta giusta.
		</note>
			
		<p>
		Gentoo Linux è ora installato, ma dobbiamo creare il file <path>/boot/grub/grub.conf</path>
		che serve per mostrare il bel menu di GRUB quando viene riavviato il sistema. Trovate di seguito come 
		fare.
		</p>

		<impo>
		Per assicurarsi la retrocompatibilità con GRUB, assicuratevi di creare un link da
		<path>grub.conf</path> a <path>menu.lst</path>. Potete provvedere a ciò digitando
		<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>.
		</impo>

		<p>
		Adesso create il file <path>grub.conf</path> (<c>nano -w 
		/boot/grub/grub.conf</c>) e aggiungetevi quanto segue:
		</p>

		<pre caption="grub.conf per GRUB">
		default 0
		timeout 30
		splashimage=(hd0,0)/boot/grub/splash.xpm.gz

		<comment># Se avete compilato il vostro kernel personale, usate qualcosa di simile a questo:</comment>
		title=My example Gentoo Linux
		root (hd0,0) 
		kernel (hd0,0)/boot/bzImage root=/dev/hda3 
		
		<comment># Se avete usato genkernel, usate qualcosa di simile a quanto segue:</comment>
		title=My example Gentoo Linux (genkernel)
		root (hd0,0)
		kernel (hd0,0)/boot/kernel-KV root=/dev/hda3
		initrd (hd0,0)/boot/initrd-KV
		
		<comment># Questo è richiesto solo per coloro che hanno un sistema dual-boot</comment>
		title=Windows XP
		root (hd0,5) 
		chainloader (hd0,5)+1
		</pre>

		<p>
		Sostituite <c>KV</c> con la versione del kernel che avete installato.
		</p>
		
		<note>
		(hd0,0) dovrebbe essere scritto senza alcuno spazio tra le parentesi.
		</note>

		<impo>
		Se avete impostato l'emulazione SCSI per un eventuale masterizzatore IDE, allora per renderlo 
		attivo avrete bisogno di aggiungere <c>hdx=ide-scsi</c> alla linea del kernel in 
		<path>grub.conf</path> (dove "hdx" dovrebbe essere il device che indica il vostro masterizzatore).
		</impo>

		<p>
		Dopo aver salvato questo file, l'installazione di Gentoo Linux è completata. Scegliendo la
		prima opzione diremo a GRUB di avviare Gentoo Linux. La seconda parte del file 
		<path>grub.conf</path> è opzionale e mostra come usare GRUB per fare il boot di una 
		partizione Windows avviabile.
		</p>

		<note>
		Sopra, <path>(hd0,0)</path> dovrebbe puntare alla vostra partizione di "boot"
		(<path>/dev/hda1</path> nella nostra configurazione d'esempio) e <path>/dev/hda3</path> 
		dovrebbe puntare al vostro filesystem root. <path>(hd0,5)</path> contiene il boot loader
		di NT.
		</note>

		<note>
		Il percorso all'immagine del kernel è legato alla partizione di boot. Se per esempio 
		avete una partizione di boot separata <path>(hd0,0)</path> e una partizione root
		<path>(hd0,1)</path>, tutti i percorsi nel file <path>grub.conf</path> precedente
		diventeranno tipo <path>/bzImage</path>.
		</note>

		<p>
		Se avete bisogno di passare qualsiasi opzione aggiuntiva al kernel, aggiungetela semplicemente 
		alla fine del comando <c>kernel</c>. Stiamo già passandogli un'opzione (<c>root=/dev/hda3</c>), 
		ma possiamo passargliene anche delle altre. In particolare, potreste disabilitare di default il supporto
		a devfs (non raccomandato a meno che sappiate cosa state facendo) aggiungendo l'opzione 
		<c>gentoo=nodevfs</c> al comando <c>kernel</c>.
		</p>

		<note>
		A differenza delle versioni iniziali di Gentoo Linux, non è più necessario aggiungere 
		<c>devfs=mount</c> alla fine della riga del <c>kernel</c> per abilitare devfs. Ora devfs
		è abilitato per default.
		</note>

	</body>
      </section>

      <section>
	<title>Configurare LILO</title>
	<body>

		<p>
		Mentre GRUB può rappresentare una nuova alternativa per molte persone, non sempre è la 
		scelta migliore. LILO, il LInuxLOader, è il più testato e vero cavallo da tiro tra i bootloader
		di Linux. Ecco come installare LILO se lo volete usare al posto di GRUB:
		</p>

		<p>
		Il primo passo è emergere LILO: 
		</p>

		<pre caption="Emergere LILO">
		# <i>emerge -k lilo</i>
		</pre>

		<p>
		Ora è il momento di configurare LILO. Trovate di seguito un file di configurazione 
		<path>/etc/lilo.conf</path> d'esempio:
		</p>

		<pre caption="Esempio di lilo.conf">
		boot=/dev/hda
		map=/boot/map
		install=/boot/boot.b
		prompt
		timeout=50
		lba32
		default=linux

		<comment># Utilizzate qualcosa di simile alle seguenti 4 linee se compilate da soli il vostro 
		kernel</comment>
		
		image=/boot/bzImage
			label=linux
			read-only
			root=/dev/hda3

		<comment># Se usate genkernel, servitevi di qualcosa simile a questo:</comment>
		image=/boot/kernel-KV
			label=gk_linux
			root=/dev/hda3
			initrd=/boot/initrd-KV
			append="root=/dev/ram0 init=/linuxrc"

		
		<comment># Per il dual boot con windows/altri OS</comment>
		other=/dev/hda1
			label=dos
		</pre>		

		<p>
		Sostituite <c>KV</c> con la versione del kernel che avete installato e
		assicuratevi che <c>default=</c> punti alla label (ndt, etichetta) corretta 
		(<c>gk_linux</c> se usate genkernel).
		</p>
	
		<ul>
		<li><c>boot=/dev/hda</c> dice a LILO di installarsi sul primo hard disk del primo controller IDE.</li>
		<li><c>map=/boot/map</c> specifica il file map. Per un uso normale, questo non andrebbe modificato.</li>
		<li><c>install=/boot/boot.b</c> dice a LILO di installare il file specificato come nuovo settore
		di boot. In un normale uso, questo non andrebbe modificato. Se la linea di installazione è omessa,
		LILO assumerà di default che il file da usare sia <path>/boot/boot.b</path>.</li>
		<li>La presenza di <c>prompt</c> dice a LILO di visualizzare il classico prompt <e>lilo:</e> all'avvio.
		Nonostante non sia raccomandata la rimozione della linea di prompt, se doveste rimuoverla, potrete 
		ancora ottenere un prompt premendo il tasto [Shift] mentra la vostra macchina si sta avviando.</li>
		<li><c>timeout=50</c> imposterà la durata dell'intervallo di tempo in cui LILO attenderà l'input 
		dell'utente prima di procedere avviando il sistema indicato dalla linea di default. Questo valore
		è misurato in decimi di secondo, con 50 come default.</li>
		<li><c>lba32</c> descrive la geometria del disco fisso a LILO. Un altro valore comune è "linear". 
		Non dovete cambiare questa linea a meno che non siate veramente sicuri di ciò che fate. Altrimenti 
		potreste portare il vostro sistema in uno stato non avviabile.</li>
		<li><c>default=linux</c> fa riferimento al sistema operativo di default che LILO avvierà tra le	quelli 
		elencati di seguito. Il nome linux si riferisce a una delle linee label che si trovano in ciascuna 
		delle successive opzioni di boot.</li>
		<li><c>image=/boot/bzImage</c> specifica il kernel linux da avviare con le relative opzioni di boot.</li>
		<li><c>label=linux</c> è il nome dell'opzione di boot relativa a un sistema operativo che LILO 
		visualizzerà. In questo caso, è anche il nome cui fa riferimento la linea default. </li>
		<li><c>read-only</c> specifica che la partizione root (guardate la seguente linea root) è in sola
		lettura e non può essere alterata durante il processo di boot.</li>
		<li><c>root=/dev/hda3</c> dice a LILO quale partizione del disco usare come partizione root.</li>
		</ul>

		<p>
		Dopo aver modificato il vostro file <path>lilo.conf</path>, è il momento di eseguire LILO
		per caricare le informazioni nell'MBR:
		</p>

		<pre caption="Eseguire LILO">
		# <i>/sbin/lilo</i>
		</pre>

		<p>
		LILO è configurato e ora la vostra macchina è pronta per avviare Gentoo Linux!
		</p>

	</body>
      </section>

      <section>
	<title>Usare il framebuffer</title>
	<body>

		<p>
		Coloro che hanno selezionato il framebuffer nel loro kernel dovrebbero aggiungere <c>vga=xxx</c> 
		al file di configurazione del loro bootloader. <c>xxx</c> è uno dei valori della seguente
		tabella:
		</p>

		<table>
		<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
		<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
		<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
		<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
		</table>

		<p>
		Gli utenti di LILO dovranno aggiungere <c>vga=xxx</c> in cima al loro file di configurazione.
		</p>

		<p>
		Gli utenti di GRUB dovranno aggiungere <c>vga=xxx</c> alla linea <c>kernel (hd0,0)...</c>.
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Creare un dischetto d'avvio</title>
      <section>
	<title>Dischetto d'avvio di GRUB</title>
	<body>

		<impo>
		Non dimenticatevi di inserire un floppy nel vostro lettore prima di procedere.
		</impo>

		<p>
		E' sempre una buona idea creare un dischetto di avvio la prima volta che installate una 
		qualsiasi distribuzione Linux. Questa per motivi di sicurezza e perchè normalmente non è 
		una cattiva idea farlo. Se il vostro hardware non vi permette di installare un bootloader 
		funzionante dall'ambiente chrooted, potreste avere la <e>necessità</e> di creare un dischetto
		d'avvio di GRUB. Se vi trovate in questa situazione, create un disco d'avvio di GRUB e quando 
		riavvierete per la prima volta potrete installare GRUB nell'MBR. Create il vostro dischetto
		di avvio in questo modo:
		</p>

		<pre caption="Creare un dischetto d'avvio di GRUB">
		# <i>cd /usr/share/grub/i386-pc/</i>
		# <i>cat stage1 stage2 > /dev/fd0</i>
		</pre>

		<p>
		Ora riavviate e caricate il floppy. Al prompt <c>grub&gt;</c> del floppy, potrete 
		finalmente eseguire i comandi <c>root</c> e <c>setup</c> necessari per l'installazione.
		</p>

	</body>
      </section>
      
      <section>
	<title>Dischetto d'avvio di LILO</title>
	<body>

		<impo>
		Non dimenticatevi di inserire un floppy nel vostro lettore prima di procedere.
		</impo>

		<p>
		Se state usando LILO, è comunque una buona idea creare un disco d'avvio:
		</p>

		<pre caption="Creare un dischetto d'avvio">
		# <i>dd if=/boot/your_kernel of=/dev/fd0 </i>
		<comment>(Ciò funzionerà solo se il vostro kernel è più piccolo di 1.4MB)</comment>
		</pre>

	</body>
      </section>
</chapter>

<chapter>
	<title>Usare GRP</title>
      <section>
	<body>

		<p>
		Gli utenti della GRP possono, a questo punto, installare i pacchetti binari:
		</p>

		<pre caption="Installare dalla GRP">
		# <i>USE="bindist" emerge -k xfree</i> 
		<codenote>(USE="bindist" deve essere impostato mentre si installa ogni pacchetto che usa XFree86)</codenote>
		</pre>

		<p>
		Il CD 1 contiene svariati pacchetti per installare un sistema funzionate con XFree86.
		Inoltre, il CD2 del set di CD GRP contiene altre applicazioni quali KDE, GNOME, Mozilla 
		e altre. Per installare questi pacchetti, dovrete prima riavviare entrando nel vostro nuovo
		sistema Gentoo (come spiegato più avanti in questo documento, nella sezione "L'installazione 
		è completa!"). Dopo che avrete caricato il vostro sistema di base dall'hard disk, potrete montare
		il secondo CD e copiare i file:
		</p>
	
		<pre caption="Caricare i pacchetti binari dal CD2">
		# <i>mount /dev/cdrom /mnt/cdrom</i>
		# <i>cp -a /mnt/cdrom/packages/* /usr/portage/packages/</i>
		</pre>

		<p>
		Ora le varie altre applicazioni possono essere installate nello stesso modo. Per esempio:
		</p>

		<pre caption="Installare KDE dalla GRP">
		# <i>USE="bindist" emerge -k kde</i>
		</pre>

	</body>
      </section>
</chapter>

<chapter>
	<title>L'installazione è completa!</title>
      <section>
	<body>

		<p>
		Adesso Gentoo Linux è installato. Il solo passo che rimane da fare è aggiornare i file di
		configurazione necessari, uscire dalla shell chrooted, quindi smontare le vostre partizioni
		e riavviare il sistema:
		</p>

		<warn>
		<c>etc-update</c> vi può fornire una lista dei file di configurazione a vostra disposizione più
		recenti di quelli attualmente installati. Controllate che nessuno dei file di configurazione
		abbia un forte impatto sul sistema (come <path>/etc/fstab</path>, <path>/etc/make.conf</path>, 
		<path>/etc/rc.conf</path>, ...). Fate il merge dei file che non sortiranno un forte impatto sul
		sistema, rimuovete gli aggiornamenti degli altri o guardatene le differenze e aggiornateli 
		manualmente.
		</warn>

		<pre caption="Riavviare il sistema">
		# <i>etc-update</i>
		# <i>exit</i> 
		<comment>(Questo per uscire dalla shell chrooted; potete anche digitare <i>^D</i>)</comment>
		# <i>cd / </i>
		# <i>umount /mnt/gentoo/boot</i>
		# <i>umount /mnt/gentoo/proc</i>
		# <i>umount /mnt/gentoo</i>
		# <i>reboot</i>
		<comment>(Non dimenticatevi di rimuovere il CD avviabile)</comment>
		</pre>

		<note>
		Dopo il riavvio, è sicuramente una buona idea eseguire il comando <c>update-modules</c> 
		per creare il file <path>/etc/modules.conf</path>.  Invece di modificare questo file 
		direttamente, potrete fare le vostre modifiche al file <path>/etc/modules.d</path>.
		</note>

		<p>
		Se avete qualsiasi domanda o vi piacerebbe essere coinvolti nello sviluppo di Gentoo 
		Linux, prendete in considerazione di iscrivervi alle nostre mailing lists gentoo-user e
		gentoo-dev (maggiori informazioni sulla nostra pagina dedicata alle 
		<uri link="http://www.gentoo.org/main/en/lists.xml">mailing lists</uri>).
		Abbiamo anche una pratica 
		<uri link="http://www.gentoo.org/doc/en/desktop.xml">Guida alla configurazione del Desktop</uri> 
		che vi aiuterà a proseguire nella configurazione del vostro nuovo sistema Gentoo 
		Linux ed un'utile <uri link="http://www.gentoo.org/doc/en/portage-user.xml">Guida utente a Portage</uri>
		per aiutarvi a familiarizzare con le basi di Portage. Potete trovare il resto della Documentazione 
		Gentoo <uri link="http://www.gentoo.org/main/en/docs.xml">qui</uri> (ndt, quasi tutta la documentazione
		è disponibile anche in italiano <uri link="http://www.gentoo.org/main/it/docs.xml">qui</uri>). 
		Se avete una qualsiasi altra domanda relativa all'installazione o altri argomenti correlati, leggete le 
		<uri link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri> di Gentoo Linux. 
		Buon divertimento e benvenuti in Gentoo Linux!
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Gentoo-Stats</title>
      <section>
	<body>

		<p>
		Il programma per le statistiche di utilizzo di Gentoo Linux è un tentativo di fornire 
		agli sviluppatori maggiori informazioni circa gli utenti di base. Il programma raccoglie 
		informazioni sull'utilizzo di Gentoo Linux per aiutarci ad assegnare le priorità alle varie fasi di
		sviluppo. L'installazione è completamente opzionale e verrebbe notevolmente apprezzata la vostra 
		eventuale scelta di installarlo. Le statistiche raccolte possono essere visionate su 
		<uri>http://stats.gentoo.org/</uri>.
		</p>

		<p>
		Il server di gentoo-stats assegnerà un ID univoco al vostro sistema. Questo ID verrà usato per
		assicurarci che ogni sistema venga contato una sola volta. L'ID non sarà usato per identificare
		individualmente il vostro sistema, nemmeno per identificare il vostro IP o altre informazioni 
		personali. E' stata presa ogni precauzione per assicurare la vostra privacy nello sviluppo del
		sistema. Trovate di seguito le informazioni che vengono monitorare attraverso il programma 
		"gentoo-stats":
		</p>

		<ul>
		<li>pacchetti installati e loro numeri di versione</li>
		<li>informazioni sulla CPU: velocità (MHz), produttore, modello, flags della CPU (come "mmx" o "3dnow")</li>
		<li>informazioni sulla memoria (RAM fisica totale disponibile, spazio totale di swap disponbile)</li>
		<li>chips delle schede PCI e dei controller di rete</li>
		<li>il profilo Gentoo Linux utilizzato per la vostra macchina (vale a dire, dove punta il link
		<path>/etc/make.profile</path>).</li>
		</ul>

		<p>
		Siamo consapevoli che la conoscenza di informazioni sensibili rappresenta una minaccia per molti 
		utenti Gentoo Linux (così come lo è per gli sviluppatori).
		</p>

		<ul>
		<li>A meno che non lo modifichiate, il programma gentoo-stats non trasmetterà mai informazioni 
		sensibili quali password, dati di configurazione, taglia delle scarpe...</li>
		<li>La trasmissione del vostro indirizzo e-mail è opzionale e disabilitata di default.</li>
		<li>L'indirizzo IP da cui ha origine la trasmissione dei vostri dati non verrà mai registrato come
		modo per potervi identificare. Non c'è la coppia "indirizzo IP/ID del sistema".</li>
		</ul>

		<p>
		L'installazione è facile - basta eseguire i seguenti comandi:
		</p>

		<pre caption="Installare gentoo-stats">
		# <i>emerge gentoo-stats</i>   <comment>(Installa gentoo-stats)</comment>
		# <i>gentoo-stats --new</i>    <comment>(Ottiene un nuovo ID per il sistema)</comment>
		</pre>
		
		<p>
		Il secondo comando qui sopra richiederà un nuovo ID per il vostro sistema e lo inserirà
		automaticamente in <path>/etc/gentoo-stats/gentoo-stats.conf</path>. Potete dare un'occhiata 
		a questo file per vedere le opzioni di configurazione aggiuntive.
		</p>

		<p>
		Fatto ciò, il programma dovrà essere avviato ad intervalli regolari (gentoo-stats non deve
		girare con privilegi di root). Aggiungete questa linea nel vostro <path>crontab</path>:
		</p>

		<pre caption="Aggiornare gentoo-stats con cron">
		0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null
		</pre>

		<p>
		Il programma <c>gentoo-stats</c> è un semplice script in perl che può essere letto con il vostro
		pager o editor preferito: <path>/usr/sbin/gentoo-stats</path>.
		</p>

	</body>
      </section>
</chapter>

<chapter>
	<title>Gentoo su hardware meno comune</title>
      <section>
	<title>Hardware ATA RAID</title>
	<body>

		<p>
		Gli utenti che vogliono installare Gentoo su hardware ATA RAID devono fare attenzione
		a seguire in ordine i passi seguenti per poter portare a temine con successo l'installazione
		di Gentoo Linux:
		</p>

		<ul>
		<li>Assicuratevi di avviare il Live CD con l'opzione del kernel <c>doataraid</c>.</li>
		<li>Se avete dimenticato di scegliere l'opzione <c>doataraid</c> durante l'avvio, o i moduli
		misteriosamente non sono stati caricati, caricateli come richiesto:
		<pre caption = "Caricare i moduli RAID">
		# <i>modprobe ataraid</i>
		<comment>Per controller Raid Promise:</comment>
		# <i>modprobe pdcraid</i> 
		<comment>Per controller Raid Highpoint:</comment>
		# <i>modprobe hptraid</i>
		</pre></li>
		<li>Alcuni controller ATA RAID richiedono che riavviate il sistema dopo il partizionamento; altrimenti la
		formattazione fallirà.</li>
		<li>Prima del chrooting, montate il devicetree all'interno del nuovo ambiente:
		<pre caption = "Montare /dev in /mnt/gentoo/dev">
		# <i>mount -o bind /dev /mnt/gentoo/dev</i>
		</pre></li>
		<li>Durante la configurazione del kernel, selezionate le opzioni RAID richieste:
		<pre caption = "RAID nella conmfigurazione del Kernel Linux">
		<comment>Per controller Raid Highpoint:</comment>
		ATA/IDE/MFM/RLL support  ---&gt;
		[*] HPT36X/37X chipset support 
		[*] Support for IDE Raid controllers
		[*] Highpoint 370 software RAID
		<comment>Per controller Raid Promise:</comment>
		ATA/IDE/MFM/RLL support  ---&gt;
		[*] PROMISE PDC202{46|62|65|67} support 
		<comment>e/o</comment>
		[*] PROMISE PDC202{68|69|70|71|75|76|77} support
		[*] Support for IDE Raid controllers
		[*] Support Promise software RAID (Fasttrak(tm))
		</pre></li>
		<li>Quando installate GRUB aggiungete <c>--stage2=/boot/grub/stage2</c>, dopo aver eseguito <c>grub</c>, 
		al comando <c>setup</c>:
		<pre caption = "Installare GRUB per sistemi con Hardware RAID">
		grub&gt; <i>root (hd0,0)</i>
		grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
		grub&gt; <i>quit</i>
		</pre>
		Inoltre, nella configurazione di GRUB assicuratevi che <c>root</c> punti all'appropriato device RAID:
		<pre caption = "grub.conf per RAID">
		title=My Gentoo Linux on RAID
		root (hd0,0)
		kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
		</pre></li>
		<li>Gli utenti di LILO devono impostare l'opzione <c>root</c> con l'appropriato device RAID:
		<pre caption = "lilo.conf per RAID">
		image=/boot/bzImage
		label=linux
		read-only
		root=/dev/ataraid/dXpY
		</pre></li>
		</ul>

		<p>
		Se riscontrate problemi durante l'installazione di Gentoo Linux sul vostro hardware RAID,
		assicuratevi di riportare un bug report su <uri>http://bugs.gentoo.org</uri>. 
		</p>

		<p>
		Grazie per aver scelto Gentoo Linux, divertitevi con la vostra nuova installazione!
		</p>

	</body>
      </section>
</chapter>
</guide>


