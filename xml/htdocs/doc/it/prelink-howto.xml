<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/prelink-howto.xml,v 1.7 2005/04/06 09:45:39 neysx Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/it/prelink-howto.xml" lang="it">
<title>Gentoo Linux Prelink Guide</title>

<author title="Autore">
  <mail link="cretin@gentoo.org">Stefan Jones</mail>
</author>
<author title="Redazione"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Redazione">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Redazione">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Redazione">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Traduzione">
  <mail link="myzelf@omnidea.it">Gilberto De Faveri</mail>
</author>
<author title="Revisione">
  <mail link="posta@massimo.biz">Massimo Canali</mail>
</author>

<abstract>
Questa guida documenta come utilizzare il supporto al prelink in portage 2.0.46
e successivi.
</abstract>

<license/>

<version>1.11</version>
<date>2005-03-25</date>

<chapter>
<title>Introduzione</title>
<section>
<title>Cos'è il prelink e come può essermi d'aiuto?</title>
<body>

<p>
Le più comuni applicazioni utilizzano librerie condivise. Queste librerie
condivise devono essere caricate in memoria durante l'esecuzione ed i vari
simboli e riferimenti devono essere risolti. Per la maggior parte dei piccoli
programmi tale linking dinamico è molto veloce, ma per i programmi scritti in
C++ che dipendono da molte librerie, il linking dinamico può richiedere una
discreta quantità di tempo.
</p>

<p>
Nella maggior parte dei sistemi le librerie non vengono modificate molto spesso
e, quando un programma è avviato, le operazioni effettuate per il linking sono
sempre le stesse. Il prelink sfrutta questa particolarità estraendo le
informazioni relative al linking e memorizzandole nell'eseguibile,
prelinkandolo, appunto.
</p>

<p>
Il prelinking può accorciare il tempo di apertura delle applicazioni. Ad
esempio, il tempo di caricamento di un qualsiasi programma KDE può essere
abbreviato fino al 50%. Le uniche operazioni di manutenzione richieste prevedono
di lanciare prelink ogni volta che una libreria di un eseguibile prelinkato
viene aggiornata.
</p>

</body>
</section>

<section>
<title>In breve</title>
<body>

<ul>
  <li>
    Il prelinking viene effettuato attraverso un programma chiamato,
    incredibilmente, <c>prelink</c>, che modifica gli eseguibili per farli
    partire più velocemente.
  </li>
  <li>
    Se una libreria da cui dipende un'applicazione viene modificata dopo il
    prelink, è necessario prelinkare nuovamente l'eseguibile, altrimenti si
    perdono i vantaggi in termini di prestazioni. In altre parole, ogni volta
    che viene aggiornato con portage un pacchetto che aggiorna delle
    librerie, è necessario effettuare
    nuovamente il prelink.
  </li>
  <li>
    I cambiamenti agli eseguibili sono completamente
    reversibili. <c>prelink</c> ha una funzione di undo.
  </li>
  <li>
    Le versione corrente di Portage tratta correttamente, attraverso
    <c>prelink</c>, i cambiamenti di MD5sum e mtime degli eseguibili.
  </li>
  <li>
    Non è necessario impostare <c>FEATURES="prelink"</c> in
    <path>make.conf</path>: Portage si appoggerà automaticamente a prelink
    se troverà il file binario 'prelinkato'.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Impostare il Prelink</title>
<section>
<title>Installare i programmi</title>
<body>

<p>
Per iniziare è necessario installare <c>prelink</c>. Durante l'esecuzione,
emerge verifica automaticamente che prelink sia supportato dal tuo sistema.
</p>


<p>
Ora è possibile emergere i tool di prelinking. L'installazione verifica
automaticamente che nel sistema il prelink possa essere attivato in modo sicuro.
</p>

<pre caption = "Installazione di prelink">
# <i>emerge prelink</i>
</pre>

<p>
Molte persone hanno problemi emergendo prelink perché i test effettuati
falliscono. I test sono stati inseriti per motivi di sicurezza e il
comportamento di prelink è imprevedibile se vengono disabilitati. Gli errori di
emerge sono di solito relativi a pacchetti fondamentali come binutils, gcc e
glibc. Prova a ri-emergerli in questo ordine.
</p>

<note>
Tip: Se ottieni degli errori prova a compilare e testare <c>prelink</c>
manualmente (<c>./configure</c> ; <c>make</c> ; <c>make check</c> ). In caso di
problemi consulta i file *.log nella directory testsuite, che potrebbero fornire
alcuni utili suggerimenti.
</note>

<p>
Se puoi riprodurre passo passo un errore di emerge su un altro sistema manda una
mail a <mail link="cretin@gentoo.org">Stefan Jones</mail>.
</p>

</body>
</section>
<section>
<title>Preparare il sistema</title>
<body>

<p>
A questo punto è necessario aggiungere la use FLAG "pic" a
<path>/etc/make.conf</path>. Non dimenticare di eseguire <c>emerge --update
--deep --newuse world</c> in modo tale da incorporare il cambiamento di use
FLAG nel tuo sistema.
</p>

<p>
Assicurati anche di <e>non</e> avere -fPIC nelle CFLAGS/CXXFLAGS. Se così
fosse, dovrai togliere -fPIC e ricompilare l'intero sistema.
</p>

</body>
</section>
<section>
<title>Configurazione</title>
<body>

<p>
L'esecuzione di <c>env-update</c> genera il file <path>/etc/prelink.conf</path>
da cui <path>prelink</path> rileva i files da prelinkare.
</p>

<pre caption="Eseguire env-update">
# <i>env-update</i>
</pre>

<p>
Purtroppo non è possibile abilitare il prelink per file compilati con vecchie
versioni di binutils. La maggior parte di queste applicazioni proviene da
pacchetti precompilati o binary-only, che sono installati in <path>/opt</path>.
Creando il seguente file possiamo evitare che prelink tenti di prelinkarli.
</p>

<pre caption="/etc/env.d/60prelink">
PRELINK_PATH_MASK="/opt"
</pre>

<note>
È possibile aggiungere altre directory separandole con i due punti (:).
</note>

</body>
</section>
</chapter>

<chapter>
<title>Prelinking</title>
<section>
<title>Utilizzo di prelink</title>
<body>

<p>
Io utilizzo il seguente comando per prelinkare tutti gli eseguibili nelle
directory elencate da <path>/etc/prelink.conf</path>.
</p>

<pre caption = "Prelink dei file elencati">
# <i>prelink -amR</i>
</pre>

<warn>
È stato osservato che se si dispone di poco spazio libero su disco e si prelinka
l'intero sistema è possibile che gli eseguibili vengano troncati. Il risultato
finale è un sistema corrotto. Utilizza i comandi <c>file</c> o <c>readelf</c>
per verificare lo stato dei file binari. In alternativa, controlla lo spazio
libero su disco con <c>df -h</c> prima di procedere.
</warn>

<table>
<tr>
  <th>La spiegazione delle opzioni:</th>
</tr>
<tr>
  <th>-a</th>
  <ti>"All": prelinka tutti i binari.</ti>
</tr>
<tr>
  <th>-m</th>
  <ti>
    Conserva lo spazio in memoria virtuale. È necessario
    se ci sono molte librerie che hanno bisogno di essere
    prelinkate.
  </ti>
</tr>
<tr>
  <th>-R</th>
  <ti>
    Random -- rende casuale l'ordinamento degli
    indirizzi, in modo da aumentare la sicurezza
    verso i buffer overflow.
  </ti>
</tr>
</table>

<note>
Per maggiori opzioni e gli altri dettagli, utilizzare <c>man prelink</c>.
</note>

</body>
</section>
<section>
<title>Incrementare le Prestazioni di KDE dopo il Prelinkings</title>
<body>

<p>
Dopo il prelinking è possibile ridurre il tempo di caricamento di KDE. Se KDE
rileva di essere stato prelinkato allora disabiliterà il caricamento di
<c>kdeinit</c> (visto che non è più necessario) con un incremento delle sue
prestazioni.
</p>

<p>
Per fare in modo che KDE rilevi il prelinking impostare
<c>KDE_IS_PRELINKED="true"</c> in <path>/etc/env.d/99kde-env</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemi Noti e Soluzioni</title>
<section>
<title>&quot;Impossibile prelinkare con librerie condivise non-PIC&quot;</title>
<body>

<p>
La causa di questo problema è l'errata compilazione di librerie condivise, senza
l'opzione -fPIC di gcc per tutti i relativi file oggetto.
</p>

<p>
Segue una lista delle librerie problematiche e dei relativi pacchetti da
ri-emergere in caso di errore.
</p>

<pre caption = "Soluzioni">
<comment>(Per la libreria ORBit /usr/lib/libIIOP.so.0.5.17)</comment>
# <i>emerge ">=sys-apps/tcp-wrappers-7.6-r4" ORBit</i>

<comment>(Per la libreria zlib /usr/lib/libz.so.1.1.4)</comment>
# <i>emerge ">=sys-libs/zlib-1.1.4"</i>

<comment>(Per svgalib, /usr/lib/libsvga.so.xx)</comment>
# <i>emerge ">=media-libs/svgalib-1.9.16"</i>

<comment>(Per libpcap.so.0.6)</comment>
# <i>emerge ">=net-libs/libpcap-0.7.1-r2"</i>

<comment>(Per la libreria lcms, /usr/lib/liblcms.so.1)</comment>
# <i>emerge ">=media-libs/lcms-1.09"</i>
</pre>

<note>
Molte librerie sono linkate staticamente a zlib e/o tcp-wrappers, quindi per
prima cosa emergere quelle librerie e quindi ri-emergere le librerie che
presentano il problema.
</note>

<p>
Qui ci sono le librerie che non sono state corrette o non possono essere
corrette:
</p>

<ul>
  <li>
    Le librerie nel pacchetto wine, incluso winex. Il prelinking
    non velocizzerebbe comunque gli eseguibili MS Windows.
  </li>
  <li>
    Le librerie in media-video/mjpegtools,
    <path>/usr/lib/liblavfile-1.6.so.0</path>.
  </li>
</ul>

<p>
Se le librerie che danno problemi non sono elencate, segnalale e allega,
preferibilmente, una patch per aggiungere <c>-fPIC</c> alle relative CFLAGS.
</p>

</body>
</section>
<section>
<title>&quot;&lt;file&gt;: error while loading shared libraries: unexpected
reloc type...&quot;</title>
<body>

<p>
Questo problema è stato risolto in <c>sys-libs/glibc-2.3.1-r2</c> il 2002/11/18,
ri-emergi le glibc se sono più vecchie.
</p>

<p>
È stato rilevato anche che <c>prelink -u -a -m</c> ; <c>prelink -a -m</c> può
aiutare. Se tutte le altre soluzioni falliscono eseguire semplicemente
<c>prelink -u &lt;file&gt;</c>.
</p>

</body>
</section>
<section>
<title>Quando prelinko il mio sistema alcuni binari statici non funzionano più</title>
<body>

<p>
Quando si ha a che fare con le glibc, non si ottiene mai un binario statico al
100%. Anche se si compila staticamente un binario con glibc, potrebbe ancora
dipendere da altri file di sistema. Ecco una spiegazione di Dick Howell,
</p>

<p>
&quot;Generalmente si presuppone che tutto il necessario sia contenuto nel file
scaricato, in modo che l'applicazione non dipenda da librerie installate sul
sistema locale. Sfortunatamente in Linux, e credo in qualsiasi altro sistema usi
le glibc, ciò non è del tutto vero. Ad esempio "libnss" (name service switch,
chiamata da alcuni network security system), che fornisce delle funzioni per
accedere a diversi database per l'autenticazione, informazioni di rete ed altro,
dovrebbe creare applicazioni indipendenti dall'effettivo ambiente di rete di una
macchina. Una bella idea, ma modifiche alle glibc possono generare problemi nel
tentativo di caricarla. E non è possibile linkare staticamente "libnss", poiché
è configurata per ogni macchina individualmente. Credo che il problema derivi
principalmente dal linkare staticamente altre librerie glibc, in particolare
"libpthread", "libm" e "libc", da cui provengono chiamate incompatibili a
funzioni di "libnss".&quot;
</p>

</body>
</section>
<section>
<title>Prelink si blocca con l'errore &quot;prelink: dso.c:306: fdopen_dso:
Assertion
`j == k' failed.&quot;</title>
<body>

<p>
Questo problema è noto e ben documentato <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=13878">qui</uri>. Prelink non
funziona con eseguibili compressi in formato UPX. Per ora (prelink-20021213) non
esiste alcuna soluzione eccetto quella di nascondere a prelink gli eseguibili in
questione. Leggi la <uri link="#doc_chap2_sect2">sezione Configurazione</uri>
per sapere come farlo facilmente.
</p>

</body>
</section>
<section>
<title>Uso grsecurity e sembra che il prelinking non funzioni.</title>
<body>

<p>
Per prelinkare su un sistema con grsecurity che utilizza chiamate mmap() casuali
è necessario disattivare "randomized mmap() base" per
<path>/lib/ld-2.3.*.so</path>. Per fare ciò, utilizzare il tool <c>chpax</c>
quando tali file non sono in uso (ad esempio, facendo il boot da un CD di
ripristino).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Conclusioni</title>
<section>
<body>

<p>
Il prelinking può velocizzare notevolmente il tempo di avvio di numerose
applicazioni complesse e portage supporta nativamente questa tecnologia. Inoltre
il prelinking è sicuro, perché è sempre possibile annullarlo per i binari che
presentano problemi. Ricorda che, se le glibc o altre librerie prelinkate
vengono aggiornate, è necessario eseguire nuovamente <path>prelink</path>! Buona
fortuna!
</p>

</body>
</section>
</chapter>
</guide>
