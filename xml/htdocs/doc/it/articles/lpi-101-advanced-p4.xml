<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/articles/lpi-101-advanced-p4.xml,v 1.3 2012/02/26 08:33:40 swift Exp $ -->

<guide disclaimer="articles"
lang="it">
<title>Preparazione all'esame per la Certificazione LPI 101 (release 2), Parte
4</title>

<author title="Autore">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autore">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Autore">
  <mail link="agriffis@gentoo.org">Aron Griffis</mail>
</author>
<author title="Traduzione">
  <mail link="skypjack@gmail.com">Michele Caini</mail>
</author>

<abstract>
In questa breve guida, saranno introdotti tutti i filesystem popolari in Linux.
Sarà spiegato come montare e smontare dispositivi. Nel prossimo capitolo sarà
illustrato come avviare il sistema e come lavorare con i runlevel. Nella
prossima sezione di questa breve guida, verranno introdotte le quote su
filesystem, sarà spiegato come impostarle e come configurarle. Verso la fine di
questa breve guida verranno discussi i log di sistema.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This
document is an updated version of the original article, and contains
various improvements made by the Gentoo Linux Documentation team -->

<version>1.0</version>
<date>2005-12-17</date>

<chapter>
<title>Prima di cominciare</title>
<section>
<title>Riguardo a questa breve guida</title>
<body>

<p>
Il lettore è il benvenuto ad "Amministrazione avanzata", l'ultima di quattro
brevi guide pensate come preparazione per l'esame 101 (release 2) del Linux
Professional Institute. In questa breve guida (Parte 4), sarà rinforzata la
propria conoscenza nelle tecniche avanzate di amministrazione in Linux coprendo
una varietà di argomenti fra i quali i filesystem in Linux, il processo di avvio
(o boot) di Linux, i runlevel, le quote sui filesystem e i log di sistema.
</p>

<p>
Questa breve guida è particolarmente adatta a qualcuno che dovesse svolgere il
ruolo di amministratore di sistema principale per la prima volta, dato che copre
molti problemi di basso livello che tutti gli amministratori di sistema
dovrebbero conoscere. Se si è nuovi in Linux, è raccomandato di cominciare con
la <uri link="/doc/it/articles/lpi-101-fundamentals-p1.xml">Parte 1</uri> e
continuare attraverso la serie fino a questo punto. Per qualcuno, molto di
questo materiale sarà nuovo, ma alcuni utenti Linux con più esperienza
potrebbero trovare questa breve guida solo un bel modo di "smussare" i propri
fondamenti sulle capacità come amministratori di sistema Linux e prepararsi così
per il prossimo livello della certificazione LPI.
</p>

<p>
Verso la fine di questa serie di brevi guide (otto in tutto che coprono gli
esami 101 e 102 del LPI), si avrà la conoscenza necessaria per diventare un
Amministratore di Sistema Linux e il lettore sarà pronto a conseguire la
certificazione LPIC di Livello 1 del Linux Professional Institute se lo
desidera.
</p>

<p>
Per coloro che hanno prelevato la <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxlpi4-i.html">versione
di rilascio 1</uri> di questa breve guida per ragioni ulteriori oltre alla
preparazione dell'esame del LPI, probabilmente non è necessario prendere anche
questa. Comunque, se si sta pianificando di sostenere l'esame, si dovrebbe
considerare seriamente la lettura di questa breve guida revisionata.
</p>

<p>
Il logo LPI è un marchio del Linux Professional Institute.
</p>

</body>
</section>
<section>
<title>Riguardo gli autori</title>
<body>

<p>
Per questioni tecniche riguardo i contenuti di questa breve guida, contattare
gli autori:
</p>

<ul>
  <li>Daniel Robbins, su <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, su <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, su <mail>agriffis@gentoo.org</mail>.</li>
</ul>

<p>
Daniel Robbins vive in Albuquerque, New Mexico, ed è l'Architetto Capo di <uri
link="http://www.gentoo.org">Gentoo Technologies, Inc.</uri>, il creatore di
Gentoo Linux, un'avanzata versione di Linux per Pc, e del sistema Portage, un
sistema di porting per Linux di prossima generazione. Ha anche dato il suo
contributo come autore per i libri Macmillan Caldera OpenLinux Unleashed, SuSE
Linux Unleashed e Samba Unleashed. Daniel è stato coinvolto con i computer in
molti modi fino dalla seconda classe, quando fu avviato per la prima volta al
linguaggio di programmazione Logo così come ad una potenzialmente pericolosa
dose di Pac Man. Questo forse spiega perché è stato fino da allora impiegato
come un Lead Graphic Artist (letteralmente, artista grafico di punta) dalla SONY
Electronic Publishing/Psygnosis. Daniel si diverte passando il proprio tempo con
la moglie, Mary, e sua figlia, Hadassah.
</p>

<p>
Chris Houser, conosciuto dagli amici come "Chouser", è diventato un sostenitore
di UNIX fin dal 1994 quando ha preso parte al gruppo di amministrazione delle
reti scentifiche di calcolatori alla Taylor University nell'Indiana, dove ha
conseguito la sua laurea in Scienze Informatiche e Matematiche. Fino da allora,
ha continuato a lavorare nella programmazione di applicazioni Web, sviluppo di
interfacce utente, supporto professionale al software video e ora alla
programmazione di driver per dispositivi Tru64 UNIX alla <uri
link="http://www.compaq.com/">Compaq</uri>. Ha anche contribuito a diversi
progetti di software libero, più recentemente a <uri
link="http://www.gentoo.org">Gentoo Linux</uri>. Vive con sua moglie e due gatti
in New Hampshire.
</p>

<p>
Aron Griffis è diplomato alla Taylor University con una laurea in Scienze
Informatiche e un premio che dichiara, "Futuro Fondatore di un utopistico gruppo
UNIX". Lavorando verso questo obiettivo, Aron è impiegato presso <uri
link="http://www.compaq.com/">Compaq</uri> scrivendo driver di rete per Tru64
UNIX e spende il suo tempo libero accordando il piano o sviluppando <uri
link="http://www.gentoo.org">Gentoo Linux</uri>. Vive con sua moglie Amy (anche
lei ingegnere UNIX) in Nashua, NH.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Filesystem, partizioni e dispositivi a blocchi</title>
<section>
<title>Introduzione ai dispositivi a blocchi</title>
<body>

<p>
In questa sezione sarà data una buona base agli aspetti orientati al disco di
Linux, inclusi i filesystem in Linux, le partizioni e i dispositivi a blocchi.
Una volta che si avrà preso familiarità con i particolari su dischi e
filesystem, il persorso continuerà attraverso il processo di preparazione delle
partizioni e dei filesystem in Linux.
</p>

<p>
Per cominciare, saranno introdotti i "dispositivi a blocchi". Il più famoso
dispositivo a blocchi è probabilmente quello che rappresenta il primo componente
sull'IDE in un sistema Linux:
</p>

<pre caption="Primo dispositivio sull'IDE in Linux">
/dev/hda
</pre>

<p>
Se il proprio sistema usa dispositivi SCSI, il primo disco fisso sarà:
</p>

<pre caption="Primo dispositivo SCSI in Linux">
/dev/sda
</pre>

</body>
</section>
<section>
<title>Livelli di astrazione</title>
<body>

<p>
Il dispositivo a blocchi di cui sopra rappresenta un'interfaccia astratta per il
disco. I programmi utente possono usare questi dispositivi a blocchi per
interagire con il disco senza preoccuparsi se l'interfaccia è realmente un'IDE,
SCSI o qualsiasi cosa. Il programma può semplicemente indirizzare la memoria sul
disco come un gruppo di blocchi contigui ad accesso casuale con dimensione pari
a 512 byte.
</p>

</body>
</section>
<section>
<title>Partizioni</title>
<body>

<p>
Sotto Linux, si creano filesystem usando uno speciale comando chiamato
<c>mkfs</c> (0 <c>mke2fs</c>, <c>mkreiserfs</c>, etc.), specificando un
particolare dispositivo a blocchi come argomento a riga di comando.
</p>

<p>
Comunque, nonostante sia teoricamente possibile usare un "intero disco" come
dispositivo a blocchi (uno che rappresenti l'intero disco) come
<path>/dev/hda</path> o <path>/dev/sda</path> per ospitare un singolo
filesystem, questo non avviene quasi mai in pratica. Invece, dispositivi a
blocchi disco interi vengono divisi in più piccole e maneggevoli dispositivi a
blocchi chiamati partizioni. Le partizioni sono create usando uno strumento
chiamato <c>fdisk</c>, che è usato per creare e modificare la tabella delle
partizioni che è immagazzinata in ogni disco. La tabella delle partizioni
definisce esattamente come suddividere l'intero disco.
</p>

</body>
</section>
<section>
<title>Introduzione a fdisk</title>
<body>

<p>
È possibile dare un'occhiata alla tabella delle partizioni di un disco eseguendo
<c>fdisk</c>, specificando un dispositivo a blocchi che rappresenta un intero
disco come argomento.
</p>

<note>
Interfacce alternative alla tabella delle partizioni di un disco includono
<c>cfdisk</c>, <c>parted</c> e <c>partimage</c>. Raccomando di evitare l'uso di
<c>cfdisk</c> (nonostante ciò che dica la pagina di manuale di fdisk) perché
talvolta calcola la geometria di un disco in modo errato.
</note>

<pre caption="Usare fdsik su un dispositivo IDE">
# <i>fdisk /dev/hda</i>
</pre>

<pre caption="Usare fdisk su un dispositivo SCSI">
# <i>fdisk /dev/sda</i>
</pre>

<impo>
<e>Non</e> si dovrebbe salvare o apportare alcuna modifica alla tabella delle
partizioni di un disco se qualcuna delle sue partizioni contiene un filesystem
che è in uso o contiene dati importanti. Farlo di solito causa la perdita dei
dati presenti su disco.
</impo>

</body>
</section>
<section>
<title>Dentro fdisk</title>
<body>

<p>
Una volta in <c>fdisk</c>, l'utente sarà accolto da un prompt che assomiglia al
seguente:
</p>

<pre caption="Prompt di benvenuto di fdisk">
Command (m for help):
</pre>

<p>
Digitare <c>p</c> per mostrare la configurazione attuale delle partizioni su
disco:
</p>

<pre caption="Mostrare la configurazione attuale delle partizioni">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
Questo particolare disco è configurato per ospitare sette filesystem Linux
(ognuno con una corrispondente partizione elencata come "Linux") così come una
partizione di swap (elencata come "Linux swap").
</p>

</body>
</section>
<section>
<title>Panoramica su dispositivi a blocchi e partizionamento</title>
<body>

<p>
Notare i nomi delle corrispondenti partizioni dei dispositivi a blocchi sul lato
sinistro, questi iniziano da <path>/dev/hda1</path> e proseguono fino a
<path>/dev/hda9</path>. Nei primi PC, il software di partizionamento permetteva
solo un massimo di quattro partizioni (chiamate partizioni primarie). Questo era
troppo limitativo, quindi è stato escogitato un modo per ovviare a questo
problema, ovvero tramite il partizionamento esteso. Una partizione estesa è
molto simile ad una partizione primaria e si somma al limite di quattro
partizioni primarie. Comunque, le partizioni estese possono contenere un
qualsiasi numero delle così dette partizioni logiche al loro interno, fornendo
un modo effettivo per superare il limite delle quattro partizioni.
</p>

</body>
</section>
<section>
<title>Panoramica sulle partizioni, continua</title>
<body>

<p>
Tutte le partizioni come hda5 e superiori sono partizioni logiche. I numeri da 1
a 4 sono riservati per partizioni primarie ed estese.
</p>

<p>
Nell'esempio sopra, da hda1 a hda3 sono partizioni primarie, hda4 è una
partizione estesa che contiene le partizioni logiche da hda5 a hda9. In effetti
non dovrebbe mai essere usata <path>/dev/hda4</path> per immagazzinare
direttamente un filesystem -- semplicemente assume il ruolo di contenitore per
le partizioni da hda5 a hda9.
</p>

</body>
</section>
<section>
<title>Tipi di partizione</title>
<body>

<p>
Inoltre, bisogna notare che ogni partizione ha un "Id", anche chiamato tipo di
partizione. Ogni volta che viene creata una nuova partizione, ci si deve
assicurare che il tipo di partizione sia impostato correttamente. 83 è il tipo
di partizione corretto per le partizioni che dovranno ospitare filesystem Linux
e 82 è il tipo di partizione corretto per partizioni swap Linux. È possibile
impostare il tipo di partizione usando l'opzione t in <c>fdisk</c>. Il kernel
Linux usa il tipo di partizione impostato per auto-rilevare il filesystem e i
dispositivi di swap sul disco all'avvio.
</p>

</body>
</section>
<section>
<title>Usare fdisk per configurare le partizioni</title>
<body>

<p>
Adesso che è stata data un'introduzione al modo in cui il partizionamento del
disco avviene sotto Linux, è il momento di procedere attraverso il processo di
configurazione delle partizione del disco e dei filesystem per una nuova
installazione di Linux. In questo processo, sarà impostato un disco con quattro
nuove partizioni e quindi verranno creati filesystem su di esse. Questi passi
condurranno ad un disco completamente pulito senza dati al suo interno che può
essere usato come base per una nuova installazione di Linux.
</p>

<impo>
Per seguire questi passi, è necessario avere un disco rigido che non contiene
alcun dato importante, dato che il procedimento <e>cancellerà</e> i dati sul
disco stesso. Se tutto ciò è nuovo al lettore, è consigliabile solamente dare
una lettura a questi passaggi o in alternativa usare un disco di avvio di Linux
su un sistema di test così che nessun dato sarà in pericolo.
</impo>

</body>
</section>
<section>
<title>Come sarà il disco partizionato</title>
<body>

<p>
Dopo aver attraversato il processo di creazione delle partizioni sul proprio
disco, la configurazione delle partizioni dovrebbe assomigliare alla seguente:
</p>

<pre caption="Uno sguardo al disco dopo aver creato le partizioni">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1    *        1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

</body>
</section>
<section>
<title>Commento all'esempio di partizionamento</title>
<body>

<p>
Nella configurazione delle partizioni "da principianti" proposta, ci sono tre
partizioni. La prima (<path>/dev/hda1</path>) all'inizio del disco è una piccola
partizione chiamata partizione d'avvio (o di boot). Lo scopo della partizione di
boot è quella di contenere tutti i dati critici relativi all'avvio --
informazioni sul boot loader GRUB (se si userà GRUB) così come anche i(l) kernel
Linux. La partizione di boot fornisce un posto sicuro per immagazzinare tutto
ciò che è legato all'avvio di Linux. Durante il normale uso di Linux di tutti i
giorni, la propria partizione di boot dovrebbe rimanere non montata per
sicurezza. Se si è impostato un sistema SCSI, la partizione di boot
probabilmente risulterà essere chiamata <path>/dev/sda1</path>.
</p>

<p>
È raccomandato avere partizioni di boot (contenenti tutto ciò che è necessario
per far funzionare il boot loader) all'inizio del disco. Anche se non è più un
requisito necessario ad oggi, è una utile tradizione dai giorni in cui il boot
loader LILO non era capace di caricare kernel da filesystem che si estendevano
oltre il cilindro 1024 del disco.
</p>

<p>
La seconda partizione (<path>/dev/hda2</path>) è usata per lo spazio di swap. Il
kernel usa lo spazio di swap come memoria virtuale quando la RAM scarseggia.
Questa partizione, relativamente parlando, non è molto grande, di solito
qualcosa come 512 MB. Se si sta impostando un sistema SCSI, questa partizione
probabilmente risulterà essere chiamata <path>/dev/sda2</path>.
</p>

<p>
La terza partizione (<path>/dev/hda3</path>) è abbastanza grande e copre il
resto del disco. Questa partizione è chiamata partizione di root (radice) e sarà
usata per ospitare il proprio filesystem che conterrà il filesystem principale
di Linux. Su un sistema SCSI, la partizione risulterà essere chiamata
<path>/dev/hda3</path>.
</p>

</body>
</section>
<section>
<title>Per cominciare</title>
<body>

<p>
Adesso bisogna creare le partizioni come nell'esempio e la tabella sopra. Primo,
entrare in fdisk digitando <c>fdisk /dev/hda</c> o <c>fdisk /dev/sda</c>, a
seconda che si usi IDE o SCSI. Quindi, digitare <c>p</c> per vedere la propria
configurazione attuale di partizionamento. Se c'è qualcosa sul disco che si
desidera recuperare, fermarsi subito. Continuando in questa direzione, tutti i
dati esistenti sul proprio disco saranno cancellati.
</p>

<impo>
Seguendo le istruzioni sotto riportate si causerà la cancellazione di tutti i
dati contenuti sul proprio disco. Se c'è qualcosa sul proprio disco, si prega di
assicurarsi che siano informazioni non critiche la cui perdita non ha
importanza. Inoltre assicurarsi di aver selezionato il dispositivo corretto così
da non cancellare per errore dati dal disco sbagliato.
</impo>

</body>
</section>
<section>
<title>Eliminare le partizioni esistenti</title>
<body>

<p>
Ora, è il momento di cancellare le partizioni esistenti. Per farlo, digitare d e
premere invio. Verrà chiesto all'utente il numero di partizione che desidera
cancellare. Per eliminare una pre-esistente <path>/dev/hda1</path>, bisogna
digitare:
</p>

<pre caption="Cancellare una partizione pre-esistente">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
La partizione è stata accodata per la cancellazione. Non apparirà più digitando
<c>p</c>, ma non sarà cancellata fino a che le proprie modifiche non verranno
salvate. Se si è fatto un errore e si vuole interrompere senza salvare le
modifiche, digitare immediatamente <c>q</c> e premere invio a la propria
partizione non sarà cancellata.
</p>

<p>
Adesso, assumendo che davvero si vogliano cancellare tutte le partizioni sul
proprio sistema, digitare ripetutamente <c>p</c> per stampare una lista delle
partizioni e quindi digitare <c>d</c> e il numero della partizione da
cancellare. In conclusione, si finirà per avere una tabella delle partizioni
vuota:
</p>

<pre caption="Come apparirà il dispositivo dopo la pulizia">

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

</body>
</section>
<section>
<title>Creare una partizione di boot</title>
<body>

<p>
Ora che la tabella delle partizioni in memoria è vuota, si è pronti per creare
una partizione di boot (avvio). Per farlo, digitare <c>n</c> per creare una
nuova partizione, quindi <c>p</c> per dire a fdisk che si vuole una partizione
primaria. Ancora, digitare <c>1</c> per creare la prima partizione primaria.
Quando viene chiesto qualcosa al riguardo dell'ultimo cilindro, digitare
<c>+100M</c> per creare una partizione della dimensione di 100MB. Di seguito il
risultato di questi passi:
</p>

<pre caption="Creare una partizione di boot">
Command (m for help): <i>n</i>
Command action
e   extended
p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+100M</i>
</pre>

<p>
Adesso, digitando <c>p</c>, dovrebbe essere mostrato il seguente listato in
merito alle partizioni:
</p>

<pre caption="Lista delle partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

</body>
</section>
<section>
<title>Creare la partizione di swap</title>
<body>

<p>
Proseguendo, bisogna creare la partizione di swap. Per farlo, digitare <c>n</c>
per creare una nuova partizione, quindi <c>p</c> per dire a fdisk che si vuole
una partizione primaria. Ancora, digitare <c>2</c> per creare la seconda
partizione primaria, <path>/dev/hda2</path> nel caso proposto. Quando viene
chiesto qualcosa al riguardo del primo cilindro, premere invio. Quando viene
chiesto qualcosa al riguardo dell'ultimo cilindro, digitare <c>+512M</c> per
creare una partizione delle dimensioni di 512MB. Dopo aver fatto tutto questo,
premere <c>t</c> per impostare il tipo della partizione e quindi digitare
<c>82</c> per assegnare il tipo di partizione "Linux Swap". Alla fine di questi
passi, digitando <c>p</c> dovrebbe essere mostrata una tabella delle partizioni
che assomiglia alla seguente:
</p>

<pre caption="Tabella delle partizioni">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

</body>
</section>
<section>
<title>Rendere avviabile</title>
<body>

<p>
Alla fine, è necessario impostare il flag "bootable" (avviabile) sulla propria
partizione di boot e poi scrivere le modifiche su disco. Per etichettare
<path>/dev/hda1</path> come partizione "avviabile", premere <c>a</c> nel menù e
quindi digitare 1 come numero di partizione. Premendo adesso <c>p</c>, è
possibile vedere che <path>/dev/hda1</path> ha un "*" nella colonna "Boot". Ora,
bisogna scrivere le modifiche su disco. Per farlo, digitare <c>w</c> e premere
invio. Le partizioni del proprio disco saranno adesso correttamente configurate
per l'installazione di Linux.
</p>

<note>
Se fdisk invita a farlo, si prega di riavviare per permettere al proprio sistema
di rilevare la nuova configurazione di partizionamento.
</note>

</body>
</section>
<section>
<title>Partizionamento esteso e logico</title>
<body>

<p>
Nell'esempio sopra, è stata creata una singola partizione primaria che conterrà
un filesystem usato per immagazzinare tutti i propri dati. Questo significa che,
dopo aver installato Linux, questo filesystem principale sarà montato come
"<path>/</path>" e conterrà un albero di cartelle che contiene tutti i propri
file.
</p>

<p>
Sebbene questo sia un modo comune di impostare un sistema Linux, c'è un altro
approccio con cui si dovrebbe avere familiarità. Questo approccio usa partizioni
multiple che ospitano filesystem diversi e sono quindi "collegate" insieme per
formare un albero di filesystem coeso. Per esempio, è comune mettere
<path>/home</path> e <path>/var</path> ognuno sul proprio filesystem.
</p>

<p>
La partizione hda2 potrebbe essere fatta come partizione estesa piuttosto che
come partizione primaria. Quindi, potrebbero essere create hda5, hda6 e hda7
come partizioni logiche (che dovrebbero essere tecnicamente contenute "dentro" a
hda2), che potrebbero ospitare rispettivamente i filesystem <path>/</path>,
<path>/home</path> e <path>/var</path>.
</p>

<p>
È possibile imparare altro riguardo questi tipi di configurazione a filesystem
multipli studiando le risorse elencate nel prossimo paragrafo.
</p>

</body>
</section>
<section>
<title>Risorse sul partizionamento</title>
<body>

<p>
Per maggiori informazioni sul partizionamento, si può dare un'occhiata ai
seguenti trucchi al riguardo:
</p>

<ul>
  <li>
    <uri link="/doc/it/articles/partition-planning-tips.xml">Trucchi sulla
    pianificazione del partizionamento</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/partitioning-p2.xml">Partizionamento in atto:
    consolidare i dati</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/partitioning-p1.xml">Partizionamento in atto:
    spostare /home</uri>.
  </li>
</ul>

</body>
</section>
<section>
<title>Creazione dei filesystem</title>
<body>

<p>
Adesso che le partizioni sono state create, è il momento di impostare i
filesystem sulle partizioni di boot e root così che possano essere montate e
usate per immagazzinare dati. Bisogna anche configurare la partizione di swap
per essere usate come memoria swap.
</p>

<p>
Linux supporta una varietà di diversi tipi di filesystem; ogni tipo ha i suoi
punti forti e le sue debolezze e il proprio insieme di caratteristiche
prestazionali. In questa breve guida verrà discussa la creazione dei filesystem
ext2, ext3, XFS, JFS e ReiserFS. Prima di creare filesystem sul sistema di
esempio, verrà fatto un breve riassunto dei vari filesystem disponibili sotto
Linux. Saranno discussi in modo più dettagliato i filesystem più avanti in
questa stessa guida.
</p>

</body>
</section>
<section>
<title>Il filesystem ext2</title>
<body>

<p>
Il filesystem per Linux ext2 è del tipo testato e provato, ma non ha metadati
per il journaling e ciò significa che i processi di controllo del filesystem
ext2 al momento dell'avvio possono essere abbastanza lunghi. Ad oggi esiste una
selezione abbastanza ampia di filesystem journaled di nuova generazione che
possono essere controllati nella loro consistenza molto velocemente e sono
perciò solitamente preferiti al posto delle loro controparti non-journaled. I
filesystem journaled impediscono lunghe attese all'avvio del proprio sistema
quando il proprio filesystem sembra essere in uno stato inconsistente.
</p>

</body>
</section>
<section>
<title>Il filesystem ext3</title>
<body>

<p>
Il filesystem ext3 è la versione journaled del filesystem ext2, fornisce
metadati di journaling per un veloce recupero in aggiunta a metodi di journaling
migliorati, come il journaling totale o logico dei dati. Il filesystem ext3 e
molto buono e affidabile. Offre in genere prestazioni decenti in molteplici
situazioni. Poiché non fa uso estensivo di "alberi" nella propria struttura
interna, non risulta molto scalabile e ciò significa che non è una scelta ideale
per filesystem molto grandi o situazioni in cui si gestiranno file molto grossi
o abbondanti quantità di file in una sola cartella. Quando usato nel rispetto
dei parametri di progettazione, però, ext3 è un eccellente filesystem.
</p>

<p>
Una delle cose positive di ext3 è che un filesystem ext2 esistente può essere
aggiornato "sul posto" ad ext3 abbastanza facilmente. Questo permette un facile
percorso di aggiornamento per sistemi Linux esistenti che già usano ext2.
</p>

</body>
</section>
<section>
<title>Il filesystem ReiserFS</title>
<body>

<p>
ReiserFS è un filesystem basato sui B-alberi (o B-tree) che ha prestazioni
complessivamente molto buone e estremamente superiori sia a ext2 che ext3 quando
ha a che fare con file piccoli (file minori di 4k), spesso di un fattore di
10x-15x. ReiserFS è anche estremamente scalabile e ha metadati di journaling.
Dal kernel 2.4.18 in poi, ReiserFS è solido come una roccia e altamente
raccomandato per essere usato sia come filesystem multiuso che nei casi estremi
come la creazione di grandi filesystem, l'uso di molti piccoli file, file molto
grandi e cartelle che contengono decine o centinaia di file. ReiserFS è il
filesystem che l'Autore raccomanda di base per tutte le partizioni non di boot.
</p>

</body>
</section>
<section>
<title>Il filesystem XFS</title>
<body>

<p>
XFS è un filesystem con metadati di journaling. È fornito con un robusto insieme
di caratteristiche e ottimizzato per la scalabilità. L'Autore raccomanda l'uso
di questo filesystem su sistemi Linux con dispositivi di alto livello SCSI e/o
memorie con canali in fibra e una fornitura di corrente senza interruzione.
Poiché XFS memorizza in cache su RAM i dati di passaggio in modo aggressivo,
programmi progettati in modo improprio (quelli che non prendono le giuste
precauzioni quando scrivono file su disco, e ce ne sono svariati di questo tipo)
possono perdere una discreta somma di dati se il sistema cede improvvisamente.
</p>

</body>
</section>
<section>
<title>Il filesystem JFS</title>
<body>

<p>
JFS è un filesystem journaling ad alte prestazioni di IBM. È diventato
recentemente pronto alla produzione e sarebbe preferibile aspettare ancora un
po' di tempo prima di commentare in modo positivo o negativo la sua generale
stabilità a questo punto.
</p>

</body>
</section>
<section>
<title>Raccomandazioni per i filesystem</title>
<body>

<p>
Se si sta cercando il più robusto dei filesystem con journaling, si usi ext3. Se
si sta cercando un filesystem multiuso dalle alte prestazioni con supporto al
journaling, si usi ReiserFS; sia ext3 che ReiserFS sono maturi, ben fatti e
raccomandati per uso generale.
</p>

<p>
Basandosi sull'esempio sopra, saranno usati i seguenti comandi per inizializzare
tutte le partizioni per l'uso:
</p>

<pre caption="Inizializzare le partizioni">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
È stato scelto ext3 per la partizione di boot <path>/dev/hda1</path> poiché è un
filesystem con journaling robusto e supportato da tutti i principali boot
loader. Viene usato <c>mkswap</c> per la partizione di swap
<path>/dev/hda2</path> -- la scelta è ovvia in questo caso. Per il filesystem
principale della partizione radice su <path>/dev/hda3</path> è stato scelto
ReiserFS, dato che è un solido filesystem con journaling che offre eccellenti
prestazioni. Adesso, andando avanti devono essere inizializzate le proprie
partizioni.
</p>

</body>
</section>
<section>
<title>Creare lo spazio di swap</title>
<body>

<p>
<c>mkswap</c> è un comando che viene usato per inizializzare le partizioni di
swap:
</p>

<pre caption="Inizializzare la partizione di swap">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
A differenza dei filesystem regolari, le partizioni di swap non vengono montate.
Piuttosto, sono abilitate usando il comando <c>swapon</c>:
</p>

<pre caption="Abilitare le partizioni di swap">
# <i>swapon /dev/hdc6</i>
</pre>

<p>
I propri script di avvio del sistema Linux si preoccupano automaticamente di
abilitare le partizioni di swap. Quindi, il comando <c>swapon</c> è di solito
necessario solo quando si ha bisogno di aggiungere immediatamente un po' di swap
appena creata. Per vedere i dispositivi di swap correntemente abilitati,
digitare <c>cat /proc/swaps</c>.
</p>

</body>
</section>
<section>
<title>Creare filesystem ext2, ext3 e ReiserFS</title>
<body>

<p>
Si può usare il comando <c>mke2fs</c> per creare filesystem ext2:
</p>

<pre caption="Creare filesystem ext2">
# <i>mke2fs /dev/hda1</i>
</pre>

<p>
Per chi desidera usare ext3, è possibile creare un filesystem ext3 usando
<c>mke2fs -j</c>:
</p>

<pre caption="Creare filesystem ext3">
# <i>mke2fs /dev/hda3</i>
</pre>

<note>
Si possono trovare ulteriori informazioni su come usare ext3 sotto Linux 2.4 su
<uri link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">questo
sito</uri> mantenuto da Andrew Morton.
</note>

<p>
Per creare un filesystem ReiserFS, usare il comando <c>mkreiserfs</c>:
</p>

<pre caption="Creare un filesystem ReiserFS">
# <i>mkreiserfs /dev/hda3</i>
</pre>

</body>
</section>
<section>
<title>Creare filesystem XFS e JFS</title>
<body>

<p>
Per creare un filesystem XFS, usare il comando <c>mkfs.xfs</c>:
</p>

<pre caption="Creare filesystem XFS">
# <i>mkfs.xfs /dev/hda3</i>
</pre>

<note>
Si potrebbe voler aggiungere una coppia di opzioni addizionali al comando
mkfs.xfs: <c>-d agcount=3 -l size=32m</c>. Il comando <c>-d agcount=3</c>
diminuirà il numero di gruppi di allocazione. XFS insisterà ad usare almeno un
gruppo di allocazione per 4GB della propria partizione, quindi, per esempio,
avendo una partizione di 20GB è necessario un minimo di 5 gruppi di allocazione.
Il comando <c>l size=32m</c> incrementa la dimensione del journaling a 32MB,
migliorando le prestazioni.
</note>

<p>
Per creare un filesystem JFS, usare il comando <c>mkfs.jfs</c>:
</p>

<pre caption="Creare filesystem JFS">
# <i>mkfs.jfs /dev/hda3</i>
</pre>

</body>
</section>
<section>
<title>Montare filesystem</title>
<body>

<p>
Una volta creato il filesystem, è possibile montarlo usando il comando
<c>mount</c>:
</p>

<pre caption="Montare filesystem">
# <i>mount /dev/hda3 /mnt</i>
</pre>

<p>
Per montare un filesystem, specificare il dispositivo a blocchi della partizione
come primo argomento e un "punto di montaggio (mount-point)" come secondo
argomento. Il nuovo filesystem sarà "agganciato" al mount-point. Questo ha anche
l'effetto di "nascondere" ogni file che era nella cartella <path>/mnt</path> sul
filesystem ospite. Più tardi, una volta smontato il filesystem, questi file
riappariranno. Dopo aver eseguito il comando mount, ogni file creato o copiato
dentro <path>/mnt</path> sarà immagazzinato sul nuovo filesystem ReiserFS
montato.
</p>

<p>
Si supponga di voler montare la propria partizione di boot dentro
<path>/mnt</path>. È possibile farlo seguendo i passi esposti di seguito:
</p>

<pre caption="Montare la partizione di boot in /mnt">
# <i>mkdir /mnt/boot</i>
# <i>mount /dev/hda1 /mnt/boot</i>
</pre>

<p>
Adesso, il filesystem di boot è disponibile dentro /mnt/boot. Se si creano file
all'interno di <path>/mnt/boot</path>, saranno immagazzinati sul filesystem ext3
che risiede fisicamente su <path>/dev/hda1</path>. Se si creano file dentro
<path>/mnt</path> ma non in <path>/mnt/boot</path>, questi saranno depositati
sul filesystem ReiserFS che risiede su <path>/dev/hda3</path>. E se si creano
file fuori da <path>/mnt</path>, non verranno immagazzinati su alcun filesystem
se non su quello del sistema Linux attuale o sul disco di boot.
</p>

<p>
Per vedere quali filesystem sono montati, digitare <c>mount</c> da solo. Di
seguito il risultato di <c>mount</c> su uno dei sistemi Linux attualmente in
esecuzione dell'Autore, che ha le partizione configurate allo stesso modo di
quelle proposte nell'esempio sopra:
</p>

<pre caption="Risultato del comando mount">
/dev/root on / type reiserfs (rw,noatime)
none on /dev type devfs (rw)
proc on /proc type proc (rw)
tmpfs on /dev/shm type tmpfs (rw)
usbdevfs on /proc/bus/usb type usbdevfs (rw)
/dev/hde1 on /boot type ext3 (rw,noatime)
</pre>

<p>
È possibile anche vedere informazioni simili digitando
<path>/proc/mounts</path>. Il filesystem di root, <path>/dev/hda3</path> viene
montato automaticamente dal kernel all'avvio e prende il nome simbolico di
<path>/dev/hda3</path>. Sul sistema di esempio, sia <path>/dev/hda3</path> che
<path>/dev/root</path> puntano allo stesso dispositivo a blocchi sottostante
usando un collegamento simbolico:
</p>

<pre caption="Collegamenti simbolici">
# <i>ls -l /dev/root</i>
lr-xr-xr-x   1 root   root   33 Mar 26 20:39 /dev/root -> ide/host0/bus0/target0/lun0/part3

# <i>ls -l /dev/hda3</i>
lr-xr-xr-x   1 root   root   33 Mar 26 20:39 /dev/hde3 -> ide/host0/bus0/target0/lun0/part3
</pre>

</body>
</section>
<section>
<title>Concetti ulteriori sul montaggio</title>
<body>

<p>
Qualcuno potrebbe chiedersi cosa è quindi il file
"<path>/dev/ide/host0</path>....". Sistemi come quello dell'Autore che usano
devfs o device-management filesystem (gestione dispositivi via filesystem) per
<path>/dev</path> hanno nomi ufficiali più lunghi per le partizioni e i
dispositivi a blocchi su disco rispetto a quelli usati da Linux in passato. Per
esempio, <path>/dev/ide/host0/bus1/target0/lun0/part7</path> è il nome ufficiale
per <path>/dev/hdc7</path> e <path>/dev/hdc7</path> stesso è solo un
collegamento simbolico che punta al dispositivo a blocchi ufficiale. È possibile
determinare se il proprio sistema sta usando devfs controllando se esiste il
file <path>/dev/.devfsd</path>; se così fosse, allora devfs è attivo.
</p>

<p>
Quando viene usato il comando mount per montare filesystem, questo cerca di
auto-rilevare il tipo di filesystem. Talvolta, potrebbe non riuscirci e l'utente
deve specificare il filesystem che deve essere montato digitandolo manualmente
tramite l'uso dell'opzione -t, come segue:
</p>

<pre caption="Montare filesystem ext3 manualmente con l'opzione -t">
# <i>mount /dev/hda1 /mnt/boot -t ext3</i>
</pre>

<p>oppure</p>

<pre caption="Montare filesystem reiserfs manualmente con l'opzione -t">
# <i>mount /dev/hda3 /mnt -t reiserfs</i>
</pre>

</body>
</section>
<section>
<title>Opzioni per mount</title>
<body>

<p>
È anche possibile personalizzare i vari attributi del filesystem da montare
specificando opzioni a mount. Per esempio, è possibile montare un filesystem
come "sola lettura" usando l'opzione ro:
</p>

<pre caption="Montare filesystem in sola lettura">
# <i>mount /dev/hdc6 /mnt -o ro</i>
</pre>

<p>
Con <path>/dev/hdc6</path> montato in sola lettura, nessun file può essere
modificato in <path>/mnt</path> -- solo letti. Se il proprio filesystem è già
montato come "lettura/scrittura" e si vuole passare alla modalità in sola
lettura, si può usare l'opzione "remount" per evitare di dover smontare e
montare il filesystem di nuovo:
</p>

<pre caption="Usare l'opzione remount">
# <i>mount /mnt -o remount,ro</i>
</pre>

<p>
Da notare che non è necessario specificare la partizione per il dispositivo a
blocchi poiché il filesystem è già montato e <c>mount</c> sa che
<path>/mnt</path> è associato con <path>/dev/hdc6</path>. Per rendere di nuovo
il filesystem scrivibile, lo si può rimontare in lettura-scrittura:
</p>

<pre caption="Rimontare il filesystem in lettura-scrittura">
# <i>mount /mnt -o remount,rw</i>
</pre>

<p>
Si noti che questi comandi per rimontare non termineranno con successo se
qualche processo ha aperto qualche file o cartella in <path>/mnt</path>. Per
familiarizzare con tutte le opzioni di montaggio disponibili sotto Linux,
digitare <c>man mount</c>.
</p>

</body>
</section>
<section>
<title>Introduzione a fstab</title>
<body>

<p>
Fin'ora è stato illustrato come partizionare un disco di esempio e montare i
filesystem manualmente da un disco di avvio. Ma una volta che il sistema Linux è
installato, è interessante scoprire quale sia il modo di configurarlo per
montare i filsystem corretti al momento giusto. Per esempio, si supponga di
installare Gentoo Linux sulla configurazione di filesystem dell'esempio visto.
C'è da chiedersi in che modo il sistema saprà come scovare il filesystem di root
che si trova su <path>/dev/hda3</path>. Se anche qualche altro filesystem --
come swap -- necessita di essere montato all'avvio, è utile scoprire come può il
sistema scoprire quali siano questi filesystem.
</p>

<p>
Il kernel Linux è informato su quale filesystem di root usare dal boot loader e
i boot loader saranno discussi più avanti in questa breve guida. Ma per ogni
altra cosa, il proprio sistema Linux ha un file chiamato <path>/etc/fstab</path>
che lo informa riguardo a quali filesystem sono disponibili per essere montati.
Bisogna dargli un'occhiata, adesso.
</p>

</body>
</section>
<section>
<title>Un esempio di fstab</title>
<body>

<p>
Verrà illustrato ora un file <path>/etc/fstab</path> di esempio:
</p>

<pre caption="File /etc/fstab di esempio">
  &lt;fs&gt; &lt;mountpoint&gt; &lt;type&gt;    &lt;opts&gt;            &lt;dump/pass&gt;

/dev/hda1       /boot           ext3            noauto,noatime          1 1
/dev/hda3       /               reiserfs        noatime                 0 0
/dev/hda2       none            swap            sw                      0 0
/dev/cdrom      /mnt/cdrom      iso9660         noauto,ro,user          0 0
# /proc should always be enabled
proc            /proc           proc            defaults                0 0
</pre>

<p>
Sopra, ogni riga non commentata in <path>/etc/fstab</path> indica una partizione
di dispositivo a blocchi, un punto di aggancio, un tipo di filesystem, le
opzione del filesystem da usare quando viene montato il filesystem e due campi
numerici. Il primo campo numerico è usato per specificare al comando di backup
<c>dump</c> i filesystem che dovrebbero essere salvati. Ovviamente, per chi non
avesse pianificato l'uso di <c>dump</c> sul proprio sistema c'è la possibilità
di ignorare questo campo senza subire alcuna conseguenza. L'ultimo campo è usato
dal programma di controllo di integrità per filesystem <c>fsck</c> e lo informa
sull'ordine in cui i filesystem presenti dovrebbero essere controllati
all'avvio. Nei prossimi paragrafi <c>fsck</c> sarà discusso ancora.
</p>

<p>
Focalizzarsi sulla riga relativa a <path>/dev/hda1</path>; è possibile vedere
che <path>/dev/hda1</path> ospita un filesystem ext3 che dovrebbe essere montato
sul punto di aggancio <path>/boot</path>. Adesso, ci si concentri sulle opzioni
per <path>/dev/hda1</path> nella colonna dedicata. L'opzione noauto informa il
sistema che <path>/dev/hda1</path> non deve essere montato automaticamente al
momento dell'avvio; senza questa opzione <path>/dev/hda1</path> sarebbe montato
in modo automatico su <path>/boot</path> all'avvio del sistema.
</p>

<p>
Da notare anche l'opzione noatime, che disattiva la registrazione delle
informazioni sull'a(ccess)time (orario dell'ultimo accesso) sul disco. Questa
informazione è di solito non necessario e disattivare l'aggiornamento dell'atime
ha un effetto positivo sulle prestazione del filesystem.
</p>

<p>
Adesso, dando un'occhiata alla linea che presenta <path>/proc</path> si nota
come opzioni defaults. Usare defaults ogni volta in cui si desidera che il
filesystem venga montato con le sole opzioni predefinite di mount. Dato che
<path>/etc/fstab</path> ha più campi, non è possibile lasciare semplicemente il
campo opzioni bianco.
</p>

<p>
Da notare anche la linea in <path>/etc/fstab</path> per <path>/dev/hda2</path>.
Questa linea definisce <path>/dev/hda2</path> come dispositivo di swap. Dato che
i dispositivi di swap non sono montati come filesystem, none (ndt, nessuno) è
specificato nel campo del punto di aggancio. Grazie a questa voce in
<path>/etc/fstab</path>, il dispositivo di swap <path>/dev/hda2</path> sarà
abilitato automaticamente all'avvio del sistema.
</p>

<p>
Con una voce in <path>/etc/fstab</path> per <path>/dev/cdrom</path> come quella
sopra, montare i dispositivi CD-ROM diventa semplice. Invece di digitare:
</p>

<pre caption="Montare CD-ROM senza una voce dedicata in fstab">
# <i>mount -t iso9660 /dev/cdrom /mnt/cdrom -o ro</i>
</pre>

<p>
È possibili digitare ora:
</p>

<pre caption="Montare CD-ROM con una voce dedicata in fstab">
# <i>mount /dev/cdrom</i>
</pre>

<p>
In realtà, usare <path>/etc/fstab</path> permette di godere dei vantaggi
riguardo all'opzione user. L'opzione user invita il sistema a permettere il
montaggio del determinato filesystem da parte di ogni utente. Questo diviene
utile per dispositivi di supporto rimovibili come dispositivi CD-ROM. Senza
questa opzione di montaggio in fstab, solo l'utente root sarebbe capace di usare
il dispositivo CD-ROM.
</p>

</body>
</section>
<section>
<title>Smontare filesystem</title>
<body>

<p>
Di solito, tutti i filesystem montati sono smontati automaticamente dal sistema
a seguito di un riavvio o dello spegnimento. Quando un filesystem è smontato,
ogni dato relativo ad esso riposto in memoria è scaricato sul disco.
</p>

<p>
Comunque, è anche possibile smontare filesystem manualmente. Prima che un
filesystem possa essere smontato, è necessario assicurarsi che non ci siano
processi in esecuzione che hanno aperto file sul filesystem in questione.
Quindi, usare il comanda <c>umount</c>, specificando o il nome del dispositivo o
il punto di aggancio come argomento:
</p>

<pre caption="Usare il comando umount">
# <i>umount /mnt</i>
</pre>

<p>
or
</p>

<pre caption="Usare il comando umount">
# <i>umount /dev/hda3</i>
</pre>

<p>
Una volta smontato, ogni file in <path>/mnt</path> che era stato "coperto" dal
filesystem precedentemente montato adesso riapparirà.
</p>

</body>
</section>
<section>
<title>Introduzione a fsck</title>
<body>

<p>
Se il proprio sistema crolla o si ferma per qualche ragione, potrebbe non avere
un'opportunità per smontare in modo pulito i filesystem. Quando questo succede,
i filesystem sono lasciati in uno stato inconsistente (e impredicibile). Al
riavvio del sistema, il programma <c>fsck</c> rileverà che questi filesystem non
sono stati smontati correttamente e vorrà effettuare un controllo di consistenza
sui filesystem elencati in <path>/etc/fstab</path>.
</p>

<impo>
Per far sì che un filesystem sia controllato da <c>fsck</c> questo deve avere un
valore diverso da zero nel campo "pass" (l'ultimo campo) in
<path>/etc/fstab</path>. Di solito, il filesystem principale ha un valore
impostato a 1, il quale specifica che dovrebbe essere controllato per primo.
Tutti gli altri filesystem che dovrebbero essere controllati al momento
dell'avvio dovrebbero avere un valore pari a 2 o superiore. Per alcuni
filesystem con journaling come ReiserFS, è sicuro porre un valore pari a 0 dato
che il codice di journaling (e non un <c>fsck</c>esterno) si preoccupa di
riportare il filesystem ancora in uno stato consistente.
</impo>

<p>
Talvolta, potrebbe succedere che dopo un riavvio <c>fsck</c> non sia capace di
riparare completamente un filesystem parzialmente danneggiato. In questi casi,
tutto ciò che l'utente deve fare è portare il proprio sistema in modalità
singolo utente ed eseguire <c>fsck</c> manualmente, fornendo le partizioni su
dispositivo a blocchi come argomento. Mentre <c>fsck</c> effettua la riparazione
dei filesystem, potrebbe chiedere all'utente se vuole correggere particolari
difetti del filesystem. In genere, si dovrebbe rispondere <c>y</c> (si) a tutte
le domande e permettere a <c>fsck</c>di fare il suo dovere.
</p>

</body>
</section>
<section>
<title>Problemi con fsck</title>
<body>

<p>
Uno dei problemi con le analisi di <c>fsck</c> è che queste possono prendere
abbastanza tempo per essere portate a termine, dato che i metadati del
filesystem (strutture dati interne) necessitano di essere analizzate nelle loro
totalità in modo da assicurare che siano consistenti. Con filesystem
estremamente grandi, non è inusuale che un fsck esaustivo prende più di un'ora.
</p>

<p>
Per poter risolvere il problema, un nuovo tipo di filesystem è stato progettato,
chiamato filesystem journaling. I filesystem con journaling registrano un log su
disco delle modifiche recenti ai metadati del filesystem stesso. In caso di
collasso, il driver del filesystem ispeziona il log. Poiché il log contiene
un'accurato resoconto delle modifiche recenti sul disco, solo queste parti di
metadati del filesystem necessitano di essere controllate in cerca di errori.
Grazie a questa importante modifica di progetto, verificare la consistenza di un
filesystem con journaling di solito impiega solo pochi secondi, in relazione
alla dimensione del filesystem. Per questa ragione, i filesystem con journaling
stanno riscuotendo successo nella comunità Linux. Per maggiori informazioni sui
filesystem con journaling, si faccia riferimento a <uri
link="http://www-106.ibm.com/developerworks/library/l-fs.html">Advanced
filesystem implementor's guide, part 1: Journaling and ReiserFS (guida avanzata
per sviluppatori di filesystem, parte 1: Journaling e ReiserFS)</uri>.
</p>

<p>
Di seguito saranno discussi i maggiori filesystem disponibili in Linux, insieme
ai comandi associati e le opzioni.
</p>

</body>
</section>
<section>
<title>Il filesystem ext2</title>
<body>

<p>
Il filesystem ext2 è stato il filesystem principale in Linux per molti anni. Ha
in genere buone prestazioni per molte applicazioni ma non offre alcuna capacità
di journaling. Questo lo rende inutilizzabile per filesystem molto grandi, dato
che <c>fsck</c> può impiegare un tempo estremamente lungo. In aggiunta, ext2 ha
molte limitazioni intrinseche dovute al fatto che ogni filesystem ext2 ha un
numero fisso di inode che può trattare. Presto detto, ext2 è di solito
considerato un filesystem estremamente robusto ed efficiente ma senza
journaling.
</p>

<ul>
  <li>In kernel: 2.0+</li>
  <li>journaling: no</li>
  <li>comando mkfs: mke2fs</li>
  <li>esempio mkfs: mke2fs /dev/hdc7</li>
  <li>comandi associati: debugfs, tune2fs, chattr</li>
  <li>opzioni di montaggio relative alle prestazioni: noatime.</li>
</ul>

</body>
</section>
<section>
<title>Il filesystem ext3</title>
<body>

<p>
Il filesystem ext3 usa lo stesso formato su disco di ext2 ma aggiunge la
capacità di journaling. In realtà, di tutti i filesystem in Linux, ext3 presenta
il più ampio supporto al journaling, supporta non solo metadati per il
journaling ma anche journaling regolato (il predefinito) e journaling totale
dati più metadati. Questa "speciale" modalità journaling aiuta ad assicurare
l'integrità sui dati, non solo un breve controllo come altre implementazioni di
journaling. Per questa ragione, ext3 è il miglior filesystem da usare se
l'integrità dei dati è una priorità primaria assoluta. Comunque, queste
caratteristiche di integrità dei dati talvolta impattano sulle prestazioni. In
aggiunta, poiché ext3 usa lo stesso formato su disco di ext2, soffre ancora
delle stesse limitazioni alla scalabilità del suo cugino senza journaling. Ext3
è una buona scelta per chi cerca un discreto filesystem con journaling multi uso
che sia anche molto robusto.
</p>

<ul>
  <li>In kernel: 2.4.16+</li>
  <li>
    journaling: metadati, scrittura ordinata dei dati, totalità di metadati più
    dati
  </li>
  <li>comando mkfs: mke2fs -j</li>
  <li>esempio di mkfs: mke2fs -j /dev/hdc7</li>
  <li>comandi associati: debugfs, tune2fs, chattr</li>
  <li>opzioni di montaggio relative alle prestazioni: noatime</li>
  <li>
    altre opzioni di montaggio:
    <ul>
      <li>data=writeback (disabilita il journaling)</li>
      <li>
        data=ordered (predefinito, metadati di journaling e dati sono trascritti
        su disco con metadati)
      </li>
      <li>
        data=journal (journaling totale dei dati per l'integrità dei dati e dei
        metadati. Prestazioni in scrittura dimezzate.)
      </li>
    </ul>
  </li>
  <li>
  Risorse per ext3:
  <ul>
    <li>
      <uri
      link="http://www.zip.com.au/~akpm/linux/ext3/">Pagine relativa a ext3 di
      Andrew Morton</uri>
    </li>
    <li>
      <uri
      link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">Eccellente
      documentazione d'uso per ext3 da parte di Andrew Morton
      (raccomandato)</uri>
    </li>
    <li>
      <uri
      link="http://www-106.ibm.com/developerworks/linux/library/l-fs7/"># Guida
      avanzata per implementatori di filesystem, parte 7: Introduzione a
      ext3.</uri>
    </li>
    <li>
      <uri
      link="http://www.gentoo.org/doc/it/articles/l-afig-p8.xml">Guida alla
      configurazione dei filesystem avanzati, Parte 8</uri>
    </li>
  </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>Il filesystem ReiserFS</title>
<body>

<p>
ReiserFS è un filesystem relativamente nuovo che è stato progettato con lo scopo
di fornire prestazioni molto buone su piccoli file, prestazioni ottime in genere
ed alta scalabilità. Di solito, ReiserFS offre prestazioni molto buone in quasi
tutte le situazioni. ReiserFS è preferito da molti  per la sua velocità e
scalabilità.
</p>

<ul>
  <li>In kernel: 2.4.0+ (2.4.18+ fortemente raccomandato)</li>
  <li>journaling: metadati</li>
  <li>comando mkfs: mkreiserfs</li>
  <li>esempio di mkfs: mkreiserfs /dev/hdc7</li>
  <li>opzioni di montaggio relative alle prestazioni: noatime, notail</li>
  <li>
  Risorse su ReiserFS:
  <ul>
    <li>
      <uri link="http://www.namesys.com/">Pagina principale di ReiserFS</uri>
    </li>
    <li>
      <uri
      link="http://www-106.ibm.com/developerworks/library/l-fs.html">Guida
      avanzata per implementatori di filesystem, parte 1: Journaling e
      ReiserFS.</uri>
    </li>
    <li>
      <uri
      link="http://www-106.ibm.com/developerworks/library/l-fs2.html">Guida
      avanzata per implementatori di filesystem, parte 2: Usare ReiserFS e Linux
      2.4.</uri>
    </li>
  </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>Il filesystem XFS</title>
<body>

<p>
Il filesystem XFS è un filesystem con journaling di classe aziendale che è stato
portato in Linux da SGI. XFS è un filesystem con journaling pieno di
caratteristiche e scalabile che rappresenta una buona scelta per hardware
affidabile di alta qualità (dato che conta pesantemente sulla memorizzazione dei
dati in RAM) ma non una buona idea per hardware di scarsa qualità.
</p>

<ul>
  <li>In kernel: solo 2.5.34+, richiede una patch per la serie 2.4</li>
  <li>journaling: metadati</li>
  <li>comando mkfs: mkfs.xfs</li>
  <li>esempio di mkfs: mkfs.xfs /dev/hdc7</li>
  <li>opzioni di montaggio relative alle prestazioni: noatime</li>
  <li>
  Risorse per XFS:
  <ul>
    <li>
      <uri link="http://oss.sgi.com/projects/xfs/">Pagine principale di XFS
      (sgi.com)</uri>
    </li>
    <li>
    <uri
      link="http://www-106.ibm.com/developerworks/library/l-fs9.html">Guida
      avanzata per implementatori di filesystem, parte 9: Introduzione a
      XFS.</uri>
    </li>
    <li>
    <uri
      link="http://www-106.ibm.com/developerworks/library/l-fs10.html">Guida
      avanzata per implementatori di filesystem, parte 10: Mettere a punto
      XFS.</uri>
    </li>
  </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>Il filesystem JFS</title>
<body>

<p>
JFS è un filesystem con journaling ad alte prestazioni portato su Linux da IBM.
JFS è usato dai server aziendali IBM e è progettato per applicazioni ad alte
prestazioni. È possibile scoprire di più riguardo a JFS sul <uri
link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">sito Web del
progetto JFS</uri>.
</p>

<ul>
  <li>In kernel: 2.4.20+</li>
  <li>journaling: metadati</li>
  <li>comando mkfs: mkfs.jfs</li>
  <li>esempio di mkfs: mkfs.jfs /dev/hdc7</li>
  <li>opzioni di montaggio relative alle prestazioni: noatime</li>
  <li>
    Risorse su JFS: <uri
    link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">sito Web del
    progetto JFS (IBM).</uri>
  </li>
</ul>

</body>
</section>
<section>
<title>VFAT</title>
<body>

<p>
Il filesystem VFAT non è davvero un filesystem che si potrebbe scegliere per
immagazzinare file in Linux. Piuttosto, è un filesystem compatibile col driver
DOS che permette di essere montato e di scambiare dati con filesystem basati su
DOS e sul FAT di Windows. Il driver per filesystem VFAT è presente nel kernel
base di Linux.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Avviare il sistema</title>
<section>
<title>Riguardo a questa sezione</title>
<body>

<p>
Questa sezione introduce la procedura di avvio in Linux. Saranno discussi il
concetto di boot loader, come impostare le opzioni del kernel all'avvio e come
esaminare i log di avvio alla ricerca di errori.
</p>

</body>
</section>
<section>
<title>Il MBR</title>
<body>

<p>
Il processo di avvio è simile per tutte le macchine, indipendentemente dalla
distribuzione installata. Si consideri il seguente disco rigido di esempio:
</p>

<pre caption="Struttura di un disco rigido">
+----------------+
|      MBR       |
+----------------+
|  Partizione 1: |
| Linux root (/) |
|    contiene    |
|    kernel e    |
|    sistema.    |
+----------------+
|  Partizione 2: |
|   Linux swap   |
+----------------+
|  Partizione 3: |
|   Windows 3.0  |
|  (ultimo avvio |
|    nel 1992)   |
+----------------+
</pre>

<p>
Per prima cosa, il BIOS del computer legge i primi pochi settori del disco
rigido. Questi settori contengono un programma molto piccolo, chiamata il
"Master Boot Record" o "MBR". Il MBR ha memorizzata la locazione del kernel
Linux sul disco rigido (la partizione 1 nell'esempio sopra), quindi carica il
kernel in memoria a lo avvia.
</p>

</body>
</section>
<section>
<title>Il processo di avvio del kernel</title>
<body>

<p>
La cosa successiva (nonostante probabilmente comparirà solo per pochi istanti) è
una linea simile alla seguente:
</p>

<pre caption="Linea del processo di avvio">
Linux version 2.4.16 (root@time.flatmonk.org) (gcc version 2.95.3 20010315 (release)) #1 Sat Jan 12 19:23:04 EST 2002
</pre>

<p>
Questa è la prima linea stampata del kernel quando ne viene avviata
l'esecuzione. La prima parte è la versione del kernel, seguita
dall'identificazione dell'utente che ha creato il kernel (di solito root), il
compilatore con cui è stato compilato e un identificativo temporale relativo al
momento della compilazione.
</p>

<p>
Di seguito a questa linea c'è una grande quantità di messaggi da parte del
kernel riguardanti l'hardware del proprio sistema: il processore, il bus PCI, il
controller del disco, i dischi, le porte seriali, il dispositivo a floppy, i
dispositivi USB, gli adattatori di rete, le schede audio e potenzialmente altro
saranno riportati ognuno insieme al loro stato.
</p>

</body>
</section>
<section>
<title>/sbin/init</title>
<body>

<p>
Quando il kernel termina il caricamento, avvia un programma chiamato
<c>init</c>. Questo programma rimane in esecuzione fino a che il sistema non
viene spento. È sempre assegnato all'ID di processo 1, come si può vedere:
</p>

<pre caption="ID del processo init">
$ <i>ps --pid 1</i>
PID TTY          TIME CMD
  1 ?        00:00:04 init.system
</pre>

<p>
Il programma <c>init</c> avvia il resto della propria distribuzione eseguendo
una serie di script. Questi script di solito risiedono in
<path>/etc/rc.d/init.d</path> o <path>/etc/init.d</path> ed effettuano servizi
come l'impostazione dell'hostname (nome della macchna) sul sistema, il controllo
di errori sul filesystem, il montaggio di filesystem addizionali, l'abilitazione
della rete, l'avvio di servizi di stampa, etc. Quando gli script hanno
completato, <c>init</c> avvia un programma chiamato <c>getty</c> che mostra il
prompt per il login, e l'utente può procedere.
</p>

</body>
</section>
<section>
<title>In profondità: LILO</title>
<body>

<p>
Adesso che è stata fatta una breve panoramica attraverso il processo di avvio,
sarà vista più da vicino la prima parte: il MBR e il caricamento del kernel. Il
mantenimento del MBR è una responsabilità del "boot loader". I due boot loader
più popolari per sistemi basati su x86 sono "LILO" (LInux LOader) e "GRUB"
(GRand Unified Bootloader).
</p>

<p>
Dei due, LILO è il boot loader più vecchio e più comune. La presenza di LILO sul
proprio sistema è evidenziata all'avvio, con il breve prompt "LILO boot:". Da
notare che potrebbe esserci il bisogno di tenere premuto il tasto di shift
durante l'avvio per ottenere il prompt, dato che spesso un sistema è configurato
per passare oltre senza fermarsi.
</p>

<p>
Il prompt di LILO è abbastanza povero ma premendo il tasto &lt;tab&gt; verrà
presentata una lista di potenziali kernel (o altri sistemi operativi) da
avviare. Spesso c'è una sola voce nella lista. È possibile avviare uno di questi
digitandolo e premendo &lt;enter&gt;. In alternativa si può semplicemente
premere &lt;enter&gt; e il primo elemento sulla lista sarà avviato in modo
predefinito.
</p>

</body>
</section>
<section>
<title>Usare LILO</title>
<body>

<p>
Occasionalmente si potrebbe voler passare un'opzione al kernel al momento
dell'avvio. Alcune delle più comuni opzioni sono <c>root=</c> per specificare un
filesystem radice alternativo, <c>init=</c>per indicare un programma init
alternativo (come <c>init=/bin/sh</c> per recuperare un sistema mal configurato)
e <c>mem=</c> per specificare la quantità di memoria nel sistema (per esempio
<c>mem=512M</c> nel caso in cui Linux autorilevi solamente 128M). È possibile
passare queste opzioni al kernel tramite il prompt di avvio di LILO:
</p>

<pre caption="Prompt di avvio di LILO">
LILO boot: linux root=/dev/hdb2 init=/bin/sh mem=512M
</pre>

<p>
Se c'è bisogno di specificare regolarmente opzioni da riga di comando, si
dovrebbe considerare il caso di aggiungerle a <path>/etc/lilo.conf</path>. Il
formato di questo file è descritto nella pagine di manuale
<path>lilo.conf</path>.
</p>

</body>
</section>
<section>
<title>Un importante puntualizzazione su LILO</title>
<body>

<p>
Prima di passare a GRUB, c'è un importante nota per LILO. Ogni volta che vengono
fatte modifiche a <path>/etc/lilo.conf</path> o quando viene installato un nuovo
kernel, bisogna lanciare <c>lilo</c>. Il programma <c>lilo</c> riscrive il MBR
per riflettere le modifiche fatte, includendo la registrazione della locazione
assoluta su disco del kernel. L'esempio sotto fa uso dell'opzione -v per avere
maggiori informazioni:
</p>

<pre caption="Usare il comando lilo con l'opzione -v">
# <i>lilo -v</i>
LILO version 21.4-4, Copyright (C) 1992-1998 Werner Almesberger
'lba32' extensions Copyright (C) 1999,2000 John Coffman

Reading boot sector from /dev/hda
Merging with /boot/boot.b
Mapping message file /boot/message
Boot image: /boot/vmlinuz-2.2.16-22
Added linux *
/boot/boot.0300 exists - no backup copy made.
Writing boot sector.
</pre>

</body>
</section>
<section>
<title>In profondità: GRUB</title>
<body>

<p>
Il boot loader GRUB può essere considerato un boot loader di prossima
generazione, successore di LILO. Più visibilmente per gli utenti, fornisce una
interfaccia a menù invece del prompt primitivo di LILO. Per gli amministratori
di sistema, il cambiamento è più significativo. GRUB supporta più sistemi
operativi di LILO, mette a disposizione funzioni di sicurezza basate su password
nel menù di avvio ed è più facile da amministrare.
</p>

<p>
GRUB è di solito installato con il comando <c>grub-install</c>. Una volta
installato, il menù di GRUB è amministrato modificando il file
<path>/boot/grub/grub.conf</path>. Entrambi questi processi vanno oltre lo scopo
di questo documento; si possono leggere le pagine info di GRUB prima di provare
ad installare o amministrare GRUB stesso.
</p>

</body>
</section>
<section>
<title>Usare GRUB</title>
<body>

<p>
Per passare parametri al kernel, è possibile digitare <c>e</c> nel menù di
avvio. Questo dà la possibilità di modificare (premendo ancora <c>e</c>) sia il
nome del kernel da caricare che i parametri da passare. Quando la modifica è
stata effettuata, premere &lt;invio&gt; e quindi <c>b</c> per riavviare con le
modifiche fatte.
</p>

</body>
</section>
<section>
<title>dmesg</title>
<body>

<p>
I messaggi di avvio del kernel e degli script di init di solito scorrono molto
veloci. Si potrebbe notare un errore ma questo potrebbe essersene andato prima
di riuscire a leggerlo correttamente. In questo caso, ci sono due posti dove
poter guardare dopo l'avvio del sistema per scoprire cosa è andato storto (e se
tutto va bene farsi un'idea di come correggere le cose).
</p>

<p>
Se l'errore è apparso mentre il kernel veniva caricato o venivano testati i
dispositivi hardware, è possibile recuperare una copia del log del kernel usando
il comando <c>dmseg</c>:
</p>

<pre caption="Recuperare i log del kernel usando il comando dmesg">
Linux version 2.4.16 (root@time.flatmonk.org) (gcc version 2.95.3 20010315 (release)) #1 Sat Jan 12 19:23:04 EST 2002
</pre>

<p>
Questa riga dovrebbe essere già nota. Questa è la prima linea che il kernel
stampa quando viene caricato. Infatti, se si ridireziona il risultato di
<c>dmesg</c> in un paginatore, è possibile vedere tutti i messaggi che il kernel
stampa all'avvio, più ogni messaggio che il kernel ha stampato sulla console nel
frattempo.
</p>

</body>
</section>
<section>
<title>/var/log/messages</title>
<body>

<p>
Il secondo posto dove guardare per informazioni è nel file
<path>/var/log/messages</path>. Questo file è registrato dal demone syslog, che
accetta dati in ingresso da librerie, demoni e il kernel. Ogni linea nel file
messages ha un riferimento temporale. Questo file è un buon posto dove guardare
alla ricerca di errori che avvengono durante la fase degli init script o
all'avvio. Per esempio, per vedere gli ultimi pochi messaggi dal nameserver:
</p>

<pre caption="Effettuare un grep sul file /var/log/messages">
# <i>grep named /var/log/messages | tail -3</i>
Jan 12 20:17:41 time /usr/sbin/named[350]: listening on IPv4 interface lo, 127.0.0.1#53
Jan 12 20:17:41 time /usr/sbin/named[350]: listening on IPv4 interface eth0, 10.0.0.1#53
Jan 12 20:17:41 time /usr/sbin/named[350]: running
</pre>

</body>
</section>
<section>
<title>Informazioni aggiuntive</title>
<body>

<p>
Informazioni aggiuntive relative a questa sezione possono essere trovate nei
collegamenti elencati di seguito:
</p>

<ul>
  <li>
    Breve guida:: <uri
    link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxgrub-i.html">
    Conoscere GRUB</uri>
  </li>
  <li><uri link="http://en.tldp.org/HOWTO/LILO.html">LILO Mini-HOWTO</uri></li>
  <li>
    <uri link="http://www.gnu.org/software/grub/">Pagina principale di
    GRUB</uri>
  </li>
  <li>
    Opzioni da riga di comando per il kernel in
    <path>/usr/src/linux/Documentation/kernel-parameters.txt</path>.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Runlevel</title>
<section>
<title>Modalità singolo utente</title>
<body>

<p>
Si ricorda dalla sezione precedente riguardo ai boot loader che è possibile
passare parametri al kernel al momento dell'avvio. Uno dei parametri usati più
di frequente è <c>s</c>, che causa l'avvio del sistema in modalità "singolo
utente". Questa modalità di solito monta solo il filesystem radice, avvia un
sotto insieme minimale degli script di init e avvia una shell piuttosto che
fornire un prompt per il login. In aggiunta, la rete non viene configurata, così
da eliminare la possibilità che fattori esterni influenzino il lavoro.
</p>

</body>
</section>
<section>
<title>Capire la modalità singolo utente</title>
<body>

<p>
Viene da chiedersi che lavoro può essere fatto con il sistema in questo stato.
Per rispondere a questa domanda, bisogna tenere di conto della grossa differenza
fra Linux e Windows. Windows è progettato per essere usato di norma da una
persona alla volta, seduta alla console. È effettivamente sempre in modalità
"singolo utente". Linux, d'altra parte, è usato più spesso per fornire
applicazioni di rete o mettere a disposizione shell o sessioni X remote agli
utenti della rete. Queste variabili aggiuntive non sono desiderabili quando si
vogliono effettuare le operazioni di manutenzione come un ripristino da un
backup, creare o modificare filesystem, aggiornare il sistema da un CD e via
dicendo. In questi casi si dovrebbe usare la modalità a singolo utente.
</p>

</body>
</section>
<section>
<title>Runlevel</title>
<body>

<p>
In realtà, non è del tutto necessario riavviare per poter raggiungere la
modalità singolo utente. Il programma <c>init</c> gestisce la modalità attuale,
o "runlevel", per il sistema. I runlevel standard per un sistema Linux
sono definiti come segue:
</p>

<ul>
  <li>0: Arresta il computer</li>
  <li>1 o s: Modalità singolo utente</li>
  <li>2: Multi-utente, nessun servizio di rete</li>
  <li>3: Multi-utente, console di testo</li>
  <li>4: Multi-utente, console grafica</li>
  <li>5: lo stesso di 4</li>
  <li>6: Riavvia il computer.</li>
</ul>

<p>
Questi runlevel variano tra le distribuzioni, quindi ci si assicuri di
consultare la documentazione della propria distribuzione.
</p>

</body>
</section>
<section>
<title>telinit</title>
<body>

<p>
Per passare alla modalità singolo utente, usare il comando <c>telinit</c>, che
indica a <c>init</c> di cambiare runlevel:
</p>

<pre caption="Usare il comando telinit">
# <i>telinit 1</i>
</pre>

<p>
Si può notare dalla tabella sopra che è anche possibile spegnere o riavviare il
sistema in questo modo. <c>telinit 0</c> arresterà il computer; <c>telinit 6</c>
riavvierà il computer. Quando si indica al comando <c>telinit</c> di cambiare
runlevel, un sotto insieme degli script di <c>init</c> saranno eseguiti per
fermare o lanciare servizi di sistema.
</p>

</body>
</section>
<section>
<title>Uso educato dei runlevel</title>
<body>

<p>
Comunque, è da notare che questo è piuttosto scortese se in quel momento ci sono
utenti sul sistema (che potrebbero risultare abbastanza arrabbiati con
l'amministratore). Il comando <c>shutdown</c> fornisce un metodo per
cambiare runlevel in un modo che tratta gli utenti ragionevolmente. In maniera
simile alla capacità del comando <c>kill</c> di inviare una varietà di segnali
ad un processo, <c>shutdown</c> può essere usato per arrestare, riavviare o
passare in modalità singolo utente. Per esempio, per passare alla modalità
singolo utente entro 5 minuti:
</p>

<pre caption="Passare in modalità singolo utente con un ritardo di 5 minuti">
# <i>shutdown 5</i>
Broadcast message from root (pts/2) (Tue Jan 15 19:40:02 2002):
The system is going DOWN to maintenance mode in 5 minutes!
</pre>

<p>
Premendo &lt;control-c&gt; a questo punto, è possibile cancellare il passaggio
imminente alla modalità singolo utente. Il messaggio sopra dovrebbe apparire su
tutti i terminali del sistema, così gli utenti hanno un ragionevole lasso di
tempo per salvare il loro lavoro e uscire (Qualcuno potrebbe discutere se 5
minuti sono o no "ragionevoli").
</p>

</body>
</section>
<section>
<title>"Now" (ora) e arresto</title>
<body>

<p>
Se si è la sola persona sul sistema, è possibile usare "now" (ora) invece di un
argomento in minuti. Per esempio, per riavviare il sistema immediatamente:
</p>

<pre caption="Usare il comando shutdown con l'opzione now">
# <i>shutdown -r now</i>
</pre>

<p>
Nessuna possibilità di premere &lt;control-c&gt; in questo caso; il sistema è
già in fase di spegnimento. Infine, l'opzione -h arresta il sistema:
</p>

<pre caption="Arrestare il sistema">
# <i>shutdown -h 1</i>
Broadcast message from root (pts/2) (Tue Jan 15 19:50:58 2002):
The system is going DOWN for system halt in 1 minute!
</pre>

</body>
</section>
<section>
<title>Il runlevel default</title>
<body>

<p>
A questo punto dovrebbe essere chiaro che il programma <c>init</c> è abbastanza
importante in un sistema Linux. È possibile configurare <c>init</c> modificando
il file <path>/etc/inittab</path>, che è descritto dalla pagina di manuale
inittab(5). Sarà discussa solamente una linea chiave di questo file:
</p>

<pre caption="Modificare il file di configurazione di init">
# <i>grep ^id: /etc/inittab</i>
id:3:initdefault:
</pre>

<p>
Sul sistema dell'Autore, il runlevel 3 è quello predefinito. Può essere utile
cambiare questo valore per chi preferisse avere un sistema che si avvia
immediatamente con una veste grafica (di solito nei runlevel 4 0 5). Per farlo,
basta modificare il file e cambiare il valore nella linea indicata. Ma bisogna
fare attenzione. Modificando il valore in qualcosa di non valido, probabilmente
bisognerà mettere in pratica il trucco del <c>init=/bin/sh</c> accennato
precedentemente.
</p>

</body>
</section>
<section>
<title>Informazioni aggiuntive</title>
<body>

<p>
Informazioni aggiuntive relative a questa sezione posso essere trovate su:
</p>

<ul>
  <li>
    <uri
    link="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/s1-init-boot-shutdown-init.html">
    Documentazione riguardo sysvinit su Red Hat</uri>.
  </li>
  <li>
    <uri link="http://www.linuxdoc.org/LDP/sag/init.html">Sezione relativa a
    init sulal Guida di Amministrazione per Sistemi Linux</uri>.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Quote del filesystem</title>
<section>
<title>Introduzione alle quote</title>
<body>

<p>
Le quote sono la caratteristica di Linux che permettere all'amministratore di
tracciare l'uso del disco da parte degli utenti o di un gruppo. Possono essere
utili per prevenire l'uso da parte di un singolo utente o un gruppo di una
porzione non equa di un filesystem o il suo riempimento completo. Le quote
possono essere abilitate e gestite solo dall'utente root. In questa sezione,
sarà descritto come impostare le quote sul proprio sistema Linux e gestirle
efficacemente.
</p>

</body>
</section>
<section>
<title>Supporto nel kernel</title>
<body>

<p>
Le quote sono una caratteristica del filesystem; Quindi, richiedono il supporto
nel kernel. La prima cosa da fare è verificare di avere il supporto per le quote
nel proprio kernel. È possibile farlo usando grep:
</p>

<pre caption="Controllare la configurazione del kernel per il supporto alle
	quote">
# <i>cd /usr/src/linux</i>
# <i>grep -i quota .config</i>
CONFIG_QUOTA=y
CONFIG_XFS_QUOTA=y
</pre>

<p>
Se questo comando restituisce qualcosa di meno decisivo (come il fatto che
CONFIG_QUOTA non è impostato) allora bisogna ricompilare il proprio kernel
includendo il supporto alle quote. Non è un processo difficoltoso ma è fuori
dallo scopo di questa sezione della guida. Se non si ha familiarità con le
procedure di compilazione e installazione di un nuovo kernel, bisogna
considerare l'idea di fare riferimento a questa <uri
link="/doc/it/articles/linux-kernel-compiling.xml">breve guida</uri>.
</p>

</body>
</section>
<section>
<title>Supporto nel filesystem</title>
<body>

<p>
Prima di scendere a fondo nell'amministrazione delle quote, si prega di notare
che il supporto ad esse in Linux nei kernel serie 2.4.x non è completo. Ci sono
al momento problemi con le quote nei filesystem ext2 e ext3 e ReiserFS non
sembra supportarle per niente. Questa breve guida basa i suoi esempi su XFS, che
sembra <uri
link="http://oss.sgi.com/projects/xfs/faq.html#quotaswork">supportare in modo
adeguato le quote</uri>.
</p>

</body>
</section>
<section>
<title>Configurazione delle quote</title>
<body>

<p>
Per cominciare con la configurazione delle quote nel proprio sistema, bisogna
modificare <path>/etc/fstab</path> per montare il filesystem interessato con le
quote abilitate. Nell'esempio proposto, sarà usato un filesystem XFS montato con
le quote per utenti e gruppi abilitate:
</p>

<pre caption="Configurare le quote">
# <i>grep quota /etc/fstab</i>
/usr/users   /mnt/hdc1    xfs    usrquota,grpquota,noauto   0 0
# <i>mount /usr/users</i>
</pre>

<p>
Da notare che le opzioni usrquota e grpquota non abilitano necessariamente le
quote su un filesystem. Bisogna assicurarci che le quote vengano abilitate
usando il comando <c>quotaon</c>:
</p>

<pre caption="Abilitare le quote">
# <i>quotaon /usr/users</i>
</pre>

<p>
Esiste il comando corrispondente <c>quotaoff</c> per i casi in cui si desidera
disabilitare le quote in futuro:
</p>

<pre caption="Disabilitare le quote">
# <i>quotaoff /usr/users</i>
</pre>

<p>
Ma per il momento, per chi proverà alcuni degli esempi proposti in questa breve
guida, assicurarsi di avere abilitato l'uso delle quote.
</p>

</body>
</section>
<section>
<title>Il comando quota</title>
<body>

<p>
Il comando <c>quota</c> mostra l'uso del disco da parte dell'utente e i suoi
limiti per tutti i filesystem montati in quel momento. L'opzione -v include
nella lista i filesystem con le quote abilitate ma per cui non esiste spazio di
immagazzinamento allocato attualmente per l'utente.
</p>

<pre caption="Usare il comando quota">
# <i>quota -v</i>

Disk quotas for user root (uid 0):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
 /dev/hdc1       0       0       0               3       0       0
</pre>

<p>
La prima colonna, blocks (blocchi), mostra quanto spazio su disco l'utente root
sta usando al momento su ciascun filesystem. Le colonne seguenti, quota e limit
(quote e limiti), si riferiscono ai limiti attualmente idonei impostati per lo
spazio su disco. Sarà spiegata in seguito la differenza tra quote e limiti e il
significato della colonna grace (grazia). La colonna files mostra quanti file
l'utente root possiede sul particolare filesystem. Le colonne quota e limit
seguenti si riferiscono ai limiti relativa ai file.
</p>

</body>
</section>
<section>
<title>Vedere le quote</title>
<body>

<p>
Ogni utente può usare il comando <c>quota</c> per vedere il proprio rapporto
sulle quote come mostrato nell'esempio precedente. In ogni caso solo l'utente
root può guardare le quote degli altri utenti e gruppi. Per esempio, supposto di
avere un filesystem, <path>/dev/hdc1</path> montato su <path>/usr/users</path>,
con due utenti: jane e john. Primo, bisogna dare un'occhiata all'uso del disco e
i limiti di jane.
</p>

<pre caption="Vedere le quote per utente">
# <i>quota -v jane</i>

Disk quotas for user jane (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
 /dev/hdc1    4100       0       0               6       0       0
</pre>

<p>
In questo esempio, si può vedere che le quote di jane sono impostate a zero, il
che indica nessun limite.
</p>

</body>
</section>
<section>
<title>edquota</title>
<body>

<p>
Adesso, si supponga di voler assegnare quote all'utente jane. Lo si può fare con
il comando <c>edquota</c>. Prima di cominciare a modificare le quote, bisogna
vedere quanto spazio è disponibile su <path>/usr/users</path>:
</p>

<pre caption="Controllare lo spazio disponibile su /usr/users">
# <i>df /usr/users</i>

Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hdc1               610048      4276    605772   1% /usr/users
</pre>

<p>
Non è un filesystem particolarmente grande, solo 600MB o quasi. Sembra prudente
assegnare a jane una quota così che non possa usarlo oltre la sua equa
partizione. Eseguendo <c>edquota</c>, viene creato un file temporaneo per ogni
utente o gruppo specificato su riga di comando.
</p>

<p>
Il comando <c>edquota</c> porta l'utente in un editor di testi e lo abilita ad
aggiungere e/o modificare quote attraverso questo file temporaneo.
</p>

<pre caption="Modificare le quote">
# <i>edquota jane</i>

Disk quotas for user jane (uid 1003):
Filesystem         blocks       soft       hard     inodes     soft     hard
 /dev/hdc1           4100          0          0          6        0        0
</pre>

<p>
In modo simile al risultato del comando <c>quota</c> di cui sopra, le colonne
blocks (blocchi) e inodes (inode) in questo file temporaneo si riferiscono allo
spazio su disco e numero di file attualmente in uso da jane. Non è possibile
modificare il numero di blocchi o inode; ogni tentativo di farlo sarà
sommariamente scartato dal sistema. Le colonne soft (debole, inferiore) e hard
(forte, superiore) mostrano le quote di jane, che come si può vedere sono
attualmente illimitate (ancora, zero indica nessuna quota).
</p>

</body>
</section>
<section>
<title>Capire edquota</title>
<body>

<p>
Il limite inferiore (soft) è la quantità massima di spazio su disco che jane ha
allocato per sé sul filesystem (in altre parole, la sua quota). Se jane usa più
spazio su disco di quanto allocato nel proprio limite inferiore, sarà avvertita
riguardo la sua violazione delle quote via e-mail. Il limite superiore (hard)
indica il limite assoluto di spazio su disco, che un utente non può eccedere. Se
jane prova ad usare più spazio su disco di quanto specificato nel limite
superiore, riceverà un errore "Disk quota exceeded" (Quota su disco superata) e
non avrà la possibilità di completare l'operazione.
</p>

</body>
</section>
<section>
<title>Effettuare modifiche</title>
<body>

<p>
Adesso saranno cambiati i limiti inferiore e superiore per jane e quindi salvato
il file:
</p>

<pre caption="Cambiare i limiti inferiore e superiore">

Disk quotas for user jane (uid 1003):
Filesystem         blocks       soft       hard     inodes     soft     hard
 /dev/hdc1           4100      10000      11500          6     2000     2500
</pre>

<p>
Eseguendo il comando <c>quota</c>, è possibile ispezionare le modifiche fatte:
</p>

<pre caption="Controllare le quote per l'utente jane">
# <i>quota jane</i>

Disk quotas for user jane (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
 /dev/hdc1    4100   10000   11500               6    2000    2500
</pre>

</body>
</section>
<section>
<title>Copiare le quote</title>
<body>

<p>
Non bisogna dimenticare di avere un altro utente, john, su questo filesystem. Se
si vuole dare a john la stessa quota di jane, è possibile usare l'opzione -p per
<c>edquota</c>, che usa la quota di jane come prototipo per tutti gli utenti
seguenti su riga di comando. Questo è un modo facile di impostare quote per
gruppi o utenti.
</p>

<pre caption="Copiare le quote">
# <i>edquota -p jane john</i>
# <i>quota john</i>

Disk quotas for user john (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
 /dev/hdc1       0   10000   11500               1    2000    2500
</pre>

</body>
</section>
<section>
<title>Restrizioni per i gruppi</title>
<body>

<p>
È anche possibile usare <c>edquota</c> per restringere l'allocazione dello
spazio su disco basandosi sulla proprietà di gruppo dei file. Per esempio, per
modificare le quote assegnate al gruppo users:
</p>

<pre caption="Modificare le quote per il gruppo users">
# <i>edquota -g users</i>
Disk quotas for group users (gid 100): Filesystem blocks soft hard inodes soft hard /dev/hdc1 4100 500000 510000 7 100000 125000
</pre>

<p>
Quindi per vedere le quote modificare per il gruppo users:
</p>

<pre caption="Vedere le quote modificate">
# <i>quota -g users</i>
Disk quotas for group users (gid 100): Filesystem blocks quota limit grace files quota limit grace /dev/hdc1 4100 500000 510000 7 100000 125000
</pre>

</body>
</section>
<section>
<title>Il comando repquota</title>
<body>

<p>
Analizzare le quote per ogni utente usando il comando <c>quota</c> può essere
tedioso se si hanno molti utenti su un filesystem. Il comando <c>repquota</c>
effettua un riassunto delle quote per un filesystem in un gradevole rapporto.
Per esempio, per vedere le quote per tutti gli utenti e gruppi su
<path>/usr/users</path>:
</p>

<pre caption="Riassunto delle quote">
# <i>repquota -ug /usr/users</i>
*** Report for user quotas on device /dev/hdc1
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --       0       0       0              3     0     0
john      --       0   10000   11500              1  2000  2500
jane      --    4100   10000   11500              6  2000  2500

*** Report for group quotas on device /dev/hdc1
Block grace time: 7days; Inode grace time: 7days
                        Block limits             File limits
Group           used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --       0       0      0               3     0     0
users     --    4100  500000 510000               7 100000 125000
</pre>

</body>
</section>
<section>
<title>Opzioni di repquota</title>
<body>

<p>
Ci sono un paio di altre opzioni per repquota che bisogna citare. <c>repquota
-a</c> tratterà tutti i filesystem attualmente montati in lettura-scrittura che
hanno le quote abilitate. <c>repquota -n</c> non risolverà gli uid e i gid in
nomi. Questo può accelerare il risultato per grandi liste.
</p>

</body>
</section>
<section>
<title>Monitorare le quote</title>
<body>

<p>
Se chi legge è un amministratore di sistema, potrebbe voler avere un modo per
monitorare le quote così da assicurarsi che non vengano sorpassate. Una via
semplice per farlo è l'uso di <c>warnquota</c>. Il comando <c>warnquota</c>
invia e-mail agli utenti che hanno ecceduto i propri limiti inferiori. Di solito
<c>warnquota</c> è eseguito da cron.
</p>

<p>
Quando un utente supera il suo limite inferiore, la colonna grace (grazia) nel
risultato del comando <c>quota</c> indica il periodo di grazia -- il tempo
concesso prima che il limite inferiore sia reso effettivo per questo filesystem.
</p>

<pre caption="Controllare il periodo di grazia">
Disk quotas for user jane (uid 1003):
    Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
    /dev/hdc1   10800*  10000   11500    7days      7     2000    2500
</pre>

<p>
In modo predefinito, il periodo di grazia per blocchi e inode è di sette giorni.
</p>

</body>
</section>
<section>
<title>Modificare il periodo di grazia</title>
<body>

<p>
È possibile modificare il periodo di grazie per il filesystem usando
<c>edquota</c>:
</p>

<pre caption="Modificare il periodo di grazia">
# <i>edquota -t</i>
</pre>

<p>
Questo mostra all'utente un editor di testo dove è presente un file temporaneo
simile al seguente:
</p>

<pre caption="Esempio di editor per il valore di grazia">
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem             Block grace period     Inode grace period
/dev/hdc1                    7days                  7days
</pre>

<p>
Il testo nel file è piacevolmente auto-esplicativo. Bisogna assicurarsi di
lasciare agli utenti abbastanza tempo per ricevere la loro e-mail di
avvertimento e trovare qualche file da cancellare.
</p>

</body>
</section>
<section>
<title>Controllare le quote all'avvio</title>
<body>

<p>
Qualcuno potrebbe anche voler controllare le proprie quote all'avvio. Lo si può
fare usando uno script per eseguire il comando <c>quotacheck</c>; c'è uno script
di esempio sul <uri link="http://en.tldp.org/HOWTO/Quota.html">Quota Mini
HOWTO</uri>. Il comando <c>quotacheck</c> ha anche la capacità di riparare file
quota danneggiati; è utile familiarizzare con esso leggendo la pagina di manuale
quotacheck(8).
</p>

<p>
Bisogna ricordare anche cosa è stato detto in precedenza riguardo a
<c>quotaon</c> e <c>quotaoff</c>. Si potrebbe incorporare <c>quotaon</c> nel
proprio script di avvio così che le quote vengano abilitate. Per abilitare le
quote su tutti i filesystem dove le quote sono supportate, usare l'opzione -a:
</p>

<pre caption="Usare l'opzione -a">
# <i>quotaon -a</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Log di sistema</title>
<section>
<title>Introduzione a syslogd</title>
<body>

<p>
Il demone syslog fornisce un avanzato meccanismo client-server per registrare
messaggi da parte di programmi in esecuzione sul sistema. Syslog riceve un
messaggio da un demone o programma e lo classifica in base a priorità e tipo,
quindi lo registra in accordo ad alcune regole configurabili
dall'amministratore. Il risultato è un robusto e unificato approccio per gestire
i log.
</p>

</body>
</section>
<section>
<title>Leggere i log</title>
<body>

<p>
Adesso bisogna scendere in dettaglio e guardare ai contenuti di un file di log
registrato da syslog. In seguito, è possibile tornare indietro alla
configurazione di syslog. Il FHS (vedere la <uri
link="/doc/it/articles/lpi-101-administration-p2.xml">Parte 2</uri> di questa
serie di brevi guide) impone che i file di log siano posizionati in
<path>/var/log</path>. Di seguito sarà usato il comando <c>tail</c> per mostrare
le ultime 10 linee nel file "messages":
</p>

<pre caption="Leggere i log">
# <i>cd /var/log</i>
# <i>tail messages</i>
Jan 12 20:17:39 bilbo init: Entering runlevel: 3
Jan 12 20:17:40 bilbo /usr/sbin/named[337]: starting BIND 9.1.3
Jan 12 20:17:40 bilbo /usr/sbin/named[337]: using 1 CPU
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: loading configuration from '/etc/bind/named.conf'
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: no IPv6 interfaces found
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: listening on IPv4 interface lo, 127.0.0.1#53
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: listening on IPv4 interface eth0, 10.0.0.1#53
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: running
Jan 12 20:41:58 bilbo gnome-name-server[11288]: starting
Jan 12 20:41:58 bilbo gnome-name-server[11288]: name server starting
</pre>

<p>
Bisognerebbe ricordare dalla discussione sull'elaborazione del testo che il
comando <c>tail</c> mostra le ultime linee in un file. in questo caso, è
possibile vedere che il server di nomi named è stato recentemente avviato sul
sistema, che è chiamato bilbo. Se si sta usando IPv6, si potrebbe notare che
named non ha trovato alcuna interfaccia IPv6, il che indica un potenziale
problema. In aggiunta, si può notare che un utente potrebbe avere di recente
avviato GNOME, il che è indicato dalla presenza di gnome-name-server.
</p>

</body>
</section>
<section>
<title>Leggere la parte finale dei file di log</title>
<body>

<p>
Un amministratore si sistema con esperienza potrebbe usare <c>tail -f</c> per
seguire il contenuto di un file di log in caso di necessità:
</p>

<pre caption="Usare il comando tail -f">
# <i>tail -f /var/log/messages</i>
</pre>

<p>
Per esempio, nel caso di analisi dell'ipotetico problema con IPv6, eseguire il
comando sopra in un terminale mentre si arresta e si avvia named dovrebbe
immediatamente mostrare i messaggi in arrivo dal demone. Questa può essere
un'utile tecnica in fase di analisi. A molti amministratori spesso piace tenere
costantemente in esecuzione <c>tail -f</c> su messages in un terminale così da
poter dare un'occhiata sugli eventi di sistema.
</p>

</body>
</section>
<section>
<title>Usare grep sui log</title>
<body>

<p>
Un'altra utile tecnica è quella di cercare in un file di log usando lo strumento
<c>grep</c>, descritto nella <uri
link="/doc/it/articles/lpi-101-administration-p2.xml">Parte 2</uri> di questa
serie di brevi guide. in questo caso, si potrebbe usare grep per cercare dove il
comportamento di "named" è cambiato:
</p>

<pre caption="Usare grep sui log">
# <i>grep named /var/log/messages</i>
</pre>

</body>
</section>
<section>
<title>Panoramica sui log</title>
<body>

<p>
Di seguito sono riassunti i file di log tipicamente presenti in
<path>/var/log</path> e mantenuti da syslog:
</p>

<ul>
  <li>
    <path>messages</path>: Messaggi informativi e di errore da programmi
    generali di sistema e demoni
    </li>
  <li>
    <path>secure</path>: Messaggi di autenticazione e errori, tenuti separati da
    <path>messages</path> per avere ulteriore sicurezza
  </li>
  <li><path>maillog</path>: Messaggi ed errori relativi a mail</li>
  <li><path>cron</path>: Messaggi ed errori relativi a cron</li>
  <li><path>spooler</path>: Messaggi ed errori relativi a UUCP e news</li>
</ul>

</body>
</section>
<section>
<title>syslog.conf</title>
<body>

<p>
In effetti, questo potrebbe essere un buon momento per investigare il file di
configurazione di syslog, <path>/etc/syslog.conf</path>. (Nota: se non è
presente <path>syslog.conf</path>, continuare a leggere per amore
dell'informazione, ma potrebbe essere in uso un demone syslog alternativo).
Esplorando questo file, si nota che ci sono voci per ognuno dei file di log più
comuni menzionati sopra, più forse qualche altra voce. Il file ha il formato
abilità.priorità azione (facility.priority action), dove questi campi sono
definiti come segue:
</p>

<p>
Abilità: specifica il sotto sistema che produce il messaggio. Parole valide per
questo campo sono auth, authpriv, cron, daemon, kern, lpr, mail, news, syslog,
user, uucp e da local0 fino a local7.
</p>

<p>
Priorità: indica la severità minima del messaggio, il che significa che i
messaggi con questa priorità e una maggiore saranno riscontrati da questa
regola. Parole valide per questo campo sono debug, info, notice, warning, err,
crit, alert, e emerg.
</p>

<p>
Azione: il campo azione potrebbe essere sia un nome di file, un tty (come
<path>/dev/console</path>), macchine remote con prefisso @, lista di utenti
separati da virgole o indicazione di inviare un messaggio a chiunque sia
presente sul sistema. L'azione più comune è un semplice nome di file.
</p>

</body>
</section>
<section>
<title>Ri-caricamento e informazioni aggiuntive</title>
<body>

<p>
Se tutto va bene questa panoramica del file di configurazione aiuterà il lettore
a prendere conoscenza con il punto di forza del sistema syslog. Bisognerebbe
leggere la pagina di manuale syslog.conf(5) per maggiori informazioni prima di
fare modifiche. In aggiunta la pagina di manuale syslogd(8) fornisce molte
informazioni dettagliate.
</p>

<p>
Da notare che vi è la necessità di informare il demone syslog dei cambiamenti al
file di configurazione per far si che abbiano effetto. Inviando un segnale
SIGHUP si ottiene quanto detto ed è possibile usare il comando <c>killall</c>
per farlo facilmente:
</p>

<pre caption="Usare il comando killall">
# <i>killall -HUP syslogd</i>
</pre>

</body>
</section>
<section>
<title>Nota di sicurezza</title>
<body>

<p>
Bisognerebbe preoccuparsi che i file di log scritti da syslogd siano creati dal
programma se questi non esistono. In relazione al proprio valore di umask
impostato al momento, i file saranno creati leggibili da tutti. Se si ha a cuore
la sicurezza, bisognerebbe usare chmod sui file per renderli di sola
lettura-scrittura per l'utente root. Inoltre, il programma <c>logrotate</c>
(descritto sotto) può essere configurato per creare nuovi file di log con i
permessi appropriati. Il demone syslog mantiene sempre gli attributi correnti di
un file di log esistente, quindi non bisogna preoccuparsi di lui una volta che
il file è stato creato.
</p>

</body>
</section>
<section>
<title>logrotate</title>
<body>

<p>
I file di log in <path>/var/log</path> cresceranno col tempo con la possibilità
potenzialmente di riempire il filesystem. È consigliabile usare un programma
come <c>logrotate</c> per gestire l'archiviazione automatica dei log. Il
programma <c>logrotate</c> di solito esegue come compito giornaliero di cron e
può essere configurato per rotare, comprimere, rimuovere o inviare via mail i
file di log.
</p>

<p>
Per esempio, una configurazione predefinita di logrotate potrebbe ruotare i log
settimanalmente, mantenendo 4 settimane intere di log arretrati (aggiungendo un
numero di sequenza al nome del file) e comprimendo i log più datati per salvare
spazio. In aggiunta, il programma può essere configurato per inviare un segnale
SIGHUP a syslogd così che il demone noti i file di log vuoti e aggiunga in coda
ad essi in modo appropriato.
</p>

<p>
Per maggiori informazioni su <c>logrotate</c>, vedere la pagina di manuale
logrotate(8), che contiene una descrizione del programma e la sintassi del file
di configurazione.
</p>

</body>
</section>
<section>
<title>Argomenti avanzati -- klogd</title>
<body>

<p>
Prima di lasciare syslog, sarebbe interessante introdurre un paio di argomenti
avanzati per i lettori più ambiziosi. Questi trucchi possono evitare molti
dispiaceri nel tentativo di capire gli argomenti relativi a syslog.
</p>

<p>
Primo, il demone syslog è al momento parte del pacchetto sysklogd, che contiene
un secondo demone chiamato klogd. I demone klogd serve a ricevere informazioni e
messaggi di errore dal kernel e quindi passarli a syslogd per la
categorizzazione e registrazione. I messaggi ricevuti da klogd sono esattamente
gli stessi che si possono recuperare usando il comando <c>dmesg</c>. La
differenza è che <c>dmesg</c> stampa il contenuto corrente di un buffer
circolare nel kernel, mentre klogd passa i messaggi a syslogd così che questi
non vengano persi quando si torna all'inizio dell'anello.
</p>

</body>
</section>
<section>
<title>Argomento avanzato -- gestori di log alternativi</title>
<body>

<p>
Secondo, si sono alternative al pacchetto predefinito sysklogd. Le alternative
mirano ad essere più efficienti, facili da configurare e possibilmente con più
caratteristiche di sysklogd. <uri
link="http://www.balabit.hu/en/downloads/syslog-ng/">Syslog-ng</uri> e <uri
link="http://metalog.sourceforge.net/">Metalog</uri> sembrano essere alcune
delle più popolari alternative: è possibile investigare su di esse se si ritiene
che sysklogd non fornisca il livello di potenza necessario.
</p>

<p>
Terzo, è possibile memorizzare messaggi nei propri script usando il comando
logger. Vedere la pagina di manuale logger(1) per maggiori informazioni.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Riassunto e risorse</title>
<section>
<title>Riassunto</title>
<body>

<p>
Congratulazioni, è stato raggiunta la fine di questa breve guida. O quasi. Ci
sono un paio di argomenti per cui non c'è stata la possibilità di essere inclusi
in queste prime quattro brevi guide a causa di limiti sullo spazio.
Fortunatamente, ci sono ancora un po' di buone risorse che potranno aiutare ad
accelerare la comprensione di questi argomenti. Assicurarsi di coprire queste
brevi guide particolari se si sta pianificando di conseguire la certificazione
di livello 1 del LPIC.
</p>

<p>
Non c'è quasi più spazio per coprire l'importante argomento dei backup di
sistema in questa breve guida. Fortunatamente, IBM developerWorks già propone
una breve guida sull'argomento, chiamata <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxbu-i.html">Backing up
your Linux machines (Backup della propria macchina Linux)</uri>. In questa
introduzione, sarà spiegato come effettuare backup del sistema Linux usando una
variante di <c>tar</c> chiamata star. Sarà anche discusso come usare il comando
<c>mt</c> per controllare le funzioni di registrazione.
</p>

<p>
Il secondo argomento di cui non c'è possibilità di discussione è la
programmazione periodica. Fortunatamente, c'è della buona <uri
link="http://www.ussg.iu.edu/usail/automation/cron.html">documentazione per
cron</uri> disponibile all'Indiana University. <c>cron</c> è usato per
programmare lavori da essere eseguiti ad un momento specifico e è un importante
strumento per ogni amministratore di sistema.
</p>

<p>
Nella prossima pagina, si possono trovare un numero di risorse che potranno
tornare utili nell'apprendere di più riguardo gli argomenti presentati in questa
breve guida.
</p>

</body>
</section>
<section>
<title>Risorse</title>
<body>

<p>
Per saperne di più sul supporto alle quote in Linux, assicurarsi di dare
un'occhiata al <uri link="http://en.tldp.org/HOWTO/Quota.html">Linux Quota
mini-HOWTO</uri>.  Inoltre assicurarsi di consultare le pagine di manuale
quota(1), edquota(8), repquota(8), quotacheck(8) e quotaon(8) sul proprio
sistema.
</p>

<p>
Informazioni aggiuntive per il processo di avvio del sistema e sui boot loader
possono essere trovate su:
</p>

<ul>
  <li>
    Breve guida su IBM developerWorks, tutorial per <uri
    link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxgrub-i.html">
    Conoscere GRUB</uri>
  </li>
  <li><uri link="http://en.tldp.org/HOWTO/LILO.html">LILO Mini-HOWTO</uri></li>
  <li>
    <uri link="http://www.gnu.org/software/grub/">Pagina web di GRUB</uri>
  </li>
  <li>
    Opzioni da riga di comando per il kernel in
    <path>/usr/src/linux/Documentation/kernel-parameters.txt</path>
  </li>
  <li>
    <uri
    link="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/s1-init-boot-shutdown-init.html">Documentazione
    per Sysvinit su Redhat</uri>.
  </li>
</ul>

<p>
Per apprendere ulteriori informazioni sui filesystem in Linux, leggere la guida
avanzata in più parti per implementatori di filesystem sull'area di IBM
developerWorks dedicata a Linux, che ricopre:
</p>

<ul>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs.html">I
    benefici del journaling e ReiserFS (Parte 1)</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs2.html">Impostare un
    sistema ReiserFS (Parte 2)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs3.html">Usare
    il filesystem virtuale tmpfs residente in memoria e montaggio (Parte
    3)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs4.html">I
    benefici di devfs, il filesystem per la gestione dei dispositivi (Parte
    4)</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs5.html">Iniziare il
    passaggio a devfs (Parte 5)</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">Completare
    il passaggio a devfs usando un wrapper per initi (Parte 6)</uri>
  </li>
  <li>
    <uri
    link="/doc/it/articles/afig-ct-ext3-intro.xml">I benefici del filesystem
    ext3 (Parte 7)</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/l-afig-p8.xml">Un'occhiata in profondità ad ext3
    e gli ultimi aggiornamenti del kernel (Parte 8)</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/linux/library/l-fs9.html">Una
    introduzione a XFS (Parte 9)</uri>.
  </li>
</ul>

<p>
Per maggiori informazioni sul partizionamento, dare un'occhiata ai seguenti
trucchi sul partizionamento nella zona dedicata a Linux sull'IBM developerWorks:
</p>

<ul>
  <li>
    <uri link="/doc/it/articles/partition-planning-tips.xml">Trucchi di
    pianificazione del partizionamento</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/partitioning-p1.xml">Partizionamento in atto,
    Parte 1</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/partitioning-p2.xml">Partizionamento in atto,
    Parte 2</uri>.
  </li>
</ul>

<p>
Risorse su ReiserFS:
</p>

<ul>
  <li><uri link="http://www.namesys.com/">La pagina web principale di
  ReiserFS</uri></li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs.html">Guida
    avanzata per implementatori di filesystem, Parte 1: Journaling e ReiserFS su
    developerWorks</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs2.html">Guida
    avanzata per implementatori di filesystem, Parte 2: Usare ReiserFS e Linux
    2.4 su developerWorks</uri>
  </li>
</ul>

<p>
Risorse su ext3:
</p>

<ul>
  <li>
    <uri link="http://www.zip.com.au/~akpm/linux/ext3/">Pagina dedicata a ext3
    di Andrew Morton</uri>
  </li>
  <li>
    <uri
    link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">Documentazione
    di un certo livello sull'uso di ext3 di Andrew Morton (raccomandata).</uri>
  </li>
</ul>

<p>
Risorse su XFS e JFS:
</p>

<ul>
  <li>
    <uri link="http://oss.sgi.com/projects/xfs">Pagina del progetto SGI
    XFS</uri>
  </li>
  <li>
    Il sito IBM sul <uri
    link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">progetto
    JFS</uri>
  </li>
</ul>

<p>
Da non dimenticare anche <uri link="http://en.tldp.org/">linuxdoc.org</uri>. Si
scoprirà che le collezioni di guide, HOWTO, FAQ e pagine di manuale di linuxdoc
sono inestimabili. Assicurarsi di controllare anche la <uri
link="http://en.tldp.org/LDP/LG/current/">Linux Gazette</uri> e <uri
link="http://en.tldp.org/linuxfocus/index.html">LinuxFocus</uri>.
</p>

<p>
La Guida per Amministratori di Sistema Linux, disponibile nella <uri
link="http://en.tldp.org/guides.html">sezione "Guides" (Guide) di
Linuxdoc.org</uri>, è un buon complemento a questa serie di brevi guide --
dargli un'occhiata. Potrebbe essere utile anche il <uri
link="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix and
Internet Fundamentals HOWTO (HOWTO sulle basi di Unix e Internet)</uri> di Eric
S. Raymond.
</p>

<p>
Nella serie di articoli Bash tramite esempi su developerWorks, Daniel mostra
come usare i costrutti della programmazione bash per scrivere i propri script.
Questa serie su bash (in particolare la Parte 1 e 2) sarà una eccellente
preparazione ulteriore per l'esame LPIC Level 1:
</p>

<ul>
  <li>
    <uri
    link="http://www.gentoo.org/doc/it/articles/bash-by-example-p1.xml">Bash
    tramite esempi, parte 1: Fondamenti di programmazione nella Bourne-again
    shell</uri>
  </li>
  <li>
    <uri
    link="http://www.gentoo.org/doc/it/articles/bash-by-example-p2.xml">Bash
    tramite esempi, parte 2: Ulteriori fondamenti di programmazione in
    bash</uri>
  </li>
  <li>
    <uri
    link="http://www.gentoo.org/doc/it/articles/bash-by-example-p3.xml">Bash
    tramite esempi, parte 3: Esplorare il sistema di ebuild</uri>
  </li>
</ul>

<p>
È fortemente raccomandato <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/">FAQ tecniche
da parte di utenti Linux</uri> di Mark Chapman, una lista approfondita di 50
pagine su domande poste di frequente in merito a Linux, corredate di risposte
dettagliate. Le FAQ sono in formato PDF (Adobe Acrobat). Per chi fosse un utente
principiante o intermedi di Linux, dare un'occhiata a queste FAQ rappresenta una
cosa da fare. Inoltre è raccomandato anche il <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-gloss/index.html">
Glossario su Linux per utenti Linux</uri>, anch'esso da parte di Mark.
</p>

<p>
Per chi non fosse familiare con l'editor vi, è fortemente raccomandato di
dare uno sguardo alla <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">
Introduzione a Vi -- bignami</uri> di Daniel. Questa breve guida fornisce una
leggera ma coinvolgente introduzione a questo potente editor di testo.
Considerare questo materiale come una lettura obbligatoria se non si sa come
usare vi.
</p>

</body>
</section>
<section>
<title>Commenti</title>
<body>

<p>
Si prega di mandare ogni commento riguardo questa breve guida agli autori:
</p>

<ul>
  <li>Daniel Robbins, su <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, su <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, su <mail>agriffis@gentoo.org</mail>.</li>
</ul>

</body>
</section>
</chapter>
</guide>