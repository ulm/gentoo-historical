<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/articles/lpi-101-administration-p2.xml,v 1.4 2012/02/26 08:33:40 swift Exp $ -->

<guide disclaimer="articles" lang="it">
<title>Preparazione all'esame per la Certificazione LPI 101 (release 2), Parte
2</title>

<author title="Autore">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autore">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Autore">
  Aron Griffis
</author>
<!--<author title="Editor">
  <mail link="smithj@gentoo.org">Jonathan Smith</mail>
</author>-->
<author title="Traduzione">
  <mail link="skypjack@gmail.com">Michele Caini</mail>
</author>

<abstract>
In questa breve guida, il lettore imparerà come usare le espressioni regolari
nella la ricerca di file per modelli di testo, come individuare file nel proprio
sistema e come avere pieno controllo dei processi in Linux. Sarà data perfino
una veloce introduzione alle pipeline della shell, la ridirezione e i comandi
per l'elaborazione del testo. Alla fine di questa breve guida, il lettore avrà
solide fondamente sulle basi dell'amministrazione in Linux e sarà pronto per
iniziare ad imparare tecniche di amministrazione di sistemi Linux più avanzate
nella guida che seguirà.
</abstract>

<!-- The original version of this article was published on IBM developerWorks,
and is property of Westtech Information Services. This document is an updated
version of the original article, and contains various improvements made by the
Gentoo Linux Documentation team -->

<version>2</version>
<date>2010-11-14</date>

<chapter>
<title>Prima di cominciare</title>
<section>
<title>Riguardo a questa introduzione</title>
<body>

<p>
Benvenuti in "Amministrazione di base", la seconda di quattro brevi guide
concepite per preparare il lettore all'esame 101 del Linux Professional
Institute. In questa breve guida, al lettore sarà mostrato come usare le
espressioni regolari nella la ricerca di file per modelli di testo. Poi, verrà
introdotto al Filesystem Hierarchy Standard (FSH) o Gerarchia predefinita per
Filesystem e quindi sarà mostrato come individuare file nel proprio sistema.
Ancora, verrà illustrato come avere pieno controllo dei processi in Linux
eseguendoli in background, recuperando la lista dei processi, slegando processi
dal terminale e tanto ancora. Di seguito, sarà data una fugace introduzione alle
pipeline della shell, le ridirezione e i comandi per l'elaborazione del testo.
Infine, il lettore sarà introdotto ai moduli del kernel Linux.
</p>

<p>
Questa breve guida in particolare (Parte 2) è indicata per coloro che hanno una
buona conoscenza di base riguardo bash e vogliono ricevere una solida
introduzione alle tecniche di base per l'amministrazione in Linux. Per chi fosse
nuovo di Linux, si raccomanda di completare la Parte 1 di questa serie di brevi
guide prima di andare avanti. Per tanti, gran parte di questo materiale sarà
nuovo ma molti utenti Linux con più esperienza possono trovare questa breve
guida un bel modo per affinare le loro abilità di base nell'amministrazione in
Linux.
</p>

<p>
Per chi fosse già in possesso della versione di rilascio 1 di questa guida per
altre ragioni oltre alla preparazione dell'esame del LPI, probabilmente non sarà
necessario prendere anche questa. Comunque, se si pianifica di sostenere gli
esami, dovrebbe essere decisamente presa in considerazione la lettura di questa
versione rivista della guida.
</p>

</body>
</section>
<section>
<title>Riguardo agli autori</title>
<body>

<p>
Residente in Albuquerque, New Mexico, Daniel Robbins è l'Architetto Capo di
Gentoo Linux, un'avanzata meta distribuzione Linux basata su sorgenti. Ha anche
scritto articoli, brevi guide e suggerimenti nell'area dedicata a Linux dell'IBM
developerWorks e per l'Intel Developer Services e ha anche preso parte come
autore di contributi per diversi libri, incluso Samba Unleashed e SuSE Linux
Unleashed. Daniel si diverte passando il proprio tempo con sua moglie, Mary, e
sua figlia, Hadassah. È possibile contattare Daniel all'indirizzo
<mail>drobbins@gentoo.org</mail>.
</p>

<p>
Chris Houser, conosciuto dagli amici come "Chouser", è diventato un sostenitore
di UNIX fin dal 1994 quando ha preso parte al gruppo di amministrazione delle
reti scientifiche di calcolatori alla Taylor University nell'Indiana, dove ha
conseguito la sua laurea in Scienze Informatiche e Matematiche. Fino da allora,
ha continuato a lavorare nella programmazione di applicazioni Web, sviluppo di
interfacce utente, supporto professionale al software video e ora alla
programmazione di driver per dispositivi Tru64 UNIX alla Compaq. Ha anche
contribuito a diversi progetti di software libero, più recentemente a Gentoo
Linux. Vive con sua moglie e due gatti in New Hampshire. È possibile contattare
Chris a chouser@gentoo.org.
</p>

<p>
Aron Griffis è diplomato alla Taylor University con una laurea in Scienze
Informatiche e un premio che dichiara, "Futuro Fondatore di un utopistico gruppo
UNIX". Lavorando verso questo obiettivo, Aron è impiegato presso Compaq
scrivendo driver di rete per TRU64UNIX e spende il suo tempo libero accordando
il piano o sviluppando Gentoo Linux. Vive con sua moglie Amy (anche lei
ingegnere UNIX) in Nashua, New Hampshire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Espressioni regolari</title>
<section>
<title>Cosa sono le espressioni regolari</title>
<body>

<p>
Una espressione regolare (anche chiamata "regex" o "regexp") è una sintassi
speciale usata per descrivere modelli di testo (o pattern). Su sistemi Linux, le
espressioni regolari sono di solito usate per trovare modelli di testo così come
effettuare operazioni di search-and-replace (cerca e sostituisci) su flussi di
testo.
</p>

</body>
</section>
<section>
<title>Confronto fra glob</title>
<body>

<p>
Nel momento in cui si affronta l'argomento espressioni regolari, ci si accorge
che la sintassi delle espressioni regolari assomiglia alla sintassi del
"globbing" per nomi di file vista nella Parte 1. Comunque, non bisogna farsi
distrarre da questo; la loro somiglianza è solo superficiale. Sia le espressioni
regolari che i modelli di globbing per nomi di file, nonostante possano
assomigliarsi, sono entità radicalmente diverse.
</p>

</body>
</section>
<section>
<title>La semplice sotto stringa</title>
<body>

<p>
Con cautela, sarà data un'occhiata all'elemento di base delle espressioni
regolari, la semplice sotto stringa. Per fare questo, verrà usato <c>grep</c>,
un comando che esamina il contenuto di un file alla ricerca di una particolare
espressione regolare. Il comando grep stampa ogni linea che concorda con
l'espressione regolate e ignora ogni linea discordante:
</p>

<pre caption="grep in azione">
$ <i>grep bash /etc/passwd</i>
operator:x:11:0:operator:/root:/bin/bash
root:x:0:0::/root:/bin/bash
ftp:x:40:1::/home/ftp:/bin/bash
</pre>

<p>
Sopra, il primo parametro di <c>grep</c> è un regex (espressione regolare, da
regular expression); il secondo è il nome del file. <c>grep</c> legge ogni linea
in /etc/passwd e applica la semplice sotto stringa regex di bash ad esse,
cercando una corrispondenza. Se c'è un riscontro, <c>grep</c> stampa a video
l'intera linea; altrimenti, la linea viene ignorata.
</p>

</body>
</section>
<section>
<title>Capire la semplice sotto stringa</title>
<body>

<p>
In genere, se si sta cercando una sotto stringa, basta specificare il testo alla
lettera senza fornire alcune carattere "speciale". Le sole volte in cui esiste
la necessità di fare qualcosa di speciale è laddove la propria sotto stringa
contiene un +, ., *, [, ] o \, nel qual caso questi caratteri devono essere
racchiusi fra apici e preceduti da una barra inversa. Di seguito alcuni esempi
di semplici sotto stringhe come espressioni regolari:
</p>

<ul>
  <li>/tmp (esamina alla ricerca della stringa letterale /tmp)</li>
  <li>"\[box\]" (esamina alla ricerca della stringa letterale [box])</li>
  <li>"\*funny\*" (esamina alla ricerca della stringa letterale *funny*)</li>
  <li>"ld\.so" (esamina alla ricerca della stringa letterale ld.so)</li>
</ul>

</body>
</section>
<section>
<title>Meta caratteri</title>
<body>

<p>
Con le espressioni regolari, possono essere effettuate molte ricerche più
complesse di quelle negli esempi visti sopra traendo vantaggio dai meta
caratteri. Uno di questi meta caratteri è il . (un punto), che si combina con
ogni carattere singolo:
</p>

<pre caption="Il meta carattere punto">
$ <i>grep dev.hda /etc/fstab</i>
/dev/hda3       /               reiserfs        noatime,ro 1 1
/dev/hda1       /boot           reiserfs        noauto,noatime,notail 1 2
/dev/hda2       swap            swap            sw 0 0
#/dev/hda4      /mnt/extra      reiserfs        noatime,rw 1 1
</pre>

<p>
In questo esempio, il testo letterale dev.hda non appare su nessuna delle linee
in /etc/fstab. Tuttavia, grep non esaminerà il file cercando la stringa
letterale dev.hda, ma il modello dev.hda. Bisogna ricordare che il .
corrisponderà a qualsiasi singolo carattere. Come è possibile vedere, il meta
carattere . ha funzionalità equivalenti a quelle del meta carattere ? nelle
espansioni "glob".
</p>

</body>
</section>
<section>
<title>Usare []</title>
<body>

<p>
Se si desidera riscontrare un carattere in modo più specifico del ., è possibile
usare [ e ] (parentesi quadre) per indicare un sotto insieme di caratteri che
dei quale effettuare la corrispondenza:
</p>

<pre caption="Parentesi in azione">
$ <i>grep dev.hda[12] /etc/fstab</i>
/dev/hda1       /boot           reiserfs        noauto,noatime,notail 1 2
/dev/hda2       swap            swap            sw 0 0
</pre>

<p>
Come si nota, questa particolare caratteristica sintattica opera in modo
identico a [] nell'espansione di nomi di file "glob". Ancora, questa è una delle
cose delicate da imparare riguardo alle espressioni regolari -- la sintassi è
simile ma non identica alla sintassi per l'espansione di nomi di file "glob", la
quale spesso rende le regex leggermente più difficili da imparare.
</p>

</body>
</section>
<section>
<title>Usare [^]</title>
<body>

<p>
Il significato delle parentesi quadre può essere invertito inserendo un ^
immediatamente prima di [. In questo caso, le parentesi corrisponderanno ad ogni
carattere che <e>non</e> è inserito nella lista all'interno di esse. Ancora, da
notare l'uso di [^] con le espressioni regolari, ma [!] con globs:
</p>

<pre caption="Parentesi con negazione">
$ <i>grep dev.hda[^12] /etc/fstab</i>
/dev/hda3       /               reiserfs        noatime,ro 1 1
#/dev/hda4      /mnt/extra      reiserfs        noatime,rw 1 1
</pre>

</body>
</section>
<section>
<title>Diversa sintassi</title>
<body>

<p>
È importante osservare che la sintassi all'interno delle parentesi quadre è
fondamentalmente diversa da quella presente in altri punti nelle espressioni
regolari. Per esempio, se viene inserito un . all'interno delle parentesi
quadre, permetterà a quest'ultime di effettuare una corrispondenza con il
carattere letterale ., come negli esempi 1 e 2 sopra. In confronto, un letterale
. fuori dalle parentesi quadre è interpretato come un meta carattere a meno che
non presenti il prefisso \. Da ciò può essere tratto vantaggio per stampare una
lista di tutte le linee in <path>/etc/fstab</path> che contengono la stringa
letterale dev.hda, digitando:
</p>

<pre caption="Stampare letterali usando le parentesi">
$ <i>grep dev[.]hda /etc/fstab</i>
</pre>

<p>
In alternativa, è possibile digitare anche:
</p>

<pre caption="Stampare letterali usando il carattere di evasione">
$ <i>grep "dev\.hda" /etc/fstab</i>
</pre>

<p>
Nessuna delle espressioni regolari è possibile che riscontri ogni linea nel file
<path>/etc/fstab</path> dell'utente.
</p>

</body>
</section>
<section>
<title>Il meta carattere "*"</title>
<body>

<p>
Alcuni meta caratteri non riscontrano niente di per sé, ma piuttosto modificano
il significato del carattere precedente. Uno di questi meta caratteri è *
(asterisco), che viene usato per indicare zero o più occorrenze ripetute del
carattere precedente. Notare che questo comporta che l'* ha un significato
diverso in una regex rispetto a quello visto per i glob. Di seguito alcuni
esempi, per cui andrebbe fatta attenzione alle istanze dove queste regex
riscontrano differenze dai glob:
</p>

<ul>
  <li>
    ab*c comprende abbbbc ma non abqc  (in un glob, sarebbero accettate entrambe
    le stringhe -- il lettore riesce a immaginarsi come?))
  </li>
  <li>
    ab*c comprende abc ma non abbqbbc (ancora, in un glob, sarebbero riscontrate
    entrambe le stringhe)
  </li>
  <li>
    ab*c comprende ac ma non cba (se in un glob, ac non sarebbe riscontrato e
    così neanche cba)
  </li>
  <li>
    b[cq]*e comprende bqe e be (se in un glob, sarebbe stato compreso bqe ma non
    più be)
  </li>
  <li>
    b[cq]*e comprende bccqqe ma non bccc (se in un glob, sarebbe stata accettata
    la prima ma non la seconda)
  </li>
  <li>
    b[cq]*e comprende bqqcce ma non cqe (se in un glob, sarebbe stata
    riscontrata la prima ma non anche la seconda)
  </li>
  <li>
    b[cq]*e comprende bbbeee (questo non sarebbe lo stesso con un glob)
  </li>
  <li>
    .* accetterà ogni stringa (se in un glob, sarebbero state riscontrate solo
    stringhe che iniziassero con .)
  </li>
  <li>
    foo.* comprenderà ogni stringa che comincia per foo (in un glob sarebbe
    stata accettata ogni stringa che cominciasse con i caratteri letterali con
    foo.)
  </li>
</ul>

<p>
Adesso, per una veloce ripasso mentale: la linea ac accetta la regex ab*c perché
l'asterisco permette anche all'espressione precedente (b) di apparire
<e>zero</e> volte. Ancora, è fondamentale notare che il meta carattere * delle
regex è interpretato in maniera fondamentalmente diversa  rispetto al carattere
glob *.
</p>

</body>
</section>
<section>
<title>Inizio e fine di una linea</title>
<body>

<p>
Gli ultimi meta caratteri che verranno discussi in dettaglio qui sono i
metacaratteri ^ e $, usati per indicare l'inizio e la fine di una linea,
rispettivamente. Usando un ^ all'inizio della propria regex, si ottiene una
reazione per cui il proprio modello (o pattern) è "ancorato" all'inizio della
linea. Nell'esempio seguente, viene usata la regex ^# per riscontrare ogni linea
che inizia con il carattere #:
</p>

<pre caption="Linee">
$ <i>grep ^# /etc/fstab</i>
# /etc/fstab: static file system information.
#
</pre>

</body>
</section>
<section>
<title>Regex su linee intere</title>
<body>

<p>
^ e $ possono essere combinate per indicare l'intera linea. Per esempio, la
regex seguente riscontrerà una linea che inizia con il carattere # e finisce con
il carattere ., qualsiasi sia il numero di altri caratteri compreso fra essi:
</p>

<pre caption="Indicare una linea intera">
$ <i>grep '^#.*\.$' /etc/fstab</i>
# /etc/fstab: static file system information.
</pre>

<p>
Nell'esempio precedente, l'espressione regolare è stata circondata con apici
singoli per prevenire l'interpretazione del $ da parte della shell. Senza gli
apici singoli, il $ sparirebbe dalla regex prima che grep possa avere la
possibilità di dargli un'occhiata.
</p>

</body>
</section>
</chapter>

<chapter>
<title>FHS e la ricerca di file</title>
<section>
<title>Filesystem Hierarchy Standard</title>
<body>

<p>
Il Filesystem Hierarchy Standard è un documento che specifica la disposizione
delle cartelle su un sistema Linux. Il FHS fu escogitato per fornire una
struttura comune così da semplificare lo sviluppo di software indipendente dalle
distribuzioni -- in questo modo le cose sono di solito allo stesso posto nelle
diverse distribuzioni Linux. Il FHS determina il seguente albero di cartelle
(preso direttamente dalle specifiche FHS):
</p>

<ul>
  <li>/ (la cartella radice)</li>
  <li>/boot (file statici del boot loader)</li>
  <li>/dev (file di dispositivi, o device)</li>
  <li>/etc (configurazione specifica del sistema ospite)</li>
  <li>/lib (librerie condivise essenziali e moduli del kernel)</li>
  <li>/mnt (punti di montaggio, o mount point, per agganciare un filesystem
	  temporaneamente)</li>
  <li>/opt (pacchetti software aggiuntivi)</li>
  <li>/sbin (binari di sistema indispensabili)</li>
  <li>/tmp (file temporanei)</li>
  <li>/usr (gerarchia secondaria)</li>
  <li>/var (dati variabili)</li>
</ul>

</body>
</section>
<section>
<title>Le due categorie indipendenti di FHS</title>
<body>

<p>
FHS basa la propria specifica della struttura sull'idea che ci sono due
categorie indipendenti di file: condivisibili contro non condivisibili, e
variabili contro statici. I dati condivisibili possono essere, appunto,
condivisi tra sistemi; i dati non condivisibili sono specifici di un dato host
(come i file di configurazione). I dati variabili possono essere modificati; i
dati statici non sono modificabili (eccetto nelle fasi di installazione e
manutenzione del sistema).
</p>

<p>
La griglia seguente riassume le quattro possibili combinazioni, con esempi di
cartelle che potrebbero trovarsi in queste categorie. Ancora, questa tabella è
ricavata dalla specifica di FHS (NdT: le voci della tabella sono state tradotte
dalla versione originale per chiarezza e completezza):
</p>

<pre caption="FHS">
+----------+-----------------+-------------------+
|          | condivisibili   | non condivisibili |
+----------+-----------------+-------------------+
|statiche  | /usr            | /etc              |
|          | /opt            | /boot             |
+----------+-----------------+-------------------+
|variabili | /var/mail       | /var/run          |
|          | /var/spool/news | /var/lock         |
+----------+-----------------+-------------------+
</pre>

</body>
</section>
<section>
<title>Gerarchia secondaria in /usr</title>
<body>

<p>
Sotto <path>/usr</path> l'utente potrà trovare una gerarchia secondaria che
assomiglia molto al filesystem principale. Non è fondamentale per
<path>/usr</path> esistere quando la macchina si avvia, perciò può essere
condiviso su una rete (condivisibile), o montato da un CD-ROM (statico). Molte
configurazioni di Linux non usano condividere <path>/usr</path>, ma è prezioso
capire l'utilità nel distinguere tra gerarchia primaria sulla cartella radice e
gerarchia secondaria su <path>/usr</path>.
</p>

<p>
Questo è tutto ciò che verrà detto su Filesystem Hierarchy Standard. Il
documento di per se è abbastanza comprensibile, quindi il lettore può andare a
dargli un'occhiata. Leggendolo si avrà un'idea molto più chiara riguardo al
filesystem in Linux. Lo si può trovare a
<uri>http://www.pathname.com/fhs/</uri>.
</p>

</body>
</section>
<section>
<title>Ricerca di file</title>
<body>

<p>
I sistemi Linux spesso contengono centinaia di migliaia di file. Forse chi legge
avrà abbastanza buon senso da non perdere mai traccia di nessuno di questi, ma è
molto più probabile che talvolta si abbia il bisogno di trovarne qualcuno. Ci
sono due diversi strumenti su Linux per la ricerca di file. Questa introduzione
aiuterà il lettore a scegliere il mezzo giusto per il lavoro.
</p>

</body>
</section>
<section>
<title>Il PATH (percorso)</title>
<body>

<p>
Quando viene eseguito un programma da riga di comando, bash in effetti cerca
attraverso una lista di cartelle per scovare il programma richiesto. Per
esempio, quando si digita <c>ls</c>, <c>bash</c> non sa già che il programma ls
risiede in <path>/usr/bin</path>. Invece, bash fa riferimento a una variabile
d'ambiente chiamata PATH, che è una lista di cartelle separate da due punti. È
possibile esaminare il valore di PATH:
</p>

<pre caption="Vedere il proprio path">
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin
</pre>

<p>
Dato questo valore di PATH (il proprio può differire) bash controllerebbe prima
<path>/usr/local/bin</path>, quindi <path>/usr/bin</path> in cerca del programma
<c>ls</c>. Più probabilmente, <c>ls</c> sarà trovato <path>/usr/bin</path>, così
bash potrebbe fermarsi a questo punto.
</p>

</body>
</section>
<section>
<title>Modificare il PATH</title>
<body>

<p>
È possibile allargare il proprio PATH assegnando ad esso su riga di comando:
</p>

<pre caption="Modificare il PATH">
$ <i>PATH=$PATH:~/bin</i>
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin:/home/agriffis/bin
</pre>

<p>
È possibile anche rimuovere elementi dal PATH, anche se questo non è così facile
dato che non ci si può riferire ad un $PATH esistente. La cosa migliore è
digitare semplicemente il nuovo PATH desiderato:
 </p>

<pre caption="Rimuovere voci dal PATH">
$ <i>PATH=/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:~/bin</i>
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/agriffis/bin
</pre>

<p>
Per rendere le proprie modifiche al PATH disponibili ad ogni futuro processo
avviato da questa shell, basta esportare le proprie modifiche usando il comando
export:
</p>

<pre caption="Esportare il PATH (o ogni variabile, per questo scopo)">
$ <i>export PATH</i>
</pre>

</body>
</section>
<section>
<title>Tutto ciò che c'è da sapere su "which"</title>
<body>

<p>
È possibile controllare se è presente un dato programma nel proprio PATH usando
<c>which</c>. Per esempio, di seguito avremo un esempio in cui in un sistema
Linux non è presente il (diffuso) programma sense:
</p>

<pre caption="Fare richiesta per sense">
$ which <i>sense</i>
which: no sense in (/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin)
</pre>

<p>
Nell'esempio che segue, viene scovato con successo <c>ls</c>:
</p>

<pre caption="Fare richiesta per ls">
$ <i>which ls</i>
/usr/bin/ls
</pre>

</body>
</section>
<section>
<title>"which -a"</title>
<body>

<p>
Infine, ci si dovrebbe preoccupare del flag <c>-a</c>, che porta <c>which</c> a
mostrare tutte le istanze di un dato programma presenti nel proprio PATH:
</p>

<pre caption="Trovare tutte le istanze di un programma presenti nel proprio
	PATH">
$ <i>which -a ls</i>
/usr/bin/ls
/bin/ls
</pre>

</body>
</section>
<section>
<title>whereis</title>
<body>

<p>
Per chi fosse interessato a ricavare più informazioni che semplicemente la
locazione di un programma, dovrebbe provare il programma <c>whereis</c>:
</p>

<pre caption="Usare whereis">
$ <i>whereis ls</i>
ls: /bin/ls /usr/bin/ls /usr/share/man/man1/ls.1.gz
</pre>

<p>
Qua si vede che <c>ls</c> compare in due posizioni comuni per i binari,
<path>bin</path> e <path>/usr/bin</path>. In aggiunta, si viene informati che
c'è una pagina di manuale presente in <path>/usr/share/man</path>. Questa è la
pagina man che dovrebbe venire mostrate digitando <c>man ls</c>.
</p>

<p>
Il programma <c>whereis</c> possiede anche l'abilità di ricercare i sorgenti,
specificare percorsi di ricerca alternativi e ricercare voci non usuali. Il
lettore faccia riferimento alla relativa pagina man per maggiori informazioni.
</p>

</body>
</section>
<section>
<title>find</title>
<body>

<p>
Il comando <c>find</c> è un altro pratico strumento per la propria macchina. Con
find infatti non si è limitati ai programmi; è possibile ricercare ogni file
desiderato, usando una varietà di criteri di ricerca. Per esempio, per cercare
un file di nome README, iniziando da <path>/usr/share/doc</path>:
</p>

<pre caption="Usare find">
$ <i>find /usr/share/doc -name README</i>
/usr/share/doc/ion-20010523/README
/usr/share/doc/bind-9.1.3-r6/dhcp-dynamic-dns-examples/README
/usr/share/doc/sane-1.0.5/README
</pre>

</body>
</section>
<section>
<title>find e wildcard</title>
<body>

<p>
Possono essere usate wildcard "glob" nell'argomento passato a -name, a patto che
vengano inserite fra apici o precedute dal carattere di escaping barra inversa
(così che vengano passati a find intatti piuttosto che venire espansi da bash).
Per esempio, volendo cercare file README con estensioni:
</p>

<pre caption="Usare find con le wildcard">
$ <i>find /usr/share/doc -name README\*</i>
/usr/share/doc/iproute2-2.4.7/README.gz
/usr/share/doc/iproute2-2.4.7/README.iproute2+tc.gz
/usr/share/doc/iproute2-2.4.7/README.decnet.gz
/usr/share/doc/iproute2-2.4.7/examples/diffserv/README.gz
/usr/share/doc/pilot-link-0.9.6-r2/README.gz
/usr/share/doc/gnome-pilot-conduits-0.8/README.gz
/usr/share/doc/gimp-1.2.2/README.i18n.gz
/usr/share/doc/gimp-1.2.2/README.win32.gz
/usr/share/doc/gimp-1.2.2/README.gz
/usr/share/doc/gimp-1.2.2/README.perl.gz
[578 additional lines snipped]
</pre>

</body>
</section>
<section>
<title>Ignorare maiuscole/minuscole con find</title>
<body>

<p>
Certamente, l'utente potrebbe volere ignorare la presenza di lettere maiuscole o
minuscole nella propria ricerca:
</p>

<pre caption="Ignorare maiuscole/minuscole con find">
$ <i>find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'</i>
</pre>

<p>
O, più semplicemente:
</p>

<pre caption="Metodo alternativo">
$ <i>find /usr/share/doc -iname readme\*</i>
</pre>

<p>
Come si può notare, è possibile usare <c>-iname</c> per rendere insensibile alle
maiuscole/minuscole (case-insensitive) la ricerca.
</p>

</body>
</section>
<section>
<title>find e le espressioni regolari</title>
<body>

<p>
Per chi ha familiarità con le espressioni regolari, c'è la possibilità di usare
l'opzione <c>-regex</c> per limitare l'output ai nomi di file che rispettano un
dato modello. In modo simile all'opzione <c>-iname</c>, c'è la corrispondente
opzione <c>-iregex</c> che ignora maiuscole/minuscole nel modello. Per esempio:
</p>

<pre caption="Regex e find">
$ <i>find /etc -iregex '.*xt.*'</i>
/etc/X11/xkb/types/extra
/etc/X11/xkb/semantics/xtest
/etc/X11/xkb/compat/xtest
/etc/X11/app-defaults/XTerm
/etc/X11/app-defaults/XTerm-color
</pre>

<p>
Da notare che diversamente da altri programma, <c>find</c> impone che la regex
indicata riscontri l'intero percorso, non solo una parte di esso. Per questo
motivo, è necessario specificare .* a monte e a valle del modello; semplicemente
usare xt come regex potrebbe non essere sufficiente.
</p>

</body>
</section>
<section>
<title>find e tipi</title>
<body>

<p>
L'opzione <c>-type</c> mette a disposizione dell'utente un modo per trovare
oggetti di un certo tipo nel filesystem. I possibili argomenti per -type sono
<c>b</c> (block device, dispositivo a blocchi), <c>c</c> (character device,
dispositivo a caratteri), <c>d</c> (directory, cartella), <c>p</c> (named pipe,
pipe dichiarata), <c>f</c> (regular file, file regolare), <c>l</c> (symbolic
link, collegamento simbolico) e <c>s</c> (socket, punto di accesso). Per
esempio, per cercare collegamenti simbolici in <path>/usr/bin</path> che
contengono la stringa vim:
</p>

<pre caption="Limitare find con i tipi">
$ <i>find /usr/bin -name '*vim*' -type l</i>
/usr/bin/rvim
/usr/bin/vimdiff
/usr/bin/gvimdiff
</pre>

</body>
</section>
<section>
<title>find e mtimes</title>
<body>

<p>
L'opzione <c>-mtime</c> abilita l'utente a selezionare file basandosi sulla loro
ultima nota temporale di modifica. L'argomento di mtime è dato in termini di
periodi di 24 ore e molto utile quando passato in aggiunta ad un segno positivo
(che significa "dopo") o un segno negativo (che significa "prima"). Per esempio,
si consideri il seguente scenario:
</p>

<pre caption="Scenario">
$ <i>ls -l ?</i>
-rw-------    1 root     root            0 Jan  7 18:00 a
-rw-------    1 root     root            0 Jan  6 18:00 b
-rw-------    1 root     root            0 Jan  5 18:00 c
-rw-------    1 root     root            0 Jan  4 18:00 d
$ <i>date</i>
Mon May  7 18:14:52 EST 2003
</pre>

<p>
È possibile cercare file che sono stati creati nelle 24 ore passate:
</p>

<pre caption="File creati nelle 24 ore precedenti">
$ <i>find . -name \? -mtime -1</i>
./a
</pre>

<p>
Oppure l'utente potrebbe voler cercare file che sono stati creati prima
dell'attuale periodo di 24 ore:
</p>

<pre caption="File creati prima delle ultime 24 ore">
$ <i>find . -name \? -mtime +0</i>
./b
./c
./d
</pre>

</body>
</section>
<section>
<title>L'opzione -daystart</title>
<body>

<p>
Se viene specificato in aggiunta l'opzione <c>-daystart</c>, allora i periodi
temporali cominciano dall'inizio del giorno indicato piuttosto che nelle 24 ore
precedenti. Per esempio, di seguito un insieme di file creati il giorno
precedente e quello prima ancora:
</p>

<pre caption="Usare -daystart">
$ <i>find . -name \? -daystart -mtime +0 -mtime -3</i>
./b
./c
$ ls -l b c
-rw-------    1 root     root            0 May  6 18:00 b
-rw-------    1 root     root            0 May  5 18:00 c
</pre>

</body>
</section>
<section>
<title>L'opzione -size</title>
<body>

<p>
L'opzione <c>-size</c> fornisce all'utente un modo per trovare file basandosi
sulla loro dimensione. In modo predefinito, l'argomento di <c>-size</c> è dato
da blocchi di 512 byte, ma aggiungendo un suffisso possono essere rese le cose
più facili. I suffissi disponibili sono <c>b</c> (blocchi di 512 byte), <c>c</c>
(byte), <c>k</c> (kilobyte) e <c>w</c> (parole di 2 byte). In più, è possibile
aggiungere un segno positivo ("più grande di") o negativo ("più piccolo di").
</p>

<p>
Per esempio, per cercare file regolari in <path>/usr/bin</path> che sono più
piccoli di 50 byte:
</p>

<pre caption="-size in azione">
$ <i>find /usr/bin -type f -size -50c</i>
/usr/bin/krdb
/usr/bin/run-nautilus
/usr/bin/sgmlwhich
/usr/bin/muttbug
</pre>

</body>
</section>
<section>
<title>Processare i file trovati</title>
<body>

<p>
L'utente potrebbe chiedersi cosa sia possibile fare con tutti i file che sono
stati trovati. Bene, <c>find</c> ha la capacità di agire sui file che sono stati
trovati usando l'opzione <c>-exec</c>. Questa opzione accetta una riga di
comando da eseguire come proprio argomento, terminata con ;, e rimpiazza ogni
occorrenza di {} con il nome del file. Questo lo si capisce meglio con un
esempio:
</p>

<pre caption="Usare -exec">
$ <i>find /usr/bin -type f -size -50c -exec ls -l '{}' ';'</i>
-rwxr-xr-x    1 root     root           27 Oct 28 07:13 /usr/bin/krdb
-rwxr-xr-x    1 root     root           35 Nov 28 18:26 /usr/bin/run-nautilus
-rwxr-xr-x    1 root     root           25 Oct 21 17:51 /usr/bin/sgmlwhich
-rwxr-xr-x    1 root     root           26 Sep 26 08:00 /usr/bin/muttbug
</pre>

<p>
Come si può vedere, <c>find</c> è davvero un comando potente. È cresciuto
attraverso gli anni di sviluppo di UNIX e Linux. Ci sono molte altre opzioni
utili in find. Si può approfondire l'argomento nella pagina di manuale di find.
</p>

</body>
</section>
<section>
<title>locate</title>
<body>

<p>
Sono stati discussi <c>which</c>, <c>whereis</c> e <c>find</c>. Il lettore
potrebbe aver notato che <c>find</c> rischia di prendere abbastanza tempo per
l'esecuzione, dato che necessita di leggere ogni cartella in cui ricerca. È
dimostrato che il comando <c>locate</c> può rendere più veloci le cose
affidandosi ad una base dati esterna generata da <c>updatedb</c> (che sarà
discusso in seguito).
</p>

<p>
Il comando <c>locate</c> si affida ad ogni parte nel nome del percorso, non solo
il file stesso. Per esempio:
</p>

<pre caption="locate in azione">
$ <i>locate bin/ls</i>
/var/ftp/bin/ls
/bin/ls
/sbin/lsmod
/sbin/lspci
/usr/bin/lsattr
/usr/bin/lspgpot
/usr/sbin/lsof
</pre>

</body>
</section>
<section>
<title>Usare updatedb</title>
<body>

<p>
Molti sistemi Linux hanno un "cron job" (processo cron) per aggiornare la base
dati periodicamente. Se il proprio <c>locate</c> ritorna un errore come il
seguente, allora l'utente avrà bisogno di eseguire <c>updatedb</c> come utente
root per generare la base dati di ricerca:
</p>

<pre caption="Aggiornare la propria base dati per locate">
$ <i>locate bin/ls</i>
locate: /var/spool/locate/locatedb: No such file or directory
$ <i>su -</i>
Password:
# <i>updatedb</i>
</pre>

<p>
Il comando <c>updatedb</c> potrebbe prendere diverso tempo per l'esecuzione. Se
si possiede un disco fisso rumoroso, è possibile che si sentano alcuni forti
rumori mentre l'intero filesystem viene indicizzato.
</p>


</body>
</section>
<section>
<title>mlocate</title>
<body>

<p>
Su molte distribuzioni Linux, il comando <c>locate</c> è stato rimpiazzato da
<c>mlocate</c>. C'è solitamente un collegamento simbolico a <c>locate</c>, così
che non vi sia la necessità di ricordarsi quale si possiede. <c>mlocate</c> sta
per "secure locate" (locate sicuro). Immagazzina informazioni sui permessi nella
base dati così che ai normali utenti sia proibito curiosare in cartelle che
sarebbero altrimenti non abilitati a leggere. Le informazioni sull'uso di
<c>mlocate</c> sono essenzialmente le stesse viste per <c>locate</c>, anche se
l'output potrebbe essere diverso in relazione all'utente che esegue il comando.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Controllo dei processi</title>
<section>
<title>Osservare xeyes</title>
<body>

<p>
Per imparare qualcosa sul controllo dei processi, bisogna prima avviare un
processo. Assicurarsi di avere X in esecuzione e lanciare il seguente comando:
</p>

<pre caption="Avviare un processo">
$ <i>xeyes -center red</i>
</pre>

<p>
Il lettore noterà che una finestra di xeyes comparirà e i bulbi oculari rossi
seguiranno il puntatore del mouse a giro per la finestra. Si noterà anche la non
presenza di un nuovo prompt sul proprio terminale.
</p>

</body>
</section>
<section>
<title>Fermare un processo</title>
<body>

<p>
Per riappropriarsi del prompt, bisogna digitare Control-C (spesso indicato come
Ctrl-C o ^C):
</p>

<p>
Sarà presentato un nuovo prompt di bash ma la finestra di xeyes scomparirà.
Infatti, l'intero processo è stato terminato, ucciso. Piuttosto che terminarlo,
lo si può solo fermare con Contrl-Z
</p>

<pre caption="Fermare un processo">
$ <i>xeyes -center red</i>
<i>Control-Z</i>
[1]+  Stopped                 xeyes -center red
$
</pre>

<p>
Questa volta è ottenuto un nuovo prompt di bash e la finestra di xeyes rimarrà
attiva. Giocando un po' con questa, comunque, si noterà che le palle degli occhi
sono ferme al loro posto. Se la finestra di xeyes viene coperta da un'altra
finestra e quindi nuovamente scoperta, l'utente vedrà che questa non è perfino
ridisegnata completamente. Il processo non sta facendo niente. In effetti è
"fermato" (o "stoppato").
</p>

</body>
</section>
<section>
<title>fg e bg</title>
<body>

<p>
Per rendere il processo "non-stoppato" ed eseguirlo ancora, lo si può portare in
primo piano (foreground) con il comando <c>fg</c> interno a bash:
</p>

<pre caption="usare fg">
$ <i>fg</i>
<comment>(verificarlo, quindi fermare di nuovo il processo)</comment>
<i>Control-Z</i>
[1]+  Stopped                 xeyes -center red
$
</pre>

<p>
Adesso continuiamo con esso sullo sfondo (background) con il comando <c>bg</c>
interno a bash:
</p>

<pre caption="usare bg">
$ <i>bg</i>
[1]+ xeyes -center red &amp;
$
</pre>

<p>
Ottimo. Il processo xeyes sta ora eseguendo sullo sfondo e in aggiunta è
presente un nuovo prompt di bash funzionante.
</p>

</body>
</section>
<section>
<title>Usare "&amp;"</title>
<body>

<p>
Nel caso in qualcuno desideri avviare xeyes sullo sfondo fin da principio
(invece di usare Control-Z e bg), basterà solo aggiungere un "&amp;" ("e"
commerciale, o ampersand) alla fine della riga di comando per xeyes:
</p>

<pre caption="Usare un ampersand per eseguire sullo sfondo i processi">
$ <i>xeyes -center blue &amp;</i>
[2] 16224
</pre>

</body>
</section>
<section>
<title>Processi sullo sfondo multipli</title>
<body>

<p>
Adesso ci sono xeyes sia rossi che blu in esecuzione sullo sfondo. Questi lavori
(job) possono essere elencati con il comando <c>jobs</c> interno a bash:
</p>

<pre caption="Usare jobs">
$ <i>jobs -l</i>
[1]- 16217 Running                 xeyes -center red &amp;
[2]+ 16224 Running                 xeyes -center blue &amp;
</pre>

<p>
I numeri nella colonna di sinistra sono il numero di lavoro assegnato da bash
quando sono stati avviati. Il secondo elemento ha un + (più) ad indicare che
questo è il processo "corrente", e ciò significa che digitando <c>fg</c> questo
verrà portato in primo piano. Esiste comunque la possibilità di scegliere un
processo (o job) specifico da portare in primo piano indicando il suo numero;
per esempio, <c>fg 1</c> renderebbe gli xeyes rossi il processo in primo piano.
La colonna che segue è l'id di processo o pid, incluso cortesemente nella lista
dall'opzione -l di jobs. Infine, entrambi i processi sono "Running" (in
esecuzione) e la loro riga di comando è riportata sulla destra.
</p>

</body>
</section>
<section>
<title>Introduzione ai segnali</title>
<body>

<p>
Per terminare, fermare o ripristinare processi, Linux usa una speciale forma di
comunicazione chiamata "segnali". Inviando un certo segnale ad un processo, si
può imporre ad esso di terminare, fermarsi o fare altre cose. Questo è ciò che
in effetti succede digitando Control-C, Control-Z o usando i comandi interni
<c>bg</c> o <c>fg</c> -- si sta usando bash per inviare un particolare segnale
al processo. Questi segnali possono anche essere inviati usando il comando
<c>kill</c> e specificando il pid (id di processo) sulla riga di comando:
</p>

<pre caption="Usare kill">
$ <i>kill -s SIGSTOP 16224</i>
$ <i>jobs -l</i>
[1]- 16217 Running                 xeyes -center red &amp;
[2]+ 16224 Stopped (signal)        xeyes -center blue
</pre>

<p>
Come si nota, kill non "uccide" necessariamente un processo, nonostante possa
farlo. Usando l'opzione "-s", <c>kill</c> può inviare ogni sorta di segnale ad
un processo. Linux termina, ferma o ripristina i processi quando sono inviati
rispettivamente i segnali SIGINT, SIGSTOP o SIGCONT. Ci sono anche altri segnali
che si possono inviare ad un processo; molti di questi segnali possono essere
interpretati in modo dipendente all'applicazione. È possibile sapere quali
segnali un particolare processo riconosce guardando la sua pagina di manuale e
cercando la sezione SIGNALS.
</p>

</body>
</section>
<section>
<title>SIGTERM e SIGINT</title>
<body>

<p>
In caso si desideri terminare un processo, ci sono diverse possibilità. Di base,
kill invia il segnale SIGTERM, che non ha la stessa fama di SIGINT o Control-C
ma di solito ottiene lo stesso risultato
</p>

<pre caption="Usare kill per terminare un processo">
$ <i>kill 16217</i>
$ <i>jobs -l</i>
[1]- 16217 Terminated              xeyes -center red
[2]+ 16224 Stopped (signal)        xeyes -center blue
</pre>

</body>
</section>
<section>
<title>Uccidere con decisione</title>
<body>

<p>
I processi possono ignorare sia SIGTERM che SIGINT, o per scelta o perchè sono
stati fermati o in qualche modo "catatonici". In questi casi potrebbe essere
necessario usare il grande martello, il segnale SIGKILL. Un processo non può
ignorare SIGKILL:
</p>

<pre caption="Usare kill per eliminare un processo">
$ <i>kill 16224</i>
$ <i>jobs -l</i>
[2]+ 16224 Stopped (signal)        xeyes -center blue
$ <i>kill -s SIGKILL</i>
$ <i>jobs -l</i>
[2]+ 16224 Interrupt               xeyes -center blue
</pre>

</body>
</section>
<section>
<title>nohup</title>
<body>

<p>
Il terminale da cui è avviato un processo viene chiamato il terminale di
controllo del processo. Alcune shell (non bash, in modo predefinito), girano un
segnale SIGHUP ai processi sullo sfondo quando l'utente effettua il logout,
causando la loro terminazione. Per proteggere i processi da questo
comportamento, usare nohup quando viene avviato il processo:
</p>

<pre caption="nohup in azione">
$ <i>nohup make &amp;</i>
[1] 15632
$ <i>exit</i>
</pre>

</body>
</section>
<section>
<title>Usare ps per avere l'elenco dei processi</title>
<body>

<p>
Il comando <c>jobs</c> usato in precedenza semplicemente elenca i processi che
sono stati avviati dalla propria sessione di bash. Per vedere tutti i processi
sul proprio sistema, usare <c>ps</c> con entrambe le opzioni <c>a</c> e
<c>x</c>:
</p>

<pre caption="ps con ax">
$ <i>ps ax</i>
  PID TTY      STAT   TIME COMMAND
    1 ?        S      0:04 init [3]
    2 ?        SW     0:11 [keventd]
    3 ?        SWN    0:13 [ksoftirqd_CPU0]
    4 ?        SW     2:33 [kswapd]
    5 ?        SW     0:00 [bdflush]
</pre>

<p>
È stato riportato l'inizio dell'elenco perché è di solito una lista molto lunga.
Questa da all'utente un'istantanea su cosa l'intera macchina sta facendo, ma
sono una mare di informazioni da passare al setaccio. Se si escludono le opzioni
<c>ax</c>, verranno mostrati solo i processi di cui l'utente è proprietario e
che hanno un terminale di controllo. Il comando <c>ps x</c> mostrerà all'utente
tutti i suoi processi, anche quelli senza un terminale di controllo. Usando
<c>ps a</c>, si otterrà la lista di tutti i processi che sono attaccati ad un
terminale.
</p>

</body>
</section>
<section>
<title>Vedere la foresta e gli alberi</title>
<body>

<p>
Possono essere ricavate anche informazioni diverse su ogni processo. L'opzione
<c>--forest</c> rende facile analizzare la gerarchi di processi, che fornisce al
lettore una indicazione su come i veri processi sul proprio sistema
interagiscono tra loro. Quando un processo avvia un nuovo processo, quest'ultimo
è chiamato processo "figlio" (o "child"). In un listato fornito da
<c>--forest</c>, il processo padre (o parent) appare sulla sinistra e i figli
sono mostrati come rami sulla destra:
</p>

<pre caption="Usare forest">
$ <i>ps x --forest</i>
  PID TTY      STAT   TIME COMMAND
  927 pts/1    S      0:00 bash
 6690 pts/1    S      0:00  \_ bash
26909 pts/1    R      0:00      \_ ps x --forest
19930 pts/4    S      0:01 bash
25740 pts/4    S      0:04  \_ vi processes.txt
</pre>

</body>
</section>
<section>
<title>Le opzioni "u" e "l" di ps</title>
<body>

<p>
Anche le opzioni <c>u</c> o <c>l</c> possono essere aggiunte ad ogni
combinazione di <c>a</c> e <c>x</c> in modo da includere più informazioni
riguardo ogni processo:
</p>

<pre caption="Opzione au">
$ <i>ps au</i>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
agriffis   403  0.0  0.0  2484   72 tty1     S     2001   0:00 -bash
chouser    404  0.0  0.0  2508   92 tty2     S     2001   0:00 -bash
root       408  0.0  0.0  1308  248 tty6     S     2001   0:00 /sbin/agetty 3
agriffis   434  0.0  0.0  1008    4 tty1     S     2001   0:00 /bin/sh /usr/X
chouser    927  0.0  0.0  2540   96 pts/1    S     2001   0:00 bash
</pre>

<pre caption="Opzione al">
$ <i>ps al</i>
  F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY        TIME COMMAND
100  1001   403     1   9   0  2484   72 wait4  S    tty1       0:00 -bash
100  1000   404     1   9   0  2508   92 wait4  S    tty2       0:00 -bash
000     0   408     1   9   0  1308  248 read_c S    tty6       0:00 /sbin/ag
000  1001   434   403   9   0  1008    4 wait4  S    tty1       0:00 /bin/sh
000  1000   927   652   9   0  2540   96 wait4  S    pts/1      0:00 bash
</pre>

</body>
</section>
<section>
<title>Usare top</title>
<body>

<p>
Nel caso in cui l'utente si ritrovi ad eseguire svariate volte di seguito ps,
cercando di percepire i cambiamenti, probabilmente quello di cui ha bisogno è
<c>top</c>. <c>top</c> mostra una lista di processi aggiornandola continuamente,
insieme a alcune utili informazioni riassuntive:
</p>

<pre caption="top">
$ <i>top</i>
 10:02pm  up 19 days,  6:24,  8 users,  load average: 0.04, 0.05, 0.00
75 processes: 74 sleeping, 1 running, 0 zombie, 0 stopped
CPU states:  1.3% user,  2.5% system,  0.0% nice, 96.0% idle
Mem:   256020K av,  226580K used,   29440K free,       0K shrd,    3804K buff
Swap:  136544K av,   80256K used,   56288K free                  101760K cached

  PID USER     PRI  NI  SIZE  RSS SHARE STAT  LIB %CPU %MEM   TIME COMMAND
  628 root      16   0  213M  31M  2304 S       0  1.9 12.5  91:43 X
26934 chouser   17   0  1272 1272  1076 R       0  1.1  0.4   0:00 top
  652 chouser   11   0 12016 8840  1604 S       0  0.5  3.4   3:52 gnome-termin
  641 chouser    9   0  2936 2808  1416 S       0  0.1  1.0   2:13 sawfish
</pre>

</body>
</section>
<section>
<title>nice</title>
<body>

<p>
Ogni processo ha una priorità impostata che Linux usa per determinare come le
porzioni di tempo della CPU sono condivise. È possibile assegnare la priorità ad
un processo avviandolo con il comando <c>nice</c>:
</p>

<pre caption="avviare un processo con nice">
$ <i>nice -n 10 oggenc /tmp/song.wav</i>
</pre>

<p>
Dato che l'impostazione della priorità è detta <c>nice</c> (letteralmente
"buono.gradevole"), dovrebbe essere facile ricordare che un valore più alto
renderà un processo più buono nei confronti degli altri processi, permettendo ad
essi di avere un accesso prioritario alla CPU. Di base, i processi sono avviati
con un impostazione a 0, così l'assegnazione di un valore 10 visto sopra
significa che oggenc rinuncerà puntualmente alla CPU a favore degli altri
processi. Di solito, questo significa che oggenc permetterà agli altri processi
di eseguire alla loro normale velocità, indipendentemente da quanto questo
risulti essere avido di CPU. È possibile vedere il dato livello di bontà
(livello di nice) sotto la colonna NI nei listati di ps e top presentati sopra.
</p>

</body>
</section>
<section>
<title>renice</title>
<body>

<p>
il comando <c>nice</c> può solamente cambiare la priorità di un processo quando
viene avviato. Nel caso in cui si vogliano cambiare le impostazioni di priorità
di un processo in esecuzione, bisogna usare <c>renice</c>:
</p>

<pre caption="usare renice">
$ <i>ps l 641</i>
  F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY        TIME COMMAND
000  1000   641     1   9   0  5876 2808 do_sel S    ?          2:14 sawfish
$ <i>renice 10 641</i>
641: old priority 0, new priority 10
$ <i>ps l 641</i>
  F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY        TIME COMMAND
000  1000   641     1   9  10  5876 2808 do_sel S    ?          2:14 sawfish
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Elaborazione del testo</title>
<section>
<title>Rivisitazione della ridirezione</title>
<body>

<p>
In precedenza all'interno di questa serie di brevi guide, è stato mostrato un
esempio di come usare l'operatore <c>></c> per ridirezionare l'output di un
comando in un file, come segue:
</p>

<pre caption="Uso dell'operatore >">
$ <i>echo "firstfile" > copyme</i>
</pre>

<p>
Oltre alla ridirezione dell'output verso un file, è possibile trarre vantaggio
da una potente caratteristica della shell chiamata pipe (letteralmente, "tubo").
Usando le pipe, è possibile passare l'output di un comando come input di un
altro comando. Si consideri il seguente esempio:
</p>

<pre caption="Introduzione alle pipe">
$ <i>echo "hi there" | wc</i>
      1       2       9
</pre>

<p>
Il carattere <c>|</c> è usato per connettere l'output del comando sulla sinistra
con l'input del comando sulla destra. Nell'esempio precedente, il comando
<c>echo</c> stampa la stringa "hi there" seguita da un carattere di avanzamento
di linea (linefeed). Il risultato apparirebbe di norma sul terminale ma la pipe
lo ridireziona verso il comando <c>wc</c>, che mostra a video il numero di
linee, parole e caratteri nel proprio input.
</p>

</body>
</section>
<section>
<title>Un esempio di uso delle pipe</title>
<body>

<p>
Di seguito un altro semplice esempio:
</p>

<pre caption="pipe in azione">
$ <i>ls -s | sort -n</i>
</pre>

<p>
In questo caso, <c>ls -l</c> mostrerebbe normalmente una lista della cartella
corrente a terminale, precedendo ogni file con la sua dimensione. Invece è stato
ridirezionato il suo output verso <c>sort -n</c>, che ordina numericamente il
risultato. Questo è davvero un modo molto utile per trovare grossi file nella
propria cartella home.
</p>

<p>
Gli esempi che seguono sono un po' più complessi ma dimostrano la potenza che può
essere concentrata nell'uso delle pipe. Saranno usati comandi non ancora
discussi, ma il lettore non deve lasciarsi scoraggiare. Bisogna invece
concentrarsi nella comprensione sul come le pipe operano così da poterle
impiegare nell'uso di tutti i giorni del proprio sistema Linux.
</p>

</body>
</section>
<section>
<title>La pipeline di decompressione</title>
<body>

<p>
Di solito per decomprimere e spacchettare un archivio tar compresso, bisogna
agire come segue:
</p>

<pre caption="Spacchettare un file">
$ <i>bzip2 -d linux-2.4.16.tar.bz2</i>
$ <i>tar xvf linux-2.4.16.tar</i>
</pre>

<p>
Il rovescio della medaglia in questo metodo è dato dal fatto che viene richiesta
la creazione di un file intermedio decompresso sul proprio disco. Dato che
<c>tar</c> ha la capacità di leggere direttamente dal proprio input (invece che
da uno specifico file), potrebbe essere ottenuto lo stesso risultato finale
usando una pipeline (cioè una riga di comando che vede presente una o più pipe):
</p>

<pre caption="spacchettare usando una pipeline">
$ <i>bzip2 -dc linux-2.4.16.tar.bz2 | tar xvf -</i>
</pre>

<p>
Non male. L'immagine compressa è stata estratta senza la necessità di un file
intermedio.
</p>

</body>
</section>
<section>
<title>Una pipeline più lunga</title>
<body>

<p>
Ecco un altro esempio di pipeline:
</p>

<pre caption="pipeline più lunghe">
$ <i>cat mio_file.txt | sort | uniq | wc -l</i>
</pre>

<p>
È stato usato <c>cat</c> per fornire il contenuto di <path>mio_file.txt</path>
al comando <c>sort</c>. Quando il comando <c>sort</c> riceve dati in ingresso,
ordina tutte le linee ricevute così che risultino essere in ordine alfabetico e
poi invia il risultato a <c>uniq</c>. <c>uniq</c> rimuove ogni linea duplicata
(e richiede che il proprio input sia ordinato, tra l'altro) inviando l'output
ripulito a <c>wc -l</c>. Il comando <c>wc</c> è stato già visto in precedenza ma
senza opzioni a riga di comando. Quando viene passata l'opzione <c>-l</c>, viene
stampato il solo numero di linee in ingresso, piuttosto che includere anche
parole e caratteri. Si può notare che questa pipeline restituirà il numero di
linee uniche (non identiche) presenti in un file di testo.
</p>

<p>
Il lettore è invitato a creare un paio di file di testo con il proprio editor
preferito e usare questa pipeline per osservarne i risultati forniti.
</p>

</body>
</section>
<section>
<title>Cominciare l'avventura dell'elaborazione del testo</title>
<body>

<p>
Adesso sarà dato il via ad una gita fra i comandi di base per l'elaborazione del
testo. Poiché verrà coperto molto materiale in questa breve guida, non rimane lo
spazio per fornire esempi per ogni comando. Piuttosto, il lettore è incoraggiato
a leggere la pagina di manuale di ogni comando (digitando <c>man echo</c>, per
esempio) e apprendere come ogni comando lavora anche in congiunzione con le
proprie opzioni, spendendo un po' di tempo nel fare tentativi con ognuno di
essi. Come regola, questi comandi stampano il risultato di ogni operazione di
elaborazione del testo sul terminale piuttosto che modificare uno specifico
file. Dopo aver raggiunto la fine del nostro giro panoramico fra i comandi di
base in Linux per l'elaborazione del testo, verrà data un'occhiata più da vicino
alla ridirezione dei dati in ingresso e uscita. Quindi non ci si preoccupi, c'è
luce alla fine del tunnel.
</p>

<p>
<c>echo</c> stampa il proprio argomento sul terminale. Usare l'opzione <c>-e</c>
se si desidera inserire sequenze di caratteri speciali nell'argomento; per
esempio <c>echo -e "foo\nfoo"</c> stamperà foo, quindi un carattere di nuova
linea e poi ancora foo. Usare l'opzione <c>-n</c> per indicare ad echo di
omettere il carattere di nuova linea al termine che viene aggiunto ai dati in
uscita in modo predefinito.
</p>

<p>
<c>cat</c> stamperà i contenuti dei file specificati come argomenti sul
terminale. Pratico come primo comando di una pipeline, per esempio, <c>cat
foo.txt | blah</c>.
</p>

<p>
<c>sort</c> stamperà i contenuti di un file specificato sulla riga di comando in
ordine alfabetico. Ovviamente, <c>sort</c> accetta anche dati in ingresso
provenienti di pipe. Digitare <c>man sort</c> per familiarizzare con le sue
varie opzioni che controllano il comportamento durante l'ordinamento.
</p>

<p>
<c>uniq</c> prende un file o un flusso dati (attraverso una pipe) <e>già
ordinato</e> e rimuove le linee duplicate.
</p>

<p>
<c>wc</c> stampa a video il numero di linee, parole e byte in uno specifico file
o nel flusso di dati in ingresso (da una pipeline). Digitare <c>man wc</c> per
imparare come mettere a punto quali conteggi sono mostrati.
</p>

<p>
<c>head</c> stampa a video le prime dieci linee di un file o flusso dati. Usare
l'opzione <c>-n</c> per specificare quante linee dovrebbero essere visualizzate.
</p>

<p>
<c>tail</c> stampa a video le ultime dieci linee di un file o flusso dati. Usare
l'opzione <c>-n</c> per specificare quante linee dovrebbero essere mostrate.
</p>

<p>
<c>tac</c> è simile a <c>cat</c>, ma stampa a video tutte le linee in ordine
inverso; in altre parole, l'ultima linea è mostrata per prima.
</p>

<p>
<c>expand</c> converte i valori di tab ("\t") in ingresso in spazi. Usare
l'opzione <c>-t</c> per specificare il numero a cui fermarsi.
</p>

<p>
<c>unexpand</c> converte gli spazi in ingresso in valori di tab. Usare l'opzione
<c>-t</c> per specificare il numero a cui fermarsi.
</p>

<p>
<c>cut</c> è usato per estrarre campi delimitati da caratteri da ogni linea di
un file o flusso dati in ingresso.
</p>

<p>
Il comando <c>nl</c> aggiunge un numero di riga ad ogni linea in ingresso. Utile
per la stampa a video.
</p>

<p>
<c>pr</c> è usato per dividere i file in pagine multiple in uscita; tipicamente
viene usato per la stampa.
</p>

<p>
<c>tr</c> è uno strumento di traduzione di caratteri; è usato per mappare certi
caratteri nel flusso in ingresso su determinati caratteri nel flusso di uscita.
</p>

<p>
<c>sed</c> è un potente editor di testo orientato ai flussi. È possibile
imparare molto di più su sed negli articoli seguenti su developerWorks di IBM:
</p>

<ul>
  <li><uri link="/doc/it/articles/l-sed1.xml">Sed per esempi, Parte 1</uri></li>
  <li><uri link="/doc/it/articles/l-sed2.xml">Sed per esempi, Parte 2</uri></li>
  <li><uri link="/doc/it/articles/l-sed3.xml">Sed per esempi, Parte 3</uri></li>
</ul>

<p>
Se si sta progettando di sostenere gli esami del LPI, assicurarsi di leggere i
primi due articoli di questa serie.
</p>

<p>
<c>awk</c> è un utile linguaggio per l'elaborazione del testo orientato alle
linee. Per imparare di più su awk, leggere i seguenti articoli da developerWorks
di IBM:
</p>

<ul>
  <li><uri link="/doc/it/articles/l-awk1.xml">Awk per esempi, Parte 1</uri></li>
  <li><uri link="/doc/it/articles/l-awk2.xml">Awk per esempi, Parte 2</uri></li>
  <li><uri link="/doc/it/articles/l-awk3.xml">Awk per esempi, Parte 3</uri>
  </li>
</ul>

<p>
<c>od</c> è progettato per trasformare il flusso in ingresso in un formato
"dump" ottale o esadecimale.
</p>

<p>
<c>split</c> è un comando usato per dividere un grosso file in molti di
dimensioni minori, così da avere porzioni più maneggiabili.
</p>

<p>
<c>fmt</c> riformatterà i paragrafi così da ristabilire le misure sui margini.
In questo periodo è meno utile data che questa caratteristica è già presente
all'interno di molti editor di testo ma è ancora una buona cosa da conoscere.
</p>

<p>
<c>paste</c> prende due o più file come ingresso, concatena ogni linea
in sequenza presa dai file di ingresso e rende in uscita le linee risultanti.
Può essere utile per creare tabelle o colonne di testo.
</p>

<p>
<c>join</c> è simile a paste ma usa un campo (di base, il primo) in ogni linea
di ingresso per riscontrare cosa dovrebbe essere combinato su una singola linea.
</p>

<p>
<c>tee</c> stampa il proprio ingresso sia su un file che a video. È utile quando
si voglia creare un log (traccia) di qualcosa ma lo si voglia anche poter vedere
a schermo.
</p>

</body>
</section>
<section>
<title>Senza sosta, la ridirezione</title>
<body>

<p>
In modo simile all'uso di <c>&gt;</c> da riga di comando in bash, è possibile
sfruttare <c>&lt;</c> per ridirezionare un file verso un comando. Per molti
comandi, l'utente può semplicemente specificare il nome del file da riga di
comando, in ogni caso altri lavorano solo sullo standard input.
</p>

<p>
Bash e altre shell supportano il concetto di "herefile" (letteralmente, "file in
questa posizione"). Questo permette di indicare l'input per un dato comando
sulla riga di seguito all'invocazione del comando stesso, terminando con un
valore di sentinella. Tutto ciò è mostrato in modo semplice attraverso un
esempio:
</p>

<pre caption="Redirezione in azione">
$ <i>sort &lt;&lt;END</i>
mela
mirtillo
banana
END
mela
banana
mirtillo
</pre>

<p>
Nell'esempio sopra, vengono digitate le parole mela, mirtillo e banana, seguite
da "END" per indicare la fine dei dati in ingresso. Il programma <c>sort</c>
quindi restituisce le nostre parole in ordine alfabetico.
</p>

</body>
</section>
<section>
<title>Usare &gt;&gt;</title>
<body>

<p>
Ci si potrebbe aspettare che l'espressione <c>&gt;&gt;</c> faccia qualcosa di
analogo a <c>&lt;&lt;</c>, ma non è così. Semplicemente comporta l'aggiunta dei
dati in uscita ad un file, piuttosto che sovrascrivere come farebbe <c>&gt;</c>
Per esempio:
</p>

<pre caption="Redirezionare verso un file">
$ <i>echo Ciao &gt; mio_file</i>
$ <i>echo a voi. &gt; mio_file</i>
$ <i>cat mio_file</i>
a voi.
</pre>

<p>
Imprevisto. È stata persa la porzione "Ciao". Quello che si voleva fare è
questo:
</p>

<pre caption="Aggiungere ad un file">
$ <i>echo Ciao &gt; mio_file</i>
$ <i>echo a voi. &gt;&gt; mio_file</i>
$ <i>cat mio_file</i>
Ciao
a voi.
</pre>

<p>
Molto meglio.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Moduli del Kernel</title>
<section>
<title>Conoscere "uname"</title>
<body>

<p>
Il comando <c>uname</c> fornisce una varietà di interessanti informazioni
riguardo il proprio sistema. Si riporta ciò che viene mostrato sul sistema di
sviluppo dell'Autore quando viene digitato <c>uname -a</c>, che richiede al
comando <c>uname</c> di stampare tutte le proprie informazioni di seguito:
</p>

<pre caption="uname -a">
$ <i>uname -a</i>
Linux inventor 2.4.20-gaming-r1 #1 Fri Apr 11 18:33:35 MDT 2003 i686 AMD Athlon(tm) XP 2100+ AuthenticAMD GNU/Linux
</pre>

</body>
</section>
<section>
<title>Altre follie con uname</title>
<body>

<p>
Adesso, bisogna dare un'occhiata alle informazioni che <c>uname</c> fornisce:
</p>

<pre caption="Informazioni fornite da uname">
info. option                    arg     example
kernel name                     -s      "Linux"
hostname                        -n      "inventor"
kernel release                  -r      "2.4.20-gaming-r1"
kernel version                  -v      "#1 Fri Apr 11 18:33:35 MDT 2003"
machine                         -m      "i686"
processor                       -p      "AMD Athlon(tm) XP 2100+"
hardware platform               -i      "AuthenticAMD"
operating system                -o      "GNU/Linux"
</pre>

<p>
Interessante. E cosa stampa invece il comando <c>uname -a</c> del lettore?
</p>

</body>
</section>
<section>
<title>La release (rilascio) del kernel</title>
<body>

<p>
Ecco un trucco magico. Primo, digitare <c>uname -r</c> per fare in modo che il
comando uname stampi la release del kernel Linux attualmente in esecuzione.
</p>

<p>
Adesso, bisogna dare un'occhiata alla cartella <path>/lib/modules</path> e
--velocemente-- si potrebbe scommettere sul fatto che è stata trovata una
cartella con lo stesso nome preciso. Certo, non è cosa così magica ma questo
potrebbe essere un buon momento per discutere riguardo al significato delle
cartelle in <path>/lib/modules</path> e spiegare cosa sono i moduli del kernel.
</p>

</body>
</section>
<section>
<title>Il kernel</title>
<body>

<p>
Il kernel Linux è il cuore di ciò che viene comunemente indicato come "Linux" --
questo è il pezzo di codice che accede al proprio hardware direttamente e
fornisce astrazioni in modo che vecchi programmi regolari possano essere
eseguiti. Grazie al kernel, il proprio editor di testi non necessita di
preoccuparsi quando sta scrivendo su un disco SCSI o IDE -- o perfino su un
disco in RAM. Scrive semplicemente su un filesystem e il kernel si prende cura
del resto.
</p>

</body>
</section>
<section>
<title>Introduzione ai moduli del kernel</title>
<body>

<p>
Quindi, cosa sono i moduli del kernel? Bene, sono parti del kernel che sono
state immagazzinate in uno speciale formato su disco. In base ai comandi
dell'utente, possono essere caricati nel kernel in esecuzione per mettere a
disposizione funzionalità aggiuntive.
</p>

<p>
Poichè i moduli del kernel sono caricati su richiesta, è possibile che il
proprio kernel supporti molte funzionalità aggiuntive che l'utente potrebbe non
volere abilitate di solito. Ma di tanto in tanto, questi moduli del kernel hanno
il vizio di diventare abbastanza utili a possono essere caricati -- spesso
automaticamente -- per supportare questi strani filesystem o dispositivi
hardware usati raramente.
</p>

</body>
</section>
<section>
<title>Moduli del Kernel in poche parole</title>
<body>

<p>
In breve, i moduli del kernel permettono al kernel in esecuzione di abilitare
potenzialità su base on-demand (a richiesta). Senza i moduli del kernel,
bisognerebbe compilare un nuovo kernel per intero e riavviare in modo da
permettergli di supportare qualcosa di nuovo.
</p>

</body>
</section>
<section>
<title>lsmod</title>
<body>

<p>
Per scoprire quali moduli sono caricati al momento sul proprio sistema, usare il
comando <c>lsmod</c>:
</p>

<pre caption="usare lsmod">
# <i>lsmod</i>
Module                  Size  Used by    Tainted: PF
vmnet                  20520   5
vmmon                  22484  11
nvidia               1547648  10
mousedev                3860   2
hid                    16772   0  (unused)
usbmouse                1848   0  (unused)
input                   3136   0  [mousedev hid usbmouse]
usb-ohci               15976   0  (unused)
ehci-hcd               13288   0  (unused)
emu10k1                64264   2
ac97_codec              9000   0  [emu10k1]
sound                  51508   0  [emu10k1]
usbcore                55168   1  [hid usbmouse usb-ohci ehci-hcd]
</pre>

</body>
</section>
<section>
<title>Elenco dei moduli</title>
<body>

<p>
Come si può notare, sul sistema dell'Autore ci sono ben pochi moduli caricati. I
moduli vmnet e vmmon mettono a disposizione funzionalità necessarie per il
programma <uri link="http://www.vmware.com/">VMWare</uri>, che permette di
eseguire un PC virtuale in una finestra sul desktop. Il modulo "nvidia" proviene
dall'ente <uri link="http://www.nvidia.com/">NVIDIA</uri> e permette di usare la
scheda grafica accelerata 3D ad alte prestazioni sotto Linux pur godendo dei
vantaggi delle sue discrete caratteristiche.
</p>

<p>
Di seguito è presente un gruppo di moduli che sono usati per mettere a
disposizione il supporto per dispositivi d'ingresso basati su USB -- chiamati
"mousedev", "input", "usb-ohci", "ehci-hcd" e "usbcore". Ha spesso senso
configurare il proprio kernel così da fornire il supporto USB sotto forma di
modulo. Il perché è dato dal fatto che i dispositivi USB sono di tipo "plug and
play" (letteralmente, inserisci e usa) e quando l'utente ha il proprio supporto
USB come modulo può allora uscire di casa e comprare un nuovo dispositivo USB,
inserirlo nel proprio sistema e scoprire che il sistema automaticamente carica i
moduli appropriati per abilitare questo servizio. È una via comoda per fare le
cose.
</p>

</body>
</section>
<section>
<title>Moduli di terze parti</title>
<body>

<p>
Esplorando la lista dei moduli dell'Autore si notano "emu10k1", "ac97_codec", e
"sound" i quali tutti insieme forniscono il supporto per la scheda audio
SoundBlaster Audigy.
</p>

<p>
Il lettore attento avrà notato che molti dei moduli del kernel provengono dai
sorgenti del kernel stesso. Per esempio, tutti i moduli relativi a USB sono
compilati a partire dai sorgenti standard del Kernel Linux. Comunque, i moduli
relativi a nvidia, emu10k1 e VMWare provengono da altri sorgenti. Questo mette
in risalto un altro grande vantaggio dei moduli del kernel -- permettono a terze
parti di fornire funzionalità del kernel molto richieste e mettono a
disposizione queste funzionalità semplicemente tramite il "plug in"
(caricamento) all'interno di un kernel Linux in esecuzione. Nessun riavvio è
necessario.
</p>

</body>
</section>
<section>
<title>depmod e compagnia</title>
<body>

<p>
Nella cartella <path>/lib/modules/2.4.20-gaming-r1/</path> dell'Autore, sono
presenti un certo numero di file che cominciano con la stringa "modules.":
</p>

<pre caption="altri moduli">
$ <i>ls /lib/modules/2.4.20-gaming-r1/modules.*</i>
/lib/modules/2.4.20-gaming-r1/modules.dep
/lib/modules/2.4.20-gaming-r1/modules.generic_string
/lib/modules/2.4.20-gaming-r1/modules.ieee1394map
/lib/modules/2.4.20-gaming-r1/modules.isapnpmap
/lib/modules/2.4.20-gaming-r1/modules.parportmap
/lib/modules/2.4.20-gaming-r1/modules.pcimap
/lib/modules/2.4.20-gaming-r1/modules.pnpbiosmap
/lib/modules/2.4.20-gaming-r1/modules.usbmap
</pre>

<p>
Questi file contengono diverse informazioni sulle dipendenze. Per esempio,
registrano informazioni sulle *dipendenze* per i moduli -- alcuni moduli
richiedono che altri moduli vengano caricati prima di essere eseguiti. Questa
informazioni è memorizzata in questi file.
</p>

</body>
</section>
<section>
<title>Come prendere i moduli</title>
<body>

<p>
Molti moduli del kernel sono progettati per lavorare con dispositivi hardware
specifici, come il modulo "emu10k1" che è relativo alla scheda SounBlaster
Audigy. Per questo tipo di moduli, questi file riportano anche gli ID PCI e
marcatori di identificazione simili per i dispositivi hardware che supportano.
Questa informazione può essere usata da strumenti come gli script di "hotplug"
(che verranno discussi in una breve guida in seguito) per auto-rilevare
l'hardware e caricare il modulo appropriato per supportare il detto hardware
automaticamente.
</p>

</body>
</section>
<section>
<title>Usare depmod</title>
<body>

<p>
Se non si installa mai un nuovo modulo, queste informazioni sulle dipendenze
potrebbero diventare obsolete. Per aggiornarle, semplicemente digitare
<c>depmode -a</c>. Il programma <c>depmod</c> effettuerà una scansione di tutti
i moduli nelle proprie cartelle presenti in <path>/lib/modules</path>
aggiornando le informazioni sulle dipendenze. Questo è possibile effettuando una
scansione dei file di modulo in <path>/lib/modules</path> e cercando all'interno
dei moduli ciò che viene chiamato "symbols".
</p>

</body>
</section>
<section>
<title>Individuare i moduli del kernel</title>
<body>

<p>
Quindi, vediamo a cosa assomigliano i moduli del kernel. Per i kernel 2.4, sono
di solito ogni file che termina con ".o" presente nell'albero
<path>/lib/modules</path>>. Per vedere tutti i moduli in
<path>/lib/modules</path>, digitare quanto segue:
</p>

<pre caption="moduli del kernel in /lib/modules">
# <i>find /lib/modules -name '*.o'</i>
/lib/modules/2.4.20-gaming-r1/misc/vmmon.o
/lib/modules/2.4.20-gaming-r1/misc/vmnet.o
/lib/modules/2.4.20-gaming-r1/video/nvidia.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/vfat/vfat.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/minix/minix.o
[elenco "troncato" per brevità]
</pre>

</body>
</section>
<section>
<title>insmod contro modprobe</title>
<body>

<p>
Ora, vediamo come chiunque può caricare un modulo all'interno di un kernel in
esecuzione. Un modo è usare il comando <c>insmod</c> e specificare il percorso
completo del modulo che si desidera caricare:
</p>

<pre caption="usare insmod">
# <i>insmod /lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o</i>
# <i>lsmod | grep fat</i>
fat                    29272   0  (unused)
</pre>

<p>
Comunque, chiunque normalmente carica moduli usando il comando <c>modprobe</c>.
Una delle cose buone del comando <c>modprobe</c> è che questo automaticamente si
preoccupa di caricare ogni modulo di dipendenza. Inoltre, non c'è bisogno di
specificare il percorso per il modulo che si desidera caricare e neanche
indicare il ".o" finale.
</p>

</body>
</section>
<section>
<title>rmmod e modprobe in azione</title>
<body>

<p>
Adesso provare a rimuovere il proprio modulo "fat.o" e caricarlo usando
<c>modprobe</c>:
</p>

<pre caption="rmmod e modprobe in azione">
# <i>rmmod fat</i>
# <i>lsmod | grep fat</i>
# <i>modprobe fat</i>
# <i>lsmod | grep fat</i>
fat                    29272   0  (unused)
</pre>

<p>
Come si può vedere, il comando <c>rmmod</c> opera in modo simile a modprobe, ma
ha l'effetto opposto -- rimuove il modulo specificato.
</p>

</body>
</section>
<section>
<title>Farsi amici modinfo e modules.conf</title>
<body>

<p>
È possibile usare il comando <c>modinfo</c> per imparare cose interessanti sui
propri moduli preferiti:
</p>

<pre caption="Usare modinfo">
# <i>modinfo fat</i>
filename:    /lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o
description: &lt;none&gt;
author:      &lt;none&gt;
license:     "GPL"
</pre>

<p>
Aggiungiamo una nota speciale sul file <path>/etc/modules.conf</path>. Questo
file contiene informazioni di configurazione per <c>modprobe</c>. Permette
all'utente di mettere a punto le funzionalità di <c>modprobe</c> dicendogli di
caricare i moduli prima/dopo il caricamento di altri, eseguire script prima/dopo
il caricamento di moduli e via dicendo.
</p>

</body>
</section>
<section>
<title>Suggerimenti per modules.conf</title>
<body>

<p>
La sintassi e funzionalità di <path>modules.conf</path> è abbastanza complicata
e questa guida non scenderà ora nello specifico (digitare <c>man
modules.conf</c> per tutti i dettagli più sanguinosi), ma di seguito sono
riportate alcune cose che il lettore *dovrebbe* conoscere riguardo a questo
file.
</p>

<p>
Primo, molte distribuzioni generano questo file automaticamente da un gruppo di
file in un'altra cartella, come <path>/etc/modules.d/</path>. Per esempio,
Gentoo Linux ha una cartella <path>/etc/modules.d/</path> e lanciando il comando
<c>update-modules</c> recupererà ogni file in <path>/etc/modules.d/</path> e li
concatenerà per produrre un nuovo <path>/etc/modules.conf</path>. Quindi,
bisogna effettuare i proprio cambiamenti ai file in <path>/etc/modules.d/</path>
ed eseguire update-modules se si sta usando Gentoo. Se si sta usando Debian, la
procedura è simile eccetto che la cartella è chiamata
<path>/etc/modutils/</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Riassunto e Risorse</title>
<section>
<title>Riassunto</title>
<body>

<p>
Congratulazioni; è stata raggiunta la fine di questa breve guida sulle basi
dell'amministrazione in Linux. L'Autore spera di avere aiutato il lettore a
solidificare la propria conoscenza di base su Linux. Prega inoltre di
partecipare alla prossima breve guida che coprirà l'amministrazione intermedia,
dove verrà costruito sulle fondamenta disposte adesso, coprendo argomenti come i
permessi in Linux e il modello di proprietà, la gestione degli account utente,
la creazione di filesystem e il loro montaggio e così via. Si ricordi,
continuando in questa serie di brevi guide, a breve il lettore sarà pronto a
raggiungere la propria Certificazione LPIC di Livello 1 del Linux Professional
Institute.
</p>

</body>
</section>
<section>
<title>Risorse</title>
<body>

<p>
Parlando della Certificazione LPIC, se questo è ciò a cui il lettore è
interessato, si raccomanda di studiare le seguenti risorse, le quali sono state
attentamente selezionate per incrementare il materiale coperto in questa breve
guida:
</p>

<p>
Ci sono un numero di buone risorse sulle espressioni regolari in rete. Di
seguito alcune scovate dall'Autore:
</p>

<ul>
  <li>
    <uri link="http://www.zvon.org/other/reReference/Output/">Regular
    Expressions Reference (Guida di Riferimento alle Espressioni Regolari)</uri>
  </li>
  <li>
    <uri link="http://zez.org/article/articleview/11/">Regular Expressions
    Explained (Spiegazione delle Espressioni Regolari)</uri>
  </li>
</ul>

<p>
Assicurarsi di documentarsi su Filesystem Hierarchy Standard all'indirizzo
<uri>http://www.pathname.com/fhs/</uri>.
</p>

<p>
Nella <uri link="/doc/it/articles/bash-by-example-p1.xml">serie di articoli Bash
tramite esempi</uri>, l'autore mostra come usare i construtti di programmazione
bash per scrivere i propri script bash. Questa serie (in particolare parti uno e
due) saranno una buona preparazione per l'esame LPIC di Livello 1:
</p>

<p>
È possibile imparare di più su <c>sed</c> negli <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-sed1.html?dwzone=linux">
articoli rilevanti su developerWorks di IBM</uri>. Se si sta pianificando di
sostenere l'esame LPI, assicurarsi di leggere i primi due articoli di questa
serie.
</p>

<p>
Per imparare di più su <c>awk</c>, leggere gli <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-awk1.html?dwzone=linux">
articoli rilevanti su developerWorks di IBM</uri>.
</p>

<p>
È caldamente raccomandato il documento <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/index.html">
Technical FAQ for Linux users (FAQ tecniche per utenti Linux)</uri>, una lista
approfondita di 50 pagine su domande poste di frequente riguardo a Linux,
seguite da dettagliate risposte. Le FAQ stesse sono in formato PDF (Acrobat). Se
il lettore è un utente Linux principiante o intermedio, dovrebbe veramente
imporre a sè stesso di dare un'occhiata alle FAQ.
</p>

<p>
Se non si è molto familiari con l'editor <c>vi</c>, è fortemente raccomandato di
esaminare la guida scritta dall'Autore e intitolata <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">Vi -- the
cheat sheet method (Vi -- bignami)</uri>. Questa breve guida fornisce al lettore
una leggera ma veloce introduzione a questo potente editor di testi. Bisogna
considerare questo materiale come obbligatorio se non si sa come usare
<c>vi</c>.
</p>

</body>
</section>
</chapter>
</guide>