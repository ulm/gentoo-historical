<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/articles/lpi-101-intermediate-p3.xml,v 1.3 2012/02/26 08:33:40 swift Exp $ -->

<guide disclaimer="articles"
lang="it">
<title>Preparazione all'esame per la Certificazione LPI 101 (release 2), Parte
3</title>

<author title="Autore">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autore">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Autore">
  <mail link="agriffis@gentoo.org">Aron Griffis</mail>
</author>
<author title="Traduzione">
  <mail link="skypjack@gmail.com">Michele Caini</mail>
</author>

<abstract>
In questa breve guidata sarà data una introduzione alla documentazione di
sistema Linux. Verrà spiegato come cambiare permessi e come gestire gli account
in Linux. Alla fine il lettore avrà imparato come raffinare il proprio sistema.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This
document is an updated version of the original article, and contains
various improvements made by the Gentoo Linux Documentation team -->

<version>1.1</version>
<date>2007-06-20</date>

<chapter>
<title>Prima di cominciare</title>
<section>
<title>Riguardo a questa introduzione</title>
<body>

<p>
Benvenuti in "Amministrazione intermedia", la terza di quattro brevi guide
pensate per preparare il lettore all'esame 101 (release 2) del Linux
Professional Institute. Questa breve guida (Parte 3) è ideale per coloro che
vogliono migliorare la propria conoscenza nelle abilità fondamentali
dell'amministrazione in Linux. Verranno coperti diversi argomenti, inclusa la
documentazione di sistema e su Internet, il modello dei permessi in Linux, la
gestione degli account utente e il raffinamento dell'ambiente di login.
</p>

<p>
Per i nuovi arrivati nel mondo Linux, si raccomanda di cominciare con la <uri
link="/doc/it/articles/lpi-101-fundamentals-p1.xml">Parte 1</uri> e la <uri
link="/doc/it/articles/lpi-101-administration-p2.xml">Parte 2</uri>. Per alcuni,
molto di questo materiale risulterà nuovo, ma gli utenti Linux con più
esperienza potrebbero trovare questa breve guida un bel modo per affinare le
loro abilità di base nell'amministrazione in Linux.
</p>

<p>
Alla fine di questa breve serie di brevi guide (otto in tutto che coprono gli
esami 101 e 102 del LPI), il lettore avrà la conoscenza necessaria per diventare
Amministratore di Sistema Linux e sarà pronto per conseguire la certificazione
LPIC di Livello 1 del Linux Professional Institute se lo desidera.
</p>

<p>
Per coloro che fossero già in possesso della <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxlpi3-i.html">versione
di rilascio 1</uri> di questa breve guida per altre ragioni oltre alla
preparazione dell'esame del LPI, probabilmente non sarà necessario prendere
anche questa. Comunque, se si pianifica di sostenere gli esami, dovrebbe essere
decisamente presa in considerazione la lettura di questa versione revisionata
della guida.
</p>

</body>
</section>
<section>
<title>Riguardo agli autori</title>
<body>

<p>
Per questioni tecniche riguardo ai contenuti di questa breve guida, contattare
gli autori:
</p>

<ul>
  <li>Daniel Robbins, a <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, a <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, a <mail>agriffis@gentoo.org</mail>.</li>
</ul>

<p>
Residente in Albuquerque, New Mexico, Daniel Robbins è l'Architetto Capo di
Gentoo Linux, un'avanzata meta distribuzione Linux basata su sorgenti. Ha anche
scritto articoli, brevi guide e suggerimenti nell'area dedicata a Linux dell'IBM
developerWorks e per l'Intel Developer Services e ha anche preso parte come
autore di contributi per diversi libri, incluso Samba Unleashed e SuSE Linux
Unleashed. Daniel si diverte passando il proprio tempo con sua moglie, Mary, e
sua figlia, Hadassah. È possibile contattare Daniel all'indirizzo
<mail>drobbins@gentoo.org</mail>.
</p>

<p>
Chris Houser, conosciuto dagli amici come "Chouser", è diventato un sostenitore
di UNIX fin dal 1994 quando ha preso parte al gruppo di amministrazione delle
reti scientifiche di calcolatori alla Taylor University nell'Indiana, dove ha
conseguito la sua laurea in Scienze Informatiche e Matematiche. Fino da allora,
ha continuato a lavorare nella programmazione di applicazioni Web, sviluppo di
interfacce utente, supporto professionale al software video e ora alla
programmazione di driver per dispositivi Tru64 UNIX alla <uri
link="http://www.compaq.com/">Compaq</uri>. Ha anche contribuito a diversi
progetti di software libero, più recentemente a <uri
link="http://www.gentoo.org/">Gentoo Linux</uri>. Vive con sua moglie e due
gatti in New Hampshire. È possibile contattare Chris a
<mail>chouser@gentoo.org</mail>.
</p>

<p>
Aron Griffis è diplomato alla Taylor University con una laurea in Scienze
Informatiche e un premio che dichiara, "Futuro Fondatore di un utopistico gruppo
UNIX". Lavorando verso questo obiettivo, Aron è impiegato presso <uri
link="http://www.compaq.com/">Compaq</uri> scrivendo driver di rete per
Tru64 UNIX e spende il suo tempo libero accordando il piano o sviluppando <uri
link="http://www.gentoo.org/">Gentoo Linux</uri>. Vive con sua moglie Amy (anche
lei ingegnere UNIX) in Nashua, New Hampshire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Documentazione di sistema e in rete</title>
<section>
<title>Tipi di documentazione su sistemi Linux</title>
<body>

<p>
Esistono essenzialmente tre fonti di documentazione su sistemi Linux: pagine di
manuale, pagine info e documentazione legata alle applicazioni in
<path>/usr/share/doc</path>. In questa sezione, sarà esplorata ognuna di queste
fonti prima di guardare "fuori dalla porta di casa" per maggiori informazioni.
</p>

</body>
</section>
<section>
<title>Pagine di manuale (manual page)</title>
<body>

<p>
Le pagine di manuale, o "man pages", sono la forma classica per la
documentazione di riferimento su UNIX e Linux. Idealmente, è possibile guardare
la pagina di manuale per ogni comando, file di configurazione o routine di
libreria. In pratica, Linux è software libero e alcune pagine non sono state
scritte o mostrano la propria età. Tuttavia, le pagine di manuale sono il primo
posto in cui guardare quando si ha bisogno di aiuto.
</p>

<p>
Per accedere ad una man page, semplicemente digitare <c>man</c> seguito dal
proprio argomento o ricerca. Un paginatore sarà avviato, quindi ci sarà bisogno
di premere <c>q</c> quando si è finito di leggere. Per esempio, per vedere le
informazioni sul comando <c>ls</c>, si dovrà digitare:
</p>

<pre caption="Cercare nelle pagine man">
$ <i>man ls</i>
</pre>

<p>
Conoscere la struttura delle pagine man può essere utile per saltare velocemente
alle informazioni di cui si necessità. In generale, si avranno le seguenti
sezioni in una <c>man</c> page:
</p>

<table>
<tr>
  <ti>NAME</ti>
  <ti>Nome e descrizione breve del comando</ti>
</tr>
<tr>
  <ti>SYNOPSIS</ti>
  <ti>Come usare il comando</ti>
</tr>
<tr>
  <ti>DESCRIPTION</ti>
  <ti>Discussione approfondita sulle funzionalità del comando</ti>
</tr>
<tr>
  <ti>EXAMPLES</ti>
  <ti>Suggerimenti su come usare il comando</ti>
</tr>
<tr>
  <ti>SEE ALSO</ti>
  <ti>Argomenti correlati (di solito altre man page)</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Sezioni delle pagine man</title>
<body>

<p>
I file che comprendono le pagine di manuale sono memorizzati in
<path>/usr/share/man</path> (o in <path>/usr/man</path> su alcuni vecchi
sistemi). Dentro questa cartella si può scoprire che le pagine di manuale sono
organizzate nelle seguenti sezioni:
</p>

<table>
<tr>
  <ti>man1</ti>
  <ti>Programmi utente</ti>
</tr>
<tr>
  <ti>man2</ti>
  <ti>System call (Chiamate di sistema)</ti>
</tr>
<tr>
  <ti>man3</ti>
  <ti>Funzioni di libreria</ti>
</tr>
<tr>
  <ti>man4</ti>
  <ti>File speciali</ti>
</tr>
<tr>
  <ti>man5</ti>
  <ti>Formato dei file</ti>
</tr>
<tr>
  <ti>man6</ti>
  <ti>Giochi</ti>
</tr>
<tr>
  <ti>man7</ti>
  <ti>Varie</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Man Page multiple</title>
<body>

<p>
Alcuni argomenti esistono in più di una sezione. Per dimostrarlo, basta usare il
comando <c>whatis</c>, il quale mostra tutte le man page disponibili per un dato
tema:
</p>

<pre caption="Usare il comando whatis">
$ <i>whatis printf</i>
printf               (1)  - format and print data
printf               (3)  - formatted output conversion
</pre>

<p>
In questo caso, <c>man printf</c> sarebbe quello predefinito per la pagina nella
sezione 1 ("Programmi utente"). Se l'utente sta scrivendo un programma in C,
potrebbe essere però più interessato alla pagina nella sezione 3 ("Funzioni di
libreria"). È possibile richiamare una pagina di manuale da una certa sezione
specificandola sulla riga di comando, quindi per richiedere <e>printf(3)</e>
dovrà essere digitato:
</p>

<pre caption="Specificare la sezione nel comando man">
$ <i>man 3 printf</i>
</pre>

</body>
</section>
<section>
<title>Trovare la pagina man corretta</title>
<body>

<p>
Talvolta è difficile trovare la giusta pagina man per uno specifico argomento.
In questo caso, è possibile provare ad usare <c>man -k</c> per cercare il NAME
(nome) della sezione nelle pagine di manuale. Bisogna fare attenzione perché è
una ricerca per sotto-stringa, quindi eseguendo qualcosa del tipo <c>man -k
ls</c> saranno restituiti un bel po' di risultati.Di seguito un esempio dell'uso
di una interrogazione un po' più precisa:
</p>

<pre caption="Cercare con man usando il comando man -k">
$ <i>man -k whatis</i>
apropos              (1)  - search the whatis database for strings
makewhatis           (8)  - Create the whatis database
whatis               (1)  - search the whatis database for complete words
</pre>

</body>
</section>
<section>
<title>Tutto riguardo apropos</title>
<body>

<p>
L'esempio nella sezione precedente introduce alcuni altri punti. Primo, il
comando <c>apropos</c> è esattamente equivalente a <c>man -k</c>. (Infatti, è
stato taciuto un piccolo segreto. Quando viene eseguito <c>man -k</c>, in
effetti viene lanciato <c>apropos</c> dietro le quinte). Il secondo punto è il
comando <c>makewhatis</c>, il quale scansiona tutte le pagine man sul proprio
sistema Linux e costruisce la base dati per <c>whatis</c> e <c>apropos</c>. Di
solito viene lanciato periodicamente da root per mantenere aggiornata la base
dati:
</p>

<pre caption="Costruire la base dati per whatis apropos">
# <i>makewhatis</i>
</pre>

<p>
Per maggiori informazioni su "man" e compagnia, bisognerebbe cominciare da
questa pagine di manuale:
</p>

<pre caption="Iniziare con la pagina man di man">
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>Il MANPATH</title>
<body>

<p>
Di base, il programma <c>man</c> cercherà le pagine man in
<path>/usr/share/man</path>, <path>/usr/local/man</path>,
<path>/usr/X11R6/man</path> e forse <path>/opt/man</path>. Qualche volta,
potrebbe risultare di dover aggiungere un elemento aggiuntivo a questo percorso
di ricerca. Se così fosse, basta semplicemente modificare
<path>/etc/man.conf</path> con un editor di testi e aggiungere una linea che
assomiglia alla seguente:
</p>

<pre caption="/etc/man.conf">
MANPATH /opt/man
</pre>

<p>
Da questo momento in poi, ogni pagina man presente nella cartella
<path>/opt/man/man*</path> sarà rilevata. Ricordarsi che c'è bisogno di eseguire
nuovamente <c>makewhatis</c> per aggiungere queste nuove pagine di manuale alla
base dati di whatis.
</p>

</body>
</section>
<section>
<title>GNU info</title>
<body>

<p>
Un difetto delle man page è che non supportano l'ipertesto, quindi non è
possibile saltare facilmente da una all'altra. Il popolo GNU ha riconosciuto
questo difetto, quindi è stato inventato un altro formato per la documentazione:
le pagine "info". Molti dei programmi GNU sono forniti insieme ad un'ampia
documentazione nella forma di pagine info. È possibile iniziare a leggere le
pagine info con il comando <c>info</c>:
</p>

<pre caption="Usare il comando info">
$ <i>info</i>
</pre>

<p>
Chiamando <c>info</c> in questo modo sarà caricato un indice delle pagine
disponibili sul sistema. L'utente può muoversi all'interno con i tasti freccia,
seguire collegamenti (indicati con un asterisco) usando il tasto Enter (Invio) e
uscire premendo <c>q</c>. I tasti sono basati su Emacs, quindi si dovrebbe
essere capaci di navigare facilmente se familiari con questo editor. Per una
introduzione all'editor Emacs, fare riferimento alla breve guida presente su
developerWorks <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">Living
in Emacs (Vivere in Emacs)</uri>.
</p>

<p>
È possibile anche indicare una pagina info da riga di comando:
</p>

<pre caption="Comando info specifico">
$ <i>info diff</i>
</pre>

<p>
Per maggiori informazioni sull'uso del lettore <c>info</c>, provare a leggere
la pagina info relativa. Si dovrebbe essere in grado di mettere in pratica una
navigazione basilare usando i pochi tasti già citati:
</p>

<pre caption="Leggere la pagina info di info">
$ <i>info info</i>
</pre>

</body>
</section>
<section>
<title>/usr/share/doc</title>
<body>

<p>
C'è un'ultima fonte di aiuto all'interno del proprio sistema Linux. Molti
programmi sono forniti con della documentazione aggiuntiva in altri formati:
testo, PDF, PostScript o HTML, per fare qualche nome. Basta dare un'occhiata in
<path>/usr/share/doc</path> (o <path>/usr/doc</path> in sistemi datati). È
presente una lunga lista di cartelle, ognuna delle quali è relativa ad una
determinata applicazione sul proprio sistema. Cercando attraverso questa
documentazione si possono scovare alcune perle che non sono disponibili come
pagine man o info, come ad esempio brevi guide o documentazione tecnica
aggiuntiva. Un controllo veloce rivela che c'è molto materiale disponibile per
la lettura:
</p>

<pre caption="/usr/share/doc/">
$ <i>cd /usr/share/doc</i>
$ <i>find . -type f | wc -l</i>
7582
</pre>

<p>
Niente male. Il compito del lettore per stasera è quello di leggere appena metà
(3791) di questi documenti. Lo aspetta un quiz domani.
</p>

</body>
</section>
<section>
<title>Il Linux Documentation Project (LDP, o Progetto Documentazione
Linux)</title>
<body>

<p>
Oltre alla documentazione di sistema, esistono un buon numero di eccellenti
risorse per Linux sulla rete. Il <uri link="http://www.tldp.org/">Linux
Documentation Project</uri>  è un gruppo di volontari che stanno lavorando nel
mettere insieme un insieme completo di documentazione libera per Linux. Questo
progetto esiste per accentrare i vari pezzi di documentazione su Linux in una
posizione che sia facile da esplorare e usare.
</p>

</body>
</section>
<section>
<title>Uno sguardo al LDP</title>
<body>

<p>
Il LDP è composto dalle seguenti aree:
</p>

<ul>
  <li>
    Guide - libri approfonditi e dettagliati, come ad esempio <uri
    link="http://www.tldp.org/LDP/lpg/index.html">The Linux Programmer's
    Guide (La Guida del Programmatore Linux)</uri>
  </li>
  <li>
    HOWTO - aiuti per argomenti specifici, come ad esempio il <uri
    link="http://www.tldp.org/HOWTO/DSL-HOWTO/index.html">DSL HOWTO</uri>
  </li>
  <li>
    FAQ - Frequently Asked Questions (Domande Frequenti) con risposte, come ad
    esempio <uri link="http://www.tldp.org/FAQ/faqs/BLFAQ">Brief Linux FAQ
    (Brevi FAQ su Linux)</uri>
  </li>
  <li>
    Pagine man - aiuti su comandi individuali (queste sono le stesse pagine di
    manuale rintracciabili sul proprio sistema Linux quando viene usato il
    comando <c>man</c>).
  </li>
</ul>

<p>
Per chi avesse dubbi in quale sezione curiosare, si può trarre vantaggio
dall'uso dell'area di ricerca, che permette all'utente di trovare cose per
argomento.
</p>

<p>
Il LDP fornisce inoltre una lista di collegamenti e risorse (Links and
Resources) come ad esempio <uri link="http://www.tldp.org/LDP/LG/current/">Linux
Gazette</uri> (si faccia riferimento ai collegamenti in <uri
link="#resources">Risorse</uri>) e <uri
link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>, così come
collegamenti a mailing list e archivi di news (novità).
</p>

</body>
</section>
<section>
<title>Mailing list</title>
<body>

<p>
Le mailing list forniscono forse il più importante punto di collaborazione per
gli sviluppatori Linux. Spesso i progetti sono sviluppati da partecipanti che
vivono lontani fra loro, possibilmente di solito su lati opposti del globo. Le
mailing list mettono a disposizione un metodo ad ogni sviluppatore di un
progetto per contattare tutti gli altri e intrattenere discussioni di gruppo via
e-mail. Una delle più famose mailing list di sviluppo è la <uri
link="http://www.tux.org/lkml/">Mailing List del Kernel linux</uri>.
</p>

</body>
</section>
<section>
<title>Ancora sulle mailing lists</title>
<body>

<p>
In aggiunta allo sviluppo, le mailing list possono fornire un metodo per porre
domande e avere risposte da parte di sviluppatori ben informati o anche altri
utenti. Per esempio, distribuzioni indipendenti spesso hanno mailing list per i
nuovi arrivati. È possibile controllare il sito web della propria distribuzione
per informazioni sulle mailing list a disposizione.
</p>

<p>
Se si spende un po' di tempo per leggere le LKML FAQ (Linux Kernel Mailing List
FAQ) sul collegamento sopra citato, sarà possibile notare che gli iscritti alla
mailing list spesso non rispondono cortesemente a domande già fatte e rifatte. È
sempre saggio cercare negli archivi di una data mailing list prima di scrivere
la propria domanda. Le possibilità ci sono e potrebbe salvare anche un po' del
proprio tempo!
</p>

</body>
</section>
<section>
<title>Newsgroup</title>
<body>

<p>
I "newsgroup" di Internet sono simili alle mailing list ma basati su un
protocollo chiamato NNTP ("Network News Transfer Protocol") piuttosto che su
e-mail. Per partecipare, è necessario usare un client NNTP come <c>slrn</c> o
<c>pan</c>. Il primo vantaggio è che si può prendere parte alle discussioni solo
quando lo si desidera, invece di vedere arrivare messaggi continuamente nella
propria casella di posta.
</p>

<p>
I newsgroup di interesse primario iniziano con comp.os.linux. È possibile
navigare la <uri link="http://www.tldp.org/links/#ng">lista sul sito di
LDP</uri>.
</p>

<p>
Come con le mailing list, le discussioni di un newsgroup sono spesso archiviate.
Un sito di archiviazione per newsgroup popolare è <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

</body>
</section>
<section>
<title>Siti web di produttori e terze parti</title>
<body>

<p>
I siti web delle varie distribuzioni Linux spesso forniscono documentazione
aggiornata, istruzioni di installazione, dritte su
compatibilità/incompatibilità hardware e altro supporto come uno strumento per
la ricerca delle conoscenze di base. Per esempio:
</p>

<ul>
  <li><uri link="http://www.redhat.com/">Redhat Linux</uri></li>
  <li><uri link="http://www.debian.org/">Debian Linux</uri></li>
  <li><uri link="http://www.gentoo.org/">Gentoo Linux</uri></li>
  <li><uri link="http://www.suse.com/">SuSE Linux</uri></li>
  <li><uri link="http://www.caldera.com/">Caldera</uri></li>
  <li><uri link="http://www.turbolinux.com/">Turbolinux</uri></li>
</ul>

</body>
</section>
<section>
<title>Produttori hardware e software</title>
<body>

<p>
Molti produttori hardware e software hanno aggiunto il supporto a Linux ai loro
prodotti negli anni passati. Sui loro siti, si possono trovare informazioni
riguardo a quale hardware supporta Linux, strumenti di sviluppo software,
sorgenti rilasciati, download di driver Linux per hardware specifico e altri
progetti speciali per Linux. Per esempio:
</p>

<ul>
  <li><uri link="http://www.ibm.com/linux/">IBM e Linux</uri></li>
  <li>
    <uri link="http://www.compaq.com/products/software/linux/">Compaq e
    Linux</uri>
  </li>
  <li>
    <uri link="http://www.sgi.com/developers/technology/linux/">SGI e
    Linux</uri>
  </li>
  <li><uri link="http://www.hp.com/products1/linux/">HP e Linux</uri></li>
  <li><uri link="http://www.sun.com/linux/">Sun e Linux</uri></li>
  <li>
    <uri link="http://technet.oracle.com/tech/linux/content.html">Oracle e
    Linux</uri>.
  </li>
</ul>

</body>
</section>
<section>
<title>Risorse per gli sviluppatori</title>
<body>

<p>
In aggiunta, molti produttori hardware e software hanno rilasciato ottime
risorse per gli sviluppatori e amministratori Linux. A rischio di sembrare
votato alla causa, l'Autore sottolinea che una delle risorse di maggior valore
proposte da un produttore hardware/software è la <uri
link="http://www.ibm.com/developerworks/linux/">IBM developerWorks Linux
zone</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Il modello dei permessi in Linux</title>
<section>
<title>Un utente, un gruppo</title>
<body>

<p>
In questa sezione, verrà dato uno sguardo al modello dei permessi e proprietari
in Linux. È stato già detto che ogni file è posseduto da un utente e un gruppo.
Questo è il vero nocciolo del modello dei permessi in Linux. Si possono vedere
utente e gruppo di un file in un listato ottenuto con <c>ls -l</c>:
</p>

<pre caption="Listato dei file">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
In questo particolare esempio, l'eseguibile <path>/bin/bash</path> è posseduto
da root e legato al gruppo wheel. Il modello dei permessi in Linux lavora
permettendo l'impostazione di tre indipendenti livelli di permesso per ogni
oggetto del filesystem -- quello per il possessore del file, il gruppo del file
e tutti gli altri utenti.
</p>

</body>
</section>
<section>
<title>Capire "ls -l"</title>
<body>

<p>
Bisogna dare un'occhiata al proprio risultato di <c>ls -l</c> ed esaminare la
prima colonna del listato ottenuto:
</p>

<pre caption="Esaminare il comando ls -l">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
Questo primo campo <e>-rwxr-xr-x</e> contiene una rappresentazione simbolica di
questi particolari permessi per file. Il primo carattere (-) in questo campo
indica il tipo di file, che in questo caso è un file regolare. Altri possibili
caratteri iniziali sono:
</p>

<pre caption="Caratteri iniziali">
'd' cartella (directory)
'l' collegamento simbolico
'c' dispositivo speciale a caratteri
'b' dispositivo speciale a blocchi
'p' fifo (o pipe)
's' socket
</pre>

</body>
</section>
<section>
<title>Tre triplette</title>
<body>

<pre caption="ls -l /bin/bash">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
Il resto del campo si compone di tre triplette di caratteri. La prima tripletta
rappresenta i permessi per il possessore del file, la seconda indica i permessi
per gli appartenenti al gruppo del file e la terza specifica i permessi per
tutti gli altri utenti:
</p>

<pre caption="Triplette nel comando ls -l">
"rwx"
"r-x"
"r-x"
</pre>

<p>
Sopra, la r significa che la lettura (ovvero l'accedere ai dati contenuti nel
file) è permessa, la w significa che la scrittura (ovvero la modifica del file,
così come la cancellazione) è permessa e la x significa che la "esecuzione"
(cioè lanciare il programma) è permessa. Mettendo insieme tutte queste
informazioni, è possibile notare che tutti sono abilitati a leggere il contenuto
ed eseguire il file, ma solo il possessore (root) ha il diritto di modificare
questo file in qualche modo. Quindi, mentre i normali utenti possono copiare
questo file, solo root può aggiornarlo o cancellarlo.
</p>

</body>
</section>
<section>
<title>Chi sono io?</title>
<body>

<p>
Prima è stato spiegato come cambiare utente e gruppo nelle proprietà di un file,
adesso è necessario dire come scoprire l'attuale id utente e l'appartenenza ad
un gruppo. A meno che non sia stato usato il comando <c>su</c> di recente, l'id
utente attuale è quello usato per accedere al sistema. Se si usa <c>su</c>
frequentemente, comunque, potrebbe non essere possibile ricordare l'id utente
attuale effettivo. Per vederlo, digitare <c>whoami</c>:
</p>

<pre caption="Usare il comando whoami">
# <i>whoami</i>
root
# <i>su drobbins</i>
$ <i>whoami</i>
drobbins
</pre>

</body>
</section>
<section>
<title>A quali gruppi appartengo?</title>
<body>

<p>
Per sapere di quali gruppi il proprio utente fa parte, usare il comando
<c>groups</c>:
</p>

<pre caption="Usare il comando groups">
$ <i>groups</i>
drobbins wheel audio
</pre>

<p>
Nell'esempio precedente, l'utente risulta fare parte dei gruppi drobbins, wheel
e audio. Se si desidera sapere a quali gruppi appartiene un altro utente (o più
di uno), specificare il nome utente come argomento:
</p>

<pre caption="Specificare l'utente come argomento">
$ <i>groups root daemon</i>
root : root bin daemon sys adm disk wheel floppy dialout tape video
daemon : daemon bin adm
</pre>

</body>
</section>
<section>
<title>Cambiare le proprietà di utente e gruppo</title>
<body>

<p>
Per cambiare il possessore o il gruppo di un file o altri oggetti su filesystem,
usare <c>chown</c> o <c>chgrp</c>, rispettivamente. Ognuno di questi comandi
prende un nome seguito da uno o più nomi di file.
</p>

<pre caption="Usare i comandi chown e chgrp">
# <i>chown root /etc/passwd</i>
# <i>chgrp wheel /etc/passwd</i>
</pre>

<p>
È possibile anche impostare possessore e gruppo simultaneamente con una forma
alternativa del comando <c>chown</c>:
</p>

<pre caption="Impostare utente e gruppo simultaneamente">
# <i>chown root:wheel /etc/passwd</i>
</pre>

<p>
Non si può usare <c>chown</c> a meno di non essere il super utente, ma
<c>chgrp</c> può essere usato da chiunque per cambiare la proprietà sul gruppo
di un file in un gruppo a cui si appartiene.
</p>

</body>
</section>
<section>
<title>Modifiche di proprietà ricorsive</title>
<body>

<p>
Sia <c>chown</c> che <c>chgrp</c> hanno l'opzione -R che può essere usata per
indicare di applicare ricorsivamente le modifiche su possessore e gruppo ad un
intero albero di cartelle. Per esempio:
</p>

<pre caption="Usare chown e chgrp con l'opzione -R">
# <i>chown -R drobbins /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Introduzione a chmod</title>
<body>

<p>
<c>chown</c> e <c>chgrp</c> possono essere usati per cambiare possessore e
gruppo di un oggetto su filesystem, ma un altro programma -- chiamato
<c>chmod</c> -- è usato per cambiare i permessi rwx che si possono vedere dal
listato di <c>ls -l</c>. <c>chmod</c> prende due o più argomenti: un "modo", che
descrive come i permessi dovrebbero essere cambiati, seguito da un file o una
lista di file che dovrebbe essere influenzata:
</p>

<pre caption="Aggiungere il permesso x con chmod">
$ <i>chmod +x scriptfile.sh</i>
</pre>

<p>
Nell'esempio precedente, il "modo" è +x. Come è possibile indovinare, un modo +x
indica a <c>chmod</c> di rendere il particolare file eseguibile sia per l'utente
e gruppo che chiunque altro.
</p>

<p>
Se si desidera rimuovere tutti i permessi di esecuzione sul file, bisognerebbe
aire come segue:
</p>

<pre caption="Rimuovere i permessi x con chmod">
$ <i>chmod -x scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>Granularità utente/gruppo/altri</title>
<body>

<p>
Così facendo, gli esempi su <c>chmod</c> hanno influenzato i permessi per tutte
le tre triplette -- l'utente, il gruppo e tutti gli altri. Spesso, è utile
modificare solo una o due triplette alla volta. Per farlo, specificare
semplicemente il carattere simbolico per la particolare tripletta che si
desidera modificare prima del segno + o -. Usare u per la tripletta "utente", g
per il "gruppo" e o per "altri/chiunque":
</p>

<pre caption="Usare le triplette">
$ <i>chmod go-w scriptfile.sh</i>
</pre>

<p>
Così sono stati appena rimossi i permessi di scrittura per il gruppo e tutti gli
altri utenti, ma lasciati intatti i permessi del "possessore".
</p>

</body>
</section>
<section>
<title>Re-impostare i permessi</title>
<body>

<p>
Oltre a poter impostare i bit dei permessi su on e off (attivi o meno), è
possibile anche resettarli insieme. Usando l'operatore = , si può dire a
<c>chmod</c> che si desiderano gli specifici permessi e nessun altro:
</p>

<pre caption="Variare i bit dei permessi">
$ <i>chmod =rx scriptfile.sh</i>
</pre>

<p>
Sopra, sono solo stati impostati tutti i bit di "lettura" ed "esecuzione" e
tolti i permessi di "scrittura". Se si vuole solamente resettare una particolare
tripletta, si può specificare il nome simbolico per la tripletta prima del segno
=, come segue:
</p>

<pre caption="Reimpostare una tripletta">
$ <i>chmod u=rx scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>Modi numerici</title>
<body>

<p>
Fino ad'ora, sono stati usati quelli che vengono chiamati modi simbolici per
specificare i cambiamenti sui permessi a <c>chmod</c>. Comunque, esiste una
altro modo comune di specificare i permessi: usando un numero ottale a 4 valori.
Usando questa sintassi, chiamata sintassi dei permessi numerica, ogni cifra
rappresenta i permessi di una tripletta. Per esempio, in 1777, il 777 imposta i
flag per "possessore", "gruppo" e "altri" come discussi in questa sezione. Il
valore 1 è usato per impostare i bit di permesso speciali, che verranno discussi
in seguito (si veda "<uri
link="https://www6.software.ibm.com/developerworks/education/l-lpir23/l-lpir23-3-23.html">The
elusive first digit (L'elusiva prima cifra)</uri>" alla fine di questa sezione).
Questo grafico mostra come le cifre dalla seconda alla quarta sono interpretate:
</p>

<table>
<tr>
  <th>Modo</th>
  <th>Cifra</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Sintassi numerica per i permessi</title>
<body>

<p>
La sintassi numerica per i permessi è specialmente utile quando si necessita di
specificare tutti i permessi per un file, come nel seguente esempio:
</p>

<pre caption="Aggiungere permessi numerici">
$ <i>chmod 0755 scriptfile.sh</i>
$ <i>ls -l scriptfile.sh</i>
-rwxr-xr-x    1 drobbins drobbins        0 Jan  9 17:44 scriptfile.sh
</pre>

<p>
In questo esempio, è stato usato un modo di 0755, che si espande nell'insieme
completo di permessi come -rwxr-xr-x.
</p>

</body>
</section>
<section>
<title>Il valore umask</title>
<body>

<p>
Quando un processo crea un nuovo file, specifica i permessi che vorrebbe
attribuire a quest'ultimo. Spesso, il modo richiesto è 0666 (leggibile e
scrivibile da chiunque), che risulta più permissivo di quanto si potrebbe
volere. Fortunatamente, Linux consulta qualcosa chiamato "umask" ogni volta che
un nuovo file viene creato. Il sistema usa il valore umask per ridurre i
permessi specificati in origine in qualcosa di più ragionevole e sicuro. È
possibile vedere l'impostazione attuale per il proprio umask digitando umask da
riga di comando:
</p>

<pre caption="Vedere l'umask corrente">
$ <i>umask</i>
0022
</pre>

<p>
Su sistemi Linux, il valore umask è normalmente impostato a 0022, il che abilita
gli altri a leggere i propri file nuovi (se questi possono interagire con essi)
ma non a modificarli.
</p>

<p>
Per rendere i nuovi file più sicuri in modo predefinito, è possibile cambiare il
valore di umask:
</p>

<pre caption="Cambiare le impostazioni per umask">
$ <i>umask 0077</i>
</pre>

<p>
Questo umask assicurerà che il gruppo e gli altri non avranno assolutamente
alcun permesso per ogni nuovo file creato. Quindi, c'è da chiedersi come opera
umask. A differenza dei permessi "regolari" su file, il valore di umask indica
quali permessi dovrebbero essere tolti. Bisogna consultare la tabella dei modi
da digitare così che sia possibile capire cosa significa un umask di 0077:
</p>

<table>
<tr>
  <th>Modo</th>
  <th>Cifre</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

<p>
Usando la tabella proposta, le ultime tre cifre di 0077 sono espanse in
---rwxrwx. Ora, si deve ricordare che <c>umask</c> indica al sistema quali
permessi disabilitare. Facendo due più due, è possibile vedere che tutti i
permessi per il "gruppo" e gli "altri" saranno disabilitati, mentre i permessi
per l'"utente" rimarranno intatti.
</p>

</body>
</section>
<section>
<title>Introduzione a suid e sgid</title>
<body>

<p>
Quando inizialmente si effettua il login, un nuovo processo shell è avviato.
Questo è già stato detto, ma forse non è stato detto che questo nuovo processo
shell (tipicamente bash) esegue usando l'id utente di chi lo avvia. In quanto
tale, il programma bash può accedere a tutti i file e le cartelle possedute
dall'utente. In realtà, come utenti si è totalmente dipendenti da altri
programmi nell'effettuare operazioni per conto proprio. Poiché i programmi che
vengono avviati ereditano l'id utente di chi li lancia, questi non possono
accedere ad alcun oggetto su filesystem per cui il tale utente non possieda
diritti d'accesso.
</p>

<p>
Per esempio, il file passwd non può essere cambiato da utenti normali
direttamente, dato che il flag di "scrittura" è disattivato per ogni utente ad
eccezione di root:
</p>

<pre caption="ls -l /etc/passwd">
$ <i>ls -l /etc/passwd</i>
-rw-r--r--    1 root     wheel        1355 Nov  1 21:16 /etc/passwd
</pre>

<p>
Comunque, i normali utenti hanno bisogno di poter modificare /etc/passwd (almeno
indirettamente) ogni volta che necessitano di cambiare la loro password. Ma, se
l'utente non è abilitato a modificare questo file, c'è da capire come questo
opera esattamente.
</p>

</body>
</section>
<section>
<title>suid</title>
<body>

<p>
Fortunatamente, il modello dei permessi in Linux ha due bit speciali chiamati
<c>suid</c> e <c>sgid</c>. Quando un programma eseguibile ha il bit <c>suid</c>
impostato, si avvierà per conto del possessore dell'eseguibile, piuttosto che
per conto della persona che avvia il programma stesso.
</p>

<p>
Adesso, si può tornare al problema di <path>/etc/passwd</path>. Dando
un'occhiata all'eseguibile <c>passwd</c> è possibile notare che questo è
posseduto da root:
</p>

<pre caption="Controllare il possessore del file /usr/bin/passwd">
$ <i>ls -l /usr/bin/passwd</i>
-rwsr-xr-x    1 root     wheel       17588 Sep 24 00:53 /usr/bin/passwd
</pre>

<p>
Inoltre è possibile vedere che al posto di una x nella tripletta di permessi per
l'utente, c'è una s. Questo indica che, per questo particolare programma, i bit
<c>suid</c> ed eseguibile sono impostati. Da questo segue che, quando è avviato
<c>passwd</c>, esso eseguirà per conto dell'utente root (con pieno accesso da
superuser, o superutente) piuttosto che per l'utente che lo ha lanciato. E dato
che <c>passwd</c> esegue con accesso root, è abilitato a modificare il file
<path>/etc/passwd</path> senza problemi.
</p>

</body>
</section>
<section>
<title>Annotazioni su suid/sgid</title>
<body>

<p>
È stato illustrato come lavora <c>suid</c>, e <c>sgid</c> opera in modo simile.
Permette ai programmi di ereditare la proprietà di gruppo del programma
piuttosto che dell'utente attuale.
</p>

<impo>
Di seguito vengono date un po' di informazioni varie ma importanti riguardo a
<c>suid</c> e <c>sgid</c>. Primo, i bit di <c>suid</c> e <c>sgid</c> occupano lo
stesso posto dei bit x in un listato ls -l. Se anche il bit x è impostato, i
rispettivi bit saranno mostrati come s (lettera minuscola). Comunque, se il bit
x non è impostato, verrà mostrata una S (lettera maiuscola).
</impo>

<impo>
Un'altra nota importante: suid e sgid vengono in aiuto in molte situazioni ma un
uso improprio di questi bit può permettere di corrompere la sicurezza di un
sistema. È meglio avere meno programmi con bit suid attivo possibile. Il comando
passwd è uno dei pochi che deve avere abilitato tale bit.
</impo>

</body>
</section>
<section>
<title>Cambiare suid e sgid</title>
<body>

<p>
Come impostare e rimuovere i bit <c>suid</c> e <c>sgid</c> è abbastanza chiaro.
Di seguito, un esempio su come impostare il bit suid:
</p>

<pre caption="Impostare il bit suid">
# <i>chmod u+s /usr/bin/myapp</i>
</pre>

<p>
E adesso, un esempio su come rimuovere il bit <c>sgid</c> da una cartella. Sarà
evidenziato come il bit <c>sgid</c> influisce sulla cartella tra pochi pochi
paragrafi:
</p>

<pre caption="Rimuovere il bit sgid">
# <i>chmod g-s /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Permessi e cartelle</title>
<body>

<p>
Fino ad ora, sono stati discussi i permessi dal punto di vista dei file
regolari. Quando questi vengono applicati a cartelle, le cose sono un poco
diverse. Le cartelle usano gli stessi flag per i permessi ma questi vengono
interpretati nel loro significato in modo leggermente differente.
</p>

<p>
Per una cartella, se il flag di "lettura" è impostato, è possibile avere una
lista dei contenuti della cartella stessa; "scrittura" significa che si possono
creare file nella cartella; "esecuzione" indica la possibilità di entrare nella
cartella e accedere ogni sotto cartella al suo interno. Senza il flag
"esecuzione", gli oggetti del filesystem all'interno di una cartella non sono
raggiungibili. Senza il flag "lettura", gli oggetti del filesystem all'interno
di una cartella non sono visibili (nel senso che non vi si può accedere in
lettura), ma agli oggetti all'interno della cartella si può ancora accedere
a patto che qualcuno conosca il percorso completo dell'oggetto su disco.
</p>

</body>
</section>
<section>
<title>Cartelle e sgid</title>
<body>

<p>
E, se una cartella ha il flag "sgid" abilitato, ogni oggetto su filesystem
creato al suo interno erediterà il gruppo della cartella. Questo particolare
caratteristica viene in aiuto quando vi sia la necessità di creare un albero di
cartelle da mettere a disposizione di un insieme di persone che appartengano
tutte allo stesso gruppo. Basta fare quanto segue:
</p>

<pre caption="Creare una cartella per un insieme di persone">
# <i>mkdir /home/groupspace</i>
# <i>chgrp mio_gruppo /home/groupspace</i>
# <i>chmod g+s /home/groupspace</i>
</pre>

<p>
Ora, ogni utente nel gruppo mio_gruppo può creare file e cartelle all'interno di
<path>/home/groupspace</path> e a questi sarà anche assegnata automaticamente la
proprietà sul gruppo per mio_gruppo. In relazione alle impostazioni di umask
degli utenti, i nuovi oggetti su filesystem possono o meno risultare leggibili,
scrivibili o eseguibili dagli altri membri del gruppo mio_gruppo.
</p>

</body>
</section>
<section>
<title>Cartelle e cancellazione</title>
<body>

<p>
In modo predefinito, le cartelle in Linux si comportano in un modo che può non
essere ideale in tutte le situazioni. Normalmente, chiunque può rinominare o
cancellare file all'interno di una cartella, a patto che chi opera abbia
l'accesso in scrittura alla specifica cartella. Per cartelle usate da utenti
individuali, questo comportamento è di solito abbastanza corretto.
</p>

<p>
Comunque, per cartelle che sono usate da molti utenti, specialmente
<path>/tmp</path> e <path>/var/tmp</path>, questo comportamento può rivelare
brutte sorprese. Dato che chiunque può scrivere in queste cartelle, chiunque può
cancellare o rinominare file di altri utenti -- anche se chi agisce non è il
proprietario! Ovviamente, è difficile usare <path>/tmp</path> per qualcosa che
abbia senso quando altri utenti possono digitare <c>rm -rf /tmp/*</c> in ogni
momento e cancellare i file di chiunque altro.
</p>

<p>
Fortunatamente, Linux ha un qualcosa chiamato bit sticky (letteralmente,
appiccicoso). Quando <path>/tmp</path> ha il bit sticky impostato (con il
comando <c>chmod +t</c>), le sole persone che possono cancellare o rinominare
file in <path>/tmp</path> sono i possessori della cartella (di solito root), i
possessori dei file o root. Quasi tutte le distribuzioni Linux abilitano il bit
sticky su <path>/tmp</path> di base, ma è possibile accorgersi che il bit sticky
divente utile anche in altre situazioni.
</p>

</body>
</section>
<section>
<title>La prima cifra elusiva</title>
<body>

<p>
Per concludere la sezione, infine verrà discussa la prima cifra elusiva del modo
numerico. Come si può notare, la prima cifra è usata per impostare i bit sticky,
<c>suid</c> e <c>sgid</c>:
</p>

<table>
<tr>
  <th>suid</th>
  <th>sgid</th>
  <th>sticky</th>
  <th>cifra del modo</th>
</tr>
<tr>
  <ti>on</ti>
  <ti>on</ti>
  <ti>on</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>on</ti>
  <ti>off</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>off</ti>
  <ti>on</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>on</ti>
  <ti>off</ti>
  <ti>off</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>on</ti>
  <ti>on</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>on</ti>
  <ti>off</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>off</ti>
  <ti>on</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>off</ti>
  <ti>off</ti>
  <ti>off</ti>
  <ti>0</ti>
</tr>
</table>

<p>
Di seguito un esempio su come usare un modo numerico a 4 cifre per impostare i
permessi per una cartella che sarà usata da un gruppo di lavoro:
</p>

<pre caption="Impostare i permessi numericamente">
# <i>chmod 1775 /home/groupfiles</i>
</pre>

<p>
Come compito per casa, il lettore è invitato a capire il significato della
impostazione numerica 1755 per i permessi.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestione degli account in Linux</title>
<section>
<title>Introduzione a /etc/passwd</title>
<body>

<p>
In questa sezione, verrà data un'occhiata al meccanismo di gestione degli
account in Linux, iniziando con il file <path>/etc/passwd</path>, che definisce
tutti gli utenti esistenti su un sistema Linux. È possibile vedere il proprio
file <path>/etc/passwd</path> digitano less <path>/etc/passwd</path>.
</p>

<p>
Ogni linea in <path>/etc/passwd</path> definisce un account utente. Di seguito
un esempio di linea dal file <path>/etc/passwd</path> dell'autore:
</p>

<pre caption="/etc/passwd">
drobbins:x:1000:1000:Daniel Robbins:/home/drobbins:/bin/bash
</pre>

<p>
Come si può notare, ci sono abbastanza informazioni su questa linea. In effetti,
ogni linea  di <path>/etc/passwd</path> consiste di più campi, ognuno separato
da :.
</p>

<p>
Il primo campo indica il nome utente (drobbins) e il secondo campo contiene una
x. Sui vecchi sistemi Linux, questo campo conteneva una password cifrata da
usare per l'autenticazione, ma quasi tutti i sistemi Linux di oggi immagazzinano
questa informazione sulla password in un altro file.
</p>

<p>
Il terzo campo (1000) specifica l'id utente numerico associato con questo
particolare utente e il quarto campo (1000) associa il dato utente ad un
particolare gruppo; entro pochi paragrafi, sarà mostrato dove viene definito il
gruppo 1000.
</p>

<p>
Il quinto campo contiene una descrizione testuale dell'account -- in questo
caso, il nome dell'utente. Il sesto campo definisce la cartella di home
dell'utente (ovvero, la sua cartella principale) e il settimo campo specifica la
shell predefinita dell'utente -- quella che sarà avviata automaticamente quando
l'utente accederà al sistema.
</p>

</body>
</section>
<section>
<title>Suggerimenti e trucchi per /etc/passwd</title>
<body>

<p>
Probabilmente qualcuno avrà notato che ci sono molti più account utente definiti
in <path>/etc/passwd</path> di quanti effettivamente utilizzabili per accedere
al sistema. Questo perché varie componenti di Linux usano account utente per
aumentare la sicurezza. Di solito, questi account utente hanno un id utente
("uid") minore di 100 e molti di questi hanno qualcosa del tipo /bin/false
elencato come shell predefinita. Dato che il programma <path>/bin/false</path>
non fa niente ma esce senza un codice di errore, questo effettivamente previene
l'utilizzo di questi account come validi per accedere al sistema -- sono
solamente per uso interno.
</p>

</body>
</section>
<section>
<title>/etc/shadow</title>
<body>

<p>
Quindi, gli account utente sono definiti in <path>/etc/passwd</path>. I sistemi
Linux contengono un file di accompagnamento per <path>/etc/passwd</path> che è
chiamato <path>/etc/shadow</path>. Questo file, a differenza di
<path>/etc/passwd</path>, è leggibile solamente da root e contiene le
informazioni sulle password cifrate. Ecco un esempio di una semplice linea presa
da <path>/etc/shadow</path>:
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Ogni linea definisce informazioni sulla password per un particolare account e,
ancora, ogni campo è separato da :. Il primo campo indica il particolare account
utente a cui questa voce nascosta è associata. Il secondo campo contiene una
password cifrate. I campi rimanenti sono descritti nella seguente tabella:
</p>

<table>
<tr>
  <ti>campo 3</ti>
  <ti># di giorni trascorsi dal 1/1/1970 all'ultima modifica della password</ti>
</tr>
<tr>
  <ti>campo 4</ti>
  <ti>
    # numero di giorni rimanenti prima che la password sia abilitata a subire
    modifiche (0 per "cambiare ogni volta")
  </ti>
</tr>
<tr>
  <ti>campo 5</ti>
  <ti>
    # di giorni rimanenti prima che il sistema forzi l'utente a cambiare la
    password con una nuova (-1 per "mai")
  </ti>
</tr>
<tr>
  <ti>campo 6</ti>
  <ti>
    # di giorni rimanenti prima che l'utente venga avvertito sulla imminente
    scadenza della propria password (-1 per "nessun avvertimento")
  </ti>
</tr>
<tr>
  <ti>campo 7</ti>
  <ti>
    # di giorni rimanenti alla disabilitazione dell'account da parte del sistema
    dopo l'avvenuta scadenza della password (-1 per "mai disabilitato")
  </ti>
</tr>
<tr>
  <ti>campo 8</ti>
  <ti>
    # di giorni trascorsi dalla disabilitazione dell'account (-1 per "questo
    account è attivo")
  </ti>
</tr>
<tr>
  <ti>campo 9</ti>
  <ti>Riservato per usi futuri</ti>
</tr>
</table>

</body>
</section>
<section>
<title>/etc/group</title>
<body>

<p>
Proseguendo, bisogna parlare del file <path>/etc/group</path>, che definisce
tutti i gruppi su un sistema Linux. Di seguito una linea di esempio:
</p>

<pre caption="/etc/group">
drobbins:x:1000:
</pre>

<p>
Il formato dei campi per <path>/etc/group</path> è il seguente. Il primo campo
definisce il nome del gruppo; il secondo campo contiene la traccia di una
password che adesso contiene semplicemente una x e il terzo campo definisce l'id
numerico di gruppo per questo particolare gruppo. Il quarto campo (vuoto
nell'esempio precedente) indica ogni utente che è membro di questo gruppo.
</p>

<p>
Bisogna ricordare che la linea di esempio per <path>/etc/passwd</path> si
riferiva ad un id di gruppo 1000. Questo ha l'effetto di piazzare l'utente
drobbins nel gruppo drobbins, anche se il nome utente drobbins non è elencato
nel quarto campo di <path>/etc/group</path>.
</p>

</body>
</section>
<section>
<title>Note sui gruppi</title>
<body>

<p>
Una nota sull'associazione fra utenti e gruppi: su alcuni sistemi si riscontrerà
che ogni nuovo account utente per il login viene associato con un gruppo dello
stesso nome (e spesso anche stesso numero). Su altri sistemi, tutti gli account
utente per il login apparterranno ad un singolo gruppo users. L'approccio che il
lettore usa sul proprio sistema amministrato (o sui propri sistemi amministrati)
è una sua decisione. Creare gruppi corrispondenti per ogni utente ha il
vantaggio di permettere agli utenti un più facile controllo sull'accesso ai loro
file inserendo amici fidati nel loro gruppo personale.
</p>

</body>
</section>
<section>
<title>Aggiungere un utente ed un gruppo a mano</title>
<body>

<p>
Adesso, verrà mostrato come creare il proprio account utente e relativo gruppo.
Il modo migliore per imparare come fare questo è aggiungere un nuovo utente al
sistema manualmente. Per iniziare, assicurarsi per prima cosa che la propria
variabile d'ambiente EDITOR sia impostata con il proprio editor di testi
preferito:
</p>

<pre caption="Controllare la variabile relativa al proprio editor di testi
preferito">
# <i>echo $EDITOR</i>
vim
</pre>

<p>
Se così non fosse, è possibile impostarla digitando qualcosa di simile a quanto
segue:
</p>

<pre caption="Impostare la variabile EDITOR">
# <i>export EDITOR=/usr/bin/emacs</i>
# <i>vipw</i>
</pre>

<p>
Si dovrebbe ora trovarsi nel proprio editor di testi preferito con il file
<path>/etc/passwd</path> caricato sullo schermo. Quando si modificano i file di
sistema <path>passwd</path> e <path>group</path>, è molto importante usare i
comandi <c>vipw</c> e <c>vigr</c>. Questi prendono precauzioni ulteriori per
assicurare che i propri file critici <path>passwd</path> e <path>group</path>
siano bloccati correttamente così che questi non risultino corrotti alla fine.
</p>

</body>
</section>
<section>
<title>Modificare /etc/passwd</title>
<body>

<p>
Adesso che il file <path>/etc/passwd</path> è stato caricato, si può andare
avanti e aggiungere la seguente linea:
</p>

<pre caption="/etc/passwd">
testuser:x:3000:3000:LPI tutorial test user:/home/testuser:/bin/false
</pre>

<p>
Così è stato appena aggiunto un utente "testuser" con un UID uguale a 3000.
Questo è stato aggiunto ad un gruppo con GID 3000, che non è stato ancora
creato. In alternativa, sarebbe possibile assegnare questo utente al GID del
gruppo users se lo si desidera. Questo nuovo utente ha un commento che recita
LPI tutorial test user; la cartella home dell'utente è impostata a
<path>/home/testuser</path> e la shell dell'utente è impostata a
<path>/bin/false</path> per ragioni di sicurezza. Se si sta creando un account
non di test, la shell potrebbe essere impostata a <path>/bin/bash</path>. Adesso
bisogna procedere salvando le modifiche ed uscendo.
</p>

</body>
</section>
<section>
<title>Modificare /etc/shadow</title>
<body>

<p>
Ora, c'è bisogno di aggiungere una voce in <path>/etc/shadow</path> per questo
particolare utente. Per farlo, digitare <c>vipw -s</c>. L'utente sarà accolto
dal proprio editor di testi favorito, che ora contiene il file
<path>/etc/shadow</path>. Adesso, andando avanti basta copiare la linea di un
account esistente (uno che ha una password ed è più lunga delle voci degli
account di base del sistema):
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
A questo punto, cambiare il nome utente sulla linea copiata col nome del proprio
nuovo utente e assicurarsi che tutti i campi (in particolare la durata della
password) siano impostati secondo le proprie preferenze:
</p>

<pre caption="Modificare /etc/shadow">
testuser:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Infine, salvare ed uscire.
</p>

</body>
</section>
<section>
<title>Impostare una password</title>
<body>

<p>
Il prompt sarà di nuovo lì. Adesso, è il momento di impostare una password per
il proprio utente nuovo:
</p>

<pre caption="Impostare password per un nuovo utente">
# <i>passwd testuser</i>
Enter new UNIX password: <comment>(enter a password for testuser)</comment>
Retype new UNIX password: <comment>(enter testuser's new password again)</comment>
</pre>

</body>
</section>
<section>
<title>Modificare /etc/group</title>
<body>

<p>
Ora che <path>/etc/passwd</path> e <path>/etc/shadow</path> sono a posto, è
l'ora di configurare correttamente <path>/etc/group</path>. Per farlo, digitare:
</p>

<pre caption="Configurare /etc/group">
# <i>vigr</i>
</pre>

<p>
Apparirà il proprio file <path>/etc/group</path>, pronto per le modifiche.
Adesso, se si sceglie di assegnare il gruppo predefinito users al proprio
particolare utente di test, non c'è bisogno di aggiungere alcun gruppo a
<path>/etc/groups</path>. Comunque, se si sceglie di creare un nuovo gruppo per
questo utente, andando avanti basta aggiungere la seguente linea:
</p>

<pre caption="Aggiungere un nuovo gruppo manualmente">
testuser:x:3000:
</pre>

<p>
Ora salvare ed uscire.
</p>

</body>
</section>
<section>
<title>Creare una cartella home</title>
<body>

<p>
La fine è vicina. Digitando il seguente comando verrà creata una cartella home
per l'utente testuser:
</p>

<pre caption="Creare una cartella home">
# <i>cd /home</i>
# <i>mkdir testuser</i>
# <i>chown testuser.testuser testuser</i>
# <i>chmod o-rwx testuser</i>
</pre>

<p>
La cartella home dell'utente creato è al suo posto e l'account è pronto per
l'uso. O meglio, quasi pronto. Se si desidera usare questo account, è necessario
usare vipw per cambiare la shell predefinita dell'utente testuser in
<path>/bin/bash</path> così che l'utente possa accedere al sistema.
</p>

</body>
</section>
<section>
<title>Strumenti di amministrazione per gli account</title>
<body>

<p>
Ora che è stato illustrato come aggiungere un nuovo account a gruppo a mano,
bisogna dare un'occhiata ai vari strumenti salva tempo disponibili sotto Linux
per la gestione degli account. A causa di vincoli di spazio, non saranno coperti
molti dettagli nella descrizione di questi comandi. Ricordarsi che è possibile
sempre avere più informazioni su un comando leggendo la pagina di manuale
relativa. Se si sta pianificando di sostenere l'esame 101 del LPIC, bisognerebbe
spendere un po' di tempo per prendere familiarità con ognuno di questi comandi.
</p>

<p>
newgrp
</p>

<p>
Di base, ogni file che un utente crea è assegnato al gruppo dell'utente stesso
specificato in <path>/etc/passwd</path>. Se l'utente appartiene ad altri gruppi,
egli o ella può digitare newgrp questo_gruppo per impostare la proprietà di
gruppo predefinita al gruppo questo_gruppo. Quindi, ogni nuovo file creato
erediterà l'appartenenza al gruppo questo_gruppo.
</p>

<table>
<tr>
  <ti><c>chage</c></ti>
  <ti>
    Il comando <c>chage</c> è usato per vedere e cambiare le impostazioni sulla
    durata della password memorizzate in <path>/etc/shadow</path>.
  </ti>
</tr>
<tr>
  <ti><c>gpasswd</c></ti>
  <ti>Uno strumento di amministrazione del gruppo multiuso.</ti>
</tr>
<tr>
  <ti><c>groupadd</c>/<c>groupdel</c>/<c>groupmod</c></ti>
  <ti>
    Usati per aggiungere/cancellare/modificare gruppi in <path>/etc/group</path>
  </ti>
</tr>
<tr>
  <ti><c>useradd</c>/<c>userdel</c>/<c>usermod</c></ti>
  <ti>
    Usati per aggiungere/cancellare/modificare utenti in
    <path>/etc/passwd</path>. Questi comandi effettuano anche varie altre
    funzioni comode. Vedere la pagina di manuale per maggiori informazioni.
  </ti>
</tr>
<tr>
  <ti><c>pwconv</c>/<c>grpconv</c></ti>
  <ti>
    Usato per convertire i file <path>passwd</path> e <path>group</path> nella
    "nuova forma" di password oscurate (o shadow password). Teoricamente tutti i
    sistemi Linux usano già le shadow password, quindi non dovrebbe esserci
    bisogno di usare questi comandi.
  </ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Raffinare l'ambiente utente</title>
<section>
<title>Introduzione a "fortune"</title>
<body>

<p>
La propria shell ha molte utili opzioni che si possono impostare per venire
incontro alla preferenze personali. Fin'ora, comunque, non è stata discussa
alcuna via per avere queste impostazioni impostate automaticamente ogni volta
che si accede al sistema, a parte se non digitando nuovamente ogni volta il
comando. In questa sezione verrà mostrato come raffinare il proprio ambiente di
login modificando i file di avvio.
</p>

<p>
Prima di tutto, verrà aggiunto un messaggio amichevole al primo accesso al
sistema. Per vedere un esempio di messaggio, lanciare <c>fortune</c>:
</p>

<pre caption="Eseguire il comando fortune">
$ <i>fortune</i>
No amount of careful planning will ever replace dumb luck.
</pre>

</body>
</section>
<section>
<title>.bash_profile</title>
<body>

<p>
Adesso, configuriamo <c>fortune</c> così che venga eseguito ad ogni login.
Usando il proprio editor di testi preferito bisogna modificare un file chiamato
<path>.bash_profile</path> nella propria cartella home. Se il file non esiste
già, si vada avanti creandolo. Inserire una linea in cima:
</p>

<pre caption="~/.bash_profile">
fortune
</pre>

<p>
Provare ad uscire e rientrare nel sistema. A meno che non si stia eseguendo un
gestore di login come xdm, gdm o kdm, dovrebbe apparire un'accoglienza
divertente accedendo al sistema:
</p>

<pre caption="Risultato del comando fortune nel file .bash_profile">
mycroft.flatmonk.org login: chouser
Password:
Freedom from incrustations of grime is contiguous to rectitude.
$
</pre>

</body>
</section>
<section>
<title>La shell di login</title>
<body>

<p>
Quando bash si avvia, attraversa il file <path>.bash_profile</path> nelle
propria home directory, eseguendo ogni riga così come se questa fosse digitata
dal prompt di bash. Questa azione è chiamata "sourcing del file" (letteralmente,
tirare fuori il file).
</p>

<p>
Bash opera in modo diverso in relazione a come viene avviato. Se è lanciato come
shell di login, opera come sopra accennato -- prima fa il sourcing del file
valido per l'intero sistema <path>/etc/profile</path> e quindi del proprio
personale <path>~/.bash_profile</path>.
</p>

<p>
Ci sono due modi per dire a bash di eseguire come shell di login. Un modo è
usato quando si effettua il primo accesso al sistema: bash è avviato con un nome
di processo di -bash. È possibile vederlo nel listato dei processi:
</p>

<pre caption="Lista dei processi">
$ <i>ps u</i>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
chouser    404  0.0  0.0  2508  156 tty2     S     2001   0:00 -bash
</pre>

<p>
Probabilmente sarà presente un più lunga lista, ma dovrebbe esserci almeno una
voce in COMMAND con un trattino prima del nome della propria shell, come -bash
in questo esempio. Questo trattino è usato dalla shell per determinare se deve
eseguire come una shell di login.
</p>

</body>
</section>
<section>
<title>Capire --login</title>
<body>

<p>
Il secondo modo per dire a bash di eseguire come shell di login è con l'opzione
a riga di comando <c>--login</c>. Questa viene usata talvolta dagli emulatori di
terminale (come xterm) per rendere la loro sessione bash simile ad una sessione
di login iniziale.
</p>

<p>
Dopo l'accesso al sistema, più copie della propria shell saranno eseguite. A
meno che non vengano lanciate con <c>--login</c> o abbiano una trattino nel nome
del processo, queste sessioni non saranno shell di login. Se presentano
all'utente un prompt, comunque, queste vengono chiamate shell interattive. Se
bash è avviata come interattiva, ma non di login, ignorerà
<path>/etc/profile</path> e <path>~/.bash_profile</path> e si rivolgerà invece a
<path>~/.bashrc</path>.
</p>

<table>
<tr>
  <th>interattiva</th>
  <th>login</th>
  <th>profile</th>
  <th>rc</th>
</tr>
<tr>
  <ti>si</ti>
  <ti>si</ti>
  <ti>usato</ti>
  <ti>ignorato</ti>
</tr>
<tr>
  <ti>si</ti>
  <ti>no</ti>
  <ti>ignorato</ti>
  <ti>usato</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>si</ti>
  <ti>usato</ti>
  <ti>ignorato</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>no</ti>
  <ti>ignorato</ti>
  <ti>ignorato</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Provare l'interattività</title>
<body>

<p>
Talvolta bash fa il sourcing del proprio file <path>~/.bashrc</path>, anche se
questa non è davvero interattiva, come quando si usano comandi del tipo rsh e
scp. Questo è bene ricordarlo perché stampare del testo, come è stato fatto con
il comando fortune in precedenza, può davvero confondere queste sessioni non
interattive di bash. È una buona idea usare la variabile PS1 per rilevare quando
la shell attuale è veramente interattiva prima di stampare del testo da un file
d'avvio:
</p>

<pre caption="Testare la variabile PS1">
if [ -n "$PS1" ]; then
fortune
fi
</pre>

</body>
</section>
<section>
<title>/etc/profile e /etc/skel</title>
<body>

<p>
Come amministratore di sistema, si ha a carico il file
<path>/etc/profile</path>. Dato che questo viene analizzato da chiunque quando
si effettua un primo accesso al sistema, è importante tenerlo in ordine e
funzionante. È anche uno strumento potente per rendere operative le cose in modo
corretto per i nuovi utenti non appena questi accedono al sistema nei loro nuovi
account.
</p>

<p>
Comunque, ci sono alcune impostazioni che si potrebbe volere mettere a
disposizione come base per i nuovi utenti, ma anche permettere loro di cambiarle
facilmente. Qui è dove viene in aiuto la cartella <path>/etc/skel</path>. Quando
si usa il comando <c>useradd</c> per creare un nuovo account utente, si copiano
tutti i file da <path>/etc/skel</path> nella nuova cartella home dell'utente
stesso. Ciò significa che si possono mettere utili file
<path>.bash_profile</path> e <path>.bashrc</path> in <path>/etc/skel</path> per
mettere a disposizione dei nuovi utenti un buon avvio
</p>

</body>
</section>
<section>
<title>export</title>
<body>

<p>
Le variabili in bash possono essere marcate così che risultino impostate in ogni
nuova shell che viene avviata; questa è chiamata marchiatura per esportazione
(export). Si può avere una lista delle variabili attualmente marcate per
l'esportazione nella propria sessione di shell con bash:
</p>

<pre caption="risultati del comando export">
$ <i>export</i>
declare -x EDITOR="vim"
declare -x HOME="/home/chouser"
declare -x MAIL="/var/spool/mail/chouser"
declare -x PAGER="/usr/bin/less"
declare -x PATH="/bin:/usr/bin:/usr/local/bin:/home/chouser/bin"
declare -x PWD="/home/chouser"
declare -x TERM="xterm"
declare -x USER="chouser"
</pre>

</body>
</section>
<section>
<title>Marcare le variabile per l'esportazione</title>
<body>

<p>
Se una variabile non è marcate per l'esportazione, ogni nuova shell che viene
avviata non avrà questa variabile impostata. Comunque, è possibile marcare una
variabile per l'esportazione passandola al comando interno <c>export</c>:
</p>

<pre caption="Marcare una variabile per l'esportazione">
$ <i>FOO=foo</i>
$ <i>BAR=bar</i>
$ <i>export BAR</i>
$ <i>echo $FOO $BAR</i>
foo bar
$ <i>bash</i>
$ <i>echo $FOO $BAR</i>
bar
</pre>

<p>
In questo esempio, le variabile FOO e BAR sono entrambe impostate, ma solo BAR è
marcata per l'esportazione. Quando bash è avviato nuovamente, ha perso il valore
di FOO. Se si esce dal nuovo bash, è possibile vedere che l'originale ha ancora
il proprio valore sia per FOO che per BAR:
</p>

<pre caption="Controllare le impostazione nella shell bash originale">
$ <i>exit</i>
$ <i>echo $FOO $BAR</i>
foo bar
</pre>

</body>
</section>
<section>
<title>Export e set -x</title>
<body>

<p>
Dato questo comportamento, le variabili possono essere impostate in
<path>~/.bash_profile</path> o <path>/etc/profile</path> e marcate per
l'esportazione, quindi non si avrà più bisogno di impostarle ancora. Ci sono
alcune opzioni che non possono essere esportate, comunque, e quindi queste
devono essere messe nei propri file <path>~/.bashrc</path> e <e>profile</e> in
modo da essere impostate coerentemente. Queste opzioni sono regolate con il
comando interno set:
</p>

<pre caption="Usare il comando set">
$ <i>set -x</i>
</pre>

<p>
L'opzione <c>-x</c> comporta la stampa da parte di bash di ogni comando che sta
per eseguire:
</p>

<pre caption="Controllare i risultati dell'opzione -x">
$ <i>echo $FOO</i>
$ <i>echo foo</i>
foo
</pre>

<p>
Questo può essere davvero utile per capire il comportamento inaspettato delle
virgolette o stranezze simili. Per togliere l'opzione <c>-x</c>, dare <c>set
+x</c>. Dare un'occhiata alla pagina di manuale per tutte le opzioni del comando
interno set.
</p>

</body>
</section>
<section>
<title>Impostare le variabili con "set"</title>
<body>

<p>
Il comando interno <c>set</c> può anche essere usato per impostare variabili, ma
quando è usato in questo modo è opzionale. Il comando bash <c>set FOO=foo</c>
significa esattamente la stessa cosa di <c>FOO=foo</c>. Per togliere
l'impostazione di una variabile si usa il comando interno <c>unset</c>:
</p>

<pre caption="Togliere l'impostazione ad una variabile">
$ <i>FOO=bar</i>
$ <i>echo $FOO</i>
bar
$ <i>unset FOO</i>
$ <i>echo $FOO</i>
</pre>

</body>
</section>
<section>
<title>Unset vs. FOO=</title>
<body>

<p>
Questa <e>non</e> è la stessa cosa che impostare una varibile al valore nullo,
anche se è talvolta difficile spiegare la differenza. Un modo per farlo è usare
il comando interno <c>set</c> senza parametri per avere una lista delle
variabili correnti:
</p>

<pre caption="Confronto fra unset e FOO=">
$ <i>FOO=bar</i>
$ <i>set | grep ^FOO</i>
FOO=bar
$ <i>FOO=</i>
$ <i>set | grep ^FOO</i>
FOO=
$ <i>unset FOO</i>
$ <i>set | grep ^FOO</i>
</pre>

<p>
Usare <c>set</c> senza parametri è simile ad usare il comando interno
<c>export</c>, ad eccezione del fatto che <c>set</c> fornisce una lista di tutte
le variabili invece che solamente quelle marcate per l'esportazione.
</p>

</body>
</section>
<section>
<title>Esportare per cambiare il comportamento di un comando</title>
<body>

<p>
Spesso, il comportamento dei comandi può essere alterato impostando variabili
d'ambiente. Così come con le nuove sessioni bash, altri programmi che vengono
avviati dal proprio prompt bash saranno capaci solo di vedere le variabili che
sono state marcate per l'esportazione. Per esempio, il comando <c>man</c>
controlla la variabile PAGER per scoprire quale programma usare per avanzare
attraverso il testo una pagina alla volta.
</p>

<pre caption="Esportare la variabile PAGER">
$ <i>PAGER=less</i>
$ <i>export PAGER</i>
$ <i>man man</i>
</pre>

<p>
Con PAGER impostato su <c>less</c>, sarà mostrata una pagina alla volta
scorrendo alla pagina seguente a seguito di una pressione della barra
spaziatrice. Se si cambia il valore di PAGER in <c>cat</c>, il testo sarà
mostrato tutto in una volta, senza pause.
</p>

<pre caption="Impostare la variabile PAGER su cat">
$ <i>PAGER=cat</i>
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>Usare "env"</title>
<body>

<p>
Sfortunatamente, se ci si dimentica di impostare la variabile PAGER nuovamente
su <c>less</c>, <c>man</c> (così come alcuni altri programmi) continueranno a
mostrare tutto il loro testo senza fermarsi. Se si desidera impostare PAGER su
<c>cat</c> per una sola volta, è possibile usare il comando <c>env</c>:
</p>

<pre caption="Usare il comando env per impostare una variabile">
$ <i>PAGER=less</i>
$ <i>env PAGER=cat man man</i>
$ <i>echo $PAGER</i>
less
</pre>

<p>
Questa volta, PAGER è stato esportato per <c>man</c> con il valore <c>cat</c>,
ma la variabile PAGER stessa è rimasta intatta nella sessione bash.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sommario e risorse</title>
<section>
<title>Sommario</title>
<body>

<p>
Congratulazione per la fine della Parte 3 di questa serie di brevi guide. A
questo punto, si dovrebbe sapere come localizzare informazioni nella
documentazione di sistema e su Internet e si dovrebbe avere una buona
infarinatura sul modello dei permessi in Linux, la gestione degli account e il
raffinamento dell'ambiente di login.
</p>

</body>
</section>
<section id="resources">
<title>Risorse</title>
<body>

<p>
Assicurarsi di dare un'occhiata alle varie risorse sulla documentazione in Linux
coperte in questa breve guida -- in particolare al <uri
link="http://www.tldp.org/">Linux Documentation Project</uri>. Ci si accorgerà
che l'insieme di guide, HOWTO, FAQ e pagine di manuale presenti ha un valore
inestimabile. Assicurarsi di controllare inoltre la <uri
link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri> e <uri
link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>.
</p>

<p>
La <uri link="http://www.tldp.org/guides.html">Linux System Administrators
guide</uri> (Guida per Amministratori di Sistema Linux, disponibile sotto nella
sezione "Guides" su www.tlpd.org) è un buon complemento a questa serie di brevi
guide -- si consiglia di dargli una lettura. Forse potrebbe essere utile anche
il <uri
link="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix and
Internet Fundamentals HOWTO (HOWTO sui Fondamenti di Unix e Internet)</uri> di
Eric S. Raymond.
</p>

<p>
È possibile leggere la documentazione dello GNU Project sulla rete per il
sistema GNU info (anche chiamato "texinfo") sulla <uri
link="http://www.gnu.org/manual/texinfo/index.html">pagina di documentazione di
GNU texinfo</uri>.
</p>

<p>
Si consiglia di fare un giro sulla <uri
link="http://www.tldp.org/links/#ng">Linux newsgroup list</uri> sul sito del LDP
e nell'archivio di newsgroup su <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

<p>
Nella serie di articoli Bash by example (Bash tramite esempi) su developerWorks,
Daniel mostra al lettore come usare i costrutti della programmazione bash per
scrivere i propri script in bash. Questa serie su bash (in particolare Parti 1
e 2) rappresenta una buona preparazione per l'esame LPIC di Livello 1 e rinforza
i concetti coperti nella sezione "Raffinare l'ambiente utente" di questa breve
guida:
</p>

<ul>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p1.xml">Bash per esempi, Parte
    1: Fondamenti di programmazione nella Bourne-again shell</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p2.xml">Bash per esempi, Parte
    2: Ulteriori fondamenti di programmazione bash</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p3.xml">Bash per esempi, Parte
    3: Esplorare il sistema ebuild.</uri>
  </li>
</ul>

<p>
È fortemente raccomandato <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/">Technical FAQ
by Linux Users</uri> (FAQ tecniche per Utenti Linux) di Mark Chapman, una lista
di 50 pagine approfondite riguardo domande frequenti su Linux, insieme a
risposte dettagliate. Le FAQ stesse sono in formato PDF (Adobe Acrobat). Se chi
legge è un utente Linux novizio o intermedio, dovrebbe preoccuparsi di imporre a
se stesso una lettura di queste FAQ. È anche raccomandato il <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-gloss/index.html">
Linux glossary for Linux users (Glossario Linux per utenti Linux)</uri>, ancora
da parte di Mark.
</p>

<p>
Per chi non fosse familiare con l'editor vi, si faccia riferimento al testo di
Daniel <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">Vi intro
-- the cheat sheet method tutorial (Introduzione a VI -- bignami)</uri>. Questa
breve guida fornisce al lettore una leggera ma veloce introduzione a questo
potente editor di testi. Bisogna considerare questo materiale come obbligatorio
se non si sa come usare vi.
</p>

<p>
Per una introduzione all'editor Emacs, si veda la breve guida su developerWorks,
<uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">Living
in Emacs (Vivere con Emacs)</uri>.
</p>

</body>
</section>
<section>
<title>Commenti</title>
<body>

<p>
Si incoraggiano i lettori a far sapere agli scrittori dove questa breve guida è
stata utile e come potrebbe essere migliorata. Gli autori di questa guida
incoraggiano i lettori a fornire un proprio riscontro sull'utilità di questa
guida e su eventuali migliorie. Avrebbero piacere anche di conoscere altri
argomenti di cui sarebbe gradita la presenza fra le guide brevi su
developerWorks.
</p>

<p>
Per domande sui contenuti di questa breve guida, contattare gli autori:
</p>

<ul>
  <li>Daniel Robbins, su <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, su <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, su <mail>agriffis@gentoo.org</mail>.</li>
</ul>

</body>
</section>
</chapter>
</guide>