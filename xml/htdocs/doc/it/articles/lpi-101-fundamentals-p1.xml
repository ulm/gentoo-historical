<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/it/articles/lpi-101-fundamentals-p1.xml,v 1.1 2007/10/08 20:57:20 scen Exp $ -->

<guide link="/doc/it/articles/lpi-101-fundamentals-p1.xml" disclaimer="articles"
lang="it">
<title>Preparazione all'esame per la Certificazione LPI 101 (release 2), Parte
1</title>

<author title="Autore">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<!--<author title="Editor">
  <mail link="curtis119@gentoo.org">M Curtis Napier</mail>
</author>-->
<author title="Traduzione">
  <mail link="skypjack@gmail.com">Michele Caini</mail>
</author>

<abstract>
In questa breve guida sarà data un'introduzione su bash (la shell predefinita in
Linux) al lettore, verrà mostrato come ottenere pieno vantaggio da comandi di
base in Linux come ls, cp e mv, saranno spiegati gli inodes e sia hard link che
link simbolici e tanto altro ancora. Alla fine di questa introduzione, il
lettore avrà una base solida sui fondamenti di Linux e sarà anche pronto per
iniziare ad imparare alcuni processi basilari riguardo all'amministrazione di
sistemi Linux.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This
document is an updated version of the original article, and contains
various improvements made by the Gentoo Linux Documentation team -->

<version>1.4</version>
<date>2005-10-12</date>

<chapter>
<title>Prima di iniziare</title>
<section>
<title>Riguardo a questa introduzione</title>
<body>

<p>
Benvenuti in "fondamenti di Linux", la prima di quattro brevi guide concepite
per preparare il lettore all'esame 101 del Linux Professional Institute. In
questa breve guida sarà data un'introduzione su bash (la shell predefinita in
Linux) al lettore, verrà mostrato come ottenere pieno vantaggio da comandi di
base in Linux come ls, cp e mv, saranno spiegati gli inodes e sia hard link che
link simbolici e tanto altro ancora. Alla fine di questa introduzione, il
lettore avrà una base solida sui fondamenti di Linux e sarà anche pronto per
iniziare ad imparare alcuni processi basilari riguardo all'amministrazione di
sistemi Linux. Al termine di questa serie di guide introduttive (otto in tutto),
il lettore avrà la conoscenza necessaria per diventare un Amministratore di
Sistema Linux e sarà pronto per raggiungere la Certificazione LPIC di Livello 1
del Linux Professional Institute se lo desidera.
</p>

<p>
Questa guida in particolare (Parte 1) è ideale per coloro che sono nuovi a Linux
o per chi vuole rinfrescare o perfezionare la propria comprensione dei concetti
fondamentali di Linux come la copia e lo spostamento di file, la creazione di
hard link e link simbolici e l'uso di comandi di base per processare del testo
insieme alle pipeline e la ridirezione. Lungo la strada, verranno forniti un
gran numero di consigli, suggerimenti e trucchi per rendere questa introduzione
carnosa e pratica, anche per coloro che hanno un buon numero di precedenti
esperienze con Linux. Per i principianti, molto di questo materiale sarà nuovo,
ma gli utenti Linux con più esperienza potrebbero trovare questa breve guida un
bel modo per affinare le loro abilità sui fondamenti di Linux.
</p>

<p>
Per chi fosse già in possesso della versione di rilascio 1 di questa guida per
altre ragioni oltre alla preparazione dell'esame del LPI, probabilmente non sarà
necessario prendere anche questa. Comunque, se si pianifica di sostenere gli
esami, dovrebbe essere decisamente presa in considerazione la lettura di questa
versione rivista della guida.
</p>

</body>
</section>
<section>
<title>Riguardo all'autore</title>
<body>

<p>
Residente in Albuquerque, New Mexico, Daniel Robbins è l'Architetto Capo di
Gentoo Linux, un'avanzata meta distribuzione Linux basata su sorgenti. Ha anche
scritto articoli, brevi guide e suggerimenti nell'area dedicata a Linux dell'IBM
developerWorks e per l'Intel Developer Services e ha anche preso parte come
autore di contributi per diversi libri, incluso Samba Unleashed e SuSE Linux
Unleashed. Daniel si diverte passando il proprio tempo con sua moglie, Mary, e
sua figlia, Hadassah. È possibile contattare Daniel all'indirizzo
<mail>drobbins@gentoo.org.</mail>
</p>

</body>
</section>
</chapter>

<chapter>
<title>Introduzione a bash</title>
<section>
<title>La shell</title>
<body>

<p>
Chi ha usato un sistema Linux, saprà che al momento dell'accesso gli viene dato
il benvenuto da un prompt che assomiglia in qualche modo al seguente:
</p>

<pre caption="Il prompt">
$
</pre>

<p>
Il particolare prompt che verrà mostrato a seconda dei casi potrebbe essere
abbastanza diverso. Potrebbe contenere il nome dell'host dell'utente, il nome
dell'attuale cartella di lavoro o entrambi. Ma comunque si presenti il proprio
prompt, una cosa è certa: il programma che stampa il detto prompt è chiamato
"shell" ed è molto probabile che questa particolare shell sia un programma
chiamato <c>bash</c>.
</p>

</body>
</section>
<section>
<title>Controllare se bash è in esecuzione</title>
<body>

<p>
È possibile controllare se si sta eseguendo <c>bash</c> digitando:
</p>

<pre caption="La variabile SHELL">
$ <i>echo $SHELL</i>
/bin/bash
</pre>

<p>
Se la linea precedente restituisce un errore o non risponde in modo simile
all'esempio, potrebbero essere in esecuzione una shell differente da bash. In
questo caso, gran parte di questa breve guida potrebbe ancora essere applicabile
ma sarebbe vantaggioso per il lettore passare a <c>bash</c> nell'interesse di
prepararsi per l'esame 101. <!-- (The next tutorial in this series, on basic
administration, covers changing your shell using the <c>chsh</c> command.) -->
</p>

</body>
</section>
<section>
<title>Riguardo a bash</title>
<body>

<p>
Bash, un acronimo per "Bourne-again shell", è la shell predefinita su molti
sistemi Linux. Il compito della shell è quello di obbedire ai comandi
dell'utente così che questo possa interagire col proprio sistema Linux. Quando
termina l'inserimento dei comandi, è possibile istruire la shell per l'uscita o
logout, nel qual caso sarà presentato nuovamente il prompt di login.
</p>

<p>
Tra l'altro, è possibile anche effettuare il logout premendo control-D nel
prompt di bash.
</p>

</body>
</section>
<section>
<title>Usare "cd"</title>
<body>

<p>
Come qualcuno avrò probabilmente notato, fissare il prompt di bash non è la cosa
più eccitante su questa terra. Quindi, è ora di iniziare ad usare bash per
navigare all'interno del proprio filesystem. Al prompt, digitare quanto segue
(senza il <c>$</c>):
</p>

<pre caption="Cambiare cartella">
$ <i>cd /</i>
</pre>

<p>
In questo modo bash viene informato del fatto che si desidera lavorare in /,
anche conosciuta come cartella radice (o root); tutte le cartelle sul sistema
formano un albero e / è considerata la cima di questo albero, o la radice. Il
comando cd imposta la cartella dove l'utente andrà a lavorare al momento, detta
anche "cartella di lavoro corrente".
</p>

</body>
</section>
<section>
<title>Percorsi</title>
<body>

<p>
Per scoprire la cartella di lavoro corrente di bash, basta digitare:
</p>

<pre caption="Cartella di lavoro attuale">
$ <i>pwd</i>
/
</pre>

<p>
Nell'esempio precedente, l'argomento / passato a <c>cd</c> è chiamato
<e>percorso</e> (o path). Indica a cd dove l'utente vuole andare. In
particolare, l'argomento / è un percorso <e>assoluto</e>, ovvero significa che
questo specifica una locazione relativa alla radice dell'albero del filesystem.
</p>

</body>
</section>
<section>
<title>Percorsi assoluti</title>
<body>

<p>
Di seguito alcuni ulteriori percorsi assoluti:
</p>

<pre caption="Esempi riguardo ai percorsi">
/dev
/usr
/usr/bin
/usr/local/bin
</pre>

<p>
Come si può notare, una cosa che tutti i percorsi assoluti hanno in comune è il
fatto che iniziano con /. Con il percorso /usr/local/bin, viene detto a cd di
accedere alla cartella /, quindi la cartella usr all'interno di essa e poi local
e bin. I percorsi assoluti sono sempre valutati partendo con / all'inizio.
</p>

</body>
</section>
<section>
<title>Percorsi relativi</title>
<body>

<p>
L'altro tipo di percorso è chiamato <e>percorso relativo</e>. <c>Bash</c>,
<c>cd</c> e altri comandi interpretano sempre questi percorsi relativi dalla
cartella corrente. I percorsi relativi non iniziano mai con un /. Quindi, se chi
opera è in /usr:
</p>

<pre caption="Cambiare cartella con percorsi assoluti">
$ <i>cd /usr</i>
</pre>

<p>
Poi, sarà possibile usare un percorso relativo per passare nella cartella
/usr/local/bin:
</p>

<pre caption="Cambiare cartella con percorsi relativi">
$ <i>cd local/bin</i>
$ <i>pwd</i>
/usr/local/bin
</pre>

</body>
</section>
<section>
<title>Usare ..</title>
<body>

<p>
I percorsi relativi possono anche contenere una o più cartelle .. . La cartella
.. è una cartella speciale che punta alla cartella precedente (o parente).
Perciò, continuando dall'esempio precedente:
</p>

<pre caption="Usare la notazione 'cartella parente'">
$ <i>pwd</i>
/usr/local/bin
$ <i>cd ..</i>
$ <i>pwd</i>
/usr/local
</pre>

<p>
Come si può notare, la cartella corrente è ora /usr/local. L'utente è così
capace di andare "indietro" di una cartella, relativamente alla cartella in cui
si trova attualmente.
</p>

<p>
In aggiunta, è possibile anche aggiungere .. ad un percorso relativo esistente,
permettendo così di spostarsi in una cartella che è di fianco a quella in cui
siamo già, per esempio:
</p>

<pre caption="Usare la notazione cartella parente nei percorsi relativi">
$ <i>pwd</i>
/usr/local
$ <i>cd ../share</i>
$ <i>pwd</i>
/usr/share
</pre>

</body>
</section>
<section>
<title>Esempi di percorsi relativi</title>
<body>

<p>
I percorsi relativi possono diventare abbastanza complessi. Di seguito vengono
proposti alcuni esempi, tutti senza mostrare la cartella destinazione
risultante. Il lettore è invitato a cercare di capire dove andrà a finire dopo
aver digitato questi comandi:
</p>

<pre caption="Esempi di percorsi relativi">
$ <i>cd /bin</i>
$ <i>cd ../usr/share/zoneinfo</i>


$ <i>cd /usr/X11R6/bin</i>
$ <i>cd ../lib/X11</i>


$ <i>cd /usr/bin</i>
$ <i>cd ../bin/../bin</i>
</pre>

<p>
Ora, non resta che provarli e assicurarsi di avere indovinato.
</p>

</body>
</section>
<section>
<title>Capire .</title>
<body>

<p>
Prima di terminare la discussione in merito a cd, ci sono altre poche cose che
meritano una menzione. Primo, c'è un'altra cartella speciale chiamata . , che
indica "la cartella corrente". Mentre questa cartella non è usata con il comando
cd, viene spesso utilizzata per eseguire alcuni programmi nella cartella
corrente, come segue:
</p>

<pre caption="Eseuire un programma dalla posizione corrente">
$ <i>./mio_prog</i>
</pre>

<p>
Nell'esempio precedente, l'eseguibile mio_prog che risiede nella cartella di
lavoro corrente verrà eseguito.
</p>

</body>
</section>
<section>
<title>Il comando cd e la cartella home</title>
<body>

<p>
Per chi vuole spostarsi nella propria cartella home, può digitare:
</p>

<pre caption="Andare nella cartella HOME">
$ <i>cd</i>
</pre>

<p>
Senza argomenti, cd condurrà l'utente nella propria cartella home, che
corrisponde a /root per l'utente principale (superuser) e tipicamente a
/home/nome_utente per utenti normali. Vediamo come è possibile specificare un
file all'interno della propria cartella home. Probabilmente per passare un file
come argomento a <c>mio_prog</c>. Se il file risiede nella propria cartella
home, basta digitare:
</p>

<pre caption="Eseguire un programma nella cartella corrente">
$ <i>./mio_prog /home/drobbins/mio_file.txt</i>
</pre>

<p>
Comunque, usare un percorso assoluto come questo non è sempre conveniente.
Fortunatamente, è possibile usare il carattere ~ (tilde) per fare la stessa
cosa:
</p>

<pre caption="Usare la notazione 'cartella home'">
$ <i>./mio_prog ~/mio_file.txt</i>
</pre>

</body>
</section>
<section>
<title>Le cartelle home degli altri utenti</title>
<body>

<p>
Bash espanderà da solo ~ per puntare alla cartella home dell'utente, ma è
possibile anche usarlo per puntare alle cartelle home di altri utenti. Per
esempio, volendo riferirsi al file chiamato fred_file.txt nella cartella home di
Fred, dovrà essere digitato:
</p>

<pre caption="Esempio di uso della notazione 'cartella home'">
$ <i>./mio_prog ~fred/fred_file.txt</i>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Usare comandi Linux</title>
<section>
<title>Introduzione a ls</title>
<body>

<p>
Adesso, sarà data un'occhiata veloce al comando ls. Molto probabilmente, il
lettore sarà già familiare con ls e saprà che digitandolo da solo mostrerà la
lista dei contenuti della cartella di lavoro corrente:
</p>

<pre caption="Recuperare la lista dei file">
$ <i>cd /usr</i>
$ <i>ls</i>
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
</pre>

<p>
Specificando l'opzione -a, verranno mostrati tutti i file nella cartella,
compresi i file nascosti: quelli che iniziano con . . Come evidenzia il seguente
esempio, ls -a rivela i collegamenti alle cartelle speciali . e .. :
</p>

<pre caption="Recuperare la lista dei file, inclusi quelli nascosti">
$ <i>ls -a</i>
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
</pre>

</body>
</section>
<section>
<title>Recuperare la descrizione estesa delle cartelle</title>
<body>

<p>
Esiste la possibilità di specificare o o più file o cartelle come argomenti del
comando <c>ls</c>. Se viene specificato un file, <c>ls</c> mostrerà il dato file
solamente. Se viene specificata una cartella, <c>ls</c> mostrerà i
<e>contenuti</e> della cartella. L'opzione <c>-l</c> risulta davvero pratica
quando vi sia la necessità di vedere i permessi, possessore, ora di modifica e
informazioni sulla dimensione nel resoconto della propria cartella.
</p>

<p>
Nell'esempio che segue, verrà usata l'opzione <c>-l</c> per stampare a video una
lista completa in merito alla cartella /usr.
</p>

<pre caption="Recuperare la lista dei file con tutte  le informazioni">
$ <i>ls -l /usr</i>
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -&gt; share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -&gt; share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -&gt; share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -&gt; gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -&gt; ../var/tmp
</pre>

<p>
La prima colonna mostra informazioni sui permessi per ogni elemento della lista.
Verrà spiegato come interpretare questa informazione a breve. La colonna che
segue mostra il numero di collegamento di ogni oggetto del filesystem, che
ignoreremo al momento ma su cui torneremo in seguito. La terza e quarta colonna
mostrano il possessore e il gruppo, rispettivamente. La quinta colonna mostra la
dimensione dell'oggetto. La sesta colonna è l'ora di "ultima modifica" o "mtime"
dell'oggetto. L'ultima colonna è il nome dell'oggetto. Se il file è un
collegamento simbolico, sarà mostrato un -&gt; di seguito e il percorso a cui il
collegamento simbolico punta.
</p>

</body>
</section>
<section>
<title>Uno sguardo alle cartelle</title>
<body>

<p>
Talvolta, c'è la necessità di dare un'occhiata ad una cartella, piuttosto che al
suo interno. In questi casi, basterà specificare l'opzione <c>-d</c>, che dirà a
ls di guardare ad ogni cartella di cui normalmente considererebbe il contenuto:
</p>

<pre caption="Recuperare informazioni sulle cartelle">
$ <i>ls -dl /usr /usr/bin /usr/X11R6/bin ../share</i>
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
</pre>

</body>
</section>
<section>
<title>Recupero delle informazioni ricorsivo e sugli inode</title>
<body>

<p>
Quindi l'opzione <c>-d</c> può essere usata per rivolgersi ad una cartella, ma
esiste anche l'opzione <c>-R</c>per fare l'opposto: non limitarsi ad esplorare
una cartella ma ricorsivamente visitare tutti i file e le cartelle in essa
contenuti. Non sarà incluso alcun esempio di risultato per questa opzione (in
quanto è normalmente voluminoso) ma il lettore potrebbe voler provare qualche
comando come <c>ls -R</c> e <c>ls -Rl</c> per avere un'idea di come questi
operano.
</p>

<p>
Infine, l'opzione <c>-i</c> di ls può venire usata per mostrate il numero di
inode associato nel filesystem agli oggetti:
</p>

<pre caption="Recuperare informazioni sugli inode">
$ <i>ls -i /usr</i>
   1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
   1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
   8316 distfiles      1517 include                776 man            23779 src
     43 doc            1386 info                 93892 portage        36737 ssl
  70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
</pre>

</body>
</section>
<section>
<title>Capire gli inode</title>
<body>

<p>
Ogni oggetto su un filesystem è assegnato ad un indice unico, chiamato numero di
<e>inode</e>. Questo può sembrare insignificante ma capire gli inode è
fondamentale per capire molte delle operazioni su filesystem. Per esempio, basti
considerare i collegamenti . e .. che appaiono in ogni cartella. Per comprendere
pienamente cosa una cartella .. è effettivamente, bisogna prima dare uno sguardo
al numero di inode di /usr/local:
</p>

<pre caption="Recuperare le informazioni sull'inode per una cartella">
$ <i>ls -id /usr/local</i>
   5120 /usr/local
</pre>

<p>
La cartella /usr/local ha un numero di inode di 5120. Adesso, va preso in
considerazione il numero di inode di /usr/local/bin/.. :
</p>

<pre caption="Recuperare le informazioni sull'inode per una cartella">
$ <i>ls -id /usr/local/bin/..</i>
   5120 /usr/local/bin/..
</pre>

<p>
Come è possibile notare, /usr/local/bin/.. ha lo stesso numero di inode di
/usr/local . Bisogna spiegare come va affrontata questa rivelazione scioccante.
In precedenza, /usr/local è stata considerata la cartella stessa. Adesso, è
stato scoperto che di fatto è l'inode 5120 la cartella e sono state individuate
due voci di cartelle (chiamate "collegamenti") che puntano a questo inode. Sia
/usr/local che /usr/local/bin/.. sono collegamenti all'inode 5120. Anche se
l'inode 5120 esiste in una posizione unica sul disco, cose diverse sono ad esso
collegate. L'inode 5120 è la voce effettiva sul disco.
</p>

<p>
Infatti, è possibile vedere il numero totale di volte che l'inode 5120 è
referenziato usando il comando <c>ls -dl</c>:
</p>

<pre caption="Recuperare informazioni sui riferimenti all'inode">
$ <i>ls -dl /usr/local</i>
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
</pre>

<p>
Dando un'occhiata alla seconda colonna da sinistra, si nota che la cartella
/usr/local (inode 5120) viene referenziata otto volte. Sul sistema di chi sta
scrivendo, quelli che seguono sono i diversi percorsi che referenziano questo
inode:
</p>

<pre caption="Riferimenti all'inode">
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
</pre>

</body>
</section>
<section>
<title>mkdir</title>
<body>

<p>
Di seguito un'occhiata veloce al comando mkdir, che può essere usato per creare
nuove cartelle. L'esempio seguente crea tre nuove cartelle, tic, tac e toe,
tutte sotto /tmp:
</p>

<pre caption="Creare cartelle">
$ <i>cd /tmp</i>
$ <i>mkdir tic tac toe</i>
</pre>

<p>
Di base, il comando mkdir non crea le cartelle precedenti (anche dette cartelle
parente o padre) per l'utente; l'intero percorso dall'inizio al penultimo
elemento deve esistere già. Quindi, volendo creare le cartelle
<path>splen/di/do</path>, bisogna lanciare tre comandi <c>mkdir</c>separati:
</p>

<pre caption="Creare le cartelle padre nel percorso">
$ <i>mkdir splen/di/do</i>
mkdir: cannot create directory `splen/di/do': No such file or directory
$ <i>mkdir splen</i>
$ <i>mkdir splen/di</i>
$ <i>mkdir splen/di/do</i>
</pre>

<p>
Comunque, mkdir ha una pratica opzione -p che indica al comando di creare ogni
cartella parente mancante, come mostrato di seguito:
</p>

<pre caption="Creare le cartelle padre in una volta sola">
$ <i>mkdir -p gioco/da/ragazzi</i>
</pre>

<p>
Tutto sommato, davvero diretto. Per saperne di più riguardo al comando mkdir,
basta digitare <c>man mkdir</c> per leggerne la pagina di manuale. Questo
dovrebbe funzionare con quasi tutti i comandi discussi qui (per esempio, <c>man
ls</c>), eccetto per cd, che è incorporato con bash.
</p>

</body>
</section>
<section>
<title>touch</title>
<body>

<p>
Adesso, verrà dato uno sguardo veloce ai comandi <c>cp</c> e <c>mv</c>, usati
per copiare, rinominare e spostare file e cartelle. Per iniziare questa visione
d'insieme, useremo prima il comando <c>touch</c> per creare un file in /tmp:
</p>

<pre caption="Creare un file">
$ <i>cd /tmp</i>
$ <i>touch copiami</i>
</pre>

<p>
Il comando touch aggiorna il valore di "mtime" di un file se esistente (un
richiamo alla sesta colonna nel risultato di <c>ls -l</c>). Se il file non
esiste, allora verrà creato un nuovo file vuoto. Dovrebbe essere presente adesso
un file <path>/tmp/copiami</path> con dimensione pari a zero.
</p>

</body>
</section>
<section>
<title>echo</title>
<body>

<p>
Adesso che il file esiste, bisogna aggiungere in esso qualche dato. Questo può
essere fatto usando il comando echo, il quale prende il proprio argomento e lo
stampa sullo standard output. Primo, il comando echo da solo:
</p>

<pre caption="Creare un file usando 'echo'">
$ <i>echo "primo_file"</i>
primo_file
</pre>

<p>
Ora, lo stesso comando echo con una ridirezione dell'output:
</p>

<pre caption="Usare la redirezione dell'output">
$ <i>echo "primo_file" &gt; copiami</i>
</pre>

<p>
Il segno di maggiore indica alla shell di scrivere l'output di echo in un file
chiamato copiami. Questo file sarà creato se non esiste, altrimenti verrà
sovrascritto se già presente. Digitando <c>ls -l</c>, è possibile vedere che il
file copiami ha dimensione pari a 11 byte, dato che contiene la parola
primo_file e il carattere di a capo:
</p>

<pre caption="Vedere le informazioni sul file">
$ <i>ls -l copiami</i>
-rw-r--r--    1 root     root           11 Dec 28 14:13 copiami
</pre>

</body>
</section>
<section>
<title>cat e cp</title>
<body>

<p>
Per stampare il contenuto di un file sul terminale, usare il comando cat:
</p>

<pre caption="Vedere il contenuto di un file">
$ <i>cat copiami</i>
primo_file
</pre>

<p>
Ora, è possibile usare una invocazione di base del comando <c>cp</c> per creare
un file copiato (di nome e di fatto) dall'originale file copiami:
</p>

<pre caption="Copiare un file">
$ <i>cp copiami copiato</i>
</pre>

<p>
Indagando, l'utente scoprirà che questi sono veramente file separati; il loro
numero di inode è diverso:
</p>

<pre caption="Controllare le differenze sugli inode">
$ <i>ls -i copiami copiato</i>
  648284 copiami   650704 copiato
</pre>

</body>
</section>
<section>
<title>mv</title>
<body>

<p>
Adesso, andiamo ad usare il comando mv per rinominare "copiato" in "spostato".
Il numero di inode rimarrà lo stesso; comunque, il nome del file che punta
all'inode cambierà.
</p>

<pre caption="Rinominare un file">
$ <i>mv copiato spostato</i>
$ <i>ls -i spostato</i>
  648284 spostato
</pre>

<p>
Il numero di inode di un file spostato rimarrà lo stesso fino a che la
destinazione del file si trova sullo stesso filesystem del file sorgente. Verrà
data un'occhiata più da vicino ai filesystem nella Parte 3 di questa serie di
guide introduttive.
</p>

<p>
Parlando ancora di mv, vediamo un altro modo di usare questo comando. mv, oltre
a permettere di rinominare file, dà la possibilità anche di spostare uno o più
file in un altra posizione nella gerarchia di cartelle. Per esempio, per
spostare <path>/var/tmp/mio_file.txt</path> in <path>/home/drobbins</path> (che
risulta essere la cartella home dello scrittore) basta digitare:
</p>

<pre caption="Spostare un file in una posizione diversa">
$ <i>mv /var/tmp/mio_file.txt /home/drobbins</i>
</pre>

<p>
Dopo aver digitato questo comando, mio_file.txt sarà spostato in
<path>/home/drobbins/mio_file.txt</path>. E se <path>/home/drobbins</path> si
trova su un filesystem diverso da <path>/var/tmp</path>, il comando mv gestirà
la copia di mio_file.txt sul nuovo filesystem e lo cancellerà dall'attuale. Come
è possibile indovinare, quando mio_file.txt viene spostato fra filesystem, il
mio_file.txt nella nuova posizione avrà un nuovo numero di inode. Questo perché
ogni filesystem ha il proprio insieme indipendente di numeri di inode.
</p>

<p>
Esiste anche la possibilità di usare il comando mv per spostare più file in una
singola cartella di destinazione. Per esempio, per spostare mio_file1.txt e
mio_articolo3.txt in /home/drobbins, basterà digitare:
</p>

<pre caption="Spostare più file">
$ <i>mv /var/tmp/mio_file1.txt /var/tmp/mio_articolo3.txt /home/drobbins</i>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Creare collegamenti e rimuovere file</title>
<section>
<title>Hard link (Collegamenti fisici)</title>
<body>

<p>
Il termine "link" (collegamento) è stato usato in riferimento alla relazione fra
le voci delle cartelle (i "nomi" che vengono digitati) e gli inode (i numeri di
indice sul filesystem sottostante che possono essere normalmente ignorati). Ci
sono in realtà due tipi di collegamenti disponibili in Linux. Il tipo discusso
in precedenza è chiamato <e>hard link</e> (collegamento fisico). Un determinato
inode può avere un numero qualsiasi di hard link e l'inode continuerà ad
esistere sul filesystem fino a che tutti gli hard link non spariranno. Quando
l'ultimo hard link sparirà e nessun programma starà tenendo il file aperto,
Linux cancellerà il file automaticamente. Nuovi hard link possono essere creati
usando il comando <c>ln</c>:
</p>

<pre caption="Creare collegamenti a file">
$ <i>cd /tmp</i>
$ <i>touch primo_link</i>
$ <i>ln primo_link secondo_link</i>
$ <i>ls -i primo_link secondo_link</i>
  15782 primo_link    15782 secondo_link
</pre>

<p>
Come è possibile vedere, gli hard link lavorano a livello di inode per puntare
ad un particolare file. Su sistemi Linux, gli hard link hanno diverse
limitazioni. Per cominciare, si possono creare solamente hard link a file, non a
cartelle. Esatto; Anche se . e .. sono hard link creati dal sistema a cartelle,
all'utente (perfino come utente "root") non è permesso in alcun caso crearne di
propri. La seconda limitazione degli hard link è che questi non possono
attraversare i filesystem. Ciò significa che non può essere creato un link da
/usr/bin/bash a /bin/bash se le cartelle / e /usr esistono su filesystem
separati.
</p>

</body>
</section>
<section>
<title>Symbolic link (Collegamenti simbolici)</title>
<body>

<p>
In pratica, i collegamenti simbolici (o <e>symlink</e>) vengono usati più spesso
degli hard link. I symlink sono tipi speciali di file dove il collegamento si
riferisce ad un altro file per nome, piuttosto che direttamente ad un inode. I
symlink non prevengono il fatto che un file possa essere cancellato; se il file
puntato sparisce, allora il symlink sarà semplicemente inutilizzabile, o rotto.
</p>

<p>
Un collegamento simbolico può essere creato passando l'opzione -s a ln.
</p>

<pre caption="Uno sguardo ai collegamenti simbolici">
$ ln -s secondo_link terzo_link
$ ls -l primo_link secondo_link terzo_link
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 primo_link
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondo_link
lrwxrwxrwx    1 agriffis agriffis       12 Dec 31 19:39 terzo_link -&gt;
secondo_link
</pre>

<p>
I collegamenti simbolici possono essere distinti dai normali file nel risultato
di <c>ls -l</c> in tre modi. Primo, basta notare che al prima colonna contiene
un carattere l a indicare il collegamento simbolico. Secondo, la dimensione del
collegamento simbolico è il numero di caratteri del file puntato
(<c>secondo_link</c>, in questo caso). Terzo, l'ultima colonna del risultato
mostra il nome del file puntato preceduto da un piccolo grazioso -&gt;.
</p>

</body>
</section>
<section>
<title>Approfondimento sui collegamenti simbolici</title>
<body>

<p>
I collegamenti simbolici sono in generale più flessibili degli hard link. È
possibile creare un collegamento simbolico ad ogni tipo di oggetto sul
filesystem, incluse le cartelle. E poiché l'implementazione dei collegamenti
simbolici è basata su percorsi (non sugli inode), è assolutamente corretto
creare collegamenti simbolici che puntano ad un oggetto su un altro filesystem
fisico. Comunque, questo aspetto può anche rendere i collegamenti simbolici
difficili da capire.
</p>

<p>
Si consideri una situazione in cui è richiesta la creazione di un collegamento
in /tmp che punti a /usr/local/bin. Potrebbe bastare digitare quanto segue:
</p>

<pre caption="Collegamento a cartelle, primo tentativo">
$ <i>ln -s /usr/local/bin bin1</i>
$ <i>ls -l bin1</i>
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -&gt; /usr/local/bin
</pre>

<p>
O in alternativa:
</p>

<pre caption="Collegamento a cartelle, secondo tentativo">
$ <i>ln -s ../usr/local/bin bin2</i>
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt; ../usr/local/bin
</pre>

<p>
Come viene mostrato, entrambi i collegamenti simbolici puntano alla stessa
cartella. Comunque, se il secondo link viene poi spostato in un'altra cartelle,
risulterà "rotto" ("broken") a causa del percorso relativo:
</p>

<pre caption="Rompere un collegamento simbolico">
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt; ../usr/local/bin
$ <i>mkdir mia_nuova_cartella</i>
$ <i>mv bin2 mia_nuova_cartella</i>
$ <i>cd mia_nuova_cartella</i>
$ <i>cd bin2</i>
bash: cd: bin2: No such file or directory
</pre>

<p>
Dato che la cartella /tmp/usr/local/bin non esiste, l'utente non potrà più
spostarsi nella cartella bin2; in altre parole, bin2 è ora rotto.
</p>

<p>
Per questa ragione, è talvolta una buona idea evitare di creare collegamenti
simbolici con informazioni sul percorso relativo. Comunque, ci sono molti casi
in cui collegamenti simbolici relativi tornano utili. Basta considerare un
esempio in cui si voglia creare un nome alternativo per un programma in
/usr/bin:
</p>

<pre caption="Vedere le informazioni sul file keychain">
# <i>ls -l /usr/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
</pre>

<p>
Come utente root, potrebbe esserci la volontà di creare un nome alternativo per
"keychain", come "kc". In questo esempio, è usato l'accesso come root, come
evidenziato dal prompt bash cambiato in "#". È necessario l'accesso come root
perché utenti normali non sono abilitati a creare file in /usr/bin. Da root,
sarà possibile creare un nome alternativo per keychain come segue:
</p>

<pre caption="Creare un collegamento simbolico per keychain">
# <i>cd /usr/bin</i>
# <i>ln -s /usr/bin/keychain kc</i>
# <i>ls -l keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# <i>ls -l kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; /usr/bin/keychain
</pre>

<p>
Nell'esempio, è stato creato un collegamento simbolico chiamato kc che punta al
file /usr/bin/keychain.
</p>

<p>
Mentre questa soluzione funziona, creerà problemi nel caso venga deciso di
spostare entrambi i file, /usr/bin/keychain e /usr/bin/kc, in /usr/local/bin:
</p>

<pre caption="Spostare i collegamenti simbolici">
# <i>mv /usr/bin/keychain /usr/bin/kc /usr/local/bin</i>
# <i>ls -l /usr/local/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# <i>ls -l /usr/local/bin/kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; /usr/bin/keychain
</pre>

<p>
Dato che è stato usato un percorso assoluto nel proprio collegamento simbolico,
il symlink kc starà ancora puntando a /usr/bin/keychain, che non esiste più dato
che è stato spostato /usr/bin/keychain in /usr/local/bin.
</p>

<p>
Questo significa che kc è ora un symlink rotto. Entrambi i parcorsi assoluti e
relativi nei collegamenti simbolici hanno i loro meriti e l'utente potrebbe
usare un tipo di percorso che è appropriato per la sua particolare applicazione.
Spesso, sia i percorsi relativi che quelli assoluti operano abbastanza bene. Il
prossimo esempio dovrebbe funzionare anche dopo che entrambi i file sono stati
spostati:
</p>

<pre caption="Spostare file in giro con symlink">
# <i>cd /usr/bin</i>
# <i>ln -s keychain kc</i>
# <i>ls -l kc</i>
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -&gt; keychain
# <i>mv keychain kc /usr/local/bin</i>
# <i>ls -l /usr/local/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# <i>ls -l /usr/local/bin/kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; keychain
</pre>

<p>
Ora, è possibile eseguire il programma keychain digitando /usr/local/bin/kc.
/usr/local/bin/kc punta al programma keychain nella stessa cartella di kc.
</p>

</body>
</section>
<section>
<title>rm</title>
<body>

<p>
Adesso che sono stati affrontati cp, mv e ln, è il momento di imparare come
rimuovere oggetti dal filesystem. Normalmente, viene fatto tramite il comando
<c>rm</c>. Per rimuovere file, basta indicarli sulla riga di comando:
</p>

<pre caption="Rimuovere file">
$ <i>cd /tmp</i>
$ <i>touch file1 file2</i>
$ <i>ls -l file1 file2</i>
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
$ <i>rm file1 file2</i>
$ <i>ls -l file1 file2</i>
ls: file1: No such file or directory
ls: file2: No such file or directory
</pre>

<p>
Bisogna notare che in Linux, una volta che un file è cancellato, risulta di
norma eliminato per sempre. Per questa ragione, molti giovani amministratori di
sistema useranno l'opzione -i cancellando file. L'opzione -i dice ad rm di
rimuovere tutti i file in modalità interattiva -- ovvero, chiederà prima di
rimuovere ogni file. Per esempio:
</p>

<pre caption="Rimuovere file e chiedere conferma">
$ <i>rm -i file1 file2</i>
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
</pre>

<p>
Nell'esempio precedente, il comando rm chiede se i file indicati dovrebbero
*veramente* essere cancellati o meno. In modo che fossero cancellato, è stato
necessario digitare "y" e Enter (Invio) due volte. Se fosse stato digitato "n",
il file non sarebbe stato rimosso. O, se fosse stato fatto qualcosa di veramente
sbagliato, sarebbe bastato digitare Control-C per abortire completamente il
comando rm -i -- tutti ciò che avviene prima è capace di arrecare ogni
potenziale danno al proprio sistema.
</p>

<p>
Se ancora si desidera usare il comando rm, può risultare utile aggiungere la
linea seguente al proprio file ~/.bashrc usando l'editor di testi preferito,
quindi effettuare il logout e nuovamente il login. Adesso, ogni volta che viene
digitato rm, la shell bash lo convertirà automaticamente nel comando rm -i. In
questo modo, rm opererà sempre in modalità interattiva:
</p>

<pre caption="Impostare l'alias 'rm -i'">
<i>alias rm="rm -i"</i>
</pre>

</body>
</section>
<section>
<title>rmdir</title>
<body>

<p>
Per cancellare cartelle, si hanno due opzioni. Possono essere rimossi tutti gli
oggetti all'interno di una cartella e quindi usato <c>rmdir</c> per rimuovere la
cartella stessa:
</p>

<pre caption="Rimuovere cartelle">
$ <i>mkdir mia_dir</i>
$ <i>touch mia_dir/file1</i>
$ <i>rm mia_dir/file1</i>
$ <i>rmdir mia_dir</i>
</pre>

<p>
Questo metodo è comunemente indicato come "rimozione di cartelle per stupidi".
Tutti gli utenti esperti e gli amministratori degni di questo nome usano il
molto più conveniente comando <c>rm -rf</c>, spiegato di seguito.
</p>

<p>
Il miglior modo per cancellare una cartella è l'uso dell'opzione di <e>forzatura
ricorsiva</e> sul comando rm per indicare a rm di cancellare la cartella
specificata, così come tutti gli oggetti in essa contenuti:
</p>

<pre caption="Rimuovere completamente una cartella">
$ <i>rm -rf mydir</i>
</pre>

<p>
In genere, rm -rf è il metodo preferito per rimuovere un albero di cartelle.
Bisogna però fare molta attenzione nell'uso di rm -rf, in quanto la sua potenza
può essere usata in modo sia divino che diabolico.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Usare le wild card</title>
<section>
<title>Introduzione alle wild card</title>
<body>

<p>
Nell'uso giornaliero di Linux, ci sono molte situazioni in cui si ha la
necessità di effettuare una singola operazione (come un rm) su molti oggetti nel
filesystem tutti in una volta. In questi casi, può essere spesso tedioso
digitare molti nomi di file sulla riga di comando:
</p>

<pre caption="Rimuovere file individualmente">
$ <i>rm file1 file2 file3 file4 file5 file6 file7 file8</i>
</pre>

<p>
Per risolvere il problema, è possibile trarre vantaggio dal supporto integrato
in Linux per le wild card. Questo supporto, anche chiamato "globbing" (per
ragioni storiche), permette all'utente di indicare file diversi in una volta
usando un <e>pattern wildcard</e>. Bash e altri comandi Linux interpreteranno
questo pattern scrutando il disco e cercando ogni file che corrisponda. Quindi,
se sono presenti file da file1 fino a file8 nella cartella corrente, possono
essere rimossi digitando:
</p>

<pre caption="Rimuovere file usando il completamento della shell">
$ <i>rm file[1-8]</i>
</pre>

<p>
O, nei casi in cui semplicemente vi sia la necessità di rimuovere tutti i file
il cui nome comincia con file così come tutti i file chiamati file, basterà
digitare:
</p>

<pre caption="Rimuovere file usando il completamento della shell con il glob *">
$ <i>rm file*</i>
</pre>

<p>
La wildcard * trova riscontro con ogni carattere o sequenza di caratteri o
perfino "nessun carattere". Certamente, le glob wildcard possono essere usate
per molte più cose della semplice cancellazione di file, come sarà mostrato nel
paragrafo successivo.
</p>

</body>
</section>
<section>
<title>Capire le discordanze</title>
<body>

<p>
Nel caso in cui si desideri avere una lista di tutti gli oggetti del filesystem
presenti in /etc il cui nome inizia con g, così come tutti i file chiamati g,
basta digitare:
</p>

<pre caption="Esempio di uso del glob *">
$ <i>ls -d /etc/g*</i>
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
</pre>

<p>
Ma cosa succede se viene specificato un pattern (modello) che non corrisponde
con alcun oggetto del filesystem? Nell'esempio che segue, viene tentato di
ricavare la lista di tutti i file in /usr/bin che iniziano con asdf e finiscono
con jkl, incluso potenzialmente il file asdfjkl:
</p>

<pre caption="Un altro esempio del glob *">
$ <i>ls -d /usr/bin/asdf*jkl</i>
ls: /usr/bin/asdf*jkl: No such file or directory
</pre>

<p>
Ecco cos'è successo. Normalmente, quando viene specificato un pattern, esso si
abbina ad uno o più file sul filesystem sottostante, e <e>bash rimpiazza il
modello con una lista, avente le voci separate da spazi, di tutti gli oggetti
che coincidono</e>. Tuttavia, quando il pattern non produce nessuna
corrispondenza, <e>bash lascia intatto l'argomento, wild card e tutto il resto,
così com'è</e>. Quindi, così facendo ls non può trovare il file
/usr/bin/asdf*jkl e consegna all'utente un messaggio d'errore. La regola
operativa in questi casi  è che <e>i modelli glob (glob pattern) sono espansi
solo se corrispondenti ad oggetti nel filesystem</e>. Altrimenti rimangono come
sono e vengono letteralmente passati al programma che è stato chiamato.
</p>

</body>
</section>
<section>
<title>Sintassi delle wild card: * e ?</title>
<body>

<p>
Adesso che è stato mostrato come operano i globbing, è doveroso dare uno sguardo
alla sintassi delle wild card. Possono essere usati caratteri speciali per
l'espansione delle wild card:
</p>

<p>
Con * vengono riscontrati zero o più caratteri. Ciò significa "ogni cosa può
andare qua, anche niente". Per esempio:
</p>

<ul>
  <li>
    /etc/g* indica tutti i file in /etc che iniziano con g, o un file chiamato
    g.
  </li>
  <li>
    /tmp/mio_*1 indica tutti i file in /tmp che iniziano con mio_ e finiscono
    con 1, incluso il file mio_1.
  </li>
</ul>

<p>
Con ? viene riscontrato ogni carattere singolarmente. Per esempio:
</p>

<ul>
  <li>
    mio_file? corrisponde ad ogni file il cui nome consiste in mio_file seguito
    da un singolo carattere
  </li>
  <li>
    /tmp/note?txt corrisponderà sia a /tmp/note.txt che a /tmp/note_txt, se
    questi esistono
  </li>
</ul>

</body>
</section>
<section>
<title>Sintassi delle wild card: []</title>
<body>

<p>
Questa wild card è simile a ?, ma permette di essere più specifici. Per usare
questa wild card, bisogna porre ogni carattere che si desidera sia concorde
all'interno di []. L'espressione risultante riscontrerà una singola occorrenza
di ognuno di questi caratteri. È possibile anche usare - per specificare un
intervallo e perfino combinare intervalli. Per esempio:
</p>

<ul>
  <li>
    mio_file[12] concorderà con mio_file1 e mio_file2. La wild card sarà espansa
    purché almeno uno di questi file esista nella cartella corrente.
  </li>
  <li>
    [Cc]hange[Ll]og riscontrerà Changelog, ChangeLog, changeLog, e changelog.
    Come è possibile vedere, l'uso della wild card parentesi può essere utile
    per rilevare variazioni nella scrittura in maiuscolo.
  </li>
  <li>
    ls /etc/[0-9]* restituirà la lista di tutti i file in /etc che iniziano con
    un numero.
  </li>
  <li>
    ls /tmp/[A-Za-z]* restituirà la lista di tutti i file in /tmp che iniziano
    con una lettera maiuscola o minuscola.
  </li>
</ul>

<p>
Il costrutto [!] è simile al costrutto [], eccetto che piuttosto che riscontrare
qualsiasi carattere all'interno delle parentesi, effettuerà la corrispondenza
con ogni carattere, purché questo non sia presente nella lista compresa fra [! e
]. Per esempio:
</p>

<ul>
  <li>
    rm mio_file[!9] rimuoverà tutti i file chiamati mio_file più un singolo
    carattere, eccetto mio_file9
  </li>
</ul>

</body>
</section>
<section>
<title>Rischi nell'uso delle wild card</title>
<body>

<p>
Di seguito vengono elencate alcune cose a cui fare attenzione quando si usano le
wild card. Dato che bash tratta i caratteri relativi alle wild card (?, [, ] e
*) in modo speciale, bisogna fare attenzione particolare quando si digitano in
un argomento per un comando che contiene questi caratteri. Per esempio, laddove
si voglia creare un file che contiene la stringa [fo]*, il seguente comando
potrebbe non fare ciò che si vuole:
</p>

<pre caption="Uso errato dei caratteri speciali">
$ <i>echo [fo]* &gt; /tmp/mio_nuovo_file.txt</i>
</pre>

<p>
Se il pattern [fo]* concorda con ogni file nella cartella di lavoro corrente,
allora troveremo i nomi di questi file all'interno di /tmp/mio_nuovo_file.txt
piuttosto che il letterale [fo]* come ci si aspetta. La soluzione? Bene, un
approccio è quello di circondare i propri caratteri con apici singoli, che
comunica a bash di non effettuare assolutamente alcuna espansione delle wild
card su di essi:
</p>

<pre caption="Eludere i caratteri speciali">
$ <i>echo '[fo]*' &gt; /tmp/mio_nuovo_file.txt</i>
</pre>

<p>
Usando questo approccio, il nuovo file conterrà un letterale [fo]* come ci si
aspettava. In alternativa, possono essere usate le barre inverse (backslash) di
escaping per indicare a bash che [, ] e * dovrebbero essere trattati
letteralmente piuttosto che come wild card:
</p>

<pre caption="Effettuare l'escaping di caratteri speciali, seconda possibilità">
$ <i>echo \[fo\]\* &gt; /tmp/mio_nuovo_file.txt</i>
</pre>

<p>
Entrambi gli approcci (apici singoli o barre inverse di escaping) hanno lo
stesso effetto. Dato che si sta discutendo dell'espansione delle barre inverse,
questo è un ottimo momento per dire che per specificare un letterale \, è
possibile sia includere quest'ultimo fra apici singoli così com'è che digitare
invece \\ (sarà espanso in \).
</p>

<note>
Gli apici doppi operano in modo simile agli apici singoli, ma permettono ancora
limitatamente a bash di fare alcune espansioni. Perciò, gli apici singoli devono
essere la scelta preferita quando l'utente è sinceramente interessato nel
passare testo letterale ad un comando. Per maggiori informazioni sull'espansione
delle wild card, digitare <c>man 7 glob</c>. Per maggiori informazioni sugli
apici in bash, digitare <c>man 8 glob</c> e leggere la sezione intitolata
QUOTING. In caso si pianifichi di sostenere gli esami del LPI, considerare
quanto sopra come un compito per casa.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Sommario e risorse</title>
<section>
<title>Sommario</title>
<body>

<p>
Congratulazioni; è giunta la fine di questo articolo sui fondamenti di Linux.
L'autore si augura che possa essere stato d'aiuto nel solidificare le fondamenta
della propria conoscenza di Linux. Gli argomenti imparati qua, inclusi i
fondamenti di bash, i comandi di base per Linux, collegamenti (link) e wild
card, hanno gettato le fondamenta per la prossima breve guida
sull'amministrazione di base, in cui saranno coperti argomenti come le
espressioni regolari, proprietà e permessi, gestione degli account utente e
altro ancora.
</p>

<p>
Continuando in questa serie di brevi guide, il lettore sarà presto pronto per
raggiungere la propria Certificazione LPIC di Livello 1 del Linux Professional
Institute. Parlando di certificazione LPIC, se questo è ciò a cui è interessato
il lettore, si raccomanda di studiare le Risorse indicare nel paragrafo
successivo, le quali sono state attentamente selezionate per completare il
materiale coperto in questa breve guida.
</p>

</body>
</section>
<section>
<title>Risorse</title>
<body>

<p>
Nella serie di articoli "Bash by example" (Bash tramite esempi) su
developerWorks, Daniel mostra al lettore come usare i costrutti della
programmazione bash per scrivere i propri script in bash. Questa serie (in
particolare Parte 1 e 2) rappresenta una buona preparazione per l'esame LPIC di
Livello 1:
</p>

<ul>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p1.xml">Bash per esempi, Parte
    1: Fondamenti di programmazione nella Bourne-again shell (bash)</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p2.xml">Bash per esempi, Parte
    2: Ulteriori fondamenti di programmazione bash</uri>
  </li>
  <li>
    <uri link="/doc/it/articles/bash-by-example-p3.xml">Bash per esempi, Parte
    3: Esplorare il sistema ebuild</uri>
  </li>
</ul>

<p>
Gli utenti novizi o intermedi di Linux dovrebbero sentirsi in dovere con se
stessi di esaminare le FAQ Tecniche per utenti Linux, una lista di 50 pagine
approfondite riguardo domande frequenti su Linux, insieme a risposte
dettagliate. Le FAQ stesse sono in formato PDF (Acrobat).
</p>

<p>
Per chi non fosse così familiare con l'editor vi, fare riferimento alla breve
guida su developerWorks chiamata Intro to vi (Introduzione a Vi). Questa
fornisce al lettore una semplice e molto veloce introduzione a questo potente
editor di testo. Bisogna considerare questo come materiale da leggere se non si
sa come usare vi.
</p>

</body>
</section>
</chapter>
</guide>