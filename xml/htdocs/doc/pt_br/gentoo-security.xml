<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/gentoo-security.xml,v 1.9 2005/05/03 23:23:20 vanquirius Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/pt_br/gentoo-security.xml">
<title>O guia de segurança do Gentoo Linux</title>
<author title="Autor">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
	<mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Editor">
  <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
</author>
<author title="Tradutor">
  <mail link="vanquirius@gentoo.org">Marcelo Góes</mail>
</author>

<abstract>
Este é um guia passo-a-passo para deixar o Gentoo Linux mais seguro.
</abstract>

<license/>

<version>0.4.47</version>
<date>2005-05-03</date>

<chapter>
<title>Introdução</title>
<section>
<body>

<p>
Este guia é feito para pessoas que estão usando o Gentoo Linux em um ambiente
de servidores ou simplesmente sentem a necessidade de maior segurança.
</p>

<note>
Se você estiver interessado em mais segurança do Gentoo depois de ler este
guia, então veja o <uri
link="http://www.gentoo.org/proj/en/hardened/">Projeto do Gentoo Hardened</uri>
</note>

</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Problemas da pré-instalação</title>
<section>
<title>Segurança física</title>
<body>

<p>
Não importa quantas medidas de segurança você implementar, todas podem ser facilmente contornadas
por um indivíduo malicioso com acesso físico a seu computador. Apesar disso, existem
algumas medidas que podem ser tomadas para fornecer um maior grau de segurança contra
um indivíduo malicioso com acesso físico a sua máquina. Colocar o hardware em um
um armário fechado previne que um indivíduo simplesmente desconecte ela e leve-a
embora. Travar o gabinete do computador também é uma boa idéia, para ter certeza de que
um indivíduo malicioso não possa simplesmente levar seu disco rígido. Para prevenir que um indivíduo malicioso
carregue a partir de outro disco, contornando de maneira sutil suas restrições de permissões e
login, experimente configurar o disco rígido como primeiro dispositivo de inicialização em seu BIOS,
e configurar uma senha de BIOS. Também é importante colocar senhas de inicialização para o LILO
ou GRUB, para prevenir que um usuário malicioso entre em modo de único usuário e
obtenha acesso completo a seu sistema. Isto é coberto em mais detalhe no
Capítulo 3, em <uri link="#passwording_GRUB">Configurando uma senha de GRUB</uri>
e <uri link="#passwording_LILO">Configurando uma senha de LILO</uri>.
</p>

</body>
</section>
<section>
<title>Planejamento de daemons/serviços</title>
<body>
<p>
Comece documentando que serviços a máquina deve rodar. Isto irá ajudar você
a compor um melhor esquema de particionamento para seu sistema, e permitir que você planeje melhor
suas medidas de segurança. Claro, isto é desnecessário se sua máquina serve um
único propósito, como um desktop, ou firewall dedicada. Nestes
casos, você não deve rodar <e>nenhum</e> serviço, fora talvez sshd.
</p>
<p>
A lista pode ser usada para ajudar na administração de sistemas. Mantendo uma lista
atualizada de informações, você achará mais fácil manter tudo
atualizado se uma vulnerabilidade remota for descoberta em um de seus daemons.
</p>

</body>
</section>
<section>
<title>Esquemas de particionamento</title>
<body>

<p>
Regras de particionamento:
</p>

<ul>
<li>
  Qualquer árvore de diretórios em que um usuário deve poder escrever (como <path>/home</path>,
  <path>/tmp</path>) deve estar em uma partição separada e usar quotas de disco. Isto
  reduz o risco de um usuário encher seu sistema de arquivos. O Portage
  usa <path>/var/tmp</path> para compilar os arquivos, então a partição deve ser grande.
</li>
<li>
  Qualquer árvore de diretórios onde você planeja instalar software alheio a distribuição deve
  estar em uma partição separada. De acordo com o <uri link =
  "http://www.pathname.com/fhs/">Padrão da hierarquia de arquivos</uri>, este lugar
  é <path>/opt</path> ou <path>/usr/local</path>. Se estas forem partições
  separadas, eles não serão apagados se você precisar re-instalar o sistema.
</li>
<li>
  Para segurança adicional, dados estáticos podem ser colocados em uma partição separada que é
  montada como somente leitura. Para os paranóides, experimente usar mídia de somente leitura como
  CD-ROM.
</li>
</ul>

</body>
</section>
<section>
<title>O usuário administrador (root)</title>
<body>

<p>
O usuário 'root' é usuário mais vital no sistema e não deve ser
usado para qualquer coisa fora quando absolutamente necessário. Se um usuário malicioso obtiver acesso
de root, o único jeito de confiar em seu sistema de novo é re-instalar.
</p>

<p>
Regradas douradas sobre o 'root'
</p>

<ul>
<li>
  Sempre crie um usuário para uso rotineiro e se o usuário precisar de acesso de
  root, adicione o usuário ao grupo 'wheel'. Isto possibilita que um usuário 
  normal faça <c>su</c> para root.
</li>
<li>
  Nunca rode o X ou qualquer outra aplicação de usuário como root. root só deve ser usado quando
  absolutamente necessário; se uma vulnerabilidade existir em uma aplicação rodando como um
  usuário, o indivíduo malicioso pode obter acesso de nível de usuário. Mas se a aplicação estiver rodando
  como root, o indivíduo obtém acesso de root.
</li>
<li>
  Sempre use caminhos completos quando logado como root (ou sempre use <c>su -</c>,
  que substitui as variáveis de ambiente do usuário com as de root,
  tendo certeza que o <c>PATH</c> do root só inclui diretórios protegidos
  como <path>/bin</path> e <path>/sbin</path>). É possível enganar
  o root para rodar uma aplicação diferente da que você quis
  rodar. Se o <c>PATH</c> do root for protegido ou o root só usar caminhos completos, nós podemos
  ter certeza de que isso não acontecerá.
</li>
<li>
  Se um usuário só precisa rodar alguns comandos como root, ao invés de dá-lo tudo que
  um root normalmente pode fazer, considere usar <c>sudo</c> ao invés disso. Só tenha cuidado para
  quem você dá acesso, também!
</li>
<li>
  Nunca deixe o terminal quando você estiver logado como root.
</li>
</ul>

<p>
O Gentoo tem algumas proteções padrões contra usuários normais tentando fazer <c>su</c> para
root. O ajuste padrão do PAM necessita que um usuário seja membro do grupo
"wheel" para poder usar <c>su</c>.
</p>

</body>
</section>
<section id = "security_policies">
<title>Políticas de segurança</title>
<body>

<p>
Existem várias razões para desenhar uma política de segurança para seu sistema(s) e
a rede.
</p> 

<ul>
<li>
  Uma boa política de segurança permite desenhar a segurança como um "sistema", ao invés
  de uma simples mistura de funções diferentes. Por exemplo, sem uma política um
  administrador pode decidir desligar o telnet, porque ele transmite
  senhas sem criptografia, mas deixar acesso FTP, que tem a mesma fraqueza. Uma
  boa política de rede ajuda a identificar que medidas de segurança valem
  a pena, e as que não valem.
</li>
<li>
  Para diagnosticar problemas, conduzir auditorias, ou procurar intrusos, pode
  ser necessário interceptar tráfico de rede, inspecionar o login e histórico de
  comandos dos usuários, e olhar em seus diretórios de home. Sem dizer isso por
  escrito, e tornando os usuários cientes, tais ações podem ser ilegais
  e colocar <e>você</e> em problemas legais.
</li>
<li>
  Contas de usuários seqüestradas são uma das ameaças mais comuns à segurança
  de sistemas. Sem explicar aos usuários porque a segurança é importante, e como
  praticar boa segurança (como não escrever senhas em um post-it grudado em
  suas mesas), é improvável que você tenha qualquer chance de contas de usuário seguras.
</li>
<li>
  Uma rede bem documentada e arranjo de sistema ajudarão você, bem como
  examinadores forenses criminais, se necessário, em rastrear uma intrusão e
  identificar fraquezas após o fato. Um banner de política de segurança "enviado sob demanda"
  dizendo que seu sistema é uma rede privada e acesso sem autorização é
  proibido, também ajudará na capacidade de processar um
  intruso, uma vez que seja pego.
</li>
</ul>

<p>
A necessidade de uma boa política de rede, esperamos, está mais que claro.
</p>

<p>
A política em si é um documento, ou vários documentos, que desenham a rede
e funções do sistema (como que serviços são fornecidos), uso aceitável e
uso proibido, "melhores práticas" de segurança, e assim em diante. Todos usuários devem estar
cientes de sua política de segurança, bem como mudanças que você fizer para mantê-la
atualizada. É importante que você tome o tempo para ajudar os usuários entenderem sua
política e porque a política precisa ser assinada ou o que acontecerá se agirem
diretamente contra a política (a política deve dizer isso também). Isto deve ser
repetido pelo menos uma vez por ano, já que a política pode mudar (mas também como
um lembrete ao usuário da política em si).
</p>

<note>
Crie políticas que são fáceis de ler e seja bem preciso em cada assunto.
</note>

<p>
Uma política de segurança deve no mínimo conter os seguintes assuntos:
</p>

<ul>
<li>Uso aceitável
  <ul>
  <li>Proteções de tela</li>
  <li>Cuidados com senhas</li>
  <li>Baixando e instalando software</li>
  <li>Informação dizendo se os usuários estão sendo monitorados</li>
  <li>Uso de software de anti-vírus</li>
  </ul>
</li>
<li>Cuidados com informações sigilosas (qualquer forma escrita, papel ou digital)
  <ul>
  <li>Mesa limpa e informações confidenciais em local trancado</li>
  <li>Desligando o PC antes de sair</li>
  <li>Uso de criptografia</li>
  <li>Cuidados com chaves para colegas de trabalho confiáveis</li>
  <li>Cuidados com material confidencial quando for viajar</li>
  </ul>
</li>
<li>Cuidados com equipamentos de computador quando viajando
  <ul>
  <li>Cuidados com laptops durante viagens e estadias em hotéis</li>
  </ul>
</li>
</ul>

<p>
Diferentes usuários podem precisar de diferentes níveis ou tipos de acesso, e assim
sua política pode variar para acomodar todos.
</p>

<p>
A política de segurança pode tornar-se enorme, e informações vitais podem ser facilmente
esquecidas. A política do departamento de TI pode conter informações que são confidenciais
para o usuário normal, então é inteligente dividi-la em políticas menores;
como política de uso aceitável, política de senhas, política de e-mail e política de acesso
remoto.
</p>

<p>
Você pode encontrar exemplos de políticas em <uri
link="http://www.sans.org/resources/policies/">O projeto de políticas de segurança 
do SANS</uri>. Se você tem uma rede pequena e acha que essas políticas são um pouco demais
você deve olhar o <uri
link="ftp://ftp.isi.edu/in-notes/rfc2196.txt">Manual de segurança
de site</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Melhorando a segurança durante e após a instalação</title>
<section>
<title>Opções de USE</title>
<body>

<p>
O arquivo <path>make.conf</path> contém opções de USE definidas por usuário e o
<path>/etc/make.profile/make.defaults</path> contém as opções de USE padrões para
o Gentoo Linux. Para o propósito deste guia, as opções importantes são <c>pam</c>
(Pluggable Authentication Modules), <c>tcpd</c> (TCP wrappers), e <c>ssl</c>
(Secure Socket Layer). Todos esses são opções de USE padrão.
</p>

</body>
</section>
<section id = "passwording_GRUB">
<title>Protegendo o GRUB com senha</title>
<body>

<p>
O GRUB suporte dois jeitos diferentes de adicionar proteção de senhas a seu gerenciador
de inicialização. O primeiro usa texto puro, enquanto o seguinte usa criptografia de md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password mudeme
</pre>

<p>
Isto irá adicionar a senha <c>mudeme</c>. Se nenhuma senha for entrada durante a inicialização,
o GRUB simplesmente irá usar a configuração de inicialização padrão.
</p>

<p>
Para adicionar uma senha md5, você deve converter sua senha em formato criptográfico (crypt),
que é o mesmo formato usado no <path>/etc/shadow</path>. Para mais informações
veja <c>man crypt</c>. A senha criptografada <e>mudeme</e>, por exemplo, poderia
parecer-se com isso: <c>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs</c>.
</p>

<p>
Você pode criptografar sua senha diretamente no shell do GRUB:
</p>

<pre caption="criptografia md5 no shell do grub">
#<i>/sbin/grub</i>

GRUB version 0.92 (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported. For the first word, TAB lists
     possible command completions. Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<comment>(Digitamos mudeme no prompt)</comment> 
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Agora, corte e cole sua senha em <path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5 
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
A espera de 5 segundos torna-se útil se o sistema for remoto e capaz de
reiniciar sem qualquer interação com teclado. Aprenda mais sobre as senhas do GRUB
executando <c>info grub</c>.
</p>

</body>
</section>
<section id = "passwording_LILO">
<title>Protegendo o LILO com senha</title>
<body>

<p>
O LILO também suporte dois jeitos de lidar com senhas: global e por imagem, ambos em
texto normal.
</p>

<p>
A senha global é colocada no começo do arquivo de configuração, e aplica-se a
todas imagens de boot:
</p>

<pre caption="/etc/lilo.conf">
password=mudeme 
restricted 
delay=3
</pre>

<p>
A senha por imagem é configurada abaixo:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage 
      read-only 
      password=mudeme 
      restricted
</pre>

<p>
Se a opção <c>restricted</c> não for digitada, ele irá pedir a senha
toda vez.
</p>

<p>
Para guardar as novas informações do <path>lilo.conf</path>, você deve rodar
<c>/sbin/lilo</c>.
</p>

</body>
</section>
<section>
<title>Restringindo o uso do console</title>
<body>

<p>
O arquivo <path>/etc/securetty</path> permite que você especifique em que dispositivos <c>tty</c>
(terminais) o administrador (root) pode fazer log-in.
</p>

<p>
Nós sugerimos que você comente todas linhas fora <c>vc/1</c>. Isto irá certificar
que o root somente pode fazer log-in uma vez e somente em um terminal.
</p>

<note>
Usuários no grupo "wheel" podem ainda fazer <c>su -</c> para virar root em outros TTYs.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Mais registros</title>
<section>
<body>

<p>
Mias registros devem ser adicionados para pegar avisos ou erros que podem indicar
um ataque em progresso ou uma invasão com sucesso. Indivíduos maliciosos freqüentemente escaneiam ou fazem sondas
antes de atacar.
</p>

<p>
Também é vital que seus arquivos de registro são de facil legibilidade e manuseio. O Gentoo
Linux permite que você escolha 3 loggers diferentes durante a instalação.
</p>

</body>
</section>
<section>
<title>Registros: syslogd</title>
<body>

<p>
O syslogd é o logger mais comum para Linux e Unix em geral. Ele não vem
com rotação de registros. Esta função é feita rodando
<path>/usr/sbin/logrotate</path> em um serviço de cron (o logrotate é configurado em
<path>/etc/logrotate.conf</path>). A freqüência com que a rotação de arquivos deve ser feita depende
na carga do sistema.
</p>

<p>
Abaixo está o <path>syslog.conf</path> padrão com algumas funções adicionais. Nós
descomentamos as linhas <c>cron</c> e <c>tty</c> e adicionamos um servidor de
registros locais. Para melhorar a segurança você pode adicionar registros em dois locais.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf      Arquivo de configuração para o syslogd.
#
#                       Para mais informações leia as manpages syslog.conf(5).
#                       Isto vem do Debian, estamos usando por enquanto
#                       Daniel Robbins, 5/15/99

#
# Primeiro alguns arquivos de log padrão. Arquivo por instalação.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Registros para o sistema de correios. Dividido para
# facilitar a escrita de scripts para interpretar os arquivos
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Registros para sistemas de news INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Alguns arquivos de registro `pega-todos'.
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Emergências e alertas são enviados para todos logados.
#
*.emerg                         *
*.=alert                        *

#
# Eu gosto de ter mensagens mostradas no console, mas em um console
# virtual normalmente deixo ocioso.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

#Configurar um servidor de registros remoto
*.*                        @logserver

# O pipe nomeado /dev/xconsole é para o utilitário `xconsole'. Para usá-lo,
# você deve invocar `xconsole' com a opção `-file':
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: ajuste a linha abaixo, ou você ficará louco se você tiver um
#      site grande..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                --/var/log/ppp.log
</pre>

<p>
Indivíduos maliciosos quase certamente irão tentar apagar seus traços tanto editando como apagando arquivos
de registros. Você pode dificultar a vida deles registrando em um ou mais servidores de registro
remotos em outras máquinas. Obtenha mais informação sobre o syslogd executando <c>man
syslog</c>.
</p>

</body>
</section>
<section>
<title>Metalog</title>
<body>

<p>
O <uri link="http://metalog.sourceforge.net">metalog</uri> de Frank Dennis não é
capaz de registrar em um servidor remoto, mas ele tem vantagens em relação a
performance e flexibilidade de registros. Ele pode fazer registros por nome de programa, urgência,
instalação (como o syslogd), e vem com analisador de expressões regulares (regex) que você
pode usar para iniciar scripts externos quando certos padrões são encontrados. Ele também é muito bom
em tomar ações quando necessárias.
</p> 

<p>
A configuração padrão é geralmente suficiente. Se você quiser se notificado por
e-mail quando um erro com senhas ocorrer use um dos seguintes scripts.
</p>

<p>
Para postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Para qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Lembre-se de fazer o script executável rodando <c>/bin/chmod +x 
/usr/local/sbin/mail_pwd_failures.sh</c>
</p>

<p>
Então descomente a linha de comando debaixo de "Erros de senha" no
<path>/etc/metalog/metalog.conf</path> assim:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Syslog-ng</title>
<body>

<p>
O syslog-ng fornece algumas das mesmas funções do syslog e metalog com uma pequena
diferença. Ele pode filtrar mensagens com base no nível e conteúdo (como o metalog),
fornecer registro remoto como o syslog, lidar com registros do syslodg (mesmo correntes do
Solaris), escrever em um TTY, executar programas, e pode agir como um servidor de registros.
Basicamente é o melhor dos dois loggers combinados com configuração avançada.
</p>

<p>
Abaixo está o arquivo de configuração clássica levemente modificado.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#fonte de onde ler o registro
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#definir destinos
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#criar filtros
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#conectar filtro e destino
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#registro padrão
log { source(src); destination(console_all); };
</pre>

<p>
O syslog-ng é muito fácil de configurar, mas também é muito fácil de esquecer de algo
no arquivo de configuração já que é enorme. O autor ainda promete algumas funções
adicionais como criptografia, autenticação e controle de MAC (Mandatory Access
Control). Com essas opções será perfeito para registros de rede,
já que o indivíduo malicioso não podera espiar o registro.
</p>

<p>
E o syslog-ng ainda tem outra vantagem: não tem que ser rodado como administrador (root)!
</p>

</body>
</section>

<section>
<title>Análise de registros com o Logcheck</title>
<body>

<p>
Lógico, cuidar de registros sozinhos é só metade da batalha. Uma aplicação como o
Logcheck pode tornar a análise de registros mais fácil. O Logcheck é um script,
acompanho de um binário chamado <c>logtail</c>, que roda de seu daemon do cron
e verifica atividades suspeitas em seus arquivos contra um conjunto de regras. Ele então
manda a saída como correio para a caixa de entrada do root.
</p>
<p>
Logcheck e logtail são parte do pacote <c>app-admin/logsentry</c>.
</p>
<p>
O Logcheck usa quatro arquivos para filtras entradas de registro importantes das não
importantes. Esses arquivos são <path>logcheck.hacking</path>, que contém mensagens
conhecidas de ataques de invasão, <path>logcheck.violations</path>, que contém
padrões indicando violações
de segurança, <path>logcheck.violations.ignore</path>, que contém palavras-chave
provavelmente relacionadas com o arquivo de violações, permitindo que entradas normais sejam
ignoradas, e  <path>logcheck.ignore</path>, que mantém aquelas entradas a serem
ignoradas.
</p>

<warn>
Não deixe o <path>logcheck.violations.ignore</path> em branco. O Logcheck
usa <c>grep</c> para interpretar registros, algumas versões dele tomarão um arquivo vazio
como um wildcard. Todas violações serão, portanto, ignoradas.
</warn>
<!-- FIXME: Might want to add more details on logcheck here...I have to install
it on Gentoo to figure out how it's configured! -->
</body>
</section>

</chapter>

<chapter>
<title>Montando partições</title>
<section>
<body>

<p>
Na hora de montar uma partição <c>ext2</c>, <c>ext3</c>, ou <c>reiserfs</c>, você
tem várias opções que pode aplicar ao arquivo <path>/etc/fstab</path>. As
opções são:
</p>

<ul>
<li>
  <c>nosuid</c> - Irá ignorar o bit de SUID e tratá-lo como um
  arquivo normal
</li>
<li>
  <c>noexec</c> - Irá prevenir a execução de arquivos da partição
</li>
<li>
  <c>nodev</c> - Ignora dispositivos
</li>
</ul>

<p>
Infelizmente, esses ajustes podem ser facilmente contornados ao executar um
caminho não direto. No entanto, configurando <path>/tmp</path> para noexec irá parar
a maioria dos exploits desenhados para serem executados diretamente de <path>/tmp</path>.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Colocar <path>/tmp</path> como modo <c>noexec</c> pode impedir que certos scripts
executem adequadamente..
</warn>

<note>
Para cotas de disco veja <uri link="#doc_chap6_sect3">a seção de cotas</uri>.
</note>

<note>
Eu não configurei <path>/var</path> como <c>noexec</c> ou <c>nosuid</c>, mesmo se arquivos
são normalmente executados deste ponto de montagem. A razão para isso é que o
qmail está instalado em <path>/var/qmail</path> e precisa poder executar
e acessar um arquivo SUID. Eu configurei <path>/usr</path> em modo de somente leitura já que eu
nunca escrevo nada ali a menos que queira atualizar o Gentoo. Então eu re-monto o
sistema de arquivos em modo de leitura-escrita, atualizo e re-monto novamente.
</note>

<note>
Mesmo se você não usa qmail, o Gentoo ainda precisa de bit executável em
<path>/var/tmp</path> já que as ebuilds são construídas lá. Mas um caminho alternativo pode
ser configurado se você insiste em ter <path>/var</path> montada em modo
<c>noexec</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Limitações de usuário/grupo</title>
<section id = "limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
Controlar a usagem de recursos pode ser muito eficáz na hora de prevenir um ataque de
Denial of Service local ou restringir o número de log-ins máximos permitidos para um grupo ou usuário.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core 0
*    hard core 0
*    hard nproc 15
*    hard rss 10000
*    -    maxlogins 2
@dev hard core 100000
@dev soft nproc 20
@dev hard nproc 35
@dev -    maxlogins 10
</pre>

<p>
Se você encontra-se tentando configurar <c>nproc</c> ou <c>maxlogins</c> em 0, talvez
seja melhor apagar o usuário. O exemplo acima configura os ajustes do <c>dev</c>
para processos, arquivo central e <c>maxlogins</c>. O resto está configurado em
um valor padrão.
</p>

<note>
<path>/etc/security/limits.conf</path> é parte do pacote PAM e só irá
funcionar com pacotes que usam PAM.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> é bem parecido com o arquivo de limites
<path>/etc/security/limits.conf</path>. A única diferença é o formato e
que só funciona em usuários ou wild cards (não funciona com grupos). Vamos ver uma
configuração de exemplo:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Aqui nós configuramos os ajustes padrão e um ajuste específico para o usuário kn. O limits
faz parte do pacote sys-apps/shadow. Não é necessário colocar quaisquer limites
neste arquivo se você desativou o <c>pam</c> no
<path>make.conf</path> ou não configurou o PAM devidamente.
</p>

</body>
</section>
<section>
<title>Cotas</title>
<body>

<warn>
Certifique-se que o sistema de arquivos que você está usando suporta cotas. Para poder usar
cotas com ReiserFS, você deve usar patches disponíveis de <uri
link =
"ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">Namesys</uri>. Ferramentas
de usuário estão disponíveis no <uri link =
"http://www.sf.net/projects/linuxquota/">Projeto de Linux DiskQuota
do Linux</uri>. Embora cotas funcionem com o ReiserFS, você pode encontrar outros
problemas em seu uso - você foi avisado!
</warn>

<p>
Colocar cotas em um sistema de arquivos restringe o uso do disco com base em usuário ou em
grupo. As cotas são ativadas no kernel e adicionadas em um ponto de montagem
em <path>/etc/fstab</path>. A opção de kernel é ativada na configuração
do kernel em <c>File systems-&gt;Quota support</c>. Aplique os seguintes
ajustes, reconstrua o kernel e reinicie usando o novo kernel.
</p>

<p>
Comece instalando as cotas com <c>emerge quota</c>. Então modifique seu
<path>/etc/fstab</path> e adicione <c>usrquota</c> e <c>grpquota</c> às
partições em que você quer restringir o uso de disco, como no exemplo abaixo.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Em cada partição que você ativar cotas, crie os arquivos de cota
(<path>aquota.user</path> e <path>aquota.group</path>) e coloque-os na
raiz da partição.
</p>

<pre caption="Criando os arquivos de cota">
# <i>touch /tmp/aquota.user</i>
# <i>touch /tmp/aquota.group</i>
# <i>chmod 600 /tmp/aquota.user</i>
# <i>chmod 600 /tmp/aquota.group</i>
</pre>

<p>
Este passo deve ser feito em cada partição onde cotas são ativas. Depois de
adicionar e configurar os arquivos de cota, nós precisamos adicionar o script <c>quota</c>
ao runlevel boot.
</p>

<pre caption="Adicionando quota ao runlevel boot">
# <i>rc-update add quota boot</i>
</pre>

<p>
Nós iremos agora configurar o sistema para verificar as cotas uma vez por semana colocando a
seguinte linha em <path>/etc/crontab</path>:
</p>

<pre caption="Adicionando verificação de cota ao crontab">
0 3 * * 0 /usr/sbin/quotacheck -avug.
</pre>

<p>
Depois de reiniciar a máquina, está na hora de configurar as cotas para usuários e
grupos. <c>edquota -u kn</c> irá iniciar o editor definido em $EDITOR (o padrão
é o nano) e permitir que você edite as cotas para o usuário kn. <c>edquota -g</c> também fará
a mesma coisa para grupos.
</p>

<pre caption="Configurando a cota para o usuário kn">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Para mais detalhes leia <c>man edquota</c> ou o<uri
link="http://www.tldp.org/HOWTO/mini/Quota.html">Quota mini howto</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>
	    
<p>
Se sua política de segurança diz que os usuários devem mudar suas senhas
uma semana sim outra não, mude o valor <c>PASS_MAX_DAYS</c> para 14
e <c>PASS_WARN_AGE</c> para 7. É recomendado que você use envelhecimento
de senhas já que métodos de força bruta podem encontrar qualquer senha, dado tempo
suficiente. Nós também recomendados que você configure <c>LOG_OK_LOGINS</c> como ativo.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
O arquivo <path>login.access</path> também é parte do pacote sys-apps/shadow,
que fornece uma tabela de controle de acessos de log-in. A tabela é usada para controlar quem
pode e não pode fazer log-in com base no nome de usuário, nome de grupo ou nome de host. Por padrão,
todos usuários em todos os sistemas podem fazer log-in, então o arquivo consiste somente de
comentários e exemplos. Não importa se você estiver cuidando da segurança de seu servidor ou estação de trabalho, nós
recomendamos que você configure este arquivo para que ninguém fora você mesmo (o administrador) tenha
acesso ao console.
</p>

<note>
Estes ajustes não se aplicam ao root.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Cuidado na hora de configurar as opções, já que enganos deixarão você
sem acesso à máquina se você não tiver acesso de root.
</impo>

<note>
Os ajustes não se aplicam a SSH, já que o SSH não executa
<c>/bin/login</c> por padrão. Isto pode ser ativado configurando <c>UseLogin 
yes</c> em <path>/etc/ssh/sshd_config</path>. 
</note>

<p>
Isto irá configurar o acesso de log-in para que os membros do grupo wheel possam fazer log-in localmente
ou do domínio gentoo.org. Talvez muito paranóide, mas é melhor prevenir do que
remediar.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Permissões de arquivo</title>
<section>
<title>Legíveis globalmente</title>
<body>

<p>
Os usuários normais não devem ter acesso a arquivos de configuração ou senhas. Um
indivíduo malicioso pode roubar senhas de bancos de dados ou website e usá-los para fazer
defaces--ou pior ainda, apagar--dados. É por isso que é importante que suas permissões de
arquivo estejam corretas. Se você tem certeza de que um arquivo somente é usado pelo root,
configure-o com as permissões <c>0600</c> e atribua o arquivo ao usuário correto
com <c>chown</c>.
</p>

</body>
</section>
<section>
<title>Graváveis globalmente/por grupo</title>
<body>

<pre caption="Encontrando arquivos e diretórios graváveis globalmente">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Isto irá criar um enorme arquivo com permissões de todos arquivos tendo ou permissão de
escrita para o grupo ou para todos. Verifique as permissões e elimine arquivos
arquivos globais graváveis por todos, executando <c>/bin/chmod o-w</c> nos
arquivos.
</p>

</body>
</section>
<section>
<title>Arquivos SUID/SGID</title>
<body>

<p>
Arquivos com o bit SUID ou SGID configurados executam com os privilégios do usuário ou
grupo <e>proprietário</e> e não do usuário executando o arquivo. Normalmente esses bits são usados
em arquivos que devem ser rodados com root para fazer o que devem. Esses arquivos podem levar
a comprometimentos de root locais (se contiverem buracos de segurança). Isto é perigoso
e arquivos com bits de SUID ou SGID devem ser evitados a qualquer custo. Se você
não usa esses arquivos, use <c>chmod 0</c> neles ou desinstale o pacote de que
eles originaram (verifique a que pacote eles pertencem usando <c>equery</c>; se
você já não o tiver instalado simplesmente digite <c>emerge
gentoolkit</c>). Caso contrário desligue o bit de SUID com <c>chmod -s</c>.
</p>

<pre caption="Encontrando arquivos setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
   -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Isto irá criar um arquivo contendo uma lista de todos arquivos SUID/SGID.
</p>

<pre caption="Lista de binários com setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Por padrão o Gentoo Linux não tem muitos arquivos com SUID (embora isso dependa do
que você tem instalado), mas você pode obter uma lista como a acima. A maior parte dos
comandos não devem ser usados por usuários normais, só root. Desligue o bit de SUID
em <c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c>
e <c>traceroute</c> executando <c>chmod -s</c> em cada arquivo. Não
remova o bit de <c>su</c>, <c>qmail-queue</c> ou <c>unix_chkpwd</c>. Remover o
sutuid destes arquivos impede que você faça <c>su</c> e receba
correio. Ao remover o bit (onde for seguro fazê-lo) você remove a possibilidade
de um usuário normal (ou um indivíduo malicioso) ganhar acesso de root através de qualquer um desses
arquivos.
</p>

<p>
Os únicos arquivos de SUID que eu tenho em meu sistema são <c>su</c>, <c>passwd</c>,
<c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> e <c>pwdb_chkpwd</c>.
Mas se você estiver rodando o X, você pode ter mais algunas, já que o X precisa de acessos
elevados conseguidos através de SUID.
</p>
</body>
</section>
<section>
<title>Binários e hardlinks com SUID/SGID</title>
<body>

<p>
Um arquivo só é considerado apagado quando não há mais links apontando para ele.
Isto pode soar como um conceito estranho, mas considere que um nome de arquivo como
<path>/usr/bin/perl</path> é na verdade um link para o inode onde os dados são
gravados. Qualquer número de links pode apontar para um arquivo, e até todos serem
apagados, o arquivo ainda existe.
</p>

<p>
Se seus usuários têm acesso a uma partição que não é montada com <c>nosuid</c>
ou <c>noexec</c> (por exemplo, se <path>/tmp</path>, <path>/home</path>, ou 
<path>/var/tmp</path> não forem partições separadas) você deve tomar cuidado para
que seus usuários não criem hardlinks para binários com SUID ou SGID, de forma que
após a atualização do Portage eles ainda tenham acesso a versões antigas.
</p>

<warn>
se você recebeu um aviso do portage sobre hardlinks remanescentes, e seus
usuários podem escrever para uma partição que permite executar arquivos SUID/SGID, você
deve ler esta seção cuidadosamente. Um de seus usuários pode tentar
contornar sua atualização mantendo uma cópia antiga de um programa. Se seus
usuários não podem criar arquivos SUID, ou só podem executar programas usando
o carregador dinâmico (partições montadas com <c>noexec</c>), você não tem com o
que se preocupar.
</warn>

<note>
Usuários não precisam ter acesso de leitura a um arquivo para criar um link para ele, só precisam ter
permissão de leitura no diretório que o contém.
</note>

<p>
Para ver quantos links um arquivo tem, você pode usar o comando <c>stat</c>.
</p>

<pre caption="Comando stat">
$ stat /bin/su    
  File: `/bin/su'
  Size: 29350           Blocks: 64         IO Block: 131072 regular file
Device: 900h/2304d      Inode: 2057419     Links: 1
Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2005-02-07 01:59:35.000000000 +0000
Modify: 2004-11-04 01:46:17.000000000 +0000
Change: 2004-11-04 01:46:17.000000000 +0000
</pre>

<p>
Para encontrar arquivos SUID e SGID com links múltiplos, você pode usar o <c>find</c>.
</p>

<pre caption="Encontrando binários suid/sgid com links múltiplos">
$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls
</pre>


</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
O PAM é uma suíte de bibliotecas compartilhadas que fornecem um modo alternativo de dar
autenticação de usuário nos programas. A opção de use <c>pam</c> está ligada por
padrão. Portanto os ajustes de PAM no Gentoo Linux são bem razoáveis, mas sempre há
espaço para melhorias. Primeiro instale o cracklib.
</p>

<pre caption="Instalando o cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Isto irá adicionar o cracklib que irá verificar que todas as senhas de usuário tenham
pelo menos 8 caracteres e contenham um mínimo de 2 dígitos, 2 outros caracteres, e
tenham mais de 3 caracteres diferentes da última senha. Isto força o
usuário a escolher uma boa senha (política de senhas). Veja a documentação do <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>
para mais opções.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Cada serviço não configurado com um arquivo de PAM em <path>/etc/pam.d</path> irá usar
as regras em <path>/etc/pam.d/other</path>. Os padrões estão configurados como <c>deny</c>,
como devem ser. Mas eu gosto de ter vários registros, motivo pelo qual eu
adicionei o <c>pam_warn.so</c>. A última configuração é <c>pam_limits</c>, que é
controlado por <path>/etc/security/limits.conf</path>. Veja a <uri link =
"#limits_conf">seção do /etc/security/limits.conf</uri> para mais desses
ajustes.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Wrappers de TCP</title>
<section>
<body>

<p>
Este é um jeito de controlar acesso a serviços normalmente rodados pelo inetd (que o
Gentoo não tem), mas também pode ser usado pelo xinetd e outros serviços.
</p>

<note>
O serviço deve executar tcpd em seu argumento de servidor (no xinetd). Veja o
capítulo sobre o xinetd para mais informações.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Como você pode ver o formato é bem parecido com o
do <path>/etc/login.access</path>. O tcpd suporta um serviço específico; ele não
sobrepõe o <path>/etc/login.access</path>. Esses ajustes só aplicam-se a
serviços que usam wrappers de tcp.
</p>

<p>
Também é possível executar comandos quando um serviço é acessado (isso pode ser
usado na hora de ativar relays para usuários de conexão discada) mas não é recomendado,
já que as pessoas acabam criando mais problemas que tentam resolver. Um
exemplo pode ser que você configure um script para mandar um e-mail cada vez que
alguém bater na regra deny, mas então um indivíduo malicioso pode iniciar um ataque de DoS ao
continuar a acertar a regra de deny. Isso irá criar muito I/O e e-mails, então
não faça isso! Leia o <c>man 5 hosts_access</c> para mais informações.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Segurança do kernel</title>
<section>
<title>Removendo funcionalidades</title>
<body>

<p>
A regra básica na hora de configurar o kernel é remover tudo que você não
precisa. Isto não só irá criar um kernel menor, mas também remover as
vulnerabilidades que podem residir dentro de drivers e outras funções.
</p>

<p>
Também considere desligar suporte de módulos carregáveis. Embora seja possível
adicionar root kits sem essa função, fica mais difícil para indivíduos maliciosos normais
instalarem root kits via módulos do kernel.
</p>

</body>
</section>
<section>
<title>O sistema de arquivos proc</title>
<body>

<p>
Muitos parâmetros de kernel podem ser alterados através do sistema de arquivos <path>/proc</path>
ou usando <c>sysctl</c>.
</p>

<p>
Para mudar parâmetros e variáveis de kernel na hora, você precisa de
<c>CONFIG_SYSCTL</c> definido em seu kernel. Ele já vem ligado por padrão em
um kernel 2.4 normal.. 
</p>

<pre caption="Desligue o encaminhamento de IP">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Certifique-se que o encaminhamento de IP esteja desligado. Nós só precisamos disso para um
host hospedado em vários lugares. É aconselhável ligar ou desligar essa opção antes de outras opções
já que ela liga/desliga outras opções também.
</p>

<pre caption="Ignorar pacotes de ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Isto fará com que o kernel simplesmente ignore todas mensagens de ping (também conhecidas como
mensagens de ICMP de tipo 0). A razão para isso é que um pacote de IP carregando uma mensagem
ICMP pode conter um payload com informações diferentes das que você espera.
Administradores usam o ping como uma ferramenta de diagnóstico e freqüentemente reclamam se ele estiver
desligado, mas não há motivo para uma pessoa de fora poder fazer ping. No entanto,
já que as vezes pode ser útil para pessoas de dentro poder fazer ping, você pode desabilitar
mensagens de ICMP de tipo 0 na firewall (permitindo que administradores locais continuem
a usar essa ferramenta).
</p>

<pre caption="Ignorar pings de broadcast">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Isto desliga respotas a broadcasts de ICMP e irá prevenir ataques de Smurf. O 
ataque de Smurf funciona mandando um mensagem de ICMP de tipo 0 (ping) para o endereço de
broadcast de uma rede. Tipicamente um indivíduo malicioso irá usar um endereço de
fonte falso. Todos os computadores na rede irão responder à mensagem de ping e
irão floodar o host com endereço de rede forjado.
</p>

<pre caption="Desligar pacotes de fonte roteada">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Não aceite pacotes de fonte roteada. Indivíduos maliciosos podem usar fontes roteadas para
gerar tráfico fingindo vir de dentro de sua rede, mas que é
na verdade roteado de volta ao caminho de onde veio, para que indivíduos maliciosos possam
comprometer sua rede. Roteamento de fonte é raramente usado para propósitos legítimos,
então você pode desligá-lo com segurança.
</p>

<pre caption="Desligar aceitação de redirecionamento">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/secure_redirects</i>
</pre>

<p>
Não aceite redirecionar pacotes ICMP. Redirecionamento de ICMP pode ser usado para alterar suas
tabelas de roteamento, possivelmente para um fim malicioso.
</p>

<pre caption="Proteção contra mensagens de erro falsas">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Ative a protação contra respostas a mensagens de erro falsas.
</p>

<pre caption="Ativar filtro de caminho reverso">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<p>
Ligue o filtro de caminho reverso. Isto ajuda a certificar que os pacotes usam endereços de
fonte legítimos ao rejeitar pacotes de entrada automaticamente se a entrada
da tabela de roteamento para o endereço fonte não bater com a interface de rede em
que chegam. Isto tem vantagens de segurança porque impede a forja de IP.
Precisamos ativá-lo em cada <path>net/ipv4/conf/*</path> caso contrário a validação
de fontes não é inteiramente funcional.
</p>

<warn>
No entanto, ligar filtro de caminhos reversos pode ser um problema se você usar
roteamento assimétrico (pacotes de você para um host tomam um caminho diferente dos pacotes daquele
host para você) ou se você opera um host sem roteamento que tem vários endereços IP
em diferentes interfaces.
</warn>

<pre caption="Registrar todos pacotes forjados, roteados por fonte e redirecionados">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Registrar pacotes forjados, roteados por fonte e redirecionados.
</p>

<p>
Todas essas configurações serão apagadas quando a máquina for reiniciada. Eu sugiro que
você adicione-os ao <path>/etc/sysctl.conf</path>, que é automaticamente lido
pelo script de init <path>/etc/init.d/bootmisc</path>.
</p>

<p>
A sintaxe para o <path>/etc/sysctl.conf</path> é bem simples. Tire o
<path>/proc/sys/</path> dos caminhos mencionados anteriormente e
substitua <path>/</path> com <path>.</path>:
</p>

<pre caption="Traduzindo para sysctl.conf">
<comment>(Usando echo manualmente):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automaticamente em sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
O patch do <uri link="http://grsecurity.net">Grsecurity</uri> é padrão nas
fontes de kernel do Gentoo, mas é desligado por padrão. Configure seu kernel como
você normalmente faria e então configure as opções de Grsecurity. Uma explicação
em profundidade das opções de Grsecurity disponíveis (versão 1.9) está disponível na
página do projeto do <uri link="/proj/en/hardened">Gentoo Hardened</uri>.
</p>

<p>
As <c>grsec-sources</c> recentes fornecem a versão 2.* do Grsecurity. Para mais
informações sobre este conjunto de patches do Grsecurity melhorados, por favor consulte
a documentação disponível na <uri link="http://www.grsecurity.net/">homepage do
Grsecurity</uri>.
</p>

</body>
</section>
<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> é um patch que adiciona criptografia
ao kernel existente. Ao aplicar o patch em seu kernel você terá novas opções como
cifras criptográficas, algoritimos de digest e filtros de loops criptográficos.
</p>

<warn>
O patch do kerneli não está atualmente em versão estável para o kernel mais recente, então
tenha cuidado na hora de usá-lo.
</warn>

</body>
</section>
<section>
<title>Outros patches de kernel</title>
<body>

<ul>
<li><uri link="http://www.openwall.com">The OpenWall Project</uri></li>
<li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
<li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
<li>
  <uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri>
</li>
<li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
E provavelmente existem muitos outros.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Melhorando a segurança de serviços</title>
<section>
<title>Apache</title>
<body>

<p>
O Apache (1.3.26) vem com um arquivo de configuração decente mas de novo, nós precisamos
melhorar algumas coisas, como fazer bind do Apache em um endereço e impedir que ele
vaze informações. Abaixo estão as opções que você deve aplicar ao
arquivo de configuração.
</p>

<p>
Se você não desabilitou <c>ssl</c> em seu <path>/etc/make.conf</path> antes de
instalar o Apache, você deve ter acesso a um servidor com acesso a ssl. Simplesmente adicione a
seguinte linha para ativá-lo.
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Faça-o ouvir seu ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#Não é uma boa idéia usar nobody ou nogroup -
#para todo serviço que não roda como root
#(simplesmente adicione o usuário apache com grupo apache)
User apache
Group apache
#Impedirá que o apache fale sobre a versão
ServerSignature Off
ServerTokens Prod
</pre>

<p>
O Apache é compilado com <c>--enable-shared=max</c> e
<c>--enable-module=all</c>. Isto irá por padrão carregar todos módulos, então você
deve comentar todos módulos que você não usa na seção <c>LoadModule</c>
(<c>LoadModule</c> e <c>AddModule</c>). Reinicie o
serviço executando <c>/etc/init.d/apache restart</c>.
</p>

<p>
Documentação está disponível em <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
Pode-se encontrar documentação no <uri
link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri>. O Manual de referências do administrador também está
no <path>doc/arm</path>.
</p>

<p>
As novas ebuilds do BIND suportam chroot sem modificações. Depois de fazer emerge do
<c>bind</c> siga essas simples instruções:
</p>

<pre caption="Fazendo chroot do BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<comment>(Antes de rodar o comando acima talvez você queira mudar o diretório de
chroot em /etc/conf.d/named. Caso contrário /chroot/dns será usado.)</comment>
<comment>(Você pode ter que substituir o número de versão com o número da versão atual)</comment>
</pre>
</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns é uma implementação de DNS de segurança sobre a qual o autor está disposto a
apostar <uri link="http://cr.yp.to/djbdns/guarantee.html">dinheiro</uri>. É muito
diferente de como o Bind 9 funciona, mas vale a tentativa. Mais informações podem ser
encontradas em <uri>http://www.djbdns.org</uri>.
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Geralmente, usar FTP (File Transfer Protocol) é uma má idéia. Ele usa dados sem
criptografia (isto é, senhas são enviadas em texto normal), ouve em 2 portas (normalmente porta
20 e 21), e indivíduos maliciosos estão freqüentemente procurando por log-ins anônimos para
trocar warez. Já que o protocolo de FTP contém vários problemas de segurança você
deve usar <c>sftp</c> ou HTTP. Se não for possível, faça a segurança de seus
serviços o melhor que puder e prepare-se.
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
Se você somente precisa de que aplicativos locais acessem o banco de dados do <c>mysql</c>,
descomente a seguinte linha em <path>/etc/mysql/my.cnf</path>.
</p>

<pre caption="Desligando acesso de rede">
skip-networking
</pre>

<p>
Então nós desligamos o uso do comando LOAD DATA LOCAL INFILE. Isto é para
impedir acesso não autorizado de leitura de arquivos locais. Isto é importante quando novas
vulnerabilidades de injeção de SQL em aplicações PHP são encontradas.
</p>

<pre caption="Desligando LOAD DATA LOCAL INFILE na seção [mysqld]">
set-variable=local-infile=0
</pre>

<p>
A seguir, precisamos remover um banco de dados de amostra (teste) e todas contas fora a 
conta de <c>root</c> local.
</p>

<pre caption="Removendo banco de dados de amostra e usuários desnecessários">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Tenha cuidado com o feito acima se você já configurou contas de usuário.
</warn>

<note>
Se você tem mudado senhas do prompt do MySQL, você deve sempre
limpar o <path>~/.mysql_history</path> e
<path>/var/log/mysql/mysql.log</path> já que eles gravam os comandos de SQL executados
com senhas em texto normal.
</note>

</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
O proftpd já teve vários problemas de segurança, mas a maior parte parece ter sido
consertada. De qualquer jeito, é uma boa idéia colocar umas melhorias:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Meu daemon de ftp"
#Não mostrar o ident do servidor
ServerIdent on "Vá embora"

#Torna mais fácil a criação de usuários virtuais
RequireValidShell off

#Usa senha e arquivo de grupo alternativo (o passwd usa formado criptográfico)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissões
Umask 077

# Timeouts e limitações
MaxInstances 30
MaxClients 10 "Só 10 conexões permitidas"
MaxClientsPerHost 1 "Você já vez um log-in"
MaxClientsPerUser 1 "Você já vez um log-in"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Fazer chroot de todos
DefaultRoot ~

#não rodar como root
User  nobody
Group nogroup

#registrar todas transferências
TransferLog /var/log/transferlog

#Problemas com globbing
DenyFilter \*.*/
</pre>

<p>
Você pode encontrar documentação em <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd é uma ramificação do original trollftpd, modificada por razões de segurança
e funcionalidade por Frank Dennis.
</p>

<p>
Use usuários virtuais (nunca contas de sistema) ativando a opção <c>AUTH</c>.
Configure-a para <c>-lpuredb:/etc/pureftpd.pdb</c> e crie seus usuários usando
<c>/usr/bin/pure-pw</c>. 
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Outras coisas ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Configure seu ajuste de <c>MISC_OTHER</c> para negar conexões anônimas (<c>-E</c>),
fazer chroot de todos (<c>-A</c>), impedir que usuários leiam ou escrevam arquivos
começando com um . (ponto) (<c>-X</c>), tempo máximo ocioso (<c>-I</c>), limitar recursão
(<c>-L</c>), e uma <c>umask</c> razoável.
</p>

<warn>
<e>Não</e> use as opções <c>-w</c> ou <c>-W</c>! Se você quiser ter um site de
warez, pare de ler este guia!
</warn>

<p>
Você pode encontrar documentação em <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (diminutivo de very secure ftp) é um pequeno daemon de ftp rodando uma configuração
razoavelmente padrão. Ele é simples e não tem tantas funções como
o pureftp e o proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#só leitura
write_enable=NO

#permitir registro de transferências
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Como você pode ver, não há jeito deste serviço ter permissões individuais,
mas em relação aos ajustes anônimos ele é
muito bom. Às vezes pode ser útil ter um servidor de ftp anônimo (para
compartilhar código livre), e o vsftpd faz um bom trabalho nisso.
</p>

</body>
</section>
<section>
<title>Qmail</title>
<body>

<p>
O qmail é freqüentemente tido como um servidor de correio muito seguro. É escrito com
segurança (e paranóia) em mente. Ele não permite relaying por padrão e não teve
um buraco de segurança desde 1996. Simplesmente faça <c>emerge qmail</c> e vá configurá-lo!
</p>
</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba é o protocolo para compartilhar arquivos com redes Microsoft/Novell e
<e>não</e> deve ser usado na Internet. Todavia, ainda precisa de
medidas de segurança.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Prender em uma interface
  interfaces = eth0 10.0.0.1/32

  #Certificar-se de usar senha criptografada
  encrypt passwords = yes
  directory security mask = 0700

  #permitir tráfico de 10.0.0.*
  hosts allow = 10.0.0.

  #Permitir autenticação de usuário
  #(não use o modo compartilhar)
  security = user

  #Proibir contas com privilégio
  invalid users = root @wheel

  #Tamanho máximo que o smb mostra para uma share (não um limite)
  max disk size = 102400

  #Manter a política de senhas
  min password length = 8
  null passwords = no

  #Usar PAM (se suporte for adicionado)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Certifique-se que as permissões estão configuradas corretamente em todas shares e lembre-se de ler
a <uri link="http://www.samba.org">documentação</uri>.
</p>

<p>
Agora reinicie o servidor e adicione os usuários que devem ter acesso ao
serviço. Isto é feito através do comando <path>/usr/bin/smbpasswd</path> com
o parâmetro <c>-a</c>.
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
A única medida de segurança que o OpenSSH precisa é ligar um método de autenticação
baseado na criptografia de chaves públicas. Muitos sites (como
<uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> e
<uri>http://www.apache.org</uri>) sofreram instrusões não autorizadas
devido a senhas vazadas ou senhas ruins.
</p>

<pre caption="/etc/ssh/sshd_config">
#Só permitir a versão 2
Protocol 2

#Desligar log-in de root. Usuários devem usar su para root
PermitRootLogin no

#Ligar autenticação de chave pública
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Desligar autenticaçao de .rhost e senha normal
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

#Só permitir que usuários nos grupos wheel ou admin façam log-in
AllowGroups wheel admin

#Nestes grupos só permitir os seguintes usuários
#O @&lt;nomededomínio&gt; é opcional mas substitui a
#antiga diretiva AllowHosts
AllowUsers kn@gentoo.org bs@gentoo.org

#Registros 
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
Também verifique que você não tem <c>UsePAM yes</c> em seu arquivo de configuração já
que isso sobrepõe o mecanismo de autenticação de chave pública.
</p>

<p>
Agora tudo o que seus usuários tem que fazer é criar uma chave (na máquina em que
querem fazer log-in) com o seguinte comando:
</p>

<pre caption="Criando um par de chaves DSA">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
E digite sua senha.
</p>

<pre caption="Saída do ssh-keygen">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Aperte enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Digite a senha]</i>
Enter same passphrase again: <i>[Digite a senha novamente]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Isto irá adicionar dois arquivos no seu diretório <path>~/.ssh/</path> chamados
<path>id_dsa</path> e <path>id_dsa.pub</path>. O arquivo chamado
<path>id_dsa</path> é sua chave privada e deve ser mantida fora do alcance outras
pessoas. O outro arquivo <path>id_dsa.pub</path> deve ser distribuído a
todos servidores a que você tem acesso. Adicione a chave ao diretórios de home dos usuários
em <path>~/.ssh/authorized_keys</path> e o usuário deve poder fazer log-in.
</p>

<p>
Agora seus usuários devem guardar sua chave privadas bem. Coloque em mídia que sempre
carregam com eles ou mantenham eu suas estações de trabalho (coloque isso na política de <uri
link="#security_policies">senhas</uri>)
</p>

<p>
Para mais informações visite o website do <uri
link="http://www.openssh.org">OpenSSH</uri>.
</p>

</body>
</section>
<section>
<title>Usando o xinetd</title>
<body>

<p>
O xinetd é um substituto do <c>inetd</c> (que o Gentoo não tem),
o daemon de serviços de Internet. Ele suporta controle de acesso com base no endereço do
host remoto e a hora de acesso. Ele também fornece capacidades de registros
extensivas, incluindo hora de início do servidor, endereço de host remoto, nome de usuário
remoto, tempo ativo do servidor, e ações pedidas.
</p>

<p>
Como com todos outros serviços é importante ter uma boa configuração padrão.
Mas já que o <c>xinetd</c> é rodado com root e suporta protocolos
que você pode não saber como funcionam, nós recomendados não usá-lo. Mas se você
quiser usá-lo de qualquer jeito, aqui está como melhorar sua segurança:
</p>

<pre caption="Instalando o xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
E edite o arquivo de configuração:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from = localhost
 instances = 10
 log_type = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps = 25 30
}

# Isto irá configurar o pserver (cvs) via xinetd com as seguintes configurações:
# max 10 instâncias (10 conexões por vez)
# limitar o pserver para somente tcp
# usar o usuário cvs para rodar este serviço
# prender todas interfaces a só 1 ip
# permitir acesso de 10.0.0.*
# limitar o horário que os desenvolvedores podem usar o cvs de 8 horas até 17 horas
# usar wrappers de tpcd (controle de acesso controlado em
# <i>/etc/hosts.allow</i> e <i>/etc/hosts.deny</i>)
# max_load na máquina configurado para 1.0
# A opção disable é por padrão no mas eu gosto de tê-la
# caso deva ser desligada
service cvspserver
{
 socket_type = stream
 protocol = tcp
 instances = 10
 protocol = tcp
 wait = no
 user = cvs
 bind = 10.0.0.2
 only_from = 10.0.0.0
 access_times = 8:00-17:00
 server = /usr/sbin/tcpd
 server_args = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load = 1.0
 log_on_failure += RECORD
 disable = no
}
</pre>

<p>
Para mais informações leia <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>X</title>
<body>

<p>
Por padrão o Xorg é configurado para agir como um Xserver. Isto pode ser perigoso já que
o X usa conexões de TCP sem criptografia e escuta xclients.

</p>

<impo>
Se você não precisa deste serviço desligue-o!
</impo>

<p>
Mas se você precisa usar sua estação de trabalho como um Xserver use o
comando <c>/usr/X11R6/bin/xhost</c> com cuidado. Este comando permite que clientes
de outros hosts conectem-se e usem seu display. Isto pode ser útil se você
precisa de uma aplicação de X de uma máquina diferente e o único jeito é através
da rede, mas também pode ser explorado por um indivíduo malicioso. A sintaxe deste
comando é <c>/usr/X11R6/bin/xhost +hostname</c>
</p>

<warn>
Nunca use a função <c>xhost +</c>! Isto permitirá que qualquer cliente
conecte-se e tome controle de seu X. Se um indivíduo obtiver acesso a seu X,
ele pode registrar o que você digitar e tomar controle de seu desktop. Se você tiver
de usá-lo lembre-se sempre de especificar um host.
</warn>

<p>
Uma solução mais segura é desativar essa função completamente iniciando o X com 
<c>startx -- -nolisten tcp</c> ou desligando-a permanentemente na configuração.
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Para ter certeza de que o <path>startx</path> não seja sobre-escrito na hora de instalar uma
nova versão do Xorg, você deve protegê-lo. Adicione a seguinte linha ao
<path>/etc/make.conf</path>:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Se você usa um gerenciador de login gráfico você precisa de um método diferente.
</p>

<p>
Para o <c>gdm</c> (Gnome Display Manager)
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Para o <c>xdm</c> (X Display Manager) e <c>kdm</c> (Kde Display Manager)
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Fazendo chroot e servidores virtuais</title>
<section>
<title>Fazendo chroot</title>
<body>

<p>
Fazer chroot de um serviço é um jeito de limitar o ambiente de um serviço (ou um usuário) a
só acessar o que deve e não obter acesso (ou informações) que
podem levar a acesso de root. Ao rodar um serviço como um usuário diferente de
<c>root</c> (<c>nobody</c>, <c>apache</c>, <c>named</c>) um indivíduo malicioso só pode
ter acesso a arquivos com a permissão do usuário. Isto significa que um indivíduo malicioso
não pode obter acesso de <c>root</c> mesmo se os serviços tiverem uma falha de segurança.
</p>

<p>
Alguns serviços como o <c>pure-ftpd</c> e <c>bind</c> têm funções de
chroot, e outros serviços não têm. Se o serviço suportá-lo, use-o,
senão você terá que descobrir como criar sua própria. Vamos ver como criar
um chroot, para um entendimento básico de como o chroot funciona, nós iremos testá-lo com o
<c>bash</c> (jeito fácil de aprender).
</p>

<p>
Crie o diretório <path>/chroot</path> com <c>mkdir chroot</c>. E descubra com que
bibliotecas dinâmicas que o <c>bash</c> é compliado (se for compilado com
<c>-static</c> este passo não é necessário):
</p>

<p>
O seguinte comando irá criar uma lista de bibliotecas usadas pelo <c>bash</c>. 
</p>

<pre caption="Obtendo uma lista de bibliotecas usadas">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Agora vamos criar o ambiente para o <c>bash</c>.
</p>

<pre caption="Criando ambiente de chroot para o bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Agora copie os arquivos usados pelo <c>bash</c> (<path>/lib</path>) para o
<path>lib</path> chrootado e copie o comando de bash para o diretório <path>bin</path>
chrootado. Isto irá criar o exato mesmo ambiente, só que com menos
funcionalidades. Depois de copiar, teste-o: <c>chroot /chroot/bash /bin/bash</c>. 
Se você receber um prompt dizendo <path>/</path> ele funciona! Caso contrário ele dirá
que um arquivo está faltando. Algumas bibliotecas compartilhadas dependem uma da outra.
</p>

<p>
Você perceberá que dentro do chroot nada funciona fora talvez o <c>echo</c>. Isto é
porque não temos outros comandos fora do ambiente de chroot fora bash e o
<c>echo</c> é uma funcionalidade interna.
</p>

<p>
Este é basicamente o mesmo jeito que você criaria um serviço chrootado. A única
diferença é que os serviços às vezes dependem de dispositivos e arquivos de configuração
em <path>/etc</path>. Simplesmente copie-os (dispositivos podem ser copiados com <c>cp 
-a</c>) para o ambiente de chroot, edite o script de init para usar chroot antes de
executar. Pode ser difícil descubrir que serviços e arquivos de configuração um
serviço precisa. Aqui é onde o comando <c>strace</c> torna-se útil. Inicie
o serviço com <c>/usr/bin/strace</c> bash e procure por open, read, stat e 
talvez connect. Isto dará a você uma melhor idéia de que arquivos copiar. Mas na maioria
dos casos só copiar o arquivo passwd (edite a cópia e remova usuários que não tem
nada em relação ao serviço), <path>/dev/zero</path>, <path>/dev/log</path> 
e <path>/dev/random</path>.
</p>

</body>
</section>
<section>
<title>User Mode Linux</title>
<body>

<p>
Outro jeito de criar um ambiente mais seguro é rodando uma máquina
virtual. Uma máquina virtual, como o nome implica, é o processo que roda em cima
de seu sistema operacional real fornecendo um hardware e ambiente de sistema
operacional que parece ser sua própria máquina individual. O benefício de segurança é
que se o servidor rodando a máquina virtual for comprometido, só o servidor
virtual é afetado e não a instalação mestre.
</p>

<p>
Para mais informações sobre como configurar o User Mode Linux consulte o
<uri link="http://www.gentoo.org/doc/en/uml.xml">Guia de User Mode
Linux</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Firewalls</title>
<section>
<title>Uma firewall</title>
<body>

<p>
As pessoas normalmente pensam que uma firewall fornece o mais alto nível de segurança, mas
estão enganadas. Na maior parte dos casos uma firewall mal-configurada dá menos segurança que
não ter nenhuma. Uma firewall também é feita de software e deve ser
tratada do mesmo jeito que qualquer outro software, porque tem a mesma chance
de conter defeitos.
</p>

<p>
Então pense antes de implementar uma firewall! Você realmente precisa de uma? Se você acha
que você precisa de uma, escreva uma política sobre como deve funcionar, que tipo de firewall, e
quem deve operá-la. Mas antes leia este guia.
</p>

<p>
Firewalls são usadas para dois propósitos:
</p>

<ul>
<li>Manter usuários (worms/indivíduos maliciosos) fora</li>
<li>Manter usuários (empregados/crianças) dentro</li>
</ul>

<p>
Basicamente há três tipos de firewalls:
</p>

<ul>
<li>Filtro de pacotes</li>
<li>Relay de circuitos</li>
<li>Roteador de aplicações</li>
</ul>

<p>
Uma firewall deve ficar em uma máquina dedicada que não roda serviços (ou <c>sshd</c> como
o único) e segura do jeito que este guia recomenda que seja.
</p>

</body>
</section>
<section>
<title>Filtro de pacotes</title>
<body>

<p>
Todo tráfico de rede é enviado na forma de pacotes. Grandes quantidades de tráfico são
divididas em pacotes menores para facilitar seu manuseio e são re-montados quando
chega em seu destino. No cabeçalho de pacote todos pacotes contêm
informações de como e onde devem ser levados. E esta informação é
exatamente o que uma firewall de filtro de pacotes usa. A filtragem é baseada em:
</p>

<ul>
<li>Permitir ou proibir pacotes com base em endereço de IP fonte/destino</li>
<li>Permitir ou proibir pacotes com base em porta de fonte/destino</li>
<li>Permitir ou proibir pacotes com base em protocolo</li>
<li>Permitir ou proibir pacotes com base em opções dentro de um protocolo específico</li>
</ul>

<p>
Em outras palavras, a filtragem é baseada em todos os dados do cabeçalho de um
pacote e não seu conteúdo.
</p>

<p>
Fraquezas:
</p>

<ul>
<li>
  Informações de endereço em um pacote podem potencialmente conter um endereço IP falso (ou como
  dizemos <e>spoofados</e>) pelo enviador.
</li>
<li>
  Dados ou pedidos dentro do pacote permitido podem conter dados não-desejável que o
  indivíduo malicioso pode usar para explorar bugs conhecidos nos serviços na firewall ou atrás dela
</li>
<li>Normalmente único ponto de falha</li>
</ul>

<p>
Vantagens:
</p>

<ul>
<li>Simples e fácil de implementar</li>
<li>
  Pode dar avisos de um possível ataque antes de acontecer (isto é, detectando
  escaneadores de portas)
</li>
<li>Bom para deter ataques de SYN</li>
</ul>

<p>
Exemplos de filtros de pacotes gratuitos para Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>
<!--FIXME: should SmoothWall really be included, since it uses iptables?-->
<note>
É recomendável que você use iptables. Ipchains está obsoleto.
</note>

</body>
</section>
<section>
<title>Relay de circuitos</title>
<body>

<p>
Um roteador é nível de circuito é uma firewall que valida as conexões antes de permitir
que os dados sejam trocados. Isto significa que ele não simplesmente permite ou nega pacotes
com base no cabeçalho do pacote, mas também determina se a conexão entre os dois
lados é válida de acordo com regras configuráveis antes de abrir uma sessão e
permitir que dados sejam trocados. A filtragem é baseada em:
</p>

<ul>
<li>Endereço IP de fonte/destino</li>
<li>Porta de fonte/destino</li>
<li>Um período de tempo</li>
<li>Protocolo</li>
<li>Usuário</li>
<li>Senha</li>
</ul>

<p>
Todo tráfico é validado e monitorado, e tráfico não desejável pode ser ignorado.
</p>

<p>
Fraquezas:
</p>

<ul>
<li>
  Opera no layer de transporte e pode necessitar de modificação substanciais nos
  programas que normalmente fornecem funções de transporte.
</li>
</ul>

</body>
</section>
<section>
<title>Roteador de aplicações</title>
<body>

<p>
Um roteador de nível de aplicações é um proxy para aplicações, trocando dados com
sistemas remotos em nome dos clientes. É mantido longe do público seguramente
atrás de uma DMZ (De-Militarized Zone: a porção de uma rede privada que é
visível através da firewall) ou uma firewall que não permite conexões do
lado de fora. A filtragem é baseada em:
</p>

<ul>
<li>Permitir ou impedir com base em endereço IP de fonte/destino</li>
<li>Baseado no conteúdo do pacote</li>
<li>Limita acesso de arquivos com base no tipo de arquivo ou extensão</li>
</ul>

<p>
Vantagens:
</p>

<ul>
<li>Pode fazer cachê de arquivos, aumentando performance de rede</li>
<li>Registros detalhados de todas conexões</li>
<li>Boa escalabilidade (alguns servidores de proxy podem "compartilhar" dados em cachê)</li>
<li>Não tem acesso direto do exterior</li>
<li>Pode alterar até o conteúdo do pacote na hora</li>
</ul>

<p>
Desvantagens:
</p>

<ul>
<li>Configuração é complexa</li>
</ul>

<p>
Roteadores de aplicações são considerados a solução mais segura já que eles
não tem que rodar como root e os hosts atrás deles não são alcançáveis através da
Internet.
</p>

<p>
Exemplo de um roteador de aplicações gratuito:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Para usar o iptables, ele deve estar ativado no kernel. Eu adicionei o
iptables como módulos (o comando <c>iptables</c> carrega-os conforme eles são
necessários) e re-compilei meu kernel (mas você pode compilar o iptables dentro do kernel, se
você tem a intenção de desligar suporte de módulos carregáveis, como discutimos anteriormente). Para mais
informações em como configurar seu kernel para o iptables vá para o<uri link =
"http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Tutorial de Iptables
Capítulo 2: Preparativos</uri>. Depois que você compilou ser kernel
(ou durante a compilação do kernel, você deve adicinoar o comando <c>iptables</c>.
Simplesmente faça <c>emerge iptables</c> e ele deve funcionar.
</p>

<p>
Agora teste se ele funciona rodando <c>iptables -L</c>. Se falhar algo
está errado e você tem quer verificar sua configuração mais uma vez.
</p>

<p>
O Iptables é o novo e muito melhorado filtro de pacotes do kernel do Linux
2.4.x. Ele é o sucessor do antigo filtro de pacotes ipchains do kernel do Linux
2.2.x. Uma das grandes melhorias é que o iptables agora pode fazer filtro
de pacotes "stateful". Com o filtro de pacotes stateful é possível
controlar cada conexão TCP estabelecida.
</p>

<p>
Uma conexão TCP consiste de uma série de pacotes contendo informações sobre
endereço IP de fonte, endereço IP de destino, porta de fonte, porta de destino, e um
número de seqüência para que os pacotes possam ser re-montados sem perder dados. TCP é um
protocolo orientado à conexão, diferente do UDP, que funciona sem conexão.
</p>

<p>
Examinando o cabeçalho do pacote TCP, um filtro de pacotes stateful pode determinar se um
pacote TCP recebido é parte de uma conexão já estabelecida ou não e
decidir aceitar ou ignorar o pacote.
</p>

<p>
Com um filtro de pacotes não-stateful é possível enganar o filtro de pacotes a
aceitar pacotes que deveriam ser ignorados manipulando os cabeçalhos dos pacotes TCP.
Isto pode ser feito manipulando as opções de SYN ou outras opções no cabeçalho de TCP
para fazer um pacote malicioso parecer ser parte de uma conexão estabelecida
(já que o filtro de pacotes em si não suporte rastreamento de conexões). Com o filtro de
pacotes stateful é possível ignorar esses pacotes, já que eles não são parte de uma
conexão pré-estabelecida. Isto também irá parar a possibilidade de
"stealth scans", um tipo de escaneamento de portas em que o escaneador manda pacotes
com opções que são muito menos possíveis de serem registradas por uma firewall que pacotes
SYN normais.
</p>

<p>
O Iptables fornece várias outras funções como NAT (Network Address Translation) 
e limite de taxas. O limite de taxas é extremamente útil na prevenção de
certos ataques de DoS (Denial of Service) como SYN floods.
</p>

<p>
Uma conexão de TCP é estabelecida pelo chamado cumprimento de três jeitos. Na hora
de estabelecer uma conexão TCP o lado do cliente envia um pacote para o servidor
com a opção SYN ligada. Quando o servidor recebe o pacote SYN ele
responde mandando um pacote SYN+ACK de volta para o cliente. Quando o pacote SYN+ACK
é recebido o lado do cliente responde com um terceiro pacote ACK reconhecendo
a conexão em efeito.
</p>

<p>
Um ataque de SYN flood é feito mandando o pacote SYN mas não enviando a
resposta ao pacote SYN+ACK. O lado do cliente pode forjar um pacote um endereço
IP falso porque não precisa de uma resposta. O sistema do servidor irá
adicionar uma entrada na fila de conexões parcialmente abertas quando recebe o
pacote SYN e esperar o pacote ACK final antes de apagar a entrada da
fila. A fila tem um número limitado de vagas e se todas vagas estiverem
preenchidas antes um tempo de espera especificado a entrada será automaticamente
apagada da fila. Os ajustes de espera variam mas são tipicamente de 30-60 
segundos ou até mais. O lado do cliente inicia o ataque forjando vários pacotes
SYN com endereços IP de fontes diferentes e enviando-os para o endereço IP
alvo o mais rápido possível e portanto preenchendo a fila de conexões parcialmente
abertas, impedindo que outros clientes estabeleçam conexões legítimas
com o servidor.
</p>

<p>
Aqui é onde o limite de taxas torna-se útil. É possível limitar a taxa de
pacotes SYN aceitos usando <c>-m limit --limit 1/s</c>. Isto irá
limitar o número de pacotes SYN aceitos para um por segundo e portanto
restringir o SYN flood em nossos recursos.
</p>

<note>
Outra opção para impedir SYN floods são os <uri link =
"http://cr.yp.to/syncookies.html">SYN cookies</uri>, que permitem que seu computador
responda a pacotes se SYN sem preencher espaço na fila de conexões. SYN
cookies podem ser ativados na configuração do kernel do Linux, mas eles são
considerados experimentais no momento.
</note>

<p>
Algumas coisas práticas agora!
</p>

<p>
Quando o iptables é carregado no kernel ele tem 5 ganchos onde você pode colocar suas
regras. São chamados <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>, 
<c>PREROUTING</c> e <c>POSTROUTING</c>. Cada um deles é chamado de uma cadeia e
consite de uma lista de regras. Cada regra diz se o cabeçalho do pacote parecer-se com
isso, aqui está o que fazer com o pacote. Se a regra não bater com
o pacote a próxima regra da cadeia é consultada.
</p>

<p>
Você pode colocar as regras diretamente nas 5 cadeias principais ou criar novas cadeias e adicioná-las
como uma regra para uma cadeia existente. O Iptables suporta as seguintes opções.
</p>

<table>
<tr>
  <th>Opção:</th>
  <th>Descrição:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>Anexar</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>Apagar</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>Inserir</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>Trocar</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>Listar</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>Apagar todas regras na cadeia ou todas cadeias</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>Zerar contadores na cadeia ou todas cadeias</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>Testar este pacote na cadeia</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>Criar uma nova cadeia definida por usuário</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>Apagar uma cadeia definida por usuário</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>Mudar política na cadeia alvo</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>Mudar nome da cadeia</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>Protocolo</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>Endereço de fonte/máscara</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>Endereço de destino/máscara</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>Nome da entrada (nome de ethernet)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>Nome de saída (nome de ethernet)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>Pular (alvo para regra)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>Relaçao extendida (pode usar extensão)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>Saída numérica de endereços e portas</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>Tabela para manipular</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>Modo verbal</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>Expandir números (mostrar valores exatos)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>Fazer relação só do segunfo fragmento e posteriores</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>Versão do pacote</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>Mostrar número das linhas quando listando</ti>
</tr>
</table>

<p>
Primeiro iremos experimentar bloquear todos pacotes ICMP em nossa máquina, só para ficarmos familiares
com o iptables.
</p>

<pre caption="Bloquear todos pacotes ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Primeiro especificamos a cadeira a que nossa regra deve ser anexada, depois o protocolo
dos pacotes para relacionar, e finalmente o alvo. O alvo pode ser o nome de uma
cadeia especificado pelo usuário ou um dos alvos especiais <c>ACCEPT</c>, <c>DROP</c>,
 <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c>, ou <c>MASQUERADE</c>. Neste caso nós
 usamos <c>DROP</c>, que irá ignorar o pacote sem responder para o cliente.
</p>

<note>
O alvo <c>LOG</c> também é o que conhecido como "não-terminante". Se o pacote relacionar-se
com uma regra do alvo <c>LOG</c>, ao invés de parar a avaliação, o pacote
continuará a ser relacionado com outros filtros. Isto permite registrar pacotes
e ainda processá-los normalmente.
</note>

<p>
Agora experimente <c>ping localhost</c>. Você não irá receber nenhuma resposta, já que o iptables
irá ignorar todas mensagens de ICMP que chegarem. Você também não poderá fazer ping de outras
máquinas, já que o pacote de respostas ICMP será ignorado também. Agora limpe a
cadeia para iniciar o fluxo de ICMP novamente.
</p>

<pre caption="Limpando todas regras">
# <i>iptables -F</i>
</pre>

<p>
Agora vamos olhar o filtro de pacotes stateful no iptables. Se nós quisermos
ativar a inspeção stateful de pacotes chegando na eth0 nós faríamos o seguinte
comando:
</p>

<pre caption="Aceitar pacotes que oriundos de uma conexão já estabelecida">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Isto irá aceitar qualquer pacote de uma conexão já estabelecida ou relacionada na
cadeia INPUT. E você pode ignorar qualquer pacote que já não estiver na tabela de estados
rodando <c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> antes
do comando anterior. Isto ativa o filtro de pacotes stateful no
iptables carregando a extensão "state". Se você quisesse permitir que outros
conectem-se a sua máquina, você pode usar a opção <c>--state NEW</c>. O Iptables
contém alguns módulos para propósitos diferentes. Alguns deles são:
</p>

<table>
<tr>
  <th>Módulo/Relação</th>
  <th>Descrição</th>
  <th>Opções extendidas</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>Extensão de relação para o endereço de mac dos pacotes que chegam.</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>Ativa inspeção stateful</ti>
  <ti>--state (estados são ESTABLISHED,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>Limite de taxas de relação</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>Tentar relacionar várias características do dono do pacote</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>Várias verificações de sanidade dos pacotes</ti><ti></ti>
</tr>
</table>

<p>
Vamos tentar criar uma cadeia definida por usuário e aplicá-la a uma das cadeias
existentes:
</p>

<pre caption="Criando uma cadeia definida por usuário">
<comment>(Crie uma nova cadeia com uma regra)</comment>
# <i>iptables -X minhacadeia</i>
# <i>iptables -N minhacadeia</i>
# <i>iptables -A minhacadeia -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(A política padrão é que todo tráfico para fora é permitido. Todo tráfico de entrada é ignorado.)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(E adicione à cadeia INPUT)</comment>
# <i>iptables -A INPUT -j minhacadeia</i>
</pre>

<p>
Aplicando a regra à cadeia input nós obtemos a política: Todos pacotes saindo
são permitidos e todos entrando são ignorados.
</p>

<p>
Pode-se encontrar documentação em <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables
documentation</uri>.
</p>

<p>
Vamos ver um exemplo completo. Neste caso minha política de firewall/roteador diz:
</p>

<ul>
<li>Conexões para a firewall só são permitidas através de SSH (porta 22)</li>
<li>
  A rede local deve ter acesso a HTTP, HTTPS e SSH (DNS também deve
  ser permitido)
</li>
<li>
  Tráfico de ICMP pode conter payload e não deve ser permitido. Claro que temos de
  permitir um certo tráfico de ICMP.
</li>
<li>Escaneamentos de portas devem ser detectados e registrados</li>
<li>Ataques de SYN devem ser evitados</li>
<li>Todo outro tráfico deve ser ignorado e registrado</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Configurando regras internas"

  einfo "Configurando o padrão para negar"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default rule
  einfo "Criando cadeias de estados"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Pacote ruim de ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffic
  einfo "Criando cadeia de icmp"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Tráfico ruim de ICMP:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Incoming traffic
  einfo "Criando uma cadeia para tráfico ssh de entrada"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #outgoing traffic
  einfo "Criando uma cadeia para tráfico ssh de saída"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Criando cadeia de saída de dns"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Criando cadeia de tráfico de saída http/https"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Pegar escaneadores de porta
  einfo "Criando cadeia de detecção de escaneamento de portas"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Aplicar a adicionar estados inválidos às redes
  einfo "Aplicando as cadeias a INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Aplicando as cadeias a FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Aplicando as cadeias a OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Permitir que o cliente roteie através de NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Iniciando firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} não existe. Usando regras padrão."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Parando firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "status de NAT"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Configurando regras de pânico"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Salvando regras de firewall"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restaurando regras de firewall"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Uso: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      irá restaurar ajuste se existir, caso contrário criar regras"
  echo "stop)       apagar todas regras e aceitar tudo"
  echo "rules)      forçar a configuração de novas regras"
  echo "save)       gravar configuraçõe em ${FIREWALL}"
  echo "restore)    restaurar configurações de ${FIREWALL}"
  echo "showstatus) Mostrar o status" 
}
</pre>

<p>
Conselhos antes de criar uma firewall:
</p>

<ol>
<li>Crie uma política de firewall antes de implementá-la</li>
<li>Mantenha simples</li>
<li>
Conheça como cada protocolo funciona (leia o <uri
link="http://www.ietf.org/">RFC</uri>(Request For Comments) relevante)
</li>
<li>
Tenha em mente que uma firewall é só outro software rodando como root.
</li>
<li>Testando sua firewall</li>
</ol>

<p>
Se você acha que o iptables é difícil de entender ou leva muito tempo para configurar
uma boa firewall você pode usar o <uri
link="http://www.shorewall.net">Shorewall</uri>. Ele basicamente usa o iptables para
gerar regras de firewall, mas concentra em regras e não protocolos específicos.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
O Squid é um servidor de proxy muito poderoso. Ele pode filtrar tráfico com base em hora,
expressões regulares (regex) sobre caminho/URI, endereço IP de fonte e destino, domínio,
navegador, usuário autenticado, tipo de MIME, e número de porta (protocolo). Eu
provavelmente esqueci de algumas funcionalidades, mas é difícil cobrir a lista inteira
aqui.
</p> 

<p>
No seguinte exemplo eu adicionei um filtro de banner ao invés de um filtro baseado
em sites pornôs. A razão para tanto é que Gentoo.org <e>não</e> deve ser
listado como um site pornô. E eu não quero perder meu tempo tentando descobrir alguns
sites bons para você.
</p>

<p>
Neste caso, minha política diz:
</p>

<ul>
<li>
Navegar (HTTP/HTTPS) é permitido durante horas de trabalho (segunda-sexta 8-17 e sábado 8-13),
mas se os empregados chegarem aqui atrasados devem trabalhar, não navegar
</li>
<li>
Baixar arquivos não é permitido (.exe, .com, .arj, .zip, .asf, .avi, .mpg,
.mpeg, etc)
</li>
<li>
Não gostamos de banners, então eles são filtrados e substituídos com um gif transparente
(aqui é onde você deve ser criativo!).
</li>
<li>
Todas outras conexões para e da Internet devem ser negadas.
</li>
</ul>

<p>
Isto é implementado em 4 passos <e>fáceis</e>.
</p>

<pre caption="/etc/squid/squid.conf">
# Prender em um ip e porta
http_port 10.0.2.1:3128

# Configuração padrão
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Listas de controle de acesso básicas
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Adicionar quem pode acessar este servidor de proxy
acl localnet src 10.0.0.0/255.255.0.0

# E portas
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Adicionar lista de controle de acesso com base em expressões
# regulares (regex) dentro de urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Adicionar lista de acesso de controle com base em hora e dia
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#permitir acesso do manager do localhost
http_access allow manager localhost
http_access deny manager

# Só permitir pedidos de purge do localhost
http_access allow purge localhost
http_access deny purge

# Negar pedidos em portas desconhecidas
http_access deny !Safe_ports

# Negar CONNECT fora portas de SSL
http_access deny CONNECT !SSL_ports

# Minhas próprias regras

# Adicionar uma página a ser mostrada quando
# um banner for removido
deny_info NOTE_ADS_FILTERED url_ads

# Então negá-los
http_access deny url_ads

# Negar todos arquivos
http_access deny archives

# Restringir acesso a horas de trabalho
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Negar o resto
http_access deny all
</pre>

<p>
A seguir preencha os arquivos que você não quer que seus usuários baixem. Eu adicionei
arquivos zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz
e z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Por favor note o [] com letras maiúsculas e minúsculas para cada caractere. Isto é feito para
ninguém enganar nosso filtro acessando um arquivo chamado AvI ao invés de avi
</note>

<p>
A seguir nós adicionamos as expressões regulares (regex) para identificar banners. Você será provavelmente
mais criativo que eu:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
E como a parte final nós queremos que este arquivo seja mostrado quando um banner for removido.
É basicamente meio arquivo html com uma imagem gif 4x4 transparente.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERRO: A URL pedida não pode ser obtida&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Anúncio filtrado!&lt;/H1&gt;
</pre>

<note>
Não feche as tags &lt;HTML&gt; &lt;BODY&gt;. O squid fará isso.
</note>

<p>
Como você pode ver, o Squid tem muitas possibilidades e é muito eficiente tanto
como filtro como proxy. Ele pode até mesmo usar proxies de Squid alternativos para
escalabilidade em redes muito grandes. A configuração que eu listei aqui serve
para uma pequena rede com 1-20 usuários.
</p>

<p>
Mas combinar o filtro de pacotes (iptables) e a aplicação roteadora (Squid)
é provavelmente a melhor solução, mesmo se o Squid está localizado em um lugar seguro e
ninguém puder acessá-lo de fora. Nós ainda precisamos nos preocupar com
ataques do interior.
</p>

<p>
Agora você tem que configurar os navegadores de seus clientes para usar o servidor de proxy. O
roteador impedirá que usuários façam contato com o exterior se não
usarem o proxy.
</p>

<note>
No Mozilla isto é feito em Editar->Preferências->Avançado->Proxies.
</note>

<p>
Isto também pode ser feito transparentemente usando o iptables para encaminha todo tráfico 
de saída para o proxy do Squid. Isto pode ser feito adicionando uma regra de encaminhamento/pré-roteamento
no roteador:
</p>

<pre caption="Permitir encaminhamento de portas para nosso servidor de proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Se o proxy estiver rodando no host que filtra pacotes--embora não seja
recomendado, pode ser necessário se você não tiver máquinas sobrando--use
um alvo <c>REDIRECT</c> ao invés de <c>DNAT</c> (<c>REDIRECT</c> dirige os pacotes para o
localhost).
</note>

</body>
</section>
<section>
<title>Lições aprendidas</title>
<body>

<p>
Nós aprendemos que:
</p>

<ol>
<li>
Uma firewall pode ser um risco em cima mesma. Uma firewall mal configurada é pior que
não ter nenhuma.
</li>
<li>Como configurar um roteador básico e proxy transparente.</li>
<li>A chave para uma boa firewall é conhecer os protocolos que você quer permitir.</li>
<li>
Que tráfico de IP nem sempre contém dados legítimos, como pacotes ICMP,
que podem conter um payload malicioso.
</li>
<li>Como prevenir um ataque SYN.</li>
<li>Filtrar tráfico HTTP removendo gravuras ofensivas e downloads de vírus.</li>
<li>
Combinar filtros de pacotes e roteadores de aplicações dá melhor controle.
</li>
</ol>

<p>
Agora, se você <e>realmente</e> precisar, crie uma firewall que assista
suas necessidades.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Detecção de invasões</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment)</title>
<body>

<p>
AIDE é um sistema de detecção de intrusão baseada em hosts (HIDS), uma alternativa gratuita para o
Tripewire (se você já conhece o Tripwire você não deverá ter dificuldades para aprender
o arquivo de configuração do AIDE). HIDS são usados para detectar mudanças em arquivos
de configuração de sistema e binários importantes, geralmente fazendo um hash
criptográfico singular para os arquivos a serem verificados e guardando-os em um lugar
seguro. Com freqüência (como uma vez por dia), o hash "conhecido" guardado é
comparado com o gerado pela cópia atual de cada arquivo, para determinar
se o arquivo mudou. HIDS são uma grande maneira de detectar mudanças não permitidas
a seu sistema, mas dão um pouco de trabalho para implementar adequadamente e tirar
proveito.
</p>

<p>
O arquivo de configuração é baseado em expressões regulares (regex), macros e regras para
arquivos e diretórios. Nós temos as seguintes macros:
</p>

<table>
<tr>
  <th>Macro</th>
  <th>Descrição</th>
  <th>Sintaxe</th>
</tr>
<tr>
  <ti>ifdef</ti>
  <ti>Se definido</ti>
  <ti>@@ifdef "nome"</ti>
</tr>
<tr>
  <ti>ifndef</ti>
  <ti>Se não definido</ti>
  <ti>@@ifndef "nome"</ti>
</tr>
<tr>
  <ti>define</ti>
  <ti>Definir uma variável</ti>
  <ti>@@define "nome" "valor"</ti>
</tr>
<tr>
  <ti>undef</ti>
  <ti>Cancelar uma variável</ti>
  <ti>@@undef "nome"</ti>
</tr>
<tr>
  <ti>ifhost</ti>
  <ti>se "hostname"</ti>
  <ti>@@ifhost "hostname"</ti>
</tr>
<tr>
  <ti>ifnhost</ti>
  <ti>se não "hostname"</ti>
  <ti>@@ifnhost "hostname"</ti>
</tr>
<tr>
  <ti>endif</ti>
<ti>
Endif deve ser usado depois de qualquer uma das macros acima fora define e undef
</ti>
<ti>@@endif</ti>
</tr>
</table>

<p>
Estas macros tornam-se úteis se você tem mais de uma máquina rodando Gentoo e quer
usar AIDE em todas elas. Mas nem todas máquinas rodam os mesmos serviços ou tem
os mesmos usuários.
</p>

<p>
A seguir temos conjuntos de opções para verificar arquivos e diretórios. Eles são uma
combinação de permissões, propriedades de arquivo e hashes criptográficos
(isto é, checksums).
</p>

<table>
<tr>
  <th>Opção</th>
  <th>Descrição</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>permissões</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>inode</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>número de links</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>usuário</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>grupo</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>tamanho</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>contagem de bloco</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>mtime</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>atime</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>ctime</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>verificar tamanho crescente</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>checksum de md5</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>checksum de sha1</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>checksum de rmd160</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>checksum de tiger</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>Grupo vazio</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>Arquivo de registro crescente p+u+g+i+n+S</ti>
</tr>
</table>

<p>
E se o AIDE for compilado com suporte a mhash ele suporta algumas funções a mais:
</p>

<table>
<tr>
<th>Opção</th>
<th>Descrição</th>
</tr>
<tr>
<ti>haval</ti>
<ti>checksum de haval</ti>
</tr>
<tr>
<ti>gost</ti>
<ti>checksum de gost</ti>
</tr>
<tr>
<ti>crc32</ti>
<ti>checksum de crc32</ti>
</tr>
</table>

<p>
Agora crie suas próprias regras com base nas opções acima combinando-as
das seguinte maneira:
</p>

<pre caption="Criando conjunto de regras para o AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
A última coisa que precisamos para criar nosso arquivo de configuração é ver como adicionar
uma regra a um arquivo ou diretório. Para entrar com uma regra, combine o nome de arquivo ou diretório
e a regra. O AIDE irá adicionar todos arquivos recursivamente a menos que você especifique uma
regra alternativa.
</p>

<table>
<tr>
<th>Opção</th>
<th>Descrição</th>
</tr>
<tr>
<ti>!</ti>
<ti>Não adicionar este arquivo ou diretório.</ti>
</tr>
<tr>
<ti>=</ti>
<ti>Adicionar este diretório, mas não recursivamente.</ti>
</tr>
</table>

<p>
Então vamos ver um exemplo completo:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# O local do banco de dados a ser lida.
database=file:@@{AIDEDIR}/aide.db

# O local do banco de dados a ser gravado.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Definição de regras
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
No exemplo acima nós especificamos algumas macros onde o topdir começa e
onde o diretório do AIDE está. O AIDE verifica o arquivo <path>/etc/aide/aide.db</path>
para verificar a integridade de arquivo. Mas quando atualizando ou criando um novo arquivo ele
grava a informação em <path>/etc/aide/aide.db.new</path>. Isto é feito para que ele
não sobre-escreva o arquivo db antigo automaticamente. A opção
<c>report_URL</c> ainda não está implementada, mas a intenção do autor era
poder enviar e-mail ou talvez até executar scripts.
</p>

<p>
Depois de editar a configuração você deve criar seu arquivo db executando
<c>aide -i</c> e copiando o arquivo <path>/etc/aide/aide.db.new</path> para
<path>/etc/aide/aide.db</path> e adicionar a verificação ao cron executando
<c>crontab -e</c> como root.
</p>

<note>
Dependendo da sua CPU, velocidade de acesso a disco, e opções use que você tem nos arquivos,
isto pode levar um tempo.
</note>

<pre caption="Agendar o aide como cronjob">
0 3 * * * /usr/bin/aide -u
</pre>

<note>
Lembre-se de configurar um alias para que você receber o correio do root. Senão, você nunca saberá
quando o AIDE der notícias.
</note>

<p>
Neste caso ele roda uma vez às 3 da manhã. Isto é feito já que eu não quero perturbar
os usuários quando eles estao trabalhando. Note que estou usando a opção <c>-u</c> (Update)
ao invés de <c>-C</c> (Check). Já que <c>-u</c> também verifica os arquivos e
não sobre-escreve o arquivo db original isto economiza tempo já que tudo que você precisa fazer
é copiar um arquivo quando ele detectar algumas mudanças. Apenas verifique as mudanças para ver
se foi você que as fez ao invés de um indivíduo malicioso antes de copiar!
</p>

<p>
Há um risco inerente em gravar os arquivos db localmente, já que o
indivíduo malicioso irá (se souberem que o AIDE está instalado) quase certamente tentar alterar
o arquivo db, atualizar o arquivo db ou modificar <path>/usr/bin/aide</path>. Então você
deve criar um CD ou outra mídia e colocar uma cópia do arquivo .db e binário do
AIDE.
</p>

<p>
Pode-se encontrar mais informações na página de projeto do <uri
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort é um sistema de detecção de intrusão de rede (NIDS). Para instalar e configurá-lo
use os seguintes exemplos.
</p>

<pre caption="Adicione um usuário snort ao sistema">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>(Passo 1)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(Passo 2)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(Passo 3)</comment>
include classification.config

<comment>(Passo 4)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NOVAS CLASSIFICAÇÕES
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Mais informações no website do <uri
link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>

<section>
<title>Detectando malware com o chkrootkit</title>

<body>

<p>
HIDS como o AIDE são um bom jeito de detectar mudanças em seu sistema, mas nunca
faz mal ter outra linha de defesa. O <c>chkrootkit</c> é um utilitário que varre
arquivos de sistema comuns procurando a presença de rootkits--software desenhado para esconder as
ações de um invasor e permitir a ele manter seu acesso--e escaneia seu sistema por
traços prováveis de gravadores de teclas e outros "malware". Enquanto o <c>chkrootkit</c> (e
alternativas como o <c>rkhunter</c>) são ferramentas úteis, tanto para a manutenção
de sistema quanto para rastrear um intruso depois que um ataque aconteceu, eles
não podem garantir que seu sistema está seguro.
</p>

<p>
O melhor jeito de usar o <c>chkrootkit</c> para detectar uma invasão é rodá-lo
rotineiramente como <c>cron</c>. Para iniciar, faça emerge <path>app-admin/chkrootkit</path>. 
O <c>chkrootkit</c> pode ser rodado da linha de comando com o comando de mesmo
nome, ou do <c>cron</c> com uma entrada parecida com o seguinte:
</p>

<pre caption="Agendar chkrootkit como um cronjob">
0 3 * * * /usr/sbin/chkrootkit
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Mantendo-se atualizado</title>
<section>
<body>

<p>
Uma vez que você instalou seu sistema com sucesso e garantiu um bom nível de
segurança você ainda não acabou. A segurança é um processo contínuo; a vasta maioria das
invasões resultam de vulnerabilidades conhecidas em sistemas não atualizados. Manter seu
sistema atualizado é o passo mais importante que você pode tomar para a maior
segurança.
</p>

<p>
Se você tiver uma versão recente do <c>portage</c> instalada, você pode primeiro sincronizar
sua árvore do portage com <c>emerge --sync</c> e depois rodar o comando
<c>glsa-check --list</c> para verificar se seu sistema está atualizado com relação à segurança.
<c>glsa-check</c> faz parte de <c>app-portage/gentoolkit</c>.
</p>

<pre caption="Exemplo de saída de glsa-check -l">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.

[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
O <c>glsa-check</c> ainda é experimental, então se a segurança realmente é sua prioridade
maior é inteligente verificar a lista com outras fontes.
</warn>

<p>
Todas linhas com um <c>[A]</c> e <c>[U]</c> podem quase seguramente ser ignoradas
já que o sistema não é afetado por essas GLSA.
</p>

<p>
Algumas pessoas ainda preferem usar <c>emerge packagename</c> ao invés de
<c>glsa-check -f</c> então todas GLSAs são listadas como <c>[N]</c>.
</p>

<p>
Se você quiser receber um e-mail cada vez que uma GLSA for lançada inscreva-se na
listagem de e-mails do <c>gentoo-announce</c>. Instruções para inscrever-se e outras
boas listagens de e-mail podem ser encontradas em <uri link="/main/en/lists.xml">Visão geral das
listagens de e-mail do Gentoo Linux</uri>.
</p>

<p>
Outro bom recurso de segurança é a<uri
link="http://www.securityfocus.com/archive/1">Listagem de e-mails do
Bugtraq</uri>.
</p>

</body>
</section>
</chapter>
</guide>
