<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/udev-guide.xml,v 1.2 2005/01/27 19:04:37 enderson Exp $ -->

<guide link="/doc/pt_br/udev-guide.xml">
<title>Guia de udev do Gentoo</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Colaborador">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Tradutor">
  <mail link="marcelogoes@gmail.com">Marcelo Góes</mail>
</author>

<abstract>
Este documento explica o que é o udev e como você pode usar o udev para atender às suas necessidades.
</abstract>

<license/>

<version>0.18</version>
<date>2004-11-28</date>

<chapter>
<title>O que é o udev?</title>
<section>
<title>O diretório /dev</title>
<body>

<p>
Quando usuários de Linux falam sobre o hardware em seu sistema na companhia de
pessoas que acreditam que o Linux é um tipo de vírus ou marca de café, o uso de
"barra dev barra algo" com certeza trará um olhar estranho. Mas para os felizes
usuários (e isso inclui você) usar <path>/dev/hda1</path> é só um jeito rápido de
explicar que estamos falando do primeiro IDE mestre, primeira partição. Ou
não estamos?
</p>

<p>
Nós todos sabemos o que é um arquivo de dispositivo. Alguns até sabem porque arquivos de dispostivos têm
número especiais quando os vemos mais de perto quando rodamos <c>ls -l</c> em
<path>/dev</path>. Mas o que sempre tomamos como garantido é que o disco
IDE mestre primário é referido como <path>/dev/hda</path>. Você pode não concordar,
mas isso é uma falha de desenho.
</p>

<p>
Pense sobre dispositivos que fazem hot-plug, como USB, IEEE1394, hot-swappable PCI, ... Qual
é o primeiro dispositivo? E por quanto tempo? Qual será o nome dos outros dispositivos quando
o primeiro desaparecer? Como irá afetar as transações que estiverem acontecendo? Não seria
muito legal se um trabalho de impressão mudasse de sua impressora a laser super-nova para
sua quase impressora matricial quase morta porque sua mãe tirou o plugue da
impressora a laser que era a primeira impressora?
</p>

<p>
Aqui entra o <e>udev</e>. As metas do projeto de udev são tão interessantes quanto
necessárias:
</p>

<ul>
  <li>Roda em espaço de usuário</li>
  <li>Cria/remove arquivos de dispositivo dinamicamente</li>
  <li>Fornece nomes consistentes</li>
  <li>Fornece uma API em espaço de usuário</li>
</ul>

<p>
Para fornecer essas funções, o udev é desenvolvido em três projetos separados:
<e>namedev</e>, <e>libsysfs</e> e, claro, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
O namedev permite que você defina os nomes dos dispositivos à parte do programa udev.
Isto permite políticas de nomes flexíveis e esquemas de nomeamento desenvolvidos por
entidades separadas. O subsistema de nomeamento de dispositivos fornece uma interface padrão
que o udev pode usar.
</p>

<p>
Atualmente só um esquema de nomes é fornecido pelo namedev; o fornecido
pela LANANA, usado pela maior parte dos sistema Linux atualmente e portanto muito
útil para a maior parte dos usuários de Linux.
</p>

<p>
O namedev usa um procedimento de 5 passos para descobrir o nome de um dispositivo. Se o
nome do dispositivo for encontrado nos passos dados, o nome é usado. Os passos
são:
</p>

<ul>
  <li>número ou etiqueta serial</li>
  <li>número do bus de dispositivo</li>
  <li>topologia de bus</li>
  <li>nome dado estaticamente</li>
  <li>nome dado pelo kernel</li>
</ul>

<p>
O passo <e>número ou etiqueta serial</e> verifica se o dispositivo tem um identificador
singular. Por exemplo, dispositivos USB tem um número serial de USB singular; dispositivos
SCSI tem um UUID singular. Se o namedev encontrar uma relação entre o número singular
e um dado arquivo de configuração, o nome fornecido no arquivo de configuração é
usado.
</p>

<p>
O passo <e>número do bus de dispositivo</e> verifica número do bus de dispositivo. Para
ambientes sem hot-swap o procedimento é suficiente para
identificar um dispositivo de hardware. Por exemplo, números de BUS de PCI raramente mudam durante
a vida de um sistema. Novamente,  se o namedev encontrar uma relação entre esta posição e
o dado arquivo de configuração, o nome fornecido no arquivo de configuração é
usado.
</p>

<p>
De forma semelhante a <e>topologia de bus</e> é um jeito estático de definir dispositivos
contanto que o usuário não mude os dispositivos. Quando a posição dispositivo bater
com um ajuste dado pelo usuário, o nome que acompanha é usado.
</p>

<p>
O quarto passo, <e>nome dado estaticamente</e>, é uma simples troca de nomes.
Quando o nome do kernel (o nome padrão) bater com uma expressão de troca, o
nome substituto será usado.
</p>

<p>
O passo final (<e>nome dado pelo kernel</e>) é um pega-tudo: ele pega
o nome padrão dado pelo kernel. Na maioria dos casos isso é
suficiente já que bate com os nomes dos dispositivos usados em sistemas Linux atuais.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
O udev interage com o kernel através do pseudo sistema de arquivos sysfs. O projeto
libsysfs fornece uma API comum para acessar informações através do sistema de arquivos
sysfs de modo genérico. Isto permite trabalhar com todos tipos de hardware
sem ter que presumir que tipo de hardware será usado.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Toda vez que o kernel percebe uma mudança na estrutura de dispositivos, ele chama o
programa <path>/sbin/hotplug</path>. O hotplug roda a aplicação linkada no 
diretório <path>/etc/hotplug.d/default</path> onde você também encontrará um link simbólico
para aplicação udev. O hotplug dirige a informação dada pelo kernel para
a aplicação udev que toma as ações necessárias na
estrutura de <path>/dev</path> (criando ou destruindo arquivos de dispositivo).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Usando o udev no Gentoo</title>
<section>
<title>Requisitos</title>
<body>

<p>
O udev é feito para ser usado em combinação com um kernel 2.6 (como
<c>development-sources</c> ou <c>gentoo-dev-sources</c>). Se você estiver usando um
desses kernéis então você deve certificar-se que você tem uma versão 
recente do <c>sys-apps/baselayout</c>. É tudo que você precisa.
</p>

<pre caption="Instalando o udev">
# <i>emerge udev</i>
</pre>

<p>
O udev irá instalar o <c>hotplug-base</c> como uma de suas dependências.
Você não precisa instalar o <c>hotplug</c> se você não quer seus módulos sejam
carregados automaticamente quando você plugar dispositivos. O <c>hotplug</c> também lida com
o levante automático de dispositivos de rede e baixar firmwares.
</p>

<pre caption="Instalando scripts opcionais de hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Se você quiser módulos carregados para dispositivos que foram plugados antes de você
iniciar, use o pacote coldplug:
</p>

<pre caption="Instalando o pacote coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Em relação kernel, certifique-se de ativar as seguintes opções:
</p>

<pre caption="Opções de kernel necessárias">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Você pode deixar o <c>/dev file system support (OBSOLETE)</c> ativo se você
desejar mas certifique-se que "Automatically mount at boot" esteja desligado:
</p>

<pre caption="Não montar o devfsd automaticamente">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Se você usar o <c>genkernel</c>, não se esqueça de rodá-lo com a opção <c>--udev</c>
para ativar as diretivas de configuração de kernel necessárias. A configuração
padrão dada pelo comando <c>genkernel</c> é suficiente.
</p>

</body>
</section>
<section>
<title>Configuração</title>
<body>

<p>
Se você quiser usar os ajustes de udev que o Gentoo adicionou para deixar sua vida
mais fácil, pare de ler aqui. O Gentoo irá usar o udev, mas manterá um
<path>/dev</path> estático para que você nunca tenha nódulos de dispositivos faltando.
Os scripts de init do Gentoo não irão rodar o daemon devfsd e irão desligar o devfs
quando você iniciar.
</p>

<p>
Mas se você é duro na queda e quer usar um sistema só com udev, sem ajustes como
feito pelos desenvolvedores do udev (incluindo as dificuldades de nódulos de sistema
faltando porque o udev ainda não os suporta), por favor, leia mais :)
</p>

<p>
Nós iremos desligar as regras para salvar os nódulos de arquivos de dispositivos: edite a 
variável <c>RC_DEVICE_TARBALL</c> no <path>/etc/conf.d/rc</path> e configure-a como
<c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Se você incluiu suporte a devfs no kernel, você pode desativá-lo na
configuração do gerenciador de inicialização: adicione <c>gentoo=nodevfs</c> como parâmetro de kernel.
Se você quiser usar devfs e desativar udev, adicione <c>gentoo=noudev</c> como parâmetro
de kernel.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemas conhecidos</title>
<section>
<title>Arquivos de nódulos de dispositivos faltando na inicialização</title>
<body>

<p>
Se você não puder iniciar com sucesso porque você obtém um erro sobre
<path>/dev/null</path> não encontrado, ou porque o console inicial está faltando, o
problema é que você não tem alguns arquivos de dispositivos que devem estar disponíveis <e>antes</e> do
<path>/dev</path> ser montado e gerenciado pelo udev. Isto é comum em máquinas Gentoo
instaladas de mídias antigas.
</p>

<p>
Se você estiver rodando <c>sys-apps/baselayout-1.8.12</c> ou mais recente, o problema é
menor já que o processo de inicialização ainda conseguirá completar. No entanto, para
livrar-se desses avisos perturbadores, você deve criar os nódulos de dispositivos
como descrito abaixo.
</p>

<p>
Para ver que nódulos de dispositivo estão presentes antes do sistema de arquivos <path>/dev</path>
ser montado, rode os seguintes comandos:
</p>

<pre caption="Listando nódulos de dispositivos disponíveis na inicialização">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Os dispositivos necessários para uma inicialização com sucesso são <path>/dev/null</path> e
<path>/dev/console</path>. Se eles não apareceram no teste anterior, você tem
que criá-los manualmente. Faça os seguintes comando no
diretório <path>test/dev/</path>:
</p>

<pre caption="Criando os arquivos de nódulos de dispositivo necessários">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Quando você terminar, não se esqueça de desmontar o diretório <path>test/</path>:
</p>

<pre caption="Desmontando o diretório test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev e nvidia</title>
<body>

<p>
Se você usa os drivers proprietários da nVidia e o servidor de X não conseguir iniciar
em um sistema somente de udev, verifique que você tem:
</p>

<ul>
  <li>
    o módulo <c>nvidia</c> listado em
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    uma versão do <c>nvidia-kernel</c> igual ao maior ao
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    uma versão do baselayout igual ou maior ao
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

</body>
</section>
<section>
<title>Nomes de LVM2 desaparecem</title>
<body>

<p>
Quando você usar <c>udev</c> e LVM2 juntos, você pode perceber que seus grupos de
volume e volumes lógicos que você criou desapareceram. Bom, eles não desapareceram, mas eles
são infelizmente chamados de <path>/dev/dm-#</path> com # sendo 0, 1, ...
</p>

<p>
Para arrumar isso, edite o <path>/etc/udev/rules.d/50-udev.rules</path> e descomente a
seguinte linha:
</p>

<pre caption="Descomente essa linha do /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

</body>
</section>
<section>
<title>Falta de consistência de nomes entre DevFS e udev</title>
<body>

<p>
Embora nossa intenção seja ter um esquema de nomes consistente entre as duas
soluções de gerenciamento dinâmico de dispositivos, às vezes diferenças de nome acontecem.
</p>

<p>
O problema que nos foi relatado é de um HP Smart Array 5i RAID controller (mais precisamente o
módulo de kernel <c>cciss</c>). Com o udev, os dispositivos são chamados de
<path>/dev/cciss/cXdYpZ</path> com X, Y e Z sendo números normais. Com o devfs, os
dispositivos são <path>/dev/hostX/targetY/partZ</path> ou um link simbólico de
<path>/dev/cciss/cXdY</path>.
</p>

<p>
Se este for o caso, não se esqueça de atualizar seu <path>/etc/fstab</path> e
arquivos de configuração de gerenciador de inicialização corretamente.
</p>

<p>
O mesmo acontece com links simbólicos que costumavam existir em
<path>/dev</path>, como <path>/dev/mouse</path>, que o <c>udev</c> não
cria mais. Tenha certeza de verificar seu arquivo de configuração de X e ver se a
regra Device para seu mouse aponta para um arquivo de dispositivo existente.
</p>

</body>
</section>
<section>
<title>Outros problemas</title>
<body>

<p>
Se os nódulos de dispositivo não são criados quando um módulo é carregado de
<path>/etc/modules.autoload.d/kernel-2.6</path>, mas eles aparecem quando você carrega
o módulo manualmente com modprobe, então você deve experimentar atualizar para o
<c>sys-apps/baselayout-1.8.12</c> ou mais recente.
</p>

<p>
Suporte para dispositivos de framebuffer (<path>/dev/fb/*</path>) vem com kernéis
começando a partir da versão 2.6.6-rc2.
</p>

<p>
Para kernéis mais antigos que o 2.6.4 você tem que explicitamente incluir suporte para o
sistema de arquivos <path>/dev/pts</path>.
</p>

<pre caption="Ativando o sistema de arquivos /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Recursos &amp; reconhecimentos</title>
<section>
<body>

<p>
A palestra de udev no Linux Symposium (Ottawa, Ontario Canadá - 2003) dada por
Greg Kroah-Hartman (IBM Corporation) forneceu uma sólida compreensão da aplicação
do udev.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> é um guia profundo sobre udev e Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Escrevendo regras de udev</uri> pelo
desenvolvedor do Gentoo Daniel Drake é um excelente documento para aprender como
personalizar sua instalação de udev.
</p>

</body>
</section>
</chapter>

</guide>
