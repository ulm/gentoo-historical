<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/security/shb-firewalls.xml,v 1.1 2005/06/04 19:36:15 vanquirius Exp $ -->
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<sections>

<version>1.0</version>
<date>2005-05-31</date>

<section>
<title>Uma firewall</title>
<body>

<p>
As pessoas normalmente pensam que uma firewall fornece o mais alto nível de segurança, mas
estão enganadas. Na maior parte dos casos uma firewall mal-configurada dá menos segurança que
não ter nenhuma. Uma firewall também é feita de software e deve ser
tratada do mesmo jeito que qualquer outro software, porque tem a mesma chance
de conter defeitos.
</p>

<p>
Então pense antes de implementar uma firewall! Você realmente precisa de uma? Se você acha
que você precisa de uma, escreva uma política sobre como deve funcionar, que tipo de firewall, e
quem deve operá-la. Mas antes leia este guia.
</p>

<p>
Firewalls são usadas para dois propósitos:
</p>

<ul>
<li>Manter usuários (worms/indivíduos maliciosos) fora</li>
<li>Manter usuários (empregados/crianças) dentro</li>
</ul>

<p>
Basicamente há três tipos de firewalls:s
</p>

<ul>
<li>Filtro de pacotes</li>
<li>Relay de circuitos</li>
<li>Roteador de aplicações</li>
</ul>

<p>
Uma firewall deve ficar em uma máquina dedicada que não roda serviços (ou unicamente 
<c>sshd</c>) e segura do jeito que este guia recomenda que seja.
</p>

</body>
</section>
<section>
<title>Filtro de pacotes</title>
<body>

<p>
Todo tráfego de rede é enviado na forma de pacotes. Grandes quantidades de tráfego são
divididas em pacotes menores para facilitar seu manuseio e são re-montados quando
chegam em seu destino. No cabeçalho de pacote todos pacotes contêm
informações de como e onde devem ser levados. E esta informação é
exatamente o que uma firewall de filtro de pacotes usa. A filtragem é baseada em:
</p>

<ul>
<li>Permitir ou proibir pacotes com base em endereço de IP fonte/destino</li>
<li>Permitir ou proibir pacotes com base em porta de fonte/destino</li>
<li>Permitir ou proibir pacotes com base em protocolo</li>
<li>Permitir ou proibir pacotes com base em opções dentro de um protocolo específico</li>
</ul>

<p>
Em outras palavras, a filtragem é baseada em todos os dados do cabeçalho de um
pacote e não seu conteúdo.
</p>

<p>
Fraquezas:
</p>

<ul>
<li>
  Informações de endereço em um pacote podem potencialmente conter um endereço IP falso (ou como
  dizemos <e>spoofados</e>) pelo enviador.
</li>
<li>
  Dados ou pedidos dentro do pacote permitido podem conter dados não-desejável que o
  indivíduo malicioso pode usar para explorar bugs conhecidos nos serviços na firewall ou atrás dela
</li>
<li>Normalmente único ponto de falha</li>
</ul>

<p>
Vantagens:
</p>

<ul>
<li>Simples e fácil de implementar</li>
<li>
  Pode dar avisos de um possível ataque antes de acontecer (isto é, detectando
  escaneadores de portas)
</li>
<li>Bom para deter ataques de SYN</li>
</ul>

<p>
Exemplos de filtros de pacotes gratuitos para Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>
<!--FIXME: should SmoothWall really be included, since it uses iptables?-->
<note>
É recomendável que você use iptables. Ipchains está obsoleto.
</note>

</body>
</section>
<section>
<title>Relay de circuitos</title>
<body>

<p>
Um roteador em nível de circuito é uma firewall que valida as conexões antes de permitir
que os dados sejam trocados. Isto significa que ele não simplesmente permite ou nega pacotes
com base no cabeçalho do pacote, mas também determina se a conexão entre os dois
lados é válida de acordo com regras configuráveis antes de abrir uma sessão e
permitir que dados sejam trocados. A filtragem é baseada em:
</p>

<ul>
<li>Endereço IP de fonte/destino</li>
<li>Porta de fonte/destino</li>
<li>Um período de tempo</li>
<li>Protocolo</li>
<li>Usuário</li>
<li>Senha</li>
</ul>

<p>
Todo tráfego é validado e monitorado, e tráfego não desejável pode ser ignorado.
</p>

<p>
Fraquezas:
</p>

<ul>
<li>
  Opera no layer de transporte e pode necessitar de modificação substanciais nos
  programas que normalmente fornecem funções de transporte.
</li>
</ul>

</body>
</section>
<section>
<title>Roteador de aplicações</title>
<body>

<p>
Um roteador de nível de aplicações é um proxy para aplicações, trocando dados com
sistemas remotos em nome dos clientes. É mantido longe do público seguramente
atrás de uma DMZ (De-Militarized Zone: a porção de uma rede privada que é
visível através da firewall) ou uma firewall que não permite conexões do
lado de fora. A filtragem é baseada em:
</p>

<ul>
<li>Permitir ou impedir com base em endereço IP de fonte/destino</li>
<li>Baseado no conteúdo do pacote</li>
<li>Limita acesso de arquivos com base no tipo de arquivo ou extensão</li>
</ul>

<p>
Vantagens:
</p>

<ul>
<li>Pode fazer cachê de arquivos, aumentando performance de rede</li>
<li>Registros detalhados de todas conexões</li>
<li>Boa escalabilidade (alguns servidores de proxy podem "compartilhar" dados em cachê)</li>
<li>Não tem acesso direto do exterior</li>
<li>Pode alterar até o conteúdo do pacote na hora</li>
</ul>

<p>
Desvantagens:
</p>

<ul>
<li>Configuração é complexa</li>
</ul>

<p>
Roteadores de aplicações são considerados a solução mais segura já que eles
não tem que rodar como root e os hosts atrás deles não são alcançáveis através da
Internet.
</p>

<p>
Exemplo de um roteador de aplicações gratuito:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Para usar o iptables, ele deve estar ativado no kernel. Eu adicionei o
iptables como módulos (o comando <c>iptables</c> carrega-os conforme eles são
necessários) e re-compilei meu kernel (mas você pode compilar o iptables dentro do kernel, se
você tem a intenção de desligar suporte de módulos carregáveis, como discutimos anteriormente). Para mais
informações em como configurar seu kernel para o iptables vá para o <uri link =
"http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Tutorial de Iptables
Capítulo 2: Preparativos</uri>. Depois que você compilou ser kernel
(ou durante a compilação do kernel, você deve adicinoar o comando <c>iptables</c>.
Simplesmente faça <c>emerge iptables</c> e ele deve funcionar.
</p>

<p>
Agora teste se ele funciona rodando <c>iptables -L</c>. Se falhar algo
está errado e você tem quer verificar sua configuração mais uma vez.
</p>

<p>
O Iptables é o novo e muito melhorado filtro de pacotes do kernel do Linux
2.4.x. Ele é o sucessor do antigo filtro de pacotes ipchains do kernel do Linux
2.2.x. Uma das grandes melhorias é que o iptables agora pode fazer filtro
de pacotes "stateful". Com o filtro de pacotes stateful é possível
controlar cada conexão TCP estabelecida.
</p>

<p>
Uma conexão TCP consiste de uma série de pacotes contendo informações sobre
endereço IP de fonte, endereço IP de destino, porta de fonte, porta de destino, e um
número de seqüência para que os pacotes possam ser re-montados sem perder dados. TCP é um
protocolo orientado à conexão, diferente do UDP, que funciona sem conexão.
</p>

<p>
Examinando o cabeçalho do pacote TCP, um filtro de pacotes stateful pode determinar se um
pacote TCP recebido é parte de uma conexão já estabelecida ou não e
decidir aceitar ou ignorar o pacote.
</p>

<p>
Com um filtro de pacotes não-stateful é possível enganar o filtro de pacotes a
aceitar pacotes que deveriam ser ignorados manipulando os cabeçalhos dos pacotes TCP.
Isto pode ser feito manipulando as opções de SYN ou outras opções no cabeçalho de TCP
para fazer um pacote malicioso parecer ser parte de uma conexão estabelecida
(já que o filtro de pacotes em si não suporte rastreamento de conexões). Com o filtro de
pacotes stateful é possível ignorar esses pacotes, já que eles não são parte de uma
conexão pré-estabelecida. Isto também irá parar a possibilidade de
"stealth scans", um tipo de escaneamento de portas em que o escaneador manda pacotes
com opções que são muito menos possíveis de serem registradas por uma firewall que pacotes
SYN normais.
</p>

<p>
O Iptables fornece várias outras funções como NAT (Network Address Translation) 
e limite de taxas. O limite de taxas é extremamente útil na prevenção de
certos ataques de DoS (Denial of Service) como SYN floods.
</p>

<p>
Uma conexão de TCP é estabelecida pelo chamado cumprimento de três jeitos. Na hora
de estabelecer uma conexão TCP o lado do cliente envia um pacote para o servidor
com a opção SYN ligada. Quando o servidor recebe o pacote SYN ele
responde mandando um pacote SYN+ACK de volta para o cliente. Quando o pacote SYN+ACK
é recebido o lado do cliente responde com um terceiro pacote ACK reconhecendo
a conexão em efeito.
</p>

<p>
Um ataque de SYN flood é feito mandando o pacote SYN mas não enviando a
resposta ao pacote SYN+ACK. O lado do cliente pode forjar um pacote um endereço
IP falso porque não precisa de uma resposta. O sistema do servidor irá
adicionar uma entrada na fila de conexões parcialmente abertas quando recebe o
pacote SYN e esperar o pacote ACK final antes de apagar a entrada da
fila. A fila tem um número limitado de vagas e se todas vagas estiverem
preenchidas antes um tempo de espera especificado a entrada será automaticamente
apagada da fila. Os ajustes de espera variam mas são tipicamente de 30-60 
segundos ou até mais. O lado do cliente inicia o ataque forjando vários pacotes
SYN com endereços IP de fontes diferentes e enviando-os para o endereço IP
alvo o mais rápido possível e portanto preenchendo a fila de conexões parcialmente
abertas, impedindo que outros clientes estabeleçam conexões legítimas
com o servidor.
</p>

<p>
Aqui é onde o limite de taxas torna-se útil. É possível limitar a taxa de
pacotes SYN aceitos usando <c>-m limit --limit 1/s</c>. Isto irá
limitar o número de pacotes SYN aceitos para um por segundo e portanto
restringir o SYN flood em nossos recursos.
</p>

<note>
Outra opção para impedir SYN floods são os <uri link =
"http://cr.yp.to/syncookies.html">SYN cookies</uri>, que permitem que seu computador
responda a pacotes de SYN sem preencher espaço na fila de conexões. SYN
cookies podem ser ativados na configuração do kernel do Linux, mas eles são
considerados experimentais no momento.
</note>

<p>
Algumas coisas práticas agora!
</p>

<p>
Quando o iptables é carregado no kernel ele tem 5 ganchos onde você pode colocar suas
regras. São chamados <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>, 
<c>PREROUTING</c> e <c>POSTROUTING</c>. Cada um deles é chamado de uma cadeia e
consite de uma lista de regras. Cada regra diz se o cabeçalho do pacote parecer-se com
isso, aqui está o que fazer com o pacote. Se a regra não bater com
o pacote a próxima regra da cadeia é consultada.
</p>

<p>
Você pode colocar as regras diretamente nas 5 cadeias principais ou criar novas cadeias e adicioná-las
como uma regra para uma cadeia existente. O Iptables suporta as seguintes opções.
</p>

<table>
<tr>
  <th>Opção:</th>
  <th>Descrição:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>Anexar</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>Apagar</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>Inserir</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>Trocar</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>Listar</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>Apagar todas regras na cadeia ou todas cadeias</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>Zerar contadores na cadeia ou todas cadeias</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>Testar este pacote na cadeia</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>Criar uma nova cadeia definida por usuário</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>Apagar uma cadeia definida por usuário</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>Mudar política na cadeia alvo</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>Mudar nome da cadeia</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>Protocolo</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>Endereço de fonte/máscara</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>Endereço de destino/máscara</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>Nome da entrada (nome de ethernet)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>Nome de saída (nome de ethernet)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>Pular (alvo para regra)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>Relaçao extendida (pode usar extensão)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>Saída numérica de endereços e portas</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>Tabela para manipular</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>Modo verbal</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>Expandir números (mostrar valores exatos)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>Fazer relação só do segunfo fragmento e posteriores</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>Versão do pacote</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>Mostrar número das linhas quando listando</ti>
</tr>
</table>

<p>
Primeiro iremos experimentar bloquear todos pacotes ICMP em nossa máquina, só para ficarmos familiares
com o iptables.
</p>

<pre caption="Bloquear todos pacotes ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Primeiro especificamos a cadeia a que nossa regra deve ser anexada, depois o protocolo
dos pacotes para relacionar, e finalmente o alvo. O alvo pode ser o nome de uma
cadeia especificado pelo usuário ou um dos alvos especiais <c>ACCEPT</c>, <c>DROP</c>,
 <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c>, ou <c>MASQUERADE</c>. Neste caso nós
 usamos <c>DROP</c>, que irá ignorar o pacote sem responder para o cliente.
</p>

<note>
O alvo <c>LOG</c> também é o que conhecido como "não-terminante". Se o pacote relacionar-se
com uma regra do alvo <c>LOG</c>, ao invés de parar a avaliação, o pacote
continuará a ser relacionado com outros filtros. Isto permite registrar pacotes
e ainda processá-los normalmente.
</note>

<p>
Agora experimente <c>ping localhost</c>. Você não irá receber nenhuma resposta, já que o iptables
irá ignorar todas mensagens de ICMP que chegarem. Você também não poderá fazer ping de outras
máquinas, já que o pacote de respostas ICMP será ignorado também. Agora limpe a
cadeia para iniciar o fluxo de ICMP novamente.
</p>

<pre caption="Limpando todas regras">
# <i>iptables -F</i>
</pre>

<p>
Agora vamos olhar o filtro de pacotes stateful no iptables. Se nós quisermos
ativar a inspeção stateful de pacotes chegando na eth0 nós faríamos o seguinte
comando:
</p>

<pre caption="Aceitar pacotes oriundos de uma conexão já estabelecida">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Isto irá aceitar qualquer pacote de uma conexão já estabelecida ou relacionada na
cadeia INPUT. E você pode ignorar qualquer pacote que já não estiver na tabela de estados
rodando <c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> antes
do comando anterior. Isto ativa o filtro de pacotes stateful no
iptables carregando a extensão "state". Se você quisesse permitir que outros
conectem-se a sua máquina, você pode usar a opção <c>--state NEW</c>. O Iptables
contém alguns módulos para propósitos diferentes. Alguns deles são:
</p>

<table>
<tr>
  <th>Módulo/Relação</th>
  <th>Descrição</th>
  <th>Opções extendidas</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>Extensão de relação para o endereço de mac dos pacotes que chegam.</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>Ativa inspeção stateful</ti>
  <ti>--state (estados são ESTABLISHED,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>Limite de taxas de relação</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>Tentar relacionar várias características do dono do pacote</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>Várias verificações de sanidade dos pacotes</ti><ti></ti>
</tr>
</table>

<p>
Vamos tentar criar uma cadeia definida por usuário e aplicá-la a uma das cadeias
existentes:
</p>

<pre caption="Criando uma cadeia definida por usuário">
<comment>(Crie uma nova cadeia com uma regra)</comment>
# <i>iptables -X minhacadeia</i>
# <i>iptables -N minhacadeia</i>
# <i>iptables -A minhacadeia -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(A política padrão é que todo tráfego para fora é permitido. Todo tráfego de entrada é ignorado.)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(E adicione à cadeia INPUT)</comment>
# <i>iptables -A INPUT -j minhacadeia</i>
</pre>

<p>
Aplicando a regra à cadeia input nós obtemos a política: Todos pacotes saindo
são permitidos e todos entrando são ignorados.
</p>

<p>
Pode-se encontrar documentação em <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables
documentation</uri>.
</p>

<p>
Vamos ver um exemplo completo. Neste caso minha política de firewall/roteador diz:
</p>

<ul>
<li>Conexões para a firewall só são permitidas através de SSH (porta 22)</li>
<li>
  A rede local deve ter acesso a HTTP, HTTPS e SSH (DNS também deve
  ser permitido)
</li>
<li>
  tráfego de ICMP pode conter payload e não deve ser permitido. Claro que temos de
  permitir um certo tráfego de ICMP.
</li>
<li>Escaneamentos de portas devem ser detectados e registrados</li>
<li>Ataques de SYN devem ser evitados</li>
<li>Todo outro tráfego deve ser ignorado e registrado</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Configurando regras internas"

  einfo "Configurando o padrão para negar"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #regra padrão
  einfo "Criando cadeias de estados"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Pacote ruim de ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #tráfego de ICMP
  einfo "Criando cadeia de icmp"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "tráfego ruim de ICMP:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #tráfego de entrada
  einfo "Criando uma cadeia para tráfego ssh de entrada"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #proteção de flood
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #tráfego de saída
  einfo "Criando uma cadeia para tráfego ssh de saída"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Criando cadeia de saída de dns"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Criando cadeia de tráfego de saída http/https"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Pegar escaneadores de porta
  einfo "Criando cadeia de detecção de escaneamento de portas"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Aplicar a adicionar estados inválidos às redes
  einfo "Aplicando as cadeias a INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Aplicando as cadeias a FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Aplicando as cadeias a OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Permitir que o cliente roteie através de NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Iniciando firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} não existe. Usando regras padrão."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Parando firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "status de NAT"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Configurando regras de pânico"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Salvando regras de firewall"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restaurando regras de firewall"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Uso: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      irá restaurar ajuste se existir, caso contrário criar regras"
  echo "stop)       apagar todas regras e aceitar tudo"
  echo "rules)      forçar a configuração de novas regras"
  echo "save)       gravar configuraçõe em ${FIREWALL}"
  echo "restore)    restaurar configurações de ${FIREWALL}"
  echo "showstatus) Mostrar o status" 
}
</pre>

<p>
Conselhos antes de criar uma firewall:
</p>

<ol>
<li>Crie uma política de firewall antes de implementá-la</li>
<li>Mantenha simples</li>
<li>
Conheça como cada protocolo funciona (leia o <uri
link="http://www.ietf.org/">RFC</uri>(Request For Comments) relevante)
</li>
<li>
Tenha em mente que uma firewall é só outro software rodando como root.
</li>
<li>Teste sua firewall</li>
</ol>

<p>
Se você acha que o iptables é difícil de entender ou leva muito tempo para configurar
uma boa firewall você pode usar o <uri
link="http://www.shorewall.net">Shorewall</uri>. Ele basicamente usa o iptables para
gerar regras de firewall, mas concentra em regras e não protocolos específicos.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
O Squid é um servidor de proxy muito poderoso. Ele pode filtrar tráfego com base em hora,
expressões regulares (regex) sobre caminho/URI, endereço IP de fonte e destino, domínio,
navegador, usuário autenticado, tipo de MIME, e número de porta (protocolo). Eu
provavelmente esqueci de algumas funcionalidades, mas é difícil cobrir a lista inteira
aqui.
</p> 

<p>
No seguinte exemplo eu adicionei um filtro de banner ao invés de um filtro baseado
em sites pornôs. A razão para tanto é que Gentoo.org <e>não</e> deve ser
listado como um site pornô. E eu não quero perder meu tempo tentando descobrir alguns
sites bons para você.
</p>

<p>
Neste caso, minha política diz:
</p>

<ul>
<li>
Navegar (HTTP/HTTPS) é permitido durante horas de trabalho (segunda-sexta 8-17 e sábado 8-13),
mas se os empregados chegarem aqui atrasados devem trabalhar, não navegar
</li>
<li>
Baixar arquivos não é permitido (.exe, .com, .arj, .zip, .asf, .avi, .mpg,
.mpeg, etc)
</li>
<li>
Não gostamos de banners, então eles são filtrados e substituídos com um gif transparente
(aqui é onde você deve ser criativo!).
</li>
<li>
Todas outras conexões para e da Internet devem ser negadas.
</li>
</ul>

<p>
Isto é implementado em 4 passos <e>fáceis</e>.
</p>

<pre caption="/etc/squid/squid.conf">
# Prender em um ip e porta
http_port 10.0.2.1:3128

# Configuração padrão
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Listas de controle de acesso básicas
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Adicionar quem pode acessar este servidor de proxy
acl localnet src 10.0.0.0/255.255.0.0

# E portas
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Adicionar lista de controle de acesso com base em expressões
# regulares (regex) dentro de urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Adicionar lista de acesso de controle com base em hora e dia
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#permitir acesso do manager do localhost
http_access allow manager localhost
http_access deny manager

# Só permitir pedidos de purge do localhost
http_access allow purge localhost
http_access deny purge

# Negar pedidos em portas desconhecidas
http_access deny !Safe_ports

# Negar CONNECT fora portas de SSL
http_access deny CONNECT !SSL_ports

# Minhas próprias regras

# Adicionar uma página a ser mostrada quando
# um banner for removido
deny_info NOTE_ADS_FILTERED url_ads

# Então negá-los
http_access deny url_ads

# Negar todos arquivos
http_access deny archives

# Restringir acesso a horas de trabalho
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Negar o resto
http_access deny all
</pre>

<p>
A seguir preencha os arquivos que você não quer que seus usuários baixem. Eu adicionei
arquivos zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz
e z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Por favor note o [] com letras maiúsculas e minúsculas para cada caractere. Isto é feito para
ninguém enganar nosso filtro acessando um arquivo chamado AvI ao invés de avi
</note>

<p>
A seguir nós adicionamos as expressões regulares (regex) para identificar banners. Você será provavelmente
mais criativo que eu:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
E como a parte final nós queremos que este arquivo seja mostrado quando um banner for removido.
É basicamente meio arquivo html com uma imagem gif 4x4 transparente.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERRO: A URL pedida não pode ser obtida&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Anúncio filtrado!&lt;/H1&gt;
</pre>

<note>
Não feche as tags &lt;HTML&gt; &lt;BODY&gt;. O squid fará isso.
</note>

<p>
Como você pode ver, o Squid tem muitas possibilidades e é muito eficiente tanto
como filtro, como proxy. Ele pode até mesmo usar proxies de Squid alternativos para
escalabilidade em redes muito grandes. A configuração que eu listei aqui serve
para uma pequena rede com 1-20 usuários.
</p>

<p>
Mas combinar o filtro de pacotes (iptables) e a aplicação roteadora (Squid)
é provavelmente a melhor solução, mesmo se o Squid está localizado em um lugar seguro e
ninguém puder acessá-lo de fora. Nós ainda precisamos nos preocupar com
ataques do interior.
</p>

<p>
Agora você tem que configurar os navegadores de seus clientes para usar o servidor de proxy. O
roteador impedirá que usuários façam contato com o exterior se não
usarem o proxy.
</p>

<note>
No Mozilla isto é feito em Editar->Preferências->Avançado->Proxies.
</note>

<p>
Isto também pode ser feito transparentemente usando o iptables para encaminha todo tráfego 
de saída para o proxy do Squid. Isto pode ser feito adicionando uma regra de encaminhamento/pré-roteamento
no roteador:
</p>

<pre caption="Permitir encaminhamento de portas para nosso servidor de proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Se o proxy estiver rodando no host que filtra pacotes--embora não seja
recomendado, pode ser necessário se você não tiver máquinas sobrando--use
um alvo <c>REDIRECT</c> ao invés de <c>DNAT</c> (<c>REDIRECT</c> dirige os pacotes para o
localhost).
</note>

</body>
</section>
<section>
<title>Lições aprendidas</title>
<body>

<p>
Nós aprendemos que:
</p>

<ol>
<li>
Uma firewall pode ser um risco em cima mesma. Uma firewall mal configurada é pior que
não ter nenhuma.
</li>
<li>Como configurar um roteador básico e proxy transparente.</li>
<li>A chave para uma boa firewall é conhecer os protocolos que você quer permitir.</li>
<li>
Que tráfego de IP nem sempre contém dados legítimos, como pacotes ICMP,
que podem conter um payload malicioso.
</li>
<li>Como prevenir um ataque SYN.</li>
<li>Filtrar tráfego HTTP removendo gravuras ofensivas e downloads de vírus.</li>
<li>
Combinar filtros de pacotes e roteadores de aplicações dá melhor controle.
</li>
</ol>

<p>
Agora, se você <e>realmente</e> precisar, crie uma firewall que assista
suas necessidades.
</p>

</body>
</section>

</sections>
