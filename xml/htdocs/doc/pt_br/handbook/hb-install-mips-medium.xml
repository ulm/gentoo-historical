<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/handbook/hb-install-mips-medium.xml,v 1.5 2005/04/19 15:19:13 vanquirius Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<sections>

<version>1.8</version>
<date>2005-04-10</date>

<section>
<title>Requisitos de hardware</title>
<subsection>
<title>Introdução</title>
<body>

<p>
Antes de começar, primeiro iremos listar que requisitos de hardware você precisa para instalar o Gentoo com sucesso em sua máquina. 
</p>

</body>
</subsection>
<subsection>
<title>Requisitos de hardware</title>
<body>

<table>
<tr>
  <th>Memória</th>
  <ti>64 MB</ti>
</tr>
<tr>
  <th>Espaço em disco</th>
  <ti>1.5 GB (menos o espaço de swap)</ti>
</tr>
<tr>
  <th>Espaço de swap</th>
  <ti>No mínimo 256 MB</ti>
</tr>
</table>

<p>
Você também deve ver o documento <uri link="/doc/en/mips-requirements.xml">Requisitos de 
hardware para MIPS</uri> disponível em nosso website.
</p>

</body>
</subsection>
</section>
<!-- Only the stuff about the stages is replicated from the
     hb-install-x86-medium.xml file since MIPS uses netbooting 
     -->
<!-- START -->
<section>
<title>Os métodos de instalação do Gentoo</title>
<subsection>
<title>Introdução</title>
<body>

<p>
O Gentoo Linux pode ser instalado usando um dos três arquivos de tarball contendo <e>stages</e> (estágios).
Um arquivo de estágio é uma tarball (arquivo comprimido) que contém um ambiente mínimo.
</p>

<ul>
  <li>
     Um arquivo de stage1 não contém nada mais que um compilador (só C, sem C++),
     Portage (o sistema de gerenciamento de software do Gentoo) e uns
     pacotes de que o compilador e o Portage dependem.
   </li>
   <li>
     Um arquivo de stage2 contém um sistema cujo bootstrap foi feito, um 
     ambiente mínimo a partir do qual alguém pode construir todos outros 
     aplicativos que tornam o ambiente Gentoo completo.
   </li>
   <li>
     Um arquivo de stage3 contém um sistema mínimo pré-construído que é 
     quase totalmente funcional. Somente não tem alguns aplicativos que 
     você, o usuário do Gentoo, deve escolher para instalar.
   </li>
</ul>

<p>
Para ajudar a escolher que arquivo de estágio você quer usar, escrevemos as maiores vantagens e desvantagens de cada arquivo de estágio.
</p>

</body>
</subsection>
<subsection>
<title>Método do stage1</title>
<body>

<p>
Um <e>stage1</e> é usado quando você quer fazer bootstrap e construir o sistema inteiro do zero.
</p>

<p>
Iniciar de um stage1 permite que você tenha controle total sobre as 
otimizações e funcionalidades opcionais disponíveis na construção de pacotes que inicialmente é habilitada em seu sistema. Isto torna instalações de <e>stage1</e> boas para usuários que sabem o que estão fazendo. Também é um bom modo de instalação para aqueles que querem aprender mais sobre o funcionamento interno do Gentoo Linux.
</p>

<table>
<tr>
  <th>Stage1</th>
  <th>Prós e contras</th>
</tr>
<tr>
  <th>+</th>
  <ti>
    Permite que você tenha controle total sobre as 
otimizações e funcionalidades opcionais disponíveis na construção de pacotes que são inicialmente habilitadas em seu sistema
  </ti>
</tr>
<tr>
  <th>+</th>
  <ti>Boas para usuários que sabem o que estão fazendo</ti>
</tr>
<tr>
  <th>+</th>
  <ti>Aprenda mais sobre o funcionamento interno do Gentoo</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Leva bastante tempo para terminar a instalação</ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Se você não tem a intenção de mexer nas configurações, é uma perda de tempo
  </ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Precisa de uma conexão à Internet funcionando durante a instalação
  </ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Método do stage2</title>
<body>

<p>
Um <e>stage2</e> é usado para construir um sistema inteiro a partir de um estado de bootstrap "semi-compilado".
</p>

<p>
Instalações de stage2 permitem que você pule o processo de bootstrap; não há problema nisso se você está feliz com os ajustes de otimização que escolhemos para para sua tarball de stage2.
</p>

<table>
<tr>
  <th>Stage2</th>
  <th>Prós e contras</th>
</tr>
<tr>
  <th>+</th>
  <ti>Você não precisa fazer bootstrap</ti>
</tr>
<tr>
  <th>+</th>
  <ti>Mais rápido que começar com um stage1</ti>
</tr>
<tr>
  <th>+</th>
  <ti>Você ainda pode mexer em suas configurações</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Você não pode personalizar tanto quanto com um stage1</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Também não é o jeito mais rápido de instalar o Gentoo</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Você tem que aceitar as otimizações que escolhemos para o bootstrap</ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Precisa de uma conexão à Internet funcionando durante a instalação
  </ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Método do stage3</title>
<body>

<p>
Uma instalação de <e>stage3</e> contém um sistema Gentoo Linux básico que foi construído para você. Você irá precisar construir apenas alguns pacotes que não podemos escolher para você.
</p>

<p>
Escolher usar um stage3 permite a instalação mais rápida do Gentoo Linux, mas também significa que seu sistema de base terá ajustes de otimização que escolhemos para você (que honestamente, são bons ajustes e foram cuidadosamente escolhidos para aumentar a performance e manter a estabilidade). O stage3 também é necessário se você quer instalar o Gentoo usando pacotes pré-construídos ou sem uma conexão de rede.
</p>

<table>
<tr>
  <th>Stage3</th>
  <th>Prós e contras</th>
</tr>
<tr>
  <th>+</th>
  <ti>Jeito mais rápido de ter um sistema Gentoo de base</ti>
</tr>
<tr>
  <th>-</th>
  <ti>Você não pode personalizar o sistema de base -- já vem construído</ti>
</tr>
</table>

<p>
Talvez você se interesse em saber que se você decidir usar diferentes 
configurações de otimização após ter instalado o Gentoo, você poderá 
recompilar seu sistema inteiro com os novos ajustes de otimização.
</p>

</body>
</subsection>
<subsection>
<title>Uma nota sobre arquiteturas de processador</title>
<body>

<p>
Em muitas arquiteturas, o processador passou por várias gerações, cada
nova geração construída nos fundamentos da anterior. O MIPS não é
exceção. Existem várias gerações de CPU cobertas na arquitetura
MIPS. Para poder escolher sua tarball de imagem de inicialização de rede (netboot) e
<c>CFLAGS</c> adequadamente, você precisa estar ciente a que família a CPU de
seu sistema pertence. As famílias são referidas como a <b>I</b>nstruction
<b>S</b>et <b>A</b>rchitecture (arquitetura de conjunto de instruções).
</p>

<table>
  <tr>
    <th>MIPS ISA</th>
    <th>32/64-bits</th>
    <th>CPUs cobertas</th>
  </tr>
  <tr>
    <ti>MIPS 1</ti>
    <ti>32-bits</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R2000">R2000</uri>, 
      <uri link="http://www.linux-mips.org/wiki/index.php/R2000">R3000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 2</ti>
    <ti>32-bits</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R6000">R6000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 3</ti>
    <ti>64-bits</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4400</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4600</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R4000">R4700</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 4</ti>
    <ti>64-bits</ti>
    <ti>
      <uri link="http://www.linux-mips.org/wiki/index.php/R5000">R5000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R5000">RM5000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/RM7000">RM7000</uri>
      <uri link="http://www.linux-mips.org/wiki/index.php/R8000">R8000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R10000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R12000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R14000</uri>,
      <uri link="http://www.linux-mips.org/wiki/index.php/R10000">R16000</uri>
    </ti>
  </tr>
  <tr>
    <ti>MIPS 5</ti>
    <ti>64-bits</ti>
    <ti>
      Nenhuma ainda
    </ti>
  </tr>
</table>

<p>
Também, outro conceito importante a entender é o de <b>endianness</b>.
Endianness refere-se ao jeito que uma CPU lê palavras da memória principal. Uma
memória pode ser lida como um <e>big</e> (grande) endian (bit mais significante primeiro), ou
<e>little</e> (pequeno) endian (bit menos significante primeiro). Máquinas Intel x86 são
geralmente Little endian, enquanto máquinas Apple e Sparc são Big Endian. Em
MIPS, pode ser qualquer um. Para separá-los, nós anexamos <c>el</c> ao
nome da arquitetura para denotar little endian.
</p>

<table>
  <tr>
    <th>Arquitetura</th>
    <th>32/64-bits</th>
    <th>Endianness</th>
    <th>Máquinas cobertas</th>
  </tr>
  <tr>
    <ti><c>mips</c></ti>
    <ti>32-bits</ti>
    <ti>Big Endian</ti>
    <ti>Silicon Graphics</ti>
  </tr>
  <tr>
    <ti><c>mipsel</c></ti>
    <ti>32-bits</ti>
    <ti>Little Endian</ti>
    <ti>DECStations, servidores Cobalt, PlayStation 2</ti>
  </tr>
  <tr>
    <ti><c>mips64</c></ti>
    <ti>64-bits</ti>
    <ti>Big Endian</ti>
    <ti>Silicon Graphics</ti>
  </tr>
  <tr>
    <ti><c>mips64el</c></ti>
    <ti>64-bits</ti>
    <ti>Little Endian</ti>
    <ti>servidores Cobalt, PlayStation 2</ti>
  </tr>
</table>

<p>
Para os que quiserem aprender mais sobre ISAs, os seguintes websites podem
ser úteis.
</p>

<ul>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Instruction_Set_Architecture">
      Linux/MIPS Website: MIPS ISA
    </uri>
  </li>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Endianess">
      Linux/MIPS Website: Endianness  
    </uri>
  </li>
  <li>
    <uri link="http://www.linux-mips.org/wiki/index.php/Processors">
      Linux/MIPS Website: Processors
    </uri>
  </li>
  <li>
    <uri link="http://en.wikipedia.org/wiki/Instruction_set">
      Wikipedia: Instruction Set
    </uri>
  </li>
</ul>

</body>
</subsection>

</section>
<section>
<title>Visão geral da inicialização via rede (netboot)</title>
<subsection>
<body>

<p>
Nesta seção, iremos cobrir o que você precisa para fazer inicialização de rede com sucesso
em uma estação de trabalho Silicon Graphics ou um servidor Cobalt. Este é apenas um breve
guia, sem a intenção de ser completo. Para mais informações, eu recomendo
ler o <uri link="/doc/en/diskless-howto.xml">Guia sem 
disco</uri>.
</p>

<p>
O que você precisa: dependendo da máquina, existe uma certa quantidade de 
hardware de que você irá precisar para poder fazer inicialização via rede com sucesso e instalar o Linux.
</p>

<ul>
  <li>
    Em geral:
    <ul>
      <li>servidor de DHCP/BOOTP (ISC DHCPd recomendado)</li>
      <li>Paciência -- e muita</li>
    </ul>
  </li>
  <li>
    Para estações de trabalho Silicon Graphics:
    <ul>
      <li>servidor TFTP (tftp-hpa recomendado)</li>
      <li>
	Se você quiser/precisar usar o console serial:
        <ul>
          <li>MiniDIN8 --&gt; cabo serial RS-232</li>
          <li>Cabo de null-modem</li>
          <li>VT100 ou terminal compatível com ANSI capaz de 9600 baud</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Para servidores Cobalt (NÃO o Qube original):
    <ul>
      <li>servidor de NFS</li>
      <li>Cabo de null-modem</li>
      <li>VT100 ou terminal compatível com ANSI capaz de 115200 baud</li>
    </ul>
  </li>
</ul>

<note>
Máquinas SGI usam um conector MiniDIN 8 para portas seriais. Aparentemente cabos de
modem da Apple funcionam bem como cabos seriais, mas com as máquinas da Apple sendo
equipadas com modems USB &amp; internos, estão ficando cada vez mais difícil
de encontrar. Alguns sites descrevem como fazer os cabos (Google é seu
amigo). O seguinte site descreve como fazer um cabo. Está em alemão,
mas tem um diagrama de fiação decente.
<uri link="http://www.arbeitsplatzvernichtung-durch-outsourcing.de/marty44/sgihard.html">
  http://www.arbeitsplatzvernichtung-durch-outsourcing.de/marty44/sgihard.html
</uri>
</note>

<note>
Para o terminal, pode ser um terminal VT100/ANSI real, ou pode ser um PC
rodando software de emulação de terminal (como HyperTerminal, Minicom, seyon,
Telex, xc, screen -- qualquer que seja sua preferência). Não importa que plataforma
a máquina rodar -- contanto que tenha uma porta serial RS-232 que você possa usar,
e o software apropriado.
</note>

<note>
Note que este guia NÃO cobre o Qube original. O servidor Qube original 
não tem uma porta serial em sua configuração padrão, e portanto não
é possível instalar o Gentoo nele sem a ajuda de uma chave de fenda e uma
máquina de surrogado para a instalação.
O seguinte site tem um guia para instalar o Gentoo nessas máquinas.
<uri link="http://www.metzner.org/projects/qube/">
  http://www.metzner.org/projects/qube/
</uri>
</note>
</body>
</subsection>
<subsection>
<title>Configurando TFTP e DHCP -- um breve guia</title>
<body>

<p>
Ok, então você juntou todas partes, agora vamos configurar tudo. Como
mencionei anteriormente -- este não é um guia completo, é uma configuração de esqueleto
que só irá pôr as coisas para funcionar. Você pode usá-lo para configurar
do zero, ou usar as sugestões para corrigir sua configuração existente para
suportar inicialização via rede.
</p>

<p>
Vale notar que os servidores usados não precisam estar rodando Gentoo Linux, você
pode muito bem usar FreeBSD ou qualquer outra plataforma Unix-like. No entanto, este
guia irá presumir que você está rodando Gentoo Linux. Você também pode rodar TFTP/NFS em uma
máquina separada do servidor de DHCP se desejado.
</p>

<p>
Primeiro passo -- configurando DHCP. Para que o daemon de ISC DHCP responda
a pedidos de BOOTP (necessários ao BOOTROM de SGI &amp; Cobalt) você precisa 
primeiro ativar BOOTP dinâmico no alcance de endereços em uso; então configure uma entrada para
cada cliente apontando para a imagem de inicialização.
</p>

<pre caption="Instalando DHCP da ISC">
# <i>emerge dhcp</i>
</pre>

<p>
Uma vez instalado você precisa criar o <path>/etc/dhcp/dhcpd.conf</path>. Aqui está
um esqueleto de configuração para começar.
</p>

<pre caption="Esqueleto de dhcpd.conf">
<comment># Diga para o dhcpd desligar DNS dinâmico.</comment>
<comment># dhcpd irá recusar-se a iniciar sem isso.</comment>
ddns-update-style none;

<comment># Crie uma subnet:</comment>
subnet <i>192.168.10.0</i> netmask <i>255.255.255.0</i> {
  <comment># Alcance de endereços para nossos clientes carregando. Não se esqueça da parte 'dynamic-bootp'!</comment>
  pool {
    range dynamic-bootp <i>192.168.10.1 192.168.10.254</i>;
  }

  <comment># servidores de DNS e roteador padrão -- substitua como necessário</comment>
  option domain-name-servers <i>203.1.72.96</i>, <i>202.47.56.17</i>;
  option routers <i>192.168.10.1</i>;

  <comment># Diga ao servidor de DHCP que é autoritativo nesta subnet.</comment>
  authoritative;

  <comment># Permita que BOOTP seja usado na subnet.</comment>
  allow bootp;
}
</pre>

<p>
Com esta configuração, pode-se colocar qualquer número de clientes dentro da 
subnet. Nós iremos cobrir o que você necessita colocar mais para frente no guia.
</p>

<p>
Próximo passo -- configurando o servidor de TFTP. Para os propósitos deste guia, irei
restringi-lo ao daemon de TFTP tftp-hpa. Eu mesmo uso em máquinas SGI,
servidores Cobalt e clientes PXE sem nenhum problema. A instalação e
configuração é bem direta:
</p>

<pre caption="Instalando tftp-hpa">
# <i>emerge net-ftp/tftp-hpa</i>
</pre>

<p>
Agora, eu pessoalmente gosto de colocar meu diretório <path>/tftpboot</path> no
<path>/home</path> onde eu tenho mais espaço. Isto é totalmente opcional, e pode
ser configurado no arquivo <path>/etc/conf.d/in.tftpd</path>. Para os propósitos
deste guia, irei presumir que você deixou-o no lugar padrão.
</p>

<p>
Agora que tudo está configurado, estamos prontos para a parte divertida --
ajustar nossa configuração para servir na máquina que queremos inicializar via rede.
</p>

</body>
</subsection>
</section>
<section>
<title>Inicialização de rede em estaços de trabalho SGI</title>
<subsection>
<title>Baixando uma imagem de inicialização de rede</title>
<body>

<p>
Dependendo do sistema em que você está instalando, existem várias imagens possíveis
para serem baixadas. Estão todas marcadas de acordo com o tipo de sistema e
a CPU para a qual são compiladas. Os tipos de máquina são como a seguir:
</p>

<table>
  <tr>
    <th>Código de nome</th>
    <th>Máquinas</th>
  </tr>
  <tr>
    <ti>IP22</ti>
    <ti>Indy, *Indigo 2, **Challenge S</ti>
  </tr>
  <tr>
    <ti>IP26</ti>
    <ti>*Indigo 2 Power</ti>
  </tr>
  <tr>
    <ti>IP27</ti>
    <ti>Origin 200, Origin 2000</ti>
  </tr>
  <tr>
    <ti>IP28</ti>
    <ti>*Indigo 2 Impact</ti>
  </tr>
  <tr>
    <ti>IP30</ti>
    <ti>Octane</ti>
  </tr>
  <tr>
    <ti>IP32</ti>
    <ti>O2</ti>
  </tr>
</table>

<note>
* É um engando comum confundir o IRIS Indigo (IP12 com CPU R3000 ou IP20 com
CPU R4000, nenhum dos quais roda Linux) o Indigo 2 (IP22, que roda
Linux sem problemas), o Indigo 2 Power baseado em R8000 (que não roda nenhum Linux) e
o Indigo 2 Impact baseado em R10000 (IP28, que é altamente experimental).
Por favor tenha em mente que são máquinas diferentes.
</note>

<note>
** No Challenge S, a porta de rede UTP é pendurada em uma placa WD33C95 SCSI,
que atualmente não é suportada no Linux. Por causa desta limitação,
você precisará usar um transreceptor AUI--&gt;UTP conectado na porta AUI.
</note>

<p>
Também no nome de arquivo, r4k refere-se a processadores da série R4000, r5k para R5000,
rm5k para o RM5200 e r10k para R10000. Você irá encontrar as imagens disponíveis em
<uri link="http://dev.gentoo.org/~kumba/mips/netboot">
http://dev.gentoo.org/~kumba/mips/netboot.
</uri>
 </p>
</body>
</subsection>

<subsection>
<title>Configuração de DHCP para um cliente SGI</title>
<body>

<p>
Uma vez que você tenha baixado o arquivo, simplesmente coloque-o em seu
diretório <path>/tftpboot</path>. Então edite seu
<path>/etc/dhcp/dhcpd.conf</path> e adicione uma entrada para seu cliente SGI.
</p>

<note>
Você pode ter que criar o diretório <path>/tftpboot</path> se ele não já
existir.
</note>

<pre caption="trecho de dhcpd.conf para estação de trabalho SGI">
subnet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx {
  <comment># ... parte normal aqui ...</comment>

  <comment># Estração de trabalho SGI... troque 'sgi' pelo hostname da máquina SGI.</comment>
  host <i>sgi</i> {
  
    <comment># Endereço de MAC da máquina SGI. Normalmente escrito na parte de trás</comment>
    <comment># ou base da máquina.</comment>
    hardware ethernet <i>08:00:69:08:db:77</i>;

    <comment># Servidor de TFTP do que baixar (por padrão, igual ao servidor de DHCP)</comment>
    next-server <i>192.168.10.1</i>;

    <comment># Endereço IP para dar para a máquina SGI</comment>
    fixed-address <i>192.168.10.3</i>;

    <comment># Nome do arquivo para o PROM baixar e carregar</comment>
    filename "<i>/gentoo-r4k.img</i>";
  }
}
</pre>
</body>
</subsection>

<subsection>
<title>Opções de kernel</title>
<body>
<p>
Estamos quase terminando, mas ainda há duas pequenas mudanças ainda a fazer. Abra
um console com privilégios de administrador (root), e digite os seguintes comandos.
</p>

<pre caption="Alguns ajustes para máquinas SGI para que o TFTP funcione devidamente">
<comment>(Desative "Path Maximum Transfer Unit", ou o SGI Prom não irá encontrar o kernel)</comment>
# <i>echo 1 &gt; /proc/sys/net/ipv4/ip_no_pmtu_disc</i>

<comment>(Ajuste a amplitude de portas que o SGI PROM pode usar)</comment>
# <i>echo "2048 32767" &gt; /proc/sys/net/ipv4/ip_local_port_range</i>
</pre>

<p>
Isto deve ser o suficiente para permitir que o servidor de Linux funcione bem com o
PROM da SGI.
</p>

</body>
</subsection>
<subsection>
<title>Iniciem seus Daemons...</title>
<body>
<p>
Neste ponto, você deve estar pronto para iniciar os daemons. Digite o seguinte:
</p>

<pre caption="Iniciando os daemons de DHCP e TFTP">
# <i>/etc/init.d/dhcp start</i>
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Se nada deu errado no último passo você deve estar pronto para ligar a 
estação de trabalho e continuar com o guia. Se o servidor de DHCP não estiver iniciando por
algum motivo, tente rodar 'dhcpd' na linha de comando e veja se o que ele diz a
você -- se tudo estiver bem, ele deve simplesmente ir para o background, caso contrário você
verá 'exiting.' abaixo de sua reclamação.
</p>

<p>
Um jeito fácil de verificar se o daemon de tftp está rodando é digitar o seguinte
comando -- se você vir algo como a saída mencionada abaixo -- tudo está
bem.
</p>

<pre caption="Verificando que o TFTPd está rodando">
# <i>netstat -al | grep ^udp</i>
udp        0      0 *:bootpc                *:*
udp        0      0 *:631                   *:*
udp        0      0 *:xdmcp                 *:*
udp        0      0 *:tftp                  *:* <comment>&lt;-- (look for this line)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Fazendo inicialização via rede da máquina SGI</title>
<body>

<p>
Ok, tudo está pronto, DHCP e TFTP estão rodando. Agora está na hora de iniciar a 
máquina SGI. Ligue a unidade -- quando você vir a tela "Running power-on
diagnostics", clique em "Stop For Maintenance" ou aperte ESCAPE.
Você verá um menu parecido com o seguinte. Digite os comandos como mostrados
abaixo.
</p>

<pre caption="Menu de manutenção do SGI PROM">
        Running power-on diagnostics

System Maintenance Menu

1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor. Type "exit" to return to the menu.
&gt;&gt; <i>bootp(): root=/dev/ram0</i>
</pre>

<p>
Deste ponto em diante, a máquina deve começar a carregar a imagem, então, aproximadamente
20 segundos depois, começar a carregar o Linux. Se tudo estiver bem, você deverá ver a
shell de Busybox <c>ash</c> como vista abaixo, de onde você pode
ir para <uri link="?part=1&amp;chap=3">Configurando sua rede</uri>.
</p>

<pre caption="Quando as coisas estão indo bem...">
init started:  BusyBox v1.00-pre10 (2004.04.27-02:55+0000) multi-call binary

Gentoo Linux; http://www.gentoo.org/
 Copyright 2001-2004 Gentoo Technologies, Inc.; Distributed under the GPL

 Gentoo/MIPS Netboot for Silicon Graphics Machines
 Build Date: April 26th, 2004

 * To configure networking, do the following:

 * For Static IP:
 * /bin/net-setup &lt;IP Address&gt; &lt;Gateway Address&gt; [telnet]

 * For Dynamic IP:
 * /bin/net-setup dhcp [telnet]

 * If you would like a telnetd daemon loaded as well, pass "telnet"
 * As the final argument to /bin/net-setup.

Please press Enter to activate this console.
</pre>

</body>
</subsection>
<subsection>
<title>Resolução de problemas.</title>
<body>

<p>
Se a máquina estiver sendo teimosa e recusando-se a baixar sua imagem, pode ser
uma de duas coisas, (1) você fez alguma confusão em algum lugar, ou (2) ela precisa ser
gentilmente convencida. (Não, abaixe o martelo!) Aqui está uma lista de coisas que
você pode verificar:
</p>

<ul>
  <li>
    O dhcpd está dando um endereço IP para a máquina SGI. Você deve ver algumas
    mensagens sobre um pedido de BOOTP nos registros de sistema. <c>tcpdump</c> também é
    útil aqui.
  </li>
  <li>
    As permissões estão corretas no diretório de tftp (normalmente 
    <path>/tftpboot</path> -- deve ler legível globalmente)
  </li>
  <li>
    Verifique logs de sistema para ver o que o servidor tftp está dizendo (erros 
    às vezes)
  </li>
<!--
  I really think this tip can go...
 
  <li>
    Reze para um boneco do Tux (pode ou não funcionar, e não é uma técnica 
    de solução de problemas oficial)
  </li>-->
</ul>

<p>
Se você houver verificado tudo no servidor, e você estiver obtendo timeouts, etc na
máquina SGI, tente digitar o seguinte no console.
</p>

<pre caption="Convencendo o SGI PROM a funcionar">
&gt;&gt; <i>resetenv</i>
&gt;&gt; <i>unsetenv netaddr</i>
&gt;&gt; <i>unsetenv dlserver</i>
&gt;&gt; <i>init</i>
&gt;&gt; <i>bootp(): root=/dev/ram0</i>
</pre>

</body>
</subsection>
</section>

<section>
<title>Inicialização via rede em servidores Cobalt</title>
<subsection>
<body>

</body>
</subsection>

<subsection>
<title>Visão geral do procedimento de inicialização de rede</title>
<body>

<p>
Ao contrário de máquinas SGI, servidores Cobalt usam NFS para transferir seu kernel para
inicialização. Você carrega a máquina segurando os botões de setas esquerda &amp; direita
enquanto estiver ligando a máquina. A máquina irá então tentar obter um
número de IP via BOOTP, montar o diretório <path>/nfsroot</path> do servidor via
NFS, então tentar baixar e carregar o arquivo <path>vmlinux_raq-2800.gz</path>
que presume ser um binário ELF padrão.
</p>

<p>
Infelizmente, o Cobalt BOOTROM não nos dá opção neste procedimento,
então o arquivo TEM que residir no diretório <path>/nfsroot</path>, e deve ser
menor que 675kB. Neste guia, iremos configurar o
<uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> para nos permitir
carregar kernéis maiores que este limite. O CoLO também suporta discos de ram embedded,
portanto eliminando a necessidade de um sistema de arquivos de raiz completo em
<path>/nfsroot</path>.
</p>

</body>
</subsection>

<subsection>
<title>Baixando uma imagem de inicialização de rede</title>
<body>

<p>
Dentro de
<uri link="http://dev.gentoo.org/~kumba/mips/cobalt/netboot/">
http://dev.gentoo.org/~kumba/mips/cobalt/netboot/</uri>
você irá encontrar as imagens de boot necessárias para fazer um Cobalt iniciar
e rodar. Os arquivos que você precisa terão o nome
<path>cobalt-netboot-YYYYMMDD.img.gz</path> -- selecione o mais recente e
coloque-o em seu diretório <path>/nfsroot</path>. Para conveniência, renomeie o
arquivo para <path>gentoo-cobalt.img.gz</path> -- irei presumir que você fez
isso.
</p>

<p>
Uma vez feito, vá para
<uri link="http://www.colonel-panic.org/cobalt-mips/">
http://www.colonel-panic.org/cobalt-mips/</uri> e
baixe o último lançamento do gerenciador de inicialização CoLo. Descompacte-o em algum lugar
conveniente. Dentro do diretório <path>colo-1.XX/binaries</path> criado,
você deve encontrar um arquivo chamado <path>colo-chain.elf</path>.  Faça gzip do
arquivo e coloque-o em <path>/nfsroot</path> chamando-o de
<path>vmlinux_raq-2800.gz</path>. Também, em alguns casos, você precisará criar um
link simbólico chamado <path>boot</path> que aponta de volta para
<path>/nfsroot</path>. Você pode fazer isto de uma tacada só usando os seguintes
comandos:
</p>

<note>
Por favor note, o RaQ1 e Qube 2700 procuram por <path>vmlinux.gz</path> ao invés de
<path>vmlinux_raq-2800.gz</path>.
</note>

<pre caption="Colocando CoLo no nfsroot">
# <i>tar -xzvf colo-1.XX.tar.gz</i>
# <i>cd colo-1.XX/binaries</i>

<comment>(Para Qubte 2800, RaQ2, etc)</comment>
# <i>gzip -9vc colo-chain.elf &gt; /nfsroot/vmlinux_raq-2800.gz</i>

<comment>(Para RaQ1, Qube 2700)</comment>
# <i>gzip -9vc colo-chain.elf &gt; /nfsroot/vmlinux.gz</i>
# <i>cd /nfsroot</i>
# <i>ln . boot</i>
</pre>

<note>
Se a última versão do CoLo não carregar com sucesso, você pode tentar uma versão
anterior. Sabe-se que a Versão 1.16 e anteriores funcionam.
</note>

</body>
</subsection>

<subsection>
<title>Configuração de servidor de NFS</title>
<body>

<p>
Já que esta máquina usa NFS para baixar sua imagem, você precisa exportar 
<path>/nfsroot</path> para seu servidor. Se você não houver feito, você
precisará instalar o pacote net-fs/nfs-utils.
</p>
<pre caption="Instalando nfs-utils">
# <i>emerge net-fs/nfs-utils</i>
</pre>

<p>
Uma vez que for feito, coloque o seguinte em seu arquivo <path>/etc/exports</path>.
Você pode colocar restrições mais estritas se desejar.
</p>

<pre caption="Exportando o diretório /nfsroot">
/nfsroot      *(ro,sync)
</pre>

<p>
Agora, uma vez que isso for feito, você pode iniciar o servidor de NFS:
</p>

<pre caption="Iniciando o servidor de NFS">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Se o servidor de NFS já estava rodando na hora, você pode pedir para que olhe
de novo em seu arquivo <c>exports</c> usando <c>exportfs</c>.
</p>

<pre caption="Exportando um novo sistema de arquivos">
# <i>exportfs -av</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configuração de DHCP para uma máquina Cobalt</title>
<body>

<p>
Agora, o lado de DHCP das coisas é relativamente direto. Adicione o seguinte
a seu arquivo <path>/etc/dhcp/dhcpd.conf</path>.
</p>

<pre caption="trecho de dhcpd.conf para servidor Cobalt">
subnet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx {
  <comment># ... parte normal aqui ...</comment>

  <comment># Configuração para um sevidor Cobalt</comment>
  <comment># Ajuste o hostname aqui:</comment>
  host <i>qube</i> {
    <comment># Caminho para o diretório nfsroot.</comment>
    <comment># Isto é principalmente para usar a opção de inicialização de TFTP no CoLo</comment>
    option root-path "/nfsroot";

    <comment># Endereço de MAC do servidor Cobalt</comment>
    hardware ethernet <i>00:10:e0:00:86:3d</i>;

    <comment># Servidor para baixar a imagem</comment>
    next-server <i>192.168.10.1</i>;

    <comment># Endereço IP do servidor cobalt</comment>
    fixed-address <i>192.168.10.2</i>;

    <comment># Imagem para baixar</comment>
    <comment># Novamente, isto é mais relacionado ao CoLo</comment>
    filename "<i>gentoo-cobalt.img.gz</i>";
  }
}
</pre>

</body>
</subsection>

<subsection>
<title>Iniciem seus daemons...</title>
<body>

<p>
Neste ponto, você deve estar pronto para iniciar os daemons. Digite o seguinte:
</p>

<pre caption="Iniciando os daemons de DHCP e NFS">
# <i>/etc/init.d/dhcp start</i>
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Se nada deu errado no último passo você deve estar pronto para ligar a 
estação de trabalho e continuar com o guia. Se o servidor de DHCP não estiver iniciando por
algum motivo, tente rodar 'dhcpd' na linha de comando e veja se o que ele diz a
você -- se tudo estiver bem, ele deve simplesmente ir para o background, caso contrário você
verá 'exiting.' abaixo de sua reclamação.
</p>

</body>
</subsection>

<subsection>
<title>Inicialização via rede da máquina Cobalt</title>
<body>

<p>
Ok, tudo está configurado, DHCP e NFS estão rodando. Agora está na hora de iniciar
a máquina Cobalt. Ligue seu cabo de null modem, e configure o terminal serial
para usar 115200 baud, 8 bits, sem paridade, 1 bit de paridade, emulação de VT100. Uma vez
que estiver feito, segure os botões de seta esquerda &amp; direita quando estiver ligando a
unidade.
</p>

<p>
Se tudo for bem, o painel traseiro deve mostrar "Net Booting", você deve
ver atividade de rede, seguida de perto do início do CoLo. No painel
traseiro, role o menu até ver "Boot Shell" e aperte ENTER. No 
console serial, você deve cair no prompt como mostrado abaixo.
</p>

<note>
Foi relatado que simplesmente selecionar a opção de NFS boot faz tudo isto
para você em versões modernas do CoLo. Se selecionar esta opção não funcionar,
leia em diante.
</note>

<pre caption="CoLo iniciando em um prompt">
[ "CoLo" v1.13 ]
stage2: 87fb0000-88000000
pci: unit type &lt;Qube2&gt;
tulip: {00:10:e0:00:86:3d}
ide: resetting
boot: running boot menu
&gt;
</pre>

<p>
Primeiro passo, diga para a máquina pedir um endereço via DHCP. Digite <c>dhcp</c> no
prompt.
</p>

<pre caption="Pedindo um endereço via DHCP">
&gt; <i>dhcp</i>
net: interface up
dhcp: DISCOVER
dhcp: OFFER 10.0.0.1 &lt;-- 192.168.10.254
dhcp: REQUEST
arp: sent request for 192.168.10.254
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
arp: resolved 192.168.10.254
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
dhcp: DISCOVER
dhcp: OFFER 10.0.0.1 &lt;-- 192.168.10.254
dhcp: REQUEST
udp: no matching socket 192.168.5.1:67 --&gt; 10.0.0.1:68
dhcp: ACK
net: interface down
net: interface up
  address     10.0.0.1
  netmask     255.255.255.0
  gateway     10.0.0.254
  name server 192.168.5.1
</pre>

<p>
NOTE: Se você tiver uma rede de Windows você pode ver mensagens do tipo
<c>udp: no matching socket</c>. Elas são em resposta a broadcasts de rede em
portas que o CoLo não reconhecem. Por mais chatas que sejam, são perfeitamente
inócuas.
</p>

<pre caption="mensagens de erro 'no matching socket'">
udp: no matching socket 10.0.0.254:138 --&gt; 10.0.0.255:138
udp: no matching socket 10.0.0.254:138 --&gt; 10.0.0.255:138
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
</pre>

<p>
Ok, o próximo passo é dizer para o servidor Cobalt baixar seu kernel.
</p>

<pre caption="Baixando o kernel">
&gt; <i>nfs 10.0.0.254 /nfsroot gentoo.img.gz</i>
arp: sent request for 10.0.0.254
arp: resolved 10.0.0.254
udp: no matching socket 10.0.0.253:1062 --&gt; 10.0.0.255:137
nfs: mounted "/nfsroot"
nfs: lookup "gentoo.img.gz"
nfs: mode &lt;0100644&gt;
4651KB loaded (1240KB/sec)
0048ada0 4763040t
</pre>

<p>
E isso é tudo... ele agora baixou seu kernel, nós agora podemos começar a
inicialização.
</p>

<pre caption="Carregando o kernel">
&gt; <i>execute</i>
elf: 80080000 &lt;-- 00001000 6586368t + 192624t
elf: entry 80328040
net: interface down
CPU revision is: 000028a0
FPU revision is: 000028a0
Primary instruction cache 32kB, physically tagged, 2-way, linesize 32 bytes.
Primary data cache 32kB 2-way, linesize 32 bytes.
Linux version 2.4.26-mipscvs-20040415 (root@khazad-dum) (gcc version 3.3.3...
Determined physical RAM map:
 memory: 08000000 @ 00000000 (usable)
Initial ramdisk at: 0x80392000 (3366912 bytes)
On node 0 totalpages: 32768
zone(0): 32768 pages.
zone(1): 0 pages.
zone(2): 0 pages.
Kernel command line: console=ttyS0,115200 root=/dev/ram0
Calibrating delay loop... 249.85 BogoMIPS
Memory: 122512k/131072k available (2708k kernel code, 8560k reserved, 3424k dat)
</pre>

<p>
Se tudo estiver bem, você cair na shell de
Busybox <c>ash</c> como mostrado abaixo, de onde você pode ir para
<uri link="?part=1&amp;chap=3">Configurando sua rede</uri>.
</p>

<pre caption="Quando as coisas estão indo bem...">
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 280k freed
init started:  BusyBox v1.00-pre10 (2004.04.27-02:55+0000) multi-call binary

Gentoo Linux; http://www.gentoo.org/
 Copyright 2001-2004 Gentoo Technologies, Inc.; Distributed under the GPL

 Gentoo/MIPS Netboot for Cobalt Microserver Machines
 Build Date: April 26th, 2004

 * To configure networking, do the following:

 * For Static IP:
 * /bin/net-setup &lt;IP Address&gt; &lt;Gateway Address&gt; [telnet]

 * For Dynamic IP:
 * /bin/net-setup dhcp [telnet]

 * If you would like a telnetd daemon loaded as well, pass "telnet"
 * As the final argument to /bin/net-setup.

Please press Enter to activate this console.
</pre>

</body>
</subsection>

<subsection>
<title>Resolução de problemas.</title>
<body>

<p>
Se a máquina estiver sendo teimosa e recusando-se a baixar sua imagem, pode ser
uma de duas coisas, (1) você fez alguma confusão em algum lugar, ou (2) ela precisa ser
gentilmente convencida. (Não, abaixe o martelo!) Aqui está uma lista de coisas que
você pode verificar:
</p>

<ul>
  <li>
    O dhcpd está dando um endereço IP para a máquina Cobalt. Você deve ver algumas
    mensagens sobre um pedido de BOOTP nos registros de sistema. <c>tcpdump</c> também é
    útil aqui.
  </li>
  <li>
    As permissões estão corretas em seu diretório <path>/nfsroot</path>.  (deve
    ser legível globalmente)
  </li>
  <li>
    Certifique-se de que o servidor NFS está rodando e exportanto o diretório
    <path>/nfsroot</path>. Verifique isso usando <c>exportfs -v</c> no servidor.
  </li>
</ul>
</body>
</subsection>
</section>
<!--

  Commented Out Until Further Notice

<section>
<title>Gentoo/MIPS LiveCD</title>
<subsection>
<title>Overview</title>
<body>

<p>
On Silicon Graphics machines, it is possible to boot from a CD in order to
install operating systems.  (This is how one installs IRIX for instance)
Recently, images for such bootable CDs to install Gentoo have been made
possible.  These CDs are designed to work in the same way.
</p>

<p>
At the moment the Gentoo/MIPS Live CD will only work on the SGI Indy,
Indigo 2 and O2 workstations equipped with R4000 and R5000-series CPUs, however
other platforms may be possible in future.
</p>

<p>
You can find the Live CD images for download on your favourite Gentoo Mirror
under the <path>experimental/mips/livecd</path> directory.
</p>

<warn>
These CDs are highly experimental at this time.  They may or may not work at
this time.  You can report success or failures either on
<uri link="http://bugs.gentoo.org">Bugzilla</uri>,
<uri link="http://forums.gentoo.org/viewtopic.php?t=242518">this forum
thread</uri> or in the <c>#gentoo-mips</c>
<uri link="http://www.gentoo.org/main/en/irc.xml">IRC channel</uri>.  We would
love to hear from you.
</warn>

</body>

</subsection>

<subsection>
<title>Burning a Live CD</title>
<body>

<p>
An important thing to note, the SGI PROM does not understand the ISO9660 format,
nor does it know anything about the El Torito boot standard.  These CD images
are constructed as a SGI disklabel with the boot image in the volume header like
a hard drive.  Therefore, care must be taken when burning the CD image.
</p>

<p>
Below is an example command that assumes 24x burning speed on an IDE burner.  If
you have a SCSI burner for instance, you may want to adjust the <c>dev</c>
statement as appropriate.  Likewise with the <c>speed</c> option - if you
strike troubles, you might want to try dropping the speed.
</p>

<pre caption="Burning using cdrecord">
# <i>bzip2 -d mips-livecd-prototype-rc2-20041027.img.bz2</i>
# <i>cdrecord -vv -pad speed=24 dev=ATAPI:0,0,0 -tao mips-livecd-prototype-rc2-20041027.img</i>
</pre>

<note>
It may be possible to burn these CDs under Windows, assuming your burning
program just blindly burns the image as is.  However, no one has succeeded in
making a working CD this way to date.
</note>

<note>
If you don't know what to put as your <c>dev</c> argument, run <c>cdrecord
-scanbus</c> as root - this will tell you where your burner is located.
</note>


</body>
</subsection>
</section>
-->
</sections>
