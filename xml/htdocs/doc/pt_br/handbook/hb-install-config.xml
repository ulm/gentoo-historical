<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/handbook/hb-install-config.xml,v 1.2 2004/10/06 12:53:18 enderson Exp $ -->

<sections>
<section>
<title>Informaçoes do Sistema de Arquivos</title>
<subsection>
<title>O que é o fstab?</title>
<body>

<p>
No Linux, todas as partições usadas pelo sistema deve estar listadas em
<path>/etc/fstab</path>. Este arquivo contémos pontos de montagem destas partições
(onde elas são vistas na estrutura do sistema de arquivos), como elas devem ser montadas
(opções especiais) e quando (automaticamente ou não, usuários podem ou não montá-las,
etc.).
</p>

</body>
</subsection>
<subsection>
<title>Criando o /etc/fstab</title>
<body>

<p>
O <path>/etc/fstab</path> usa uma sintaxe especial. Cada linha consiste de seis
campos, separados por espacos em branco (espaco(s), tabs ou ambos). Cada campos com
seu próprio significado:
</p>

<ul>
<li>
  O primeiro campos mostra a <b>partição</b> descrita (o caminho para o arquivo de 
  dispositivo)
</li>
<li>
  O segundo campo mostra o <b>ponto de montagem</b> no qual a partição deve ser 
  montada
</li>
<li>
  O terceiro campo mostra o <b>sistema de arquivo</b> usado pela partição
</li>
<li>
  O quarto campo mostra as <b>opções de montagem</b> usadas pelo <c>mount</c> quando a
  partição for montada. Como cada sistema de arquivos tem suas próprias opções de montagem,
  é aconselhado que você leia o manual do mount (<c>man mount</c>) para uma listagem
  completa. Multiplas opções são separadas por vírgulas.
</li>
<li>
  O quinto campo é usado pelo <c>dump</c> para determinar se a partição precisa 
  ser de um <b>dump</b> ou não. Geralmente você pode deixar isso como <c>0</c> (zero).
</li>
<li>
  O sexto campo é usado pelo <c>fsck</c> para determinar a ordem em que os
  os sistemas de arquivos devem ser <b>verificados</b> se o sistema não foi deligado corretamente. 
  O sistema de arquivos raiz deve ter o valor <c>1</c> enquanto o restante deve ter <c>2</c> 
  (ou <c>0</c> caso uma verificação no sistema de arquivos não seja necessária).
</li>
</ul>

<p>
Então inicie o <c>nano</c> (ou seu editor favorito) para criar o seu 
<path>/etc/fstab</path>:
</p>

<pre caption="Abrindo o /etc/fstab">
# <i>nano -w /etc/fstab</i>
</pre>

<p>
Vamos dar uma olhada em como nós escrevemos as opções para a partição 
<path>/boot</path>. Isto é só um exemplo, então, se a sua arquitetura não
requer uma partição <path>/boot</path>, não copie da mesma maneira.
</p>

<p>
Em nosso exemplo padrão x86 de particionamento, <path>/boot</path> é a
partição <path>/dev/hda1</path>, e sistema de arquivos <c>ext2</c>. E não deve
ser montado automaticamente (<c>noauto</c>) mas precisa ser verificado. Então nós escreveriamos:
</p>

<pre caption="Uma entrada exemplo do /boot no /etc/fstab">
/dev/hda1   /boot     ext2    noauto        1 2
</pre>

<p>
Alguns usuários não querem que sua partição <path>/boot</path> seja montada
automaticamente para melhorar a segurança de seu sistema. Estas pessoas deveriam
substtuir <c>defaults</c> por <c>noauto</c>. Isto significa que você precisa
montar manualmente esta partição cada vez que você queira usá-la
</p>

<p>
Agora, para melhorar a performance, a maioria pode querer adicionar a opção 
<c>noatime</c> como opção de montagem, que resulta em um sistema mais rápido, 
já que o tempo de acesso não é registrado (você não precisará tanto disto):
</p>

<pre caption="Uma linha do /boot no /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
</pre>

<p>
Se continuarmos com isto, nós terminariamos com as seguintes três linhas
(para <path>/boot</path>, <path>/</path> e a partição swap):
</p>

<pre caption="Três linhas no /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1
</pre>

<p>
Para finalizar, você deve adicionar uma regra para o <path>/proc</path>, <c>tmpfs</c>
(requirido) e para o seu CD-ROM (e claro, se você tiver outras partições
ou dispositivos, para eles também):
</p>

<pre caption="Um exemplo completo do /etc/fstab">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1

none        /proc     proc    defaults          0 0
none        /dev/shm  tmpfs   defaults          0 0

/dev/cdroms/cdrom0    /mnt/cdrom    auto      noauto,user    0 0
</pre>

<p>
A opção <c>auto</c> faz com que o <c>mount</c> descubra o sistema de arquivos (recomendado para
mídias removíveis já que podem ser criadas com vários tipos de sistemas de arquivos) e a opção
<c>user</c> faz com que seja possível usuários que não o root possam montar o CD.
</p>

<p>
Agora use o exemplo acima para ciar o seu <path>/etc/fstab</path>. Se você é um 
usuário de um <b>SPARC</b>, você deveria adiconar a seguinte linha ao seu 
<path>/etc/fstab</path>
também:
</p>

<pre caption="Adicionando um sistema de arquivos openprom ao /etc/fstab">
none        /proc/openprom  openpromfs    defaults      0 0
</pre>

<p>
Se você precisa de <c>usbfs</c>, adicione a seguinte linha ao <path>/etc/fstab</path>:
</p>

<pre caption="Adicionando o sistema de arquivos usbfs ao /etc/fstab">
none        /proc/bus/usb   usbfs         defaults      0 0
</pre>

<p>
Confira o seu <path>/etc/fstab</path>, salve e saia para continuar.
</p>

</body>
</subsection>
</section>
<section>
<title>Informações de Rede</title>
<subsection>
<title>Nome do host, domínio, etc.</title>
<body>

<p>
Uma das escolhas que o usuário deve fazer é dar um nome ao PC. Isto parece ser bem
fácil, mas <e>muitos</e> usuários tem dificuldades em achar um nome apropriado
para seus Linux-pc. Para acelerar as coisas, saiba que qualquer nome que você escolher 
pod ser mudado depois. Para que possamos continuar, você pode apenas chamar seu sistema
de <c>tux</c> e domínio <c>homenetwork</c>. 
</p>

<p>
Nós usamos estes valores nos próximos exemplos. Primeiro configuramos o nome do host:
</p>

<pre caption="Configurando o nome do host">
# <i>echo tux &gt; /etc/hostname</i>
</pre>

<p>
Em seguida nós configuramos o nome do domínio:
</p>

<pre caption="Configurando o nome do domínio">
# <i>echo homenetwork &gt; /etc/dnsdomainname</i>
</pre>

<p>
Se você tem um domínio NIS (se você não sabe o que é isso, é sinal que você não tem um), 
você também precisa definí-lo:
</p>

<pre caption="Configurando o nome do domínio NIS">
# <i>echo nis.homenetwork &gt; /etc/nisdomainname</i>
</pre>

<p>
Agora adicione o initscript <c>domainname</c> ao runlevel default:
</p>

<pre caption="Adicionando o domainname ao runlevel default">
# <i>rc-update add domainname default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Configurando a rede</title>
<body>

<p>
Antes de você pensar "Ei, nós já fizemos isto!", você deve lembrar
a rede que você configurou no início da instalação do Gentoo era 
somente para a instalação. Neste momento você irá configurar a rede para
o sistema Gentoo permanentemente.
</p>

<p>
Toda informação de rede é reunida em <path>/etc/conf.d/net</path>. É usada 
uma sintaxe simples mas não intuitiva se você não sabe como configrar a 
rede manualmente. Mas não se assuste, iremos explicar tudo. :)
</p>

<p>
Primeiro abra o <path>/etc/conf.d/net</path> com o seu editor favorito (o <c>nano</c>
é usado neste exemplo):
</p>

<pre caption="Abrindo o /etc/conf.d/net para edição">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
A primeira variavel que você encontará é <c>iface_eth0</c>. Nela é usada a seginte 
sintaxe:
</p>

<pre caption="Sintaxe de iface_eth0">
iface_eth0="<i>&lt;your ip address&gt;</i> broadcast <i>&lt;your broadcast address&gt;</i> netmask <i>&lt;your netmask&gt;</i>"
</pre>

<p>
Se você usa DHCP (obtenção atomatica de IP), você deve configurar <c>iface_eth0</c>
para <c>dhcp</c>. Se você usa rp-pppoe (ADSL), configure isto para <c>up</c>. 
Se você precisa configurar sua rede manualmente e você não estiver 
familiarizado com todos os termos acima, favor leia a seção em <uri
link="?part=1&amp;chap=3#doc_chap4_sect3">Understanding Network
Terminology</uri> se você ainda não a leu.
</p>

<p>
Então deixe-nos dar três exemplos; o primeiro usa DHCP, o segundo um 
IP (192.168.0.2) fixo com máscara de rede 255.255.255.0, broadcast 192.168.0.255 e 
gateway 192.168.0.1 enquanto o terceiro ativa a interface para 
usar rp-pppoe:
</p>

<pre caption="Exemplos para o /etc/conf.d/net">
<comment>(For DHCP)</comment>
iface_eth0="dhcp"
<comment># Some network admins require that you use the</comment>
<comment># hostname and domainname provided by the DHCP server.</comment>
<comment># In that case, add the following to let dhcpcd use them.</comment>
<comment># That will override your own hostname and domainname definitions.</comment>
dhcpcd_eth0="-HD"
<comment># If you intend on using NTP to keep your machine clock synchronized, use</comment>
<comment># the -N option to prevent dhcpcd from overwriting your /etc/ntp.conf file</comment>
dhcpcd_eth0="-N"

<comment>(For static IP)</comment>
iface_eth0="192.168.0.2 broadcast 192.168.0.255 netmask 255.255.255.0"
gateway="eth0/192.168.0.1"

<comment>(For rp-pppoe)</comment>
iface_eth0="up"
</pre>

<p>
Se você tem várias interfaces de rede, crie variáveis <c>iface_eth</c> extras,
como <c>iface_eth1</c>, <c>iface_eth2</c> etc. A variável <c>gateway</c> 
não deveria haver várias já que só pode haver um gateway por computador.
</p>

<p>
Agora salve a configuração e saia para continuar.
</p>

</body>
</subsection>
<subsection>
<title>Iniciar a Rede Automaticamente na Inicialização</title>
<body>

<p>
Para ter sua interface de rede ativa na inicialização, você precisa adicioná-las
ao runlevel default. Se você tem interfaces PCMCIA você não precisa fazer isto já que
as interfaces PCMCIA são iniciadas pelo initscript PCMCIA.
</p>

<pre caption="Adicionando net.eth0 ao runlevel default">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
Se você tem várias interfaces de rede, você precisa criar os initscripts 
<path>net.eth1</path>, <path>net.eth2</path> etc. apropriados para elas. Você pode 
usar <c>ln</c> para fazer isto:
</p>

<pre caption="Criando initscripts extras">
# <i>cd /etc/init.d</i>
# <i>ln -s net.eth0 net.eth1</i>
# <i>rc-update add net.eth1 default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Escrevendo Informações de Rede</title>
<body>

<p>
Você precisa informar ao Linux sobre sua rede. Isto é definido em
<path>/etc/hosts</path> e ajuda na resolução dos nomes dos hosts para enderedeços IP
para hosts que não são resolvidos pelo seu servidor de nomes. Por exemplo, se sua
rede interna consiste de três PCs chamados <c>jenny</c> (192.168.0.5), 
<c>benny</c> (192.168.0.6) and <c>tux</c> (192.168.0.7 - este sistema) você abriria 
o <path>/etc/hosts</path> e preencheria os valores:
</p>

<pre caption="Abrindo o /etc/hosts">
# <i>nano -w /etc/hosts</i>
</pre>

<pre caption="Preenchendo as informações de rede">
127.0.0.1     localhost
192.168.0.5   jenny.homenetwork jenny
192.168.0.6   benny.homenetwork benny
192.168.0.7   tux.homenetwork tux
</pre>

<p>
Se o seu sistema é o único sistema (ou o servidor de nomes cuida de toda a 
resolução de nomes) uma única linha é suficiente. Por exemplo, se você quer chamar seu
sistema de <c>tux.homenetwork</c>:
</p>

<pre caption="/etc/hosts para PCs isolados ou completamente intergrados">
127.0.0.1     localhost
</pre>

<p>
Salve e saia do editor para continuar.
</p>

<p>
Se você não tem PCMCIA, você pode continuar com <uri
link="#doc_chap3">System Information</uri>. Usuários de PCMCIA devem ler o
seguinte tópico sobre PCMCIA.
</p>

</body>
</subsection>
<subsection>
<title>Opcional: Tenha o PCMCIA Funcionando</title>
<body>

<note>
pcmcia-cs é somente disponível para as plastaformas x86, amd64 e ppc.
</note>

<p>
Usuários de PCMCIA devem primeiramente instalar o pacote <c>pcmcia-cs</c>. Isto também
inclui usuário que irão trabalhar com kernel 2.6 (mesmo que ele não usem drivers PCMCIA
deste pacote). A flag  <c>USE="-X"</c> é necessária para evitar a instalação do 
xorg-x11 neste momento:
</p>

<pre caption="Instalando o pcmcia-cs">
# <i>USE="-X" emerge pcmcia-cs</i>
</pre>

<p>
Com o <c>pcmcia-cs</c> instalado, adicione <c>pcmcia</c> ao runlevel 
<e>default</e>:
</p>

<pre caption="Adicionando pcmcia ao runlevel default">
# <i>rc-update add pcmcia default</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Informações do Sistema</title>
<subsection>
<title>Senha do Root</title>
<body>

<p>
Primeiro nós configuramos a senha do root digitando:
</p>

<pre caption="Configurando a senha do root">
# <i>passwd</i>
</pre>

<p>
Se você que o root possa logar através de uma porta serial, adicione
<c>tty/0</c> ao arquivo <path>/etc/securetty</path>
</p>

<pre caption="Adicionando tts/0 to /etc/securetty">
# <i>echo "tts/0" &gt;&gt; /etc/securetty</i>
</pre>

</body>
</subsection>
<subsection>
<title>Informações do Sistema</title>
<body>

<p>
O Gentoo usa o <path>/etc/rc.conf</path> para configurações gerais para todo o sistema.
Abra o <path>/etc/rc.conf</path> e aproveite todos os comentários do arquivo. :)
</p>

<pre caption="Abrindo o /etc/rc.conf">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
Como você pode ver, este arquivo é bem comentado para ajudar você a configurar as variáveis
de configuraão necessárias. Dê uma atenção especial a variável <c>KEYMAP</c>: se
você selecionar o <c>KEYMAP</c> errado você terá resultados estranhos quando digitar
em seu teclado.
</p>

<note>
Usuários de sistemas SPARC baseados em USB e clones do SPARC deve ter de selecionar im keymap
de i386 (como "us") ao invés de "sunkeymap".
</note>

<p>
<b>PPC</b> uses x86 keymaps on most systems. Users who want to be able to use 
ADB keymaps on boot have to enable ADB keycode sendings in their kernel and have
to set a mac/ppc keymap in <path>rc.conf</path>.
</p>

<p>
Quando você terminar de configurar <path>/etc/rc.conf</path>, salve e saia, e 
continue com <uri link="?part=1&amp;chap=9">Instalando Ferramentas de Sistema
Necessárias</uri>.
</p>

</body>
</subsection>
</section>
</sections>
