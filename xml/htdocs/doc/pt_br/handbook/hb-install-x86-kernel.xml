<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/handbook/hb-install-x86-kernel.xml,v 1.6 2005/01/20 19:19:46 enderson Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<sections>

<version>1.30</version>
<date>2005-01-18</date>

<section>
<title>Fuso horário</title>
<body>

<p>
Você deve primeiro selecionar seu fuso horário para que seu sistema saiba onde está localizado. Procure seu fuso horário em <path>/usr/share/zoneinfo</path>, então faça um link
simbólico para <path>/etc/localtime</path> usando o comando <c>ln</c>:
</p>

<pre caption="Configurando informação de fuso horário">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Suponha que você queira usar GMT)</comment>
# <i>ln -sf /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalando as fontes</title>
<subsection>
<title>Escolhendo um kernel</title>
<body>

<p>
O centro através do qual todas distribuições são construídas é o kernel do Linux. Ele fica entre os programas de usuário e o hardware do sistema. O Gentoo permite que seus usuários escolham dentro de uma variedade de fontes de kernel. Uma lista completa com descrições pode ser encontrada no <uri link="/doc/en/gentoo-kernel.xml">Guia de Kernel do Gentoo</uri>.
</p>

<p>
Para sistemas baseados em x86 nós temos, entre outros kernéis, <c>vanilla-sources</c>
(a fonte do kernel 2.4 padrão desenvolvido pela equipe do kernel do linux),
<c>gentoo-sources</c> (fonte do kernel 2.4 com alterações de melhoria de performance),
 <c>gentoo-dev-sources</c> (fonte do kernel v2.6 com alterações de melhoria 
de performance e estabilidade), <c>development-sources</c> (fonte do kernel vanilla versão 2.6), ...
</p>

<p>
Escolha sua fonte de kernel e instale-a usando o comando <c>emerge</c>. 
</p>

<pre caption="Instalando uma fonte de kernel">
# <i>emerge gentoo-sources</i>
</pre>

<p>
Quando você ver em <path>/usr/src</path> você deve perceber um link simbólico chamado 
<path>linux</path> apontando para a seu fonte do kernel. Iremos presumir que a fonte do
kernel instalado é a <c>gentoo-sources-2.4.26-r6</c>:
</p>

<pre caption="Vendo o link simbólico para a fonte do kernel">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.4.26-gentoo-r9
</pre>

<p>
Se o link simbólico não aponta para a fonte de kernel de sua escolha (note que
<c>linux-2.4.26-gentoo-r9</c> é meramente um exemplo você deve mudá-lo para
o kernel certo:
</p>

<pre caption="Mudando o link simbólico para o kernel">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.4.26-gentoo-r9 linux</i>
</pre>

<p>
Agora está na hora de configurar e compilar sua fonte do kernel. Você pode usar o comando <c>genkernel</c> para fazer isto, que irá construir um kernel genérico parecido com o do LiveCD. Iremos, porém, explicar a configuração manual primeiro, já que é a melhor maneira de otimizar seu ambiente.
</p>

<p>
Se você quiser configurar seu kernel manualmente, continue agora com  <uri
link="#manual">Padrão: Configuração manual</uri>. Se você quiser usar o comando <c>genkernel</c> você deve ler <uri link="#genkernel">Alternativa: Usando o genkernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Padrão: Configuração manual</title>
<subsection>
<title>Introdução</title>
<body>

<p>
Configurar um kernel manualmente é freqüentemente tido como o procedimento mais difícil que um usuário de Linux tem de fazer. Grande mentira -- depois de configurar uns dois kernéis você nem lembrará que foi difícil ;)
</p>

<p>
No entanto, uma coisa <e>é</e> verdade: você deve conhecer seu sistema quando você começar a configurar o kernel manualmente. A maior parte das informações pode ser obtida lendo o conteúdo de <path>/proc/pci</path> (ou usando o comando <c>lspci</c> se disponível). Você também pode rodar  <c>lsmod</c> para ver que módulos o LiveCD usa (pode dar uma boa dica sobre o que ativar).
</p>

<p>
Agora vá para o diretório da fonte do kernel e execute <c>make menuconfig</c>. Isto irá iniciar um menu de configuração baseado em ncurses.
</p>

<pre caption="Rodando o menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Você verá várias seções de configuração. Iremos primeiro listar algumas opções que você deve ativar (ou o Gentoo não irá funcionar, ou não irá funcionar sem mudanças adicionais).
</p>

</body>
</subsection>
<subsection>
<title>Ativando as opções necessárias</title>
<body>

<p>
Antes de tudo, ative o uso de código/drivers em desenvolvimento e experimentais. Você precisa disso, senão muito código/drivers importantes não irão aparecer:
</p>

<pre caption="Selecionando código/drivers experimentais">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
Confira que você irá compilar o seu kernel com o tipo de processador configurado adequadamente:
</p>

<pre caption="Selecionando seu processador">
Processor type and features ---&gt;
  <comment>(Mude de acordo com seu sistema)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

<p>
Agora vá para <c>File Systems</c> e selecione suporte para os sistemas de arquivos que você usa.
<e>Não</e> os compile como módulos, senão seu sistema Gentoo não será capaz de montar suas partições. Também selecione <c>Virtual memory</c>, <c>/proc
file system</c>, <c>/dev file system</c> + <c>Automatically mount at boot</c>:
</p>

<pre caption="Selecionando sistemas de arquivos necessários">
<comment>(Com um kernel da linha 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(Com um kernel da linha 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] /dev file system support (OBSOLETE)
    [*]   Automatically mount at boot
    [*] Virtual memory file system support (former shm fs)

<comment>(Selecione uma ou mais das seguintes opções conforme necessárias ao seu sistema)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Se sua BIOS não consegue trabalhar com discos rígidos grandes e você colocou jumpers no disco rígido para
mostrar um tamanho limitado, você tem que habilitar as seguintes opções para obter acesso
a todo o disco rígido:
</p>

<pre caption="Selecionando suporte de modificação de tamanho auto-geométrica">
<comment>(só com um kernel da linha 2.4.x)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

<p>
Se você está usando PPPoE para conectar à Internet ou está usando um modem discado, você irá precisar das seguintes opções no kernel:
</p>

<pre caption="Selecionando drivers necessários para PPPoE">
<comment>(Com um kernel da linha 2.4.x)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports

<comment>(Com um kernel da linha 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
As duas opções de compressão não fazem mal, mas não são absolutamente necessárias, bem como a opção <c>PPP over Ethernet</c>, que somente pode ser usada pelo comando <c>rp-pppoe</c> quando configurado para fazer PPPoE em modo de kernel.
</p>

<p>
Se você precisar, não se esqueça de incluir suporte no kernel para sua placa de rede.
</p>

<p>
Se você tiver uma CPU Intel que suporta HyperThreading (tm), ou tem um
sistema de várias CPUs, você deve ativar "Symmetric multi-processing support":
</p>

<pre caption="Ativando suporte a SMP">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<p>
Se você usa dispositivos USB (como teclado ou mouse) não se esqueça de ativá-los também:
</p>

<pre caption="Ativando suporte a USB para dispositivos de entrada">
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

<p>
Usuários de laptop que queiram suporte a PCMCIA <e>não</e> devem usar os drivers PCMCIA se
eles escolherem o kernel 2.4. Drivers mais recentes estão disponíveis através do
pacote <c>pcmcia-cs</c> que será instalado depois. Usuários do kernel 2.6, entretanto,
devem usar os drivers PCMCIA disponíveis no kernel.
</p>

<p>
Quando você terminar de configurar seu kernel, continue com  <uri
link="#compiling">Compilando e instalando</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Compilando e instalando</title>
<body>

<p>
Agora que seu kernel está configurado, está na hora de compilá-lo e instalá-lo. Saia da configuração e rode <c>make dep &amp;&amp; make bzImage modules 
modules_install</c>:
</p>

<pre caption="Compilando o kernel">
<comment>(Para um kernel 2.4)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(Para um kernel 2.6)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Quando o kernel terminar de compilar, copie a imagem do kernel para
<path>/boot</path>. Daqui em diante, presumimos que o kernel que você está
instalando seja a versão 2.4.26 do <c>gentoo-sources</c>. Use qualquer nome
que você achar apropriado e lembre-se dele, já que você precisará
mais tarde para configurar o gerenciador de inicialização.
</p>

<pre caption="Instalando o kernel">
# <i>cp arch/i386/boot/bzImage /boot/kernel-2.4.26-gentoo-r9</i>
# <i>cp System.map /boot/System.map-2.4.26-gentoo-r9</i>
</pre>

<p>
Também é sábio copiar o seu arquivo de configuração do kernel para
<path>/boot</path>, caso você precise :)
</p>

<pre caption="Copiando sua configuração de kernel">
# <i>cp .config /boot/config-2.4.26-gentoo-r9</i>
</pre>

<p>
Agora continue com <uri link="#kernel_modules">Instalando módulos avulsos do kernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternativa: Usando o genkernel</title>
<body>

<p>
Se você está lendo esta seção, você escolheu usar nosso script <c>genkernel</c> para 
configurar o kernel para você.
</p>

<p>
Agora que a árvore fonte de seu kernel está instalada, está na hora de compilar seu kernel usando nosso script <c>genkernel</c> para automaticamente construir um kernel para você. 
O <c>genkernel</c> funciona configurando um kernel praticamente idêntico ao modo que nosso kernel do LiveCD é configurado. Isto significa que quando você usar o comando <c>genkernel</c> para construir seu kernel, seu sistema irá geralmente detectar seu hardware na hora da inicialização, como no Live CD. Dado que o genkernel não necessita de nenhuma configuração manual, é uma solução ideal para aqueles usuários que não se sentem confortáveis compilando seus próprios kernéis.
</p>

<p>
Agora vamos ver como usar o genkernel. Primeiro, faça emerge da ebuild do genkernel:
</p>

<pre caption="Instalando o genkernel">
# <i>emerge genkernel</i>
</pre>

<p>
Agora, compile suas fontes de kernel rodando <c>genkernel all</c>.
Esteja alerta, entretanto, de que como o <c>genkernel</c> compila um kernel que suporta quase todos hardwares, esta compilação irá demorar bastante para terminar!
</p>

<p>
Note que se sua partição de inicialização (boot) não usa ext2 ou ext3 como sistema de arquivos você precisará configurar manualmente seu kernel usando o comando  <c>genkernel --menuconfig all</c>
e adicione suporte para seu sistema de arquivos <e>dentro</e> do kernel (isto é, <e>não</e> como módulo).
</p>

<pre caption="Rodando o genkernel">
# <i>genkernel all</i>
</pre>

<p>
Uma vez que o <c>genkernel</c> termine, um kernel, um conjunto completo de módulos e um <e>initial root disk</e> (initrd) serão criados. Nós iremos usar o kernel e o initrd quando formos configurar um gerenciador de inicialização numa parte mais adiantada deste documento. Escreva os nomes do kernel e initrd, uma vez que você irá precisar deles quando for escrever o arquivo de configuração do gerenciador de inicialização. A initrd será iniciada imediatamente após a inicialização para fazer a auto-detecção de hardware (igual ao Live CD), antes de seu sistema "de verdade" iniciar.
</p>

<pre caption="Verificando o nome da imagem de kernel criada e initrd">
# <i>ls /boot/kernel* /boot/initrd*</i>
</pre>

<p>
Agora, vamos fazer mais um passo para deixar nosso sistema mais parecido com o Live CD -- vamos instalar o <c>coldplug</c>. Enquanto o initrd detecta automaticamente hardware que é necessário para carregar seu sistema, o <c>coldplug</c> detecta o resto.
Para instalar e habilitar o <c>coldplug</c>, digite o seguinte:
</p>

<pre caption="Instalando e habilitando o coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Se você quiser que seu sistema reaja a todos eventos de hotplugging, você deve
instalar e configurar o hotplug também:
</p>

<pre caption="Instalando e habilitando o hotplug">
# <i>emerge hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Instalando módulos avulsos do kernel</title>
<subsection>
<title>Instalando módulos adicionais</title>
<body>

<p>
Caso necessário, você deverá realizar fazer emerge dos ebuilds para qualquer hardware adicional que está 
em seu sistema. Aqui está uma lista de ebuilds relacionados ao kernel que você pode realizar um emerge:
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="4in"/>
<tcolumn width="2in"/>
<tr>
  <th>Ebuild</th>
  <th>Propósito</th>
  <th>Comando</th>
</tr>
<tr>
  <ti>nvidia-kernel</ti>
  <ti>Aceleração gráfica da NVIDIA para xorg-x11</ti>
  <ti><c>emerge nvidia-kernel</c></ti>
</tr>
<tr>
  <ti>nforce-audio</ti>
  <ti>Áudio on-board nas placas-mãe NVIDIA NForce(2)</ti>
  <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
  <ti>e100</ti>
  <ti>Adaptadores Intel e100 Fast Ethernet</ti>
  <ti><c>emerge e100</c></ti>
</tr>
<tr>
  <ti>e1000</ti>
  <ti>Adaptadores Intel e1000 Gigabit Ethernet</ti>
  <ti><c>emerge e1000</c></ti>
</tr>
<tr>
  <ti>emu10k1</ti>
  <ti>Suporte a Creative Sound Blaster Live!/Audigy (só para kernéis 2.4)</ti>
  <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
  <ti>ati-drivers</ti>
  <ti>Aceleração gráfica ATI Radeon 8500+/FireGL para xorg-x11</ti>
  <ti><c>emerge ati-drivers</c></ti>
</tr>
</table>

<p>
Lembre-se que alguns dessas ebuilds podem ter muitas dependências. Para verificar 
quais pacotes serão instalados durante o emerge, use <c>emerge 
--pretend</c>. Por exemplo, para o pacote <c>emu10k1</c>:
</p>

<pre caption="Venda a lista completa de pacotes a serem instalados">
# <i>emerge --pretend emu10k1</i>
</pre>

<p>
Se você não gostar das dependências que serão instaladas, utilize <c>emerge --pretend 
--verbose</c> para ver quais opções USE estão sendo checadas para decidir as dependências:
</p>

<pre caption="Vendo as opções USE de um pacote">
# <i>emerge --pretend --verbose emu10k1</i>
<comment>...</comment>
[ebuild  N    ] media-sound/aumix-2.8  +gpm +nls +gtk +gnome +alsa -gtk2
</pre>

<p>
No exemplo anterior você pode ver que as dependências do <c>emu10k1</c> 
(<c>aumix</c>) utiliza as opções de USE <c>gtk</c> e <c>gnome</c>, fazendo com que o gtk (que depende 
do xorg-x11) também seja compilado.
</p>

<p>
Se você não quiser que tudo isso seja instalado, desative as opções de USE, por exemplo:
</p>

<pre caption="Instalando emu10k1 com as opções de USE desativadas">
# <i>USE="-gpm -nls -gtk -gnome -alsa" emerge --pretend emu10k1</i>
</pre>

<p>
Quando você estiver feliz com os resultados, remova a opção <c>--pretend</c> para iniciar 
a instalação do <c>emu10k1</c>.
</p>

</body>
</subsection>
<subsection>
<title>Configurando os módulos</title>
<body>

<p>
Você deve listar os módulos que você quer carregar automaticamente em  
<path>/etc/modules.autoload.d/kernel-2.4</path> (ou <path>kernel-2.6</path>). 
Você pode colocar opções adicionais aos módulos também se quiser.
</p>

<p>
Para ver todos módulos disponíveis, rode o seguinte comando usando o <c>find</c>. Não se esqueça de substituir "&lt;versão do kernel&gt;" com a versão do kernel que você acaba de compilar:
</p>

<pre caption="Vendo todos módulos disponíveis">
# <i>find /lib/modules/&lt;versão do kernel&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Por exemplo, para carregar o módulo <c>3c59x.o</c> automaticamente, edite o arquivo 
<path>kernel-2.4</path> ou <path>kernel-2.6</path> e coloque o nome do módulo nele.
</p>

<pre caption="Editando o /etc/modules.autoload.d/kernel-2.4">
<comment>(Exemplo para kernéis 2.4)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 ou kernel-2.6">
3c59x
</pre>

<p>
Agora rode <c>modules-update</c> para atualizar as mudanças no arquivo
<path>/etc/modules.conf</path>:
</p>

<pre caption="Rodando modules-update">
# <i>modules-update</i>
</pre>

<p>
Continue a instalação com <uri link="?part=1&amp;chap=8">Configurando seu sistema</uri>.
</p>

</body>
</subsection>
</section>
</sections>
