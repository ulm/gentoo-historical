<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/handbook/hb-install-mips-disk.xml,v 1.1 2005/01/14 12:08:27 enderson Exp $ -->

<sections>

<version>1.6</version>
<date>2004-09-14</date>

<section>
<title>Introdução a dispositivos de bloco</title>
<subsection>
<title>Dispositivos de bloco</title>
<body>

<p>
Iremos estudar os aspectos de manuseio de discos do Gentoo Linux e do Linux em geral, incluindo sistemas de arquivos de Linux, partições e dispositivos de bloco.
Então, uma vez que você estiver familiar com o funcionamento de discos e sistemas de arquivos, você será levado para o processo de configuração de partições e sistemas de arquivos para sua instalação do Gentoo Linux.
</p>

<p>
Para começar, iremos introduzir os <e>dispositivos de bloco</e>. O dispositivo de bloco mais famoso é provavelmente aquele que representa o primeiro disco rígido SCSI em um sistema Linux, chamado de 
<path>/dev/sda</path>.
</p>

<p>
Os dispositivos de bloco acima representam uma interface abstrata para o disco. Programas de usuário podem usar os dispositivos de bloco para interagir com seu disco sem preocupação se eles são IDE, SCSI ou outra coisa. O programa pode simplesmente classificar o espaço de armazenagem no disco como um monte de blocos de 512 bytes contíguos acessíveis aleatoriamente.
</p>

</body>
</subsection>
<subsection>
<title>Partições</title>
<body>

<p>
Embora seja teoricamente possível usar um disco inteiro para armazenar seu sistema Linux, isto é quase nunca feito na prática. Ao invés disso, dispositivos de bloco de discos são divididos em dispositivos de bloco menores e mais fáceis de manusear. Eles são chamados de 
<e>partições</e>. 
</p>

</body>
</subsection>
</section>
<section>
<title>Desenhando um esquema de particionamento</title>
<subsection>
<title>Quantas e de que tamanho?</title>
<body>

<p>
O número de partições depende muito de seu ambiente. Por exemplo, se você tem muitos usuários, você provavelmente deve ter seu <path>/home</path> 
separado para aumentar a segurança e tornar backups mais fáceis.
Se você estiver instalando o Gentoo para funcionar como um servidor 
de e-mails, seu <path>/var</path> deve ser separado, uma vez que todos e-mails são gravados dentro de <path>/var</path>. Uma boa escolha de sistema de arquivos irá maximizar sua performance. Servidores de jogos têm uma partição <path>/opt</path> separada, uma vez que a maior parte de servidores de jogos são instalados lá. A razão é semelhante à do <path>/home</path>: 
segurança e backups.
</p>

<p>
Como você pode ver, muito depende do que você quer fazer. Partições ou volumes separados têm as seguintes vantagens:
</p>

<ul>
<li>
  Você pode escolher o sistema de arquivos de melhor performance para cada 
  partição ou volume
</li>
<li>
  Seu sistema inteiro não irá ficar sem espaço se uma ferramenta defunta 
  estiver continuamente escrevendo arquivos em uma partição ou volume
</li>
<li>
  Se necessárias, verificações de sistemas de arquivos têm seu tempo reduzido, já que verificações múltiplas podem ser  
  feitas em paralelo (embora esta vantagem seja maior com vários discos que com várias partições)
</li>
<li>
  A segurança pode ser melhorada ao montar algumas partições ou volumes como somente-leitura, nosuid (bits de setuid são 
  ignorados), noexec (bits executáveis são ignorados), etc...
</li>
</ul>

<p>
No entanto, partições múltiplas têm uma grande desvantagem: se não são configuradas apropriadamente, você pode acabar com um sistema com muito espaço livre em uma partição e nenhum em outra. Também existe um limite de 15 partições para SCSI e SATA.
</p>

</body>
</subsection>
</section>
<section>
<title>Usando o fdisk no MIPS para particionar o seu disco</title>
<subsection>
<title>Criando um SGI Disk Label</title>
<body>

<p>
Todos discos em um sistema SGI precisam de um <e>SGI Disk Label</e>, que serve uma função 
semelhante à das disklabels da Sun e MS-DOS -- gravar informação sobre 
as partições do disco. Duas partições especiais são necessárias para criar um 
novo SGI Disk Label:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (nona partição): Esta partição é importante. É 
    onde vão as imagens do kernel. Para gravar imagens de kernel, você usa a 
    ferramenta conhecida como <c>dvhtool</c> para copiar as imagens de kernel nesta partição.
    Você irá então poder carregar kernéis desta partição vai o SGI PROM 
    Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (décima-primeira partição): Esta partição tem um propósito semelhante 
    à terceira partição do Sun Disklabel que toma "o disco inteiro". Esta partição toma 
    todo o disco, e não deve ser tocada. Ela não tem nenhum propósito especial 
    fora ajudar o PROM de maneiras não documentadas (ou usadas pelo IRIX de 
    algum jeito).
  </li>
</ul>

<warn>
O SGI Volume Header <e>deve</e> começar no cilindro 0. Se você não fizer isto 
não poderá bootar a partir do disco.
</warn>

<p>
O exemplo seguinte é parte de uma sessão de <c>fdisk</c>. Leia e 
adapte conforme suas necessidades...
</p>

<pre caption="Criando um SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Se seu disco não tiver um SGI Disklabel existente, então o fdisk não irá permitir 
a criação de uma label nova. Existem dois jeitos de contornar o problema. Um é criar uma 
disklabel da Sun ou do MS-DOS, salvar as mudanças em disco, e re-iniciar o fdisk. O segundo 
é sobre-escrever a tabela de partições com dados de zero com o seguinte 
comando: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Deixando o SGI Volume Header do tamanho correto</title>
<body>

<p>
Agora que um SGI Disklabel foi criado, as partições podem ser definidas. No nosso 
exemplo acima, existem duas partições definidas para você. Elas são as partições 
especiais mencionadas acima e que não devem ser alteradas normalmente. No entanto,
para instalar o Gentoo, nós iremos carregar imagens múltiplas de kernel diretamente no
volume header, já que não existe um Bootloader para SGI disponível no Portage
ainda. O volume header em si pode armazenar até <e>oito</e> imagens de qualquer tamanho,
com cada imagem podendo ter nomes de oito caracteres. 
</p>

<p>
O processo de tornar o volume header maior não é exatamente simples --
necessitam um pouco de truques. Não é possível simplesmente apagar e re-adicionar o volume 
header devido a problemas no funcionamento do fdisk. No exemplo abaixo, criaremos um 
Volume header de 50MB em conjunção com uma partição de /boot de 50MB. O arranjo real 
de seu disco pode variar, mas este serve propósitos somente ilustrativos.
</p>

<pre caption="Modificando o tamanho do SGI Volume Header corretamente">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Veja como o fdisk só permite que a partição número 1 seja re-criada em um cilindro mínimo de 5)</comment>
<comment>(Se você houvesse tentado apagar e re-criar o SGI Volume Header desta forma, este é o mesmo problema 
 que você teria encontrado.)</comment>
<comment>(Em nosso exemplo, queremos que /boot tenha 50MB, então começamos no cilindro 51 (o Volume Header precisa 
 começar no cilindro 0, lembra?) e ajustar seu cilindro final em 101, o que dará próximo de 50MB (+/- 1-5MB))</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Apagando a partição número 9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Re-criando a partição número 9, terminando antes do fim da partição número 1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Arranjo final de partições</title>
<body>

<p>
Uma vez pronto, você pode criar o resto de suas partições como você quiser.
Depois que todas partições estiverem prontas, certifique-se de mudar a ID da partição 
para <c>82</c>, que é o swap do Linux. Por padrão, serão <c>83</c>, nativas do Linux.
</p>

<p>
Agora que suas partições foram criadas, você pode continuar com  <uri
link="#filesystems">Criando sistemas de arquivos</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Criando sistemas de arquivos</title>
<subsection>
<title>Introdução</title>
<body>

<p>
Agora que suas partições foram criadas, está na hora de colocar um sistema de arquivos nelas.
Se você não se importa em escolher o sistema de arquivos e está contente com o que usamos como padrão neste livro de referência, continue com <uri 
link="#filesystems-apply">Aplicando um sistema de arquivos a uma partição</uri>.
Caso contrário, leia mais para aprender sobre os sistemas de arquivos disponíveis...
</p>

</body>
</subsection>
<subsection>
<title>Sistemas de arquivos?</title>
<body>

<p>
Vários sistemas de arquivos estão disponíveis. Ext2 e ext3 estão estáveis nas 
arquiteturas MIPS, os outros são experimentais.
</p>

<p>
O <b>ext2</b> é o sistema mais testado e fiel ao Linux, mas não tem journaling de metadata, o que significa que verificações rotineiras de sistemas de arquivo ext2 podem levar bastante tempo. Existe agora uma razoável seleção de sistemas de arquivos de nova geração com journaling que podem ter sua consistência verificada rapidamente e que são geralmente preferíveis aos seus respectivos sistemas sem journaling. Sistemas de arquivo com journaling previnem longas esperas quando você carrega seu sistema e seu sistema de arquivos está em um estado inconsistente.
</p>

<p>
O <b>ext3</b> é a versão com journaling do sistema de arquivos ext2, providenciando journaling de metadata para recuperação rápida, fora outros modos de journaling aprimorados como full data e ordered data. O ext3 é um sistema de arquivos muito bom e confiável. Tem uma opção adicional de catalogar hashed b-trees que permite alta performance em quase todas situações. Para resumir, o ext3 é um excelente sistema de arquivos.
</p>

<p>
O <b>ReiserFS</b> é sistema de arquivos baseado em B*-trees que tem uma performance em geral muito boa e muito superior a tanto o ext2 quanto o ext3 na hora de lidar com arquivos pequenos (de menos de 4k), freqüentemente com um fator de 10x-15x. O ReiserFS também escala extremamente bem e tem journaling de metadata. A partir do kernel 2.4.18+, o ReiserFS está sólido e pronto para ser usado tanto como um sistema de arquivos genérico quanto para casos extremos como a criação de sistemas de arquivos enormes, uso de muitos arquivos pequenos, arquivos muito grandes e diretórios contendo dezenas de milhares de arquivos.
</p>

<p>
O <b>XFS</b> é um sistema de arquivos com journaling de metadata que vem com um robusto conjunto de funções e é otimizado para escalabilidade. Só recomendamos usar este sistema de arquivos em sistemas rodando Linux com equipamento SCSI de ponta e/ou armazenamento em canais de fibra e fonte de energia sem interrupção. Pelo fato de o XFS criar cachês agressivamente de dados em uso na memória RAM, programas mal desenhados (que não tomam precauções na hora de escrever os arquivos em disco, e existem muitos deles) podem perder uma grande quantidade de dados se o sistema for desligado sem aviso.
</p>

<p>
O <b>JFS</b> é o sistema de arquivos com journaling de alta performance da IBM. Recentemente tornou-se pronto para uso em produção e não há experiência suficiente para comentar a favor ou contra sua estabilidade geral neste ponto.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Aplicando um sistema de arquivos a uma partição</title>
<body>

<p>
Para criar um sistema de arquivos em uma partição ou volume, existem ferramentas disponíveis para cada sistema de arquivos possível:
</p>

<table>
<tr>
  <th>Sistema de arquivos</th>
  <th>Comando de criação</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Por exemplo, para ter a partição de boot (<path>/dev/sda1</path> em nosso
exemplo) em ext2 e a partição de root (<path>/dev/sda3</path> em nosso exemplo)
em ext3 (como em nosso exemplo), você faria:
</p>

<pre caption="Aplicando um sistema de arquivos a uma partição">
# <i>mke2fs /dev/sda1</i>
# <i>mke2fs -j /dev/sda3</i>
</pre>

<p>
Agora crie os sistemas de arquivos em suas partições recém-criadas (ou volumes
lógicos).
</p>

</body>
</subsection>
<subsection>
<title>Ativando a partição de swap</title>
<body>

<p>
<c>mkswap</c> é o comando usado para iniciar partições de swap:
</p>

<pre caption="Criando uma assinatura de swap">
# <i>mkswap /dev/sda2</i>
</pre>

<p>
Para ativar a partição de swap, use <c>swapon</c>:
</p>

<pre caption="Ativando a partição de swap">
# <i>swapon /dev/sda2</i>
</pre>

<p>
Crie e ative o swap agora.
</p>

</body>
</subsection>
</section>
<section>
<title>Montando</title>
<body>

<p>
Agora que suas partições foram iniciadas e possuem um sistema de arquivos, está na hora de montá-las. Use o comando <c>mount</c>. Não se esqueça de criar os diretórios necessários de montagem para cada partição que você criou. Como exemplo montamos a partição de root e de boot:
</p>

<pre caption="Montando partições">
# <i>mount /dev/sda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/sda1 /mnt/gentoo/boot</i>
</pre>

<note>
Se você quiser que seu <path>/tmp</path> resida em uma partição separada, certifique-se de mudar suas permissões depois de montá-la: <c>chmod 1777 /mnt/gentoo/tmp</c>. O mesmo vale para <path>/var/tmp</path>.
</note>

<p>
Agora iremos montar o sistema de arquivos proc (uma interface virtual com o kernel) em <path>/proc</path>. Mas primeiro iremos colocar nossos arquivos nas partições.
</p>

<p>
Continue com <uri link="?part=1&amp;chap=5">Instalando os arquivos de instalação do Gentoo</uri>.
</p>

</body>
</section>
</sections>
