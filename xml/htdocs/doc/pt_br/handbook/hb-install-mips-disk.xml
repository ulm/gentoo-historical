<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pt_br/handbook/hb-install-mips-disk.xml,v 1.6 2005/03/12 23:01:49 enderson Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<sections>

<version>1.7</version>
<date>2005-02-14</date>

<section>
<title>Introdução a dispositivos de bloco</title>
<subsection>
<title>Dispositivos de bloco</title>
<body>

<p>
Iremos estudar os aspectos de manuseio de discos do Gentoo Linux e do Linux em geral, incluindo sistemas de arquivos de Linux, partições e dispositivos de bloco.
Então, uma vez que você estiver familiar com o funcionamento de discos e sistemas de arquivos, você será levado para o processo de configuração de partições e sistemas de arquivos para sua instalação do Gentoo Linux.
</p>

<p>
Para começar, iremos introduzir os <e>dispositivos de bloco</e>. O dispositivo de bloco mais famoso é provavelmente aquele que representa o primeiro disco rígido SCSI em um sistema Linux, chamado de 
<path>/dev/sda</path>.
</p>

<p>
Os dispositivos de bloco acima representam uma interface abstrata para o disco. Programas de usuário podem usar os dispositivos de bloco para interagir com seu disco sem preocupação se eles são IDE, SCSI ou outra coisa. O programa pode simplesmente classificar o espaço de armazenagem no disco como um monte de blocos de 512 bytes contíguos acessíveis aleatoriamente.
</p>

</body>
</subsection>
<subsection>
<title>Partições</title>
<body>

<p>
Embora seja teoricamente possível usar um disco inteiro para armazenar seu sistema Linux, isto é quase nunca feito na prática. Ao invés disso, dispositivos de bloco de discos são divididos em dispositivos de bloco menores e mais fáceis de manusear. Eles são chamados de 
<e>partições</e>. 
</p>

</body>
</subsection>
</section>
<section>
<title>Desenhando um esquema de particionamento</title>
<subsection>
<title>Quantas e de que tamanho?</title>
<body>

<p>
O número de partições depende muito de seu ambiente. Por exemplo, se você tem muitos usuários, você provavelmente deve ter seu <path>/home</path> 
separado para aumentar a segurança e tornar backups mais fáceis.
Se você estiver instalando o Gentoo para funcionar como um servidor 
de e-mails, seu <path>/var</path> deve ser separado, uma vez que todos e-mails são gravados dentro de <path>/var</path>. Uma boa escolha de sistema de arquivos irá maximizar sua performance. Servidores de jogos têm uma partição <path>/opt</path> separada, uma vez que a maior parte de servidores de jogos são instalados lá. A razão é semelhante à do <path>/home</path>: 
segurança e backups.
</p>

<p>
Como você pode ver, muito depende do que você quer fazer. Partições ou volumes separados têm as seguintes vantagens:
</p>

<ul>
<li>
  Você pode escolher o sistema de arquivos de melhor performance para cada 
  partição ou volume
</li>
<li>
  Seu sistema inteiro não irá ficar sem espaço se uma ferramenta defunta 
  estiver continuamente escrevendo arquivos em uma partição ou volume
</li>
<li>
  Se necessárias, verificações de sistemas de arquivos têm seu tempo reduzido, já que verificações múltiplas podem ser  
  feitas em paralelo (embora esta vantagem seja maior com vários discos que com várias partições)
</li>
<li>
  A segurança pode ser melhorada ao montar algumas partições ou volumes como somente-leitura, nosuid (bits de setuid são 
  ignorados), noexec (bits executáveis são ignorados), etc...
</li>
</ul>

<p>
No entanto, partições múltiplas têm uma grande desvantagem: se não são configuradas apropriadamente, você pode acabar com um sistema com muito espaço livre em uma partição e nenhum em outra. Também existe um limite de 15 partições para SCSI e SATA.
</p>

</body>
</subsection>
</section>
<section>
<title>Usando o fdisk no MIPS para particionar o seu disco</title>
<subsection>
<title>Máquinas SGI: Criando um SGI Disk Label</title>
<body>

<p>
Todos discos em um sistema SGI precisam de um <e>SGI Disk Label</e>, que serve uma função 
semelhante à das disklabels da Sun e MS-DOS -- gravar informação sobre 
as partições do disco. Duas partições especiais são necessárias para criar um 
novo SGI Disk Label:
</p>

<ul>
  <li>
<!--    <e>SGI Volume Header</e> (9th partition): This partition is important. It
    is where the kernel images will go. To store kernel images, you will utilize
    the tool known as <c>dvhtool</c> to copy kernel images to this partition. 
    You will then be able to boot kernels from this partition via the SGI PROM 
    Monitor.	-->
    <e>SGI Volume Header</e> (nona partição): Esta partição é importante. Ela é
    onde o gerenciador de inicialização arcboot será instalado.
  </li>
  <li>
    <e>SGI Volume</e> (décima-primeira partição): Esta partição tem um propósito semelhante 
    à terceira partição do Sun Disklabel que toma "o disco inteiro". Esta partição toma 
    todo o disco, e não deve ser tocada. Ela não tem nenhum propósito especial 
    fora ajudar o PROM de maneiras não documentadas (ou usadas pelo IRIX de 
    algum jeito).
  </li>
</ul>

<warn>
O SGI Volume Header <e>deve</e> começar no cilindro 0. Se você não fizer isto 
não poderá carregar a partir do disco.
</warn>

<p>
O exemplo seguinte é parte de uma sessão de <c>fdisk</c>. Leia e 
adapte conforme suas necessidades...
</p>

<pre caption="Criando um SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Se seu disco não tiver um SGI Disklabel existente, então o fdisk não irá permitir 
a criação de uma label nova. Existem dois jeitos de contornar o problema. Um é criar uma 
disklabel da Sun ou do MS-DOS, salvar as mudanças em disco, e re-iniciar o fdisk. O segundo 
é sobre-escrever a tabela de partições com dados de zero com o seguinte 
comando: <c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

<!-- This has been dropped in favour of using arcboot
<p>Getting the SGI Volume Header to just the right size</p>

<p>
Now that an SGI Disklabel is created, partitions may now be defined. In the
above example, there are already two partitions defined for you. These are the
special partitions mentioned above and should not normally be altered. However,
for installing Gentoo, we'll need to load multiple kernel images directly into
the volume header, as there is no supported SGI Bootloader available in Portage
yet. The volume header itself can hold up to <e>eight</e> images of any size, 
with each image allowed eight-character names.
</p>

<p>
The process of making the volume header larger isn't exactly straight-forward - -
there's a bit of a trick to it. One cannot simply delete and re-add the volume
header due to odd fdisk behavior. In the example provided below, we'll create a
50MB Volume header in conjunction with a 50MB /boot partition. The actual layout
of your disk may vary, but this is for illustrative purposes only.
</p>

<pre caption="Resizing the SGI Volume Header correctly">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>

<comment>(Notice how fdisk only allows Partition #1 to be re-created starting at a
minimum of cylinder 5?  Had you attempted to delete &amp; re-create the SGI
Volume Header this way, this is the same issue you would have encountered.
In our example, we want /boot to be 50MB, so we start it at cylinder 51 (the 
Volume Header needs to start at cylinder 0, remember?), and set its ending 
cylinder to 101, which will roughly be 50MB (+/- 1-5MB).)</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>

<comment>(Delete Partition #9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>

<comment>(Re-Create Partition #9, ending just before Partition #1)</comment>
</pre>
-->
<p>
Se você não tiver certeza de como usar o <c>fdisk</c> leia abaixo as instruções
de particionamento para Cobalts. Os conceitos são exatamente iguais --
apenas lembre-se de deixar as partições de cabeçalho de volume e disco inteiro sozinhas.
</p>

<!-- <p>  Perhaps part of the above commented-out block?
Once this is done, you are safe to create the rest of your partitions as you see
fit. After all your partitions are laid out, make sure you set the partition ID
of your swap partition to <c>82</c>, which is Linux Swap. By default, it will be
<c>83</c>, Linux Native. 
</p> -->

<p>
Agora que suas partições foram criadas, você pode continuar com  <uri
link="#filesystems">Criando sistemas de arquivos</uri>.
</p>

</body>
</subsection>

<subsection>
<title>Máquinas Cobalt: Particionando seu disco</title>
<body>

<p>
Em máquinas Cobalt, o BOOTROM espera ver um MBR de MS-DOS, então o particionamento do
drive é relativamente simples -- na verdade, é feito da mesma maneira que você faria
em uma máquina Intel x86. <e>Todavia</e> existem algumas coisas que você deve
ter em mente.
</p>

<ul>
  <li>
    O firmware do Cobalt irá esperar que <path>/dev/hda1</path> seja uma partição de Linux
    formatada com <e>EXT2 Revision 0</e>.  <e>Partições EXT2 Revision 1 NÃO IRÃO
    FUNCIONAR!</e>  (O BOOTROM do Cobalt só entende EXT2r0)
  </li>
  <li>
    A partição dita acima deve conter uma imagem ELF gzip-ada,
    <path>vmlinux.gz</path> na raiz da partição, que carrega como o
    kernel
  </li>
</ul>

<p>
Por este motivo, eu recomendo criar uma partição <path>/boot</path> de ~20MB <path>/boot</path>
formatada com EXT2r0 na qual você pode instalar o CoLo &amp; seus kernéis. Isto
permite que você rode um sistema de arquivos moderno (EXT3 ou ReiserFS) para seu sistema de arquivos
raiz.
</p>

<p>
Irei presumir que você criou <path>/dev/hda1</path> para montar mais tarde como uma
partição <path>/boot</path>. Se você quiser que esta seja a partição <path>/</path>, você
precisará lembrar-se das expectativas do PROM.
</p>

<p>
Entao, continuando... Para criar as partições você digita <c>fdisk /dev/hda</c> no
prompt. Os comandos principais de que você precisa saber são os seguintes:
</p>

<ul>
  <li>
    <c>o</c>: Apagar antiga tabela de partições, iniciando com uma tabela de 
    partições MS-DOS vazia
  </li>
  <li>
    <c>n</c>: Nova partição
  </li>
  <li>
    <c>t</c>: Mudar tipo de partição
    <ul>
      <li>Use tipo <c>82</c> para swap de Linux, <c>83</c> para sistema de arquivos de Linux</li>
    </ul>
  </li>
  <li>
    <c>d</c>: Apagar uma partição
  </li>
  <li>
    <c>p</c>: Mostrar (print) tabela de partições
  </li>
  <li>
    <c>q</c>: Sair -- deixando a antiga tabela de partições como está.
  </li>
  <li>
    <c>w</c>: Sair -- escrevendo a tabela de partições no processo.
  </li>
</ul>

<pre caption="Particionando o disco">
# <i>fdisk /dev/hda</i>

The number of cylinders for this disk is set to 19870.
There is nothing wrong with that, but this is larger than 1024,
and could in certain setups cause problems with:
1) software that runs at boot time (e.g., old versions of LILO)
2) booting and partitioning software from other OSs
   (e.g., DOS FDISK, OS/2 FDISK)

<comment>(Inicie limpando quaisquer partições existentes)</comment>
Command (m for help): <i>o</i>
Building a new DOS disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content won't be recoverable.


The number of cylinders for this disk is set to 19870.
There is nothing wrong with that, but this is larger than 1024,
and could in certain setups cause problems with:
1) software that runs at boot time (e.g., old versions of LILO)
2) booting and partitioning software from other OSs
   (e.g., DOS FDISK, OS/2 FDISK)
Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

<comment>(Você pode agora verificar que a tabela de partições está vazia usando o comando 'p')</comment>

Command (m for help): <i>p</i>

Disk /dev/hda: 10.2 GB, 10254827520 bytes
16 heads, 63 sectors/track, 19870 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System

<comment>(Crie a partição /boot)</comment>

Command (m for help): <i>n</i>
Command action
   e   extended
   p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>

<comment>(Simplesmente aperte ENTER aqui para aceitar o padrão)</comment>

First cylinder (1-19870, default 1):
Last cylinder or +size or +sizeM or +sizeK (1-19870, default 19870): <i>+20M</i>

<comment>(e agora se apertarmos 'p' novamente, nós devemos ver a nova partição)</comment>
Command (m for help): <i>p</i>

Disk /dev/hda: 10.2 GB, 10254827520 bytes
16 heads, 63 sectors/track, 19870 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hda1               1          40       20128+  83  Linux

<comment>(O resto, prefiro colocar em uma partição estendida, então irei criá-la)</comment>

Command (m for help): <i>n</i>
Command action
   e   extended
   p   primary partition (1-4)
<i>e</i>
Partition number (1-4): <i>2</i>

<comment>(Novamente, tudo bem com o padrão, só aperte ENTER.)</comment>

First cylinder (41-19870, default 41):
Using default value 41

<comment>(Nós devemos usar o disco inteiro aqui, então aperte ENTER novamente)</comment>
Last cylinder or +size or +sizeM or +sizeK (41-19870, default 19870):
Using default value 19870

<comment>(Agora, a partição / -- eu uso partições separadas para /usr, /var,
etc... então / pode ser pequena. Ajuste de acordo com sua preferência.)</comment>

Command (m for help): <i>n</i>
Command action
   l   logical (5 or over)
   p   primary partition (1-4)
<i>l</i>
First cylinder (41-19870, default 41):<i>&lt;Aperte ENTER&gt;</i>
Using default value 41
Last cylinder or +size or +sizeM or +sizeK (41-19870, default 19870): <i>+500M</i>

<comment>(... e semelhante para quaisquer outras partições ...)</comment>

<comment>(Por fim, a partição de swap. Eu recomendo pelo menos 250MB de swap,
de preferência 1GB)</comment>

Command (m for help): <i>n</i>
Command action
   l   logical (5 or over)
   p   primary partition (1-4)
<i>l</i>
First cylinder (17294-19870, default 17294): <i>&lt;Aperte ENTER&gt;</i>
Using default value 17294
Last cylinder or +size or +sizeM or +sizeK (1011-19870, default 19870): <i>&lt;Aperte ENTER&gt;</i>
Using default value 19870

<comment>(Agora, se nós verificarmos nossa tabela de partições, tudo deve estar pronto para embarcação
fora uma coisa...)</comment>

Command (m for help): <i>p</i>

Disk /dev/hda: 10.2 GB, 10254827520 bytes
16 heads, 63 sectors/track, 19870 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

Device Boot      Start         End      Blocks      ID  System
/dev/hda1               1          21       10552+  83  Linux
/dev/hda2              22       19870    10003896    5  Extended
/dev/hda5              22        1037      512032+  83  Linux
/dev/hda6            1038        5101     2048224+  83  Linux
/dev/hda7            5102        9165     2048224+  83  Linux
/dev/hda8            9166       13229     2048224+  83  Linux
/dev/hda9           13230       17293     2048224+  83  Linux
/dev/hda10          17294       19870     1298776+  83  Linux

<comment>(Veja como o #10, nossa partição de swap ainda é do tipo 83?)</comment>

Command (m for help): <i>t</i>
Partition number (1-10): <i>10</i>
Hex code (type L to list codes): <i>82</i>
Changed system type of partition 10 to 82 (Linux swap)

<comment>(Isto deve consertar o problema... só para verificar...)</comment>

Command (m for help): <i>p</i>

Disk /dev/hda: 10.2 GB, 10254827520 bytes
16 heads, 63 sectors/track, 19870 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

Device Boot      Start         End      Blocks      ID  System
/dev/hda1               1          21       10552+  83  Linux
/dev/hda2              22       19870    10003896    5  Extended
/dev/hda5              22        1037      512032+  83  Linux
/dev/hda6            1038        5101     2048224+  83  Linux
/dev/hda7            5102        9165     2048224+  83  Linux
/dev/hda8            9166       13229     2048224+  83  Linux
/dev/hda9           13230       17293     2048224+  83  Linux
/dev/hda10          17294       19870     1298776+  82  Linux Swap

<comment>(Agora, nós escrevemos a nova tabela de partições.)</comment>

Command (m for help): <i>w</i>
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.

#
</pre>

<p>
E isso é tudo que há para fazer. Você deve seguir agora para o próximo
estágio: <uri link="#filesystems">Criando sistemas de arquivos</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Criando sistemas de arquivos</title>
<subsection>
<title>Introdução</title>
<body>

<p>
Agora que suas partições foram criadas, está na hora de colocar um sistema de arquivos nelas.
Se você não se importa em escolher o sistema de arquivos e está contente com o que usamos como padrão neste manual, continue com <uri 
link="#filesystems-apply">Aplicando um sistema de arquivos a uma partição</uri>.
Caso contrário, leia mais para aprender sobre os sistemas de arquivos disponíveis...
</p>

</body>
</subsection>
<subsection>
<title>Sistemas de arquivos?</title>
<body>

<p>
Vários sistemas de arquivos estão disponíveis. ReiserFS, EXT2 e EXT3 estão estáveis nas 
arquiteturas MIPS, os outros são experimentais.
</p>

<p>
O <b>ext2</b> é o sistema mais testado e fiel ao Linux, mas não tem journaling de metadata, o que significa que verificações rotineiras de sistemas de arquivo ext2 podem levar bastante tempo. Existe agora uma razoável seleção de sistemas de arquivos de nova geração com journaling que podem ter sua consistência verificada rapidamente e que são geralmente preferíveis aos seus respectivos sistemas sem journaling. Sistemas de arquivo com journaling previnem longas esperas quando você carrega seu sistema e seu sistema de arquivos está em um estado inconsistente.
</p>

<p>
O <b>ext3</b> é a versão com journaling do sistema de arquivos ext2, fornecendo journaling de metadata para recuperação rápida, fora outros modos de journaling aprimorados como full data e ordered data. O ext3 é um sistema de arquivos muito bom e confiável. Tem uma opção adicional de catalogar hashed b-trees que permite alta performance em quase todas situações. Para resumir, o ext3 é um excelente sistema de arquivos.
</p>

<p>
O <b>ReiserFS</b> é sistema de arquivos baseado em B*-trees que tem uma performance em geral muito boa e muito superior a tanto o ext2 quanto o ext3 na hora de lidar com arquivos pequenos (de menos de 4k), freqüentemente com um fator de 10x-15x. O ReiserFS também escala extremamente bem e tem journaling de metadata. A partir do kernel 2.4.18+, o ReiserFS está sólido e pronto para ser usado tanto como um sistema de arquivos genérico quanto para casos extremos como a criação de sistemas de arquivos enormes, uso de muitos arquivos pequenos, arquivos muito grandes e diretórios contendo dezenas de milhares de arquivos.
</p>

<p>
O <b>XFS</b> é um sistema de arquivos com journaling de metadata que vem com um robusto conjunto de funções e é otimizado para escalabilidade. Só recomendamos usar este sistema de arquivos em sistemas rodando Linux com equipamento SCSI de ponta e/ou armazenamento em canais de fibra e fonte de energia sem interrupção. Pelo fato de o XFS criar cachês agressivamente de dados em uso na memória RAM, programas mal desenhados (que não tomam precauções na hora de escrever os arquivos em disco, e existem muitos deles) podem perder uma grande quantidade de dados se o sistema for desligado sem aviso.
</p>

<p>
O <b>JFS</b> é o sistema de arquivos com journaling de alta performance da IBM. Recentemente tornou-se pronto para uso em produção e não há experiência suficiente para comentar a favor ou contra sua estabilidade geral neste ponto.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Aplicando um sistema de arquivos a uma partição</title>
<body>

<p>
Para criar um sistema de arquivos em uma partição ou volume, existem ferramentas disponíveis para cada sistema de arquivos possível:
</p>

<table>
<tr>
  <th>Sistema de arquivos</th>
  <th>Comando de criação</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Por exemplo, para ter a partição de inicialização (boot) (<path>/dev/sda1</path> em nosso
exemplo) em ext2 e a partição de root (<path>/dev/sda3</path> em nosso exemplo)
em ext3 (como em nosso exemplo), você faria:
</p>

<pre caption="Aplicando um sistema de arquivos a uma partição">
# <i>mke2fs /dev/sda1</i>
# <i>mke2fs -j /dev/sda3</i>
</pre>

<p>
Agora crie os sistemas de arquivos em suas partições recém-criadas (ou volumes
lógicos).
</p>

<warn>
Se você estiver instalando em um servidor Cobalt, lembre-se de que <path>/dev/hda1</path> DEVE ser
do tipo <e>EXT2 revision 0</e>; Qualquer outro (como EXT2 revision 1, EXT3,
ReiserFS, XFS, JFS e outros) <e>NÃO IRÁ FUNCIONAR!</e>
Você pode formatar a partição usando o comando: <c>mke2fs -r 0 /dev/hda1</c>.
</warn>

<warn>
Também, saiba que o arcboot não é capaz de ler outros sistemas de arquivos fora
EXT2, EXT3 e ISO9660 (versões recentes). Por este motivo, 
<path>/boot</path> em máquinas SGI devem também residir em uma partição EXT2 ou EXT3.
</warn>

</body>
</subsection>
<subsection>
<title>Ativando a partição de swap</title>
<body>

<p>
<c>mkswap</c> é o comando usado para criar e inicializar partições de swap:
</p>

<pre caption="Criando uma assinatura de swap">
# <i>mkswap /dev/sda2</i>
</pre>

<p>
Para ativar a partição de swap, use <c>swapon</c>:
</p>

<pre caption="Ativando a partição de swap">
# <i>swapon /dev/sda2</i>
</pre>

<p>
Crie e ative o swap agora.
</p>

</body>
</subsection>
</section>
<section>
<title>Montando</title>
<body>

<p>
Agora que suas partições foram iniciadas e possuem um sistema de arquivos, está na hora de montá-las. Use o comando <c>mount</c>. Não se esqueça de criar os diretórios necessários de montagem para cada partição que você criou. Como exemplo montamos a partição de root e de inicialização (boot):
</p>

<pre caption="Montando partições">
# <i>mount /dev/sda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/sda1 /mnt/gentoo/boot</i>
</pre>

<note>
Se você quiser que seu <path>/tmp</path> resida em uma partição separada, certifique-se de mudar suas permissões depois de montá-la: <c>chmod 1777 /mnt/gentoo/tmp</c>. O mesmo vale para <path>/var/tmp</path>.
</note>

<p>
Agora iremos montar o sistema de arquivos proc (uma interface virtual com o kernel) em <path>/proc</path>. Mas primeiro iremos colocar nossos arquivos nas partições.
</p>

<p>
Continue com <uri link="?part=1&amp;chap=5">Instalando os arquivos de instalação do Gentoo</uri>.
</p>

</body>
</section>
</sections>
