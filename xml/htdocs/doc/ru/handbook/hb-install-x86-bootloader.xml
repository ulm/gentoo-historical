<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-x86-bootloader.xml,v 1.9 2006/03/08 00:52:45 achumakov Exp $ -->


<sections>

<version>2.11</version>
<date>2006-02-02</date>

<section>
<title>Делаем выбор</title>
<subsection>
<title>Введение</title>
<body>

<p>
Теперь, когда ядро сконфигурировано и собрано, необходимые системные файлы
отредактированы должным образом, пришло время установить программу, которая
будет запускать ваше ядро при старте системы. Такого рода программа называется
<e>загрузчик</e>. Для архитектуры x86 Gentoo Linux предоставляет загрузчики <uri
link="#grub">GRUB</uri> и <uri link="#lilo">LILO</uri>. Но прежде, чем
приступить к установке одного из двух загрузчиков, мы расскажем как настроить
кадровый буфер (естественно если вы хотите). Используя кадровый буфер вы сможете
работать в консоли Linux, используя (ограниченно) графику (например, симпатичная
картинка при загрузке, как это сделано во время начала установки Gentoo).
</p>

</body>
</subsection>
<subsection>
<title>Необязательный шаг: кадровый буфер</title>
<body>

<p>
<e>Если</e> вы настроили в ядре поддержку кадрового буфера (или использовали 
настройки по умолчанию в <c>genkernel</c>), вы можете включить его, добавив
параметр <c>vga</c> и/или <c>video</c> в файл конфигурации вашего загрузчика.
</p>

<p>
Для начала, вам надо знать тип используемого вами кадрового буфера. Если вы
используете исходные коды ядра специально подготовленные для использования в
Gentoo (такие, как <c>gentoo-sources</c>), вы имеете возможность выбрать
<c>vesafb-tng</c> в качестве <c>типа драйвера VESA</c> (который используется по
умолчанию в этих исходных кодах ядра). В случае использования <c>vesafb-tng</c>
вам нет необходимости использовать параметр <c>vga</c>. Наоборот, если вы
используете драйвер <c>vesafb</c>, вам необходимо использовать параметр
<c>vga</c>.
</p>

<p>
Параметр <c>vga</c> устанавливает разрешение и глубину цвета, используемые
кадровым буфером <c>vesafb</c>. Как означено в
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path> (который вы сможете
найти после установки пакета с деревом исходных кодов ядра), вы должны передать 
кадровому буферу число в стандарте VESA, относящееся к желаемому разрешению и
глубине цвета 
</p>

<p>
В приведенной ниже таблице собраны возможные варианты сочетаний
разрешение/глубина цвета и соответствующие им значения для параметра <c>vga</c>
</p>

<table>
<tr>
  <ti></ti>
  <th>640x480</th>
  <th>800x600</th>
  <th>1024x768</th>
  <th>1280x1024</th>
</tr>
<tr>
  <th>256</th>
  <ti>0x301</ti>
  <ti>0x303</ti>
  <ti>0x305</ti>
  <ti>0x307</ti>
</tr>
<tr>
  <th>32k</th>
  <ti>0x310</ti>
  <ti>0x313</ti>
  <ti>0x316</ti>
  <ti>0x319</ti>
</tr>
<tr>
  <th>64k</th>
  <ti>0x311</ti>
  <ti>0x314</ti>
  <ti>0x317</ti>
  <ti>0x31A</ti>
</tr>
<tr>
  <th>16M</th>
  <ti>0x312</ti>
  <ti>0x315</ti>
  <ti>0x318</ti>
  <ti>0x31B</ti>
</tr>
</table>

<p>
Значение <c>video</c> устанавливает параметры отображения кадрового буфера.
Здесь необходимо указать тип используемого кадрового буфера (<c>vesafb</c> для
ядра 2.6 или <c>vesa</c> для ядра 2.4) и желаемые дополнительные параметры.
Значения всех переменных приведены в
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path>, но здесь мы расскажем о
трех наиболее часто используемых из них:
</p>

<table>
<tr>
  <th>Переменная</th>
  <th>Описание</th>
</tr>
<tr>
  <ti>ywrap</ti>
  <ti>
    Предполается, что видеокарта может закольцевать свою память (например,
    продолжить с начала, когда достигнут конец).
  </ti>
</tr>
<tr>
  <ti>mtrr</ti>
  <ti>
    Установить регистры MTRR
  </ti>
</tr>
<tr>
  <ti><c>mode</c></ti>
  <ti>
    (только для <c>vesafb-tng</c>)<br/>
    Установить разрешение, глубину цветопередачи и частоту обновления.
    Например, <c>1024x768-32@85</c> для разрешения 1024x768, 32 битной глубины
    цвета и частота обновления 85 Герц.
  </ti>
</tr>
</table>

<p>
В результате должно получиться что-то аналогичное <c>vga=0x318
video=vesafb:mtrr,ywrap</c> или <c>video=vesafb:mtrr,ywrap,1024x768-32@85</c>.
Запомните (или запишите) значения, которое вы подобрали, скоро они понадобятся.
</p>

<p>
Продолжаем установку <uri link="#grub">GRUB</uri> <e>или</e> <uri
link="#lilo">LILO</uri>.
</p>

</body>
</subsection>
</section>
<section id="grub">
<title>По умолчанию: Используем GRUB</title>
<subsection>
<title>Введение в терминологию GRUB'а</title>
<body>

<p>
Самым сложным моментом в освоении GRUB является понимание того, 
как он именует жесткие диски и разделы. Ваш Linux раздел <path>/dev/hda1</path> 
скорее всего будет именоваться <path>(hd0,0)</path> в терминологии GRUB.
Обратите внимание на круглые скобки вокруг <path>hd0,0</path> - они 
обязательны.
</p>

<p>
Жесткие диски нумеруются, начиная с &quot;0&quot;, а не с &quot;а&quot;.
Разделы, также нумеруются, начиная с &quot;0&quot;, а не с &quot;1&quot;.
Необходимо отметить, что под hd подразумеваются только жесткие диски, а
atapi-ide устройства, такие как cdrom или пишущий cdrom не учитываются. Тоже
самое относится и к устройствам SCSI (обычно они получают номера большие, чем
IDE устройства, исключая те случаи, когда BIOS настроена на загрузку с
устройства SCSI). Когда вы настраиваете BIOS на загрузку с другого жесткого
диска (например, второй диск на первом канале IDE) <e>этот</e> жесткий диск и
будет назван <path>hd0</path>.
</p>

<p>
Предположим у вас жесткий диск <path>/dev/hda</path>, cdrom
<path>/dev/hdb</path>, пишущий cdrom <path>/dev/hdc</path>, второй жесткий диск
<path>/dev/hdd</path> и в системе нет устройств SCSI, тогда раздел
<path>/dev/hdd7</path> будет именоваться как <path>(hd1,6)</path>. Это может
показаться несколько запутанным, но GRUB обладает механизмом автодополнения при нажатии на tab,
что облегчает жизнь обладателям большого количества жестких дисков с большим
количеством разделов и тем, кто чувствует себя неуверенно в схеме нумерации
GRUB'ом устройств.
</p>

<p>
Настало время установить GRUB.
</p>

</body>
</subsection>
<subsection>
<title>Установка GRUB</title>
<body>

<p>
Установим GRUB в систему:
</p>

<pre caption = "Установка GRUB">
# <i>emerge grub</i>
</pre>

<p>
Несмотря на то, что GRUB установлен, нам все же надо подправить его файл
конфигурации и разместить GRUB в MBR, чтобы он автоматически загружал ваше,
вновь созданное ядро. Создайте <path>/boot/grub/grub.conf</path>, используя
<c>nano</c> (или, если угодно, другой редактор):
</p>

<pre caption = "Создаем /boot/grub/grub.conf">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
Теперь мы заполним <path>grub.conf</path> нашими значениями. Ниже приведены два
возможных примера настройки <path>grub.conf</path> для схемы разделения дисков
из наших примеров. Первый из примеров <path>grub.conf</path>
содержит подробные комментарии. Удостоверьтесь, что вы используете имена
файлов, которые содержат <e>ваш</e> образ ядра и, при необходимости, образ
<e>вашего</e> начального корневого диска (initrd).
</p>

<ul>
  <li>
    Первый пример <path>grub.conf</path> предназначен для тех, кто не
    пользовался <c>genkernel</c> для сборки ядра.
  </li>
  <li>
    Второй пример <path>grub.conf</path> предназначен для тех, кто пользовался 
    <c>genkernel</c> для сборки ядра.
  </li>
</ul>

<note>
Если вы используете JFS в корневом разделе, вы <e>должны</e> добавить
&quot;ro&quot; в строку, содержащую <c>kernel</c>, т.к. JFS требует
восстановления своего журнала до монтирования раздела в режиме чтения-записи.
</note>

<pre caption = "grub.conf для тех, кто не пользовался genkernel">
<comment># Пункт меню, загружаемый по умолчанию: 0 - первый, 1 - второй и т.д.</comment>
default 0
<comment># Время задержки (в секундах) до начала загрузки пункта меню по умолчанию.</comment>
timeout 30
<comment># Симпатичная картинка :)
# Закомментируйте эту строку, если у вас не установлена графическая видеокарта</comment>
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
<comment># Раздел, где находится файл образа ядра (или вся операционная система)</comment>
root (hd0,0)
kernel /boot/kernel-2.6.12-gentoo-r10 root=/dev/hda3

<comment># Следующие четыре строки только для тех у кого параллельно установлена Windows.</comment>
<comment># В этом примере Windows установлена на /dev/hda6.</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<pre caption = "grub.conf для тех, кто пользовался genkernel">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
root (hd0,0)
kernel /boot/kernel-genkernel-x86-2.6.12-gentoo-r10 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev
initrd /boot/initramfs-genkernel-x86-2.6.12-gentoo-r10

<comment># Только для возможности загрузки Windows</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<note>
Указание <c>udev</c> в конце строки с параметрами ядра необходимо для обхода
ошибок в некоторых версиях genkernel, <e>если</e> вы изначально намереваетесь
использовать udev (по умолчанию предполается использовать).
</note>

<note>
Если схема разделения вашего жесткого диска отличается и/или вы используете
другое ядро, внесите необходимые изменения. Удостоверьтесь, что все, что следует
за указанием на устройство (например <path>(hd0,0)</path>) относительно точки
монтирования, а не корня файловой системы. Другими словами,
<path>(hd0,0)/grub/splash.xpm.gz</path> на самом деле
<path>/boot/grub/splash.xpm.gz</path>, т.к. <path>(hd0,0)</path> это
<path>/boot</path>.
</note>

<p>
Кроме того, если вы решили использовать другую схему разбиения диска, и не 
разместили <path>/boot</path> в отдельном разделе, префикс <path>/boot</path>, 
использованный в примерах выше, в действительности <e>обязателен</e>. Если вы 
следовали рекомендованному нами плану разбиения, то префикс <path>/boot</path>
не требуется, но все работает благодаря символьной ссылке <path>boot</path>.
Короче говоря, приведенные примеры долдны работать независимо от того, 
выделили ли вы отдельный раздел <path>/boot</path> или нет.
</p>

<p>
Если вам надо передать ядру дополнительные параметры, просто добавьте их в
конце строки, с командой kernel. Мы уже передаем ядру один параметр
(<c>root=/dev/hda3</c> или <c>real_root=/dev/hda3</c>), но вы свободно можете
добавлять другие, например такие, как <c>video</c> и/или <c>vga</c> для
кадрового буфера, которые обсуждались ранее.
</p>

<p>
Если вы используете ядро 2.6.7 или выше и вы при помощи перемычек, аппаратно,
ограничили объем жесткого диска из-за того, что BIOS не в состоянии работать с
дисками большого объема, вы должны добавить <c>hdx=stroke</c>.
</p>

<p>
Те, кто использует <c>genkernel</c>, должны помнить, что их ядро использует те
же параметры, что используются в установочном компакт-диске. Например, если у
вас есть устройства SCSI, вы должны передать ядру параметр <c>doscsi</c>.
</p>

<p>
Теперь можно сохранить <path>grub.conf</path> и выйти из редактора. Вам
по-прежнему необходимо установить GRUB в MBR (Master Boot Record), для того,
чтобы GRUB автоматически запускался при загрузке системы.
</p>

<p>
Разработчики GRUB рекомендуют использовать <c>grub-install</c>. Однако, если по
какой-либо причине <c>grub-install</c> завершится с ошибкой, вы можете
установить GRUB вручную.
</p>

<p>
Продолжайте чтение раздела <uri link="#grub-install-auto">По умолчанию:
установка GRUB, используя grub-install</uri> или <uri
link="#grub-install-manual">Альтернатива: установка GRUB вручную</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-auto">
<title>По умолчанию: установка GRUB, используя grub-install</title>
<body>

<p>
Для установки GRUB вам надо выполнить команду <c>grub-install</c>. 
Однако, <c>grub-install</c> не заработает сама по себе, т.к. мы находимся в
изолированной среде. Прежде мы должны создать файл <path>/etc/mtab</path>,
перечислив в нем все смонтированные файловые системы. К счастью, есть очень 
легкий способ сделать это: просто скопируйте содержимое 
<path>/proc/mounts</path> поверх <path>/etc/mtab</path>, за исключением строки  
<c>rootfs</c>, если вы не создавали отдельный загрузочный раздел. Следующая 
команда подойдет в обоих случаях:
</p>

<pre caption="Создание /etc/mtab">
# <i>grep -v rootfs /proc/mounts &gt; /etc/mtab</i>
</pre>

<p>
Теперь мы можем установить GRUB, используя <c>grub-install</c>:
</p>

<pre caption="Выполнение grub-install">
# <i>grub-install /dev/hda</i>
</pre>

<p>
Если у вас есть вопросы, касательно GRUB, пожалуйста обратитесь к <uri
link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> или <uri
link="http://www.gnu.org/software/grub/manual/">руководству по GRUB</uri>.
</p>

<p>
Переходите к разделу <uri link="#reboot">Перезагрузка системы</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-manual">
<title>Альтернатива: установка GRUB вручную</title>
<body>

<p>
Для начала введите <c>grub</c>. Вы увидите приглашение вида
<path>grub&gt;</path>, это командная строка grub. Теперь необходимо ввести
несколько команд для установки GRUB в качестве загрузчика на ваш жесткий диск.
</p>

<pre caption ="Запуск оболочки GRUB">
# <i>grub</i>
</pre>

<note>
Если у вас нет дисковода, добавьте <c>--no-floppy</c> к вышеуказанной команде, 
чтобы grub не искал (не существующий) дисковод.
</note>

<p>
В приведенном примере мы хотим установить GRUB таким образом, чтобы он читал 
необходимую информацию с раздела <path>/dev/hda1</path> и находился в MBR 
(Master Boot Record), чтобы первое, что мы увидим после включения компьютера, 
было приглашение GRUB. Естественно, если ваши установки отличаются от
приведенных в качестве примера, внесите необходимые поправки.
</p>

<p>
Внутри GRUB может использоваться механизм автодополнения (по клавише TAB).
К примеру, если вы напечатаете &quot;<c>root (</c>&quot; с последующим нажатием
на TAB, вы увидите список всех доступных устройств (таких как
<path>hd0</path>). Если вы введете &quot;<c>root (hd0,</c>&quot; и нажмете TAB,
то получите для выбора список всех доступных разделов (таких как
<path>hd0,0</path>).
</p>

<p>
Используя автодополнение, установка GRUB не покажется очень сложной.
Теперь продолжим конфигурирование GRUB.
</p>

<pre caption ="Установка GRUB в MBR">
grub&gt; <i>root (hd0,0)</i>          <comment>(Укажите, где находится раздел с /boot)</comment>
grub&gt; <i>setup (hd0)</i>           <comment>(Устанавливаем GRUB в MBR)</comment>
grub&gt; <i>quit</i>                 	 <comment>(Выходим из оболочки GRUB)</comment>
</pre>

<note>
Если вы хотите установить GRUB в определенный раздел, вместо установки в MBR, 
измените команду <c>setup</c> таким образом, чтобы она указывала на необходимый 
вам раздел. Если, например, вы хотите установить GRUB в <path>/dev/hda3</path>,
тогда команда приобретет следующий вид <c>setup (hd0,2)</c>. Однако, 
потребность в этом встречается не часто.
</note>

<p>
Если у вас есть вопросы, касательно GRUB, пожалуйста обратитесь к <uri
link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> или <uri
link="http://www.gnu.org/software/grub/manual/">руководству по GRUB</uri>.
</p>

<note>
Если вы, впоследствии, будете переустанавливать ядро, вам не надо заново
копировать файлы. Просто введите <c>make install</c> после компиляции
ядра, необходимые действия по копированию файлов и правке конфигурации 
GRUB будут выполнены автоматически.
</note>

<p>
Переходите к разделу <uri link="#reboot">Перезагрузка системы</uri>.
</p>

</body>
</subsection>
</section>
<section id="lilo">
<title>Альтернатива: Используем LILO</title>
<subsection>
<title>Установка LILO</title>
<body>

<p>
LILO (сокращение от LInux LOader) - это испытанный временем загрузчик, 
рабочая лошадка в мире загрузчиков Linux систем. Несмотря на это, он не 
обладает рядом возможностей, которые есть у GRUB (это одна из причин 
возрастающей популярности GRUB). Причина, по которой LILO еще используется, 
заключается в том, что на некоторых системах где он работает GRUB не работает. 
Конечно еще и потому, что многие знакомы с LILO и не желают переходить 
на что-либо другое. Gentoo поддерживает оба загрузчика и, очевидно, вы решили 
использовать LILO.
</p>

<p>
Установка LILO в систему легка, как бриз, просто используйте <c>emerge</c>.
</p>

<pre caption = "Установка LILO">
# <i>emerge lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>Конфигурирование LILO</title>
<body>

<p>
Для настройки LILO вы должны создать файл <path>/etc/lilo.conf</path>. 
Призовите на помощь свой любимый редактор (в этом руководстве мы 
используем <c>nano</c> для единообразия) и создайте файл.
</p>

<pre caption = "Создаем /etc/lilo.conf">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
Несколькими пунктами раньше мы просили вас запомнить имя файла, 
содержащего образ ядра, созданного вами. В приведенном примере 
используется схема разделения диска из наших примеров. 
Пример разделен на две части: 
</p>

<ul>
  <li>
    Одна для тех, кто не использовал <c>genkernel</c> для сборки ядра
  </li>
  <li>
    Другая для тех, кто использовал <c>genkernel</c> для сборки ядра
  </li>
</ul>

<p>
Удостоверьтесь, что вы используете имена файлов, которые содержат <e>ваш</e>
образ ядра и, при необходимости, образ <e>вашего</e> начального корневого диска
(initrd).
</p>

<note>
Если вы используете JFS в корневом разделе, вы <e>должны</e> добавить
&quot;ro&quot; в строку, содержащую <c>kernel</c>, т.к. JFS требует
восстановления своего журнала до монтирования раздела в режиме чтения-записи.
</note>

<pre caption = "Пример /etc/lilo.conf">
boot=/dev/hda		<comment># Устанавливаем LILO в MBR</comment>
prompt			<comment># Даем пользователю шанс выбрать, что он хочет загрузить</comment>
timeout=50		<comment># Ждем 5 (пять) секунд до начала загрузки секции по умолчанию</comment>
default=gentoo	<comment># Когда время истекает, загружаем секцию &quot;gentoo&quot;</comment>

<comment># Для тех, кто не использует genkernel</comment>
image=/boot/kernel-2.6.12-gentoo-r10
  label=gentoo		<comment># Название, присвоенное этой секции</comment>
  read-only		<comment># Запуск с режимом &quot;только для чтения&quot; для корневой ФС. Не изменять!</comment>
  root=/dev/hda3	<comment># Расположение корневой ФС</comment>

<comment># Для тех, кто использует genkernel</comment>
image=/boot/kernel-genkernel-x86-2.6.12-gentoo-r10
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"
  initrd=/boot/initramfs-genkernel-2.6.12-gentoo-r10

<comment># Следующие две строки только если вы хотите иметь возможность загружать установленную у вас Windows.</comment>
<comment># В этом примере Windows установлена на /dev/hda6.</comment>
other=/dev/hda6
  label=windows
</pre>

<note>
Указание <c>udev</c> в конце строки с параметрами ядра необходимо для обхода
ошибок в некоторых версиях genkernel, <e>если</e> вы изначально намереваетесь
использовать udev (по умолчанию предполается использовать).
</note>

<note>
Если схема разделения вашего диска отличается от приведенной в примере 
и/или вы используете другое ядро, внесите необходимые изменения.
</note>

<p>
Если вам необходимо передать ядру дополнительные параметры, 
добавьте в секцию выражение <c>append</c>. В качестве примера 
мы передаем параметр <c>video</c> для включения кадрового буфера:
</p>

<pre caption = "Использование append для передачи ядру параметров">
image=/boot/kernel-2.6.12-gentoo-r10
 label=gentoo
 read-only
 root=/dev/hda3
 <i>append="video=vesafb:mtrr,ywrap,1024x768-32@85"</i>
</pre>

<p>
Если вы используете ядро 2.6.7 или выше и вы при помощи перемычек, аппаратно,
ограничили объем жесткого диска из-за того, что BIOS не в состоянии работать с
дисками большого объема, вы должны добавить <c>hdx=stroke</c>.
</p>

<p>
Те, кто использует <c>genkernel</c>, должны помнить, что их ядро использует те
же параметры, что используются в установочном компакт-диске. Например, если у
вас есть устройства SCSI, вы должны передать ядру параметр <c>doscsi</c>.
</p>


<p>
Пришло время сохранить файл и выйти из редактора. Для окончания 
установки необходимо выполнить <c>/sbin/lilo</c>, чтобы LILO смог 
применить <path>/etc/lilo.conf</path> к вашей системе (например 
установил бы себя на диск) Запомните, что вам необходимо выполнять 
<c>/sbin/lilo</c> каждый раз, когда вы устанавливаете новое ядро или 
вносите изменения в меню, чтобы изменения вступили в силу.
</p>

<pre caption = "Окончание установки LILO">
# <i>/sbin/lilo</i>
</pre>

<note>
Если вы, впоследствии, будете переустанавливать ядро, вам не надо заново
копировать файлы. Просто введите <c>make install</c> после компиляции
ядра, необходимые действия по копированию файлов и правке конфигурации 
LILO будут выполнены автоматически.
</note>

<p>
Теперь вы можете перейти к разделу <uri link="#reboot">Перезагрузка
системы</uri>.
</p>

</body>
</subsection>
</section>
<section id="reboot">
<title>Перезагрузка системы</title>
<subsection>
<body>

<p>
Выйдите из временного окружения и отмонтируйте все разделы. После этого 
введите ту волшебную команду, которую вы так долго ждали: <c>reboot</c>.
</p>

<pre caption="Размонтирование разделов и перезагрузка">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<p>
Естественно не забудьте вынуть загрузочный CD, иначе CD будет загружен 
опять вместо вашей новой установки Gentoo.
</p>

<p>
Перезагрузившись в вашу установленную Gentoo, окончите установку,
руководствуясь разделом <uri link="?part=1&amp;chap=11">Окончание установки
Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 2.11-r1
target-date: 2006-03-08
source-cvs-revision: 1.42
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Sergey Kuleshov [svyatogor@gentoo.org]
-->
