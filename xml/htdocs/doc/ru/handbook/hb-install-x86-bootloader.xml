<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-x86-bootloader.xml,v 1.12 2006/03/30 16:49:11 achumakov Exp $ -->


<sections>

<version>2.11</version>
<date>2006-02-02</date>

<section>
<title>Выбор</title>
<subsection>
<title>Введение</title>
<body>

<p>
Теперь, когда ядро настроено и собрано, нужные конфигурационные файлы заполнены
как надо, пришло время установить программу, которая будет запускать ваше ядро 
при старте системы. Такого рода программа называется <e>загрузчиком</e>. Для 
архитектуры x86 в Gentoo Linux предусмотрены загрузчики <uri 
link="#grub">GRUB</uri> и <uri link="#lilo">LILO</uri>. Но прежде, чем 
приступить к установке одного из двух загрузчиков, мы расскажем, как настроить 
кадровый буфер (естественно, если вы хотите). С помощью кадрового буфера можно
работать в командной строке Linux с использованием элементов графического 
оформления (например, симпатичного изображения из загрузочной заставки Gentoo).
</p>

</body>
</subsection>
<subsection>
<title>Дополнительно: кадровый буфер</title>
<body>

<p>
<e>Если</e> вы настроили в ядре поддержку кадрового буфера (или использовали 
настройки по умолчанию в <c>genkernel</c>), вы можете включить его, добавив
параметр <c>vga</c> и/или <c>video</c> в файл конфигурации своего загрузчика.
</p>

<p>
Для начала, вам надо узнать тип используемого вами кадрового буфера. При 
использовании исходных кодов ядра, измененных для использования в Gentoo 
(таких как <c>gentoo-sources</c>), у вас есть возможность выбрать в качестве 
<c>типа драйвера VESA</c> <c>vesafb-tng</c> (который используется по 
умолчанию в этих исходных кодах ядра). При использовании <c>vesafb-tng</c>
вам не нужно указывать параметр <c>vga</c>. В других случаях используется
драйвер <c>vesafb</c>, а вам нужно указывать параметр <c>vga</c>.
</p>

<p>
Параметр <c>vga</c> устанавливает разрешение и глубину цвета, используемые
кадровым буфером <c>vesafb</c>. Как отмечено в
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path> (который 
устанавливается в составе пакета с деревом исходных кодов ядра), кадровому 
буферу необходимо передават код режима VESA, соответствующий нужному разрешению 
и цветности.
</p>

<p>
В следующей таблице приведены коды режимов для передачи в параметре <c>vga</c>
и соответствующие значения разрешения и цветности.
</p>

<table>
<tr>
  <ti></ti>
  <th>640x480</th>
  <th>800x600</th>
  <th>1024x768</th>
  <th>1280x1024</th>
</tr>
<tr>
  <th>256</th>
  <ti>0x301</ti>
  <ti>0x303</ti>
  <ti>0x305</ti>
  <ti>0x307</ti>
</tr>
<tr>
  <th>32 тыс</th>
  <ti>0x310</ti>
  <ti>0x313</ti>
  <ti>0x316</ti>
  <ti>0x319</ti>
</tr>
<tr>
  <th>64 тыс</th>
  <ti>0x311</ti>
  <ti>0x314</ti>
  <ti>0x317</ti>
  <ti>0x31A</ti>
</tr>
<tr>
  <th>16 млн</th>
  <ti>0x312</ti>
  <ti>0x315</ti>
  <ti>0x318</ti>
  <ti>0x31B</ti>
</tr>
</table>

<p>
Выражение <c>video</c> отвечает за параметры отображения кадрового буфера.
В нем указывается название драйвера кадрового буфера (<c>vesafb</c> для
ядра 2.6 или <c>vesa</c> для ядра 2.4), а затем параметры, которые нужно 
включить. Все переменные приведены в 
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path>, а здесь мы расскажем
о трех самых используемых:
</p>

<table>
<tr>
  <th>Переменная</th>
  <th>Описание</th>
</tr>
<tr>
  <ti>ywrap</ti>
  <ti>
    предполагать, что видеоплата может закольцевать свою память (например,
    продолжить обращение с начала, когда достигнут конец)
  </ti>
</tr>
<tr>
  <ti>mtrr</ti>
  <ti>
    установить регистры MTRR
  </ti>
</tr>
<tr>
  <ti><c>mode</c></ti>
  <ti>
    (только для <c>vesafb-tng</c>)<br/>
    Установить разрешение, цветность и частоту кадров. Например, 
    <c>1024x768-32@85</c> для разрешения 1024x768, 32-битного цвета и частоты 
    кадров 85 Гц. 
  </ti>
</tr>
</table>

<p>
В результате должно получиться что-то вроде <c>vga=0x318
video=vesafb:mtrr,ywrap</c> или <c>video=vesafb:mtrr,ywrap,1024x768-32@85</c>.
Запомните (или запишите) подобранное значение, скоро оно понадобится.
</p>

<p>
Перейдем к установке <uri link="#grub">GRUB</uri> <e>или</e> <uri
link="#lilo">LILO</uri>.
</p>

</body>
</subsection>
</section>
<section id="grub">
<title>По умолчанию: использование GRUB</title>
<subsection>
<title>Введение в терминологию GRUB</title>
<body>

<p>
Самое сложное в освоении GRUB &mdash; освоиться с тем, как в нем именуются 
жесткие диски и разделы. Ваш Linux-раздел <path>/dev/hda1</path>, скорее всего, 
в GRUB станет <path>(hd0,0)</path>. Обратите внимание на круглые скобки вокруг 
<path>hd0,0</path> &mdash; они обязательны.
</p>

<p>
Жесткие диски нумеруются, начиная с нуля, а не с &laquo;а&laquo;, а разделы 
&mdash; c нуля, а не с единицы. Нужно помнить, что как hd нумеруются только 
жесткие диски, но не устройства atapi-ide, такие как приводы компакт-дисков.
Тот же способ нумерации используется для устройств SCSI (обычно им 
присваиваются номера большие, чем устройствам IDE, кроме случаев, когда BIOS 
настроена на загрузку с устройства SCSI). Когда BIOS настроен на загрузку с 
другого жесткого диска (например, с первичного ведомого), <e>этот</e> жесткий 
диск и называется <path>hd0</path>.
</p>

<p>
Например, если у вас есть жесткий диск <path>/dev/hda</path>, привод CD-ROM
<path>/dev/hdb</path>, записывающий CD <path>/dev/hdc</path>, второй жесткий 
диск <path>/dev/hdd</path>, а устройств SCSI нет, то разделу
<path>/dev/hdd7</path> соответствует <path>(hd1,6)</path>. Возможно, это 
кажется запутанным (так и есть), но, как мы увидим, в GRUB есть механизмом 
автодополнения по tab, облегчающий жизнь обладателям множества жестких дисков и
разделов, и тем кто теряется в схеме нумерации устройств GRUB.
</p>

<p>
Почувствовав, что к чему, пора установить GRUB.
</p>

</body>
</subsection>
<subsection>
<title>Установка GRUB</title>
<body>

<p>
Для установки GRUB сначала добавим его в систему:
</p>

<pre caption="Установка GRUB">
# <i>emerge grub</i>
</pre>

<p>
Хотя GRUB уже установлен, нам еще надо подправить его файл конфигурации,
и поместить GRUB в MBR, чтобы он автоматически загружал ваше новое ядро. 
С помощью <c>nano</c> (или другого редактора) создайте 
<path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Создание /boot/grub/grub.conf">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
Теперь заполним <path>grub.conf</path> нашими значениями. Ниже приведены два
варианта <path>grub.conf</path> для приведенного примера разбиения дисков. 
Первый вариант <path>grub.conf</path> мы подробно прокомментировали. 
Удостоверьтесь, что у себя вы указываете имя <e>своего</e> файла с образом 
ядра, и при необходимости имя <e>своего</e> образа начального корневого диска 
(initrd).
</p>

<ul>
  <li>
    первый вариант <path>grub.conf</path> &mdash; для тех, кто для сборки ядра 
    не пользовался <c>genkernel</c>
  </li>
  <li>
    второй вариант <path>grub.conf</path> &mdash; для тех, кто при сборке ядра 
    пользовался <c>genkernel</c>
  </li>
</ul>

<note>
Если ваша корневая файловая система &mdash; JFS, <e>необходимо</e> добавить
&laquo;ro&raquo; в строку <c>kernel</c>, поскольку JFS 
&laquo;накатывает&raquo; свой журнал перед тем, как разрешить монтирование 
раздела на чтение-запись.
</note>

<pre caption = "grub.conf для тех, кто не пользовался genkernel">
<comment># какой пункт загружать по умолчанию: 0 - первый, 1 - второй и т.д.</comment>
default 0
<comment># сколько секунд ждать до начала загрузки пункта по умолчанию</comment>
timeout 30
<comment># симпатичная заставка для приправы блюда :)
# закомментируйте, если у вас не установлена графическая видеоплата</comment>
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
<comment># раздел с файлом образа ядра (или операционной системой)</comment>
root (hd0,0)
kernel /boot/kernel-2.6.12-gentoo-r10 root=/dev/hda3

<comment># следующие четыре строки - только для двойной загрузки с Windows</comment>
<comment># в этом примере Windows находится на /dev/hda6</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<pre caption = "grub.conf для тех, кто пользовался genkernel">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
root (hd0,0)
kernel /boot/kernel-genkernel-x86-2.6.12-gentoo-r10 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev
initrd /boot/initramfs-genkernel-x86-2.6.12-gentoo-r10

<comment># только для двойной загрузки</comment>
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre>

<note>
Параметр <c>udev</c>, указанный в конце строки kernel, необходим для обхода
ошибки в некоторых версиях genkernel, <e>если</e> вы вообще используете udev 
(по умолчанию &mdash; используется). 
</note>

<note>
Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите 
необходимые изменения. При этом убедитесь, что все пути, следующие
за упоминанием устройства GRUB (например <path>(hd0,0)</path>), приведены
относительно точки подключения, а не корня файловой системы. Другими словами,
<path>(hd0,0)/grub/splash.xpm.gz</path> &mdash; на самом деле 
<path>/boot/grub/splash.xpm.gz</path>, так как <path>(hd0,0)</path> &mdash; это
<path>/boot</path>.
</note>

<p>
Кроме того, если вы избрали другую схему разбиения диска, и не размещали 
<path>/boot</path> в отдельном разделе, префикс <path>/boot</path>,  
использованный в примерах выше, <e>обязателен</e>. Если же вы следовали 
рекомендованному нами плану разбиения, префикс <path>/boot</path> 
не требуется, но все работает благодаря символьной ссылке <path>boot</path>.
Короче говоря, приведенные примеры должны работать независимо от того, 
выделили ли вы отдельный раздел <path>/boot</path> или нет.
</p>

<p>
Если вам надо передать ядру дополнительные параметры, просто добавьте их в
конец строки kernel. Один параметр мы уже передаем ядру (<c>root=/dev/hda3</c> 
или <c>real_root=/dev/hda3</c>), но можно добавлять и другие, например,
такие как выражения <c>video</c> и/или <c>vga</c> для кадрового буфера, которые 
обсуждались ранее. 
</p>

<p>
Если вы используете ядро 2.6.7 или выше, и перемычками ограничили объем 
жесткого диска из-за того, что BIOS не в состоянии работать с дисками большого 
объема, вам потребуется добавить <c>hdx=stroke</c>. 
</p>

<p>
Тем, кто использует <c>genkernel</c>, нужно помнить, что их ядро использует 
такие же загрузочные параметры, как на установочном компакт-диске. Например, 
если у вас есть устройства SCSI, следует передать ядру параметр <c>doscsi</c>.
</p>

<p>
Теперь сохраните <path>grub.conf</path> и выйдите из редактора. Вам по-прежнему 
необходимо установить GRUB в MBR (Master Boot Record), чтобы GRUB автоматически 
запускался при загрузке системы.
</p>

<p>
Разработчики GRUB рекомендуют использовать <c>grub-install</c>. Однако, на 
случай некорректной работы <c>grub-install</c> есть возможность установки GRUB 
вручную.
</p>

<p>
Переходите к разделу <uri link="#grub-install-auto">По умолчанию:
установка GRUB, используя grub-install</uri> или <uri
link="#grub-install-manual">Альтернатива: установка GRUB вручную</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-auto">
<title>По умолчанию: установка GRUB с помощью grub-install</title>
<body>

<p>
Для установки GRUB вам надо выполнить команду <c>grub-install</c>. 
Однако, <c>grub-install</c> не заработает сам по себе, т.к. мы находимся в
изолированной среде. Нам нужно создать файл <path>/etc/mtab</path>,
перечислив в нем все смонтированные файловые системы. К счастью, для этого есть 
очень легкий способ: просто скопируйте содержимое <path>/proc/mounts</path> 
поверх <path>/etc/mtab</path>, исключив строку <c>rootfs</c>, если вы не 
создавали отдельный загрузочный раздел. Следующая команда подойдет в обоих 
случаях:
</p>

<pre caption="Создание /etc/mtab">
# <i>grep -v rootfs /proc/mounts &gt; /etc/mtab</i>
</pre>

<p>
Теперь мы можем установить GRUB, используя <c>grub-install</c>:
</p>

<pre caption="Выполнение grub-install">
# <i>grub-install /dev/hda</i>
</pre>

<p>
Если у вас есть вопросы о GRUB, пожалуйста, обратитесь к <uri
link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> или <uri
link="http://www.gnu.org/software/grub/manual/">руководству по GRUB</uri>.
</p>

<p>
Переходите к <uri link="#reboot">перезагрузке системы</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-manual">
<title>Альтернатива: установка GRUB вручную</title>
<body>

<p>
Для начала настройки, введите <c>grub</c>. Вы увидите приглашение 
<path>grub&gt;</path> &mdash; это командная строка grub. Теперь потребуется
ввести команды, нужные для установки загрузочной записи GRUB на ваш жесткий 
диск.
</p>

<pre caption ="Запуск оболочки GRUB">
# <i>grub</i>
</pre>

<note>
Если у вас нет приводов для дискет, к приведенной команде добавьте 
<c>--no-floppy</c>, чтобы grub не опрашивал несуществующие дисководы.
</note>

<p>
В приводимом примере мы хотим установить GRUB так, чтобы он считывал нужную 
информацию с загрузочного раздела <path>/dev/hda1</path>, а загрузочная запись
GRUB находилась в MBR (Master Boot Record) жесткого диска, чтобы первое, что мы 
видели после включения компьютера &mdash; это приглашение GRUB. Естественно, 
если при установке вы не следовали предлагаемой настройке, внесите необходимые 
поправки.
</p>

<p>
Находясь в GRUB, можно использовать автодополнение по клавише TAB. К примеру, 
если ввести &laquo;<c>root (</c>&raquo;, а затем TAB, появится список 
устройств (таких как <path>hd0</path>). Если ввести &laquo;<c>root 
(hd0,</c>&laquo; и нажать TAB, появится список для выбора раздела из доступных 
(такого как <path>hd0,0</path>).
</p>

<p>
При использовании автодополнения установка GRUB не так сложна.
Теперь приступим к настройке GRUB.
</p>

<pre caption ="Установка GRUB в MBR">
grub&gt; <i>root (hd0,0)</i>          <comment>(указание расположения раздела с /boot)</comment>
grub&gt; <i>setup (hd0)</i>           <comment>(установка GRUB в MBR)</comment>
grub&gt; <i>quit</i>                  <comment>(выход из оболочки GRUB)</comment>
</pre>

<note>
Если вы хотите установить GRUB в определенный раздел вместо MBR, команду 
<c>setup</c> потребуется изменить так, чтобы она указывала на нужный раздел. 
Например, команда для установки GRUB в <path>/dev/hda3</path> &mdash; <c>setup 
(hd0,2)</c>. Однако, так поступают немногие.
</note>

<p>
С дополнительными вопросами о GRUB, пожалуйста, обращайтесь к <uri
link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> или <uri
link="http://www.gnu.org/software/grub/manual/">руководству по GRUB</uri>.
</p>

<note>
При переустановке ядра вам больше не потребуется копировать содержимое файлов. 
Просто запустите <c>make install</c> после компиляции ядра; копирование файлов 
и изменение конфигурации GRUB выполнится автоматически.
</note>

<p>
Переходите к <uri link="#reboot">перезагрузке системы</uri>.
</p>

</body>
</subsection>
</section>
<section id="lilo">
<title>Альтернатива: использование LILO</title>
<subsection>
<title>Установка LILO</title>
<body>

<p>
LILO (сокращение от LInux LOader) &mdash; это испытанная временем рабочая 
лошадка среди загрузчиков Linux-систем. Но ей недостает ряда возможностей,  
которые есть в GRUB (и в этом также причина растущей популярности GRUB). 
LILO все еще используется потому, что на некоторых системах он работает, а GRUB 
&mdash; нет. Конечно же, он используется еще и потому, что многие знакомы с 
LILO и сроднились с ним. Так или иначе, в Gentoo поддерживаются оба загрузчика,
и вы, видимо, решили использовать LILO.
</p>

<p>
Установка LILO в систему легка как ветер: просто используйте <c>emerge</c>.
</p>

<pre caption = "Установка LILO">
# <i>emerge lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>Настройка LILO</title>
<body>

<p>
Для настройки LILO нужно создать файл <path>/etc/lilo.conf</path>. Запустите 
свой любимый редактор (в руководстве мы для единообразия используем 
<c>nano</c>) и создайте файл. 
</p>

<pre caption = "Создание /etc/lilo.conf">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
Несколькими разделами раньше мы попросили вас запомнить название созданного 
файла с образом ядра. В следующем примере используется предложенная нами схема 
разделения диска. Пример разделен на две части: 
</p>

<ul>
  <li>
    одна &mdash; для тех, кто не пользовался для сборки ядра <c>genkernel</c>
  </li>
  <li>
    другая &mdash; для тех, кто при сборке ядра пользовался <c>genkernel</c>
  </li>
</ul>

<p>
Удостоверьтесь, что у себя вы указываете имя <e>своего</e> файла с образом 
ядра, и при необходимости имя <e>своего</e> образа начального корневого диска 
(initrd).
</p>

<note>
Если ваша корневая файловая система &mdash; JFS, <e>необходимо</e> добавить
&laquo;ro&raquo; в строку <c>kernel</c>, поскольку JFS 
&laquo;накатывает&raquo; свой журнал перед тем, как разрешить монтирование 
раздела на чтение-запись.
</note>

<pre caption = "Пример /etc/lilo.conf">
boot=/dev/hda         <comment># установка LILO в MBR</comment>
prompt                <comment># предоставление шанса выбора другого варианта</comment>
timeout=50            <comment># ожидание пять секунд до загрузки варианта по умолчанию</comment>
default=gentoo        <comment># по истечении времени загрузка варианта gentoo</comment>

<comment># для тех, кто не использует genkernel</comment>
image=/boot/kernel-2.6.12-gentoo-r10
  label=gentoo        <comment># название этого варианта</comment>
  read-only           <comment># запуск с корневой ФС только для чтения; не менять!</comment>
  root=/dev/hda3      <comment># расположение корневой файловой системы</comment>

<comment># для тех, кто использует genkernel</comment>
image=/boot/kernel-genkernel-x86-2.6.12-gentoo-r10
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"
  initrd=/boot/initramfs-genkernel-2.6.12-gentoo-r10

<comment># следующие две строки нужны только для двойной загрузки с Windows</comment>
<comment># в этом примере Windows находится на /dev/hda6</comment>
other=/dev/hda6
  label=windows
</pre>

<note>
Параметр <c>udev</c>, указанный в конце строки kernel, необходим для обхода
ошибки в некоторых версиях genkernel, <e>если</e> вы вообще используете udev 
(по умолчанию &mdash; используется). 
</note>

<note>
Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите 
необходимые изменения.
</note>

<p>
Если нужно передать ядру дополнительные параметры, добавьте в нужный раздел 
файла выражение <c>append</c>. Например, добавим выражение <c>video</c> для 
включения кадрового буфера: 
</p>

<pre caption = "Использование append для добавления параметров ядра">
image=/boot/kernel-2.6.12-gentoo-r10
  label=gentoo
  read-only
  root=/dev/hda3
  <i>append="video=vesafb:mtrr,ywrap,1024x768-32@85"</i>
</pre>

<p>
Если вы используете ядро 2.6.7 или выше, и перемычками ограничили объем 
жесткого диска из-за того, что BIOS не в состоянии работать с дисками большого 
объема, вам потребуется добавить <c>hdx=stroke</c>. 
</p>

<p>
Тем, кто использует <c>genkernel</c>, нужно помнить, что их ядро использует 
такие же загрузочные параметры, как на установочном компакт-диске. Например, 
если у вас есть устройства SCSI, следует передать ядру параметр 
<c>doscsi</c>.
</p>

<p>
Теперь сохраните файл и выйдите из редактора. Для окончания установки 
нужно запустить <c>/sbin/lilo</c>, чтобы LILO смог отразить 
<path>/etc/lilo.conf</path> в вашей системе (т.е. установился на диск). 
Имейте в виду, что вам потребуется выполнять <c>/sbin/lilo</c> заново 
при каждой установке нового ядра или изменении меню.
</p>

<pre caption = "Завершение установки LILO">
# <i>/sbin/lilo</i>
</pre>

<note>
При переустановке ядра вам больше не потребуется копировать содержимое файлов. 
Просто запустите <c>make install</c> после компиляции ядра; копирование файлов 
и изменение конфигурации LILO выполнится автоматически.
</note>

<p>
Переходите к <uri link="#reboot">перезагрузке системы</uri>.
</p>

</body>
</subsection>
</section>
<section id="reboot">
<title>Перезагрузка системы</title>
<subsection>
<body>

<p>
Выйдите из изолированной среды и размонтируйте все смонтированные разделы. 
Затем введите ту волшебную команду, которую вы так заждались: <c>reboot</c>.
</p>

<pre caption="Размонтирование всех разделов и перезагрузка">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<p>
Естественно, не забудьте вынуть загрузочный компакт-диск, иначе он загрузится
вместо вашей новой системы Gentoo.
</p>

<p>
Загрузив установленную Gentoo, переходите к <uri 
link="?part=1&amp;chap=11">завершению установки Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 2.11-r2
target-date: 2006-03-27
source-cvs-revision: 1.42
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Sergey Kuleshov; Alexey Chumakov [achumakov@gentoo.org]
-->
