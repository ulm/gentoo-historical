<?xml version='1.0' encoding='UTF-8'?>
<!-- *$Localization:
target-language: Russian
target-version: 1.21-r2
target-date: 2005-06-08
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by:  none
proof-by: Sergey Kuleshov <svyatogor@gentoo.org>
links_checked_by: none
tested_by: none

note:
-->
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/1.0 -->
<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/hb-working-rcscripts.xml,v 1.2 2005/07/09 13:31:10 sergey Exp $ -->
<!-- REV: 1.24 -->
<sections>

<version>1.21</version>
<date>2005-05-29</date>

<section>
<title>Уровни запуска</title>
<subsection>
<title>Загрузка вашей системы</title>
<body>

<p>
В процессе загрузки вашей системы по экрану пробегает большое количество
текстовой информации. Если вы обратите внимание, то заметите, что этот текст
один и тот же каждый раз при каждой загрузке. Последовательность всех событий
называется <e>последовательностью загрузки</e> и в той или иной степени
статично определена.
</p>

<p>
Во-первых, загрузчик размещает в памяти образ ядра, который вы указали в
файле его конфигурации. После этого ядро запускается. После того, как ядро
загружено и запущено, оно в свою очередь запускает структуры и задания
специфичные для ядра и запускает процесс <c>init</c>.
</p>

<p>
Этот процесс проверяет, что все файловые системы (определенные в
<path>/etc/fstab</path>) смонтированы и готовы к использованию. После этого
будут выполнены несколько сценариев, размещенных в каталоге
<path>/etc/init.d</path>, которые запускают службы необходимые для нормальной
загрузки системы.
</p>

<p>
И, наконец, когда все сценарии выполнены, <c>init</c> активизирует терминалы
(чаще всего виртуальные консоли, которые видны при нажатии <c>ALT+F1</c>,
<c>ALT+F2</c> и т.д.) прикрепляя к каждой консоли специальный процесс, который
называется <c>agetty</c>. Этот процесс, выполняя <c>login</c>, помогает вам
зарегистрироваться в системе.
</p>

</body>
</subsection>
<subsection>
<title>Сценарии инициализации</title>
<body>

<p>
Сейчас процесс <c>init</c> не запускает сценарии из каталога
<path>/etc/init.d</path> в случайном порядке. Более того, не запускаются все
сценарии из <path>/etc/init.d</path>, а только те, которые ему предписаны.
Решение о запуске сценария принимается после просмотра каталога
<path>/etc/runlevels</path>.
</p>

<p>
Сначала, <c>init</c> запускает все сценарии из <path>/etc/init.d</path>,
на которые есть символьные ссылки в <path>/etc/runlevels/boot</path>. Обычно
запуск происходит в алфавитном порядке, но некоторые сценарии имеют информацию
о зависимостях от других сценариев, которые должны быть запущенны
предварительно.
</p>

<p>
Когда все сценарии, относящиеся к <path>/etc/runlevels/boot</path> будут
выполнены, <c>init</c> продолжает запуск сценариев, ссылки на которые
находятся в <path>/etc/runlevels/default</path>. И снова запуск происходит в
алфавитном порядке, пока не встретится информация о зависимостях и,
следовательно, порядок не изменится для обеспечения правильного запуска.
</p>

</body>
</subsection>
<subsection>
<title>Как работает Init</title>
<body>

<p>
Конечно, <c>init</c> не принимает решений сам по себе. Ему необходим
конфигурационный файл, описывающий что необходимо сделать. Этот файл называется
<path>/etc/inittab</path>.
</p>

<p>
Если вы помните последовательность загрузки, описанную чуть ранее, то первое,
что делает процесс <c>init</c> - это монтирование файловых систем. Это
описывается в <path>/etc/inittab</path> строкой, приведенной ниже:
</p>

<pre caption="Строка инициализации системы из /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Этой строкой предписывается процессу <c>init</c> выполнить <c>/sbin/rc
sysinit</c> для инициализации системы. Непосредственно инициализация системы
происходит посредством сценария <path>/sbin/rc</path>, так, что вы можете
сказать, что <c>init</c> не делает слишком много работы - он просто
запускает другие процессы, которые выполняют всю работу.
</p>

<p>
Далее <c>init</c> выполняет все сценарии, имеющие символические ссылки в
<path>/etc/runlevels/boot</path>. Это определяется следующей строкой:
</p>

<pre caption="Инициализация системы, продолжение">
rc::bootwait:/sbin/rc boot
</pre>

<p>
И, снова, скрипт <c>rc</c> выполняет все необходимые действия. Заметьте, что
параметр, переданный <c>rc</c> (<e>boot</e>) такой же, как название
используемого подкаталога в <path>/etc/runlevels</path>.
</p>

<p>
Теперь пришло время проверить конфигурационный файл, чтобы определить, какой
<e>уровень запуска</e> использовать. Для этого <c>init</c> читает строку из
<path>/etc/inittab</path>:
</p>

<pre caption="Уровень запуска по умолчанию">
id:3:initdefault:
</pre>

<p>
В приведенном примере (который подходит для подавляющего большинства
пользователей Gentoo) используется <e>уровень запуска</e> номер 3. Опираясь на
эту информацию, <c>init</c> проверяет, что он должен запустить для <e>уровня
запуска номер 3</e>:
</p>

<pre caption="Определение уровней запуска">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
Строка, определяющая уровень 3, предписывает использовать сценарий <c>rc</c>
для запуска необходимых служб (на сей раз с аргументом <e>default</e>).
Опять-таки обратите внимание, что аргумент, передаваемый сценарию <c>rc</c>
такой же, как название подкаталога из <path>/etc/runlevels</path>.
</p>

<p>
После окончания работы <c>rc</c>, <c>init</c> принимает решение о том, какие
виртуальные консоли включить и какие команды выполнить на каждой из них:
</p>

<pre caption="Определение виртуальных консолей">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>


</body>
</subsection>
<subsection>
<title>Что такое уровень запуска?</title>
<body>

<p>
Как вы заметили <c>init</c> использует нумерацию для определения <e>уровня
запуска</e>, который надо использовать. <e>Уровень запуска</e> - это то
состояние, в котором запускается ваша система, он содержит набор
сценариев (<e>сценариев уровня запуска [initscript]</e>), которые должны быть
выполнены, когда вы  переключаетесь на какой-то уровень или покидаете его.
</p>

<p>
В Gentoo определено семь уровней запуска: три из них служебные и четыре
определяемые пользователем. Служебные называются <e>sysinit</e>,
<e>shutdown</e> и <e>reboot</e>. Действия, совершаемые ими в точности
соответствуют их названиям: инициализация системы, выключение системы и ее
перезагрузка.
</p>

<p>
Определяемые пользователем уровни - это те, которым соответствуют
подкаталоги в <path>/etc/runlevels</path>: <path>boot</path>,
<path>default</path>, <path>nonetwork</path> и <path>single</path>. Уровень под
названием <path>boot</path> запускает службы, необходимые системе и
используемые всеми остальными уровнями. Остальные уровни отличаются друг от
друга запускаемыми службами: <path>default</path> используется для повседневной
работы, <path>nonetwork</path> - для тех случаев, когда не требуется
никаких сетевых соединений и <path>single</path> для случаев восстановления
системы.
</p>

</body>
</subsection>
<subsection>
<title>Работа со сценариями инициализации</title>
<body>

<p>
Сценарии, которые запускает процесс <c>rc</c> называются <e>инициализационными
сценариями</e>. Каждый сценарий из <path>/etc/init.d</path> может быть выполнен
с аргументами <e>start</e>, <e>stop</e>, <e>restart</e>, <e>pause</e>,
<e>zap</e>, <e>status</e>, <e>ineed</e>, <e>iuse</e>, <e>needsme</e>,
<e>usesme</e> и <e>broken</e>.
</p>

<p>
Для запуска, остановки или перезапуска службы (и других, зависящих от нее)
используются <c>start</c>, <c>stop</c> и <c>restart</c>:
</p>

<pre caption="Запуск Postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Только те службы которым <e>необходима</e> эта служба будут остановлены или
перезапущенны. Все остальные, зависимые службы (те, которые <e>используют</e>
но не нуждаются), эта операция не затронет.
</note>

<p>
Если вы хотите остановить службу, но зависимые от нее оставить работающими, вы
можете использовать аргумент <c>pause</c>:
</p>

<pre caption="Остановка только Postfix без зависимых служб">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Если вы хотите узнать статус службы с данный момент (запущена, остановлена,
приостановлена, ...) вы можете использовать аргумент <c>status</c>:
</p>

<pre caption="Информация о статусе postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Если, судя по выданной информации, служба работает, но вы точно знаете, что это
не так, вы можете изменить статус на &quot;stopped&quot; (остановлена),
используя аргумент <c>zap</c>:
</p>

<pre caption="Сброс информации о статусе postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Для того, чтобы узнать зависимости службы, вы можете использовать аргументы
<c>iuse</c> или <c>ineed</c>. При аргументе <c>ineed</c> вы увидите те службы,
которые действительно необходимы для правильного функционирования интересующей
нас службы. С другой стороны <c>iuse</c> выдаст информацию о тех службах,
которые могут быть использованы нашей службой, но они не жизненно необходимы.
</p>

<pre caption="Информация о всех необходимых службах для Postfix">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
Аналогично вы можете получить информацию о службах, которым необходима эта
служба (<c>needsme</c>) или может быть использована (<c>usesme</c>):
</p>

<pre caption="Информация о службах, которым необходим Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Наконец, вы можете посмотреть список требуемых служб, но которые отсутствуют в
системе:
</p>

<pre caption="Список служб необходимых Postfix, но отсутствующих в системе">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Использование rc-update</title>
<subsection>
<title>Что такое rc-update?</title>
<body>

<p>
Система инициализации Gentoo использует дерево зависимостей для определения
служб, которые запускаются в первую очередь. Т.к. это очень утомительное
занятие и мы не хотели, чтобы пользователь занимался этим вручную, мы
разработали инструменты, упрощающие администрирование уровней запуска и
сценариев инициализации.
</p>

<p>
Используя <c>rc-update</c>, вы можете добавлять и удалять сценарии
инициализации к уровням запуска. Из <c>rc-update</c> автоматически запускается
сценарий <c>depscan.sh</c> для перестроения дерева зависимостей.
</p>

</body>
</subsection>
<subsection>
<title>Добавление и удаление служб</title>
<body>

<p>
Вы уже добавляли инициализационные сценарии в уровень запуска
&quot;default&quot; в процессе установки Gentoo. В тот момент вы, возможно, не
имели понятия, что такое &quot;default&quot; и зачем это надо, но теперь вы все
это знаете. Сценарию <c>rc-update</c> требуется второй аргумент, который
определяет действие: <e>add</e> (добавить), <e>del</e> (удалить) или
<e>show</e> (показать).
</p>

<p>
Для того, чтобы добавить или удалить сценарий, просто введите <c>rc-update</c>
с аргументом <c>add</c> или <c>del</c>, последующим названием сценария и
названием уровня запуска. Для примера:
</p>

<pre caption="Удаление Postfix из уровня загрузки default">
# <i>rc-update del postfix default</i>
</pre>

<p>
По команде <c>rc-update show</c> будет выведен список, содержащий все доступные
сценарии и соответствующие им уровни запуска:
</p>

<pre caption="Получение информации о сценариях">
# <i>rc-update show</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Настройка служб</title>
<subsection>
<title>Почему нужна дополнительная настройка?</title>
<body>

<p>
Сценарии инициализации могут быть весьма сложны. Поэтому не желательно
редактирование непосредственно самого сценария пользователями, т.к. это может
привнести в систему множество ошибок. Но с другой стороны необходимо правильно
настроить службу. Например, вы захотите сообщить дополнительные параметры этой
службе.
</p>

<p>
Вторая причина, по которой настройки хранятся отдельно от самого сценария
- это возможность обновления сценария не боясь, что все ваши настройки
будут утеряны.
</p>

</body>
</subsection>
<subsection>
<title>Каталог /etc/conf.d</title>
<body>

<p>
Gentoo предоставляет очень простой способ конфигурирования служб: для каждого
сценария, который может быть настроен, в каталоге <path>/etc/conf.d</path>
располагается файл настроек. Например, сценарий, запускающий apache2
(называется <path>/etc/init.d/apache2</path>), берет свои настройки из файла
под названием <path>/etc/conf.d/apache2</path>, в котором вы располагаете
параметры, передаваемые Apache 2 при запуске:
</p>

<pre caption="Переменная, определенная в /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP4"
</pre>

<p>
Такие файлы настроек содержат переменные и дополнительные параметры (наподобие
<path>/etc/make.conf</path>), которые облегчают процесс настройки службы. Это
также позваляет нам предоставлять больше информации о переменных (в
комментариях).
</p>

</body>
</subsection>
</section>
<section>
<title>Написание сценариев инициализации</title>
<subsection>
<title>Я тоже должен?</title>
<body>

<p>
Нет, написание сценариев инициализации обычно не требуется, т.к. Gentoo
содержит готовые сценарии для всех поддерживаемых служб. Однако, вы можете
установить какую-либо службу не используя систему Portage, в таком случае,
вероятно, вам придется создавать сценарий инициализации самостоятельно.
</p>

<p>
Не используйте сценарии, предоставляемые службой, если только они не написаны с
учетом использования в Gentoo: сценарии инициализации, используемые в Gentoo не
совместимы с аналогичными сценариями из других дистрибутивов!
</p>

</body>
</subsection>
<subsection>
<title>Разметка</title>
<body>

<p>
Основная разметка сценария инициализации показана ниже.
</p>

<pre caption="Основная разметка сценария">
#!/sbin/runscript

depend() {
  <comment>(Информация о зависимостях)</comment>
}

start() {
  <comment>(Команды, необходимые для запуска службы)</comment>
}

stop() {
  <comment>(Команды, необходимые для остановки службы)</comment>
}

restart() {
  <comment>(Команды, необходимые для перезапуска службы)</comment>
}
</pre>

<p>
В любом сценарии <e>обязана</e> быть заполненной функция <c>start()</c>. Все
остальные секции не обязательны.
</p>

</body>
</subsection>
<subsection>
<title>Зависимости</title>
<body>

<p>
Существует два типа зависимостей, которые вы можете определить: <c>use</c>
(использую) и <c>need</c> (необходимо). Как обсуждалось ранее,
<c>need</c>-зависимость более строгая, чем <c>use</c>-зависимость. После типа 
зависимости приводится название службы, от которой существует зависимость, или
указание на <e>виртуальную</e> (virtual) зависимость.
</p>

<p>
<e>Виртуальная</e> зависимость - это то, что предоставляет сервис, но без
привязки конкретно к этой программе. Ваш инициализационный сценарий может быть
зависим от средств ведения системного журнала, но таких средств достаточно
много (metalogd, syslog-ng, sysklogd, ...). Вы не можете использовать
<c>need</c>-зависимость для каждого из них (не существует ни одной системы, в
которой установлены и запущенны все эти программы), поэтому все эти средства
<e>предоставляют</e> виртуальные зависимости.
</p>

<p>
Давайте взглянем на информацию о зависимостях для postfix.
</p>

<pre caption="Информация о зависимостях Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Как вы можете видеть, postfix:
</p>

<ul>
  <li>
    требует (виртуальная зависимость) <c>net</c> (например, может быть
    предоставлена <path>/etc/init.d/net.eth0</path>)
  </li>
  <li>
    использует (виртуальная зависимость) <c>logger</c> (например, может быть
    предоставлена <path>/etc/init.d/syslog-ng</path>)
  </li>
  <li>
    использует (виртуальная зависимость) <c>dns</c> (например, может быть
    предоставлена <path>/etc/init.d/named</path>)
  </li>
  <li>
    предоставляет (виртуальная зависимость) <c>mta</c> (общая зависимость для
    всех программ почтовых серверов)
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Упорядочивание</title>
<body>

<p>
В некоторых случаях вы хотите, чтобы служба запускалась <c>до</c> (или
<e>после</e>) другой службы <e>если</e> она присутствует на этой системе
(обратите внимание на условие - это не зависимости) <e>и</e> принадлежит
к тому же уровню запуска (обратите внимание на условие - это возможно
только для служб из одного уровня запуска). Вы можете указать на очередность
запуска, используя значения <c>before</c> (до) или <c>after</c> (после).
</p>

<p>
В качестве примера рассмотрим установки для сервиса Portmap:
</p>

<pre caption="Функция depend() службы Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Также вы можете использовать маску &quot;*&quot; для того, чтобы отметить все
службы на данном уровне запуска, но это не рекомендуется.
</p>

<pre caption="Запуск сценария первым на уровне запуска">
depend() {
  before *
}
</pre>

</body>
</subsection>
<subsection>
<title>Стандартные функции</title>
<body>

<p>
Следом за секцией <c>depend()</c> вам необходимо определить секцию
<c>start()</c>. Этот раздел содержит команды, необходимые для запуска вашей
службы. Рекомендуется применять функции <c>ebegin</c> и <c>eend</c> для
информирования пользователя о том, что происходит:
</p>

<pre caption="Пример функции start()">
start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}
</pre>

<p>
Если вам необходимы еще примеры функции <c>start()</c>, пожалуйста прочитайте
исходные коды доступных в каталоге <path>/etc/init.d</path> инициализационных
сценариев. Что касается команды <c>start-stop-daemon</c>, то существует
превосходная справочная страница, если вам необходимо получить больше
информации:
</p>

<pre caption="Вызов справочной страницы по start-stop-daemon">
# <i>man start-stop-daemon</i>
</pre>

<p>
Другими функциями, которые вы можете определить, являются: <c>stop()</c> и
<c>restart()</c>. Вы не обязаны определять эти функции! Система инициализации,
применяемая нами, достаточно развита и в состоянии самостоятельно заполнить эти
функции, если вы используете <c>start-stop-daemon</c>.
</p>

<p>
Синтаксис инициализационных сценариев, применяемых в Gentoo, основан на
оболочке Борна (Bourne Again Shell - bash), поэтому вы свободно можете
использовать bash-совместимые конструкции внутри ваших сценариев.
</p>

</body>
</subsection>
<subsection>
<title>Использование дополнительных функций</title>
<body>

<p>
Если вы хотите использовать в своем инициализационном сценарии дополнительные
функции, нежели те, с которыми мы уже встречались, вам необходимо добавить к
переменной <c>opts</c> название необходимой функции и создать тело этой
функции. К примеру, чтобы создать дополнительную функцию по названием
<c>restartdelay</c>, необходимо:
</p>

<pre caption="Создание дополнительной функции restartdelay">
opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <comment># Пауза в 3 секунды перед повторным запуском</comment>
  start
}
</pre>

</body>
</subsection>
<subsection>
<title>Переменные для настройки службы</title>
<body>

<p>
Вам не нужно ничего делать дополнительно для поддержки настроечного файла в
каталоге <path>/etc/conf.d</path>: когда ваш инициализационный сценарий
запускается, то автоматически происходит включение следующих файлов (например
для поиска доступных переменных):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;ваш инициализационный сценарий&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Если ваш инициализационный сценарий предоставляет виртуальную зависимость
(такую, как <c>net</c>), то файл, ассоциированный с этой зависимостью (такой,
как <path>/etc/conf.d/net</path>), будет также включен.
</p>

</body>
</subsection>
</section>
<section>
<title>Изменение поведения уровней запуска</title>
<subsection>
<title>Кому это может потребоваться?</title>
<body>

<p>
Большинству пользователей ноутбуков знакома ситуация: дома вам нужен запуск
<c>net.eth0</c> и наоборот в дороге запуск <c>net.eth0</c> не нужен (так как
сеть недоступна). Используя Gentoo вы можете изменить поведение уровня запуска
по своему усмотрению.
</p>

<p>
Например вы можете создать второй уровень запуска &quot;по умолчанию&quot;.
После этого вы можете выбирать в процессе загрузки какой из уровней по
умолчанию хотите использовать.
</p>

</body>
</subsection>
<subsection>
<title>Использование программного уровня (softlevel)</title>
<body>

<p>
Для начала, создайте каталог уровня запуска для вашего второго уровня &quot;по
умолчанию&quot;. В примере мы создадим уровень запуска <path>offline</path>:
</p>

<pre caption="Создание каталога уровня запуска">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Добавьте необходимые инициализационные сценарии к вновь созданному уровню
запуска. Например, если вы хотите получить копию уровня <c>default</c>, но без
<c>net.eth0</c>:
</p>

<pre caption="Добавление необходимых инициализационных сценариев">
<comment>(Скопируйте все сценарии с уровня &quot;default&quot; в уровень &quot;offline&quot;)</comment>
# <i>cd /etc/runlevels/default</i>
# <i>for service in *; do rc-update add $service offline; done</i>
<comment>(Удалите ненужные сценарии с уровня &quot;offline&quot;)</comment>
# <i>rc-update del net.eth0 offline</i>
<comment>(Просмотрите запускаемые сценарии на уровне &quot;offline&quot;)</comment>
# <i>rc-update show offline</i>
<comment>(Часть примерного списка)</comment>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre>

<p>
Теперь необходимо отредактировать конфигурацию загрузчика и добавить запись об
уровне &quot;offline&quot;. К примеру, в файле <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Добавление записи об уровне offline">
title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Вуаля, все готово. Теперь, если во время загрузки вы выберите вновь созданную
запись, то будет использоваться уровень <c>offline</c>, вместо <c>default</c>.
</p>

</body>
</subsection>
<subsection>
<title>Использование загрузочного уровня (bootlevel)</title>
<body>

<p>
Использование <c>загрузочного уровня</c> полностью аналогично использованию
<c>программного уровня</c>. Единственная разница состоит в том, что вы
определяете второй уровень &quot;boot&quot; вместо &quot;default&quot;.
</p>

</body>
</subsection>
</section>
</sections>
