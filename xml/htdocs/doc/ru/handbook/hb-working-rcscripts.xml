<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/hb-working-rcscripts.xml,v 1.7 2006/03/31 07:41:50 achumakov Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>

<version>1.21</version>
<date>2005-05-29</date>

<section>
<title>Уровни запуска</title>
<subsection>
<title>Процесс загрузки системы</title>
<body>

<p>
При загрузке вашей системы по экрану пробегает много текста. Если
присмотреться, заметно, что этот текст не меняется от загрузки к загрузке.
Последовательность всех этих действий называется <e>последовательностью
загрузки</e> и в той или иной степени постоянна.
</p>

<p>
Во-первых, загрузчик размещает в памяти образ ядра, который вы указали в
файле его конфигурации. После этого ядро запускается. Когда ядро загружено и
запущено, оно инициализирует относящиеся к ядру структуры и задания, и
запускает процесс <c>init</c>.
</p>

<p>
Этот процесс удостоверяется, что все файловые системы (определенные в
<path>/etc/fstab</path>) смонтированы и готовы к использованию. Затем он 
выполняет несколько сценариев, находящихся в каталоге <path>/etc/init.d</path>,
которые запускают службы, необходимые для нормального запуска системы.
</p>

<p>
И, наконец, когда все сценарии выполнены, <c>init</c> подключает терминалы
(чаще всего просто виртуальные консоли, которые видны при нажатии
<c>ALT+F1</c>, <c>ALT+F2</c> и т.д.), прикрепляя к каждой консоли специальный
процесс под названием <c>agetty</c>. Этот процесс впоследствии обеспечивает
возможность входа в систему с помощью <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Сценарии инициализации</title>
<body>

<p>
Сейчас процесс <c>init</c> запускает сценарии из каталога
<path>/etc/init.d</path> не просто в случайном порядке. Более того, запускаются
не все сценарии из <path>/etc/init.d</path>, а только те, которые предписано
исполнять. Решение о запуске сценария принимается в результате просмотра
каталога <path>/etc/runlevels</path>.
</p>

<p>
Во-первых, <c>init</c> запускает все сценарии из <path>/etc/init.d</path>, на
которые есть символьные ссылки из <path>/etc/runlevels/boot</path>. Обычно
сценарии запускаются в алфавитном порядке, но в некоторых сценариях имеется
информация о зависимостях от других сценариев, указывающая системе на
необходимость их предварительного запуска.
</p>

<p>
Когда все сценарии, указанные в <path>/etc/runlevels/boot</path>, будут
выполнены, <c>init</c> переходит к запуску сценариев, на которые есть
символьные ссылки из <path>/etc/runlevels/default</path>. И снова запуск
происходит в алфавитном порядке, пока в сценарии не встретится информация о
зависимостях; тогда порядок изменяется для обеспечения правильного порядка
запуска.
</p>

</body>
</subsection>
<subsection>
<title>Как работает init</title>
<body>

<p>
Конечно, <c>init</c> не принимает решений сам по себе. Ему необходим
конфигурационный файл, где описаны необходимые действия. Этот файл &mdash;
<path>/etc/inittab</path>.
</p>

<p>
Если вы запомнили последовательность загрузки, описанную чуть ранее, вы
вспомните, что первое действие <c>init</c> &mdash; это монтирование всех файловых
систем. Это определяется в строке <path>/etc/inittab</path>, приведенной ниже:
</p>

<pre caption="Строка инициализации системы из /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Этой строкой процессу <c>init</c> предписывается выполнить <c>/sbin/rc
sysinit</c> для инициализации системы. Самой инициализацией занимается
сценарий <path>/sbin/rc</path>, так что можно сказать, что <c>init</c> делает
не слишком много &mdash; он просто делегирует задачу по инициализации системы
другому процессу.
</p>

<p>
Во-вторых, <c>init</c> выполняет все сценарии, на которые есть символьные
ссылки из <path>/etc/runlevels/boot</path>. Это определяется следующей строкой:
</p>

<pre caption="Инициализация системы, продолжение">
rc::bootwait:/sbin/rc boot
</pre>

<p>
И снова все необходимые действия выполняются сценарием <c>rc</c>. Заметьте, что
параметр, переданный <c>rc</c> (<e>boot</e>), совпадает с названием
используемого подкаталога в <path>/etc/runlevels</path>.
</p>

<p>
Теперь <c>init</c> проверяет свой конфигурационный файл, чтобы определить,
какой <e>уровень запуска</e> использовать. Для этого из
<path>/etc/inittab</path> считывается строка:
</p>

<pre caption="Строка initdefault">
id:3:initdefault:
</pre>

<p>
В приведенном примере (который подходит для подавляющего большинства
пользователей Gentoo) номер <e>уровня запуска</e> &mdash; 3. Пользуясь этой
информацей, <c>init</c> проверяет, что нужно выполнить для запуска <e>уровня
запуска 3</e>:
</p>

<pre caption="Определение уровней запуска">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
В строке, определяющей уровень 3, для запуска служб снова используется сценарий
<c>rc</c> (на этот раз с аргументом <e>default</e>). Опять-таки, обратите
внимание, что аргумент, передаваемый сценарию <c>rc</c>, совпадает с названием
подкаталога из <path>/etc/runlevels</path>.
</p>

<p>
По окончании работы <c>rc</c>, <c>init</c> принимает решение о том, какие
виртуальные консоли включить и какие команды выполнить в каждой из них:
</p>

<pre caption="Определение виртуальных консолей">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>


</body>
</subsection>
<subsection>
<title>Что такое уровень запуска?</title>
<body>

<p>
Как вы заметили, <c>init</c> применяет нумерацию для определения <e>уровня
запуска</e>, который надо использовать. <e>Уровень запуска</e> &mdash; это то
состояние, в котором запускается ваша система, он содержит набор
сценариев (сценариев уровня запуска или <e>сценариев инициализации 
[initscript]</e>), которые следует выполнять, при входе и выходе из 
определенного уровня запуска. 
</p>

<p>
В Gentoo определено семь уровней запуска: три служебных и четыре
определяемых пользователем. Служебные называются <e>sysinit</e>,
<e>shutdown</e> и <e>reboot</e>. Действия, совершаемые ими, в точности
соответствуют их названиям: инициализация системы, выключение системы и ее
перезагрузка.
</p>

<p>
Определяемые пользователем уровни &mdash; это те, которым соответствуют
подкаталоги в <path>/etc/runlevels</path>: <path>boot</path>,
<path>default</path>, <path>nonetwork</path> и <path>single</path>. Уровень 
<path>boot</path> запускает все службы, необходимые системе и используемые 
всеми остальными уровнями. Остальные уровни отличаются друг от друга 
запускаемыми службами: <path>default</path> используется для повседневной 
работы, <path>nonetwork</path> &mdash; для тех случаев, когда не требуется
сеть, а <path>single</path> &mdash; при необходимости восстановления системы.
</p>

</body>
</subsection>
<subsection>
<title>Работа со сценариями инициализации</title>
<body>

<p>
Сценарии, запускаемые процессом <c>rc</c>, называются <e>сценариями
инициализации</e>. Каждый сценарий из <path>/etc/init.d</path> может
запускаться с аргументами <e>start</e>, <e>stop</e>, <e>restart</e>, 
<e>pause</e>, <e>zap</e>, <e>status</e>, <e>ineed</e>, <e>iuse</e>, 
<e>needsme</e>, <e>usesme</e> и <e>broken</e>.
</p>

<p>
Для запуска, остановки или перезапуска службы (и всех, зависящих от нее)
следует использовать <c>start</c>, <c>stop</c> и <c>restart</c>:
</p>

<pre caption="Запуск postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Останавливаются или перезапускаются только те службы, которым <e>необходима</e>
данная служба. Остальные зависимые службы (те, которые <e>используют</e>
службу, но не нуждаются в ней) эта операция не затрагивает.
</note>

<p>
Если вы хотите остановить службу, но оставить зависимые от нее работающими,
можно использовать аргумент <c>pause</c>:
</p>

<pre caption="Остановка postfix без остановки зависимых служб">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Чтобы узнать текущее состояние службы (запущена, остановлена,
приостановлена и т.д.), можно использовать аргумент <c>status</c>:
</p>

<pre caption="Информация о состоянии postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Если указано, что служба работает, но вы знаете, что это не так, можно сбросить
состояние на stopped (остановлена), используя аргумент <c>zap</c>:
</p>

<pre caption="Сброс информации о состоянии postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Для того, чтобы выяснить зависимости службы, можно использовать аргументы
<c>iuse</c> или <c>ineed</c>. С помощью <c>ineed</c> вы увидите те службы,
которые действительно необходимы для правильного функционирования интересующей
вас службы. С другой стороны, <c>iuse</c> покажет те службы, которые могут
использоваться нашей службой, но не обязательны для ее работы. 
</p>

<pre caption="Запрос списка всех необходимых служб, от которых зависит Postfix">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
Аналогично вы можете узнать, какие службы нуждаются в данной службе 
(<c>needsme</c>) или могут ее использовать (<c>usesme</c>): 
</p>

<pre caption="Запрос списка всех служб, которым необходим Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Наконец, можно просмотреть список служб, требующихся для данной, но 
отсутствующих в системе:
</p>

<pre caption="Запрос списка служб, необходимых Postfix, но отсутствующих">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Использование rc-update</title>
<subsection>
<title>Что такое rc-update?</title>
<body>

<p>
Система инициализации Gentoo использует дерево зависимостей для определения
служб, которые запускаются в первую очередь. Т.&nbsp;к. это очень утомительное
занятие, и мы не хотели, чтобы пользователь занимался этим вручную, мы
разработали инструменты, упрощающие управление уровнями запуска и сценариями 
инициализации. 
</p>

<p>
Используя <c>rc-update</c>, можно включать и исключать сценарии инициализации 
из уровней запуска. Из <c>rc-update</c> автоматически запускается сценарий 
<c>depscan.sh</c> для перестроения дерева зависимостей.
</p>

</body>
</subsection>
<subsection>
<title>Добавление и удаление служб</title>
<body>

<p>
В процессе установки Gentoo вы уже добавляли сценарии инициализации в уровень 
запуска &laquo;default&raquo;. В тот момент вы, возможно, не имели понятия, что 
такое &laquo;default&raquo; и зачем он нужен, но теперь вы все это знаете. 
Сценарию <c>rc-update</c> требуется второй аргумент, определяющий действие: 
<e>add</e> (добавить), <e>del</e> (удалить) или <e>show</e> (показать).
</p>

<p>
Для того, чтобы добавить или удалить сценарий, просто введите <c>rc-update</c>
с аргументом <c>add</c> или <c>del</c>, затем название сценария и уровня 
запуска. Например:
</p>

<pre caption="Удаление Postfix из уровня запуска default">
# <i>rc-update del postfix default</i>
</pre>

<p>
По команде <c>rc-update show</c> выводится список всех доступных сценариев с
указанием соответствующих уровней запуска: 
</p>

<pre caption="Получение информации о сценариях инициализации">
# <i>rc-update show</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Настройка служб</title>
<subsection>
<title>Почему нужна дополнительная настройка?</title>
<body>

<p>
Сценарии инициализации могут быть весьма сложны. Поэтому нежелательно допускать
непосредственное редактирование сценария пользователями, т.к. это может
привнести в систему множество ошибок. Но, с другой стороны, необходимо 
правильно настроить службу. Например, может понадобиться передать службе
дополнительные параметры.
</p>

<p>
Вторая причина, по которой настройки хранятся отдельно от самого сценария
&mdash; это возможность обновления сценария без опасения, что все ваши 
настройки будут утеряны.
</p>

</body>
</subsection>
<subsection>
<title>Каталог /etc/conf.d</title>
<body>

<p>
В Gentoo предусмотрен очень простой способ настройки служб: для каждого
сценария, предполагающего настройку, в каталоге <path>/etc/conf.d</path>
есть конфигурационный файл. Например, у сценария, запускающего apache2
(под названием <path>/etc/init.d/apache2</path>) есть конфигурационный файл
<path>/etc/conf.d/apache2</path>, где могут храниться нужные вам параметры,
передаваемые серверу Apache 2 при запуске:
</p>

<pre caption="Переменная, определенная в /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP4"
</pre>

<p>
Такие файлы настроек содержат одни переменные (наподобие 
<path>/etc/make.conf</path>), облегчая настройку служб. Это также позволяет нам
давать больше информации о переменных (в комментариях).
</p>

</body>
</subsection>
</section>
<section>
<title>Написание сценариев инициализации</title>
<subsection>
<title>Мне тоже придется?..</title>
<body>

<p>
Нет, написание сценариев инициализации обычно не требуется, т.к. Gentoo
содержит готовые сценарии для всех поддерживаемых служб. Однако, вы можете
установить какую-либо службу, не используя систему Portage; в таком случае,
вероятно, вам придется создавать сценарий инициализации самостоятельно.
</p>

<p>
Не используйте сценарий, идущий со службой, если он не написан специально для
Gentoo: сценарии инициализации Gentoo не совместимы со сценариями, 
используемыми в других дистрибутивах! 
</p>

</body>
</subsection>
<subsection>
<title>Структура</title>
<body>

<p>
Основная структура сценария инициализации показана ниже.
</p>

<pre caption="Основная структура сценария">
#!/sbin/runscript

depend() {
  <comment>(информация о зависимостях)</comment>
}

start() {
  <comment>(команды, необходимые для запуска службы)</comment>
}

stop() {
  <comment>(команды, необходимые для остановки службы)</comment>
}

restart() {
  <comment>(команды, необходимые для перезапуска службы)</comment>
}
</pre>

<p>
В любом сценарии <e>должна</e> быть определена функция <c>start()</c>. Все
остальные разделы необязательны.
</p>

</body>
</subsection>
<subsection>
<title>Зависимости</title>
<body>

<p>
Можно определять два типа зависимостей: <c>use</c> (использую) и <c>need</c> 
(нуждаюсь). Как упоминалось ранее, <c>need</c>-зависимость более строга, чем 
<c>use</c>-зависимость. Вслед за типом зависимости указывается название службы, 
от которой существует зависимость, или ссылка на <e>виртуальную</e> (virtual) 
зависимость.
</p>

<p>
<e>Виртуальная</e> зависимость &mdash; это зависимость от функций,
предоставляемых службой, но не какой-то единственной службой. Сценарий может 
зависеть от службы системного журнала, но таких достаточно много (metalogd, 
syslog-ng, sysklogd и т.п.). Поскольку нельзя нуждаться в каждой из них
(ни в одной вразумительной системе они не запущены все сразу), мы обеспечили
<c>предоставление</c> виртуальной зависимости всеми этими службами.
</p>

<p>
Давайте взглянем на информацию о зависимостях postfix.
</p>

<pre caption="Информация о зависимостях Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Как можно увидеть, postfix:
</p>

<ul>
  <li>
    требует сеть (<c>net</c>): виртуальная зависимость, удовлетворяемая, 
    например, <path>/etc/init.d/net.eth0</path>
  </li>
  <li>
    использует журнал (<c>logger</c>): виртуальная зависимость, 
    удовлетворяемая, например, <path>/etc/init.d/syslog-ng</path>
  </li>
  <li>
    использует службу имен (<c>dns</c>): виртуальная зависимость,
    удовлетворяемая, например, <path>/etc/init.d/named</path>)
  </li>
  <li>
    предоставляет почтовый агент (<c>mta</c>): виртуальная зависимость,
    общая для всех программ &mdash; почтовых серверов
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Порядок запуска</title>
<body>

<p>
Иногда вам нужна не сама служба, а запуск вашей службы <c>до</c> (или
<e>после</e>) другой службы, <e>если</e> та присутствует в системе
(обратите внимание на условие: это уже не зависимость) <e>и</e> запускается
на том же уровне запуска (отметьте условие: это относится только к службам
из одинакового уровня запуска). Такую очередность можно указать, используя 
значения <c>before</c> (до) или <c>after</c> (после).
</p>

<p>
Например, рассмотрим значения для службы Portmap:
</p>

<pre caption="Функция depend() службы Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Также можно использовать знак &laquo;*&laquo;, чтобы охватить все службы
данного уровня запуска, хотя это не рекомендуется. 
</p>

<pre caption="Запуск сценария первым на уровне запуска">
depend() {
  before *
}
</pre>

</body>
</subsection>
<subsection>
<title>Стандартные функции</title>
<body>

<p>
Следом за разделом <c>depend()</c> вам потребуется определить функцию
<c>start()</c>. В ней содержатся все команды, необходимые для запуска вашей
службы. Рекомендуется применять функции <c>ebegin</c> и <c>eend</c> для
сообщений пользователю о том, что происходит:
</p>

<pre caption="Пример функции start()">
start() {
  ebegin "Запуск - моя_служба"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}
</pre>

<p>
Если вам нужны дополнительные примеры функции <c>start()</c>, пожалуйста,
прочитайте исходные коды сценариев инициализации, находящихся в каталоге 
<path>/etc/init.d</path>. Что касается команды <c>start-stop-daemon</c>, то 
на случай, если вам нужны дополнительные сведения, есть превосходная 
страница справки:
</p>

<pre caption="Вызов страницы справки по start-stop-daemon">
# <i>man start-stop-daemon</i>
</pre>

<p>
Другими функциями, которые можно определить &mdash; <c>stop()</c> и
<c>restart()</c>. От вас не требуется определение этих функций! Система 
инициализации, применяемая нами, достаточно развита и в состоянии 
самостоятельно заполнить эти функции, если вы используете 
<c>start-stop-daemon</c>.
</p>

<p>
Синтаксис сценариев инициализации, применяемых в Gentoo, основан на
оболочке Борна (Bourne Again Shell &mdash; bash), поэтому вы можете свободно
использовать внутри своих сценариев bash-совместимые конструкции.
</p>

</body>
</subsection>
<subsection>
<title>Добавление дополнительных параметров</title>
<body>

<p>
Если вы хотите ввести в сценарий дополнительные параметры, кроме упоминавшихся,
нужно добавить к переменной <c>opts</c> название параметра и создать функцию
с названием, соответствующим параметру. Например, для поддержки параметра
<c>restartdelay</c>:
</p>

<pre caption="Создание дополнительной функции restartdelay">
opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <comment># пауза в 3 секунды перед повторным запуском</comment>
  start
}
</pre>

</body>
</subsection>
<subsection>
<title>Переменные для настройки служб</title>
<body>

<p>
Для поддержки конфигурационного файла в каталоге <path>/etc/conf.d</path>
ничего дополнительно делать не нужно: при запуске вашего сценария инициализации
автоматически включаются следующие файлы (т.е., переменные из них становятся 
доступны):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;ваш сценарий инициализации&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Если ваш инициализационный сценарий предоставляет виртуальную зависимость
(например, <c>net</c>), то также включается файл, соответствующий этой 
зависимости (например, <path>/etc/conf.d/net</path>).
</p>

</body>
</subsection>
</section>
<section>
<title>Изменение поведения уровней запуска</title>
<subsection>
<title>Кто от этого выиграет?</title>
<body>

<p>
Большинству пользователей ноутбуков знакома ситуация: дома вам нужен запуск
<c>net.eth0</c>, и наоборот, в дороге запуск <c>net.eth0</c> не нужен (так как
сеть недоступна). В Gentoo можно изменять поведение уровней запуска по своему 
усмотрению.
</p>

<p>
Например вы можете создать второй загружаемый уровень запуска &laquo;по 
умолчанию&raquo;, в котором будут другие сценарии. Затем при загрузке вы
сможете выбрать, какой из уровней по умолчанию следует использовать.
</p>

</body>
</subsection>
<subsection>
<title>Использование программного уровня (softlevel)</title>
<body>

<p>
Прежде всего, создайте каталог для своего второго уровня запуска &laquo;по
умолчанию&raquo;. Например, создадим уровень запуска <path>offline</path>:
</p>

<pre caption="Создание каталога уровня запуска">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Добавьте необходимые сценарии инициализации в только что созданный уровень
запуска. Например, чтобы получить точную копию уровня <c>default</c>, за 
исключением <c>net.eth0</c>:
</p>

<pre caption="Добавление нужных сценариев инициализации">
<comment>(копирование всех служб с уровня default в уровень offline)</comment>
# <i>cd /etc/runlevels/default</i>
# <i>for service in *; do rc-update add $service offline; done</i>
<comment>(удаление ненужных сценариев с уровня offline)</comment>
# <i>rc-update del net.eth0 offline</i>
<comment>(просмотр сценариев, запускаемых на уровне offline)</comment>
# <i>rc-update show offline</i>
<comment>(часть выведенного списка)</comment>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre>

<p>
Теперь необходимо отредактировать конфигурацию загрузчика, добавив запись об
уровне <c>offline</c>. Например, в файле <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Добавление записи об уровне offline">
title Автономное использование Gentoo Linux
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Вуаля, все готово. Теперь, если при загрузке вы выберете вновь созданную
запись, то вместо <c>default</c> будет использоваться уровень <c>offline</c>.
</p>

</body>
</subsection>
<subsection>
<title>Использование загрузочного уровня (bootlevel)</title>
<body>

<p>
Использование <c>загрузочного уровня</c> полностью аналогично использованию
<c>программного уровня</c>. Единственная разница состоит в том, что вы
определяете второй уровень &laquo;boot&raquo; вместо &laquo;default&raquo;.
</p>

</body>
</subsection>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 1.21-r4
target-date: 2006-03-24
source-cvs-revision: 1.25
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Sergey Kuleshov; Alexey Chumakov [achumakov@gentoo.org]

note:
-->
