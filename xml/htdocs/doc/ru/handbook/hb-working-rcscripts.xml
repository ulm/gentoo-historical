<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/hb-working-rcscripts.xml,v 1.9 2013/01/20 15:47:40 swift Exp $ -->

<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>

<version>3</version>
<date>2012-10-31</date>

<section>
<title>Уровни запуска</title>
<subsection>
<title>Процесс загрузки системы</title>
<body>

<p>
При загрузке вашей системы по экрану пробегает много текста. Если
присмотреться, заметно, что этот текст не меняется от загрузки к загрузке.
Последовательность всех этих действий называется <e>последовательностью
загрузки</e> и в той или иной степени постоянна.
</p>

<p>
Во-первых, загрузчик размещает в памяти образ ядра, который вы указали в
файле его конфигурации. После этого ядро запускается. Когда ядро загружено и
запущено, оно инициализирует относящиеся к ядру структуры и задания, и
запускает процесс <c>init</c>.
</p>

<p>
Этот процесс удостоверяется, что все файловые системы (определенные в
<path>/etc/fstab</path>) смонтированы и готовы к использованию. Затем он 
выполняет несколько сценариев, находящихся в каталоге <path>/etc/init.d</path>,
которые запускают службы, необходимые для нормального запуска системы.
</p>

<p>
И, наконец, когда все сценарии выполнены, <c>init</c> подключает терминалы
(чаще всего просто виртуальные консоли, которые видны при нажатии
<c>ALT+F1</c>, <c>ALT+F2</c> и т.д.), прикрепляя к каждой консоли специальный
процесс под названием <c>agetty</c>. Этот процесс впоследствии обеспечивает
возможность входа в систему с помощью <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Сценарии инициализации</title>
<body>

<p>
Сейчас процесс <c>init</c> запускает сценарии из каталога
<path>/etc/init.d</path> не просто в случайном порядке. Более того, запускаются
не все сценарии из <path>/etc/init.d</path>, а только те, которые предписано
исполнять. Решение о запуске сценария принимается в результате просмотра
каталога <path>/etc/runlevels</path>.
</p>

<p>
Во-первых, <c>init</c> запускает все сценарии из <path>/etc/init.d</path>, на
которые есть символьные ссылки из <path>/etc/runlevels/boot</path>. Обычно
сценарии запускаются в алфавитном порядке, но в некоторых сценариях имеется
информация о зависимостях от других сценариев, указывающая системе на
необходимость их предварительного запуска.
</p>

<p>
Когда все сценарии, указанные в <path>/etc/runlevels/boot</path>, будут
выполнены, <c>init</c> переходит к запуску сценариев, на которые есть
символьные ссылки из <path>/etc/runlevels/default</path>. И снова запуск
происходит в алфавитном порядке, пока в сценарии не встретится информация о
зависимостях; тогда порядок изменяется для обеспечения правильного порядка
запуска.
</p>

</body>
</subsection>
<subsection>
<title>Как работает init</title>
<body>

<p>
Конечно, <c>init</c> не принимает решений сам по себе. Ему необходим
конфигурационный файл, где описаны необходимые действия. Этот файл &mdash;
<path>/etc/inittab</path>.
</p>

<p>
Если вы запомнили последовательность загрузки, описанную чуть ранее, вы
вспомните, что первое действие <c>init</c> &mdash; это монтирование всех файловых
систем. Это определяется в строке <path>/etc/inittab</path>, приведенной ниже:
</p>

<pre caption="Строка инициализации системы из /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Этой строкой процессу <c>init</c> предписывается выполнить <c>/sbin/rc
sysinit</c> для инициализации системы. Самой инициализацией занимается
сценарий <path>/sbin/rc</path>, так что можно сказать, что <c>init</c> делает
не слишком много &mdash; он просто делегирует задачу по инициализации системы
другому процессу.
</p>

<p>
Во-вторых, <c>init</c> выполняет все сценарии, на которые есть символьные
ссылки из <path>/etc/runlevels/boot</path>. Это определяется следующей строкой:
</p>

<pre caption="Инициализация системы, продолжение">
rc::bootwait:/sbin/rc boot
</pre>

<p>
И снова все необходимые действия выполняются сценарием <c>rc</c>. Заметьте, что
параметр, переданный <c>rc</c> (<e>boot</e>), совпадает с названием
используемого подкаталога в <path>/etc/runlevels</path>.
</p>

<p>
Теперь <c>init</c> проверяет свой конфигурационный файл, чтобы определить,
какой <e>уровень запуска</e> использовать. Для этого из
<path>/etc/inittab</path> считывается строка:
</p>

<pre caption="Строка initdefault">
id:3:initdefault:
</pre>

<p>
В приведенном примере (который подходит для подавляющего большинства
пользователей Gentoo) номер <e>уровня запуска</e> &mdash; 3. Пользуясь этой
информацей, <c>init</c> проверяет, что нужно выполнить для запуска <e>уровня
запуска 3</e>:
</p>

<pre caption="Определение уровней запуска">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
В строке, определяющей уровень 3, для запуска служб снова используется сценарий
<c>rc</c> (на этот раз с аргументом <e>default</e>). Опять-таки, обратите
внимание, что аргумент, передаваемый сценарию <c>rc</c>, совпадает с названием
подкаталога из <path>/etc/runlevels</path>.
</p>

<p>
По окончании работы <c>rc</c>, <c>init</c> принимает решение о том, какие
виртуальные консоли включить и какие команды выполнить в каждой из них:
</p>

<pre caption="Определение виртуальных консолей">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>


</body>
</subsection>
<subsection>
<title>Что такое уровень запуска?</title>
<body>

<p>
Как вы заметили, <c>init</c> применяет нумерацию для определения <e>уровня
запуска</e>, который надо использовать. <e>Уровень запуска</e> &mdash; это то
состояние, в котором запускается ваша система, он содержит набор
сценариев (сценариев уровня запуска или <e>сценариев инициализации 
[initscript]</e>), которые следует выполнять, при входе и выходе из 
определенного уровня запуска. 
</p>

<p>
В Gentoo определено семь уровней запуска: три служебных и четыре
определяемых пользователем. Служебные называются <e>sysinit</e>,
<e>shutdown</e> и <e>reboot</e>. Действия, совершаемые ими, в точности
соответствуют их названиям: инициализация системы, выключение системы и ее
перезагрузка.
</p>

<p>
Определяемые пользователем уровни &mdash; это те, которым соответствуют
подкаталоги в <path>/etc/runlevels</path>: <path>boot</path>,
<path>default</path>, <path>nonetwork</path> и <path>single</path>. Уровень 
<path>boot</path> запускает все службы, необходимые системе и используемые 
всеми остальными уровнями. Остальные уровни отличаются друг от друга 
запускаемыми службами: <path>default</path> используется для повседневной 
работы, <path>nonetwork</path> &mdash; для тех случаев, когда не требуется
сеть, а <path>single</path> &mdash; при необходимости восстановления системы.
</p>

</body>
</subsection>
<subsection>
<title>Работа со сценариями инициализации</title>
<body>

<p>
Сценарии, запускаемые процессом <c>rc</c>, называются <e>сценариями
инициализации</e>. Каждый сценарий из <path>/etc/init.d</path> может
запускаться с аргументами <e>start</e>, <e>stop</e>, <e>restart</e>, 
<e>pause</e>, <e>zap</e>, <e>status</e>, <e>ineed</e>, <e>iuse</e>, 
<e>needsme</e>, <e>usesme</e> и <e>broken</e>.
</p>

<p>
Для запуска, остановки или перезапуска службы (и всех, зависящих от нее)
следует использовать <c>start</c>, <c>stop</c> и <c>restart</c>:
</p>

<pre caption="Запуск postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Останавливаются или перезапускаются только те службы, которым <e>необходима</e>
данная служба. Остальные зависимые службы (те, которые <e>используют</e>
службу, но не нуждаются в ней) эта операция не затрагивает.
</note>

<p>
Если вы хотите остановить службу, но оставить зависимые от нее работающими,
можно использовать аргумент <c>pause</c>:
</p>

<pre caption="Остановка postfix без остановки зависимых служб">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Чтобы узнать текущее состояние службы (запущена, остановлена,
приостановлена и т.д.), можно использовать аргумент <c>status</c>:
</p>

<pre caption="Информация о состоянии postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Если указано, что служба работает, но вы знаете, что это не так, можно сбросить
состояние на stopped (остановлена), используя аргумент <c>zap</c>:
</p>

<pre caption="Сброс информации о состоянии postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Для того, чтобы выяснить зависимости службы, можно использовать аргументы
<c>iuse</c> или <c>ineed</c>. С помощью <c>ineed</c> вы увидите те службы,
которые действительно необходимы для правильного функционирования интересующей
вас службы. С другой стороны, <c>iuse</c> покажет те службы, которые могут
использоваться нашей службой, но не обязательны для ее работы. 
</p>

<pre caption="Запрос списка всех необходимых служб, от которых зависит Postfix">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
Аналогично вы можете узнать, какие службы нуждаются в данной службе 
(<c>needsme</c>) или могут ее использовать (<c>usesme</c>): 
</p>

<pre caption="Запрос списка всех служб, которым необходим Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Наконец, можно просмотреть список служб, требующихся для данной, но 
отсутствующих в системе:
</p>

<pre caption="Запрос списка служб, необходимых Postfix, но отсутствующих">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Использование rc-update</title>
<subsection>
<title>Что такое rc-update?</title>
<body>

<p>
Система инициализации Gentoo использует дерево зависимостей для определения
служб, которые запускаются в первую очередь. Т.&nbsp;к. это очень утомительное
занятие, и мы не хотели, чтобы пользователь занимался этим вручную, мы
разработали инструменты, упрощающие управление уровнями запуска и сценариями 
инициализации. 
</p>

<p>
Используя <c>rc-update</c>, можно включать и исключать сценарии инициализации 
из уровней запуска. Из <c>rc-update</c> автоматически запускается сценарий 
<c>depscan.sh</c> для перестроения дерева зависимостей.
</p>

</body>
</subsection>
<subsection>
<title>Добавление и удаление служб</title>
<body>

<p>
В процессе установки Gentoo вы уже добавляли сценарии инициализации в уровень 
запуска &laquo;default&raquo;. В тот момент вы, возможно, не имели понятия, что 
такое &laquo;default&raquo; и зачем он нужен, но теперь вы все это знаете. 
Сценарию <c>rc-update</c> требуется второй аргумент, определяющий действие: 
<e>add</e> (добавить), <e>del</e> (удалить) или <e>show</e> (показать).
</p>

<p>
Для того, чтобы добавить или удалить сценарий, просто введите <c>rc-update</c>
с аргументом <c>add</c> или <c>del</c>, затем название сценария и уровня 
запуска. Например:
</p>

<pre caption="Удаление Postfix из уровня запуска default">
# <i>rc-update del postfix default</i>
</pre>

<p>
По команде <c>rc-update -v show</c> выводится список всех доступных сценариев с
указанием соответствующих уровней запуска: 
</p>

<pre caption="Получение информации о сценариях инициализации">
# <i>rc-update -v show</i>
</pre>

<p>
Вы также можете запустить <c>rc-update show</c> (без <c>-v</c>) чтобы просто 
просмотреть включенные инициализационные скрипты и их уровни запуска.
</p>

</body>
</subsection>
</section>
<section>
<title>Настройка служб</title>
<subsection>
<title>Почему нужна дополнительная настройка?</title>
<body>

<p>
Сценарии инициализации могут быть весьма сложны. Поэтому нежелательно допускать
непосредственное редактирование сценария пользователями, т.к. это может
привнести в систему множество ошибок. Но, с другой стороны, необходимо 
правильно настроить службу. Например, может понадобиться передать службе
дополнительные параметры.
</p>

<p>
Вторая причина, по которой настройки хранятся отдельно от самого сценария
&mdash; это возможность обновления сценария без опасения, что все ваши 
настройки будут утеряны.
</p>

</body>
</subsection>
<subsection>
<title>Каталог /etc/conf.d</title>
<body>

<p>
В Gentoo предусмотрен очень простой способ настройки служб: для каждого
сценария, предполагающего настройку, в каталоге <path>/etc/conf.d</path>
есть конфигурационный файл. Например, у сценария, запускающего apache2
(под названием <path>/etc/init.d/apache2</path>) есть конфигурационный файл
<path>/etc/conf.d/apache2</path>, где могут храниться нужные вам параметры,
передаваемые серверу Apache 2 при запуске:
</p>

<pre caption="Переменная, определенная в /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP5"
</pre>

<p>
Такие файлы настроек содержат одни переменные (наподобие 
<path>/etc/portage/make.conf</path>), облегчая настройку служб. Это также позволяет нам
давать больше информации о переменных (в комментариях).
</p>

</body>
</subsection>
</section>
<section>
<title>Написание сценариев инициализации</title>
<subsection>
<title>Мне тоже придется?..</title>
<body>

<p>
Нет, написание сценариев инициализации обычно не требуется, т.к. Gentoo
содержит готовые сценарии для всех поддерживаемых служб. Однако, вы можете
установить какую-либо службу, не используя систему Portage; в таком случае,
вероятно, вам придется создавать сценарий инициализации самостоятельно.
</p>

<p>
Не используйте сценарий, идущий со службой, если он не написан специально для
Gentoo: сценарии инициализации Gentoo не совместимы со сценариями, 
используемыми в других дистрибутивах! 
</p>

</body>
</subsection>
<subsection>
<title>Структура</title>
<body>

<p>
Основная структура сценария инициализации показана ниже.
</p>

<pre caption="Основная структура сценария">
#!/sbin/runscript

depend() {
  <comment>(информация о зависимостях)</comment>
}

start() {
  <comment>(команды, необходимые для запуска службы)</comment>
}

stop() {
  <comment>(команды, необходимые для остановки службы)</comment>
}
</pre>

<p>
В любом сценарии <e>должна</e> быть определена функция <c>start()</c>. Все
остальные разделы необязательны.
</p>

</body>
</subsection>
<subsection>
<title>Зависимости</title>
<body>

<p>
Существуют две настройки, работающие с зависимостями, которые вы можете 
определить, и они будут влиять на порядок запуска инициализационных 
скриптов: <c>use</c> (использую) и <c>need</c> (нуждаюсь). Кроме этих двух, 
существуют еще два влияющих на порядок загрузки метода, называющихся 
<c>before</c> (перед) и <c>after</c> (после). Последние два определяют не 
зависимости, они не заставят выдать ошибку скрипт, если тот скрипт, что в 
них описан вообще не должен запуститься (или не запустится).
</p>

<ul>
  <li>
    Настройка <c>use</c> информирует систему init, что данный скрипт 
    <e>использует</e> функциональность некоторого скрипта, но строго от 
    него не зависит. Хорошим примером будет <c>use logger</c> или 
    <c>use dns</c>. Если эти сервисы есть, они будут хорошо использоваться, 
    но если у вас нет логгера, или DNS-сервера, сервисы все равно будут 
    работать. Если сервисы существуют, они будут запущены до того, 
    как запустится скрипт, <c>использующий</c> их.
  </li>
  <li>
     Настройка <c>need</c> это жесткая зависимость. Она означает, что 
     скрипт, которому <c>нужен</c> другой скрипт, не запустится, пока 
     другой скрипт не запустится успешно. Также, если другой скрипт 
     будет перезапущен, то этот тоже будет перезапущен.
  </li>
  <li>
     При использовании <c>before</c>, данный скрипт запускается до 
     некоторого скрипта, <e>если</e> выбранный скрипт это часть того же 
     уровня инициализации. Так, инициализационный скрипт <path>xdm</path>, 
     который определен <c>before alsasound</c> будет запущен до скрипта 
     <path>alsasound</path>, но только если <path>alsasound</path> запланирован 
     запуститься на том же уровне инициализации. Если <path>alsasound</path> 
     не запланирован запуститься, то эта конкретная настройка не будет иметь 
     эффекта, и <path>xdm</path> запустится в тот момент времени, который 
     система init посчитает лучшим вариантом.
  </li>
  <li>
     Похожим образом, <c>after</c> информирует систему init, что данный скрипт 
     нужно запустить после некоторого скрипта, <e>если</e> выбранный скрипт 
     является частью того же уровня инициализации. Если нет, то настройка не 
     имеет эффекта, и скрипт будет запущен системой init в момент времени, 
     который, как она посчитает, будет наилучшим.
  </li>
</ul>

<p>
Из вышенаписанного должно быть ясно, что <c>need</c> это единственная 
"действительная" настройка зависимостей, так как она влияет на то, 
будет ли запущен скрипт или нет. Все остальные являются больше указателями 
системе init, говорящими в каком порядке скрипты могут (или должны) 
запускаться.
</p>

<p>
Теперь, если вы посмотрите на многие из существующих инициализационных 
скриптов Gentoo, вы заметите, что некоторые из них имеют зависимости 
от вещей, которые не являются инициализационными скриптами. 
Эти "вещи" мы называем <e>виртуальными</e>.
</p>

<p>
<e>Виртуальная</e> зависимость &mdash; это зависимость от функций,
предоставляемых службой, но не какой-то единственной службой. Сценарий может 
зависеть от службы системного журнала, но таких достаточно много (metalogd, 
syslog-ng, sysklogd и т.п.). Поскольку нельзя нуждаться в каждой из них
(ни в одной вразумительной системе они не запущены все сразу), мы обеспечили
<c>предоставление</c> виртуальной зависимости всеми этими службами.
</p>

<p>
Давайте взглянем на информацию о зависимостях postfix.
</p>

<pre caption="Информация о зависимостях Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Как можно увидеть, postfix:
</p>

<ul>
  <li>
    требует сеть (<c>net</c>): виртуальная зависимость, удовлетворяемая, 
    например, <path>/etc/init.d/net.eth0</path>
  </li>
  <li>
    использует журнал (<c>logger</c>): виртуальная зависимость, 
    удовлетворяемая, например, <path>/etc/init.d/syslog-ng</path>
  </li>
  <li>
    использует службу имен (<c>dns</c>): виртуальная зависимость,
    удовлетворяемая, например, <path>/etc/init.d/named</path>)
  </li>
  <li>
    предоставляет почтовый агент (<c>mta</c>): виртуальная зависимость,
    общая для всех программ &mdash; почтовых серверов
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Порядок запуска</title>
<body>

<p>
Как мы описали в предыдущем разделе, вы можете сказать системе init, 
в каком порядке она должна запускать (или останавливать) скрипты. 
Этот порядок поддерживается как через настройки зависимостей 
<c>use</c> и <c>need</c>, так и через настройки порядка <c>before</c> и 
<c>after</c>. Так как мы описали их ранее, давайте посмотрим на сервис 
Portmap, как на пример такого инициализационного скрипта.
</p>

<pre caption="Функция depend() службы Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Также можно использовать знак &laquo;*&laquo;, чтобы охватить все службы
данного уровня запуска, хотя это не рекомендуется. 
</p>

<pre caption="Запуск сценария первым на уровне запуска">
depend() {
  before *
}
</pre>

<p>
Если ваш сервис должен писать на локальные диски, он должен потребовать 
<c>localmount</c>. Если он что-либо поместит в <path>/var/run</path>, например, 
pid-файл, тогда он должен запускаться после <c>bootmisc</c>:
</p>

<pre caption="Пример функции depend()">
depend() {
need localmount
after bootmisc
}
</pre>

</body>
</subsection>
<subsection>
<title>Стандартные функции</title>
<body>

<p>
Следом за разделом <c>depend()</c> вам потребуется определить функцию
<c>start()</c>. В ней содержатся все команды, необходимые для запуска вашей
службы. Рекомендуется применять функции <c>ebegin</c> и <c>eend</c> для
сообщений пользователю о том, что происходит:
</p>

<pre caption="Пример функции start()">
start() {
  if [ "${RC_CMD}" = "restart" ];
  then
  <comment># Что-нибудь сделать, если рестарт требует больше, чем просто
  последовательный запуск stop и start</comment>
  fi

  ebegin "Запуск - моя_служба"
  start-stop-daemon --start --exec /path/to/my_service \
    --pidfile /path/to/my_pidfile
  eend $?
}
</pre>

<p>
Как <c>--exec</c>, так и <c>--pidfile</c> должны использоваться в 
функциях start и stop. Если сервис не создает pid-файл, тогда 
используйте <c>--make-pidfile</c>, если возможно, хотя лучше протестировать 
это, чтобы быть уверенным. Иначе, не используйте пид-файлы. Вы также 
можете добавить <c>--quiet</c> к опциям <c>start-stop-daemon</c>, но это 
не рекомендуется, если только сервис не очень многословный. Использование 
<c>--quiet</c> может скрыть информацию если сервис не сможет запуститься.
</p>

<p>
Другой интересной настройкой, используемой в вышеприведенном примере является 
проверка содержимого переменной <c>RC_CMD</c>. В отличие от предыдущей 
инициализационной системы, новая система <c>openrc</c> не поддерживает 
отдельную функциональность restart для каждого скрипта. Вместо этого, 
скрипт должен проверить содержимое переменной <c>RC_CMD</c>, чтобы проверить, 
вызывается ли функция (как <c>start()</c>, так и <c>stop()</c>) как часть 
restart, или нет.
</p>

<note>
Удостоверьтесь, что <c>--exec</c> действительно вызывает сервис, а не 
shell-скрипт, который запускает сервисы и выходит — это должен делать 
сам инициализационный скрипт.
</note>

<p>
Если вам нужны дополнительные примеры функции <c>start()</c>, пожалуйста,
прочитайте исходные коды сценариев инициализации, находящихся в каталоге 
<path>/etc/init.d</path>. 
</p>

<p>
Еще одной функцией, которую можно определить, является <c>stop()</c>.
От вас не требуется определение этой функции! Система 
инициализации, применяемая нами, достаточно развита и в состоянии 
самостоятельно заполнить эту функцию, если вы используете 
<c>start-stop-daemon</c>.
</p>

<p>
Ниже приведен пример функции <c>stop()</c>:
</p>

<pre caption="Пример функции stop()">
stop() {
ebegin "Stopping my_service"
start-stop-daemon --stop --exec /path/to/my_service \
--pidfile /path/to/my_pidfile
eend $?
}
</pre>

<p>
Если ваш сервис запускает некоторый другой скрипт (например, на bash, 
python или perl), и этот скрипт позднее изменяет имя (например, с 
<c>foo.py</c> на <c>foo</c>), тогда вам нужно добавить <c>--name</c> к 
<c>start-stop-daemon</c>. Вы должны определить имя, на которое имя файла 
будет изменено. В приведенном примере, сервис запускает <c>foo.py</c>, а 
потом это имя меняется на <c>foo</c>:
</p>

<pre caption="Сервис, который запускает скрипт foo">
start() {
ebegin "Starting my_script"
start-stop-daemon --start --exec /path/to/my_script \
--pidfile /path/to/my_pidfile --name foo
eend $?
}
</pre>

<p>
У <c>start-stop-daemon</c> есть отличная man-страница, которую вы можете 
посмотреть, если вам нужна дополнительная информация.
</p>

<pre caption="Получаем man-страницу для start-stop-daemon">
$ <i>man start-stop-daemon</i>
</pre>

<p>
Синтаксис сценариев инициализации, применяемых в Gentoo, основан на
оболочке POSIX, поэтому вы можете свободно использовать внутри своих сценариев 
sh-совместимые конструкции. Остальные конструкции, вроде тех, которые
специфичны только для bash, выносите за пределы инициализационных сценариев,
чтобы быть уверенным, что скрипты будут работать независимо от того, что
Gentoo может сделать со своей системой инициализации.
</p>

</body>
</subsection>
<subsection>
<title>Добавление дополнительных параметров</title>
<body>

<p>
Если вы хотите ввести в сценарий дополнительные параметры, кроме упоминавшихся,
нужно добавить к переменной <c>extra_commands</c> название параметра и создать функцию
с названием, соответствующим параметру. Например, для поддержки параметра
<c>restartdelay</c>:
</p>

<pre caption="Создание дополнительной функции restartdelay">
extra_commands="restartdelay"

restartdelay() {
  stop
  sleep 3    <comment># пауза в 3 секунды перед повторным запуском</comment>
  start
}
</pre>

<impo>
Функция <c>restart</c> не может быть переназначена в openrc!
</impo>

</body>
</subsection>
<subsection>
<title>Переменные для настройки служб</title>
<body>

<p>
Для поддержки конфигурационного файла в каталоге <path>/etc/conf.d</path>
ничего дополнительно делать не нужно: при запуске вашего сценария инициализации
автоматически включаются следующие файлы (т.е., переменные из них становятся 
доступны):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;ваш сценарий инициализации&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Если ваш инициализационный сценарий предоставляет виртуальную зависимость
(например, <c>net</c>), то также включается файл, соответствующий этой 
зависимости (например, <path>/etc/conf.d/net</path>).
</p>

</body>
</subsection>
</section>
<section>
<title>Изменение поведения уровней запуска</title>
<subsection>
<title>Кто от этого выиграет?</title>
<body>

<p>
Большинству пользователей ноутбуков знакома ситуация: дома вам нужен запуск
<c>net.eth0</c>, и наоборот, в дороге запуск <c>net.eth0</c> не нужен (так как
сеть недоступна). В Gentoo можно изменять поведение уровней запуска по своему 
усмотрению.
</p>

<p>
Например вы можете создать второй загружаемый уровень запуска &laquo;по 
умолчанию&raquo;, в котором будут другие сценарии. Затем при загрузке вы
сможете выбрать, какой из уровней по умолчанию следует использовать.
</p>

</body>
</subsection>
<subsection>
<title>Использование программного уровня (softlevel)</title>
<body>

<p>
Прежде всего, создайте каталог для своего второго уровня запуска &laquo;по
умолчанию&raquo;. Например, создадим уровень запуска <path>offline</path>:
</p>

<pre caption="Создание каталога уровня запуска">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Добавьте необходимые сценарии инициализации в только что созданный уровень
запуска. Например, чтобы получить точную копию уровня <c>default</c>, за 
исключением <c>net.eth0</c>:
</p>

<pre caption="Добавление нужных сценариев инициализации">
<comment>(копирование всех служб с уровня default в уровень offline)</comment>
# <i>cd /etc/runlevels/default</i>
# <i>for service in *; do rc-update add $service offline; done</i>
<comment>(удаление ненужных сценариев с уровня offline)</comment>
# <i>rc-update del net.eth0 offline</i>
<comment>(просмотр сценариев, запускаемых на уровне offline)</comment>
# <i>rc-update show offline</i>
<comment>(часть выведенного списка)</comment>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre>

<p>
Даже несмотря на то, что <c>net.eth0</c> был удален с уровня запуска offline, 
но <c>udev</c> может попытаться запустить любые устройства, которые 
он найдет, и запустить соответствующие сервисы. Данная функциональность
называется <e>hotplugging</e>. По умолчанию, Gentoo отключает hotplugging.
</p>

<p>
Если вы хотите включить hotplugging, но только для конкретного набора
скриптов, используйте переменную <c>rc_hotplug</c> в <path>/etc/rc.conf</path>:
</p>

<pre caption="Отключаем сервисы, инициируемые устройствами в /etc/rc.conf">
<comment># Разрешить hotplugging для net.wlan и любого другого сервиса, кроме 
# тех, которые попадают под выражение net.*</comment>
rc_hotplug="net.wlan !net.*"
</pre>

<note>
Для более детальной информации о сервисах, инициируемых устройствами, 
просмотрите комментарии в <path>/etc/rc.conf</path>.
</note>

<p>
Теперь необходимо отредактировать конфигурацию загрузчика, добавив запись об
уровне <c>offline</c>. Например, в файле <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Добавление записи об уровне offline">
title Автономное использование Gentoo Linux
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Вуаля, все готово. Теперь, если при загрузке вы выберете вновь созданную
запись, то вместо <c>default</c> будет использоваться уровень <c>offline</c>.
</p>

</body>
</subsection>
<subsection>
<title>Использование загрузочного уровня (bootlevel)</title>
<body>

<p>
Использование <c>загрузочного уровня</c> полностью аналогично использованию
<c>программного уровня</c>. Единственная разница состоит в том, что вы
определяете второй уровень &laquo;boot&raquo; вместо &laquo;default&raquo;.
</p>

</body>
</subsection>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-date: 2012-10-31
source-cvs-revision: 1.38
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Sergey Kuleshov; Alexey Chumakov [achumakov@gentoo.org]
edited-by: Vladimir Romanov [blueboar2@gmail.com]
-->
