<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">


<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-x86-kernel.xml,v 1.10 2006/01/23 21:37:40 achumakov Exp $ -->


<sections>

<version>3.11</version>
<date>2006-01-06</date>

<section>
<title>Часовой пояс</title>
<body>

<p>
Сначала вы должны выбрать часовой пояс (time zone), чтобы система знала, где вы 
находитесь. Найдите нужный пояс в <path>/usr/share/zoneinfo</path>, затем 
скопируйте его в <path>/etc/localtime</path>. Постарайтесь, пожалуйста, 
избегать использования часовых поясов 
<path>/usr/share/zoneinfo/Etc/GMT*</path>, т. к. их названия не соответствуют
ожидаемым поясам. Например, <path>GMT-8</path> фактически является поясом GMT+8.
</p>

<pre caption="Установка часового пояса">
# <i>ls /usr/share/zoneinfo</i>
<comment>(допустим, вы хотите использовать GMT)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>

<section>
<title>Установка исходных кодов ядра</title>
<subsection>
<title>Выбор ядра</title>
<body>

<p>
Ядро Linux - это то, вокруг чего формируются все дистрибутивы. Это слой между
пользовательскими программами и вашими аппаратными средствами. Пользователи
Gentoo могут использовать один из нескольких типов ядра. Полный их список с
описанием можно найти в <uri link="/doc/en/gentoo-kernel.xml">Руководстве по
выбору ядра Gentoo</uri>.
</p>

<p>
Для x86 систем, помимо прочих, есть такие ядра, как <c>vanilla-sources</c> 
(ядро по умолчанию от разработчиков linux ядра), <c>gentoo-sources</c> (ядро с
заплатками, улучшающими производительность).
</p>

<p>
Выберите и установите ядро, используя команду <c>emerge</c>. <c>USE="-doc"</c> 
требуется, чтобы на этом этапе избежать установки xorg-x11 или других зависимых 
пакетов. <c>USE="symlink"</c> для новой установки не требуется, но обеспечивает
правильное создание символьной ссылки <path>/usr/src/linux</path>:
</p>

<pre caption="Установка исходных кодов ядра">
# <i>USE="-doc symlink" emerge gentoo-sources</i>
</pre>

<p>
Просмотрев содержимое каталога <path>/usr/src</path>, вы увидите
символическую ссылку <path>linux</path>, которая указывает на каталог с
исходными кодами ядра. В данном случае, установленный исходный код ядра
указывает на <c>gentoo-sources-2.6.12-r10</c>. Ваша версия может отличаться, 
имейте это в виду.
</p>

<pre caption="Просмотр папки с исходными кодами ядра">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.12-gentoo-r10
</pre>

<p>
Теперь настало время настройки и компиляции ядра. Вы можете использовать
сценарий <c>genkernel</c>, который сформирует стандартное ядро, аналогичное
используемому на установочном компакт-диске. Однако сначала мы расскажем о
"ручной" настройке ядра, т.к. это наиболее подходящий способ
оптимизации системы.
</p>

<p>
Если вы хотите вручную настроить ядро, то переходите к разделу <uri
link="#manual">По умолчанию: ручная настройка</uri>. Если вы хотите
использовать <c>genkernel</c>, то читайте <uri link="#genkernel">Альтернатива:
использование genkernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>По умолчанию: ручная настройка</title>
<subsection>
<title>Введение</title>
<body>

<p>
Ручная настройка ядра считается одним из самых сложных вопросов для
пользователей Linux. Зато после настройки нескольких ядер вы и не вспомните,
что это было трудно ;)
</p>

<p>
Однако есть одна <e>истина</e>: когда вы запускаете ручную настройку ядра, вы 
должны знать аппаратную часть своего компьютера. Большую часть информации можно 
получить после установки пакета pciutils (<c>emerge pciutils</c>), который 
содержит <c>lspci</c>. После этого вы сможете использовать <c>lspci</c> внутри 
временной среды установки. Можете не обращать внимания на предупреждения, 
касающиеся <e>pcilib</e> (например: pcilib: cannot open /sys/bus/pci/devices 
[pcilib: не могу открыть /sys/bus/pci/devices]), которые выводит на экран 
<c>lspci</c>. В качестве альтернативы, вы можете запустить <c>lspci</c> <e>вне 
временной среды установки</e>. Результат тот же. Вы также можете запустить 
<c>lsmod</c> для просмотра модулей ядра, используемых установочным 
компакт-диском (это послужит хорошей подсказкой, на предмет того, какие 
параметры надо включить).
</p>

<p>
Теперь войдите в каталог с исходными кодами ядра и введите команду <c>make
menuconfig</c>. Этой командой вы вызовете конфигурационное меню, использующее
ncurses.
</p>

<pre caption="Вызов конфигурационного меню">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Перед вами появятся несколько секций настроек. Мы сначала перечислим пункты,
которые надо активировать (иначе Gentoo не будет работать, или будет работать
не так как надо без дополнительных настроек).
</p>

</body>
</subsection>
<subsection>
<title>Активация нужных пунктов</title>
<body>

<p>
Прежде всего разрешите использование разрабатываемых и экспериментальных
кодов/драйверов. Если этого не сделать, вы не увидите некоторых важных пунктов:
</p>

<pre caption="Выбор экспериментальных кодов/драйверов, основные настройки">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers"
General setup  ---&gt;
  [*] Support for hot-pluggable devices
</pre>

<p>
Удостоверьтесь, что все драйверы, необходимые в процессе загрузки системы
(например, SCSI-контроллеры и т.п.), собраны <e>внутри</e> ядра, а не как 
модули, иначе загрузка системы будет невозможна.
</p>

<p>
Далее выберите тип процессора, для которого будет собрано ядро:
</p>

<pre caption="Выбор правильного семейства процессоров">
Processor type and features ---&gt;
  <comment>(измените в соответствии с вашей системой)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family 
</pre>

<p>
Теперь войдите в <c>File Systems</c> и выберите поддержку всех нужных
файловых систем. <e>Не</e> компилируйте их как модули, иначе система Gentoo не
сможет смонтировать эти разделы. Также выберите <c>Virtual memory</c> и
<c>/proc file system</c>. Если вы используете ядро из ветви 2.4, то вам 
по-прежнему необходимо включить <c>/dev file system</c>, т.к. эти ядра не
поддерживают <c>udev</c>.
</p>

<pre caption="Выбор необходимых файловых систем">
<comment>(в ядрах версии 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   automatically mount /dev at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(в ядрах версии 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<comment>(включите поддержку одной или нескольких ФС, по вашей потребности)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Если ваш BIOS не поддерживает жесткие диски больших размеров, и вы ограничили
перемычками сообщаемый диском объем, то для получения доступа ко всему диску
нужно включить следующие параметры ядра:
</p>

<pre caption="Включение поддержки автогеометрии">
<comment>(только в ядре 2.4.x)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

<p>
Не забудьте включить поддержку режима DMA для ваших дисков:
</p>

<pre caption="Включение DMA">
Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
    [*]   Use PCI DMA by default when available
</pre>

<p>
Если вы используете PPPoE или dial-up для соединения с интернетом, вам нужно
включить в ядре следующие опции:
</p>

<pre caption="Выбор нужных драйверов PPPoE">
<comment>(в ядрах версии 2.4.х)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports
  
<comment>(в ядрах версии 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Два параметра сжатия данных не являются необходимыми, но и вреда от них тоже не
будет. То же относится и к опции <c>PPP over Ethernet</c> которая нужна только
для <c>rp-pppoe</c>, сконфигурированного для работы с PPPoE в ядре.
</p>

<p>
Если вам надо использовать сетевые карты, то не забудьте включить в ядре их
поддержку.
</p>

<p>
Если у вас CPU от Intel с поддержкой HyperTreading (tm), или же у вас
многопроцессорная система, то вам надо включить "Symmetric multi-processing
support":
</p>

<pre caption="Активация поддержки SMP">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<p>
Если вы используете USB устройства ввода (например мышь или клавиатуру), не
забудьте включить их поддержку:
</p>

<pre caption="Включение поддержки USB для устройств ввода">
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

<p>
Владельцы ноутбуков, которым нужна поддержка PCMCIA, <e>не</e> должны включать
PCMCIA драйверы в ядре, если они выбрали версию ядра 2.4. Более свежие драйверы
доступны в пакете <c>pcmcia-cs</c>, который мы установим позже. Пользователи же
ядра 2.6 должны включить драйверы PCMCIA в ядре.
</p>

<p>
На ряду с включением поддержки PCMCIA в ядре 2.6, не забывайте включить
поддержку PCMCIA моста вашей системы:
</p>

<pre caption="Поддержка PCMCIA для ядра ветки 2.6">
Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
     &lt;*&gt; PCCard (PCMCIA/CardBus) support
<comment>(если нужно, включите поддержку старых 16-битных карт PCMCIA. Чаще всего нужно.)</comment>
     &lt;*&gt;   16-bit PCMCIA support
     [*]   32-bit CardBus support
<comment>(выберите наиболее подходящий мост)</comment>
     --- PC-card bridges
     &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
     &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
     &lt;*&gt; i82092 compatible bridge support (NEW)
     &lt;*&gt; i82365 compatible bridge support (NEW)
     &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
Когда вы закончите настройку ядра, можете переходить к разделу <uri
link="#compiling">Компиляция и установка</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Компиляция и установка</title>
<body>

<p>
Теперь ваше ядро настроено, настало время его скомпилировать и установить.
Выйдете из конфигурационного меню и запустите процесс компиляции:
</p>

<pre caption="Компиляция ядра">
<comment>(для ядер версии 2.4)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(для ядер версии 2.6)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Когда ядро будет скомпилировано, скопируйте образ ядра в каталог
<path>/boot</path>. Используйте любое имя, кажущееся вам наиболее подходящим 
для ядра, но не забудьте его, так как оно нам потребуется позже при настройке 
загрузчика. Не забудьте заменить <path>&lt;версия-ядра&gt;</path> на
имя и версию своего ядра.
</p>

<pre caption="Установка ядра">
# <i>cp arch/i386/boot/bzImage /boot/&lt;версия-ядра&gt;</i>
</pre>

<p>
Теперь переходите к разделу <uri link="#kernel_modules">Модули ядра</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Альтернатива: использование genkernel</title>
<body>

<p>
Если вы читаете эти строки, значит вы хотите использовать наш сценарий
<c>genkernel</c> для настройки своего ядра.
</p>

<p>
Теперь когда исходные коды ядра установлены, настало время скомпилировать ядро,
используя сценарий <c>genkernel</c>. <c>genkernel</c> создаст ядро почти
идентичное тому, что используется на установочном компакт-диске. Т.е. при
использовании <c>genkernel</c> для сборки ядра, ваша система будет искать
новые устройства при каждой загрузке, подобно установочному компакт-диску.
Поскольку genkernel не требует ручной настройки ядра, это идеальное решение для
пользователей, которые чувствуют себя неуютно от одной мысли, что придется
компилировать ядро.
</p>

<p>
Рассмотрим как использовать genkernel. Сначала выполним emerge genkernel:
</p>

<pre caption="Установка genkernel">
# <i>emerge genkernel</i>
</pre>

<p>
Далее, если вы собираетесь использовать ядро ветви 2.6, скопируйте
конфигурационный файл ядра, используемый установочным компакт-диском, в
каталог, который genkernel просматривает на предмет конфигурации по умолчанию:
</p>

<pre caption="Копирование конфигурационного файла ядра с установочного диска">
<comment>(только если вы желаете собрать ядро 2.6.х)</comment>
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

<p>
Теперь соберем ядро, запустив <c>genkernel all</c>. Так как <c>genkernel</c> 
будет собирать ядро, поддерживающее почти все оборудование, этот процесс может 
занять приличное время.
</p>

<p>
Если на вашем загрузочном (boot) разделе не используется ext2 или ext3, то вам 
придется вручную настроить ядро, запустив <c>genkernel --menuconfig all</c> и 
добавить поддержку вашей файловой системы <e>в</e> ядро (т.е. <e>не</e> 
модулем). Тем, кто используют EVMS2 или LVM2, нужно добавить параметр командной 
строки <c>--evms2</c> или <c>--lvm2</c>.
</p>

<pre caption="Запуск genkernel">
# <i>genkernel all</i>
</pre>

<p>
Когда <c>genkernel</c> завершит свою работу, будет создано ядро, полный набор
модулей и <e>начальный корневой диск</e> (initrd). Ядро и initrd мы будем 
использовать в процессе настройки загрузчика системы, которая описывается далее 
в этом руководстве. Запишите имена ядра и начального корневого диска так как 
они нам понадобятся при редактировании конфигурационного файла загрузчика. 
Сразу после загрузки для автоматического определения устройств будет запущен 
initrd (точно так же как и в установочном компакт-диске), до "настоящей" 
загрузки вашей системы.
</p>

<pre caption="Проверяем название созданного ядра и initrd">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Теперь давайте сделаем нашу систему еще ближе к установочному компакт-диску - 
соберем <c>coldplug</c>. В то время как initrd автоматически находит
оборудование, необходимое для загрузки системы, <c>coldplug</c> автоматически
определяет все остальное оборудование. Установим <c>coldplug</c>, командой: 
</p>

<pre caption="Установка и активация coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Модули ядра</title>
<subsection>
<title>Конфигурация модулей</title>
<body>

<p>
Вы должны перечислить модули, которые следует загружать автоматически, в файле
<path>/etc/modules.autoload.d/kernel-2.4</path> (или <path>kernel-2.6</path>).
Также, при желании, можно сообщить модулям некоторые дополнительные параметры.
</p>

<p>
Для просмотра всех доступных модулей запустите команду <c>find</c>, заменив
"&lt;kernel version&gt;" на версию ядра, которое вы только что собрали:
</p>

<pre caption="Просмотр доступных модулей">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Например, если вы хотите автоматически загружать модуль <c>3c59x.o</c>,
отредактируйте файл <path>kernel-2.4</path> или <path>kernel-2.6</path> и
пропишите туда имя модуля.
</p>

<pre caption="Редактируем /etc/modules.autoload.d/kernel-2.4">
<comment>(пример для ядра 2.4.x)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 или kernel-2.6">
3c59x
</pre>

<p>
Теперь для продолжения установки можно перейти к разделу <uri
link="?part=1&amp;chap=8">Настройка системы</uri>.
</p>

</body>
</subsection>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 3.10-r1
target-date: 2006-01-23
source-cvs-revision: 1.60
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Alexey Chumakov [achumakov@gentoo.org]
-->
