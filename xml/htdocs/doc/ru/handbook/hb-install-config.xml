<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/hb-install-config.xml,v 1.1 2005/02/25 18:22:03 sergey Exp $ -->
<!-- REV: 1.55 -->

<sections>
<version>1.51</version>
<date>2004-12-26</date>

<section>
<title>Информация о файловой системе</title>
<subsection>
<title>Что такое fstab?</title>
<body>

<p>В Linux, все разделы используемые системой должны быть перечислены в
<path>/etc/fstab</path>. Этот файл содержит: точки монтирования разделов (где
разделы видны в файловой системе),
информацию о том, как они будут монтироваться (специальные опции) и когда (автоматически или нет, могут ли пользователи их монтировать 
или нет, и т.д.).
</p>

</body>
</subsection>
<subsection>
<title>Создание /etc/fstab</title>
<body>

<p>
<path>/etc/fstab</path> имеет специальный синтаксис. Каждая строка содержит шесть полей, разделенных разделителем (пробел(ы), табуляция или их комбинация).
Каждое поле имеет свое собственное назначение:
</p>

<ul>
<li>
  Первое поле описывает <b>раздел</b> (путь к устройству)
</li>
<li>
  Второе поле задает <b>точку монтирования</b> в которую раздел будет смонтирован
</li>
<li>
  Третье поле задает тип <b>файловой системы</b>.</li>
<li>
  Четвертое поле задает <b>опции монтирования</b> используемые <c>mount</c> при
  монтировании раздела. Т.к. каждая файловая система имеет свои опции,
  почитайте документацию к команде mount (<c>man mount</c>).
  Опции монтирования разделяются запятыми.
</li>
<li>
  Пятое поле используется <c>dump</c> и определяет нуждается ли раздел в 
  <b>дампировании</b> или нет. Вы можете установить его в <c>0</c> (ноль).
</li>
<li>
  Шестое поле используется <c>fsck</c> и определяет должна ли файловая система
  <b>проверяться</b> если система была выключена не должным образом. Файловая система root
  должна иметь значение <c>1</c>, в то время как другие должны быть <c>2</c> (или <c>0</c> если
  прверка файловой системы не нужна).
</li>
</ul>

<p>
Файл <path>/etc/fstab</path>, предоставляемы Gentoo по умолчание, <e>не является
верным fstab файлом</e>, так что  запустите <c>nano</c> (или любой другой
редактор) чтобы создать <path>/etc/fstab</path>:
</p>

<pre caption="Открытие /etc/fstab">
# <i>nano -w /etc/fstab</i>
</pre>

<p>
Рассмотрим опции задаваемые для  раздела <path>/boot</path>.
Это только пример и если ваша архитектура не требует раздела 
<path>/boot</path> (например <b>PPC</b>), не копируйте его дословно.
</p>

<p>
Для примера возьмем архитектуру x86, раздел <path>/boot</path> возьмем с устройства
<path>/dev/hda1</path>, с файловой системой <c>ext2</c>. Раздел должен
проверяться при загрузке. Итак, мы должны написать следующее:
</p>

<pre caption="Пример строки /boot в /etc/fstab">
/dev/hda1   /boot     ext2    noauto        1 2
</pre>

<p>
Если, в целях безопасности, вы не хотите монтировать <path>/boot</path>
автоматически, замените <c>defaults</c> на <c>noauto</c>. В этом случае вам надо
будет вручную монтировать раздел каждый раз, когда он будет нужен.
</p>

<p>
Теперь, чтобы улучшить быстродействие, большинство пользователей хотело бы добавить опцию <c>noatime</c>
для монтирования, которая приведет к более быстрой работе системе, т.к. не будет
регистрироваться время доступа к файлам (как правило это все равно не нужно):
</p>

<pre caption="Улучшенная строка /boot для /etc/fstab">
/dev/hda1   /boot     ext2    defaults,noatime    1 2
</pre>

<p>
Если продолжать дальше, то надо добавить еще три строки (для
<path>/boot</path>, <path>/</path> и swap-раздела):
</p>

<pre caption="Еще три строчки /etc/fstab ">
/dev/hda1   /boot     ext2    defaults,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1
</pre>

<p>
Ну и наконец добавим еще строки для <path>/proc</path>, <c>tmpfs</c>
(обязательно) и для вашего CD-ROM (и конечно, если у вас есть еще разделы, то их тоже можно добавить):
</p>

<pre caption="Пример полного /etc/fstab">
/dev/hda1   /boot     ext2    defaults,noatime      1 2
/dev/hda2   none      swap    sw               		0 0
/dev/hda3   /         ext3    noatime          		0 1

none        /proc     proc    defaults          	0 0
none        /dev/shm  tmpfs   nodev,nosuid,noexec   0 0

/dev/cdroms/cdrom0    /mnt/cdrom    auto      noauto,user    0 0
</pre>

<p>
<c>auto</c> задает автоматическое  <c>определение</c> файловой системы (рекумендуется для 
сменных носителей т.к. они могут содержать разные файловые системы), а 
<c>user</c> разрешает монтировать CD не root-пользователям.
</p>

<p>
Теперь используем вышенаписанный пример для создания <path>/etc/fstab</path>. Если вы являетесь
SPARC-пользователем, то должны еще добавить такую строчку к <path>/etc/fstab</path>:
</p>

<pre caption="Добавление файловой системы openprom к /etc/fstab">
none        /proc/openprom  openpromfs    defaults      0 0
</pre>

<p>
Емли вам нужна <c>usbfs</c>, добавьте следующие строчки <path>/etc/fstab</path>:
</p>

<pre caption="Добавление файловой системы usbfs к /etc/fstab">
none        /proc/bus/usb   usbfs         defaults      0 0
</pre>

<p>
Проверьте еще раз ваш <path>/etc/fstab</path>, сохраните и выйдите для продолжения.
</p>

</body>
</subsection>
</section>
<section>
<title>Сетевая информация</title>
<subsection>
<title>Имя хоста, домена и т.д.</title>
<body>

<p>
Один из вопросов, которые должен решить пользователь - это какое будет имя компьютера.
Он кажется очень простым, но <e>многие</e> пользователи затрудняются дать 
имя для своего Linux-pc. Дабы ускорить этот процес дайте ему любое имя, т.к. впоследствии его можно будет 
изменить. Например вы можете назвать свою систему -
<c>tux</c>,а  домен - <c>homenetwork</c>. 
</p>

<p>
Мы будем использовать эти значения в последующих примерах. Сначала установим имя хоста:
</p>

<pre caption="Установка имени хоста">
# <i>echo tux &gt; /etc/hostname</i>
</pre>

<p>
Затем установим имя домена:
</p>

<pre caption="Установка имени домена">
# <i>echo homenetwork &gt; /etc/dnsdomainname</i>
</pre>

<p>
Если у вас NIS-домен (если вы не знаете, что это такое - значит у вас его нет), 
вам также надо задать его имя:
</p>

<pre caption="Установка имени NIS-домена">
# <i>echo nis.homenetwork &gt; /etc/nisdomainname</i>
</pre>

<p>
Теперь добавьте скрипт <c>domainname</c> к уровню загрузки по умолчанию:
</p>

<pre caption="Добавляем domainname в default runlevel">
# <i>rc-update add domainname default</i>
</pre>
</body>
</subsection>
<subsection>
<title>Настройка сети</title>
<body>

<p>
Прежде чем кричать "Эй, мы это уже делали"-, помните, что
то что мы делали раньше, относлось к сети которую мы использовали для инсталяции Gentoo.
Теперь же мы настроим сеть для постоянного использования.
</p>

<p>
Вся информация о сети хранится в <path>/etc/conf.d/net</path>. В нем
используется не очень понятный синтаксис. Но не бойтесь - мы все вам объясним:)
</p>

<p>
Сначала откройте <path>/etc/conf.d/net</path> в вашем любимом редакторе (в этом примере используется <c>nano</c>
):
</p>

<pre caption="Открытие  /etc/conf.d/net для редактирования">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
Сперва найдем переменную <c>iface_eth0</c>. У нее будет такой синтаксис:
</p>

<pre caption="Синтаксис iface_eth0">
iface_eth0="<i>&lt;ваш IP-адрес&gt;</i> broadcast <i>&lt;ваш broadcast-адрес&gt;</i> netmask <i>&lt;ваша маска сети&gt;</i>"
</pre>

<p>
Если вы используете  DHCP (автоматическое определение IP), вы должны установить <c>iface_eth0</c>
равной <c>dhcp</c>. Если вы используете rp-pppoe (например для ADSL) установите
переменную рвной <c>up</c>. Однако, если вам нужно установить сеть вручную и вы
не знакомы со всеми терминами, пожалуйста прочтите раздел <uri
link="?part=1&amp;chap=3#network_term">Понимание сетевой
терминологии</uri> если еще этого не сделали.
</p>

<p>
Итак приведем три примера; первый использует DHCP, второй использует статический IP
(192.168.0.2) с маской 255.255.255.0, broadcast-адресом 192.168.0.255 и шлюзом
192.168.0.1 и третий для rp-pppoe:
</p>

<pre caption="Пример /etc/conf.d/net">
<comment>(Для  DHCP:)</comment>
iface_eth="dhcp"
<comment># Нетокоторые сетевые администраторы требуют использования</comment>
<comment># имени хоста и домена, предоставленных DHCP сервером.</comment>
<comment># В этом случае используйте</comment>
<comment># Это перепишет ваши настройки имени хоста и домена</comment>
dhcpcp_eth0="-HD"
<comment># Если вы собираетесь использовать NTP для синхронизации часов, то</comment>
<comment># испольуйте опцию -N, чтобы dhcpcd не переписал файл /etc/ntp.conf</comment>
dhcpcd_eth0="-N"

<comment>(Для статического IP:)</comment>
iface_eth0="192.168.0.2 broadcast 192.168.0.255 netmask 255.255.255.0"
gateway="eth0/192.168.0.1"

<comment>(Для rp-pppoe)</comment>
iface_eth0="up"
</pre>

<p>
Если у вас несколько сетевых интерфейсов, создайте дополнительные переменные <c>iface_eth</c>,
например <c>iface_eth1</c>, <c>iface_eth2</c> и т.д. Переменная <c>gateway</c> не должна 
писаться, т.к. в компьютере может быть только один шлюз.
</p>

<p>
Теперь сохраним этот файл и выйдем для продолжения.
</p>

</body>
</subsection>
<subsection>
<title>Автоматический запуск сети при загрузке</title>
<body>

<p>
Чтобы активировать ваши сетевые интерфейсы при загрузке, вы должны установить
добавить их runlevel 'default'. Если у вас PCMCIA-интерфейс вы можете пропустить это действие, т.к.
PCMCIA-интерфейсы запускаются с помощью PCMCIA скрипта.
</p>

<pre caption="Добавление net.eth0 в runlevel default">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
Если у вас несколько сетевых интерфейсов, то вы должны создать соответсвующий скрипт инициализации для 
<path>net.eth1</path>, <path>net.eth2</path> и т.д. Для этого можно использовать
<c>ln</c>:
</p>

<pre caption="Создание дополнительного скрипта инициализации">
# <i>cd /etc/init.d</i>
# <i>ln -s net.eth0 net.eth1</i>
# <i>rc-update add net.eth1 default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Запись сетевой информации.</title>
<body>

<p>
Теперь надо сообщить Linux о вашей сети. Это определяется в
<path>/etc/hosts</path> и сдесь же можно задать имена хостов  для IP-адресов,
которые не были заданы в сервере имен. Например, если ваша внутренняя
сеть состоит из трех PC названных <c>jenny</c> (192.168.0.5), 
<c>benny</c> (192.168.0.6) и <c>tux</c> (эта система) вы должны открыть
<path>/etc/hosts</path> и задать такие переменные:
</p>

<pre caption="Открытие /etc/hosts">
# <i>nano -w /etc/hosts</i>
</pre>

<pre caption="Задание информации о сети">
127.0.0.1     localhost
192.168.0.5   jenny
192.168.0.6   benny
192.168.0.7   tux.homenetwork tux
</pre>

<p>
Если ваша система одна единственная (или сервер имен обрабатывает все имена) хватит и одной строки:
</p>

<pre caption="/etc/hosts для 'одинокого' или полностью интегрированного PC">
127.0.0.1     localhost   tux
</pre>

<p>
Сохраните и выйдите для продолжения.
</p>

<p>
Если у вас не PCMCIA, вы можете перейти к разделу <uri
link="#doc_chap3">Системная информация</uri>. PCMCIA-пользователи должны прочесть
следущий разделк о PCMCIA.
</p>

</body>
</subsection>
<subsection>
<title>Опционально: Получение рабочей PCMCIA</title>
<body>

<note>
pcmcia-cs доступен только для следующих платформ: x86, amd64 и ppc.
</note>

<p>
PCMCIA-пользователи сначала должны установить пакет <c>pcmcia-cs</c>. Это
включает в себя и пользователей использующих ядро 2.6, хотя они и не будут
использовать драйверы из этого пакета. Чтобы не ставить сейчас xorg-x11
установить <c>USE="-X"</c>:
</p>

<pre caption="Установка pcmcia-cs">
# <i>USE="-X" emerge pcmcia-cs</i>
</pre>

<p>
Когда <c>pcmcia-cs</c> установится, добавьте <c>pcmcia</c> в runlevel
<e>default</e>:
</p>

<pre caption="Добавление pcmcia">
# <i>rc-update add pcmcia default</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Системная информация</title>
<subsection>
<title>Пароль root'а</title>
<body>

<p>
Сначала установим пароль для root'a:
</p>

<pre caption="Ставим root пароль">
# <i>passwd</i>
</pre>

<p>
Если вы хотите иметь возможность подлючиться через серийную консоль, добавьте
<c>tts/0</c> в <path>/etc/securetty</path>:
</p>

<pre caption="Добавляем tts/0 в /etc/securetty">
# <i>echo "tts/0" &gt;&gt; /etc/securetty</i>
</pre>

</body>
</subsection>
<subsection>
<title>Системная информация</title>
<body>

<p>
Gentoo использует <path>/etc/rc.conf</path> для общих  системных настроек.
Откройте <path>/etc/rc.conf</path> и насладитесь комментариями в этом файле :)
</p>

<pre caption="Открытие  /etc/rc.conf">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
Как вы наверно заметили, этот файл хорошо прокомментирован, что поможет вам 
в настройке необходимых переменных. Будьте осторожны при установке
<c>KEYMAP</c>, если поставите ее неправильно, то можете получить странные
результаты при попытке вести текст с клавиатуры.
</p>

<note>
Пользователям USB- <b>SPARC</b> систем и <b>SPARC</b>-клонов, возможно надо
выбрать i386 раскладку (например "us") вместо "sunkeymaps".
</note>

<p>
<b>PPC</b> как правило использует x86 раскладки. Если вы хотите использовать ADB
раскладку при загрузке, должны включить ADB код в ядре и установить mac/ppc
раскладку в <path>rc.conf</path>.
</p>

<p>
Когда вы закончите настраивать <path>/etc/rc.conf</path>, сохраните его, и
продолжайте читать раздел <uri link="?part=1&amp;chap=9">Установка необходимых
системых утилит</uri>.
</p>


</body>
</subsection>
</section>
</sections>
