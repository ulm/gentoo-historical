<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-x86-disk.xml,v 1.4 2006/03/27 09:29:19 achumakov Exp $ -->


<sections>

<version>2.5</version>
<date>2006-01-01</date>

<section>
<title>Общие сведения о блочных устройствах</title>
<subsection>
<title>Блочные устройства</title>
<body>

<p>
Мы достаточно подробно рассмотрим аспекты работы с дисками в Gentoo Linux 
и Linux вообще, включая файловые системы, разделы и блочные устройства. 
Позже, когда вы уже освоитесь с дисками и файловыми системами, мы проведем вас 
через процесс настройки разделов и файловых систем для установки Gentoo Linux.
</p>

<p>
Для начала, давайте познакомимся с <e>блочными устройствами</e>. Наиболее 
известно, вероятно, блочное устройство, соответствующее в системе Linux первому 
IDE-диску, а именно <path>/dev/hda</path>. Если в вашей системе используются 
диски SCSI или SATA, вашим первым жестким диском будет <path>/dev/sda</path>.
</p>

<p>
Подобные блочные устройства представляют собой абстрактный интерфейс к диску. 
Прикладные программы могут использовать их для обращения к дискам, не 
беспокоясь, к какому типу они принадлежат: IDE, SCSI или какому-то еще. 
Программы могут просто обращаться к накопителю, как к набору смежных 
512-байтных блоков с произвольным доступом.
</p>

</body>
</subsection>
<subsection>
<title>Разделы</title>
<body>

<p>
Хотя теоретически для размещения системы Linux можно использовать весь диск, 
это почти никогда не делают на практике. Вместо этого большое физическое 
блочное устройство разбивают на меньшие блочные устройства, более удобные для 
обращения. В архитектуре x86 они называются <e>разделами</e>. 
</p>

<p>
Существуют разделы трех типов: <e>первичные</e> (primary), <e>расширенные</e> 
(extended) и <e>логические</e> (logical).
</p>

<p>
<e>Первичный</e> раздел &mdash; это раздел, информация о котором хранится в MBR
(Master Boot Record &mdash; главной загрузочной записи). Так как MBR очень мала
(512 байт), можно определять всего четыре первичных раздела (например, от 
<path>/dev/hda1</path> до <path>/dev/hda4</path>). 
</p>

<p>
<e>Расширенный</e> раздел &mdash; это особый первичный раздел (имеется
в виду, что расширенный раздел должен быть одним из четырех возможных первичных
разделов), в котором содержатся другие разделы. Таких разделов изначально
не существовало, но введение разделов этого типа помогло расширить существующую 
схему разметки без потери совместимости, как только четырех разделов перестало 
хватать.
</p>

<p>
<e>Логический</e> раздел &mdash; это раздел внутри расширенного раздела. Его
определение находится не в MBR, а внутри расширенного раздела.
</p>

</body>
</subsection>
<subsection>
<title>Дополнительные возможности</title>
<body>

<p>
На установочном компакт-диске для х86 предусмотрена поддержка EVMS и LVM2. 
Использование EVMS и LVM2 повышает гибкость разбиения диска. В ходе установки 
мы остановимся на &laquo;обычных&raquo; разделах, но стоит запомнить, что EVMS 
и LVM2 тоже поддерживаются. 
</p>

</body>
</subsection>
</section>
<section>
<title>Разработка схемы разбиения диска</title>
<subsection>
<title>Схема разбиения по умолчанию</title>
<body>

<p>
Если вам не интересно заниматься разработкой схемы для вашей системы, можно 
воспользоваться схемой, используемой в этой книге:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Файловая система</th>
  <th>Размер</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32МБ</ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512МБ</ti>
  <ti>раздел подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>оставшаяся часть диска</ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Если вам интересно узнать, какого размера должны быть разделы, и сколько их вам 
вообще может потребоваться, читайте дальше. В противном случае приступайте к 
созданию разделов, описанному в главе <uri link="#fdisk">Использование fdisk 
для создания разделов</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Сколько и каких?</title>
<body>

<p>
Количество разделов очень сильно зависит от назначения системы. Например, если 
у вас много пользователей, вам, скорее всего, захочется отделить 
<path>/home</path> для повышения безопасности и упрощения резервного 
копирования. Если вы устанавливаете Gentoo в роли почтового сервера, следует 
отделить <path>/var</path>, т.к. вся почта хранится там. Затем, правильно 
выбрав файловую систему, вы добьетесь максимальной производительности. 
Для игровых серверов потребуется отдельный раздел <path>/opt</path>,
так как большинство программ для их работы устанавливается туда. Причины
выделения те же, что и для <path>/home</path>: безопасность и резервное 
копирование. Определенно потребуется побольше места для <path>/usr</path>:
не только потому, что там хранится большинство приложений, а еще из-за того, 
что только дерево Portage, не считая размещенных в нем архивов с исходными 
кодами, занимает около 500 МБ.
</p>

<p>
Как видно, все зависит от ваших целей. Наличие отдельных разделов или
томов имеет следующие плюсы:
</p>

<ul>
<li>
  для каждого раздела или тома можно выбрать наиболее подходящую файловую 
  систему 
</li>
<li>
  свободное место во всей системе не кончится &laquo;вдруг&raquo; из-за того, 
  что одна-единственная сбойная программа постоянно записывает файлы на раздел 
  или том 
</li>
<li>
  необходимая проверка файловых систем будет занимать меньше времени, т.к. 
  проверка разных разделов может выполняться параллельно (еще больший 
  выигрыш времени дает использование нескольких физических дисков)
</li>
<li>
  можно повысить безопасность системы, монтируя часть разделов в режиме 
  read-only (только для чтения), nosuid (игнорируется бит setuid),
  noexec (игнорируется бит исполнения) и т.д.
</li>
</ul>

<p>
Однако у создания множества разделов есть один большой минус: при неправильной
настройке можно получить систему, в которой много свободного места на одном
разделе, и совершенно нет на другом. Кроме того, на дисках SCSI и SATA можно 
создавать не более 15 разделов.
</p>

<p>
Для примера мы покажем разбиение диска объемом 20 ГБ, используемого в 
демонстрационном ноутбуке (с веб-сервером, почтовым сервером, средой Gnome и 
т.д.):
</p>

<pre caption="Пример файловой системы">
$ <i>df -h</i>
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;не смонтирован&gt;
<comment>(свободное место для будущего использования: 2 ГБ)</comment>
</pre>

<p>
Раздел <path>/usr</path>, как видим, почти заполнен (использовано 83%),
но когда все программы установлены, <path>/usr</path> растет не слишком быстро.
Хотя отведение нескольких гигабайт дискового пространства для <path>/var</path> 
может показаться расточительством, помните, что Portage по умолчанию использует 
этот раздел для компиляции пакетов. Если вы захотите удержать <path>/var</path> 
в рамках более разумного размера, например, 1ГБ, вам потребуется изменить
переменную <c>PORTAGE_TMPDIR</c> в <path>/etc/make.conf</path>, чтобы она 
указывала на раздел, где достаточно свободного места для компиляции чрезвычайно 
больших пакетов, таких как OpenOffice. 
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Использование fdisk для создания разделов</title>
<subsection>
<body>

<p>
В следующих разделах описывается, как разбить диск в соответствии с примерной 
схемой, описанной ранее, а именно:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>раздел подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Эту схему вы можете изменять по своему усмотрению.
</p>

</body>
</subsection>
<subsection>
<title>Просмотр текущей схемы разбиения диска</title>
<body>

<p>
<c>fdisk</c> &mdash; это популярная и очень мощная утилита для создания 
разделов на ваших дисках. Запустите <c>fdisk</c>, указав свой диск в
качестве параметра (в примере мы используем <path>/dev/hda</path>):
</p>

<pre caption="Запуск fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
После запуска <c>fdisk</c> выдаст такое приглашение:
</p>

<pre caption="Приглашение fdisk">
Command (m for help): 
</pre>

<p>
Нажмите <c>p</c>, чтобы вывести текущую схему разбиения диска:
</p>

<pre caption="Пример схемы разделов диска">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
В данном случае на диске выделено семь разделов Linux (для которых в графе 
&laquo;System&raquo; указано &laquo;Linux&raquo;) и один раздел подкачки (в 
списке отмечен как &laquo;Linux swap&raquo;).
</p>

</body>
</subsection>
<subsection>
<title>Удаление всех разделов</title>
<body>

<p>
Сначала удалим с диска все существующие разделы. Для удаления раздела 
введите <c>d</c>. Например для удаления существующего <path>/dev/hda1</path>:
</p>

<pre caption="Удаление раздела">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Будет запланировано удаление раздела. Он больше не будет отображаться при вводе
<c>p</c>, но фактически не будет удален до тех пор, пока вы не сохраните 
внесенные изменения. Если вы ошиблись и хотите прервать разбиение без 
сохранения изменений, немедленно введите <c>q</c> и нажмите ENTER; тогда ваш 
раздел сохранится в неизменности.
</p>

<p>
Теперь, если вы действительно собираетесь удалить все разделы в своей системе, 
вводите <c>p</c> для вывода оставшихся разделов, затем <c>d</c> и номер 
удаляемого раздела до тех пор, пока они не кончатся. В итоге вы получите пустую 
таблицу разделов: 
</p>

<pre caption="Пустая таблица разделов">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Теперь, когда мы очистили таблицу разделов, хранящуюся в памяти, настало время
создавать разделы. Мы воспользуемся примерной схемой разбиения, описанной выше.
Естественно, не следуйте этим инструкциям буквально, если вам не нужна таблица 
разделов, идентичная нашей! 
</p>

</body>
</subsection>
<subsection>
<title>Создание загрузочного раздела</title>
<body>

<p>
Сначала создадим маленький загрузочный раздел. Введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы выбрать первичный раздел, и
<c>1</c> для указания первого первичного раздела. На вопрос о первом цилиндре
нажмите ввод. На вопрос о последнем цилиндре введите <c>+32M</c>, чтобы создать 
раздел размером 32МБ:
</p>

<pre caption="Создание загрузочного раздела">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(нажмите ввод)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Теперь, введя <c>p</c>, вы должны увидеть следующую распечатку:
</p>

<pre caption="Созданный загрузочный раздел">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Нам необходимо сделать этот раздел загружаемым. Введите <c>a</c>, чтобы
включить признак загрузки с раздела, и выберите <c>1</c>. Введя
<c>p</c> заново, вы увидите, что в столбце &laquo;boot&raquo; появился знак 
<path>*</path>.
</p>

</body>
</subsection>
<subsection>
<title>Создание раздела подкачки</title>
<body>

<p>
Теперь создадим раздел подкачки. Для этого введите <c>n</c> (создание нового 
раздела), затем <c>p</c> для выбора первичного раздела. Потом введите <c>2</c>, 
чтобы создать второй первичный раздел, в нашем случае <path>/dev/hda2</path>. 
На вопрос о первом цилиндре просто нажмите ввод. На вопрос о последнем &mdash; 
ответьте <c>+512M</c>, чтобы создать раздел размером 512МБ. Сделав это, введите 
<c>t</c> для указания типа раздела,  <c>2</c>, для выбора только что созданного 
раздела, и <c>82</c>, чтобы установить тип раздела &laquo;Linux Swap&raquo;. 
При вводе <c>p</c> по завершении этих действий, таблица разделов должна 
выглядеть примерно так:
</p>

<pre caption="Список разделов после создания раздела подкачки">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Создание корневого раздела</title>
<body>

<p>
Наконец, давайте создадим корневой раздел. Для этого введите <c>n</c> (создание 
нового раздела), затем <c>p</c> (первичный раздел). После этого введите 
<c>3</c> для создания третьего первичного раздела, в нашем случае 
<path>/dev/hda3</path>. На вопрос о первом цилиндре нажмите ввод. На вопрос о 
последнем &mdash; также нажмите ввод, чтобы создать раздел, занимающий все 
оставшееся свободное место на диске. По завершении этих шагов, при вводе 
<c>p</c> должна выводиться таблица разделов, подобная этой:
</p>

<pre caption="Список разделов после создания корневого раздела">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Сохранение схемы разбиения</title>
<body>

<p>
Для сохранения схемы разбиения и выхода из <c>fdisk</c>, введите <c>w</c>.
</p>

<pre caption="Сохранение и выход из fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Теперь, создав все разделы, перейдем к <uri link="#filesystems">созданию
файловых систем</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Создание файловых систем</title>
<subsection>
<title>Введение</title>
<body>

<p>
Разделы созданы, настало время разместить на них файловые системы. Если вам
безразлично, какую файловую систему использовать, и вы вполне довольны той, 
что мы используем в книге по умолчанию, переходите к <uri 
link="#filesystems-apply">размещению файловой системы в разделе</uri>.  
Если нет, продолжайте чтение, чтобы разузнать о существующих файловых 
системах...
</p>

</body>
</subsection>
<subsection>
<title>Файловые системы?</title>
<body>

<p>
Ядро Linux поддерживает различные файловые системы. Мы расскажем о самых 
распространенных в Linux: ext2, ext3, ReiserFS, XFS и JFS.
</p>

<p>
<b>ext2</b> &laquo; испытанная файловая система Linux, в которой нет 
средств журналирования метаданных. Поэтому ее обычная проверка при запуске 
может быть очень долгой. Сегодня есть довольно много журналируемых файловых 
систем нового поколения, целостность которых проверяется очень быстро, и 
поэтому обычно есть смысл использовать их. Журналируемые файловые системы
позволяют избежать долгих задержек при запуске, когда состояние файловой 
системы неустойчиво.
</p>

<p>
<b>ext3</b> &mdash; это журналируемая версия ext2, где есть журналирование 
метаданных для быстрого восстановления, а также другие режимы, такие как 
полное и упорядоченное журналирование данных. ext3 &mdash; очень хорошая и 
надежная файловая система. В ней есть дополнительная функция индексации через 
хэшированные сбалансированные деревья (b-tree), что в большинстве случаев 
обеспечивает высокую  скорость. Такую индексацию можно включить, добавив к 
команде <c>mke2fs</c> параметр <c>-O dir_index</c>. Короче говоря, ext3 &mdash; 
превосходная файловая система.
</p>

<p>
<b>ReiserFS</b> &mdash; файловая система, построенная на B*-деревьях. У нее очень 
хорошая скорость, и она намного (часто в 10-15 раз) быстрее ext2 и ext3 при 
работе с маленькими файлами (менее 4k). ReiserFS также великолепно 
масштабируется; в ней есть средства журналирования. На дату выхода ядра 2.4.18, 
ReiserFS признана стабильной и пригодной как для систем общего назначения, так 
и для крайних случаев типа создания больших томов, использования множества 
маленьких файлов, гигантских файлов или каталогов с десятками тысяч файлов.
</p>

<p>
<b>XFS</b> &mdash; это файловая система с журналированием метаданных и 
дополнительными средствами, оптимизированными для максимальной 
масштабируемости. Ее применение рекомендуется только в Linux-системах с 
высококлассными дисками SCSI или с оптическим подключением (fibre-channel), при 
наличии источников бесперебойного питания. Из-за того, что XFS выполняет очень 
агрессивное промежуточное кэширование в оперативной памяти, при внезапном 
отключении питания очень вероятна потеря изрядного объема данных неверно 
спроектированными программами (не принимающими адекватные меры предосторожности
при записи файлов на диск, а таких довольно много).
</p>

<p>
<b>JFS</b> &mdash; высокопроизводительная журналируемая файловая система 
производства IBM. Она лишь недавно стала пригодной для широкого применения, и 
пока слишком мало данных, чтобы сказать что-то хорошее или плохое о ее общей 
стабильности.
</p>
                                                          	
</body>
</subsection>
<subsection id="filesystems-apply">
<title>Размещение файловой системы в разделе</title>
<body>

<p>
Для создания каждого типа файловой системы раздела или тома существуют 
специальные утилиты:
</p>

<table>
<tr>
  <th>Файловая система</th>
  <th>Команда создания</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Например, чтобы у загрузочного раздела (<path>/dev/hda1</path> в наших
примерах) была файловая система ext2, а у корневого раздела 
(<path>/dev/hda3</path> в наших примерах) &mdash; ext3, требуется выполнить:
</p>

<pre caption="Создание файловых систем разделов">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
А теперь сами создайте файловые системы на своих только что созданных разделах
(логических томах).
</p>

</body>
</subsection>
<subsection>
<title>Подключение раздела подкачки</title>
<body>

<p>
<c>mkswap</c> &mdash; команда, используемая для инициализации разделов 
подкачки:
</p>

<pre caption="Создание признака раздела подкачки">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Для подключения раздела подкачки пользуйтесь <c>swapon</c>:
</p>

<pre caption="Подключение раздела подкачки">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Теперь командами, приведенными выше, создайте и подключите раздел подкачки в
своей системе. 
</p>

</body>
</subsection>
</section>
<section>
<title>Монтирование</title>
<body>

<p>
Теперь, когда разделы созданы и файловые системы размещены, настало время
смонтировать (подключить к системе) эти разделы. Используйте команду 
<c>mount</c>. Не забудьте создать для каждого раздела соответствующие каталоги
монтирования. Например, смонтируем корневой и загрузочный разделы: 
</p>

<pre caption="Монтирование разделов">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Если вы хотите разместить <path>/tmp</path> в отдельном разделе, не забудьте
изменить права доступа к этому каталогу после монтирования: <c>chmod 1777
/mnt/gentoo/tmp</c>. Это также относится к <path>/var/tmp</path>.
</note>

<p>
Нам также потребуется смонтировать файловую систему proc (виртуальный интерфейс 
ядра) в каталог <path>/proc</path>. Но сначала надо разместить нужные файлы
в разделах.
</p>

<p>
Переходите к <uri link="?part=1&amp;chap=5">установке установочных файлов 
Gentoo</uri>.
</p>

</body>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 2.5-r2
target-date: 2006-03-27
source-cvs-revision: 1.25
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Alexey Chumakov [achumakov@gentoo.org]
-->
