<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-x86-disk.xml,v 1.3 2006/01/23 21:37:40 achumakov Exp $ -->


<sections>

<version>2.5</version>
<date>2006-01-01</date>

<section>
<title>Общие сведения о блочных устройствах</title>
<subsection>
<title>Блочные устройства</title>
<body>

<p>
Мы достаточно подробно рассмотрим аспекты работы с дисками в Gentoo Linux 
и Linux вообще, включая файловые системы, разделы и блочные устройства. 
Позже, когда вы уже разберетесь с вводом-выводом на диск и файловыми системами,
мы поможем вам с настройкой разделов и файловых систем для установки Gentoo 
Linux.
</p>

<p>
Для начала давайте познакомимся с <e>блочными устройствами</e>. Наиболее 
известным блочным устройством, вероятно, является устройство, представляющее
собой первый IDE диск в системе Linux, и известное как <path>/dev/hda</path>.
Если в вашей системе используются диски SCSI или SATA, тогда ваш первый жесткий
диск будет именоваться <path>/dev/sda</path>.
</p>

<p>
Блочные устройства, аналогичные приведенным примерам, представляют собой 
абстрактный интерфейс к диску. Пользовательское ПО может использовать 
эти блочные устройства для обращения к дискам, не беспокоясь, к какому типу они 
принадлежат: IDE, SCSI или какому-то еще. ПО может адресовать место на диске, 
как набор смежных 512 байтных блоков с произвольным доступом.
</p>

</body>
</subsection>
<subsection>
<title>Разделы</title>
<body>

<p>
Несмотря на то, что теоретически для размещения системы Linux можно 
использовать весь диск, это почти никогда не делают на практике. Вместо 
этого все большое блочное устройство разбивается на меньшие блочные устройства, 
более удобные для обращения. В архитектуре x86 они называются <e>разделами</e>.
</p>

<p>
Существуют разделы трех типов: <e>первичные</e> (primary), <e>расширенные</e> 
(extended) и <e>логические</e> (logical).
</p>

<p>
<e>Первичный</e> раздел - это раздел, информация о котором хранится в MBR
(Master Boot Record - главная загрузочная запись). Так как MBR очень мала
(512 байт), можно определять всего четыре первичных раздела (например от 
<path>/dev/hda1</path> до <path>/dev/hda4</path>). 
</p>

<p>
<e>Расширенный</e> раздел - это особый первичный раздел (имеется
в виду, что расширенный раздел должен быть одним из четырех возможных первичных
разделов), в котором содержатся другие разделы. Таких разделов изначально
не существовало, но введение разделов этого типа помогло расширить существующую 
схему разметки без потери совместимости, как только четырех разделов перестало 
хватать.
</p>

<p>
<e>Логический</e> раздел - это раздел внутри расширенного раздела. Его
определение находится не в MBR, а внутри расширенного раздела.
</p>

</body>
</subsection>
<subsection>
<title>Дополнительные возможности</title>
<body>

<p>
На установочном компакт-диске для х86 предоставляется поддержка для EVMS и
LVM2. Использование EVMS и LVM2 повышает гибкость при создании разделов. В
ходе установки мы сфокусируемся на "обычных" разделах, но стоит запомнить,
что EVMS и LVM2 тоже поддерживаются.
</p>

</body>
</subsection>
</section>
<section>
<title>Разработка схемы разбиения диска</title>
<subsection>
<title>Схема разбиения по умолчанию</title>
<body>

<p>
Если вам не интересно заниматься разработкой схемы для вашей системы, можно 
воспользоваться схемой, приведенной в этой книге:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Файловая система</th>
  <th>Размер</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>раздел подкачки (swap)</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>оставшаяся часть диска</ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Если вам интересно узнать, какого размера должны быть разделы, и даже сколько 
их вам вообще может потребоваться, читайте дальше. В противном случае
приступайте к созданию разделов, описанному в главе <uri
link="#fdisk">Использование fdisk для создания разделов</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Сколько и какого размера?</title>
<body>

<p>
Количество разделов очень сильно зависит от назначения системы. Например, у вас
много пользователей, вам скорее всего захочется отделить <path>/home</path>
для повышения безопасности и упрощения резервного копирования. Если вы 
устанавливаете Gentoo в роли почтового сервера, следует отделить 
<path>/var</path>, т.к. вся почта хранится в <path>/var</path>. Затем, 
правильно выбрав файловую систему, вы добьетесь максимальной производительности.
Для игровых серверов потребуется отдельный раздел <path>/opt</path>,
так как большинство ПО для их работы устанавливается туда. Причины
выделения те же, что и для <path>/home</path>: безопасность и резервное 
копирование. Определенно стоит выделить побольше места для <path>/usr</path>:
не только потому, что там хранится большинство приложений, а из-за того, что
только дерево Portage, не считая размещенных в нем архивов с исходными кодами,
занимает около 500 МБ.
</p>

<p>
Как видно, все зависит от ваших целей. Наличие отдельных разделов или
томов имеет следующие плюсы:
</p>

<ul>
<li>
  для каждого раздела или тома можно выбрать наиболее подходящую файловую 
  систему 
</li>
<li>
  свободное место для всей системы не кончится "вдруг" из-за того, что 
  единственная погибшая программа постоянно записывает файлы на диск или том
</li>
<li>
  необходимая проверка файловых систем будет занимать меньше времени, т.к. 
  проверка разных разделов может выполняться параллельно (еще больший 
  выигрыш времени дает использование нескольких физических дисков)
</li>
<li>
  можно повысить безопасность системы, монтируя часть разделов в режиме 
  read-only (только для чтения), nosuid (игнорируется бит setuid),
  noexec (игнорируется бит исполнения) и т.д.
</li>
</ul>

<p>
Однако у создания множества разделов есть один большой минус: при неправильной
настройке вы можете получить систему, в которой много свободного места на одном
разделе, и совсем нет на другом. Кроме того, на дисках SCSI и SATA можно 
создавать не более 15 разделов.
</p>

<p>
Для примера мы покажем разбиение диска объемом 20 ГБ, используемого в 
демонстрационном ноутбуке (с веб-сервером, почтовым сервером, 
средой Gnome и т.д.):
</p>

<pre caption="Пример файловой системы">
$ <i>df -h</i>
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;не смонтирован&gt;
<comment>(свободное место для будущего использования: 2 ГБ)</comment>
</pre>

<p>
Раздел для <path>/usr</path>, как видим, почти заполнен (использовано 83%),
но когда все ПО установлено, <path>/usr</path> растет не слишком быстро.
Хотя отведение нескольких гигабайт дискового пространства для <path>/var</path> 
может показаться расточительством, помните, что Portage по умолчанию использует 
этот раздел для компиляции пакетов. Если вы захотите удержать <path>/var</path> 
в рамках более разумного размера, например, 1ГБ, вам потребуется изменить
переменную <c>PORTAGE_TMPDIR</c> в <path>/etc/make.conf</path>, чтобы она 
указывала на раздел, где достаточно свободного места для компиляции чрезвычайно 
больших пакетов, таких как OpenOffice. 
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Использование fdisk для создания разделов</title>
<subsection>
<body>

<p>
В следующей части описывается, как разбить диск по примерной схеме, описанной 
ранее, а именно:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>раздел подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Изменяйте эту схему по своему усмотрению.
</p>

</body>
</subsection>
<subsection>
<title>Просмотр текущей схемы разбиения диска</title>
<body>

<p>
<c>fdisk</c> - это популярная и очень мощная утилита для создания разделов на
ваших дисках. Запустите <c>fdisk</c> с указанием вашего диска в качестве
параметра (в примере мы используем <path>/dev/hda</path>):
</p>

<pre caption="Запуск fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Запустив <c>fdisk</c>, вы увидите приветственное сообщение, выглядящее примерно
так:
</p>

<pre caption="Приглашение fdisk">
Command (m for help): 
</pre>

<p>
Нажмите <c>p</c>, чтобы вывести текущую схему разделения диска:
</p>

<pre caption="Пример схемы диска">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>
<!-- (**) thorough style editing 'til here by achumakov, TBD later -->
<p>
Конкретно этот диск разбит на семь разделов Linux (следует из того, что в
списке отмечено как &quot;Linux&quot;) и один раздел подкачки (в списке отмечен
как &quot;Linux swap&quot;).
</p>

</body>
</subsection>
<subsection>
<title>Удаление всех разделов</title>
<body>

<p>
Сначала мы удалим все существующие разделы с диска. Введите <c>d</c> для
удаления раздела. Например для удаления существующего раздела
<path>/dev/hda1</path>:
</p>

<pre caption="Удаление раздела">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Раздел будет отмечен для удаления. Он больше не будет отображаться, если вы
введете <c>p</c>, но фактически он не будет удален до тех пор, пока вы не
сохраните сделанные изменения. Если вы сделали ошибку и хотите прервать работу
без сохранения изменений, немедленно введите <c>q</c> и нажмите ввод, ваш
раздел не будет удален.
</p>

<p>
Теперь, подразумевая, что вы действительно хотите удалить все разделы на вашей
системе, поочередно вводите <c>p</c>, что бы посмотреть список оставшихся
разделов, потом <c>d</c> и номер раздела для удаления. В конечном итоге вы
получите пустую таблицу разделов:
</p>

<pre caption="Пустая таблица разделов">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Теперь, когда мы очистили таблицу разделов, хранящуюся в памяти, настало время
создавать разделы. Мы будем использовать схему разделения диска из нашего
примера, о чем мы говорили ранее. Естественно, не следуйте этим инструкциям, если
не хотите получить таблицу разделов идентичную нашей!
</p>

</body>
</subsection>
<subsection>
<title>Создание загрузочного раздела</title>
<body>

<p>
В первую очередь мы создадим маленький загрузочный раздел. Введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы выбрать первичный раздел и
<c>1</c> для выбора первого первичного раздела. Когда появится вопрос о первом
цилиндре, нажмите ввод. На вопрос о последнем цилиндре введите <c>+32M</c>,
чтобы создать раздел размером 32 МБ:
</p>

<pre caption="Создание загрузочного раздела">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(нажмите ввод)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Теперь, когда вы введете <c>p</c>, вы должны увидеть следующую распечатку:
</p>

<pre caption="Созданный загрузочный раздел">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Нам необходимо сделать этот раздел загружаемым. Введите <c>a</c>, чтобы
установить флаг загрузки с раздела и выберите <c>1</c>. Если вы введете
<c>p</c> заново, то увидите символ <path>*</path>, расположенный в столбце
&quot;Boot&quot;.
</p>

</body>
</subsection>
<subsection>
<title>Создание раздела подкачки</title>
<body>

<p>
Давайте теперь создадим раздел подкачки. Чтобы сделать это, введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы указать fdisk'у, что вы хотите
получить первичный раздел. После этого вводите <c>2</c>, чтобы создать
первичный раздел номер два, в нашем случае <path>/dev/hda2</path>. На вопрос о
первом цилиндре просто нажмите ввод. По поводу последнего же цилиндра ответьте
<c>+512M</c>, чтобы создать раздел размером 512 Мб. После того как вы все это
проделаете, введите <c>t</c> для установки типа раздела, потом <c>2</c>, для
выбора раздела, который вы только что создали и после всего введите <c>82</c>,
чтобы выбрать для раздела тип &quot;Linux Swap&quot;. После окончания этих
процедур, если вы введете <c>p</c>, таблица разделов должна выглядеть
примерно так:
</p>

<pre caption="Список разделов после создания раздела подкачки">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Создание корневого раздела</title>
<body>

<p>
Ни и наконец, давайте создадим корневой раздел. Чтобы сделать это, введите
<c>n</c> для создания нового раздела, затем <c>p</c>, чтобы указать fdisk,
что вы хотите получить первичный раздел. После этого вводите <c>3</c>, чтобы
создать первичный раздел номер три, в нашем случае <path>/dev/hda3</path>. На
вопрос о первом цилиндре просто нажмите ввод. На вопрос о последнем цилиндре
также нажимайте ввод, чтобы создать раздел, занимающий все оставшееся свободное
место на диске. После того как вы проделаете эти операции и введете <c>p</c>,
будет показана таблица разделов эквивалентная этой:
</p>

<pre caption="Список разделов после создания корневого раздела">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Сохранение созданных разделов</title>
<body>

<p>
Чтобы сохранить все сделанные изменения и выйти из <c>fdisk</c>, введите
<c>w</c>.
</p>

<pre caption="Сохранение и выход из fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Теперь, когда созданы все разделы перейдем к <uri link="#filesystems">Созданию 
файловых систем</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Создание файловых систем</title>
<subsection>
<title>Введение</title>
<body>

<p>
Разделы созданы, настало время разместить файловые системы на них. Если вам
безразлично, какую файловую систему использовать, и вы вполне довольны файловой 
системой, используемой нами в книге по-умолчанию, вы можете перейти к разделу 
<uri link="#filesystems-apply">Размещение файловой системы на разделе</uri>. 
Если нет, то продолжайте чтение и узнайте больше о доступных для использования 
файловых системах...
</p>

</body>
</subsection>
<subsection>
<title>Файловые системы?</title>
<body>

<p>
Ядро Linux поддерживает различные файловые системы. Мы расскажем о ext2, ext3,
ReiserFS, XFS и JFS как о наиболее часто применяемых ФС в Linux-системах.
</p>

<p>
<b>ext2</b> - это проверенная временем и родная для Linux файловая система, но
она не обладает средствами журналирования метаданных, что при повседневном
использовании означает, что проверка целостности во время запуска системы может
оказаться весьма продолжительной. Сегодня существует достаточно широкий выбор
ФС нового поколения, т.н. журналируемых файловых систем, которые могут быть
проверены на целостность очень быстро и по этому более предпочтительны нежели
их не журналируемые собратья. Журналируемая ФС позволяет избежать долгих
задержек при старте системы, если при том ваша файловая система оказалась в
нестабильном состоянии.
</p>

<p>
<b>ext3</b> - это журналируемая версия ext2. Она обладает средствами
журналирования метаданных для быстрого восстановления наряду с другими
режимами ведения журнала, такими как журналирование всех данных и упорядоченное
ведение журнала данных. ext3 - это очень хорошая и надежная ФС. У нее есть
дополнительная возможность индексации через хэшированные b-деревья, что
позволяет повысить производительность практически в любой ситуации. Вы можете
включить этот способ индексации, добавив <c>-O dir_index</c> к команде
<c>mke2fs</c>. Короче говоря, ext3 - превосходная файловая система.
</p>

<p>
<b>ReiserFS</b> - это ФС, основанная на так называемых B*-деревьях. Она 
обладает очень хорошей производительностью и сильно (иногда в 10-15 раз) 
превосходит ext2 и ext3 при работе с файлами малого размера (файлами, размером 
менее 4k). ReiserFS также очень хорошо масштабируется и обладает средствами 
журналирования. Начиная со времени выхода ядра версии 2.4.18, ReiserFS признана 
стабильной и пригодной для использования как в системах общего назначения, так 
и в системах с большой нагрузкой, такой как создание больших файловых систем, 
использованием множества файлов малого размера, файлов очень большого размера и 
каталогов, содержащих десятки тысяч файлов.
</p>

<p>
<b>XFS</b> - это файловая система, обладающая наряду со средствами ведения
журнала хорошим набором дополнительных возможностей, оптимизированна для
хорошей масштабируемости. Мы рекомендуем ее применение только в Linux-системах
с высококлассными SCSI и / или fibre-channel дисками и оборудованными
источниками бесперебойного питания. Из-за того, что XFS очень агрессивно
кеширует данные в памяти, очень вероятная ситуация, когда неправильно
спроектированная программа (не обладающая достаточной осторожностью при записи
файлов на диск, но таких мало) может потерять большой объем информации при
неожиданном отключении питания.
</p>

<p>
<b>JFS</b> - высокопроизводительная журналируемая файловая система производства
IBM. Она только недавно получила статус пригодной для широкого применения. Так 
как история ее применения еще мала, то трудно сказать что-то определенное о ее 
стабильности, плюсах и минусах.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Размещение файловой системы на разделе</title>
<body>

<p>
Для создания файловой системы на разделе или томе существуют утилиты для
каждого доступного типа:
</p>

<table>
<tr>
  <th>Файловая система</th>
  <th>Команда</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
К примеру, для создания загрузочного раздела (<path>/dev/hda1</path> в наших
примерах) с ФС ext2 и корневой раздел (<path>/dev/hda3</path> в наших примерах)
с ФС ext3, вы должны выполнить следующие команды:
</p>

<pre caption="Размещение ФС на разделе">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Теперь разместите файловые системы на вновь созданных разделах (или логических
томах).
</p>

</body>
</subsection>
<subsection>
<title>Активация раздела подкачки</title>
<body>

<p>
<c>mkswap</c> - команда, используемая для инициализации раздела подкачки:
</p>

<pre caption="Создание сигнатуры раздела подкачки">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Для активации раздела подкачки используется <c>swapon</c>:
</p>

<pre caption="Активация раздела подкачки">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Создайте и активируйте раздел подкачки, используя команды, приведенные выше.
</p>

</body>
</subsection>
</section>
<section>
<title>Монтирование</title>
<body>

<p>
Теперь, когда разделы созданы и файловые системы размещены, настало время
смонтировать эти разделы. Используйте команду <c>mount</c>. Не забудьте
предварительно создать необходимые каталоги для монтирования каждого раздела.
В этом примере мы монтируем корневой и загрузочный разделы:
</p>

<pre caption="Монтирование разделов">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Если вы хотите разместить <path>/tmp</path> на отдельном разделе, не забудьте
изменить права доступа к этому каталогу после монтирования: <c>chmod 1777
/mnt/gentoo/tmp</c>. В этом каталоге размещается <path>/var/tmp</path>.
</note>

<p>
Нам также необходимо будет смонтировать ФС proc (виртуальный интерфейс ядра) в
каталог <path>/proc</path>. Но для начала надо разместить необходимые нам файлы
на разделах.
</p>

<p>
Переходите к разделу книги <uri link="?part=1&amp;chap=5">Подготовка 
установочных файлов Gentoo </uri>.
</p>

</body>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 2.5-r1
target-date: 2006-01-23
source-cvs-revision: 1.25
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Alexey Chumakov [achumakov@gentoo.org]
-->
