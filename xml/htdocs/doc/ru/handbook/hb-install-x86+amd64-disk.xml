<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/hb-install-x86+amd64-disk.xml,v 1.5 2014/01/03 03:36:51 blueboar Exp $ -->

<sections>

<abstract>
Чтобы иметь возможность установки Gentoo, вы должны создать необходимые
разделы. Данная глава описывает, как разбить диск для последующего
использования.
</abstract>

<version>6</version>
<date>2013-12-30</date>

<section>
<title>Общие сведения о блочных устройствах</title>

<subsection>
<include href="hb-install-blockdevices.xml"/>
</subsection>

<subsection>
<title>Разделы</title>
<body>

<p>
Хотя теоретически для размещения системы Linux диск можно использовать целиком,
так почти никогда не делают на практике. Вместо этого большое физическое 
блочное устройство разбивают на меньшие блочные устройства, более удобные для 
обращения. В архитектуре <keyval id="arch"/> они называются <e>разделами</e>. 
На данный момент существуют две стандартных технологии разбивки на разделы: MBR и GPT.
</p>

<p>
<e>MBR (Master Boot Record)</e> использует 32-битные идентификаторы для разделов
и поддерживают три типа разделов: <e>первичные</e> (primary), <e>расширенные</e> 
(extended) и <e>логические</e> (logical). Первичные разделы хранят информацию о себе
в самом MBR - очень маленьком кусочке пространства (обычно 512 байт) в самом
начале диска. Из-за такого маленького объема, поддерживаются только четыре
первичных раздела (например, от <path>/dev/sda1</path> до <path>/dev/sda4</path>).
</p>

<p>
Для поддержки большего числа разделов, один из первичных разделов может быть
помечен как расширенный раздел. Данный раздел может затем содержать логические
разделы (разделы внутри разделов).
</p>

<p>
Каждый раздел имеет ограничение на размер в 2Тб (из-за 32-битных идентификаторов).
Кроме того, MBR не имеет никакого запасного MBR, так что если приложение
перезапишет MBR, то вся информация о разделах будет потеряна.
</p>

<p>
<e>GPT (GUID Partition table)</e> использует 64-битные идентификаторы для
разделов. Кусочек пространства, в котором сохраняется информация о разделах
также гораздо больше, чем 512 байт в случае MBR, а также не существует ограничения
на количество разделов. Кроме того, размер раздела имеет оганичение, но
гораздо большего объема (Почти 8 Зб - да, Зеттабайт).
</p>

<p>
Когда между операционной системой и оборудованием связь осуществляется через 
UEFI (а не BIOS), GPT является практически обязательной, так как в данном случае
возникнут проблемы совместимости с MBR.
</p>

<p>
Также GPT имеет то преимущество, что в конце диска имеется копия GPT, которая
может использоваться для восстановления повреждения основной GPT в начале
диска. Кроме того, в GPT хранятся контрольные суммы по алгоритму CRC32 для
обнаружения ошибок в заголовке и таблицах разделов.
</p>

</body>
</subsection>

<subsection id="gpt_or_mbr">
<title>Итак, GPT или MBR?</title>
<body>

<p>
Из описания выше можно подумать, что рекомендуется всегда использовать GPT.
Однако существует несколько ограничений.
</p>


<p>
Использование GPT при наличии BIOS в компьютере работает, но при этом нельзя
иметь второй системой Microsoft Windows. Причина в том, что Microsoft Windows
попытается загрузиться в режиме EFI, если увидит метку раздела GPT.
</p>

<p>
Некоторые BIOSы или EFI содержат ошибки, и если их сконфигурировать в режиме
BIOS/CSM/Legacy, то у них будут проблемы при загрузке с дисков, имеющих GPT.
В этом случае, вероятно, вы сможете обойти данную проблему, добавив флаг
загрузки/активности на нужный раздел MBR. Это нужно делать в <c>fdisk</c>
(<c>parted</c> понимает таблицы GPT, и не покажет вам нужный раздел MBR):
</p>

<pre caption="Включаем флаг загрузки на раздел MBR">
# <i>fdisk /dev/sda</i>
WARNING: GPT (GUID Partition Table) detected on '/dev/sda'! The util fdisk
doesn't support GPT. Use GNU Parted.

Command (m for help): <i>a</i>
Partition number (1-4): <i>1</i>

Command (m for help): <i>w</i>
</pre>

</body>
</subsection>

<subsection>
<title>Дополнительные возможности</title>
<body>

<p>
На установочном компакт-диске для <keyval id="arch"/> предусмотрена поддержка LVM2. 
Использование LVM2 повышает гибкость разбиения диска. В ходе установки 
мы останавливаемся на &laquo;обычных&raquo; разделах, но стоит запомнить, что 
LVM2 тоже поддерживается. 
</p>

</body>
</subsection>
</section>
<section>
<title>Разработка схемы разбиения диска</title>
<subsection>
<title>Схема разбиения по умолчанию</title>
<body>

<p>
Если вам не интересно заниматься разработкой схемы для своей системы, можно 
воспользоваться схемой, используемой в этой книге.
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Файловая система</th>
  <th>Размер</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/sda1</path></ti>
  <ti>(начальный загрузчик)</ti>
  <ti>2МБ</ti>
  <ti>загрузочный раздел BIOS</ti>
</tr>
<tr>
  <ti><path>/dev/sda2</path></ti>
  <ti>ext2</ti>
  <ti>128МБ</ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/sda3</path></ti>
  <ti>(swap)</ti>
  <ti>512МБ или больше</ti>
  <ti>раздел подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/sda4</path></ti>
  <ti>ext4</ti>
  <ti>оставшаяся часть диска</ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Если вам интересно узнать, какого размера должны быть разделы, и сколько их вам 
вообще может потребоваться, читайте дальше. В противном случае приступайте к 
созданию разделов, описанному в главах <uri link="#parted">По умолчанию: использование parted
для создания разделов</uri> (либо <uri link="#fdisk">Альтернатива: использование fdisk для создания 
разделов</uri>). И та, и другая программа являются инструментами для разбивки дисков, <c>fdisk</c>
известен и стабилен, <c>parted</c> немного новее, но поддерживает разделы более чем 2Тб.
</p>

</body>
</subsection>
<subsection>
<title>Сколько и каких именно?</title>
<body>

<p>
Количество разделов очень сильно зависит от назначения системы. Например, если 
у вас много пользователей, вам, скорее всего, захочется отделить 
<path>/home</path> для повышения безопасности и упрощения резервного 
копирования. Если вы устанавливаете Gentoo в роли почтового сервера, следует 
отделить <path>/var</path>, т.к. вся почта хранится там. Затем, правильно 
выбрав файловую систему, вы добьетесь максимальной производительности. 
Для игровых серверов потребуется отдельный раздел <path>/opt</path>,
так как большинство программ для их работы устанавливается туда. Причины
выделения те же, что и для <path>/home</path>: безопасность и резервное 
копирование. Определенно не помешает побольше места для <path>/usr</path>:
не только потому, что там хранится большинство приложений, а еще из-за того, 
что лишь дерево Portage, не считая размещенных в нем архивов с исходными 
кодами, занимает около 500 МБ.
</p>

<p>
Как видите, все зависит от ваших целей. Наличие отдельных разделов или
томов имеет следующие плюсы:
</p>

<ul>
<li>
  для каждого раздела или тома можно выбрать наиболее подходящую файловую 
  систему 
</li>
<li>
  свободное место во всей системе не кончится &laquo;вдруг&raquo; из-за того, 
  что одна-единственная сбойная программа постоянно записывает файлы в раздел 
  или том 
</li>
<li>
  необходимая проверка файловых систем будет занимать меньше времени, т.к. 
  проверка разных разделов может выполняться параллельно (еще больший 
  выигрыш времени дает использование нескольких физических дисков)
</li>
<li>
  можно повысить безопасность системы, монтируя часть разделов в режиме 
  read-only (только для чтения), nosuid (игнорируется бит setuid),
  noexec (игнорируется бит исполнения) и т.д.
</li>
</ul>

<p>
Однако у множества разделов также есть недостатки. Если они не сконфигурированы 
правильно, у вас будет система с огромным количеством свободного места на одном 
разделе и отсутствием его на другой. Другой проблемой является то, что отдельные 
разделы, особенно для важных точек монтирования, например <path>/usr</path> или <path>/var</path>, часто 
требуют загрузки некоторого кода в ОЗУ, чтобы смонтировать разделы прежде чем 
запустятся другие загрузочные скрипты. Это не всегда является проблемой, так что 
результаты могут быть разные.
</p>

<p>
Также существует лимит в 15 разделов для SCSI и SATA, если только вы не используете 
метки GPT.
</p>

</body>
</subsection>

<subsection>
<title>О пространстве подкачки</title>
<body>

<p>
Не существует идеального значения для раздела подкачки. Целью пространства
подкачки является предоставление дискового пространства ядру, когда оперативная
память (ОЗУ) сильно используется. Пространство подкачки позволяет ядру переносить
страницы памяти, которые, скорее всего, не будут использоваться в ближайшее
время, на диск (что называется своп, или page-out), освобождая память.
Конечно, если эта память, вдруг, неожиданно понадобится, эти страницы должны
быть помещены обратно в память (page-in), что займет некоторое время (так как
диски - это очень медленные устройства, если сравнивать их с оперативной
памятью).
</p>

<p>
Если вы не собираетесь запускать приложения, требовательные к памяти, либо
у вас очень много памяти, то, скорее всего, вам не нужно много пространства
подкачки. Однако раздел подкачки также используется для сохранения всей
памяти в случае гибернации. Если вы планируете использовать гибернацию,
вам будет нужно большее пространство подкачки, хотя бы равное количеству
оперативной памяти, которое у вас есть в системе.
</p>
</body>
</subsection>

<subsection>
<title>Что за загрузочный раздел BIOS?</title>
<body>

<p>
Загрузочный раздел BIOS это очень маленький (от 1 до 2 Мб) раздел, в котором
начальные загрузчики вроде GRUB2 могут сохранять дополнительные данные, если
они не помещаются в выделенное пространство (в случае MBR это несколько сот
байт), и их нельзя разместить ни в каком другом месте.
</p>

<p>
Такие разделы не всегда необходимы, но принимая во внимание, что они занимают
очень мало места, а также сложность документирования множества вариантов, 
когда они нужны, а когда нет, рекомендуется создать такой раздел в любом случае.
</p>

<p>
Для полноты картины, можно сказать, что загрузочный раздел BIOS необходим
при использования GPT с GRUB2, либо при использовании MBR с GRUB2, если первый
раздел начинается ранее, чем 1 мегабайт от начала диска.
</p>
</body>
</subsection>
</section>

<section id="parted">
<title>По умолчанию: Использование parted для создания разделов</title>
<subsection>
<body>

<p>
В данной главе, мы проведем вас через создание примерной компоновки разделов, 
о которой мы говорили ранее в данной главе (но повторим здесь еще раз для
вашего удобства).
</p>

<p>
Примерная компоновка разделов, которую мы будем использовать, показана в следующей таблице:
</p>

<table>
<tr>
<th>Раздел</th>
<th>Описание</th>
</tr>
<tr>
<ti><path>/dev/sda1</path></ti>
<ti>Загрузочный раздел BIOS</ti>
</tr>
<tr>
<ti><path>/dev/sda2</path></ti>
<ti>Загрузочный раздел</ti>
</tr>
<tr>
<ti><path>/dev/sda3</path></ti>
<ti>Swap раздел</ti>
</tr>
<tr>
<ti><path>/dev/sda4</path></ti>
<ti>Корневой раздел</ti>
</tr>
</table>

<p>
Измените вашу компоновку разделов так, как вам необходимо.
</p>

</body>
</subsection>


<subsection>
<title>Просмотр текущей компоновки разделов</title>
<body>

<p>
Приложение <c>parted</c> предлагает простой интерфейс для разбивки ваших дисков 
и поддерживает очень большие разделы (более чем 2Тб). Запустите <c>parted</c> с вашим диском 
(в нашем примере мы используем <path>/dev/sda</path>). Мы также попросим <c>parted</c>
использовать оптимальное выравнивание
</p>

<pre caption="Запускаем parted">
# <i>parted -a optimal /dev/sda</i>
  GNU Parted 2.3
  Using /dev/sda
  Welcome to GNU Parted! Type 'help' to view a list of commands.
</pre>

<p>
Выравнивание означает, что разделы будут начинаться на известных границах на диске,
что приведет к тому, что операции с диском на уровне операционной системы (получение
страниц с диска) будут использовать самое маленькое число внутренних операций с
диском. Невыровненные разделы могут потребовать от диска загрузить две страницы
вместо одной даже если операционная система потребовала всего одну страницу.
</p>


<p>
Чтобы прочитать про все опции, поддерживаемые <c>parted</c>, введите <c>help</c> и 
нажмите ввод.
</p>

</body>
</subsection>
<subsection>
<title>Установка метки GPT</title>
<body>

<p>
Большинство дисков на x86/amd64 используют метку <e>msdos</e>. Используя <c>parted</c>, мы
можем разместить на диске метку GPT с помощью команды <c>mklabel gpt</c>:
</p>

<warn>
Измение типа раздела удалит все разделы с вашего диска. Все данные на диске будут потеряны.
</warn>

<pre caption="Установка метки GPT">
(parted) <i>mklabel gpt</i>
</pre>

<p>
Если вы хотите, чтобы ваш диск имел MBR, используйте <c>mklabel msdos</c>.
</p>

</body>
</subsection>
<subsection>
<title>Удаляем все разделы</title>
<body>

<p>
Если это еще не выполнено (например через операцию <c>mklabel</c>, про которую 
рассказано выше, или потому что диск только что отформатированный), сначала 
нам нужно удалить все существующие разделы с диска. Введите <c>print</c> для
просмотра текущих разделов и <c>rm &lt;номер&gt;</c>, где &lt;номер&gt; это раздел, 
который вы хотите удалить.
</p>

<pre caption="Удаление раздела с диска">
(parted) <i>rm 2</i>
</pre>

<p>
Повторите то же самое для всех остальных разделов, которые вам не нужны. Однако 
удостоверьтесь, что вы не допустили никаких ошибок — <c>parted</c> запускает изменения 
сразу (в отличие от <c>fdisk</c>, который накапливает их, позволяя пользователю 
отменить свои изменения прежде чем записать их или выйти из <c>fdisk</c>).
</p>

</body>
</subsection>
<subsection>
<title>Создаем разделы</title>
<body>

<p>
Сначала давайте создадим разделы, про которые мы говорили ранее. Создание разделов 
с помощью <c>parted</c> не очень сложно — все, что нам нужно — это дать <c>parted</c> 
следующие настройки:
</p>

<ul>
<li>
<e>Тип раздела</e> для использования. Обычно это <e>primary</e>. Если вы использовали
метку раздела <e>msdos</e>, помните, что вы не можете создать более четырех первичных
разделов. Если вам нужно больше четырех первичных разделов, создайте <e>расширенный</e>
(extended) раздел, и создайте в нем <e>логические</e> разделы (logical).
</li>
<li>
Начальное положение раздела (которое может быть выражено в Мб, Гб, и так далее)
</li>
<li>
Конечное положение раздела (которое может быть выражено в Мб, Гб, и так далее)
</li>
</ul>

<p>
Сначала мы говорим <c>parted</c>, что мы будем работать с мегабайтами (на самом
деле, мебибайтами, которые обозначаются как МиБ, что является "стандартной"
формой записи, но мы будем использовать в тексте МБ, так как это гораздо
более распространено).
</p>

<pre caption="Используем единицы измерения МиБ">
(parted) <i>unit mib</i>
</pre>

<p>
Теперь создадим раздел размером в 2Мб, который будет использоваться позднее
начальным загрузчиков GRUB. Мы будем использовать для этого команду <c>mkpart</c>,
и скажем <c>parted</c>, чтобы он создал раздел от 1Мб до 3Мб (он получится
размером в 2Мб).
</p>

<pre caption="Создаем раздел в 2Мб">
(parted) <i>mkpart primary 1 3</i>
(parted) <i>name 1 grub</i>
(parted) <i>set 1 bios_grub on</i>
(parted) <i>print</i>
Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number Start End Size File system Name Flags
1 1.00MiB 3.00MiB 2.00MiB grub bios_grub
</pre>

<p>
Повторите данные шагидля загрузочного раздела (128 Мб), раздела
подкачки (в примере 512 Мб) и корневого раздела, который занимает
оставшуюся часть диска (для этого его конечное положение обозначено
как <c>-1</c>, что означает "конец диска минус один мегабайт").
</p>

<pre caption="Создаем остальные разделы">
(parted) <i>mkpart primary 3 131</i>
(parted) <i>name 2 boot</i>
(parted) <i>mkpart primary 131 643</i>
(parted) <i>name 3 swap</i>
(parted) <i>mkpart primary 643 -1</i>
(parted) <i>name 4 rootfs</i>
</pre>

<p>
Конечный результат будет выглядеть примерно так:
</p>

<pre caption="Просмотр текущей картины разделов">
(parted) <i>print</i>
Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number   Start    End      Size      File system   Name   Flags
 1       1.00MiB  3.00MiB  2.00MiB                 grub   bios_grub
 2       3.00MiB  131MiB   128MiB                  boot
 3       131MiB   643MiB   512MiB                  swap
 4       643MiB   20479MiB 19836MiB                rootfs
</pre>

<p>
Когда вы будете удовлетворены, используйте команду <c>quit</c>, чтобы выйти из <c>parted</c>.
</p>

</body>
</subsection>
</section>

<section id="fdisk">
<title>Альтернатива: Использование fdisk для создания разделов</title>
<subsection>
<body>

<impo>
Если ваше окружение будет работать с разделами, большими чем 2Тб,
пожалуйста, используйте инструкции из главы 
<uri link="#parted">По умолчанию: использование parted для создания разделов</uri> вместо
этих. <c>fdisk</c> не может работать с разделами большего размера. Кроме того,
fdisk использует только MBR. Другие приложения fdisk, например, gdisk (которое
в Gentoo находится в пакете gptfdisk) поддерживают GPT, однако они могут
отсутствовать на диске, с которого вы устанавливаете Gentoo.
</impo>

<p>
В следующих разделах описывается, как разбить диск в соответствии с примерной 
схемой, используя <c>fdisk</c>. Примерная схема разделов была описана ранее:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/sda1</path></ti>
  <ti>загрузочный раздел BIOS</ti>
</tr>
<tr>
  <ti><path>/dev/sda2</path></ti>
  <ti>загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/sda3</path></ti>
  <ti>раздел подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/sda4</path></ti>
  <ti>корневой раздел</ti>
</tr>
</table>

<p>
Эту схему вы можете изменять по своему усмотрению.
</p>

</body>
</subsection>
<subsection>
<title>Просмотр текущей схемы разбиения диска</title>
<body>

<p>
<c>fdisk</c> &mdash; это популярная и очень мощная утилита для создания 
разделов на ваших дисках. Запустите <c>fdisk</c>, указав свой диск в
качестве параметра (в примере мы используем <path>/dev/sda</path>):
</p>

<pre caption="Запуск fdisk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
После запуска <c>fdisk</c> выдаст такое приглашение:
</p>

<pre caption="Приглашение fdisk">
Command (m for help): 
</pre>

<p>
Нажмите <c>p</c>, чтобы вывести текущую схему разбиения диска:
</p>

<pre caption="Пример схемы разделов диска">
Command (m for help): <i>p</i>

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

     Device Boot    Start       End    Blocks   Id  System
/dev/sda1    *        1        14    105808+  83  Linux
/dev/sda2            15        49    264600   82  Linux swap
/dev/sda3            50        70    158760   83  Linux
/dev/sda4            71      2184  15981840    5  Extended
/dev/sda5            71       209   1050808+  83  Linux
/dev/sda6           210       348   1050808+  83  Linux
/dev/sda7           349       626   2101648+  83  Linux
/dev/sda8           627       904   2101648+  83  Linux
/dev/sda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
В данном случае на диске есть семь разделов Linux (для которых в графе 
&laquo;System&raquo; указано &laquo;Linux&raquo;) и один раздел подкачки (в
списке показан как &laquo;Linux swap&raquo;).
</p>

</body>
</subsection>
<subsection>
<title>Удаление всех разделов</title>
<body>

<p>
Сначала удалим с диска все существующие разделы. Для удаления раздела 
вводите <c>d</c>. Например для удаления существующего <path>/dev/sda1</path>:
</p>

<pre caption="Удаление раздела">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Удаление раздела будет запланировано. Он больше не будет отображаться при вводе
<c>p</c>, но фактически не будет удалятся до тех пор, пока вы не сохраните 
внесенные изменения. Если вы ошиблись и хотите прервать разбиение без 
сохранения изменений, немедленно введите <c>q</c> и нажмите ENTER; тогда ваш 
раздел сохранится в неизменном виде.
</p>

<p>
Теперь, если вы действительно собираетесь удалить в своей системе все разделы, 
повторяйте ввод <c>p</c> для показа оставшихся разделов, затем <c>d</c> и 
номера удаляемого раздела до тех пор, пока разделы не кончатся. В итоге вы 
получите пустую таблицу разделов: 
</p>

<pre caption="Пустая таблица разделов">
Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Теперь, когда мы очистили таблицу разделов, хранящуюся в оперативной памяти, 
настало время создавать разделы. Мы воспользуемся примерной схемой разбиения, 
описанной выше. Естественно, не следуйте этим инструкциям буквально, если 
только вам не нужна таблица разделов, идентичная нашей! 
</p>

</body>
</subsection>
<subsection>
<title>Создание загрузочного раздела BIOS</title>
<body>

<p>
Сначала мы создадим очень маленький загрузочный раздел BIOS. Введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы выбрать первичный раздел, и
<c>1</c> для указания первого первичного раздела. На вопрос о первом секторе,
удостоверьтесь, что он начинается с <c>2048</c> (это необходимо для
начального загрузчика), и нажмите ввод. На вопрос о последнем секторе 
введите <c>+2M</c>, чтобы создать раздел размером 2МБ.
</p>

<note>
Начало с сектора номер 2048 это гарантия работоспособности на случай,
если начальный загрузчик не сможет определить, что данный раздел создан для
его использования.
</note>

<pre caption="Создание загрузочного раздела BIOS">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First sector (64-10486533532, default 64): <i>2048</i>
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): <i>+2M</i>
</pre>

<p>
Пометим раздел для целей EFI:
</p>

<pre caption="Пометим раздел для целей EFI">
Command (m for help): <i>t</i>
Selected partition 1
Hex code (type L to list codes): <i>ef</i>
Changed system type of partition 1 to ef (EFI (FAT-12/16/32))
</pre>

</body>
</subsection>

<subsection>
<title>Создание загрузочного раздела</title>
<body>
<p>
Теперь мы создадим маленький загрузочный раздел. Нажмите <c>n</c> для создания
нового раздела, затем <c>p</c> для выбора первичного раздела, затем <c>2</c> для
выбора второго первичного раздела. Когда вас попросят ввести первый сектор,
согласитесь со значением по умолчанию, нажав enter. Когда попросят ввести
последний сектор, введите <c>+128M</c> для создания раздела размером 128 Мб.
</p>

<pre caption="Создаем загрузочный раздел">
Command (m for help): <i>n</i>
Command action
e extended
p primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>2</i>
First sector (5198-10486533532, default 5198): <comment>(Hit enter)</comment>
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): <i>+128M</i>
</pre>

<p>
Теперь, введя <c>p</c>, вы должны увидеть следующий текст:
</p>

<pre caption="Созданный загрузочный раздел">
Command (m for help): <i>p</i>

Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks    Id  System
/dev/sda1             1         3      5198+   ef  EFI (FAT-12/16/32)
/dev/sda2             3         14    105808+  83  Linux
</pre>

<p>
Нам необходимо сделать этот раздел загружаемым. Введите <c>a</c> для
включения признака загрузки с раздела, затем нажмите <c>2</c>. Если снова 
ввести <c>p</c>, можно увидеть, что в столбце &laquo;boot&raquo; появился знак
<e>*</e>.
</p>

</body>
</subsection>
<subsection>
<title>Создание раздела подкачки</title>
<body>

<p>
Теперь создадим раздел подкачки. Для этого введите <c>n</c> (создание нового 
раздела), затем <c>p</c> для выбора первичного раздела. Потом нажмите <c>3</c>, 
чтобы создать третий первичный раздел, в нашем случае <path>/dev/sda3</path>. 
На вопрос о первом секторе просто нажмите ввод. На вопрос о последнем &mdash; 
ответьте <c>+512M</c>, чтобы создать раздел размером 512МБ. 
</p>

<p>
Сделав это, введите <c>t</c> для указания типа раздела,  <c>3</c>, для выбора только что созданного 
раздела, и <c>82</c>, чтобы установить тип раздела &laquo;Linux Swap&raquo;. 
</p>

</body>
</subsection>
<subsection>
<title>Создание корневого раздела</title>
<body>

<p>
Теперь создадим корневой раздел. Для этого введите <c>n</c> (создание нового 
раздела), затем <c>p</c> (первичный раздел). После этого нажмите <c>4</c> для 
создания четвертого первичного раздела, в нашем случае <path>/dev/sda4</path>. На 
вопрос о первом секторе нажмите ввод. На вопрос о последнем &mdash; также 
нажмите ввод, чтобы раздел занял все оставшееся свободное место на диске. По 
завершении этих шагов, при вводе <c>p</c> должна выводиться подобная таблица 
разделов:
</p>

<pre caption="Список разделов после создания корневого раздела">
Command (m for help): <i>p</i>

Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks    Id  System
/dev/sda1             1         3      5198+   ef  EFI (FAT-12/16/32)
/dev/sda2    *        3        14    105808+   83  Linux
/dev/sda3            15        81    506520    82  Linux swap
/dev/sda4            82      3876  28690200    83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Сохранение схемы разбиения</title>
<body>

<p>
Для сохранения схемы разбиения и выхода из <c>fdisk</c>, введите <c>w</c>.
</p>

<pre caption="Сохранение и выход из fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Теперь, создав все разделы, перейдем к <uri link="#filesystems">созданию
файловых систем</uri>.
</p>

</body>
</subsection>
</section>

<section id="filesystems">
<title>Создание файловых систем</title>
<subsection>
<title>Введение</title>
<body>

<p>
Разделы созданы, настало время разместить на них файловые системы. Если вам
безразлично, какую файловую систему использовать, и вы вполне довольны той, 
что мы предлагаем в книге по умолчанию, переходите к <uri 
link="#filesystems-apply">размещению файловой системы в разделе</uri>.  
Если нет, читайте дальше, чтобы разузнать о существующих файловых системах...
</p>

</body>
</subsection>
<subsection>
<include href="hb-install-filesystems.xml"/>
</subsection>

<subsection id="filesystems-apply">
<title>Размещение файловой системы в разделе</title>
<body>

<p>
Для создания в разделе или томе файловой системы каждого типа существуют 
специальные средства:
</p>

<table>
<tr>
  <th>Файловая система</th>
  <th>Команда создания</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mkfs.ext2</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mkfs.ext3</c></ti>
</tr>
<tr>
  <ti>ext4</ti>
  <ti><c>mkfs.ext4</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Например, чтобы у загрузочного раздела (<path>/dev/sda2</path> в наших
примерах) была файловая система ext2, а у корневого раздела 
(<path>/dev/sda4</path> в наших примерах) &mdash; ext4, требуется выполнить:
</p>

<pre caption="Создание файловых систем разделов">
# <i>mkfs.ext2 /dev/sda2</i>
# <i>mkfs.ext4 /dev/sda4</i>
</pre>

<p>
Теперь самостоятельно создайте файловые системы на своих только что созданных 
разделах (логических томах).
</p>

</body>
</subsection>
<subsection>
<title>Подключение раздела подкачки</title>
<body>

<p>
<c>mkswap</c> &mdash; команда, используемая для инициализации разделов 
подкачки:
</p>

<pre caption="Создание идентификатора раздела подкачки">
# <i>mkswap /dev/sda3</i>
</pre>

<p>
Для подключения раздела подкачки воспользуйтесь <c>swapon</c>:
</p>

<pre caption="Подключение раздела подкачки">
# <i>swapon /dev/sda3</i>
</pre>

<p>
Теперь командами, приведенными выше, создайте и подключите раздел подкачки в
своей системе. 
</p>

</body>
</subsection>
</section>
<section>
<title>Монтирование</title>
<body>

<p>
Теперь, когда разделы созданы, а файловые системы размещены, настало время
смонтировать (подключить к системе) эти разделы. Используйте команду 
<c>mount</c>. Не забудьте создать для каждого раздела соответствующие каталоги
монтирования. Например, смонтируем корневой и загрузочный разделы: 
</p>

<pre caption="Монтирование разделов">
# <i>mount /dev/sda4 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/sda2 /mnt/gentoo/boot</i>
</pre>

<note>
Если вы хотите разместить каталог <path>/tmp</path> в отдельном разделе, не 
забудьте изменить права доступа к этому каталогу после монтирования: <c>chmod 
1777 /mnt/gentoo/tmp</c>. Это также относится к <path>/var/tmp</path>.
</note>

<p>
Еще нам потребуется смонтировать файловую систему proc (виртуальный интерфейс 
ядра) в каталог <path>/proc</path>. Но сначала надо поместить в разделы нужные 
файлы.
</p>

<p>
Переходите к <uri link="?part=1&amp;chap=5">установке установочных файлов 
Gentoo</uri>.
</p>

</body>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-date: 2013-12-30
source-cvs-revision: 1.35
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: Alexey Chumakov [achumakov@gentoo.org]
edited-by: Romanov Vladimir [blueboar2@gmail.com]
-->
