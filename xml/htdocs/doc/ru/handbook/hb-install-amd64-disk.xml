<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<!-- Текст этого документа распространяется на условиях лицензии CC-BY-SA -->
<!-- См. http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/handbook/Attic/hb-install-amd64-disk.xml,v 1.2 2006/01/23 21:37:40 achumakov Exp $ -->

<sections>

<version>2.5</version>
<date>2006-01-01</date>


<section>
<title>Общие сведения о блочных устройствах</title>
<subsection>
<title>Блочные устройства</title>
<body>

<p>
Мы достаточно подробно рассмотрим аспекты работы с дисками в Gentoo Linux 
и Linux вообще, включая файловые системы, разделы и блочные устройства. 
Позже, когда вы уже разберетесь с вводом-выводом на диск и файловыми системами 
мы пошагово поможем вам с разметкой диска на разделы и файловые системы для 
вашей установки Gentoo Linux.
</p>

<p>
Для начала давайте познакомимся с <e>блочными устройствами</e>. Наиболее 
известным блочным устройством, вероятно, является устройство, представляющее
собой первый IDE диск в Linux системе, и известное как <path>/dev/hda</path>.
Если в вашей системе используются диски SCSI, тогда ваш первый жесткий диск
будет именоваться <path>/dev/sda</path>.
</p>

<p>
Блочные устройства, аналогичные приведенным примерам, представляют собой 
абстрактный интерфейс к диску. Это позволяет пользовательскому ПО использовать 
эти блочные устройства для обращения к дискам не беспокоясь, к какому типу они 
принадлежат: IDE, SCSI или какому-то еще. ПО может адресовать место на диске, 
как набор смежных 512 байтных блоков с произвольным доступом.
</p>

</body>
</subsection>
<subsection>
<title>Разделы и слайсы</title>
<body>

<p>
Не смотря на то, что теоретически возможно использовать весь диск для
размещения вашей Linux системы, этого почти никогда не случается на практике.
Вместо этого все большое блочное устройство (диск) разбивается на меньшие,
более удобные для обращения блочные устройства. На архитектуре amd64 они
называются <e>разделами</e>.
</p>

</body>
</subsection>
<subsection>
<title>Разделы</title>
<body>

<p>
Существуют разделы трех типов:
<e>первичные</e>, <e>расширенные</e> и <e>логические</e>.
</p>

<p>
<e>Первичный</e> раздел - это раздел, информация о котором хранится в MBR
(Master Boot Record - главная загрузочная запись). Т.к. MBR очень маленького
размера (512 байт), то может быть определено только четыре первичных раздела
(например от  <path>/dev/hda1</path> до <path>/dev/hda4</path>).
</p>

<p>
<e>Расширенный</e> раздел - это специального типа первичный раздел (имеется
ввиду, что расширенный раздел должен быть одним из четырех возможных первичных
разделов), в котором содержаться другие разделы. Этого типа разделов изначально
не существовало, но т.к. четырех разделов оказалось мало, введение
дополнительного типа разделов помогло расширить существующую схему
форматирования без потери обратной совместимости.
</p>

<p>
<e>Логический</e> раздел - это раздел внутри расширенного раздела. Его
определения не находятся внутри MBR, но прописаны внутри расширенного раздела.
</p>

</body>
</subsection>
</section>
<section>
<title>Разработка схемы разделения диска</title>
<subsection>
<title>Схема разделения по умолчанию</title>
<body>

<p>
Если вы не хотите заниматься разработкой схемы для вашей системы, вы можете
воспользоваться схемой, которую мы используем в этой книге:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Файловая система</th>
  <th>Размер</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Раздел подкачки (Swap)</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Оставшаяся часть диска</ti>
  <ti>Корневой раздел</ti>
</tr>
</table>

<p>
Если вам интересно знать какого размера должны быть разделы (или логические
тома), а равно как и сколько их вообще вам потребуется продолжайте чтение. В
противном случае переходите к главе <uri link="#fdisk">Использование fdisk для
создания разделов</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Сколько и какого размера?</title>
<body>

<p>
Количество разделов очень сильно зависит от используемого ПО. Например если в
вашей системе зарегистрировано большое количество пользователей, вероятно вы
захотите, чтобы <path>/home</path> находился отдельно для увеличения
безопасности и упрощения создания резервных копий. Если вы устанавливаете
Gentoo в качестве почтового сервера, то <path>/var</path> должен находиться на
отдельном разделе, т.к. вся почта хранится в <path>/var</path>. Правильный
выбор файловой системы для разделов позволит увеличить производительность вашей
системы. Игровые серверы должны иметь отдельный раздел с <path>/opt</path>,
т.к. большая часть ПО для их работы устанавливается в этот каталог. Причина
выделения на собственный раздел аналогична для <path>/home</path>:
безопасность и резервные копии. Разместить <path>/usr</path> на отдельном
разделе - это определенно хорошая мысль, т.к. помимо того, что здесь хранится
большинство приложений, одно дерево Portage занимает около 500 Мб не считая
архивов с исходными кодами, размещенных внутри дерева.
</p>

<p>
Как вы можете видеть все зависит от ваших целей. Наличие отдельных разделов или
томов имеет следующие плюсы:
</p>

<ul>
<li>
  Вы можете выбрать наиболее подходящую файловую систему для каждого раздела
  или тома
</li>
<li>
  Вы не столкнетесь с нехваткой места на диске для всей системы, например если  
  какое-нибудь неправильно работающее приложение постоянно производит запись на
  раздел или том.
</li>
<li>
  В случае необходимости проверка ФС займет меньше времени, т.к. проверка
  разных разделов может выполняться параллельно (однако еще больший выигрыш по
  времени дает использование нескольких физических дисков)
</li>
<li>
  Безопасность системы может быть улучшена если некоторые разделы будут
  смонтированы в режиме read-only (только для чтения), nosuid (setuid бит
  игнорируется), noexec (бит запуска игнорируется) и т.д.
</li>
</ul>

<p>
Однако создание множества разделов имеет один большой минус: при неправильной
настройке вы можете получит систему в которой много свободного места на одном
разделе и полная его нехватка на другом. Также существует ограничение, в
размере 15 штук на возможное количество разделов для дисков SCSI и SATA.
</p>

<p>
В качестве примера мы покажем диск объемом 20 Гб, используемый в составе
демонстрационного лэптопа (с установленными веб сервером, почтовым сервером,
средой Гном, ...):
</p>

<pre caption="Пример использования файловой системы">
$ <i>df -h</i>
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;не смонтирован&gt;
<comment>(Свободное пространство для будущего использования: 2 Гб)</comment>
</pre>

<p>
Раздел, содержащий <path>/usr</path>, как видим, почти полностью израсходован
(занято 83%), но когда установлено все необходимое ПО, рост раздела замедлится.
Хотя отведение нескольких гигабайт дискового пространства для <path>/var</path> 
может показаться расточительством, помните, что Portage по умолчанию использует 
этот раздел для компиляции пакетов. Если вы захотите удержать <path>/var</path> 
в рамках более разумного размера, например, 1ГБ, вам потребуется изменить
переменную <c>PORTAGE_TMPDIR</c> в <path>/etc/make.conf</path>, чтобы она 
указывала на раздел, где достаточно свободного места для компиляции чрезвычайно 
больших пакетов, таких как OpenOffice. 
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Использование fdisk для создания разделов</title>
<subsection>
<body>

<p>
Следующая часть описывает создание примерной схемы разделения диска, 
описанной ранее:
</p>

<table>
<tr>
  <th>Раздел</th>
  <th>Описание</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Загрузочный раздел</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Область подкачки</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Корневая ФС</ti>
</tr>
</table>

<p>
Измените эту схему в соответствии с вашими пожеланиями.
</p>

</body>
</subsection>
<subsection>
<title>Просмотр текущей схемы разделения диска</title>
<body>

<p>
<c>fdisk</c> - это популярная и очень мощная утилита для создания разделов на
ваших дисках. Запустите <c>fdisk</c> с указанием вашего диска в качестве
параметра (в примере мы используем <path>/dev/hda</path>):
</p>

<pre caption="Запуск fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Запустив <c>fdisk</c>, вы увидите приветственное сообщение, выглядящее примерно
так:
</p>

<pre caption="Приглашение fdisk">
Command (m for help): 
</pre>

<p>
Type <c>p</c> to display your disk's current partition configuration:
</p>

<pre caption="Примерная схема диска">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Конкретно этот диск разбит на семь Linux разделов (следует из того, что в
списке отмечено как "Linux") и один раздел подкачки (в списке отмечен как
"Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Удаление всех разделов</title>
<body>

<p>
Сначала мы удалим все существующие разделы с диска. Введите <c>d</c> для
удаления раздела. Например для удаления существующего раздела
<path>/dev/hda1</path>:
</p>

<pre caption="Удаление раздела">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Раздел будет отмечен для удаления. Он больше не будет отображаться если вы
введете <c>p</c>, но фактически он не будет удален до тех пор, пока вы не
сохраните сделанные изменения. Если вы сделали ошибку и хотите прервать работу
без сохранения изменений, немедленно введите <c>q</c> и нажмите ввод, ваш
раздел не будет удален.
</p>

<p>
Теперь, подразумевая что вы действительно хотите удалить все разделы на вашей
системе, поочередно вводите <c>p</c>, что бы посмотреть список оставшихся
разделов, потом <c>d</c> и номер раздела для удаления. В конечном итоге вы
получите пустую таблицу разделов:
</p>

<pre caption="Пустая таблица разделов">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Теперь, когда мы очистили таблицу разделов хранящуюся в памяти, настало время
создавать разделы. Мы будем использовать схему разделения диска из нашего
примера, о чем мы говорили ранее. Естественно не следуйте этим инструкциям если
не хотите получить таблицу разделов идентичную нашей!
</p>

</body>
</subsection>
<subsection>
<title>Создание загрузочного раздела</title>
<body>

<p>
В первую очередь мы создадим маленький загрузочный раздел. Введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы выбрать первичный раздел и
<c>1</c> для выбора первого первичного раздела. Когда появится вопрос о первом
цилиндре, нажмите ввод. На вопрос о последнем цилиндре введите <c>+32M</c>,
чтобы создать раздел размером 32 Мб:
</p>

<pre caption="Создание загрузочного раздела">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Нажмите ввод)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Теперь, когда вы введете <c>p</c>, вы должны увидеть следующую распечатку:
</p>

<pre caption="Созданный загрузочный раздел">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Нам необходимо сделать этот раздел загружаемым. Введите <c>a</c>, чтобы
установить флаг загрузки с раздела и выберите <c>1</c>. Если вы введете
<c>p</c> заново, то увидите символ <path>*</path>, расположенный в столбце
"Boot".
</p>

</body>
</subsection>
<subsection>
<title>Создание раздела подкачки</title>
<body>

<p>
Давайте теперь создадим раздел подкачки. Чтобы сделать это введите <c>n</c> для
создания нового раздела, затем <c>p</c>, чтобы указать fdisk'у, что вы хотите
получить первичный раздел. После этого вводите <c>2</c>, чтобы создать
первичный раздел номер два, в нашем случае <path>/dev/hda2</path>. На вопрос о
первом цилиндре просто нажмите ввод. По поводу последнего же цилиндра ответьте
<c>+512M</c>, чтобы создать раздел размером 512 Мб. После того как вы все это
проделаете, введите <c>t</c> для установки типа раздела, потом <c>2</c>, для
выбора раздела, который вы только что создали и после всего введите <c>82</c>,
чтобы выбрать для раздела тип "Linux Swap". После окончания этих процедур, если
вы введете <c>p</c>, то таблица разделов должна выглядеть примерно следующим
образом:
</p>

<pre caption="Список разделов после создания раздела подкачки">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Создание корневого раздела</title>
<body>

<p>
Ни и наконец, давайте создадим корневой раздел. Чтобы сделать это введите
<c>n</c> для создания нового раздела, затем <c>p</c>, чтобы указать fdisk'у,
что вы хотите получить первичный раздел. После этого вводите <c>3</c>, чтобы
создать первичный раздел номер три, в нашем случае <path>/dev/hda3</path>. На
вопрос о первом цилиндре просто нажмите ввод. На вопрос о последнем цилиндре
также нажимайте ввод, чтобы создать раздел, занимающий все оставшееся свободное
место на диске. После того как вы проделаете эти операции и введете <c>p</c>,
будет показана таблица разделов эквивалентная этой:
</p>

<pre caption="Список разделов после создания корневого раздела">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Сохранение созданных разделов</title>
<body>

<p>
Чтобы сохранить все сделанные изменения и выйти из <c>fdisk</c>'а, введите
<c>w</c>.
</p>

<pre caption="Сохранение и выход из fdisk'а">
Command (m for help): <i>w</i>
</pre>

<p>
Теперь, когда созданы все разделы перейдем к <uri
link="#filesystems">Созданию файловых систем</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Создание файловых систем</title>
<subsection>
<title>Введение</title>
<body>

<p>
Разделы созданы, настало время разместить файловые системы на них. Если вам
безразлично, какую ФС использовать и вы вполне довольны файловой системой,
используемой нами в этом Руководстве по-умолчанию, вы можете перейти к разделу
<uri link="#filesystems-apply">Размещение ФС на разделе</uri>. Если нет, то
продолжайте чтение и узнайте больше о доступных для использования файловых
системах...
</p>

</body>
</subsection>
<subsection>
<title>Файловые системы?</title>
<body>

<p>
Доступно несколько файловых систем. Некоторые из них признаны стабильными для
платформы amd64, другие нет. Следующие ФС признаны стабильными: ext2 и ext3.
jfs и reiserfs могут работать, но требуется дополнительное тестирование. Если в
вас достаточно авантюризма, вы можете попробовать использовать неподдерживаемые
ФС.
</p>

<p>
<b>ext2</b> - это проверенная временем и родная для Linux файловая система, но
она не обладает средствами журналирования метаданных, что при повседневном
использовании означает, что проверка целостности во время запуска системы может
оказаться весьма продолжительной. Сегодня существует достаточно широкий выбор
ФС нового поколения, т.н. журналируемых файловых систем, которые могут быть
проверены на целостность очень быстро и по этому более предпочтительны нежели
их не журналируемые собратья. Журналируемая ФС позволяет избежать долгих
задержек при старте системы и уменьшает риск порчи файловой системы.
</p>

<p>
<b>ext3</b> - это журналируемая версия ext2. Она обладает средствами
журналирования метаданных для быстрого восстановления наряду с другими
режимами ведения журнала, такими как журналирование всех данных и упорядоченное
ведение журнала данных. ext3 - это очень хорошая и надежная ФС. У нее есть
дополнительная возможность индексации через хэшированные b-деревья, что
позволяет повысить производительность практически в любой ситуации. Вы можете
включить этот способ индексации, добавив <c>-O dir_index</c> к команде
<c>mke2fs</c>. Подводя итог, можно сказать, что ext3 - превосходная ФС.
</p>

<p>
<b>ReiserFS</b> - это ФС, основанная на т.н. B*-деревьях. Она обладает очень
хорошей производительностью и сильно (иногда в 10-15 раз) превосходит ext2 и
ext3 при работе с файлами малого размера (файлами, размером менее 4k). ReiserFS
также очень хорошо масштабируется и обладает средствами журналирования. Начиная
со времени выхода ядра версии 2.4.18, ReiserFS признана стабильной и пригодной
для использования как в системах общего назначения, так и в системах с большой
нагрузкой, такой как создание больших файловых систем, использованием множества
файлов малого размера, файлов очень большого размера и каталогов, содержащих
десятки тысяч файлов.
</p>

<p>
<b>XFS</b> - это файловая система, обладающая наряду со средствами ведения
журнала хорошим набором дополнительных возможностей, оптимизированна для
хорошей масштабируемости. Мы рекомендуем ее применение только в Linux-системах
с высококлассными SCSI и / или fibre-channel дисками и оборудованными
источниками бесперебойного питания. Из-за того, что XFS очень агрессивно
кеширует данные в памяти, очень вероятная ситуация, когда неправильно
спроектированная программа (не обладающая достаточной осторожностью при записи
на файлов диск, но таких мало) может потерять большой объем информации при
неожиданном отключении питания.
</p>

<p>
<b>JFS</b> - высокопроизводительная журналируемая файловая система производства
IBM. Она только недавно получила статус готовой для применения в
промышленности. Так как история ее применения еще мала, то трудно сказать
что-то определенное о ее стабильности, плюсах и минусах.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Размещение ФС на разделе</title>
<body>

<p>
Для создания файловой системы на разделе или томе существуют утилиты для
каждого доступного типа:
</p>

<table>
<tr>
  <th>Файловая система</th>
  <th>Команда</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
К примеру, для создания загрузочного раздела (<path>/dev/hda1</path> в наших
примерах) с ФС ext2 и корневой раздел (<path>/dev/hda3</path> в наших примерах)
с ФС ext3, вы должны выполнить следующие команды:
</p>

<pre caption="Размещение ФС на разделе">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Теперь разместите файловые системы на вновь созданных разделах.
</p>

</body>
</subsection>
<subsection>
<title>Активация раздела подкачки</title>
<body>

<p>
<c>mkswap</c> - команда, используемая для инициализации раздела подкачки:
</p>

<pre caption="Создание сигнатуры раздела подкачки">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Для активации раздела подкачки используется <c>swapon</c>:
</p>

<pre caption="Активация раздела подкачки">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Создайте и активируйте раздел подкачки, используя команды, приведенные выше.
</p>

</body>
</subsection>
</section>
<section>
<title>Монтирование</title>
<body>

<p>
Теперь, когда разделы созданы и файловые системы размещены настало время
смонтировать эти разделы. Используйте команду <c>mount</c>. Не забудьте
предварительно создать необходимые каталоги для монтирования каждого раздела.
В этом примере мы монтируем корневой и загрузочный разделы:
</p>

<pre caption="Монтирование разделов">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Если вы хотите разместить <path>/tmp</path> на отдельном разделе, не забудьте
изменить права доступа к этому каталогу после монтирования: <c>chmod 1777
/mnt/gentoo/tmp</c>. В этом каталоге размещается <path>/var/tmp</path>.
</note>

<p>
Нам также необходимо будет смонтировать ФС proc (виртуальный интерфейс ядра) в
каталог <path>/proc</path>. Но для начала надо разместить необходимые нам файлы
на разделах.
</p>

<p>
Переходите к разделу <uri link="?part=1&amp;chap=5">Подготовка установочных
файлов Gentoo </uri>.
</p>

</body>
</section>
</sections>

<!-- *$Localization:
target-language: Russian
target-version: 2.5-r1
target-date: 2006-01-23
source-cvs-revision: 1.23
translated-by: Vasiliy Golubev [vas@nightmail.ru]
edited-by: none
-->
