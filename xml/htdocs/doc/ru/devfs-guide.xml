<?xml version='1.0' encoding="UTF-8"?>
<!-- REV: 1.7 -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/devfs-guide.xml,v 1.1 2004/10/07 15:51:09 sergey Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/devfs-guide.xml">
<title>Руководство по файловой системе для устройств</title>
<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Reviewer">
  <mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Translator">
  <mail link="map7000@tlen.pl">Mikhail Filatov</mail>
</author>
<author title="Editor">
  <mail link="svyatogor@gentoo.org">Sergey Kuleshov</mail>
</author>

<abstract>
Из этого документа вы узнаете что представляет из себя devfs
и как с ней работать
</abstract>

<license/>

<version>0.2</version>
<date>9 Сентября 2004г.</date>

<chapter>
<title>Что такое devfs?</title>
<section>
<title>Старые (добрые?) времена</title>
<body>

<p>
Традиционная реализация Linux предоставляет пользователю 
абстрактный каталог устройств называемый <path>/dev</path>. Внутри этого каталога
находятся <e>device nodes</e>, специальные файлы символизирующие устройства
внутри системы. Например, <path>/dev/hda</path> символизирует
первое IDE устройство в вашей системе. Файлы устройств
позволяют создавать программы которые взаимодействуют с устройствами 
так как если бы устройства были обычными файлами, вместо использования специальных API.
</p>

<p>
Файлы устройств подразделяются на две группы называемые <e>character</e>
devices (символьные устройства)и <e>block</e> devices (блочные устройства).
Первая группа содержит устройства для котрых отсутствует буферизация чтения/записи.
Вторая группа естественно содержит устройства для которых чтение/запись буферизируется.
Из обоих типов устройств может быть прочитан за раз один символ или блок.
Поэтому такой способ присваивания имён может сбивать с толку и на самом деле неправилен. 
</p>

<p>
Если посмотреть на конкретное устройство вы можете обнаружить что то похожее на это:
</p>

<pre caption = "Исследование информации о файле устройства">
# <i>ls -l /dev/hda</i>
brw-rw----    1 root     disk       3,   0 Jul  5  2000 /dev/hda
</pre>

<p>
В предыдущем примере мы увидели что <path>/dev/hda</path> это блочное
устройство. Однако важнее то что ему присвоено два специальных номера
<path>3, 0</path>. Эта пара называется <e>major-minor</e>. 
Она используется ядром чтобы соотнести файл устройства и реальное устройство.
major (старший) относится к типу устройства, minor (младший) 
к конкретному устройству.
Выглядит запутано? Неправда ли.
</p>

<p>
Ещё два примера <path>/dev/hda4</path> и <path>/dev/tty5</path>. 
Первое устройство соответствует четвёртой партиции на первом IDE устройстве.
Его пара major-minor <path>3, 4</path>. Другими словами 
minor соответствует партиции тогда как major соответствует устройству.
Второй пример имеет пару major-minor <path>4, 5</path>. В этом случае
первое число соответствует драйверу терминала тогда как второе соответствует номеру
терминала (в данном случае пятый терминал).
</p>

</body>
</section>
<section>
<title>Проблемы</title>
<body>

<p>
Если вы заглядывали в папку <path>/dev</path>, вы обнаружили
что там перечислены не только все ваши устройства но и <e>все</e> возможные
устройства которые только могут быть. Другими словами, у вас есть
файлы устройств для устройств которых у вас нет. Управление такой кучей устройств
по крайней мере можно назвать громоздким. Представьте, что надо поменять права
на все устройства релаьно существующие в вашей системе, оствив остальные без
изменений.</p>

<p>
Затем вы добавили новое оборудование в вашу систему, для него может не оказаться
уже существующего файла. Продвинутые пользователи
знают что эта задача может быть выполнена с помощью команды 
<c>./MAKEDEV</c> внутри директории <path>/dev</path>, но разве вы сразу знаете
что за устройство вам придётся создать?
</p>

<p>
Когда у вас есть программы взаимодействующие с оборудованием при помощи
файлов устройств вы не можете смонтировать корневую партицию только для чтения,
в то время как в дальнейшем нет необходимости в том чтобы она была смонтирована на 
чтение и запись. И вы не можете иметь <path>/dev</path> на отдельной партиции,
так как <c>mount</c> необходим <path>/dev</path> чтобы монтировать партиции.
</p>

</body>
</section>
<section>
<title>Решения</title>
<body>

<p>
Как вы могли себе предствить, kernel hackers нашли достаточно решений для
вышеперечисленных проблем. Однако многие из этих решений имеют собственные проблемы 
описанные в <uri>http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why</uri>.
Мы не будем обсуждать эти варианты а сконцентрируемся на 
одном способе который был реализован в официальной версии исходников ядра:
</p>

</body>
</section>
<section>
<title>devfs как абсолютный победитель?</title>
<body>

<p>
devfs решает все перечисленные проблемы. Она просто предоставляет пользователю доступ
к существующим устройствам, добавляет новые device nodes (файлы устройств) когда найдены
новые устройства, и делает возможным монтировать корневую файловую систему в режиме
read only (только чтение). А также решает многие проблемы которые мы раньше не обсуждали
потому что они не так интересны для пользователей...
</p>

<p>
Как пример, с devfs вам не надо беспокоится о паре major/minor. 
Она продолжат поддерживаться (для обратной совместимости), но в ней нет
необходимости. Это позволяет Linux поддерживать ещё больше устройств,
так как больше нет ограничений (числа всегда имеют границы :)
</p>

<p>
Однако у devfs есть свои проблемы, не столь очевидные для пользователей, но
достаточно серьезные, чтобы разработчики ядра пометили ее как <e>obsolete</e>
(устаревшее), порекомендовав использовать <uri link="udev-guide.xml">udev</uri>,
которая также поддерживается Gentoo.
</p>

<p>
Чтобы узнать, почему devfs считается устаревшей, читайте <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ">udev
FAQ</uri> и <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev_vs_devfs">udev
versus devfs document</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Навигация через дерево устройств</title>
<section>
<title>Директории</title>
<body>

<p>
Одна из первых особенностей которые вы можете заметить это то что devfs 
использует директории для объединения устройств вместе. Это повышает читабельность
так как теперь все связанные между собой устройства находятся внутри одной общей 
директории.
</p>

<p>
Например все устройства относящиеся к IDE находятся в директории
<path>/dev/ide/</path>, а все относящиеся к SCSI в директории
<path>/dev/scsi/</path>. SCSI и IDE диски во многом похожи,
у них одинаковая структура поддиректорий.
</p>

<p>
IDE и SCSI диски управляются при помощи адаптера (встроенным или отдельной платой),
называемым <e>host</e>. Каждый адаптер может иметь несколько каналов.
Канал называется <e>bus</e>. На каждом канале может быть несколько IDs (индентификаторов).
ID служит для индентификации диска. Этот ID называется <e>target</e>.
Многие SCSI устройства могут иметь множество LUN
(<e>Logical Unit Numbers (Номер Логического Устройства)</e>),
Например устройства которые управляют несколькими носителями одновременно (hi-end
tapedrives). У вас скорее всего будет только один lun, <path>lun0/</path>.
</p>

<p>
Итак несмотря на то что раньше использовался <path>/dev/hda4</path>, теперь появился
<path>/dev/ide/host0/bus0/target0/lun0/part4</path>. Это намного проще... нет, 
не спорьте со мной... это <e>проще</e>... как бы то ни было!
:)
</p>

<note>
Вы также можете использовать более похожие на Unix названия для жёстких дисков, 
такие как <path>c0b0t0u0p2</path>. Они могут быть найдены в <path>/dev/ide/hd</path>,
<path>/dev/scsi/hd</path> и.т.д.
</note>

<p>
Чтобы дать вам лучше понять идею с директориями, вот листинг директорий которые есть у меня: 
</p>

<pre caption = "Дирректории в /dev">
cdroms/     cpu/        discs/          floppy/
ide/        input/      loop/           misc/
netlink/    printers/   pts/            pty/
scsi/       sg/         shm/            sound/
sr/         usb/        vc/             vcc/
</pre>

</body>
</section>
<section>
<title>Обратная совместимость при помoщи devfsd</title>
<body>

<p>
Использование этой новой структуры выглядит здорово но многие утилиты и программы
используют предыдущую, старую структуру. Для уверенности что система не будет
нарушена был создан <c>devfsd</c>. Этот демон создаёт символьные ссылки на
новые файлы устройств но со старыми именами (compatibility symlinks).
</p>

<pre caption = "Созданные символьные ссылки">
$ <i>ls -l /dev/hda4</i>
lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -> ide/host0/bus0/target0/lun0/part4
</pre>

<p>
При помощи <c>devfsd</c>, вы можете устанавливать права доступа, создавать новые файлы
устройств и т.д. Всё это описывается в следующей главе.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Администрирование дерева устройств</title>
<section>
<title>Перезагрузка devfsd</title>
<body>

<p>
Если вы изменили файл <path>/etc/devfsd.conf</path>, и хотите чтобы 
изменения вступили в силу, вым не обязательно перезагружаться.
В зависимости от того что вы хотите, вы можете использовать любой из следующих сигналов:
</p>

<p>
<b>SIGHUP</b> заставит <c>devfsd</c> перечитать конфигурационный файл,
перегрузить разделяемые объекты (shared objects) и сгенерировать событие REGISTER
для каждого листа в дереве устройств.
</p>

<p>
<b>SIGUSR1</b> сделает то же самое, но не будет событий REGISTER.
</p>

<p>
Чтобы послать сигнал, просто используйте <c>kill</c> или <c>killall</c>:
</p>

<pre caption = "Посылка сигнала SIGHUP демону devfsd">
# <i>kill -s SIGHUP `pidof devfsd`</i>
<comment>или</comment>
# <i>killall -s SIGHUP devfsd</i>
</pre>

</body>
</section>
<section>
<title>Удаление compatibility symlinks</title>
<body>

<warn>
В настоящее время Gentoo не может существовать без этих ссылок.
</warn>

<p>
Если вы хотите удалить из вашей системы ссылки которые засоряют <path>/dev</path>
(в Gentoo они используются по умолчанию), отредактируйте
<path>/etc/devfsd.conf</path> и удалите следующие две строчки:
</p>

<pre caption = "/etc/devfsd.conf для обратной совместимости">
<comment># Закоментируйте эти две строчки для удаления симлинков</comment>
REGISTER        .*  MKOLDCOMPAT
UNREGISTER      .*  RMOLDCOMPAT
</pre>

<p>
Вам придётся перезагрузится чтобы изменения пришли в силу.
</p>

</body>
</section>
<section>
<title>Удаление возможности автосоздания файлов устройств</title>
<body>

<p>
Когда вы загружаете модуль, devfs автоматически создаёт файлы устройств.
Если вы не хотите чтоб он так делал, удалите эту строчку из 
<path>/etc/devfsd.conf</path>:
</p>

<pre caption = "/etc/devfsd.conf, autoload functionality">
LOOKUP      .*  MODLOAD
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Вопросы относящиеся к правам доступа</title>
<section>
<title>Установка/изменение прав доступа при помощи PAM</title>
<body>

<p>
Хотя вы можите установит права доступа в <path>/etc/devfsd.conf</path>, мы советуем
использовать PAM (<e>Pluggable Authentification Modules (</e>). Так как PAM 
имеет решающий голос при установке прав доступа и может проигнорировать изменения
которые вы сделали в <path>/etc/devfsd.conf</path>.
</p>

<p>
PAM использует <path>/etc/security/console.perms</path> для установки прав доступа.
Файл состоит из двух частей: в первой описываются группы, а во второй права.
</p>

<p>
Давайте сначала взглянем на часть с группами. Как пример мы рассмотрим sound-group:
</p>

<pre caption = "Sound group в /etc/security/console.perms">
&lt;sound&gt;=/dev/dsp* /dev/audio* /dev/midi* \
    /dev/mixer* /dev/sequencer* \
    /dev/sound/* /dev/snd/* /dev/beep \
    /dev/admm* \
    /dev/adsp* /dev/aload* /dev/amidi* /dev/dmfm* \
    /dev/dmmidi* /dev/sndstat
</pre>                  

<p>
Синтакс достаточно прост: вы начинаете с имени группы, и заканчиваете списком
устройств принадлежащих этой группе.
</p>

<p>
Теперь для того чтобы с группами можно было что нибудь сделать рассмотрим
следующую часть описывающую как управлять правами. 
</p>

<pre caption = "Права доступа для sound group в /etc/security/console.perms">
&lt;console&gt;  0600 &lt;sound&gt;      0600 root.audio
</pre>

<p>
Первое поле это проверка терминала. На большинстве систем, это console-group.
PAM будет проверять это поле при каждом логине. Если логин произошёл на устройстве
содержащемся в console-group, PAM проверит и возможно сменит права на некоторые файлы
устройств.
</p>

<p>
Второе поле содержит права которые установятся на файл устройства после удачного логина.
Когда человек залогинится в систему а файлы устройств принадлежат пользователю и группе
по умолчанию, PAM сменит владельца на залогиневшегося пользователя
и установит на них права из второго поля. В данном случае используется 0600 (пользователь
имеет право на чтение/запись, все остальные нет).
</p>

<p>
В третьем поле содержатся группы устройств чьи права будут изменены.
В данном случае, вторая группа (все устройства относящиеся к звуку) будут изменены.
</p>

<p>
Четвёртое поле определяет права которые будут установлены на файлы устройств 
после возврата в состояние по умолчанию. Другими словами, если человек который
владеет правами на все файлы устройств разлогинится, PAM установит
права обратно в состояние по умолчанию, описанному в этом четвёртом поле.
</p>

<p>
Пятое поле определяет собственника (с группой если вам надо) к котрому
будут установлены атрибуты устройства после возврата в состояние по умолчанию
Другими словами, если человек владеет правами на все файлы устройств разлогинится,
PAM установит собственника обратно в состояние по умолчанию, описанному в пятом поле.
</p>

</body>
</section>
<section>
<title>Установка/изменение прав доступа при помощи devfsd</title>
<body>

<p>
Если вы действительно хотите установить права используя
<path>/etc/devfsd.conf</path>, тогда используйте синтекс приведённый в этом примере:
</p>

<pre caption = "Права в /etc/devfsd.conf">
REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660
</pre>

<p>
Второе поле это группа устройств, начиная с <path>/dev</path>.
Это регулярное выражение, означающее что вы можете выбрать несколько файлов устройств
с одним правилом.
</p>

<p>
Четвёртое поле - это владелец файла устройства. В отличие от PAM
он не изменяется (если он не упоминается в <path>console.perms</path>,
так как PAM главнее).
</p>

<p>
Пятое поле содержит права на файлы устройств.
</p>

</body>
</section>
<section>
<title>Ручная установка прав и их сохранение devfsd</title>
<body>

<p>
Это обычная ситуация для Gentoo: если вы делаете <c>chown</c> (CHange
OWNer (Смена владельца)) и <c>chmod</c> (CHange MODe (Смена вида)) некоторым
файлам устройств, то <c>devfsd</c> сохраняют информацию когда вы вы выключаете систему.
Это происходит из-за того что файл <path>/etc/devfsd.conf</path> содержит следующие
строчки:
</p>

<pre caption = "/etc/devfsd.conf для сохранения прав доступа">
REGISTER        ^pt[sy]/.*   IGNORE
CHANGE          ^pt[sy]/.*   IGNORE
CREATE          ^pt[sy]/.*   IGNORE
DELETE          ^pt[sy]      IGNORE
REGISTER        ^log         IGNORE
CHANGE          ^log         IGNORE
CREATE          ^log         IGNORE
DELETE          ^log         IGNORE
REGISTER        .*           COPY    /lib/dev-state/$devname $devpath
CHANGE          .*           COPY    $devpath /lib/dev-state/$devname
CREATE          .*           COPY    $devpath /lib/dev-state/$devname
DELETE          .*           CFUNCTION GLOBAL unlink
/lib/dev-state/$devname
RESTORE         /lib/dev-state
</pre>

<p>
Другими словами, изменённые файлы усройств копируются в
<path>/lib/dev-state</path> когда выключается система, и копируются в
<path>/dev</path> когда система грузится.
</p>

<p>
Другая возможность - монтировать <path>/lib/dev-state</path> в
<path>/dev</path> во время загрузки. Чтобы это зделать,вы должны быть уверены что
devfs не монтируется автоматически (это значит, что вы должны перекомпилировать ядро) 
и что <path>/dev/console</path> существует. Затем, где-то 
в начале bootscripts (загрузочных скриптов) вашей системы, вы должны разместить:
</p>

<pre caption = "Монтирование /lib/dev-state в /dev">
mount --bind /dev /lib/dev-state
mount -t devfs none /dev
devfsd /dev
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ссылки</title>
<section>
<body>

<p>
По этим ссылкам вы можете найти дополнительную документацию:
</p>

<p>
devfsd.conf manpage описывает синтаксис файла
<path>/etc/devfsd.conf</path>. Чтобы просмотреть его напишите <c>man
devfsd.conf</c>.
</p>

<p>
<uri link="http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html">devfs
FAQ</uri> описывает всё что касается devfs. Также содержит информацию
о внутренней структуре devfs и о том как устройства могут подерживать devfs.
</p>

<p>
На <uri link="http://www.linuxjournal.com">LinuxJournal</uri> интересная статья
<uri link="http://www.linuxjournal.com/article.php?sid=6035">devfs for
Management and Administration</uri>.
</p>

<p>
Daniel Robbins написал серию статей для IBM's DeveloperWorks
о Advanced filesystems. Три из них о devfs:
</p>

<ul>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs4/">
    Introduction to devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs5/">
    Setting up devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">
    Implementing devfs</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
