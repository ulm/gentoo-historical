<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/udev-guide.xml,v 1.7 2006/03/13 14:17:21 achumakov Exp $ -->

<guide link="/doc/ru/udev-guide.xml" lang="ru" disclaimer="draft">
<title>Руководство по udev в Gentoo</title>

<author title="автор">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="участник">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="переводчик">
  <mail link="technetscaper@yahoo.com">Юрий Астахов</mail>
</author>

<abstract>
В этом документе объясняется, что такое udev и как его использовать в 
зависимости от ваших потребностей.
</abstract>

<license/>

<version>0.22</version>
<date>2006-01-05</date>

<chapter>
<title>Что такое udev?</title>
<section>
<title>Каталог /dev</title>
<body>

<p>
Когда пользователи Linux разговаривают о начинке своих систем среди людей, 
полагающих, что Linux &mdash; это какой-то вид вируса или марка кофе, пользуясь 
оборотами вроде &laquo;слэш дев слэш что&mdash;нибудь&raquo; (/dev/foo), на них 
наверняка смотрят косо. Но для счастливчиков (естественно, включая вас),
<path>/dev/hda1</path> &mdash; просто быстрый способ упоминания первого раздела
ведущего диска IDE на первичном канале. Разве нет?
</p>

<p>
Все мы знаем, что такое файл устройства. Некоторые даже знают, почему рядом с 
ними видны специальные числа, если посмотреть на результат <c>ls -l</c>, 
запущенной в каталоге <path>/dev</path>. Но мы принимаем за данность, что 
первичный ведущий диск IDE называется <path>/dev/hda</path>. У вас может быть и 
не так, но это всего лишь пример. 
</p>

<p>
Представим себе устройства &laquo;горячей замены&raquo; вроде USB, IEEE1394,
заменямой PCI и т.д. Какое из них является первым по счету? Надолго ли? Как 
изменятся названия других устройств, если первое отключить? Как это повлияет на 
текущие операции? Было бы забавно, если бы задание печати вдруг переключалось с 
вашего супернавороченного лазерного принтера на старый полудохлый матричный 
из-за того, что ваша мама решила выдернуть разъем лазерного принтера, а тот 
оказался первым в списке, не так ли?
</p>

<p>
Перейдем к <e>udev</e>. Цели проекта udev как занимательны, так и актуальны: 
</p>

<ul>
  <li>запуск драйверов в режиме пользователя</li>
  <li>динамическое создание и удаление файлов устройств</li>
  <li>согласованное назначение имен устройств</li>
  <li>
    предоставление интерфейса программирования (API) для режима пользователя
  </li>
</ul>

<p>
Разработка udev состоит из трех отдельных проектов: <e>namedev</e>, 
<e>libsysfs</e> и, конечно, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev позволяет отделить именование устройств от программы udev. Это 
дает возможность гибкого использования правил и схем именования, разработанныых
отдельно. Подсистема именования предоставляет стандартный интерфейс, который 
может использоваться udev.
</p>

<p>
Сейчас, через namedev представлена только одна схема именования, предоставляемая
LANANA. Она используется на большинстве Linux&mdash;систем, и поэтому хорошо
подходит основной массе пользователей Linux.
</p>

<p>
В namedev для определения имени конкретного устройства используется 
последовательность из пяти шагов. Если на одном из шагов имя установлено, 
оно и используется. Вот эти шаги: 
</p>

<ul>
  <li>по метке или серийному номеру</li>
  <li>по номеру устройства шины</li>
  <li>по топологии шины</li>
  <li>статическое имя</li>
  <li>имя, назначенное в ядре</li>
</ul>

<p>
<e>По метке или серийному номеру</e> &mdash; проверяется, есть ли у устройства
уникальный идентификатор. Например, у устройств USB есть уникальный серийный
номер USB, а у устройств SCSI &mdash; уникальный UUID. Если namedev находит
соответствие уникального номера и определенного конфигурационного файла, 
используется имя, указанное в конфигурационном файле.
</p>

<p>
<e>По номеру устройства шины</e> &mdash; проверяется номер устройства, 
подключаемого к шине. В среде, где нет возможности &laquo;горячей 
замены&raquo;, этого шага достаточно для идентификации устройства (например, 
номер на шине PCI редко меняется за время существования системы). Опять же, 
если namedev находит соответствие номера устройства шины и определенного 
конфигурационного файла, используется имя, указанное в конфигурационном файле.
</p>

<p>
Подобным образом, <e>по топологии шины</e> &mdash; это, скорее, статический
способ идентификации устройств, подходящий до тех пор, пока пользователь не 
начинает их переключать. Когда позиция устройства совпадает со значением, 
заданным пользователем, используется указанное имя.
</p>

<p>
Четвёртый шаг, <e>статическое имя</e> &mdash; это простая подстановка 
строки. Замененное имя присваивается, когда имя, назначенное в ядре (по 
умолчанию) совпадает с заданной строкой замены.
</p>

<p>
Последний шаг (<e>имя, назначенное в ядре</e>) покрывает все остальные случаи: 
при этом берётся имя по умолчанию, присвоенное в ядре. В большинстве 
случаев этого достаточно, поскольку имя соответствует принятому в современных 
Linux-системах.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev взаимодействует с ядром через псевдофайловую систему sysfs. Проект libsysfs
предлагает обобщенный интерфейс программирования для доступа к сведениям, 
предоставляемым файловой системой sysfs. Это даёт возможность опроса 
разнородных устройств без необходимости знания их типа.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Каждый раз, когда ядро обнаруживает обновление структуры устройств, оно 
вызывает программу <path>/sbin/hotplug</path>. Hotplug, в свою очередь, 
запускает приложения, указанные в каталоге <path>/etc/hotplug.d/default</path>, 
где также находится символическая ссылка на приложение udev. Hotplug направляет
сведения, данные ядром, в программу udev, которая производит необходимые
действия над структурой <path>/dev</path> (создавая или удаляя файлы 
устройств).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Как использовать udev в Gentoo</title>
<section>
<title>Требования к системе</title>
<body>

<p>
Файловая система udev должна использоваться вместе с ядром версии 2.6
(пакеты <c>vanilla-sources</c> или <c>gentoo-sources</c>, и профилем 2005.0).
Если вы используете такое ядро, убедитесь, что у вас есть самая последняя версия
<c>sys-apps/baselayout</c>. Вот и всё, что потребуется.
</p>

<pre caption="Установка udev">
# <i>emerge udev</i>
</pre>

<p>
udev установит пакет <c>hotplug-base</c>, как одну из зависимостей. Не нужно
устанавливать пакет <c>hotplug</c> до тех пор, пока вы хотите, чтобы модули
автоматически загружались при подключении устройств. <c>hotplug</c> также
управляет автоматическим включением сетевых устройств и загрузкой встроенного
ПО.
</p>

<pre caption="Установка дополнительных сценариев hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Если хотите, чтобы загружались модули для устройств, подключаемых до загрузки,
используйте пакет coldplug:
</p>

<pre caption="Установка пакета coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
И не забудьте добавить <c>coldplug</c> на загрузочный уровень запуска (boot):
</p>

<pre caption="Добавление coldplug на загрузочный уровень запуска">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Что же касается ядра, не забудьте выбрать следующие параметры:
</p>

<pre caption="Требуемые параметры ядра">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
По вашему усмотрению, можете оставить поддержку файловой системы <c>/dev file
system support (OBSOLETE)</c> активной, но обязательно убедитесь в том, что
параметр &laquo;Automatically mount at boot&raquo; выключен:
</p>

<pre caption="Автоматически не монтировать devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Если вы используете <c>genkernel</c>, не забудьте запустить её с параметром
<c>--udev</c>, для включения всех необходимых параметров конфигурации ядра.
Конфигурация по умолчанию, даваемая этим обращением к <c>genkernel</c>,
достаточна.
</p>

</body>
</section>
<section>
<title>Конфигурация</title>
<body>

<p>
Если вы хотите использовать улучшения udev, добавленные Gentoo для более
удобного использования, не читайте дальше. Gentoo будет использовать udev,
сохраняя неизменной структуру <path>/dev</path>, так что вы никогда не
потеряете специальные файлы устройств. Сценарии иницилизации Gentoo не будут
запускать демон devfsd и деактивируют devfs при загрузке.
</p>

<p>
Но если вы &laquo;крепкий орешек&raquo; и хотите запустить любыми
средствами систему только с udev и без улучшений, к чему и стремится разработка
udev (включая сложности в отсутствии узлов устройств, потому, что udev их ещё
не поддерживает), тогда читайте дальше :)
</p>

<p>
Мы деактивируем правила, которые сохраняют специальные файлы устройств:
отредактируйте переменную <c>RC_DEVICE_TARBALL</c> в <path>/etc/conf.d/rc</path>
и устанавите её значение на <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Если вы включили поддержку devfs в вашем ядре, вы можете деактивировать её в
конфигурации загрузчика: добавьте <c>gentoo=nodevfs</c> как параметр
ядра. Если вы хотите использовать devfs и деактивировать udev, добавьте
<c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Известные проблемы</title>
<section>
<title>Остутствие специальных файлов устройств при загрузке</title>
<body>

<p>
Если ваша машина не может успешно загрузится и выдаётся ошибка о том, что путь
<path>/dev/null</path> не найден или отсутствует первоначальная консоль, то
проблема в том, что отсутствуют некоторые файлы устройств, которые должны быть
доступны <e>до того</e>, как <path>/dev</path> смонтирован и обработан udev. Это
часто встречается на машинах, где Gentoo установлен со старых носителей.
</p>

<p>
Если вы используете <c>sys-apps/baselayout-1.8.12</c> или более позднюю версию,
эта проблема облечается, так как процесс загрузки должен управлять до полного
завершения. Однако, чтобы избавится от этих раздражающих предупреждений, вам
следует создать отсутствующие специальные файлы, как описано далее.
</p>

<p>
Выполните следующие команды для того, чтобы увидеть, какие специальные файлы
присутствуют до обработки udev в <path>/dev</path>:
</p>

<pre caption="Вывод списка специальных файлов устройств, доступных при
загрузке">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Устройства <path>/dev/null</path> и <path>/dev/console</path> необходимымы для
успешной загрузки. Если они не были показаны в предыдущем тесте, вы должны
создать их самостоятельно. Выполните следующие команды в
каталоге <path>test/dev/</path>:
</p>

<pre caption="Создание необходимых специальных файлов устройств">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Когда закончите, не забудьте отмонтировать каталог <path>test/</path>:
</p>

<pre caption="Отмонтирование каталога test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev и nvidia</title>
<body>

<p>
Если вы используете коммерческий драйвер от nVidia и сервер X не запускается
только в системе с udev, убедитесь что у вас:
</p>

<ul>
  <li>
    название модуля <c>nvidia</c> указано в файле
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    версия <c>nvidia-kernel</c> больше или равна
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    версия baselayout как минимум <c>sys-apps/baselayout-1.8.12</c> 
  </li>
</ul>

<p>
Если <c>xorg-x11</c> отказывается запускаться, возможно, отсутствует файл 
устройства <path>/dev/nvidia</path>. В этом случае запустите 
<path>/sbin/NVmakedevices.sh</path>, чтобы его создать или пересоздать.
</p>


</body>
</section>
<section>
<title>Не появляются имена LVM2</title>
<body>
 
<p>
Если вы используете вместе <c>udev</c> и Logical Volume Manager&nbsp;2
(LVM&mdash;менеджер логических разделов), вы можете заметить,
что созданные вами группы разделов и логические разделы исчезли. Что ж, на самом
деле нет, но они, к несчастью, названы <path>/dev/dm-#</path>, где
#&mdash;это 0,1,&nbsp;... и т.д.
</p>

<p>
Чтобы это исправить, отредактируйте файл
<path>/etc/udev/rules.d/50-udev.rules</path> и уберите комментарий со следующей
строки:
</p>

<pre caption="Как убрать комментарий со строки из файла
/etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k",
SYMLINK="%c"
</pre>

<p>
Далее, установите пакет <c>sys-fs/multipath-tools</c>, который содержит
программу <c>devmap_name</c>.
</p>

<pre caption="Установка пакета multipath-tools">
<comment>(На момент написания, пакет multipath-tools был доступен только в
тестовой ветке дерева Portage)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt;
/etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>Отличающиеся названия в DevFS и udev</title>
<body>

<p>
Даже если наша цель&mdash;иметь совместимую схему именований между этими
динамическими системами управления устройствами, иногда случаются различия в
именовании.
</p>

<p>
Сообщалось о коллизии в работе контроллера HP Smart Array 5i (более точно -
модуль ядра <c>cciss</c>). При использовании udev, устройства именовались как
<path>/dev/cciss/cXdYpZ</path>, где X, Y и Z - числа. При использовании devfs,
устройства именовались <path>/dev/hostX/targetY/partZ</path> или являлись
символическими ссылками на <path>/dev/ccisss/cXdY</path>.
</p>

<p>
В этом случае, не забудьте обновить файл <path>/etc/fstab</path> и
конфигурационные файлы загрузчика соответственно.
</p>

<p>
То же самое происходит со всеми символическими ссылками, которые существуют в
каталоге <path>/dev</path>, такими как <path>/dev/mouse</path>, которые
<c>udev</c> больше не создаёт. Обязательно проверьте настройку графического
сервера X и посмотрите секцию Device, указывает ли там строка настройки на
существующий файл устройства.
</p>

</body>
</section>
<section>
<title>Другие проблемы</title>
<body>

<p>
Если файлы устройств не создаются, когда соответствующий модуль
загружается из <path>/etc/modules.autoload.d/kernel-2.6</path>, но появляются
когда вы загружаете этот модуль вручную при помощи modprobe, тогда вам стоит
произвести обновление до <c>sys-apps/baselayout-1.8.12</c> или более поздней
версии.
</p>

<p>
Поддержка устройств кадрового буфера (<path>/dev/fb/*</path>) включена в ядро
с версии 2.6.6-rc2.
</p>

<p>
В ядрах старше, чем 2.6.4, вам следует явно включить поддержку для файловой
системы <path>/dev/pts</path>.
</p>

<pre caption="Включение поддержки файловой системы /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ссылки на ресурсы и благодарности</title>
<section>
<body>

<p>
Разговор об udev начался на симпозиуме по Linux в Оттаве в 2003 году (Linux
Symposium, Ottawa, Ontario Canada - 2003) Грегом Кроа-Хартманом (Greg
Kroah-Hartman) из корпорации IBM, который дал ясное понимание для применения
udev.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> - документ о udev и Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Написание правил для
udev</uri> члена сообщества разработки Gentoo Дэниела Дрэйка (Daniel Drake) -
отличный документ для того, чтобы научится управлять установкой udev.
</p>

</body>
</section>
</chapter>

</guide>

<!-- *$Localization:
target-language: Russian
target-version: 0.22-r2
target-date: 2006-02-01
source-cvs-revision: 1.28
translated-by: Yuri Astakhov

note:
Translation updated (0.22) and reviewed (revision 0.21-r3).

note:
Partially reviewed by Alexey Chumakov (chapter 1; review comments posted at 
gentoo-doc-ru)

note:
Other text reviewed by Yuri Astakhov
-->