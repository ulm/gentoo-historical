<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- REV: 1.12 -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/udev-guide.xml,v 1.1 2004/08/29 19:37:37 sergey Exp $ -->

<guide link="/doc/ru/udev-guide.xml">
<title>Руководство Gentoo по использованию udev</title>

<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributor">
  <mail link="g.guidi@sns.it">Gregorio Guidi</mail>
</author>
<author title="Translator">
	<mail link="devil@gentoo.org.ua">Alexander Simonov</mail>
</author>
<author title="Editor">
	<mail link="svyatogor@gentoo.org">Sergey Kuleshov</mail>
</author>

<abstract>
Этот документ описывает что такое "udev " и как его можно использовать для ваших
нужд.
</abstract>

<license/>

<version>0.9</version>
<date>May 27, 2004</date>

<chapter>
<title>Что такое udev ?</title>
<section>
<title>Каталог /dev</title>
<body>

<p>
Когда пользователи Linux говорят про апаратное обеспечение своих систем в обществе
людей которые верят что Linux это вид вируса или марка кофе используют выражение
"слеш dev слеш " , то замечают удивление окружающих. Но для счастливых пользователей 
Linux (вы тоже в их числе) использовать <path>/dev/hda1</path> быстрее и легче чем 
говорить про первый раздел первого главного диска. Не так ли?
</p>

<p>
Все мы знаем что в UNIX-подобных ОС устройство это файл.Некоторые знают почему 
файлы устройств имеют специальные номера, которые мы видим когда выполняем 
команду <c>ls -l</c> в каталоге <path>/dev</path>. Но мы уверены, что первый
мастер IDE диск должен быть представлен как
<path>/dev/hda</path>. Вы можете не замечать этого, но это так.
</p>

<p>
Подумайте про устройства с "горячей" заменой, таких как USB, IEEE1394, 
PCI платы с "горячим" подключением и так далее. Какое устройство первое? 
Как долго? Как будут названы другие устройства когда первый отключен? 
Какой это будет иметь эффект? Вы будете рады когда ваше задание на печать 
вдруг будет перенесено с вашего супернового лазерного принтера на ваш 
почти мертвый матричный принтер, потому что ваша мама решила отключить
ваш принтер?
</p>

<p>
Введение в <e>udev</e>. Цели проекта интересные и нужные:
</p>

<ul>
  <li>Запуск в userspace</li>
  <li>Динамическое создание/удаление файлов устройств</li>
  <li>Предоставление стандартных имен</li>
  <li>Предоставление "user-space" API</li>
</ul>

<p>
Для предоставления этих особенностей, udev разрабатываеться как три независимых проекта:
<e>namedev</e>, <e>libsysfs</e> и, конечно, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev позволяет задавать именa устройств отдельно от программы udev.
Это делает систему именования очень гибкой и позволяет использование "третьих"
схем.  Эта подсистема именования устройств дает стандартный интерфейс, который 
использует udev.
</p>

<p>
Сейчас namedev предоставляет только одну схему именования устройств; эта схема
предоставлена LANANA, которая используеться для нумерования устройств сейчас и 
потому очень ситуативна для пользователей Linux.
</p>

<p>
Namedev использует пяти-шаговую процедуру поиска имени для заданного устройства. 
Если имя устройства найдено в одном из шагов, то оно и используется . 
Вот эти шаги такие:
</p>

<ul>
  <li>метка или серийный номер</li>
  <li>номер устройства по шине</li>
  <li>топология шины</li>
  <li>статически заданное имя</li>
  <li>имя предоставленное ядром</li>
</ul>

<p>
Шаг "<e>метка или серийный номер</e>" проверяет имеет ли устройство уникальный
идентификатор. Для примера, USB устройства имеют уникальный USB серийный номер;
SCSI устройства имеют уникальный UUID. Если namedev найдет соответствие между уникальным
номером и заданным конфигурационным файлом, то будет использоваться имя заданное в 
конфигурационном файле.
</p>

<p>
Шаг "<e>шинный номер устройства</e>" проверяет номер устройства, который дает шина.
Для окружений, не поддерживающих горячее подключение  эта процедура позволяет 
определить устройство. Для примера, номера шины PCI нечасто изменяются за все 
время работы системы. И снова, если namedev найдет соответствие между уникальным 
номером и заданным конфигурационным файлом, то будет использоваться имя заданное в
конфигурационном файле.
</p>

<p>
Шаг "<e>топология шины</e>" тоже достаточно тстаический метод определения
устройства, при условии, что пользователь не переподключает их. Когда положение
устройства совпадает с настройками пользователя, используется соответствующее
имя.
</p>

<p>
Четвертый шаг - "<e>статически заданное имя</e>", - это просто строка замены.
Когда имя предоствленое ядром (имя по умолчанию) совпадает со строкой
для подстановки, оно заменяется нужным именем.
</p>

<p>
Последний шаг (<e>имя заданное ядром</e>) - выбирается стандартное
предоставленное ядром. В большинстве случаев этого вполне достаточно, т.к.
соответствует наименованию, использующемуся на данный момент в Linux системах.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev контактирует с ядром через псевдофайловую систему - sysfs. Проект libsysfs
предоставляет единый программный инетрфейс (API) для доступа к информации, 
предоставляемой файловой системой sysfs. Это позволяет обращаться к любому 
устройтву независимо от его типа.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Как только ядро замечает изменение в структуре устройств, оно вызывает программу 
<path>/sbin/hotplug</path>. Hotplug запускает приложения , которые линкованы в каталог
<path>/etc/hotplug.d/default</path> где вы также можете найти символическую ссылку
на программу udev. Hotplug передает информацию от ядра к udev, 
который производит необходимы изменения в структуре каталога <path>/dev</path>,
такие как создание и удаление файлов устройств.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Использование udev в Gentoo</title>
<section>
<title>Требования</title>
<body>

<p>
udev подразумевает использование в комбинации с ядром ветки 2.6 (таких как 
<c>development-sources</c> или <c>gentoo-dev-sources</c>). Если вы используете такое
ядро, тогда вы должны установить достаточно свежую версию
<c>sys-apps/baselayout</c>. Это все что нужно.
</p>

<pre caption="Инсталяция udev">
# <i>emerge udev</i>
</pre>

<p>
udev установит <c>hotplug-base</c>как одно из требований зависимостей.Если вы
при "горячем" подключении вашего любимого  USB или IEEE1394 устройства 
хотите исполнять специфические действия , тогда вы должны также установить 
полную версию hotplug скриптов.
</p>

<pre caption="Инсталяция полной версии hotplug ">
# <i>emerge hotplug</i>
</pre>

<p>
Относительно ядра, если вы используете установки по умолчанию заданные программой <c>genkernel</c> тогда у вас все уже есть. Иначе вам требуется при 
конфигурации ядра включить следующие опции:
</p>

<pre caption="Требуемые опции ядра">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Вы можете оставить <c>файловую систему устройств /dev (УСТАРЕЛО)</c> активной если хотите.
</p>

</body>
</section>
<section>
<title>Конфигурирование</title>
<body>

<p>
Если вы хотите использовать udev-настройки от Gentoo, делающие вашу жизнь более
комфортной, то дальше можете не читать. Вы все установили. Скрипты 
загрузки Gentoo не запустят демон devfsd и деактивируют devfs когда вы загрузитесь. 
</p>

<p>
Но если вы считаете себя крутым пользователем и хотите запустить только udev,
без наших специфичных настроек, в том виде, какой предполагался разработчиками
udev (включая проблемы потери номеров устройств, потому что udev пока этого
неподдерживает), то читайте дальше :)
</p>

<warn>
Тогда <e>не</e> жалуйтесь если что-то случиться. Вы отказываетесь от тяжелой работы
многих разработчиков Gentoo, которые корректировали ваши скрипты загрузки, что бы 
добиться стабильной работы udev с Gentoo!
</warn>

<p>
Мы деактивируем все правила сохранения файловых номеров устройств:
отредактируйте переменную <c>RC_DEVICE_TARBALL</c> в файле <path>/etc/conf.d/rc</path>
и задайте ей значение <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Если вы включили поддержку devfs в ваше ядро, то вы можете отключить эту поддержку в
файле конфигурации загрузчика: добавьте <c>devfs=nomount</c> к параметрам ядра. Если 
вы хотите использовать devfs и отключить udev - добавьте <c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Известные проблемы</title>
<section>
<title>Потеря файла устройства при загрузке</title>
<body>

<p>
Если вы неможете загрузить систему, потому что получаете ошибку про то что 
<path>/dev/null</path> несуществует или потому что потерена консоль инициализации 
системы, значит проблема в том, что некоторые файлы устройств должны существовать 
<e>до того как</e> <path>/dev</path> примонтируется и будет управляться udev. Это 
часто происходит на машинах на машинах, на которые Gentoo был установлен со старых носителей.
</p>

<p>
Если вы используете <c>sys-apps/baselayout-1.8.12</c> или новее, то это не столь
важно, т.к. процесс загрузки будет продолжен до конца. Но чтобы избвится от
надоедливых предупреждений, вы должны создать недостающие устройства, следуюя
нижеприведенным инструкциям:
</p>

<p>
Что бы посмотреть какие устройства должны быть до монтирования <path>/dev</path>
запустите следующие команды:
</p>

<pre caption="Список файлов устройств, которые должны существовать при загрузке">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Устройства нужные для корректной загрузки системы это <path>/dev/null</path> и
<path>/dev/console</path>. Если они небыли показаны в предыдущем тесте, то вы должны
их создать вручную. Выполните следующие команды в каталоге <path>test/dev/</path> :
</p>

<pre caption="Создание некоторых файлов устроуств">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Когда закончите незабудьте отмонтировать каталог<path>test/</path> :
</p>

<pre caption="Отмонтирование каталога test/ ">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev и nvidia</title>
<body>

<p>
Если вы используете проприетарные драйвера nVidia и X-сервер нестартует на
udev-only системе, тогда проверьте следующее:
</p>

<ul>
  <li>
    модуль <c>nvidia</c> прописан в
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    версия <c>nvidia-kernel</c> равняеться или больше чем
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    версия baselayout равняеться или больше чем
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

</body>
</section>
<section>
<title>Другие проблемы</title>
<body>

<p>
Если файлы устройств несоздаються когда моуль загружаеться через 
<path>/etc/modules.autoload.d/kernel-2.6</path>, но создаються когда
вы загружаете модуль вручную используя modprobe, тогда вы должны обновиться до 
<c>sys-apps/baselayout-1.8.12</c> или позже.
</p>

<p>
Поддержка устройств фреймбуфера (<path>/dev/fb/*</path>) появилась только в ядрах начиная с 2.6.6-rc2.
</p>

<p>
Для ядер младше 2.6.4 вы должны включить поддержку файловой системы
<path>/dev/pts</path> .
</p>

<pre caption="Включение поддержки файловой системы /dev/pts ">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ресурсы &amp; Благодарности</title>
<section>
<body>

<p>
На Linux Symposium (Ottawa, Ontario Canada - 2003) Грег Кроах-Хартман 
(Greg Kroah-Hartman) (Корпорация IBM) достаточно хорошо и понятно расказал 
про программы udev.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's UDEV Primer</uri> - это подробный документ про udev и Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri> 
Gentoo-разработчика Даниела Дрейка (Daniel Drake) - это превосходный документ для того что-бы научиться настраивать инсталяцию udev.
</p>

</body>
</section>
</chapter>

</guide>
