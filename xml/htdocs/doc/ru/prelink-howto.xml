<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide disclaimer="obsolete" lang="ru">
<title>Руководство по предварительному связыванию в Gentoo Linux</title>

<author title="автор">
  <mail link="cretin@gentoo.org">Stefan Jones</mail>
</author>
<author title="редактор">
  <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>
<author title="редактор">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="переводчик">
  <mail link="dzaletov@rambler.ru">Денис Залетов</mail>
</author>
<author title="редактор перевода">
  <mail link="julia_magenta@hotmail.com">Юлия Залетова</mail>
</author>
<author title="редактор перевода">
  <mail link="svyatogor@gentoo.org">Сергей Кулешов</mail>
</author>

<abstract>
Данное руководство информирует о том, как использовать поддержку
предварительного связывания в дереве портежей версии 2.0.46 или более поздней.
</abstract>

<license/>

<version>1.3</version>
<date>2003-05-12</date>

<chapter>
<title>Введение</title>
<section>
<title>
  Что такое предварительное связывание (Prelink) и как оно может помочь мне?
</title> 
<body>

<p>
Большинство приложений используют разделяемые библиотеки. Эти разделяемые
библиотеки должны быть загружены в память во время выполнения программы, при
этом необходимо определить различные символьные ссылки. Для большинства
небольших программ динамическое связывание происходит очень быстро. Но для
программ, написанных на C++, имеющих много библиотечных зависимостей,
динамическое связывание может занять много времени.
</p>

<p>
На большинстве систем, библиотеки обычно остаются неизменными и когда программа
запускается, операции необходимые для связывания, каждый раз одинаковы.
Предварительное связывание использует данную особенность, выполняя связывание и
сохраняя библиотеки в выполняемом файле, фактически уже связанными. Для
связывания, вам потребуется ld-linux.so в glibc; для распознавания
предварительного связывания версия glibc должна быть &gt;= 2.3.1-r2
</p>

<p>
Предварительное связывание может уменьшить время загрузки приложений. Например,
типичные программы KDE могут загружаться на 50% быстрее. Необходимым условием
является перезапуск процесса предварительного связывания каждый раз при
обновлении библиотек для программ, которые на них ссылаются.
</p>

</body>
</section>
<section>
<title>Резюме</title>
<body>

<ul>
  <li>
    Предварительное связывание производится программой, имеющей название, как 
    ни странно, <path>prelink</path>. Она изменяет выполняемый файл таким 
    образом, что он запускается быстрее.
  </li>
  <li>
    Если зависимые от приложения библиотеки были изменены после того, как были 
    предварительно связаны с приложением, то они потребуют повторного 
    предварительного связывания, иначе вы потеряете преимущества в скорости 
    загрузки.
  </li>
  <li>
    Изменения выполняемого файла полностью обратимы, поскольку программа 
    <path>prelink</path> имеет функцию undo.
  </li>
  <li>
    Новые версии portage могут обрабатывать, при помощи программы 
    <path>prelink</path>, изменяющиеся контрольные суммы MD5 и поля mtime 
    выполняемых файлов.
  </li>
  <li>
    У вас должен быть glibc-2.3.1-r2 или более новый, и бинарные файлы должны 
    быть скомпилированы с binutils-2.13.90.0.xx или выше.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Инициализация предварительного связывания</title>
<section>
<title>Установка программ</title>
<body>

<note>
Я подразумеваю, что у вас есть Gentoo-1.4, который был собран при помощи
gcc-3.2 или более поздней версии и binutils-2.13.90.0.xx. Это требуется для
того, что бы выполняемые файлы могли быть предварительно связаны.
</note>

<warn>
Должен быть установлен glibc 2.3.1 или более новый, иначе программа
<path>prelink</path> может испортить все ваши выполняемые файлы!
</warn>

<p>
Для начала обновите своё дерево портежей, потому что многие из необходимых
приложений часто обновляются и постоянно выходят исправления ошибок.
</p>

<pre caption="Обновление вашего дерева портежей">
# <i>emerge sync</i>
</pre>

<p>
Далее, убедитесь, что у вас установлен portage-2.0.26 или более новый. Это
требуется для того, что бы portage могло распознать предварительно связанные
выполняемые файлы и при необходимости корректно их удалить. Т.к.
предварительное связывание изменяет контрольную сумму MD5 бинарных файлов.
</p>

<pre caption="Проверка версии дерева портежей">
# <i>emerge "&gt;=portage-2.0.46"</i>
</pre>

<p>
Теперь вы можете вызвать emerge для программы предварительного связывания.
Процесс emerge автоматически проверит, что ваша система может безопасно
выполнять предварительное связывание.
</p>

<pre caption="Устанавливаем предварительное связывание">
# <i>emerge prelink</i>
</pre>

<p>
Некоторые люди, в ходе выполнения тестов, получают ошибки выполняя emerge для
программы <path>prelink</path>. Тесты размещены в пакете из соображений
безопасности, предварительное связывание будет непредсказуемым, если их
отменить. Эти ошибки обычно связаны с базовыми пакетами, такими как binutils,
gcc и glibс. В таком случае попробуйте выполнить emerge этих пакетов повторно.
</p>

<note>
Если ошибки продолжают появляться, попробуйте скомпилировать и протестировать
программу <c>prelink</c> самостоятельно (<c>./configure</c> ; <c>make</c> ; <c>
make check</c> ). В случае сбоя вы можете просмотреть *.log файлы в директории
с набором тестов. Они могут дать вам некоторые полезные подсказки.
</note>

<p>
Если вы имеете набор действий, которые демонстрируют ошибки в другой системе,
пожалуйста отправьте его <mail link="cretin@gentoo.org">Stefan Jones</mail>.
</p>

</body>
</section>
<section>
<title>Настройка</title>
<body>

<p>
Portage автоматически генерирует файл <path>/etc/prelink.conf</path>, который
говорит программе <path>prelink</path> какие файлы требуется предварительно
связать.
</p>

<p>
К сожалению, вы не сможете предварительно связать файлы, которые были
скомпилированы старыми версиями пакета binutils. Большинство таких приложений
поставляется уже скомпилированными, не имея исходных кодов, и устанавливаются в
каталоге <path>/opt</path>. Создайте следующий файл, для того, что бы запретить
программе <path>prelink</path> использовать предварительное связывание для
подобных файлов.
</p>

<pre caption="/etc/env.d/99prelink">
PRELINK_PATH_MASK="/opt"
</pre>

<note>
Вы можете добавить больше или меньше директорий, в список, разделённый
двоеточиями.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Предварительное связывание</title>
<section>
<title>Применение предварительного связывания</title>
<body>

<p>
Я использую следующую команду для предварительного связывания всех бинарных
файлов в директориях, заданных в файле <path>/etc/prelink.conf</path>.
</p>

<pre caption="Предварительное связывание заданных файлов">
# <i>prelink -afmR</i>
</pre>

<warn>
Наблюдалось, что при наличии небольшого свободного пространства в момент
выполнения предварительного связывания для всей системы, существует вероятность
усечения выполняемых файлов. Результатом может стать испорченная система.
Используйте команду <c>file</c> или <c>readelf</c> для проверки целостности
выполняемых файлов. Также вы можете заранее проверить наличие свободного места
командой <c>df -h</c>
</warn>

<table>
<tr>
  <th>Описание опций:</th>
</tr>
<tr>
  <th>-a</th>
  <ti>
    All, применить предварительное связывание ко всем выполняемым
    файлам.
  </ti>
</tr>
<tr>
  <th>-f</th>
  <ti>
    Вынуждает повторить предварительное связывание для файлов, которые уже
    подвергались ему. Это требуется т.к. программа <path>prelink</path>
    прекращает обработку существующих старых связанных файлов, зависимые
    библиотеки которых могли измениться.
  </ti>
</tr>
<tr>
  <th>-m</th>
  <ti>
    Сохраняет пространство виртуальной памяти. Это требуется, если вы имеете
    много библиотек, которые необходимо связать.
  </ti>
</tr>
<tr>
  <th>-R</th>
  <ti>
    Random, -- Выбирает случайный порядок адресов, это увеличивает безопасность
    против переполнений буферов.
  </ti>
</tr>
</table>

<note>
Более подробно об опциях можно узнать, набрав <c>man prelink</c>
</note>

</body>
</section>
</chapter>

<chapter>
<title>Известные проблемы и методы их решения</title>
<section>
<title>
  "Предварительное связывание не работает с разделяемой библиотекой, собранной
  без опции PIC"
</title>
<body>

<p>
Причиной данной проблемы являются объектные файлы разделяемой библиотеки,
скомпилированные без опции gcc -fPIC.
</p>

<p>
Далее следует список проблемных библиотек и список пакетов, для которых
требуется повторно вызвать emerge, в случае возникновения данной проблемы.
</p>

<pre caption="Исправления">
<comment>(Для библиотеки ORBit /usr/lib/libIIOP.so.0.5.17)</comment>
emerge "&gt;=sys-apps/tcp-wrappers-7.6-r4" ORBit
<comment>(Для библиотеки zlib  /usr/lib/libz.so.1.1.4)</comment>
emerge "&gt;=sys-libs/zlib-1.1.4"
<comment>(Для svgalib, /usr/lib/libsvga.so.xx)</comment>
emerge "&gt;=media-libs/svgalib-1.9.16"
<comment>(Для библиотеки XFree openGL, libGLU.so.1)</comment>
emerge "&gt;=x11-base/xfree-4.2.1-r2"
<comment>(Для libpcap.so.0.6)</comment>
emerge "&gt;=net-libs/libpcap-0.7.1-r2"
<comment>(Для библиотеки lcms, /usr/lib/liblcms.so.1)</comment>
emerge "&gt;=media-libs/lcms-1.09"
</pre>

<note>
Многие библиотеки статично связаны с zlib и/или tcp-wrappers, так что сначала
попробуйте выполнить emerge для них, после чего, повторно запустите emerge для
проблемных библиотек.
</note>

<p>
Если вы имеете проблемы с предварительным связыванием QT/KDE, то сначала
попытайтесь обновить x11-base/xfree до версии 4.2.1-r2 или более новой и
x11-libs/qt до версии 3.1.0-r1 или более новой. Если QT так и не работает,
тогда попробуйте скомпилировать его без поддержки xinerama, задав строку
myconf="-no-xinerama ${myconf}" в файле ebuild для qt.
</p>

<p>
Далее приводится список библиотек, которые пока не работают или не могут
работать вообще:
</p>

<ul>
  <li>
    Библиотеки в пакете wine, включая windex. Они в любом случае не могут
    ускорить выполняемые файлы MS Windows.
  </li>
  <li>
    Библиотека в media-video/mjpgtools, /usr/lib/liblavfile-1.6.so.0
  </li>
</ul>

<p>
Если у вас есть проблемы с библиотекой, которой нет в списке, пожалуйста
сообщите об этом, предпочтительно, добавив <c>-fPIC</c> к соответствующим
CFLAGS.
</p>

</body>
</section>
<section>
<title>
  Прерывание предварительного связывания файла, с выводом сообщения, вида:
  "1631 Aborted ...."
</title>
<body>

<p>
Вам необходимо использовать опцию <c>-f</c> программы <path>prelink</path>;
т.е. повторить предварительное связывание для всей системы с нуля. Попробуйте
запустить <c>prelink -af</c>
</p>

</body>
</section>
<section>
<title>
  "Ошибка: &lt;file&gt;: error while loading shared libraries: unexpected 
  reloc type..."
</title>
<body>

<p>
Это было исправлено в пакете <c>sys-libs/glibc-2.3.1-r2</c> 2002/11/18,
выполните emerge для glibc, если у вас более старая версия.
</p>

<p>
Так же запустите <c>prelink -u -a -m</c> ; <c>prelink -a -m</c> это должно
помочь. Если все это не помогает, просто запустите <c>prelink -u
&lt;file&gt;</c>
</p>

</body>
</section>
<section>
<title>У меня проблемы с библиотеками Nvidia openGL</title>
<body>

<p>
Ускоренные библиотеки openGL идущие с пакетом nvidia-glx скомпилированы
нестандартным образом, и программа <path>prelink</path> выводит массу
предупреждений. Здесь нет повода для беспокойства, и это не может быть
исправленo кем-либо помимо компании nvidia. Вы всегда можете вернуться к xfree
версии библиотеки libGL.so, если вам не требуется ускорение 3D. Хотя драйвер
xfree nvidia работает нормально.
</p>

</body>
</section>
<section>
<title>
  После предварительного связывания моей системы, некоторые статичные
  выполняемые файлы более не работают
</title>
<body>

<p>
Там где участвует glibc, не бывает такой вещи как 100% статичный выполняемый
файл. Если вы статично скомпилировали выполняемый файл с glibс, он может
продолжать оставаться зависимым от других системных файлов. Далее приводится
объяснение от Dick Howell.
</p>

<p>
"Я предполагал, что все должно находиться в скачанном файле и не должно быть
никаких зависимостей с локальными библиотеками на целевой системе. К сожалению,
в Linux, и я думаю везде, где используется GLIBC, это до сих пор не совсем
верно. Существует библиотека "libnss" (name service switch - переключатель
сервиса имён, некоторые люди думают, что это network secutiry system - сетевая
система безопасности) которая предоставляет функции для доступа к различным
базам данных для аутентификации, сетевой информации и для других вещей. Эта
библиотека предполагает сделать приложения независимыми от отдельно
сконфигурированных сетевых окружений машины. Хорошая идея, но изменения GLIBC
может вести к проблемам её загрузки. И вы не можете статически связать "libnss"
так как она сконфигурирована для каждой машины индивидуально. Я думаю, что,
главным образом, это происходит из-за статического связывания других GLIBC
библиотек, особенно "libpthread, "libm" и "libc", откуда приходят несовместимые
вызовы к функциям "libnss""
</p>

</body>
</section>
<section>
<title>
  Предварительное связывание обрывается с ошибкой"prelink: dso.c:306:
  fdopen_dso: Assertion `j == k' failed."
</title>
<body>

<p>
Это известная проблема любезно продиагностированная <uri 
link="http://bugs.gentoo.org/show_bug.cgi?id=13878">здесь</uri>. Программа 
<path>prelink</path> не может справиться с выполняемыми файлами сжатыми методом 
UPX. Для версии prelink-20021213 нет другого способа решить эту проблему, кроме
как спрятать выполняемые файлы во время предварительного связывания. Смотрите
<uri link="#doc_chap2_sect2">раздел конфигурации</uri> выше, где обсуждается 
вопрос о том, как это осуществить.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Заключение</title>
<section>
<body>

<p>
Предварительное связывание может решительно ускорить время запуска для
некоторых больших приложений. Его поддержка встроена в дерево портежей.
Предварительное связывание безопасно, т.к. вы всегда можете отменить его
действие для любого выполняемого файла, если вы столкнётесь с какими-либо
проблемами. Помните что когда вы обновляете glibc или другие библиотеки, с
которыми вы осуществили предварительное связывание, вам надо будет
перезапустить prelink. В общем, удачи!
</p>
</body>
</section>
</chapter>
</guide>
<!--Revision 1.17-->
