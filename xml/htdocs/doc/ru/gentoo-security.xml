<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/Attic/gentoo-security.xml,v 1.1 2004/01/26 14:52:35 sergey Exp $ -->

<!-- Synced against rev. 1.38 -->
<guide link="/doc/ru/gentoo-security.xml">
<title>Введение в систему безопасности Gentoo Linux</title>
<author title="Author">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
	<mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Translator">
	<mail link="Shurik_M@macbox.ru">Alexandr Logechnik</mail>
</author>

<license/>

<abstract>
Этот документ, шаг за шагом помогает укрепить систему безопасности Gentoo Linux.
</abstract>

<version>0.4.11</version>
<date>10 Ноябрь, 2003</date>

<chapter>
<title>Введение</title>
<section>
<body>

<p>
Этот документ предназначен для людей использующих Gentoo Linux как сервер или если они чувствуют, что их настольная система нуждается в усилении безопасности.
</p>

<note>
Если после прочтения этого документа вы заинтересованы в более обширном материале о безопасности Gentoo, посмотрите здесь - <uri link="http://www.gentoo.org/proj/en/hardened/">Проект безопасности Gentoo</uri>
</note>

</body>
</section>

<!-- 
<section>
<title>Улучшения в будущих релизах этого документа:</title>
<body>

<p>
В версии 0.6 (резервное копирование)
</p>
<ul>
<li>Arpwatch</li>
<li>Полная резервная копия системы используя Systemimager</li>
<li>Частичная резервная копия с помощью tar</li>
<li>Резервное копирование postgres</li>
</ul>


<p>
В версии 0.8 (Тест на проникновение)
</p>
<ul>
<li>Удаленный аудит</li>
<li>Сетевой аудит</li>
<li>Аудит хоста</li>
<li>Аудит ПО</li>
</ul>

<p>
В версии 1.0 (Действия после проникновения в систему)
</p>
<ul>
<li>Как описать события по инциденту</li>
<li>Судебный анализ</li>
<li>Создание образа системы без уничтожения доказательств(Используя dd)</li>
<li>Трассировка(Используя tcpdump)</li>
<li>.. и так далее ..</li>
<li>Восстановление системы</li>
</ul>

<note>
Каждая версия документа содержит добавления только одной темы, для того чтобы гарантировать качество добавленного материала.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Планирование до инсталляции</title>
<section>
<title>Безопасность физического доступа</title>
<body>

<p>
Не имеет значение сколько мер безопасности вы ввели, их все легко можно
обмануть, если атакующий имеет физический доступ к серверу. Вы должны быть
уверенны, что к вашему серверу, никто случайный не может получить доступ.
Например, установите сервер в закрытом помещении. Хорошей идеей будет закрытый
шкаф. Для более высокого уровня защиты можете установить пароль на BIOS, и
разрешить загрузку только с жесткого диска. Для пользователей лэптопов, пароль на БИОС отличная идея. 
</p>

</body>
</section>
<section>
<title>Планирование демонов/сервисов</title>
<body>

<p>
Напишите на бумаге, какие сервисы должны быть на сервере, и какие предполагаются
в будущем. Это поможет лучше составить схему разделов системы. Это также
облегчит стратегию обнаружение атак. Конечно нет смысла документировать это если
вы сами используете один или несколько компьютеров. Пример: если вы используете
один компьютер для брандмауэра, на нем не должно быть <e>никаких</e> сервисов,
исключая, возможно, sshd.
</p>

<p>
Задокументируйте это и используемую версию sshd - это поможет вам отслеживать, что в системе нуждается в обновлении если, например, кто-то найдет дыру в безопасности sshd. Также документ поможет в определении кто должен иметь доступ к системе.
</p>

</body>
</section>
<section>
<title>Схема разделов</title>
<body>

<p>
Золотые правила:
</p>

<ul>
<li>
Любая директория дерева, куда пользователи должны записывать данные
(<path>/home</path> <path>/tmp</path> <path>/var</path>), должна быть в
отдельном разделе, и должна использовать disk quotas. Portage используют
директорию <path>/var/tmp</path> для компиляции, поэтому этот раздел должен быть
большим. Это уменьшит риск того, что пользователи забьют главную точку монтирования <path>/</path>.
</li>
<li>
Любая директория в дереве, куда вы хотите инсталлировать ПО, поставляемое
отдельно от дистрибутива, должна быть на отдельном разделе. Следуя рекомендациям <uri link="http://www.pathname.com/fhs/">File Hierarchy Standard</uri>, это - <path>/opt</path> или <path>/usr/local</path>. Если это отдельные разделы, они не уничтожатся при переинсталяции системы.
</li>
<li>
Попробуйте перенести статические данные, на собственный раздел, и монтировать этот раздел в режиме read-only. Если вы настоящий параноик, можете попробовать хранить эти данные на read-only носителе, вроде CD-ROM'a.
</li>
</ul>

</body>
</section>
<section>
<title>Суперпользователь</title>
<body>

<p>
Пользователь 'root' - наиболее жизненоважный пользователь системы, и должен использоваться, только если это необходимо. Если атакующий получил root доступ, вы не можете быть уверенны в системе - переустановите ее.
</p>

<p>
Золотые правила для 'root'
</p>

<ul>
<li>
Всегда создавайте пользователя для каждодневного использования, и если пользователь требует доступ на уровне root, просто добавьте его в группу wheel. Это сделает возможным использование нормальным пользователем su для root.
</li>
<li>
Никогда не запускайте Х, или любое пользовательское приложение как root
</li>
<li>
Всегда используйте абсолютный путь, когда работаете как root, иначе вы можете запустить вовсе не то приложение, которое хотели. Например это может произойти если кто-то игрался с переменной PATH, а в зашли в режим суперпользователя без <c>su -</c>. Root будет использовать путь заданный пользователем.

</li>
<li>
Если пользователь требует только несколько команд, взамен всего что root может обычно делать, можете попробовать использовать <c>sudo</c>, но будьте осторожны с ним!
</li>
<li>
Никогда не оставляйте терминала, в котором вы залогинены как root.
</li>
</ul>

<p>
Gentoo имеет общую защиту для обычных пользователей, например докучливый <c>su</c>. По умолчанию настройки PAM позволяют пользователям, которые входят в группу wheel, использовать su.
</p>

</body>
</section>
<section>
<title>Политики безопасности</title>
<body>

<p>
Здесь приведены несколько причин, почему политики безопасности необходимы.
</p> 

<ul>
<li>
Вы не можете иметь претензии на безопасную сеть, без четкого понимания - что есть безопасность. 
</li>
<li>
Практически невозможно поймать потенциальных взломщиков, решить сетевые проблемы, или управлять аудитом сети, без просмотра сетевого трафика или заглядывании в домашние директории пользователей. Такие действия незаконны в большинстве стран, без согласия пользователя. В наши дни около 60% атак, имеют источник внутри организации, и здесь очень важно держать ухо востро. 
</li>
<li>
Вы не можете ожидать от пользователей корректных действий в смысле безопасности, если никогда не объясняли, насколько это важно или как они должны защищать самих себя и своих коллег.
</li>
<li>
Хорошие руководства и сетевая документация никогда не помешает.
</li>
</ul>

<p>
Должно быть очевидно, почему очень важно создание политик для систем, с больше чем один пользователем и почему важно обучать пользователей принципам сетевой безопасности.
</p>

<p>
Политика - это документ (или несколько документов) с ответами на вопросы, типа кто, где, что и почему. Каждый пользователь в вашей системе/сети должен прочесть, понять и подписаться под ним. Очень важно, если вы возьмете на себя задачу обьяснить и помочь понять политику, и объяснить почему политика безопасности так важна, и что произойдет если они будут нарушать политику (в документе это также должно быть описано). Раз в год, они должны перечитывать документ, ведь он может измениться, и конечно для напоминания пользователю.
</p>

<note>
Политика должна быть легкой для чтения и понимания, быть ясной в каждом из ее разделов.
</note>

<p>
Большинство пунктов политики может быть реализовано прямо в операционной системе или в брандмауэре.
</p>

<p>
Политика безопасности должна по крайней мере содержать следующие темы:
</p>

<ul>
<li>Возможность использования</li>
<li>
  <ul>
  <li>Экранных заставок</li>
  <li>Обращение с паролями</li>
  <li>Закачивание и инсталляция ПО</li>
  <li>Информационное уведомление, если за пользователями наблюдают</li>
  <li>Использование антивирусного ПО</li>
  </ul>
</li>
<li>Обращение с чувствительной информацией (в любой форме, бумажной или цифровой)</li>
<li>
  <ul>
  <li>Очистка рабочего пространство и закрытие конфиденциальной информации</li>
  <li>Выключение компьютера после ухода</li>
  <li>Обращение с шифрованием</li>
  <li>Обращение с папками для доверенных сотрудников</li>
  <li>Обращение с конфиденциальными материалами, при командировках</li>
  </ul>
</li>
<li>Обращение с компьютером при командировках</li>
<li>
  <ul>
  <li>Обращение с ноутбуками в командировках и во время проживания в отелях</li>
  </ul>
</li>
</ul>

<p>
Политика для ИТ-структуры может быть несколько иной чем для обычных пользователей.
</p>

<p>
Политика безопасности может стать огромной и жизненноважная информация может быть легко забыта. Политика для ИТ-структуры может содержать информация которая секретна для обычных пользователей, и поэтому политика должна быть разбита на несколько политик, таких как "Политика использования ПО", "Политика паролей", "политика электронной почты" и "Политика доступа в интернет".
</p>

<p>
Вы можете найти пример политики на <uri link="http://www.sans.org/resources/policies/">The SANS Security Policy Project</uri>. Если вы имеете маленькую сеть, и думаете что эта политика большая, вы можете заглянуть сюда <uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">Site Security Handbook</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Укрепление безопасности после/во время инсталляции</title>
<section>
<title>Флаг USE</title>
<body>

<p>
Файл <path>make.conf</path> содержит определенные пользователем флаги USE,
	<path>/etc/make.profile/make.defaults</path> содержит флаг USE установленный
	по умолчанию для Gentoo Linux. Для использования этого документа важны
	следующие флаги: <c>pam</c> (Подключаемый Авторизационный Модуль),
	<c>tcpd</c> (TCP оболочка) и <c>ssl</c> (Secure 
Socket Layer). Они все присутствуют в установленном флаге по умолчанию.
</p>

</body>
</section>
<section>
<title>Пароль на GRUB</title>
<body>

<p>
Grub поддерживает 2 разных пути задания пароля в его конфигурационные файлы (<path>/boot/grub/grub.conf</path>). Один с паролем в виде обычного текста, и другой с md5+salt шифрованием.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
Это добавит пароль <c>changeme</c> и если не будет введен пароль, будет просто использовать загрузку по умолчанию.
</p>

<p>
Когда добавляете пароль md5, вам необходимо конвертировать пароль в зашифрованный формат (<c>man crypt</c>), который используется в  <path>/etc/shadow</path>. Больше информации вы можете прочесть в <c>man crypt</c>. Зашифрованный пароль <e>changeme</e> должен выглядеть где-то так $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</p>

<p>
Или его можно конвертировать прямо в шеле grub'а:
</p>

<pre caption="md5crypt в шеле grub'a">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<codenote>Набираем changeme</codenote>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Тогда скопируйте и вставьте ваш пароль в <path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Таймаут в 5 секунд нужен, если система удаленная и может быть перезагружена без использования клавиатуры. Прочтите больше о пароле в grub'e просто запустив <c>info grub</c>.
</p>

</body>
</section>
<section>
<title>Пароль на LILO</title>
<body>

<p>
LILO также поддерживает два пути обращения с паролем: глобальный и на образ, оба в виде обычного текста.
</p>

<p>
Глобальный пароль устанавливается в начале файла конфигурации:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
Второй способ - задать пароль на раздел:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
Если опция <c>restricted</c> не установлена, он будет требовать каждый раз.
</p>

<p>
Чтобы новый пароль установленный <path>lilo.conf</path> вам нужно запустить <c>/sbin/lilo</c>.
</p>

</body>
</section>
<section>
<title>Ограничение использования консоли</title>
<body>

<p>

Файл <path>/etc/securetty</path> допускает указание, какие устройства <c>tty</c> (терминалы) могут аутентифицировать root'a.
</p>

<p>
Мы советуем закомментировать все строки, кроме <c>vc/1</c>. Это позволит root'у аутентифицироваться только раз на одном терминале.
</p>

<note>
Пользователи входящие в группу wheel могут использовать <c>su -</c> чтобы root на других терминалах.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Более детальное логирование</title>
<section>
<body>

<p>
Детальное логирование должно увеличить возможность поймать предупреждения или ошибки, которые могут указать на производящуюся атаку, или  уже осуществленную атаку. Атакующие часто сканируют или исследуют сеть перед атакой.
</p>

<p>
Также очень важно, чтобы log файлы были легко читаемы и удобны в управлении. При инсталляции Gentoo Linux вы можете выбрать 3 различных метода ведения логов.
</p>

</body>
</section>
<section>
<title>Логирование: Syslogd</title>
<body>

<p>
Syslogd самый распространенная программа ведения логов для Linux и в общем для
Unix. Но она не имеет возможности ротации логов. Эта возможность предоставляется запуском <path>/usr/sbin/logrotate</path> с помощью cron и настраивается в <path>/etc/logrotate.conf</path>. Как часто логи должны подвергается ротации, сжатию и удалению, зависит от загрузки системы.
</p>

<p>
Ниже - стандартный файл <path>syslog.conf</path> с некоторыми добавленными опциями. Мы раскоментировали линии <c>cron</c> и <c>tty</c> и добавили удаленный сервер логирования, для усиления безопасности вы можете записывать логи в два места.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# First some standard logfiles.  Log by facility.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Logging for the mail system. Split it up so that
# it is easy to write scripts to parse these files.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Logging for INN news system
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Some `catch-all' logfiles.
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Emergencies and alerts are sent to everybody logged in.
#
*.emerg                         *
*.=alert                        *

#
# I like to have messages displayed on the console, but only on a virtual
# console I usually leave idle.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

#Setup a remote logging server
*.*                        @logserver

# The named pipe /dev/xconsole is for the `xconsole' utility.  To use it,
# you must invoke `xconsole' with the `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: adjust the list below, or you'll go crazy if you have a reasonably
#      busy site..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
Атакующие часто пробуют уничтожить свои следы, редактируя или удаляя лог файлы. Вы можете усложнить задачу атакующему, ведя логи на одной или нескольких других машинах. Больше информации вы найдете с помощью <c>man syslog</c>.
</p>

</body>
</section>
<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> написанный Frank Dennis не позволяет вести логи на удаленной машине, но он имеет преимущество когда требуется производительность и гибкость в ведении логов. Он может вести логи по названию программы, нагрузке, средствам (как syslogd) и позволяет задавать статические выражения для запуска внешней программы в случае совпадения. Это очень хорошая возможность, для запуска любого действия когда необходимо.
</p> 

<p>
Стандартная конфигурация в принципе достаточна, но если вы например хотите быть уведомленным по электронной почте, при неверно введенном пароле - используйте соответствующий скрипт.
</p>

<p>
Для postfix:
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh для postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Для qmail:
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh для qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Запомните, чтобы сделать скрипт запускаемым запустите команду <c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c>
</p>

<p>
Затем раскомментируйте строку command в <path>/etc/metalog/metalog.conf</path>:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng обеспечивает некоторые возможности syslog и metalog с маленьким отличием. Он может фильтровать сообщения основанные на уровне и содержимом (как metalog), обеспечивает удаленное ведение логов, может обрабатывать логи от syslogd (равномерные потоки в Solaris, писать на TTY, исполнять программы и он может работать как сервер ведения логов.
По сути это лучшая программа, совмещает в себе преимущества обоих вышеуказанных программ в расширенной конфигурации. 
</p>

<p>
Классическая конфигурация, слегка измененная.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#source where to read log
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#define destinations
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#create filters
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#connect filter and destination
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#default log
log { source(src); destination(console_all); };
</pre>

<p>
Очень легко для настройки, но и очень легко пропустить что-то в конфигурации,
	потому что файл огромный. Автор обещает некоторые расширенные функции, вроде
	шифрования, авторизации, сжатия и MAC контроль (Обязательный контроль за
			доступом). С этими опциями он станет идеальным сетевым логером, так исключается возможность слежения атакующим за логами. 
</p>

<p>
Также syslog-ng имеет другие преимущества. Он не требует запуска как root!.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Монтирование разделов</title>
<section>
<body>

<p>
Когда монтируете <c>ext2</c>, <c>ext3</c> или <c>reiserfs</c> разделы, вы имеете несколько опций которые вы можете установить в <path>/etc/fstab</path>. Это:
</p>

<ul>
<li>
  <c>nosuid</c> - Игнорируем SUID-бит и работаем как с обычным файлом
</li>
<li>
  <c>noexec</c> - Запрещаем запуск программ с этого раздела
</li>
<li>
  <c>nodev</c> - Игнорируем устройствa
</li>
</ul>

<p>
К сожалению эти установки могут быть легко обойдены через не прямые пути.
Кстати, установив путь <path>/tmp</path> как неисполняемый, остановит 99% всех
детсадовских скриптов, в основном эксплойты сделаны так, чтобы запускать прямо <path>/tmp</path>.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Установка <path>/tmp</path> как <c>noexec</c> может привести к
неработоспособности некоторых скриптов.
</warn>

<note>
Информацию о дисковых квотах смотрите <uri link="#doc_chap6_sect3">Раздел о дисковых квотах</uri>.
</note>

<note>
Я не устанавливаю <path>/var</path> как <c>noexec</c> или <c>nosuid</c> даже если файлы никогда не будут исполняться из этой точки монтирования. Причина для этого, qmail инсталлируется в <path>/var/qmail</path> и ему должно быть разрешено запускать и иметь доступ к одному SUID файлу. Я устанавливаю <path>/usr</path> как read-only, так как никогда ничего туда не записываю, конечно если не хочу обновить Gentoo. Тогда я монтирую раздел как read-write, обновляю и монтирую снова.
</note>

<note>
Даже если вы не используете qmail, Gentoo требует возможности исполнения в пути
<path>/var/tmp</path>, так как компилирование ebuild происходит здесь, но может быть задан альтернативный путь, если сильно нужно иметь <path>/var</path> в <c>noexec</c> режиме.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Ограничение пользователей/групп</title>
<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
Контролирование ресурсов может быть очень эффективным, когда требуется предотвратить локальную DoS-атаку или использовать максимально возможное количество логинов для групп или пользователей.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Если вы пытаетесь установить <c>nproc</c> или <c>maxlogins</c> в 0, наверное вы должны удалить пользователя вместо этого. Пример выше устанавливает группу <c>dev</c>, настройки для процессов, настроек core и <c>maxlogins</c>. Остальные настройки устанавливаются по умолчанию.
</p>

<note>
Путь <path>/etc/security/limits.conf</path> часть PAM и используется только пакетами использующими PAM. 
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
Путь <path>/etc/limits</path> очень похож на файл лимитов <path>/etc/security/limits.conf</path>. Разница только в формате и в том что он работает только с пользователями или неопределенными пользователями(не группами). Давайте посмотрим на подходящую конфигурацию:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Здесь мы устанавливаем начальные значения и устанавливаем настройки для пользователя kn. Limits часть пакета sys-apps/shadow. Нет необходимости устанавливать какие-либо ограничения в этом файле если вы отключили <c>pam</c> в <path>make.conf</path> или не настроили PAM.
</p>

</body>
</section>
<section>
<title>Квоты</title>
<body>

<warn>
Убедитесь что ваша файловая система работает с квотами. ReiserFS не работает с ними!
</warn>

<p>
Установка квот на файловую систему предотвращает заполнение пользователями диска или записи до заполнения. Квоты разрешаются в ядре и добавляются на точку монтирования. В ядре опции которые разрешают квоты находятся в <c>File systems->Quota support</c>. Установите эти настройки, перекомпилируйте ядро и перезагрузитесь с новым ядром.
</p>

<p>
Начните установку квот <c>emerge quota</c>. Дальше измените ваш <path>/etc/fstab</path> и добавьте <c>usrquota</c> и <c>grpquota</c> на раздел, который вы хотите ограничивать в использовании места на диске, как указано ниже. 
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
На каждый раздел, на котором вы разрешили квоты, создайте файлы квот (<path>quota.user</path> и <path>quota.group</path>) и положите их в корень раздела. 
</p>

<pre caption="Создание файлов квот">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Этот шаг должен быть сделан, для каждого раздела на котором разрешены квоты. После добавления и настройки файлов, вам необходимо добавить скрипт <c>quota</c> в runlevel default.
</p>

<pre caption="Добавление quota в runlevel default">
# <i>rc-update add quota default</i>
</pre>

<p>
Дальше мы настроим систему на проверку квот раз в неделю, добавлением следующей строки в <path>/etc/crontab</path>:
</p>

<pre caption="Добавление проверки quota в crontab">
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
После перезагрузки машины, время настроить квоты для пользователей и групп. <c>edquota -u kn</c> запустит редактор определенный в $EDITOR (по умолчанию установлен nano) и вы сможете редактировать квоту для пользователя kn. <c>edquota -g</c> сделает тоже самое только для групп.
</p>

<pre caption="Настройка квот для пользователя kn">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Для дополнительной информации прочтите <c>man edquota</c> или <uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Quota mini howto</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>
	    
<p>
Если политика безопасности требует чтобы пользователи изменяли свои пароли каждую неделю, измените значение <c>PASS_MAX_DAYS</c> на 14 и <c>PASS_WARN_AGE</c> на 7. Это рекомендуется, в связи с тем что методы вроде brute force, подберут любой пароль, это только вопрос времени. Также установите <c>LOG_OK_LOGINS</c> в yes.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Файл <path>login.access</path> также часть пакета sys-apps/shadow, который дает
таблицу управлением доступа логинов. Таблица используется для того чтобы
контролировать, кто может, а кто не может логинится, основываясь на имени
пользователя, имени группы, или имени хоста. По умолчанию все пользователи
системы могут логинится, а файл содержит комментарии и примеры. Обеспечиваете ли вы безопасность сервера или рабочей станции, мы рекомендуем настраивать этот файл так, чтобы никто кроме вас не имел доступа к консоли. 
</p>

<note>
Эти настройки не применяются к root.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Будьте осторожны с настройкой этих опций, ошибка может лишить вас доступа к машине, если в не имеете доступа root.
</impo>

<note>
Эти настройки не применяются к SSH, так как SSH не исполняет <c>/bin/login</c> по умолчанию. Это может быть разрешено с помощью <c>UseLogin yes</c> в <path>/etc/ssh/sshd_config</path>. Так SSH будет использовать login и эти настройки будут распространятся и на него.
</note>

<p>
Эти настройки, для того, чтобы только члены группы wheel могли логинится локально, или например из домена gentoo.org. Может быть это слишком параноидально, но это лучше чем потом жалеть.
</p>

</body>
</section>
</chapter>

<chapter>
<title>File permissions (разрешения для файлов)</title>
<section>
<title>World readable</title>
<body>

<p>
Обычный пользователь не имеет доступа к файлам конфигурации или файлам паролей. Атакующий может украсть пароли из базы данных, или веб-сайта и использовать их для дефейса или что еще хуже, для удаления информации. Поэтому очень важно чтобы разрешения были правильными. Если вы уверены что файлы используются только root'ом установите их разрешения в <c>0600</c> и измените владельца файлов с помощью <c>chown</c>.
</p>

</body>
</section>
<section>
<title>World/Group writable</title>
<body>

<pre caption="Поиск файлов и директорий с разрешениями world-writable">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Этим вы создадите огромный файл, с списком всех файлов с разрешениями на запись для group или everybody. проверьте разрешения и устраните файлы с world-writable для everyone, с помощью <c>/bin/chmod o-w</c> для файлов.
</p>

</body>
</section>
<section>
<title>Файлы SUID/SGID</title>
<body>

<p>
Файлам с битом SUID или SGID разрешается запускать их с привилегиями владельца -
пользователя или группы <e>владельца</e>, но не запускающего файл пользователя. Обычно эти биты используются, если файлы должны запускаться как root, для их работы. Эти файлы могут послужить для компроментации root'a (если они содержать дыры в безопасности). Это очень опасно и файлов с битами SUID или SGID нужно избегать любой ценой. Если вы не используете файл, сделайте <c>chmod 0</c> для него или unmerge для его пакета (проверить из какого пакета файл можно использовать <c>qpkg -f</c>, если у вас нет этих утилит просто установите их - <c>emerge gentoolkit</c>). В противном случае просто отключите бит SUID - <c>chmod -s</c>.
</p>

<pre caption="Поиск файлов setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Это создаст файл со списком всех файлов SUID/SGID.
</p>

<pre caption="Список приложений с setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
По умолчанию Gentoo Linux имеет немного файлов с SUID (это зависит от того, что установлено в системе), но вы можете получить список всех таких файлов, как указано выше. Большая часть команд не используется обычными пользователями, только root'ом. Отключите бит SUID на <c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> и <c>traceroute</c> с помощью <c>chmod -s</c> для каждого файла. Не убирайте на <c>su</c>, <c>qmail-queue</c> или <c>unix_chkpwd</c>. При отключение его на них, вы не сможете пользоваться su и получать почту. Отключением этого бита, вы исключаете возможность использования обычным пользователем (или атакующим) этих файлов для получения root'a через любой из этих файлов. 
</p>

<p>
Только следующие файлы имеют на моей системе бит SUID - <c>su</c>, <c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> и <c>pwdb_chkpwd</c>. Но если вы запускаете Х, вы будете иметь намного больше. так как Х-ы требуют доступ.
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM - это набор разделяемых библиотек, которые обеспечивают альтернативные пути
для авторизации в программах. <c>pam</c> в USE включен по умолчанию. Таким образом установка PAM на Gentoo Linux вполне разумна, но всегда имеется место для виража. Сперва установим cracklib.
</p>

<pre caption="Установка cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_pwdb.so shadow nullok
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_pwdb.so md5 use_authtok
session	 required pam_pwdb.so
</pre>

<p>
Этим мы установим cracklib который позволяет убедится, что пользователи используют пароли длиной минимум 8 символов, содержит минимум 2 цифры, 2 других символа (например точку, или пробел) и отличие от предыдущего пароля более чем 3 символа. Это заставит пользователей выбирать хорошие пароли (подходящие по политике паролей). Посмотрите документацию здесь -<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri> для большего количества настроек .
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_pwdb.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_pwdb.so shadow md5
session	 required pam_pwdb.so
session	 required pam_limits.so
</pre>

<p>
Каждый сервис, который не настроен в файле PAM - <path>/etc/pam.d</path> будет
использовать правила из <path>/etc/pam.d/other</path>. Установки по умолчанию -
<c>deny</c>, как и должно быть. Но я люблю иметь много логов и поэтому я
добавляю <c>pam_warn.so</c>. Последней настройкой будет <c>pam_limits</c> ,
	который котролируется через <path>/etc/security/limits.conf</path>. Посмотрите - <uri 
link="#doc_chap6_sect1">/etc/security/limits.conf section</uri>, если хотите использовать больше настроек.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
иля контролирования доступа к сервисам, обычно используют inetd (которого Gentoo
		не имеет), но он может использоваться xinetd и другими сервисами.
</p>

<note>
Сервисы должны использовать tcpd в серверном аргументе вызова (в xinetd). Смотрите главу xinetd, для большей информации.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Как вы видите формат файла очень похож на <path>/etc/login.access</path>. Tcpd поддерживает специфические сервисы и они не работают в таких же зонах безопасности. Эти настройки применяются только к сервисам, которые используют tcp wrappers.
</p>

<p>
Также возможно исполнение команд, когда происходит использование сервиса (например может быть использован, когда необходимо активировать релей для dial-in пользователей), но мы не рекомендуем использовать эту возможность, так как она создает проблемы, которые трудно устранить. Примером может служить следующее, вы настроили скрипт, для посылки предупреждения каждый раз когда срабатывает deny-правило, но атакующий может запустить DoS-атаку, которая будет заставлять правило срабатывать, и вам будут посылаться сообщения, это может создать много почтовых I/O-подключения, что может вызвать проблемы с почтой. Прочтите <c>man 5 hosts_access</c> для большей информации.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Безопасность ядра</title>
<section>
<title>Удаление ненужных функций</title>
<body>

<p>
Основное правило при конфигурации ядра - удалите все, что вам не нужно. Это поможет создать маленькое ядро, но также и исключит, возможные уязвимости, которые могут быть в драйверах или некоторых функциях.
</p>

<p>
Также подумайте о возможности исключить из ядра поддержку модулей. Конечно root
kit можно установить и без этой функции, но сделать это намного сложнее.
</p>

</body>
</section>
<section>
<title>/proc (флаги ядра)</title>
<body>

<p>
Много параметров ядра могут быть изменены, через файловую систему <path>/proc</path> или с помощью <c>sysctl</c>.
</p>

<p>
Для динамического изменения параметров ядра и переменных "на лету" вам нужно указать переменную <c>CONFIG_SYSCTL</c> в ядре. Она указана по умолчанию в стандартном ядре вер. 2.4.
kernel.
</p>

<pre caption="Фильтрация пакетов ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Это действие укажет ядру просто игнорировать все ping-пакеты или сообщения
протокола ICMP тип 0. Причиной для этого служит, то что ICMP-пакеты могут
содержать больше информации чем вы думаете. Администратры используют ping как
средство диагностики и, но это не причина, чтобы внешнее подключение к интернету
отвечало на ping. Но в тоже время необходимо разрешить ping из внутренней сети.
В таком слчае можно возпользоваться настойками firewall.
</p>

<pre caption="Игнорирование широковещательных pings">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Так вы отключите ответ на ICMP-broadcast'ы, что предотвратит атаки типа Smurf.
Атака типа Smurf, работает так - посылается ping на адрес широковещательной
рассылки в сети. Обычно атакующий использует поддельный адрес источника. Все
компьютеры в сети ответят на этот адрес, и таким образом может быть поисходить
flood пакетами на этот адреса.
</p>

<pre caption="Отключение source routed пакетов (роутинг пакета происходит по адресу источника, а не по адресу назначения)">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Source routing порождается источником пакета и заставляет все маршрутизаторы по пути следования к получателю маршрутизировать пакет так, как этого захотел источник. Не принимайте source routed пакетов. Атакующий может использовать роутинг для генерации сетевого трафика инициатором которого как-будто служит хост внутри вашей сети, и происходит ответ на его запрос, так атакующий может скомпроментировать вашу сеть. Source routing редко использовался для законных вещей, так что отключите его.
</p>

<pre caption="Отключение приема redirect">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Отключите прием ICMP-redirect. ICMP-redirects может быть использован для изменения вашей таблицы маршрутизации, что очень плохо.
</p>

<pre caption="Защита против неправильных сообщений о ошибках">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Разрешите защиту против поддельных сообщения о ошибках.
</p>

<pre caption="Разрешите фильтрацию обратного пути">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>
Если вы включили IP-forwarding, вы также получите этот результат.
</note>

<p>
Включите фильтрацию обратного пути. Это поможет убедиться что пакеты используют правильный адрес источника, и автоматически отклоняются входящие пакеты, если не совпадает содержимое таблицы маршрутизации сетевого интерфейса откуда пакеты приходят с их значением источника. Это выгодно для усилений безопасности, потому что предотвращает IP-spoofing.
</p>

<warn>
Однако, включение фильтрации reverse path, может создать проблемы, если вы используете asymmetric routing (пакет в к вам от хоста имеет путь отличный, при пакете от вас к хосту) или если вы используете non-routing хост, который имеет несколько IP адресов на нескольких интерфейсах.
</warn>

<pre caption="Логирование всех spoofed, source routed и redirect пакетов">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Логирование всех spoofed, source routed и redirect пакетов
</p>

<pre caption="Отключение IP-forwarding">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Убедитесь, что IP-forwarding выключен. Это нужно только для multi-homed хостов.
</p>

<p>
Все эти настройки пропадут, после перезагрузки машины. Поэтому я предлагаю добавить следующий скрипт в runlevel <c>rc-update add procparam default</c> и сделать его исполняемым <c>chmod +x /etc/init.d/procparam</c>.
</p>

<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 use checkroot
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
Патч с <uri link="http://grsecurity.net">Grsecurity</uri> стандартный в ядре Gentoo, но отключен по умолчанию. Здесь мы его включим:
</p>

<p>
Настройте ваше ядро как обычно, а потом настройте опцию Grsecurity : (выбирите customized) и разрешите следующие опции:
</p>

<ul>
<li>Buffer Overflow Protection</li>
<li>
  <ul>
  <li>Openwall non-executable stack</li>
  <li>GCC trampoline support</li>
  </ul>
</li>
<li>Filesystem Protections</li>
<li>
  <ul>
  <li>Proc restrictions</li>
  <li>Linking restrictions</li>
  <li>Secure file descriptors</li>
  <li>Chroot jail restrictions (разрешите все опции ниже этой)</li>
  </ul>
</li>
<li>Kernel Auditing</li>
<li>
  <ul>
  <li>Log execs within chroot</li>
  <li>(Un)Mount logging</li>
  <li>Signal logging</li>
  <li>Fork failure logging</li>
  <li>Log set*ids to root</li>
  <li>Time change logging</li>
  </ul>
</li>
<li>Executable Protections</li>
<li>
  <ul>
  <li>Dmesg restriction</li>
  <li>Randomized PIDs</li>
  <li>
    Altered default IPC permissions (может помешать правильной работе некоторых программ)
  </li>
  <li>Restricted ptrace</li>
  </ul>
</li>
<li>Network Protections</li>
<li>
  <ul>
  <li>Randomized IP IDs</li>
  <li>Randomized TCP source ports</li>
  <li>Altered Ping IDs.</li>
  <li>Randomized TTL</li>
  </ul>
</li>
<li>Miscellaneous Features</li>
<li>
  <ul>
  <li>
    BSD-style coredumps (создаст coredumps вроде <path>core.named</path>)
  </li>
  </ul>
</li>
</ul>

<p>
Теперь скомпилируйте и установите security enhanced ядро.
</p>

</body>
</section>
<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> - это патч, который добавит шифрование в ядро. После его установки, вы получите новые опции в ядре, например: Cryptographic ciphers, digest algorithms и cryptographic loop filters.
</p>

<warn>
Версия патча kerneli, non-stable для последней версии ядра, будьте осторожны с его использованием.
</warn>

</body>
</section>
<section>
<title>Другие патчи ядра</title>
<body>

<ul>
<li>
  <uri link="http://www.openwall.com">The OpenWall Project</uri> (не для 2.4-ядра)
</li>
<li><uri link="http://www.lids.org">Система обнаружения атак для Linux</uri></li>
<li><uri link="http://www.rsbac.org">Rule Set Based Access Control (RSBAC)</uri></li>
<li>
  <uri link="http://www.nsa.gov/selinux">Расширение безопасности ядра</uri>
</li>
<li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
И вероятно, еще много чего....
</p>

</body>
</section>
</chapter>

<chapter>
<title>Безопасность сервисов</title>
<section>
<title>Использование xinetd</title>
<body>

<p>
xinetd -это замена для inetd (которого в Gentoo нет :), - internet services daemon. Он поддерживает контроль доступа по адресу удаленного хоста и по времени доступа. Также обеспечивает расширенное логирование событий, включая время запуска сервера, адресов удаленных хостов, имя пользователя авторизованного удаленно, uptime (продолжительность работы сервера) и действие по требованию.
</p>

<p>
Как и со всеми другими сервисами, очень важно иметь хорошую начальную настройку. Но так как <c>xinetd</c> требует запуска как root и поддерживает протоколы, возможности которых вы не знаете, мы не рекомендуем использовать его. Но если вы все равно хотите пользоваться им, вы можете усилить его безопасность:
</p>

<pre caption="Установка xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Отредактируйте файлы конфигурации:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# This will setup pserver (cvs) via xinetd with the following settings:
# max 10 instances (10 connections at a time)
# limit the pserver to tcp only
# use the user cvs to run this service
# bind the interfaces to only 1 ip
# allow access from 10.0.0.*
# limit the time developers can use cvs from 8am to 5pm
# use tpcd wrappers (access control controlled in 
# <path>/etc/hosts.allow</path> and <path>/etc/hosts.deny</path>)
# max_load on the machine set to 1.0
# The disable flag is per default set to no but I like having 
# it in case of it should be disabled
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Для большей информации прочтите  <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
Только организация защиты OpenSSH требует включения мощной системы авторизации основанной на шифровании открытым ключем. Много сайтов (вроде <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> и <uri>http://www.apache.org</uri>) были взломаны, благодаря утечкам паролей или благодаря плохим паролям.
</p>

<pre caption="/etc/ssh/sshd_config">
#Only enable version 2
Protocol 2

#No direct root access
PermitRootLogin no

#Turn on RSA key authentication
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Disable .rhost files and normal password auth.
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Only people in the wheel or admin group can be given access
AllowGroups wheel admin

#Of all the people in those groups, only kn and bs really have access
AllowUsers kn bs

#add logging level
SyslogFacility AUTH
LogLevel INFO

#bind
ListenAddress 127.0.0.1
</pre>

<p>
Теперь все что требуется от пользователей, создать ключ (на машинах, откуда они хотят логиниться) с помощью следующей команды:
</p>

<pre caption="Создание пары ключей RSA">
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>

<p>
И ввести пароль
</p>

<pre caption="Вывод на екран ssh-keygen">
Generating public/private rsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_rsa):<c>[Press enter]</c>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <c>[Enter passphrase]</c>
Enter same passphrase again: <c>[Enter passphrase again]</c>
Your identification has been saved in /home/kn/.ssh/id_rsa.
Your public key has been saved in /home/kn/.ssh/id_rsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Это добавит два файла в каталог <path>~/.ssh/</path> - <path>id_rsa</path> и <path>id_rsa.pub</path>. Файл <path>id_rsa</path> - это приватный ключ и он должен быть сохранен от доступа других людей, кроме вас. Другой файл - <path>id_rsa.pub</path> передается любому серверу, к которому вы хотите иметь доступ. Добавьте ключи  в дериктория пользователя, в <path>~/.ssh/authorized_keys</path>, после этого пользователь будет иметь возможность логиниться.
</p>

<p>
Теперь пользователи должны хорошо беречь свой ключ. Запишите его на любой носитель, который всегда с вами, или сохраните на их рабочей станции (добавьте это в <uri link="#doc_chap2_sect5">политику использования паролей</uri>).
</p>

<p>
Для большей информации посмотрите сайт - <uri link="http://www.openssh.org">OpenSSH</uri>.
</p>

</body>
</section>
<section>
<title>X</title>
<body>

<p>
По умолчанию XFree настроен как Xserver. Это может быть опасным, так как пользователи Х используют нешифрованное ТСР-соединение и открыт для подключения xclient. 
</p>

<impo>
Если вам не нужен этот сервис - отключите его!
</impo>

<p>
Но если вы хотите использовать вашу рабочую станцию как Xserver используйте команду <c>/usr/X11R6/bin/xhost</c> с осторожностью. Это команда позволяет иметь доступ пользователей с других хостов, для подключения к Х. Это может быть использовано, если вам необходимо, какое-то Х-приложение с другой машины, только через сеть. Синтаксис - <c>/usr/X11R6/bin/xhost +имя_хоста</c>
</p>

<warn>
Никогда не используйте <c>xhost +</c>! Это сделает возможным подключение любого клиента и контролирование Х. Если атакующий имеет доступ к Х, он может отследить ваши нажатия клавиш и контролировать desktop. Если вы пользуетесь им, всегда указывайте хост.
</warn>

<p>
Лучшее решения для безопасности, полное отключение этой возможности при старте Х - <c>startx -- -nolisten tcp</c> или отключить ее совсем в конфигурации.
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Убедитесь что <path>startx</path> не перезаписывается, когда устанавливается
новая версия XFree, тогда вы должны защитить его. Добавьте следующую строку в <path>/etc/make.conf</path>:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Если вы используете графический login manager, вам нужно другое решение.
</p>

<p>
For <c>gdm</c> (Gnome Display Manager)
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Для <c>xdm</c> (X Display Manager) и <c>kdm</c> (Kde Display Manager)
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Обычно использование FTP (File Transfer Protocol) плохая идея. Он использует
нешифрованные данные, прослушивает два порта (обычно 20 и 21 порты), и можно
логиниться как anonymous, поэтому многие атакующие ищут открытый FTP. Так как
FTP-протокол имеет проблемы с безопасностью, вы должны использовать <c>sftp</c>
или HTTP вместо него. Если нет, усильте безопасность вашего сервиса, так хорошо
как вы можете и готовьтесь к чему угодно.
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd - это ответвление от trollftpd. Он был изменен для по причинам безопасности и функциональности Frank'ом Dennis'ом.
</p>

<p>
Используйте виртуальных пользователей (никогда системные акаунты) путем задания опций <c>AUTH</c>. 
Установите ее в - <c>-lpuredb:/etc/pureftpd.pdb</c> и создайте пользователей используя <c>/usr/bin/pure-pw</c>. 
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
И настройте <c>MISC_OTHER</c> для запрещения авторизации anonymous (<c>-E</c>),
	использовать chroot для каждого пользователя (<c>-A</c>), пользователь не
	может читать/записывать файлы имя которых начинается с точки (<c>-X</c>), максимальное время неактивности пользователя (<c>-I</c>), лимит рекурсии (<c>-L</c>) и корректность <c>umask</c>.
</p>

<warn>
НЕ используйте опции <c>-w</c> или <c>-W</c>! Если вы хотите иметь у себя сайт вареза, перестаньте читать этот документ!
</warn>

<p>
Документацию вы можете найти здесь - <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd имел несколько проблем с безопасностью, но большинство уже решены. Давайте немного расширим безопасность:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#Don't show the ident of the server
ServerIdent on "Go away"

#Makes it easier to create virtual users
RequireValidShell off

#Use alternative password and group file (passwd uses crypt format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissions
Umask 077

# Timeouts and limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Chroot everyone
DefaultRoot ~

#don't run as root
User  nobody
Group nogroup

#Log every transfer
TransferLog /var/log/transferlog

#Problems with globbing
DenyFilter \*.*/
</pre>

<p>
Вы можете найти документацию - <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (сокращение от - very secure ftp) маленький ftp-daemon, работает корректно с начальными установками. Он прост и не имеет не много функций (вроде виртуальных пользователей) как pureftp и proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#read only
write_enable=NO

#enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Как вы видите, нет возможности для индивидуальных разрешений и по умолчанию отключен chroot. Но подход к настройкам  anonymous, очень хорош. Иногда когда требуется иметь доступ anonymous на ftp-сервер - vsftpd действительно хорошо решает подобные задачи.
</p>

</body>
</section>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) идет с весьма неплохой конфигурацией. Мы улучшим некоторые вещи, вроде привязки на один адрес и исключения возможности утечки информации. Следующие опции вы должны изменить в конфигурационном файле: 
</p>

<p>
Если вы не отключили <c>ssl</c> в <path>/etc/make.conf</path> перед инсталляцией apache, вы должны иметь доступ к запущенному ssl-серверу. Просто добавьте следующую строку:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Make it listen on your ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#It is not a good idea to use nobody or nogroup - 
#for every service not running as root 
#(just add the user apache with group apache)
User apache
Group apache
#Will keep apache from telling about the version
ServerSignature Off
ServerTokens min
</pre>

<p>
Apache компилируется с опциями <c>--enable-shared=max</c> и <c>--enable-module=all</c>. Это по умолчанию разрешает все модули, так что вы должны закомментировать все модули которые вы не используете в разделе <c>LoadModule</c> (<c>LoadModule</c> и <c>AddModule</c>). Перезапустите сервис после завершения, <c>/etc/init.d/apache restart</c>.
</p>

<p>
Вы можете найти документацию - <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<section>
<title>Qmail</title>
<body>

<p>
Qmail самый защищенный почтовый сервер. Он написан с самого начала с идеей безопасности. Он не допускает релея по умолчанию и не имеет дыр в безопасности с 1996 года. Просто сделайте <c>emerge qmail</c>.
</p>

</body>
</section>
<section>
<title>Bind</title>
<body>


<p>
Вы можете найти документацию - <uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software Consortium</uri>, также вы можете найти "BIND 9 Administrator Reference Manual" в <path>doc/arm</path>.
</p>

<!--
<p>
По умолчанию Gentoo не имеет конфигурации для этого сервиса, так что вам нужно добавить ваши DNS-зоны самому <path>/etc/bind/named.conf</path>. Но так как дыры в безопасности присутствуют не только в сервисах, но и в протоколах, они должны быть правильно настроены:
</p>

<p>
Люди часто спрашивают, почему не использовать djbdns (очень защищенный DNS server написанный D.J. Bernstein) - потому что Bind имеет возможности, которых в djbdns нет, вроде поддержки IPv6 (с патчем или без него).
</p>

<pre caption="/etc/bind/named.conf">
#setup access control
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
#allow "mynet" to make queries
  allow-query { "mynet"; };
#don't allow zone transfers
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
#Only provide recursive service to "mynet"
  recursion no;
  allow-recursion { mynet; };
# Bind to an interface
  listen-on { 10.0.0.1; };
# Don't show the version
  version "Go away";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

#allow only control from localhost and with a key
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>

<p>
Это хорошая настройка по умолчанию. Как бы то ни было Bind 9-ой версии имеет возможность <c>chroot</c> которую вы должны использовать. Далее описано как настроить chrooted-bind:
</p>

<pre caption="Подготовка chroot-окружения">
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>

<p>
Это создаст chroot-окружение в <path>/chroot</path>. Теперь все что мы должны сделать, это изменить init-скрипт для поддержки нового окружения. Поправьте <path>/etc/init.d/named</path> и добавьте <c>-t /chroot/dns</c> в функцию старта. Так же измените функцию stop, где указывается pid-файл - <path>/chroot/var/run/named/named.pid</path>. Перезапустите ваш DNS-сервер.
</p>

<note>
Атакующий может выйти за границу chroot, если он достаточно умен (прочтите как пресечь это в разделе патчей ядра).
</note>
-->

</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Здесь действительно нечего сказать о djbdns, за исключением того, что автор предлагает <uri link="http://cr.yp.to/djbdns/guarantee.html">деньги</uri> за найденную дыру в безопасности. Так что можете попробовать его использовать  <uri>http://www.djbdns.org/</uri> он очень отличается от Bind v.9, но вы можете попробовать его использовать.
</p>

</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba это протокол для передачи файлов в сетях Microsoft/Novell и он <e>не должен</e> использоваться через Internet. Но никогда не помешает укрепить безопасность.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Bind to an interface
  interfaces = eth0 10.0.0.1/32

  #Make sure to use encrypted password
  encrypt passwords = yes
  directory security mask = 0700

  #allow traffic from 10.0.0.*
  hosts allow = 10.0.0.

  #Enables user authentication 
  #(don't use the share mode)
  security = user
  
  #Disallow privileged accounts
  invalid users = root @wheel

  #Maximum size smb shows for a share (not a limit)
  max disk size = 102400

  #Uphold the password policy
  min password length = 8
  null passwords = no

  #Use PAM (if added support)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Убедитесь что разрешения - корректны для каждой общей папки и прочтите документацию - <uri link="http://www.samba.org">documentation</uri>.
</p>

<p>
Теперь перезапустите сервер, и добавьте пользователей, которые должны иметь доступ к этому сервису. Это делается с помощь  <path>/usr/bin/smbpasswd</path> с параметром -a.
</p>

</body>
</section>
<section>
<title>Chroot или виртуальные сервера</title>
<body>

<p>
Chrooting для сервиса - путь для ограничения окружения сервиса (или
		пользователя), для доступа его только к тому что нужно и закрытия путей
(или информации) для приобретения прав root. Если сервис запущен как любой
другой пользователь (nobody, apache, named) атакующий может иметь доступ к
файлам с правами этого пользователя. Это означает что атакующий не может
получить прав root, даже если сервис имеет дыру в безопасности.
</p>

<p>
Некоторые сервисы вроде pure-ftpd и bind имеют возможности для chroot'инга, а другие нет. Если сервис поддерживает его - используйте, иначе ищите как его сделать. Давайте посмотрим как можно сделать chroot, для начального понимания работы chroot, мы протестируем его на примере <c>bash</c>.
</p>

<p>
Создайте директорию <path>/chroot</path> (<c>mkdir chroot</c>). И найдите динамические библиотеки которые необходимы <c>bash</c> (если скомпилирован с опцией <c>-static</c> этот шаг можно пропустить):
</p>

<p>
Эта команда создаст список библиотек используемых bash. 
</p>

<pre caption="Создание списка используемых библиотек">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Теперь давайте создадим окружение для bash.
</p>

<pre caption="Создание chroot-окружения для bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Дальше скопируем файлы используемые bash (<path>/lib</path>) в chroot директорию
lib и скопируем команды bash в директорию chroot bin. Это создаст точную копию
окружения, только меньшей функциональности. После копирования попробуйте
выполнить: <c>chroot /chroot/bash</c>. Если вы перейдете в корень вашего
каталога <path>/</path>, вы увидите что это работает. Иначе вы увидите сообщение
о том что файлы отсутствуют. Нехватает некоторых библиотек для библиотек
bash'a. Некоторые библиотеки могут зависить от других библиотек.
</p>

<p>
Внутри chroot-окружения ничего не будет работать кроме <c>echo</c>. Это потому что в окружении нет других команд, а <c>echo</c> это встроенная возможность bash.
</p>

<p>
Это все что можно для начала сказать о сервисах в chroot. Одно но: сервис иногда зависит от устройств и конфигурационных файлов <path>/etc</path>. Просто скопируйте их (устройства могут быть скопированы с помощью <c>cp -a</c>) в chroot-окружение, поправьте init-скрипт для использования chroot перед исполнением. Это может трудно найти какие устройства и конфигурационные файлы используются сервисом. Поэтому можно использовать <c>strace</c> для этого. Запустите сервис с <c>/usr/bin/strace</c> и просмотрите на открытые для чтения, записи файлы, также на соединения открытые сервисом. Так вы можете понять, какие устройства и файлы необходимо скопировать. Но в большинстве случаев достаточно просто скопировать файл passwd (отредактируйте копию и удалите пользователей которые ничего не требуются для сервиса), <path>/dev/zero</path>, <path>/dev/log</path> и <path>/dev/random</path>.
</p>

<p>
Другой способ создания безопасного окружения - использование виртуального окружения сервера. Это создаст копию существующего Linux'а и boot-файлов в виртуальном режиме. Это значит что если сервер будет взломан, это будет только виртуальный сервер, но не настоящая инсталляция.
</p>

<p>
Пример виртуального сервера
</p>

<ul>
<li>
  <uri link="http://user-mode-linux.sourceforge.net">User-Mode Linux</uri> и howto про <uri link="http://www.gentoo.org/doc/uml.html">User-Mode Linux</uri>.
</li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Брандмауэры</title>
<section>
<title>Брандмауэр</title>
<body>

<p>
Люди часто думают что брандмауэр обеспечивает совершенную защиту, но это
неправильно. В большинстве случаев лучше вообще не иметь брандмауэра, чем иметь
его с неправильной конфигурацией. Брандмауэр - это ПО, и оно требует такой же настройки как и все остальные программы, потому что он тоже может содержать ошибки.
</p>

<p>
Поэтому подумайте перед использованием. Вам он действительно необходим? Если вы думаете что брандмауэр вам необходим, опишите в политике как он должен работать, тип брандмауэра и кто должен им управлять. Но сначала прочтите этот документ.
</p>

<p>
Брандмауэры используются для двух случаев:
</p>

<ul>
<li>Оградиться от пользователей (от червей/атакующих)</li>
<li>Оградить пользователей (работников/детей)</li>
</ul>

<p>
Обычно есть 3 типа брандмауэров:
</p>

<ul>
<li>Фильтрации пакетов</li>
<li>Релеинг соединений</li>
<li>Программный gateway</li>
</ul>

<p>
Брандмауэр должен быть на для отдельной машине, на которой не запущено сервисов (или только <c>sshd</c>), это рекомендуется для безопасности.
</p>

</body>
</section>
<section>
<title>Фильтрация пакетов</title>
<body>

<p>
Весь сетевой трафик идет в форме пакетов. Большая сумма трафика также разбивается на маленькие пакеты для легкости обработки и потом собираются при достижении пункта назначения. В заголовке каждого пакета содержится информация о том как и куда он должен доставляться. Именно эта информация и используется когда пакет фильтруется брандмауэром. Фильтрация основана на:
</p>

<ul>
<li>Разрешении/запрещении пакетов по источнику/месту назначения IP-адреса</li>
<li>Разрешении/запрещении пакетов по порту источника/места назначения</li>
<li>Разрешении/запрещении пакетов по протоколу</li>
<li>Разрешении/запрещении пакетов по флагу указанного протокола</li>
</ul>

<p>
Т.е. фильтрация основана на информации присутствующей в заголовке пакета а не по содержимому пакета.
</p>

<p>
Недостатки:
</p>

<ul>
<li>
IP-адрес в пакете может быть поддельным или так называемым <e>spoofed</e> (когда адрес источника существует, но пакет отправляется атакующим с другого хоста, то есть просто подделывает пакет)
</li>
<li>
Информация в пропущенном пакете может содержать данные которые атакующий может
использовать для эксплуатации известных дыр в сервисах за брандмауэром.
</li>
<li>Обычно один пункт назначения для запрета</li>
</ul>

<p>
Преимущества:
</p>

<ul>
<li>Простота и легкость в использовании</li>
<li>
Может посылать предупреждения о возможной атаке, до того, как она начнется (т.е. отслеживание сканирования портов)
</li>
<li>Хороши для предотвращения SYN-атак</li>
</ul>

<p>
Пример свободно распространяемых брандмауэров для Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

</body>
</section>
<section>
<title>Релеинг соединений</title>
<body>

<p>
Также используется релеинг соединений, когда брандмауэр проверяет соединение
перед разрешением обмена данных. Т.е. соединение не просто разрешается или
запрещается основываясь на заголовке пакета, но по набору конфигурируемых правил
тестируется соединение. Фильтрация основывается на таких методах:
</p>

<ul>
<li>Источник/пункт назначения IP-адреса</li>
<li>Порт источника/пункта назначения</li>
<li>Период времени</li>
<li>Протокол</li>
<li>Пользователь</li>
<li>Пароль</li>
</ul>

<p>
Весь трафик проверяется, подвергается мониторингу и весь нелегальный трафик может быть отклонен.
</p>

<p>
Недостатки:
</p>

<ul>
<li>
Оперирование происходит на уровне "Transport Layer" и может потребовать
существенной изменения программирования, которое обычно предоставляет
транспортные функции.
</li>
</ul>

</body>
</section>
<section>
<title>Программный gateway</title>
<body>

<p>
Программный gateway служит прокси сервером для приложений и осуществляет от их
имени обмен данными. Он находится в дали от посторонних глаз за DMZ
(демилитаризованная зона - часть внутренний сети, которая видна сквозь firewall)
или за firewall'ом который не разрешает внешних подключений. Фильтрация основана на:
</p>

<ul>
<li>Разрешении или запрещении по источнику/пункту назначения IP-адреса</li>
<li>По содержимому пакета</li>
<li>Ограничение доступа к файлам по типу файла или расширению</li>
</ul>

<p>
Преимущества:
</p>

<ul>
<li>Можно кэшировать файлы, увеличивая производительность сети</li>
<li>Детальное логирование всех соединений</li>
<li>Отличное масштабирование (некоторые прокси могут обеспечивать общий доступ к кэшированной информации)</li>
<li>Нет прямого доступа из вне</li>
<li>Может изменять содержимое пакета на лету</li>
</ul>

<p>
Недостатки:
</p>

<ul>
<li>Достаточно сложная настройка</li>
</ul>

<p>
Программные прокси считаются наиболее безопасными, так как не требуют запуска от имени root и к сети за хостом нет доступа из интернета.
</p>

<p>
Пример свободно распространяемых программных прокси:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Для того чтобы iptables работал, он должен быть разрешен в ядре. Вы можете добавить его как модуль (команда <c>iptables</c> загрузит необходимый модуль, когда он необходим) и скомпилируйте свое ядро. Для большей информации, как его настроить прочтите <uri link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables Tutorial Chapter 2: Preparations</uri>. После того как у вас будет скомпилировано новое ядро (или пока оно компилируется) вы можете установить  <c>iptables</c>. Просто сделайте <c>emerge iptables</c> и он должен заработать.
</p>

<p>
Теперь давайте попробуем запустить его - <c>iptables -L</c>. Его что-то не так, проверьте свою конфигурацию.
</p>

<p>
Iptables - новый,усовершенствованный, брандмауэр в ядре Linux 2.4.x. Он является
продолжение брандмауэра ipchains, который присутствует в ядре Linux 2.2.x. Одно
из главных улучшений - iptables имеет возможность фильтрации пакетов по статус соединения (stateful filter). С такой фильтрацией возможно отслеживать каждое TCP-соединение.
</p>

<p>
TCP-соединение состоит из серий пакетов содержащих информацию о IP-адресе источника, IP-адресе пункта назначения, последовательный номер пакета (чтобы пакеты могли быть пересобранны в случае ошибки, чтобы не потерять данные). ТСР это connection-ориентированный протокол, в отличии от UDP, который не устанавливает соединение.
</p>

<p>
При проверке заголовка TCP-пакета, статусный фильтр может определить: принятый пакет часть уже установленного соединения или нет и решить - принимать его или отвергнуть.
</p>

<p>
С stateless-фильтром (фильтр не изменяет своего состояния во время выполнения) возможно обмануть фильтр, и пакет будет принят, хотя должен был быть отвергнут при проверке ТСР-заголовка. Это может быть сделано путем манипуляции с SYN-флагом или другими флагами TCP-заголовка. С stateful-фильтрацией возможно отвергнуть пакет, который не является частью уже установленного соединения. Это также исключит возможность так называемого "stealth-сканирования" так как пакеты не части уже установленных соединений.
</p>

<p>
Iptables обеспечивают несколько других функций вроде NAT (Network Address Translation) и шейпинга трафика (ограничение пропускной способности соединения). Шейпинг трафика в высшей степени полезно при пресечении DoS-атак (Denial of Service) вроде атак SYN-flood.
</p>

<p>
TCP-соединение устанавливается после тройного рукопожатием. Когда устанавливается ТСР-соединение клиент посылает пакет с установленным SYN-флагом в заголовке к серверу, сервер отвечает SYN+ACK-пакетом к клиенту. Когда SYN+ACK-пакет принят клиентом, он отвечает третьим АСК-пакетом, в подтверждение установленного соединения.
</p>

<p>
SYN-flood атака проводится путем посылки SYN-пакета, но не отвечая на SYN+ACK-пакет packet. Клиент может подделать IP-адрес, ведь ему не требуется получение ответа. Серверная сторона добавит соединения в очередь полуоткрытых, когда примет SYN-пакеты и будет ожидать ACK-пакета перед удалением соединения из очереди. Эта очередь ограничена количеством соединений, и если все ячейки ее, будут заполнены, хост не сможет открыть нового соединения. Если АСК-пакет не принят за время таймаута - соединения удаляется из очереди. Величина таймаута различна, но обычно составляет в пределах 30-60 секунд или больше. Клиентская сторона инициирующая атаку, посылает множество SYN-пакетов, с разными IP-адресами источника к атакуемому серверу, так быстро как позволяет канал, заполняя таким образом очередь соединений, и лишая возможности подключения обычных пользователей.
</p>

<p>
В этом случае возможность ограничения скорости соединения весьма кстати. По возможности ограничьте скорость приема SYN-пакетов используя <c>-m limit --limit 1/s</c>. Это будет ограничивать количество принятых SYN-пакетов до одного в секунду.
</p>

<p>
Теперь практический материал.
</p>

<p>
Когда iptables загружены в ядро, вы имеете 5 мест (hooks), куда можете
записывать свои правила. Они называются <c>INPUT</c>, <c>OUTPUT</c>,
	<c>FORWARD</c>, <c>PREROUTING</c> и <c>POSTROUTING</c> и содержат список
	правил для фильтрации. Каждое правило описывает как должен выглядеть
	заголовок пакета, и что делать с этим пакетом. если правило не
	соответствует пакету - оно передается дальше по цепочке. 
</p>

<p>
Вы можете записать правило в 5 главных цепочек или создать новую цепочку и добавить в нее правило из существующей цепочки. Iptables поддерживает следующие опции:
</p>

<table border="0">
<tr>
  <th>Опция:</th>
  <th>Описание:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>Добавление</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>Удаление</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>Вставка</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>Перезапись</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>Список</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>Удалить все правила в цепочке или все цепочки</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>Обнулить счетчики в цепочке или всех цепочек</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>Тест этого пакета в цепочке</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>Создать новую цепочку управляемую пользователем</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>Удалить цепочку управляемую пользователем</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>Изменить политику для действия в цепочке</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>Изменить имя цепочки</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>Протокол</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>Адрес/маска источника</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>Адрес/маска пункта назначения</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>Входное имя (ethernet-имя)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>Выходное имя (ethernet-имя)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>Jump (действие для правила)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>Расширенное сравнение (можно использовать расширения)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>Цифровой вывод адресов и портов</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>Таблица для манипуляций</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>Режим verbose (для отладки, выдается более подробная информация)</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>Расширенные номера (показывает точные значения)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>Применять только ко второму или последующим пакетам</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>Версия пакета</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>Выводит количество строк при листинге</ti>
</tr>
</table>

<p>
Для начала мы попробуем блокировать все ICMP-пакеты для нашей машины, только для того чтобы показать пример в iptables.
</p>

<pre caption="Блокирование всех ICMP-пакетов">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Сначала мы указали цепочку куда должно добавиться правило, дальше протокол и действие для правила. Действие может быть определено пользователем или одно из специальных действий <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, 
<c>QUEUE</c>, <c>MASQUERADE</c>. В этом случае мы используем <c>DROP</c> -
действие которое отклоняет пакеты, не отвечая клиенту.
</p>

<p>
Теперь попробуйте <c>ping localhost</c>. Вы не получите никакого ответа, так как
iptables отклонит все входящие пакеты ICMP сообщений. Также вы не сможете
пинговать другие машины, так как будут отклонены ответные пакеты. Теперь сбросим
цепочку, чтобы вернуть ICMP потоки.
</p>

<pre caption="Сброс всех правил">
# <i>iptables -F</i>
</pre>

<p>
Теперь рассмотрим stateful-фильтр в iptables. Если вы хотите использовать stateful-фильтрацию входящих пакетов, вы должны разрешить его так:
</p>

<pre caption="Принятие пакетов которые создаются уже установленным соединением">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Это разрешит принятие пакетов из уже установленных соединений или связанной с
ними цепочки INPUT. И вы можете отклонять любой пакет который не находится
таблице соединений спомощью - <c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c>. Это разрешит stateful-фильтрацию в iptables и загрузит необходимое расширение. Если вы хотите разрешить другие соединения к вашей машине, вы можете использовать <c>--state NEW</c>. Iptables содержит некоторые модули для различных нужд. Некоторые из них:
</p>

<table border="0">
<tr>
  <th>Модуль/Совпадение</th>
  <th>Описание</th>
  <th>Расширенные опции</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>Проверяющее расширение для входящих пакетов по mac-адресу.</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>Позволяет stateful-фильтрацию</ti>
  <ti>--state (states are ESTABLISHED,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>Ограничение скорости</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>Позволяет совпадения различных характеристик хоста создающего пакет</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>Различные проверки пакетов на "правильность"</ti><ti></ti>
</tr>
</table>

<p>
Давайте попробуем создать цепочку управляемую пользователем и применить ее к одной из уже существующих:
</p>

<pre caption="Creating a user defined chain">
<codenote>Создаем новую цепочку с одним правилом</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>Политика по умолчанию весь исходящий трафик разрешен. Входящий запрещен.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>И добавим ее в цепочку INPUT</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
После применения правила с цепочке INPUT мы имеем политику: все исходящие пакеты
разрешены, все входящие пакеты выкидываются.
</p>

<p>
Вы можете найти документацию здесь - <uri link="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables documentation</uri>.
</p>

<p>
Давайте посмотрим теперь полный пример. Здесь приведена моя политика безопасности брандмауэра/шлюза:
</p>

<ul>
<li>Соединения к брандмауэру разрешены только через SSH (порт 22)</li>
<li>
Локальная сеть имеет доступ к HTTP, HTTPS и SSH (DNS также должен быть разрешен)
</li>
<li>
ICMP-трафик может нести сведения о сети и должен быть запрещен. Конечно разрешим некоторые возможности ICMP-протокола.
</li>
<li>Сканирование портов должны засекаться ПО и логироваться</li>
<li>SYN-атаки должны избегаться</li>
<li>Весь другой трафик должен отвергаться и логироваться</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default rule
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffic
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Incoming traffic
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #outgoing traffic
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Catch portscanners
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Apply and add invalid states to the chains
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Allow client to route through via NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<p>
Бесплатные советы при создании брандмауэра:
</p>

<ol>
<li>Продумайте политику брандмауэра перед ее воплощением</li>
<li>Постарайтесь сохранить его простым</li>
<li>
Вы должны знать как работают протоколы (читайте <uri link="http://www.ietf.org/">RFC</uri> (Request For Comments))
</li>
<li>
Помните что брандмауэр только часть ПО, которая запускается как root
</li>
<li>Тестируйте свой брандмауэр</li>
</ol>

<p>
Если вы думаете что iptables трудны для понимания, или довольно долго
настраивается до пристойного брандмауэра, вы можете попробовать использовать
<uri link="http://www.shorewall.net">Shorewall</uri>. По сути он использует
iptables генерации правил брандмауэра, но концентрируется на правилах, а не
конкретных протоколах.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid - очень мощный прокси сервер, который может фильтровать трафик по: времени, статическим выражениям в пути/URL, IP-адресу клиента/запрашиваемого сервера, домену, браузеру, имени пользователя, типу MIME и номеру порта (протокола). Вероятно я не указал всех возможностей, но это и не нужно.
</p> 

<p>
В следующем примере я добавлю фильтр баннеров вместо фильтра порно-сайтов. Потому
что Gentoo.org <e>не должен</e> быть в списках порно-сайтов. И я не хочу тратить
время в поисках хороших сайтов для вас.
</p>

<p>
В этом случае моя политика такова:
</p>

<ul>
<li>
Просмотр (HTTP/HTTPS) разрешен только в течении рабочего времени (пон-пят 9-18 и суб 9-14), если вы задерживаетесь по работе, вы не можете просматривать веб-страницы (вы должны работать :), если уж задержались):
</li>
<li>
Загрузка файлов не разрешена (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg и т.д.)
</li>
<li>
Мы не любим баннеры, поэтому они должны отфильтровываться и заменятся прозрачным gif (вот где простор для творчества)
</li>
<li>Все другие соединения в и из интернета не разрешены</li>
</ul>

<p>
Это реализуется в 4 <e>простых</e> шага.
</p>

<pre caption="/etc/squid/squid.conf">
# Bind to a ip and port
http_port 10.0.2.1:3128

# Standard configuration
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Add basic access control lists
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Add who can access this proxy server
acl localnet src 10.0.0.0/255.255.0.0

# And ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Add access control list based on regular
# expressions within urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Add access control list based on time and day
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#allow manager access from localhost
http_access allow manager localhost
http_access deny manager

# Only allow purge requests from localhost
http_access allow purge localhost
http_access deny purge

# Deny requests to unknown ports
http_access deny !Safe_ports

# Deny CONNECT to other than SSL ports
http_access deny CONNECT !SSL_ports

# My own rules

# Add a page do be displayed when
# a banner is removed
deny_info NOTE_ADS_FILTERED url_ads

# Then deny them
http_access deny url_ads

# Deny all archives
http_access deny archives

# Restrict access to work hours
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Deny the rest
http_access deny all
</pre>

<p>
Дальше заполним в files.acl какие файлы запрещены для скачивания. Я добавил zip, 
viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz и z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
Запомните - символы указанные в скобках [ ] заглавные и прописные, для того чтобы фильтр нельзя было обойти файлом с расширением например AvI вместо avi
</note>

<p>
Дальше мы зададим выражения для идентификации баннеров. Возможно воображение у вас будет лучше чем у меня:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
В этой части мы хотим заменить баннер файлом. Обычно это html-файл с 4x4 прозрачным gif изображением.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
Не закрывайте теги &lt;HTML&gt; &lt;BODY&gt; . Это сделает squid.
</note>

<p>
Как вы можете видеть, squid имеет множество возможностей, которые эффективны как при фильтрации так и для прокси. Вы можете его использовать для установки на очень больших сетях. Конфигурация которую я привел больше всего подходит для небольшой сети 1-20 пользователей. 
</p>

<p>
Но комбинирование пакетного фильтра (iptables) и прокси (squid) возможно лучшее
решение, к тому же если squid находится в защищенном месте и к нему никто не
имеет доступа снаружи. Нам все еще необходима защита от атак снаружи.
</p>

<p>
Теперь нам надо настроить браузеры ваших пользователей, для использования
прокси-сервера. Прокси ограничивает пользователей от ллюбых контактов с внешним
миром, кроме как через прокси.
</p>

<note>
В Мозилле это настраивается в Edit->Preferences->Advanced->Proxies.
</note>

<p>
Того же самого можно добиться если настроить iptables для прозрачного перенаправления всего исходящего трафика на squid. Это делается добавлением правила в iptables:
</p>

<pre caption="Разрещение portforwarding'a на наш прокси">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>
<section>
<title>Что теперь мы знаем</title>
<body>

<p>
Мы знаем следующее:
</p>

<ol>
<li>
Брандмауэр содержит потенциальную угрозу безопасности. Плохо настроенный брандмауэр может свести на нет все ваши меры безопасности.
</li>
<li>Как для начала настроить прокси</li>
<li>Ключ к хорошему брандмауэру - знание работы протоколов которые вы хотите разрешить</li>
<li>
Что IP-трафик не всегда содержит легитимную информацию. ICMP-пакеты могут содержать полезную информацию о вашей сети.
</li>
<li>Как пресечь SYN-атаки</li>
<li>
Как фильтровать HTTP-трафик, удалять его содержимое.
</li>
<li>
Комбинирование пакетного фильтра и прокси обеспечивает лучший контроль.
</li>
</ol>

<p>
Теперь если вам <e>действительно</e> необходимо, вы сможете сделать такой брандмауэр какой вам нужен.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Детектирование атак</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment)</title>
<body>

<p>
AIDE - это система обнаружения атак (бесплатная альтернатива Tripwire). 
Если вы уже знаете Tripwire у вас не должно возникнуть трудностей с изучением конфигурационных файлов AIDE.
</p>

<p>
Конфигурационные файлы основаны на выражениях, макросах и правилах для фалов и директорий. Мы имеем следующий макросы:
</p>

<table borlder="0">
<tr>
  <th>Макрос</th>
  <th>Описание</th>
  <th>Синтаксис</th>
</tr>
<tr>
  <ti>ifdef</ti>
  <ti>если определен (If definded)</ti>
  <ti>@@ifdef "name"</ti>
</tr>
<tr>
  <ti>ifndef</ti>
  <ti>Если не определен (If not defined)</ti>
  <ti>@@ifndef "name"</ti>
</tr>
<tr>
  <ti>define</ti>
  <ti>Определение переменной (Define a variable)</ti>
  <ti>@@define "name" "value"</ti>
</tr>
<tr>
  <ti>undef</ti>
  <ti>Присвоение переменной неопределенного значения (Undefine a variable)</ti>
  <ti>@@undef "name"</ti>
</tr>
<tr>
  <ti>ifhost</ti>
  <ti>Если "имя хоста" (if "hostname")</ti>
  <ti>@@ifhost "hostname"</ti>
</tr>
<tr>
  <ti>ifnhost</ti>
  <ti>Если не "имя хоста" (if not "hostname")</ti>
  <ti>@@ifnhost "hostname"</ti>
</tr>
<tr>
  <ti>endif</ti>
  <ti>
    Endif нужно использовать после любых макросов исключая define и undef
  </ti>
  <ti>@@endif</ti>
</tr>
</table>

<p>
Эти макросы очень часто используются, если вы имеете больше чем один хост с
Gentoo и хотите использовать AIDE на всех. Но не на всех машинах работают одни и
те же сервисы или даже пользователи.
</p>

<p>
Дальше мы настроим флаги и применим их к файлам и директориям. Это комбинация
разрешений (permissions), свойств файлов и криптографические хеш/контрольных сумм.
</p>

<table border="0">
<tr>
  <th>Флаг</th>
  <th>описание</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>разрешения (permissions)</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>inode</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>количество ссылок (number of links)</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>пользователь (user)</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>группа (group)</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>размер (size)</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>метка блока (block count)</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>mtime</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>atime</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>ctime</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>проверка растущего размер (check for growing size)</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>контрольная сумма md5 (md5 checksum)</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>контрольная сумма sha1 (sha1 checksum)</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>контрольная сумма rmd160 (rmd160 checksum)</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>контрольная сумма tiger (tiger checksum)</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>Пустая группа (Empty group)</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>Растущий лог файл p+u+g+i+n+S (Growing logfile p+u+g+i+n+S)</ti>
</tr>
</table>

<p>
Если AIDE скомпилирован с поддержкой mhash он имеет несколько дополнительных возможностей:
</p>

<table border="0">
<tr>
  <th>Флаг</th>
  <th>Описание</th>
</tr>
<tr>
  <ti>haval</ti>
  <ti>Контрольная сумма haval (haval checksum)</ti>
</tr>
<tr>
  <ti>gost</ti>
  <ti>Контрольная сумма gost (gost checksum)</ti>
</tr>
<tr>
  <ti>crc32</ti>
  <ti>Контрольная сумма crc32 (crc32 checksum)</ti>
</tr>
</table>

<p>
Теперь мы можем создать наше правило из комбинации флагов указанных выше:
</p>

<pre caption="Создание набора правил для AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Последнее что нам надо сделать, чтобы создать наши конфигурационные файлы - это увидеть как добавить правило для файла или директории. Сначала вы набираете имя файла или директория и имя правила. AIDE добавит все  файлы рекурсивно, если вы не укажите иного.
</p>

<table border="0">
<tr>
  <th>Флаг</th>
  <th>Описание</th>
</tr>
<tr>
  <ti>!</ti>
  <ti>Не добавлять этот файл или директорию.</ti>
</tr>
<tr>
  <ti>=</ti>
  <ti>Добавить эту директорию, но не рекурсивно.</ti>
</tr>
</table>

<p>
Давайте приведем полный пример:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# The location of the database to be read.
database=file:@@{AIDEDIR}/aide.db

# The location of the database to be written.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Rule definition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
В выше приведенном примере вместе с некоторыми макросами мы указали где начинаются главные каталоги (topdir) и расположение директории AIDE. AIDE проверяет <path>/etc/aide/aide.db</path> при проверке файлов на целостность. Но при обновлении или создании новых файлов он сохраняет информацию в файле <path>/etc/aide/aide.db.new</path>. Это сделано для того, чтобы автоматически не перезаписать старый db файл. Опция <c>report_URL</c> пока не работает. Но авторы намерены реализовать возможность предупреждения по email или возможно исполнение скрипта.
</p>

<p>
После исправления конфигурационных файлов вы должны создать ваш db файл путем исполнения <c>aide -i</c> и потом скопировать файл <path>/etc/aide/aide.db.new</path> в <path>/etc/aide/aide.db</path> и добавить проверку по крону с помощью команды <c>crontab -e</c> выполненной как root.
</p>

<note>
Также зависит от вашего процессора, дисков и флагов которых вы установили в файлах, сколько это займет времени.
</note>

<pre caption="Задания расписания aide как cronjob">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
Не забудьте настроить получение почты root. Иначе вы не сможете узнать, о сообщениях aide.
</note>

<p>
Так aide будет запускаться раз в день в 3 часа ночи. Это сделано для того, чтобы
не мешать пользователям если они работают. Здесь я использовал опцию <c>-u</c>
(обновление) вместо <c>-C</c> (проверка). Потому что <c>-u</c> также проверяет
файлы, но не перезаписывает db файл, так как вы можете сделать это сами если он
обнаружит какие-то изменения. Просто проверьте перед копированием изменения
обнаруженные, на предмет - это сделали вы или атакующий.
</p>

<p>
Дальше, есть некoторые проблемы при хранении db файла локально, атакующий может
(если знает что установлен aide) попробовать изменить db файл, обновить его или
изменить <path>/usr/bin/aide</path>. Поэтому вы должны создать CD или другой
носитель и скопировать на него .db файл, и бинарные файлы aide.
</p>

<p>
Информацию вы можете найти здесь - <uri link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort - это сетевая система обнаружения атак (Network Intrusion Detection
		System, NIDS). Для установки и настройки настройки смотрите пример ниже.
</p>

<pre caption="Добавление пользователя snort в систему">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>Шаг 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Шаг 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>Шаг 3</codenote>
include classification.config

<codenote>Шаг 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Больше информации вы можете найти здесь - <uri link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>

</chapter>
</guide>
