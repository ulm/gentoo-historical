<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link = "/doc/ru/cvs-tutorial.xml">
<title>Учебное пособие по CVS в Gentoo Linux</title>
<author title="Chief Architect" email="drobbins@gentoo.org">Daniel Robbins</author>
<author title="Переводчик" email="zenkov@gentoo.org">Иван Зенков</author>

<version>1.1</version>
<date>17 May 2003</date>

<abstract>
Данное руководство познакомит читателей с CVS, системой используемой
людьми для совместной разработки программного обеспечения по всему
миру.  Предназначенное для новичков, оно быстро ознакомит пользователей
и разработчиков с общими принципами CVS.  Собираетесь ли вы
использовать CVS для получения (check out) последних версий
программного обеспечения, или же вы решили как профессиональный
разработчик ознакомиться с его возможностями, данное руководство для вас.
</abstract>

<chapter>
<title>Введение</title>

<section>
<title>Построение документа</title>
<body>

<p>
Это руководство состоит из двух частей.  Первая, объяснит обычным
пользователям как использовать CVS.  Например, как получать и
обновлять исходные файлы.  Вторая, предназначенная для разработчиков,
помимо всего прочего расскажет как редактировать, удалять и добавлять
файлы в CVS.  Если вы никогда раньше не использовали CVS,
рекомендуется начать с первой части, а далее уже дочитать и
вторую.  Если же у вас уже есть некоторый опыт использования CVS, но вы
собираетесь использовать CVS на уровне разработчика всё, что
необходимо можно найти во второй части, хотя первая может пригодиться
в качестве вступления.
</p>

</body>
</section>

<section>
<title>Что такое CVS и для чего это нужно?</title>
<body>

<p>
CVS это клиент-серверная система позволяющая разработчику хранить свои
проекты в одном единственном месте, называемом репозитарий.
Разработчик может изменять содержимое репозитария, используя CVS
клиент.  В свою очередь CVS отслеживает каждое изменение, сделанное над
каждым файлом, создавая законченную хронологию развития
проекта.  Разработчик может просмотреть лог файл изменений, запросить
более старую версию любого исходного файла, и при необходимости
использовать дополнительные возможности CVS.
</p>

</body>
</section>

<section>
<title>Роль CVS</title>
<body>

<p>
Множество open source проектов имеют собственный CVS репозитарий,
используемый разработчиками как архив всей их работы.  Рассеяные по
всему миру, они могут хоть по несколько раз на дню изменять исходные
файлы в CVS.  То есть CVS это механизм необходимый для объединения
проекта в связанное целое, для его централизации.  CVS как бы
"организационное связывающие звено", позволяющие разработчикам
совершенствовать код не наступая друг другу на ноги, теряя важные
данные и пропуская критические обновления к специфическим исходным
файлам.
</p>

</body>
</section>

<section>
<title>Свежие исходники от разработчиков из CVS</title>
<body>

<p>
Когда разработчики готовы, текущая работа на CVS упаковывается ими в
.tar.gz файл и выпускается как новая официальная версия
программы.  Однако, из-за ряда различных причин, официальная последняя
версия не всегда достаточно "последняя".  В первой части данного
руководства я расскажу как использовать CVS для приобретения самых
последних версий исходных файлов для вашего личного пользования.
</p>

</body>
</section>

<section>
<title>Есть ли у вас CVS?</title>
<body>

<p>
Перед использованием CVS, как ни странно, его необходимо
установить.  Самый простой метод проверки его установки, это запуск
программы, командой:
</p>

<pre>
# <i>cvs</i>
</pre>

<p>
Если команда найдена, тогда он у вас установлен.  В противном же
случае вам понадобиться установить его из бинарного пакета для вашего
дистрибутива или собрать прямо из исходных файлов.  Сборка CVS из
исходных файлов на самом деле достаточно проста, об этом я расскажу
чуть ниже.
</p>

</body>
</section>


<section>
<title>Сборка CVS из исходных файлов</title>
<body>

<p>
Собрать CVS очень просто.  Для начала загрузим cvs-1.11.tar.gz архив с
<uri>ftp://ftp.cvshome.org/pub/cvs-1.11/cvs-1.11.tar.gz</uri> (если
<uri link="ftp://ftp.cvshome.org/pub/">здесь</uri>, доступна более
новая версия, то лучше её и загрузить).  После чего выполним следующие
шаги (для компактности вывод команд был опущен):
</p>

<pre>
# <i>tar xzvf cvs-1.11.tar.gz</i>
# <i>cd cvs-1.11</i>
# <i>./configure</i>
# <i>make</i>
# <i>make install</i>
</pre>

<p>
Теперь всё готово и можно приступать к работе.
</p>

</body>
</section>

<section>
<title>CVSROOT</title>
<body>

<p>
Перед началом, необходимо запомнить несколько фундаментальных основ
CVS.  Перове - для соединения с CVS архивом необходимо знать путь,
называемый "CVSROOT".  Значение CVSROOT подобно URL сообщает программе
где находится удаленный архив и каким способом мы бы хотели с ним
соединиться.  Любопытно то, что CVS имеет несколько форматов CVSROOT в
зависимости от локального или удаленного местонахождения репозитария, а
также метода используемого вами для соединения с ним.  Вот примеры
CVSROOT, вместе с разъяснениями.
</p>

</body>
</section>

<section>
<title>Локальный CVSROOT</title>
<body>

<pre>CVSROOT=/home/cvsroot</pre>

<p>
Это пример локального CVSROOT.  Используя CVSROOT вроде этого, вы
подключитесь к локальному репозитарию находящемуся в /home/cvsroot
или возможно смонтированному через NFS к /home/cvsroot.
</p>

</body>
</section>

<section>
<title>CVSROOT для защищённого удалённого сервера</title>
<body>

<pre>CVSROOT=:pserver:cvs@foo.bar.com:/home/cvsroot</pre>

<p>
Это пример CVSROOT для удалённого репозитария с хостом foo.bar.com и
находящегося в директории /home/cvsroot на той машине.  Часть
":pserver:" сообщает клиенту, что для подключения к репозитарию
следует использовать защищённый серверный протокол (password server
protocol), протокол встроенный в CVS.  Обычно публичные CVS
репозитарии, дают ограниченный доступ, анонимным (anonymous)
пользователям используя защищённый серверный протокол.
</p>

</body>
</section>

<section>
<title>Удалённый rsh/ssh CVSROOT</title>
<body>

<pre>CVSROOT=drobbins@foo.bar.com:/data/cvs</pre>

<p>
Данный пример CVSROOT, использующий RSH или SSH протокол, позволяет
пользователю с учётной записью drobbins получить доступ к удалённому
репозитарию на foo.bar.com.  В случае если системная переменная CVS_RSH
содержит значение "ssh", для соединения cvs клиентом будет
использоваться ssh, иначе всё тот же rsh.  Ssh метод популярнее введу
своей безопастности.  Однако ни тот ни другой, не подойдут для
анонимного пользователя желающего получить исходные файлы, поскольку
необходимо иметь учётную запись на сервере foo.bar.com.
</p>

</body>
</section>

<section>
<title>Ещё несколько вещей...</title>
<body>

<p>
В дополнение к CVSROOT, вам так же понадобится название модуля
(коллекции исходных файлов), что вы хотели бы получить.  А так же
анонимный пароль, необходимый для защищенного CVS сервера.  В отличии от
анонимного ftp, здесь нет "стандартного" формата для анонимных
паролей, вам нужно будет получить пароль с сайта разработчиков или у
разработчиков лично.  Теперь когда у вас всё есть, можно приступать к
работе.
</p>

</body>
</section>

<section>
<title>Работа с CVS, часть 1</title>
<body>

<p>
Получение исходных файлов, состоит из двух стадий.  Первое, мы должны
подключиться к защищённому серверу.  После чего, командой
<c>checkout</c> получить собственно сами исходники.  На нашем примере,
следующими командами, мы попытаемся получить последние исходные файлы
Samba, популярного проекта UNIX/Windows интеграции.
</p>

<pre>
# <i>export CVSROOT=:pserver:cvs@pserver.samba.org:/cvsroot</i>
</pre>

<p>
Эта первая команда, задаёт системную переменную CVSROOT.  Если вы не
зададите эту переменную следующие две команды потребуют добавления
ключа <c>-d :pserver:cvs@pserver.samba.org:/cvsroot</c> после команды
<c>cvs</c>.  Экспортирование переменной CVSROOT, экономит количество
вводимых знаков.
</p>

</body>
</section>

<section>
<title>Работа с CVS, часть 2</title>
<body>

<p>
Вот команды, необходимые для получения текущей версии исходников.  Вы
можете просмотреть объяснение команд чуть ниже, а затем опять вернуться
к этой части.
</p>

<pre>
# <i>cvs login</i>
(Logging in to cvs@pserver.samba.org)
CVS password: <comment>(Здесь введите пароль)</comment>

# <i>cvs -z5 co samba</i>
U samba/COPYING
U samba/Manifest
U samba/README
U samba/Read-Manifest-Now
U samba/Roadmap
U samba/WHATSNEW.txt
<comment>(Это только отрывок, вывода cvs co)</comment>
</pre>

</body>
</section>

<section>
<title>Работа с CVS -- разъяснения</title>
<body>

<p>
Первая команда cvs регистрирует нас в pserver, вторая сообщает нашему
CVS клиенту забрать ("co") модуль samba, используя gzip с уровнем
сжатия 5 ("-z5"), для ускорения передачи файлов по медленному
соединению.

Для каждого нового файла, созданного локально, cvs выводит идентификатор
"U [path]" означающий обновление данного файла на диске.
</p>

</body>
</section>

<section>
<title>Завершение загрузки</title>
<body>

<p>
Сразу после выполнения загрузки, в текущей рабочей директории вы
увидите каталог "samba" содержащий все последние исходные
файлы.  Возможно вы также заметите, что все директории имеют внутри
себя, каталог "CVS".  CVS сохраняет некоторую информацию внутри этих
каталогов, они могут безопасно игнорироваться.  С этого момента, мы
можем не волноваться об установленной системной переменной CVSROOT, и
нет нужды каждый раз задавать её, поскольку всё кэшировано во
внутренних, дополнительных каталогах "CVS".  Запомните -- CVSROOT вам
требуется задать только для входа на сервер и получения необходимых
файлов.
</p>

</body>
</section>

<section>
<title>Обновление исходников</title>
<body>

<p>
Хорошо, теперь у нас есть самые свежие исходники!  Их можно
скомпилировать и установить программу, можно просмотреть, можно
делать с ними всё, что захотите.
</p>

<p>
Время от времени, вам возможно понадобиться обновить исходники, в
соответствии с текущей версией на CVS.  Для этого, вам не понадобиться
подключаться к pserver; вся необходимая информация кэширована внутри
тех самых каталогов "CVS".  Перовое, войдите в установочную директорию
(в нашем случае "samba") и напечатайте:
</p>

<pre>
# <i>cvs update -dP</i>
</pre>

</body>
</section>

<section>
<title>Следим за "cvs update", часть 1</title>
<body>

<p>
Если есть любые новые файлы, cvs выведет строку "U [path]" для
каждого обновлённого файла.  В случае же когда вы скомпилировали
исходные файлы, вы возможно увидите множество строк "? [path]",
сообщающих, что эти объектные файлы не из удалённого репозитария.
</p>

</body>
</section>

<section>
<title>Следим за "cvs update", часть 2</title>
<body>

<p>
Также обратите внимания на две опции командной строки, используемых
нами для "cvs update".  "-d" сообщает cvs создавать любые новые
каталоги, которые возможно были добавлены в репозитарий (по умолчанию
этого не происходит), и "-P" сообщающий cvs удалять пустые директории
из локальной копии с исходниками.  Использование "-P" хорошая идея,
поскольку cvs имеет тенденцию, спустя некоторое время, скапливать
множество пустых (когда-то используемых, но уже давно заброшенных)
директорий.
</p>

<p>
Это всё, что вам требуется знать для простого получения свежих
исходников.  Теперь же возьмёмся за CVS с позиции разработчика.
</p>

</body>
</section>
</chapter>

<chapter>
<title>CVS для разработчиков</title>

<section>
<title>Изменение файлов</title>
<body>

<p>
Как разработчику, вам потребуется изменять файлы на CVS.  Для
этого, просто сделайте необходимые изменения в локальной копии
репозитария.  Изменения сделанные вами не будут приняты в удалённом
репозитарии, до тех пор пока вы их не отправите (commit).
Проверив свои изменения, и убедившись в их пригодности, для принятия
изменений в репозитарии необходимо выполнить два шага.  Первое,
обновите ваши исходные файлы, набрав в основной директории,
команду:
</p>

<pre>
# <i>cvs update -dP</i>
</pre>

</body>
</section>

<section>
<title>CVS объединяет все изменения</title>
<body>

<p>
Как мы уже видели выше, "cvs update" поддерживает ваши исходники на
современном уровне до текущей версии в репозитарии.  Но что же
происходит со сделанными вами изменениями?  Не волнуйтесь - они не были потеряны.
Если другой разработчик сделает изменения в файле, которого вы не
коснулись, ваш локальный файл будет обновлён в соответствии с версией
в репозитарии.
</p>

<p>
А если вы измените 1-10 строк в локальном файле, а другой
разработчик, сотрёт 40-50 и добавит 12 в конце, изменив 30-40 строк и
отправив (committed) свои изменения в репозитарии раньше вас, cvs
разумно объединит все изменения в вашей локальной копии, при этом
сохранив и ваше редактирование.  Что позволяет двум и более
разработчикам одновременно работать над разными частями одного и того
же файла.
</p>

</body>
</section>

<section>
<title>Несовершенство объединения</title>
<body>

<p>
Однако, если два или более, разработчиков изменили <i>одну и туже
область, одного и того же файла</i>, всё становится немного сложней.
Если это произойдёт, cvs сообщит вам о случившемся конфликте.  Работа
не будет потеряна, но потребуется немного человеческого вмешательства,
дабы объяснить cvs как лучше всего провести объединение конфликтующих
изменений.
</p>

</body>
</section>

<section>
<title>Отправка</title>
<body>

<p>
Немного позже мы ещё посмотрим как могут быть решены конфликты, а пока
предположим, что напечатав "cvs update -dP" всё прошло
успешно.  Конфликтов нет, ваши локальные исходники самые свежие и вы
готовы отправить ваши изменения в репозитарий набрав:
</p>

<pre>
# <i>cvs commit</i>
</pre>

</body>
</section>

<section>
<title>Что делает "commit"?</title>
<body>

<p>
"cvs commit" <i>не только</i> принимает ваши изменения в
репозитарий.  Перед отправкой ваших изменений в удалённый репозитарий,
cvs запустит заданный по умолчанию редактор, где вы можете
прокомментировать сделанные вами изменения.  Как только вы введёте
комментарии, сохраните файл и выйдете из редактора, ваши изменения (и
комментарии) будут отравлены в удалённый репозитарий и станут доступны
другим разработчикам из вашей команды.
</p>

</body>
</section>

<section>
<title>Просмотр log файлов</title>
<body>

<p>
Просмотреть полную историю отдельного файла,
включая все комментарии разработчиков (и вас тоже), возможно сделанные
ими при отправки файлов довольно просто.  Для этого нужно набрать:
</p>

<pre>
# <i>cvs log myfile.c</i>
</pre>

<p>
Команда "cvs log" рекурсивна, то есть если вы хотите просмотреть
полный log дерева каталогов, просто зайдите в директорию и
напечатайте:
</p>

<pre>
# <i>cvs log | less</i>
</pre>

</body>
</section>

<section>
<title>Опции "commit"</title>
<body>

<p>
Возможно вы хотели бы выбрать другой редактор, чем тот, что
запускается по умолчанию при выполнении "cvs commit".  Если это так,
сделайте значением системной переменной EDITOR название редактора
который вы бы хотели использовать.  Также было бы хорошей идей
поместить это определение в ~/.bashrc:
</p>

<pre>
export EDITOR=jpico
</pre>

<p>
Альтернативно, можно указать log сообщение в качестве опции командной
строки (в данном случае редактор запускаться не будет).
</p>

<pre>
# <i>cvs commit -m 'I fixed a few silly bugs in portage.py'</i>
</pre>

</body>
</section>

<section>
<title>Файл .cvsrc</title>
<body>

<p>
Перед тем как продолжить изучение прочих cvs команд, я советую создать
~/.cvsrc файл.  Создавая .cvsrc в вашем домашнем каталоге, вы можете
задать по умолчанию, опции которые не хотели бы каждый раз заново
набирать.  Вот рекомендуемый .cvsrc файл:
</p>

<pre>
cvs -q
diff -u -b -B
checkout -P
update -d -P
</pre>

</body>
</section>

<section>
<title>Файл .cvsrc -- дополнение</title>
<body>

<p>
В дополнение к установке полезных опций для команд cvs, первая строка
.cvsrc переводит cvs в тихий режим (quiet mode), который отлично
подходит для "cvs update", делая вывод на терминал более читабельным.
Теперь как только .cvsrc будет на месте вы сможете использовать "cvs
update" взамен "cvs update -dP".
</p>

</body>
</section>

<section>
<title>Добавление файла в репозитарий</title>
<body>

<p>
Добавить файл в CVS, очень просто.  Для начала, создайте в вашем
любимом текстовом редакторе, файл.  Затем напечатайте:
</p>

<pre>
# <i>cvs add myfile.c</i>
cvs server: use 'cvs commit' to add this file permanently
</pre>

<p>
Как сказано в сообщении, cvs добавит данный файл сразу после того как
вы выполните "cvs commit", до тех же пор он не будет доступен другим
разработчикам.
</p>

</body>
</section>

<section>
<title>Добавление директории в репозитарий</title>
<body>

<p>
Процесс добавления каталога, схож с добавлением файла:
</p>

<pre>
# <i>mkdir foo</i>
# <i>cvs add foo</i>
Directory /home/cvsroot/mycode/foo added to the repository
</pre>

<p>
В отличии от добавления файла, добавленный каталог немедленно
появляется в репозитарии; "cvs commit" не требуется.  Как только вы
добавите ваш локальный каталог к cvs, обратите внимание, внутри будет
создана директория "CVS" -- этакий контейнер для учётной
информации.  Таким образом, вы могли бы легко всё сказать, если отдельный
каталог был добавлен в cvs, заглянув внутрь директории "CVS".
</p>

</body>
</section>

<section>
<title>Примечания к "cvs add"</title>
<body>

<p>
Эх, ну и конечно перед добавлением файла или директории в репозитарий, вы
должны удостовериться в том, что их родительский каталог уже был
добавлен в CVS.  В противном случае вы получите подобную ошибку:
</p>

<pre>
# <i>cvs add myfile.c</i>
cvs add: cannot open CVS/Entries for reading: No such file or directory
cvs [add aborted]: no repository  
</pre>

</body>
</section>

<section>
<title>Знакомимся с "cvs update", часть 1</title>
<body>

<p>
Перед тем как мы рассмотрим проблему разрешения конфликтов, давайте
взглянем подробней на вывод команды "cvs update".  В случае когда
созданный вами файл ~/.cvsrc содержит строку "cvs -q", вывод "cvs
update" будет намного читабельной.  "cvs update" информирует вас о
происходящем выводя одну букву, пробел и имя файла; как например так:
</p>

<pre>
# <i>cvs update -dP</i>
? distfiles
? packages
? profiles
</pre>

</body>
</section>

<section>
<title>Знакомимся с "cvs update", часть 2</title>
<body>

<p>
Используя символ "?" "cvs update" сообщает вам о том, что ничего не
знает о файлах найденных в вашей локальной копии репозитария.  Они не
официальная часть архива, не помеченные для добавления.  Вот список
всех остальных одно-буквенных сообщений используемых в CVS:
</p>

<pre>
U [path]
</pre>

<p>
Используется в случае создания нового файла в локальной копии
репозитария, или обновления не тронутого вами файла.
</p>

<pre>
A [path]
</pre>

<p>
Этот файл уже помечен для добавления, и будет официально добавлен в
репозитарий после выполнения "cvs commit".
</p>

</body>
</section>

<section>
<title>Знакомимся с "cvs update", часть 3</title>
<body>

<pre>
R [path]
</pre>

<p>
Подобно "A", "R" сообщает вам о том, что файл был помечен для удаления
и после выполнения "cvs commit" будет полностью удалён.
</p>

<pre>
M [path]
</pre>

<p>
Это означает, что данный файл был изменён вами; также возможно что
новые изменения из репозитария были успешно объединены внутри него.
</p>

<pre>
C [path]
</pre>

<p>
Символ "C" сообщает, о конфликтах с данным файлом, требующих ручного
вмешательства перед выполнением "cvs commit".
</p>

</body>
</section>

<section>
<title>Разрешение внутренних конфликтов</title>
<body>

<p>
Теперь давайте взглянем на проблему разрешения конфликтов.  Я участвую
в проекте Gentoo Linux, и у нас есть собственный cvs сервер,
cvs.gentoo.org.  Мы, разработчики, проводим большенство нашего времени
"хакая" исходники внутри модуля "gentoo-x86".  В каждом каталоге есть файл
"ChangeLog" который содержит (вы возможно уже сами догадались)
описание основных изменений сделанных над файлами в репозитарии.
</p>

</body>
</section>

<section>
<title>Пример конфликта</title>
<body>

<p>
Поскольку этот файл обновляется почти каждый раз когда
разработчики производят значительные изменения в CVS, это первичный
источник конфликтов -- вот пример конфликта.  Предположим я добавил
следующие строки в начало файла "ChangeLog":
</p>

<pre>
date 25 Feb 2001
 
Это то, что я добавил
</pre>

<p>
Однако предположим, что перед тем как я добавил эти три строки, другой
разработчик уже добавил несколько строк в начало файла "ChangeLog" и
отправил свои изменения:
</p>

<pre>
date 25 Feb 2001
 
Это фрагмент добавленный другим разработчиком
</pre> 

</body>
</section>

<section>
<title>Пример конфликта, продолжение</title>
<body>

<p>
Теперь когда я запускаю "cvs update -dP" (это необходимо делать всегда,
перед выполнением "commit"), cvs не может добавить его изменения в мою
локальную копию "ChangeLog" потому, что мы добавляем строки в одну и
туже часть файла -- как cvs определит какую версию использовать?  Так
я получаю следующую ошибку от CVS:
</p>

<pre>
RCS file: /home/cvsroot/gentoo-x86/ChangeLog,v
retrieving revision 1.362
retrieving revision 1.363
Merging differences between 1.362 and 1.363 into ChangeLog
rcsmerge: warning: conflicts during merge
cvs server: conflicts found in ChangeLog
C ChangeLog
</pre>

</body>
</section>

<section>
<title>Разрешение конфликта, часть 1</title>
<body>

<p>
Ох, ну и конфликт!  К счастью его несложно разрешить.  Если я запущу
мой любимый текстовый редактор, вверху файла "ChangeLog" я увижу
следующий текст:
</p>

<pre>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ChangeLog
date 25 Feb 2001
 
Это то, что я добавил

=======
date 25 Feb 2001
 
Это фрагмент добавленный другим разработчиком
 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.363
</pre>

</body>
</section>

<section>
<title>Разрешение конфликта, часть 2</title>
<body>

<p>
Вместо выбора одной или другой версии, cvs добавил обе к файлу
"ChangeLog", разделив их специальным разделителем, чтобы ясно отметить
рассматриваемый конфликт.  Теперь моя очередь заменить эту область на
текст который <i>должен</i> находиться в "ChangeLog"; в данном случае
нужна не одна или другая версия, а комбинация обоих:
</p>

<pre>
date 25 Feb 2001

Это то, что я добавил

Это фрагмент добавленный другим разработчиком
</pre>

<p>
Теперь когда я заменил противоречивую область файла соответствующим
текстом (и удалил разделитель "=======", вместе с прочими маркерами),
я могу спокойно и беспроблемно отправить свои изменения в cvs.
</p>

</body>
</section>

<section>
<title>Советы в разрешении конфликтов</title>
<body>

<p>
Всякий раз, когда вы редактируете конфликтный файл, удостоверьтесь в
том, что вы просматриваете наиболее полную версию файла; если вы
забудете разрешить специфический конфликт, cvs не позволит активировать
"commit" пока конфликт не будет разрешён!  Также очень важно удалить
специальные маркеры добавляемые cvs в конфликтный файл.  Другой совет
-- если при разрешении конфликта вы совершите ошибку и случайно
("Ох!") сохраните свои изменения, первоначальную копию вашей версии
можно найти в файле ".#filename.version".
</p>

</body>
</section>

<section>
<title>Удаление файла</title>
<body>

<p>
Теперь настало время изучить последнюю возможность -- удаление файлов
из репозитария.  Процесс удаления файла состоит из двух шагов.
Сначала, удаляем файл из локальной копии репозитария, а затем выполняем
соответствующую команду "cvs remove":
</p>

<pre>
# <i>rm myoldfile.c</i>
# <i>cvs remove myoldfile.c</i>
</pre>

</body>
</section>

<section>
<title>Удаление файла, продолжение</title>
<body>

<p>
Помеченный файл удалится из репозитария в следующий раз, как только вы
выполните "commit".  После выполнения "commit", файл будет официально
удалён из текущей версии репозитария.  Однако cvs не выбросит этот
файл, и на всякий случай сохранит законченный отчёт о его содержании и
хронологии, который возможно понадобится в будущем.  Это только один
из многих способов которыми cvs защищает ваш исходный код.
</p>

<p>
"cvs remove" рекурсивна, это означает, что вы можете удалять сразу
связку файлов, запустив команду "cvs remove" без аргументов из
родительской директории.  Проделав это, мы получим файлы помеченные к
удалению до следующего запуска "commit".
</p>

</body>
</section>

<section>
<title>Удаление директории</title>
<body>

<p>
Если вы хотите удалить полный каталог, я рекомендую проделать следующие.
Сначала, физически удаляем все файлы в директории, а затем "cvs remove":
</p>

<pre>
# <i>rm *.c</i>
# <i>cvs remove</i>
</pre>

</body>
</section>

<section>
<title>Удаление директории, продолжение</title>
<body>

<p>
Теперь выполним "commit":
</p>

<pre>
# cvs commit
</pre>

<p>
Здесь присутствует некоторая уловка.  Далее выполните следующие шаги,
чтобы просто удалить каталог:
</p>

<pre>
# <i>cd ..</i>
# <i>cvs remove mydir</i>
# <i>rm -rf mydir</i>
</pre>

<p>
Обратите внимание, что удаление директории не требует ещё одного
запуска "commit" -- каталоги удаляются и добавляются из репозитария в реальном времени.
</p>

</body>
</section>

<section>
<title>Завершение!</title>
<body>

<p>
Ваше знакомство с CVS завершено -- я надеюсь, что данное пособие было
полезно.  CVS содержит гораздо больше чем я мог охватить в этом
вводном обучающем документе, но к счастью есть целая связка ресурсов
которые можно использовать для дополнительной развёртки ваших знаний:
</p>

<p>
<ul>
<li><uri>http://www.cvshome.org</uri> это дом разработки CVS, и целый набор документации включая
<uri link="http://www.cvshome.org/docs/manual/cvs.html">официальную online документацию по CVS</uri>.
</li>
<li>
Сайт <uri link="http://www.durak.org/cvswebsites/">CVS Version Control for Web Site Projects</uri>
хорошая информация об использовании CVS в разработки вэб проектов.
</li>
<li>
Карл Фогел (Karl Fogel) написал книгу
<uri link="http://cvsbook.red-bean.com/">Open Source Development with CVS</uri>.
Несколько глав бесплатно доступны на сайте.
</li>
<li>
<uri link="http://stud.fh-heilbronn.de/~zeller/cgi/cvsweb.cgi/">cvsweb</uri>
это действительно замечательный CGI скрипт, создающий вэб интерфейс
для вашего CVS репозитария; превосходно для просмотра.
</li>
<li>
<uri link="http://www.loria.fr/~molli/cvs-index.html">CVS Bubbles</uri>
имеет список хороших ресурсов включая CVS FAQ-o-matic.
</li>	
</ul>
</p>

</body>
</section>

<section>
<body>

<note>
Данное руководство впервые появилось на <uri link="http://www.ibm.com/developerworks/linux">IBM developerWorks Linux Zone</uri>, под названием <uri link="http://www-105.ibm.com/developerworks/education.nsf/linux-onlinecourse-bytitle/A5C4A0AF4296C66886256A0E005DE112?OpenDocument">CVS for the developer or amateur (CVS для любителя и разработчика)</uri>.  Эта статья принадлежит Tenco Media Corporation.
</note>

</body>
</section>

</chapter>
</guide>
