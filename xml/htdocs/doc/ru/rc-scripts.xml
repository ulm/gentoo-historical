<?xml version="1.0"  encoding="UTF-8"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ru/rc-scripts.xml">
<title>Система инициализации Gentoo Linux 1.0</title>
<author>
<mail link="azarah@gentoo.org">Martin Schlemmer</mail>
</author>
<author title="Proof-reader">
<mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Переводчик">
<mail link="kirillv@amsd.com">Кирилл Васильев</mail>
</author>
<author title="Editor"><mail link="alv@linux-online.ru">Алексей Федорчук</mail></author>

<abstract>
Настоящее руководство является введением в систему инициализации Gentoo Linux, а также освещает некоторые детали создания rc-сценариев.
</abstract>

<version>1.0.2</version>
<date>Jan 12 2003</date>

<chapter>
<title>Введение</title>
<section>
	<body>

<p>
Gentoo Linux использует систему инициализации, которая практически полностью управляется с помощью зависимостей. Она должна быть простой в поддержке, но в то же время достаточно мощной и гибкой для любого типа установки. Не стоит рассматривать данное руководство как введение в то, как все это работает; скорее, это краткое руководство по тому, как с этим (т.е. с системой инициализации Gentoo) работать. Для тех же, кто озабочен деталями внутреннего устройства... читайте исходники ;-)
</p>

	</body>
</section>
</chapter>

<chapter>
<title>Уровни исполнения (runlevels)</title>
<section>
	<body>

<p>
В отличие от прочих систем инициализации, у уровней исполнения в Gentoo нет строго определенных имен или номеров, но сходство с init есть. Существуют три уровня исполнения по умолчанию: <e>&quot;boot&quot;</e>, <e>&quot;default&quot;</e> и
<e>&quot;nonetwork&quot;</e>.
</p>

<p>
Уровень исполнения &quot;boot&quot; должен быть стандартным для
большинства установок и, как следует из его названия, это первый
уровень исполнения, запускаемый на стадии загрузки. Следующий -
<e>&quot;default&quot;</e> - это главный уровень исполнения,
исполняющийся после загрузки, что и отражено в его названии. И
последний уровень, <e>&quot;nonetwork&quot;</e>, выступает
исключительно в качестве примера.
</p>

<p>
Уровни исполнения расположены в каталоге <path>/etc/runlevels</path>, в
подкаталоге, названном по имени уровня исполнения; этот подкаталог
заполняется символическими ссылками на сервисы, относящиеся к данному
уровню исполнения.

<note>
Наиболее предпочтительный способ добавления или удаления сервисов
обсуждается в разделе &quot;О rc-update&quot;.
</note>
</p>

<p>
Как показано ранее, имя уровня исполнения можно изменить на более
подходящее пользователю, поскольку для отражения нового имени также
меняется и запись правила в файле <path>/etc/inittab</path>.

<impo>
Однако, из этого правила есть исключение: уровень исполнения
&quot;boot&quot;.
</impo>

<warn>
Пожалуйста, НЕ меняйте имя уровня исполнения <e>&quot;boot&quot;</e>,
так как это может привести к неприятным последствиям!
</warn>
</p>

<p>
Всю работу (в том числе и переключение уровней исполнения на лету)
выполняет сценарий <path>/sbin/rc</path>.
</p>

	</body>
</section>

<section>
	<title>Виртуальные уровни исполнения</title>
	<body>

<p>
В силу того, что уровни исполнения Gentoo не имеют явного отображения
на уровни исполнения init, первых может быть гораздо больше. А
пользователь получает возможность по своему желанию создавать профили,
или виртуальные уровни исполнения.
</p>

<p>
Например, владелец ноутбука может иметь два уровня исполнения по
умолчанию - &quot;online&quot; и &quot;offline&quot;, что позволяет
активировать первый, когда подключена сетевая карта PCMCIA, и второй -
когда карта отключена. Сценарии для PCMCIA можно настроить так, чтобы
они вызывали <c>&quot;/sbin/rc online&quot;</c> или <c>&quot;/sbin/rc
offline&quot;</c> в каждом соответствующем случае, запуская или
останавливая сервисы, зависящие от статуса сетевой карты.
</p>

	</body>
</section>

<section>
	<title>Уровни исполнения и XFree86</title>
	<body>

<p>
В соответствии со стратегией Gentoo, для X-сервера нет отдельного
уровня исполнения, но есть сценарий для запуска, &quot;xdm&quot;,
который можно добавить на любой требуемый уровень исполнения.

<note>
Это должен быть основной (default) уровень исполнения пользователя.
</note>

<warn>
Добавление этого сценария на загрузочный (boot) уровень исполнения может вызывать побочные эффекты.
</warn>
</p>

<p>
По умолчанию, если вы запускаете xdm, gdm или kdm перед тем, как будут
запущены процессы getty на виртуальных консолях, X-сервер будет работать на следующей доступной консоли. На медленных машинах то, что менеджер рабочего стола
запускается ближе к концу процесса инициализации, проблемой не
является. Процессы getty запустятся перед X-сервером, а тот будет работать на
7-й консоли, как и должно быть. Однако на быстрых машинах все не
совсем так - X-сервер запустится раньше getty, обычно начинающего работу на 2-й консоли. Когда же запустится getty, он возьмет контроль над клавиатурой, а Desktop Manager его потеряет.
</p>

<p>
Проблема решается помещением сценария запуска менеджера рабочих столов
на один из дополнительных уровней исполнения, а именно - на уровень
исполнения 'a'.  Этот уровень исполнения - не настоящий: наш сценарий
<c>&quot;xdm&quot;</c> просто вызывает <c>&quot;telinit a&quot;</c>,
что заставляет все сервисы на уровне исполнения 'a' начать работу
после текущего уровня исполнения, то есть после того, как все getty
будут запущены.

<note>
Дополнительную информацию об уровне исполнения 'a' можно
получить, прочитав man init.
</note>
</p>


	</body>
</section>
</chapter>

<chapter>
<title>RC-сценарии</title>
<section>
	<body>

<p>
RC-сценарии определяют как основные функции каждого сервиса, так и
зависимости при загрузке. Расположены они в <path>/etc/init.d/</path>.
</p>

	</body>
</section>

<section>
	<title>Базовая схема RC-сценария</title>
	<body>

<pre caption="Схема rc-сценария">
#!/sbin/runscript

depend() {
    need bar
}

start() {
    ebegin &quot;Starting foo&quot;
    /sbin/foo
    eend $? &quot;Failed to start foo&quot;
}

stop() {
    ebegin &quot;Stopping foo&quot;
    kill $(cat /var/run/foo.pid)
    eend $? &quot;Failed to stop foo&quot;
}
</pre>

<p>
<note>
Интерпретатор для RC-сценариев -  &quot;/sbin/runscript&quot;.
</note>

<note>
Функция &quot;depend&quot; не обязательна.
</note>
<note>
Каждый RC-сценарий должен иметь по крайней мере функцию &quot;start&quot;.
</note>
</p>

	</body>
</section>

<section>
	<title>Управление запуском</title>
	<body>

<p>
Общепринятым порядком запуска сервисов на уровне исполнения является алфавитный - вследствие выходной информации, генерируемой <path>/bin/ls</path>.
</p>

<p>
Зависимости - основной способ уклониться от порядка исполнения по умолчанию. В других случаях (если между сервисами зависимости отсутствуют) можно использовать типы упорядочивания (order types).
</p>

	</body>
</section>
</chapter>

<chapter>
<title>Типы зависимостей</title>
<section>
	<body>

<p>
Большинство сервисов имеют отношение или зависят от каких-либо других сервисов.
</p>

<p>
Например, для работы postfix необходима запущенная сеть и system logger.
</p>

<p>
С другой стороны, для samba также необходима работающая сеть. Однако, если для печати используется CUPS, то cupsd также должен быть запущен перед samba.  Отметьте, что запуск cups не критичен для работы samba.
</p>

<p>
Таким образом, у нас есть два способа выразить отношения зависимости между различными сервисами. Эти зависимости имеют силу всегда, вне зависимости от того, целиком ли меняется уровень исполнения, или сервис был запущен или остановлен вручную после загрузки.
</p>

	</body>
</section>

<section>
	<title>Тип зависимости NEED</title>
	<body>

<p>
Используется, если зависимый сервис критичен для запуска текущего сервиса.
</p>

<pre caption="добавление logger и net в качестве NEED-зависимости">
depend() {
    need net logger
}
</pre>

<p>
<note>
Сервисы, упомянутые после <e>NEED</e> критичны для работы текущего сервиса.  Следовательно, если не удастся запустить какой-либо из зависимых сервисов, текущий сервис также запущен не будет.
</note>

<impo>
Каждый сервис, упомянутый в строке <e>NEED</e> будет запущен даже в том случае, если он НЕ добавлен к текущему или <e>&quot;boot&quot;</e> уровню исполнения.
</impo>

То есть, <e>NEED</e> - это &quot;строгая&quot; зависимость.
</p>

	</body>
</section>

<section>
	<title>Тип зависимости USE</title>
	<body>

<p>
Сервис не критичен для работы текущего сервиса, но, если он используется, то запуск его должен произойти до начала работы текущего сервиса.
</p>

<pre caption="добавление portmap в качестве USE-зависимости для netmount">
depend() {
    use portmap
}
</pre>

<p>
По умолчанию netmount может управлять точками монтирования NFS, но
рассчитывать на portmap он будет только тогда, когда тот добавлен в
текущий или загрузочный уровень исполнения. Каждому пользователю,
имеющему в своем распоряжении точки монтирования NFS, следует добавить
portmap на уровень исполнения по умолчанию, заставляя netmount
опознать portmap как USE-зависимость и запустить его перед началом
собственной работы.
</p>

<p>
<impo>
Для того, чтобы считаться правильной USE-зависимостью, каждый
сервис, упомянутый в строке <e>USE</e>, <e>*должен*</e> быть добавлен
на текущий или загрузочный уровни исполнения.
</impo>

То есть,<e>USE</e> - это &quot;слабая&quot; зависимость.
</p>

<p>
<note>
Если какой-либо из сервисов, упомянутых в строке <e>USE</e> не
сможет запуститься, текущий сервис все равно начнет свою работу,
поскольку сервисы из строки <e>USE</e> не должны быть критичными для запуска.
</note>
</p>

	</body>
</section>
</chapter>

<chapter>
<title>Управление порядком загрузки без применения зависимостей</title>
<section>
	<body>

<p>
Если между двумя сервисами нет отношений зависимости, но необходимо (или 
желательно) явно запустить один сервис после другого, можно использовать 
отношения <e>AFTER</e> и <e>BEFORE</e>.

<note>
Оба типа действенны только во время смены уровня исполнения.
</note>
</p>

<p>
Также, оба они могут поддерживать шаблон &quot;*&quot; для включения
всех остальных сервисов:
</p>

<pre caption="пример шаблона для AFTER">
depend() {
    after *
}
</pre>

<p>
Заставит текущий сервис запуститься <e>*после*</e> всех остальных.
</p>

	</body>
</section>

<section>
	<title>Тип BEFORE</title>
	<body>

<p>
Текущий сервис начнет работу <e>*перед*</e> перечисленными в строке
<e>BEFORE</e>.
</p>

<pre caption="запустим foo перед bar (отрывок из foo)">
depend() {
   before bar
}
</pre>

	</body>
</section>

<section>
	<title>Тип AFTER</title>
	<body>

<p>
Текущий сервис начнет работу <e>*после*</e> перечисленных в строке
<e>AFTER</e>.
</p>

<pre caption="запустим bar после foo (отрывок из bar)">
depend() {
    after foo
}
</pre>

	</body>
</section>
</chapter>

<chapter>
<title>Виртуальные сервисы</title>
<section>
	<body>

<p>
Как принято в современном мире Unix, существует множество разновидностей 
сервисов. Выбор обычно определяется пользователем или администратором.
</p>

<p>
Один из примеров - это system loggers, которых в Gentoo Linux
насчитывается четыре разновидности. Все сервисы, которым для работы
требуется запущенный system logger, не могут использовать
NEED-зависимость сразу для всех четырех. А USE-зависимость - слишком
слабая.
</p>

<p>
Именно здесь и вступают в действие виртуальные сервисы и тип <e>PROVIDE</e>.
</p>

	</body>
</section>

<section>
	<title>Тип PROVIDE</title>
	<body>

<p>
Тип <e>PROVIDE</e> определяет виртуальный сервис, который все
остальные сервисы могут подключать с помощью 
зависимостей типа <e>NEED</e> или <e>USE</e>.
</p>

<pre caption="sysklogd предоставляет logger">
depend() {
    provide logger
}
</pre>

	</body>
</section>

<section>
	<title>Виртуальный сервис LOGGER</title>
	<body>

<p>
<e>LOGGER</e> - это предопределенный виртуальный сервис,
предоставляемый всеми system loggers. Его можно использовать с помощью
типов зависимости <e>NEED</e> или <e>USE</e>.
</p>

	</body>
</section>

<section>
	<title>Виртуальный сервис NET</title>
	<body>

<p>
Сервис <e>NET</e> - это еще один виртуальный сервис, но, в отличие
от <e>LOGGER</e>, не предоставляющий <e>PROVIDE</e> явно.
</p>

<p>
<impo>Для того, чтобы предоставлять виртуальный сервис-NET, сервис должен:
<ul>
<li>Быть добавленным к текущему или загрузочному уровню исполнения</li>
<li>Иметь в начале своего имени &quot;net.&quot;.</li>
<li>Часть имени после &quot;net.&quot; должна быть именем
существующего сетевого интерфейса (например, net.eth0 или net.ppp1 for
example).</li>
</ul>
</impo>
</p>

<p>
Для каждого действительного сервиса net.* переменная $IFACE будет
содержать имя сетевого интерфейса (например, &quot;eth0&quot; для
net.eth0).
</p>

	</body>
</section>
</chapter>

<chapter>
<title>Опции командной строки по умолчанию</title>
<section>
	<body>

<p>
Каждый сервис может быть вызван с любым параметром по умолчанию. Все функции
упомянутые выше, уже определены, за исключением <e>START</e> и
<e>STOP</e>, которые должны быть описаны пользователем в его
rc-сценарии.

<impo>
Функция <e>start()</e> должна быть определена.
</impo>
<note>
Функция <e>stop()</e> менее важна и может быть опущена.
</note>
</p>

<p>
<note>
В принципе, пользователю потребуется объявить только функции <e>start()</e>,
<e>stop()</e> и <e>restart()</e>. Все остальные - внутренние, их стоит
оставить в покое.
</note>
</p>

<pre caption="запустить сервис httpd">
# <c>/etc/init.d/httpd start</c>
</pre>

<p>
<note>
Опции командной строки можно комбинировать.
</note>
</p>

<pre caption="приостановить, а затем запустить net.eth0">
# <c>/etc/init.d/net.eth0 pause start</c>
</pre>

	</body>
</section>

<section>
	<title>Опции START и STOP</title>
	<body>

<p>
<e>START</e> запускает текущий сервис, включая все те, от которых он зависит.
</p>

<p>
<e>STOP</e> останавливает текущий сервис, включая все те, от которых
он зависит.
</p>

</body>
</section>

<section>
	<title>Опция RESTART</title>
	<body>

<p>Сервис должен начинать работу с помощью <e>RESTART</e>. В этом
случае будет перезапущен текущий и все зависимые сервисы.

<impo>
Если определена пользовательская функция <e>restart()</e>, то для
запуска и останова сервиса должны использоваться функции
<e>&quot;svc_start()&quot;</e> и <e>&quot;svc_stop()&quot;</e>.
</impo>

<note>
Это сделано для правильной обработки всех зависимых сервисов.
</note>
</p>

</body>
</section>

<section>
<title>Опция PAUSE</title>
	<body>

<p>
Остановит текущий сервис, но, в отличие от <e>STOP</e>, ни один из зависимых
сервисов остановлен не будет.
</p>

	</body>
</section>

<section>
<title>Опция ZAP</title>
	<body>

<p>
Помечает статус сервиса как остановленный.

<note>
Заметьте, что ни одна команда в функции <e>stop()</e> не выполняется. 
Следовательно, пользователь сам должен сделать все необходимые действия.
</note>
</p>
</body>
</section>

<section>
<title>Опции INEED и NEEDSME</title>
	<body>

<p>
Опция <e>INEED</e> выводит список всех сервисов, указанных в
разделе <e>NEED</e> запрашиваемого сервиса.
</p>

<p>
Опция <e>NEEDSME</e> выводит список всех сервисов, содержащих в
разделе <e>NEED</e> имя запрашиваемого сервиса.
</p>

	</body>
</section>

<section>
<title>Опции IUSE и USESME</title>
	<body>

<p>
Опция <e>IUSE</e> выводит список всех сервисов, указанных в разделе <e>USE</e> запрашиваемого сервиса.
</p>

<p>
Опция <e>USESME</e> выводит список всех сервисов, содержащих в своем
разделе <e>USE</e> имя запрашиваемого сервиса.
</p>

	</body>
</section>

<section>
	<title>Опция BROKEN</title>
	<body>

<p>
Выводит список пропущенных сервисов (если таковые присутствуют),
содержащихся в разделе <e>NEED</e> опрашиваемого сервиса.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Добавление собственных опций командной строки</title>
<section>
	<body>

<p>
Добавить собственные опции командной строки довольно просто. Для этого в 
rc-сценарии должна быть определена функция с именем нужной опции и, как
показано ниже, добавлена к содержимому переменной $opts.
</p>

<pre caption="собственная опция foo">
opts=&quot;${opts} foo&quot;

foo() {
    ............
}
</pre>
	</body>
</section>
</chapter>

<chapter>
<title>Настройка</title>
<section>
	<body>

<p>
Настройка обычно производится с помощью переменных окружения. Однако,
эти переменные должны определяться не в самом rc-сценарии, а в одном
из трех файлов настройки.
</p>

<p>
Один из них относится к самому rc-сценарию, два остальных - ко всей
системе:
</p>

<pre caption="Файлы настройки для rc-сценариев">
<path>/etc/conf.d/имя_сценария</path>
<path>/etc/conf.d/basic</path>
<path>/etc/rc.conf</path>
</pre>

<p>
<note>
Все три файла читаются системой в указанном порядке
</note>

<impo>
Все NET-сервисы также читают и <path>/etc/conf.d/net</path>
</impo>
</p>

	</body>
</section>
</chapter>

<chapter>
<title>Утилиты и сценарии-помощники</title>

<section>
	<title>Утилита rc-update</title>
	<body>

<p>
rc-update - основной инструмент для добавления и удаления сервисов из
уровня исполнения. Помимо этого, для обновления кэша зависимостей он
запускает сценарий &quot;depscan.sh&quot;.
</p>

<pre caption="добавить metalog на уровень исполнения по умолчанию">
# <c>rc-update add metalog default</c>
</pre>

<pre caption="удалить metalog с уровня исполнения по умолчанию">
# <c>rc-update del metalog default</c>
</pre>

<p>
<note>
Дополнительную информацию поможет получить запуск rc-update без
аргументов.
</note>
</p>

</body>
</section>

<section>
	<title>Сценарий-помощник depscan.sh</title>
	<body>

<p>
depscan.sh упомянут здесь для полноты. Используется он для создания
кэша зависимостей, который есть ни что иное, как таблица отображения
зависимостей между сервисами.
</p>

<p>
Этот сценарий следует запускать всякий раз, когда в
<path>/etc/init.d/</path> добавляется новый сервис, но, поскольку
rc-update запускает его автоматически, то большинству пользователей
делать этого не потребуется.
</p>

	</body>
</section>
</chapter>

<chapter>
<title>От редактора. Примеры применения</title>

<p>
Здесь даны несколько примеров решения практических задач настройки стартовых сценариев.
</p>

<section>
	<title>Настройка сервиса консольной мыши</title>
	<body>

<p>
Первая из таких задач - включение сервиса консольной мыши. Для этого сначала командой 
</p>

<pre caption = "Установка пакета gpm">
# emerge sys-libs/gpm
</pre>

<p> 
устанавливается пакет gpm, а затем он активизируется для заданного по умолчанию уровня исполнения:
</p>

<pre caption = "Активизация сервиса gpm">
# rc-update add gpm default
</pre>

<p> 
После этого остается лишь внести изменения в файл <path>/etc/conf.d/gpm</path>, соответствующие реалиям пользователя.
</p>

	</body>
</section>

<section>
	<title>Активизация таблицы перекодировки кириллицы</title>
	<body>

<p> 
Следующая задача, решаемая с помощью rc-сценариев - включение поддержки кириллицы. Само по себе оно осуществляется редактированием файла <path>/etc/rc.conf</path>, где указываются загружаемые при старте системы экранные шрифты (в кодировке CP866) и раскладка клавитауры с символами кириллицы (в кодировке KOI8-R), а также карта перекодирования (mapscreen) одного в другое.
</p>

<p>
Остается только активизировать последнюю на всех виртуальных консолях. Для этого составляется (в случае 6 виртуальных консолей) скрипт <path>/etc/init.d/consoletrans</path> следующего содержания:
</p>

<pre caption = "Скрипт автивизации таблицы перекодировки">
for i in 1 2 3 4 5 6
        do
        echo -ne '\033(K' > /dev/vc/$i
done
</pre>

<p>
ему присваивается бит исполнения, а затем он добавляется к уровню запуска по умолчанию:
</p>

<pre caption = "Активизация таблицы перекодировки">
# rc-update add consoletrans default
</pre>

	</body>
</section>
</chapter>

</guide>
