<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/genkernel.xml,v 1.7 2006/04/01 20:03:27 achumakov Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ru/genkernel.xml" lang="ru">
<title>Руководство по Gentoo Linux Genkernel</title>

<author title="автор">
  <mail link="plasmaroo@gentoo.org">Tim Yamin</mail>
</author>

<!-- folajimi@speakeasy.net -->
<author title="участник">
  Jimi Ayodele
</author>

<!-- thseiler@gmail.com -->
<author title="поддержка NFS">
  Thomas Seiler
</author>
<author title="переводчик">
    <mail link="mike.spacer@gmail.com">Михаил Ярмиш</mail>
</author>
<author title="редактор перевода">
    <mail link="achumakov@gentoo.org">Алексей Чумаков</mail>
</author>

<abstract>
В этом руководстве дается описание всех функций genkernel.
</abstract>

<license/>

<version>1.4.3</version>
<date>2005-12-16</date>

<chapter>
<title>Предисловие</title>
<section>
<title>Назначение</title>
<body>

<p>
Genkernel &mdash; это инструмент, позволяющий автоматизировать компиляцию ядра 
для пользователей, не посвященных в этот процесс. Он помогает создать образ 
ядра, подобный имеющимся на установочных дисках Gentoo, которые в свою очередь 
разработаны для автоматического определения аппаратной конфигурации вашей 
системы. Помимо этого, некоторых пользователей заинтересует использование 
genkernel для устройств, требующих инициализации и рабочего ядра до запуска 
системы. Так как genkernel автоматически компилирует модули вашего ядра, 
вы можете использовать такие устройства, которым для правильной работы могут 
требоваться определенные параметры модуля.
</p>

</body>
</section>
<section>
<title>Целевая аудитория</title>
<body>

<p>
Genkernel очень полезный инструмент, если вы не уверенны в том, как компилировать
ядро или просто не осведомлены об имеющихся на вашей системе устройствах. Он
разработан для упрощения процесса компиляции ядра и по умолчанию поддерживает
большинство  устройств.
</p>

<p>
Однако, если вам известно, какие драйверы необходимы системе, вы можете сократить
время последующей компиляции ядра. Это возможно посредством указания genkernel
компилировать только драйверы, относящиеся к вашим устройствам. Часто нужно
меньше драйверов, чем предусмотрено в настройке по умолчанию (что приводит 
к сокращению времени компиляции ядра).
</p>

</body>
</section>
<section>
<title>Установка genkernel</title>
<body>

<p>
Для получения genkernel запустите <c>emerge genkernel</c> в командной строке.
Если вы используете <uri
link="/doc/en/handbook/2006.0/hb-install-about.xml#doc_chap2_sect1">Gentoo
Reference Platform</uri> (GRP), не забудьте установить двоичные пакеты, указав 
флаг <c>-k</c> команде emerge. Так как GRP комплектуется старой версией 
genkernel, флаги могу различаться. В любом случае, обратитесь к <c>genkernel
--help</c>, чтобы узнать, как использовать версию genkernel, установленную в
вашей системе. 
</p>

</body>
</section>
</chapter>

<chapter>
<title>Работа с genkernel</title>
<section>
<title>Как использовать genkernel</title>
<body>

<p>
Хотя есть несколько способов запустить genkernel, простейший из них &mdash; 
<c>genkernel all</c>. В нем используется универсальные настройки, прекрасно 
работающие на большинстве систем. Как отмечено ранее, этот подход не избавлен 
от недостатков. Большинство создаваемых модулей бесполезно для обычного 
пользователя, но увеличивает время компиляции. Ниже приведен более 
эффективный подход, достигаемый передачей genkernel определенных флагов от
имени root:
</p>

<pre caption="Запуск genkernel (с флагами)">
# <i>genkernel --bootsplash --no-install --no-clean --menuconfig all</i>
</pre>

<p>
Приведенная операция вынуждает genkernel создать ядро с загрузочной заставкой
(<c>--bootsplash</c>), предназначенное для ручной установки 
(<c>--no-install</c>). При подготовке дерева исходного кода ядра, genkernel не 
будет вычищать существующие в нем объектные файлы (<c>--no-clean</c>). Будет 
запущена утилита настройки, снабженная меню, позволяющая выбрать модули для 
компиляции (<c>--menuconfig</c>).
</p>

<p>
Есть и другие флаги, влияющие на результат работы genkernel. Например, замена 
флага <c>--no install</c> на <c>--install</c> позволяет genkernel автоматически 
установить новое ядро в каталог <path>/boot</path>. Использование флага 
<c>--mountboot</c> позволяет genkernel автоматически смонтировать раздел 
<path>/boot</path>, если необходимо.
</p>

<p>
Помните, что genkernel разработан, чтобы сделать процесс компиляции ядра 
простым и не вызывающим стрессов. Поэтому в genkernel есть флаги, облегчающие 
компиляцию ядра. Например, одни флаги упрощают настройку ядра, а другие влияют 
на сам процесс компиляции. Для тех, кто заинтересован в дальнейшей оптимизации, 
имеются флаги, влияющие на компоновку, упаковку, и даже на инициализацию ядра.
</p>

<p>
Далее в этой главе рассматривается действие различных флагов, и операции,
имеющиеся в genkernel. У некоторых флагов есть варианты, позволяющие выполнять
обратные операции. В обратных вариантах используется приставка 
<b><c>no-</c></b>, а описание их действия приводится в квадратных скобках, [].
</p>

</body>
</section>
<section>
<title>Флаги настройки</title>
<body>

<p>
Флаги настройки, приведенные ниже, существуют, чтобы помочь вам до компиляции 
определить, какие возможности ядра включить, а какие &mdash; выключить. Вы даже 
можете выбрать, сохранять ли файл настроек, создаваемый в процессе работы.
Основные флаги настройки таковы:
</p>

<ul>
  <li>
    <b>--<c>no-</c>menuconfig</b>: запустить <e>[или не запускать]</e> команду
    <c>make menuconfig</c> (которая запускает интерактивную утилиту
    настройки ядра, снабженную меню) перед компиляцией ядра.
  </li>
  <li>
    <b>--gconfig</b>: запустить утилиту настройки ядра, основанную на 
    библиотеках GTK+. Ее достоинство в том, что многим пользователям проще и
    понятнее настраивать ядро в оконной среде. А ее недостаток в том, что для 
    ее запуска вам <b>потребуется</b> сама система окон X, т.е. она не 
    заработает из командной строки.
  </li>
  <li>
    <b>--xconfig</b>: запустить утилиту настройки ядра, основанную на 
    библиотеках QT. Ее достоинство в том, что многим пользователям проще и
    понятнее настраивать ядро в оконной среде. А ее недостаток в том, что для 
    ее запуска вам <b>потребуется</b> сама система окон X, т.е. она не 
    заработает из командной строки.
  </li>
  <li>
    <b>--<c>no-</c>save-config</b>: сохранять <e>[или не сохранять]</e> 
    настройки ядра на будущее в файл, находящийся в каталоге 
    <path>/etc/kernels/</path>.
  </li>
</ul>

</body>
</section>
<section>
<title>Флаги компиляции</title>
<body>

<p>
Действие следующих флагов обычно проявляется в самом процессе компиляции:
</p>

<ul>
  <li>
    <b>--kerneldir=<path>/путь/к/исходникам/</path></b>: указание 
    альтернативного расположения исходного кода ядра вместо расположения по 
    умолчанию в <path>/usr/src/linux/</path>.
  </li>
  <li>
    <b>--kernel-config=<path>/путь/к/файлу-настроек</path></b>: указание
    на использование альтернативного файла настроек, вместо файла по умолчанию
    <path>/path/to/sources/.config</path>.
  </li>
  <li>
    <b>--module-prefix=<path>/путь/к/каталогу-модулей/</path></b>: определение
    пути к каталогу, в который устанавливаются модули ядра (по умолчанию 
    &mdash; <path>/lib/modules/</path>).
  </li>
</ul>

<ul>
  <li>
    <b>--<c>no-</c>clean</b>: запустить <e>[или не запускать]</e> команду
    <c>make clean</c> перед компиляцией ядра. Команда <c>make clean</c> удаляет 
    все объектные файлы и зависимости из дерева исходного кода ядра.
  </li>
  <li>
    <b>--<c>no-</c>mrproper</b>: запустить <e>[или не запускать]</e> команду 
    <c>make mrproper</c> перед компиляцией ядра. Как и команда <c>make 
    clean</c>, команда <c>make mrproper</c> удаляет все объектные файлы и 
    зависимости из дерева исходного кода ядра. Кроме того, из дерева исходного
    кода ядра <b>также</b> убираются любые предыдущие файлы настроек (в 
    <path>/путь/к/исходникам/.config</path> или 
    <path>/путь/к/исходникам/.config.old</path>).
  </li>
  <li>
    <b>--oldconfig</b>: запустить команду <c>make oldconfig</c>, которая 
    попытается собрать информацию о настройках системной архитектуры из 
    универсального сценария <path>/usr/share/genkernel/</path>. Этот процесс не 
    интерактивен. Участие пользователя не предусмотрено. К тому же, если флаг 
    <c>--oldconfig</c> используется совместно с <c>--clean</c>, последний 
    обращается, т.е. включается флаг <c>--no-clean</c>.
  </li>
</ul>

<ul>
  <li>
    <b>--callback="<c>echo hello</c>"</b>: вызвать указанные аргументы (здесь: 
    <c>echo hello</c>) после компиляции ядра и необходимых модулей, но до 
    сборки образа начального корневого диска (initrd). Это может быть полезно, 
    если вы хотите установить (emerge) внешние модули в образ initrd с помощью 
    параметра callback, а затем переопределить группу модулей genkernel.
  </li>
</ul>

<ul>
  <li>
    <b>--<c>no-</c>install</b>: запускать <e>[или не запускать]</e> команду 
    <c>make install</c>, которая устанавливает новое ядро, файл настроек, образ 
    initrd и карту системы в смонтированый загрузочный раздел. Также 
    устанавливаются любые скомпилированные модули.
  </li>
  <li>
    <b>--<c>no-</c>initrdmodules</b>: воздержаться от копирования каких-либо 
    модулей в создаваемый genkernel образ initrd. Этот флаг &mdash; исключение 
    из правила, касающегося приставки <c>no-</c>; отсутствие приставки приводит
    к созданию недопустимого флага genkernel.
  </li>
  <li>
    <b>--genzimage</b>: создавать образ initrd до создания образа ядра.
    (Этот хак предназначен исключительно для систем PPC Pegasos.)
  </li>
</ul>

</body>
</section>
<section>
<title>Флаги компилятора</title>
<body>

<p>
Следующие флаги поддерживаются genkernel и передаются соответствующим 
приложениям по мере сборки ядра. Эти флаги влияют <e>компилятор</e>,
используемый для трансляции ядра, в том числе на низком уровне. 
</p>

<ul>
  <li>
    <b>--kernel-cc=<c>некийКомпилятор</c></b>: указание компилятора, 
    применяемого при сборке ядра.
  </li>
  <li>
    <b>--kernel-ld=<c>некийКомпоновщик</c></b>: указание компоновщика, 
    применяемого при сборке ядра.
  </li>
  <li>
    <b>--kernel-as=<c>некийАссемблер</c></b>: указание ассемблера,
    применяемого при сборке ядра.
  </li>
  <li>
    <b>--kernel-make=<c>некийСборщик</c></b>: указание альтернативы утилите
    <e>GNU make</e>, используемой при сборке ядра.
  </li>
</ul>

<ul>
  <li>
    <b>--utils-cc=<c>некийКомпилятор</c></b>: указание компилятора,
    применяемого при сборке утилит поддержки.
  </li>
  <li>
    <b>--utils-ld=<c>некийКомпоновщик</c></b>: указание компоновщика,
    применяемого при сборке утилит поддержки.
  </li>
  <li>
    <b>--utils-as=<c>некийАссемблер</c></b>: указание ассемблера,
    применяемого при сборке утилит поддержки.
  </li>
  <li>
    <b>--utils-make=<c>некийСборщик</c></b>: указание альтернативы утилите
    <e>GNU make</e>, используемой при сборке утилит поддержки.
  </li>
</ul>

<ul>
  <li>
    <b>--makeopts=<c>-jX</c></b>: определение количества одновременных потоков, 
    которые утилита make может порождать в процессе компиляции ядра (и утилит).
    Переменная <b>'X'</b> &mdash; это число, получаемое добавлением 1 к 
    количеству процессоров, доступных системе. Так, для системы с одним 
    процессором подходит значение <c>-j2</c>; для системы с двумя процессорами 
    &mdash; <c>-j3</c> и т.д. <e>(На однопроцессорной системе с поддержкой 
    технологии Hyper-Threading можно использовать флаг </e><c>-j3</c><e>, если
    поддержка симметричной многопроцессорной обработки (SMP) включена в 
    ядре.)</e> 
  </li>
</ul>

</body>
</section>
<section>
<title>Отладочные флаги</title>
<body>

<p>
В процессе компиляции ядра, флаги отладки регулируют способ и количество сообщаемой
пользователю информации.
</p>

<ul>
  <li>
    <b>--debuglevel=<c>verblevel</c></b>: установка уровня подробности 
    информации, выводимой genkernel. Переменная <c>verblevel</c> &mdash;  
    целое от 0 до 5. '0' соответствует минимальному выводу, а '5' включает
    выдачу максимально подробной информации о действиях genkernel во время
    компиляции ядра.
  </li>
  <li>
    <b>--debugfile=<path>/путь/к/файлу-вывода</path></b>: направление 
    <b>всей</b> порождаемой genkernel отладочной информации в указанный файл,
    при этом уровень, установленный в <c>--debuglevel</c>, игнорируется. По 
    умолчанию файл расположен в <path>/var/log/genkernel.log</path>.
  </li>
  <li>
    <b>--no-color</b>: включение <e>[или отключение]</e> цветовой раскраски 
    отладочной информации genkernel c использованием управляющих escape-кодов.
  </li>
</ul>

</body>
</section>

<section>
<title>Флаги инициализации</title>
<body>

<p>
Эти влаги вызывают определенные эффекты при запуске системы. Некоторые 
влияют только на внешний вид, а другие могут понадобиться для включения 
определенных функций системы.
</p>

<ul>
  <li>
    <b>--<c>no-</c>bootsplash</b>: включение <e>[или отключение]</e> поддержки 
    <uri link="http://www.bootsplash.org/">загрузочной заставки 
    bootsplash</uri> в образе initrd, подготовленном genkernel. Загрузочная 
    заставка поддерживается не на всех архитектурах, а ее поддержка должна быть 
    включена в ядро.  
  </li>
  <li>
    <b>--<c>no-</c>gensplash</b>: включение <e>[или отключение]</e> поддержки
    <uri
    link="http://dev.gentoo.org/~spock/projects/gensplash/">загрузочной заставки
    gensplash</uri> в образе initrd, подготовленном genkernel. Заставка 
    gensplash разработана для ядер 2.6 и предназначена для замены bootsplash.
    Для изменения темы по умолчанию, используемой gensplash, используйте
    <b>--gensplash=<c>ПредпочитаемаяТема</c></b> (где <c>ПредпочитаемаяТема</c> 
    &mdash; имя одного из подкаталогов в каталоге <path>/etc/splash/</path>.
  </li>
  <li>
    <b>--gensplash-res=<c>ПредпочитаемоеРазрешение</c></b>: данный флаг позволяет
    выбрать варианты разрешения заставки, поддерживаемые в initrd при загрузке
    системы. Это полезно по двум причинам: во-первых, вы можете выбрать только
    те варианты разрешения заставки, которые подходят для вашей системы. 
    Во-вторых, избежите ненужного увеличения места, занимаемого образом initrd 
    на жестком диске (т.к. не понадобится включать разрешения, не 
    соответствующие параметрам вашей системы). С другой стороны, этот флаг 
    лучше не включать, если ядро компилируются для установочного диска; это
    позволит gensplash поддерживать все возможные варианты разрешения.
  </li>
  <li>
    <b>--do-keymap-auto</b>: принудительный выбор раскладки клавиатуры во время 
    загрузки системы.
  </li>
  <li>
    <b>--lvm2</b>: включение поддержки устройств хранения с использованием <uri
    link="http://sources.redhat.com/lvm2/">диспетчера логических томов</uri>
    (LVM2) из <e>статических</e> бинарников в случае их доступности. При 
    отсутствии соответствующие (статические) LVM2 бинарники компилируются. 
    Перед использованием этого флага, пакет lvm2 нужно установить в вашу 
    систему командой <c>emerge lvm2</c>. Обязательно прочтите руководство по
    <uri link="/doc/en/lvm2.xml">установке LVM2 на Gentoo (англ.)</uri>.
  </li>
  <li>
    <b>--evms2</b>: включение поддержки устройств хранения с использованием 
    <uri link="http://evms.sourceforge.net/">системы управления томами 
    предприятия</uri> (EVMS2) при ее доступности. Перед использованием этого
    флага, установите пакет в свою систему командой <c>USE=static emerge 
    evms2</c>. <e>(При пропуске во время установки пакета флага 
    </e><c>USE=static</c><e>, не будут включены необходимые статические 
    бинарники.</e> 
  </li>
  <li>
    <b>--dmraid</b>: включение поддержки <uri
    link="http://people.redhat.com/~heinzm/sw/dmraid/readme">DMRAID</uri> 
    &mdash; утилиты, создающей проекции RAID с использованием подсистемы
    отображения устройств, встроенную в ядро. DMRAID находит, включает, 
    отключает и отображает свойства програмных RAID-массивов (например, 
    ATARAID), и содержащихся разделов DOS. 
  </li>
  <li>
    <b>--linuxrc=/путь/к/вашему/linuxrc</b>: указание созданного пользователем 
    сценария <e>linuxrc</e>, который запускается на этапе запуска ядра, до 
    собственно процесса загрузки. (Сценарий linuxrc по умолчанию должен 
    находиться в каталоге <path>/usr/share/genkernel/</path>.) Он позволяет 
    загрузить маленькое модульное ядро и подгрузить необходимые драйверы, 
    нужные системе, как модули. 
  </li>
  <li>
    <b>--cachedir=/путь/к/альтернативному/каталогу/</b>: изменение каталога для
    размещения кэша при компиляции ядра.
  </li>
  <li>
    <b>--tempdir=/путь/к/новому/временному каталогу/</b>: указание расположения 
    временного каталога, используемого genkernel во время компиляции ядра.
  </li>
  <li>
    <b>--unionfs</b>: включение поддержки <uri
    link="http://www.fsl.cs.sunysb.edu/project-unionfs.html">объединяющей 
    файловой системы</uri> (unification file system) в образ initrd.
  </li>
</ul>

</body>
</section>
<section>
<title>Прочие флаги</title>
<body>

<p>
Флаги, перечисленные ниже, поддерживаются genkernel, но не относятся к другим
категориям: 
</p>

<ul>
  <li>
    <b>--mountboot</b>: определение необходимости монтирования каталога 
    <path>/boot/</path> на отдельном разделе. По необходимости инструкции по 
    монтированию файловой системы загрузочного раздела будут браться из 
    сценария <path>/etc/fstab</path>. 
  </li>
  <li>
    <b>--kernname=<c>Псевдоним</c></b>: позволяет изменить названия образов 
    ядра и initrd в каталоге <path>/boot/</path>. Будут создаваться образы 
    kernel-<c>Псевдоним</c>-версия и initramfs-<c>Псевдоним</c>-версия.
  </li>
</ul>

</body>
</section>
<section>
<title>Возможные действия</title>
<body>

<p>
Действия указывают genkernel, что компилировать. На данный момент 
поддерживаются следующие действия:
</p>

<ul>
  <li><c>initrd</c>: сборка только образа initrd</li>
  <li><c>bzImage</c>: сборка только образа ядра</li>
  <li><c>kernel</c>: сборка только образа ядра и модулей</li>
  <li>
    <c>all</c>: сборка всех стадий: образа initrd, образа ядра и модулей
  </li>
</ul>

<p>
Последнее действие, <c>all</c>, рекомендуется большинству пользователей, так 
как обеспечивает сборку всех стадий, необходимых для работоспособности ядра.
Помните, что <e>действие</e> просто сообщает genkernel, что 
<e>собирать</e>, а не что <e>устанавливать</e>. 
</p>

</body>
</section>
<section>
<title>Настройка загрузчика</title>
<body>

<p>
Чтобы настроить genkernel на работу с вашим загрузчиком, необходимо сделать 
три-четыре изменения в файле настроек загрузчика:
</p>

<ol>
  <li>
    Включите <c>root=/dev/ram0</c> и <c>init=/linuxrc</c> в параметры ядра,
    передаваемые образу ядра.
  </li>
  <li>
    Добавьте <c>real_root=/dev/hda3</c> (например) к параметрам ядра,
    передаваемым образу ядра, если ваш корневой раздел &mdash; 
    <path>/dev/hda3</path>. 
  </li>
  <li>
    Если вы пользуетесь загрузочной заставкой bootsplash, добавьте подходящую 
    строчку режимов, например, <c>vga=0x317</c>, к параметрам, передаваемым 
    ядру. Также добавьте <c>splash=verbose</c> или <c>splash=silent</c>,
    в зависимости от необходимого уровня подробности сообщений загрузчика.
  </li>
  <li>
    Добавьте нужную загрузчику информацию о начальном корневом диске (initrd).
    За подробностями о настройке загрузчика на initrd обращайтесь к главе <uri
    link="/doc/ru/handbook/handbook-x86.xml?part=1&amp;chap=10">Настройка
    загрузчика</uri> Настольной книги Gentoo.
  </li>
</ol>

</body>
</section>
</chapter>

<chapter>
<title>Параметры настройки</title>
<section>
<title>Изменение /etc/genkernel.conf</title>
<body>

<p>
Передавать genkernel флаги из командной строки может быть очень неудобно, в 
особенности, если у вас их с десяток:
</p>

<pre caption="Запуск genkernel (перегруженного флагами)">
# <i>genkernel --debuglevel=5 --no-color --no-mrproper --clean --gensplash \
--kerneldir=/path/to/alternate/kernel/sources --install --menuconfig \
--kernel-config=/path/to/preferred/configfile --save-config --mountboot all</i>
</pre>

<p>
К счастью, существует файл настроек, при необходимости можно выставить как надо
большинство основных параметров. Ниже приведено краткое описание самых 
значимых:
</p>

<ul>
  <li>
    <b>MENUCONFIG=<c>[yes|no]</c></b>: этот параметр эквивалентен флагу
    <c>--menuconfig</c>, используемому genkernel, который, в свою очередь, 
    пользуется командой <c>make menuconfig</c> для вызова утилиты настройки 
    ядра, использующей командную строку. Для автоматического запуска утилиты
    во время настройки ядра этим сценарием, установите в 'yes'. В противном 
    случае установите в 'no'. 
  </li>
  <li>
    <b>CLEAN=<c>[yes|no]</c></b>: установка этого параметра в 'yes' 
    соответствует флагу <c>--clean</c> genkernel, и приводит к запуску команды 
    <c>make clean</c> для удаления всех объектных файлов и зависимостей из 
    дерева исходного кода ядра. Его установка в 'no' вызывает каскадный эффект, 
    эквивалентный флагу genkernel <c>--no-clean</c>, отключающему команду
    <c>make clean</c> и неявно включающему флаг <c>--no-mrproper</c>, 
    аннулирующий команду <c>make mrproper</c>.
  </li>
  <li>
    <b>MRPROPER=<c>[yes|no]</c></b>: установка в 'yes' эквивалентна передаче 
    genkernel флага <c>--mrproper</c>, вызывающего команду <c>make 
    mrproper</c>, которая очищает дерево исходного кода ядра от любых файлов 
    настроек. Установка в 'no' эквивалентна флагу <c>--no-mrproper</c>, 
    который оключает команду <c>make mrproper</c>.
  </li>
  <li>
    <b>MOUNTBOOT=<c>[yes|no]</c></b>: установка этого параметра в 'yes' 
    эквивалентна флагу <c>--mountboot</c>, приводя при необходимости 
    автоматическое монтирование каталога <path>/boot/</path> во время 
    компиляции. Параметр рекомендуется включать, если каталог 
    <path>/boot/</path> находится на отдельном разделе. Тогда позднее придется 
    помнить на один существенный шаг меньше. 
  </li>
  <li>
    <b>SAVE_CONFIG=<c>[yes|no]</c></b>: после настройки ядра, выбранные 
    параметры сохраняются в файл <path>.config</path>, находящийся в дереве 
    исходного кода ядра. Этот сценарий заменяется или даже удаляется при 
    последующей компиляции ядра. Установка в 'yes' эквивалентна флагу 
    <c>--save-config</c>, вызывая сохранение всех параметров, выбранных при 
    настройке ядра, в сценарии в каталоге <path>/etc/kernels/</path>. Выбор 'no'
    сохраняет существующее положение.
  </li>
  <li>
    <b>USECOLOR=<c>[yes|no]</c></b>: установка параметра в 'yes' эквивалентна
    флагу <c>--color</c>, раскрашивающему сообщения genkernel для облегчения
    отладки (при необходимости).
  </li>
  <li>
    <b>DEBUGLEVEL=<c>[0|1|2|3|4|5]</c></b>: этот параметр отвечает за 
    подробность сообщений genkernel. Его установка на '0', как и 
    <c>--debuglevel=0</c>, подавляет все сообщения, выводимые genkernel. А 
    установка в '5', как и <c>--debuglevel=5</c>, обеспечивает пользователя 
    полным объемом информации, выводимой genkernel. 
  </li>
</ul>

<p>
Установив нужные значения в <path>/etc/genkernel.conf</path>, вы можете 
наполовину сократить количество флагов, передаваемых genkernel из командной 
строки:
</p>

<pre caption="Запуск genkernel с флагами после применения genkernel.conf">
# <i>genkernel --gensplash --kerneldir=/path/to/alternate/kernel/sources \
--kernel-config=/path/to/preferred/configfile --install all</i>
</pre>

<p>
При обоих подходах достигается одинаковый результат, но в последнем случае 
большинство параметров хранится в сценарии, который впоследствии можно 
изменять.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Загрузка по сети с применением genkernel</title>
<section>
<title>Загрузка по сети с установочного диска</title>
<body>

<p>
Утилита genkernel может собирать образы ядра и initrd, поддерживающие сетевую
загрузку, или <e>netboot</e>. Если повезет, в среду, предоставляемую 
установочным диском, по сети можно загрузить любой современный компьютер.
</p>

<p>
Волшебство таится в сценарии genkernel linuxrc. Он пытается смонтировать 
установочный диск по сети (<e>netmount</e>) с помощью сетевой файловой системы 
(NFS). Далее управление передается <e>сценариям инициализации</e>, как если бы 
установочный диск присутствовал локально.
</p>

</body>
</section>
<section>
<title>Сборка образов ядра и initrd с поддержкой сетевой загрузки</title>
<body>

<p>
Для включения поддержки сетевой загрузки, при настройке ядра включите следующие 
параметры:
</p>

<warn>
Поддержка сетевой загрузки в genkernel является экспериментальной и может 
содержать ошибки.
</warn>

<p>
Во-первых, в образ ядра должны быть включены драйверы ваших сетевых плат. 
Обычно драйверы таких устройств компилируются как модули. Однако, для сетевой 
загрузки необходимо, чтобы такие драйверы компилировались прямо в образ ядра,
а <b>не</b> как модули.
</p>

<pre caption="Настройка поддержки драйвера сетевой платы в ядрах 2.6">
Device Drivers --->
   Networking Support --->
      Ethernet (10 or 100Mbit)  --->
         [*] Ethernet (10 or 100Mbit)
         &lt;*&gt;   the driver for your network card
<comment>(обязательно выбирайте &lt;*&gt;, а не &lt;M&gt;)</comment>
</pre>

<p>
Во-вторых, советуем включить параметры <c>IP: kernel level 
autoconfiguration</c> и <c>IP: DHCP support</c>. Это позволит избежать лишних
сложностей, так как IP-адрес и сетевой путь NFS к установочному диску можно
настроить на сервере DHCP. Конечно, это означает, что командная строка ядра 
останется неизменной для любого компьютера, что очень важно для загрузки 
по сети.
</p>

<pre caption="Настройка поддержки DHCP в ядрах 2.6">
Device Drivers --->
   Networking Support --->
      Networking options
         [*] TCP/IP networking--->
         [*]   IP: kernel level autoconfiguration
         [*]     IP: DHCP support
<comment>(эти параметры обязывают ядро посылать при загрузке запрос DHCP)</comment>
</pre>

<p>
Кроме того, следует включить SquashFS, поскольку она требуется для большинства 
современных установочных дисков Gentoo. Поддержка SquashFS не включена в 
основное дерово исходного кода ядра. Для ее включения требуется наложить 
необходимые заплатки на дерево или установить <c>gentoo-sources</c>.
</p>

<pre caption="Настройка поддержки SquashFS в ядре">
File systems--->
   Miscellaneous filesystems --->
      [*] SquashFS 2.X - Squashed file system support
</pre>

<p>
После завершения компиляции создайте архив (tar.gz), содежащий модули ядра. 
Этот шаг необходим только тогда, когда версия вашего ядра не совпадает с 
версией образа ядра на установочном диске.
</p>

<pre caption="Создание архива с модулями ядра">
<comment>(создание tar.gz, содержащего все модули)</comment>
# <i>cd /</i>
# <i>tar -cf /tmp/modules-X.Y.Z.tar.gz /lib/modules/X.Y.Z/</i>
</pre>

<p>
В зависимости от механизма загрузки в вашей сети, вам потребуется 
проделать некоторые из этих шагов:
</p>

<pre caption="Создание загрузочного образа">
<comment>(создание образа для загрузки по сети ethernet)</comment>
# <i>emerge mknbi</i>
# <i>cd /boot</i>
# <i>mkelf-linux -params="root=/dev/ram0 init=/linuxrc ip=dhcp" kernel... initrd... > etherboot.img</i>

<comment>(cоздание образа OpenBoot / SPARC64 TFTP)</comment>
# <i>emerge sparc-utils</i>
# <i>cd /boot</i>
# <i>elftoaout kernel... -o kernel.aout</i>
# <i>piggyback64 kernel.aout System.map-... initrd-...</i>
# <i>mv kernel.aout openboot.img</i> <comment>(это - загрузочный образ)</comment>

<comment>(для PXE больше ничего не надо. kernel и initrd можно использовать как есть)</comment>
</pre>

<p>
И наконец, скопируйте ядро на свой TFTP сервер. Подробности зависят от 
архитектуры, и выходят за рамки данного рудоводства. Обратитесь к документации
от своей платформы.
</p>

</body>
</section>
<section>
<title>Настройка NFS</title>
<body>

<p>
Для создания общего ресурса сетевой файловой системы (NFS), содержащего 
установочный диск, используйте устройство loop, для монтирования ISO-образа, а
затем cкопируйте содержимое компакт-диска на общий ресурс. В качестве приятного 
дополнения, сценарии initrd genkernel распакуют все архивы tar.gz, находящиеся 
в каталоге <path>/nfs/livecd/add/</path>. Все что от вас потребуется &mdash; 
скопировать архив <c>modules-X.Y.Z.tar.gz</c> в каталог 
<path>/nfs/livecd/add/</path>.
</p>

<pre caption="Подготовка общего каталога NFS">
<comment>(предполагается, что /nfs/livecd - экспортированный общий каталог NFS)</comment>
# <i>mount /tmp/gentoo-livecd.iso /mnt/cdrom -o loop</i>
# <i>cp -p /mnt/cdrom /nfs/livecd</i>
# <i>umount /mnt/cdrom</i>

<comment>(копирование modules.tar.gz в /add)</comment>
# <i>mkdir /nfs/livecd/add</i>
# <i>cp /tmp/modules-X.Y.Z.tar.gz /nfs/livecd/add</i>
</pre>

</body>
</section>
<section>
<title>Настройка DHCP</title>
<body>

<p>
Образы сетевой загрузки запрашивают IP-адрес и корневой путь у сервера DHCP.
Оба параметра можно указывать раздельно для каждого узла, для идентификации
компьютера пользуясь MAC-адресом:
</p>

<pre caption="Пример настройки клиентского dhcpd.conf">
...

host netbootableMachine {
         hardware ethernet 11:22:33:44:55:66;
         fixed-address 192.168.1.10;
         option root-path "192.168.1.2:/nfs/livecd";
}
<comment># Здесь 192.168.1.2 - сервер NFS,
# а 192.168.1.10 будет IP-адресом компьютера, загружаемого по сети</comment>
...
</pre>

</body>
</section>
<section>
<title>Порядок сетевой загрузки</title>
<body>

<p>
Сам процесс сетевой загрузки очень зависит от платформы. Важно указать
параметры <c>ip=dhcp</c> и <c>init=/linuxrc</c> в командной строке ядра,
так как это запускает сетевой интерфейс и указывает сценариям initrd 
монтировать установочный диск по сети. Ниже приведены примеры сетевой 
загрузки для некоторых платформ:  
</p>

<pre caption="Инструкции по сетевой загрузке">
<comment># Etherboot - вставьте загрузочный диск etherboot и перезагрузитесь
# Командная строка ядра указана при создании образа</comment>

<comment># Sparc64 - нажмите Stop-A в загрузочном приглашении</comment>
ok boot net ip=dhcp init=/linuxrc

<comment># PXE - установите pxelinux (входит в syslinux),
затем создайте pxelinux.cfg/default, содержащий строки:</comment>

DEFAULT gentoo
TIMEOUT 40
PROMPT 1

LABEL gentoo
    KERNEL kernel-X.Y.Z
    APPEND initrd=initrd-X.Y.Z root=/dev/ram0 init=/linuxrc ip=dhcp
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Заключение</title>
<section>
<title>Автоматизировать или нет?</title>
<body>

<p>
Предназначение genkernel &mdash; дать (упрощенную) альтернативу подходу
к компиляции ядра, проверенному временем. Как всегда, решать, автоматизировать 
ли процесс компиляции ядра, только вам!
</p>

</body>
</section>
</chapter>

</guide>

<!-- *$Localization:
target-language: Russian
target-version: 1.4.3
target-date: 2006-03-23
source-cvs-revision: 1.26
translated-by: Mikhail Yarmish [mike.spacer@gmail.com]
edited-by: Alexey Chumakov [achumakov@gentoo.org]
-->
