<?xml version='1.0' encoding="UTF-8"?>
<!-- REV: 1.3 -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ru/Attic/2.6-koutput.xml,v 1.1 2004/08/28 19:23:10 sergey Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ru/2.6-koutput.xml">

<title>Вывод В Ядре 2.6</title>

<author title="Developer">
  <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Translator">
	<mail link="gclion@mail.ru">Cyrill V. Gorcunov</mail>
</author>

<abstract>
Это руководство предназначено для разработчиков и рассматривает детали изменений
вывода в новом ядре, применительно к Gentoo.
</abstract>

<license/>

<version>1.2</version>
<date>March 26, 2004</date>

<chapter>
<title>Введение</title>
<section>
<title>Новая Система</title>
<body>

<p>
В ядрах серии 2.6, помимо множества других усовершенствований, была разработана
новая инфраструктура "kbuild", предназначенная для создания высококонфигурируемой
и гибкой системы сборки. Детальное рассмотрение этого изменения не является
выходит за рамки данного документа. Важным является новый рекомендуемый метод
компилирования внешних модулей для ядра 2.6. Из файла 
<path>Documentation/kbuild/modules.txt</path>:
</p>

<pre caption="Documentation/kbuild/modules.txt (Перевод)">
Компиляция модули вне официального ядра
---------------------------------------
Часто модули разработываются вне официального ядра. Для соответствия изменениям
в системе сборки, наиболее переносимый путь компилирования модуля вне ядра -
это использование следующей команды:

make -C path/to/kernel/src SUBDIRS=$PWD modules
</pre>

<p>
Переопределяя переменную SUBDIRS, самая последняя версия инфраструктуры kbuild
так же может быть использована для компилирования внешних модулей. Само по себе
это <e>огромное</e> преимущество, но некоторые вещи становятся проблематичными.
</p>

</body>
</section>
<section>
<title>Проблема</title>
<body>

<p>
Даже имея сконфигурированное и скомпилированное ядро серии 2.6, размещенное
в <path>/usr/src/linux</path>, желание компилировать некоторые модули вне этих
исходников ядра не является необоснованным. Более того, можно было бы надеяться,
что компилирование можно проводить непривилегированному пользователю. Практика
показывает, что это <e>не так</e>. Попытка компиляции вызывает сбой, поскольку
программа <c>make</c> пытается обновить файлы в каталоге
<path>/usr/src/linux</path>, но непривилегированный пользователь не имеет
достаточных прав для записи в этот каталог.
</p>

<p>
Модули собираемые в системе портеджей, сталкиваются с точно такой же проблемой,
так как при попытке обновления файлов возникает нарушение правил sandbox,
и процесс сборки прерывается. Новые свойства kbuild также добавили проблем
тем, кто предпочитает придерживается безопасной практики использования
наименьших привилегий.
</p>

<p>
Поиск в базе данных ошибок Gentoo bugzilla найдет много ошибок, открытых
из-за этой самой проблемой, а во многих сообщениях на форумах вообще предложили
отключить sandbox как единственное решение данной проблемы. Действительно, с
текущим положением дел, казалось, что при компилировании модулей вне ядра версии
2.6, записи или обновления файлов в катале <path>/usr/src/linux</path> не
избежать.
</p>

</body>
</section>
<section>
<title>Борьба с Ситемой</title>
<body>

<p>
Для работы с новой системой kbuild сейчас существует (и уже было предложено)
много "хакерских" трюков, включая формирование ссылок во временной директории,
указывающих на элементы в <path>/usr/src/linux</path>. Но в конце концов, любой
путь приводит проблемам с системой безопасности, поскольку необходимо
взаимодействие с каталогом <path>/usr/src/linux</path>. Однако, отсутствие
относительно простого пути обновления враинат тоже неприемлемый. Фактически, новый
kmod.eclass может сделать каталог <path>/usr/src/linux</path> доступным для
записи портеджем автоматически, для ядер 2.6 старого стиля.
</p>

<p>
Так как отслеживание это затрагивает вопросы безопасности,
пользователям придется принять такой подход, когда они в первый раз столкнутся с
ним при использовании нового инструмента <b>config-kernel</b>. Пользователи
могут запустить config-kernel один раз, чтобы согласиться с таким подходом, а
затем будут просто получать предупреждения всякий раз, когда портедж получает
доступ к каталогу с исходниками ядра в течение компилирования модуля ядра.
</p>

<pre caption="Запуск config-kernel">
# <i>config-kernel --allow-writable yes</i>
</pre>

</body>
</section>
<section>
<title>Содержание Изменения</title>
<body>

<p>
Наиболее стройное решение пришло из осознания того, что борьба с новыми
свойствами kbuild привела бы к появлению все больших и больших проблем в
будущем. Фактически, новая возможность kbuild помещать сформированные
файлы в отдельную директорию доказала разрешимость проблемы. Ключевым
моментом является поддержание исходников ядра полностью в исходном состоянии
и допустимость сборки внешних модулей вне ядра, с формированием результатов
во временной директории.
</p>

<p>
Детальное описание взаимодействия этих элементов является достаточно сложным.
Надеемся, что следующие разделы разделят концепцию на более понятные части, так
что и разработчики, и пользователи, желающие расширить или просто использовать
эту новую систему, получат достаточно знаний для решения своих задач.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Вывод В Ядре</title>
<section>
<title>Переменные KBUILD_OUTPUT и O</title>
<body>

<p>
kbuild предоставляет две переменные для указания того, куда ядро должно
выводить свои файлы.
</p>

<table>
<tr>
  <th>Переменная</th>
  <th>Использование</th>
</tr>
<tr>
  <ti>KBUILD_OUTPUT</ti>
  <ti>
    Эта переменная может быть задана в головном <path>Makefile</path> ядра.
    Она может быть использована если вы хотите установить новый путь для 
    формируемых файлов, отличающийся от установленного в самих исходниках ядра.
  </ti>
</tr>
<tr>
  <ti>O</ti>
  <ti>
    Эта переменная используется в командной строке для переопределения
    любых других установок и указывает куда производить вывод для текущей
    команды. 
  </ti>
</tr>
</table>

<p>
Комбинация этих двух переменных является ключом к успешному использованию kbuild
и портеджа для установки модулей ядра.
</p>

</body>
</section>
<section>
<title>Изменения Процесса Установки Ядра</title>
<body>

<p>
Для использования особенностей вывода в ядре, новый
<path>kernel-2.eclass</path>, написанный <mail link="johnm@gentoo.org">John
Mylchreest</mail>, был пропатчен для добавления пути по умолчанию 
<c>KBUILD_OUTPUT</c> в головной файл Makefile ядра
(<path>/usr/src/linux/Makefile</path>). По умолчанию, этот путь
будет установлен на <path>/var/tmp/kernel-output/${KV}</path>, т.к. каталог
<path>/var/tmp</path> является удобным местом для расположения временных файлов
сохраняемых между перезагрузками.
</p>

<p>
Однажды установленная переменная приводит к тому, что все команды make,
вызванные для исходников ядра, формируют файлы в новой директории.
Со стороны пользователя не требуется никакой большей работы и изменение
(см. следующий раздел для описания исключений). После установки ядра,
пользователь, как и раньше, может сделать:
</p>

<pre caption="Конфигурирование ядра">
# <i>make menuconfig</i>
</pre>

<p>
и сможет конфигурировать и собирать свое ядро.
</p>

</body>
</section>
<section>
<title>Изменения Расположения Важных Файлов</title>
<body>

<p>
Поскольку все сгенерированные файлы теперь расположены в отдельной
директории, несколько ключевых файлов окажутся в неожиданных для
пользователя местах. В частности, файлы пользователя <path>.config</path>
и <path>bzImage</path>, больше не будут находится в <path>/usr/src/linux</path>
как это было ранее. <mail link="latexer@gentoo.org">Peter Johanson</mail>
написал новое <uri
link="http://www.gentoo.org/doc/en/2.6-koutput-user.xml">руководство по ядру
2.6</uri>, оно
ориентировано на конечных пользователей и обращает особое внимание на изменения
в системе kbuild и в частности, на изменение расположения указанных выше файлов.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Ebuild-скрипты Для Сборки Внешних Модулей</title>
<section>
<title>Основная Идея</title>
<body>

<p>
Теперь, когда ядра выводят свои файлы в другое место, следующим шагом
является написание ebuild-скрипта для новой системы. Ключевым является
обновление ebuild-скриптов таким образом, чтобы они искали некоторые
сформированные файлы и файлы заголовков в соответствующих местах, а также
использовали корректный <path>Makefile</path>.
</p>

<p>
Основная идея - пропатчить в пакетах файлы Makefile, чтобы при компилировании
вне ядра 2.6, они использовали переменную O для формирования результатов
во временной директории, в нашем sandbox окружении. Добавляя несколько
небольших кусочков кода мы получаем успешно устанавливаемый пакет для внешнего
модуля ядра.
</p>

<note>
Реальная функциональность и "полезность" модулей после их установки, не
рассматривается в данном документе. Это отдельная проблема, которую должны
решать разработчики драйверов.
</note>

<p>
В kmod.eclass были добавлены изменения позволяющие автору ebuild-скрипта
включать в скрипт некоторые переменные и программы, которые они могут
использовать для упрощения процесса правки на уровне ebuild-скрипта.
</p>

</body>
</section>
<section>
<title>Требования К Makfile</title>
<body>

<p>
Установка koutput добавляет некоторые требования к файлу Makefile в портеджах
модуля ядра. В частности, они должны будут использовать kbuild переменную O,
для записи скомпилированных файлов в некоторый подкаталог директории
определяемой переменной WORKDIR. Обычто это будет что-то похожее на ${S}/tmp.
При использовании этой системы, выходная директория должна содержать
файл ядра <path>.config</path>. Копирование этого файла может быть выполнено
либо в файле makefile, либо в ebuild-скрипте, но копирование в файле makefile
в явном виде может помочь сделать патч для upstream, что в дальнейшем избавит
Gentoo от неожходимости делать на уровне ebuild'a.
</p>

</body>
</section>
<section>
<title>Свойства kmod.eclass</title>
<body>

<p>
Сейчас все ebuild-скрипты модулей ядра должны использовать kmod.eclass. Далее
приведено краткое описание его применения. Функция kmod_src_unpack() производит
распаковку файлов, и устанавливает ряд чрезвычайно важных
переменных, которые могут использоваться где-то в другом месте. Две переменные
могут быть установлены ebuild-скриптом для описания того, как должна
работать функция kmod_src_unpack().
</p>

<table>
<tr>
  <th>Переменная</th>
  <th>Использование</th>
</tr>
<tr>
  <ti>KMOD_SOURCES</ti>
  <ti>
    Если установлена, эти файлы (обычно tarboll'ы) будут распакованы в WORKDIR.
    Иначе будет распакована ${A}. В качестве альтернативы, переменная может быть
    установлена на "none", если сам ebuild-скрипт должен провести распаковку.
  </ti>
</tr>
<tr>
  <ti>KMOD_KOUTPUT_PATCH</ti>
  <ti>
    Если обнаружено, что переменная KV_OUTPUT установлена и указывает не на
    <path>/usr/src/linux</path>, этот патч будет применен при помощи epatch в
    <path>${S}</path>. Конечно это может быть сделано и вручную, но так может
	быть проще, т.к. не надо вовсе будет опредлять функцию src_unpack().
  </ti>
</tr>
</table>

<p>
Функция kmod_src_unpack() выполняет очень тяжелую работу по вычислению того,
как должен быть обработан собираемый драйвер. В частности, она очень хорошо
обрабатывает два различных метода сборки 2.6. Если обнаружено использование
нового метода koutput, он не будет использоваться, а будет наложен патч из
KMOD_KOUTPUT_PATCH, если таковой существует. После вызова kmod_src_unpack(),
для скрипта становится доступным использование большого количества переменных.
</p>

<table>
<tr>
  <th>Переменная</th>
  <th>Назначение</th>
</tr>
<tr>
  <ti>KV_OUTPUT</ti>
  <ti>
    Полный путь где ядро формирует свои файлы при сборке. Для ядер 2.4 это
    всегда будет <path>/usr/src/linux</path>. Для 2.6 желателен другой путь
    (иначе произойдут сбои в процессе компиляции модуля).
  </ti>
</tr>
<tr>
  <ti>KV_OJB</ti>
  <ti>
    Расширение для модулей ядра для данной версии ядра. В зависимости от версии
    либо "o", либо "ko".
  </ti>
</tr>
<tr>
  <ti>KV_VERSION_FULL</ti>
  <ti>Полная версия ядра.</ti>
</tr>
<tr>
  <ti>KV_MAJOR</ti>
  <ti>Основной номер ядра.</ti>
</tr>
<tr>
  <ti>KV_MINOR</ti>
  <ti>Дополнительный номер ядра.</ti>
</tr>
<tr>
  <ti>KV_PATCH</ti>
  <ti>Номер патча ядра.</ti>
</tr>
<tr>
  <ti>KV_TYPE</ti>
  <ti>Тип ядра (т.е. "-gentoo-r1" в "2.4.23-gentoo-r1")</ti>
</tr>
</table>

<p>
Окончательная установка KV_OUTPUT зависит от найденного типа установки ядра и
метода, который будет использоваться при сборке. Далее приведена таблица
показывающая три различных конфигурации ядра, и на что будут установлены эти две
переменные после вызова kmod_src_unpack().

What KV_OUTPUT ends up being set to is ultimately the factor dictating which
kernel setup we've found, and which method of building will be used. Here's a
table showing the three different kernel configurations, and what these two
variables will be set to after kmod_src_unpack() is called.
</p>

<table>
<tr>
  <ti></ti>
  <th>KV_OUTPUT</th>
  <th>Принцип сборки модулей</th>
</tr>
<tr>
  <th>ядро 2.4</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Гибкий. Некоторые makefile файлы собираются вручную, другие для сборки будут
  использовать <b>make -C $(KV_BUILD)</b>. Любой подход прост в использовании с исходниками
  ядра 2.4.
  </ti>
</tr>
<tr>
  <th>ядро 2.6, обычный вывод</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Это традиционный метод. В этой ситуации kmod.eclass использует config-kernel
  для проверки возможности записи в каталог <path>/usr/src/linux</path>, если
  запись недоступна, он обеспечивает доступ к каталогу. Это запасной метод для
  использования во время перехода пользователей на новый метод сборки ядра.
  </ti>
</tr>
<tr>
  <th>ядро 2.6, альтернативный вывод</th>
  <ti>/some/other/path</ti>
  <ti>
  В этом случае для сборки ядра должен использоваться "koutput" метод.
  Обычно необходимо наложить некоторые патчи файлов makefile, после чего будут
  установлены обе переменные "sources" и "output". Далее модули собираются при
  помощи файлов makefile ядра, но продукты компиляции помещаются в некоторую
  локальну поддиректорию.
  </ti>
</tr>
</table>

<p>
kmod.eclass предосталяет вспомогательную функцию для определения метода
установки. <b>is_koutput()</b> позволяет ebuild-скриптам определить как следует
производить сборку ядра. Обычный ebuild-скрипт может использовать следующую
проверку:
</p>

<pre>
  if is_koutput
  then
    # Программа sed вносит исправления при использовании koutput
    # Sed to fix some things for koutput
    sed -i "s:foo:bar:" Makefile
  fi
</pre>

<p>
Большинство ebuild-скриптов будут нуждаться в проведении одного патча файлов
makefile, чтобы подключить вывод в другую директорию, а затем внести исправления
в эти файлы, если функция is_koutput() вернет true (т.е. используется
альтернативный вывод, см. выше). Пример ebuild-скрипта приведенный ниже, покажет
как это делается. Для тех ebuild-скриптов, которые нуждаются в ручной доработке
(например nvidia-kernel), здесь приведены несколько функций, которые могут
вызываться индивидуально, для более детального контроля над процессом сборки.
</p>

<table>
<tr>
  <th>Функция</th>
  <th>Использование</th>
</tr>
<tr>
  <ti>kmod_make_linux_writable()</ti>
  <ti>
    Эта функция служит для того, чтобы сделать доступным для
    записи каталог <path>/usr/src/linux</path>. Она должна быть вызвана вместо
    addwrite, т.к. она производит необходимые проверки для оценки необходимости
    такого доступа, и подтверждает, что пользователь дал разрешение для
    записи с помощью config-kernel.
  </ti>
</tr>
<tr>
  <ti>kmod_do_buildpatches()</ti>
  <ti>
    Эта функция может быть вызвана при необходимости наложения патча из
    KMOD_KOUTPUT_PATCH. Обычно эта функция будет вызвана, если по некоторым
    причинам необходимо вручную распаковать исходники.
  </ti>
</tr>
<tr>
  <ti>is_kernel()</ti>
  <ti>
    Эта функция принимает два аргумента - основной и дополнительный номер ядра.
    Эта функция рекомендуется для точной проверки номера используемого ядра.
  </ti>
</tr>
</table>

<p>
Кроме этих функциий, kmod.eclass экспортирует функции src_unpack,
src_compile и др., на которые можно ссылаться как kmod_src_unpack,
kmod_src_compile и т.д.
</p>

</body>
</section>
<section>
<title>Пример ebuild-скрипта и исправления файла Makefile</title>
<body>

<p>
Далее приводится реальный пример, как пакет драйвера hostap был исправлен для
создания полнофункционального ebuild-скрипта для ядер серий 2.4 и 2.6. Он
использует патч для файла <path>Makefile</path> верхнего уровня драйвера
hostap (этот файл достаточно обобщеный, что позволяет упростить последующие
ebuild-скрипты), так же как некоторые изменения для ebuild-скрипта, чтобы
рассчитать изменения месторасположения некоторых файлов.
</p>

<p>
Ниже некоторые отрывки из оригинального файла <path>Makefile</path> и некоторые
новые и модифицированные секции для проведения корректной сборки. Во-первых, нам
необходимо исправить строку которая подключала <path>.config</path> из
исходников ядра.
</p>

<note>
Переменная KERNEL_OUTPUT_PATH добавлена ранее при сборке для дополнения
оригинальной переменной KERNEL_PATH.
</note>

<pre caption="Оригинальная строка с подключением файла">
include $(KERNEL_PATH)/.config
</pre>

<p>
В исправленной версии приведенной ниже, переменная KERNEL_OUTPUT_PATH
устанавливается только в случае если она еще не задана (это делается для
обратной совместимости с версией 2.4), а затем подключается файл
<path>.config</path> из нового месторасположения.
</p>

<pre caption="Исправленная строка с подключением файла">
ifndef KERNEL_OUTPUT_PATH
KERNEL_OUTPUT_PATH=$(KERNEL_PATH)
endif

include $(KERNEL_OUTPUT_PATH)/.config
</pre>

<p>
Так как теперь мы имеем переменную KERNEL_OUTPUT_PATH в нашем распоряжении,
исправление объявления следующей переменной, которая содержит
<path>version.h</path>, становится очень простым. Оригинал:
</p>

<pre caption="Оригинальная VERFILE">
VERFILE := $(KERNEL_PATH)/include/linux/version.h
</pre>

<p>
А теперь исправленная версия:
</p>

<pre caption="Исправленная VERFILE">
VERFILE := $(KERNEL_OUTPUT_PATH)/include/linux/version.h
</pre>

<p>
В заключение, наш патч исправляет строки которые содержат вызовы системы kbuild
2.6 для включения использования переменной O, т.е. устанавливая вывод в каталог
<path>tmp/</path> текущей директории.
</p>

<warn>
kbuild ожидает найти полноценный <path>.config</path> файл в директории заданной
<c>O=foo</c>. Т.о. либо ebuild-скрипт, либо файл makefile должен быть исправлен, чтобы произвести копирование файла <path>.config</path> из ${KV_OUTPUT}
(устанавливается в kmod.eclass) в директорию, куда будет производится вывод.
</warn>

<p>
Вот оригинал:
</p>

<pre caption="Оригинальная директория для вывода">
$(MAKE) -C $(KERNEL_PATH) SUBDIRS=$(PWD)/driver/modules \
  MODVERDIR=$(PWD)/driver/modules modules
</pre>

<p>
А здесь исправленная версия:
</p>

<pre caption="Исправленная директория для вывода">
mkdir -p $(PWD)/tmp
-cp $(KERNEL_OUTPUT_PATH)/.config $(PWD)/tmp
$(MAKE) -C $(KERNEL_PATH) O=$(PWD)/tmp \
  SUBDIRS=$(PWD)/driver/modules \
  MODVERDIR=$(PWD)/driver/modules  modules
</pre>

<p>
Изменения в ebuild-скрипте относительно просты. Некоторые вещи особенно просто
сделать при помощи kmod.eclass. Далее приведены наиболее важные секции функции
src_unpack() и установка некоторых переменных в ebuild-скрипте:
</p>

<pre caption="функция src_unpack()">
KMOD_SOURCES="${P}.tar.gz"
KMOD_KOUTPUT_PATCH="${PN}-koutput.diff.gz"

src_unpack() {
    # Распаковка и установка некоторых переменных
    kmod_src_unpack

    ## распаковка исходников pcmcia-cs при необходимости
    pcmcia_src_unpack

    epatch "${FILESDIR}/${P}.firmware.diff.bz2"
    
    # При обнаружении использования koutput вызов программы sed
    # для корректировки путей к файлам
    if is_koutput
    then
        sed -i -e \
      "s:^# KERNEL_OUTPUT_PATH=.*:KERNEL_OUTPUT_PATH=${KV_OUTPUT}:" \
      ${S}/Makefile
    fi
}
</pre>

<p>
Обратите внимание на использование двух переменных: <c>KMOD_SOURCES</c> и
<c>KMOD_KOUTPUT_PATCH</c>. Если используется koutput, эти переменные могут
устанавливаться для описания исходников которые должны быть распакованы при
помощи kmod_src_unpack(), а так же для описания файла, который должен быть
пропатчен. Патч из <c>KMOD_KOUTPUT_PATCH</c> не будет наложен, если
обнаружится, что ядро 2.6 до сих пор (в старой манере) использует вывод в
каталог <path>/usr/src/linux</path>:
</p>

<pre caption="функция src_compile()">
src_compile() {
    # Конфигурирование исходников pcmcia-cs при необходимости.
    pcmcia_configure

    ##-- "Сборка драйвера hostap для ядра версии: ${KV}"
    einfo "Building hostap-driver for kernel version: ${KV}"
    case ${KV_MINOR} in
        [34])
            local mydrivers

            use pcmcia &amp;&amp; mydrivers="${mydrivers} pccard"
            use hostap-nopci || mydrivers="${mydrivers} pci"
            use hostap-noplx || mydrivers="${mydrivers} plx"

            ##-- "Сборка следующих драйверов: ${mydrivers}"
            einfo "Building the following drivers: ${mydrivers}"
            emake ${mydrivers} || die "make failed"
            ;;
        [56])
            unset ARCH
            emake all || die "make failed"
            ;;
        *)
            ##-- "Неподдерживаемая версия ядра: ${KV}"
            eerror "Unsupported kernel version: ${KV}"
      die
      ;;
    esac
}
</pre>

<warn>
Для ядер 2.6, переменная <c>ARCH</c> должна быть сброшена (т.е. не установлена).
Новые файлы Makefile используют переменную <c>ARCH</c> для определения того, что
и как компоновать и используют различный другой синтаксис для i386 и т.д.
</warn>

<p>
Функция ebuild-скрипта src_install() не будет рассмотрена, т.к. она просто
устанавливает все модули в каталог <path>/lib/modules/${KV}/</path>. Отметим,
что в ядре 2.6 она отвечает за изменение расширения скомпилированных модулей
с <path>.o</path> на <path>.ko</path>. В соответствии с версией ядра,
kmod.eclass устанавливает переменную <c>KV_OBJ</c> либо на <path>o</path>, либо
на <path>ko</path>.
</p>

</body>
</section>
</chapter>
</guide>
