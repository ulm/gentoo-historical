<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- English doc rev. 1.13 -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<sections>
<section>
<title>Runlevel</title>
<subsection>
<title>Booting Sistem Anda</title>
<body>

<p>
Ketika Anda melakukan boot pada sistem Anda, Anda akan melihat banyak teks yang 
bergulung. Jika Anda memperhatikan dengan benar, Anda akan mengetahui bahwa
teks ini adalah teks yang sama setiap kali Anda melakukan boot ulang sistem
Anda. Urutan dalam semua kegiatan-kegiatan ini disebut <e>urutan boot</e>
dan (lebih kurang) didefenisikan secara statis.
</p>

<p>
Pertama-tama, boot loader Anda akan memuat imej kernel yang telah didefenisikan
oleh Anda pada konfigurasi boot loader ke dalam memori, setelah itu boot loader
memerintahkan CPU untuk menjalankan kernel. Ketika kernel telah dimuat dan
berjalan, boot loader menginisialisasi semua struktur dan tugas-tugas khusus kernel
dan memulai proses <c>init</c>.
</p>

<p>
Proses ini kemudian akan memastikan bahwa semua sistem file (yang didefenisikan
dalam <path>/etc/fstab</path>) dimuat dan siap digunakan. Kemudian beberapa
skrip yang berada pada <path>/etc/init.d</path> akan dijalankan, yang akan
memulai servis yang Anda perlukan untuk menghasilkan suatu sistem yang sukses
diboot.
</p>

<p>
Terakhir, setelah semua skrip dijalankan, <c>init</c> mengaktifkan
terminal-terminal (dalam banyak kasus ini berupa konsol virtual yang
tersembunyi di dalam <c>Alt-F1</c>, <c>Alt-F2</c>, dan lain-lain) dengan
melampirkan proses khusus yang disebut <c>agetty</c> padanya. Proses ini akan
memastikan bahwa Anda dapat login melalui terminal-terminal ini dengan
menjalankan <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Skrip Init</title>
<body>

<p>
Sekarang <c>init</c> tidak hanya menjalankan skrip pada <path>/etc/init.d</path>
secara acak. Bahkan tidak menjalankan semua skrip yang berada di
<path>/etc/init.d</path>, melainkan hanya skrip yang diperintahkan untuk 
dijalankan saja. Skrip yang dijalankan ditentukan dengan melihat ke dalam
<path>/etc/runlevels</path>.
</p>

<p>
Pertama-tama, <c>init</c> menjalankan semua skrip dari <path>/etc/init.d</path>
yang mempunyai link simbolis di <path>/etc/runlevels/boot</path>. Biasanya,
skrip dijalankan sesuai dengan urutan abjad, tetapi beberapa skrip mempunyai
dependensi di dalamnya, memberitahukan kepada sistem bahwa
skrip yang lain harus dijalankan terlebih dahulu sebelum menjalankan mereka.
</p>

<p>
Ketika semua skrip yang direferensi oleh <path>/etc/runlevels/boot</path>
telah dijalankan, <c>init</c> melanjutkannya dengan menjalankan skrip yang 
memiliki link simbolis di <path>/etc/runlevels/default</path>.
Lagi, init akan menggunakan urutan abjad untuk menentukan skrip mana yang akan
dijalankan lebih dulu, kecuali jika suatu skrip mempunyai dependensi di
dalamnya, yang menyebabkan perubahan urutan agar skrip-skrip dijalankan dengan
urutan yang benar.
</p>

</body>
</subsection>
<subsection>
<title>Bagaimana Init Bekerja</title>
<body>

<p>
Tentu saja <c>init</c> tidak memutuskan semuanya sendirian.
Ia memerlukan file konfigurasi yang menentukan aksi apa yang perlu
diambil. File konfigurasi ini adalah <path>/etc/inittab</path>.
</p>

<p>
Jika Anda mengingat urutan boot yang telah kami jelaskan kepada Anda,
Anda akan mengingat bahwa aksi <c>init</c> yang pertama adalah 
melakukan mount semua filesystem. Aksi ini didefenisikan pada baris
berikut ini dalam <path>/etc/inittab</path>:
</p>

<pre caption="Baris Inisialisasi Sistem pada /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Baris ini memerintahkan <c>init</c> untuk menjalankan <c>/sbin/rc sysinit</c>
untuk menginisialisasi sistem. Skrip <path>/sbin/rc</path> menangani proses
inisialisasi, jadi Anda dapat menganggap bahwa <c>init</c> tidaklah
bekerja banyak -- ia hanya mendelegasikan tugas untuk inisialisasi sistem
kepada proses yang lain.
</p>

<p>
Kedua, <c>init</c> menjalankan semua skrip yang mempunyai link simbolis
di <path>/etc/runlevels/boot</path>. Hal ini didefenisikan pada baris
berikut ini:
</p>

<pre caption="Inisialisasi sistem, lanjutannya">
rc::bootwait:/sbin/rc boot
</pre>

<p>
Kemudian skrip <c>rc</c> akan melakukan tugas-tugas yang diperlukan. Catat
bahwa opsi yang diberikan kepada <c>rc</c> (<e>boot</e>) sama dengan
subdirektori dari <path>/etc/runlevels</path> yang dipergunakan.
</p>

<p>
Sekarang <c>init</c> akan memeriksa file konfigurasinya untuk melihat
<e>runlevel</e> apa yang perlu dijalankan. Untuk memutuskan hal ini, maka
baris berikut ini dari <path>/etc/inittab</path> akan dibaca:
</p>

<pre caption="Baris init default">
id:3:initdefault:
</pre>

<p>
Dalam hal ini (dimana mayoritas pengguna Gentoo akan menggunakannya), id 
<e>runlevel</e> adalah 3. Dengan menggunakan informasi ini, <c>init</c>
akan memeriksa apa saja yang harus dijalankan untuk memulai 
<e>runlevel 3</e>:
</p>

<pre caption="Defenisi runlevel">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
Baris yang mendefenisikan level 3, sekali lagi, menggunakan skrip <c>rc</c>
untuk memulai servis (dengan argumen <e>default</e>). Dan juga perlu dicatat
bahwa argumen <c>rc</c> sama dengan subdirektori dari
<path>/etc/runlevels</path>.
</p>

<p>
Ketika <c>rc</c> selesai dijalankan, <c>init</c> memutuskan konsol virtual apa
yang perlu diaktifkan dan perintah apa yang perlu dijalankan pada setiap konsol:
</p>

<pre caption="Defenisi konsol virtual">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>

</body>
</subsection>
<subsection>
<title>Apakah runlevel itu?</title>
<body>

<p>
Anda telah melihat bahwa <c>init</c> menggunakan skema penomoran untuk
menentukan <e>runlevel</e> apa yang harus diaktifkan. Sebuah <e>runlevel</e>
adalah sebuah kondisi dimana sistem Anda berjalan dan berisi koleksi skrip
(skrip runlevel atau <e>initscripts</e>) yang harus dijalankan ketika 
Anda memasuki atau meninggalkan suatu runlevel.
</p>

<p>
Di dalam Gentoo, terdapat tujuh runlevel yang didefenisikan, tiga runlevel
internal, dan empat runlevel yang didefenisikan user. Runlevel internal
terdiri dari <e>sysinit</e>, <e>shutdown</e> dan <e>reboot</e> dan melakukan
hal-hal yang sama dengan nama mereka: inisialisasi sistem, mematikan sistem
dan reboot sistem.
</p>

<p>
Runlevel yang didefenisikan user berada pada subdirektori 
<path>/etc/runlevels</path>: <path>boot</path>,
<path>default</path>, <path>nonetwork</path> dan <path>single</path>. 
Runlevel <path>boot</path> memulai semua servis yang penting untuk sistem
yang akan digunakan oleh runlevel-runlevel lainnya. Sisa tiga runlevel dibedakan
dari servis yang dimulai: <path>default</path> digunakan untuk penggunaan
sehari-hari, <path>nonetwork</path> digunakan bila koneksi jaringan tidak
diperlukan, dan <path>single</path> digunakan ketika Anda harus
memperbaiki sistem.
</p>

</body>
</subsection>
<subsection>
<title>Bekerja dengan Skrip Init</title>
<body>

<p>
Skrip yang dimulai oleh proses <c>rc</c> disebut <e>skrip init</e>.
Setiap skrip pada <path>/etc/init.d</path> dapat dieksekusi dengan argumen
<e>start</e>, <e>stop</e>, <e>restart</e>, <e>pause</e>, <e>zap</e>,
<e>status</e>, <e>ineed</e>, <e>iuse</e>, <e>needsme</e>, <e>usesme</e>
atau <e>broken</e>.
</p>

<p>
Untuk memulai, menghentikan atau memulai kembali suatu servis (dan semua
servis yang bergantung padanya), <c>start</c>, <c>stop</c> dan <c>restart</c>
harus digunakan:
</p>

<pre caption="Memulai Postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Hanya servis yang <e>memerlukan</e> servis yang diberikan yang akan dihentikan
atau dimulai ulang. Servis lain yang bergantung padanya (yang <e>menggunakan</e>
servis ini tetapi tidak memerlukannya) tidak akan diutak-atik.
</note>

<p>
Jika Anda ingin menghentikan suatu servis, tetapi bukan servis yang bergantung
padanya, Anda dapat menggunakan argumen <c>pause</c>:
</p>

<pre caption="Menghentikan Postfix tetapi membiarkan servis yang bergantung
padanya tetap berjalan">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Jika Anda ingin melihat status dari suatu servis (started, stopped, paused,
...) Anda dapat menggunakan argumen <c>status</c>:
</p>

<pre caption="Informasi status dari postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Jika informasi status memberitahukan Anda bahwa suatu servis sedang berjalan,
tetapi Anda tahu bahwa itu tidak berjalan, maka Anda dapat mereset informasi
status ke "stopped" dengan argumen <c>zap</c>:
</p>

<pre caption="Reset informasi status untuk postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Untuk memeriksa dependensi dari servis tersebut, Anda dapat 
menggunakan <c>iuse</c> atau <c>ineed</c>. Dengan <c>ineed</c> Anda dapat
melihat servis yang benar-benar diperlukan oleh suatu servis agar dapat
berfungsi dengan benar. Pada sisi lain, <c>iuse</c> menunjukkan
servis yang dapat digunakan oleh servis itu, tetapi tidak benar-benar diperlukan
untuk berfungsi dengan benar.
</p>

<pre caption="Meminta suatu daftar yang berisi semua servis dimana Postfix 
bergantung">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
Demikian juga, Anda dapat meminta servis-servis apa yang memerlukan servis
tersebut (<c>needsme</c>) atau yang dapat menggunakannya (<c>usesme</c>):
</p>

<pre caption="Meminta suatu daftar yang berisi semua servis yang membutuhkan
 Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Terakhir, Anda dapat meminta dependensi apa yang dibutuhkan oleh servis
tersebut tetapi tidak tersedia:
</p>

<pre caption="Meminta suatu daftar yang berisi dependensi yang tidak tersedia
untuk Postfix">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Bekerja dengan rc-update</title>
<subsection>
<title>Apakah rc-update itu?</title>
<body>

<p>
Sistem init Gentoo menggunakan suatu pohon dependensi untuk memutuskan
servis-servis apa yang harus dijalankan terlebih dulu. Karena ini merupakan
tugas yang membosankan, maka kami tidak ingin user kami melakukannya secara
manual, kami telah membuat sebuah utilitas yang memudahkan administrasi dari
runlevel dan skrip init.
</p>

<p>
Dengan <c>rc-update</c> Anda dapat menambahkan dan menghapus skrip init
dari suatu runlevel. Utilitas <c>rc-update</c> kemudian akan secara otomatis
memerintahkan skrip <c>depscan.sh</c> untuk membangun ulang pohon 
dependensi.
</p>

</body>
</subsection>
<subsection>
<title>Menambahkan dan Menghapus Servis</title>
<body>

<p>
Anda telah menambahkan skrip init pada runlevel "default" selama instalasi
Gentoo. Pada saat itu, mungkin Anda sama sekali tidak mempunyai bayangan
"default" itu untuk apa, tetapi sekarang Anda seharusnya sudah tahu. Skrip
<c>rc-update</c> membutuhkan argumen ke dua yang mendefenisikan aksi:
<e>add</e>, <e>del</e> atau <e>show</e>.
</p>

<p>
Untuk menambahkan atau menghapus sebuah skrip init, berikan argumen <c>add</c>
atau <c>del</c> kepada <c>rc-update</c>, diikuti dengan skrip init dan
runlevel. Sebagai contoh:
</p>

<pre caption="Menghapus Postfix dari runlevel default">
# <i>rc-update del postfix default</i>
</pre>

<p>
Perintah <c>rc-update show</c>  akan menunjukkan semua skrip init yang ada
dan daftar runlevel tempat mereka dijalankan:
</p>

<pre caption="Menampilkan informasi skrip init">
# <i>rc-update show</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Mengkonfigurasi Servis</title>
<subsection>
<title>Mengapa Konfigurasi Tambahan Diperlukan?</title>
<body>

<p>
Skrip init dapat menjadi begitu kompleks. Jadi akan menjadi sangat tidak
menarik bagi user untuk mengedit skrip init secara langsung, karena akan 
membuatnya menjadi rentan kesalahan. Bagaimanapun juga untuk mengkonfigurasi
servis tersebut tetap penting. Contohnya, Anda mungkin ingin memberikan
opsi lebih untuk servis itu sendiri.
</p>

<p>
Alasan ke dua untuk memiliki konfigurasi ini di luar skrip init adalah dapat
melakukan update skrip init tanpa takut kalau perubahan konfigurasi Anda 
dibatalkan.
</p>

</body>
</subsection>
<subsection>
<title>Direktori /etc/conf.d</title>
<body>

<p>
Gentoo memberikan jalan mudah untuk melakukan konfigurasi suatu servis:
setiap skrip init yang dapat dikonfigurasi, mempunyai suatu file di dalam
<path>/etc/conf.d</path>. Contohnya, skrip init apache2 (disebut 
<path>/etc/init.d/apache2</path>) mempunyai suatu file konfigurasi yang disebut
<path>/etc/conf.d/apache2</path>, yang dapat berisi opsi yang ingin Anda berikan
kepada server Apache 2 ketika memulai servis tersebut: 
</p>

<pre caption="Variable yang didefenisikan pada /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP4"
</pre>

<p>
File konfigurasi tersebut berisi variabel dan hanya variabel (seperti 
<path>/etc/make.conf</path>), sehingga konfigurasi servis menjadi sangat mudah. 
Dan Juga, kita dapat memberikan lebih banyak informasi mengenai variabel
(sebagai komentar).
</p>

</body>
</subsection>
</section>
<section>
<title>Menulis Skrip Init</title>
<subsection>
<title>Haruskah Saya Melakukannya?</title>
<body>

<p>
Tidak. Menulis suatu skrip init biasanya tidak diperlukan, karena Gentoo
telah menyediakan skrip init siap pakai untuk semua servis yang disediakan.
Tetapi, Anda mungkin telah menginstalasi suatu servis tanpa menggunakan
Portage, sehingga Anda harus membuat sendiri skrip initnya.
</p>

<p>
Jangan menggunakan skrip init yang disediakan oleh servis tersebut bila
tidak disebutkan secara pasti ditulis untuk Gentoo: skrip init Gentoo
tidak kompatibel dengan skrip init yang digunakan oleh distribusi lain!
</p>

</body>
</subsection>
<subsection>
<title>Layout</title>
<body>

<p>
Layout dasar dari sebuah skrip init ditunjukkan di bawah ini.
</p>

<pre caption="Layout dasar dari sebuah skrip init">
#!/sbin/runscript

depend() {
  <comment>(Informasi dependensi)</comment>
}

start() {
  <comment>(Perintah penting untuk memulai servis)</comment>
}

stop() {
  <comment>(Perintah penting untuk menghentikan servis)</comment>
}

restart() {
  <comment>(Perintah penting untuk memulai kembali servis)</comment>
}
</pre>

<p>
Semua skrip init <e>mengharuskan</e> fungsi <c>start()</c> didefenisikan.
Semua seksi yang lain adalah opsional.
</p>

</body>
</subsection>
<subsection>
<title>Dependensi</title>
<body>

<p>
Terdapat dua dependensi yang dapat Anda defenisi: <c>use</c> dan <c>need</c>.
Seperti yang telah kami sebutkan sebelumnya, dependensi <c>need</c> adalah
lebih ketat dari pada dependensi <c>use</c>. Mengikuti tipe dependensi ini,
Anda memasukkan servis yang dibutuhkan oleh Anda, atau dependensi
<e>virtual</e>.
</p>

<p>
Dependensi <e>virtual</e> adalah suatu dependensi yang diberikan oleh suatu
servis, tetapi tidak melulu cuma bisa diberikan oleh servis itu saja. 
Skrip Anda dapat bergantung pada logger sistem, tetapi terdapat banyak logger
sistem yang tersedia (metalogd, syslog-ng, sysklogd, ...). Karena Anda tidak
dapat <c>menjalankan</c> semuanya (tidak ada sistem yang menginstalasi dan 
menjalankan semua logger sistem ini) kami memastikan bahwa semua servis ini
<c>menyediakan</c> sebuah dependensi virtual.
</p>

<p>
Marilah kita melihat informasi dependensi untuk servis postfix.
</p>

<pre caption="Informasi dependensi untuk Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Seperti yang Anda lihat, servis postfix:
</p>

<ul>
  <li>
    membutuhkan dependensi <c>net</c> (virtual) (yang disediakan oleh, misalnya,
    <path>/etc/init.d/net.eth0</path>)
  </li>
  <li>
    menggunakan dependensi <c>logger</c> (virtual) (yang disediakan oleh,
    misalnya, <path>/etc/init.d/syslog-ng</path>)
  </li>
  <li>
    menggunakan dependensi <c>dns</c> (virtual) (yang disediakan oleh, misalnya,
     <path>/etc/init.d/named</path>)
  </li>
  <li>
    menyediakan dependensi <c>mta</c> (virtual) (yang umum untuk semua
    server mail)
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Mengatur Urutan</title>
<body>

<p>
Dalam beberapa kasus, Anda mungkin tidak membutuhkan suatu servis, tetapi
menginginkan servis Anda dimulai <c>sebelum</c> (atau <c>sesudah</c>)
menjalankan servis yang lain <e>jika</e> tersedia dalam sistem (catatan
kondisi - ini sudah bukan merupakan dependensi) <e>dan</e> berjalan dalam
runlevel yang sama (catatan kondisi - hanya servis yang berada dalam 
runlevel yang sama yang terlibat). Anda dapat memberikan informasi ini
menggunakan setting <c>before</c> atau <c>after</c>.
</p>

<p>
Sebagai suatu contoh, kita akan melihat setting dari servis Portmap:
</p>

<pre caption="Fungsi depend() pada servis Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Anda dapat juga menggunakan glob "*" untuk menangkap semua servis yang
berada pada runlevel yang sama, meskipun hal ini tidak dianjurkan.
</p>

<pre caption="Menjalankan skrip init sebagai skrip pertama pada runlevel">
depend() {
  before *
}
</pre>

</body>
</subsection>
<subsection>
<title>Fungsi Standar</title>
<body>

<p>
Setelah fungsi <c>depend()</c>, Anda juga perlu mendefenisikan fungsi
<c>start()</c>. Fungsi ini berisi semua perintah yang diperlukan untuk
menginisialisasi servis Anda. Dianjurkan untuk menggunakan fungsi
<c>ebegin</c> dan <c>eend</c> untuk menginformasikan kepada user apa
saja yang terjadi:
</p>

<pre caption="Contoh fungsi start()">
start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}
</pre>

<p>
Jika Anda memerlukan contoh lebih lanjut mengenai fungsi <c>start()</c>,
silahkan membaca kode sumber dari skrip init yang tersedia di direktori 
<path>/etc/init.d</path>. Untuk <c>start-stop-daemon</c>, tersedia halaman 
manual yang sangat bagus jika Anda memerlukan informasi lebih lanjut:
</p>

<pre caption="Mendapatkan halaman manual untuk start-stop-daemon">
# <i>man start-stop-daemon</i>
</pre>

<p>
Fungsi lain yang dapat Anda defenisikan adalah: <c>stop()</c> dan 
<c>restart()</c>. Anda tidak diijinkan untuk mendefenisikan fungsi-fungsi ini!
Sistem init kita cukup cerdas untuk mengisi fungsi-fungsi ini secara otomatis
jika Anda menggunakan <c>start-stop-daemon</c>.
</p>

</body>
</subsection>
<subsection>
<title>Menambahkan Opsi Kustomisasi</title>
<body>

<p>
Jika Anda menginginkan skrip init Anda untuk mendukung opsi lebih lanjut daripada
opsi-opsi yang telah kami sediakan, Anda harus menambahkan opsi tersebut pada
variabel <c>opts</c>, dan membuat suatu fungsi dengan nama yang sama dengan
opsi tersebut. Contohnya, untuk mendukung sebuah opsi bernama
<c>restartdelay</c>:
</p>

<pre caption="Mendukung opsi restartdelay">
opts="${opts} restartdelay"

restartdelay() {
  stop()
  sleep 3    <comment># Tunggu 3 detik sebelum menjalankan lagi</comment>
  start()
}
</pre>

</body>
</subsection>
<subsection>
<title>Variabel Konfigurasi servis</title>
<body>

<p>
Anda tidak perlu melakukan apa-apa untuk menyediakan sebuah file
konfigurasi di <path>/etc/conf.d</path>: jika skrip init Anda dijalankan,
file-file berikut ini secara otomatis dijadikan sumber (variabel-variabel
tersedia untuk digunakan):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;skrip init Anda&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Juga, jika skrip init Anda menyediakan dependensi virtual (seperti <c>net</c>),
file yang diasosiasikan dengan dependensi itu (seperti 
<path>/etc/conf.d/net</path>) akan dijadikan sumber juga.
</p>

</body>
</subsection>
</section>
<section>
<title>Mengubah Tingkah Laku Runlevel</title>
<subsection>
<title>Siapa yang akan diuntungkan dari ini?</title>
<body>

<p>
Banyak pengguna laptop mengetahui situasi ini: di rumah Anda perlu memulai
<c>net.eth0</c> sementara di perjalanan, Anda tidak ingin memulai
<c>net.eth0</c> (karena tidak ada network yang tersedia). Dengan Gentoo,
Anda dapat mengubah tingkah laku runlevel sesuai keinginan anda.
</p>

<p>
Contoh, Anda dapat membuat suatu runlevel "default" ke dua yang dapat anda
boot yang memiliki skrip init yang berbeda di dalamnya. Lalu, Anda dapat memilih
pada saat boot, runlevel default mana yang ingin Anda gunakan.
</p>

</body>
</subsection>
<subsection>
<title>Menggunakan SOFTLEVEL</title>
<body>

<p>
Pertama-tama, buatlah direktori runlevel untuk runlevel "default" Anda yang ke dua.
Sebagai contoh kami akan membuat runlevel <path>offline</path>:
</p>

<pre caption="Membuat direktori runlevel">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Tambahkan skrip init yang diperlukan pada runlevel yang baru dibuat ini.
Contoh, jika Anda ingin memiliki duplikat yang sama persis dengan runlevel
<c>default</c> Anda sekarang, tetapi tanpa <c>net.eth0</c>:
</p>

<pre caption="Menambahkan skrip init yang diperlukan">
# <i>ls /etc/runlevels/default</i>
acpid  domainname  local  net.eth0  netmount  postfix  syslog-ng  vixie-cron
# <i>rc-update add acpid offline</i>
# <i>rc-update add domainname offline</i>
# <i>rc-update add local offline</i>
# <i>rc-update add syslog-ng offline</i>
# <i>rc-update add vixie-cron offline</i>
</pre>

<p>
Sekarang edit konfigurasi bootloader Anda dan tambahkan suatu entri
baru untuk runlevel <c>offline</c>. Misalnya, di file
<path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Menambahkan sebuah entri untuk runlevel offline">
title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Voila, semuanya sudah diset sekarang. Jika Anda melakukan boot sistem Anda 
dan memilih entri yang baru ditambahkan pada waktu boot, runlevel 
<c>offline</c> akan digunakan sebagai ganti <c>default</c>.
</p>

</body>
</subsection>
<subsection>
<title>Menggunakan BOOTLEVEL</title>
<body>

<p>
Menggunakan <c>bootlevel</c> adalah sejalan dengan <c>softlevel</c>.
Perbedaannya di sini hanyalah Anda mendefenisikan runlevel "boot" yang ke dua
dan bukan runlevel "default" yang ke dua.
</p>

</body>
</subsection>
</section>
</sections>
