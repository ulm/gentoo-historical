<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>

<version>7.0</version>
<date>2006-08-30</date>

<section id="sgi">
<title>Komputer Silicon Graphics -- Setup arcload</title>
<subsection>
<title>Yang mana?</title>
<body>

<p>
Pada komputer SGI, kami menyediakan bootloader <c>arcload</c>. Pada rilis-rilis
sebelumnya, kami juga menyediakan <c>arcboot</c>, tetapi bootloader ini secara
resmi telah dianggap usang dan diganti dengan <c>arcload</c>.
</p>

<!-- Slated for possible removal
<table>
<tr>
  <th> </th>
  <th>arcboot</th>
</tr>
<tr>
  <th>+</th>
  <ti>
    It can load off EXT2 and EXT3 partitions, so no need to store them in the
    volume header
  </ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    It doesn't work on Octane/Octane2, Origin 200/2000 or Indigo2 Impact
    (R10000)
  </ti>
</tr>
</table>

<table>
<tr>
  <th> </th>
  <th>arcload</th>
</tr>
<tr>
  <th>+</th>
  <ti>
    It boots ALL Linux-compatible SGI systems
  </ti>
</tr>
<tr>
  <th>-</th>
  <ti>
    Currently, It cannot read EXT2/EXT3 partitions, and so needs the kernels
    and config file to be placed in the volume header
  </ti>
</tr>
</table>
-->

<note>
Nama file header volum SGI terbatas pada 8 karakter, dan satu volum tidak boleh
diisi dengan lebih dari 16 file.
</note>

</body>
</subsection>

<!--<subsection>
<title>Installing arcboot</title>
<body>

<warn>
<c>arcboot</c> is deprecated and will be removed in future.
</warn>

<p>
Previously in this guide, we showed you how to make a kernel, then copy it to
the volume header using <c>dvhtool</c>. There were two main flaws with this
system:
</p>

<ul>
  <li>This is not supported on all SGI systems</li>
  <li>It requires a significantly larger volume header</li>
</ul>

<p>
In order to boot the machine, a bootloader, <c>arcboot</c> was developed for
this purpose. Instead of putting the kernel directly into the volume header, we
leave it in <path>/boot</path> (which resides on a EXT2/3 partition), and tell
<c>arcboot</c> (which sits in the volume header in place of the kernel) where
to find it. So our first step, is to emerge some tools that we'll use later...
</p>

<pre caption="Installing the required tools">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
That should have installed two tools, <c>arcboot</c> which sits in the volume
header and loads kernels for us, and <c>dvhtool</c> which helps us put
<c>arcboot</c> into the volume header.
</p>

<p>
The <c>arcboot</c> binary lurks in <path>/usr/lib/arcboot</path>. The name of
the binary depends on the machine it's compiled for.
</p>

<ul>
  <li>
    <c>arcboot.ip22</c>: The binary for Indy, Indigo2 (R4k) and Challenge S
    systems
  </li>
  <li>
    <c>arcboot.ip32</c>: The binary for O2 systems
  </li>
</ul>

<pre caption="Installing arcboot into the volume header">
# <i>dvhtool - -unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
We then verify the presence of the file in the volume header.
</p>

<pre caption="Checking if arcboot made it okay">
# <i>dvhtool - -print-volume-directory</i>
- - - - - directory entries - - - - -
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
You'll notice that in the example above, there are two old kernels sitting
around, <path>linux</path> and <path>newlinux</path>. This is a hangover from
before we started using <c>arcboot</c>. Their presence doesn't matter - - just
so long as <c>arcboot</c> is present, everything is fine.
</note>

<p>
If you've ever set up the Linux Loader (<c>lilo</c>) before, you'll find that
<c>arcboot</c> employs a similar syntax in its configuration file. Bear in mind
though; <c>arcboot</c> expects to find its configuration file existing on an
EXT2/3 partition as <path>/etc/arcboot.conf</path>. The easiest way around this
is to make sure <path>/boot</path> is an EXT2/3 partition and that there's a
file called <path>arcboot.conf</path> inside the <path>/boot/etc</path>
directory. An example config can be found in
<path>/etc/arcboot.conf.sample</path>.
</p>

<note>
Adjust the paths accordingly if you don't have a separate <path>/boot</path>
partition.
</note>

<pre caption="Putting arcboot.conf in its place">
<comment>(Create the /boot/etc directory)</comment>
# <i>mkdir /boot/etc</i>

<comment>(Put our configuration into the target directory)</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(Create a symlink back to /etc)</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(... and a symlink in /boot pointing to itself)</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
You can then edit <path>/etc/arcboot.conf</path> to your own preference. One
possible layout, is to set up two kernel images: <path>new</path>, a freshly
built image that may or may not work; and <path>working</path>, a proven
trustworthy kernel image. The <path>arcboot.conf</path> for that setup looks a
bit like this.
</p>

<pre caption="Example arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
<comment># known working version</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># fresh "untested" version</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Once that is set up, there's then just some little tweaks that you need to do
within the SGI PROM to make this magic work. This is covered in, not the next
section (that's for Cobalt servers) but the following section <uri
link="#reboot">Rebooting the System</uri>.
</p>

</body>
</subsection>
-->
<subsection>
<title>Instalasi arcload</title>
<body>

<p>
Pada awalnya <c>arcload</c> diciptakan untuk komputer yang membutuhkan kernel
64-bit yang tidak dapat menggunakan <c>arcboot</c> (yang tidak dapat
dikompilasi sebagai binari 64-bit dengan mudah). <c>arcload</c> juga mengatasi
masalah yang timbul ketika me-load kernel langsung dari header volum. Jadi,
sekarang anda telah mengetahui apa sebenarnya bootloader ini, dan kita dapat
melanjutkan ke proses instalasi:
</p>

<pre caption="Instalasi arcload dan dvhtool">
# <i>emerge arcload dvhtool</i>
</pre>

<p>
Setelah selesai, anda perlu menemukan binari <c>arcload</c> di
<path>/usr/lib/arcload</path>. Sekarang, terdapat dua file:
</p>

<ul>
  <li>
    <c>sashARCS</c>: Binari 32-bit untuk sistem Indy, Indigo2 (R4k), Challenge
    S dan O2
  </li>
  <li>
    <c>sash64</c>: Binari 64-bit untuk sistem Octane/Octane2, Origin 200/2000
    dan Indigo2 Impact
  </li>
</ul>

<p>
Gunakan <c>dvhtool</c> untuk menginstal binari yang diperlukan oleh sistem
anda di header volum:
</p>

<pre caption="Instalasi arcload di header volum">
<comment>(Untuk pengguna Indy/Indigo2/Challenge S/O2)</comment>
# <i>dvhtool --unix-to-vh /usr/lib/arcload/sashARCS sashARCS</i>

<comment>(Untuk pengguna Indigo2 Impact/Octane/Octane2/Origin 200/Origin 2000)</comment>
# <i>dvhtool --unix-to-vh /usr/lib/arcload/sash64 sash64</i>
</pre>

<note>
Anda tidak harus menggunakan nama <c>sashARCS</c> atau <c>sash64</c>, kecuali
anda sedang menginstal ke header volum CD bootable. Untuk boot biasa dari
harddisk, anda boleh menamakannya sesuka anda.
</note>

<p>
Sekarang gunakan <c>dvhtool</c> untuk memeriksa apakah semuanya telah
berada di header volum.
</p>

<pre caption="Memeriksa keberadaan arcload di header volum">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "sash64", start 4, bytes 55859
#
</pre>

<p>
Sekarang, file <c>arc.cf</c> sudah memiliki sintaks seperti sintaks C. Untuk
penjelasan tentang cara mengkonfigurasinya, bacalah <uri
link="http://www.linux-mips.org/wiki/Arcload">halaman arcload di wiki
Linux/MIPS</uri>. Singkat kata, anda perlu menentukan beberapa opsi yang anda
aktif/nonaktifkan saat boot dengan variabel <c>OSLoadFilename</c>.
</p>

<pre caption="Contoh arc.cf">
<comment># Konfigurasi ARCLoad</comment>

<comment># Beberapa aturan default...</comment>
append  "root=/dev/sda3";
append  "ro";
append  "console=ttyS0,9600";

<comment># Definisi utama kita. ip28 beloh anda ganti.</comment>
ip28 {
        <comment># Definisi untuk kernel "working/bagus" </comment>
        <comment># Pilih dengan mengeset OSLoadFilename="ip28(working)"</comment>
        working {
                description     "SGI Indigo2 Impact R10000\n\r";
                image system    "/working";
        }

        <comment># Definisi untuk kernel "new/baru"</comment>
        <comment># Pilih dengan mengeset OSLoadFilename="ip28(new)"</comment>
        new {
                description     "SGI Indigo2 Impact R10000 - Testing Kernel\n\r";
                image system    "/new";
        }

        <comment># Kernel untuk debug</comment>
        <comment># Pilih dengan mengeset OSLoadFilename="ip28(working,debug)"</comment>
        <comment># atau OSLoadFilename="ip28(new,debug)"</comment>
        debug {
                description     "Debug console";
                append          "init=/bin/bash";
        }
}
</pre>

<p>
Ini kemudian diletakkan di header volum dengan <c>sash64</c> (atau
<c>sashARCS</c>) seperti ditunjukkan di bawah ini. Kernel-kernel juga akan
diletakkan di header volum.
</p>

<note>
Dengan <c>arcload</c> 0.5, anda dapat me-load file-file ini dari partisi EXT3,
tanpa harus me-load-nya ke header volum. Jika anda menggunakan rilis yang lebih
baru, anda boleh melangkahi penyalinan file ke header volum, dan meletakkannya
di partisi <c>/boot</c> anda.
</note>

<pre caption="Meletakkan arc.cf dan kernel di header volum">
# <i>dvhtool --unix-to-vh arc.cf arc.cf</i>
# <i>dvhtool --unix-to-vh /usr/src/linux/vmlinux new</i>
</pre>

<p>
Jika semuanya sudah beres, yang perlu kita lakukan adalah mengatur beberapa
opsi di PROM. Bacalah seksi <uri link="#reboot">Reboot Sistem</uri>.
</p>

</body>
</subsection>

</section>

<section id="cobalt">
<title>Cobalt MicroServers -- Setup CoLo</title>
<subsection>
<title>Instalasi CoLo</title>
<body>

<p>
Pada server Cobalt, komputer-komputer ini memiliki firmware yang kurang bagus
di chip-nya. BOOTROM Cobalt sangat primitif, jika dibandingkan dengan PROM SGI,
dan memiliki beberapa keterbatasan.
</p>

<ul>
  <li>
    Ada batas ukuran 675kB (perkiraan) di kernel. Ukuran kernel Linux 2.4 saat
    ini menjadikannya hampir tidak mungkin untuk membuat kernel seukuran ini.
    Jangan tanya tentang kernel 2.6.
  </li>
  <li>
    Kernel 64-bit tidak didukung oleh firmware asli (walaupun saat ini kernel
    64-bit masih sedang terus dicoba di komputer Cobalt)
  </li>
  <li>
    Shell paling bagusnya adalah basic
  </li>
</ul>

<p>
Untuk mengatasi keterbatasan ini, telah dikembangkan sebuah firmware
alternatif, yang dinamakan <uri
link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> (Cobalt Loader).
Ini adalah imej BOOTROM yang dapat di-<e>flash</e> ke chip di dalam server
Cobalt, atau di-load dari firmware yang sudah ada.
</p>

<note>
Panduan ini akan mengajak anda men-setup CoLo agar dapat di-load oleh firmware
asli. Ini satu-satunya cara yang paling aman dan dianjurkan untuk men-setup
CoLo.
</note>

<warn>
Anda boleh, jika ingin, mem-<e>flash</e> CoLo ke server, dan mengganti seluruh
firmware asli -- namun, anda tidak akan dibantu jika terjadi kesalahan. Jika ada
yang tidak beres, anda perlu mencabut BOOTROM dan mem-program-ulang sendiri
dengan firmware asli. Jika anda tidak yakin bagaimana cara melakukannya, maka
<b>JANGAN</b> <e>flash</e> komputer anda. Kami tidak akan bertanggung jawab
dengan apapun yang terjadi jika anda mengabaikan anjuran ini.
</warn>

<p>
Baiklah, setelah semua peringatan, sekarang kita akan menginstal CoLo. Pertama,
mulailah dengan meng-emerge paketnya.
</p>

<pre caption="Emerge colo">
# <i>emerge colo</i>
</pre>

<p>
Setelah terinstal, (penulis harap anda membaca semua pesan yang ditampilkan :-),
anda harus mencari dua file di direktori <path>/usr/lib/colo</path>, yaitu
<path>colo-chain.elf</path>: "kernel" untuk di-load oleh firmware asli, dan
<path>colo-rom-image.bin</path>: sebuah imej ROM yang akan di-<e>flash</e> ke
BOOTROM. Kita mulai dengan me-mount <path>/boot</path> dan meletakkan salinan
<path>colo-chain.elf</path> yang telah dipadatkan di <path>/boot</path>, tempat
sistem akan mencarinya.
</p>

<pre caption="Meletakkan CoLo di tempatnya">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Konfigurasi CoLo</title>

<body>

<p>
Sekarang, ketika sistem pertama kali boot, sistem akan me-load CoLo yang akan
menampilkan sebuah menu di belakang LCD. Pilihan pertama (dan dianggap default
setelah kira-kira 5 detik) adalah boot ke harddisk. Kemudian sistem akan
mencoba me-mount partisi Linux yang pertama kali ditemukan, lalu menjalankan
skrip <path>default.colo</path>. Sintaksnya telah didokumentasikan dengan
lengkap di  dokumentasi CoLo (intiplah
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path> -- X.YY adalah versi
yang terinstal), dan sangat sederhana.
</p>

<note>
Hanya tips: ketika menginstal kernel, penulis biasanya menciptakan dua imej
kernel, <path>kernel.gz.working</path> -- kernel yang telah diketahui bagus,
dan <path>kernel.gz.new</path> -- kernel yang baru saja dikompilasi.
Anda dapat menggunakan symlink untuk menunjuk ke kernel "baru" dan "bagus",
atau mengganti nama imej kernel.
</note>

<pre caption="default.colo dasar">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo tidak akan me-load skrip yang tidak dimulai dengan baris <c>#:CoLo:#</c>.
Bayangkan saja seperti <c>#!/bin/sh</c> pada skrip shell.
</note>

<p>
Dimungkinkan juga untuk membuat pertanyaan, seperti kernel &amp; konfigurasi
mana yang ingin anda boot, dengan sebuat timout default. Konfigurasi ini
benar-benar melaksanakan tugas ini, menanyakan kernel mana yang akan digunakan,
lalu mengeksekusi imej yang dipilih. <path>vmlinux.gz.new</path> dan
<path>vmlinux.gz.working</path> bisa berupa imej kernel asli, atau hanya berupa
symlinks yang menunjuk ke imej kernel di dalam disk. Argumen <c>50</c>
menentukan kernel mana yang harus dipilih ("Working") setelah 50/10 detik.
</p>

<pre caption="Konfigurasi berbasis menu">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
select "Which Kernel?" 50 Working New

goto {menu-option}
var image-name vmlinux.gz.working
goto 3f
@var image-name vmlinux.gz.working
goto 2f
@var image-name vmlinux.gz.new

@lcd "Loading Linux" {image-name}
load /{image-name}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Untuk lebih jelasnya, bacalah dokumentasi di
<path>/usr/share/doc/colo-VERSION</path>.
</p>

</body>

</subsection>
</section>

<section>
<title>Setup Konsol Serial</title>

<subsection>
<body>

<p>
Baiklah, sampai sekarang instalasi Linux akan boot dengan sukses, tetapi
dengan anggapan anda akan masuk/login melalui terminal fisik. Pada komputer
Cobalt, hal ini dianggap tidak baik -- tidak ada yang namanya terminal fisik.
</p>

<note>
Bagi anda yang memiliki chipset video bagus dapat melangkahi seksi ini.
</note>

<p>
Pertama-tama, bukalah file <path>/etc/inittab</path> dengan sebuah editor.
Jauh di bagian bawah file, anda akan melihat baris-baris seperti ini:
</p>

<pre caption="Konfigurasi inittab">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># Apa yang harus dilakukan saat "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Pertama, buanglah tanda komentar di baris <c>c0</c>. Secara default, ini telah
diatur untuk menggunakan <e>baud rate</e> terminal sebesar 9600 bps.
Pada server Cobalt, anda mungkin perlu menggantinya ke 115200 agar sama dengan
<e>baud rate</e> yang ditentukan oleh BOOTROM. Berikut ini tampilan dari seksi
ini pada komputer penulis. Pada komputer tanpa monitor, (mis. server Cobalt),
penulis juga menganjurkan anda untuk meberikan tanda komentar di baris terminal
lokal (<c>c1</c> sampai ke <c>c6</c>) karena akan mengacak-acak ketika tidak
dapat membuka <path>/dev/ttyX</path>.
</p>

<pre caption="Cotoh dari bagian inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- Baris-baris ini tidak berguna jika tidak ada monitor</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Sekarang, terakhir... kita harus memberitahukan sistem, bahwa port serial lokal
dapat dipercaya sebagai terminal aman. File yang perlu kita sentuh adalah file
<path>/etc/securetty</path>. File ini berisi daftar terminal yang dipercaya oleh
sistem. Kita hanya perlu menambahkan dua baris, mengijinkan baris serial untuk
digunakan oleh login <c>root</c>.
</p>

<pre caption="Mengijinkan login root dari konsol serial">
<comment>(/dev/ttyS0 -- nama tradisional untuk port serial pertama)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Akhir-akhir ini, Linux juga menyebutnya sebagai /dev/tts/0 -- jadi
kita tambahkan juga)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Reboot Sistem</title>
<subsection>
<body>

<p>
Keluarlah dari lingkungan chroot dan unmount semua partisi. Lalu ketikkan sebuah
perintah ajaib yang telah anda tunggu-tunggu: <c>reboot</c>.
</p>

<pre caption="Keluar dari chroot, unmounting semua partisi dan reboot">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Pengguna Cobalt:</e> Sisa panduan ini berisi cara mengatur PROM SGI agar
mem-boot <!--<c>arcboot</c>/--><c>arcload</c> dari disk dan me-load Linux.
Ini tidak sesuai dengan pengaturan server Cobalt. Sebenarnya, semua tugas anda
sudah selesai -- tidak ada lagi konfigurasi yang diperlukan untuk boot pertama,
anda dapat langsung lanjut ke bagian: <uri
link="?part=1&amp;chap=11">Menyelesaikan Instalasi Gentoo Anda</uri>
</note>

</body>
</subsection>
</section>
<section>
<title>Tweak PROM SGI</title>
<subsection>
<title>Mengatur setting standar PROM</title>
<body>

<p>
Sekarang setelah anda menginstal bootloader, anda siap me-reboot komputer.
</p>

<pre caption="Reboot">
<comment>(Keluar dari lingkungan chroot)</comment>
# <i>exit</i>

<comment>(Unmount semua partisi)</comment>
# <i>umount /gentoo/boot</i>
# <i>umount /gentoo</i>

<comment>(Reboot)</comment>
# <i>reboot</i>
</pre>

<p>
Setelah anda reboot, pergilah ke <e>System Maintenance Menu</e> lalu pilih
<e>Enter Command Monitor</e> (<c>5</c>) seperti yang anda lakukan ketika
mem-boot komputer dari jaringan.
</p>

<pre caption="Mengatur PROM Agar Boot ke Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor. Type "exit" to return to the menu.

<comment>(Set beberapa opsi untuk arcload)</comment>

<comment>(Menyediakan lokasi header volum)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Langsung boot ke Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Atur timezone)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Gunakan konsol serial - pengguna kartu grafis harus mengganti "d1" (satu) dengan "g")</comment>
&gt;&gt; <i>setenv console d1</i>

<comment>(Mengeset baud rate konsol serial. Ini hanya opsional, 9600 adalah          )
(setting default, tapi anda dapat menggunakan sampai 38400 jika diinginkan.)</comment>
&gt;&gt; <i>setenv dbaud 9600</i>
</pre>

<p>
Sekarang setting selanjutnya bergantung pada bagaimana anda mem-boot sistem.
</p>

</body>
</subsection>

<subsection>
<title>Setting untuk boot langsung ke header volume</title>
<body>

<p>
Bagian ini dijelaskan hanya sebagai pelengkap. Kami menganjurkan anda untuk
mengikuti petunjuk instalasi <c>arcload</c>.
</p>

<note>
Setting ini hanya berlaku untuk Indy, Indigo2 (R4k) dan Challenge S.
</note>

<pre caption="Setting PROM untuk boot langsung dari header volume">
<comment>(&lt;root device&gt; = Partisi root Gentoo, mis. /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>

<comment>(Untuk melihat kernel yang tersedia, ketik "ls")</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>

<comment>(Tentukan parameter kernel yang ingin anda gunakan)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>
</pre>

<p>
Jika anda ingin mencoba kernel baru tanpa merusak parameter kernel, anda dapat
menggunakan perintah PROM <c>boot -f</c>:
</p>

<pre caption="Boot tanpa mengganti variabel lingkungan">
<comment>(Boot sebuah kernel, "new", dengan opsi-opsi tambahan)</comment>
# <i>boot -f new root=/dev/sda3 ro</i>
</pre>

</body>
</subsection>

<subsection>
<title>Setting untuk arcload</title>
<body>

<p>
<c>arcload</c> menggunakan opsi <c>OSLoadFilename</c> untuk menentukan opsi
apa yang akan di-set dari <path>arc.cf</path>. Pada dasarnya file konfigurasi
<c>arcload</c> hanyalah sebuah skrip, dengan blok bagian atas menentukan imej
boot untuk beberapa sistem, dan di dalamnya ada beberapa setting opsional.
Jadi, setting <c>OSLoadFilename=mysys(serial)</c> akan memberikan setting
untuk clok <c>mysys</c>, lalu kemudian mengeset opsi-opsi selanjutnya di
<c>serial</c>.
</p>

<p>
Pada contoh file di atas, kita telah menentukan satu blok sistem, <c>ip28</c>
yang memiliki opsi-opsi <c>working</c>, <c>new</c> dan <c>debug</c>. Kita juga
akan menentukan variabel PROM kita dengan cara yang sama:
</p>

<pre caption="Setting PROM untuk menggunakan arcload">
<comment>(Pilih arcload sebagai bootloader:- sash64 atau sashARCS)</comment>
&gt;&gt; setenv OSLoader sash64

<comment>(Gunakan imej kernel "working/bagus", ditentukan di seksi "ip28" dari arc.cf)</comment>
&gt;&gt; setenv OSLoadFilename ip28(working)
</pre>

</body>
</subsection>

<!-- Slated for removal
<subsection>
<title>Settings for arcboot</title>
<body>

<p>
<c>arcboot</c> loads its configuration file and kernels from your
<path>/boot</path> partition, which needs to be formatted either EXT2 or EXT3.
Thus <c>OSLoadPartition</c> needs to point to that partition. <c>OSLoader</c>
should point to the <c>arcboot</c> binary in the volume header, and
<c>OSLoadFilename</c> is the image name being used.
</p>

<pre caption="PROM settings for using arcboot">
<comment>(Read configuration and kernels from SCSI ID# 1, partition 0 - - sda1)</comment>
&gt;&gt; <i>setenv OSLoadPartition scsi(0)disk(1)rdisk(0)partition(0)</i>

<comment>(Use arcboot as the bootloader)</comment>
&gt;&gt; <i>setenv OSLoader arcboot</i>

<comment>(Which boot image in arcboot.conf to load)</comment>
&gt;&gt; <i>setenv OSLoadFilename working</i>
</pre>

<p>
When testing kernels via <c>arcboot</c> you can specify an alternate image like
so (where <c>new</c> is the alternate image):
</p>

<pre caption="Specifying an alternate image">
# <i>boot new</i>
</pre>

</body>
</subsection> -->

<subsection>
<title>Selesai</title>
<body>

<p>
Sekarang anda sudah siap untuk menikmati Gentoo! Boot instalasi Gentoo anda
dan lanjutkan dengan <uri link="?part=1&amp;chap=11">Menyelesaikan Instalasi
Gentoo Anda</uri>.
</p>

</body>
</subsection>
</section>
</sections>
