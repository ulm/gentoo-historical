<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide disclaimer="obsolete" lang="id">
<title>Panduan Manajemen Power</title>

<author title="Author">
  <mail link="earthwings@gentoo.org">Dennis Nienh√ºser</mail>
</author>
<author title="Editor">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Translator">
  <mail link="kucrut.dz@gmail.com">Dzikri Aziz</mail>
</author>

<abstract>
Manajemen Power merupakan kunci untuk memperpanjang ketahanan baterai pada
komputer jinjing seperti laptop. Panduan ini berisi cara pengaturannya.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.39</version>
<date>2008-01-31</date>

<chapter>
<title>Pendahuluan</title>
<section>
<body>

<p>
Kapasitas dan umur baterai laptop mengalami banyak peningkatan pada beberapa
tahun terakhir ini. Namun begitu, prosesor baru juga memerlukan energi yang
lebih besar dibandingkan dengan prosesor lama dan setiap generasi laptop baru
memperkenalkan perangkat baru yang haus energi. Itu sebabnya Manajemen Power
sangatlah penting. Memperpanjang ketahanan baterai tidak selalu berarti membeli
baterai baru yang lebih bagus, tetapi bisa didapatkan dengan cara menerapkan
kebijakan Manajemen Power yang bagus.
</p>

</body>
</section>
<section>
<title>Tinjauan Singkat</title>
<body>

<p>
Perlu dicatat bahwa panduan ini menjelaskan Manajemen Power untuk
<e>laptop</e>, walaupun beberapa bagian mungkin dapat diterapkan pada
<e>server</e>, bagian-bagian lainnya tidak dapat anda terapkan di server dan
dapat menyebabkan kerusakan. Jangan terapkan apapun yang dijelaskan pada
panduan ini di server kecuali anda benar-benar mengerti kegunaannya.
</p>

<p>
Karena panduan ini semakin bertambah panjang, berikut ini adalah tinjauan
singkat agar anda lebih mudah membacanya.
</p>

<p>
Bab <uri link="#doc_chap2">Kebutuhan Awal</uri> berbicara tentang beberapa
kebutuhan yang harus tersedia. Ini termasuk pengaturan BIOS, konfigurasi kernel
dan beberapa penyederhanaan pada <e>userland</e>. Tiga bab berikut ini berfokus
pada perangkat-perangkat yang paling banyak menyerap energi - prosesor,
<e>display</e> dan harddisk. Masing-masing dapat dikonfigurasi secara terpisah.
<uri link="#doc_chap3">Manajemen Power CPU</uri> berisi cara merubah frekuensi
prosesor untuk menghemat energi tanpa harus mengalami penurunan performa yang
berarti. Beberapa trik untuk menghemat kerja harddisk dijelaskan di <uri
link="#doc_chap5">Manajemen Power Disk</uri> (juga menurunkan tingkat
kebisingan sebagai manfaat tambahannya). Beberapa catatan tentang kartu grafis,
Wireless dan USB mengakhiri bagian perangkat di <uri
link="#doc_chap6">Manajemen Power Untuk Perangkat Lain</uri>, sedangkan bab
lainnya diperuntukkan bagi <uri link="#doc_chap7">status sleep</uri> (yang
masih eksperimental). Terakhir, <uri link="#doc_chap8">Pemecahan Masalah</uri>
menjelaskan beberapa masalah yang sering dihadapi.
</p>

</body>
</section>
<section>
<title>Penggunaan Power Dari Setiap Komponen</title>
<body>

<figure link="/images/energy-budget.png" short="Komponen apa yang paling banyak
menyerap energi dan seberapa banyak?" caption="Penggunaan energi dari setiap
komponen"/>

<p>
Hampir setiap komponen dapat beroperasi pada berbagai tingkatan - di antaranya
<e>off, sleep</e> dan <e>active</e> - dan menggunakan jumlah energi yang
berbeda pula. Sebagian besar energi dihabiskan oleh display LCD, CPU, chipset
dan harddisk. Ada laptop yang dapat diatur untuk menghemat energi baterai dari
BIOS tanpa konfigurasi tambahan pada sistem operasi, tetapi pengaturan Power
Manajemen pada tingkat sistem operasi dapat menghemat energi lebih banyak lagi.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Kebutuhan Awal</title>
<section>
<body>

<p>
Sebelum kita berbicara lebih jauh tentang cara mengemat energi pada setiap
perangkat, kita perlu memastikan agar semua kebutuhan awal telah terpenuhi.
Setelah mengatur BIOS, beberapa opsi kernel harus diaktifkan - seperti ACPI,
<e>sleep states</e> dan <e>CPU frequency scaling</e>. Karena penghematan energi
biasanya akan mengakibatkan penuruanan performa atau meningkatkan
<e>latency</e>, maka kita hanya akan mengaktifkan penghematan ketika baterai
digunakan. Untuk itu kita memerlukan runlevel <e>battery</e>.
</p>

</body>
</section>
<section>
<title>BIOS</title>
<body>

<p>
Pertama anda perlu memeriksa pengaturan Power Management di BIOS. Cara terbaik
adalah dengan menggabungkan pengaturan di BIOS dengan pengaturan di sistem
operasi, tetapi untuk sekarang kita lebih baik menonaktifkan beberapa opsi di
BIOS agar tidak menghalangi kebijakan yang kita tetapkan di sistem operasi.
Jangan lupa periksa kembali pengaturan BIOS setelah selesai melakukan
konfigurasi.
</p>

</body>
</section>
<section>
<title>Pengaturan Flag USE</title>
<body>

<p>
Periksa kembali apakah flag USE <c>acpi</c> telah digunakan di
<path>/etc/make.conf</path>. Flag USE lain yang mungkin ingin anda gunakan
adalah <c>apm</c>, <c>lm_sensors</c>, <c>nforce2</c>, <c>nvidia</c>, dan
<c>pmu</c>. Bacalah <path>/usr/portage/profiles/use*.desc</path> untuk
mengetahui kegunaan masing-masing flag. Jika anda lupa mengaktifkan salah satu
flag yang ingin anda gunakan, anda dapat mengkompilasi ulang paket yang
terpengaruh dengan menambahakan opsi <c>--newuse</c> pada perintah
<c>emerge</c>, bacalah <c>man emerge</c>.
</p>

</body>
</section>
<section>
<title>Konfigurasi Kernel</title>
<body>

<p>
Dukungan ACPI (Advanced Configuration and Power Interface) di kernel masih
dalam masa pengembangan. Anda perlu menggunakan kernel terbaru untuk
mendapatkan dukungan terbaik.
</p>

<p>
Terdapat tiga source kernel di Portage. Penulis menganjurkan anda untuk
menggunakan <c>gentoo-sources</c> atau <c>tuxonice-sources</c>. Kernel kedua
berisi banyak tambalan untuk TuxOnIce, bacalah bab tentang <uri
link="#doc_chap7">sleep states</uri> untuk perinciannya. Ketika
mengkonfigurasi kernel, aktifkan paling tidak opsi-opsi berikut ini:
</p>

<pre caption="Konfigurasi kernel minimal untuk Manajemen Power (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservative' cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Putuskan sendiri apakah anda ingin mengkatifkan <e>Software Suspend</e>, dan
<e>Sleep States</e> (baca penjelasan di bawah). Jika anda menggunakan laptop
ASUS, Medion, IBM Thinkpad atau Toshiba, aktifkan opsi-opsi yang sesuai.
</p>

<p>
Kernel harus mengetahui cara apa yang akan digunakan untuk merubah frekuensi
prosesor. Karena setiap jenis CPU memiliki antarmuka yang berbeda, anda harus
memilih driver yang cocok untuk prosesor anda. Berhati-hatilah di sini -
mengaktifkan <c>Intel Pentium 4 clock modulation</c> pada sistem dengan Pentium
M, misalnya, dapat memberikan hasil yang aneh. Bacalah dokumentasi kernel jika
anda tidak yakin harus memilih yang mana.
</p>

<p>
Kompilasi kernel anda, pastikan agar modul-modul yang diperlukan telah diatur
untuk dimuat ketika boot lalu boot kernel baru anda. Selanjutnya jalankan
<c>emerge sys-power/acpid</c> untuk menginstal daemon acpi. Daemon ini akan
memberikan informasi kepada anda tentang <e>event</e> yang terjadi seperti
perpindahan sumber energi dari AC ke baterai atau ketika laptop ditutup.
Pastikan agar semua modul yang diperlukan telah dimuat jika anda tidak
mengkompilasinya di dalam kernel lalu jalankan <c>acpid</c> dengan
<c>/etc/init.d/acpid start</c>. Jalankan <c>rc-update add acpid default</c>
agar daemon ini dijalankan ketika boot. Sebentar lagi anda akan mengetahui cara
menggunakannya.
</p>

<pre caption="Instalasi acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Menciptakan Runlevel "battery"</title>
<body>

<p>
Kebijakan default adalah mengaktifkan Manajemen Power hanya ketika diperlukan -
yaitu ketika baterai digunakan. Agar perpindahan sumber energi dari AC ke
baterai dan sebaliknya lebih mudah, ciptakan runlevel <c>battery</c> yang
berisi semua yang menjalankan dan menghentikan Manajemen Power.
</p>

<note>
Anda boleh saja melangkahi bagian ini jika anda tidak setuju dengan ide
pembuatan runlevel baru. Namun begitu, anda akan menghadapi kesulitan ketika
mengikuti panduan pada bagian-bagian selanjutnya jika anda melangkahinya.
Bagian berikut ini menganggap anda menciptakan runlevel <c>battery</c>.
</note>

<pre caption="Menciptakan runlevel battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Selesai. Sekarang runlevel <c>battery</c> baru anda berisi semua yang ada di
dalam runlevel <c>default</c>, namun belum ada otomatisasi untuk perpindahan.
Kita akan membuatnya sekarang.
</p>

</body>
</section>
<section>
<title>Bereaksi pada Event ACPI</title>
<body>

<p>
Event ACPI umum adalah menutup laptop, mengganti sumber energi atau menekan
tombol power. Event yang penting adalah mengganti sumber energi yang harus
menyebabkan perpindahan runlevel. Skrip pendek berikut ini akan menanganinya.
</p>

<p>
Pertama anda memerlukan sebuah skrip yang dapat melakukan perpindahan runlevel
dari <c>default</c> ke <c>battery</c> atau sebaliknya, tergantung sumber
energi. Skrip ini menggunakan perintah <c>on_ac_power</c> dari
<c>sys-power/powermgmt-base</c> - jangan lupa menginstal paket ini dulu.
</p>

<pre caption="Instalasi powermgt-base">
# <i>emerge powermgmt-base</i>
</pre>

<p>
Sekarang anda dapat mengetahui sumber energi yang digunakan dengan menjalankan
<c>on_ac_power &amp;&amp; echo AC available || echo Running on batteries</c> di
shell. Skrip berikut ini bertanggung jawab untuk mengganti runlevel. Simpan
skrip ini sebagai <path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>.
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># AWAL konfigurasi </comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># AKHIR konfigurasi </comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
    logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
    exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
    logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
    exit 1
fi

if on_ac_power
then
    if [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
    then
        logger "Switching to ${RUNLEVEL_AC} runlevel"
         /sbin/rc ${RUNLEVEL_AC}
    fi
elif [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
    logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
    /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
Jangan lupa jalankan <c>chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</c>
agar skrip tersebut mendapatkan bit <e>executable</e>. Satu lagi yang perlu
anda lakukan adalah memanggil skrip tersebut ketika terjadi perubahan sumber
energi. Hal ini dapat dilakukan dengan menangkap event ACPI dengan bantuan dari
<c>acpid</c>. Pertama anda perlu mengetahui event apa yang dihasilkan ketika
perubahan sumber energi terjadi. Event-event ini dinamakan <c>ac_adapter</c>
dan <c>battery</c> pada kebanyakan laptop, tetapi bisa jadi berbeda pada laptop
anda.
</p>

<pre caption="Menangkap event ACPI pada perubahan sumber energi">
# <i>tail -f /var/log/messages | grep "received event"</i>
</pre>

<p>
Jalankan perintah di atas lalu cabut kabel power. Anda akan melihat pesan-pesan
seperti berikut.
</p>

<pre caption="Contoh pesan tentang pergantian sumber energi">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
Bagian yang perlu diperhatikan adalah kalimat yang diberi tanda kutip setelah
<c>received event</c>. Kalimat ini akan dicocokkan dengan baris event pada file
yang akan anda tulis. Anda tidak perlu khawatir jika sistem anda menghasilkan
banyak event atau menghasilkan event yang sama. Selama ada event baru yang
dihasilkan, pergantian runlevel dapat dilakukan.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Gantikan "ac_adapter" di bawah ini dengan event pada laptop anda</comment>
<comment># Sebagai contoh, ac_adapter.* sama dengan ac_adapter AC 00000080 00000000</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Gantikan "battery" di bawah ini dengan event pada laptop anda</comment>
<comment># Sebagai contoh, battery.* sama dengan battery BAT0 00000080 00000001</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Terakhir, acpid harus di-restart agar perubahan diterapkan.
</p>

<pre caption="Menyelesaikan konfigurasi penggantian runlevel dengan acpid">
# <i>/etc/init.d/acpid restart</i>
</pre>

<p>
Cobalah: Tancapkan lalu cabut kabel power AC dan cari pesan "Switching to AC
mode" atau "Switching to battery mode" di syslog. Bacalah bagian <uri
link="#doc_chap8">Pemecahan Masalah</uri> jika skrip tadi tidak dapat
mendeteksi sumber energi dengan benar.
</p>

<p>
Karena sifat alami dari mekanisme event, laptop anda akan boot ke runlevel
<c>default</c> tanpa mempedulikan sumber energi. Hal ini tidak perlu
dikhawatirkan jika kita sedang menggunakan energi dari AC, namun kita ingin
boot ke runlevel <c>battery</c> ketika kita menggunakan sumber energi dari
baterai. Salah satu solusinga adalah dengan menambahkan entri baru di
konfigurasi bootloader dengan parameter <c>softlevel=battery</c>, tetapi
kemungkinan besar anda akan lupa memilih entri ini. Cara yang lebih baik adalah
dengan memalsukan event ACPI pada akhir proses boot dan memerintahkan skrip
<path>pmg_switch_runlevel.sh</path> untuk menentukan apakah perpindahan
runlevel diperlukan. Buka file <path>/etc/conf.d/local.start</path> dengan
editor kesukaan anda dan tambahkan baris-baris berikut:
</p>

<pre caption="Perpindahan runlevel saat boot dengan mengedit local.start">
<comment># Event acpi palsu untuk berpindah runlevel ketika menggunakan baterai</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Dengan begini, anda dapat menerapkan kebijakan Manajemen Power untuk
masing-masing perangkat.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Manajemen Power CPU</title>
<section>
<body>

<p>
Prosesor <e>mobile</e> dapat beroperasi pada frequensi yang berbeda. Sejumlah
CPU bahkan dapat menggati voltase. Biasanya CPU anda tidak perlu dijalankan
pada kecepatan penuh dan dengan menurunkan kecepatannya, kita dapat menghemat
banyak energi - bahkan tanpa mengalami penurunan performa.
</p>

</body>
</section>
<section>
<title>Istilah-istilah Penting</title>
<body>

<p>
<e>CPU frequency scaling</e> memperkenalkan beberapa istilah baru yang mungkin
belum anda kenal. Berikut ini sedikit penjelasannya.
</p>

<p>
Pertama, kernel harus mampu mengganti frekuensi prosesor. <b>Driver CPUfreq
prosesor</b> mengetahui perintah untuk menjalankannya. Untuk itu, anda harus
memilih driver yang benar. Seharusnya anda telah melakukannya tadi ketika
mengkonfigurasi kernel untuk mengaktifkan acpi. Jika kernel telah mengetahui
cara mengganti frekuensi, kernel harus tahu frekuensi yang akan digunakan.
Nilai ini didapatkan dari sebuah <b>aturan</b> yang terdiri dari <b>aturan
CPUfreq</b> dan sebuah <b>governor</b>. Aturan CPUfreq hanyalah berupa dua
nilai - minimal dan maksimal - yang menentukan rentang frekuensi yang akan
digunakan. Governor akan memilih frekuensi di antara rentang tersebut. Sebagai
contoh, governor <b>powersave</b> selalu memilih frekuensi terendah yang
tersedia, sedangkan governor <b>performance</b> memilih frekuensi tertinggi.
Governor <b>userspace</b> tidak membuat keputusan tetapi memilih apapun yang
dipilih oleh pengguna (atau program di dalam userspace) - yang berarti governor
ini membaca frekuensi dari
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Ini kedengarannya tidak seperti perubahan frekuensi secara dinamis, dan
sebenarnya memang tidak. Perubahan secara dinamis bisa didapatkan dengan
melalui berbagai pendekatan. Sebagai contoh, governor <b>ondemand</b> membuat
keputusan berdasarkan muatan/kerja CPU saat ini. Hal yang sama dilakukan juga
oleh berbagai tool userland seperti <c>cpudyn</c>, <c>cpufreqd</c>,
<c>powernowd</c> dan masih banyak lagi. Event ACPI dapat digunakan untuk
mengaktifkan atau menonaktifkan perubahan frekuensi secara dinamis menurut
sumber energi yang digunakan.
</p>

</body>
</section>
<section>
<title>Pengaturan Frekuensi Secara Manual</title>
<body>

<p>
Menurunkan kecepatan dan voltase CPU memberikan dua manfaat: penghematan energi
dan penurunan panas CPU. Akibat jelek dari penurunan kecepatan CPU sudah pasti
adalah penurunan performa. Mengurangi kecepatan prosesor juga berarti
pertukaran antara kehilangan performa dan penghematan energi.
</p>

<note>
Tidak semua laptop mendukung perubahan frekuensi. Jika anda tidak yakin,
periksalah daftar prosesor yang mendukungnya di bagian <uri
link="#doc_chap8">Pemecahan Masalah</uri> untuk memastikan apakah laptop anda
mendukungnya.
</note>

<p>
Saatnya untuk menguji apakah perubahan frekuensi CPU dapat dilakukan. Mari kita
instal tool lain yang sangat berguna untuk proses <e>debug</e>:
<c>sys-power/cpufrequtils</c>
</p>

<pre caption="Memeriksa frekuensi CPU">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Berikut adalah contoh output:
</p>

<pre caption="Contoh output dari cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: conservative, ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz.
</pre>

<p>
Sekarang barmain-mainlah dengan <c>cpufreq-set</c> untuk memastikan apakah
penggantian frekuensi dapat dilakukan. Jalankan <c>cpufreq-set -g ondemand</c>
misalnya, untuk mengaktifkan governor <c>ondemand</c> dan lihat perubahannya
dengan perintah <c>cpufreq-info</c>. Jika tidak berhasil, anda mungkin bisa
mendapatkan batuan dari bagian <uri link="#doc_chap8">Pemecahan Masalah</uri>
di akhir panduan ini.
</p>

</body>
</section>
<section>
<title>Pengaturan Frekuensi Secara Otomatis</title>
<body>

<p>
Perintah-perintah di atas cukup bermanfaat, tetapi kurang cocok untuk
penggunaan sehari-hari. Akan lebih bagus lagi jika frekuensi dapat diatur
secara otomatis. Ada beberapa pendekatan yang dapat digunakan untuk
melakukannya. Tabel berikut ini berisi tinjauan singkat yang dapat membantu
anda memilih dari pendekatan-pendekatan yang tersedia. Cara-cara ini dipisahkan
menjadi tiga bagian, pendekatan <b>kernel</b> yang hanya membutuhkan dukungan
kernel, <b>daemon</b> untuk program yang dijalankan di belakang dan
<b>graphical</b> untuk program yang menyediakan GUI untuk mempermudah
konfigurasi.
</p>

<table>
<tr>
  <th>Nama</th>
  <th>Kategori</th>
  <th>Dasar pengambilan keputusan</th>
  <th>Governor kernel</th>
  <th>Governor lain</th>
  <th>Komentar</th>
</tr>
<tr>
  <ti>Governor 'ondemand'</ti>
  <ti>Kernel</ti>
  <ti>Beban CPU</ti>
  <ti>Tidak tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>
    Memilih frekuensi maksimal saat beban CPU penuh dan menurunkannya secara
    perlahan ketika CPU mengalami <e>idle</e>. Pengaturan tambahan dilakukan
    melalui file-file di dalam
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Membutuhkan
    tool userland (program, skrip) jika diperlukan penggantian governor atau
    yang sejenisnya.
  </ti>
</tr>
<tr>
  <ti>Governor 'conservative'</ti>
  <ti>Kernel</ti>
  <ti>Beban CPU</ti>
  <ti>Tidak tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>
    Tidak seperti governor odemand, governor conservative tidak langsung
    menggunakan frekuensi tertinggi ketika beban CPU penuh, tetapi
    meningkatkannya secara perlahan. Pengaturan tambahan dilakukan melalui
    file-file di dalam
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Membutuhkan
    tool userland (program, skrip) jika diperlukan penggantian governor atau
    yang sejenisnya.
  </ti>
</tr>
<tr>
  <ti>
    <uri
    link="http://projects.simpledesigns.com.pl/project/ncpufreqd/">ncpufreqd</uri>
  </ti>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Daemon</ti>
  <ti>Beban CPU</ti>
  <ti>Performa, penghematan energi</ti>
  <ti>Dinamis</ti>
  <ti>
    Juga mendukung <e>disk standby</e> - perlu diketahui bahwa pada kebanyakan
    kasus, <e>laptop mode</e> dapat bekerja lebih baik.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Daemon</ti>
  <ti>Status baterai, beban CPU, suhu, jumlah program yang berjalan, dll</ti>
  <ti>Semua tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>
    Pengaturannya detil (tetapi agak rumit). Dapat diperluas dengan plugin
    seperti monitor sensor (lm_sensors atau dengan mengkoordinasikan kartu
    video yang memiliki memori atau inti berbasis nVidia. Cpufreqd mendukung
    SMP dan dapat dikendalikan ketika sedang dijalankan.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Beban CPU</ti>
  <ti>Tidak tersedia</ti>
  <ti>Pasif, sinus, agresif</ti>
  <ti>
    Mendukung multi-cpu (SMP).
  </ti>
</tr>
<tr>
  <ti>
    <uri
    link="http://fatcat.ftj.agh.edu.pl/~nelchael/index.php?cat=projs&amp;subcat=ncpufreqd&amp;language=en">ncpufreqd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Suhu</ti>
  <ti>Tidak tersedia</ti>
  <ti>Penghematan energi, performa</ti>
  <ti>
    Memilih governor yang digunakan antara performa dan penghematan energi,
    tergantung pada suhu sistem. Sangat berguna untuk laptop yang bermasalah
    dengan suhu.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Daemon</ti>
  <ti>Beban CPU</ti>
  <ti>Tidak tersedia</ti>
  <ti>Dinamis, penghematan energi, performa, kecepatan tetap</ti>
  <ti>
    Mudah dikonfigurasi dengan antarmuka klien/server yang bagus. Membutuhkan
    kernel 2.6. Tidak dikembangkan lagi, karenanya tidak tersedia di Portage.
    Gunakan cpefreqd jika anda masih menggunakan daemon ini.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Grafis</ti>
  <ti>Tidak tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>
    Aplikasi Gnome, tool grafis untuk mengatur frekuensi CPU secara manual dan
    tidak menawarkan pengaturan secara otomatis.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>grafis</ti>
  <ti>Status baterai</ti>
  <ti>Semua tersedia</ti>
  <ti>Tidak tersedia</ti>
  <ti>
    Aplikasi KDE, membutuhkan governor 'ondemand' untuk pengaturan frekuensi
    secara dinamis.
  </ti>
</tr>
</table>

<p>
Walaupun kelihatannya mengatur frekuensi berdasarkan beban CPU mudah dilakukan,
sebenarnya ini bukan tugas yang mudah. Algoritma yang kurang bagus dapat
menyebabkan terjadinya perubahan frekuensi tanpa henti atau penghamburan energi
ketika frekuensi diatur ke level tinggi yang sebenarnya tidak diperlukan.
</p>

<p>
Apa yang harus saya pilih? Jika anda tidak yakin, gunakan <c>cpufreqd</c>:
</p>

<pre caption="Instalasi cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> dapat dikonfigurasi dengan mengedit
<path>/etc/cpufreqd.conf</path>. Konfigurasi defaultnya agak sedikit
membingungkan. Penulis menganjurkan anda untuk menggantinya dengan konfigurasi
berikut ini dari mantan pengembang Gentoo, Henrik Brix Andersen. Perlu
diketahui bahwa anda memerlukan cpufreqd-2.0.0 atau yang lebih baru. Versi
sebelumnya menggunakan sintaks konfigurasi yang berbeda.
</p>

<pre caption="/etc/cpufreqd.conf (cpufreqd-2.0.0 dan yang lebih baru)">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=3
enable_plugins=acpi_ac, acpi_battery
enable_remote=1
remote_group=wheel
verbosity=5
[/General]

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand
[/Profile]

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative
[/Profile]

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave
[/Profile]

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance
[/Profile]

[Rule]
name=battery
ac=off
profile=conservative
[/Rule]

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave
[/Rule]

[Rule]
name=ac
ac=on
profile=ondemand
[/Rule]
</pre>

<p>
Sekarang anda dapat menjalankan daemon cpufreqd. Jangan lupa tambahkan daemon
ini ke runlevel <c>default</c> dan <c>battery</c>.
</p>

<pre caption="Menjalankan cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<p>
Terkadang kita ingin menerapkan kebijakan yang berbeda dari kebijakan yang
dipilih oleh daemon, misalnya ketika baterai lemah, tetapi kita tahu bahwa AC
sebentar lagi akan tersedia. Pada kasus ini, anda dapat menggunakan modus
manual cpufreqd dengan perintah <c>cpufreqd-set manual</c> lalu pilih salah
satu kebijakan yang telah anda tetapkan (seperti yang ditampilkan oleh
<c>cpufreqd-get</c>). Anda dapat meninggalkan modus manual dengan
<c>cpufreqd-set dynamic</c>.
</p>

<warn>
Jangan jalankan lebih dari satu perintah di atas secara bersamaan karena dapat
menyebabkan kebingungan seperti perpindahan frekuensi tanpa henti.
</warn>

</body>
</section>
<section>
<title>Memeriksa hasil</title>
<body>

<p>
Hal terakhir yang perlu diperiksa adalah apakah kebijakan kita telah berfungsi
dengan baik. Cara mudah untuk melakukannya adalah dengan memonitor kecepatan
CPU ketika laptop digunakan:
</p>

<pre caption="Memonitor kecepatan CPU">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Jika <path>/proc/cpuinfo</path> tidak diperbarui (baca bagian <uri
link="#doc_chap8">Pemecahan Masalah</uri>), monitor frekuensi CPU dengan:
</p>

<pre caption="Cara alternatif untuk memonitor kecepatan CPU">
# <i>watch x86info -mhz</i>
</pre>

<p>
Tergantung pada pengaturan anda, kecepatan CPU seharusnya akan ditingkatkan
ketika beban penuh, dan diturunkan ketika tidak ada aktifitas. Ketika
menggunakan <c>cpufreqd</c> dan tingkat verbositas yang ditetapkan di
<path>cpufreqd.conf</path> adalah 5 atau lebih, informasi tambahan tentang apa
saja yang terjadi akan dilaporkan ke <c>syslog</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Manajemen Power LCD</title>
<section>
<body>

<p>
Seperti yang bisa anda lihat di <uri link="#doc_chap1_fig1">gambar 1.1</uri>,
LCD adalah penyerap energi terbesar. Jadi, penting sekali untuk tidak hanya
mematikan display ketika tidak diperlukan, tetapi juga mengurangi cahayanya
jika memungkinkan. Kebanyakan laptop menyediakan fitur untuk mengendalikan
pengaturan cahaya LCD.
</p>

</body>
</section>
<section>
<title>Pengaturan Standby</title>
<body>

<p>
Hal pertama yang perlu diperiksa adalah penetapan waktu standby/suspend/off
display. Karena hal ini sangat bergantung pada WM yang anda gunakan, anda harus
mencari sendiri cara melakukannya. Dua petunjuk: Mengosongkan layar terminal
dapat dilakukan dengan <c>setterm -blank &lt;jumlah-menitM&gt;</c>, <c>setterm
-powersave on</c> dan <c>setterm -powerdown &lt;jumlah-menitM&gt;</c>. Untuk
X.org, edit <path>/etc/X11/xorg.conf</path> seperti berikut:
</p>

<pre caption="Pengaturan cahaya LCD untuk X.org">
Section "ServerFlags"
  Identifier  [...]
  [...]
  Option  "blank time"  "5"  <comment># Kosongkan layar setelah 5 menit (palsu)</comment>
  Option  "standby time"  "10"  <comment># Kosongkan layar 10 menit (DPMS)</comment>
  Option  "suspend time"  "20"  <comment># Suspend penuh setelah 20 menit</comment>
  Option  "off time"  "30"  <comment># Matikan setelah setengah jam</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"
  [...]
EndSection
</pre>

</body>
</section>
<section>
<title>Pengaturan Cahaya</title>
<body>

<p>
Pengaturan cahaya mungkin lebih penting. Jika anda memiliki akses untuk ini
melalui sebuah tool, tuliskan skrip kecil yang dapat mengatur cahaya LCD ketika
baterai digunakan dan tambahkan skrip ini ke runlevel <c>battery</c>. Skrip
berikut ini dapat digunakan pada kebanyakan laptop IBM Thinkpad dan Toshiba.
Anda harus mengaktifkan opsi yang diperlukan di kernel (hanya untuk IBM
Thinkpad). Untuk laptop Toshiba, instal <c>sys-power/acpitool</c> dan lewatkan
konfigurasi <c>thinkpad_acpi</c> (dahulu bernama <c>ibm_acpi</c>) berikut ini.
</p>

<warn>
Dukungan untuk pengaturan cahaya masih dianggap eksperimental pada ibm-acpi.
Pengaturan ini mengakses hardware secara langsung dan mungkin dapat
mengakibatkan kerusakan pada sistem anda. Kunjungilah <uri
link="http://ibm-acpi.sourceforge.net/">website thinkpad_acpi</uri>.
</warn>

<p>
Untuk dapat mengatur tingkat cahaya LCD, modul <c>thinkpad_acpi</c> harus dimuat
dengan parameter eksperimental.
</p>

<pre caption="Muat modul thinkpad_acpi secara otomatis">
<comment>(Bacalah peringatan di atas tentang hal ini!)</comment>
# <i>echo "options thinkpad_acpi experimental=1" >> /etc/modules.d/thinkpad_acpi</i>
# <i>/sbin/update-modules</i>
# <i>echo thinkpad_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
# <i>modprobe thinkpad_acpi</i>
</pre>

<p>
Perintah-perintah di atas seharusnya dapat dijalankan tanpa pesan error dan
file <path>/proc/acpi/ibm/brightness</path> akan diciptakan setelah modul
dimuat. Sebuah skrip init akan menangani pengaturan cahaya menurut sumber
energi yang digunakan.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Bacalah /proc/acpi/ibm/brightness untuk mengetahui nilai-nilai yang tersedia</comment>
<comment># Bacalah /usr/src/linux/Documentation/thinkpad-acpi.txt</comment>

<comment># Tingkat cahaya pada modus AC. Default adalah 7.</comment>
BRIGHTNESS_AC=7

<comment># Tingkat cahaya pada modus baterai. Default adalah 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    elif [[ -e /usr/bin/acpitool &amp;&amp; -n $(acpitool -T | grep "LCD brightness") ]]
    then
        ebegin "Setting LCD brightness"
        acpitool -l $LEVEL >/dev/null || ewarn "Unable to set lcd brightness"
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "For IBM Thinkpads, check that thinkpad_acpi is loaded into the kernel"
        ewarn "For Toshiba laptops, you've got to install sys-power/acpitool"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Setelah selesai, jangan lupa tambahkan skrip ini ke runlevel <c>battery</c>.
</p>

<pre caption="Mengaktifkan pengaturan cahaya secara otomatis">
# <i>chmod +x /etc/init.d/lcd-brightness</i>
# <i>rc-update add lcd-brightness battery</i>
# <i>rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Manajemen Power Disk</title>
<section>
<body>

<p>
Harddisk menyerap energi yang lebih sedikit pada modus <e>sleep</e>. Jadi, kita
perlu mengaktifkan fitur penyimpanan energi ketika harddisk tidak digunakan
dalam rentang waktu tertentu. Berikut ini adalah dua cara untuk melakukannya.
Pertama, <c>laptop-mode</c> akan menyimpan energi karena sebab tertentu yang
akan mencegah atau paling tidak menunda akses penulisan ke harddisk. Kekurangan
dari cara ini adalah, karena akses penulisan ditunda, maka ketika power hilang
atau kernel <e>crash</e>, data yang belum ditulis kemungkinan besar akan
hilang. Jika anda tidak menyukai akibat ini, pastikan agar tidak ada proses
yang melakukan penulisan ke harddisk secara terus menerus. Setelah itu anda
dapat mengaktifkan fitur penyimpanan energi harddisk dengan <c>hdparm</c>
sebagai alternatif.
</p>

</body>
</section>
<section>
<title>Meningkatkan waktu idle - laptop-mode</title>
<body>

<pre caption="Instalasi laptop-mode-tools">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> memiliki file konfigurasinya sendiri di
<path>/etc/laptop-mode/laptop-mode.conf</path>, sesuaikan dengan kebutuhan
anda. File ini juga berisi petunjuk-petunjuk berupa komentar. Jalankan
<c>rc-update add laptop_mode battery</c> untuk menjalankannya secara otomatis.
</p>

<p>
Versi-versi terbaru (1.11 dan yang lebih baru) laptop-mode-tools
mengikutsertakan sebuah tool baru, <c>lm-profiler</c>. Tool ini dapat memonitor
sistem dan penggunaan disk anda dan menjalankan servis jaringan dan memberikan
anjuran tentang servis yang sebaiknya dihentikan. Anda dapat menonaktifkannya
melalui dukungan runlevel built-in laptop-mode-tools (yang akan kembali kepada
<c>/sbin/rc</c> dari Gentoo) atau dengan runlevel
<c>default</c>/<c>battery</c>.
</p>

<pre caption="Contoh output dari lm-profiler">
# <i>lm-profiler</i>
Profiling session started.
Time remaining: 600 seconds
[4296896.602000] amarokapp
Time remaining: 599 seconds
[4296897.714000] sort
[4296897.970000] mv
Time remaining: 598 seconds
Time remaining: 597 seconds
[4296900.482000] reiserfs/0
</pre>

<p>
Setelah memonitor sistem anda selama 10 menit, lm-profiler akan memberikan
daftar servis yang mungkin menyebabkan akses disk selama proses monitor
berlangsung.
</p>

<pre caption="Anjuran lm-profiler tentang servis yang sebaiknya dihentikan">
Program:     "atd"
Reason:      standard recommendation (program may not be running)
Init script: /etc/init.d/atd (GUESSED)

Do you want to disable this service in battery mode? [y/N]: <i>n</i>
</pre>

<p>
Untuk menonaktifkan <c>atd</c> seperti yang dianjurkan pada contoh di atas,
anda perlu menjalankan <c>rc-update del atd battery</c>. Jangan sampai anda
menonaktifkan servis yang diperlukan oleh sistem anda untuk dapat berjalan
dengan normal - <c>lm-profiler</c> bisa saja memberikan pesan keliru. Jangan
nonaktifkan sebuah servis jika anda tidak yakin apakah servis tersebut
diperlukan atau tidak.
</p>

</body>
</section>
<section>
<title>Membatasi Akses Penulisan</title>
<body>

<p>
Jika anda tidak ingin menggunakan laptop-mode, anda harus lebih berhati-hati
ketika menonaktifkan servis yang sering melakukan penulisan ke disk -
<c>syslogd</c> adalah contohnya. Anda mungkin tidak perlu mengehentikan servis
tersebut secara menyeluruh, tetapi cukup dengan mengubah file konfigurasi agar
hal-hal yang "tidak terlalu penting" tidak perlu di-log untuk mengurangi
penulisan ke disk. <c>cups</c> melakukan penulisan ke disk secara berkala, jadi
anda mungkin perlu menghentikannya dan hanya mengaktifkannya kembali secara
manual ketika diperlukan.
</p>

<pre caption="Menonaktifkan cups pada modus baterai">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Anda juga dapat menggunakan <c>lm-profiler</c> dari laptop-mode-tools (baca
penjelasan di atas) untuk menghentikan servis. Setelah selesai, lanjutkan
dengan mengkonfigurasi <c>hdparm</c>.
</p>

</body>
</section>
<section>
<title>hdparm</title>
<body>

<p>
Pendekatan kedua adalah dengan menggunakan <c>hdparm</c>. Lewatkan bagian ini
jika anda menggunakan laptop-mode. Jika tidak, edit
<path>/etc/conf.d/hdparm</path> dan tambahkan beberapa nialai berikut ini pada
entri device anda. Contoh ini menganggap harddisk anda adalah <b>hda</b>:
</p>

<pre caption="Menggunakan hdparm untuk disk standby">
hda_args="-q -S12"
</pre>

<p>
Konfigurasi di atas akan mengaktifkan manajemen power untuk harddisk anda.
Jika anda ingin menonaktifkan manajemen power, anda dapat mengedit
<path>/etc/conf.d/hdparm</path> dan mengganti nilai di atas menjadi
<c>-q -S0</c>, atau jalankan saja <c>hdparm -q -S0 /dev/hda</c>.
</p>

<p>
Bacalah manual hdparm untuk mengetahui opsi-opsi yang tersedia. Walaupun anda
bisa saja menjalankan sendiri <c>hdparm</c> ketika anda menggunakan power dari
baterai dengan perintah <c>/etc/init.d/hdparm start</c>, akan lebih mudah jika
anda menambahkannya ke runlevel battery agar manajemen power selalu diaktifkan
ketika boot.
</p>

<pre caption="Pengaturan disk standby secara otomatis">
# <i>rc-update add hdparm battery</i>
</pre>

<impo>
Berhati-hatilah dengan pengaturan <e>sleep/spin down</e> harddisk. Penggunaan
nilai kecil dapat merusak harddisk dan menghilangkan garansi.
</impo>

</body>
</section>
<section>
<title>Trik-trik lain</title>
<body>

<p>
Pendekatan lainnya adalah dengan menonaktifkan swap pada modus baterai. Sebelum
menulis skrip pemanggil swapon/swapoff, pastikan agar anda memiliki RAM yang
cukup dan swap tidak sedang mendapatkan beban penuh, jika tidak, anda akan
mendapatkan masalah besar.
</p>

<p>
Jika anda tidak ingin menggunakan laptop-mode, anda masih dapat mengurangi
akses disk dengan me-mount beberapa direktori sebagai <c>tmpfs</c> - akses
penulisan tidak dilakukan ke disk, tetapi ke memori utama dan akan hilang
ketika unmount. Biasanya anda dapat menggunakan cara ini untuk
<path>/tmp</path> - anda tidak perlu khawatir karena direktori ini akan tetap
selalu dibersihkan setiap kali reboot tanpa mempedulikan apakah direktori
tersebut di-mount ke RAM atau disk. Pastikan saja agar anda memiliki RAM yang
cukup besar dan tidak ada program (seperti <e>downloader</e> atau utilitas
kompresi) yang membutuhkan ruang besar di <path>/tmp</path>. Untuk
melakukannya, tambahkan sebuah baris di <path>/etc/fstab</path> seperti
berikut:
</p>

<pre caption="Edit /etc/fstab">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Perhatikan baik-baik parameter ukuran dan sesuaikan dengan sistem anda. Jika
anda tidak yakin, jangan coba-coba menggunakan cara ini, karena dengan mudah
dapat menjadi penyebab penurunan performa. Jika anda ingin me-mount
<path>/var/log</path> seperti ini, jangan lupa gabungkan dulu file-file log
sebelum melakukan unmount. File-file ini penting. Jangan coba-coba untuk
me-mount <path>/var/tmp</path> dengan cara ini. Portage menggunakannya untuk
melakukan kompilasi...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Manajemen Power Untuk Perangkat Lain</title>
<section>
<title>Kartu Grafis</title>
<body>

<p>
Jika anda menggunakan kartu grafis ATi yang mendukung PowerPlay (pengaturan
<e>clock</e> secara dinamis untuk <e>graphics processing unit</e>/GPU), anda
dapat mengaktifkan fitur ini di X.org. Bukalah <path>/etc/X11/xorg.conf</path>
dan tambahkan (atau aktifkan) opsi <c>DynamicClocks</c> pada seksi
<c>Device</c>. Perlu diketahui bahwa fitur ini bisa menyebabkan crash pada
beberapa sistem.
</p>

<pre caption="Mengaktifkan dukungan ATi PowerPlay di X.org">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>

</body>
</section>
<section>
<title>Manajemen Power Wireless</title>
<body>

<p>
Kartu LAN Wireless dapat menyerap energi yang lumayan banyak. Tempatkan
kartu ini pada modus Manajemen Power seperti halnya harddisk anda.
</p>

<note>
Skrip berikut menganggap kartu wireless anda bernama <c>wlan0</c>; gantikan
dengan nama kartu anda yang sebenarnya.
</note>

<p>
Tambahkan opsi berikut ini ke <path>/etc/conf.d/net</path> agar manajemen
power untuk kartu wireless anda langsung diaktifkan.
</p>

<pre caption="Otomatisasi Manajemen Power WLAN">
iwconfig_wlan0="power on"
</pre>

<p>
Bacalah <c>man iwconfig</c> untuk mengetahui opsi-opsi lain seperti rentang
waktu antara <e>wakeup</e> dan pengaturan <e>timeout</e>. Jika driver dan akses
poin anda mendukung penggantian waktu penyiaran sinyal, anda dapat menyimpan
energi yang lebi banyak lagi.
</p>

</body>
</section>
<section>
<title>Manajemen Power USB</title>
<body>

<p>
Terdapat dua masalah dengan perangkat USB berdasarkan konsumsi energi: Pertama,
perangkat seperti mouse USB, kamera digital atau flashdisk mengkonsumsi energi
ketika ditancapkan. Anda tidak dapat menghindarinya (untuk itu cabut perangkat
tersebut jika tidak diperlukan). Kedua, ketika ada perangkat USB yang
ditancapkan, pengendali host USB secara berkala mengakses <e>bus</e> untuk
mencegah CPU masuk ke modus <e>sleep</e>. Kernel menyediakan sebuah opsi
eksperimental untuk mendapatkan penonaktifan perangkat USB melalui pemanggilan
driver atau salah satu file <path>power/state</path> di <path>/sys</path>.
</p>

<pre caption="Aktifasi dukungan penonaktifan USB di kernel">
Device Drivers
  USB support
    [*]   Support for Host-side USB
      [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Status sleep: sleep, standby, dan suspend ke disk</title>
<section>
<body>

<p>
ACPI menentukan beberapa jenis status sleep. Jenis-jenis yang penting untuk
diketahui adalah:
</p>

<ul>
  <li>S1 alias Standby</li>
  <li>S3 alias Suspend ke RAM alias Sleep</li>
  <li>S4 alias Suspend ke Disk alias Hibernate</li>
</ul>

<p>
Semuanya dapat dipanggil ketika sistem sedang tidak digunakan, tetapi,
<e>shutdown</e> tidak diinginkan karena lamanya waktu boot.
</p>

</body>
</section>
<section>
<title>Sleep (S3)</title>
<body>

<p>
Dukungan ACPI untuk status sleep ini masih dianggap eksperimental untuk alasan
yang baik. Status sleep APM kelihatannya lebih stabil, tetapi anda tidak dapat
menggunakan APM dan ACPI bersamaan.
</p>

<pre caption="Konfigurasi kernel untuk beberapa tipe suspend">
  Power Management Options ---&gt;
    [*]  Power Management support
      ACPI (Advanced Configuration and Power Interface) Support ---&gt;
        [*]  ACPI Support
          [*]   Sleep States
</pre>

<p>
Setelah kernel anda dikonfigurasi dengan benar, anda dapat menggunakan
<c>hibernate-script</c> untuk mengaktifkan modus suspend atau sleep. Mari kita
instal skrip ini.
</p>

<pre caption="Instalasi hibernate-script">
# <i>emerge hibernate-script</i>
</pre>

<p>
Beberapa konfigurasi harus dilakukan di <path>/etc/hibernate</path>. Paket
default menyediakan beberapa file konfigurasi untuk setiap status sleep. Opsi
yang umum untuk semua metode suspen ditempatkan di <path>common.conf</path>;
pastikan agar file ini dikonfigurasi dengan benar untuk sistem anda.
</p>

<p>
Untuk mengkonfigurasi sleep, edit <path>sysfs-ram.conf</path> di
<path>/etc/hibernate</path>. <c>UseSysfsPowerState mem</c> telah dikonfigurasi
dengan benar, tetapi jika anda masih perlu membuat sedikit perubahan pada
status sleep ini (atau status sleep lain), anda harus menambahkan perubahan
anda di <path>/etc/hibernate/hibernate.conf</path>. Komentar dan nama-nama opsi
akan membantu anda. Jika anda menggunakan <e>share</e> nfs atau samba, jangan
lupa menghentikan skrip init yang bersangkutan untuk menghindari timeout.
</p>

<note>
Untuk informasi lebih lanjut tentang pengaturan status sleep, bacalah <c>man
hibernate.conf</c>.
</note>

<p>
Siap? Sekarang adalah kesempatan terakhir bagi anda untuk mem-backup data
apapun yang ingin anda simpan sebelum menjalankan perintah berikut. Anda
mungkin perlu menekan tombol khusus seperti <c>Fn</c> untuk kembali dari sleep.
</p>

<pre caption="Memanggil sleep">
# <i>hibernate-ram</i>
</pre>

<p>
Jika anda masih membaca, kelihatannya pemanggilan telah berhasil. Anda juga
dapat mengatur standby (S1) dengan cara yang sama dengan mengedit
<path>sysfs-ram.conf</path> dan mengganti "UseSysfsPowerState mem" menjadi
"UseSysfsPowerState standby". Bagaimanapun juga, S3 dan S4 adalah status sleep
yang lebih menarik karena dapat menyimpan lebih banyak energi.
</p>

</body>
</section>
<section>
<title>Hibernate (S4)</title>
<body>

<p>
Bagian ini memperkenalkan <e>hibernation</e> yang akan menciptakan sebuah
<e>snapshot</e> dari sistem saat ini sebelum komputer dimatikan. Ketika resume,
snapshot tersebut akan dimuat dan anda dapat melanjutkan pekerjaan anda persis
seperti sebelum anda memanggil hibernate.
</p>

<warn>
Jangan lakukan penggantian hardware <e>non-pluggable</e> selama hibernate.
Jangan mencoba untuk memuat snapshot dengan imej kernel yang berbeda dengan
imej kernel ketika snapshot tersebut diciptakan. Matikan semua server/klien NFS
atau samba sebelum melakukan hibernate.
</warn>

<p>
Terdapat dua implementasi yang berbeda untuk S4. Implementasi yang asli adalah
<e>swsusp</e>, dan yang kedua dan yang lebih baru adalah <e>tuxonice</e>
(sebelumnya bernama suspen2) yang memiliki antarmuka yang lebih bagus (termasuk
dukungan fbsplash). <uri
link="http://tuxonice.net/features.html#compare">Perbandingan
fitur-fiturnya</uri> bisa anda baca di <uri link="http://tuxonice">website
tuxonice</uri>. Dahulu ada <e>Suspend-to-Disk</e> (pmdisk), pencabangan dari
swsusp, tetapi telah digabungkan kembali.
</p>

<p>
TuxOnIcebelum diikutsertakan pada kernel resmi, untuk itu anda harus menambal
sendiri source kernel anda dengan tambalan-tambalan yang disediakan oleh <uri
link="http://tuxonice.net">tuxonice.net</uri> atau menggunakan
<c>sys-kernel/tuxonice-sources</c>.
</p>

<p>
Bagian kernel untuk swusp dan TuxOnIce adalah sebagai berikut:
</p>

<pre caption="Konfigurasi kernel untuk beberapa tipe suspend">
Power Management Options ---&gt;
  <comment>(hibernate dengan swsusp)</comment>
  [*] Software Suspend
      <comment>(gantikan /dev/SWAP dengan partisi swap anda)</comment>
      (/dev/SWAP)      Default resume partition

  <comment>(hibernate dengan TuxOnIce)</comment>
  Enhanced Hibernation (TuxOnIce)
    --- Image Storage (you need at least one writer)
    [*]     File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(gantikan /dev/SWAP dengan partisi swap)</comment>
    (swap:/dev/SWAP)   Default resume device name
    [ ]     Allow Keep Image Mode
</pre>

<p>
Konfigurasi swusp cukup mudah. Jika anda tidak menentukan lokasi partisi swap
anda pada konfigurasi kernel, anda dapat menentukannya dengan menambahkan
parameter <c>resume=/dev/SWAP</c> pada konfigurasi bootloader. Jika proses boot
gagal karena imej snapshot rusak, gunakan parameter <c>noresume</c>. Skrip init
<c>hibernate-cleanup</c> akan menghapus imej swusp ketika proses boot
berlangsung.
</p>

<pre caption="Penghapusan swsusp ketika proses boot berlangsung">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Untuk mengaktifkan hibernate dengan swusp, gunakan skrip hibernate lalu atur
<c>UseSysfsPowerState disk</c> di <path>/etc/hibernate/sysfs-disk</path>.
</p>

<warn>
Backup data anda sebelum melanjutkan. Jalankan <c>sync</c> sebelum menjalankan
perintah apapun agar semua data dituliskan ke disk. Pertama coba jalankan
perintah ini dari luar X, kemudian jalankan ketika X berjalan, tetapi anda
tidak login.
</warn>

<p>
Jika anda mendapatkan masalah kernel <e>panic</e> disebabkan oleh uhci atau
yang semacamnya, coba kompilasikan dukungan USB sebagai modul dan unload modul
tersebut sebelum melakukan hibernate. Konfigurasi untuk ini ada di
<path>common.conf</path>
</p>

<pre caption="Hibernate dengan swsusp">
# <i>nano -w /etc/hibernate/common.conf</i>
<comment>(Jangan lupa membuat backup sebelumnya)</comment>
# <i>hibernate</i>
</pre>

<p>
Bagian berikut ini menjelaskan pengaturan TuxOnIce termasuk dukungan fbsplash
yang akan ditampilkan ketika suspend atau resume.
</p>

<p>
Konfigurasi bagian pertama mirip dengan konfigurasi swusp. Jika anda tidak
menentukan lokasi partisi swap pada konfigurasi kernel, anda harus
menentukannya sebagai parameter kernel, <c>resume=swap:/dev/SWAP</c>. Jika
proses boot gagal karena imej rusak, tambahkan parameter <c>noresume</c>.
Sebagai tambahan, skrip init <c>hibernate-cleanup</c> akan menghapus imej
TuxOnIce selama proses boot berlangsung.
</p>

<pre caption="Penghapusan imej selama proses boot">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Sekarang edit <path>/etc/hibernate/suspend2.conf</path>, aktifkan opsi
<c>TuXOnIce</c> yang anda perlukan. Jangan dulu aktifkan opsi <c>fbsplash</c>.
</p>

<pre caption="Hibernate dengan TuxOnIce">
# <i>nano -w /etc/hibernate/suspend2.conf</i>
<comment>(Jangan lupa membuat backup sebelumnya!)</comment>
# <i>hibernate</i>
</pre>

<p>
Sekarang konfigurasikan <c>fbsplash</c>. Untuk menggunakan fbsplash ketika
proses hibernate, diperlukan paket <c>sys-apps/tuxonice-userui</c>. Sebagai
tambahan, anda harus mengaktifkan flag USE <c>fbsplash</c>.
</p>

<pre caption="Instalasi tuxonice-userui">
# <i>echo "sys-apps/tuxonice-userui fbsplash" >> /etc/portage/package.use</i>
<comment>(Paket ini mungkin ditandai ~arch, jadi tambahkan dulu)</comment>
# <i>echo "sys-apps/tuxonice-userui" >> /etc/portage/package.keywords</i>
# <i>emerge tuxonice-userui</i>
</pre>

<p>
Ebuild akan memerintahkan anda untuk menciptakan symlink ke tema yang ingin
anda gunakan. Sebagai contoh, untuk menggunakan tema <c>livecd-2005.1</c>,
jalankan perintah berikut:
</p>

<pre caption="Menggunakan tema livecd-2005.1 ketika hibernate">
# <i>ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
Jika anda tidak menginginkan layar kosong pada awal proses resume, anda harus
menambahkan tool <c>tuxoniceui_fbsplash</c> ke imej initrd anda. Dengan
anggapan anda telah menciptakan imej intrd dengan perintah
<c>splash_geninitramfs</c> dan menyimpannya sebagai
<path>/boot/fbsplash-emergence-1024x768</path>, berikut cara melakukannya:
</p>

<pre caption="Menambahkan tuxoniceui_fbsplash ke imej initrd">
# <i>mount /boot</i>
# <i>mkdir ~/initrd.d</i>
# <i>cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
# <i>cd ~/initrd.d</i>
# <i>gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
# <i>rm fbsplash-emergence-1024x768</i>
# <i>cp /usr/sbin/tuxoniceui_fbsplash sbin/</i>
# <i>find . | cpio --quiet --dereference -o -H newc | gzip -9 > /boot/fbsplash-tuxonice-emergence-1024x768</i>
</pre>

<p>
Selanjutnya konfigurasikan <path>grub.conf</path> (atau <path>lilo.conf</path>)
agar kernel tuxonice anda menggunakan
<path>/boot/fbsplash-tuxonice-emergence-1024x768</path> sebagai imej initrd.
Sekarang anda dapat (pura-pura) mencobanya untuk mengetahui apakah semuanya
telah diatur dengan benar.
</p>

<pre caption="Pengujian hibernate dengan fbsplash">
# <i>tuxoniceui_fbsplash -t</i>
</pre>

<p>
Kemudian buka <path>/etc/hibernate/common.conf</path> dan aktifkan opsi
fbsplash. Jalankan <c>hibernate</c> dan..... enjoy!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Pemecahan Masalah</title>
<section>
<body>

<p>
<b>T:</b> Saya mencoba untuk mengganti frekuensi CPU, tetapi
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> tidak ada.
</p>

<p>
<b>J:</b> Pastikan agar prosesor anda mendukung penggantian frekuensi CPU dan
anda telah memilih driver CPUfreq yang sesuai untuk prosesor anda. Berikut ini
adalah daftar prosesor yang didukung oleh cpufreq (kernel 2.6.7): ARM
Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+,
AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon
64, Cyrix Media GXm, Intel mobile PIII dan Intel mobile PIII-M pada beberapa
chipset, Intel Pentium 4, Intel Xeon, Intel Pentium M (Centrino), National
Semiconductors Geode GX, Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III,
SuperH SH-3, SH-4, berbagai jenis "PowerBook" dan "iBook2" serta berbagai
prosesor pada sistem yang kompatibel dengan ACPI 2.0 (hanya jika "ACPI
Processor Performance States" tersedia di antarmuka ACPI/BIOS).
</p>

<p>
<b>T:</b> Laptop saya mendukung penggantian frekuensi, tetapi
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> kosong.
</p>

<p>
<b>J:</b> Carilah pesan error terkait ACPI dengan <c>dmesg | grep ACPI</c>.
Cobalah untuk memperbarui BIOS anda, terutama jika anda menemukan pesan tentang
DSDT yang rusak. Anda juga dapat mencoba untuk memperbaikinya sendiri (tidak
dijelaskan pada panduan ini).
</p>

<p>
<b>T:</b> Laptop saya mendukung penggantian frekuensi, tetapi menurut
<path>/proc/cpuinfo</path>, kecepatannya tidak pernah berganti.
</p>

<p>
<b>J:</b> Kemungkinan anda telah mengaktifkan dukungan SMP di kernel.
Nonaktifkan dukungan ini maka anda akan baik-baik saja. Beberapa kernel lama
memiliki bug yang menyebabkan masalah ini. Jika benar ini penyebabnya, jalankan
<c>emerge x86info</c>, konfigurasikan kernel anda seperti yang telah
ditunjukkan lalu periksa frekuensi saat ini dengan <c>x86info -mhz</c>.
</p>

<p>
<b>T:</b> Saya dapat mengganti frekuensi CPU, tetapi tidak sebebas yang dapat
saya lakukan pada OS lain.
</p>

<p>
<b>J:</b> Anda dapat menggabungkan penggantian frekuensi dengan <e>ACPI
throttling</e> untuk mendapatkan frekuensi terendah. Perlu diketahui bahwa
<e>throttling</e> tidak menyimpan banyak energi dan biasanya digunakan untuk
menurunkan suhu (agar laptop anda tetap dingin dan tidak bising). Anda dapat
membaca status throttling saat ini dengan <c>cat
/proc/acpi/processor/CPU/throttling</c> lalu ganti dengan <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, di mana x adalah salah satu dari <e>Tx</e>
yang terdapat di <path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<b>T:</b> Ketika mengkonfigurasi kernel, governor powersave, performance dan
userspace tampil, tetapi ondemand tidak tampil. Mengapa?
</p>

<p>
<b>J:</b> Governor ondemand hanya terdapat pada source kernel baru. Coba
perbarui kernel anda.
</p>

<p>
<b>T:</b> Ketahanan baterai kelihatannya lebih parah dari sebelumnya.
</p>

<p>
<b>J:</b> Periksa pengaturan BIOS anda. Mungkin anda lupa mengaktifkan kembali
beberapa opsi.
</p>

<p>
<b>T:</b> Baterai saya penuh, tetapi KDE melaporkan baterai kosong dan langsung
melakukan shutdown.
</p>

<p>
<b>J:</b> Periksa apakah dukungan untuk baterai telah dikompilasi di dalam
kernel anda. Jika anda mengkompilasinya sebagai modul, pastikan agar modul
tersebut telah dimuat.
</p>

<p>
<b>T:</b> Logger sistem saya memberikan laporan seperti: "logger: ACPI group
battery / action battery is not defined".
</p>

<p>
<b>J:</b> Pesan ini dihasilkan oleh skrip <path>/etc/acpi/default.sh</path>
dari acpid. Anda boleh mengabaikannya. Jika anda ingin menghindarinya, berikan
tanda komentar pada baris yang sesuai di <path>/etc/acpi/default.sh</path>
seperti berikut:
</p>

<pre caption="Menonaktifkan peringatan tentang event acpi yang tidak dikenal">
        *)      # logger "ACPI action $action is not defined"
</pre>

<p>
<b>T:</b> Saya menggunakan Dell Inspiron 51XX dan tidak mendapatkan event ACPI
apapun.
</p>

<p>
<b>J:</b> Kelihatannya ini disebabkan oleh bug kernel. Bacalah <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">bug ini</uri>.
</p>

<p>
<b>T:</b> Saya telah mengaktifkan opsi <c>DynamicClocks</c> di
<path>xorg.conf</path> tetapi X.org malah crash / layar tetap kosong / laptop
saya tidak dapat shutdown dengan benar.
</p>

<p>
<b>J:</b> Masalah ini terjadi pada beberapa sistem. Anda harus menonaktifkan
<c>DynamicClocks</c>.
</p>

<p>
<b>T:</b> Saya ingin menggunakan TuxOnIce, tetapi saya mendapatkan pesan
tentang partisi swap yang terlalu kecil dan saya tidak dapat merubah ukurannya.
</p>

<p>
<b>J:</b> Jika anda masih memiliki ruang kosong lagi pada harddisk, anda dapat
menggunakan <e>filewriter</e> sebagai pengganti <e>swapwriter</e>.
<c>hibernate-script</c> mendukung opsi ini. Informasi lebih lanjut bisa anda
dapatkan dari <path>/usr/src/linux/Documentation/power/tuxonice.txt</path>.
</p>

<p>
<b>T:</b> Saya baru saja membeli baterai baru, tetapi baterai ini hanya bisa
bertahan beberapa menit saja! Apa yang salah?
</p>

<p>
<b>J:</b> Pertama ikuti petunjuk cara mengisi ulang baterai dengan benar.
</p>

<p>
<b>T:</b> Anjuran di atas belum dapat mengatasi masalah. Apa yang harus saya
lakukan?
</p>

<p>
<b>J:</b> Sejumlah baterai dijual sebagai baterai "baru", padahal bukan.
Cobalah yang berikut ini:
</p>

<pre caption="Memeriksa status baterai">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Jika "last full capacity" berbeda jauh dengan "design capacity", kemungkinan
baterai anda rusak. Mintakan garansi anda.
</p>

<p>
<b>T:</b> Masalah saya tidak dicantumkan di sini. Apa yang harus saya lakukan?
</p>

<p>
<b>A:</b> Jangan ragu untuk menghubungi penulis, <mail
link="earthwings@gentoo.org">Dennis Nienh√ºser</mail>,  secara langsung. <uri
link="http://forums.gentoo.org">Forum Gentoo</uri> juga merupakan tempat yang
baik untuk mendapatkan bantuan. Jika anda lebih suka menggunakan IRC,
bergabunglah di channel <c>#gentoo-laptop</c> di <uri
link="irc://irc.freenode.net">irc.freenode.net</uri>.
</p>

</body>
</section>
</chapter>
</guide>
