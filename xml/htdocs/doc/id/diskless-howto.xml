<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Id: diskless-howto.xml,v 1.4 2012/06/30 18:25:24 swift Exp $ -->

<guide disclaimer="obsolete" lang="id">

<title>Diskless Nodes dengan Gentoo</title>

<author title="Researcher">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Editor">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Reviewer">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Translator">
    <mail link="kucrut.dz@gmail.com">Dzikri Aziz</mail>
</author>

<abstract>
HOWTO akan membantu anda untuk mensetup diskless nodes dengan Gentoo Linux
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.26</version>
<date>2007-03-05</date>

<chapter>
<title>Pendahuluan</title>

<section>
<title>Tentang HOWTO ini</title>
<body>

<p>
HOWTO ini akan membantu anda untuk mensetup workstation <e>diskless</e>
berbasis distribusi Gentoo Linux. Kami sengaja membuat panduan ini semudah
mungkin dan dapat dicerna oleh pengguna baru Linux, karena kita semua barawal
dari sana :) Walaupun penguna yang telah berpengalaman dapat mennyatukan
berbagai HOWTO yang tersedia untuk diskless nodes dan jaringan bersamaan kami
harap panduan ini dapat memudahkan  instalasi untuk semua pengguna yang
tertarik, gaek ataupun bukan.
</p>

</body>
</section>
<section>
<title>Aa itu komputer diskless?</title>
<body>

<p>
Komputer diskless merupakan sebuah PC tanpa perangkat boot biasa seperti
harddisk, floppy, atau CD-ROM. Diskless node melakukan boot dari jaringan
dan membutuhkan server yang menyediakan ruangan peyimpanan sebagaimana
harddisk lokal. Dari sekarang kita akan menyebut server sebagai <e>master</e>,
sedangkan komputer diskless kita namakan <e>slave</e>. Node slave membutuhkan
kartu jaringan yang mendukung boot PXE atau Etherboot; bacalah <uri
link="http://www.etherboot.org">Etherboot.org</uri> untuk daftar perangkat yang
didukung. Kartu-kartu jaringan modern kebanyakan telah mendukung PXE dan banyak
kartu jaringan built-in motherboard juga dapat digunakan.
</p>

</body>
</section>
<section>
<title>Sebelum anda mulai</title>
<body>

<p>
Anda harus memiliki instalasi Gentoo pada node master dan ruang yang cukup di
harddisk master untuk menempatkan filesystem node slave. Pastikan juga agar
anda memiliki satu antarmuka jaringan untuk internet yang terpisah dari koneksi
lokal.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Konfigurasi master dan slave</title>
<section>
<title>Tentang kernel-kernel</title>
<body>

<p>
Kernel merupakan software yang berada di antara hardware anda dan semua
software yang terinstal di komputer anda, jadi pada dasarnya merupakan jantung
dari sistem operasi. Ketika komputer anda dinyalakan, BIOS mengeksekusi
instruksi-instruksi yang ditemukan di ruang boot dari harddisk anda.
Instruksi-instruksi ini biasanya merupakan sebuah bootloader yang me-load
kernel anda. Setelah kernel di-load, semua proses ditangani oleh kernel.

</p>

<p>
Untuk informasi lebih rinci tentanf kerel dan konfigurasi kernel, anda mungkin
ingin membaca <uri link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">HOWTO
kernel</uri>.
</p>

</body>
</section>
<section>
<title>Konfigurasi kernel master</title>
<body>

<p>
Kernel master boleh berukuran sebesar mungkin dan terkostumisasi sesuai dengan
keinginan anda, tetapi ada beberapa opsi kernel yang perlu anda aktifkan.
Masuklah ke menu konfigurasi kernel dengan mengetikkan:
</p>

<pre caption="Mengedit konfigurasi kernel master">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Anda akan mendapatkan GUI abu-abu dan biru yang menawarkan cara alternatif yang
lebih aman daripada mengedit file <path>/usr/src/linux/.config</path>.  Jika
kernel anda saat ini telah berfungsi dengan benar, anda mungkin ingin menyimpan
konfigurasinya dengan cara keluar dari GUI lalu mengetikkan:
</p>

<pre caption="Mem-backup konfigurasi kernel master">
# <i>cp .config .config_working</i>
</pre>

<p>
Masuklah ke submenu-submenu berikut ini dan pastikan agar semua item yang ada
telah anda pilih sebagai built-in (dan <e>BUKAN</e> sebagai modul). Opsi-opsi
berikut ini diambil dari kernel versi 2.6.10. Jika anda menggunakan versi lain,
tulisan atau urutannya mungkin berbeda. Pastikan saja agar anda paling tidak
telah memilih opsi-opsi yang ditunjukkan di bawah ini.
</p>

<pre caption="Opsi-opsi kernel master">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Device Drivers ---&gt;
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)

File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support

<comment>
Jika anda menginginkan akses internet lewat node master anda dan/atau
memiliki sebuah firewall yang aman, pastikan agar anda menambahkan dukungan
untuk iptables
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Jika anda ingin menggunakan packet filtering, anda dapat menambahkan
modul-modul yang nanti. Jangan lupa untuk membaca <uri
link="/doc/en/security/security-handbook.xml?part=1&amp;chap=12">Bab tentang
Firewall dari Buku panduan Keamanan Gentoo</uri> tentang cara men-setup-nya
dengan benar.
</p>

<note>
Opsi-opsi konfigurasi kernel ini hanya ditujukan untuk ditambahkan ke opsi-opsi
konfigurasi sistem anda dan bukan untuk mengganti konfigurasi kernel anda.
</note>

<p>
Setelah mengkonfigurasi-ulang kernel master, anda perlu membangun-ulang kernel
anda.
</p>

<pre caption="Mengkompilasi-ulang kernel master's kernel dan modul-modulnya">
# <i>make &amp;&amp; make modules_install</i>
<comment>(Pastikan agar /boot telah di-mount sebelum menyalinnya)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
</pre>

<p>
Kemudian tambahkan sebuah entri untuk kernel baru tersebut di
<path>lilo.conf</path> atau <path>grub.conf</path>, tergantung bootloader yang
anda gunakan, lalu jadikan kernel baru sebagai kernel default. Sekarang setelah
bzImage disalin ke direktori boot anda, yang perlu anda lakukan adalah me-reboot
sistem anda agar opsi-opsi baru tadi di-load.
</p>

</body>
</section>
<section>
<title>Tentang kernel slave</title>
<body>

<p>
Anda dianjurkan untuk mengkompilasi kernel slave tanpa modul apapun, karena
me-load modul dan menyiapkannya lewat boot jauh merupakan proses yang susah
dan sia-sia. Sebagai tambahan, kernel slave harus berukuran sekecil dan
seramping mungkin untuk mengefisiensikan boot lewat jaringan. Kita akan
mengkompilasi kernel di tempat yang sama dengan tempat kita mengkonfigurasi
kernel master.
</p>

<p>
Untuk menghindari kebingungan dan menyingkat waktu, mungkin mem-backup
konfigurasi master merupakan ide bagus. Lakukan dengan perintah berikut:
</p>

<pre caption="Mem-backup konfigurasi kernel master">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Sekarang kita perlu mengkonfigurasi kernel slave seperti kita telah
mengkonfigurasi kernel master. Jika anda ingin memulai dengan file konfigurasi
baru, anda dapat membuat file <path>/usr/src/linux/.config</path> default
dengan mengetikkan:
</p>

<pre caption="Mendapatkan konfigurasi kernel baru">
# <i>cd /usr/src/linux</i>
# <i>cp .config_master .config</i>
</pre>

<p>
Sekarang masuklah ke GUI konfigurasi kernel dengan mengetikkan:
</p>

<pre caption="Mengedit konfigurasi kernel slave">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Anda perlu memastikan untuk memilih opsi-opsi berikut ini sebagai built-in
dan <e>BUKAN</e> sebagai modul:
</p>

<pre caption="Opsi-opsi kernel slave">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Device Drivers ---&gt;
  [*] Networking support
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support (NEW)

File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
Sebuah cara alternatif untuk memiliki server dhcp adalah dengan men-setup
server BOOTP.
</note>

<impo>
Penting bagi anda untuk menambahkan kartu jaringan anda ke dalam kernel (dan
bukan sebagai modul) pada node. Tetapi menggunakan modul pada node diskless
biasanya tidak menjadi masalah.
</impo>

<p>
Sekarang kernel slave perlu dikompilasi. Anda perlu berhati-hati di sini karena
anda tidak ingin mengacak-acak modul (jika memang ada) yang telah anda kompilasi
untuk master:
</p>

<pre caption="Kompilasi kernel slave">
# <i>cd /usr/src/linux</i>
# <i>make</i>
</pre>

<p>
Sekarang ciptakan direktori di master yang akan digunakan untuk menyimpan
file-file slave dan file-file sistem yang diperlukan. Kami akan menggunakan
<path>/diskless</path>, tetapi anda dapat memilih lokasi lain yang anda sukai.
sekarang salin bzImage slave ke direktori <path>/diskless</path>:
</p>

<note>
Jika anda menggunakan arsitektur yang berbeda, anda mungkin perlu menyimpan
setiap konfigurasi ke <path>.config_arch</path>. Lakukan hal yang sama pada
imej-imej kernel: simpanlah ke <path>/diskless</path> sebagai
<path>bzImage_arch</path>.
</note>

<pre caption="Menyalin kernel slave">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>

</body>
</section>
<section>
<title>Mengkonfigurasi filesystem awal slave</title>
<body>

<p>
Filesystem master dan slave dapat banyak anda tweak dan ubah. Untuk sekarang
ini kita hanya akan mengurusi filesystem dasar dari file konfigurasi dan titik
mount. Pertama kita perlu menciptakan sebuah direktori di dalam
<path>/diskless</path> untuk slave pertama. Setiap slave harus memiliki
filesystem root-nya masing masing, karena berbagi file-file sistem tertentu
akan mengakibatkan masalah perizinan  dan <e>hard crash</e>. Anda boleh
menamakan direktori-direktori ini dengan nama aa saja, tetapi penulis sarankan
untuk menggunakan alamat iP masing masing slave, karena alamat IP unik dan
tidak membingungkan. IP statis slave pertama kita misalnya adalah,
<c>192.168.1.21</c>:
</p>

<pre caption="Menciptakan direktori root remote">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Banyak file konfigurasi di <c>/etc</c> yang perlu anda edit agar berfungsi di
slave. Salin direktori <c>/etc</c> master ke root slave anda dengan mengetikkan:
</p>

<pre caption="Menciptakan /etc untuk filesystem slave">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Filesystem ini masih belum siap pakai karena masih memerlukan beberapa titik
mount dan direktori. Untuk menciptakannya, ketik:
</p>

<pre caption="Menciptakan titik mount dan direktori di filesystem slave">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/sys</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
</pre>

<p>
Anda seharusnya sudah mengenal kebanyakan dari "stub" ini; stub seperti
<path>/dev</path>, <path>/proc</path> atau <path>/sys</path> akan diisi ketika
slave dinyalakan, sisanya akan di-mount nanti. Anda juga perlu mengedit file
<path>/diskless/192.168.1.21/etc/conf.d/hostname</path> dan menyesuaikannya
dengan nama host slave. Binari, pustaka dan file-file lain akan diisikan
di bagian selanjutnya pada HOWTO ini tepat sebelum anda mulai mem-boot slave.
</p>

<p>
Walaupun <path>/dev</path> nantinya akan diisikan oleh <c>udev</c>, anda perlu
menciptakan entri <path>console</path>. Jika tidak, anda akan mendapatkan
pesan error yang mengatakan "unable to open initial console".
</p>

<pre caption="Menciptakan entri console di /dev">
# <i>mknod /diskless/192.168.1.21/dev/console c 5 1</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>Konfigurasi server DHCP</title>
<section>
<title>Tentang server DHCP</title>
<body>

<p>
DHCP adalah kependekan dari Dynamic Host Configuration Protocol. Sever DHCP
adalah komputer pertama yang akan dihubungi oleh slave ketika PXE boot. Tujuan
utama dari server DHCP adalah untuk memberikan alamat IP. Server DHCP dapat
memberikan alamat IP berdasarkan alamat MAC ethernet host. Ketika slave telah
mendapatkan alamat IP, server DHCP akan memberitahukan slave tempat mengambil
filesystem dasar dan kernel-nya.
</p>

</body>
</section>
<section>
<title>Sebelum anda mulai</title>
<body>

<p>
Ada beberapa hal yang perlu anda pastikan telah berfungsi dengan benar sebelum
anda memulai. Pertama, periksa koneksi jaringan anda:
</p>

<pre caption="Memeriksa konfigurasi jaringan">
# <i>ifconfig eth0 multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Anda perlu memastikan agar <c>eth0</c> telah berfungsi. Seharusnya terlihat
seperti berikut ini:
</p>

<pre caption="Perangkat eth0 yang telah berfungsi dengan benar">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
<e>MULTICAST</e> harus ada, jika tidak, anda perlu mengkompilasi ulang kernel
anda dan mengaktifkan dukungan multicast.
</p>

</body>
</section>
<section>
<title>Instalasi sever DHCP</title>
<body>

<p>
Jika jaringan anda belum memiliki server DHCP, anda perlu menginstalnya:
</p>

<pre caption="Instalasi server dhcp">
# <i>emerge dhcp</i>
</pre>

<p>
Jika jaringan anda sudah memiliki server DHCP, anda perlu mengedit file
konfigurasinya agar PXE dapat boot dengan benar.
</p>

</body>
</section>
<section>
<title>Konfigurasi server DHCP</title>
<body>

<p>
Anda hanya perlu mengedit satu file konfigurasi sebelum menjalankan server
DHCP: <path>/etc/dhcp/dhcpd.conf</path>. Salin lalu edit contoh file
konfigurasi berikut ini:
</p>

<pre caption="Edit file konfigurasi server dhcp">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
Layout umum dari file ini telah di-set dengan gaya indent dan terlihat seperti
berikut:
</p>

<pre caption="Contoh layout dhcpd.conf">
<comment># opsi-opsi global di sini</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># opsi-opsi shared network di sini</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # opsi-opsi subnet network di sini</comment>
    host slave{
<comment>        # opsi-opsi khusus host di sini</comment>
    }
    group {
<comment>        # opsi-opsi khusus grup di sini</comment>
    }
}
}
</pre>

<p>
Blok <c>shared-network</c> hanyalah opsional dan digunakan untuk IP yang ingin
anda berikan kepada host di jaringan yang menggunakan topologi yang sama.
Paling tidak harus ada satu <c>subnet</c> yang ditentukan dan blok <c>group</c>
yang opsional dpat anda gunakan untuk mengelompokkan opsi-opsi di anatara
item-item. Contoh yang bagus dari <path>dhcpd.conf</path> terlihat seperti
berikut:
</p>

<pre caption="Contoh dhcpd.conf">
#
# contoh dhcpd.conf untuk klien diskless
#

ddns-update-style none;

# Dengan anggapan satu gateway sudah cukup untuk traffic IP
option routers 192.168.1.1;

# Memberikan info DNS ke klien
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";

# Menentukan server TFTP yang digunakan
next-server 192.168.1.1;

# Menentukan buffer opsi-opsi khusus vendor ke klien PXE:
# Code 1: Multicast IP address of boot file server
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of seconds a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of seconds a client must listen before trying to restart
#         a MTFTP transfer

option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;

# Menentukan subnet tempat node diskless berada
subnet 192.168.1.0 netmask 255.255.255.0 {

  # Memberikan info yang dibutuhkan untuk klien PXE
  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;

    # Paling tidak harus ada satu opsi khusus vendor PXE yang harus di-set agar
    # ROM boot klien tahu bahwa server ini mendukung PXE. Kita set alamat IP
    # MCAST ke 0.0.0.0 agar ROM tahu bahwa kita tidak dapat menyediakan TFTP
    # multicast

    option PXE.mtftp-ip 0.0.0.0;

    # Ini adalah nama file yang harus didownload oleh ROM boot
    filename "pxelinux.0";
  }

  # Menyediakan info yang diperlukan untuk klien etherboot
  class "etherboot" {
        match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
        filename "vmlinuz_arch";
  }

  # Menambahkan satu deklarasi host untuk setiap klien diskless
  host slave21 {
       hardware ethernet 00:02:A5:04:3B:66;
       fixed-address                    192.168.1.21;
  }
}
</pre>

<note>
Anda boleh menggunakan PXE dan Etherboot bersama-sama. Konfigurasi di atas
hanyalah sebuah contoh; jika anda mendapatkan masalah, bacalah dokumentasi
DHCPd.
</note>

<p>
Alamat IP setelah <c>next-server</c> akan ditanyakan untuk <c>filename</c>
yang ditentukan. Alamat IP ini harus merupakan IP server tftp, biasanya
alamat yang sama dengan alamat IP master. <c>filename</c> tergantung kepada
direktori <path>/diskless</path> (ini karena opsi-opsi server tftp yang akan
dijelaskan nanti). Di dalam blok <c>host</c>, opsi <c>hardware ethernet</c>
menentukan alamat MAC, dan <c>fixed-address</c> memberikan IP tetap ke alamat
MAC tersebut. Terdapat manual yang bagus <path>dhcpd.conf</path> berisi
opsi-opsi yang tidak dapat kami jelaskan di panduan ini. Anda dapat membacanya
dengan mengetikkan:
</p>

<pre caption="Membaca manual dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>
<section>
<title>Menjalankan server DHCP</title>
<body>

<p>
Sebelum anda menjalankan skrip inisialiasi dhcp, edit file
<path>/etc/conf.d/dhcp</path> agar menjadi seperti berikut ini:
</p>

<pre caption="Contoh /etc/conf.d/dhcp">
IFACE="eth0"
<comment># masukkan opsi-opsi lain yang diperlukan</comment>
</pre>

<p>
Variabel <c>IFACE</c> merupakan device yang ingin anda gunakan untuk menjalankan
server DHCP, pada contoh ini adalah <c>eth0</c>. Menambahkan argumen lain pada
variabel <c>IFACE</c> bisa berguna untuk topologi jaringan rumit dengan banyak
kartu jaringan. Untuk menjalankan server dhcp, ketik:
</p>

<pre caption="Menjalankan server dhcp pada master">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Untuk menambahkan server dhcp di skrip start-up, ketik:
</p>

<pre caption="Menambahkan server dhcp di runlevel default master">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>
<section>
<title>Mengatasi masalah server DHCP</title>
<body>

<p>
Untuk mengetahui apakah node telah boot, anda dapat melihat isi file
<path>/var/log/messages</path>. Jika node telah boot dengan sukses, file
<path>messages</path> akan berisi baris-baris seperti berikut ini:
</p>

<pre caption="Contoh entri file log yang diciptakan oleh dhcp">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
File log ini juga dapat membantu anda untuk mengetahui alamat MAC slave.
</note>

<p>
Jika anda mendapatkan pesan berikut, kemungkinan ada sesuatu yang salah dengan
file konfigurasi, tetapi server DHCP telah melakukan broadcast dengan benar.
</p>

<pre caption="contoh kesalahan server dhpc">
no free leases on subnet LOCAL-NET
</pre>

<p>
Setiap kali anda mengubah isi file konfigurasi, anda harus me-restart server
DHCP. Untuk me-restart-nya, ketik:
</p>

<pre caption="Me-estart server dhcp pada master">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Konfigurasi server TFTP dan Bootloader PXE Linux dan/atau Etherboot </title>
<section>
<title>Tentang server TFTP</title>
<body>

<p>
TFTP merupakan singkatan dari Trivial File Transfer Protocol. Sever TFTP akan
mensuplai kernel dan sistem dasar untuk slave. Semua kernel dan filesystem
slave disimpan di server TFTP, jadi sebaiknya anda menjadikan master sebagai
server TFTP.
</p>

</body>
</section>
<section>
<title>Instalasi server TFTP</title>
<body>

<p>
Server yang sangat dianjurkan penggunaanya tersedia pada paket tftp-hpa.
Server tftp ini kebetulan diciptakan oleh pencipta SYSLINUX dan dapat
bekerja sama dengan baik dengan pxelinux. Untuk menginstalnya, ketik:
</p>

<pre caption="Instalasi server tfp">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>
<section>
<title>Konfigurasi server TFTP</title>
<body>

<p>
Edit <path>/etc/conf.d/in.tftpd</path>. Anda perlu menentukan direktori
tftproot dengan variabel <c>INTFTPD_PATH</c> dan opsi-opsi perintah dengan
variabel <c>INTFTPD_OPTS</c>. Berikut ini merupakan contohnya:
</p>

<pre caption="Contoh /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
Opsi <c>-l</c> menyatakan bahwa server ini berjalan pada modus <e>stand
alone</e>, jadi anda tidak perlu menjalankan inetd. Opsi <c>-v</c> menyatakan
bahwa pesan-pesan log/error harus terinci. Opsi <c>-s /diskless</c> menentukan
root server tftp anda.
</p>

</body>
</section>
<section>
<title>Menjalankan Server TFTP</title>
<body>

<p>
Untuk menjalankan server tftp, ketik:
</p>

<pre caption="Menjalankan server tftp master">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Perintah tadi akan menjalankan server tftp dengan opsi-opsi yang telah anda
tentukan di <path>/etc/conf.d/in.tftpd</path>. Jika anda ingin agar server ini
dijalankan langsung ketika boot, ketik:
</p>

<pre caption="Menambahkan server tftp ke runlevel default master">
# <i>rc-update add in.tftpd default</i>
</pre>

</body>
</section>
<section>
<title>Tentang PXELINUX</title>
<body>

<p>
Seksi ini tidak diperlukan jika anda hanya menggunakan Etherboot. PXELINUX
adalah bootloader jaringan yang setara dengan LILO atau GRUB dan akan
dijalankan dengan bantuan TFTP. Paket ini pada dasarnya hanyalah kumpulan
instruksi-instruksi yang memberitahukan klien kemana mencari kernel dan
filesystem dasarnya serta dapat ditambahkan berbagai opsi-opsi kernel.
</p>

</body>
</section>
<section>
<title>Sebelum anda memulai</title>
<body>

<p>
Anda memerlukan file pxelinux.0 yang diikutsertakan pada paket SYSLINUX
ciptaan H. Peter Anvin. Anda dapat menginstal paket ini dengan mengetikkan:
</p>

<pre caption="Instalasi syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>
<section>
<title>Men-setup PXELINUX</title>
<body>

<note>
Seksi ini tidak diperlukan untuk Etherboot
</note>

<p>
Sebelum anda menjalankan server tftp anda, anda perlu men-setup pxelinux.
Pertama, salin binari pxelinux ke direktori <path>/diskless</path> anda:
</p>

<pre caption="Men-setup bootloader jaringan">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Perintah-perintah tersebut akan menciptakan file konfigurasi bootloader. Binari
<path>pxelinux.0</path> akan mencari file dengan nama alamat IP klien dalam
format heksadesimal di direktori <path>pxelinux.cfg</path>. Jika tidak ditemukan,
dijit paling akhir dari nama file akan dibuang lalu pencarian dilanjutkan sampai
semua dijit habis. Syslinux versi 2.05 dan yang lebih baru pertama-tama akan
melakukan pencarian untuk file dengan nama alamat MAC. Jika file ini tidak
ditemukan, metode pencarian dengan alamat IP dalam heksadesimal akan dilakukan.
Jika masih tidak ditemukan, maka file <path>default</path> akan digunakan.
</p>

<pre caption="Urutan file yang dicari oleh PXE di dalam direktori pxelinux.cfg/">
<comment>(01 di depan berarti Ethernet, byte selanjutnya sesuai dengan alamat MAC slave)</comment>
01-00-40-63-c2-ca-c9

<comment>(IP dalam hexadecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C

default
</pre>

<note>
Semua dengan huruf kecil.
</note>

<p>
Mari kita mulai dengan file <path>default</path>:
</p>

<pre caption="Contoh pxelinux.cfg/default">
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
Tag <c>DEFAULT</c> menunjukkan pxelinux ke kernel bzImage yang telah kita
kompilasi sebelumnya. Tag <c>APPEND</c> menambahkan opsi-opsi inisialisasi
kernel. Karena kita telah mengkompilasi kernel slave dengan opsi
<c>NFS_ROOT_SUPPORT</c>, kita perlu menentukan nfsroot di sini. IP pertama
adalah IP master, sedangkan IP kedua adalah direktori yang telah dibuat di
dalam <path>/diskless</path> untuk menyimpan filesystem dasar slave.
</p>

</body>
</section>

<section>
<title>Tentang Etherboot</title>
<body>

<note>
Seksi ini tidak diperlukan jika anda menggunakan boot PXE.
</note>

<p>
Etherboot mem-boot imej boot jaringan dari server TFTP. Seperti PXE, Etherboot
setara dengan LILO atau GRUB. Utilitas <c>mknbi</c> dapat membantu anda untuk
menciptakan imej-imej dengan opsi-opsi yang berbeda.
</p>

</body>
</section>
<section>
<title>Sebelum anda memulai</title>
<body>

<p>
Anda memerlukan paket <c>mknbi</c> (utilitas untuk menciptakan imej kernel yang telah
diberikan tag untuk digunakan boot jaringan) untuk menciptakan imej Etherboot anda.
Tool ini akan menciptakan imej kernel yang telah dikonfigurasi dari kernel asli anda.
Imej ini berisi opsi-opsi boot seperti yang tertera berikut:
</p>

<pre caption="Instalasi mknbi">
# <i>emerge mknbi</i>
</pre>

</body>
</section>
<section>
<title>Men-setup Etherboot</title>
<body>

<p>
Pada bagian ini kita akan menciptakan imej etherboot sederhana. Karena server
dhcp telah memberitahukan klien tentang root-path di "option root-path"
dhcp.conf, kita tidak perlu lagi memasukkannya di sini. Perinciannya bisa
anda dapatkan dari manual mknbi.
</p>

<pre caption="Manual mknbi">
# <i>man mknbi</i>
</pre>

<p>
Menciptakan imej boot. Perintah ini akan menciptakan imej bootable ELF yang
dapat menghantarkan dhcp dan rootpath ke kernel. Juga memaksa kernel untuk
mencari server dhcp di jaringan.
</p>

<pre caption="Menciptakan imej netboot">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Untuk imej khusus arch tertentu, anda perlu mengetikkan <c>bzImage_arch</c>
dan <c>vmlinuz_arch</c>.
</note>

</body>
</section>
<section>
<title>Mengatasi masalah pada proses boot jaringan</title>
<body>

<p>
Ada beberapa hal yang dapat anda lakukan untuk mengatasi masalah pada proses
boot jaringan. Pertama anda dapat menggunakan tool <c>tcpdump</c>. Untuk
menginstalnya, ketik:
</p>

<pre caption="Instalasi tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Sekarang anda dapat memperhatikan berbagai lalu-lintas jaringan dan pastikan
agar interaksi klien/server telah berfungsi. Jika ada sesuatu yang tidak
berfungsi, ada beberapa hal yang mungkin perlu anda periksa. Pertama pastika
agar klien dan server secara fisik telah terhubung dan kabel-kabel jaringan
tidak ada yang rusak. Jika klien/server anda tidak dapat menerima request pada
port tertentu, pastikan agar tidak ada rintangan firewall. Untuk melihat
interaksi antara dua komputer, ketik:
</p>

<pre caption="Melihat interaksi klien dan server dengan tcpdump">
# <i>tcpdump host </i><comment>client_ip</comment><i> and </i><comment>server_ip</comment>
</pre>

<p>
Anda juga dapat menggunakan <c>tcpdump</c> untuk melihat port tertentu seperti
port ftp dengan mengetikkan:
</p>

<pre caption="Mengawasi server tftp">
# <i>tcpdump port 69</i>
</pre>

<p>
Kesalahan umum yang mungkin akan anda dapatkan adalah: "PXE-E32: TFTP open
time-out". Ini kemungkinan disebabkan oleh firewall. Jika anda menggunakan
<c>TCPwrappers</c>, anda mungkin perlu memeriksa <path>/etc/hosts.allow</path>
dan <path>etc/hosts.deny</path> untuk memastikan agar konfigurasinya telah
benar. Klien harus diperbolehkan untuk terhubung ke server.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Konfigurasi server NFS</title>
<section>
<title>Tentang server NFS</title>
<body>

<p>
NFS adalah singkatan dari Network File System. Server NFS akan digunakan untuk
menyediakan direktori-direktori bagi slave. Bagian ini bisa anda utak-atik lagi
nantinya, tetapi untuk sekarang ini kita akan menyiapakan node slave dasar
untuk mem-boot diskless.
</p>

</body>
</section>
<section>
<title>Tentang Portmapper</title>
<body>

<p>
Banyak servis klien/server yang tidak menggunakan port tertentu, melainkan
bergantung pada RPC (Remote Procedure Calls). Ketika servis tersebut dijalankan
ia akan menggunakan sembarang port yang kemudian akan didaftarkan dengan
utilitas Portmapper. NFS bergantung pada RPC dan untuk itu memerlukan
Portmapper dijalankan sebelumnya.
</p>

</body>
</section>
<section>
<title>Sebelum anda mulai</title>
<body>

<p>
Server NFS memerlukan dukungan pada level kernel, jadi jika anda belum
mengkonfigurasinya, anda perlu mengkompilasi ulang kernel master anda. Untuk
memriksa kembali konfigurasi kernel anda, ketik:
</p>

<pre caption="Memeriksa opsi-opsi NFS tertentu">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
Anda seharusnya melihat output seperti ini jika kernel anda telah dikonfigurasi
dengan benar:
</p>

<pre caption="Opsi-opsi NFS yang telah dipilih dengan benar pada konfigurasi kernel master">
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>

</body>
</section>
<section>
<title>Instalasi server NFS</title>
<body>

<p>
Paket NFS bisa anda dapatkan dari portage dengan megetikkan:
</p>

<pre caption="Instalasi nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Paket ini akan meng-emerge utilitas portmap, server nfs dan utilitas klien nfs
serta dependensi dasarnya.
</p>

</body>
</section>
<section>
<title>Konfigurasi server NFS</title>
<body>

<p>
Ada tiga file konfigurasi utama yang perlu anda edit:
</p>

<pre caption="File konfigurasi NFS">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
File <path>/etc/exports</path> menentukan bagaimana, kemana, dan apa yang akan
diekspor melalui NFS. fstab slave akan diubah agar dapat me-mount filesystem
NFS yang diekspor oleh master.
</p>

<p>
File <path>/etc/exports</path> master biasanya berisi seperti berikut ini:
</p>

<pre caption="Contoh /etc/exports master">
<comment># satu baris seperti ini untuk setiap slave</comment>
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
<comment># untuk semua slave</comment>
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
<comment># jika anda ingin memiliki log gabungan</comment>
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>

<p>
Kolom pertama berisi direktori yang akan diekspor, dan kolom selanjutnya
berisi kemana dan bagaimana. Kolom ini dapat dibagi dua: komputer mana saja
yang boleh me-mount direktori tertentu, dan apa yang dapat dilakukan oleh
klien terhadap filesystem yang di-mount tersebut: <c>ro</c> untuk <e>read
only</e>, <c>rw</c> untuk <e>read/write</e>; <c>no_root_squash</c> dan
<c>no_all_squash</c> sangat penting untuk klien diskless karena penulisan ke
disk diperlukan, jadi klien-klien ini tidak di-"squash" ketika melakukan
request I/O. Berikut ini contoh file fstab slave
<path>/diskless/192.168.1.21/etc/fstab</path>.
</p>

<pre caption="Contoh fstab slave">
<comment># entri-entri ini wajib</comment>
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># useful but superfluous</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
</pre>

<p>
Pada contoh ini, <e>master</e> hanyalah nama host dari master, tetapi bisa juga
berupa alamat IP master. Kolom pertama mencantumkan direktori yang akan di-mount
dan kolom kedua berisi mount point. Kolom ketiga mencantumkan filesystem dan
harus diisi dengan NFS untuk semua direktori NFS yang di-mount. Kolom keempat
mencantumkan berbagai opsi yang akan digunakan ketika proses mount berlangsung
(baca manual mount(1) untuk mengetahui opsi-opsi mount). Dilaporkan adanya
masalah dengan <e>soft mount point</e> untuk itu di sini kami menciptakan
<e>hard mount point</e>, namun anda perlu mengetahui opsi-opsi
<path>/etc/fstab</path> agar cluster anda lebih efisien.
</p>

<p>
File terakhir yang perlu anda edit adalah <path>/etc/conf.d/nfs</path> yang
berisi beberapa opsi untuk NFS ketika diinisialisasi, isinya seperti berikut:
</p>

<pre caption="Contoh /etc/conf.d/nfs master">
# Config file for /etc/init.d/nfs

# Jumlah server yang akan dijalankan secara default
RPCNFSDCOUNT=8

# Opsi-opsi yag akan diberikan ke rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Anda perlu mengganti <c>RPCNFSDCOUNT</c> dengan jumlah node diskless yang ada
di jaringan.
</p>

</body>
</section>
<section>
<title>Menjalankan server NFS</title>
<body>

<p>
Anda perlu menjalankan server NFS dengan skrip initnya yang ada di
<path>/etc/init.d</path> dengan mengetikkan:
</p>

<pre caption="Menjalankan server NFS master">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Jika anda ingin agar skrip ini dijalankan ketika sistem anda bot:
</p>

<pre caption="Menambahkan server nfs ke runlevel default master">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Melengkapi filesystem slave</title>
<section>
<title>Menyalin file-file</title>
<body>

<p>
Sekarang kita akan mengsinkronkan filesystem slave dengan filesystem master
dan menyediakan binari-binari yang diperlukan namun tetap menjaga file-file
khusus slave.
</p>

<pre caption="Menciptakan filesystem slave">
# <i>rsync -avz /bin /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib /diskless/192.168.1.21</i>
</pre>

<note>
Alasan penggunaan rsync -avz dan bukan cp adalah untuk memelihara symlink
dan perizinan
</note>

</body>
</section>
<section>
<title>Konfigurasi jaringan diskless</title>
<body>

<p>
Agar skrip init jaringan tidak menghentikan koneksi ke server NFS, anda perlu
menambahkan sebuah opsi di <path>/etc/conf.d/net</path> pada klien diskless.
</p>

<pre caption="Edit /etc/conf.d/net">
<comment>(Tambahkan baris ini)</comment>
config_eth0=( "noop" )
</pre>

<note>
Untuk informasi lebih lanjut, bacalah <path>/etc/conf.d/net.example</path>.
</note>

</body>
</section>
<section>
<title>Skrip-skrip inisialisasi</title>
<body>

<p>
Anda membutuhkan skrip-skrip init di
<path>/diskless/192.168.1.21/etc/runlevels</path> sebanyak skrip init yang
anda butuhkan di node diskless. Namun semuanya tergantung pada apa yang
ingin anda tugaskan pada slave.
</p>

<warn>
Jangan gunakan program <c>rc-update</c> untuk menambah atau menghapus skrip
dari runlevel slave ketika anda sedang login di master karena dapat mengubah
runlevel master. Anda perlu menciptakan sendiri link-link yang dibutuhkan
atau dengan login ke node slave melalui ssh atau memasang monitor dan keyboard
ke slave.
</warn>

<pre caption="Contoh runlevel slave">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single

/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom

/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron

/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local

/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
Sekarang adalah saatnya untuk mem-boot slave anda. Berhasilkah? Selamat,
sekarang anda telah menjadi pemilik node diskless! :)
</p>

</body>
</section>

<!--

<section>
<title>An alternative : ClusterNFS</title>
<body>

<warn>
This is mentioned only because a reviewer of this document is using this
solution. Be aware that Gentoo <e>does not</e> support ClusterNFS. It is not in
portage and requires changes to a baselayout init script. <b>Use at your own
risks</b>.
</warn>

<p>
If you don't fancy having a distinct root for each slave because it needs some
maintenance when upgrading files from the master directories, you could share
the same root across all nodes, master and slaves included. This means all your
machines need to be compatible because you will have only one set of binaries.
You also need to be aware that this might have security issues because all of
your master root will be exported through NFS.
</p>

<p>
If you still want to try out this alternative, visit the ClusterNFS <uri
link="http://clusternfs.sourceforge.net/">home page</uri>, download the
software and read the doc.
</p>

<p>
To make it short, all files are shared and the files that need to be different
between master and all slaves are copied to <path>file$$CLIENT$$</path>. When a
slave requests <path>file</path>, ClusterNFS will notice the existence of
<path>file$$CLIENT$$</path> and send it instead. Files that need to be
different on each node are copied to <path>file$$IP=192.168.1.21$$</path>.
The same applies to directories.
</p>

<p>
Very shortly, this is what differs from the installation procedure described
above:
</p>

<ul>
  <li>You do not need NFS server support in your master kernel</li>
  <li>Install ClusterNFS <e>after</e> you emerge nfs-utils</li>
  <li>Make slave copies of files and directories as described below</li>
  <li>Do not create a root dir for each node</li>
  <li>Export only / in your <path>/etc/exports</path> file</li>
  <li>
    Only mount / via NFS in the slave <path>/etc/fstab$$CLIENT$$</path> file
  </li>
  <li>Edit <path>/etc/init.d/nfs</path> as described below</li>
  <li>
    Edit <path>/etc/conf.d/local.start$$CLIENT$$</path> as described below
  </li>
</ul>

<pre caption="Files that need to be different between master and slaves">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Probably empty)</comment>
/etc/crontab$$CLIENT$$<comment> (Probably empty, master takes care of chores)</comment>
/etc/exports$$CLIENT$$<comment> (Empty, slaves do not export NFS mounts)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Name your slaves)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Clean separation between master and slave boot scripts)</comment>
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Create subdirs as in /var)</comment>
</pre>

<pre caption="Editing /etc/init.d/nfs">
        ebegin "Starting NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Add - -translate-names option</comment>
                $nfsd - - - -translate-names
        eend $? "Error starting NFS daemon"
         # Check if we support NFSv3
        ebegin "Starting NFS mountd"
<comment># Comment the following two lines (ClusterNFS only knows NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Error starting NFS mountd"
</pre>

</body>
</section>
-->
</chapter>

</guide>
