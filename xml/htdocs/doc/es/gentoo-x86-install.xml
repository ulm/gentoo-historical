<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/es/gentoo-x86-install.xml">
  <title>Instrucciones de instalación para Gentoo Linux 1.4</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">
    <mail link="jerry@gentoo.org">Jerry Alexandratos</mail>
  </author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Editor">
    <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
  <author title="Reviewer">
    <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
  </author>
  <abstract>Estas instrucciones te guiarán a través del proceso de instalación de Gentoo Linux 1.4. El proceso de instalación de Gentoo Linux soporta varias modalidades, dependiendo de qué partes del sistema quieres crear desde cero.
  </abstract>
  <version>2.3.8</version>
  <date>28 de Julio del 2003</date>
  <chapter>
    <title>Acerca de la instalación</title>
    <section>
      <body>
        <p>Este nuevo CD de arranque debe funcionar en la mayoría de las unidades CD-ROM IDE modernas, así como en las unidades CD-ROM SCSI, asumiendo que tanto el CD-ROM como la BIOS soportan este tipo de arranque. En el CD-ROM está incluido el soporte Linux de IDE (y PCI IDE) (compilados en el kernel) así como soporte para todos los dispositivos SCSI (disponible como módulos). Además, proporcionamos modulos para, literalmente todo tipo de tarjetas de red que Linux soporta, así como herramientas para que te ayuden a configurar la red y establecer tráfico externo (e interno) para el uso de <c>ssh</c> y descarga de archivos.
        </p>
        <p>Para instalar desde el CD, necesitas tener un procesador 486+ y al menos 64 Megabytes de RAM. (Gentoo linux ha sido instalado exitosamente con 64MB de RAM + 64MB de swap, pero el proceso de instalación es horriblemente lento en estas condiciones.)
        </p>
        <p>Gentoo Linux puede ser instalado usando uno de estos tres tarball (archivo comprimido) de &quot;stage&quot;. El que eligas dependerá de cuántas partes del sistema quieres compilar tu mismo. El tarball del stage1 es usado cuando se quiere construir todo el sistema desde cero. El tarball del stage2 es usado para construir el sistema completo desde cero menos la parte del bootstrap que ha sido creada para ti. Y el tarball del stage3 contiene un sistema básico Gentoo Linux optimizado para el CPU de tu ordenador.
        </p>
        <p> Entonces, ¿cómo se comienza con el sistema de instalación? Primero, debes decidir cual de nuestras imágenes ISO del livecd vas a usar. Puedes encontrarlas en: <uri>http://www.ibiblio.org/gentoo/releases/1.4_rc2/x86/</uri>. En este directorio verás subdirectorios, como por ejemplo <c>athlon</c>, para cada una de las arquitecturas específicas que hemos preparado. A continuación puedes ver el arbol de directorio y su contenido:
        </p>
        <table>
          <tr>
            <th>Arquitectura</th>
            <th>Descripción</th>
          </tr>
          <tr>
            <ti>x86</ti>
            <ti>Stage 1 y &quot;gentoo-basic&quot; livecd -- funcionará para cualquier procesador x86.</ti>
          </tr>
          <tr>
            <ti>i586</ti>
            <ti>Stage 2 y 3, paquetes GRP y livecd para i586+ </ti>
          </tr>
          <tr>
            <ti>i686</ti>
            <ti>Stage 2 y 3 , paquetes GRP y livecd para i686+ </ti>
          </tr>
          <tr>
            <ti>athlon</ti>
            <ti>Stage 2 y 3 , paquetes GRP y livecd para AMD Athlon </ti>
          </tr>
          <tr>
            <ti>athlon-xp</ti>
            <ti>Stage 2 y 3 , paquetes GRP y livecd para AMD Athlon XP </ti>
          </tr>
          <tr>
            <ti>athlon-mp</ti>
            <ti>Stage 2 y 3 , paquetes GRP y livecd para AMD Athlon MP </ti>
          </tr>
          <tr>
            <ti>pentium3</ti>
            <ti>Stage 2 y 3 , paquetes GRP y livecd para Intel Pentium III y Pentium 4 </ti>
          </tr>
        </table>
        <p>Dentro de cada uno de estos directorios, encontrarás un directorio <path>livecd/</path> que contiene livecds. Realmente los livecds iniciarán en cualquier arquitectura, pero los tarballs para la instalación están optimizados para cada tipo de CPU y no funcionarán en el resto de CPUs, exceptuando el livecd &quot;gentoo-basic&quot; que se encuentra en el directorio <path>x86</path> que puede ser usado para instalar en cualquier sistema.
        </p>
        <p>Los livecds son imágenes completas que deben ser grabadas en un CDR o CD-RW usando algún software de grabación. Actualmente, tenemos 2 tipos de livecds. El primer tipo es el llamado &quot;gentoo-basic&quot;, y ocupa aproximadamente 40MB y se encuentra en el directorio <path>x86/livecd/</path>. Este livecd tiene un tamaño mínimo que permite una descarga rápida y contiene un tarball del stage1 que se puede encontrar en <path>/mnt/cdrom/gentoo/</path> una vez el CD se inicie.
        </p>
        <p>El segundo sabor de livecd que actualmente ofrecemos se llama &quot;livecd-grp.&quot;
Estos CDs (que se encuentran en sus respectivos directorios <path>arch/livecd</path> )contienen los stage1, 2 y 3, y también contienen un conjunto de paquetes GRP optimizados para una arquitectura específica. Usando estos livecds, es posible instalar un sistema Gentoo Linux completamente funcional muy rápidamente. Descargas estas imágenes ISO lleva más tiempo --alrededor de 600MB-- por lo que pueden tardar un rato en descargarse.
        </p>
        <info>Si por cualquier razón tu instalación se interrumpe en algun punto, puedes reiniciar y volver a empezar donde te quedaste. Por ejemplo, si has particionado, instalado el stageX, y estas preparado para hacer el chroot, puedes volver a hacer todos los pasos desde el principio, o proseguir donde te quedaste. Solo reinicia con el livecd, monta tus particiones <path>/mnt</path> como normalmente. Básicamente puedes hacer esto en cualquier punto de la instalación, excepto antes de la partición por razones obvias.
        </info>
        <warn>Si encuentras algún problema con algun aparte de la instalación y quieres reportarlo como un bug (fallo), usa <uri>http://bugs.gentoo.org</uri>. Si el bug necesita que sea dirigido a una sección concreta (por ejemplo KDE) los <e>desarrolladores</e> se encargarán de hacerlo.
        </warn>
        <p>Ahora, demos un rápido vistazo al proceso de instalación. Primero, descargaremos, quemaremos y arrancaremos con un livecd. Tras tener el prompt de root, crearemos particiones, los sistemas de archivos, y extraeremos el stage1, stage2 o stage3. Si estamos usando el stage1 o stage2, daremos los pasos necesarios para llegar al stage3. Una vez que nuestro sistema este en el stage3, podremos configurar el sistema (editando los archivos de configuración, instalando un gestor de arranque, etc) y entonces reiniciaremos y tendremos un sistema Gentoo Linux completamente funcional. Dependiendo en que stage comienzes, esto es lo que necesitas para la instalación:
        </p>
        <table>
          <tr>
            <th>stage tarball</th>
            <th>requerimientos para la instalación</th>
          </tr>
          <tr>
            <ti>1</ti>
            <ti>partición/configuración del sistema de archivo, emerge sync, bootstrap, emerge system, emerge fuentes linux, configuración final</ti>
          </tr>
          <tr>
            <ti>2</ti>
            <ti>partición/configuración del sistema de archivo, emerge sync, emerge system, emerge fuentes linux, configuración final</ti>
          </tr>
          <tr>
            <ti>3</ti>
            <ti>partición/configuración del sistema de archivo, emerge sync, configuración final</ti>
          </tr>
        </table>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Arrancando</title>
    <section>
      <body>
        <p>Comienza arrancando el livecd. Si es detectado correctamente, podrás ver una bonita pantalla de inicio con el logo de Gentoo Linux. En esta pantalla, puedes pulsar Intro para comenzar el proceso de inicio, pulsar F2 para ayuda, o pasar opciones de inicio al kernel escribiendo <c>gentoo opt1 opt2</c>, etc. Una vez que pulses Intro, serás recibido con un monton de texto, seguido por la usual secuencia de arranque de Gentoo Linux. Serás automáticamente logueado en el sistema como &quot;root&quot; y la contraseña de root será establecida por una secuencia al azar por razones de seguridad. Ahora deberías tener un prompt de root (&quot;<c>#</c>&quot;) en la consola actual, e incluso puedes abrir nuevas consolas presionando Alt-F2, Alt-F3 y Alt-F4. Vuelve a la consola del principio presionando Alt-F1.
        </p>
        <p>Probablemente te habrás percatado de que encima de tu prompt <c>#</c> tienes un texto de ayuda explicando cÃ³mo hacer cosas como configurar tus tarjetas de red y dÃ³nde puedes encontrar el tarball del stage de Gentoo Linux y los paquetes en tu CD.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Cargando los módulos del Kernel</title>
    <section>
      <body>
        <p>Si la autodetección PCI no encuentra algo de tu hardware, tendrás que cargar los módulos apropiados manualmente. Para ver una lista de todos los módulos disponibles para tarjetas de red, escribe <c>ls /lib/modules/*/kernel/drivers/net/*</c>. Para cargar un módulo en concreto, escribe:
        </p>
        <pre caption="Configuración de Módulos PCI">
# <c>modprobe pcnet32</c>
<comment>(en lugar de pcnet32, pon el nombre de tu módulo)</comment>
        </pre>
        <p>Ahora, si quieres tener acceso a algún hardware SCSI que no fue detectado durante la autodetección del arranque, necesitas cargar el módulo adecuado de /lib/modules, de nuevo usando <c>modprobe</c>:
        </p>
        <pre caption="Cargando Módulos SCSI">
# <c>modprobe aic7xxx</c>
# <c>modprobe sd_mod</c>
        </pre>
        <p><c>aic7xxx</c> es para tu controladora SCSI y <c>sd_mod</c> para tus discos duros SCSI.
        <note>
        El soporte para CD-ROMs SCSI y discos estan compilados en el kernel.
        </note>
        </p>
        <p>si estas usando hardware RAID, necesitarás cargar los módulos ATA-RAID para tu controladora RAID.
        </p>
        <pre caption="Cargando Módulos RAID">    
# <c>modprobe ataraid</c>    
# <c>modprobe pdcraid</c>            
      <comment>(Controladora Raid Promise)</comment>    
# <c>modprobe hptraid</c>            
      <comment>(Controladora Raid Highpoint)</comment>    
        </pre>
        <p>El livecd de Gentoo debe haber activado el DMA en tus discos, pero si no lo ha hecho, <c>hdparm</c> puede ser usado para habilitar el DMA en tus dispositivos.
        </p>
        <pre caption="Habilitando DMA"><comment>Reemplazar hdX con tu dispositivo de disco.</comment>
# hdparm -d 1 /dev/hdX <comment>Habilita DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 <comment>Habilita DMA y opciones seguras de optimización</comment>
# hdparm -X66 /dev/hdX <comment>Fuerza Ultra-DMA -- peligroso -- puede causar que algunos dispositivos dejen de funcionar</comment></pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Cargando Módulos PCMCIA en el Kernel</title>
    <section>
      <body>
        <p>Si tienes una tarjeta de red PCMCIA, necesitarás hacer un par de cosas adicionales.
        </p>
        <warn>Para evitar problemas con <c>cardmgr</c>, <e>debes</e> ejecutarlo <e>antes</e> de entrar en el chroot.</warn>
        <pre caption="Cargando Módulos PCMCIA">
# <i>modprobe pcmcia_core</i>
# <i>modprobe i82365</i>
# <i>modprobe ds</i>
# <i>cardmgr -f</i>
        </pre>
        <p>Cuando <c>cardmgr</c> detecte qué hardware esta presente, tu altavoz debe emitir unos pocos beeps, y tu tarjeta de red PCMCIA debe vivir. Por supuesto que puedes insertar la tarjeta PCMCIA despues de cargar <c>cardmgr</c>, si lo prefieres. (Teóricamente, no necesitas ejecutar <c>cardmgr</c> si sabes exactamente los módulos que necesita tu tarjeta PCMCIA. Puedes probar a cargar todos los módulos para ver cual de ellos no funciona en absoluto hasta encontrar los adecuados. <c>cardmgr</c> también debe descargar los módulos de tu tarjeta cuando la quites).
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configurando la Red</title>
    <section>
      <title> Configuración de PPPoE</title>
      <body>
        <p>Asumiendo que necesitas PPPoE para conectarte a internet, el livecd (cualquier versión) te pone las cosas fácil incluyendo <c>rp-pppoe</c>. Usa el script <c>adsl-setup</c> para configurar tu conexión. Serás preguntado por tu dispositivo de red que se conecta a tu modem adsl, por tu nombre de usuario y por la contraseña, también por las IPs de tus servidores DNS, y si necesitas cortafuego básico o no.
        </p>
        <pre caption="Configurando PPPoE">
# <c> adsl-setup </c>
# <c> adsl-start </c>
        </pre>
        <p>Si algo va mal, comprueba bien tu nombre de usuario y la contraseña mirándolo en <path>/etc/ppp/pap-secrets</path> o en <path>/etc/ppp/chap-secrets</path>, y asegúrate de estar usando el dispositivo de red correcto.
        </p>
      </body>
    </section>
    <section>
      <title> Configuración automática de la Red</title>
      <body>
        <p>La instalación de Gentoo Linux te permite configurar una red funcional, permitiéndote usar <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> o <c>wget</c> que será necesitado antes incluso de comenzar el proceso de instalación. Incluso si no necesitas estas utilidades ahora deberás continuar y configurar la red. Una vez que la red este levantada, Portage será capaz de usar esta una vez estes en el chroot (requerido para instalar Gentoo Linux). La manera más simple para configurar la red, es ejecutar nuestro nuevo script <c>net-setup</c>.
        </p>
        <pre caption="Script Net-Setup">
# <c>net-setup eth0</c>
		</pre>
        <p>Por supuesto. si lo prefieres, puedes seguir configurando la red manualmente.
        </p>
      </body>
    </section>
    <section>
      <title>Configuración Manual del DHCP</title>
      <body>
        <p>Configurar la red es muy simple usando DHCP; si tu ISP no usa DHCP, sáltate esta parte y ve a la configuración estática más abajo.
        </p>
        <pre caption="Configurando la Red con DHCP">
# <c>dhcpcd eth0</c> 
        </pre>
        <note>Algunos ISP necesitan que proporciones el hostname (nombre del host). Para hacer esto, añada la variable <c>-h myhostname</c> al comando dhcpcd.
        </note>
        <p>Si recibes avisos de <i>dhcpConfig</i>, no te asustes; los errores son mayormente cosméticos. Sáltate la siguiente sección hasta la prueba de la Red.
        </p>
      </body>
    </section>
    <section>
      <title>Configuración Estática manual</title>
      <body>
        <p>Necesitamos configurar la red solo lo suficiente para poder descargar las fuentes para cosntruir el sistema, así como la interfaz local. Escribe los siguientes comandos reemplazando $IFACE con tu interfaz de red (normalmentetyp <c>eth0</c>), $IPNUM con tu dirección IP, $BCAST con tu direcciÃ³n broadcast, y $NMASK con tu máscara de red. En el comando <c>route</c>, reemplaza $GTWAY con tu puerta de enlace por defecto gateway.
        </p>
        <pre caption="Configuración de una red con IP estática">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</c>
        </pre>
        <p>Ahora es el momento de crear el archivo <path>/etc/resolv.conf</path> para que la resolución de nombres funcione (pudiendo buscar sitios Web/FTP por nombre, es mejor que tener que escribir el número IP).
        </p>
        <p>Aquí tienes una plantilla para crear tu archivo /etc/resolv.conf:
        </p>
        <pre caption="Plantilla /etc/resolv.conf">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
        </pre>
        <p>Reemplaza <c>10.0.0.1</c> y <c>10.0.0.2</c> con las direcciones IP de tu servidor DNS primario y secundario respectivamente.
        </p>
      </body>
    </section>
    <section>
      <title>Configuración del Proxy</title>
      <body>
        <p>Si estás detrás un proxy, es necesario que lo configures para poder continuar. Vamos a  exportar algunas variables de entorno para configurarlo.
        </p>
        <pre caption="Configurando un Proxy">
# <c>export http_proxy=&quot;equipo.company.com:1234&quot; </c>
# <c>export ftp_proxy=&quot;$HTTP_PROXY&quot; </c>
# <c>export RSYNC_PROXY=&quot;$HTTP_PROXY&quot; </c>
        </pre>
      </body>
    </section>
    <section>
      <title>Probando La Red</title>
      <body>
        <p>Ahora que la red ha sido configurada, el comando <c>/sbin/ifconfig -a</c> debe mostrar que tu tarjeta de red esta funcionando (busca <e>UP</e> y <e>RUNNING</e> en la salida).
        </p>
        <pre caption="/sbin/ifconfig Una tarjeta de red funcionando">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
        </pre>
        <p>Si quieres puedes probar a hacer ping a los servidores DNS de tu ISP (que están en <path>/etc/resolv.conf</path>), y a una web de tu elección, sÃ³lo para asegurarte de que la resolución de nombre funciona correctamente, que tus paquetes viajan a través de la red, etc.
        </p>
        <pre caption="Seguimos Probando la red">
# <c>ping www.redisirs.es </c>
        </pre>
      </body>
    </section>
    <section>
      <title>¡La Red va!</title>
      <body>
        <p>La red debe estar ahora configurada y debe ser usable. Deberías poder usar <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> y <c>wget</c> comandos para conectar a otras máquinas en tu  LAN o en Internet.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configuración de las Particiones</title>
    <section>
      <body>
        <p>Ahora que el kernel puede ver la tarjeta de red y el controlador de discos, es el momento de crear las particiones para Gentoo Linux.
        </p>
        <p>Esto es un vistazo rápido a la forma estándar de particiones en Gentoo Linux. Vamos a crear al menos tres particiones: una partición swap, una partición root (para guardar la base de Gentoo Linux), y una partición de arranque especial (boot). La partición boot esta diseñada para guardar la información de los gestores de arranque grub o LILO, así como tu kernel Linux. La partición boot nos proporciona un lugar seguro donde guardar todo lo necesario para iniciar Linux. Para un uso de Gentoo Linux de diario, tu partición boot debe permanecer <e>desmontada</e>. Esto previene que tu kernel se vuelva inaccesible para grub (debido a la corrupción del sistema de archivos) en el caso de que el sistema falle, previniendo el problema del huevo y la gallina cuando grub no puede leer tu kernel (dado que el sistema de archivos puede no ser consistente) pero no puedes reparar tu sistema de archivos (¡porque no puedes iniciar!)
        </p>
        <p>Ahora, vamos con los tipos de sistemas de archivos. Actualmente tienes cuatro opciones donde elegir: XFS, ext2, ext3 (journaling) y ReiserFS. ext2 es el auténtico y probado sistema de archivos de Linux pero no tiene metadata journaling. ext3 es la nueva versión de ext2 pero con metadata journaling y escritura de datos ordenada, efectivemente también tiene data journaling. ReiserFS está basado en B*-tree esto da un gran rendimiento para archivos pequeños, y gratamente supera tanto a ext2 como ext3 en el trato con archivos pequeños (archivos menores de 4k), a menudo entre 10 y 15 veces más. ReiserFS también escala extremadamente bien y tiene metadata journaling. A partir del kernel 2.4.18+, ReiserFS es finalmente muy solido y altamente recomendable. XFS es un sistema de ficheros con metadata journaling que está completamente soportado en el kernel de Gentoo Linux <path>xfs-sources</path>, pero generalmente no se recomienda por su tendencia para perder datos recientemente modificados si tu sistema cierra o reinicia inesperadamente (lo mismo pasa con un fallo de energía).
        </p>
        <p>Si estás buscando el sistema de archivos más estándar, usa ext2. Si estás buscando para el sistema de archivos con journaling más cutre, usa ext3. Si lo que quieres es un sistema de archivos con alto rendimiento, y con journaling, usa ReiserFS; tanto ext3 y ReiserFS están maduros y refinados. Aquí está nuestras recomendaciones básicas para tipos y tamaños de sistemas de archivos:
        </p>
        <table>
          <tr>
            <th>Partición</th>
            <th>Tamaño</th>
            <th>Tipo</th>
            <th>dispositivo de ejemplo</th>
          </tr>
          <tr>
            <ti>partición boot, containing kernel(s) e información para el inicio</ti>
            <ti>100 Megabytes</ti>
            <ti>ext2/3 altamente recomendables (más sencillo); si usas ReiserFS recuerda montar con la opción <c>-o notail</c></ti>
            <ti>/dev/hda1</ti>
          </tr>
          <tr>
            <ti>partición swap (ya no tiene límite de tamaño en 128 Megabyte)</ti>
            <ti>&gt;=2*Cantidad de RAM en el sistema es lo recomendado, pero no requerido (desde el kernel 2.4.10)</ti>
            <ti>Linux swap</ti>
            <ti>/dev/hda2</ti>
          </tr>
          <tr>
            <ti>partición raíz, conteniendo el sistema de archivos principal (/usr, /home, etc)</ti>
            <ti>&gt;=1.5 Gigabytes</ti>
            <ti>ReiserFS, ext3 recomendado; ext2 vale</ti>
            <ti>/dev/hda3</ti>
          </tr>
        </table>
        <p>Antes de crear el sistema de archivos, puedes querer inicializar el principio de tu disco duro (HD) usando <c>dd</c>. Haciéndolo te asegurarás que tu nuevo sistema de archivos no será mal identificado por el código de montaje de Linux. Se puede hacer así:
        </p>
        <pre caption="Inicializando los primeros 1024 sectores del HD">
# <c>dd if=/dev/zero of=/dev/hdxy bs=1K count=1</c>
<comment>Reemplaza /dev/hdxy con el dispositivo que deseas &quot;limpiar.&quot;</comment>
        </pre>
        <p>En este punto, crea tus particiones usando <c>fdisk</c>. Date cuenta de que tu partición debe de ser del tipo 82 para swap y 83 para los sistemas de archivos usuales (cualquiera que sea ReiserFS, ext2/3 u otro).
        </p>
        <note><c>cfdisk</c> está incluido en el CD de instalación, y es <i>considerablemente</i> más fácil de usar que <c>fdisk</c>. Tan solo escribe <c>cfdisk</c> para ejecutarlo; por defecto, cfdisk trabajará con <b>/dev/hda</b>. si /dev/hda es el disco duro que quieres particionar, dale a cfdisk el valor adecuado. Por ejemplo: <c>cfdisk /dev/hde</c>
        </note>
        <note>si <c>fdisk</c> o <c>cfdisk</c> te dicen que lo hagas, por favor reinicia para permitir que tu sistema detecte la nueva tabla de particiones.
        </note>
        <note>Si estás usando RAID tus particiones serán un poco diferentes. Tendrás particiones como éstas: <path>/dev/ataraid/discX/partY</path> X es el array que has hecho, pero si solo tienes hecho 1 array, entonces debe de ser disc0. Y es el número de la partición como en <path>/dev/hdaY</path>
        </note>
        <p>Una vez que hayas creado tus particiones, Es el momento para inicializar el sistema de archivos que será usado para almacenar nuestros datos. Inicializa la swap de la siguiente manera:
        </p>
        <pre caption="Inicializando la Swap">
# <c>mkswap /dev/hda2</c>
        </pre>
        <p>Puedes usar el comando <c>mke2fs</c> para crear el sistema de archivos ext2.</p>
        <pre caption="Creando un sistema de archivos ext2">
# <i>mke2fs /dev/hda1</i>
        </pre>
        <p>Para crear un sistema de archivos XFS, usa el comando <c>mkfs.xfs</c>.</p>
        <pre caption="Creando un sistema de archivos XFS">
# <c>mkfs.xfs /dev/hda3</c>
        </pre>
        <note>
    Tu puedes querer añadir un par de parámetros adicionales al comando <c>mkfs.xfs</c>: <c>-d agcount=3 -l size=32m</c>. El parámetro <c>-d agcount=3</c> bajará el número de grupos localizados. XFS debe insistir en usar al menos 1 grupo localizado por cada 4 GB de tu partición, por ejemplo, si tu tienes una partición de 20 GB necesitarás como mínimo un agcount de 5. El parámetro <c>-l size=32m</c> aumenta el tamaño del journal a 32 Mb, aumentando el rendimiento.
        </note>
        <warn>
Si estás instalando una partición XFS sobre una partición que anteriormente era ReiserFS,
más tarde puede fallar al montarla si no especificas <c>mount -t xfs</c>. La solución es llenar de ceros antes de crear el sistema XFS: <c>dd if=/dev/zero of=/dev/hd<comment>x</comment> bs=1k</c>. 
        </warn>
        <p>Si quieres usar ext3, puedes crear el sistema de archivos con <c>mke2fs -j</c>.</p>
        <pre caption="Creando un sistema de archivos ext3">
# <c>mke2fs -j /dev/hda3</c>
        </pre>
        <note>Puedes encontrar más información acerca del uso de ext3 bajo Linux 2.4 en
    <uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
        </note>
        <p>Para crear un sistema de archivos ReiserFS, usa el comando <c>mkreiserfs</c>.</p>
        <pre caption="Creando un sistema de archivos ReiserFS">
# <c>mkreiserfs /dev/hda3</c>
        </pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Montando Particiones</title>
    <section>
      <body>
        <p>Ahora, vamos a activar nuestra nueva swap, ya que podríamos necesitar la memoria virtual adicional que proporciona más tarde:
        </p>
        <pre caption="Activando la Swap">
# <c>swapon /dev/hda2</c>
        </pre>
        <p>Lo próximo será crear los puntos de montaje <path>/mnt/gentoo</path> y <path>/mnt/gentoo/boot</path>, y montaremos nuestros sistemas de archivos en estos puntos.
        </p>
        <pre caption="Creando Puntos de Montaje">
# <c>mkdir /mnt/gentoo</c>
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
        </pre>
        <p>
        Si estás configurando Gentoo Linux con el <path>/usr</path> o el <path>/var</path>, debes montarlos en <path>/mnt/gentoo/usr</path> y en <path>/mnt/gentoo/var</path>, respectivamente.
        </p>
                <impo>Si tu partición <e>boot</e> (la que contiene el kernel) es ReiserFS, asegúrate de usar la opción <c>-o notail</c> para montarla para que grub se instale correctamente. Asegúrate de usar <c>notail</c> en tu <path>/etc/fstab</path> también.
                </impo>
        <impo>Si estás teniendo problemas montando tu partición boot con ext2, prueba usando <c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>
        </impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Obteniendo el tarball del 'stage-x' deseado</title>
    <section>
      <body>
        <p>Si quieres empezar desde el tarball stage1, entonces ya estas listo para hacerlo; puedes encontrar el tarball del stage1 en <path>/mnt/cdrom/gentoo/</path>. Por otra parte, si prefieres empezar con el tarball de stage2 o stage3 que han sido optimizados para tu arquitectura puedes descargarlos (dentro de <path>/mnt/gentoo</path> sería lo más simple) de uno de nuestros servidores espejo de Gentoo.
        </p>
        <pre caption="Descargando los Stages necesarios">
# <c>cd /mnt/gentoo</c>
<comment>Usa lynx para tomar la URL de tu tarball</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc2/x86/</c>
# <c>wget <comment>pon aquí la url del tarball que quieres.</comment></c>
        </pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Desempaquetando el tarball del Stage</title>
    <section>
      <body>
        <p>Ahora es momento de extraer el archivo comprimido del stage que has elegido en <path>/mnt/gentoo</path>. Entonces, podremos hacer <c>chroot</c> en la instalación de Gentoo Linux para poder &quot;entrar&quot; en el nuevo sistema Gentoo Linux.
        </p>
        <impo>Asegúrate que usas la opción <c>p</c> en el comando <c>tar</c>. Si te olvidas de hacerlo algunos archivos tendrán permisos incorrectos.
        </impo>
        <p>Si estás usando el método de instalación &quot;desde cero, constrúyelo todo&quot; es que quieres usar la imágen <path>stage1-ix86-1.4_beta.tbz2</path> image. Si estás usando alguno de nuestro mayores CDs, también has elegido las imágenes del stage2 y stage3. Estas imágenes te permiten ahorrar tiempo pero perdiendo configurabilidad (nosotros hemos elegido parametros de compilación y variables USE por ti).
        </p>
        <pre caption="Desempaquetando los Stages">
# <c>cd /mnt/gentoo</c>
# <c>tar -xvjpf /mnt/cdrom/gentoo/stage?-*.tbz2</c>
# <c>mount -o bind /proc /mnt/gentoo/proc</c>
# <c>mount -o bind /dev /mnt/gentoo/dev</c>
<comment>El montaje bind de es necesario para que perl se compile bien para algunas personas.</comment>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
        </pre>
<p>Si vas a usar GRP, ahora sería un buen momento para ejecutar los siguientes comandos:
</p>

<pre caption="Preparándose para GRP">
# <c>mkdir /mnt/gentoo/GRP</c>
# <c>mount -o bind /mnt/cdrom/gentoo/packages /mnt/gentoo/GRP</c>
</pre>

        <pre caption="Entrando en el chroot">
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
        </pre>
        <p>Tras ejecutar estos comandos, estarás &quot;dentro&quot; de tu nuevo Gentoo Linux.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Obteniendo el árbol de Portage usando rsync</title>
    <section>
      <body>
        <p>Ahora, necesitas ejecutar <c>emerge sync</c>. Esto te asegurará que tienes una copia de la versión más reciente del árbol Portage.
        </p>
        <pre caption="Actualizando usando rsync">
# <c>emerge sync</c>
        </pre>
        <p>El árbol del Portage será descargado y almacenado en<path>/usr/portage</path>; son unos 90Mb sin tarballs.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configurando las optimzaciones de Gentoo (make.conf)</title>
    <section>
      <body>
        <p>Ahora tienes una copia funcional del árbol de Portage, aquellos que usen el stage1 para hacer la instalación, necesitarán lo siguiente para hacer el bootstrap de su sistema Gentoo Linux. Primero edita el archivo <path>/etc/make.conf</path>. En este archivo, debes especificar tus variables  <c>USE</c>, que especifican funcionalidades adicionales las cuales quieres habilitar en los paquetes; generalmente, las variables por defecto (un <c>USE</c> <e>vacío</e> o sin especificar) es suficiente. Más información acerca de las variables <c>USE</c> puede ser encontrada <uri link="http://www.gentoo.org/doc/en/use-howto.xml">aquí</uri>.
        </p>
        <note>Para usuarios de habla no inglesa es adecuado especificar la variable nls.</note>
        <p>También deberás especificar apropiadamente <c>CHOST</c>, <c>CFLAGS</c> y <c>CXXFLAGS</c> para el tipo de sistema que estás creando (en el propio archivo encontrarás ejemplos comentados). Tu mejor amigo es el comando <path>man gcc</path> para ver qué parámetros están disponibles para <c>CFLAGS</c> y <code>CXXFLAGS</code>. Búsca 'Optimización'.
        </p>
        <p>Si es necesario, también puedes configurar la información del proxy en este archivo, si es que estás trás un cortafuegos.
        </p>
        <pre caption="Configurando make.conf">
# <c>nano -w /etc/make.conf</c>
        </pre>
        <note>
        Aquellos que necesiten cambiar algo más profundamente en el proceso de creación, deben echar un vistazo al archivo <path>/etc/make.globals</path>. Este archivo contiene los parámetros por defecto de Gentoo y nunca debe ser tocado. Si los valores por defecto no te satisfacen, entonces los nuevos valores deben ponerse en <path>/etc/make.conf</path>, ya que las entradas en <path>make.conf</path> <comment>sobreescriben</comment> las entradas en <path>make.globals</path>. Si estás interesado en optimizar las variables USE, mira en <path>/etc/make.profile/make.defaults</path>. Si quieres desactivar alguna variable del USE que se encuentre aquí, añade el <c>USE=&quot;-loquesea&quot;</c> adecuado en /etc/make.conf (para desactivar la variable <c>loquesea</c> en el USE).
        </note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Comenzando desde el Stage1</title>
    <section>
      <body>
        <p>El tarball del stage1 es para la optimización/versatilidad definitiva. Si te has bajado este tarball, es que seguramente estás buscando un sistema ultra-optimizado. Diviértete, ¡ya que la optimización lo es todo en Gentoo Linux!
        </p>
        <p>Ahora, es el momento de comenzar el proceso llamado &quot;bootstrap&quot;. Este proceso tarda aproximadamente 2 horas en  mi sistema 1200Mhz AMD Athlon. Durante este tiempo, la imagen compilada que extrajiste será preparada para compilar el resto del sistema. El conjunto del compilador GNU será construido, asi como la librería C GNU. En esto se consumira el tiempo, y creará el grueso del sistema.
        </p>
        <pre caption="Hacer el Bootstrap">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
        </pre>
        <p>El proceso del &quot;bootstrap&quot; comenzará ahora.
        </p>
        <note>
        Por defecto, el sistema Portage usa <c>/var/tmp</c> durante la construcción de paquetes, usando varios cientos de megabytes de almacenamiento temporal (de ahí que se llame /var/tmp;). Si quieres cambiar donde Portage guarda estos archivos temporales, configura la variable de entorno PORTAGE_TMPDIR <e>antes</e> de comenzar el proceso de bootstrap proceso así:
        </note>
        <pre caption="Cambiando el directorio de almacenamiento de Portage">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
        </pre>
        <p><c>bootstrap.sh</c> contruirá <c>binutils</c>, <c>gcc</c>, <c>gettext</c>, y <c>glibc</c>, reconstruirá <c>binutils</c>, <c>gcc</c>, y <c>gettext</c> después de <c>glibc</c>. No es necesario decir, que este proceso toma un buen tiempo. Que tengas una buena siesta ... Una vez que el proceso se complete, tu sistema se encontrará en el &quot;stage2&quot;, lo que significa que ahora puedes ir a las instrucciones del stage2.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Comenzando con el Stage2</title>
    <section>
      <body>
        <p>El tarball del stage2 ya tiene hecho el bootstrapping para ti. Todo lo que tienes que hacer es instalar el resto del sistema.
        </p>
        <note>
        Si no lo has hecho aún, por favor edita <path>/etc/make.conf</path> para adaptarlo a tu gusto.
        </note>
        <pre caption="Instalando el resto del sistema">
# <c>export CONFIG_PROTECT=&quot;-*&quot;</c>
# <c>emerge -p system</c>
    <comment>[lista los paquetes que serán instalados]</comment>
# <c>emerge system</c>
        </pre>
        <note>La línea <c>export CONFIG_PROTECT=&quot;-*&quot;</c> asegura que ningún nuevo script instalado en <path>/etc</path> sobreescribirá los viejos (guardados en <path>sys-apps/baselayout</path>), usando el soporte de Portage para nuevos archivos de configuración. Escribe <c>emerge --help config</c> para más detalles.
        </note>
        <p>Se tomará su tiempo hasta completar el sistema base completo. Tu recompensa será que estará realmente optimizado para tu sistema. La pega es que tendrás que buscarte algo para mantenerte ocupado este rato. El autor sugiere &quot;Star Wars - Super Bombad Racing&quot; para la PS2, yo sugiero bajar al bar de la esquina con los amigos ;).
        </p>
    <p>Cuando se complete este proceso, tu sistema se encontrará en el equivalente de un stage3. Tienes un par de opciones de como continuar en este punto. Te puedes ir a las instrucciones del stage3 y completarlas. Haciendo esto tendrás un sistema actualizado con el árbol actual de Portage. Esto no es necesario pero si recomendable. Si finalmente decides no ir a las instrucciones del stage3, puedes ir a la sección de la instalación GRP. Si no deseas usar GRP, ve a <uri link="http://www.gentoo.org/doc/es/gentoo-x86-install.xml#doc_chp16">Capítulo 16: Pasos Finales</uri>.
    </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Comenzando con el Stage3</title>
    <section>
      <body>
        <p>El tarball del stage3 está configurado para tu sistema. No tienes que hacer mucho en este stage, pero es una muy buena idea actualizar tu sistema para poder tener los últimos paquetes disponibles.
        </p>
        <note>Si aún no has editado <path>/etc/make.conf</path> para configurar tus especificaciones, Ahora puede ser un buen momento para hacerlo.
        </note>
        <pre caption="Poniéndose al día">
    # <c>emerge sync</c>
    # <c>emerge -up world</c>
    <comment>Lista los [<i>paquetes</i>] que se instalarán</comment>
    # <c>emerge -u world</c>
    </pre>
    <p>Una vez que completes este paso, tienes algunas opciones para continuar. Si lo que quieres es usar GRP, ve a la sección GRP. Si no vas a usar GRP, pásate por <uri link="http://www.gentoo.org/doc/en/gentoo-x86-install.xml#doc_chp16">Capítulo 16: Pasos Finales</uri>.
    </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Usando GRP</title>
    <section>
      <body>
        <p>Puedes beneficiarte de los paquetes preconstruidos GRP para evitar la compilación de paquetes particularmente grandes y populares. Actualmente, proporcionamos compilaciones completas con todo lo que necesitas para <c>openoffice-bin</c>, <c>GNOME</c>, <c>KDE</c> y <c>xfree</c>.
        </p>
        <p>Primero, primero necesitas ir al directorio donde están los paquetes, en el livecd los encontrarás en <path>/mnt/cdrom/gentoo/packages</path>. En este directorio encontrarás el script <c>grp-install.sh</c>, un directorio <i>All</i> que contiene todos los paquetes binarios, y una lista de paquetes GRP disponibles. Para instalar cualquiera/todos estos paquetes debes hacer lo siguiente:
        </p>
        <pre caption="Usando GRP">
# <c>sh grp-install.sh &lt;lista de listas de paquetes&gt;</c>
<comment>&lt;lista de listas de paquetes&gt; se refiere a cualquiera de los archivos *-list.txt que se encuentran en ese mismo directorio.
</comment>
        </pre>
        <p><c>grp-install.sh</c> puede ser ejecutados varias veces sin que sobre-escriba una instalación existente. Puedes hacer un <c>sh grp-install.sh</c> para obtener una descripción básica de su uso.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Zona horaria</title>
    <section>
      <body>
        <p>En este punto, debes de tener un sistema que esta listo para la configuración final. Comenzaremos el proceso de configuración con la zona horaria. Haciendo esto antes de construir el kernel nos aseguraremos que los usuarios obtengan una respuesta razonable al ejecutar <c>uname -a</c>.
        </p>
        <p>Busca tu zona horaria (o GMT si estás usando el Tiempo del Meridiano de Greenwich) en <path>/usr/share/zoneinfo</path>. Despues haz un enlace simbólico así:
        </p>
        <pre caption="Creando un enlace simbólico para la zona horaria">
# <c>ln -sf /usr/share/zoneinfo/directorio/archivozona /etc/localtime</c>
        </pre>
        <p>Puedes querer comprobar <path>/etc/rc.conf</path> para asegurarte de que tu zona horaria está correcta.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: logeador del kernel y del sistema</title>
    <section>
      <body>
        <note>
        Si todavía no lo has hecho (no te quejes, que no te lo hemos dicho), edita <path>/etc/make.conf</path> para adaptarlo a tu gusto.
        </note>
        <p>Ahora necesitas hacer merge del código fuente de del kernel Linux. Estás son las que ofrecemos actualmente:
        </p>
        <table>
          <tr>
            <th>ebuild</th>
            <th>descripción</th>
          </tr>
          <tr>
            <ti>
              <path>gentoo-sources</path>
            </ti>
            <ti>Nuestro propio kernel orientado al rendimiento y a las funcionalidades adicionales, pero sin soporte XFS.</ti>
          </tr>
          <tr>
            <ti>
              <path>xfs-sources</path>
            </ti>
            <ti>Kernel altamente compatible con soporte XFS.</ti>
          </tr>
          <tr>
            <ti>
              <path>openmosix-sources</path>
            </ti>
            <ti>Un kernel Linux parcheado con soporte para la tecnología GPL <uri link="http://www.openmosix.com">openMosix</uri>  de balanceo de carga y computación distribuida</ti>
          </tr>
          <tr>
            <ti>
              <path>usermode-sources</path>
            </ti>
            <ti>Un kernel Linux original parcheado con soporte para User-Mode Linux. (tecnología &quot;Linux dentro de Linux&quot;)</ti>
          </tr>
          <tr>
            <ti>
              <path>vanilla-sources</path>
            </ti>
            <ti>Un kernel Linux original, tal y como lo obtendrías de kernel.org</ti>
          </tr>
        </table>
        <warn>
        Si estás configurando tu propio kernel, ten cuidado con la opción <i>grsecurity</i>. Si eres muy agresivo con tus opciones de seguridad, puedes causar que ciertos programas (como las X) no se ejecuten adecuadamente. Si tienes dudas, déjalo en blanco.
        </warn>
        <p>Elige un kernel y haz merge así:</p>
        <pre caption="Emergiendo las fuentes del Kernel">
# <c>emerge sys-kernel/gentoo-sources</c>
        </pre>
        <p>Una vez que tengas las fuentes del kernel Linux disponibles, es el momento de compilar tu propio kernel.
        </p>
        <pre caption="Compilando el Kernel Linux">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>mv /boot/bzImage /boot/bzImage.orig</c>
<comment>[Si acaso el bzImage ya existía.]</comment>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
    </pre>
        <warn>Para que tu kernel funcione adecuadamente, asegúrate que ciertas opciones están en el kernel -- esto significa que, deben <i>construirse dentro y no como módulos</i>. Necesitarás habilitar la opción <i>&quot;Code maturity level options --&gt; Prompt for development and/or incomplete code/drivers&quot;</i>. En la sección &quot;File systems&quot;, asegúrate de habilitar <i>&quot;/dev file system support&quot;</i> (<e>no</e> necesitas habilitar la opción &quot;/dev/pts file system for UNIX98 ptys&quot;). También necesitarás habilitar <i>&quot;Virtual memory file system support&quot;</i>. No olvides habilitar &quot;ReiserFS&quot; si tienes alguna partición ReiserFS; lo mismo para &quot;Ext3&quot;. Si estás usando XFS, habilita la opción &quot;SGI XFS filesystem soporte&quot;. Es una buena idea dejar habilitado ext2, aunque no lo estes usando. También, la mayoría de la gente que use discos duros IDE querrán habilitar la opción &quot;USE DMA by default&quot;; de otra forma, tus unidades IDE tendrán un rendimiento muy pobre. Por supuesto, recuerda habilitar el soporte &quot;IDE disk&quot; -- de otra manera el kernel no podra ver tus discos IDE.
        </warn>
        <p>Si estás usando hardware RAID necesitarás habilitar un par de opciones más en el kernel: Para controladoras RAID Highpoint, selecciona el soporte para hpt366, soporte para controladoras IDE RAID y Highpoint 370 software RAID. Para controladoras RAID Promise, selecciona el soporte PROMISE PDC202{46|62|65|67|68|69|70}, soporte para IDE RAID y Support Promise software RAID (Fasttrak(tm))
        </p>
        <p>Si usas PPPoE para conectarte a Internet, necesitarás las siguientes opciones en el kernel (mejor compilados que como módulos): &quot;soporte PPP (point-to-point protocol)&quot;, &quot;soporte PPP para async serial ports&quot;, &quot;soporte PPP para sync tty ports&quot;. Las dos opciones de compresión no son necesarias, ni la opción &quot;PPP over Ethernet&quot;, que sÃ³lo debe ser usada por <i>rp-pppoe</i> cuando el kernel se configura para modo PPPoE.
        </p>
        <p>Si tienes una grabadora de CD's IDE, necesitarás habilitar la emulación SCSI. Habilita &quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA and ATAPI Block devices&quot; ---&gt; &quot;SCSI emulation support&quot; (Yo normalmente lo hago como módulo), entonces en &quot;SCSI support&quot; habilita &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; y &quot;SCSI generic support&quot; (de nuevo, normalmente lo compilo como módulo). Si también decides compilar como módulos, haz <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot; &gt;&gt; /etc/modules.autoload</c> para que se cargen automáticamente al iniciar el sistema.
        </p>
        <note>
    Para aquellos que lo prefieran, es posible instalar Gentoo Linux con un kernel 2.2. Pero hacer esto tiene un precio: perderás muchas de las interesantes características que son nuevas en los kernel de la serie 2.4 (como XFS y tmpfs, iptables, y más), aunque el kernel 2.2 puede ser parcheado con soporte ReiserFS y devfs. Los scripts de arranque de Gentoo linux requieren tmpfs o soporte ramdisk en the kernel, por lo que los usuarios del kernel 2.2 necesitan asegurarse de tener soporte ramdisk compilado (no como módulo). Es <comment>vital</comment> que la variable <e>gentoo=notmpfs</e> se añada a la línea del kernel en <path>/boot/grub/grub.conf</path> para el kernel 2.2 kernel para que se use ramdisk en los scripts de inicio en lugar de tmpfs. Si decides no usar devfs, debes de usar <e>gentoo=notmpfs,nodevfs</e>.
        </note>
        <p>Tu nuevo kernel (y sus módulos) están ahora instalados. Ahora necesitas elegir un logeador para el sistema. Ofrecemos sysklogd, que es el tradicional. También ofrecemos msyslog y syslog-ng así como metalog. Los usuarios avanzados querrán alejarse de sysklogd (no tiene un buen rendimiento) y probar las alternativas. Si dudas, prueba metalog, ya que se esta volviendo bastante popular. Para emerger tu logeador, escribe <e>una</e> de las siguientes líneas: 
        </p>
        <pre caption="Emergiendo el logeador">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>or</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>or</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>or</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
        </pre>
        <warn>
    En el caso de syslog-ng necesitas crear <path>/etc/syslog-ng/syslog-ng.conf</path>. Mira <path>/etc/syslog-ng</path> para tener un ejemplo de configuración.
        </warn>
        <impo>
    Metalog escribe la salida al disco en bloques, así que los mensajes no son grabados inmediatemente en los logs. Si estás intentado depurar algo, este aumento de rendimiento es inútil. Cuando tu Gentoo Linux system está iniciado y andando, puedes mandar a metalog una señal USR1 para que desactivar temporalmente esta característica (esto significa que <i>tail -f <path>/var/log/everything/current</path></i> ahora funciona en tiempo real, como se esperaba), y una señal USR2 volverá a metalog a su estado normal.
        </impo>
        <p>Ahora, opcionalmente puedes elegir el paquete cron que te gustaría usar. Ofrecemos dcron, fcron y vcron. si no sabes cual escoger, prueba con vcron. Se instalan de la siguiente manera:
        </p>
        <pre caption="Escogiendo un gestor cron">
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>o</comment>
# <c>emerge sys-apps/vcron</c>
<comment>No necesitas ejecutar <c>crontab /etc/crontab</c> si estás usando vcron.</comment>
<comment>No olvides añadir tu *cron al nivel de arranque adecuado.</comment>
# <c>rc-update add *cron default </c>
        </pre>
<!--<p>Para más información acerca de como funciona cron bajo Gentoo Linux, mira <uri link="http://lists.gentoo.org/pipermail/gentoo-announce/2002-April/000151.html">este anuncio</uri>.</p>-->
        <p>Para más información acerca de programas de inicio y demonios en el arranque mira <uri link="/doc/es/rc-scripts.xml">la guía de rc-script</uri>. 
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Instalar Paquetes adicionales</title>
    <section>
      <body>
        <p>Si necesitas rp-pppoe para conectar a la red, ten cuidado en este punto no ha sido instalado aún. Es un buen momento para hacerlo.
        </p>
        <pre caption="Instalando rp-pppoe">
# <c>emerge rp-pppoe</c>
        </pre>
        <note> Fijate en que rp-pppoe estará instalado, pero no configurado. Tendrás que hacerlo usando <c>adsl-setup</c> cuando entres en tu sistema Gentoo por primera vez.
        </note>
        <p>Puede que necesites instalar algún paquete adicional si estás usando alguna funcionalidad adicional como XFS, ReiserFS o LVM. Si estás usando XFS, debes emerger el ebuild <c>xfsprogs</c>: 
        </p>
        <pre caption="Emergiendo utilidades para sistemas de archivos">
# <c>emerge sys-apps/xfsprogs</c>
<comment>si vas a usar ReiserFS, debes emerger las utilidades de ReiserFS:</comment>
# <c> emerge sys-apps/reiserfsprogs</c>
<comment>Si estás usando LVM, debes emerger el paquete <c>lvm-user</c>: </comment>
# <c>emerge sys-apps/lvm-user</c>
        </pre>
        <p>Si estás usando un portátil y deseas poder usar tu PCMCIA la primera vez que reinicies, asegúrate de instalar el paquete <i>pcmcia-cs</i>.
        </p>
        <pre caption="Emergiendo PCMCIA-cs">
# <c>emerge sys-apps/pcmcia-cs</c>
        </pre>
        <warn>Tendrás que re-emerger <i>pcmcia-cs</i> tras al insalación para que el PCMCIA funcione.
        </warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: /etc/fstab</title>
    <section>
      <body>
        <p>Tu sistema Gentoo Linux está casí listo para el su uso. Todo lo que necesitamos hacer ahora es configurar unos cuantos archivos importantes del sistema e instalar el gestor de arranque grub. El primer archivo que necesitas configurar es <path>/etc/fstab</path>. Recuerda que debes de usar la opción <c>notail</c> en tu partición boot si decidiste usar ReiserFS en ella. Recuerda especificar <c>ext2</c>, <c>ext3</c> o <c>reiserfs</c> donde corresponda.
        </p>
        <p>Usa algo como el <path>/etc/fstab</path> mostrado a continuación, pero por supuesto asegúrate de reemplazar &quot;BOOT&quot;, &quot;ROOT&quot; y &quot;SWAP&quot; con los dispositivos que estés usando (como por ejemplo <c>hda1</c>, etc.)
        </p>
        <pre caption="Editando fstab">
        <comment>
# /etc/fstab: static file system information.
#
# noatime turns off atimes to increased performace (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It's safe para drop the noatime options if you want ant to 
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mountpoint&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: if your BOOT partition is ReiserFS, add the notail option to opts.
        </comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
        </pre>
        <warn>Por favor note que la particiÃ³n <i>/boot</i> NO está montada al arrancar. Esto es para proteger la data en <i>/boot</i> de posible corrupciÃ³n. Si requiere acceso, por favor monte esta particiÃ³n.
			</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Clave de Root</title>
    <section>
      <body>
        <p>Antes que te olvides, especifica la contraseña de root:</p>
        <pre caption="Especificando la contraseña de root">
# <c>passwd</c>
        </pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: /etc/hostname</title>
    <section>
      <body>
        <p>Edita este archivo ya que debe contener el nombre del dominio en una sola línea,
         por ejemplo: <c>mymachine.mydomain.com</c>. 
        </p>
        <pre caption="Configurando Hostname">
# <c>echo mymachine.mydomain.com &gt; /etc/hostname</c>
			</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: /etc/hosts</title>
    <section>
      <body>
        <p>Este archivo contiene una lista de direcciones ip y sus nombres asociados. Es usado por el sistema para resolver las direcciones IP de cualquier nombre que no esté en tus servidores de nombre. Aquí tienes una plantilla para este archivo:
        </p>
        <pre caption="Plantilla de /etc/hosts">
127.0.0.1      localhost
<comment># la prÃ³xima línea contiene el IP para tu local LAN, y el del equipo asociado</comment>
192.168.1.1    mymachine.mydomain.com mymachine
        </pre>
        <note>Si estás en una red con un servidor DHCP, puede ser útil colocarle <i>localhost</i> al hostname de tu equipo. Esto ayudará a GNOME y a otros programas en la resoluciÃ³n de nombres.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configuración final de red</title>
    <section>
      <body>
        <p>Añade los nombres de cualquier módulo que sea necesario para el correcto funcionamiento de tu sistema en el archivo <path>/etc/modules.autoload</path> (también puedes añadir cualquier opcion que necesites en la misma línea). Cuando Gentoo Linux inicie, estos módules serán cargados automáticamente. El módulo de tu tarjeta de red tiene una particular importancia, si es que lo has compilado como módulo:
        </p>
        <pre caption="/etc/modules.autoload">
        <comment>Esto es si estuvieras usando una tarjeta 3com. 
        Mira en <path>/lib/modules/`uname -r`/kernel/drivers/net</path> para tu tarjeta. </comment>
3c59x
        </pre>
        <p>Edit el archivo <path>/etc/conf.d/net</path> para tener tu tarjeta de red funcionando en tu primer arranque:
        </p>
        <pre caption="Configuración de red en el arranque">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
        </pre>
        <p>Si tienes varias tarjetas de red necesitas crear un archivo <path>net.eth<comment>x</comment></path> para cada una (<comment>x</comment> = 1, 2, ...):
        </p>
        <pre caption="Multiples tarjetas de red">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
        </pre>
        <p>Si tienes una tarjeta PCMCIA instalada, echa un rápido vistazo en <path>/etc/init.d/pcmcia</path> para verificar que esta todo correcto para tu sistema, entonces añade esta línea al principio de <path>/etc/init.d/ethx</path>:
        </p>
        <pre caption="Dependencias PCMCIA en /etc/init.d/net.ethx">
depend() {
    need pcmcia
}
        </pre>
        <p>Esto asegura que tus manejadores para PCMCIA se carguen automáticamente cuando la red se cargue.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Configura las opciones básicas (incluyendo el mapa de teclado)</title>
    <section>
      <body>
        <pre caption="Configuración Básica">
# <c>nano -w /etc/rc.conf</c>
        </pre>
        <p>Sigue las instrucciones en el archivo para configurar las opciones básicas. Todos los usarios deben asegurarse de que <c>CLOCK</c> está configurado para su sistema. Los usuarios de teclados internacionales querrán configurar la variable <c>KEYMAP</c> (mira en <path>/usr/share/keymaps</path> para ver las posibilidades).
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Configurando grub</title>
    <section>
      <body>
        <p>La parte más crítica de entender grub es sentirse cómodo en la manera como grub se refiere a los discos duros y a las particiones. Tu partición Linux <path>/dev/hda1</path> es llamada <path>(hd0,0)</path> por grub. Fijate en los paréntesis que rodean a hd0,0 - son necesarios. Los discos duros se empiezan a contar desde cero en lugar de desde &quot;a&quot;, y las particiones empiezan desde cero en lugar de desde 1. Realmente ten mucho cuidado en como grub cuenta todo esto, ya que solo los discos duros son contados, los dispositivos ide-atapi como los cdroms no lo son, y lo mismo pasa con los dispositivos scsi, (normalmente estos tienen números mayores que los dispositivos IDE, excepto cuando la bios esta configurada para iniciar desde un dispositivo scsi). Asumiendo que tienes un disco duro en /dev/hda, un cdrom en /dev/hdb, una grabadora en /dev/hdc y un segundo disco duro en /dev/hdd, por ejemplo, y que no tienes discos duros scsi <path>/dev/hdd7</path> se convierte en <path>(hd1,6)</path>. Puede sonar un poco raro, y en el fondo lo es, pero como veremos, grub ofrece autocompletado por tabulación que ayuda mucho a hacer esto, en especial si tienes un montón de discos duros y particiones y estás un poco perdido en el tema de numeración de grub. Teniendo esto claro, es el momento de instalar grub.
    </p>
        <p>La manera más fácil de instalar grub es simplemente escribiendo <c>grub</c> en tu shell del chroot:
        </p>
        <pre caption="Instalando grub">
# <c>grub</c>
        </pre>
        <impo>Si estás usando hardware RAID, no funcionará por el momento. Ve a la sección sobre la creación de <path>grub.conf</path> trás completar la configuración de controladores RAID.
        </impo>
        <p>Serás recibido con la línea de comando de grub <c>grub&gt;</c> . Ahora, necesitas escribir los comandos adecuados para instalar grub en el sector de arranque de tu disco duro. En mi configuración de ejemplo, quiero instalar grub en el MBR (master boot record) de mi disco duro, para que la primera cosa que vea al encender el ordenador sea el grub. En mi caso, los comandos que debo usar son:
        </p>
        <pre caption="Comandos de grub">
grub&gt; <c>root (hd0,0)</c>
grub&gt; <c>setup (hd0)</c>
grub&gt; <c>quit</c>
        </pre>
        <p>Esto es lo que hacen estos comandos. El primer comando <c>root ( )</c> le dice a  grub  la localización de tu partición de arranque (en nuestro ejemplo, <path>/dev/hda1</path> o <path>(hd0,0)</path> en la terminología de grub. Entonces, el segundo comando <c>setup ( )</c> le dice a grub donde instalarse - debe de ser configurado para que busque sus archivos especiales en la localización <c>root ( )</c> que especificaste. En mi caso, quiero instalarlo en el MBR de mi disco duro, por lo que simplemente specifico <path>/dev/hda</path> (también conocido como <path>(hd0)</path>). Si estuviera usando algún otro gestor de arranque y quiero configurar grub como el gestor segundario, puedo instalar grub en una partición determinada. En este caso, especificaría una partición en concreto en lugar de el disco completo. Una vez grub ha sido instalado con éxito, puedes escribir <c>quit</c> para salir de grub. <note>El mecanismo de auto-completar de grub puede ser usado en este punto, asumiendo que escribes <c>root (</c> y pulsas la tecla TAB, se te mostrará con una lista de los dispositivos disponibles (no solo discos duros), pulsando TAB habiendo escrito <c> root (hd</c>, grub te mostrará los discos duros disponibles, y pulsando de nuevo TAB trás teclear <c> root (hd0,</c> verás las particiones del primer disco duro. El auto-completado te ayuda a comprobar que la sintaxis sea la correcta.
    </note>
    Gentoo Linux está ahora instalada, pero necesitamos crear el archivo <path>/boot/grub/grub.conf</path> para poder tener un bonito menú grub cuando iniciamos el sistema.
        </p>
        <impo>Para asegurar la compatibilidad con versiones anteriores de grub, asegúrate de crear un enlace de <i>grub.conf</i> a <i>menu.lst</i>. Para hacerlo, haz <c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>.
        </impo>
        <p>Ahora, crea el archivo grub.conf (<c>nano -w /boot/grub/grub.conf</c>), y añádele lo siguiente:
        </p>
        <pre caption="Archivo grub.conf para grub">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Mi sistema de ejemplo Gentoo Linux
root (hd0,0) 
kernel /boot/bzImage root=/dev/hda3 

<comment> #Lo siguiente es si usas hardware RAID</comment>
title=My Gentoo Linux on RAID
root (hd0,0)
kernel /boot/bzImage root=/dev/ataraid/discX/partY

<comment># Lo siguiente sÃ³lo lo necesita la gente con arranque dual</comment>
title=Windows NT Workstation
root (hd0,5) 
chainloader +1
        </pre>
        <note>
    (hd0,0) debe de ser escrito sin espacios dentro del paréntesis.
        </note>
        <impo>
    Si configuras emulación scsi para una grabadora IDE, para que funcione necesitas añadir el parámetro &quot;hdx=ide-scsi&quot; a la línea del kernel en grub.conf (donde &quot;hdx&quot; debe de ser tu grabadora).
        </impo>
        <p>Trás salvar este archivo, la instalación de Gentoo Linux se ha completado. Selecciona la primera opción en el menú de grub para iniciar Gentoo Linux. La segunda parte de grub.conf es opcional y muestra como iniciar una partición Windows.
        </p>
        <note>A continuación, <path>(hd0,0)</path> debe de ser tu partición &quot;boot&quot; (<path>/dev/hda1</path> en nuestra configuración de ejemplo) y <path>/dev/hda3</path> debe de ser a la raíz del sistema. <path>(hd0,5)</path> contiene un arranque de NT.
        </note>
        <p>Si necesitas pasar alguna otra opción adicional para el kernel, simplemente añádela al final del comando <c>kernel</c>. En este caso estamos pasando una opción (<c>root=/dev/hda3</c>), pero puedes pasar otras del mismo modo. Por ejemplo, puedes desactivar el sistema de archivo devfs por defecto (no recomendado al menos que sepas lo que estas haciendo) añadiendo la opción <c>gentoo=nodevfs</c> al comando kernel <c>kernel</c>.
        </p>
        <note>Al menos que estés usando una vieja versión de Gentoo Linux, no tienes que seguir añadiendo <c>devfs=mount</c> al final de la línea del <c>kernel</c> para activar devfs. En la rc6 devfs está activado por defecto.
        </note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Configurar LILO</title>
    <section>
      <body>
        <p>Mientras que grub puede ser la mejor alternativa para la mayoría de la gente, no es siempre la mejor elección. LILO, el LInuxLOader, es el más probado y usado de los gestores de arranque de Linux. Así es como se instala LILO, si prefieres usarlo en lugar de grub:
        </p>
        <p>El primer paso es emerger LILO: 
        </p>
        <pre caption="Emergiendo LILO">
# <c>emerge lilo</c>
        </pre>
        <p>Ahora es el momento de configurar LILO. Aquí tienes un pequeño <i>lilo.conf</i> para usarlo, y te explico las diferentes partes del archivo.
        </p>
        <pre caption="Ejemplo de lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	initrd=/boot/initrd-2.4.20.img
	read-only
	root=/dev/hda5
	
#Para arranque dual con windows u otro sistema operativo
other=/dev/hda1
	label=dos

        </pre>
        <li><i>boot=/dev/hda</i> le dice a LILO que se instale en el primer disco duro de la primera controladora IDE.
        </li>
        <li><i>map=/boot/map</i> establece el mapa del sistema. En un uso normal, no debe de ser modificado.
        </li>
        <li><i>install=/boot/boot.b</i> le dice a LILO que instale el archivo especificado como el nuevo sector de arranque. Normalmente no debe de ser alterado. Si la línea del install no está, LILO asumirá por defecto /boot/boot.b como parámetro.
        </li>
        <li>La existencia de <i>prompt</i> le dice a LILO que se muestre en la línea de mensajes.  No es recomendable quitar la línea del prompt, si la quitas, podrás volver a tener el prompt presionando la tecla [Shift] mientras tu equipo se inicia.
        </li>
        <li><i>timeout=50</i> especifica el tiempo que LILO debe esperar ante de proceder a iniciar la línea de entrada por defecto. Este está especificado en decimas de segundo, tiene 50 por defecto.
        </li>
        <li><i>message=/boot/message</i> se refiere a la pantalla que LILO muestra para dejarte seleccionar el sistema operativo o kernel para arrancuar.
        </li>
        <li><i>lba32</i> describe la geometría del disco duro. Otra entrada común es "linear". No debes cambiar esta línea al menos que sepas muy bien lo que estes haciendo. De otra forma, podrías volver tu sistema no-iniciable.
        </li>
        <li><i>default=linux</i> se refiere al sistema operativo por defecto que LILO usará para iniciar usando las opciones que tiene a continuación. El nombre linux se refiere a la línea "label" que se encuentra antes de las opciones de arranque.
        </li>
        <li><i>image=/boot/vmlinuz-2.4.20</i> especifica el kernel linux para iniciar con esas opciones.
        </li>
        <li><i>label=linux</i> nombra el conjunto de opciones del sistema operativo. En este caso, es también el nombre que se usa por defecto.
        </li>
        <li><i>initrd=/boot/initrd-2.4.20.img</i> se refiere a la imagen de ram disk usada al arrancar para inicializar y arrancar los dispositivos que hacen posible que el kernel arranque. El ram disk inicial es un conjunto de drivers especificos necesarios para poser usar una tarjeta SCSI, disco duro,o cualquier otra cosa 
    necesaria para iniciar el kernel. Nunca debes intentar usar el ram disk de inicio en distintas máquinas.
        </li>
        <li><i>read-only</i> especifica que la partición raíz (mira la línea "root" a continuación) es de solo escritura y que no puede ser modificada durante el proceso de inicio.
        </li>
        <li><i>root=/dev/hda5</i> le dice a LILO que partición usar como partición raíz.
        </li>
        <note>Gracias a<uri link="http://www.redhat.com">Redhat.com</uri> por esta información.
        </note>
        <p>Tras editar <i>lilo.conf</i>, es el momento de ejecutar LILO para cargar la información dentro del MBR:
        </p>
        <pre caption="Ejecutando LILO">
# <c>/sbin/lilo</c>
        </pre>
        <p>LILO está configurado, y ¡ahora tu equipo está listo para arrancar Gentoo Linux!
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pasos Finales: Diskettes de arranque</title>
    <section>
      <title>Diskettes de arranque de grub</title>
      <body>
        <p>Es una buena idea hacer diskettes de arranque la primera vez que instales cualquier distribución Linux por seguridad. Si estás usando algun tipo de hardware RAID, puedes <e>necesitar</e> hacer un diskette de arranque grub. Si estás intentando instalar grub en un hardware RAID desde un la línea de comando dentro de un chroot, ésto podría fallar. Si este tu caso, crea un diskette de arranque grub y cuando reinicies por primera vez podrás instalar grub en el MBR. Para hacer tu diskette de arranque haz:
        </p>
        <pre caption="Creando un diskette de arranque de grub">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>

# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
        </pre>
        <p>Ahora reinicia el ordenador y usa este disco. En el prompt <c>grub&gt;</c>, podrás ejecutar los comandos <c>root</c> y <c>setup</c> necesarios.</p>
      </body>
    </section>
    <section>
      <title>Diskettes de arranque de LILO</title>
      <body>
        <p>Si estás usando LILO, también es una buena idea crear los diskettes de arranque:
        </p>
        <pre caption="Creando el diskette de arranque con LILO">
# <c>dd if=/boot/su_kernel of=/dev/fd0 </c>
<comment>Esto solo funcionará si tu kernel es menor que 1.4MB</comment>
        </pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>¡Instalación Completada!</title>
    <section>
      <body>
        <p>Ahora, Gentoo Linux está instalado. El último paso que falta es salir del chroot, actualizar los archivos de configuración necesarios, desmontar con seguridad las particiones y reiniciar el sistema:
        </p>
        <pre caption="Reiniciando el Sistema">
# <c>etc-update</c>
# <c>exit</c> 
<codenote>Con esto se sale del chroot; también puedes pulsar <c>^D</c></codenote>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo/dev</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
        </pre>
        <note>
        Trás reiniciar, es una buena idea ejecutar el comando <c>update-modules</c> para crear el archivo <path>/etc/modules.conf</path>. En lugar de modificar este archivo directamente, generalmente debes hacer los cambios en el archivo <path>/etc/modules.d</path>.
        </note>
        <impo>Recuerda que si estás usando un hardware RAID, debes arrancar con tu diskette de arranque para arrancar la primera vez y entonces instalar grub. Lo has hecho -- ¡felicidades!
        </impo>
        <p>Si tienes alguna pregunta o te gustaría involucrarte en el desarrollo de Gentoo Linux, considera la posibilidad de subscribirte a las listas de correo gentoo-user y gentoo-dev (hay un &quot;click para subscribirse&quot; en nuestra <uri link="http://www.gentoo.org">página principal</uri>). También tenemos una interesante <uri link="http://www.gentoo.org/doc/es/desktop.xml">guía de configuración del escritorio</uri> que te puede ayudar a continuar configurando tu nuevo sistema Gentoo Linux y una útil <uri link="http://www.gentoo.org/doc/es/portage-user.xml">Guía del usuario de Portage</uri> para ayudarte a familiarizarte con Portage. Puedes encontrar el resto de la documentación de Gentoo <uri link="http://www.gentoo.org/main/en/docs.xml">aquí</uri>. Si tienes cualquier otra pregunta relacionada con al instalación, lee el <uri link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri> de Gentoo Linux. ¡Disfruta y bienvenido a Gentoo Linux!
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Programa estadístico Gentoo-Stats</title>
    <section>
      <body>
        <p>El programa estadístico del uso de Gentoo Linux comenzó como un intento de dar a los desarrolladores una manera de encontrar algo sobre su base de usuarios. Recolecta información acerca del uso de Gentoo Linux para ayudarnos a priorizar nuestro desarrollo. Instalarlo es completamente opcional y será muy apreciado si decides usarlo. Las estadísticas actuales se pueden ver en <uri>http://stats.gentoo.org/</uri>.
        </p>
        <p>El servidor de gentoo-stats asignará una ID única para tu sistema. Esta ID es usada para para asegurarse de que cada sistema es contado tan solo una vez. La ID no será usada para identificar el sistema individualmente, no coincidirá con la dirección IP o otra información personal. Todas las precauciones han sido debidamente tomadas para asegurar la privacidad en el desarrollo de este sistema. Lo siguiente es lo que monitoreamos justo ahora en nuestro programa &quot;gentoo-stats&quot;:
        </p>
        <ul>
          <li>paquetes instalados y sus versiones</li>
          <li>CPU información: velocidad (MHz), vendedor, modelo, CPU flags (como &quot;mmx&quot; o &quot;3dnow&quot;)</li>
          <li>información de memoria (RAM física disponible total, espacio swap disponible)</li>
          <li>tarjetas PCI y chips de controladoras de red</li>
          <li>El perfil que tu equipo está usando (esto es, donde apunta el link /etc/make.profile).</li>
        </ul>
        <p>Tenemos cuidado de no registrar cualquier información sensible de los usuarios de Gentoo Linux (solo la que los desarrolladores necesitan).
        </p>
        <ul>
          <li>Al menos que modifiques el programa gentoo-stats, nunca transmitirá información sensible como contraseñas, datos de configuración, talla de zapatos ...
          </li>
          <li>La transmisión de tu dirección de correo electrónico es opcional y están desactivadas por defecto.
          </li>
          <li>La dirección IP originada por la transmisión de datos nunca será logeada de ninguna manera en la que te podamos identificar. Esto no es un &quot;sistema de ID por dirección IP&quot;.
          </li>
        </ul>
        <p>La instalación es sencilla, tan solo ejecuta los siguientes comandos:
        </p>
        <pre caption="Instalando gentoo-stats">
# <c>emerge gentoo-stats</c>   <codenote>Instala gentoo-stats</codenote>
# <c>gentoo-stats --new</c>    <codenote>Obtiene una nueva ID</codenote>
        </pre>
        <p>El segundo comando pedirá una nueva ID para el sistema, y la guardara dentro de <path>/etc/gentoo-stats/gentoo-stats.conf</path> automáticamente. Puedes mirar este archivo para revisar las opciones de configuración adicionales.
        </p>
        <p>Después de esto, el programa debe ejecutarse regularmente (no necesita ser ejecutado como root). Añade esta línea a tu <path>crontab</path>:
        </p>
        <pre caption="Actualizando gentoo-stats con cron">
          <c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
        </pre>
        <p>El programa <c>gentoo-stats</c> es un simple script en perl que puede ser revisado con tu editor o paginador favorito: <path>/usr/sbin/gentoo-stats</path>.
        </p>
      </body>
    </section>
  </chapter>
</guide>
