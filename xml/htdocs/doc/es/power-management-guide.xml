<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header -->
<guide link="/doc/es/power-management-guide.xml" lang="es">
<title>Guía de Administración de Energía</title>

<author title="Autor">
  <mail link="fragfred@gmx.de">Dennis Nienhüser</mail>
</author>
<author title="Editor Es">
  <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
</author>
<author title="Editor Es">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>
<author title="Editor Es">
  <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
</author>
<author title="Traductor">
  <mail link="anpereir@gentoo.org">Andrés Pereira</mail>
</author>

<abstract>
La Administración de Energía es la clave para extender el tiempo
de duración de la batería en sistemas móviles como los portátiles.
Ésta guía le ayuda a configurarla en su portátil.
</abstract>

<!-- El contenido de este documento está liberado bajo la licencia CC-BY-SA -->
<!-- Vea http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.24</version>
<date>2005-06-10</date>

<chapter>
<title>Introducción</title>
<section>
<title>¿Porqué Administrar la Energía?</title>
<body>

<p>
La capacidad y el tiempo de vida de las baterías de un portátil han mejorado
mucho en los últimos años. No obstante, los procesadores modernos consumen
mucha más energía que los antiguos y cada generación de portátiles trae
consigo más dispositivos hambrientos de energía. Por eso es que la
Administración de Energía es más importante que nunca. Incrementar el
tiempo de duración de una batería no significa necesariamente comprar otra.
Mucho se puede lograr con tan sólo aplicar políticas inteligentes de
Administración de Energía.
</p>
</body>
</section>

<section>
<title>Una rápida vista general</title>
<body>

<p>
Por favor, observe que esta guía describe la Administración de Energía
para <e>portátiles</e>. Aunque algunas secciones pueden ser válidas
para <e>servidores</e>, otras no lo son e incluso pueden causar daño. Por favor,
no aplique nada de esta guía a un servidor a menos que realmente sepa lo
que está haciendo.
</p>

<p>
Como esta guía se ha convertido un poco larga, a continuación hay un corta vista
general que le ayudará a encontrar su camino a lo largo de ésta.
</p>

<p>
El capítulo de <e>Prerrequisitos</e> habla acerca de algunos requerimientos
que deberían cumplirse antes de que funcione cualquiera de las siguientes
secciones individuales de dispositivos. Esto incluye los ajustes a la BIOS,
configuración del kernel y algunas simplificaciones en el área del usuario.
Los siguientes tres capítulos se enfocan en los dispositivos que típicamente
consumen más energía - procesador, pantalla y disco duro. Cada uno puede ser
configurado de forma separada. La <e>Administración de Energía de la CPU</e>
muestra cómo ajustar la frecuencia del procesador para ahorrar un máximo de
energía sin perder mucho rendimiento. Distintos trucos previenen a su disco
duro de trabajar innecesariamente más de lo usual en la sección
<e>Administración de Energía del Disco</e> (disminuyendo el nivel de ruido
como agradable efecto secundario). Algunas notas sobre LAN inalámbricas y
USB completan la sección de dispositivos en <e>Administración de Energía
para otros dispositivos</e> mientras que otro capítulo está dedicado
(más experimentalmente) a los <e>estados de sueño</e>.  Última pero no menos
importante está la sección de <e>Solución de problemas</e> que
lista los errores comunes.
</p>
</body>
</section>

<section>
<title>Presupuesto de Energía para cada componente</title>
<body>

<figure link="/images/energy-budget.png" short="¿Cuánta energía consume cada
componente?" caption="Presupuesto de Energía para cada componente"/>

<p>
Casi toda componente puede operar en estados diferentes - apagada, durmiendo,
inactiva, activa por nombrar unos pocos - consumiendo una cantidad distinta de
energía. La mayor parte de la energía es consumida por la pantalla LCD, la CPU,
el chipset y los discos duros. Frecuentemente se puede activar la Administración
de Energía independientedel SO en la BIOS, pero una configuración inteligente
en los sistemas operativos que se adapta a situaciones diferentes puede lograr
mucho más.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Prerrequisitos</title>
<section>
<title>Lo que debe hacerse en primer lugar</title>
<body>

<p>
Antes de entrar en detalles acerca de cómo hacer que los dispositivos
individuales sepan de sus propias capacidades de Administración de
Energía, asegúrese que se cumplan ciertos requerimientos. Después de controlar
los ajustes de la BIOS, algunas opciones del kernel deben estar activadas -
éstas son en resumen: ACPI, estados de sueño y calibración de frecuencia de
la CPU.
Como el ahorro de energía viene la mayoría de la veces junto a pérdida de
rendimiento o latencia incrementada, debería ser sólo activada cuando se están
usando las baterías. Aquí es cuando viene a mano un nuevo runlevel denominado
<e>battery</e>.
</p>
</body>
</section>

<section>
<title>La parte de la BIOS</title>
<body>

<p>
Primero demos una mirada a su configuración de Administración de Energía
en la BIOS. La mejor forma es combinar políticas de la BIOS y del sistema
operativo, pero por el momento es mejor desactivar la mayor parte referente a la
BIOS. Esto le asegura que no va a interferir con sus políticas. No olvide
revisar nuevamente su configuración de la BIOS luego de que haya configurado
el resto de las cosas.
</p>
</body>
</section>

<section>
<title>Configurando el núcleo</title>
<body>

<p>
El soporte de ACPI (siglas en inglés de Configuración Avanzada e Interfaz de Energía) en el núcleo
aún está en progreso. Al usar un núcleo reciente se asegurará de tener el soporte más actualizado.
</p>

<p>
En la configuración del kernel, active al menos estas opciones:
</p>

<pre caption="Configuración mínima del núcleo para la Administración de Energía (Núcleo 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Decida si quiere activar "Software Suspend" (Suspensión del Software), "Suspend-to-Disk" (Suspenda a Disco) y "Sleep States" (Estados de Sueño) (ver más abajo). Si posee un portátil ASUS, Medion o Toshiba,
active la sección apropiada. 
</p>

<p>
El núcleo debe saber cómo activar la calibración de la frecuencia de la CPU
en su procesador. Debido a que cada tipo de CPU tiene una interfaz distinta,
tiene que elegir el manejador apropiado para su procesador. Tenga cuidado aquí, 
por ejemplo, al activar la <e>modulación del reloj de un Pentium 4</e> en un sistema Pentium
M llevará a resultados extraños. Consulte la documentación del
núcleo si no está seguro cuál elegir.
</p>

<p>
Compile su núcleo, asegúrese de que se carguen los módulos adecuados al inicio y
arranque su nuevo núcleo con ACPI activada. A continuación ejecute <c>emerge
sys-power/acpid</c> para obtener el demonio acpi. Éste le informa sobre los
eventos como el cambio de Corriente Alterna a la batería o al cerrar la tapa del
portátil. Verifique que estén cargados los módulos si es que no los
compiló en el núcleo e inicie acpid mediante  <c>/etc/init.d/acpid
start</c>. Ejecute <c>rc-update add acpid default</c>  para cargarlo al inicio.
Pronto verá cómo usarlo.
</p>

<pre caption="Instalando acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>
</body>
</section>

<section>
<title>Creando un nivel de ejecución "battery"</title>
<body>

<p>
La política por defecto será activar la Administración de Energía sólo
cuando se necesite, al usar baterías. Para que sea conveniente el cambio
entre Corriente Alterna y batería, haga un nivel de ejecución <e>battery</e> que
contenga todos los guiones que inician y detienen la Administración de
Energía.
</p>

<note>
Puede saltarse con seguridad esta sección si no le agrada la idea de tener otro
nivel de ejecución. No obstante, al saltarse este paso hará que el resto sea más
complicado de configurar. Las siguientes secciones asumen que existe el nivel de
ejecución <e>battery</e>.
</note>

<pre caption="Creando el nivel de ejecución battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Listo. Su nuevo nivel de ejecución <e>battery</e> contiene todo tal como el
<e>default</e>, pero todavía no existe un cambio automático entre ellos. Es hora
de cambiar eso.
</p>
</body>
</section>

<section>
<title>Reaccionando a los eventos de ACPI</title>
<body>

<p>
Entre los típicos eventos de ACPI están el cerrar la tapa del portátil, cambiar
la fuente de energía o presionar el botón para dormir. Un evento importante es
el cambiar la fuente de energía, que debería gatillar un cambio del nivel de
ejecución. Cree los siguientes archivos para cambiarse entre los niveles de
ejecución <e>default</e> y <e>battery</e> dependiendo de la fuente de energía
que haya:</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># INICIO configuración</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># FIN configuración</comment>
if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Reemplace "ac_adapter" que aparece abajo con el evento generado en su portátil</comment>
<comment># See /var/log/acpid</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Reemplace "battery" que aparece abajo con el evento generado en su portátil</comment>
<comment># Vea /var/log/acpid</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Adicionalmente va a necesitar del paquete sys-power/powermgmt-base que
contiene el utilitario <c>on_ac_power</c>. El archivo <path>pmg_switch_runlevel.sh</path>
debe ser ejecutable.
</p>

<pre caption="Finalizando el cambio de nivel de ejecución con acpid">
<i># emerge powermgmt-base</i>
<i># chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</i>
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Pruébelo: Conecte su portátil a la Corriente Alterna y observe en syslog los
mensajes "Switching to AC mode" o "Switching to battery mode". Vea la sección de
Solución de Problemas si el guión no es capaz de detectar la fuente de
energía de forma apropiada.
</p>

<p>
Debido a la naturaleza del mecanismo de eventos, su portátil arrancará en el
nivel de ejecución <e>default</e> sin importar el estado de la Corriente Alterna
o la batería. Puede agregar un parámetro adicional al gestor de arranque con
<c>softlevel=battery</c>, pero es fácil que dicha elección se olvide. Una mejor
manera es falsear un evento ACPI al término del proceso de arranque y dejar que
el guión <path>/etc/acpi/default.sh</path> decida si es necesario un cambio del
nivel de ejecución. Abra  <path>/etc/conf.d/local.start</path> en su editor
favorito y agregue estas líneas:
</p>

<pre caption="Cambio del nivel de ejecución al momento del arranque mediante la
edición de local.start">
<comment># Falsear un evento acpi para cambiarse el nivel de ejecución si se
están usando baterías</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Al estar preparado tal como se ha hecho antes, ya puede activar las políticas de
Administración de Energía para los dispositivos individuales.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Administración de Energía de la CPU</title>
<section>
<title>Algunos términos técnicos</title>
<body>

<p>
La calibración de frecuencia de la CPU trae algunos términos técnicos que
pueden ser desconocidos. A continuación se presenta una rápida introducción.
</p>

<p>
Primero que todo, el núcleo debe ser capaz de cambiar la frecuencia del
procesador. El <e>manejador CPUfreq del procesador</e> conoce los comandos para
hacerlo en su CPU. Por lo tanto es importante elegir el manejador correcto en su
núcleo. Ya debería haber hecho esto más arriba. Una vez que el kernel sabe cómo
cambiar las frecuencias, debe conocer qué frecuencia debería configurar. Ésto es
realizado de acuerdo a la <e>política</e> que consiste de una <e>política
CPUfreq</e> y un <e>gobernador</e>. Una política CPUfreq la constituyen dos
números que definen el rango en que debe estar la frecuencia - la mínima y
máxima frecuencia. Por ejemplo, el <e>gobernador powersave</e> siempre elige la
mínima frecuencia disponible, el <e>gobernador de performance</e> elige la
más alta. El <e>gobernador userspace</e> no hace decisión alguna pero elige
aquello que el usuario (o el programa en el área del usuario) quiera - lo que
significa que lee la frecuencia desde <path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Éstos todavía no parecen ser los cambios dinámicos de frecuencia esperados y de
hecho no lo son. Sin embargo, es posible llevar a cabo el ansiado dinamismo
con varias aproximaciones. Por ejemplo, el <e>gobernador ondemand</e> realiza
sus decisiones dependiendo de la carga actual de la CPU. Es lo mismo que
realizan otra herramientas de usuario como <c>cpudyn</c>,
<c>cpufreq</c>, <c>powernowd</c> y muchas más. Los eventos de ACPI
pueden ser usados para activar o desactivar los cambios dinámicos dependiendo de
la fuente de energía.
</p>
</body>
</section>

<section>
<title>Ajustando manualmente la frecuencia</title>
<body>

<p>
Disminuir la velocidad de la CPU y el voltaje tiene dos ventajas: Por un lado se
consume menos energía y en el otro hay una mejora térmica ya que su sistema no
se calienta como si estuviera corriendo a toda velocidad. La principal
desventaja es que obviamente hay una pérdida de rendimiento. El disminuir la
velocidad del procesador es un contrapeso entre la pérdida de rendimiento y el
ahorro de energía.
</p>

<note>
No todo portátil ofrece la capacidad de calibración de la frecuencia. Si no está
seguro, déle una mirada a la lista de procesadores soportados en la sección
<e>Solución de Problemas</e> para verificar si el suyo lo está.
</note>

<p>
Es hora de probar si funciona el cambio de frecuencia de la CPU. Instalemos otra 
herramienta que es muy útil para propósitos de depuración:
<c>sys-power/cpufrequtils</c>
</p>

<pre caption="Chequeando la frecuencia de la CPU">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Aquí hay un ejemplo de la salida del comando:
</p>

<pre caption="Salida de ejemplo de cpufreq-info">
cpufrequtils 0.2: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz (asserted by call to hardware).
</pre>

<p>
Pruebe <c>cpufreq-set</c> para estar seguro que funciona el cambio de frecuencia.
Ejecute, por ejemplo, <c>cpufreq-set -g ondemand</c> para activar el gobernador
ondemand y verifique el cambio con <c>cpufreq-info</c>. Si no funciona como
es esperado, puede encontrar ayuda en la sección Solución de Problemas al
final de esta guía.
</p>

</body>
</section>

<section>
<title>Adaptación automatizada de la frecuencia</title>
<body>

<p>
Lo de arriba es agradable, pero no para realizarlo a diario. Es mejor dejar que
su sistema ajuste automáticamente la frecuencia apropiada. Hay muchos
enfoques diferentes para hacer ésto. La siguiente tabla le da una visión
general para ayudarle a decidirse en una de ellos. Está separada en tres categorías:
<e>núcleo</e> para los enfoques que sólo necesitan apoyo en el kernel,
<e>demonio</e> para los programas que corren en segundo plano y <e>gráfica</e>
para los programas que provean de una interfaz para realizar una fácil
configuración y cambios.
</p>

<table>
<tr>
  <th>Nombre</th>
  <th>Categoría</th>
  <th>Decisión de cambio</th>
  <th>Gobernadores del Núcleo</th>
  <th>Gobernadores adicionales</th>
  <th>Comentarios</th>
</tr>
<tr>
  <ti>Gobernador 'en demanda'</ti>
  <ti>Núcleo</ti>
  <ti>Carga de la CPU</ti>
  <ti>N/D</ti>
  <ti>N/D</ti>
  <ti>
    Afinamientos adicionales a través de los archivos en
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Aún requiere
    de herramientas del área del usuario (programas y guiones) si se desea
    cambiar de gobernador (o similar).
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demonio</ti>
  <ti>Carga de la CPU</ti>
  <ti>Performance, powersave</ti>
  <ti>"dynamic"</ti>
  <ti>
    También permite disk standby - No obstante, note que el <e>laptop mode</e>
    hará un mejor trabajo en la mayoría de los casos.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demonio</ti>
  <ti>Estado de la batería, carga de la CPU, programas en ejecución</ti>
  <ti>Todos disponibles</ti>
  <ti>Ninguno</ti>
  <ti>
    Configuración sofisticada (pero también complicada). 
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Demonio</ti>
  <ti>Carga de la CPU</ti>
  <ti>Ninguno</ti>
  <ti>"passive", "sine", "aggressive"</ti>
  <ti>
    Acepta SMP.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demonio</ti>
  <ti>Carga de la CPU</ti>
  <ti>Ninguno</ti>
  <ti>"dynamic", "powersave", "performance", "fixed speed"</ti>
  <ti>
    Pequeño pero poderoso con una útil interfaz cliente/servidor. Requiere de un
    núcleo 2.6. No parece seguir siendo mantenido y será sacado de Portage en el
    futuro próximo.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Gráfica</ti>
  <ti>Ninguno</ti>
  <ti>Ninguno</ti>
  <ti>Ninguno</ti>
  <ti>
    Herramientra gráfica de Gnome para ajustar manualmente la frecuencia de la
    CPU. No ofrece automatización alguna.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Gráfica</ti>
  <ti>Estado de la batería</ti>
  <ti>Todos disponibles</ti>
  <ti>Ninguno</ti>
  <ti>
    Sólo para KDE, se requiere del gobernador 'ondemand' para la calibración
    dinámica de frecuencia.
  </ti>
</tr>
</table>

<p>
Aunque a primera vista parece simple ajustar la frecuencia al nivel actual de
carga, no es una tarea trivial. Un mal algoritmo puede causar que se cambie
entre dos frecuencias todo el tiempo o gastar energía cuando se ajusta la
frecuencia a un nivel innecesariamente alto.
</p>

<p>
¿Cuál elegir? Si no tiene idea acerca de esto, primero intente <c>cpufreqd</c>:
</p>

<pre caption="Instalando cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> puede ser configurado editando <path>/etc/cpufreqd.conf</path>.
La configuración por defecto que viene con cpufreqd puede parecer algo
confusa. Recomendamos reemplazarla con la hecha por el desarrollador de Gentoo
Henrik Brix Andersen (ver más abajo).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=ondemand

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=performance
</pre>

<p>
Si está usando un núcleo 2.6 con la interfaz sysfs (probablemente sí)
no puede usar un porcentaje como los descritos arriba en min_freq y max_freq.
Reempláacelo con la frecuencia más baja y alta que despliega <c>cpufreq-info
--hwlimits</c>. Por ejemplo, en un portátil Pentium M 1.4 GHz se configuraron
los siguiente valores:
</p>

<pre caption="Valores de muestra para minfreq y maxfreq">
minfreq=600000
maxfreq=1400000
</pre>

<p>
Último pero no menos importante, inicie el demonio.
</p>

<pre caption="Iniciando cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<warn>
No ejecute al mismo tiempo más de uno de los programas indicados arriba.
Puede causar confusión como intercambios sucesivos entre dos frecuencias.
</warn>

</body>
</section>

<section>
<title>Verificando el resultado</title>

<body>

<p>
La última cosa por chequear es que sus nuevas políticas hagan bien el trabajo.
Una forma fácil de comprobarlo es monitoreando la velocidad de la CPU mientras
esté trabajando con su portátil:
</p>

<pre caption="Monitoreando la velocidad de la CPU">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Si no se actualiza <path>/proc/cpuinfo</path> (ver sección de Solución de
Problemas), monitoree la frecuencia de la CPU con:
</p>

<pre caption="Monitoreo alternativo de la velocidad de la CPU">
# <i>watch x86info -mhz</i>
</pre>

<p>
Dependiendo de su configuración, la velocidad de la CPU debería aumentar en
situaciones de alta carga, disminuir cuando no hay actividad o permenecer en el
mismo nivel. Cuando se usa cpufreqd y el nivel de verbosidad está ajustado en
5 o más en <path>cpufreqd.conf</path>, obtendrá información adicional de
lo que está pasando y será reportada a syslog.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Administración de Energía de la pantalla LCD</title>
<section>
<title>Consumidor de energía # 1</title>
<body>
<p>
Como puede ver en la <uri link="#doc_chap1_fig1">figura 1.1</uri>, la pantalla
LCD consume la mayor parte de la energía (puede que no sea el caso para CPUs no
móviles). Por tanto, es bien importante no sólo apagar la pantalla cuando ésta
no se necesite, sino también reducir su contraluz si es posible. La mayoría de
los portátiles ofrece la posibilidad para controlar la disminición de aquello.
</p>

<p>
La primera cosa a revisar son los tiempos de standby/suspensión/apagado de la
pantalla. Como esto depende fuertemente de su gestor de ventanas, le dejaremos esa
tarea. Hay dos lugares en común: Se puede blanquear el terminal con  <c>setterm
-blank &lt;número de minutos&gt;</c>, <c>setterm -powersave on</c> y <c>setterm
-powerdown &lt;número de minutosM&gt;</c>.
Para Xorg, modifique  <path>/etc/X11/xorg.conf</path> en forma similar a ésto:
</p>

<pre caption="Ajustes para suspender el LCD en Xorg y XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Blanquea la pantalla luego de 5 minutos (Falso)</comment>
  Option  "StandbyTime"  "10"  <comment># Apaga la pantalla luego de minutos (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Suspensión total luego de 20 minutos</comment>
  Option  "OffTime"  "30"  <comment># Apagado completo pasado una media hora</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Esto es lo mismo para XFree86 y <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probablemente es más importante la disminución de contraluz. Si tiene acceso a
los ajustes de disminución via alguna herramienta, escriba un pequeño guión que
disminuya el contraluz en el modo battery y ubíquelo en su nivel de ejecución
<e>battery</e>. El siguiente script debería funcionar en la mayoría de los
portátiles IBM Thinkpad. Necesita el paquete <c>app-laptop/ibm-acpi</c> o
debe estar activada la opción apropiada en su núcleo. 
</p>

<warn>
El soporte para el ajusto del brillo está marcado como experimental en
ibm-acpi. Este accede directamente al hardware y puede causar daño severo
a su sistema. Por favor, lea el <uri link="http://ibm-acpi.sourceforge.net/">
sitio Web ibm-acpi</uri>.
</warn>

<p>
Para poder ajustar el nivel de brillo debe ser cargado el módulo ibm_acpi 
con el parámetro experimental.
</p>

<pre caption="Cargando automáticamente el módulo ibm_acpi">
<comment>(¡Por favor, lea las advertencias indicadas arriba antes de seguir!)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
Esto debería funcionar sin mensajes de error y debería ser creado el
archivo <path>/proc/acpi/ibm/brightness</path> luego de que sea cargado
el módulo. Un script de inicio se preocupará de elegir el brillo de acuerdo
a la fuente de energía que esté presente.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Vea /proc/acpi/ibm/brightness para los valores disponibles</comment>
<comment># Por favor lea /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># Nivel de brillo en modo CA (Corriente Alterna). El valor por defecto es 7.</comment>
BRIGHTNESS_AC=7

<comment># Nivel de brillo en modo batería. El valor por defecto es 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "Check that ibm_acpi is loaded into the kernel"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Cuando esté listo, asegúrese de que el brillo sea ajustado de forma automática
mediante la adición de este al nivel de ejecución battery.
</p>

<pre caption="Activando el ajuste de brillo automático">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Administración de energía del Disco</title>
<section>
<title>Dormir cuando se esté inactivo</title>
<body>

<p>
Hagamos que el disco duro duerma tan pronto como sea posible, siempre y cuando
no se necesite. Le mostraré dos posibilidades para hacerlo. Primero
<c>cpudyn</c> acepta la Administración de Energía del Disco. Descomente las
líneas en la sección "Disk Options" en <path>/etc/conf.d/cpudyn</path>. Para
que su primer disco duro duerma después de 60 segundos de inactividad, debería
modificarlo como sigue:
</p>
<pre caption="Usando cpudyn para disco en suspensión temporal">
<comment>################################################
# DISK OPTIONS
# (disabled by default)
################################################

#
# Timeout to put the disk in standby mode if there was no
# io during that period (in seconds)
#
</comment>
TIMEOUT=60
<comment>
#
# Specified disks to spindown (comma separated devices)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
La segunda posibilidad es usar un pequeño guión y hdparm. Cree el archivo
<path>/etc/init.d/pm.hda</path> como se indica a continuación:
</p>
<pre caption="Usando hdparm para la suspensión temporal del disco">
#!/sbin/runscript

depend() {
   after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Revise las opciones con <c>man hdparm</c>. Si su guión está listo, agréguelo al
nivel de ejecución battery.
</p>

<pre caption="Automatizando la configuración de la suspensión temporal del disco">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Sea cuidadoso con los ajustes de disminución de velocidad/rotación de su disco
duro. Ajustándolos a valores pequeños puede que dañe su disco y pierda la
garantía.
</impo>
</body>
</section>

<section>
<title>Aumentando el tiempo de inactividad - laptop-mode</title>
<body>

<p>
Los núcleos recientes (2.6.6 y superiores, versiones actuales de la serie 2.4 y
otros con parches) incluyen el denominado <e>laptop-mode</e>. Cuando está
activado, los contenidos de las memorias de tránsito en estado sucio se escriben a disco
cuando hay llamadas de lectura o después de 10 minutos (en vez de 30 segundos).
Esto minimiza el tiempo de rotación del disco.
</p>

<pre caption="Inicio automatizado de laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> tiene su archivo de configuración en
<path>/etc/laptop-mode/laptop-mode.conf</path>. Ajústelo de la forma que le
guste, está bien comentado. Ejecute <c>rc-update add laptop_mode battery</c> 
para iniciarlo automáticamente.
</p>
</body>
</section>

<section>
<title>Otros trucos</title>
<body>

<p>
Además de colocar su disco en el modo de suspensión tan pronto sea posible, es
buena idea minimizar los accesos al disco. Déle una mirada a los procesos que
escriben frecuentemente al disco - syslogd es un buen candidato. Probablemente
no quiera apagarlo por completo, pero es posible modificar el archivo de
configuración de manera que no se registren cosas "innecesarias" y por tanto no
crear de esta forma tráfico al disco. Cups escribe periódicamente al disco, así
que considere apagarlo y actívelo manualmente sólo cuando lo necesite.
</p>

<pre caption="Inhabilitar cups en el modo batería">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Otra posibilidad es desactivar el archivo de intercambio ("swap".) en el modo
batería. Antes de escribir el guión para realizar el swapon/swapoff, asegúrese
que haya suficiente memoria RAM y que el archivo de intercambio no se use
intensivamente, de otro modo estará en problemas.
</p>

<p>
Si no quiere usar el laptop-mode, todavía es posible minimizar el acceso
al disco montando ciertos directorios como <e>tmpfs</e> - los accesos de
escritura no son almacenados en el disco sino que permanecen en memoria
principal y se pierden al desmontar. A menudo es útil montar el directorio
<path>/tmp</path> de esta forma - pues no se le presta mayor atención
ya que se limpia en cada arranque sin importar si fue montado en disco
o en RAM. Sólo asegúrese tener suficiente RAM y que no haya algún programaa
(tal como un cliente de descargas o herramienta de compresión) que necesite
mucho espacio en <path>/tmp</path>. Para activar ésto, active la opción de
tmpfs en su núcleo y agregue a una línea como la siguiente al
<path>/etc/fstab</path>:
</p>

<pre caption="Editando /etc/fstab para que el /tmp sea aún más volátil">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Preste atención al parámetro "size" y modifíquelo para su sistema. Si no está
seguro, no intente probar esto, puede convertirse fácilmente en un cuello
de botella del rendimiento. En caso de que quiera montar el <path>/var/log</path>
de esta manera, asegúrese de escribir los archivos de bitácora a disco antes
de desmontar el directorio. Son archivos esenciales. No intente montar el
directorio /var/tmp de esta forma. Portaga lo usa para compilar ...
</warn>
</body>
</section>
</chapter>

<chapter>
<title>Administración de Energía para otros dispositivos</title>
<section>
<title>Administración de Energía para tarjetas inalámbricas</title>
<body>

<p>
Las tarjetas LAN inalámbricas consumen bastante energía. Colóquelas en el
modo de Administración de Energía en analogía al guión pm.hda.
</p>

<pre caption="Administración de Energía automatizada para WLAN">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Al iniciar este guión se configurará wlan0 en el modo de Administración de Energía
y se cambiará al modo "sleep" luego de haber pasado tres segundos en ausencia de tráfico.
Guárdelo como  <path>/etc/init.d/pm.wlan0</path> y agreguélo al nivel de ejecución
battery tal como se hizo con el guión para el disco de más arriba. Vea <c>man iwconfig</c>
para más detalles y opciones. Si su manejador y punto de acceso están habilitados para
cambiar el tiempo de reconocimiento de la señal ("beacon time"), ésto es un buen punto
de partida para ahorrar aún más energía:
</p>

<pre caption="Administración de Energía de WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>
</body>
</section>

<section>
<title>Administración de Energía USB</title>
<body>

<p>
Existen dos problemas con los dispositivos USB respecto al consumo de
energía: Primero, los dispositivos como el mouse USB, cámaras digitales
o llaveros USB consumen energía mientras están enchufados. No puede evitar
ésto (no obstante desenchúfelos es caso de que no se necesiten). Segundo, cuando
hay dispositivos USB enchufados, la controladora USB accede periódicamente
al bus lo que previene que la CPU entre en el modo « sleep  C3/4. La respuesta por
parte del SO a este problema es la llamada "suspensión selectiva USB", la cual no
ha sido implementada todavía en el núcleo. La suspensión selectiva USB sólo
permite acceso al bus en caso de que el dispositivo esté en uso. La solución
temporal mientras se implementa es la siguiente: Compile el soporte para USB
y los dispositivos como módulos y remúevalos mediante un guión a medida que
no se usen (Por ejemplo, cuando se cierra la tapa del portátil).
</p>
</body>
</section>
</chapter>

<chapter>
<title>Estados de sueño: Suspensión, en espera e hibernación </title>
<section>
<title>Visión general</title>
<body>

<p>
ACPI define tres estados de sueño. Los más importantes son:
</p>

<ul>
  <li>S1 alias En espera ("standby")</li>
  <li>S3 alias Suspensión a RAM o Suspensión</li>
  <li>S4 alias Suspensión a Disco o Hibernación</li>

</ul>

<p>
Dichos estados pueden ser invocados siempre y cuando el sistema no
esté en uso de forma de evitar apagar el sistema debido al largo tiempo
de arranque.
</p>
</body>
</section>

<section>
<title>Suspensión, En espera e Hibernación</title>
<body>

<p>
El soporte de ACPI para esos estados es considerado experimental por una buen
motivo. Los estados de sueño de APM parecen ser más estables, sin embargo, no
puede usar APM y ACPI juntos.
</p>

<warn>
Aunque está mejorando con creces el soporte de los estados de sueño, aún se
considera algo experimental. Al menos, se pudo hacer funcionar swsusp2 y suspensión
a RAM, pero le advertimos: Ésto es muy probable que no le funcione con el riesgo
de dañar sus datos/sistema.
</warn>

<p>
Actualmente hay tres implementaciones para S4. El original denominado
swsusp, luego está swsusp2 que tiene la interfaz más agradable de todas
(incluyendo soporte para bootsplash), pero requiere de parchar manualmente
el núcleo. La última no menos importante es Suspend-to-Disk, un clon de
swsup.
</p>

<p>
Si esto lo confundió, déle una mirada a la <uri
link="http://softwaresuspend.berlios.de/features.html#compare">comparación de
características</uri>. Si aún sigue confundido y no sabe cuál elegir, primero
intente con swsusp2, se ve como la más prometedora.
</p>

<p>
La parte relacionada al núcleo para ésto es como sigue:
</p>

<pre caption="Configuración del núcleo para los diversos tipos de suspensión">
Power Management Options ---&gt;

  <comment>(suspensión y en espera)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernación con swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)

  <comment>(hibernación con swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"su-swap-aquí")    Default resume device name

  <comment>(hibernación con Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"su-swap-aquí") Default resume partition
</pre>

<p>
Compile su núcleo con las opciones apropiadas activadas y ejecute  <c>cat
/proc/acpi/sleep</c> para la serie 2.4 y <c>cat /sys/power/state</c> para
la 2.6 y así averiguar qué es lo que está soportado. Para swsup, debe
agregar el parámetro del núcleo <c>resume=/dev/"su-swap-aquí"</c>. Si no
puede realizar el arranque debido a una imagen dañada, use <c>noresume</c>
para swsup, <c>pmdisk=off</c> para Suspend-to-Disk y <c>noresume2</c> for
swsusp2.
</p>

<p>
Para colocar su sistema en uno de los estados de sueño, use
</p>

<pre caption="Activando los estados de sueño">
<comment>(serie 2.4 del núcleo)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>En espera ("standby")</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(Suspensión)</comment>

<comment>(serie 2.6 del núcleo)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>En espera ("standby")</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(Suspensión)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(Hibernar)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(Hibernar)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                   <comment>(Hiberar, vea más abajo)</comment>
</pre>

<warn>
Respalde sus datos antes de realizar ésto. Ejecute <c>sync</c> antes de correr
uno de los comandos para que los datos en caché se escriban al disco. Primero,
inténtelo fuera de X, luego con X corriendo pero sin haber ingresado.
</warn>

<p>
Si experimenta un error del tipo "kernel panic" debido a uhci o similar, intente
compilar el soporte USB como módulo y remueva los módulos antes de enviar
a su portátil a un modo de suspensión.
</p>

<p>
Aunque lo anterior debería ser suficiente para que corra swsup
y Suspend-to-Disk (no necesariamente que funcionen), swsusp2 necesita
de especial atención.
La primera cosa por hacer es aplicar un parche al núcleo con los que
se proveen en <uri link="http://softwaresuspend.berlios.de/">
http://softwaresuspend.berlios.de/</uri>. Adicionalmente tiene  que
instalar <c>hibernate-script</c>. Una vez instalado, configure <path>/etc/hibernate/hibernate.conf</path>
y pruebe si funciona:
</p>

<pre caption="Configurar hibernation">
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Última oportunidad para respaldar datos)</comment>
<i># hibernate</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Solución de Problemas</title>
<section>
<title>Si las cosas no van bien ...</title>
<body>

<p>
<e>P:</e>
Estoy intentando cambiar la frecuencia de la CPU pero
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> no existe.
</p>

<p>
<e>R:</e>Asegúrese que su procesador soporta la característica de calibración
de frecuencia de la CPU y que haya elegido el manejador CPUFreq adecuado (kernel
2.6.7): ARM Integrator, ARM-SA1100,ARM-SA1110, AMD Elan - SC400, SC410,
AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon,
AMD Opteron, AMD Athlon 64, Cyrix Media GXm,
Intel mobile PIII e Intel mobile PIII-M en algunos chipsets, Intel Pentium 4,
Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX,
Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, varios
"PowerBook" e "iBook2" y algunos procesadores en sistemas ACPI 2.0-compatible
(sólo si está disponible la opción "ACPI Processor Performance States" en la interfaz
ACPI/BIOS).
</p>

<p>
<e>P:</e> Mi portátil tiene la capacidad de calibración de la frecuencia, pero
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> está vacío.
</p>

<p>
<e>R:</e> Revise los errores relacionados a ACPI en el núcleo con
<c>dmesg | grep ACPI</c>. Intente actualizar la BIOS, en especial
si se reporta que está dañado el DSDT. También puede intentar arreglándolo
por si mismo (lo que escapa del alcance de esta guía).
</p>

<p>
<e>P:</e> Mi portátil tiene la capacidad de calibración de la frecuencia, pero
de acuerdo a <path>/proc/cpuinfo</path> la velocidad nunca cambia.
</p>

<p>
<e>R:</e> Es probable que haya activado en su núcleo el soporte para multiprocesamiento
simétrico (CONFIG_SMP). Desactívelo y debería funcionar. Algunos
núcleos antiguos tienen un error que causa ésto. En ese caso, ejecute <c>emerge x86info</c>,
actualice su núcleo tal como se pide y chequee la frecuencia actual con <c>x86info -mhz</c>.
</p>

<p>
<e>P:</e> Puedo cambiar la frecuencia de la CPU, no obstante el rango no es tan amplio
como lo es en otro SO.
</p>

<p>
<e>R:</e> Puede combinar la calibración de la frecuencia con la regulación
de temperatura de la CPU ("ACPI CPU throttling") para obtener un mínimo más bajo
de frecuencia. Note que la regulación de temperatura del procesador no ahorra
mucha energía y se usa principalmente con propósitos de gestión térmica
(mantener su portátil a baja temperatura y en silencio). Puede leer el estado
actual de regulación de temperatura del procesador con <c>cat
/proc/acpi/processor/CPU/throttling</c> y cambiarlo con <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c> donde x es uno de los Tx estados mencionados
en <path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>P:</e> Al configurar el núcleo aparecen los gobernadores powersave, performance y
userspace, pero falta el relacionado a ondemand. ¿Dónde lo obtengo?
</p>

<p>
<e>R:</e> El gobernador ondemand sólo está incluido en las fuentes recientes del
núcleo. Intente actualizarlas.
</p>

<p>
<e>P:</e> La vida la batería parece ser peor que antes.
</p>

<p>
<e>R:</e> Revise la configuración de su BIOS. Quizás olvidó reactivar algunos ajustes.
</p>

<p>
<e>P:</e> Mi batería está cargada, pero KDE reporta que el nivel actual es 0% restante y
se apaga de inmediato.
</p>

<p>
<e>R:</e> Revise que esté compilado el soporte de batería en su núcleo. Si puede usarlo como
módulo, asegúrese que esté cargado.
</p>

<p>
<e>P:</e> Tengo un portátil Dell Inspiron 51XX y no obtengo eventos ACPI.
</p>

<p>
<e>R:</e> Esto parece ser un error del núcleo. Lea el siguiente <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">reporte</uri>.
</p>

<p>
<e>P:</e> Me acabo de comprar una batería nueva, ¡pero dura sólo unos pocos minutos!
¿Qué estoy haciendo mal?
</p>

<p>
<e>R:</e> Primero siga los consejos de su fabricante acerca de cómo cargar adecuadamente
la batería.
</p>

<p>
<e>P:</e> Lo mencionado anteriormente no me ayudó. ¿Qué debería hacer entonces?
</p>

<p>
<e>R:</e> Algunas baterías vendidas como "nuevas" en realidad son viejas. Intente lo
siguiente:
</p>

<pre caption="Consultando el estado de la batería">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Si el ítem "última capacidad llena" ("last full capacity") difiere significativamente
de la capacidad diseñada, su batería está probablemente dañada. Intente reclamar
su garantía.
</p>

<p>
<e>P:</e> Mi problema no aparece mencionado acá. ¿Qué debería hacer?
</p>

<p>
<e>R:</e> No dude en contactar directamente a <mail link="fragfred@gmx.de">Dennis
Nienhüser</mail>.
</p>
</body>
</section>
</chapter>
</guide>
