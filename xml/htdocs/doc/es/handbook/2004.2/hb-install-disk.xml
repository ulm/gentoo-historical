<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/handbook/2004.2/hb-install-disk.xml,v 1.1 2004/11/16 11:12:59 chiguire Exp $ -->

<sections>
<section>
<title>Introducción a Dispositivos de Bloque</title>
<subsection>
<title>Dispositivos de Bloque</title>
<body>

<p>
Examinaremos de forma detallada los aspectos de Gentoo Linux así como
Linux en general que tengan que ver con discos, sistemas de ficheros
de Linux, particiones y dispositivos de bloque. Una vez esté
familiarizado con las entrañas de los discos y sistemas de ficheros,
le guiaremos a través del proceso de creación de particiones y
sistemas de ficheros de tu instalación Gentoo Linux. 
</p>

<p>
Para empezar, introduciremos el término <e>dispositivos de
bloque</e>. Quizás el dispositivo de bloque más conocido es el que
representa la primera unidad IDE llamada <path>/dev/hda</path> en un
sistema Linux. Si tu máquina utiliza discos SCSI entonces el primer
disco duro se denominará <path>/dev/sda</path>.
</p>

<p>
Los dispositivos de bloque mencionados anteriormente representan una
interfaz abstracta de disco. Las aplicaciones pueden hacer uso de
estas interfaces para interactuar con el disco duro de la máquina sin
importar el tipo de unidad que tienes: IDE, SCSI, o cualquier otra. La
aplicación puede simplemente dirigirse al almacenamiento en el disco
como a una serie de bloques de acceso aleatorio de 512-bytes situados
de forma contigua.
</p>
</body>
</subsection>

<subsection>
<title>Particiones y Porciones de Disco</title>
<body>

<p>
Aunque teóricamente es posible utilizar el disco duro completo para
albergar la instalación Linux, esto casi nunca se hace. En su lugar,
los dispositivos de bloque enteros se dividen en partes más manejables
y pequeñas. En la mayoría de sistemas éstas se llaman
<e>particiones</e>, y en otras arquitecturas que utilizan una técnica
similar las llaman <e>porciones</e>.
</p>
</body>
</subsection>

<subsection>
<title>Particiones</title>
<body>

<note>
Esta descripción teórica sólo es relevante para arquitecturas x86.
</note>

<p>
Particiones se dividen en tres tipos:
<e>primarias</e>, <e>extendidas</e> y <e>lógicas</e>.
</p>

<p>
La particion <e>primaria</e> es aquella que almacena su información en
el MBR (registro principal de arranque). Ya que el MBR puede almacenar
hasta 512 bytes, sólo pueden definirse cuatro particiones primarias
(por ejemplo, desde <path>/dev/hda1</path> hasta
<path>/dev/hda4</path>).
</p>

<p>
Una partición <e>extendida</e> es un tipo especial de partición
diseñada para contener dentro de sí otras particiones (una de las
cuatro posibles particiones primarias tiene que ser extendida). Al
principio no existía este tipo de partición, pero como cuatro
primarias eran muy pocas, se diseñó para extender el esquema de
particionamiento sin perder la compatibilidad inversa.
</p>

<p>
Una partición <e>lógica</e> es aquella que está dentro de la partición
extendida. En otras palabras, estas particiones no se definen dentro
del MBR, sino que se declaran dentro de la partición extendida.
</p>
</body>
</subsection>

<subsection>
<title>Almacenamiento Avanzado</title>
<body>

<p>
Algunas arquitecturas (incluyendo x86) proporcionan soporte para EVMS
(en inglés, Enterprise Volume Management System) manejo empresarial de
volúmenes o LVM2 (en inglés, Logical Volume Management) manejo lógico
de volúmenes, si has arrancado desde un LiveCD Gentoo. EVMS y LVM2
incrementan la flexibilidad ofrecida por el esquema de
particionamiento. Durante la instalación las instrucciones
principalmente se enfocan sobre particiones "habituales", pero es
bueno saber que EVMS y LVM2 también están soportadas.
</p>
</body>
</subsection>
</section>

<section>
<title>Diseñando un Esquema de Particionamiento</title>
<subsection>
<title>Esquema de Particionamiento por Defecto</title>
<body>

<p>
Si no está interesado en diseñar un esquema de particionamiento
particular para tu sistema, puede hacer uso del esquema por defecto
(sin LVM) que utilizamos en este manual.
</p>

<p>
Para arquitecturas x86 o amd64:
</p>

<table>
<tr>
  <th>Partición</th>
  <th>Sistema de Ficheros</th>
  <th>Tamaño</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partición de arranque</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partición de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>El resto del disco</ti>
  <ti>Partición de raíz</ti>
</tr>
</table>

<p>
Para arquitectura ppc:
</p>

<table>
<tr>
  <th>Partición NewWorld</th>
  <th>Partición OldWorld</th>
  <th>Sistema de Ficheros</th>
  <th>Tamaño</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(innecesaria)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partición de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>El resto del disco</ti>
  <ti>Partición de raíz</ti>
</tr>
</table>

<p>
Para arquitectura Sparc:
</p>

<table>
<tr>
  <th>Etiqueta de Disco Sun</th>
  <th>Sistema de Ficheros</th>
  <th>Tamaño</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partición de arranque</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partición de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>La totalidad del disco</ti>
  <ti>Partición Sun Disk Label (obligatoria)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>El resto del disco</ti>
  <ti>Partición de raíz</ti>
</tr>
</table>

<p>
Si estás realizando una instalación a partir de una distribución
existente, primero debe redimensionar las particiones actuales (en
caso de que no tenga espacio suficiente) para poder instalar
Gentoo. Puede usar <uri
link="http://www.gnu.org/software/parted">GNU/Parted</uri> para
modificar el tamaño de las particiones.
</p>

<p>
Si está interesado en saber el tamaño que debería tener una partición
(o volumen lógico), o incluso cuantas particiones (o volúmenes)
necesita, continue leyendo. En caso contrario siga con el
particionamiento del disco:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Uso de fdisk sobre x86 o amd64 para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Uso de fdisk sobre Alpha para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Uso de fdisk sobre SPARC para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Uso de mac-fdisk sobre PPC para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Uso de fdisk sobre HPPA para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Uso de fdisk sobre MIPS para Particionar tu Disco</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>¿Cuántas? y ¿de qué tamaño?</title>
<body>

<p>
El número de particiones que necesita depende mucho de su entorno
particular. Por ejemplo, si la máquina tiene muchos usuarios, lo más
probable es que desee tener <path>/home</path> en una partición
separada para facilitar las tareas de copia de respaldo y aumentar la
seguridad. Si está instalando Gentoo para funcionar como servidor de
correo, debe tener <path>/var</path> sobre una partición separada ya
que es allí dónde se almacena todo el correo. Asimismo, una buena
elección de sistema de ficheros optimizará el rendimiento del
equipo. Las estaciones de juegos deben disponer de una partición
<path>/opt</path> ya que la mayoría de juegos se instalan en ese
directorio. Las razones para todas estas recomendaciones son similares
a aquellas que hemos mencionado para el caso de <path>/home</path>:
seguridad y salvaguarda de datos.
</p>

<p>
Como puede ver, todo depende de lo que quiera conseguir. Tener
particiones o volúmenes separados tiene las siguientes ventajas:
</p>

<ul>
<li>
  Puede elegir el mejor sistema de ficheros para cada partición o volumen
</li>

<li>
  El equipo en su totalidad no puede quedar sin espacio si una
  herramienta o aplicación está escribiendo datos de forma continua al
  volumen o partición
  </li>
<li>
  Si es el caso, el tiempo dedicado a las comprobaciones de integridad
  de sistemas de fichero se reduce ya que las comprobaciones pueden
  ser llevadas acabo en paralelo (sin embargo esta ventaja es mayor
  con múltiples discos que con múltiples particiones)
</li>

<li>
  La seguridad puede ser aumentada montando algunas de las particiones
  en modo sólo lectura, nosuid (los setuid bits se ignoran), noexec
  (los bits de ejecución se ignoran), etc.
</li>
</ul>

<p>
Pero, tener múltiples particiones tiene una gran desventaja: si la
configuración no es la adecuada, puede acabar teniendo mucho espacio
libre en una de las particiones y quedar sin espacio en otras.
</p>

<p>
Como ejemplo de un esquema de particionamiento utilizaremos un disco
duro de 20 Gb de un portátil para fines de demostración (incluye
servidor web, servidor de correo, gnome, etc.):
</p>

<pre caption="Ejemplo de particionamiento">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Espacio sin particionar para uso futuros: 2 Gb.)</comment>
</pre>

<p>
<path>/usr</path> parece estar bastante llena (83%), pero una vez que
todo el software esté instalado no tiende a llenarse más. La gente
puede pensar que el espacio que asignamos a <path>/var</path> es
excesivo, sin embargo hay que saber que Gentoo compila todas las
aplicaciones en <path>/var/tmp/portage</path>, por lo tanto se debe
tener una capacidad mínima de 1 Gb de <path>/var</path> si no se
planea compilar aplicaciones grandes, en caso contrario se recomienda
tener 3 Gb libres, si desea compilar KDE y OpenOffice.org a la vez.
</p>

<p>
Ahora particione el/los disco/s según las instrucciones de ejemplo
disponibles para su arquitectura:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Uso de fdisk sobre x86 o amd64 para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap4">Uso de fdisk sobre Alpha para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap5">Uso de fdisk sobre SPARC para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap6">Uso de mac-fdisk sobre PPC para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap7">Uso de fdisk sobre HPPA para Particionar tu Disco</uri>
</li>
<li>
  <uri link="#doc_chap8">Uso de fdisk sobre MIPS para Particionar tu Disco</uri>
</li>
</ul>

</body>
</subsection>
</section>

<section>
<title>Uso de fdisk sobre x86 o amd64 para Particionar tu Disco</title>
<subsection>
<body>

<impo>
Esta sección es sólo para aquellos usuarios que tengan sistemas
basados en <e>x86</e> o <e>amd64</e>.
</impo>

<p>
Las siguientes instrucciones explican como particionar el disco duro
según el esquema descrito anteriormente:
</p>

<table>
<tr>
  <th>Partición</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partición de arranque</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partición de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partición de raíz</ti>
</tr>
</table>

<p>
Cambie el esquema de particionamiento según su propio criterio.
</p>

</body>
</subsection>

<subsection>
<title>Examinando el Esquema de Particionamiento Actual</title>
<body>

<p>
<c>fdisk</c> es una herramienta potente y bastante popular que permite
dividir el disco en particiones. Arranca <c>fdisk</c> sobre tu unidad
de disco (en nuestro ejemplo usamos el dispositivo de disco
<path>/dev/hda</path>):
</p>

<pre caption="Iniciando fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Una vez que <c>fdisk</c> esté en ejecución, el programa ofrecerá el
siguiente símbolo de comandos:
</p>

<pre caption="Símbolo de espera de órdenes de fdisk">
Command (m for help): 
</pre>

<p>
Teclee <c>p</c> para mostrar el esquema de particionamiento actual:
</p>

<pre caption="Listado del particionamiento actual">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Este disco en particular está configurado para albergar siete sistemas
de ficheros Linux, cada uno con su correspondiente partición con la
etiqueta "Linux", así como una partición de intercambio (swap) que
aparece con la etiqueta "Linux swap".
</p>

</body>
</subsection>

<subsection>
<title>Eliminación de todas las Particiones</title>
<body>

<p>
Primero eliminaremos todas las particiones existentes en el
disco. Teclee <c>d</c> para eliminar una partición, seguido por
intro. Por ejemplo, para borrar una partición existente en
<path>/dev/hda1</path>:
</p>

<pre caption="Eliminando una partición">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
La partición ha sido marcada para su borrado. Ya no aparecerá si
teclea <c>p</c>, pero no será eliminada hasta que guarde los cambios
realizados. Si comete una equivocación y desea abortar los cambios
realizados, teclee <c>q</c> inmediatamente y pulse intro; las
particiones no serán eliminadas.
</p>

<p>
Ahora, asumiendo que intenta eliminar todas las particiones existentes
del disco duro, debe teclear <c>p</c> en forma repetida para ver el
listado de particiones y pulsar <c>d</c> junto con el número de la
partición para borrarlas. Finalmente, acabará teniendo una tabla de
particiones vacía:
</p>

<pre caption="Una tabla de particiones vacía">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Ahora que la tabla de particiones en memoria del sistema está vacía,
estamos preparados para crear nuevas particiones. Utilizaremos el
esquema por defecto, tal como hemos acordado anteriormente. ¡Claro
está, que no debe seguir estas instrucciones al píe de la letra si no
desea tener una tabla de particiones exactamente igual que la nuestra!
</p>
</body>
</subsection>

<subsection>
<title>Creación de una Partición de Arranque</title>
<body>

<p>
En primer lugar debemos crear una pequeña partición de
arranque. Teclee <c>n</c> para crear esta nueva partición, y luego
<c>p</c> para seleccionar una partición primaria, siguiendo por
<c>1</c> para elegirla como primera partición primaria. Cuando el
sistema solicite introducir el primer cilindro, pulse intro y cuando
pida definir el valor del último cilindro, teclee <c>+32M</c> para
crear una partición de tamaño 32 Mb.:
</p>

<pre caption="Creando una partición de arranque">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Pulsa Intro)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Si ahora teclea <c>p</c>, debe ver la siguiente partición en la tabla:
</p>

<pre caption="Una partición creada">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Necesitamos hacer que esta partición sea arrancable. Teclee <c>a</c>
para marcar esta partición como arrancable. Si introduce <c>p</c> de
nuevo, verá que el <path>*</path> ha aparecido en la columna "Boot".
</p>
</body>
</subsection>

<subsection>
<title>Creación de una Partición de Intercambio</title>
<body>

<p>
Vamos a crear ahora la partición de intercambio. Para hacerlo, teclee
<c>n</c> para crear una nueva partición, y luego <c>p</c> para
comunicar a fdisk que debe ser una partición primaria. Entonces teclee
<c>2</c> para crear la segunda partición primaria,
<path>/dev/hda2</path> en nuestro caso. Cuando el sistema solicite
introducir el valor del primer cilindro, pulse intro y cuando solicite
introducir el valor del último, teclee <c>+512M</c> para crear una
partición de 512 Mb. Cuando lo haya hecho, teclee <c>t</c> para
establecer el tipo de partición, <c>2</c> para seleccionar la
partición que acaba de crear y entonces <c>82</c> para fijar el tipo
"Linux Swap". Una vez completados estos pasos la introducción de
<c>p</c> visualizará la tabla de particiones que debe ser similar a
ésta.
</p>

<pre caption="Listado de particiones después de la creación de la partición de intercambio">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>

<subsection>
<title>Creación de la Partición de Raíz</title>
<body>

<p>
En el último lugar, creamos la partición de raíz. Introduzca <c>n</c>
para crear la nueva partición, <c>p</c> para marcarla como partición
primaria. A continuación teclee <c>3</c> para crear la tercera
partición primaria, <path>/dev/hda3</path>, según nuestro ejemplo. Al
solicitar la introducción del valor del primer cilindro de la
partición pulsamos intro, mientras que cuando el sistema solicite que
introduzcamos el valor del último cilindro, también le damos a intro
para crear una partición que ocupe todo el espacio restante en el
disco. Tras completar todos estos pasos, introducimos <c>p</c> para
ver la tabla de particiones que debe parecer mucho a la siguiente:
</p>

<pre caption="Listado de particiones después de crear la partición de raíz">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

</body>
</subsection>

<subsection>
<title>Almacenamiento de la Tabla de Particiones</title>
<body>

<p>
Para guardar el esquema de particionamiento y salir del <c>fdisk</c>
tecleamos <c>w</c>.
</p>

<pre caption="Guardado y salida del fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ahora que las particiones están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>

</body>
</subsection>
</section>

<section>
<title>Uso de fdisk sobre Alpha para Particionar tu Disco</title>
<subsection>
<body>

<impo>
Esta sección es sólo para aquellos usuarios que tengan sistemas basados en <e>Alpha</e>.
</impo>

<p>
Las siguientes instrucciones explican como particionar el disco duro
según el esquema descrito anteriormente:
</p>

<table>
<tr>
  <th>Porción</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Porción de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Porción de raíz</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>La totalidad del disco (obligatorio)</ti>
</tr>
</table>

<p>
Cambie el esquema de particionamiento según su propio criterio.
</p>

</body>
</subsection>

<subsection>
<title>Identificación de Discos Disponibles</title>
<body>

<p>
Para averiguar que discos dispone, utilize los siguientes comandos:
</p>

<pre caption="Averiguamos que discos tenemos">
<comment>(Para discos IDE)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Para discos SCSI)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
A partir de la salida que nos proporcionan los comandos anteriores
podemos ver que discos han sido detectados y sus respectivos
dispositivos <path>/dev</path> registrados. En lo sucesivo, asumiremos
que el disco que se detectó era un SCSI en <path>/dev/sda</path>.
</p>

<p>
Y ahora, arranque <c>fdisk</c>:
</p>

<pre caption="Arrancando fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>

<subsection>
<title>Borrado de Todos Porciones de Disco</title>
<body>

<p>
Empezamos eliminando todas las porciones a <e>excepción</e> de la
porción 'c'. El siguiente ejemplo muestra como eliminar una porción de
disco (en este ejemplo 'a'). Repita todo el proceso para eliminar las
porciones restantes (salvo la porción 'c').
</p>

<p>
Usa <c>p</c> para ver todas las porciones existentes. El comando
<c>d</c> se utiliza para borrar una porción.
</p>

<pre caption="Eliminación de una porción">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Tras repetir el proceso para todas las porciones, el listado debe ser
similar a este:
</p>

<pre caption="Examinando la esquema vacía">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>

<subsection>
<title>Creación de la Porción de Intercambio</title>
<body>

<p>
En sistemas Alpha no se necesita tener una partición de arranque. Sin
embargo, el primer cilindro no puede ser utilizado ya que la imagen
<c>aboot</c> será almacenada allí.
</p>

<p>
Crearemos una porción de intercambio en el tercer cilindro, con un
tamaño total de 1 Gb. Teclee <c>n</c> para crear una nueva
porción. Después de haberla creado, cambiaremos su tipo tecleando
<c>1</c>, lo que significa <e>swap</e>.
</p>

<pre caption="Creando una porción de intercambio">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Después de realizar todos los pasos mencionados, debe observar algo
similar a ésto:
</p>

<pre caption="El esquema después de la creación de porción de intercambio">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>

<subsection>
<title>Creación de la Porción de Raíz</title>
<body>

<p>
Ahora procederemos a crear la porción de raíz, empezando a partir del
primer cilindro <e>después</e> de la partición de intercambio. Teclee
<c>p</c> para ver dónde acaba la porción de intercambio. En nuestro
ejemplo, es en el cilindro 1003, por lo tanto la partición de raíz
empezará a partir del cilindro 1004.
</p>

<p>
En actualidad hay un fallo en <c>fdisk</c>, que le hace creer que el
número de cilindros es el número de cilindros reales más uno. En otras
palabras, cuando el programa pide introducir el último cilindro, hay
que rebajar el número de último cilindro por uno (en el ejemplo es
5290).
</p>

<p>
Cuando la partición ya esté creada, establecemos su tipo marcando
<c>8</c> lo que significa <e>ext2</e>.
</p>

<pre caption="Creación de la porción de raíz">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
El esquema de particionamiento debe ser similar a ésta:
</p>

<pre caption="Examinando el esquema">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>

<subsection>
<title>Almacenamiento del Esquema de Porciones y Salida</title>
<body>

<p>
Para guardar el esquema de particionamiento y salir del <c>fdisk</c>
tecleamos <c>w</c>.
</p>

<pre caption="Guardado y salida de fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ahora que las porciones ya están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>
</body>
</subsection>
</section>

<section>
<title>Uso de fdisk sobre SPARC para Particionar el Disco</title>
<subsection>
<body>

<impo>
Esta sección es sólo para aquellos usuarios que tengan sistemas basados en <e>SPARC</e>.
</impo>

<p>
Las siguientes instrucciones explican como particionar el disco duro
según el esquema descrito anteriormente:
</p>

<table>
<tr>
  <th>Partición</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partición de arranque</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partición de intercambio</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Etiqueta de Disco Sun (obligatoria)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Partición de raíz</ti>
</tr>
</table>

<p>
Cambia el esquema de particionamiento según tu propio criterio.
</p>
</body>
</subsection>

<subsection>
<title>Iniciando fdisk</title>
<body>

<p>
Arranca <c>fdisk</c> sobre tu unidad de disco (en nuestro ejemplo
usamos el dispositivo de disco es <path>/dev/hda</path>):
</p>

<pre caption="Iniciando fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Una vez <c>fdisk</c> esté en ejecución, el programa ofrecerá el
siguiente saludo:
</p>

<pre caption="Símbolo de espera de órdenes de fdisk">
Command (m for help):
</pre>

<p>
Teclee <c>p</c> para mostrar el esquema de particionamiento actual:
</p>

<pre caption="Listado particionamiento actual">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Es importante anotar que la etiqueta <c>Sun disk label</c> figura en
la tabla anterior. En caso de que no estuviese, el disco está
utilizando el particionamiento DOS y no el de Sun. En este caso,
teclee <c>s</c> para asegurarse que la tabla de particiones es de
Sun.
</p>
</body>
</subsection>

<subsection>
<title>Eliminación de todas las Particiones</title>
<body>

<p>
Ya es hora de eliminar todas las particiones en el disco. Teclee
<c>d</c> para eliminar una partición seguido, por intro. El sistema
solicitará el número de la partición que desea eliminar. Para borrar
la partición existente <path>/dev/hda1</path> debería teclear lo
siguiente:
</p>

<pre caption="Eliminando una partición">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Asumiendo que desea borrar todas las particiones existentes, teclee
<c>p</c> para mostrar el listado de particiones disponibles y <c>d</c>
para borrarlas una por una. Si cree que ha cometido algún error,
teclee <c>q</c> inmediatamente, <c>fdisk</c> no realiza cambios
inmediatamente en la tabla de particiones, sino en su memoria y sólo
cuando introduzca <c>w</c> las modificaciones se escriben al disco.
</p>

<p>
Al cabo de haber borrado todas las particiones, la tabla debe aparecer
de siguiente modo:
</p>

<pre caption="Una tabla de particiones vacía">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>

</body>
</subsection>

<subsection>
<title>Creación Partición Sun Disk Label</title>
<body>

<p>
Ahora que la tabla de particiones en memoria de <c>fdisk</c> está
vacía estamos preparados para crear una partición Sun Disk Label. Para
hacerlo debe teclear <c>n</c>, y a continuación <c>3</c> para crear la
partición. Cuando el sistema solicite introducir el primer cilindro,
pulse intro y cuando pida definir el último, también. Una vez hecho
eso, teclee <c>t</c> para establecer el tipo de partición y luego
<c>5</c> para marcarla como "Whole disk" (totalidad del disco).
</p>

<pre caption="Pasos para crear un Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Press Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Después de haber completado todos estos pasos, si tecleamos <c>p</c>
el programa mostrará la tabla de particiones:
</p>

<pre caption="Ver la tabla de particiones">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>

<subsection>
<title>Creación de una Partición de Arranque</title>
<body>

<p>
En primer lugar debemos crear una pequeña partición de
arranque. Teclee <c>n</c> para crear esta nueva partición, y luego
<c>p</c> para seleccionar una partición primaria, siguiendo por
<c>1</c> para elegirla como primera partición primaria. Cuando el
sistema solicite introducir el primer cilindro, pulse intro y cuando
pida definir el valor del último cilindro, teclee <c>+32M</c> para
crear una partición de tamaño 32 Mb. Asegúrese que la partición de
arranque se encuentra dentro los primeros 2 Gb del disco.
</p>

<pre caption="Creando una partición de arranque">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Press Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Si ahora teclea <c>p</c>, debe ver la siguiente partición en la tabla:
</p>

<pre caption="Listado de tabla de particiones">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>

<subsection>
<title>Creación de una Partición de Intercambio</title>
<body>

<p>
Como próximo paso crearemos una partición de intercambio. Teclee
<c>n</c> para crear una nueva partición y <c>2</c> para establecer su
número <path>/dev/hda2</path> en este caso. Cuando el sistema solicite
introducir el valor del primer cilindro, pulse intro. Y cuando
solicite introducir el valor del último, teclee <c>+512M</c> para
crear una partición con tamaño 512 Mb. Cuando lo haya hecho teclee
<c>t</c> para establecer el tipo de partición, y <c>82</c> para fijar
el tipo "Linux Swap". Asimismo, teclee <c>p</c> para ver la
configuración actual de la tabla de particiones:
</p>

<pre caption="Listado de particiones disponibles">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>

<subsection>
<title>Creación de la Partición de Raíz</title>
<body>

<p>
En el último lugar creamos la partición de raíz. Introduzca <c>n</c>
para crear la nueva partición, y <c>4</c> para crear la cuarta
partición primaria, <path>/dev/hda4</path>, según nuestro ejemplo. Al
solicitar la introducción del valor del primer cilindro de la
partición pulsamos intro, mientras que cuando el sistema solicite que
introduzcamos el valor del último cilindro, también le damos al intro
para crear una partición que ocupa todo el espacio restante en el
disco. Tras completar todos estos pasos, introducimos <c>p</c> para
ver la tabla de particiones que debe parecer mucho a la siguiente:
</p>

<pre caption="Listado de particiones después de crear la partición de raíz">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>

<subsection>
<title>Guardado y Salida</title>
<body>

<p>
Para guardar el esquema de particionamiento y salir del <c>fdisk</c>,
tecleamos <c>w</c>.
</p>

<pre caption="Guardado y salida del fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Ahora que las particiones están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>

</body>
</subsection>
</section>

<section>
<title>Uso de mac-fdisk sobre PPC para Particionar tu Disco</title>
<body>

<p>
En este punto crearemos las particiones utilizando <c>mac-fdisk</c>:
</p>

<pre caption="Arrancando mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Primero, elimine todas las particiones existentes a fin de hacer
espacio para tus particiones Linux. Usa <c>d</c> en <c>mac-fdisk</c>
para borrar particiones. El programa solicitará el número de partición
a eliminar.
</p>

<p>
Segundo, cree una partición <e>Apple_Bootstrap</e> tecleando
<c>b</c>. En este paso se le solicitará el número de bloque a partir
del cual desea empezar. Si previamente ha seleccionado <c>3</c> como
número de partición, introduzca <c>3p</c>.
</p>

<note>
Esta porción del disco <e>no</e> corresponde a la partición de
arranque. Linux no la utiliza para nada. No debe crear ningún sistema
de fichero en esta partición, ni tampoco montarla. Los usuarios de PPC
no necesitan una partición de arranque.
</note>

<p>
Cree una partición de intercambio pulsando <c>c</c>. De nuevo,
<c>mac-fdisk</c> solicitará el número de bloque inicial de la
partición. Ya que anteriormente hemos puesto <c>3</c> para crear
Apple_Bootstrap, ahora introduciremos <c>4p</c>. Cuando el programa
pregunte por el tamaño de la partición, teclearemos <c>512M</c> (o
cualquier otro tamaño, sin embargo, el tamaño recomendado es 512). El
nombre de la partición debe ser introducido como <c>swap</c>
(obligatoriamente).
</p>

<p>
Iniciamos la creación de la partición de raíz, tecleando <c>c</c>,
seguido por <c>5p</c> para seleccionar el bloque para la partición de
raíz. Cuando el programa pregunte por el tamaño de la partición
introducimos <c>5p</c> de nuevo, lo que significa que <c>mac-fdisk</c>
debe interpretar como "Usar todo el espacio disponible". El nombre de
la partición debe ser <c>root</c> (obligatoriamente).
</p>

<p>
Para finalizar y escribir la tabla de particiones al disco tecleamos
<c>w</c> y <c>q</c> para salir de <c>mac-fdisk</c>.
</p>

<p>
Ahora que las particiones están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>

</body>
</section>

<section>
<title>Uso de fdisk sobre HPPA para Particionar tu Disco</title>
<body>

<p>
Utiliza <c>fdisk</c> para crear las particiones que necesites:
</p>

<pre caption="Particionamiento de Disco">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO precisa una partición especial para funcionar. Debe crear una
partición de por lo menos 16 Mb de tamaño al principio del disco. La
partición debe ser de tipo <e>f0</e> (Linux/PA-RISC boot).
</p>

<impo>
Si ignoras este aviso sobre la creación de la partición PALO, tu
máquina dejará de quererte y no arrancará.
</impo>

<p>
Además, si tu disco es mayor de 2 Gb, asegúrate que la partición de
arranque está dentro de los primeros 2 Gb. PALO no es capaz de leer un
kernel más allá del límite de 2 Gb.
</p>

<p>
Ahora que lass particiones están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>

</body>
</section>

<section>
<title>Uso de fdisk sobre MIPS para Particionar tu Disco</title>
<!-- Esta sección está pegada tal cual del texto original de Kumba, -->
<!-- que probablemente debe ser reescrito, pero eso parece un poco -->
<!-- complicado. ¿Hay alguna alma caritativa que me quiera donar un -->
<!-- MIPS? :) -->
<!-- ~SwifT -->

<subsection>
<title>Creación Partición SGI Disk Label</title>
<body>

<p>
Todos los discos en un sistema SGI requieren <e>SGI Disk Label</e>,
que lleva acabo las mismas funciones que las etiquetas de sistema de
Sun y MS-DOS. La etiqueta almacena información acerca de particiones
en el disco. La creación de una nueva partición SGI Disk Label creará
dos particiones especiales en el disco duro:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (9ª partición): Esta partición es muy
    importante. Allí es dónde se almacenan las imágenes del
    kernel. Para guardar allí el kernel, deberás utilizar una
    herramienta llamada <c>dvhtool</c> para copiar las imágenes a ésta
    partición. Sólo entonces podrás arrancar tus kernels desde esta
    partición a través de SGI PROM Monitor. 
  </li>

  <li>
    <e>SGI Volume</e> (11ª partición): Esta partición parece mucho a
    la tercera partición Sun Disklabel "Whole Disk" (totalidad del
    disco). Esta partición incluye todo el disco duro y no debe ser
    modificada. Esta porción del disco no realiza ninguna función
    específica salvo la de ayudar a PROM de forma informal y
    indocumentada o alternativamente se utilizada por IRIX de alguna
    forma.
  </li>
</ul>

<warn>
La partición SGI Volume Header <e>tiene que</e> empezar desde el
cilindro 0, en caso contrario no se podrá arrancar del disco.
</warn>

<p>
A continuación incluimos un ejemplo de sesión de trabajo con
<c>fdisk</c>. Léalo detenidamente y modifica a gusto:
</p>

<pre caption="Creación de SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
En caso de que el disco ya tenga un SGI Disklabel creada, fdisk no
permitirá la creación de una nueva. Hay dos formas de solucionar este
problema. El primero es crear un Disklabel de Sun o de MS-DOS, guardar
los cambios y reiniciar <e>fdisk</e>. La segunda solución es
sobrescribir los datos de la tabla de particiones con información nula
a través del siguiente comando: <c>dd if=/dev/zero of=/dev/sda bs=512
count=1</c>.
</note>
</body>
</subsection>

<subsection>
<title>Ajuste de Tamaño de SGI Volume Header</title>
<body>

<p>
Ahora que el SGI Disklabel está creado, podemos empezar a definir las
particiones. En el ejemplo anterior, hemos creado dos
particiones. Éstas son las particiones especiales que mencionamos
anteriormente, no se puede alterar. Sin embargo, para instalar Gentoo,
tendremos que cargar múltiples imágenes de kernel directamente dentro
del la cabecera del volumen, ya que por ahora no hay ningún SGI
Bootloader disponible en Portage. La cabecera de volumen puede
almacenar hasta <e>ocho</e> imágenes de cualquier tamaño, cada uno con
máximo de ocho caracteres de nombre.
</p>

<p>
El proceso de cambio de tamaño de la cabecera del volumen no es
exactamente sencillo, hay un truco para conseguirlo. No se puede
simplemente eliminar y volver a leer la cabecera del volumen pese al
extraño comportamiento de fdisk. En el ejemplo a continuación
crearemos una cabecera de volumen de 50 Mb de capacidad y una
partición <e>/boot</e>. El esquema real de la tabla de particiones
puede variar, pues el ejemplo es sólo para fines demostrativos.
</p>

<pre caption="Modificación de SGI Volume Header">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Ojo que fdisk ahora solo permite recrear la Partición #1
empezando desde el cilindro 5 como mínimo)</comment>
<comment>(Si intentara borrar y recrear el SGI Volume Header de esta
manera encontrará el mismo problema.)</comment>
<comment>(En este ejemplo, queremos que /boot tenga 50 Mb, pues
empezamos desde el cilindro 51 (la cabecera de volumen debe empezar
desde el cilindro 0, ¿recuerda?), y fijamos el cilindro 101 como
último, lo que aproximadamente suma 50 Mb (+/- 1-5MB))</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Borrado de la Partición #9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Recreación de la Partición #9 justo antes de empezar la Partición #1)</comment>
</pre>

</body>
</subsection>

<subsection>
<title>Esquema de Particionamiento Final</title>
<body>

<p>
Una vez terminado con la tarea anterior, podemos crear el resto de
particiones como nos apetezca. Una vez que tenga organizadas las
particiones, asegúrese que el ID de la partición de intercambio es
<c>82</c>, correspondiente a "Linux Swap". Por defecto tendrá el ID
<c>83</c>, que corresponde a "Linux Native".
</p>

<p>
Ahora que las particiones están creadas, puede proseguir con la <uri
link="#filesystems">Creación de Sistemas de Ficheros</uri>.
</p>
</body>
</subsection>
</section>

<section id="filesystems">
<title>Creación de Sistemas de Ficheros</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Ahora que ya tiene creadas las particiones, debe formatearles para
poder tener un sistema de ficheros. Si no le importa el tipo de
sistema de ficheros que desee utilizar y está conforme con nuestra
elección por defecto, continúe con la sección <uri
link="#filesystems-apply">Creación de Sistema de Ficheros en una
Partición</uri>. En caso contrario, siga leyendo para ver qué sistemas
de ficheros puede utilizar ...
</p>
</body>
</subsection>

<subsection>
<title>¿Sistemas de Ficheros?</title>
<body>

<p>
Hay diferentes sistemas de fichero disponibles. Algunos de estos
sistemas de ficheros son estables para todas las arquitecturas,
mientras que otras sólo sobre en algunas. La siguiente tabla muestra
el listado de sistemas de ficheros y arquitecturas en las que éstas
funcionan. Si la arquitectura esta dentro de "(...)", el sistema de
ficheros debe funcionar en él pero no se han realizado pruebas
todavía.
</p>

<table>
<tr>
  <th>Sistema de Ficheros</th>
  <th>Transaccionalidad</th>
  <th>Arquitectura</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>Todas las arquitecturas</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>sí</ti>
  <ti>Todas las arquitecturas</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>sí</ti>
  <ti>x86, hppa, alpha, (mips), (pcc), (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>sí</ti>
  <ti>x86, alpha, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>sí</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> es un sistema de ficheros Linux probado, pero no dispone
de soporte para transacciones, lo que significa que las comprobaciones
rutinarias al arrancar pueden tardar bastante tiempo. Ahora, hay
muchas opciones alternativas, sistemas de ficheros de nueva generación
con soporte para transacciones cuya integridad puede ser verificada
con mayor rapidez, por lo que gozan de mayor popularidad. Los sistemas
de ficheros transaccionales previenen retrasos durante el reinicio del
equipo, incluso cuando el sistema de ficheros está en un estado
inconsistente.
</p>

<p>
<b>ext3</b> es la versión transaccional de ext2, que proporciona
soporte para una rápida recuperación además de otros modos mejorados
de funcionamiento como registro completo y ordenado de datos. Ext3 es
un buen sistema de ficheros además de fiable. En mayoría de los casos
ofrece índices de rendimiento bastante decentes. Como no implementa
extensivamente los árboles (en inglés, trees) en su diseño interno, no
escala demasiado bien, lo que significa que no es una opción ideal
para sistemas de ficheros grandes, o situaciones cuando se trabaja con
ficheros grandes o grandes cantidades de ficheros en un sólo
directorio. Pero, dentro de los límites de su diseño, ext3 es un
sistema de ficheros excelente.
</p>

<p>
<b>ReiserFS</b> es un sistema de ficheros B*-tree (basado en árboles
balanceados) que tiene un gran rendimiento y que sobrepasa con creces
a ext2 y ext3 cuando se trate de trabajar con ficheros pequeños
(archivos menores de 4kb.), a veces diez o quince veces
mejor. ReiserFS es extremadamente escalable y soporta
transaccionalidad. Desde la versión 2.4.18+, ReiserFS es sólido y
estable para su uso en casos genéricos así como en casos extremos
cuando es necesario trabajar por ejemplo con sistemas de ficheros
grandes, utilizar múltiples ficheros pequeños o manejar archivos
grandes y directorios con miles y miles de ficheros.
</p>

<p>
<b>XFS</b> es un sistema de ficheros transaccional completamente
soportado por el kernel xfs-sources de Gentoo Linux. Viene con un
juego de características robustas y está optimizado para ser
escalable. Recomendamos el uso de este sistema de ficheros para
aquellas plataformas Linux que dispongan de dispositivos de
almacenamiento SCSI de alto rendimiento y/o almacenamientos de canal
de fibra (en inglés, fiber channel) con sistema de alimentación
ininterrumpida. XFS realiza un almacenamiento temporal agresivo de
datos en tránsito en RAM, pues aquellas aplicaciones con defectos de
diseño (de las cuales hay muchas) que no toman precauciones necesarias
durante la escritura de datos al disco pueden perderlos en caso de que
el sistema se apague de forma inesperada.
</p>

<p>
<b>JFS</b> de IBM es un sistema de ficheros de alto rendimiento con
soporte transaccional. Sólo recientemente ha entrado en fase de
producción por lo tanto en este momento todavía no hay datos
suficientes para opinar de forma favorable o negativa sobre su
estabilidad.
</p>
</body>
</subsection>

<subsection id="filesystems-apply">
<title>Creación de Sistema de Ficheros en una Partición</title>
<body>

<p>
Para crear un sistema de ficheros en una partición o volumen existen
herramientas específicas para cada sistema de ficheros:
</p>

<table>
<tr>
  <th>Sistema de Ficheros</th>
  <th>Comando de Creación</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Por ejemplo, para formatear la partición de arranque
(<path>/dev/hda1</path> según el ejemplo) en formato ext2 y la
partición de raíz (<path>/dev/hda3</path> según el ejemplo) en formato
ext3, utilizaría los siguientes comandos:  
</p>

<pre caption="Creación de un sistema de ficheros en una partición">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Y ahora, puede crear sistemas de fichero sobre sus particiones o
volúmenes lógicos recién creados.
</p>
</body>
</subsection>

<subsection>
<title>Activando la Partición de Intercambio</title>
<body>

<p>
<c>mkswap</c> es el comando usado para inicializar particiones swap:
</p>

<pre caption="Inicialización de una partición de intercambio">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Para activar la partición, usa el comando <c>swapon</c>:
</p>

<note>
Los usuarios de Knoppix que ya disponen de una partición de
intercambio en sus sistemas pueden saltarse esto ya que Knoppix activa
las particiones de intercambio existentes de forma automática.
</note>

<pre caption="Activación de una partición de intercambio">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Crea y activa tu partición de intercambio ahora.
</p>
</body>
</subsection>
</section>

<section>
<title>Montaje</title>
<body>

<p>
Ahora que las particiones están inicializadas y albergan sistemas de
ficheros, es la hora de montarlas. Utiliza el comando <c>mount</c>. No
olvides de crear puntos de montaje necesarios para cada partición que
has creado. Como ejemplo montamos la partición de raíz y de arranque:
</p>

<pre caption="Montaje de particiones">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Si quiere que su <path>/tmp</path> resida sobre una partición
diferente, asegúrese de cambiar los permisos después de montarla:
<c>chmod 1777 /mnt/gentoo/tmp</c>. Lo mismo debe ser aplicado a
<path>/var/tmp</path>.
</note>

<p>
También necesitamos montar el sistema de ficheros proc (la interfaz
virtual del kernel) en <path>/proc</path>. Asimismo, primero fijamos
el punto de montaje <path>/mnt/gentoo/proc</path> y a continuación
montamos el sistema de ficheros:
</p>

<pre caption="Creación de punto de montaje /mnt/gentoo/proc">
# <i>mkdir /mnt/gentoo/proc</i>
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Ahora puede proceder a la <uri link="?part=1&amp;chap=5">Instalación de Ficheros de Instalación de Gentoo</uri>.
</p>
</body>
</section>
</sections>
