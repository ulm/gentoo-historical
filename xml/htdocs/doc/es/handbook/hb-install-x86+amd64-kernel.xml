<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/handbook/hb-install-x86+amd64-kernel.xml,v 1.1 2006/08/15 21:51:35 yoswink Exp $ -->

<sections>

<version>3.14</version>
<date>2006-07-26</date>

<section>
<title>Zona Horaria</title>
<body>

<p>
Primero necesita seleccionar su zona horaria para que su sistema sepa
dónde está localizado. Busque su zona horaria en
<path>/usr/share/zoneinfo</path>, luego copielo a <path>/etc/localtime</path>.
Por favor, evite las zonas horarias  <path>/usr/share/zoneinfo/Etc/GMT*</path>
ya que los nombres no indican las zonas esperadas. Por ejemplo,
<path>GMT-8</path> es realmente GMT+8.
</p>

<pre caption="Configurar la Zona Horaria">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Suponga que quiere usar el GMT)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>
</body>
</section>

<section>
<title>Instalar las Fuentes</title>
<subsection>
<title>Elegir un Kernel</title>
<body>

<p>
El punto alrededor del cual se construyen todas las distribuciones es
el Kernel de Linux. Es la capa entre los programas de usuario y el
hardware del sistema. Gentoo proporciona a sus usuarios varias fuentes
de kernel. Una lista completa está disponible en la <uri
link="/doc/es/gentoo-kernel.xml">Guía Gentoo del Kernel</uri>.
</p>

<p test="func:keyval('arch')='x86'">
Para los sistemas basados en x86 tenemos, entre otros kernels, las
<c>vanilla-sources</c> (las fuentes predeterminadas del kernel
creadas por los desarrolladores del kernel de linux), las
<c>gentoo-sources</c> (fuentes del kernel parcheadas con características
que mejoran su rendimiento), ...
</p>

<p test="func:keyval('arch')='AMD64'">
Para los sistemas basados en AMD64 tenemos <c>gentoo-sources</c> (fuentes del
kernel de la versión 2.6 modifacdas con parches especificos de amd64 para
estabilidad, rendimiento y soporte de hardware).
</p>

<p>
Elija sus fuentes del kernel e instálelas usando <c>emerge</c>.
El parámetro <c>USE="-doc"</c> es necesario para evitar la instalación
de xorg-x11 u otras dependencias en este momento. El parámetro
<c>USE="symlink"</c> no es necesario en una instalación nueva, pero
asegura la correcta creación del enlace
simbólico <path>/usr/src/linux</path>:
</p>

<pre caption="Instalar unas fuentes del kernel">
# <i>USE="-doc symlink" emerge gentoo-sources</i>
</pre>

<p>
Cuando vea en <path>/usr/src</path> verá un enlace simbólico llamado
<path>linux</path> apuntando a las fuentes de su kernel. En este caso,
asumimos que la fuentes del kernel instaladas apuntan a
<c>gentoo-sources-<keyval id="kernel-version"/></c>. Su versión podría
ser distinta, así que por favor tenga esto presente.
</p>

<pre caption="Ver el enlace a las fuentes del kernel">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-<keyval id="kernel-version"/>
</pre>

<p>
Ahora vamos a configurar y compilar las fuentes del kernel. Puede usar
para esto <c>genkernel</c>, que construirá un kernel genérico como el
usado por el CD de instalación. Aquí explicaremos la configuración
"manual", ya que es la mejor manera de optimizar su entorno.
</p>

<p>
Si quiere configurar manualmente su kernel, continúe con <uri
link="#manual">Predeterminado: Configuración Manual</uri>. En cambio,
si quiere usar <c>genkernel</c> debe leer <uri
link="#genkernel">Alternativa: Usar genkernel</uri>.
</p>
</body>
</subsection>
</section>

<section id="manual">
<title>Predeterminado: Configuración Manual</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Configurar manualmente un kernel frecuentemente se ve como el
procedimiento más difícil que tiene que realizar un usuario de
Linux. Nada mas lejos de la verdad -- después de configurar un par de
kernels no recordará si fue difícil ;)
</p>

<p>
Sin embargo, una cosa <e>es</e> cierta: debe conocer su sistema cuando
empiece a configurar su kernel manualmente. Mucha información se puede
recolectar instalando pciutils (<c>emerge pciutils</c>) el cual contiene
<c>lspci</c>. Ahora será capaz de utilizar <c>lspci</c> en el entorno
chroot. Puede ignorar tranquilamente los avisos sobre <e>pcilib</e>
(como pcilib: cannot open /sys/bus/pci/devices) que <c>lspci</c> le
muestre. Alternativamente, puede ejecutar <c>lspci</c> desde un
entorno <e>no-chroot</e>. Los resultados son los mismos. También puede
ejecutar <c>lsmod</c> para ver que módulos del kernel usa el CD de
instalación (puede proporcionarle buenos consejos sobre qué habilitar).
</p>

<p>
Ahora vaya al directorio de sus fuentes y ejecute <c>make
menuconfig</c>. Esto lanzará un menú de configuración basado en
ncurses.
</p>

<pre caption="Invocar a menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Le darán la bienvenida varias secciones de configuración. Listaremos
primero algunas opciones que debe activar (de otro modo Gentoo no
funcionará, o no funcionará adecuadamente sin configuración
adicional).
</p>
</body>
</subsection>

<subsection>
<title>Activar Opciones Necesarias</title>
<body>

<p>
Primero que nada, active el uso de código y dispositivos en desarrollo
y experimentales. Esto es necesario, porque algunos dispositivos o
código importante no se verá:
</p>

<pre caption="Seleccionar código/drivers experimentales">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
Asegúrese de que todos los controladores vitales para el arranque
del sistema (como pueden ser los de SCSI, ...) están compilados
<e>dentro</e> del kernel y no como módulos o, de lo contrario,
su sistema no será capaz de arrancar correctamente.
</p>

</body>
<body test="func:keyval('arch')='AMD64'">

<p>
Luego procederemos a seleccionar el tipo exacto de procesador. El mantenedor
del núcleo x86_64 recomienda fervorosamente activar las características MCE
de manera que puedan ser notificados ante cualquier falla de hardware. En
x86_64 estos errores no son impresos a <c>dmesg</c> tal como sucede en
otras arquitecturas pero sí a <path>/dev/mcelog</path>. Esto requiere del
paquete <c>app-admin/mcelog</c>.
</p>

<pre caption="Seleccionar el tipo de procesador y características">
Processor type and features  --->
   [ ] Intel MCE Features
   [ ] AMD MCE Features
  Processor family (AMD-Opteron/Athlon64)  --->
    ( ) AMD-Opteron/Athlon64
    ( ) Intel EM64T
    ( ) Generic-x86-64"
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Seleccione la familia correcta de procesadores:
</p>

<pre caption="Seleccionar la familia de procesador correcta">
Processor type and features ---&gt;
  <comment>(Selecciónelo de acuerdo a su sistema)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

</body>
<body>

<p>
Vaya ahora a <c>File Systems</c> y seleccione los soportes para los
sistemas de archivos que use. <e>No</e> los compile como módulos, de
otro modo su sistema Gentoo no será capaz de montar sus
particiones. También seleccione <c>Virtual memory</c> y el <c>/proc file
system</c>.
</p>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Si utiliza un kernel 2.4, necesita seleccionar <c>/dev
file system</c> ya que 2.4 no soporta <c>udev</c>.
</p>

<pre caption="Seleccionar los sistemas de archivos necesarios">
<comment>(Con un kernel 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   automatically mount /dev at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(Con un kernel 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support

    [*] Virtual memory file system support (former shm fs)

<comment>(Seleccione una o mas de las siguientes opciones según las necesite su sistema)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Si su BIOS no es capaz de gestionar discos duros de gran tamaño y el tamaño
del que informa es menor del real, debe habilitar la siguiente opción para
tener acceso al disco duro completo:
</p>

<pre caption="Seleccionar soporte para redimensionamiento automático por geometría">
<comment>(Solo kernel 2.4.x)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

</body>
<body test="func:keyval('arch')='AMD64'">

<pre caption="Seleccionar los sistemas de ficheros necesarios">
File systems ---&gt;
 Pseudo Filesystems ---&gt;
    &lt;*&gt; /proc file system support
    &lt;*&gt; Virtual memory file system support (former shm fs)

<comment>(Seleccione una o más de las siguientes opciones según las necesite su sistema)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

</body>
<body>

<p>
No olvide activar el DMA para sus unidades:
</p>

<pre caption="Activating DMA">
 Device Drivers ---&gt;
   ATA/ATAPI/MFM/RLL support ---&gt;
     [*] Generic PCI bus-master DMA support
     [*]   Use PCI DMA by default when available
</pre>

<p>
Si está usando PPPoE para conectarse a Internet o está usando un módem
dial-up, necesitará las siguientes opciones en el kernel:
</p>

<pre caption="Seleccionar los controladores PPPoE necesarios" test="func:keyval('arch')='AMD64'">
Device Drivers ---&gt;
 Networking Support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<pre caption="Seleccionar los controladores PPPoE necesarios" test="func:keyval('arch')='x86'">
<comment>(Con un kernel 2.4.x)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports

<comment>(Con un kernel 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Las dos opciones de compresión no lo afectan pero no son necesarias,
ni para la opción<c>PPP over Ethernet</c>, tal vez solo sea usada por
<c>rp-pppoe</c> cuando configure un kernel en modo PPPoE.
</p>

<p>
Si lo requiere, no olvide incluir el soporte en el kernel para su
tarjeta ethernet:
</p>

<p test="func:keyval('arch')='x86'">
Si tiene un CPU Intel que soporte HyperThreading (tm), o tiene un
sistema multi-CPU, debe activar "Symmetric multi-processing support":
</p>

<p test="func:keyval('arch')='AMD64'">
Si tiene un sistema Opteron con múltiples CPUs o multi-núcleo (por ejemplo:
AMD64 X2), active "Symmetric multi-processing support":
</p>

<pre caption="Activar el soporte SMP">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<note>
En sistemas multi-núcleo, cada núcleo cuenta como un procesador.
</note>

<p>
Si usa dispositivos de entrada USB (como un ratón o teclado) no olvide
activarlos también:
</p>

<pre caption="Activar Soporte para Dispositivos de Entrada USB">
Device Drivers ---&gt;
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
Los usuarios de laptops que quieran soporte PCMCIA <e>no deben</e> usar
los controladores PCMCIA si eligen usar un kernel 2.4. Controladores
más recientes están disponibles a través del paquete <c>pcmcia-cs</c>
que será instalado después. Los usuarios de kernel 2.6 sin embargo, si
deben usar los controladores PCMCIA desde el kernel.
</p>

<p>
A la par que compila el soporte PCMCIA en el kernel 2.6, no olvide activar
el soporte para el puente de tarjetas PCMCIA que se encuentre en su sistema:
</p>

<pre caption="Activar el soporte PCMCIA para kenels 2.6">
 Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
 PCCARD (PCMCIA/CardBus) support  ---&gt;
     &lt;*&gt; PCCard (PCMCIA/CardBus) support
 <comment>(Seleccione 16 bit si necesita soporte para las antiguas tarjetas PCMCIA. La mayoría de la gente querrá utilizar esto.)</comment>
     &lt;*&gt;   16-bit PCMCIA support
     [*]   32-bit CardBus support
 <comment>(Seleccione los puentes adecuados a continuación)</comment>
     --- PC-card bridges
     &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
     &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
     &lt;*&gt; i82092 compatible bridge support (NEW)
     &lt;*&gt; i82365 compatible bridge support (NEW)
     &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
Cuando haya terminado de configurar el kernel, continúe con <uri
link="#compiling">Compilar e Instalar</uri>.
</p>
</body>
</subsection>

<subsection id="compiling">
<title>Compilar e Instalar</title>
<body>

<p>
Ahora que ya está configurado su kernel, es hora de compilarlo e
instalarlo. Salga de la configuración y comience con el proceso de
compilación:
</p>

<pre caption="Compilar el kernel" test="func:keyval('arch')='x86'">
<comment>(Para un kernel 2.4)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(Para un kernel 2.6)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<pre caption="Compilar el kernel" test="func:keyval('arch')='AMD64'">
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Cuando el kernel ha terminado de compilar, copie la imagen a
<path>/boot</path>. Use cualquier nombre que estime apropiado para su
kernel y recuérdelo, ya que le hará falta más adelante al configurar
el gestor de arranque. Recuerde reemplazar <c><keyval id="kernel-name"/></c>
con el nombre y versión de su kernel.
</p>

<pre caption="Instalar el kernel">
# <i>cp arch/<keyval id="arch-sub"/>/boot/bzImage /boot/<keyval id="kernel-name"/></i>
</pre>

<p>
Ahora continúe con <uri link="#kernel_modules">Módulos del Kernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternativa: Usar genkernel</title>
<body>

<p>
Si está leyendo esta sección, eligió usar nuestro guión
<c>genkernel</c> para configurar el kernel.
</p>

<p>
Ahora que el árbol de las fuentes del kernel está instalado, es hora
de compilarlo usando nuestro guión <c>genkernel</c> que automáticamente
construirá un kernel. <c>genkernel</c> trabaja configurando un kernel
prácticamente idéntico al kernel de nuestro CD de instalación. Esto significa
que cuando use <c>genkernel</c> para construir su kernel, su sistema
generalmente detectará todo su hardware en el arranque, tal como lo hace el
CD de instalación. Debido a que genkernel no requiere ningúna configuración
manual del kernel, es una solución ideal para esos usuarios que no se sienten
cómodos compilando sus propios kernels.
</p>

<p>
Ahora, veamos como usar genkernel. Primero, haga emerge al ebuild de
genkernel:
</p>

<pre caption="Instalar genkernel">
# <i>emerge genkernel</i>
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
A continuación, si va a configurar un kernel 2.6, copie la configuración
del kernel empleada por el CD de instalación al sitio donde genkernel
busca la configuración predeterminada de su kernel:
</p>

<pre caption="Copiar la configuración del kernel del CD de instalación">
<comment>(Solamente haga esto si está configurando un kenerl 2.6)</comment>
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

</body>
<body>

<p>
Ahora, compile las fuentes de su kernel ejecutando <c>genkernel all</c>
Recuerde que <c>genkernel</c> compila un kernel que soporta casi todo el
hardware, ¡esta compilación tardará un rato en terminar!
</p>

<p>
Observe que si su partición de arranque no usa ext2 o ext3 como
sistema de archivos, necesitará configurar manualmente su kernel
usando <c>genkernel --menuconfig all</c> y agregar soporte para su
sistema de archivos <e>en</e> el kernel (<e>no</e> como módulo). Los
usuarios de EVMS2 o LVM2 probablemente querrán añadir también los
argumentos <c>--evms2</c> or <c>--lvm2</c>.
</p>

<pre caption="Ejecutar genkernel">
# <i>genkernel all</i>
</pre>

<p>
Una vez que <c>genkernel</c> haya terminado, un kernel, un conjunto
completo de módulos y un <e>disco raíz de inicio</e> (initrd) serán
creados. Usaremos el kernel e initrd para configurar un gestor de
arranque mas tarde en este documento. Escriba los nombres del kernel y
de initrd ya que los necesitará para el archivo de configuración del
gestor de arranque. El initrd iniciará inmediatamente después del
arranque para realizar la autodetección de hardware (igual que en el CD
de instalación) antes que inicie su sistema "real".
</p>

<pre caption="Verificar los nombres del kernel e initrd creados">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Ahora vamos a realizar un paso más para que nuestro sistema sea más
parecido al CD de instalación, vamos a instalar <c>coldplug</c>. Mientras
initrd autodetecta el hardware necesario para arrancar su sistema,
<c>coldplug</c> autodetecta todo lo demás. Para instalar y habilitar
<c>coldplug</c>, escriba lo siguiente:
</p>

<pre caption="Instalar y habilitar coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Módulos del Kernel</title>
<subsection>
<title>Configurar los Módulos</title>
<body>

<note test="func:keyval('arch')='x86'">
Si se eligió un kernel 2.4, reemplace todas las menciones
a <c>2.6</c> por <c>2.4</c> durante esta sección.
</note>

<p>
Debe listar los módulos que quiera cargar automáticamente en
<path>/etc/modules.autoload.d/kernel-2.6</path>. Puede agregar
opciones extras a los módulos si lo desea.
</p>

<p>
Para ver todos los módulos disponibles, ejecute el comando <c>find</c>.
No olvide sustituir <c><keyval id="kernel-version"/></c> con la versión
del kernel que acaba de compilar:
</p>

<pre caption="Ver todos los módulos disponibles">
# <i>find /lib/modules/<keyval id="kernel-version"/>/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Por ejemplo, para cargar automáticamente el módulo <c>3c59x.o</c>,
edite el archivo <path>kernel-2.6</path> y escriba el nombre del
módulo ahí.
</p>

<pre caption="Editar /etc/modules.autoload.d/kernel-2.6">
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
3c59x
</pre>

<p>
Continúe la instalación con <uri link="?part=1&amp;chap=8">Configurar
su Sistema</uri>.
</p>
</body>
</subsection>
</section>
</sections>
