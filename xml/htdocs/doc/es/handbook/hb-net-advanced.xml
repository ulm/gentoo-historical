<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/handbook/hb-net-advanced.xml,v 1.6 2006/12/30 21:17:11 chiguire Exp $ -->

<sections>

<abstract>
Aquí aprenderemos como funciona la configuración - debe estar enterado
de esto antes de aprender sobre redes modulares.
</abstract>

<version>7.0</version>
<date>2006-08-30</date>

<section>
<title>Configuración Avanzada</title>
<body>

<p>
La variable <c>config_eth0</c> es el corazón de la configuración de una
interfaz. Es una lista de instrucciones de alto nivel para configurar la
interfaz (<c>eth0</c> en este caso). Cada comando en la lista de instrucciones
se ejecuta de manera secuencial. La interfaz será evaluada como OK si, al
menos, un comando funciona.
</p>

<p>
Aquí tiene una lista de instrucciones integradas:
</p>

<table>
  <tr>
    <th>Comando</th>
    <th>Descripción</th>
  </tr>
  <tr>
    <ti><c>null</c></ti>
    <ti>No hace nada</ti>
  </tr>
  <tr>
    <ti><c>noop</c></ti>
    <ti>
      Si la interfaz está funcionando y existe una dirección entonces aborta
      la configuración con éxito.
    </ti>
  </tr>
  <tr>
    <ti>una dirección IPv4 o IPv6</ti>
    <ti>Añade la dirección a la interfaz</ti>
  </tr>
  <tr>
    <ti>
      <c>dhcp</c>,<c>adsl</c> o <c>apipa</c> (o un comando propio perteneciente 
      a un módulo de terceras partes)
    </ti>
    <ti>
      Ejecuta el módulo que proporciona el comando. Por ejemplo <c>dhcp</c>
      ejecutará un módulo que proporcione dhcp, que pudiera ser uno cualquiera
      de los siguientes: <c>dhcpcd</c>, <c>udhcpc</c>, <c>dhclient</c> o
      <c>pump</c>.
    </ti>
  </tr>
</table>

<p>
Si un comando falla, puede especificar un comando de retorno (fallback). 
El retorno tiene que coincidir exactamente con la estructura de la 
configuración.
</p>

<p>
Puede encadenar estos comandos. Aquí se muestran algunos ejemplo reales:
</p>

<pre caption="Ejemplos de configuración">
<comment># Añadir tres direcciones IPv4</comment>
config_eth0=(
	"192.168.0.2/24"
	"192.168.0.3/24"
	"192.168.0.4/24"
)

<comment># Añadir una dirección IPv4 y dos IPv6</comment>
config_eth0=(
	"192.168.0.2/24"
	"4321:0:1:2:3:4:567:89ab"
	"4321:0:1:2:3:4:567:89ac"
)

<comment># Mantener la dirección asignada por el kernel, a menos que la 
interfaz se caiga, entonces asignar otra vía DHCP. Si DHCP falla entonces
añadir una dirección estática determinada mediante APIPA</comment>

config_eth0=(
	"noop"
	"dhcp"
)
fallback_eth0=(
	"null"
	"apipa"
)
</pre>

<note>
Cuando se utiliza el módulo <c>ifconfig</c> y se añade más de una dirección,
se crean alias de interfaz para cada dirección extra. De esta manera los dos
ejemplos anteriores tendrán interfaces <c>eth0</c>, <c>eth0:1</c> y
<c>eth0:2</c>.  No se puede hacer nada especial con estas interfaces ya que el
kernel y otros programas simplemente tratan <c>eth0:1</c> y <c>eth0:2</c> como
<c>eth0</c>.
</note>

<impo>
¡La orden de retorno es importante! Si no especificamos la opción <c>null</c>,
el comand <c>apipa</c> solamente sería ejecutado si el comando <c>noop</c>
falla.
</impo>

<note>
<uri link="?part=4&amp;chap=3#apipa">APIPA</uri> y
<uri link="?part=4&amp;chap=3#dhcp">DHCP</uri> serán tratados más adelante.
</note>

</body>
</section>
<section>
<title>Dependencias de red</title>
<body>

<p>
Los scripts en <path>/etc/init.d</path> pueden depender de una interfaz de 
red específica o, simplemente, de net (red). <c>net</c> puede definirse en 
<path>/etc/conf.d/rc</path> ya que puede significar cosas distintas utilizando
la variable <c>RC_NET_STRICT_CHECKING</c>.
</p>

<table>
  <tr>
    <th>Valor</th>
    <th>Descripción</th>
  </tr>
  <tr>
    <ti><c>none</c></ti>
    <ti>El servicio <path>net</path> se considera siempre funcionando</ti>
  </tr>
  <tr>
    <ti><c>no</c></ti>
    <ti>
      Básicamente significa que al menos uno de los servicios
      <path>net.*</path> sin contar <path>net.lo</path> debe estar
      funcionando. Esto podría ser usado por los usuarios de equipos
      portátiles que tienen una conexión wifi y una estática y solamente
      quieren tener una activa para que el servicio net aparezca como
      funcionando.
    </ti>
  </tr>
  <tr>
    <ti><c>lo</c></ti>
    <ti>
      Es la misma que la opción <c>no</c> pero <path>net.lo</path> también
      cuenta. Esto puede ser útil para la gente que no le importa que alguna
      interfaz en concreto se active durante el arranque.
    </ti>
  </tr>
  <tr>
    <ti><c>yes</c></ti>
    <ti>
      Con esto TODAS las interfaces de red DEBEN estar activas para que el
      servicio <path>net</path> se considere funcionando.
    </ti>
  </tr>
</table>

<p>
Pero, ¿y qué pasa si <path>net.br0</path> depende de <path>net.eth0</path> y
<path>net.eth1</path>?  <path>net.eth1</path> podría ser un dispositivo
wireless o ppp que necesita configurarse antes de añadirse al puente. Esto no
puede hacerse en <path>/etc/init.d/net.br0</path> ya que es un enlaces
simbólico a <path>net.lo</path>.
</p>

<p>
La respuesta es hacer nuestra propia función <c>depend()</c> en 
<path>/etc/conf.d/net</path>
</p>

<pre caption="dependencia de net.br0 en /etc/conf.d/net">
<comment># Puede utilizar cualquier tipo de dependencia (use, after, before) 
que puede encontrar en los actuales scripts</comment>

depend_br0() {
	need net.eth0 net.eth1
}
</pre>

<p>
Para una lectura más detallada sobre dependencias, consulte la sección
<uri link="?part=2&amp;chap=4#doc_chap4">
 "Guiones de Inicio"</uri> en el manual de Gentoo.
</p>

</body>
</section>

<section id="variable_name">
<title>Nombre de variables y valores</title>
<body>

<p>
Los nombre de variables son dinámicos. Normalmente sigue la estructura 
<c>variable_${interface|mac|essid|apmac}</c>. Por ejemplo, la variable 
<c>dhcpcd_eth0</c> guarda los valores para las opciones de dhcpcd para eth0
y <c>dhcpcd_essid</c> los valores para dhcpcd cuando cualquier interfaz se
conecta al ESSID "essid".
</p>

<p>
Sin embargo, no hay ninguna regla que indique que los nombre de las interfaces
sean ethx. De hecho, muchas interfaces wireless tienen nombres como wlanx, rax 
o ethx. También, algunas interfaces definidas por el usuario como pueden ser
puentes puede tener cualquier nombre, como foo. Para hacer la vida un poco más
interesante, los puntos de acceso wireless pueden tener nombres con caracteres
no alfanuméricos - esto es importante porque puede configurar los parámetros de
red por ESSID.
</p>

<p>
La desventaja de todo esto es que Gentoo usa variables bash para la red -
y bash no puede utilizar nada fuera de caracteres alfanuméricos ingleses.
Para solucionar esta limitación cambiamos cada carácter que no sea alfanumérico
inglés por un carácter <c>_</c>.
</p>

<p>
Otra desventaja de bash es el contenido de las variables - algunos caracteres
necesitan especificarse de manera especial. Esto se hace utilizando <c>\</c>
delante del carácter. A continuación tenemos una lista de caracteres
especiales que necesitamos indicar de esta manera. <c>"</c>,<c>'</c> y
<c>\</c>.  
</p>

<p>
En este ejemplo utilizamos ESSID wireless ya que puede contener un amplio
abanico de caracteres. Deberemos utilizar ESSID <c>My "\ NET</c>:
</p>

<pre caption="ejemplo de nombre para la variable">
<comment># Esto funciona, pero el dominio no es válido</comment>
dns_domain_My____NET="My \"\\ NET"

<comment># Lo que hay arriba configura el dominio dns a My "\ NET cuando una 
# tarjeta wireless se conecta a un AP cuyo ESSID es My "\ NET</comment>
</pre>

</body>
</section>
</sections>
