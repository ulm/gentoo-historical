<?xml version = '1.0' encoding = 'UTF-8' ?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/handbook/hb-install-ppc-kernel.xml,v 1.12 2006/05/03 19:18:08 chiguire Exp $ -->

<sections>

<version>2.17</version>
<date>2006-04-30</date>

<section>
<title>Zona horaria</title>
<body>

<p>
Primero necesitamos seleccionar la zona horaria para que nuestro
sistema sepa dónde está ubicado. Hay que buscar la zona horaria en
<path>/usr/share/zoneinfo</path>, y luego cópiela en
<path>/etc/localtime</path>. Por favor, tenga cuidado con las zonas horarias
de <path>/usr/share/zoneinfo/Etc/GMT*</path> pues sus nombres no hacen 
referencia a las zonas esperadas. Por ejemplo, <path>GMT-8</path> es 
en realidad GMT+8.
</p>

<pre caption="Configurar la zona horaria" >
# <i>ls /usr/share/zoneinfo</i>
<comment>(Suponiendo que queremos usar GMT)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalar las fuentes</title>
<subsection>
<title>Elegir un núcleo</title>
<body>

<p>
La base alrededor de la cual se construyen todas las distribuciones es
el núcleo (kernel) de Linux. Es la capa entre los programas de usuario
y el hardware del sistema. Gentoo proporciona a sus usuarios varias
fuentes de kernel. Una lista completa está disponible en la <uri
link="/doc/es/gentoo-kernel.xml" >Guía Gentoo del Kernel</uri>.
</p>

<p>
Sugerimos utilizar tanto las <c>vanilla-sources</c> como las 
<c>gentoo-sources</c> en PPC, ambos núcleos 2.6. El último está disponible
para una instalación sin red. Vamos, pues, a continuar con la instalación o
<c>emerge</c> de las fuentes del kernel.
La <c>USE="-doc"</c> es necesaria en este momento para prevenir la instalación
de xorg-x11 u otras dependencias. <c>USE="symlink"</c>  no es necesario en una
instalación nueva, pero nos asegura una correcta creación del enlace 
<path>/usr/src/linux</path>.
</p>

<pre caption="Instalar las fuentes del kernel" >
# <i>USE="-doc symlink" emerge gentoo-sources</i>
</pre>

<p>
En <path>/usr/src</path> se encuentra un enlace simbólico llamado 
<path>linux</path> apuntando a las fuentes del núcleo actual. En nuestro 
caso, el enlace a las fuentes del núcleo instaladas apunta a
<c>gentoo-sources-2.6.15</c>. Tenga en cuenta que su versión puede ser
diferente.
</p>

<pre caption="Ver el enlace a las fuentes del kernel" >
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           22  Mar 18 16:23 /usr/src/linux -&gt; linux-2.6.15-gentoo
</pre>

<p>
Ahora vamos a configurar y compilar las fuentes del núcleo. Puede usarse 
<c>genkernel</c> para construir un núcleo genérico como el usado por el 
CD de instalación, o podemos realizar una configuración manual que es la 
mejor manera de ajustar nuestro sistema.
</p>

<p>
Para configurar manualmente el núcleo, podemos seguir en <uri link="#manual">
Predeterminado: Configuración manual</uri>. En cambio,para usar 
<c>genkernel</c> podemos leer <uri link="#genkernel">Alternativa: Usar 
genkernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="manual" >
<title>Predeterminado: Configuración manual</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Configurar manualmente un núcleo se ve frecuentemente como el
procedimiento más difícil al que tiene que enfrentarse un usuario de
Linux. Nada mas lejos de la realidad: después de configurar un par de
núcleos no recordaremos si fue difícil la primera vez ;)
</p>

<p>
Sin embargo, una cosa <e>es</e> cierta: necesitaremos conocer nuestro sistema 
si queremos configurar el núcleo manualmente. Mucha de la información
necesaria se puede recolectar instalando pciutils (<c>emerge pciutils</c>) que
contiene <c>lscpi</c>. Ahora podremos utilizar <c>lscpi</c> en el entorno del
chroot. Se puede ignorar sin riesgo cualquier aviso que muestre <c>lspci</c> 
relativo a <e>pcilib</e> (como "pcilib: cannot open /sys/bus/pci/devices").
Alternativamente, se puede ejecutar <c>lscpi</c> desde un entorno <e>no
chroot</e>. Los resultados serían los mismos. También se puede ejecutar
<c>lsmod</c> para ver que módulos del núcleo usa el CD de instalación (puede
proporcionar buenos consejos sobre qué habilitar). Otro lugar para buscar
posibles pistas sobre que componentes habilitar es comprobar los mensajes del
kernel que se obtienen durante el proceso de inicio. Ejecute <c>dmesg</c> para
ver los mensajes del kernel.
</p>

<p>
Ahora hay que ir al directorio de las fuentes, para configurar el núcleo. Se
recomienda incluir inicialmente la configuración por defecto con 
<c>make defconfig</c> (para núcleos 2.6.15 y anteriores) o
<c>make pmac32_defconfig</c> (pra núcleos 2.6.16 y posteriores). Una vez
que la configuración por defecto haya sido incluida,
ejecutaremos <c>make menuconfig</c> que lanzará un menú de configuración
basado en ncurses.
</p>

<pre caption="Invocar a menuconfig" >
# <i>cd /usr/src/linux</i>
<comment>Sustituya el pmac32_defconfig siguiente por defconfig si está usando
un núcleo 2.6.15 o anterior</comment>
# <i>make pmac32_defconfig</i>
# <i>make menuconfig</i>
</pre>

<p>
Nos darán la bienvenida varias secciones de configuración. Listaremos
primero algunas opciones que se deben activar (de otro modo Gentoo no
funcionará, o no funcionará adecuadamente sin configuración
adicional).
</p>

</body>
</subsection>
<subsection>
<title>Activar opciones necesarias</title>
<body>

<p>
Primero que nada, activaremos el uso de código y dispositivos en
desarrollo y experimentales. Es necesario, porque algunos dispositivos
o código importante no aparecerían:
</p>

<pre caption="Seleccionar código/dispositivo expremiental" >
Code maturity level options --->
  [*] Prompt for development and/or incomplete code/drivers
General setup --->
  [*] Support for hot-pluggable devices
</pre>

<p>
Ahora, en <c>File Systems</c> seleccionaremos el soporte para los
sistemas de ficheros empleados. <e>No</e> deben compilarse como
módulos, en cuyo caso el sistema Gentoo no sería capaz de montar las
particiones. También debe seleccionarse el <c>/proc file system</c> y
<c>Virtual memory</c>.
</p>

<pre caption="Selecionar los sistemas de ficheros necesarios" >
File systems --->
  Pseudo Filesystems --->
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
<comment>(Deben seleccionarse una o más de las siguientes opciones según se necesite)</comment>
  &lt;*> Second extended fs support
  &lt;*> Ext3 journalling file system support  
  &lt;*> Reiserfs support
  &lt;*> XFS filesystem support
</pre>

<p>
Si usamos PPPoE o un módem para conectar a Internet, necesitaremos las
siguientes opciones del núcleo:
</p>

<pre caption="Seleccionando los controladores necesarios para PPPoE" >
Device Drivers --->
  Networking support --->
    &lt;*> PPP (point-to-point protocol) support
    &lt;*>   PPP support for async serial ports
    &lt;*>   PPP support for sync tty ports
</pre>

<p>
Las dos opciones de compresión no molestan pero no son necesarias. La
opción<c>PPP over Ethernet</c> tampoco es obligatoria, tal vez solo
sea usada por <c>rp-pppoe</c> cuando se configure PPPoE en modo
núcleo.
</p>

<p>
Si es necesario, no hay que olvidar incluir el soporte en el núcleo
para la tarjeta ethernet.
</p>

<p>
Los usuarios de sistemas NewWorld y OldWorld querrán igualmente activar 
el soporte HFS. Los usuarios de OldWorld lo necesitan para poder copiar 
el núcleo en la partición MacOS. Los usuarios de NewWorld lo necesitan
para configurar la partición especial Apple_Bootstrap:
</p>

<pre caption="Activar el soporte HFS" >
File Systems --->
  [*] HFS Support
</pre>

<p>
En el momento presente, la característica de núcleo preentivo es todavía 
inestable en PPC y puede causar fallos de compilación y de segmentación 
aleatorios. Se sugiere <c>encarecidamente</c> no usar esta opción.
</p>
 
<pre caption="Asegurarse que la opción Preemptible Kernel está desactivada">
Platform options ---&gt;
  [ ] Preemptible Kernel
</pre>

<p>
Si estamos arrancando desde Firewire, necesitaremos habilitar estas opciones. 
Si no queremos compilar el soporte embebido, necesitaremos incluir estos 
módulos y sus dependencias en un initrd.
</p>

<pre caption="Activar soporte para dispositivos firewire en el arranque">
  Device Drivers ---&gt;
    IEEE 1394 (FireWire) support ---&gt;
      &lt;*&gt; IEEE 1394 (FireWire) support
      &lt;*&gt;   OHCI-1394 support
      &lt;*&gt;   SBP-2 support (Harddisks etc.)
</pre>

<p>
Si estamos arrancando desde USB, necesitaremos habilitar estas opciones, si 
no queremos compilar el soporte embebido, necesitaremos incluir estos módulos 
y sus dependencias en un initrd.
</p>

<pre caption="Activar soporte para dispositivos USB en el arranque">
  Device Drivers ---&gt;
    USB support ---&gt;
      &lt;*&gt; Support for Host-side USB
      &lt;*&gt;   OHCI HCD support
      &lt;*&gt;   USB Mass Storage support
</pre>

<p>
No desactivaremos el soporte en el núcleo para el framebuffer porque se 
necesita para un arranque satisfactorio. Si utilizamos un chipset basado 
en NVIDIA deberemos utilizar el framebuffer de OpenFirmware. Si utilizamos 
un chipset basado en ATI, deberemos utilizar el controlador de framebuffer 
basado en el chipset (Mach64, Rage128 or Radeon).
</p>

<pre caption="Elegir un Controlador de Framebuffer">
  Device Drivers ---&gt;
  Graphics support ---&gt;
    &lt;*&gt; Support for frame buffer devices
    [*] Open Firmware frame buffer device support
    &lt;*&gt; ATI Radeon display support
    &lt;*&gt; ATI Rage128 display support
    &lt;*&gt; ATI Mach64 display support
    Console display driver support ---&gt;
    &lt;*&gt; Framebuffer Console support
</pre>

<note>
Si seleccionamos más de un dispositivo de framebuffer puede que se utilice por 
defecto un controlador no óptimo. Podemos tanto utilizar un sólo framebuffer 
como especificar el que queremos utilizar pasándolo como parámetro del núcleo 
durante el arranque, como por ejemplo <c>video=radeonfb</c>.
</note>
	 
<p>
Continuaremos con <uri link="#compiling" >Compilar e instalar</uri> al
acabar de configurar el núcleo.
</p>

</body>
</subsection>
<subsection id="compiling" >
<title>Compilar e instalar</title>
<body>

<p>
Ahora que ya está configurado el núcleo, es el momento para compilarlo
e instalarlo. Saldremos de la configuración y comenzaremos con el
proceso de compilación:
</p>

<pre caption="Compilar el núcleo" >
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Cuando el núcleo haya terminado de compilar, se ha de copiar la imagen
a <path>/boot</path> (hay que asegurarse que esté correctamente
montada en ordenadores Pegasos).
Si estamos utilizando BootX para arrancar, copiaremos el núcleo después.
</p>

<p>
Yaboot y BootX usan un núcleo sin comprimir a diferencia de otros gestores
de arranque. El núcleo sin comprimir se llama vmlinux y se encontrará en
<path>/usr/src/linux</path> una vez que el núcleo haya terminado de
compilarse. Si está utilizando una máquina Pegasos, el microcódigo del
Pegasos necesita un núcleo comprimido llamado zImage.chrp que puede
encontrarse en <path>/usr/src/linux/arch/ppc/boot/images</path>.
</p>

<pre caption="Instalar el kernel" >
# <i>cd /usr/src/linux</i>
<comment>reemplace &lt;kernel-version&gt; con la versión correspondiente del núcleo</comment>
<comment>(Apple/IBM)</comment>
# <i>cp vmlinux /boot/&lt;kernel-version&gt;</i>

<comment>(Pegasos)</comment>
# <i>cp arch/ppc/boot/images/zImage.chrp /boot/&lt;kernel-version&gt;</i>
</pre>

<p>
Ahora hay que continuar con <uri link="#kernel_modules" >Instalar
módulos del núcleo separadamente</uri>.
</p>

</body>
</subsection>
</section>
<section id="kernel_modules" >
<title>Instalar módulos del núcleo separadamente</title>
<subsection>
<title>Configurar los módulos</title>
<body>

<p>
Se deben poner los módulos que queramos cargar automáticamente en
<path>/etc/modules.autoload.d/kernel-2.6</path>. Se pueden agregar
opciones extras a los módulos si así se necesita.
</p>

<p>
Para ver todos los módulos disponibles, se puede ejecutar el comando
<c>find</c>. No hay que olvidar sustituir &quot;&lt;versión del
kernel>&quot; con la versión del kernel que hemos compilado:
</p>

<pre caption="Ver todos los módulos disponibles" >
# <i>find /lib/modules/&lt;kernel version>/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Por ejemplo, para cargar automáticamente el módulo <c>3c59x.o</c>, hay
que editar el fichero <path>kernel-2.6</path> y escribir en él el
nombre del módulo.
</p>

<pre caption="Editar /etc/modules.autoload.d/kernel-2.6" >
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6" >
3c59x
</pre>

<p>
Continuaremos la instalación con <uri link="?part=1&amp;chap=8"> Configurar el sistema</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel" >
<title>Alternativa: Usar genkernel</title>
<body>

<p>
Si hemos llegado a esta sección, es porque habremos elegido usar el
guión <c>genkernel</c> para configurar el kernel.
</p>

<p>
Ahora que el árbol de las fuentes del núcleo está instalado, es hora
de compilarlo usando el guión <c>genkernel</c> que automáticamente
construirá uno por nosostros. <c>genkernel</c> trabaja configurando un
núcleo prácticamente idéntico al núcleo del CD de instalación. Esto
significa que cuando se usa <c>genkernel</c> para construir el núcleo,
el sistema generalmente detectará todo el hardware durante el
arranque, tal como lo hace el CD de instalación. Debido a que genkernel 
no requiere ninguna configuración manual del núcleo, es una solución 
ideal para esos usuarios que no se sienten cómodos compilando sus propios 
núcleos.
</p>

<p>
Ahora, veamos como usar genkernel. Primero, hay que hacer emerge al
ebuild de genkernel:
</p>

<pre caption="Instalar genkernel" >
# <i>emerge genkernel</i>
</pre>

<p>
A continuación, hay que copiar la configuración del núcleo empleada
por el CD de instalación al sitio donde genkernel busca la
configuración predeterminada del núcleo:
</p>

<pre caption="Copiar la configuración del kernel del CD de instalación" >
# <i>zcat /proc/config.gz > /usr/share/genkernel/ppc/kernel-config-2.6</i>
</pre>

<p>
Si estamos usando firewire o USB para arrancar, necesitaremos añadir los 
módulos al initrd. Editaremos 
<path>/usr/share/genkernel/ppc/modules_load</path> y cambiaremos 
<c>MODULES_FIREWIRE="ieee1394 ohci1394 sbp2"</c> para el soporte de firewire 
o <c>MODULES_USB="usbcore ohci-hcd ehci-hcd usb-storage"</c> para el soporte 
de USB.
</p>

<p>
Ahora hay que compilar las fuentes del núcleo ejecutando <c>genkernel 
--genzimage all</c>. Para Pegasos necesitaremos usar una configuración 
diferente y crear una zImage en lugar del núcleo vmlinux usado en las 
máquinas Apple. Recordaremos que como <c>genkernel</c> compila un núcleo 
que soporta casi todo el hardware, esta compilación ¡tardará un rato en 
terminar!
</p>

<p>
Observaremos que si la partición de arranque no usa ext2 o ext3 como sistema 
de archivos, se necesita configurar manualmente el núcleo usando <c>genkernel 
--menuconfig --genzimage all</c> para agregar soporte para el sistema de 
archivos correspondiente <e>en</e> el núcleo (<e>no</e> como módulo). Los 
usuarios de EVMS2 o LVM2 probablemente querrán añadir también los argumentos 
<c>--evms2</c> or <c>--lvm2</c>.
</p>

<pre caption="Ejecutar genkernel" >
# <i>genkernel all</i>
</pre>

<pre caption="Ejecutar genkernel en el Pegasos">
# <i>genkernel --genzimage --kernel-config=/usr/share/genkernel/ppc/Pegasos all</i>
</pre> 

<p>
Una vez que <c>genkernel</c> haya terminado, un núcleo, un conjunto
completo de módulos y un <e>disco raíz de inicio</e> (initrd) habrán
sido creados. Usaremos el núcleo e initrd para configurar un gestor de
arranque más tarde en este documento. Escribiremos los nombres del
núcleo y de initrd ya que se necesitarán para el archivo de
configuración del gestor de arranque. initrd se iniciará
inmediatamente después del arranque para realizar la autodetección de
hardware (igual que en el CD de instalación) antes que se inicie el
sistema &quot;real&quot;. Nos aseguraremos de escribir también los
parámetros de arranque necesarios, puesto que se requieren para un
arranque correcto con genkernel.
</p>

<pre caption="Verificar los nombres del kernel e initrd creados" >
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Ahora vamos a dar un paso más para que nuestro sistema sea más
parecido al CD de instalación, vamos a instalar
<c>coldplug</c>. Mientras initrd autodetecta el hardware necesario
para arrancar el sistema, <c>coldplug</c> autodetecta todo lo
demás. Para instalar y habilitar <c>coldplug</c>, escribiremos lo
siguiente:
</p>

<pre caption="Instalar y habilitar coldplug" >
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Ahora continuaremos con <uri link="?part=1&amp;chap=8" >Configurar el
sistema</uri>.
</p>

</body>
</section>
</sections>
