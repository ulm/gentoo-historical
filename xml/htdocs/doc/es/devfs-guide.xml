<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/devfs-guide.xml,v 1.1 2005/02/24 22:22:55 chiguire Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/devfs-guide.xml" lang="es">
<title>Guía del Sistema de Archivos de Dispositivos</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Editor-Es">
  <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
</author>
<author title="Editor-Es">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>
<author title="Editor-Es">
  <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
</author>
<author title="Traductor">
  <mail link="eduardo_lazo@yahoo.com">Rodrigo Lazo Paz</mail>
</author>

<abstract>
En este documento encontrarás información sobre qué es en realidad
devfs y cómo trabajar con él.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>0.2</version>
<date>2005-02-05</date>

<chapter>
<title>¿Qué es el devfs?</title>
<section>
<title>Los (¿buenos?) viejos tiempos</title>
<body>

<p>
La implementación tradicional de Linux provee a los usuarios con un
directorio abstracto, llamado <path>/dev</path>. Dentro de este se
pueden encontrar los <e>nodos de dispositivos</e>, archivos especiales
que representan los dispositivos dentro del sistema. Por ejemplo,
<path>/dev/hda</path> representa el primer dispositivo IDE en el
sistema. Al proveer archivos de dispositivos a los usuarios, estos
pueden crear programas que interactúen con el hardware como si este
fuese un archivo regular en vez de utilizar APIs especiales.
</p>

<p>
Los archivos de dispositivos están divididos en dos grupos, los
llamados dispositivos de <e>caracteres</e> y lo dispositivos de
<e>bloques</e>.El primer grupo consiste en el hardware cuyos procesos
de lectura/escritura no tienen buffer. El segundo grupo, naturalmente,
consiste en el hardware cuyo proceso de lectura/escritura sí tiene
buffer. Ambos tipos pueden ser leídos un caracter a la vez, o en
bloques. Por lo que la nomenclatura puede sonar confusa y en realidad
es incorrecta.
</p>

<p>
Si le echas una mirada a algún archivo de dispositivo, es probable que
encuentres algo parecido a esto:
</p>

<pre caption = "Revisando la información sobre un archivo de dispositivo">
# <i>ls -l /dev/hda</i>
brw-rw----    1 root     disk       3,   0 Jul  5  2000 /dev/hda
</pre>

<p>
En el ejemplo previo podemos ver que <path>/dev/hda</path> es un
dispositivo de bloques. Sin embargo, más importante aún, tiene dos
números especiales asignados a él: <path>3, 0</path>. Este par es
llamado el par <e>mayor-menor</e>. Es utilizado por el kernel para
convertir el archivo de dispositivo en un dispositivo real. El mayor
corresponde a cierto dispositivo, el menor a un
sub-dispositivo. ¿Parece confuso? No lo es.
</p>

<p>
Dos ejemplos son <path>/dev/hda4</path> y <path>/dev/tty5</path>. El
primer archivo de dispositivo corresponde a la cuarta partición del
primer dispositivo IDE. Su par mayor-menor es <path>3, 4</path>. En
otras palabras, el menor corresponde a la partición mientras que el
mayor corresponde al dispositivo. El segundo ejemplo tiene <path>4,
5</path> como par mayor-menor. En este caso, el mayor corresponde al
controlador del terminal, mientras que el menor corresponde al numero
de terminal (en este caso, el quinto terminal).
</p>
</body>
</section>

<section>
<title>Los problemas</title>
<body>

<p>
Si le das una mirada al directorio <path>/dev</path>, encontrarás que
no solo todos tus dispositivos están listados, sino <e>todos</e> los
dispositivos que te puedas imaginar. En otras palabras, tienes
archivos de dispositivos por dispositivos que no tienes. Manejar tal
grupo de dispositivos es pesado, por decir menos. Imagine tener que
cambiar permisos a todos los archivos de dispositivos que tienen un
dispositivo correspondiente en tu sistema, y dejar el resto intacto.
</p>

<p>
Cuando añades un nuevo hardware a tu sistema, y este nuevo hardware no
tiene un archivo de dispositivo previamente diseñado, tienes que crear
uno. Usuarios avanzados saben como hacer esto utilizado
<c>./MAKEDEV</c> dentro del árbol del <path>/dev</path>, pero ¿Sabes
inmediatamente qué dispositivo crear?
</p>

<p>
Cuando tienes programas interactuando con el hardware utilizando
archivos de dispositivos, no puedes tener la partición raíz montada como
sólo lectura, dado que no puedes tener el directorio <path>/dev</path>
en otra partición, ya que <c>mount</c> necesita de <path>/dev</path>
para montar las particiones. 
</p>
</body>
</section>

<section>
<title>Las soluciones</title>
<body>

<p>
Como puedes imaginar, los hackers del núcleo han encontrado varias
soluciones para los problemas previamente mencionados. Sin embargo,
muchos de ellos sufren de otras carencias como se describe en
<uri>http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why</uri>.
Nosotros no vamos a hablar acerca de estas soluciones, sino que nos
concentraremos en una implementación que llegó a las fuentes oficiales
del núcleo: devfs.
</p>
</body>
</section>

<section>
<title>¿devfs como un ganador completo?</title>
<body>

<p>
devfs ataca todos los problemas listados. Sólo provee al usuario con
dispositivos existentes, añade nuevos nodos cuando un dispositivo es
encontrado, y hace posible montar el sistema de archivos raíz como
sólo lectura. También soluciona otros problemas que no hemos discutido
previamente porque no son de mucho interés a los usuarios...
</p>

<p>
Por ejemplo, con devfs, no tienes que preocuparte por los pares
mayores/menores. Aunque siguen siendo soportados (por compatibilidad
con el antiguo sistema), ya no es necesario. Esto hace posible a Linux
soportar incluso más dispositivos, dado que ya no hay límites (los
números siempre tiene límites :).
</p>

<p>
Pero devfs también tiene sus propios problemas; para los usuarios
finales estos no son realmente visibles, pero para los mantenedores
del núcleo los problemas son lo suficientemente grandes como para
marcar a devfs como <e>obsoleto</e> en favor de <uri
link="udev-guide.xml">udev</uri> (también soportado por Gentoo :).
</p>

<p>
Para más información sobre por qué devfs ha sido marcado como obsoleto, por favor lea <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ">udev
PUF(en inglés)</uri> y <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev_vs_devfs">udev
versus devfs</uri>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Navegando a través del árbol de dispositivos</title>
<section>
<title>Directorios</title>
<body>

<p>
Una de las primeras cosas que debes haber notado, es que devfs utiliza
directorios para agrupar los dispositivos. Esto mejora la
comprensibilidad, ya que todos los dispositivos relacionados están
dentro de un mismo directorio.
</p>

<p>
Por ejemplo, todos los dispositivos IDE o relacionados, se encuentran
dentro del directorio <path>/dev/ide/</path>, y todos los SCSI o
relacionados están dentro de <path>/dev/scsi/</path>. Los discos SCSI
e IDE son vistos de la misma manera, lo que significa que ambos tienen
la misma estructura de subdirectorios.
</p>

<p>
Los discos IDE y SCSI son controlados por un adaptador (incorporado o
en una tarjeta separada), llamado <e>anfitrión</e>.  Cada adaptador
puede tener varios canales. El canal es llamado <e>bus</e>. En cada
canal, puedes tener varios IDs. Un ID identifica un disco. Este Id es
llamado el <e>objetivo</e>. Algunos dispositivos SCSI pueden tener
varios luns (abreviatura en inglés de <e>Números de Unidad
Lógica</e>), un ejemplo son los dispositivos que manejan múltiples
medios al mismo tiempo (Controladores de cinta de alto
desempeño). Mayormente sólo tendrás un único lun, <path>lun0/</path>.
</p>

<p>
Así, de tener el previo <path>/dev/hda4</path>, ahora tenemos
<path>/dev/ide/host0/bus0/target0/lun0/part4</path>. Esto es mucho más
simple... no, tranquilo... de verdad <e>es</e> más fácil ... naa, no
importa! :)
</p>

<note>
También puedes utilizar un nombre de archivo de dispositivo más Unix,
como <path>c0b0t0u0p2</path>. Estos pueden ser encontrados en
<path>/dev/ide/hd</path>, <path>/dev/scsi/hd</path>, etc.
</note>

<p>
Para darte una idea de los directorios, esta es una lista de los
directorios que yo tengo en mi laptop:
</p>

<pre caption = "Directorios en /dev">
cdroms/     cpu/        discs/          floppy/
ide/        input/      loop/           misc/
netlink/    printers/   pts/            pty/
scsi/       sg/         shm/            sound/
sr/         usb/        vc/             vcc/
</pre>
</body>
</section>

<section>
<title>Compatibilidad con anteriores utilizando devfsd</title>
<body>

<p>
Usar este nuevo esquema suena divertido, pero varias herramientas y
programas hacen uso del antiguo esquema. Para asegurarse de que no se
rompa el sistema, se creó <c>devfsd</c>. Este demonio crea enlaces
simbólicos con los nombres antiguos, apuntando hacia los nuevos
archivos de dispositivos.
</p>

<pre caption = "Enlaces simbólicos creados">
$ <i>ls -l /dev/hda4</i>
lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -> ide/host0/bus0/target0/lun0/part4
</pre>

<p>
Con <c>devfsd</c>, también puedes configurar los permisos, crear
nuevos archivos de dispositivos, definir acciones, etc. Todo esto está
descrito en el siguiente capítulo.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Administrando el árbol de dispositivos</title>
<section>
<title>Reiniciando devfsd</title>
<body>

<p>
Cuando modificas el archivo <path>/etc/devfsd.conf</path>, y quieres
que los cambios sean aplicados a tu sistema, no necesitas reiniciar
todo el sistema. Dependiendo de lo que quieras hacer, puedes utilizar
cualquiera de las dos siguientes señales:
</p>

<p>
<b>SIGHUP</b> hará que <c>devfsd</c> relea el archivo de
configuración, recargue los objetos compartidos y genere los eventos
REGISTER para cada nodo hoja del árbol de dispositivos.
</p>

<p>
<b>SIGUSR1</b> hará lo mismo, pero no generará los eventos REGISTER.
</p>

<p>
Para enviar una señal, simplemente utiliza <c>kill</c> o <c>killall</c>:
</p>

<pre caption = "Enviando la señal SIGHUP a devfsd">
# <i>kill -s SIGHUP `pidof devfsd`</i>
<comment>o</comment>
# <i>killall -s SIGHUP devfsd</i>
</pre>
</body>
</section>

<section>
<title>Removiendo los enlaces simbólicos de compatibilidad</title>
<body>

<warn>
Actualmente, Gentoo no funciona sin los enlaces simbólicos de
compatibilidad.
</warn>

<p>
Si quieres remover los enlaces de compatibilidad que rellenan
<path>/dev</path> de tu sistema Gentoo (Gentoo lo activa por defecto),
edita <path>/etc/devfsd.conf</path> y remueve las siguientes dos
lineas:
</p>

<pre caption = "/etc/devfsd.conf con compatibilidad con anteriores">
<comment># Comenta las siguientes dos lineas para remover los enlaces simbólicos</comment>
REGISTER        .*  MKOLDCOMPAT
UNREGISTER      .*  RMOLDCOMPAT
</pre>

<p>
Necesitas reiniciar tu sistema para que los cambios se ejecuten.
</p>
</body>
</section>

<section>
<title>Removiendo la funcionalidad de auto cargado</title>
<body>

<p>
Cuando tu cargas un módulo, devfs automáticamente creará los archivos
de dispositivos. Si no quieres que esto ocurra, remueve la siguiente
linea del archivo <path>/etc/devfsd.conf</path>:
</p>

<pre caption = "/etc/devfsd.conf, funcionalidad de auto-cargado">
LOOKUP      .*  MODLOAD
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Puntos relacionados con los permisos</title>
<section>
<title>Configurar/cambiar permisos utilizando PAM</title>
<body>

<p>
Aunque se puede configurar los permisos en
<path>/etc/devfsd.conf</path>, es recomendable hacerlo con PAM
(abreviatura en inglés de <e>Módulos de Autenticación
Insertables</e>). Esto es porque PAM tiene la última palabra en lo que
a permisos se refiere, posiblemente ignorando los cambios que hagas en
<path>/etc/devfsd.conf</path>.
</p>

<p>
PAM utiliza el archivo <path>/etc/security/console.perms</path> para
los permisos. El archivo consta de dos partes: la primera describe los
grupos, y la segunda los permisos.
</p>

<p>
Primero veamo la primera parte, los grupos. Como ejemplo usaremos al
grupo sound:
</p>

<pre caption = "Grupo sound en /etc/security/console.perms">
&lt;sound&gt;=/dev/dsp* /dev/audio* /dev/midi* \
    /dev/mixer* /dev/sequencer* \
    /dev/sound/* /dev/snd/* /dev/beep \
    /dev/admm* \
    /dev/adsp* /dev/aload* /dev/amidi* /dev/dmfm* \
    /dev/dmmidi* /dev/sndstat
</pre>                  

<p>
La sintaxis no es complicada: empiezas con un nombre de grupo, y
terminas con una lista de dispositivos que pertenecen a ese grupo.
</p>

<p>
Ahora, los grupos no son muy útiles si no puedes hacer nada con
ellos. Así que la siguiente parte describe como los permisos son
manejados.
</p>

<pre caption = "Permisos para el grupo de sonido en /etc/security/console.perms">
&lt;console&gt;  0600 &lt;sound&gt;      0600 root.audio
</pre>

<p>
El primer campo es el del terminal. En la mayoría de los sistemas, este
es el grupo de la consola. PAM siempre revisará este campo en cada
inicio de sesión. Si el inicio de sesión se da en un dispositivo
contenido en el grupo de consola, PAM revisará y posiblemente cambiará
los permisos de algunos archivos de dispositivos.
</p>

<p>
El segundo campo contiene los permisos que se aplicarán a los archivos
de dispositivos cuando se inicie la sesión exitosamente. Cuando una
persona inicia su sesión en el sistema, y los archivos de dispositivos
tienen un dueño preestablecido, PAM lo cambiará para que pertenezcan
al usuario que acaba de ingresar. En este caso, se utiliza el permiso
0600 (sólo el usuario tiene permiso de lectura/escritura).
</p>

<p>
El tercer campo contiene el grupo de dispositivo cuyos permisos serán
cambiados. En este caso, el grupo de sonido (todos los dispositivos
relacionados con el sonido) será cambiado.
</p>

<p>
El cuarto campo define los permisos que le serán asignados al archivo
de dispositivo una vez que regrese a su estado previo. En otras
palabras, cuando la persona que tiene los permisos termina su sesión, PAM
asignará los permisos de estos campos como por defecto.
</p>

<p>
El quinto campo define el dueño (con grupo si deseas) al que será
asignado el dispositivo en el estado por defecto. En otras palabras,
si la persona que posee todos los archivos de dispositivos termina su
sesión, PAM asignará como dueño al definido en el estado por defecto,
que está en este quinto campo.
</p>
</body>
</section>

<section>
<title>Asignar/cambiar los permisos con devfsd</title>
<body>

<p>
Si realmente quieres configurar los permisos utilizando
<path>/etc/devfsd.conf</path>, entonces utiliza la sintaxis del
siguiente ejemplo:
</p>

<pre caption = "Permisos en /etc/devfsd.conf">
REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660
</pre>

<p>
El segundo campo es el grupo de dispositivos, empezando desde
<path>/dev</path>. Es una expresión regular, lo que quiere decir que
puede seleccionar varios archivos de dispositivos en una sola regla.
</p>

<p>
El cuarto campo es el dueño del archivo de dispositivo. A diferencia
de PAM, este no es cambiado (a menos que se mencione en
<path>console.perms</path> ya que PAM siempre gana).
</p>

<p>
El quinto campo contiene los permisos del archivo de dispositivos.
</p>
</body>
</section>

<section>
<title>Configurar manualmente los permisos y hacer que devfsd los guarde</title>
<body>

<p>
Este es el comportamiento normal de Gentoo: si ejecutas <c>chown</c> y
<c>chmod</c> sobre algún archivo de dispositivo, <c>devfsd</c> salvará
la información cuando se apaga el sistema. Esto es porque el archivo
<path>/etc/devfsd.conf</path> contiene las siguientes lineas:
</p>

<pre caption = "/etc/devfsd.conf salvando permisos">
REGISTER        ^pt[sy]/.*   IGNORE
CHANGE          ^pt[sy]/.*   IGNORE
CREATE          ^pt[sy]/.*   IGNORE
DELETE          ^pt[sy]      IGNORE
REGISTER        ^log         IGNORE
CHANGE          ^log         IGNORE
CREATE          ^log         IGNORE
DELETE          ^log         IGNORE
REGISTER        .*           COPY    /lib/dev-state/$devname $devpath
CHANGE          .*           COPY    $devpath /lib/dev-state/$devname
CREATE          .*           COPY    $devpath /lib/dev-state/$devname
DELETE          .*           CFUNCTION GLOBAL unlink
/lib/dev-state/$devname
RESTORE         /lib/dev-state
</pre>

<p>
En otras palabras, los cambios sobre los archivos de dispositivos son
copiados a <path>/lib/dev-state</path> cuando se apaga el sistema, y
de regreso a <path>/dev</path> al iniciar el sistema.
</p>

<p>
Otra posibilidad es montar <path>/lib/dev-state</path> en
<path>/dev</path> en tiempo de arranque. Para hacer esto necesitas
asegurarte que devfs no es montado automáticamente (para lo cual
deberás recompilar tu kernel) y que <path>/dev/console</path>
existe. Luego, en algún momento en el inicio de los guiones de inicio
de tu sistema coloca:
</p>

<pre caption = "Montando /lib/dev-state encima de /dev">
mount --bind /dev /lib/dev-state
mount -t devfs none /dev
devfsd /dev
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Recursos</title>
<section>
<body>

<p>
Para mayor información acerca de devfs, revisa los siguientes
recursos.
</p>

<p>
La página del manual devfsd.conf explica la sintaxis del archivo
<path>/etc/devfsd.conf</path>. Para verla, escribe <c>man
devfsd.conf</c>.
</p>

<p>
El <uri
link="http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html">devfs
PUF (en inglés)</uri> explica todo acerca de devfs. También contiene
información acerca de la estructura interna de devfs y como los
controladores pueden soportar devfs.
</p>

<p>
En <uri link="http://www.linuxjournal.com">LinuxJournal</uri> hay un
interesante artículo sobre <uri
link="http://www.linuxjournal.com/article.php?sid=6035">devfs for
Management and Administration</uri>.
</p>

<p>
Daniel Robbins ha escrito un par de artículos para IBM's
DeveloperWorks acerca de sistemas de archivos avanzados. Tres de ellos
tratan sobre (todos en inglés):
</p>

<ul>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs4/">
    Introducción a devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs5/">
    Configurando devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">
    Implementando devfs</uri>
  </li>
</ul>
</body>
</section>
</chapter>
</guide>
