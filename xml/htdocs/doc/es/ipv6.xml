<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/ipv6.xml,v 1.10 2007/07/19 12:05:50 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/ipv6.xml" lang="es">

<title>Guía del router IPv6 en Gentoo</title>
<author title="Desarrollador">
  <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor, Revisor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="cam@gentoo.org">Camille Huot</mail>
</author>
<author title="Editor">
  <mail link="okun@hack.fi">Pasi Valminen</mail>
</author>
<author title="Traductor">
  <mail link="fiam@asturlinux.org">Alberto García Hierro</mail>
</author>
<author title="Traductor">
  <mail link="enrique@barbeito.org">Enrique Barbeito García</mail>
</author>

<abstract>
Esta guía muestra cómo configurar IPv6 en un sistema Gentoo. Incluye establecer
un túnel con un "tunnel broker", la configuración básica del DNS
y la configuración de los clientes para usar el sistema para conectar con
una dirección IPv6.
</abstract>

<license/>

<version>1.4</version>
<date>2007-05-30</date>

<chapter>

<title>Configuración del kernel</title>
<section>
<title>Configuración básica del kernel</title>
<body>

<p>
Cualquiera de los kernel 2.6 disponibles en Gentoo soportará conexiones
IPv6 fácilmente. La nueva pila USAGI para IPv6 está integrada en el kernel 
desde la versión 2.6.0.
</p>

<pre caption="Emergiendo un kernel">
# <i>emerge gentoo-sources</i>
</pre>

<p>
Ahora estamos listos para entrar en el directorio de las fuentes
del kernel y comenzar con su configuración.
</p>

<pre caption="Configurando el kernel de Linux">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<note>
Esta guía asume que el enlace <path>/usr/src/linux</path> apunta
a las fuentes que estará usando.
</note>

<note>
Asegúrese de que tiene activada la opción <path>Prompt for development and/or
incomplete code/drivers</path> en su configuración del kernel.
</note>

<pre caption="Opciones de 'make menuconfig'">
Device Drivers ---&gt;
Networking support ---&gt;
Networking options ---&gt;
   &lt;*&gt; The IPv6 protocol (EXPERIMENTAL)
<comment>(Las opciones IPv6 bajo ésta pueden ser útiles para otras muchas aplicaciones,</comment>
<comment>pero no deberían de ser necesarias para una configuración básica)</comment>

<comment>(Esta opción solo es necesaria si está usando ptrtd para la conversión de IPv6 a IPv4)</comment>
[*] Network device support
   &lt;*&gt; Universal TUN/TAP device driver support
</pre>
</body>
</section>

<section>
<title>Probando el soporte IPv6</title>
<body>

<p>
Después de activar las opciones recomendadas, recompile su kernel y reinicie
usando su nuevo kernel con IPv6 activado.
</p>

<p>
Si todavía no tiene <b>iproute2</b> instalado, le animamos a hacerlo ahora.
iproute2 es una suite de configuración de red que contiene <c>ip</c>, el famoso
sustituto para <c>ifconfig</c>, <c>route</c>, <c>iptunnel</c> y otros ...
</p>

<pre caption="Instalando iproute2">
# <i>emerge sys-apps/iproute2</i>
</pre>

<warn>
El uso de ifconfig puede ocasionar serios dolores de cabeza si tiene múltiples 
dispositivos de tunel. Tiene que eliminar los túneles en orden inverso, quiere decir 
que el creado en último lugar debe ser eliminado primero ¡Queda avisado!
</warn>

<p>
Si IPv6 está funcionando, el dispositivo de loopback debería mostrar una dirección IPv6:
</p>

<pre caption="Comprobando el dispositivo de loopback">
# <i>ip -6 addr show lo</i>
1: lo: &lt;LOOPBACK,UP&gt; mtu 16436
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
    <comment>(Las líneas de arriba demuestran que las cosas funcionan)</comment>
</pre>

<p>
Antes de proseguir, asegúrese de añadir <e>ipv6</e> a su lista de variables USE 
en <path>make.conf</path>, de tal modo que en futuras instalaciones de paquetes
se incluirá soporte para IPv6.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configuración del túnel</title>
<section>
<title>Configuración básica</title>
<body>

<p>
La mayoría de los proveedores de Internet todavía no ofrecen conexiones IPv6
de modo nativo.  Para saltarse está limitación, existen varios "tunnel
brokers" en todo el mundo que ofrecen gratuitamente túneles IPv6. Esto le
permite hacer un túnel para todas las conexiones IPv6 a través de una conexión
IPv4.
</p>

<table>
<tr><th>Broker</th><th>Situación geográfica</th></tr>
<tr>
  <ti><uri link="http://tunnelbroker.net">Hurricane Electric</uri>
  </ti><ti>EE.UU./Canada</ti>
</tr>
<tr>
  <ti><uri link="http://www.freenet6.net">Freenet6</uri></ti>
  <ti>EE.UU.</ti>
</tr>
<tr>
  <ti><uri link="http://www.sixxs.net/">Sixxs</uri></ti>
  <ti>Europa</ti>
</tr>
<tr>
  <ti><uri link="http://tunnel-broker.singnet.com.sg/">Singnet</uri></ti>
  <ti>Singapur</ti>
</tr>
<tr>
  <ti><uri link="http://broker.aarnet.net.au/">Aarnet</uri></ti>
  <ti>Australia/Pacífico Sur</ti>
</tr>
</table>

<p>
A continuación hay dos ejemplos de configuración de un túnel IPv6 con dos
populares brokers de Norteamérica: Hurricane Electric (también se aplica a 
túneles de sixxs.net sin mecánismo heartbeat) y Freenet6.
</p>

</body>
</section>
<section>
<title>Hurricane Electric</title>
<body>

<p>
Hurricane Electric (HE de forma abreviada) ofrece túneles IPv6
gratuitos y asigna un bloque /64 de direcciones para usted.
También permite configurar un DNS inverso. Conseguir un túnel de HE
es tan sencillo como ir a <uri>http://www.tunnelbroker.net</uri> y rellenar 
un formulario.
</p>

<note>
El registro incluye una lista de datos personales como su dirección
y número de teléfono.
</note>

<warn>
Los túneles de HE tardan 24 horas en activarse, con el fin de
evitar abusos.
</warn>

<p>
Una vez que tenga el túnel activado y le haya sido asignado un bloque
/64, puede configurar su sistema Gentoo. HE proporciona configuraciones
de ejemplo basadas en las utilidades ifconfig e iproute. Los dos
siguientes ejemplos asumen que tiene la siguiente configuración:
</p>

<table>
<tr><ti>Dirección IPv4 Local</ti><ti>68.36.91.195</ti></tr>
<tr><ti>Dirección IPv4 de HE</ti><ti>64.71.128.82</ti></tr>
<tr><ti>Dirección local del túnel IPv6</ti><ti>2001:470:1F00:FFFF::189</ti></tr>
<tr><ti>Bloque IPv6k</ti><ti>2001:470:1F00:296::/64</ti></tr>
</table>

<p>
Utilizando el paquete iproute2 y el comando <c>ip</c>, usted haría lo siguiente:
</p>

<pre caption="Configuración de un túnel IPv6">
<comment>(Crear un túnel entre la IPv4 local (eth0) and la dirección IPv4 de HE</comment>
# <i>ip tunnel add sixbone mode sit remote 64.71.128.82 local 68.36.91.195 ttl 64 dev eth0</i>
<comment>(Extraer el túnel indirecto del MTU)</comment>
# <i>ip link set sixbone mtu 1280</i>
<comment>(Levantar el túnel)</comment>
# <i>ip link set sixbone up</i>
<comment>(Asignarle la dirección IPv6)</comment>
# <i>ip addr add 2001:470:1F00:FFFF::189 dev sixbone</i>
<comment>(Enrutar todo el tráfico de direcciones IPv6 a través de nuestro dispositivo túnel 'sixbone')</comment>
# <i>ip route add 2000::/3 dev sixbone</i>
</pre>
</body>
</section>

<section>
<title>Freenet6</title>
<body>

<p>
<uri link="www.freenet6.net">Freenet6</uri> es otro proveedor de túneles
(broker) gratuito. El registro solo requiere un nombre de usuario y una
dirección de correo electrónico válida. En Freenet6 han escogido
utilizar una estructura de cliente/servidor para administrar
el túnel y han creado el cliente <c>tspc</c>. El cliente está disponible
en Portage. Para instalarlo haga:
</p>

<pre caption="Instalando el cliente de Freenet6">
# <i>emerge freenet6</i>
</pre>

<p>
Ahora necesita configurar freenet6 editando:
<path>/etc/freenet6/tspc.conf</path>. Solamente debería tener que cambiar los 
campos <e>userid</e> and <e>passwd</e> colocando los asignados por 
Freenet6. Debajo tiene una configuración de ejemplo completa.
</p>

<pre caption="ejemplo de tspc.conf">
tsp_version=1.0.1
tsp_dir=/etc/freenet6
auth_method=any
client_v4=auto
<i>userid=anonymous</i>
<i>passwd=foobar</i>
template=gentoo
server=tsps1.freenet6.net
retry_delay=0
if_tunnel=sit3
</pre>
</body>
</section>

<section>
<title>Probando su conexión</title>
<body>

<p>
Ahora que su túnel está configurado, puede probar su conexión. La forma
más sencilla de hacerlo es usando la utilidad <c>ping6</c> e intentando
hacer ping a un nombre de máquina IPv6.
</p>

<pre caption="Probando la conexión">
# <i>emerge iputils</i>
# <i>ping6 www.kame.net</i>
PING www.kame.net(orange.kame.net) 56 data bytes
64 bytes from orange.kame.net: icmp_seq=1 ttl=52 time=290 ms
64 bytes from orange.kame.net: icmp_seq=2 ttl=52 time=277 ms
64 bytes from orange.kame.net: icmp_seq=3 ttl=52 time=280 ms
64 bytes from orange.kame.net: icmp_seq=4 ttl=52 time=279 ms
64 bytes from orange.kame.net: icmp_seq=5 ttl=52 time=277 ms

--- www.kame.net ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4038ms
rtt min/avg/max/mdev = 277.040/281.041/290.046/4.699 ms
</pre>

<p>
Actualmente se está trabajando para añadir mejor soporte IPv6 a los
scripts de inicio de la red. Si desea conocer su estado  y/o ofrecer
ayuda, escriba a <mail link="latexer@gentoo.org">latexer@gentoo.org</mail>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Soporte IPv6 en aplicaciones</title>
<section>
<title>Re-emergiendo paquetes</title>
<body>

<p>
A menos que previamente tenga <e>USE="ipv6"</e> en su
<path>/etc/make.conf</path>, probablemente necesitará re-emerger unos cuantos
paquetes para compilarlos con soporte IPv6. Para obtener una lista de todos los
paquetes instalados afectados por el cambio del parámetro USE, use la opción
<c>--newuse</c> (<c>-N</c>) de Portage:
</p>

<pre caption="Candidatos para ser re-emergidos">
# <i>emerge -uDNav world</i>
</pre>

<p>
Si ha cambiado muchos parámetros USE la lista puede que sea bastante grande. Se
recomienda mantener el sistema actualizado para que éste no sufra en caso de
tener que recompilar todos los paquetes afectados.
</p>

<note>
Algunos paquetes detectan soporte IPv6 "automágicamente" y por eso no tienen 
la opción ipv6 en la variable USE. Por eso no todos los paquetes, que 
deberían soportar IPv6, lo soportarán si no lo compilaste con IPv6 habilitado.
</note>

</body>
</section>

<section>
<title>Paquetes específicos de IPv6</title>
<body>

<p>
Hay algunos paquetes que tratan con elementos IPv6. La
mayoría de ellos se encuentran en <path>/usr/portage/net-misc</path>.
</p>

<table>
<tr><th>Paquete</th><th>Descripción</th></tr>
<tr>
  <ti>net-misc/ipv6calc</ti>
  <ti>Convierte una dirección IPv6 a un formato comprimido</ti>
</tr>
<tr>
  <ti>net-misc/netcat6</ti>
  <ti>Versión de netcatque soporta tanto IPv6 como IPv4</ti>
</tr>
<tr>
  <ti>dev-perl/Socket6</ti>
  <ti>
    La parte de las definiciones de socket.h de C y los manipuladores de
    estructuras relacionados con IPv6
  </ti> 
</tr>
</table>
</body>
</section>
</chapter>

<chapter>
<title>Configuración de DNS</title>
<section>
<title>IPv6 y DNS</title>
<body>

<p>
Los DNS para IPv4 utilizan registros A, los DNS para IPv6 usan registros
AAAA. (Esto se debe a que IPv4 tiene un espacio de direcciones de 2^32
mientras que el de IPv6 es de 2^128). Para el DNS inverso, el estándar
INT es el más soportado. ARPA es el último formato pero no está tan difundido
como INT. El soporte para el formato INT será descrito ahora.
</p>
</body>
</section>

<section>
<title>Configuración de BIND</title>
<body>

<p>
Las versiones recientes de BIND incluyen un soporte IPv6 excelente. Esta
sección asumirá que tiene un mínimo conocimiento sobre configuración y
uso de BIND. Asumiremos que no está corriendo BIND en una jaula chroot.
Si, por el contrario, usted esta corriéndolo dentro, simplemente añada
el prefijo de la jaula a la mayoría de las rutas en la siguiente sección.
</p>

<p>
Lo primero que necesita es añadir entradas tanto para la resolución directa
como para la resolución inversa en <path>/etc/bind/named.conf</path>.
</p>

<pre caption="entradas en named.conf">
<comment>(Permitimos a bind escuchar a direcciones IPv6.</comment>
<comment>Usando 'any' es la única forma de hacerlo en versiones anteriores a bind-9.3)</comment>
options {
    [...]
    listen-on-v6 { any; }
    [...]
};
<comment>(Esto proporcionará el DNS directo para el dominio 'ipv6-rules.com':)</comment>
zone "ipv6-rules.com" IN {
    type master;
    file "pri/ipv6-rules.com";
};
<comment>(El formato para el DNS inverso se obtiene bit a bit. Se hace tomando el prefijo IPv6,</comment>
<comment>invirtiendo el orden de los números y colocando un punto entre cada uno de ellos)</comment>
zone "6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa" {
        type master;
        file "pri/rev-ipv6-rules.com.arpa";
};
</pre>

<p>
Ahora debemos crear los archivos de zona y añadir entradas para todas
nuestros nombres de máquina:
</p>

<pre caption="pri/ipv6-rules.com">
$TTL    2h
@       IN      SOA     ipv6-rules.com. webmaster.ipv6-rules.com.  (
                                2003052501 ; Serial
                                28800      ; Refresh
                                14400      ; Retry
                                3600000    ; Expire
                                86400 )    ; Minimum
                NS      ns1.ipv6-rules.com

        IN      AAAA    2001:470:1f00:296::1 ; address for ipv6-rules.com
host1   IN      AAAA    2001:470:1f00:296::2 ; address for host1.ipv6-rules.com
host2   IN      AAAA    2001:470:1f00:296::3:3 ; address for host2.ipv6-rules.com
</pre>

<pre caption="pri/rev-ipv6-rules.com.arpa">
$TTL 3d ; Default TTL (bind 8 needs this, bind 9 ignores it)
@       IN SOA ipv6-rules.com. webmaster.ipv6-rules.com. (
                        2003052501      ; Serial number (YYYYMMdd)
                        24h             ; Refresh time
                        30m             ; Retry time
                        2d              ; Expire time
                        3d )            ; Default TTL
        IN      NS     ns1.ipv6-rules.com.
; IPv6 PTR entries
$ORIGIN 6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa.

1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     ipv6-rules.com.
2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host1.ipv6-rules.com.
3.0.0.0.3.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host2.ipv6-rules.com.
</pre>
</body>
</section>

<section>
<title>Configuración de DJBDNS</title>
<body>

<p>
Actualmente hay algunos parches hechos por otros para DJBDNS disponibles
en <uri link="http://www.fefe.de/dns/">http://www.fefe.de/dns/</uri> 
que le permiten funcionar con IPv6. DJBDNS puede instalarse con estos
parches emergiéndolo con <e>ipv6</e> en el USE.
</p>

<warn>
Todavía no están soportados todos los tipos de registro con estos parches.
En particular, los registros MX y NS no están soportados.
</warn>

<pre caption="Instalando djbdns">
# <i>emerge djbdns</i>
</pre>

<p>
Una vez que djbdns está instalado, puede configurarlo ejecutando
<c>tinydns-setup</c> y respondiendo unas cuantas preguntas sobre
las direcciones IP en las que debe escuchar, donde instalar tinydns, etc.
</p>

<pre caption="Configurando tinydns">
# <i>tinydns-setup</i>
</pre>

<p>
Asumiendo que hemos instalado <c>tinydns</c> en <path>/var/tinydns</path>, 
ahora editaremos <path>/var/tinydns/root/data</path>. Este archivo contendrá
todos los datos necesarios para conseguir que tinydns maneje los DNS para su
delegación IPv6.
</p>

<pre caption="archivo data de ejemplo">
<comment>(*.ipv6-rules.com manejado autoritariamente por 192.168.0.1)</comment>
.ipv6-rules.com:192.168.0.1:a:259200
<comment>(DNS inverso autoritario para 2001:470:1f00:296::/64)</comment>
.6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.arpa:192.168.0.1:a
<comment>(Especifica las IPs para host1 y host2)</comment>
6host1.ipv6-rules.com:200104701f0002960000000000000001:86400
6host2.ipv6-rules.com:200104701f0002960000000000000002:86400
<comment>(Apunta www a host1)</comment>
3www.ipv6-rules.com:200104701f0002960000000000000002:86400
</pre>

<p>
Las líneas que comienzan con <c>6</c> tendrán creado tanto
un registro AAAA como un registro PTR. Aquellas que comiencen con
un <c>3</c> solamente tendrán un registro AAAA creado. Además de editar
manualmente el archivo <path>data</path> , puede usar los scripts
<c>add-host6</c> y <c>add-alias6</c> para añadir nuevas entradas.
Una vez haya hecho los cambios al archivo <path>data</path> , simplemente
necesita ejecutar <c>make</c> desde <path>/var/tinydns/root</path>. Así
se creará <path>/var/tinydns/root/data.cfb</path>, el cual usa tinydns
como fuente de información para las peticiones DNS.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Router IPv6</title>
<section>
<title>Configurar el enrutado</title>
<body>

<p>
Si queremos que nuestro sistema funcione como router para otros clientes
que deseen conectar al mundo exterior con IPv6, se necesita algo más de 
configuración. Necesitamos activar el reenvío de paquetes IPv6. Podemos
hacerlo de dos maneras.
</p>

<pre caption="Activando el reenvío">
# <i>echo 1 > /proc/sys/net/ipv6/conf/all/forwarding</i>
o
# <i>sysctl -w net.ipv6.conf.all.forwarding=1</i>
</pre>

<warn>
El script de inicio radvd, explicado en el próximo capítulo, activa (y
desactiva) el reenvío haciendo el siguiente paso innecesario.
</warn>

<p>
Para activar el reenvío en el inicio, necesitará editar
<path>/etc/sysctl.conf</path> y editar la línea siguiente.
</p>

<pre caption="Fragmento a añadir en sysctl.conf">
net.ipv6.conf.default.forwarding=1
</pre>

<p>
Ahora el tráfico debería ser reenviado desde esta máquina a través del
túnel que hemos establecido con nuestro broker.
</p>

<p>
Para asignar direcciones IPv6 a los clientes, las especificación IPv6 permite 
tanto la asignación con estado como sin estado. La asignación sin estado usa 
un proceso llamado Router Advertisement y permite a los clientes obtener una 
IP y una ruta predeterminada simplemente levantando el dispositivo un red. Se 
denomina 'sin estado' porque no se guarda ningún registro del estado de las 
IPs asignadas y las máquinas a las cuales se les ha asignado. La asignación 
'con estado' se maneja mediante DHCPv6. Se llama así porque el servidor 
mantiene un registro con el estado de los clientes que han solicitado una IP y 
la han obtenido.
</p>
</body>
</section>

<section>
<title>Configuración sin estado</title>
<body>

<p>
La configuración sin estado se lleva a cabo de una manera sencilla
usando el demonio Router Advertisement, o radvd.
</p>

<pre caption="Configurando radvd">
# <i>emerge radvd</i>
</pre>

<p>
Después de emerger radvd, necesitamos crear 
<path>/etc/radvd/radvd.conf</path> que contiene información acerca
del bloque de IP del que se asignarán las IPs. Aquí tiene un ejemplo
del archivo <path>radvd.conf</path> usando el prefijo asignado por
nuestro broker.
</p>

<pre caption="Ejemplo de radvd.conf">
interface eth1
{
        <comment>(Envía el mensaje de anuncio a otro hosts)</comment>
        AdvSendAdvert on;
        <comment>(La fragmentación es mala(tm))</comment>
        AdvLinkMTU 1280;
        MaxRtrAdvInterval 300;
        <comment>(El prefijo de subred IPv6 que hemos asignado por nuestro PoP)</comment>
        prefix 2001:470:1F00:296::/64
        {
                AdvOnLink on;
                AdvAutonomous on;
        };
};
</pre>

<warn>
¡Asegúrese de que la interfaz en la primera línea son correctas para propagar router
advertisement a su intranet y no a su ISP!
</warn>

<p>
En <c>man radvd.conf</c> está disponible información más detallada.
Ahora podemos iniciar radvd y configurarlo para que se cargue al inicio.
</p>

<pre caption="Iniciando radvd">
# <i>/etc/init.d/radvd start</i>
# <i>rc-update add radvd default</i>
</pre>
</body>
</section>

<section>
<title>Configuración con estado</title>
<body>

<p>
Si desea usar configuración con estado, necesitará instalar y configurar
dhcpv6.
</p>

<pre caption = "Instalando dhcpv6">
# <i>emerge dhcpv6</i>
</pre>

<p>
Ahora debemos configurar el servidor DHCPv6 editando
<path>/etc/dhcp6s.conf</path>.
</p>

<pre caption="Ejemplo de dhcp6s.conf">
prefer-life-time 10000;
valid-life-time 20000;
renew-time 5000;
rebind-time 8000;
interface eth1 {
    link AAA {
        allow unicast;
        send unicast;
        allow rapid-commit;
        send server-preference 5;
        renew-time 1000;
        rebind-time 2400;
        prefer-life-time 2000;
        valid-life-time 3000;
        pool{
            range 2001:470:1f00:296::10 to 2001:470:1f00:296::110/64;
            prefix 2001:470:1f00:296::/64;
        };
    };
};
</pre>

<p>
Ahora podemos arrancar dhcp6s y configurarlo para que se cargue al inicio.
</p>

<pre caption="Iniciando dhcp6s">
# <i>/etc/init.d/dhcp6s start</i>
# <i>rc-update add dhcp6s default</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Clientes IPv6</title>
<section>
<title>Usando radvd</title>
<body>

<p>
Los clientes que se encuentren detrás de este router, ahora deben ser
capaces de acceder a la red vía IPv6. Si está usando radvd, configurar
las máquinas debería ser tan sencillo como levantar el dispositivo de red.
(Probablemente ya lo hayan hecho sus scripts de inicio net.ethX).
</p>

<pre caption="Conectando a través IPv6">
# <i>ip link set eth0 up</i>
# <i>ip addr show eth0</i>
1: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1400 qdisc pfifo_fast qlen 1000
    link/ether 00:01:03:2f:27:89 brd ff:ff:ff:ff:ff:ff
    inet6 2001:470:1f00:296:209:6bff:fe06:b7b4/128 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::209:6bff:fe06:b7b4/64 scope link
       valid_lft forever preferred_lft forever
    inet6 ff02::1/128 scope global
       valid_lft forever preferred_lft forever
</pre>
</body>
</section>

<section>
<title>Usando DHCPv6</title>
<body>

<p>
Si su router está configurado para usar DCPv6, sus clientes también
necesitarán tener el paquete dhcpv6 instalado. Una vez haya hecho esto,
tendrá que configurar sus clientes editando <path>/etc/dhcp6c.conf</path>.
</p>

<pre caption="Ejemplo de dhcp6c.conf">
interface eth0 {
        send rapid-commit;
        request domain-name-servers;
        iaid 11111;
        renew-time 11000;
};
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Usando conversión 6a4</title>
<section>
<title>Principios básicos</title>
<body>

<p>
La conversión 6a4 puede usarse si tiene máquinas que necesitan comunicarse
con otras máquinas con direcciones IPv4 sobre una conexión IPv6 pura.
Puede tener una red interna funcionando enteramente con IPv6, con una máquina
tratando las conexión hacia el mundo exterior IPv4/IPv6.
</p>
</body>
</section>

<section>
<title>Configuración DNS</title>
<body>

<p>
Para tener la conversión 6a4 funcionando necesita configurar
un proxy DNS, <c>totd</c>, que enviará registros AAAA para los sitios
que realmente solo tiene un registro A. Estos registros AAAA apuntarán a
direcciones IPv6 que realmente no existen, pero serán enrutadas a través de
un proxy 6a4.
</p>

<p>
<c>totd</c> todavía está enmascarado en <c>~x86</c> pendiente de más pruebas, 
tendrá que desenmascararlo añadiendo la siguiente línea en su fichero
<path>/etc/portage/package.keywords</path> (mire "man portage" para mayor
información acerca de este fichero).
</p>

<pre caption="totd permanentemente desenmascarado es package.keywords">
net-misc/totd ~x86
</pre>

<p>
Después simplemente ejecute emerge:
</p>

<pre caption="Instalando totd">
# <i>emerge totd</i>
</pre>

<p>
Ahora, necesitamos configurar <path>/etc/totd.conf</path> con
alguna información básica de configuración.
</p>

<pre caption="Ejemplo de /etc/totd.conf">
<comment>(Apunta a un DNS real)</comment>
forwarder 192.168.0.2 port 53
<comment>(El prefijo que se colocará delante de los registros AAAA falsos)</comment>
prefix 3ffe:abcd:1234:9876::
<comment>(El puerto en el que correrá totd)</comment>
port 5005
<comment>(El archivo PID a usar)</comment>
pidfile /var/run/totd.pid
<comment>(Hacer realmente las tareas 6a4)</comment>
stf
</pre>

<note>
<c>totd</c> debe configurarse para usar un puerto diferente al 53
si otro servidor de nombres está corriendo en la misma máquina. 
</note>

</body>
</section>

<section>
<title>Proxy 6a4</title>
<body>

<p>
<c>ptrtd</c> se usará como proxy 6a4, permitiendo conexiones entre
las máquinas IPv6 de la red interna y las máquinas IPv4 de fuera.
</p>

<pre caption="Instalando ptrtd">
# <i>emerge ptrtd</i>
</pre>

<p>
Ahora necesitamos configurar <c>ptrtd</c>, especificándole el falso prefijo 
(el que le especificamos a <c>totd</c> que use) para crear las conexiones del 
proxy.  Edite <path>/etc/conf.d/ptrtd</path> y configure <c>IPV6_PREFIX</c>. 
Recuerde que debe ser el mismo prefijo con el cual se configuró <c>totd</c>.
</p>

<pre caption="Ejemplo de /etc/ptrtd.conf">
IPV6_PREFIX="3ffe:abcd:1234:9876::"
</pre>

<p>
Ahora puede iniciar totd, y configurarlo para que se cargue en el inicio.
</p>

<pre caption="Starting totd">
# <i>/etc/init.d/totd start</i>
# <i>rc-update add totd default</i>
</pre>

</body>
</section>

<section>
<title>Configuración de los clientes y pruebas</title>
<body>

<p>
Los clientes ahora deberían estar configurados para conectar con
máquinas tanto IPv4 como IPv6 a través de una conexión basada solamente
en IPv6. Asumiendo que los clientes ya han recibido una dirección IPv6
de radvd, simplemente necesitamos añadir una nueva entrada para la
resolución de DNS y añadir una ruta predeterminada para esas "direcciones
falsas". En primer lugar, añada una entrada al principio de su
<path>/etc/resolv.conf</path> apuntando a la máquina que está corriendo
<c>totd</c>.
</p>

<pre caption="Ejemplo de /etc/resolv.conf">
nameserver 2001:470:1f00:296::1 <comment>(El servidor corriendo totd)</comment>
</pre>

<p>
Para probar la resolución de nombres, solicite un registro AAAA
para un único sitio IPv4 conocido.
</p>

<pre caption = "Probando la resolución de nombres">
# <i>dig aaaa google.com</i>
;; ANSWER SECTION:
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3364
google.com.             300     IN      AAAA     3ffe:abcd:1234:9876::d8ef:3564
</pre>

<p>
Ahora añadiremos una ruta predeterminada para todas las
direcciones que comiencen con nuestro falso prefijo.
</p>

<pre caption="Añadiendo la ruta predeterminada">
<comment>(Asumiento que su interfaz IPv6 es eth0)</comment>
# <i>ip route add 3ffe:abcd:1234:9876::/64 via 2001:470:1f00:296::1 dev eth0</i>
</pre>

<p>
Finalmente, use <c>ping6</c> para hacer ping a google.com a su
falsa dirección IPv6.
</p>

<pre caption="Probando 6a4">
# <i>ping6 -c 2 google.com</i>
PING 3ffe:abcd:1234:9876::d8ef:3364(3ffe:abcd:1234:9876::d8ef:3364) 56 data bytes
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=1 ttl=54 time=0.106 ms
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=2 ttl=54 time=0.090 ms

--- 3ffe:abcd:1234:9876::d8ef:3364 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.090/0.098/0.106/0.008 ms
</pre>

<note>
El router corriendo <c>ptrtd</c> está respondiendo, lo cual nos muestra
que todo está funcionando.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Otros recursos</title>
<section>
<body>

<p>
En la red, hay una gran cantidad de recursos muy buenos relacionados con IPv6.
</p>

<table>
<tr><th>Sitios web</th><th>Recurso</th></tr>
<tr>
  <ti><uri link="http://www.ipv6.org/">www.ipv6.org</uri></ti>
  <ti>Información general sobre IPv6</ti>
</tr>
<tr>
  <ti><uri link="http://www.linux-ipv6.org/">www.linux-ipv6.org/</uri></ti>
  <ti>Proyecto USAGI</ti>
</tr>
<tr>
  <ti><uri link="http://www.deepspace6.net/">www.deepspace6.net</uri></ti>
  <ti>Sitio sobre Linux/IPv6</ti>
</tr>
<!-- dead, was hacked<tr>
  <ti><uri link="http://www.hs247.com/">www.hs247.com</uri></ti>
  <ti>Todo sobre IPv6</ti>
</tr>-->
<!-- dead, not responding<tr>
  <ti><uri link="http://www.ipv6-net.org/">www.ipv6-net.org</uri></ti>
  <ti>Sitio alemán sobre IPv6</ti>
</tr>-->
<tr>
  <ti><uri link="http://www.kame.net/">www.kame.net</uri></ti>
  <ti>Implementación *BSD</ti>
</tr>
</table>

<p>
En el IRC, puede probar <c>#ipv6</c> en <uri
link="http://www.freenode.net">Freenode</uri>. Puede conectarse a los
servidores de Freenode mediante IPv6 usando <b>irc.ipv6.freenode.net</b>.
</p>

</body>
</section>
</chapter>
</guide>
