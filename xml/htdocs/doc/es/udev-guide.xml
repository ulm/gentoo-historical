<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/udev-guide.xml,v 1.24 2010/05/18 21:03:40 chiguire Exp $ -->

<guide link="/doc/es/udev-guide.xml" lang="es">
<title>Guía udev en Gentoo</title>

<author title="Autor">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Colaborador">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Editor">
  <mail link="nightmorph"/>
</author>
<author title="Traductor">
   <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
<author title="Traductor">
   <mail link="chiguire@gentoo.org"/>
</author>
<author title="Traductor">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>
<author title="Traductor">
   <mail link="afcapel@supercable.es">Alberto F. Capel</mail>
</author>
<author title="Traductor">
   <mail link="mcklaren@gmail.com">Manuel Peral González</mail>
</author>
<author title="Traductor">
  <mail link="gentoo@nimiux.org">José María Alonso</mail>
</author>

<abstract>
Este documento explica qué es udev y cómo puede usarlo de acuerdo a
sus necesidades.
</abstract>

<license/>

<version>6</version>
<date>2010-05-14</date>

<chapter>
<title>¿Qué es udev?</title>
<section>
<title>El directorio /dev</title>
<body>

<p>
Cuando los usuarios de Linux hablan acerca del hardware de sus
sistemas a gente que puede llegar a pensar que Linux es algún tipo de
virus o marca de café, el uso de términos como "barra dev barra algo"
provocará, sin dudas, miradas raras. Pero para el usuario afortunado
(incluyendo al lector) el usar <path>/dev/hda1</path> es sólo una
forma rápida de explicar que nos referimos a la primera partición del
disco IDE maestro. ¿O no?
</p>

<p>
Todos sabemos lo que es un archivo de dispositivo. Algunos incluso
saben por qué cuando miramos un poco más de cerca la salida de <c>ls
-l</c> en <path>/dev</path> los archivos de dispositivo muestran unos
números especiales. Pero lo que siempre damos por sentado es que el
primer disco IDE se llama <path>/dev/hda</path>. Tal vez no lo vea
así, pero ésta es un fallo de diseño.
</p>

<p>
Piense en los dispositivos que se enchufan en caliente como los USB,
IEEE 1394, tarjetas PCI que se cambian en caliente ... ¿Cuál es el
primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás
dispositivos cuando el primero desaparezca? ¿Cómo afectará ésto a las
transacciones en curso? ¿No sería gracioso que un trabajo de impresión
se cambiase de repente desde su flamante impresora láser nueva a la
moribunda impresora de matriz solo porque alguien decidió desenchufar
la impresora láser que era la primera impresora?
</p>

<p>
Entra en escena <e>udev</e>. Los objetivos del proyecto udev son a la
vez interesantes y necesarios:
</p>

<ul>
  <li>Funciona en espacio de usuario</li>
  <li>Crea/borra archivos de dispositivo dinámicamente</li>
  <li>Proporciona nombres consistentes</li>
  <li>Proporciona una API en espacio de usuario</li>
</ul>

<p>
Para proporcionar estas características, udev se desarrolla en tres
proyectos separados: <e>namedev</e>, <e>libsysfs</e> y por supuesto,
<e>udev</e>.
</p>
</body>
</section>

<section>
<title>namedev</title>
<body>

<p>
Namedev permite definir nombres de dispositivos independientemente del
programa udev. Esto permite políticas y esquemas flexibles de
asignación de nombres desarrollados por entidades diferentes. Este
subsistema de asignación de nombres proporciona un interfaz estándar
que udev puede usar.
</p>

<p>
Actualmente se proporciona un solo esquema de asignación de nombres
con udev; de LANANA, usado por la mayoría de sistemas Linux actuales y
por tanto muy apropiado para la mayoría de usuarios de Linux.
</p>

<p>
Namedev usa un procedimiento de cinco pasos para averiguar el nombre
de un determinado dispositivo. Si el nombre se encuentra en uno de los
pasos dados, se usa ese nombre. Estos pasos son:
</p>

<ul>
  <li>etiqueta o número de serie</li>
  <li>número del bus del dispositivo</li>
  <li>topología del bus</li>
  <li>nombre dado estáticamente</li>
  <li>nombre proporcionado por el núcleo</li>
</ul>

<p>
El paso de <e>etiqueta o número de serie</e> comprueba si el
dispositivo tiene un identificador único. Por ejemplo, los
dispositivos USB tienen un número de serie USB único; los dispositivos
SCSI tienen un único UUID. Si namedev encuentra una correspondencia
entre este número único y un archivo de configuración dado, se usa el
nombre proporcionado por el archivo de configuración.
</p>

<p>
El paso del <e>número del bus del dispositivo</e> comprueba el número
del bus del dispositivo. Para dispositivos no enchufables en caliente
este procedimiento es suficiente para identificar un dispositivo de
hardware. Por ejemplo, los números de bus PCI rara vez cambian durante
la vida de un sistema. De nuevo, si namedev encuentra una correlación
entre esta posición y un archivo de configuración dado, se usa el
nombre proporcionado por el archivo de configuración.
</p>

<p>
Asimismo, <e>la topología del bus</e> es una forma algo estática de
definir dispositivos mientras el usuario no los cambie. Cuando la
posición de los dispositivos concuerda con la configuración
proporcionada por el usuario, se usa el nombre acompañante.
</p>

<p>
El cuarto paso <e>nombres dados estáticamente</e>, es simplemente una
sustitución de cadenas. Cuando un nombre del núcleo (el nombre por
defecto) concuerda con una cadena dada, se usa el nombre sustituto.
</p>

<p>
El paso final (<e>nombre proporcionado por el núcleo</e>) es una
solución para cuando no funcione ninguno de los anteriores: toma el
nombre por defecto proporcionado por el núcleo. En la mayoría de los
casos, esto es suficiente ya que concuerda con los nombres de
dispositivo usados en los sistemas actuales de Linux.
</p>
</body>
</section>

<section>
<title>libsysfs</title>
<body>

<p>
Udev interacciona con el núcleo a través de el pseudo-sistema de
archivos sysfs. El proyecto libsysfs proporciona una API común para
acceder de forma genérica a la información dada por el sistema de
archivos sysfs. Esto permite consultar todo tipo de hardware sin tener
que hacer suposiciones acerca de su tipo.
</p>
</body>
</section>

<section>
<title>udev</title>
<body>

<p>
Cada vez que el núcleo detecta un evento en la estructura de
dispositivos, llama a udev para echarle un vistazo. udev sigue las
reglas dispuestas en el directorio <path>/etc/udev/rules.d/</path> y
luego usa la información entregada por el núcleo para realizar las
acciones necesarias sobre la estructura de <path>/dev</path> (creando
o eliminando archivos de dispositivos).
</p>
</body>
</section>
</chapter>

<chapter>
<title>Utilizar udev en Gentoo</title>
<section>
<title>Requisitos</title>
<body>

<p>
Udev está pensado para ser utilizado en combinación con un núcleo 2.6
(como <c>gentoo-sources</c>) con el perfil por defecto 2007.0. Si está
usando alguno de estos núcleos, asegúrese de tener instalado una
versión reciente de <c>sys-apps/baselayout</c>. Es todo lo que hace
falta.
</p>

<pre caption="Instalar udev">
# <i>emerge udev</i>
</pre>

<p>
Al construir un núcleo, asegúrese de activar las siguientes opciones:
</p>

<pre caption="Opciones requeridas en el núcleo">
File systems ---&gt;
    [*] Inotify file change notification support
    [*]   Inotify support for userspace
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Si usa <c>genkernel</c>, no necesita hacer nada especial. Genkernel
activa udev por defecto.
</p>
</body>
</section>

<section>
<title>Configuración</title>
<body>

<p>
Si desea usar los ajustes que ofrece Gentoo para hacer su vida más
fácil, entonces no siga leyendo. Gentoo usará udev, pero mantendrá un
<path>/dev</path> estático, de forma que no le falten nodos de
dispositivos. Los guiones de inicio de Gentoo no ejecutarán al demonio
devfsd y desactivará devfs al arrancar.
</p>

<p>
Pero si es fanático y quiere tener un sistema sólo con udev, sin
modificaciones, tal y como se pretende en el desarrollo de udev
(incluyendo la dificultad generada por perder los nodos de los
dispositivos que udev no soporta todavía), por supuesto, siga adelante
:)
</p>

<p>
Desactivaremos las reglas que guarden los nodos de archivo: modifique
la variable <c>RC_DEVICE_TARBALL</c> en <path>/etc/conf.d/rc</path> y
cámbielo a <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Si ha incluido soporte para devfs en el núcleo, puede desactivarlo en
el archivo de configuración del gestor de arranque, agregando el
parámetro al núcleo: <c>gentoo=nodevfs</c>. Si desea usar devfs y
desactivar udev, agregue el parámetro <c>gentoo=noudev</c>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Problemas conocidos</title>
<section>
<title>Nodos de dispositivos que faltan al arrancar</title>
<body>

<p>
Si no logra arrancar por culpa de errores acerca de un
<path>/dev/null</path> no encontrado, o porque falta la consola
inicial, el problema es que faltan unos nodos de algunos dispositivos
que deberían existir <e>antes</e> de montar <path>/dev</path> para
luego sea manejado por udev. Esto es común en máquinas Gentoo que
tienen instalaciones hechas con mucha antigüedad.
</p>

<p>
Si tiene instalado <c>sys-apps/baselayout-1.8.12</c> o más reciente,
este problema está paliado, ya que el proceso de arranque debe poder
completarse. Sin embargo, para deshacerse de esas advertencias
molestas, debe crear los nodos faltantes como describimos más
adelante.
</p>

<p>
Para determinar cuáles nodos están presentes antes de montar el
sistema de archivos <path>/dev</path>, ejecute los siguientes
comandos:
</p>

<pre caption="Listar los nodos de dispositivos disponibles al arrancar">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Los dispositivos necesarios para un arranque exitoso son
<path>/dev/null</path> y <path>/dev/console</path>. Si no aparecen en
el listado previo, debe crearlos manualmente. Escriba los siguientes
comandos dentro del directorio <path>test/dev/</path>:
</p>

<pre caption="Crear los archivos de nodos de dispositivos necesarios">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Al terminar, no se olvide de desmontar el directorio
<path>test/</path>:
</p>

<pre caption="Desmontar el directorio test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>
</body>
</section>

<section>
<title>Udev y nvidia</title>
<body>

<p>
Si usa el driver propietario de nvidia y el servidor X falla al
iniciar en un sistema puramente udev, asegúrese de tener:
</p>

<ul>
  <li>
    el módulo <c>nvidia</c> listado en
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    una versión de baselayout igual o mayor que
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>
</body>
</section>

<section>
<title>Nombramiento inconsistente entre DevFS y udev</title>
<body>

<p>
Aunque nuestra intención es tener un esquema de nombramiento
consistente para ambas soluciones dinámicas de manejo de dispositivos,
a veces ocurren diferencias en el nombramiento.
</p>

<p>
Un conflicto reportado ocurre con el controlador HP Smart Array 5i
(para ser más preciso, con el módulo del núcleo <c>cciss</c>). Con
udev los dispositivos son nombrados <path>/dev/cciss/cXdYpZ</path> con
la X, Y y Z como números enteros. Con devfs, los dispositivos son
nombrados <path>/dev/hostX/targetY/partZ</path> o enlazados
simbólicamente a <path>/dev/cciss/cXdY</path>.
</p>

<p>
Si este es el caso, no se olvide actualizar su archivo
<path>/etc/fstab</path> y su archivo de configuración del gestor de
arranque como corresponde.
</p>

<p>
Lo mismo ocurre con los enlaces simbólicos que existían en el
directorio <path>/dev</path>, como <path>/dev/mouse</path>, el cual
<c>udev</c> ya no crea. Asegúrese de revisar su configuración X para
ver si la regla del ratón apunta a un archivo de dispositivo
existente.
</p>

<p>
Otro problema es la diferencia en el nombramiento de los terminales
entre devfs y udev. Aunque devfs denomina <c>tty</c> a sus terminales,
udev por su parte los llama <c>vc</c> y <c>tty</c>. Esto podría
resultar en un problema en caso de que esté restringiendo los ingresos
del superusuario desde las consolas usando
<path>/etc/securetty</path>. Tendrá que asegurarse que <c>tty1</c> y
<c>vc/1</c> aparezcan listados en <path>/etc/securetty</path> para que
el superusuario pueda ingresar usando la consola.
</p>
</body>
</section>

<section>
<title>Renombrar dispositivos de bloque</title>
<body>

<p>
Versiones más recientes de udev (104 y subsiguientes) conjuntamente
con núcleos más recientes (2.6.19 y subsiguientes) podrían cambiar los
nombre de los dispositivos de disco, debido a un cambio en la
implementación de libata del núcleo. Un dispositivo CD-RW en
<path>/dev/hdc</path> podría cambiar a <path>/dev/sr0</path>. Mientras
que normalmente esto no es problema, podría causar dificultades para
algunas aplicaciones que busquen los dispositivos en ubicaciones
fijas. Por ejemplo, <c>media-sound/rip</c> espera encontrar los discos
en <path>/dev/cdrom</path>, lo cual es un problema porque los núcleos
nuevos, en conjunción con udev renombrarán este dispositivo a
<path>/dev/cdrom1</path>.
</p>

<p>
Para solucionar estos problemas, modifique el archivo
<path>/etc/udev/rules.d/70-persistent-cd.rules</path> y asigne el
nombre correcto al dispositivo.
</p>

<p>
Para más información acerca de escribir reglas para udev, por favor
lea la <uri link="http://www.reactivated.net/udevrules.php">guía</uri>
de Daniel Drake.
</p>
</body>
</section>

<section>
<title>Renombrar dispositivos de red</title>
<body>

<p>
A veces enchufar y enchufar de nuevo un dispositivo de red (cómo una
tarjeta WiFi USB) puede renombrar su dispositivo de red cada vez,
incrementando el número en uno.
</p>

<p>
Cuando esto ocurra, puede ver que se nombran <c>wlan0</c>,
<c>wlan1</c>, <c>wlan2</c>, etc. Esto es porque udev esta añadiendo
reglas adicionales a su fichero de reglas, en lugar de recargar las
reglas existentes. Ya que udev ve su directorio de reglas a través de
inotify, necesitará soporte para inotify en su fichero de
configuración del núcleo:
</p>

<pre caption="Habilitando soporte para inotify en el núcleo">
File systems ---&gt;
    [*] Inotify file change notification support
    [*]   Inotify support for userspace
</pre>

<p>
Ahora udev conservará los nombres apropiados para sus dispositivos de red.
</p>
</body>
</section>

<section>
<title>udev carga los módulos en orden impredecible</title>
<body>

<p>
A veces udev carga los módulos en un orden indeseado, impredecible o
hasta aparentemente aleatorio. Esto es especialmente común en sistema
con dispositivo múltiples del mismo tipo, al igual que dispositivos
multimedia. Esto puede afectar los número de dispositivo asignados;
por ejemplo, las tarjetas de sonido se cambian de número.
</p>

<p>
Existen unas pocas soluciones para resolver la asignación de números
de dispositivo y/o orden de carga de los módulos. Idealmente, podría
pasar parámetros al módulo para especificar el número de dispositivo
deseado. Algunos módulos, como los de ALSA, incluyen un parámetro tipo
"índice". Los módulos que usen este parámetro pueden ser ajustados de
esta manera. Este ejemplo es para un sistema con dos tarjetas de
sonido. La tarjeta con el índice 0 es designada como la primera
tarjeta. Una vez que los parámetros sean cambiados, los archivos de
configuración de los módulos deben ser actualizados.
</p>

<pre caption="Especificar los parámetros por módulo">
# <i>echo "option snd-ice1724 index=0" >> /etc/modprobe.d/alsa</i>
# <i>echo "option snd-ymfpci index=1" >> /etc/modprobe.d/alsa</i>
# <i>update-modules</i>
</pre>

<p>
El ejemplo anterior es la solución preferida, pero no todos los
módulos soportan este tipo de parámetro. Para estos módulos, habrá que
forzar el orden correcto para su carga. Primero hay que pedirle a udev
que no los cargue, colocándolos en una lista negra. Asegúrese de usar
el nombre exacto del módulo a cargar. Para los dispositivos PCI, use
los nombres obtenidos de la salida del comando <c>pcimodules</c>,
disponible en el paquete <c>pciutils</c>. El siguiente ejemplo usa
módulos DVB.
</p>

<pre caption="Colocar los módulos en lista negra">
# <i>echo "blacklist b2c2-flexcop-pci" >> /etc/modprobe.d/dvb</i>
# <i>echo "blacklist budget" >> /etc/modprobe.d/dvb</i>
# <i>update-modules</i>
</pre>

<p>
Luego, cargue los módulos en el orden correcto. Agréguelos al
<path>/etc/modules.autoload.d/kernel-2.6</path> <e>en el orden exacto
que desee cargarlos</e>.
</p>

<pre caption="Cargar los módulos en el orden correcto">
# <i>echo "budget" >> /etc/modules.autoload.d/kernel-2.6</i>
# <i>echo "b2c2-flexcop-pci" >> /etc/modules.autoload.d/kernel-2.6</i>
</pre>
</body>
</section>

<section>
<title>Otros problemas</title>
<body>

<p>
Si los nodos de dispositivo no son creados al cargar un módulo en el
archivo <path>/etc/modules.autoload.d/kernel-2.6</path> pero si
aparecen al cargarlo manualmente con modprobe, intente actualizar al
<c>sys-apps/baselayout-1.8.12</c> o más reciente.
</p>

<p>
El soporte para los dispositivos framebuffer (<path>/dev/fb/*</path>)
viene con los núcleos a partir de la versión 2.6.6-rc2.
</p>

<p>
Para núcleos más antiguos que la versión 2.6.4, debe explícitamente
incluir el soporte para el sistema de archivos <path>/dev/pts</path>.
</p>

<pre caption="Activar el sistema de archivos /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Recursos y reconocimientos</title>
<section>
<body>
<p>
La charla sobre udev en el Linux Symposium (Ottawa, Ontario Canada -
2003) dada por Greg Kroah-Hartman (IBM Corporation) proporcionó un
sólido entendimiento acerca de la aplicación udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's
UDEV Primer</uri> es un documento, en inglés, que trata en profundidad
acerca de udev y Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev
rules</uri> por nuestro compañero desarrollador Gentoo Daniel Drake,
es un excelente documento para aprender a personalizar su instalación
udev.
</p>
</body>
</section>
</chapter>
</guide>
