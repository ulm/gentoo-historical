<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/udev-guide.xml,v 1.11 2006/04/06 00:39:23 yoswink Exp $ -->

<guide link="/doc/es/udev-guide.xml" lang="es">
<title>Guía udev en Gentoo</title>

<author title="Autor">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Colaborador">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Traductor">
   <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
<author title="Traductor">
   <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>
<author title="Traductor">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>
<author title="Traductor">
   <mail link="afcapel@supercable.es">Alberto F. Capel</mail>
</author>

<abstract>
Este documento explica qué es udev y cómo puede usarlo de acuerdo a
sus necesidades.
</abstract>

<license/>

<version>0.23</version>
<date>2006-03-25</date>

<chapter>
<title>¿Qué es udev?</title>
<section>
<title>El directorio /dev</title>
<body>

<p>
Cuando los usuarios de Linux hablan acerca del hardware de sus sistemas a
gente que puede llegar a pensar que Linux es algún tipo
de virus o marca de café, el uso de términos como "barra dev barra
algo" provocará, sin dudas, miradas raras. Pero para el usuario afortunado
(incluyendo al lector) el usar <path>/dev/hda1</path> es sólo una
forma rápida de explicar que nos referimos a la primera partición del
disco IDE maestro. ¿O no?
</p>

<p>
Todos sabemos lo que es un archivo de dispositivo. Algunos incluso
saben por qué cuando miramos un poco más de cerca la salida de <c>ls
-l</c> en  <path>/dev</path> los archivos de dispositivo muestran unos
números especiales. Pero lo que siempre damos por sentado es que
el primer disco IDE se llama <path>/dev/hda</path>. Tal vez no lo vea
así, pero ésta es una falla de diseño.
</p>

<p>
Piense en los dispositivos que se enchufan en caliente como los USB,
IEEE 1394, tarjetas PCI que se cambian en caliente ... ¿Cuál es el
primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás
dispositivos cuando el primero desaparezca? ¿Cómo afectará ésto a las
transacciones en curso? ¿No sería gracioso que un trabajo de impresión se
cambiase de repente desde su flamante impresora láser nueva a la moribunda
impresora de matriz solo porque alguien decidió desenchufar la impresora láser
que era la primera impresora?
</p>

<p>
Entra en escena <e>udev</e>. Los objetivos del proyecto udev son a la vez
interesantes y necesarios:
</p>

<ul>
  <li>Funciona en espacio de usuario</li>
  <li>Crea/borra archivos de dispositivo dinámicamente</li>
  <li>Proporciona nombres consistentes</li>
  <li>Proporciona una API en espacio de usuario</li>
</ul>

<p>
Para proporcionar estas características, udev se desarrolla en tres
proyectos separados: <e>namedev</e>, <e>libsysfs</e> y por supuesto,
<e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev permite definir nombres de dispositivos independientemente del
programa udev. Esto permite políticas y esquemas flexibles de
asignación de nombres desarrollados por entidades diferentes. Este
subsistema de asignación de nombres proporciona un interfaz estándar
que udev puede usar.
</p>

<p>
Actualmente se proporciona un solo esquema de asignación de nombres
con udev; de LANANA, usado por la mayoría de sistemas Linux actuales y
por tanto muy apropiado para la mayoría de usuarios de Linux.
</p>

<p>
Namedev usa un procedimiento de cinco pasos para averiguar el nombre de un
determinado dispositivo. Si el nombre se encuentra en uno de los pasos
dados, se usa ese nombre. Estos pasos son:
</p>

<ul>
  <li>etiqueta o número de serie</li>
  <li>número del bus del dispositivo</li>
  <li>topología del bus</li>
  <li>nombre dado estáticamente</li>
  <li>nombre proporcionado por el núcleo</li>
</ul>

<p>
El paso de <e>etiqueta o número de serie</e> comprueba si el dispositivo tiene
un identificador único. Por ejemplo, los dispositivos USB tienen un
número de serie USB único; los dispositivos SCSI tienen un único
UUID. Si namedev encuentra una correspondencia entre este número único
y un archivo de configuración dado, se usa el nombre proporcionado por
el archivo de configuración.
</p>

<p>
El paso del <e>número del bus del dispositivo</e> comprueba el número
del bus del dispositivo. Para dispositivos que no enchufables en
caliente este procedimiento es suficiente para identificar un
dispositivo de hardware. Por ejemplo, los números de bus PCI rara vez
cambian durante la vida de un sistema. De nuevo, si namedev encuentra
una correlación entre esta posición y un archivo de configuración
dado, se usa el nombre proporcionado por el archivo de configuración.
</p>

<p>
Asimismo, <e>la topología del bus</e> es una forma algo estática de
definir dispositivos mientras el usuario no los cambie. Cuando la
posición de los dispositivos concuerda con la configuración
proporcionada por el usuario, se usa el nombre acompañante.
</p>

<p>
El cuarto paso <e>nombres dados estáticamente</e>, es simplemente una
sustitución de cadenas. Cuando un nombre del núcleo (el nombre por
defecto) concuerda con una cadena dada, se usa el nombre sustituto.
</p>

<p>
El paso final (<e>nombre proporcionado por el núcleo</e>) es una
solución para cuando no funcione ninguno de los anteriores: toma el nombre
por defecto proporcionado por el núcleo. En la mayoría de los casos,
esto es suficiente ya que concuerda con los nombres de dispositivo
usados en los sistemas actuales de Linux.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
Udev interacciona con el núcleo a través de el pseudo-sistema de
archivos sysfs. El proyecto libsysfs proporciona una API común para
acceder de forma genérica a la información dada por el sistema de
archivos sysfs. Esto permite consultar todo tipo de hardware sin tener
que hacer suposiciones acerca de su tipo.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Cada vez que el núcleo detecta una actualización en la estructura de
dispositivos, llama al programa <path>/sbin/hotplug</path>. Hotplug
ejecuta las aplicaciones enlazadas en el directorio
<path>/etc/hotplug.d/default</path> donde encontrará enlaces
simbólicos a la aplicación udev. Hotplug dirige la información dada
por el núcleo a la aplicación udev que realiza las acciones necesarias
(creando o borrando archivos de dispositivo) en la estructura
<path>/dev/</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Usando udev en Gentoo</title>
<section>
<title>Requisitos</title>
<body>

<p>
udev está supuesto de ser utilizado en combinación con un núcleo 2.6
(<c>vanilla-sources</c> o <c>gentoo-sources</c>) con el perfil por
defecto 2005.0. Si está usando alguno de estos núcleos, asegúrese de
tener instalado una versión reciente de <c>sys-apps/baselayout</c>. Es
todo lo que hace falta.
</p>

<pre caption="Instalando udev">
# <i>emerge udev</i>
</pre>

<p>
udev instalará <c>hotplug-base</c> como una de sus dependencias. No
hará falta instalar <c>hotplug</c> a no ser que quiera que sus módulos
sean cargados automáticamente al enchufar dispositivos. <c>hotplug</c>
también maneja automáticamente la instalación de dispositivos de red y
descarga de firmware.
</p>

<pre caption="Instalando guiones opcionales de hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Si desea que los módulos correspondientes a los dispositivos
enchufados antes de arrancar sean cargados, use el paquete coldplug:
</p>

<pre caption="Instalando el paquete coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
No olvide agregar <c>coldplug</c> al nivel de ejecución boot:
</p>

<pre caption="Agregando coldplug al nivel de ejecución boot">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Al construir un núcleo, asegúrese de activar las siguientes opciones:
</p>

<pre caption="Opciones requeridas en el núcleo">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Puede dejar activo el soporte al sistema de archivos <c>/dev file
system support (OBSOLETE)</c>, si lo desea, pero desactive la opción
para montar automáticamente al arrancar ("Automatically mount at
boot"):
</p>

<pre caption="No monte devfsd automáticamente">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Si usa <c>genkernel</c>, no se olvide ejecutarlo con la opción
<c>--udev</c> para que active todas las directivas requeridas para el
núcleo. La configuración por defecto dada por esta invocación de
<c>genkernel</c> es suficiente.
</p>

</body>
</section>
<section>
<title>Configuración</title>
<body>

<p>
Si desea usar los afinamientos agregados por Gentoo para hacer la vida
más fácil, entonces no siga leyendo. Gentoo usará udev, pero mantendrá
un <path>/dev</path> estático, de forma que no le falten nodos de
dispositivos. Los guiones de inicio de Gentoo no ejecutarán al demonio
devfsd y desactivará devfs al arrancar.
</p>

<p>
Pero si es fanático y quiere tener un sistema sólo con udev, sin
afinamientos, tal y como se pretende en el desarrollo de udev
(incluyendo la dificultad generada por perder los nodos de los
dispositivos que udev no soporta todavía), por supuesto, siga
adelante :)
</p>

<p>
Desactivaremos las reglas que guarden los nodos de archivo: modifique
la variable <c>RC_DEVICE_TARBALL</c> en <path>/etc/conf.d/rc</path> y
cámbielo a <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Si ha incluido soporte para devfs en el núcleo, puede desactivarlo en
el archivo de configuración del gestor de arranque, agregando el
parámetro al núcleo: <c>gentoo=nodevfs</c>. Si desea usar devfs y
desactivar udev, agregue el parámetro <c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemas conocidos</title>
<section>
<title>Nodos de dispositivos que faltan al arrancar</title>
<body>

<p>
Si no logra arrancar por culpa de errores acerca de un
<path>/dev/null</path> no encontrado, o porque falta la consola
inicial, el problema es que faltan unos nodos de algunos dispositivos
que deberían existir <e>antes</e> de montar <path>/dev</path> para
luego sea manejado por udev. Esto es común en máquinas Gentoo que
tienen instalaciones hechas con mucha antigüedad.
</p>

<p>
Si tiene instalado <c>sys-apps/baselayout-1.8.12</c> o más reciente,
este problema está aliviado, ya que el proceso de arranque debe poder
completarse. Sin embargo, para deshacerse de esas advertencias
molestas, debe crear los nodos faltantes como describimos más
adelante.
</p>

<p>
Para determinar cuáles nodos están presentes antes de montar el
sistema de archivos <path>/dev</path>, ejecute los siguientes
comandos:
</p>

<pre caption="Listando los nodos de dispositivos disponibles al arrancar">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Los dispositivos necesarios para un arranque exitoso son
<path>/dev/null</path> y <path>/dev/console</path>. Si no aparecen en
el listado previo, debe crearlos manualmente. Escriba los siguientes
comandos dentro del directorio <path>test/dev/</path>:
</p>

<pre caption="Creando los archivos de nodos de dispositivos necesarios">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Al terminar, no se olvide de desmontar el directorio <path>test/</path>:
</p>

<pre caption="Desmontando el directorio test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev y nvidia</title>
<body>

<p>
Si usa el driver propietario de nVidia y el servidor X falla al
iniciar en un sistema puramente udev, asegúrese de tener:
</p>

<ul>
  <li>
    el módulo <c>nvidia</c> listado en
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    una versión de <c>nvidia-kernel</c> igual o mayor que
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    una versión de baselayout igual o mayor que
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

<p>
Si <c>xorg-x11</c> rechaza en iniciar, puede que se deba a la falta del
archivo de dispositivo <path>/dev/nvidia</path>. Si aquel es el caso,
ejecute <path>/sbin/NVmakedevices.sh</path> para (re)crearlo.
</p>

</body>
</section>
<section>
<title>Nombres de LVM2 desaparecen</title>
<body>

<p>
Al usar <c>udev</c> en conjunto con LVM2, tal vez note que los
grupos de volúmenes y volúmenes lógicos creados han desaparecido. Bueno, en
realidad, no han desaparecido, desafortunadamente han sido
renombrados <path>/dev/dm-#</path> siendo el # 0, 1, ...
</p>

<p>
Para arreglar esto, modifique el archivo
<path>/etc/udev/rules.d/50-udev.rules</path> y descomente la siguiente
línea:
</p>

<pre caption="Descomente esta línea en el archivo /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
A continuación, instale <c>sys-fs/multipath-tools</c>, el cual contiene la
aplicación <c>devmap_name</c>.
</p>

<pre caption="Instalando multipath-tools">
<comment>(Al momento de escribir esta guía, multipath-tools está solamente
disponible en la rama de pruebas:)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>No existe nombramiento consistente entre DevFS y udev</title>
<body>

<p>
Aunque nuestra intención es tener un esquema de nombramiento
consistente para ambas soluciones dinámicas de manejo de dispositivos,
a veces ocurren diferencias en el nombramiento.
</p>

<p>
Un conflicto reportado ocurre con el controlador HP Smart Array 5i
(para ser más preciso, con el módulo del núcleo <c>cciss</c>). Con
udev los dispositivos son nombrados <path>/dev/cciss/cXdYpZ</path> con
la X, Y y Z como números enteros. Con devfs, los dispositivos son
nombrados <path>/dev/hostX/targetY/partZ</path> o enlazados
simbólicamente a <path>/dev/cciss/cXdY</path>.
</p>

<p>
Si este es el caso, no se olvide actualizar su archivo
<path>/etc/fstab</path> y su archivo de configuración del gestor de
arranque como corresponde.
</p>

<p>
Lo mismo ocurre con los enlaces simbólicos que existían en el
directorio <path>/dev</path>, como <path>/dev/mouse</path>, el cual
<c>udev</c> ya no crea. Asegúrese de revisar su configuración X para
ver si la regla del ratón apunta a un archivo de dispositivo
existente.
</p>

<p>
Otro problema es la diferencia en el nombramiento de los terminales
entre devfs y udev. Aunque devfs denomina <c>tty</c> a sus terminales,
udev por su parte los llama <c>vc</c>. Esto podría resultar en un problema
en caso de que esté restringiendo los ingresos del superusuario desde las
consolas usando <path>/etc/securetty</path>. Tendrá que asegurarse que
<c>tty1</c> sea cambiado a <c>vc/1</c> en <path>/etc/securetty</path> para
que el superusuario pueda ingresar usando la consola.
</p>

</body>
</section>
<section>
<title>Otros problemas</title>
<body>

<p>
Si los nodos de dispositivo no son creados al cargar un módulo en el
archivo <path>/etc/modules.autoload.d/kernel-2.6</path> pero si
aparecen al cargarlo manualmente con modprobe, intente actualizar al
<c>sys-apps/baselayout-1.8.12</c> o más reciente.
</p>

<p>
El soporte para los dispositivos framebuffer (<path>/dev/fb/*</path>)
viene con los núcleos a partir de la versión 2.6.6-rc2.
</p>

<p>
Para núcleos más antiguos que la versión 2.6.4, debe explícitamente
incluir el soporte para el sistema de archivos <path>/dev/pts</path>.
</p>

<pre caption="Activando el sistema de archivos /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Recursos y reconocimientos</title>
<section>
<body>
<p>
La charla sobre udev en el Linux Symposium (Ottawa, Ontario Canada -
2003) dada por Greg Kroah-Hartman (IBM Corporation) proporcionó un
sólido entendimiento acerca de la aplicación udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's
UDEV Primer</uri> es un documento, en inglés, que trata en profundidad acerca
de udev y Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev
rules</uri> por nuestro compañero desarrollador Gentoo Daniel Drake,
es un excelente documento para aprender a personalizar su instalación
udev.
</p>

</body>
</section>
</chapter>

</guide>
