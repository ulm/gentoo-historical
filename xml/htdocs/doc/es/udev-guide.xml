<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/udev-guide.xml,v 1.31 2013/03/21 18:29:00 nimiux Exp $ -->

<guide lang="es">
<title>Guía udev en Gentoo</title>

<author title="Autor">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Colaborador">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Editor">
  <mail link="nightmorph"/>
</author>
<author title="Traductor">
   <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
<author title="Traductor">
   <mail link="chiguire@gentoo.org"/>
</author>
<author title="Traductor">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>
<author title="Traductor">
   <mail link="afcapel@supercable.es">Alberto F. Capel</mail>
</author>
<author title="Traductor">
   <mail link="mcklaren@gmail.com">Manuel Peral González</mail>
</author>
<author title="Traductor">
  <mail link="nimiux"/>
</author>

<abstract>
Este documento explica qué es udev y cómo puede usarlo de acuerdo a
sus necesidades.
</abstract>

<license/>

<version>13</version>
<date>2013-03-20</date>

<chapter>
<title>¿Qué es udev?</title>
<section>
<title>El directorio /dev</title>
<body>

<p>
Cuando los usuarios de Linux hablan acerca del hardware de sus
sistemas a gente que puede llegar a pensar que Linux es algún tipo de
virus o marca de café, el uso de términos como "barra dev barra algo"
provocará, sin dudas, miradas raras. Pero para el usuario afortunado
(incluyendo al lector) el usar <path>/dev/sda1</path> es solo una
forma rápida de explicar que nos referimos a la primera partición del
disco primer disco SATA. ¿O no?
</p>

<p>
Todos sabemos lo que es un archivo de dispositivo. Algunos incluso
saben por qué cuando miramos un poco más de cerca la salida de <c>ls
-l</c> en <path>/dev</path> los archivos de dispositivo muestran unos
números especiales. Pero lo que siempre damos por sentado es que el
primer disco SATA se llama <path>/dev/sda</path>. Tal vez no lo vea
así, pero ésta es un fallo de diseño.
</p>

<p>
Piense en los dispositivos que se enchufan en caliente como los USB,
IEEE 1394, tarjetas PCI que se cambian en caliente ... ¿Cuál es el
primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás
dispositivos cuando el primero desaparezca? ¿Cómo afectará ésto a las
transacciones en curso? ¿No sería gracioso que un trabajo de impresión
se cambiase de repente desde su flamante impresora láser nueva a la
moribunda impresora de matriz solo porque alguien decidió desenchufar
la impresora láser que era la primera impresora?
</p>

<p>
Entra en escena <e>udev</e>. Los objetivos del proyecto udev son a la
vez interesantes y necesarios:
</p>

<ul>
  <li>Funciona en espacio de usuario</li>
  <li>Crea/borra archivos de dispositivo dinámicamente</li>
  <li>Proporciona nombres consistentes</li>
  <li>Proporciona una API en espacio de usuario</li>
</ul>

<p>
Cada vez que se produce un cambio en la estructura de dispositivos, el
núcleo emite un <e>uevent</e> el cual es recogido por udev. Entonces,
udev sigue las reglas declaradas en los directorios
<path>/etc/udev/rules.d</path>, <path>/run/udev/rules.d</path>
y <path>/lib/udev/rules.d</path>. Basándose en la información contenida
en el evento, busca la regla o reglas que necesita ejecutar y realiza
las acciones requeridas. Estas acciones pueden consistir en la creación
o eliminación de ficheros de dispositivo, pero pueden suponer también
la carga de ficheros de firmware particulares en la memoria del núcleo.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Utilizar udev en Gentoo</title>
<section>
<title>Requisitos</title>
<body>

<p>
Udev está pensado para ser utilizado en combinación con núcleos 2.6
y 3.X (como <c>gentoo-sources</c> con el perfil por defecto 13.0).
Si está usando alguno de estos núcleos, no debería tener problemas,
ya que el soporte necesario está incluido en todas las versiones
estables de <c>sys-apps/baselayout</c>. Normalmente, udev debería
estar instalado en su sistema, pero si éste no es el caso, es fácil
de instalar:
</p>

<pre caption="Instalando udev">
# <i>emerge udev</i>
</pre>

<p>
Al construir un núcleo, asegúrese de activar las siguientes opciones:
</p>

<pre caption="Opciones requeridas en el núcleo">
General Setup ---&gt;
  <comment>(Asegúrese de que las siguientes opciones *no* están instaladas)</comment>
  [ ] Enable deprecated sysfs features to support old userspace tools

File Systems ---&gt;
  [*] Inotify support for userspace
  Pseudo filesystems ---&gt;
    [*] Virtual memory file system support (former shm fs)

Device Drivers ---&gt;
  <comment>(Asegúrese de que las siguientes opciones *no* están habilitadas)</comment>
  &lt; &gt; ATA/ATAPI/MFM/RLL support (DEPRECATED)
  <comment>(Esto es *absolutamente* necesario para que /dev tenga entradas)</comment>
  Generic Driver Options ---&gt;
    [*] Maintain a devtmpfs filesystem to mount at /dev
</pre>

<p>
Si usa <c>genkernel</c>, no necesita hacer nada especial. Genkernel
activa udev por defecto.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemas conocidos</title>
<section>
<title>Nombramiento inconsistente entre DevFS y udev</title>
<body>

<p>
Aunque nuestra intención es tener un esquema de nombramiento
consistente para ambas soluciones dinámicas de manejo de dispositivos,
a veces ocurren diferencias en el nombramiento.
</p>

<p>
Un conflicto reportado ocurre con el controlador HP Smart Array 5i
(para ser más preciso, con el módulo del núcleo <c>cciss</c>). Con
udev los dispositivos son nombrados <path>/dev/cciss/cXdYpZ</path> con
la X, Y y Z como números enteros. Con devfs, los dispositivos son
nombrados <path>/dev/hostX/targetY/partZ</path> o enlazados
simbólicamente a <path>/dev/cciss/cXdY</path>.
</p>

<p>
Si este es el caso, no se olvide actualizar su archivo
<path>/etc/fstab</path> y su archivo de configuración del gestor de
arranque como corresponde.
</p>

<p>
Lo mismo ocurre con los enlaces simbólicos que existían en el
directorio <path>/dev</path>, como <path>/dev/mouse</path>, el cual
<c>udev</c> ya no crea. Asegúrese de revisar su configuración X para
ver si la regla del ratón apunta a un archivo de dispositivo
existente.
</p>

<p>
Otro problema es la diferencia en el nombramiento de los terminales
entre devfs y udev. Aunque devfs denomina <c>tty</c> a sus terminales,
udev por su parte los llama <c>vc</c> y <c>tty</c>. Esto podría
resultar en un problema en caso de que esté restringiendo los ingresos
del superusuario desde las consolas usando
<path>/etc/securetty</path>. Tendrá que asegurarse que <c>tty1</c> y
<c>vc/1</c> aparezcan listados en <path>/etc/securetty</path> para que
el superusuario pueda ingresar usando la consola.
</p>

</body>
</section>
<section>
<title>udev carga los módulos en orden impredecible</title>
<body>

<p>
A veces udev carga los módulos en un orden indeseado, impredecible o
hasta aparentemente aleatorio. Esto es especialmente común en sistema
con dispositivo múltiples del mismo tipo, al igual que dispositivos
multimedia. Esto puede afectar los número de dispositivo asignados;
por ejemplo, las tarjetas de sonido se cambian de número.
</p>

<p>
Existen unas pocas soluciones para resolver la asignación de números
de dispositivo y/o orden de carga de los módulos. Idealmente, podría
pasar parámetros al módulo para especificar el número de dispositivo
deseado. Algunos módulos, como los de ALSA, incluyen un parámetro tipo
"índice". Los módulos que usen este parámetro pueden ser ajustados de
esta manera. Este ejemplo es para un sistema con dos tarjetas de
sonido. La tarjeta con el índice 0 es designada como la primera
tarjeta. Una vez que los parámetros sean cambiados, los archivos de
configuración de los módulos deben ser actualizados.
</p>

<pre caption="Especificar los parámetros por módulo">
# <i>echo "option snd-ice1724 index=0" >> /etc/modprobe.d/alsa</i>
# <i>echo "option snd-ymfpci index=1" >> /etc/modprobe.d/alsa</i>
# <i>update-modules</i>
</pre>

<p>
El ejemplo anterior es la solución preferida, pero no todos los
módulos soportan este tipo de parámetro. Para estos módulos, habrá que
forzar el orden correcto para su carga. Primero hay que pedirle a udev
que no los cargue, colocándolos en una lista negra. Asegúrese de usar
el nombre exacto del módulo a cargar. Para los dispositivos PCI, use
los nombres obtenidos de la salida de la orden <c>lspci -k</c>,
disponible en el paquete <c>pciutils</c>. El siguiente ejemplo usa
módulos DVB.
</p>

<pre caption="Colocar los módulos en lista negra">
# <i>echo "blacklist b2c2-flexcop-pci" >> /etc/modprobe.d/dvb</i>
# <i>echo "blacklist budget" >> /etc/modprobe.d/dvb</i>
# <i>update-modules</i>
</pre>

<p>
Luego, cargue los módulos en el orden correcto. Agréguelos al
<path>/etc/conf.d/modules</path> <e>en el orden exacto
que desee cargarlos</e>.
</p>

<pre caption="Cargar los módulos en el orden correcto">
# <i>nano -w /etc/conf.d/modules</i>

modules="<i>budget b2c2-flexcop-pci</i>"
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Recursos y reconocimientos</title>
<section>
<body>

<p>
<uri link="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames">
Documentación para el uso de los nuevos nombres de interfaces de red
</uri> (en inglés).
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">
Decibel's UDEV Primer</uri> es un documento, en inglés, que trata en
profundidad acerca de udev y Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev
rules</uri> por nuestro compañero desarrollador Gentoo Daniel Drake,
es un excelente documento para aprender a personalizar su instalación
udev.
</p>

</body>
</section>
</chapter>
</guide>
