<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/udev-guide.xml,v 1.3 2005/01/25 11:48:14 neysx Exp $ -->

<guide link="/doc/es/udev-guide.xml" lang="es">
<title>Guía udev en Gentoo</title>

<author title="Autor">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contribuyente">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Editor Es">
   <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
<author title="Editor Es Adjunto">
   <mail link="chiguire@gentoo.org">Joohn Christian Stoddart</mail>
</author>
<author title="Traductor">
   <mail link="afcapel@supercable.es">Alberto F. Capel</mail>
</author>

<abstract>
Este documente explica qué es udev y cómo puede usarlo de acuerdo a
sus necesidades.
</abstract>

<license/>

<version>0.18</version>
<date>2004-11-28</date>

<chapter>
<title>¿Qué es udev?</title>
<section>
<title>El directorio /dev</title>
<body>
<p>
Cuando los usuarios de Linux hablan acerca del hardware de sus
sistemas, gente en la cercanía puede llegar a pensar que es algún tipo
de virus o marca de café, el uso de términos como "barra dev barra
algo" provocará, sin dudas, miradas raras. Pero para el usuario afortunado
(incluyendo al lector) el usar <path>/dev/hda1</path> es sólo una
forma rápida de explicar que nos refirimos a la primera partición del
disco IDE maestro. ¿O no?
</p>

<p>
Todos sabemos lo que es un archivo de dispositivo. Algunos incluso
saben por qué cuando miramos un poco más de cerca la salida de <c>ls
-l</c> en  <path>/dev</path> los archivos de dispositivo muestran unos
números especiales. Pero pero lo que siempre damos por sentado es que
el primer disco IDE se llama <path>/dev/hda</path>. Tal vez no lo vea
así, pero ésta es una falla de diseño.
</p>

<p>
Piense en los dispositivos que se enchufan en caliente como los USB, 
IEEE 1394, tarjetas PCI que se cambian en caliente ... ¿Cuál es el primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás dispositivos
cuando el primero desaparezca? ¿Cómo afectará ésto a las transacciones
en curso? ¿No sería gracioso que un trabajo de impresión se cambiase
de repente desde su flamante impresora laser nueva a la moribunda impresora
de matrices solo porque alguien decidió desenchufar la impresora laser
que era la primera impresora?
</p>

<p>
Entra en escena <e>udev</e>. Los objetivos del proyecto udev son a la vez interesantes y necesarios:
</p>

<ul>
  <li>Funciona en espacio de usuario</li>
  <li>Crea/borra archivos de dispositivo dinámicamente</li>
  <li>Proporciona nombres consistentes</li>
  <li>Proporciona un API en espacio de usuario</li>
</ul>

<p>
Para proporcionar estas características, udev se desarrolla en tres
proyectos separados: <e>namedev</e>, <e>libsysfs</e> y por supuesto,
<e>udev</e>.
</p>
</body>
</section>

<section>
<title>namedev</title>
<body>
<p>
Namedev permite definir nombres de dispositivos independientemente del
programa udev. Esto permite políticas y esquemas flexibles de
asignación de nombres desarrollados por entidades diferentes. Este
subsistema de asignación de nombres proporciona un interfaz estándar
que udev puede usar.
</p>

<p>
Actualmente se proporciona un solo esquema de asignación de nombres
con udev; de LANANA, usado por la mayoría de sistemas Linux actuales y
por tanto muy apropiado para la mayoría de usuarios de Linux.
</p>

<p>
Namedev usa un procedimiento de cinco pasos para averiguar el nombre de un 
determinado dispositivo. Si el nombre se encuentra en uno de los pasos
dados, se usa ese nombre. Estos pasos son:
</p>

<ul>
  <li>etiqueta o número de serie</li>
  <li>número del bus del dispositivo</li>
  <li>topología del bus</li>
  <li>nombre dado estáticamente</li>
  <li>nombre proporcionado por el núcleo</li>
</ul>

<p>
El paso de <e>etiqueta o número de serie</e> comprueba si el dispositvo tiene
un identificador único. Por ejemplo, los dispositivos USB tienen un
número de serie USB único; los dispositivos SCSI tienen un único
UUID. Si namedev encuentra una correspondencia entre este número único
y un archivo de configuración dado, se usa el nombre proporcionado por
el archivo de configuración.
</p>

<p>
El paso del <e>número del bus del dispositivo</e> comprueba el número
del bus del dispositivo. Para dispositivos que no enchufables en
caliente este procedimiento es suficiente para identificar un
dispositivo de hardware. Por ejemplo, los números de bus PCI rara vez
cambian durante la vida de un sistema. De nuevo, si namedev encuentra
una correlación entre esta posición y un archivo de configuración
dado, se usa el nombre proporcionado por el archivo de configuración.
</p>

<p>
Asimismo, <e>la topología del bus</e> es una forma algo estática de
definir dispositivos mientras el usuario no los cambie. Cuando la
posición de los dispositivos concuerda con la configuración
proporcionada por el usuario, se usa el nombre acompañante.
</p>

<p>
El cuarto paso <e>nombres dados estáticamente</e>, es simplemente una
sustitución de cadenas. Cuando un nombre del núcleo (el nombre por
defecto) concuerda con una cadena dada, se usa el nombre sustituto. 
</p>

<p>
El paso final (<e>nombre proporcionado por el núcleo</e>) es una
solución para no funcione ninguno de los anteriores: toma el nombre
por defecto proporcionado por el núcleo. En la mayoría de los casos,
esto es suficiente ya que concuerda con los nombres de dispositivo
usados en los sistemas actuales de Linux.
</p>
</body>
</section>

<section>
<title>libsysfs</title>
<body>
<p>
Udev interacciona con el núcleo a través de el pseudo sistema de
archivos sysfs. El proyecto libsysfs proporciona un API común para
acceder de forma genérica a la información dada por el sistema de
archivos sysfs. Esto permite consultar todo tipo de hardware sin tener
que hacer suposiciones acerca del su tipo.
</p>
</body>
</section>

<section>
<title>udev</title>
<body>
<p>
Cada vez que el núcleo detecta una actualización en la estructura de
dispositivos, llama al programa <path>/sbin/hotplug/</path>. Hotplug
ejecuta las aplicaciones enlazadas en el directorio
<path>/etc/hotplug.d/default</path> donde encontrará enlaces
simbólicos a la aplicación udev. Hotplug dirige la información dada
por el núcleo a la aplicación udev que realiza las acciones necesarias
(creando o borrando archivos de dispositivo) en la estructura
<path>/dev/</path>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Usando udev en Gentoo</title>
<section>
<title>Requisitos</title>
<body>

<p>
udev está supuesto de ser utilizado en combinación con un núcleo 2.6
(<c>development-sources</c> o <c>gentoo-dev-sources</c>). Si está
usando alguno de estos núcleos, asegúrese de tener instalado una
versión reciente de <c>sys-apps/baselayout</c>. Es todo lo que hace
falta.
</p>

<pre caption="Instalando udev">
# <i>emerge udev</i>
</pre>

<p>
udev instalará <c>hotplug-base</c> com una de sus dependencias. No
hará falta instalar <c>hotplug</c> a no ser que quiere que sus módulos
sean cargados automáticamente al enchufar dispositivos. <c>hotplug</c>
también maneja automáticamente la instalación de dispositivos de red y
descarga de firmware.
</p>

<pre caption="Instalando guiones opcioneales de hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Si desea que los módulos correspondientes a los dispositivos
enchufados antes de arrancar sean cargados, use el paquete coldplug:
</p>

<pre caption="Instalando el paquete coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Al construir un núcleo, asegúrese de activar las siguientes opciones:
</p>

<pre caption="Opciones requerida en el núcleo">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Puede dejar activo el soporte al sistema de archivos <c>/dev file
system support (OBSOLETE)</c>, si lo desea, pero desactive la opción
para montar automáticamente al arrancar ("Automatically mount at
boot"):
</p>

<pre caption="No monte devfsd automáticamente">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Si usa <c>genkernel</c>, no se olvide ejecutarlo con la opción
<c>--udev</c> para que active todas las directivas requeridas para el
núcleo. La configuración por defecto dada por esta invocación es
suficiente.
</p>
</body>
</section>

<section>
<title>Configuración</title>
<body>
<p>
Si desea usar los afinamientos agregados por Gentoo para hacer la vida
más fácil, entonces no siga leyendo. Gentoo usará udev, pero mantendrá
un <path>/dev</path> estático, de forma que no le falten nodos de
dispositivos. Los guiones de inicio de Gentoo no ejecutarán al demonio
devfsd y desactivará devfs al arrancar. 
</p>

<p>
Pero si eres fanático y quieres tener un sistema solo con udev, sin
afinamientos, tal y como se pretende en el desarrollo de udev
(incluyendo la dificultad generada por perder los nodos de los
dispositivos que udev no soporta todavía), por supuesto, sigue
adelante :)
</p>

<p>
Desactivaremos las reglas que guarden los nodos de archivo: modifique
la variable <c>RC_DEVICE_TARBALL</c> en <path>/etc/conf.d/rc</path> y
cámbielo a <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Si ha incluido soporte para devfs en el núcleo, puede desactivarlo en
el archivo de configuración del gestor de arranque, agregando el
parámetro al núcleo: <c>gentoo=nodevfs</c>. Si desea usar devfs y
desactivar udev, agregue el parámetro <c>gentoo=noudev</c>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Problemas conocidos</title>
<section>
<title>Nodos de dispositivos que faltan al arrancar</title>
<body>

<p>
Si no logra arrancar por culpa de errors acerca de un
<path>/dev/null</path> no encontrado, o porque falta la consola
inicial, el problema es que faltan unos nodos de algunos dispositivos
que deberían existir <e>antes</e> de montar <path>/dev</path> para
luego ser manejado por udev. Esto es común en máquinas Gentoo que
tienen instalaciones hechas con mucha antiguedad.
</p>

<p>
Si tiene instalado <c>sys-apps/baselayout-1.8.12</c> o más reciente,
este problema está aliviado, ya que el proceso de arranque debe poder
completarse. Sin embargo, para deshacerse de esas advertencias
molestas, debe crear los nodos faltantes como describimos más
adelante.
</p>

<p>
Para determinar cuáles nodos están presentes antes de montar el
sistema de archivos <path>/dev</path>, ejecute los siguientes
comandos:
</p>

<pre caption="Listando los nodos de dispositivos disponibles al arrancar">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Los dispositivos necesarios para un arranque exitoso son
<path>/dev/null</path> y <path>/dev/console</path>. Si no aparecen en
el listado previo, debe crearlos manualmente. Escriba los siguientes
comando dentro del directorio <path>test/dev/</path>:
</p>

<pre caption="Creando los archivos de nodos de dispositivos necesarios">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Al terminar, no se olvide de desmontar el directorio <path>test/</path>:
</p>

<pre caption="Desmontando el directorio test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>
</body>
</section>

<section>
<title>udev y nvidia</title>
<body>

<p>
Si usa el manejador propietario de nVidia y el servidor X falla al
iniciar en un sistema puramente udev, asegúrese de tener:
</p>

<ul>
  <li>
    el módulo <c>nvidia</c> listado en
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    una versión de <c>nvidia-kernel</c> igual o mayor que
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    una versión de baselayout igual o mayor que
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>
</body>
</section>

<section>
<title>Nombres de LVM2 desaparecen</title>
<body>

<p>
Al usar <c>udev</c> en conjunto con LVM2, tal vez note que los
grupos de volúmenes y volúmenes lógicos creados han desaparecido. Bueno, en
realidad, no han desaparecidos, desafortunadamente han sido
renombrados <path>/dev/dm-#</path> siendo el # 0, 1, ...
</p>

<p>
Para arreglar esto, modifique el archivo
<path>/etc/udev/rules.d/50-udev.rules</path> y descomente la siguiente
línea:
</p>

<pre caption="Descomente esta línea en el archivo /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>
</body>
</section>

<section>
<title>No existe nombramiento consistente entre DevFS y udev</title>
<body>

<p>
Aunque nuestra intención es tener un esquema de nombramiento
consistente para ambas soluciones dinámicas de manejo de dispositivos,
a veces ocurren diferencias en el nombramiento.
</p>

<p>
Un conflicto reportado ocurre con el controlador HP Smart Array 5i
(para ser más preciso, con el módulo del núcleo <c>cciss</c>). Con
udev los dispositivos son nombrados <path>/dev/cciss/cXdYpZ</path> con
la X, Y y Z como números enteros. Con devfs, los dispositivos son
nombrados <path>/dev/hostX/targetY/partZ</path> o enlazados
simbólicamente a <path>/dev/cciss/cXdY</path>.
</p>

<p>
Si este es el caso, no se olvide actualizar su archivo
<path>/etc/fstab</path> y su archivo de configuración del gestor de
arranque correspondientmente.
</p>

<p>
Los mismo ocurre con los enlaces simbólicos que existían en el
directorio <path>/dev</path>, como <path>/dev/mouse</path>, el cual
<c>udev</c> ya no crea. Asegúrese de revisar su configuración X para
ver si la regla del ratón apunta a un archivo de dispositivo
existente.
</p>
</body>
</section>

<section>
<title>Otros problemas</title>
<body>

<p>
Si los nodos de dispositivo no son creados al cargar un módulo en el
archivo <path>/etc/modules.autoload.d/kernel-2.6</path> pero si
aparecen al cargarlo manualmente con modprobe, intente actualizar al
<c>sys-apps/baselayout-1.8.12</c> o más reciente.
</p>

<p>
El soporte para los dispositivos framebuffer (<path>/dev/fb/*</path>)
viene con los núcleos a partir de la versión 2.6.6-rc2.
</p>

<p>
Para núcleos más antiguos que la versión 2.6.4, debe explícitamente
incluir el soporte para el sistema de archivos <path>/dev/pts</path>.
</p>

<pre caption="Activando el sistema de archivos /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Recursos y reconocimientos</title>
<section>
<body>
<p>
La charla sobre udev en el Linux Symposium (Ottawa, Ontario Canada -
2003) dada por Greg Kroah-Hartman (IBM Corporation) proporcionó un
sólido entendimiento acerca de la applicación udev.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> es un documento, en inglés, que trata en profundidad acerca de udev y Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev
rules</uri> por nuestro compañero desarrollador Gentoo Daniel Drake,
es un excelente documento para aprender a personalizar su instalación
udev.
</p>
</body>
</section>
</chapter>
</guide>
