<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/Attic/2.6-koutput.xml,v 1.1 2005/03/02 12:06:02 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/2.6-koutput.xml" lang="es">

<title>Salida del Núcleo 2.6</title>

<author title="Desarrollador">
  <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor Es">
    <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
</author>
<author title="Editor Es">
    <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
 </author>
<author title="Editor Es">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>

<author title="Traductor">
    <mail link="nmiyasato@datafull.com">Nicolás Miyasato</mail>
</author>

<abstract>
Esta guía esta apuntada a desarrolladores y cubre los detalles del 
direccionamiento de la salida del nuevo kernel en Gentoo.
</abstract>

<license/>

<version>1.3</version>
<date>2004-07-28</date>

<chapter>
<title>Prefacio</title>
<section>
<title>El Nuevo Sistema</title>
<body>

<p>
Entre la enorme cantidad de mejoras en la serie 2.6 del núcleo de Linux ha sido desarrollada una
nueva infraestructura, "kbuild",  para crear un sistema
de construcción altamente configurable y versátil.  
El total alcance de este cambio no es el tema principal de este documento.
Lo importante es el nuevo método recomendado para compilar módulos externos del núcleo
contra las fuentes del núcleo 2.6. De
<path>Documentation/kbuild/modules.txt</path>:
</p>

<pre caption="Documentation/kbuild/modules.txt">
Compilando módulos por fuera del núcleo oficial
-----------------------------------------------

Frecuentemente, los módulos son desarrollados por fuera del núcleo oficial.
Para estar al tanto de los cambios en el sistema de construcción, la manera
más portable para compilar un módulo por fuera del núcleo es usando el 
siguiente comando de línea:

make -C path/to/kernel/src SUBDIRS=$PWD modules
</pre>

<p>
Con la sustitución de la variable SUBDIRS, la última infraestructura del kbuild
puede fácilmente ser usado para compilar módulos externos. Esto es de por sí un
<e>gran</e> boom, pero tiene la contra de complicar las cosas.
</p>
</body>
</section>

<section>
<title>El problema</title>
<body>

<p>
Habiendo configurado y compilado el núcleo de las series 2.6 el cual reside en
<path>/usr/src/linux</path>, no es irrazonable el hecho de querer compilar
algunos módulos externos contra esta fuente del núcleo. Más allá de eso, uno
esperaría que esto pueda ser realizado por un usuario sin privilegios de 
escritura contra dicho directorio.
Al tratar de hacer esto, concluímos que este <b>no</b> es el caso. Tal 
intento falla, ya que <c>make</c> trata de actualizar los archivos en 
<path>/usr/src/linux</path>, en donde un usuario sin privilegios no tiene
acceso de escritura.
</p>

<p>
Los módulos construídos dentro del sistema de portage sufren exactamente
del mismo problema, muriendo con violaciones del sandbox cuando tales 
actualizaciones son intentadas. Las funcionalidades agregadas al kbuild también 
han agregado un tipo de complejidad que es muy problemático para aquellos que
quieren seguir las seguras prácticas del "privilegio mínimo".
</p>

<p>
Realizando una busqueda en el bugzilla de Gentoo, se encuentran varios bugs
abiertos debido a este problema, y han aparecido muchos mensajes en los foros
sugiriendo la deshabilitación del sandbox como la única solución. Ciertamente,
con el actual estado de las cosas, parecía inevitable que ocurra alguna 
escritura o actualización a <path>/usr/src/linux</path> para la construcción 
de módulos contra los kernels de la serie 2.6.
</p>
</body>
</section>

<section>
<title>Luchando contra el sistema</title>
<body>

<p>
Siempre han existido muchas formas diferentes del tipo "hacker" y fueron
propuestas a solucionar el sistema kbuild, incluyendo la creación de un 
directorio temporal con enlaces simbólicos a elementos en <path>/usr/src/linux</path>.

Finalmente, cualquier manera en que se maneje esto, nos lleva a un 
inconveniente en cuanto a la seguridad, ya que <path>/usr/src/linux</path>
requiere de ser tocado y/o modificado. Sin embargo, el hecho de no tener
una forma relativamente fácil de actualizar la ruta para los usuarios no
es una opción aceptable. Debido a esto, para los estilos viejos del kernel 
2.6, un nuevo kmod.eclass puede hacer que <path>/usr/src/linux</path> sea 
escrito por Portage automáticamente.
</p>

<p>
Como esto es un problema de seguridad mayor, la primera vez que los usuarios 
se encuentren con esto, serán forzados a aceptarlo mediante una nueva 
herramienta, <b>config-kernel</b>. Los usuarios pueden correr config-kernel 
una vez para aceptarlo, y luego serán simplemente advertidos cada vez que 
Portage esté escribiendo sobre <path>/usr/src/linux</path> durante una 
compilación de un módulo.
</p>

<pre caption="Corriendo config-kernel">
# <i>config-kernel --allow-writable=yes</i>
</pre>
</body>
</section>

<section>
<title>Cambio abrazador</title>
<body>

<p>
La solución más limpia nace en el "darse cuenta" de que luchar contra las 
nuevas funcionalidades del kbuild solamente traerán más y más problemas en
el futuro. De hecho, la nueva habilidad del kbuild para redireccionar todos
los archivos de salida a un directorio diferente es la solución. La clave del
asunto, es mantener la fuente del núcleo completamente limpio y permitirle 
a los módulos externos a construirse contra esta, mientras que ellos 
redireccionan su salida a un directorio temporal.
</p>

<p>
Los detalles de como estos elementos interactúan es relativamente complicado.
Esperamos que la próxima sección divida a estos conceptos en pequeñas
piezas más digeribles, de manera tal que los desarrolladores y usuarios que
quieran mejorar o usar este nuevo sistema tengan los conocimientos necesarios
para hacerlo.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Salida del núcleo</title>
<section>
<title>KBUILD_OUTPUT y variables O</title>
<body>

<p>
kbuild nos provee dos variables para configurar el destino de los archivos de
salida que se generan.
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Modo de uso</th>
</tr>
<tr>
  <ti>KBUILD_OUTPUT</ti>
  <ti>
    Estas variables pueden ser definidas en el <path>Makefile</path> de primer
    nivel.
    Esto puede ser usado si quiere configurar una salida por defecto que no sea
    la fuente del núcleo en si.
    </ti>
</tr>
<tr>
  <ti>O</ti>
  <ti>
    Esta variable es usada en la línea de comandos para ignorar cualquier otra
    configuración e indicar la salida para el comando que actualmente se está
    ejecutando.
  </ti>
</tr>
</table>

<p>
Para instalar los módulos del núcleo, la combinación de estas dos variables 
es la clave para utilizar satisfactoriamente a kbuild y portage.
</p>
</body>
</section>

<section>
<title>Cambios en la instalación del núcleo</title>
<body>

<p>
Para usar las funcionalidades de salida del núcleo, el nuevo 
<path>kernel-2.eclass</path> escrito por 
<mail link="johnm@gentoo.org">John Mylchreest</mail> ha sido parcheado para 
agregar una ruta por defecto a <c>KBUILD_OUTPUT</c> en el primer nivel 
del makefile del núcleo (<path>/usr/src/linux/Makefile</path>). Por defecto, 
esta ruta será configurada a <path>/var/tmp/kernel-output/${KV}</path>, ya 
que <path>/var/tmp</path> es un lugar propicio para situar archivos temporales 
que deban persistir entre reinicios.
</p>

<p>
Una vez que esta variable ha sido configurada, todos los comandos make realizados
por dentro de la fuente del núcleo, mandarán sus salidas a este nuevo directorio.
No se requiere ningún otro trabajo por parte de los usuarios y el cambio realizado
en este proceso es muy pequeño (ver la siguiente sección para excepciones). Una 
vez que un núcleo ha sido instalado, un usuario todavía puede hacer:
</p>

<pre caption="Configurando el núcleo">
# <i>make menuconfig</i>
</pre>

<p>
y ellos podrán ser capaces de configurar su núcleo y luego construirlo.
</p>
</body>
</section>

<section>
<title>Cambios en la ubicación de archivos importantes</title>
<body>

<p>
Como todos los archivos generados son redirigidos a un directorio aparte,
algunos archivos claves terminarán en un lugar inesperado por el usuario. En
particular, los <path>.config</path> y <b>bzImage</b> de los usuarios ya no se
encontrarán en <path>/usr/src/linux</path> como lo estaban anteriormente. 
<mail link="latexer@gentoo.org">Peter Johanson</mail> ha escrito una nueva 
<uri link="http://www.gentoo.org/doc/en/2.6-koutput-user.xml">guía</uri> del
nuevo núcleo 2.6 orientado a usuarios finales, la cual se enfoca en 
cambios del kbuild y en particular, las nuevas ubicaciones de estos archivos.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Ebuilds de los módulos externos</title>
<section>
<title>Iniciativa general</title>
<body>

<p>
Ahora que los kernels están redireccionando sus archivos de salida a una
ubicación diferente, el siguiente paso es la escritura de ebuilds que estén
en concordancia con el nuevo sistema. La clave reside en que los ebuilds
sean actualizados de manera tal que busquen a ciertos archivos generados y 
encabezados en la ubicación correcta y hacer que ellos utilizen el 
<path>Makefile</path> correspondiente.
</p>

<p>
La idea general es parchear los <path>Makefiles</path> en los paquetes, de
forma tal que cuando se estén compilando en el entorno del sandbox contra 
núcleos 2.6 , ellos utilizen la variable O para redireccionar su salida 
al directorio temporal. Agregaremos algunos pequeños cambios, obteniendo
así, otro satisfactorio paquete para realizar el emerge de un módulo externo.
</p>

<note>
La usabilidad y funcionalidad de los módulos de por sí luego de ser 
construídos e instalados <e>no</e> es el objetivo de este documento.
Ese es otro tema que los autores de los correpondientes drivers 
deberían de manejar.
</note>

<p>
Los cambios han sido agregados a <path>kmod.eclass</path> de manera que
incluyan algunas variables y herramientas útiles para que los cambios
a nivel del ebuild sean más fáciles de realizar por los autores de los
mismos.
</p>
</body>
</section>

<section>
<title>Requerimientos del Makefile</title>
<body>

<p>
El nuevo koutput agrega ciertas necesidades a los <path>Makefile</path>s de los
paquetes de los módulos del núcleo. En particular, ellos necesitarán utilizar
la variable <c>O</c> del kbuild para redireccionar los archivos construídos a
algún subdirectorio de <c>WORKDIR</c>.
Usualmente esto será algo similar a <path>${S}/tmp</path>. Cuando se usa este
sistema, el directorio de salida debe de contener presente el archivo 
<path>.config</path> del núcleo. La realización de la copia del archivo
<path>.config</path> se puede hacer en el makefile o en el ebuild, es 
recomendable hacerlo en el makefile, ya que esto llevaría a un parche 
que aliviaría a Gentoo de realizar dicha copia.
</p>
</body>
</section>

<section>
<title>Funcionalidades del kmod.eclass</title>
<body>

<p>
Todos los ebuilds de los módulos del núcleo deberán usar ahora el
<path>kmod.eclass</path>.
Todos los ebuilds de los módulos del núcleo deberán usar el 
<path>kmod.eclass</path>. Aquí se muestra un rápido pantallazo de su uso.
La funcion kmod_src_unpack() maneja el desempaquetamiento, así como configurar
un grupo de extremadamente útil de variables que pueden ser usados en cualquier
lugar. El comportamiento de las funciones kmod_src_unpack() son afectados por
dos variables, las cuales pueden ser configurados por el ebuild.
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Modo de uso</th>
</tr>
<tr>
  <ti>KMOD_SOURCES</ti>
  <ti>
    Si está configurado, estos archivos (usualmente tarballs) serán
    descomprimidos dentro de WORKDIR. 
    De otro modo, ${A} será descomprimido. Alternativamente, sin un ebuild 
    necesita descomprimirse, o lo que sea por si sola, WORKDIR puede ser
    configurado a "nada" (none).
  </ti>
</tr>
<tr>
  <ti>KMOD_KOUTPUT_PATCH</ti>
  <ti>
    Si se detecta que KV_OUTPUT es otra cosa diferente a 
    <path>/usr/src/linux</path> y éste está configurado, este parche 
    será aplicado utilizando epatch en <path>${S}</path>. 
    Obviamente esto puede ser hecho a mano, pero esto sería útil para 
    evitar la definición de un src_unpack() en un ebuild.
  </ti>
</tr>
</table>

<p>
kmod_src_unpack() intenta darse cuenta de como tiene que ser manejado 
el driver que se está construyendo. En particular, maneja bastante bien
los 2 métodos de construcción de los núcleos 2.6. Si se detecta que koutput
está siendo usado por el nuevo método, éste no será utilizado, y si existe 
el parche definido en KMOD_KOUTPUT_PATCH, el mismo será aplicado. Luego de 
que kmod_src_unpack() haya sido ejecutado, existen muchísimas variables 
disponibles para el uso en cualquier lugar del ebuild.
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Significado</th>
</tr>
<tr>
  <ti>KV_OUTPUT</ti>
  <ti>
    Es la ruta completa de la salida del núcleo. Para los núcleos 2.4, este 
    siempre será <path>/usr/src/linux</path>. Para los 2.6, se espera que
    sea un directorio diferente (de otra manera, diferentes cosas fallarán 
    durante la compilación del módulo.)
  </ti>
</tr>
<tr>
  <ti>KV_OJB</ti>
  <ti>
    Es la extensión para los módulos del núcleo para esta versión del núcleo.
    Puede ser "ko" o "o" según sea el caso. (núcleo 2.6 o 2.4)
  </ti>
</tr>
<tr>
  <ti>KV_VERSION_FULL</ti>
  <ti>La versión del núcleo en su totalidad.</ti>
</tr>
<tr>
  <ti>KV_MAJOR</ti>
  <ti>El número más significativo del núcleo.</ti>
</tr>
<tr>
  <ti>KV_MINOR</ti>
  <ti>El número menos significativo del núcleo.</ti>
</tr>
<tr>
  <ti>KV_PATCH</ti>
  <ti>El número del parche del núcleo.</ti>
</tr>
<tr>
  <ti>KV_TYPE</ti>
  <ti>El tipo del núcleo (e.g. "-gentoo-r1" in "2.4.23-gentoo-r1")</ti>
</tr>
</table>

<p>
Lo que KV_OUTPUT termina siendo es en definitiva, el factor determinante para
la decisión de que método se utilizará para la correspondiente contrucción. 
Aquí se presenta una tabla en donde se muestra tres configuraciones de núcleos 
diferentes, y el valor que estas dos variables toman luego de que 
kmod_src_unpack() es llamado.
</p>

<table>
<tr>
  <ti></ti>
  <th>KV_OUTPUT</th>
  <th>Primera iniciativa a la construcción de módulos</th>
</tr>
<tr>
  <th>2.4 kernel</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Flexible. Algunos makefiles son construídos a mano, otros utilizarán 
  <b>make -C $(KV_BUILD)</b> para ser construídos. Ambas formas son fáciles
  para núcleos 2.4.
  </ti>
</tr>
<tr>
  <th>Núcleo 2.6, salida normal</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Este es el método tradicional. kmod.eclass maneja esta situación con el uso
  de config-kernel para chequear si los usuarios han permitido la escritura de
  <path>/usr/src/linux</path>, y escribe en él si es necesario. Este es el 
  método a usar hasta que las personas sean convertidas al nuevo estilo de
  construcción.
  </ti>
</tr>
<tr>
  <th>Núcleo 2.6, salida alternativa</th>
  <ti>/algun/directorio</ti>
  <ti>
  Se debe de usar el "método koutput" para la construcción con esta configuración.
  Usualmente se requiere de aplicar parches a los makefiles, y luego variables
  del tipo "origen" y "destino" serán configurados. Los módulos luego se
  construirán utilizando los makefiles del núcleo, pero redirigiendo sus salidas
  a algún subdirectorio local.
  </ti>
</tr>
</table>

<p>
Una función ayudante es provista por kmod.eclass para determinar fácilmente que
configuración será utilizada. <b>is_koutput()</b> permite que el ebuild determine
fácilmente como se contruirán las cosas. Un ebuild típico podría usar el 
siguiente test:
</p>

<pre>
	if is_koutput
	then
		# Se utiliza Sed para arreglar algunas cosas para koutput
		sed -i "s:foo:bar:" Makefile
	fi
</pre>

<p>
Generalmente, la mayoría de los ebuilds necesitan aplicar un parche a los
makefiles para habilitar la redirección a otro directorio, y luego utilizar
sed sobre el mismo si is_koutput() devuelve verdadero. El ejemplo del ebuild
que se encuentra por debajo muestra como esto es manejado. Para aquellos
ebuilds que requieran de mayor trabajo manual (por ejemplo nvidia-kernel), 
se encuentran disponibles algunas funciones que pueden ser llamados 
individualmente para un control más fino del asunto.
</p>

<table>
<tr>
  <th>Función</th>
  <th>Modo de uso</th>
</tr>
<tr>
  <ti>kmod_make_linux_writable()</ti>
  <ti>
    Esta función sirve para que se pueda escribir en <path>/usr/src/linux</path>.
    Debería de ser llamado en vez de llamar directamente a addwrite, ya que 
    realizará todos los chequeos necesarios para asegurarse que el usuario 
    ha autorizado explicitamente la escritura del mismo con el comando
    <b>config-kernel</b>.
  </ti>
</tr>
<tr>
  <ti>kmod_do_buildpatches()</ti>
  <ti>
    Esta función puede ser llamada para aplicar el parche desde 
    KMOD_KOUTPUT_PATCH cuando se requiera. Usualmente será llamado
    si un ebuild es forzado, por algún motivo, a descomprimir las 
    fuentes del módulo a mano.
  </ti>
</tr>
<tr>
  <ti>is_kernel()</ti>
  <ti>
    Esta función toma dos argumentos, la versión mayor y menor del núcleo.
    Éste es el método recomendado para evaluar si estamos usando un
    núcleo en particular.
  </ti>
</tr>
</table>

<p>
Así como lo hacen éstas funciones especiales, kmod.eclass también exporta
src_unpack, src_compile, etc, los cuales pueden ser referenciados por
kmod_src_unpack, kmod_src_compile, etc.
</p>
</body>
</section>

<section>
<title>Ejemplo de un ebuild y modificación del Makefile</title>
<body>

<p>
El siguiente es un ejemplo real de como el paquete hostap-driver fue
modificado para crear un ebuild totalmente funcional para ambos núcleos 
2.4.x y 2.6.x. Utiliza un parche para que el Makefile del nivel superior 
de hostapl-driver (que es lo suficientemente generalizado como  para
permitir que ebuilds futuros sean simplificados) 
así como algunos cambios en el ebuild para darnos cuenta de ciertos cambios
en la ubicación de algunos archivos.
</p>

<p>
Debajo se encuentran algunas partes del <path>Makefile</path> original y 
algunas secciones originales y modificadas que harán posible la construcción. 
Primero, es necesario que se arregle una lína que está incluída en el 
<path>.config</path> que se espera que se encuentre en la ruta con las
fuentes del núcleo.
</p>

<note>
La variable KERNEL_OUTPUT_PATH es agregado con anterioridad en la construcción para
complementar la variable KERNEL_PATH que se encuentra en la versión original.
</note>

<pre caption="Línea original del include">
include $(KERNEL_PATH)/.config
</pre>

<p>
Debajo se encuentra una versión arreglada que deja que KERNEL_OUTPUT_PATH sea
configurado si no lo ha sido todavía (para tener una compatibilidad con los
núcleos 2.4) y busca el <path>.config</path> en esa ubicación.
</p>

<pre caption="Línea include reparada">
ifndef KERNEL_OUTPUT_PATH
KERNEL_OUTPUT_PATH=$(KERNEL_PATH)
endif

include $(KERNEL_OUTPUT_PATH)/.config
</pre>

<p>
Ya que disponemos de la variable KERNEL_OUTPUT_PATH  a nuestro alcance, 
la modificación de la siguiente declaración de variable, que tiene que ver
con el <path>version.h</path> generado, es simple. El original:
</p>

<pre caption="VERFILE original">
VERFILE := $(KERNEL_PATH)/include/linux/version.h
</pre>

<p>
y ahora la versión reparada:
</p>

<pre caption="VERFILE modificado">
VERFILE := $(KERNEL_OUTPUT_PATH)/include/linux/version.h
</pre>

<p>
Finalmente, nuestro parche modifica la línea que invoca el sistema
2.6 del kbuild a incluir el uso de la variable O, configurando la salida del
sistema a un directorio <path>tmp/</path> en el siguiente directorio.
</p>

<warn>
kbuild espera encontrar un <path>.config</path> válido en el directorio actual,
especificado por <c>O=foo</c>. Ambos, el ebuild o el makefile, deberían ser
editados a copiar el <path>.config</path> en ${KV_OUTPUT} (configurado por 
kmod.eclass) dentro del directorio de salida.
</warn>

<p>
Aquí se encuentra el original:
</p>

<pre caption="Directorio de salida original">
$(MAKE) -C $(KERNEL_PATH) SUBDIRS=$(PWD)/driver/modules \
	MODVERDIR=$(PWD)/driver/modules modules
</pre>

<p>
Y aquí se encuentra la versión modificada:
</p>

<pre caption="Directorio de salida modificado">
mkdir -p $(PWD)/tmp
-cp $(KERNEL_OUTPUT_PATH)/.config $(PWD)/tmp
$(MAKE) -C $(KERNEL_PATH) O=$(PWD)/tmp \
	SUBDIRS=$(PWD)/driver/modules \
	MODVERDIR=$(PWD)/driver/modules  modules
</pre>

<p>
Los cambios al ebuild son relativamente directos. Particularmente, las 
cosas son fácilmente hechas por kmod.eclass. Aquí se encuentran las 
partes importantes de la sección src_unpack y algunas variables que
nosotros configuramos en el ebuild:
</p>

<pre caption="Función src_unpack()">
KMOD_SOURCES="${P}.tar.gz"
KMOD_KOUTPUT_PATCH="${PN}-koutput.diff.gz"

src_unpack() {
    # Descomprimimos y configuramos algunas variables
    kmod_src_unpack
	
    ## Descomprimimos, si es necesario, las fuentes del pcmcia-cs.
    pcmcia_src_unpack

    epatch "${FILESDIR}/${P}.firmware.diff.bz2"
    
    # Si encontramos un estilo koutput, utilizamos sed para agregar la ruta correspondiente
    if is_koutput
    then
        sed -i -e \
	    "s:^# KERNEL_OUTPUT_PATH=.*:KERNEL_OUTPUT_PATH=${KV_OUTPUT}:" \
	    ${S}/Makefile
    fi
}
</pre>

<p>
Cabe destacar el uso de dos variables, <c>KMOD_SOURCES</c> y 
<c>KMOD_KOUTPUT_PATCH</c>. Las mismas pueden ser configuradas para 
especificar que fuentes deberán ser descomprimidas por kmod_src_unpack() y 
el archivo a parchear si encontramos que koutput es usado. 
<c>KMOD_KOUTPUT_PATCH</c> <b>no</b> será aplicado si se encuentra que el 
núcleo 2.6 está utilizando la vieja manera de redireccionar su salida a 
<path>/usr/src/linux</path>. Aquí se encuentra una versión reducida de 
la función src_compile:
</p>

<pre caption="src_compile() function">
src_compile() {
    # Configurar las fuentes del pcmcia-cs como sea necesario
    pcmcia_configure

    einfo "Building hostap-driver for kernel version: ${KV}"
    case ${KV_MINOR} in
        [34])
            local mydrivers

            use pcmcia &amp;&amp; mydrivers="${mydrivers} pccard"
            use hostap-nopci || mydrivers="${mydrivers} pci"
            use hostap-noplx || mydrivers="${mydrivers} plx"

            einfo "Building the following drivers: ${mydrivers}"
            emake ${mydrivers} || die "make failed"
            ;;
        [56])
            unset ARCH
            emake all || die "make failed"
            ;;
        *)
            eerror "Unsupported kernel version: ${KV}"
	    die
	    ;;
    esac
}
</pre>

<warn>
Para núcleos 2.6, la variable <c>ARCH</c> necesita de estar en 0 ("falso").
Los makefiles del nuevo núcleo utilizan <c>ARCH</c> para determinar la arquitectura 
a la cual deben construir, y utilizar diferentes sintáxis para i386, etc...
</warn>

<p>
La función src_install() de este ebuild no será mostrado, ya que básicamente
instala todos los módulos dentro de <path>/lib/modules/${KV}/</path>. Hay que
notar que maneja el cambio de las extensiones de los módulos del núcleo, 
desde <path>.o</path> a <path>.ko</path> en el núcleo 2.6. kmod.eclass 
configura apropiadamente la variable <c>KB_OBJ</c> a <path>o</path> o 
<path>ko</path> para hacerte las cosas más fáciles.
</p>
</body>
</section>
</chapter>
</guide>
