<?xml version = '1.0' encoding = 'UTF-8' ?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/gentoo-security.xml,v 1.9 2004/07/28 13:21:51 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/en/gentoo-security.xml" >
<title>Guía de seguridad de Gentoo Linux</title>
<author title="Author" >
  <mail link="kn@insecurity.dk" >Kim Nielsen</mail>
</author>
<author title="Editor" >
<!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor" >
  <mail link="stocke2@gentoo.org" >Eric R. Stockbridge</mail>
</author>
<author title="Editor" >
  <mail link="carl@gentoo.org" >Carl Anderson</mail>
</author>
<author title="Editor" >
  <mail link="peesh@gentoo.org" >Jorge Paulo</mail>
</author>
<author title="Editor" >
  <mail link="swift@gentoo.org" >Sven Vermeulen</mail>
</author>
<author title="Editor" >
  <mail link="bennyc@gentoo.org" >Benny Chuang</mail>
</author>
<author title="Editor" >
  <mail link="jaervosz@itu.dk" >Sune Jeppesen</mail>
</author>
<author title="Editor" >
  <mail link="blubber@gentoo.org" >Tiemo Kieft</mail>
</author>
<author title="Editor" >
  <mail link="klasikahl@gentoo.org" >Zack Gilburd</mail>
</author>
<author title="Editor" >
  <mail link="bass@gentoo.org" >José Alberto Suárez López</mail>
</author>
<author title="Follow-up Editor-Es" >
  <mail link="chiguire@gentoo.org" >John Christian Stoddart</mail>
</author>
<author title="Traductor" >
  <mail link="postel@antipoder.dyndns.org" >Postel</mail>
</author>
<author title="Traductor" >
  <mail link="carles@carles.no-ip.info" >Carles Ferrer Peris</mail>
</author>

<abstract>
Esta guía describe paso a paso como asegurar Gentoo Linux.
</abstract>
<license/>
<version>0.4.29</version>
<date>16 de julio, 2004</date>
<chapter>
<title>Introducción</title>
<section>
<body>
<p>
Esta guía está orientada a las personas que utilizan Gentoo Linux en
un entorno de servidor o simplemente creen necesario mejorar la
seguridad.
</p>

<note>
Si después de leer esta guía está interesado en más aspectos
relacionados con la seguridad en Gentoo, entonces vea el <uri
link="http://www.gentoo.org/proj/en/hardened/" >Hardened Gentoo
Project</uri>.
</note>
</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->  </chapter>

<chapter>
<title>Consideraciones previas a la instalación</title>
<section>
<title>Seguridad física</title>
<body>
<p>
No importa cuantas medidas de seguridad implemente, todas pueden ser
fácilmente traspasadas si el atacante puede obtener acceso físico a su
equipo. Asegúrese de que su hardware no es fácilmente accesible. Por
ejemplo, podría ubicar su equipo en un armario para servidores
cerrado. Cerrar con llave la caja de la CPU también es una buena
idea. Para un mayor nivel de seguridad puede restringir la BIOS para
que sólo arranque de su disco duro y deshabilitar el arranque de las
unidades de disquete y de CD-ROM. Para el paranoico es una buena idea
establecer una contraseña de acceso a la BIOS. En los portátiles, las
contraseñas para la BIOS son también una buena idea.
</p>
</body>
</section>

<section>
<title>Planificación de Demonios/Servcios</title>
<body>
<p>
Documente qué servicios debería ejecutar la máquina o piensa que
debería ejecutar. Esto le ayudará a definir mejor la estructura de
particiones para su sistema. Puede incluso hacer que su estrategia de
detección de intrusos sea mucho más sencilla. Desde luego no
necesitaría documentar todo esto si sólo tiene uno o unos pocos
equipos y es el único usuario de los mismos. Por ejemplo, si el equipo
va a actuar como cortafuegos (firewall) no debería ejecutar
<e>ningún</e> servicio salvo, quizás, sshd.
</p>

<p>
Documente eso y la versión actual de sshd, lo que le ayudará a
actualizar el sistema en el caso que se encuentre un agujero de
seguridad en sshd. También le ayudará a determinar quien pudiera tener
acceso al sistema.
</p>
</body>
</section>
<section>
<title>Esquema de particiones</title>
<body>
<p>
Reglas de oro:
</p>
<ul>
<li>Cualquier árbol de directorios en el que un usuario tenga permiso
de escritura (<path>/home</path>, <path>/tmp</path> o
<path>/var</path>) debería estar en una partición separada y usar
cuotas de disco. Portage usa <path>/var/tmp</path> para compilar
ficheros por lo que esta partición debería ser lo suficientemente
grande. Esto reduce el riesgo de que un usuario llene el punto de
montaje raíz (<path>/</path>).</li>
<li>Cualquier árbol de directorios donde quiera instalar software que
no forme parte de la distribución debería estar en una partición
separada. Conforme a la <uri link="http://www.pathname.com/fhs/"
>Jerarquía estándar de ficheros</uri> estos directorios serían
<path>/opt</path> o <path>/usr/local</path>. Si ambos están en
particiones separadas no haría falta borralos si tiene que reinstalar
el sistema.</li>
<li>Pruebe a mover los datos estáticos a su propia partición, y
móntela en modo de sólo lectura (read-only). Si es realmente paranoico
puede intentar almacenar los datos estáticos en un medio de sólo
lectura, como un CD-ROM.</li>
</ul>
</body>
</section>

<section>
<title>El usuario root</title>
<body>
<p>
El usuario root es el usuario más importante del sistema y no debería
usarse para nada más que lo estrictamente necesario. Si un atacante
consigue acceso de root no puede volver a confiar en su sistema, por
lo que deberá reinstalarlo.
</p>

<p>
Reglas de oro respecto a 'root'
</p>

<ul>
<li>
Cree siempre un usuario para la gestión diaria y si este usuario
necesita tener acceso de root, añádalo al grupo 'wheel'. Esto
posibilita que un usuario normal pueda cambiar su ID a root usando el
comando su.
</li>
<li>
Nunca ejecute X u otro software de aplicación como root.
</li>
<li>
Use siempre rutas absolutas cuando se conecte como root. Es posible
engañar a root para que ejecute una aplicación distinta de aquella que
pretendía ejecutar. Por ejemplo si alguien altera el PATH y root hace
su sin usar <c>su -</c>. Entonces root tendrá la trayectoria del usuario.
</li>
<li>
Si un usuario sólo necesita algunos comandos, en lugar de todo lo que
root puede hacer normalmente, considere usar <c>sudo</c>, pero ¡tenga
cuidado con esto!
</li>
<li>
Nunca se deje abierta una terminal donde esté identificado como root.
</li>
</ul>

<p>
Gentoo tiene una protección por defecto para los usuarios normales que
intentan hacer <c>su</c>. La configuración por defecto de PAM
establece que un usuario debe pertenecer al grupo 'wheel' para poder
ser capaz de usar 'su'.
</p>
</body>
</section>

<section>
<title>Políticas de seguridad</title>
<body>
<p>
Hay algunas razones por las cuales son necesarias las políticas de seguridad.
</p>

<ul>
<li>
Nunca puede manifestar que tiene una red segura sin una definición de
lo que piensa que es seguro.
</li>
<li>
Es casi imposible coger potenciales atacantes, resolver problemas de
la red o realizar auditorías sin espiar el tráfico de red o mirar en
los directorios personales de los usuarios (home). Y espiar sin el
consentimiento de los usuarios es ilegal en muchos países. Además,
teniendo en cuenta que alrededor del 60% de los ataques provienen de
la propia organización, es importante mantener los ojos bien
abiertos.
</li>
<li>
No puede esperar que sus usuarios entiendan la seguridad, si nunca les
ha explicado por qué es importante o cómo podrían protegerse ellos
mismos y a sus compañeros.
</li>
<li>
Las buenas guías y la documentación de la red siempre valen la pena.
</li>
<li>
La policía o las fuerzas de orden público no pueden ayudarle a coger
al atacante si no conocen su configuración de red o los servicios que
ofrece.
</li>
<li>
¿Qué hará usted cuando haya ocurrido un ataque? Necesita definir qué
se debería hacer y a quien debería hablarle de ello. ¿Llamará a la
policía o al equipo del CERT en cada ocasión? ¡Así no le tomarán a
usted en serio!
</li>
</ul>

<p>
Esto le debería ayudar a clarificar por qué es importante crear
políticas para los sistemas con más de un usuario y por qué es
importante educar a los usuarios.
</p>

<p>
Una &quot;política&quot; o &quot;directiva&quot; es un documento (o un
conjunto de documentos) con respuestas a preguntas como quién, cómo,
dónde, por qué y cuándo. Cada usuario de su sistema o red debería leer
el documento, entenderlo y firmarlo. Es importante que usted se tome
el tiempo necesario para ayudar a los usuarios a que entiendan las
políticas y por qué las políticas deben ser firmadas, o qué sucedería
si ellos actúan en contra de las mismas (lo que también debe recogerse
en las políticas). Esto debería hacerse por lo menos una vez al año
pues las políticas pueden cambiar, pero también como un recordatorio
para el usuario.
</p>

<note>
Se deben crear políticas fáciles de leer y que sean muy precisas en
cada apartado.
</note>

<p>
Muchas partes de una política pueden ser forzadas directamente en el
sistema operativo o a través del cortafuegos, pero otras no.
</p>

<p>
Una política de seguridad debería contener, al menos, los siguientes
apartados:
</p>

<ul>
<li>Uso aceptable
<ul>
<li>Protectores de pantalla</li>
<li>Manejo de contraseñas</li>
<li>Descarga e instalación de software</li>
<li>Información sobre si los usuarios son monitorizados</li>
<li>Uso de programas antivirus</li>
</ul>
</li>
<li>Manejo de información sensible (en cualquier formato, sea papel o sea electrónico)
<ul>
<li>Limpieza del escritorio y protección de la información confidencial</li>
<li>Apagado del PC antes de marcharse</li>
<li>Uso de cifrado</li>
<li>Manejo de claves para empleados de confianza</li>
<li>Tratamiento de los documentos confidenciales durante los viajes</li>
</ul>
</li>
<li>Manejo de los equipos informáticos durante los viajes
<ul>
<li>Uso de los portátiles en los viajes y las estancias en los hoteles</li>
</ul>
</li>
</ul>

<p>
Las políticas para el equipo de TI deben ser ligeramente distintas de
la de los usuarios normales.
</p>

<p>
Las políticas de seguridad pueden convertirse en algo enorme, y
resultar ser información vital que puede fácilmente olvidarse. Las
políticas para el equipo de TI pueden contener información
confidencial para el usuario normal, por esto se pueden separar en
políticas más pequeñas, como por ejemplo, Política de uso aceptable,
Política de contraseñas, Política de correo electrónico y acceso
remoto.
</p>

<p>
Puede encontrar ejemplos de políticas en <uri
link="http://www.sans.org/resources/policies/" >The SANS Security
Policy Project</uri>. Si tiene una red pequeña y las encuentra
demasiado complejas para su realidad, puede mirar en <uri
link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html" >Site
Security Handbook</uri>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Ajustando la seguridad durante/después la instalación</title>
<section>
<title>Parámetros USE</title>
<body>
<p>
El archivo <path>make.conf</path> contiene los parámetros USE definidas
por el usuario y <path>/etc/make.profile/make.defaults</path> los
parámetros USE por defecto para Gentoo Linux. Para esta guía, las opciones
importantes son <c>pam</c> (Pluggable Authentication Modules),
<c>tcpd</c> (TCP wrappers) y <c>ssl</c> (Secure Socket Layer). Esas
tres aparecen en los parámetros USE por defecto.
</p>
</body>
</section>

<section>
<title>Contraseña para GRUB</title>
<body>
<p>
Grub soporta dos formas diferentes para añadir una contraseña de
acceso a su fichero de configuración
(<path>/boot/grub/grub.conf</path>). Una con texto en claro y otra con
cifrado md5+salt.
</p>
<pre caption="/boot/grub/grub.conf" >
timeout 5
password cámbiame
</pre>

<p>
Esto añadirá la contraseña <c>cámbiame</c> y si no se teclea ninguna
simplemente usará la configuración de arranque por defecto.
</p>

<p>
Cuando añade una contraseña md5, necesita convertirla en un formato
cifrado (<c>man crypt</c>) con el mismo formato que usa
<path>/etc/shadow</path>. Para más información mire <c>man
crypt</c>. La contraseña cifrada <e>cámbiame</e> podría verse como
esto $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0.
</p>

<p>
O también puede convertirla directamente en el shell de grub:
</p>
<pre caption="md5crypt en el shell de grub" >
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<codenote>Tecleado cámbiame</codenote>
Encrypted: $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0

grub> <i>quit</i>
</pre>

<p>
Entonces, corte y pegue la contraseña en
<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf" >
timeout 5
password --md5 $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0
</pre>

<p>
Los 5 segundos de espera resultan prácticos si se trata de un sistema
remoto y debería poder reiniciarse sin interacción con el
teclado. Puede encontrar más información a cerca de las contraseñas de
grub ejecutando <c>info grub</c>.
</p>
</body>
</section>

<section>
<title>Contraseña para LILO</title>
<body>
<p>
LILO también soporta dos formas de uso de contraseñas: global y por
imagen, ambas en texto plano.
</p>

<p>
La contraseña global se establece en el inicio del fichero de configuración:
</p>

<pre caption="/etc/lilo.conf" >
password=cámbiame
restricted
delay=3
</pre>

<p>
De la otra forma, añádala simplemente a la imagen que corresponda.
</p>

<pre caption="/etc/lilo.conf" >
image=/boot/bzImage
      read-only
      password=cámbiame
      restricted
</pre>

<p>
Si la opción <c>restricted</c> no es indicada, LILO pedirá la contraseña, cada vez.
</p>

<p>
Para poder almacenar la nueva información en <path>lilo.conf</path> se
necesita ejecutar <c>/sbin/lilo</c>.
</p>
</body>
</section>

<section>
<title>Restricción de uso de la consola</title>
<body>
<p>
El fichero <path>/etc/securetty</path> le permite especificar desde
qué dispositivos <c>tty</c> (terminales) tiene root permitido el
inicio de sesión.
</p>

<p>
Le sugerimos que comente todas las líneas excepto <c>vc/1</c>. Esto le
asegurará que root sólo puede hacer un login y sólo en un terminal.
</p>

<note>
Los usuarios del grupo 'wheel' podrán continuar haciendo <c>su -</c>
para convertirse en root en otras TTYs.
</note>

<p/>
<pre caption="/etc/securetty" >
vc/1
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Más sobre gestión de registro</title>
<section>
<body>
<p>
Puede conseguir un mayor nivel de detalle en sus registros de sistema
para recibir avisos o errores que le puedan avisar de un ataque en
curso o ya realizado. Los atacantes normalmente escudriñan o
investigan las redes antes de actuar.
</p>

<p>
Es también de vital importancia que los ficheros de registro de
sistema sean fácilmente legibles y manejables. Gentoo Linux le permite
elegir durante la instalación entre tres tipos diferentes de gestores
de registro.
</p>
</body>
</section>

<section>
<title>Gestión de registro: Syslogd</title>
<body>
<p>
Syslogd es el gestor de registro más común para Linux y Unix en
general. No incorpora rotación de los logs. Esta característica se
maneja ejecutando <path>/usr/sbin/logrotate</path> en un trabajo
programado y configurado en <path>/etc/logrotate.conf</path>. Cuan a
menudo se deba ejecutar la rotación de los registros dependerá de la
carga del sistema.
</p>

<p>
A continuación se encuentra el <path>syslog.conf</path> estándar con
algunas características añadidas. Hemos &quot;descomentado&quot; las
líneas <c>cron</c> y <c>tty</c> y añadido un gestor de registro
remoto. Para mejorar la seguridad usted puede almacenar los registros
en dos lugares.
</p>

<pre caption="/etc/syslog.conf" >
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# Primero algunos ficheros de registro estándar. Registre por servicio.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Registro para el sistema de correo. Divídalo porque
# es fácil escribir guiones para manejar estos ficheros. 
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Registro para el servicio de news INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Algunos fichero de registro para todo lo demás
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Las emergencias y alertas son enviadas a todos los
# que han iniciado una sesión.
#
*.emerg                         *
*.=alert                        *

#
# Me gusta que los mensajes se muestren en la consola, pero sólo en una
# consola virtual que normalmente dejo disponible.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# Configurando un servidor para gestionar el registro remotamente
*.*                        @logserver

# La 'named pipe' /dev/xconsole es para la utilidad 'xconsole'. Para usarla,
# debe llamar 'xconsole' con la opción '-file':
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTA: ajuste la siguiente lista, o podría volverse loco si tiene 
#       un sitio medianamente ocupado...
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
Los atacantes intentarán borrar sus huellas editando o borrando los
ficheros de registro. Usted puede dificultar la tarea del atacante
enviando los registros a más de un servidor en máquinas
distintas. Encuentre más información sobre syslogd ejecutando <c>man
syslog</c>.
</p>
</body>
</section>

<section>
<title>Gestión de registro: Metalog</title>
<body>
<p>
El <uri link="http://metalog.sourceforge.net" >Metalog</uri> de Frank
Dennis no puede enviar los registros a un servidor remoto, pero tiene
como ventajas su rendimiento y flexibilidad. Puede registrar por
nombre de programa, urgencia, servicio (como syslogd) e incorpora
concordancia con expresiones regulares y puede ejecutar guiones
externos cuando son encontradas pautas específicas. Es muy bueno para
realizar acciones cuando se necesite.
</p>

<p>
La configuración estándar es suficiente. Si necesita notificar por
correo electrónico cuando ocurre un fallo de contraseña puede utilizar
uno de los siguientes guiones.
</p>

<p>
Para postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para postfix" >
#! /bin/sh
echo &quot;$3&quot; | mail -s &quot;Warning (program : $2)&quot; root
</pre>

<p>
Para qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para qmail" >
#!/bin/sh
echo &quot;To: root
Subject:Failure (Warning: $2) 
$3
&quot; | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Recuerde hacer ejecutable el guión con <c>/bin/chmod +x
/usr/local/sbin/mail_pwd_failures.sh</c>.
</p>

<p>
Entonces &quot;descomente&quot; la línea de comando debajo de
&quot;Password failures&quot; en
<path>/etc/metalog/metalog.conf</path> tal que:
</p>

<pre caption="/etc/metalog/metalog.conf" >
command  = &quot;/usr/local/sbin/mail_pwd_failures.sh&quot;
</pre>
</body>
</section>

<section>
<title>Gestión de registro: Syslog-ng</title>
<body>
<p>
Syslog-ng proporciona algunas de las mismas características que syslog
y metalog con una pequeña diferencia. Puede filtrar mensajes basándose
en nivel y contenido (como metalog), proporciona gestión de registro
remoto como syslog, mantiene registros de syslogd (incluso
descriptores de Solaris), los envía a una TTY, ejecuta programas y
puede actuar como un servidor de registro. Básicamente tiene lo mejor
de los otros dos gestores de registro combinado con una configuración
avanzada.
</p>

<p>
Un clásico fichero de configuración ligeramente modificado:
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf" >
options { long_hostnames(off); sync(0); };

#origen donde leer el registro
source src { unix-stream(&quot;/dev/log&quot;); internal(); };
source kernsrc { file(&quot;/proc/kmsg&quot;); };

#define los destinos
destination authlog { file(&quot;/var/log/auth.log&quot;); };
destination syslog { file(&quot;/var/log/syslog&quot;); };
destination cron { file(&quot;/var/log/cron.log&quot;); };
destination daemon { file(&quot;/var/log/daemon.log&quot;); };
destination kern { file(&quot;/var/log/kern.log&quot;); };
destination lpr { file(&quot;/var/log/lpr.log&quot;); };
destination user { file(&quot;/var/log/user.log&quot;); };
destination mail { file(&quot;/var/log/mail.log&quot;); };

destination mailinfo { file(&quot;/var/log/mail.info&quot;); };
destination mailwarn { file(&quot;/var/log/mail.warn&quot;); };
destination mailerr { file(&quot;/var/log/mail.err&quot;); };

destination newscrit { file(&quot;/var/log/news/news.crit&quot;); };
destination newserr { file(&quot;/var/log/news/news.err&quot;); };
destination newsnotice { file(&quot;/var/log/news/news.notice&quot;); };

destination debug { file(&quot;/var/log/debug&quot;); };
destination messages { file(&quot;/var/log/messages&quot;); };
destination console { usertty(&quot;root&quot;); };
destination console_all { file(&quot;/dev/tty12&quot;); };
destination xconsole { pipe(&quot;/dev/xconsole&quot;); };

#crea los filtros
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match(&quot;failed&quot;); };
filter f_denied { match(&quot;denied&quot;); };

#enlaza filtros con destinos
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#log por defecto
log { source(src); destination(console_all); };
</pre>

<p>
Es muy sencillo de configurar pero también es muy fácil olvidar algo
en el archivo de configuración, ya que es extenso. El autor promete
algunas características extra como cifrado, autentificación,
compresión y control MAC (Mandatory Access Control). Con esas opciones
se convertirá en el gestor de registro de red perfecto, ya que el
atacante no podrá espiar en el registro.
</p>

<p>
Y syslog-ng tiene otras ventajas: ¡no necesita ejecutarse como root!
</p>
</body>
</section>
</chapter>

<chapter>
<title>Montaje de particiones</title>
<section>
<body>
<p>
Al montar una partición <c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>
tiene usted algunas opciones que puede aplicar en
<path>/etc/fstab</path>. Las opciones son:
</p>

<ul>
<li>
<c>nosuid</c> - Ignorará el bit SUID y actúa como si se tratase de un archivo ordinario
</li>
<li>
<c>noexec</c> - Deshabilitará la ejecución de ficheros en esta partición
</li>
<li>
<c>nodev</c> - Ignora dispositivos
</li>
</ul>

<p>
Desafortunadamente esas opciones pueden ser fácilmente burladas
ejecutando una trayectoria indirecta. Sin embargo, estableciendo
<path>/tmp</path> como noexec parará alrededor del 99% de los 'script
kiddies' ya que sus exploits están diseñados para ser ejecutados
directamente desde <path>/tmp</path>.
</p>

<pre caption="/etc/fstab" >
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>
<p/>

<warn>
Estableciendo <path>/tmp</path> en modo <c>noexec</c> puede hacer que
ciertos guiones no ejecuten correctamente.
</warn>

<p/>
<note>
La cuotas de disco están descritas en la sección <uri
link="#doc_chap6_sect3" >Cuotas</uri>.
</note>

<p/>
<note>
Yo no configuro <path>/var</path> en modo <c>noexec</c> o
<c>nosuid</c> incluso si nunca se ejecutan ficheros desde este punto
de montaje. La razón de esto es que qmail se instala en
<path>/var/qmail</path> y debe tener permitido ejecutar y acceder a un
fichero SUID. Yo establezco <path>/usr</path> en modo de sólo lectura
ya que nunca escribo nada en él excepto cuando quiero actualizar
Gentoo. Entonces vuelvo a montar el sistema de ficheros en modo de
lectura-escritura, actualizo y lo vuelvo a montar nuevamente.
</note>

<p/>
<note>
Incluso si usted no utiliza qmail, Gentoo continua necesitando tener
activado el bit de ejecución en <path>/var/tmp</path> ya que los
ebuilds se construyen ahí. Pero se puede establecer una trayectoria 
alternativa si insiste en tener <path>/var</path> en modo
<c>noexec</c>.
</note>
</body>
</section>
</chapter>

<chapter>
<title>Limitaciones de usuario/grupo</title>
<section>
<title>/etc/security/limits.conf</title>
<body>
<p>
El control de recursos puede ser muy efectivo para prevenir DoS
locales o manejar el máximo de logins permitidos a un usuario o
grupo.
</p>

<pre caption="/etc/security/limits.conf" >
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Si quiere establecer <c>nproc</c> o <c>maxlogins</c> a 0, quizás sea
mejor borrar el usuario. En el ejemplo anterior se configura el grupo
<c>dev</c> para procesos, fichero core y <c>maxlogins</c>. El resto se
configura con el valor predeterminado.
</p>

<note>
<path>/etc/security/limits.conf</path> forma parte del paquete PAM y
será sólo aplicable a paquetes que utilicen PAM.
</note>
</body>
</section>

<section>
<title>/etc/limits</title>
<body>
<p>
<path>/etc/limits</path> es muy similar al fichero de limitaciones
<path>/etc/security/limits.conf</path>. Las únicas diferencias son el
formato y que sólo trabaja con usuarios o comodines (no
grupos). Echemos un vistazo a una configuración aceptable:
</p>

<pre caption="/etc/limits" >
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Donde establecemos la configuración por defecto y una configuración
específica para el usuario kn. Limits forma parte del paquete
sys-apps/shadow. No es necesario configurar ninguna limitación en este
archivo si usted ha deshabilitado <c>pam</c> en <path>make.conf</path>
o no configura PAM correctamente.
</p>
</body>
</section>

<section>
<title>Cuotas</title>
<body>
<warn>
Asegúrese que los sistemas de ficheros con los que trabaja soportan
cuotas. ¡ReiserFS no es uno de ellos!
</warn>

<p>
Establecer cuotas en un sistema de ficheros impide a los usuarios
llenar el disco totalmente. Las cuotas son habilitadas en el kernel y
añadidas a un punto de montaje. La opción del kernel se habilita en la
configuración del kernel en <c>File systems->Quota
support</c>. Aplique la siguiente configuración, recompile el kernel y
reinicie usando el nuevo kernel.
</p>

<p>
Empiece instalando cuotas con <c>emerge quota</c>. Entonces modifique
el <path>/etc/fstab</path> y añada <c>usrquota</c> y <c>grpquota</c> a
las particiones en las que quiera restringir el uso de disco como en
el ejemplo siguiente.
</p>

<pre caption="/etc/fstab" >
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
En cada partición en la que haya establecido las cuotas, cree los
ficheros de cuota (<path>quota.user</path> y <path>quota.group</path>)
y guárdelos en la raíz de la partición.
</p>

<pre caption="Crear los ficheros de cuota" >
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Este paso debe hacerse en cada partición en la que se hayan activado
las cuotas. Después de añadir y configurar los ficheros de cuota,
necesitamos añadir el guión <c>quota</c> al nivel de ejecución boot.
</p>

<pre caption="Añadir cuotas al nivel de ejecución boot" >
# <i>rc-update add quota boot</i>
</pre>

<p>
Ahora configuraremos el sistema para comprobar las cuotas una vez a la
semana añadiendo la siguiente línea a <path>/etc/crontab</path>:
</p>

<pre caption="Añadir la comprobación de cuotas en crontab" >
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
Después de reiniciar la máquina, es el momento para establecer las
cuotas de usuarios y grupos. <c>edquota -u kn</c> ejecutará el editor
definido en $EDITOR (por defecto es nano) y le permitirá editar la
cuotas para el usuario kn. <c>edquota -g</c> hará lo mismo para los
grupos.
</p>

<pre caption="Configurando las cuotas para el usuario kn" >
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Para más detalles lea <c>man edquota</c> o el <uri
link="http://www.tldp.org/HOWTO/mini/Quota.html" >Quota mini
howto</uri>.
</p>
</body>
</section>

<section>
<title>/etc/login.defs</title>
<body>
<p>
Si las políticas indican que los usuarios deben cambiar su contraseña
cada dos semanas, cambie el valor <c>PASS_MAX_DAYS</c> a 14 y
<c>PASS_WARN_AGE</c> a 7. También es recomendable que use la caducidad
de contraseñas puesto que los ataques por fuerza bruta permiten
encontrar cualquier contraseña, es sólo cuestión de tiempo. También le
alentamos a que establezca <c>LOG_OK_LOGINS</c> a sí.
</p>
</body>
</section>

<section>
<title>/etc/login.access</title>
<body>
<p>
El fichero <path>login.access</path> también pertenece al paquete
sys-apps/shadow, y proporciona una tabla de control de acceso. La
tabla se usa para controlar quien puede y quien no puede acceder
basándose en el nombre de usuario, nombre de grupo o nombre de
host. Por defecto, todos los usuarios del sistema tienen permitido
hacer login por lo que el fichero consiste sólo en comentarios y
ejemplos. Si usted está asegurando su servidor o estación de trabajo,
le recomendamos que configure este fichero para que nadie más que
usted (el administrador) tenga acceso a la consola.
</p>

<note>
Esta configuración no es aplicable al usuario root.
</note>

<p/>
<pre caption="/etc/login.access" >
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<p/>
<impo>
Tenga cuidado cuando configure estas opciones, puesto que ciertos
errores podrán impedirle acceder a la máquina si usted no tiene acceso
de root.
</impo>

<p/>
<note>
Estas configuraciones no se aplican a SSH puesto que SSH no ejecuta
por defecto <c>/bin/login</c>. Pero se puede habilitar usando
<c>UseLogin yes</c> en <path>/etc/ssh/sshd_config</path>. Lo que hará
que SSH use login y las configuraciones le serán aplicadas.
</note>

<p>
Esto permitirá a los miembros del grupo wheel el acceso local o desde
el dominio gentoo.org. Puede que sea paranoico, pero mejor prevenir
que curar.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Permisos de ficheros</title>
<section>
<title>Lectura para todos</title>
<body>
<p>
Los usuarios normales no deberían tener acceso a los archivos de
configuración o contraseñas. Un atacante puede robar contraseñas de
bases de datos o sitios web y usarlos para alterar, o incluso peor,
borrar datos. Por esto es importante que los permisos sean
correctos. Si usted está seguro que un archivo sólo es usado por root,
asígnele los permisos <c>0600</c> y asigne el usuario correcto al
fichero con <c>chown</c>.
</p>
</body>
</section>

<section>
<title>Escritura para todos/grupos</title>
<body>
<pre caption="Buscando ficheros y directorios con escritura para todos" >
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Esto creará un fichero enorme con los permisos de todos los archivos
que tienen tanto permiso de escritura para el grupo a para
todos. Verifique los permisos y elimine los permisos de escritura para
todos ejecutando <c>/bin/chmod o-w</c> en cada fichero.
</p>
</body>
</section>

<section>
<title>Ficheros SUID/SGID</title>
<body>
<p>
Los ficheros con el bit SUID o SGID habilitado permiten que sean
ejecutados con los privilegios del usuario o grupo <e>propietario</e>
y no del usuario que ejecuta el archivo. Normalmente esos bits son
usados en archivos que necesitan ejecutarse como root para hacer su
labor. Esos archivos pueden provocar un compromiso de root (si
contienen agujeros de seguridad). Los ficheros con el bit SUID o SGID
activado resultan peligrosos y deberían ser evitados a toda costa.  Si
usted no usa estos ficheros utilice en ellos <c>chmod 0</c> o
desinstale (unmerge) el paquete de los que provienen (verifique a qué
paquete pertenecen usando <c>qpkg -f</c>, si todavía no lo tiene
instalado simplemente escriba <c>emerge gentoolkit</c>). En cualquier
caso, basta desactivar el bit SUID con <c>chmod -s</c>.
</p>

<pre caption="Buscando ficheros setuid" >
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Esto creará un archivo conteniendo la lista de los ficheros
SUID/SGID.
</p>

<pre caption="Listado de los binarios setuid" >
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Por defecto, Gentoo Linux no tiene muchos ficheros SUID (depende de lo
que haya instalado), pero usted debería obtener una lista similar a la
anterior. Muchos de los comandos no deben ser utilizados por los
usuarios normales, sólo por root. Desactive el bit SUID en
<c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>,
<c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> y <c>traceroute</c>
usando <c>chmod -s</c> en cada fichero. No desactive el bit en
<c>su</c>, <c>qmail-queue</c> o <c>unix_chkpwd</c>. El desactivarlo le
impedirá hacer 'su' y recibir correo. Desactivando el bit usted
elimina la posibilidad de que un usuario normal (o un atacante)
consiga acceso de root a través de estos archivos.
</p>

<p>
Los únicos ficheros SUID que tengo en mi sistema són <c>su</c>,
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c>
y <c>pwdb_chkpwd</c>. Pero si usted está ejecutando X, necesita tener
alguno más, puesto que X necesita dicho acceso.
</p>
</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>
<p>
PAM es un conjunto de librerías compartidas que proporcionan una forma
alternativa para la autentificación en los programas. El parámetro USE
<c>pam</c> está activado por defecto. Los parámetros de PAM en Gentoo
Linux son bastante razonables, pero siempre se puede mejorar. Primero
instale cracklib.
</p>

<pre caption="Instalación de cracklib" >
# <i>emerge cracklib</i>
</pre>
<p/>
<pre caption="/etc/pam.d/passwd" >
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Esto añadirá cracklib lo cual obligará a los usuarios a que utilicen
una contraseña con un mínimo de 8 caracteres y que contenga como
mínimo 2 números, 2 caracteres de otro tipo y que hayan al menos 3
caracteres distintos respecto a la última contraseña. Lo que fuerza al
usuario a elegir una buena contraseña (política de
contraseñas). Revise la documentación de <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3"
>PAM</uri> para más opciones.
</p>

<pre caption="/etc/pam.d/sshd" >
auth	 required pam_unix.so nullok
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Cada servicio no configurado con un fichero PAM en
<path>/etc/pam.d</path> utilizará las reglas de
<path>/etc/pam.d/other</path>. Los parámetros por defecto establecen
<c>deny</c>, como deberían hacer. Pero me gusta tener muchos logs y
esto es por lo que he añadido<c>pam_warn.so</c>. La última
configuración es <c>pam_limits</c> que está controlada por
<path>/etc/security/limits.conf</path>. Mire <uri
link="#doc_chap6_sect1" >/etc/security/limits.conf section</uri> para
más detalles acerca de estas opciones.
</p>

<pre caption="/etc/pam.d/other" >
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>
</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>
<p>
Es una forma de controlar el acceso a los servicios ejecutados
normalmente por inetd (del que Gentoo no dispone) pero que también
puede ser usado por xinetd y otros servicios.
</p>

<note>
El servicio debería ejecutar tcpd en los argumentos de servidor (en
xinetd). Vea el capítulo de xinetd para más información.
</note>

<p/>
<pre caption="/etc/hosts.deny" >
ALL:PARANOID
</pre>

<p/>
<pre caption="/etc/hosts.allow" >
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Como puede ver el formato es muy similar al de
<path>/etc/login.access</path>. Tcpd soporta un servicio específico y
no trabaja en el mismo apartado de seguridad. Estas configuraciones
sólo se aplican a los servicios que utilizan tcp wrappers.
</p>

<p>
También es posible ejecutar comandos cuando se accede a un servicio
(puede ser usado cuando se activa el reenvío por marcado en los
usuarios) pero no se recomienda puesto que la gente tiende a crear más
problemas de los que está tratando de resolver. Un ejemplo podría ser
cuando configura un guión para enviar un mensaje cada vez que alguien
caiga en un regla de denegación (deny rule), y entonces un atacante
lanza un ataque de denegación de servicio (DoS) que busque activar
dicha regla de denegación. Esto creará un montón de I/O y
mensajes. Por tanto ¡no lo haga! Lea <c>man 5 hosts_access</c> para
más información.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Seguridad del Kernel</title>
<section>
<title>Eliminado funcionalidad</title>
<body>
<p>
La regla básica cuando se configura el kernel es eliminar todo lo que
no se necesite. Esto creará un kernel pequeño pero también eliminará
vulnerabilidades que puedan encontrarse en drivers y otras
características.
</p>

<p>
Considere también desactivar el soporte para módulos cargables. Aunque
incluso es posible añadir módulos (root kits) sin esta característica
activada, se hace más difícil para los atacantes normales instalar
root kits sin poder hacerlo a través de módulos del kernel.
</p>
</body>
</section>

<section>
<title>/proc (parámetros del kernel)</title>
<body>
<p>
Muchos de los parámetros del kernel pueden cambiarse a través del
sistema de ficheros <path>/proc</path> o usando <c>sysctl</c>.
</p>

<p>
Para cambiar dinámicamente parámetros y variables del kernel al vuelo
se necesita tener definido el kernel <c>CONFIG_SYSCTL</c>. Lo que está
definido por defecto en un kernel 2.4 estándar.
</p>

<pre caption="Descartar los paquetes de ping" >
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>
<p>
Esto hará que el kernel simplemente ignore todos los mensajes de ping,
también conocidos como mensajes ICMP tipo 0. La razón para hacer esto
es que el paquete IP que lleva el mensaje ICMP puede contener
información distinta de la que cree. Los administradores usan ping
como una herramienta de diagnóstico y frecuentemente se quejan si no
pueden hacer ping. No hay ninguna razón para que alguien desde fuera
pueda mandar un ping. Pero a veces puede ser práctico que desde dentro
se puedan hacer pings. Entonces, lo que se haría sería deshabilitar el
ICMP tipo 0 en el cortafuegos.
</p>

<pre caption="Ignorar pings de broadcast" >
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Esto deshabilita la respuesta a broadcasts ICMP y prevendrá de ataques
'Smurf'. El ataque Smurf consiste en enviar un ICMP tipo 0 (ping) a la
dirección de broadcast de una red. Por regla general el atacante usará
una dirección de origen falseada (spoofed). Todos los ordenadores de
la red responderán al mensaje de ping y de ese modo inundarán al host
cuya dirección se ha falsificado.
</p>

<pre caption="Dehabilitar paquetes enrutados desde el origen" >
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
No acepte paquetes enrutados desde el origen. Los atacantes pueden
usar enrutamiento desde el origen para generar tráfico que pretende
ser originado dentro de su red, pero que es actualmente enrutando
hacia el origen por el camino por el que ha venido, de esta forma los
atacantes pueden comprometer su red. El enrutamiento desde el origen
es raramente utilizado para fines legítimos, por ello desactívelo.
</p>

<pre caption="Deshabilitar la aceptación de redirección" >
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Desactive la aceptación de redirección ICMP. La redirección ICMP puede
ser usada para alterar sus tablas de enrutamiento, posiblemente para
una mala finalidad.
</p>

<pre caption="Protección contra mensajes de error falsos" >
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Habilite la protección contra respuestas de mensajes de error falsos.
</p>

<pre caption="Activar el filtrado inverso de paths" >
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo &quot;1&quot; > $i/rp_filter
done</i>
</pre>

<p/>
<note>
Si activa IP forwarding, obtendrá el mismo resultado.
</note>

<p>
Active el filtrado inverso para trayectorias. Esto ayuda a estar
seguros que los paquetes usan una dirección de orígen legítima,
rechazando automáticamente los paquetes entrantes si la entrada
correspondiente a la dirección origen en la tabla de enrutamiento no
coincide con la interfaz de red por la que llegan. Lo cual tiene
ventajas de seguridad porque previene el falseamiento de IP (IP
spoofing).
</p>

<warn>
No obstante, activar el filtrado inverso de paths puede ser un
problema si usted utiliza el enrutamiento asimétrico (los paquetes que
usted envía a un host toman un camino diferente que los paquetes que
le envía a usted ese host) o si opera en un host que no enruta y que
tiene varias direcciones IP en distintas interfaces.
</warn>

<p/>
<pre caption="Registre todos los paquetes falsificados (spoofed), enrutados en el origen y paquetes de redirección" >
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Registre todos los paquetes falsificados (spoofed), enrutados en el
origen y paquetes de redirección.
</p>

<pre caption="Desactive IP forwarding" >
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Asegúrese que IP forwarding está deshabilitado. Sólo lo necesitaremos
en máquinas con más de un interfaz de red.
</p>

<p>
Todos estos ajustes se perderán cuando la máquina se reinicie. Por
ello le sugiero que los añada a <path>/etc/sysctl.conf</path> el cual
es automáticamente inicializado por el guión de
inicio<path>/etc/init.d/bootmisc</path>.
</p>

<p>
La sintaxis para <path>/etc/sysctl.conf</path> es bastante
simple. Elimine el <path>/proc/sys/</path> de los paths anteriormente
mencionados y sustituya <path>/</path> por <path>.</path>:
</p>

<pre caption="Trasladando a sysctl.conf" >
<comment>(Uso manual de echo):</comment>
/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/ip_forward

<comment>(Automático en sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>
<p>
El parche de <uri link="http://grsecurity.net" >Grsecurity</uri> es un
estándar en las fuentes del kernel de Gentoo pero está deshabilitado
por defecto. Configure su kernel como lo hace normalmente y luego
configure las opciones de Grsecurity. Una explicación en profundidad
de las opciones disponibles en Grsecurity (versión 1.9) está
disponible en la página del proyecto <uri link="/proj/en/hardened"
>Gentoo Hardened</uri>.
</p>

<p>
Las recientes <c>grsec-sources</c> proporcionan la versión 2.* de
Grsecurity. Para más información de este parche de Grsecurity
mejorado, por favor consulte la documentación disponible en <uri
link="http://www.grsecurity.net/" >Grsecurity homepage</uri>.
</p>
</body>
</section>

<section>
<title>Kerneli</title>
<body>
<p>
<uri link="http://www.Kerneli.org" >Kerneli</uri> es un parche que
añade cifrado al kernel existente. Parcheando el kernel conseguiremos
nuevas opciones como: cifradores criptográficos, algoritmos digest y
bucles de filtros criptográficos.
</p>

<warn>
Actualmente el parche kerneli no es una versión estable en el último
kernel, por tanto tenga cuidado cuando lo use.
</warn>
</body>
</section>

<section>
<title>Otros parches para el kernel</title>
<body>
<ul>
<li>
<uri link="http://www.openwall.com" >El proyecto OpenWall</uri>
</li>
<li>
<uri link="http://www.lids.org" >Sistema de detección de intrusos en Linux</uri>
</li>
<li>
<uri link="http://www.rsbac.org" >Conjunto de reglas de control de acceso</uri>
</li>
<li>
<uri link="http://www.nsa.gov/selinux" >Mejoras de seguridad en el kernel de la NSA (agencia de seguridad estadounidense)</uri>
</li>
<li>
<uri link="http://sourceforge.net/projects/wolk/" >Wolk</uri>
</li>
</ul>

<p>
Y probablemente haya bastantes más.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Asegurando los servicios</title>
<section>
<title>Apache</title>
<body>
<p>
Apache (1.3.26) viene con un más que decente fichero de configuración
pero todavía necesitamos mejorar algunas cosas, como el enlace (bind)
a una dirección y prevenir fugas de información. Debería aplicar las
siguientes opciones en el fichero de configuración:
</p>

<p>
Si usted no deshabilita <c>ssl</c> en su <path>/etc/make.conf</path>
antes de instalar apache, debería tener habilitado el acceso al
servidor mediante ssl. Sólo tiene que añadir la siguiente línea para
activarlo:
</p>

<pre caption="/etc/conf.d/apache" >
HTTPD_OPTS=&quot;-D SSL&quot;
</pre>

<p/>
<pre caption="/etc/apache/conf/apache.conf" >
#Indica si escucha en su ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#No es una buena idea usar nobody o nogroup
#en cualquier servicio que no corra como root
#(basta añadir el usuario apache con el grupo apache)
User apache
Group apache
#Le indica a apache que no revele la versión
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache está compilado con <c>--enable-shared=max</c> y
<c>--enable-module=all</c>. Esto activará por defecto todos los
módulos, así que puede &quot;comentar&quot; todos los módulos en la
sección<c>LoadModule</c> (<c>LoadModule</c> y <c>AddModule</c>) que no
use. Reinicie el servicio ejecutando <c>/etc/init.d/apache
restart</c>.
</p>

<p>
Puede encontrar más información en <uri>http://www.apache.org</uri>.
</p>
</body>
</section>

<section>
<title>Bind</title>
<body>
<p>
Puede encontrar información en <uri
link="http://www.isc.org/products/BIND/bind9.html" >Internet Software
Consortium</uri>, el Manual de referencia del administrador en BIND 9
lo puede encontrar también en <path>doc/arm</path>.
</p>

<p>
Los nuevos &quot;ebuilds&quot; de BIND soportan el chrooting fuera del
entorno. Después de instalar (emerge) <c>bind</c> siga estos sencillos
pasos:
</p>

<pre caption="Chrooting BIND" >
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`&quot;
<codenote>Antes de ejecutar el comando anterior debe tratar de cambiar</codenote>
<codenote>el directorio de chroot en /etc/conf.d/named.</codenote>
<codenote>En caso contrario será usado /chroot/dns.</codenote>
<codenote>Puede necesitar sustituir el número de versión por el número de versión actual.</codenote>
</pre>
</body>
</section>

<section>
<title>Djbdns</title>
<body>
<p>
Djbdns es una implementación de DNS en la que su autor está dispuesto
a apostar <uri link="http://cr.yp.to/djbdns/guarantee.html"
>dinero</uri> en cuan segura es. Trabaja de forma muy diferente a Bind
9 pero vale la pena probarlo. Puede obtener más información en
<uri>http://www.djbdns.org</uri>.
</p>
</body>
</section>

<section>
<title>FTP</title>
<body>
<p>
Generalmente, usar FTP (File Transfer Protocol) es una mala
idea. Porque no cifra los datos, escucha en dos puertos (normalmente
el 20 y el 21), y permite accesos anónimos lo que hace que los
atacantes lo busquen (para intercambiar warez). Puesto que protocolo
FTP tiene varios problemas de seguridad, más bien debería utilizar en
su lugar <c>sftp</c> o HTTP . Si no lo hace, asegure tan bien como
pueda sus servicios y prepárese.
</p>
</body>
</section>

<section>
<title>Mysql</title>
<body>
<p>
Si sólo necesita que las aplicaciones locales accedan a la base de
datos <c>mysql</c> &quot;descomente&quot; la siguiente línea en
<path>/etc/mysql/my.cnf</path>.
</p>

<pre caption="Deshabilitar el acceso de red" >
skip-networking
</pre>

<p>
Deshabilite el comando <c>LOAD DATA LOCAL INFILE</c> en el mismo
fichero.
</p>

<pre caption="Deshabilitar LOAD DATA LOCAL INFILE en la sección [mysqld]" >
set-variable=local-infile=0
</pre>

<p>
La instalación por defecto de <c>mysql</c> viene sin contraseña para
<c>root</c>.
</p>

<pre caption="Establecer la contraseña de root" >
<i>/usr/local/mysql/bin/mysql -u root</i> 
mysql> <i>SET PASSWORD FOR root@localhost=PASSWORD('nueva_contraseña');</i>
</pre>

<note>
Es un buen hábito no cambiar contraseñas desde la línea de comandos,
por ejemplo, usando el comando <c>mysqladmin password</c>. Lo que es
especialmente importante cuando otros usuarios trabajan en el
servidor. Es este caso, la contraseña puede ser fácilmente hallada,
por ej. usando el comando <c>ps aux</c> o revisando los archivos de
historial (<path>~/.history</path>, <path>~/.bash_history</path>
etc.), cuando se les han asignado derechos de acceso equivocados.
</note>

<p>
A continuación, vamos a borrar la base de datos de ejemplo (test) y
todas las cuentas excepto la cuenta local de <c>root</c>.
</p>

<pre caption="Borrando la base de datos de ejemplo y todos los usuarios innecesarios" >
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host=&quot;localhost&quot; and user=&quot;root&quot;);</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Tenga cuidado con lo anterior si usted previamente ya ha configurado
cuentas de usuario.
</warn>
</body>
</section>

<section>
<title>Proftpd</title>
<body>
<p>
Proftpd ha tenido bastantes problemas de seguridad, pero parece que se
han resuelto muchos de ellos. Todavía puede aplicar algunas mejoras:
</p>

<pre caption="/etc/proftpd/proftpd.conf" >
ServerName &quot;My ftp daemon&quot;
# No muestre la identidad del servidor
ServerIdent on &quot;Go away&quot;

# Hace más fácil crear usuarios virtuales
RequireValidShell off

# Use unos ficheros de contraseñas y grupos alternativos (passwd usa cifrado)
AuthUserFile &quot;/etc/proftpd/passwd&quot;
AuthGroupFile &quot;/etc/proftpd/group&quot;

# Permisos
Umask 077

# Timeouts y limitaciones
MaxInstances 30
MaxClients 10 &quot;Only 10 connections allowed&quot;
MaxClientsPerHost 1 &quot;You have already logged on once&quot;
MaxClientsPerUser 1 &quot;You have already logged on once&quot;
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# Chroot todo el mundo
DefaultRoot ~

# No lo ejecute como root
User  nobody
Group nogroup

# Registre cada transacción
TransferLog /var/log/transferlog

# Problemas con globbing
DenyFilter \*.*/
</pre>

<p>
Puede encontrar más documentación en
<uri>http://www.proftpd.org</uri>.
</p>
</body>
</section>

<section>
<title>Pure-ftpd</title>
<body>
<p>
Pure-ftpd es una variante del trollftpd original. Modificado por Frank
Dennis por razones de seguridad y funcionalidad.
</p>

<p>
Utilice usuarios virtuales (nunca cuentas del sistema) habilitando la
opción <c>AUTH</c>. Ajústela a <c>-lpuredb:/etc/pureftpd.pdb</c> y
cree sus usuarios mediante <c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd" >
AUTH=&quot;-lpuredb:/etc/pureftpd.pdb&quot;

## Misc. Others ##
MISC_OTHER=&quot;-A -E -X -U 177:077 -d -4 -L100:5 -I 15&quot;
</pre>

<p>
Y configure la opción <c>MISC_OTHER</c> para que no permita accesos
anónimos (<c>-E</c>), no haga chroot todo el mundo (<c>-A</c>), para
que los usuarios no puedan leer o escribir en los archivos que
empiezan por . (punto) (<c>-X</c>), el tiempo máximo 'idle'
(<c>-I</c>), el límite de recursión (<c>-L</c>), y una razonable
<c>umask</c>.
</p>

<warn>
¡<e>No</e> use las opciones <c>-w</c> or <c>-W</c>! Si usted quiere
tener un sitio de warez, ¡no lea más esta guía!
</warn>

<p>
Puede encontrar más documentación en
<uri>http://www.pureftpd.org</uri>.
</p>
</body>
</section>

<section>
<title>Qmail</title>
<body>
<p>
Qmail está considerado como el servidor de correo más seguro. Está
escrito pensando en la seguridad (y en la paranoia). Por defecto no
permite el reenvío y no ha tenido un sólo agujero de seguridad desde
1.996. ¡Simplemente instálelo con <c>emerge qmail</c> y configúrelo!
</p>
</body>
</section>

<section>
<title>Samba</title>
<body>
<p>
Samba es un protocolo para compartir ficheros con redes Microsoft y
Novell y <e>no</e> debería usarse a través de Internet. Pero sin
embargo necesita ser asegurado.
</p>

<pre caption="/etc/samba/smb.conf" >
[global]
  #Enlace a una interface
  interfaces = eth0 10.0.0.1/32

  #Indica el uso de contraseñas cifradas
  encrypt passwords = yes
  directory security mask = 0700

  #Permite el tráfico desde 10.0.0.*
  hosts allow = 10.0.0.

  #Habilita el modo de autentificación por usuario
  #(no use el modo compartido)
  security = user

  #Deshabilita las cuentas con privilegios
  invalid users = root @wheel

  #Tamaño máximo que smb muestra para un recurso compartido
  #(no es un límite)
  max disk size = 102400

  #Política de contraseñas
  min password length = 8
  null passwords = no

  #Uso de PAM (si se ha añadido su soporte)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Asegúrese que los permisos están correctamente establecidos en cada
recurso compartido y recuerde leer la <uri link="http://www.samba.org"
>documentación</uri>.
</p>

<p>
Ahora reinicie el servidor y añada los usuarios que deban tener acceso
a este servicio. Esto se hace mediante <path>/usr/bin/smbpasswd</path>
con el parámetro -a.
</p>
</body>
</section>

<section>
<title>ssh</title>
<body>
<p>
La única seguridad que OpenSSH necesita es habilitar la
autentificación fuerte basada en cifrado de clave pública. Demasiados
sitios (como <uri>http://www.sourceforge.net</uri>,
<uri>http://www.php.net</uri> y<uri>http://www.apache.org</uri>) han
sufrido accesos no autorizados debidos a filtraciones de contraseñas o
a malas contraseñas.
</p>

<pre caption="/etc/ssh/sshd_config" >
#Sólo habilitar la versión 2
Protocol 2

#No permitir el acceso directo a root
PermitRootLogin no

#Habilitar la autentificación de clave pública
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Deshabilitar los ficheros .rhost y la autentificación normal con contraseña
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Sólo los usuarios en los grupos wheel o admin pueden obtener acceso
AllowGroups wheel admin

#De todos los usuarios de esos grupos sólo kn y bs tendrán acceso
AllowUsers kn bs

#Añadir registro de actividad
SyslogFacility AUTH
LogLevel INFO

#Enlace
ListenAddress 127.0.0.1
</pre>

<p>
Ahora todo lo que sus usuarios tienen que hacer es crear una clave (en
el ordenador desde el que se van a conectar) usando el comando
siguiente:
</p>

<pre caption="Crea un par de claves DSA" >
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Y teclear una frase de paso (passphrase)
</p>

<pre caption="Salida de ssh-keygen" >
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Pulse enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Escriba la frase de paso]</i>
Enter same passphrase again: <i>[Vuelva a escribir la frase de paso]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Esto añadirá dos archivos a su directorio <path>~/.ssh/</path>,
llamados <path>id_dsa</path> y <path>id_dsa.pub</path>. El archivo
<path>id_dsa</path> es su clave privada y debe ser accesible sólo por
usted. El otro fichero <path>id_dsa.pub</path> debe ser distribuido en
cada servidor al cual tenga acceso. Añada la clave en el directorio
home del usuario en <path>~/.ssh/authorized_keys</path> y el usuario
debería ser capaz de hacer login.
</p>

<p>
Ahora, sus usuarios deberían salvaguardar su clave privada
convenientemente. Poniéndola en un dispositivo que ellos lleven
siempre encima o dejarla en su estación de trabajo (añada esto a las
políticas de <uri link="#doc_chap2_sect5" >Contraseñas</uri>).
</p>

<p>
Para más información visite la página web de <uri
link="http://www.openssh.org" >OpenSSH</uri>.
</p>
</body>
</section>

<section>
<title>Uso de xinetd</title>
<body>
<p>
xinetd es un sustituto de inetd (Gentoo no dispone de él), el demonio
de servicios de Internet. Soporta control de acceso basado en la
dirección del host remoto y el tiempo de acceso. También proporciona
extensas posibilidades de log, incluyendo una hora de arranque del
servidor, dirección de host remoto, nombre de usuario remoto, tiempo
de ejecución del servidor, y acciones solicitadas.
</p>

<p>
Como en todos los demás servicios es importante tener una buena
configuración por defecto. Pero desde el momento que <c>xinetd</c> se
ejecuta como root y soporta protocolos que puede que usted no conozca
como funcionan, le recomendamos que no lo utilice. Pero si a pesar de
todo lo quiere utilizar, aquí le explicamos como puede añadirle algo
de seguridad:
</p>

<pre caption="Instale xinetd" >
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Y edite el fichero de configuración:
</p>

<pre caption="/etc/xinetd.conf" >
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Esto configurará pserver (cvs) via xinetd con los siguientes parámetros:
# un máximo de 10 instancias (10 conexiones simultáneas)
# limita pserver a conexiones tcp solamente
# utiliza el usuario cvs para ejecutar este servicio
# enlaza una sola dirección IP en las interfaces de red
# permite el acceso desde 10.0.0.*
# limita el tiempo que los desarrolladores pueden usar cvs: desde 8am a 5pm
# usa tcpd wrappers (control de acceso especificado en 
# <i>/etc/hosts.allow</i> y <i>/etc/hosts.deny</i>)
# la carga máxima del sistema se establece a 1.0
# el disable flag está a no por defecto, pero preferimos tenerlo
# en caso de querer desactivarlo
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Para más información consulte <c>man 5 xinetd.conf</c>.
</p>
</body>
</section>

<section>
<title>Vsftpd</title>
<body>
<p>
Vsftpd (siglas de &quot;very secure ftp&quot;, ftp realmente seguro)
es un pequeño demonio ftp que se ejecuta con una razonable
configuración por defecto. Es sencillo y no tiene algunas de las
características (como usuarios virtuales) de pureftp o proftp.
</p>

<pre caption="/etc/vsftpd" >
anonymous_enable=NO
local_enable=YES

#sólo escritura
write_enable=NO

#permite el registro de transacciones
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Como puede ver no hay forma en este servicio de tener permisos
individuales y no hay una acción chroot por defecto. Pero cuando se
prepara con una configuración para un usuario anónimo es bastante
bueno. Algunas veces es bueno tener un ftp anónimo (para compartir
programas de código abierto) y entonces vsftpd hace muy buen papel.
</p>
</body>
</section>

<section>
<title>X</title>
<body>
<p>
Por defecto XFree está configurado para actuar como un servidor
X. Esto puede resultar peligroso puesto que X usa conexiones TCP no
cifradas y está a la escucha para clientes X.
</p>

<impo>
Si usted no necesita este servicio, ¡deshabilítelo!
</impo>

<p>
Pero si piensa usar su estación de trabajo como servidor X use el
comando <c>/usr/X11R6/bin/xhost</c> con precaución. Este comando
permite a clientes desde otros hosts conectarse y usar su pantalla. Lo
que puede ser práctico si usted necesita una aplicación X de un equipo
diferente y la única manera de utilizarla es a través de la red. La
sintaxis es <c>/usr/X11R6/bin/xhost +nombre_de_host</c>
</p>

<warn>
¡No use nunca la opción <c>xhost +</c>! Esto permitirá a cualquier
cliente conectarse y tomar el control de sus X. Si un atacante puede
tener acceso a sus X, puede registrar lo que teclee y tomar el control
de su escritorio. Recuerde especificar siempre un host, si usted debe
utilizarlo.
</warn>

<p>
Un solución más segura es deshabilitar completamente esta
característica arrancando X con <c>startx -- -nolisten tcp</c> o
deshabilitándola permanentemente en la configuración.
</p>

<pre caption="/usr/X11R6/bin/startx" >
defaultserverargs=&quot;-nolisten tcp&quot;
</pre>

<p>
Para asegurarse de que <path>startx</path> no será sobreescrito al
'emerger' una nueva versión de XFree debe protegerlo. Añada la
siguiente línea a <path>/etc/make.conf</path>:
</p>

<pre caption="/etc/make.conf" >
CONFIG_PROTECT_MASK=&quot;/usr/X11R6/bin/startx&quot;
</pre>

<p>
Si usted usa un gestor gráfico de login necesitará cambiar otros
archivos.
</p>

<p>
Para <c>gdm</c> (Gnome Display Manager):
</p>

<pre caption="/etc/X11/gdm/gdm.conf" >
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Para <c>xdm</c> (X Display Manager) y <c>kdm</c> (Kde Display
Manager):
</p>

<pre caption="/etc/X11/xdm/Xservers" >
:0 local /usr/bin/X11/X -nolisten tcp
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Chroot o servidores virtuales</title>
<section>
<title>Chrooting</title>
<body>
<p>
Hacer chroot a un servicio es la manera de limitar el entorno de un
servicio (o usuario) para que acceda sólo a lo que debería y para que
no escale acceso (o consiga información) que le permita un acceso de
root. Ejecutando el servicio como un usuario distinto de <c>root</c>
(<c>nobody</c>, <c>apache</c>, <c>named</c>) un atacante sólo podrá
acceder a los ficheros con permisos para dicho usuario. Lo que
significa que un atacante no conseguirá el acceso de root incluso si
los servicios tuvieran algún defecto de seguridad.
</p>

<p>
Algunos servicios como <c>pure-ftpd</c> y <c>bind</c> tienen
características para hacer chroot, pero otros no. Si el servicio lo
soporta, úselo, si no usted tiene que saber como crearse el suyo
propio. Veamos como crear un chroot. Para una comprensión elemental de
como trabaja un chroot, vamos a probarlo con <c>bash</c> (la manera
fácil de aprenderlo)
</p>

<p>
Cree el directorio <path>/chroot</path> (<c>mkdir chroot</c>). Y
averigüe con qué librerías dinámicas está compilado <c>bash</c> (este
paso no es necesario si está compilado con <c>-static</c>).
</p>

<p>
El siguiente comando creará una lista con las librerías usadas por
bash.
</p>

<pre caption="Obtener la lista de librerías usadas" >
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Ahora creemos el entorno para bash.
</p>

<pre caption="Crear el entorno chroot para bash" >
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Luego copie los ficheros usados por <c>bash</c> (<path>/lib</path>) al
directorio <path>lib</path> del chroot y copie también el comando bash
al directorio <path>bin</path> del chroot. Esto creará exactamente el
mismo entorno, pero con menos funcionalidad. Después de copiarlo
pruébelo:<c>chroot /chroot/bash</c>. Si obtiene un prompt indicado
<path>/</path> ¡funciona! En caso contrario le informará adecuadamente
de qué fichero falta. Algunas librerías compartidas dependen unas de
otras.
</p>

<p>
Se dará cuenta que dentro del chroot sólo funciona <c>echo</c>. Esto
ocurre porque no tenemos otros comandos dentro del entorno chroot que
no sean bash y <c>echo</c> que es una funcionalidad incorporada.
</p>

<p>
Esta es básicamente la manera en la que usted podría crear un servicio
ejecutado con chroot. La única diferencia es que los servicios a veces
depende de servicios y ficheros de configuración en
<path>/etc</path>. Simplemente cópielos (los dispositivos pueden
copiarse con <c>cp -a</c>) en el entorno de chroot, edite el guión de
inicio init para que use chroot antes de ejecutarlo. Puede resultar difícil
encontrar qué dispositivos y ficheros de configuración necesita un
servicio. Para esto es práctico el comando <c>strace</c>. Inicie el
servicio en bash con <c>/usr/bin/strace</c> y busque los open, read,
stat y puede que connect. Lo que le dará una pista de qué ficheros
copiar. Pero en muchos casos basta copiar el fichero de contraseñas
(passwd) (edite la copia y borre los usuarios que no tienen nada que
ver con el servicio), <path>/dev/zero</path>, <path>/dev/log</path> y
<path>/dev/random</path>.
</p>
</body>
</section>

<section>
<title>Virtual servers</title>
<body>
<p>
Otra forma de crear un entorno más seguro es usando un entorno de
servidor virtual. Esto creará una copia del Linux existente y
arranques en modo virtual. Lo que significa que si el servidor se ve
comprometido únicamente el servidor virtual habrá resultado
comprometido y no la instalación real.
</p>

<p>
Ejemplo de servidores virtuales::
</p>

<ul>
<li>
<uri link="http://user-mode-linux.sourceforge.net" >User-Mode Linux</uri> y un 'howto' al respecto <uri link="http://www.gentoo.org/doc/uml.html" >User-Mode Linux</uri>.
</li>
</ul>
</body>
</section>
</chapter>

<chapter>
<title>Cortafuegos</title>
<section>
<title>Acerca de los cortafuegos</title>
<body>
<p>
Mucha gente piensa a menudo que un cortafuegos (firewall) es la máxima
expresión de la seguridad, pero están equivocados. En muchos casos un
cortafuegos mal configurado da peor seguridad que no teniendo uno
instalado. Un cortafuegos también es un componente de software y
debería tratarse de la misma manera que cualquier otro software,
porque puede contener agujeros de seguridad.
</p>

<p>
¡Así que piénselo antes de implementar uno! ¿Realmente lo necesita? Si
cree que lo necesita, escriba una política sobre cómo debería
funcionar. Pero primero lea esta guía.
</p>

<p>
Los cortafuegos se usan con dos propósitos:
</p>

<ul>
<li>Para mantener a los usuarios (gusanos/atacantes) fuera</li>
<li>Para mantener a los usuarios (empleados/niños) dentro</li>
</ul>

<p>
Básicamente hay tres tipos de cortafuegos:
</p>

<ul>
<li>Filtrado de paquetes</li>
<li>Circuit relay</li>
<li>Aplicación de puerta de enlace</li>
</ul>

<p>
Un cortafuegos debe ser una máquina dedicada que no ejecute otros
servicios (<c>sshd</c> es el único) y asegurada tal como recomienda
esta guía.
</p>
</body>
</section>

<section>
<title>Filtrado de paquetes</title>
<body>
<p>
Todo el tráfico de la red se transmite con paquetes. Grandes
cantidades de tráfico también se dividen en paquetes pequeños para un
mejor manejo y se juntan cuando llegan al destino. La cabecera de cada
paquete contiene la información de cómo y dónde debe ser entregado. Y
esas informaciones son exactamente las que un cortafuegos de filtrado
de paquetes utiliza. El filtrado se basa en:
</p>

<ul>
<li>Permitir o denegar los paquetes basados en la dirección IP origen/destino</li>
<li>Permitir o denegar los paquetes basados en un puerto de origen/destino</li>
<li>Permitir o denegar los paquetes basados en un protocolo</li>
<li>Permitir o denegar los paquetes basados en parámetros específicos del protocolo</li>
</ul>

<p>
Principalmente el filtrado está basado en la información de la
cabecera del paquete y no en su contenido.
</p>

<p>
Debilidades:
</p>

<ul>
<li>
La dirección de un paquete puede ser potencialmente falsa, o como se
suele decir <e>spoofed</e> por el remitente
</li>
<li>
Los datos o peticiones contenidos en un paquete permitido pueden
contener datos no esperados que el atacante puede usar para explotar
fallos en servicios en el cortafuegos o a través de él
</li>
<li>Normalmente es un punto único de fallo
</li>
</ul>
<p>
Ventajas:
</p>
<ul>
<li>Simple y fácil de implementar</li>
<li>Puede avisar de posibles ataques antes de que ocurran (por ejemplo
detectando sondeos de puertos)
</li>
<li>Son buenos para parar ataques SYN</li>
</ul>

<p>
Ejemplos de cortafuegos de filtrado de paquetes libres en Linux:
</p>

<ul>
<li>
<uri link="http://www.iptables.org" >Iptables</uri>
</li>
<li>
<uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html" >Ipchains</uri>
</li>
<li>
<uri link="http://www.smoothwall.org" >SmoothWall</uri>
</li>
</ul>
</body>
</section>

<section>
<title>Circuit relay</title>
<body>
<p>
O circuitos de nivel de puerta de enlace, es un cortafuegos que valida
las conexiones antes de permitir el intercambio de datos. Esto
significa que simplemente no permite o deniega paquetes basándose en
su cabecera si no que determina si la conexión entre los dos extremos
es válida de acuerdo a las reglas configuradas antes de abrir una
sesión y permitir que los datos sean intercambiados. El filtrado está
basado en:
</p>

<ul>
<li>Dirección IP de origen/destino</li>
<li>Puerto de origen/destino</li>
<li>Periodo de tiempo</li>
<li>Protocolo</li>
<li>Usuario</li>
<li>Contraseña</li>
</ul>

<p>
Todo el tráfico es validado y monitorizado, y el tráfico no deseado se
descarta.
</p>

<p>
Debilidades:
</p>

<ul>
<li>
Opera en la Capa de Trasporte y puede requerir una modificación
sustancial en el programa que normalmente provee de las funciones de
transporte.
</li>
</ul>
</body>
</section>

<section>
<title>Aplicación de puerta de enlace</title>
<body>
<p>
El cortafuegos de aplicación de puerta de enlace es un
&quot;proxy&quot; para aplicaciones, que intercambian datos con los
sistemas remotos en nombre de sus clientes. Suele estar a salvo detrás
de una DMZ (&quot;zona desmilitarizada&quot;: la porción de una red
privada que es visible a través del cortafuegos) o de un cortafuegos
que no permite conexiones desde el exterior. El filtrado está basado
en:
</p>

<ul>
<li>Permitir o denegar basándose en direcciones IP del origen/destino</li>
<li>Basándose en el contenido del paquete</li>
<li>Limitar el acceso a ficheros basándose en su tipo o su extensión</li>
</ul>

<p>
Ventajas:
</p>

<ul>
<li>Puede hacer &quot;cache&quot; de archivos, incrementando el rendimiento de red</li>
<li>Detallado registro de todas las conexiones</li>
<li>Crece perfectamente (algunos proxys de servidores pueden
&quot;compartir&quot; los datos en cache)</li>
<li>No hay acceso directo desde el exterior</li>
<li>Pueden alterar el contenido del paquete al vuelo</li>
</ul>

<p>
Debilidades:
</p>

<ul>
<li>La configuración es compleja</li>
</ul>

<p>
Las aplicaciones de pasarela están consideradas la mejor solución
segura puesto que no tienen que ser ejecutadas como root y los hosts
internos no son accesibles desde Internet.
</p>

<p>
Ejemplo de una aplicación de pasarela libre:
</p>

<ul>
<li>
<uri link="http://www.squid-cache.org/" >Squid</uri>
</li>
</ul>
</body>
</section>

<section>
<title>Iptables</title>
<body>
<p>
Para poner en funcionamiento iptables, tiene que estar habilitado en
el kernel. Yo lo he añadido como módulo (el comando <c>iptables</c> lo
cargará como necesite) y he recompilado mi kernel. Para más
información al respecto de como configurar su kernel para iptables
vaya a <uri
link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html"
>Iptables Tutorial Chapter 2: Preparations</uri>. Después de que haya
compilado su nuevo kernel (o mientras lo compila) tiene que añadir el
comando <c>iptables</c> . Simplemente con <c>emerge iptables</c> ya
debería funcionar.
</p>

<p>
Ahora compruebe que funciona ejecutando <c>iptables -L</c>. Si falla,
algo está mal y deberá revisar su configuración una vez más.
</p>

<p>
Iptables es el nuevo y fuertemente mejorado filtro de paquetes en el
kernel de Linux 2.4.x. Es el sucesor del anterior filtro de paquetes
ipchains del kernel de linux 2.2.x. Una de las más grandes mejoras es
que iptables es capaz de realizar filtrado de estado de paquetes. Con
el filtrado de estado es posible mantener el registro de cada conexión
TCP establecida.
</p>

<p>
Una conexión TCP consiste en una serie de paquetes que contienen
información respecto la dirección IP origen, la IP de destino y un
número de secuencia para que los paquetes puedan juntarse y no perder
datos. TCP es un protocolo orientado a la conexión en contraste a UDP
que es &quot;sin conexión&quot;.
</p>

<p>
Examinando la cabecera del paquete TCP un filtro de estado de paquetes
puede determinar si un paquete TCP recibido es parte de una conexión
ya establecida o no y decidir si aceptarlo o rechazarlo.
</p>

<p>
A un filtro de paquetes que no verifique el estado de los mismos es
posible engañarlo para que acepte paquetes que deberían ser desechados
manipulando la cabecera del paquete TCP. Esto puede hacerse alterando
el flag SYN u otros flags en la cabecera TCP. Con un cortafuegos que
verifique el estado de los paquetes es posible descartar aquellos
paquetes que no forman parte de una conexión ya establecida. Esto
parará también la posibilidad de &quot;escaneos pasivos&quot; puesto
que sus paquetes no serán parte de una conexión previamente
establecida.
</p>

<p>
Iptables proporciona otras prestaciones como NAT (Network Address
Translation) y limitación de tasas. La limitación de tasas es muy
práctica para prevenir ciertos ataques DoS (&quot;Denial of
Service&quot;, denegación de servicio) como las inundaciones SYN
(&quot;SYN floods&quot;)
</p>

<p>
Una conexión TCP se establece con una &quot;conversación en tres
fases&quot;. Para iniciar la conexión TCP la parte de cliente envía un
paquete al servidor con el flag SYN habilitado. Cuando el servidor
recibe el paquete con el SYN responde enviando un paquete SYN+ACK de
vuelta al cliente. Entonces el SYN+ACK es recibido en el cliente que
responde con un tercer paquete ACK reconociendo la conexión.
</p>

<p>
Un ataque de inundación SYN se realiza enviando paquetes SYN de forma
que no se responda el correspondiente paquete SYN+ACK. El cliente
puede crear un paquete con una dirección IP origen falsa puesto que no
necesita la respuesta. El sistema del servidor añadirá una entrada en
la cola de las conexiones pendientes de establecer cuando se reciba el
paquete SYN y esperará a recibir el paquete final ACK antes de borrar
esta entrada de la cola. La cola tiene un número limitado de
posiciones (slots) y si todas estas posiciones están ocupadas no podrá
abrir nuevas conexiones. Si el paquete ACK no se recibe antes de un
tiempo determinado la entrada se borrará automáticamente de la
cola. Este tiempo de espera es variable, pero normalmente es de 30 a
60 segundos o incluso más.  La parte de cliente inicia el ataque
enviando gran número de paquetes SYN con diferentes IP origen y
enviándolos a la IP objetivo todo lo rápido que pueda y de ese modo
llenará la cola de las conexiones pendientes de establecer y por tanto
impedirá que otros clientes establezcan una conexión legítima con el
servidor.
</p>

<p>
Aquí es donde la limitación de tasas se vuelve útil. Es posible
limitar la tasa de paquetes SYN aceptados usando <c>-m limit --limit
1/s</c>. Esto limitará el número de paquetes SYN aceptados a uno por
segundo y por tanto evitará el riesgo de inundaciones SYN en nuestros
equipos.
</p>

<p>
¡Ahora algunas prácticas!
</p>

<p>
Cuando iptables se activa en el kernel proporciona 5 lugares donde
especificar las reglas. Estos lugares se llaman <c>INPUT</c>,
<c>OUTPUT</c>, <c>FORWARD</c>, <c>PREROUTING</c> y
<c>POSTROUTING</c>. Cada uno de ellos es a su vez una cadena que
consiste en una serie de reglas. Cada regla especifica una cabecera de
paquete con la que compararse, después indica qué hacer con el
paquete. Si la regla no coincide con el paquete se consulta la
siguiente regla en la cadena.
</p>

<p>
Usted puede añadir reglas directamente en estas 5 cadenas principales
o crear nuevas cadenas y añadirlas como si fueran reglas a una cadena
existente. Iptables admite las siguientes opciones.
</p>

<table>
<tr>
<th>Opción:</th>
<th>Descripción:</th>
</tr>
<tr>
<ti>-A</ti>
<ti>Añadir</ti>
</tr>
<tr>
<ti>-D</ti>
<ti>Borrar</ti>
</tr>
<tr>
<ti>-I</ti>
<ti>Insertar</ti>
</tr>
<tr>
<ti>-R</ti>
<ti>Reemplazar</ti>
</tr>
<tr>
<ti>-L</ti>
<ti>Listar</ti>
</tr>
<tr>
<ti>-F</ti>
<ti>Borra todas las reglas de una o de todas las cadenas</ti>
</tr>
<tr>
<ti>-Z</ti>
<ti>Pone a cero los contadores en una o en todas las cadenas</ti>
</tr>
<tr>
<ti>-C</ti>
<ti>Verifica ese paquete en la cadena</ti>
</tr>
<tr>
<ti>-N</ti>
<ti>Crea una nueva cadena definida por el usuario</ti>
</tr>
<tr>
<ti>-X</ti>
<ti>Borra una cadena definida por el usuario</ti>
</tr>
<tr>
<ti>-P</ti>
<ti>Cambia la forma de actuar de una cadena respecto un objetivo</ti>
</tr>
<tr>
<ti>-E</ti>
<ti>Cambia el nombre de la cadena</ti>
</tr>
<tr>
<ti>-p</ti>
<ti>Protocolo</ti>
</tr>
<tr>
<ti>-s</ti>
<ti>Dirección o máscara de origen</ti>
</tr>
<tr>
<ti>-d</ti>
<ti>Dirección o máscara de destino</ti>
</tr>
<tr>
<ti>-i</ti>
<ti>Nombre de entrada (nombre ethernet)</ti>
</tr>
<tr>
<ti>-o</ti>
<ti>Nombre de salida (nombre ethernet)</ti>
</tr>
<tr>
<ti>-j</ti>
<ti>Salto (objetivo de la regla)</ti>
</tr>
<tr>
<ti>-m</ti>
<ti>Coincidencia extendida (puede usar una extensión)</ti>
</tr>
<tr>
<ti>-n</ti>
<ti>Salida numérica para las direcciones y puertos</ti>
</tr>
<tr>
<ti>-t</ti>
<ti>Tabla a manipular</ti>
</tr>
<tr>
<ti>-v</ti>
<ti>Modo de información detallada</ti>
</tr>
<tr>
<ti>-x</ti>
<ti>Expande los números (muestra valores exactos)</ti>
</tr>
<tr>
<ti>-f</ti>
<ti>Sólo hacer coincidir el segundo fragmento o posteriores</ti>
</tr>
<tr>
<ti>-V</ti>
<ti>Versión de paquete</ti>
</tr>
<tr>
<ti>--line-numbers</ti>
<ti>Muestra los números de línea al listar</ti>
</tr>
</table>

<p>
Primero trataremos de bloquear todos los paquetes ICMP en nuestra
máquina, sólo para familiarizarnos con iptables.
</p>

<pre caption="Bloquear todos los paquetes ICMP" >
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Primero indicamos la cadena donde debe ser añadida, después el
protocolo y después el objetivo. El objetivo puede ser el nombre de
una cadena definida por el usuario o uno de los siguientes
<c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c>,
<c>MASQUERADE</c>. En este ejemplo usamos <c>DROP</c> que desechará el
paquete sin responder al cliente.
</p>

<p>
Ahora intente <c>ping localhost</c>. No debería recibir ninguna
respuesta puesto que iptables desechará todos los paquetes ICMP
entrantes. No podrá hacer ping a otras máquinas puesto que los
paquetes ICMP de respuesta también son desechados. Ahora elimine la
cadena para permitir el tráfico ICMP de nuevo.
</p>

<pre caption="Elimina todas las reglas" >
# <i>iptables -F</i>
</pre>

<p>
Ahora veamos el filtrado de paquetes de estado en iptables. Si
buscamos tener una inspección de estado en los paquetes entrantes en
eth0, podríamos activarlo con:
</p>

<pre caption="Acepta paquetes originados en una conexión entrante o ya establecida" >
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Esto aceptará cualquier paquete de una conexión ya establecida o con
relación a la cadena INPUT. Usted también puede desechar cualquier
paquete que no esté en la tabla de estado indicando <c>iptables -A
INPUT -i eth0 -m state --state INVALID -j DROP</c> justo antes. Si
quiere permitir a otros conectarse a su máquina puede usar <c>--state
NEW</c>. Iptables contiene algunos módulos con propósitos
diversos. Algunos de ellos son:
</p>

<table>
<tr>
<th>Módulo/Concordancia</th>
<th>Descripción</th>
<th>Opciones extendidas</th>
</tr>
<tr>
<ti>mac</ti>
<ti>Comprueba la extensión para los paquetes que provienen de esa dirección mac.</ti>
<ti>--mac-source</ti>
</tr>
<tr>
<ti>state</ti>
<ti>Activa la inspección de estado</ti>
<ti>--state (los estados son ESTABLISHED,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
<ti>limit</ti>
<ti>Limitación de tasas</ti>
<ti>--limit, --limit-burst</ti>
</tr>
<tr>
<ti>owner</ti>
<ti>Intenta comparar varias características del creador de los paquetes</ti>
<ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
</ti>
</tr>
<tr>
<ti>unclean</ti>
<ti>Varios chequeos aleatorios en los paquetes</ti>
<ti/>
</tr>
</table>

<p>
Intentemos crear una cadena definida por el usuario y añadirla a una
de las ya existentes:
</p>

<pre caption="Creación de una cadena definida por el usuario" >
<codenote>Creamos una nueva cadena con una regla</codenote>
# <i>iptables -X micadena</i>
# <i>iptables -N micadena</i>
# <i>iptables -A micadena -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>El comportamiento por defecto es permitir todo el tráfico saliente. El entrante es desechado.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>Y la añadimos a la cadena INPUT</codenote>
# <i>iptables -A INPUT -j micadena</i>
</pre>

<p>
Aplicando la regla a la cadena input obtenemos la política: Se permite
todos los paquetes salientes y se desechan todos los entrantes.
</p>

<p>
Puede encontrar más documentación en <uri
link="http://www.iptables.org/documentation/index.html#HOWTO"
>Documentación sobre netfilter/iptables</uri>.
</p>

<p>
Veamos ahora un ejemplo completo. En este caso el comportamiento de mi
cortafuegos/puerta de enlace indica:
</p>

<ul>
<li>Sólo se permiten las conexiones hacia el cortafuegos a través de
SSH (puerto 22)</li>
<li>La red local debe tener acceso a HTTP, HTTPS y SSH (DNS puede
también permitirse)</li>
<li>El tráfico ICMP puede contener carga no deseada y no debe ser
permitido. Por supuesto deberemos permitir cierto tráfico ICMP</li>
<li>Los sondeos de puertos deben ser detectados y registrados</li>
<li>Los ataques SYN deben ser prevenidos</li>
<li>El tráfico restante debe ser desechado y registrado</li>
</ul>

<pre caption="/etc/init.d/firewall" >
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#interior
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#exterior
OIP=217.157.156.144
OINTERFACE=eth1

opts=&quot;${opts} showstatus panic save restore showoptions rules&quot;

depend() {
  need net
}

rules() {
  stop
  ebegin &quot;Estableciendo las reglas internas&quot;

  einfo &quot;Estableciendo la regla por defecto para drop&quot;
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # Regla por defecto
  einfo &quot;Creando las cadenas de estado&quot;
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      &quot;Bad packet from ${IINTERFACE}:&quot;
  $IPTABLES -A allowed-connection -j DROP

  # Tráfico ICMP
  einfo &quot;Creando la cadena icmp&quot;
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix &quot;Bad ICMP traffic:&quot;
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # Tráfico entrante
  einfo &quot;Creando la cadena para el tráfico ssh entrante&quot;
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Protección &quot;Flood&quot;
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  # Tráfico saliente
  einfo &quot;Creando la cadena para el tráfico ssh saliente&quot;
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo &quot;Creando la cadena para el tráfico DNS saliente&quot;
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo &quot;Creando la regla para el tráfico http/https saliente&quot;
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # Detección de scanners de puertos
  einfo &quot;Creando la cadena de detección de scanner de puertos&quot;
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix &quot;NMAP-XMAS:&quot; 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix &quot;XMAS:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix &quot;XMAS-PSH:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix &quot;NULL_SCAN:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix &quot;SYN/RST:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix &quot;SYN/FIN:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Aplicando y añadiendo estados no válidos a las cadenas
  einfo &quot;Aplicando cadenas en INPUT&quot;
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo &quot;Aplicando cadenas en FORWARD&quot;
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo &quot;Aplicando cadenas en OUTPUT&quot;
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # Permite a los clientes enrutar a través de NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin &quot;Iniciando el cortafuegos&quot;
  if [ -e &quot;${FIREWALL}&quot; ]; then
    restore
  else
    einfo &quot;${FIREWALL} no existe. Usando las reglas por defecto.&quot;
    rules
  fi
  eend $?
}

stop() {
  ebegin &quot;Parando el cortafuegos&quot;
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin &quot;Estatus&quot;
  $IPTABLES -L -n -v --line-numbers
  einfo &quot;Estatus NAT&quot;
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin &quot;Estableciendo reglas 'panic'&quot;
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin &quot;Guardando las reglas del cortafuegos&quot;
  $IPTABLESSAVE > $FIREWALL
  eend $?
}

restore() {
  ebegin &quot;Restaurando las reglas del cortafuegos&quot;
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo &quot;Usage: $0 {start|save|restore|panic|stop|restart|showstatus}&quot;
  echo &quot;start)      restaura si existe y si no fuerza las reglas&quot;
  echo &quot;stop)       elimina todas las reglas y lo permite todo&quot;
  echo &quot;rules)      fuerza el establecimiento de nuevas reglas&quot;
  echo &quot;save)       gruada la configuración en ${FIREWALL}&quot;
  echo &quot;restore)    restaura la configuración desde ${FIREWALL}&quot;
  echo &quot;showstatus) muestra el estatus&quot; 
}
</pre>

<p>
Consejo para cuando cree un cortafuegos:
</p>

<ol>
<li>Cree su política de cortafuegos antes de implementarlo</li>
<li>Hágalo simple</li>
<li>Conozca cómo trabajan los protocolos (lea <uri
link="http://www.ietf.org/" >RFC</uri> (Request For Comments))</li>
<li>Tenga bien presente que un cortafuegos sólo es otro software
ejecutándose como root</li>
<li>Compruebe su cortafuegos</li>
</ol>

<p>
Si piensa que iptables es difícil de comprender o le lleva mucho
tiempo configurar un cortafuegos decente, puede usar <uri
link="http://www.shorewall.net" >Shorewall</uri>. Básicamente utiliza
iptables para generar las reglas del cortafuegos, pero se concentra en
reglas y no en protocolos específicos.
</p>
</body>
</section>

<section>
<title>Squid</title>
<body>
<p>
Squid es un servidor proxy muy potente que puede filtrar el tráfico
atendiendo a: tiempo, expresiones regulares en la ruta/URI, dirección
IP de origen y destino, dominio, navegador, nombre de usuario
autentificado, mime-type y número de puerto (protocolo). Probablemente
olvido algunas características, pero puede ser difícil cubrir la lista
de características entera.
</p>

<p>
En el ejemplo siguiente he añadido un filtrado de
&quot;pancartas&quot; (banners) en lugar de un filtro basado en sitios
porno. La razón de esto es que Gentoo.org <e>no</e> debería ser
catalogado como un sitio pornográfico. Y yo no quiero malgastar mi
tiempo intentando buscar algunos buenos sitios para usted.
</p>

<p>
En este caso, mi política de acceso es:
</p>

<ul>
<li>La navegación (HTTP/HTTPS) está permitida durante las horas de
trabajo (lunes a viernes de 8 a 17 y sábado de 8 a 13 horas). Si
alguien está más tarde debería trabajar, no navegar.</li>
<li>No se puede descargar ningún fichero (.exe, .com, .arj, .zip,
.asf, .avi, .mpg, .mpeg, etc.)</li>
<li>No nos gustan las pancartas, por lo que son filtrados y
reemplazados por un gif transparente (¡aquí es donde se puede ser
creativo!)</li>
<li>Cualquier otra conexión hacia o desde Internet no está
permitida</li>
</ul>

<p>
Esto se implementa en 4 pasos <e>fáciles</e>.
</p>

<pre caption="/etc/squid/squid.conf" >
# Enlaza con una IP y un puerto
http_port 10.0.2.1:3128

# Configuración standard 
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Añade listas de control de acceso básico
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Añade quien puede acceder a este servidor proxy
acl localnet src 10.0.0.0/255.255.0.0

# Y los puertos
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Añade una lista de control de acceso basada en
# expresiones regulares mediante urls
acl archives urlpath_regex &quot;/etc/squid/files.acl&quot;
acl url_ads url_regex &quot;/etc/squid/banner-ads.acl&quot;

# Añade una lista de control de acceso basada en día y hora
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Permite el acceso administrativo desde localhost
http_access allow manager localhost
http_access deny manager

# Solo permite purgar peticiones desde localhost
http_access allow purge localhost
http_access deny purge

# Deniega peticiones hacia puertos desconocidos
http_access deny !Safe_ports

# Deniega CONNECT a otros puertos distintos de SSL
http_access deny CONNECT !SSL_ports

# Mis propias reglas

# Añade una página para ser mostrada cuando
# se elimina una pancarta
deny_info NOTE_ADS_FILTERED url_ads

# Entonces lo rechaza
http_access deny url_ads

# Deniega todos los archivos
http_access deny archives

# Restringe el acceso a las horas de trabajo
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Deniega el resto
http_access deny all
</pre>

<p>
Después complete los ficheros que no quiere que sus usuarios
descarguen. Yo he indicado zip, viv, exe, mp3, rar, ace, avi, mov,
mpg, mpeg, au, ra, arj, tar, gz and z files.
</p>

<pre caption="/etc/squid/files.acl" >
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<p/>
<note>
Por favor, tenga en cuenta los [ ] con mayúsculas y minúsculas en cada
carácter. Esto sirve para que alguien no se salte las reglas
accediendo a un fichero llamado AvI en lugar de avi.
</note>

<p>
Ahora vamos a añadir las expresiones regulares para identificar a las
pancartas. Probablemente usted será más creativo que yo:
</p>

<pre caption="/etc/squid/banner-ads.acl" >
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Y como último paso, queremos que este fichero sea mostrado cuando una
pancarta sea eliminada. Básicamente es un medio archivo html con una
imagen gif transparente de 4x4 pixels.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED" >
&lt;HTML>
&lt;HEAD>
&lt;META HTTP-EQUIV=&quot;REFRESH&quot; CONTENT=&quot;0; URL=http://localhost/images/4x4.gif&quot;>
&lt;TITLE>ERROR: La URL solicitada no puede ser recuperada&lt;/TITLE>
&lt;/HEAD>
&lt;BODY>
&lt;H1>Anuncio filtrado&lt;/H1>
</pre>

<p/>
<note>
No cierre los tags &lt;HTML> &lt;BODY>. Eso lo hará squid.
</note>

<p>
Como puede ver, squid tiene muchas posibilidades y es muy efectivo
tanto como filtro como proxy. Incluso se pueden usar proxies squid
encadenados para escalar en redes muy grandes. La configuración que he
indicado aquí es muy conveniente para una pequeña red de 1 a 20
usuarios.
</p>

<p>
Pero combinar el filtrado de paquetes (iptables) y una pasarela de
aplicaciones (squid) es probablemente la mejor solución, incluso si
squid está ubicado en un lugar seguro y donde nadie pueda acceder
desde el exterior. Continuamos teniendo que preocuparnos de los
ataques desde dentro.
</p>

<p>
Ahora tiene que configurar los navegadores en los clientes para usar
el servidor proxy. La puerta de enlace evitará que los usuarios tengan
cualquier contacto con el exterior salvo que usen el proxy.
</p>

<note>
En Mozilla se consigue en Edición->Preferencias->Advanzadas->Proxies.
</note>

<p>
También se conseguir un proxy transparente usando iptables dirigiendo
todo el tráfico saliente a un proxy squid. Esto se hace añadiendo una
regla de forwarding/prerouting en la pasarela:

</p>
<pre caption="Activa el portforwarding hacia nuestro servidor proxy" >
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>
</body>
</section>

<section>
<title>¿Qué hemos aprendido?</title>
<body>
<p>
Hemos aprendido esto:
</p>

<ol>
<li>Un cortafuegos puede representar un riesgo por si mismo. Un
cortafuegos mal configurado es peor que no tenerlo.</li>
<li>Cómo configurar una pasarela básica y un proxy transparente</li>
<li>La clave para tener un buen cortafuegos es conocer el protocolo
que queremos permitir</li>
<li>Que el tráfico IP puede contener datos no legítimos, por ejemplo
los paquetes ICMP pueden llevar una carga oculta</li>
<li>Cómo prevenir un ataque SYN</li>
<li>El filtrado de tráfico HTTP quitando imágenes no adecuadas,
descargas de ficheros de virus</li>
<li>Combinar filtros de paquetes y pasarelas de aplicaciones
proporcionan mayor control</li>
</ol>

<p>
Entonces si <e>realmente</e> usted necesita un cortafuegos, cree uno que satisfaga sus necesidades.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Detección de intrusos</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment, Entorno Avanzado de Detección de Intrusos)</title>
<body>
<p>
AIDE es un sistema de detección de intrusos basado en host
(alternativa libre a Tripwire). Y si usted ya conoce Tripwire no
debería tener dificultades para aprender a configurar AIDE.
</p>

<p>
El fichero de configuración está basado en expresiones regulares,
macros y reglas para ficheros y directorios. Tenemos la macros
siguientes:
</p>

<table>
<tr>
<th>Macro</th>
<th>Descripción</th>
<th>Sintaxis</th>
</tr>
<tr>
<ti>ifdef</ti>
<ti>Si está definido</ti>
<ti>@@ifdef &quot;name&quot;</ti>
</tr>
<tr>
<ti>ifndef</ti>
<ti>Si no está definido</ti>
<ti>@@ifndef &quot;name&quot;</ti>
</tr>
<tr>
<ti>define</ti>
<ti>Define una variable </ti>
<ti>@@define &quot;name&quot; &quot;value&quot;</ti>
</tr>
<tr>
<ti>undef</ti>
<ti>Elimina la definición de una variable</ti>
<ti>@@undef &quot;name&quot;</ti>
</tr>
<tr>
<ti>ifhost</ti>
<ti>Si &quot;hostname&quot;</ti>
<ti>@@ifhost &quot;hostname&quot;</ti>
</tr>
<tr>
<ti>ifnhost</ti>
<ti>Si no &quot;hostname&quot;</ti>
<ti>@@ifnhost &quot;hostname&quot;</ti>
</tr>
<tr>
<ti>endif</ti>
<ti>Endif puede ser usado después de cualquiera de las macros
anteriores excepto define y undef</ti>
<ti>@@endif</ti>
</tr>
</table>

<p>
Esas macros se convierten en algo muy práctico si usted tiene más de
un sistema Gentoo y quiere usar AIDE en todos ellos, pero no todas las
máquinas ejecutan los mismos servicios o quizás tengan los mismos
usuarios.
</p>

<p>
A continuación tenemos conjuntos de marcas (flags) para comprobar en
ficheros y directorios. Son una combinación de permisos, propiedades
de archivos y sumas de control criptográficas (hashes).
</p>

<table>
<tr>
<th>Flag</th>
<th>Descripción</th>
</tr>
<tr>
<ti>p</ti>
<ti>permisos</ti>
</tr>
<tr>
<ti>i</ti>
<ti>inode</ti>
</tr>
<tr>
<ti>n</ti>
<ti>número de enlaces</ti>
</tr>
<tr>
<ti>u</ti>
<ti>usuario</ti>
</tr>
<tr>
<ti>g</ti>
<ti>grupo</ti>
</tr>
<tr>
<ti>s</ti>
<ti>tamaño</ti>
</tr>
<tr>
<ti>b</ti>
<ti>'block count'</ti>
</tr>
<tr>
<ti>m</ti>
<ti>mtime</ti>
</tr>
<tr>
<ti>a</ti>
<ti>atime</ti>
</tr>
<tr>
<ti>c</ti>
<ti>ctime</ti>
</tr>
<tr>
<ti>S</ti>
<ti>verifica el tamaño creciente</ti>
</tr>
<tr>
<ti>md5</ti>
<ti>suma de control md5</ti>
</tr>
<tr>
<ti>sha1</ti>
<ti>suma de control sha1</ti>
</tr>
<tr>
<ti>rmd160</ti>
<ti>suma de control rmd160</ti>
</tr>
<tr>
<ti>tiger</ti>
<ti>suma de control tiger</ti>
</tr>
<tr>
<ti>R</ti>
<ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
<ti>L</ti>
<ti>p+i+n+u+g</ti>
</tr>
<tr>
<ti>E</ti>
<ti>Grupo vacío</ti>
</tr>
<tr>
<ti>></ti>
<ti>Crecimiento del fichero de log p+u+g+i+n+S</ti>
</tr>
</table>

<p>
Y si AIDE se compila con soporte para mhash también tiene algunas
otras características:
</p>

<table>
<tr>
<th>Flag</th>
<th>Descripción</th>
</tr>
<tr>
<ti>haval</ti>
<ti>suma de control haval</ti>
</tr>
<tr>
<ti>gost</ti>
<ti>suma de control gost</ti>
</tr>
<tr>
<ti>crc32</ti>
<ti>suma de control crc32</ti>
</tr>
</table>

<p>
Ahora puede crear sus propias reglas basadas en los indicadores
(flags) anteriores, combinándolas tal que así:
</p>

<pre caption="Creación de un conjunto de reglas para AIDE" >
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Lo último que necesita para crear su propio fichero de configuración
es ver cómo añadir una regla a un fichero o
directorio. Fundamentalmente sólo necesita indicar el nombre de
fichero o directorio y la regla. AIDE añadirá todos los archivos
recursivamente a no ser que usted especifique alguna otra cosa.
</p>

<table>
<tr>
<th>Flag</th>
<th>Descripción</th>
</tr>
<tr>
<ti>!</ti>
<ti>No añadir este fichero o directorio.</ti>
</tr>
<tr>
<ti>=</ti>
<ti>Añadir este directorio, pero sin recursividad.</ti>
</tr>
</table>
<p>
Veamos, pues, un ejemplo completo.
</p>
<pre caption="/etc/aide/aide.conf" >
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# La ubicación de la base de datos a ser leída
database=file:@@{AIDEDIR}/aide.db

# La ubicación de la base de datos donde escribir
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Definición de reglas
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
En el ejemplo anterior especificamos con algunas macros donde comienza
el directorio de nivel superior y donde está el directorio de
AIDE. AIDE comprueba el fichero <path>/etc/aide/aide.db</path> cuando
comprueba la integridad de un fichero. Pero cuando actualiza o crea un
nuevo fichero almacena la información en
<path>/etc/aide/aide.db.new</path>. Esto se hace porque no se puede
sobrescribir automáticamente el antiguo fichero de base de datos. La
opción <c>report_URL</c> no está todavía implementada. Pero la
intención de los autores es que sea capaz de enviar correo electrónico
o quizá también ejecutar un guión.
</p>

<p>
Después de editar la configuración usted debe crear su fichero de base
de datos mediante la ejecución de <c>aide -i</c> y entonces copiar el
fichero <path>/etc/aide/aide.db.new</path> como
<path>/etc/aide/aide.db</path> y comprobar cron ejecutando <c>crontab
-e</c> como root.

</p>
<note>
Dependiendo de su cpu, acceso de disco y los indicadores configurados
para los ficheros, el proceso puede llevar algún tiempo.
</note>

<p/>
<pre caption="Planificar aide como un trabajo de cron" >
0 3   * * * /usr/bin/aide -u
</pre>

<p/>
<note>
Recuerde configurar la posibilidad de leer los mensajes de correo para
root. En caso contrario nunca conocerá qué está informando aide.
</note>

<p>
En este caso se ejecuta una vez a las 3 de la mañana. Lo he programado
de esta manera para no molestar a los usuarios mientras trabajan. Note
que estoy usando la opción <c>-u</c> (Actualización) en lugar de
<c>-C</c> (Verificación). Como <c>-u</c> comprueba también los
ficheros y no sobrescribe el fichero de base de datos original ahorra
algún tiempo porque todo lo que usted necesita hacer es copiar el
fichero cuando se detecta algún cambio. ¡Sólo compruebe los cambios
mirando si fue usted mismo quien los hizo o fue algún atacante antes
de que usted lo copiara!
</p>

<p>
Note que almacenar localmente los ficheros de base de datos tiene
algunos problemas, puesto que los atacantes (si conocen que aide está
instalado) intentarán sin duda alterar el fichero de base de datos,
actualizarlo o modificar <path>/usr/bin/aide</path>. Por esto, debería
crear un CD o otro medio donde dejar una copia del fichero .db y los
binarios de AIDE.
</p>

<p>
Puede encontrar más información en la página del proyecto <uri
link="http://www.cs.tut.fi/~rammer/aide.html" >AIDE</uri>.
</p>
</body>
</section>

<section>
<title>Snort</title>
<body>
<p>
Snort es un Sistema de Detección de Intrusiones de Red (Network
Intrusion Detection System, NIDS). Para instalarlo y configurarlo use
los ejemplos siguientes.
</p>

<pre caption="Añadir el usuario snort al sistema" >
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>
<p/>
<pre caption="/etc/conf.d/snort" >
PIDFILE=/var/run/snort_eth0.pid
MODE=&quot;full&quot;
NETWORK=&quot;10.0.0.0/24&quot;
LOGDIR=&quot;/var/log/snort&quot;
CONF=/etc/snort/snort.conf
SNORT_OPTS=&quot;-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF&quot;
</pre>

<p/>
<pre caption="/etc/snort/snort.conf" >
<codenote>Step 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Step 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>Step 3</codenote>
include classification.config

<codenote>Step 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<p/>
<pre caption="/etc/snort/classification.config" >
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Más información en el sitio web de <uri link="http://www.snort.org"
>Snort</uri>.
</p>
</body>
</section>

<section>
<title>Manteniendo el sistema actualizado</title>
<body>
<p>
Una vez que ha instalado satisfactoriamente su sistema y conseguido un
buen nivel de seguridad no lo ha hecho todo. La seguridad es un
proceso continuo y usted tiene que mantener su sistema actualizado con
los últimos parches de seguridad.
</p>

<p>
Si tiene una versión reciente del <c>portage</c> instalada usted puede
primero sincronizar su árbol del portage mediante <c>emerge sync</c> y
entonces ejecutar el comando <c>glsa-check --list</c> para comprobar
si su sistema está actualizado en cuanto a la seguridad.
</p>

<pre caption="Ejemplo de salida de glsa-check -l" >
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.
  
[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.
 
200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
<c>glsa-check</c> es todavía experimental por lo que si la seguridad es realmente
su máxima prioridad sería juicioso contrastar la lista con otras fuentes
</warn>

<p>
Todas las líneas con <c>[A]</c> y <c>[U]</c> pueden casi ser ignoradas
sin peligro mientras el sistema no esté afectado por este GLSA.
</p>

<p>
Algunas personas todavía prefieren usar <c>emerge
nombre_de_paquete</c> en lugar de <c>glsa-check -f</c> por esto todos
los GLSA están listados como <c>[N]</c>.
</p>

<p>
Si usted quiere recibir un mensaje cada vez que se libera un GLSA,
subscríbase a la lista de correo <c>gentoo-announce</c>. Las
instrucciones para unirse así como un montón de otras buenas listas de
correo se pueden encontrar en <uri link="/main/en/lists.xml" >Gentoo
Linux Mailing List Overview</uri>.
</p>

<p>
Otro buen recurso de seguridad es <uri
link="http://www.securityfocus.com/archive/1" >Bugtraq
mailinglist</uri>.
</p>
</body>
</section>
</chapter>
</guide>
