<?xml version = '1.0' encoding = 'UTF-8' ?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd"><!-- $Header: -->
<!-- /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/es/gentoo-security.xml,v 1.21 2005/02/22 15:18:01 chiguire Exp $ -->

<guide link="/doc/es/gentoo-security.xml" lang="es">
<title>Guía de seguridad de Gentoo Linux</title>

  <author title="Autor">
    <mail link="kn@insecurity.dk">Kim Nielsen</mail>
  </author>
  <author title="Editor">
<!-- zhen@gentoo.org -->
John P. Davis
</author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Editor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
  </author>
  <author title="Editor">
    <mail link="bennyc@gentoo.org">Benny Chuang</mail>
  </author>
  <author title="Editor">
    <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
  </author>
  <author title="Editor">
    <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
  </author>
  <author title="Editor">
    <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
  </author>
  <author title="Editor">
    <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
  </author>
  <author title="Editor Es">
    <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
  </author>
  <author title="Editor Es">
    <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
  </author>
  <author title="Editor Es">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
  </author>
  <author title="Traductor">
    <mail link="postel@antipoder.dyndns.org">Postel</mail>
  </author>
  <author title="Traductor">
    <mail link="carles@carles.no-ip.info">Carles Ferrer Peris</mail>
  </author>

<abstract>
Esta es una guía paso a paso para asegurar Gentoo Linux.
</abstract>

<license/>

<version>0.4.48</version>
<date>2005-05-23</date>

<chapter>
<title>Introducción</title>
<section>

<body>
<p>
Esta guía está orientada a las personas que utilizan Gentoo Linux en
un entorno de servidor o simplemente creen necesario mejorar la
seguridad.
</p>

<note>
Si después de leer esta guía está interesado en más aspectos
relacionados con la seguridad en Gentoo, entonces vea el <uri link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo
Project</uri>.
</note>
</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>

<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>

<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>

<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.This is for
quality assurance purposes.
</note>
</body>
</section>
-->
</chapter>

<chapter>
<title>Consideraciones previas a la instalación</title>
<section>
<title>Seguridad física</title>
<body>

<p>
No importa cuantas medidas de seguridad implemente: todas pueden ser
fácilmente traspasadas por un atacante que tenga acceso físico a su
equipo. A pesar de ello, puede tomar algunas medidas que proporcionan
un nivel de seguridad contra atacantes con acceso físico a su
equipo. Ubicar el hardware en un armario cerrado para servidores
previene contra alguien que sencillamente apague el equipo y se lo
lleve. Cerrar con llave la caja del ordenador también es una buena
idea para asegurarse que el atacante no se vaya con el disco duro bajo
el brazo. Para prevenir que un atacante arranque desde otro disco,
burlando fácilmente sus permisos y restricciones de acceso, configure
en la BIOS el disco duro como primer dispositivo de arranque y ponga
una contraseña de acceso a la BIOS. También es importante establecer
una contraseña de aranque para LILO o GRUB, y así prevenir que
usuarios maliciosos arranquen en modo monousuario y consigan acceso
total al sistema. Esto está más detallado en el Capítulo 3, en <uri link="#passwording_GRUB">Contraseña para GRUB</uri> y <uri link="#passwording_LILO">Contraseña para LILO</uri>.
</p>
</body>
</section>

<section>
<title>Planificación de Demonios/Servicios</title>
<body>
<p>
Empiece por documentar qué servicios deberá ejecutar este equipo. Esto
le ayudará a definir mejor la estructura de particiones de su sistema,
y le permitirá planificar mejor sus medidas de seguridad. Desde luego
esto es innecesario si el equipo tiene un único y sencillo propósito,
como un puesto de trabajo o un cortafuegos (firewall) dedicado. En
todos estos casos no debería ejecutar <e>ningún</e> servicio salvo,
quizás, sshd.
</p>

<p>
Esta lista puede servirle de ayuda al administrador del
sistema. Manteniendo una lista puesta al día de versiones encontrará
mucho más sencillo mantenerlo todo actualizado si alguien descubre una
vulnerabilidad remota en alguno de sus servicios.
</p>
</body>
</section>

<section>
<title>Esquema de particiones</title>
<body>

<p>
Reglas para crear particiones:
</p>

<ul>
<li>
Cualquier árbol de directorios en el que un usuario tenga permiso
de escritura (por ejemplo <path>/home</path>, <path>/tmp</path>)
debería estar en una partición separada y usar cuotas de disco. Esto
reduce el riesgo de que un usuario llene por completo el sistema de
ficheros. Portage usa <path>/var/tmp</path> para compilar ficheros por
lo que esta partición debería ser lo suficientemente grande.
</li>

<li>
Cualquier árbol de directorios donde quiera instalar software que
no forme parte de la distribución debería estar en una partición
separada. Conforme a la <uri link="http://www.pathname.com/fhs/">Jerarquía estándar de ficheros</uri> estos directorios serían
<path>/opt</path> o <path>/usr/local</path>. Si ambos están en
particiones separadas no haría falta borrarlos si tiene que reinstalar
el sistema.
</li>

<li>
Para mayor seguridad, los datos estáticos pueden ponerse en una
partición separada y montada en modo de sólo lectura
(&quot;read-only&quot;). El paranoico de verdad puede intentar
almacenar los datos estáticos en un medio de sólo lectura, como un
CD-ROM.
</li>
</ul>
</body>
</section>

<section>
<title>El usuario root</title>
<body>

<p>
El usuario root es el usuario más importante del sistema y no debería
usarse para nada más que lo estrictamente necesario. Si un atacante
consigue acceso de root, reinstalar es la única forma de volver a
confiar en su sistema.
</p>

<p>
Reglas de oro respecto a 'root'
</p>

<ul>
<li>
Cree siempre un usuario para la gestión diaria y si este usuario
necesita tener acceso de root, añádalo al grupo 'wheel'. Esto
posibilita que un usuario normal pueda cambiar su ID a root usando el
comando <c>su</c>.
</li>

<li>
Nunca ejecute X u otro software de aplicación como root, root debe
usarse sólo cuando sea absolutamente necesario; si existe una
vulnerabilidad en una aplicación ejecutándose como usuario, el
atacante consigue el nivel de acceso del usuario. Pero si esta
aplicación se ejecuta como root, el atacate consigue acceso de root.
</li>

<li>
Use siempre rutas absolutas cuando se conecte como root (o use siempre
<c>su -</c>, que reemplaza las variables de entorno del usuario con
las de root, estando seguro que el <c>PATH</c> de root sólo contiene
directorios protegidos como <path>/bin</path> y
<path>/sbin</path>). Es posible engañar a root para que ejecute una
aplicación distinta de aquella que pretendía ejecutar. Si el
<c>PATH</c> de root está protegido o root sólo usa rutas absolutas,
podemos estar seguros de que esto no sucede.
</li>

<li>
Si un usuario sólo necesita ejecutar algunos comandos, en lugar de
todo lo que root puede hacer normalmente, considere usar <c>sudo</c>
en su lugar. Pero, al final, ¡tenga cuidado a quién le da este acceso!
</li>

<li>
Nunca se deje abierta una terminal donde esté identificado como root.
</li>
</ul>

<p>
Gentoo tiene algunas protecciones por defecto para los usuarios
normales que intentan hacer <c>su</c> a root. La configuración por
defecto de PAM establece que un usuario debe pertenecer al grupo
&quot;wheel&quot; para poder ser capaz de usar <c>su</c>.
</p>
</body>
</section>

<section id="security_policies">
<title>Políticas de seguridad</title>
<body>

<p>
Hay ciertas razones para diseñar un política de seguridad para su(s)
sistema(s) y red.
</p>

<ul>
<li>
Una buena política de seguridad le permite perfilar la seguridad como
un &quot;sistema&quot;, antes que simplemente como un revoltijo de
distintas características. Por ejemplo, sin una política un
administrador puede decidir desconectar el telnet, porque transmite
las contraseñas sin cifrar, pero puede dejar el acceso FTP, que tiene
el mismo problema. Una buena política de seguridad le permite
identificar qué medidas de seguridad merecen la pena, y cuáles no.
</li>

<li>
Para diagnosticar problemas, realizar auditorías o localizar intrusos,
puede ser necesario interceptar el tráfico de la red, inspeccionar el
acceso de los usuarios y su historial de ejecución de comandos, y
mirar en sus directorios locales. Sin especificar esto por escrito y
sin advertirlo a los usuarios, tales acciones pueden ser actualmente
ilegales, y ponerle a <e>usted</e> en un compromiso legal.
</li>

<li>
Uno de los escenarios más comunes en la seguridad del sistema son las
cuentas de usuario secuestradas. Sin explicar a los usuarios por qué
es importante la seguridad, y cómo practicar una buena seguridad (tal
como no escribir las contraseñas en un &quot;post-it&quot; pegado en
la mesa), es improbable que tenga alguna esperanza de tener cuentas de
usuario seguras.
</li>

<li>
Una red bien documentada y un guión del sistema le ayudará, además de
a los expertos forenses de las fuerzas de seguridad, si se necesitan,
a seguir una intrusión y a identificar los puntos débiles después del
problema. La &quot;publicación&quot; de un aviso de uso, donde se
explique que su sistema es privado y que los accesos no autorizados no
están permitidos, podrá también ayudarle a asegurarse la posibilidad
para procesar correctamente a un intruso, una vez ha sido cogido.
</li>
</ul>

<p>
La necesidad de una buena política de seguridad debería estar ahora
más que clara.
</p>

<p>
La &quot;política&quot; o &quot;directiva&quot; por sí misma es un
documento, o un conjunto de documentos, que perfilan las
características de la red y los sistemas (como los servicios que
proporcionan), el uso permitido y prohibido, los &quot;buenos
hábitos&quot; de seguridad, y así sucesivamente. Todos los usuarios
deben ser concienciados de su política de seguridad, además de
mantenerlos al corriente de los cambios que se introduzcan. Es
importante tomarse el tiempo necesario para ayudar a los usuarios a
comprender la política y por qué las políticas deben ser firmadas, o
qué sucedería si ellos actúan en contra de las mismas (lo que también
debe recogerse en las políticas). Esto debería hacerse por lo menos
una vez al año pues las políticas pueden cambiar (pero también como un
simple recordatorio para el usuario).
</p>

<note>
Se deben crear políticas fáciles de leer y que sean muy precisas en
cada apartado.
</note>

<p>
Una política de seguridad debería contener, al menos, los siguientes
apartados:
</p>

<ul>
  <li>Uso aceptable
<ul>
  <li>Protectores de pantalla</li>
  <li>Manejo de contraseñas</li>
  <li>Descarga e instalación de software</li>
  <li>Información sobre si los usuarios son monitorizados</li>
  <li>Uso de programas antivirus</li>
</ul>
  </li>
  <li>Manejo de información sensible (en cualquier formato, sea papel o
sea electrónico)
<ul>
  <li>Limpieza del escritorio y protección de la información confidencial</li>
  <li>Apagado del PC antes de marcharse</li>
  <li>Uso de cifrado</li>
  <li>Manejo de claves para empleados de confianza</li>
  <li>Tratamiento de los documentos confidenciales durante los viajes</li>
</ul>
  </li>
  <li>Manejo de los equipos informáticos durante los viajes
<ul>
  <li>Uso de los portátiles en los viajes y las estancias en los hoteles</li>
</ul>
  </li>
</ul>

<p>
Usuarios distintos pueden requerir distintos niveles o tipos de
acceso, y como tal, su política puede variar para acomodarse a todos
ellos.
</p>

<p>
Las políticas de seguridad pueden convertirse en algo enorme, y
resultar ser información vital que puede fácilmente olvidarse. Las
políticas para el equipo de TI pueden contener información
confidencial para el usuario normal, por esto se pueden separar en
políticas más pequeñas, como por ejemplo, Política de uso aceptable,
Política de contraseñas, Política de correo electrónico y acceso
remoto.
</p>

<p>
Puede encontrar ejemplos de políticas en <uri link="http://www.sans.org/resources/policies/">The SANS Security
Policy Project</uri>. Si tiene una red pequeña y las encuentra
demasiado complejas para su realidad, puede mirar en <uri link="ftp://ftp.isi.edu/in-notes/rfc2196.txt">Site
Security Handbook</uri>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Ajustando la seguridad durante y después de la instalación</title>
<section>
<title>Parámetros USE</title>
<body>

<p>
El archivo <path>make.conf</path> contiene los parámetros USE
definidas por el usuario y
<path>/etc/make.profile/make.defaults</path> los parámetros USE por
defecto para Gentoo Linux. Para el propósito de esta guía, las
opciones importantes son <c>pam</c> (Pluggable Authentication
Modules), <c>tcpd</c> (TCP wrappers) y <c>ssl</c> (Secure Socket
Layer). Esas tres aparecen en los parámetros USE por defecto.
</p>
</body>
</section>

<section id="passwording_GRUB">
<title>Proteger GRUB con contraseña</title>
<body>

<p>
Grub soporta dos formas diferentes para añadir una contraseña de
acceso a su fichero de configuración. La primera usa texto en claro,
mientras que la segunda utiliza cifrado md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password cámbiame
</pre>

<p>
Esto añadirá la contraseña <c>cámbiame</c>. Si no se teclea ninguna
durante el arranque, GRUB usará simplemente la configuración de
arranque por defecto.
</p>

<p>
Cuando añada una contraseña md5, necesita convertirla en un formato
cifrado con el mismo formato que se usa en
<path>/etc/shadow</path>. Para más información mire <c>man
crypt</c>. La contraseña cifrada <e>cámbiame</e>, por ejemplo, se
vería así $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0.
</p>

<p>
Puede cifrar su contraseña directamente en el shell de grub:
</p>

<pre caption="md5crypt en el shell de grub">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
  <comment>(Tecleado cámbiame en el prompt)</comment>
Encrypted: $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0

grub> <i>quit</i>
</pre>

<p>
Entonces, corte y pegue la contraseña en
<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$tDa3G0$ex6pzfebFmkeZrGRU1YWe0
</pre>

<p>
Los 5 segundos de espera resultan prácticos si se trata de un sistema
remoto y debería poder reiniciarse sin interacción con el
teclado. Puede encontrar más información a cerca de las contraseñas de
GRUB ejecutando <c>info grub</c>.
</p>
</body>
</section>

<section id="passwording_LILO">
<title>Protegiendo LILO con contraseña</title>
<body>

<p>
LILO también soporta dos formas de uso de contraseñas: global y por
imagen, ambas en texto plano.
</p>

<p>
La contraseña global se establece en el inicio del fichero de configuración, y se aplica a cada imagen de arranque:
</p>

<pre caption="/etc/lilo.conf">
password=cámbiame
restricted
delay=3
</pre>

<p>
La contraseña por imagen se establece de la siguiente forma:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=cámbiame
      restricted
</pre>

<p>
Si la opción <c>restricted</c> no es introducida, LILO pedirá la
contraseña cada vez.
</p>

<p>
Para poder almacenar la nueva información en <path>lilo.conf</path> debe ejecutar <c>/sbin/lilo</c>.
</p>
</body>
</section>

<section>
<title>Restricción de uso de la consola</title>
<body>

<p>
El fichero <path>/etc/securetty</path> le permite especificar desde
qué dispositivos <c>tty</c> (terminales) tiene root permitido el
inicio de sesión.
</p>

<p>
Le sugerimos que comente todas las líneas excepto <c>vc/1</c>. Esto le
asegurará que root sólo puede hacer un login y sólo en un terminal.
</p>

<note>
Los usuarios del grupo &quot;wheel&quot; podrán continuar haciendo
<c>su -</c> para convertirse en root en otras TTYs.
</note>

<p/>
<pre caption="/etc/securetty">
vc/1
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Más sobre gestión de registro</title>
<section>
<body>

<p>
Puede conseguir un mayor nivel de detalle en sus registros de sistema
para que indiquen un ataque en curso o ya realizado. Los atacantes
normalmente escudriñan o investigan las redes antes de actuar.
</p>

<p>
Es también de vital importancia que sus ficheros de registro de
sistema sean fácilmente legibles y manejables. Gentoo Linux le permite
elegir durante la instalación entre tres tipos diferentes de gestores
de registro.
</p>
</body>
</section>

<section>
<title>Gestión de registro: Syslogd</title>
<body>

<p>
Syslogd es el gestor de registro más común para Linux y Unix en
general. Incorpora algunas utilidades de rotación de logs, pero usar <path>/usr/sbin/logrotate</path> en una tarea programada (logrotate se configura en <path>/etc/logrotate.conf</path>) puede que sea más potente, puesto que <c>logrotate</c> tiene más prestaciones. Cuan a menudo se debe ejecutar la rotación de los registros dependerá de la carga del sistema.
</p>

<p>
A continuación se encuentra el <path>syslog.conf</path> estándar con
algunas características añadidas. Hemos &quot;descomentado&quot; las
líneas <c>cron</c> y <c>tty</c> y añadido un gestor de registro
remoto. Para mejorar la seguridad usted puede almacenar los registros
en dos lugares.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# Primero algunos ficheros de registro estándar. Registre por servicio.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Registro para el sistema de correo. Divídalo porque
# es fácil escribir scripts para manejar estos ficheros. 
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Registro para el servicio de news INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Algunos fichero de registro para todo lo demás
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Las emergencias y alertas son enviadas a todos los
# que han iniciado una sesión.
#
*.emerg                         *
*.=alert                        *

#
# Me gusta que los mensajes se muestren en la consola, pero sólo en una
# consola virtual que normalmente dejo disponible.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# Configurando un servidor para gestionar el registro remotamente
*.*                        @logserver

# La 'named pipe' /dev/xconsole es para la utilidad 'xconsole'. Para usarla,
# debe llamar 'xconsole' con la opción '-file':
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTA: ajuste la siguiente lista, o podría volverse loco si tiene 
#       un sitio medianamente ocupado...
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                --/var/log/ppp.log
</pre>

<p>
Los atacantes intentarán borrar sus huellas editando o borrando los
ficheros de registro. Usted puede dificultarles la tarea enviando los
registros a más de un servidor remoto en máquinas distintas. Encuentre
más información sobre syslogd ejecutando <c>man syslog</c>.
</p>
</body>
</section>

<section>
<title>Gestión de registro: Metalog</title>
<body>

<p>
El <uri link="http://metalog.sourceforge.net">Metalog</uri> de Frank
Dennis no puede enviar los registros a un servidor remoto, pero tiene
como ventajas su rendimiento y flexibilidad. Puede registrar por
nombre de programa, urgencia, servicio (como syslogd) e incorpora
concordancia con expresiones regulares con las que puede ejecutar
guiones (&quot;scripts&quot;) externos cuando son encontradas
determinadas pautas. Es muy bueno realizando acciones cuando se
necesitan.
</p>

<p>
La configuración estándar es normalmente suficiente. Si necesita
notificar por correo electrónico cuando ocurre un fallo de contraseña
puede utilizar uno de los siguientes guiones.
</p>

<p>
Para postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para postfix">
#! /bin/sh
echo &quot;$3&quot; | mail -s &quot;Warning (program : $2)&quot; root
</pre>

<p>
Para qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh para qmail">
#!/bin/sh
echo &quot;To: root
Subject:Failure (Warning: $2) 
$3
&quot; | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Recuerde hacer ejecutable el script con <c>/bin/chmod +x
/usr/local/sbin/mail_pwd_failures.sh</c>.
</p>

<p>
Entonces &quot;descomente&quot; la línea de comando debajo de
&quot;Password failures&quot; en
<path>/etc/metalog/metalog.conf</path> tal que:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = &quot;/usr/local/sbin/mail_pwd_failures.sh&quot;
</pre>
</body>
</section>

<section>
<title>Gestión de registro: Syslog-ng</title>
<body>

<p>
Syslog-ng proporciona algunas de las mismas características que syslog
y metalog con una pequeña diferencia. Puede filtrar mensajes basándose
en nivel y contenido (como metalog), proporciona gestión de registro
remoto como syslog, mantiene registros de syslogd (incluso
descriptores de Solaris), los envía a una TTY, ejecuta programas y
puede actuar como un servidor de registro. Básicamente tiene lo mejor
de los otros dos gestores de registro combinado con una configuración
avanzada.
</p>

<p>
Seguidamente un fichero de configuración típico ligeramente modificado:
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#origen donde leer el registro
source src { unix-stream(&quot;/dev/log&quot;); internal(); };
source kernsrc { file(&quot;/proc/kmsg&quot;); };

#define los destinos
destination authlog { file(&quot;/var/log/auth.log&quot;); };
destination syslog { file(&quot;/var/log/syslog&quot;); };
destination cron { file(&quot;/var/log/cron.log&quot;); };
destination daemon { file(&quot;/var/log/daemon.log&quot;); };
destination kern { file(&quot;/var/log/kern.log&quot;); };
destination lpr { file(&quot;/var/log/lpr.log&quot;); };
destination user { file(&quot;/var/log/user.log&quot;); };
destination mail { file(&quot;/var/log/mail.log&quot;); };

destination mailinfo { file(&quot;/var/log/mail.info&quot;); };
destination mailwarn { file(&quot;/var/log/mail.warn&quot;); };
destination mailerr { file(&quot;/var/log/mail.err&quot;); };

destination newscrit { file(&quot;/var/log/news/news.crit&quot;); };
destination newserr { file(&quot;/var/log/news/news.err&quot;); };
destination newsnotice { file(&quot;/var/log/news/news.notice&quot;); };

destination debug { file(&quot;/var/log/debug&quot;); };
destination messages { file(&quot;/var/log/messages&quot;); };
destination console { usertty(&quot;root&quot;); };
destination console_all { file(&quot;/dev/tty12&quot;); };
destination xconsole { pipe(&quot;/dev/xconsole&quot;); };

#crea los filtros
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match(&quot;failed&quot;); };
filter f_denied { match(&quot;denied&quot;); };

#enlaza filtros con destinos
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#log por defecto
log { source(src); destination(console_all); };
</pre>

<p>
syslog-ng es muy sencillo de configurar, pero también es muy fácil
olvidar algo en el archivo de configuración, ya que es extenso. El
autor promete algunas características extra como cifrado,
autentificación, compresión y control MAC (Mandatory Access
Control). Con esas opciones se convertirá en el gestor de registro de
red perfecto, ya que el atacante no podrá espiar en el registro.
</p>

<p>
Y syslog-ng tiene otras ventajas: ¡no necesita ejecutarse como root!
</p>
</body>
</section>

<section>
<title>Análisis de registros con Logcheck</title>
<body>

<p>
Desde luego, mantener los registros sólo es la mitad del trabajo. Un
programa como Logcheck puede hacer mucho más fácil el análisis regular
de los registros. Logcheck es un guión (&quot;script&quot;),
acompañado de un binario llamado <c>logtail</c>, que se ejecuta desde
el servicio de cron y comprueba los registros mediante una serie de
reglas para detectar actividad sospechosa. Entonces, envía los
resultados al buzón de correo de root.
</p>

<p>
Logcheck y logtail forman parte del paquete <c>app-admin/logsentry</c>.
</p>

<p>
Logcheck usa cuatro ficheros para separar las líneas del registro
importantes de las que no lo son. Estos ficheros son
<path>logcheck.hacking</path>, que contiene los mensajes conocidos de
ataques de alteración (hacking), <path>logcheck.violations</path>, que
contiene los patrones indicadores de compromisos de seguridad,
<path>logcheck.violations.ignore</path>, con las palabras claves que
probablemente emparejaría el fichero de compromisos de seguridad, pero
que permiten que los registros normales sean ignorados, y
<path>logcheck.ignore</path>, que casa todas aquellas entradas que
deban ser ignoradas.
</p>

<warn>
No deje <path>logcheck.violations.ignore</path> vacío, Logcheck usa
<c>grep</c> para analizar sintácticamente los registros, y algunas
versiones del mismo asumen que un fichero vacío significa un comodín:
Todos los compromisos de seguridad serían ignorados.
</warn>

<!-- FIXME: Might want to add more details on logcheck here...I have to install
  	 it on Gentoo to figure out how it's configured! -->
</body>
</section>
</chapter>

<chapter>
<title>Montaje de particiones</title>
<section>
<body>

<p>
Al montar una partición <c>ext2</c>, <c>ext3</c> o <c>reiserfs</c>
tiene usted algunas opciones que puede aplicar en el fichero
<path>/etc/fstab</path>. Las opciones son:
</p>
<ul>
  <li>
  <c>nosuid</c> - Ignorará el bit SUID y actúa como si se tratase de
  un archivo ordinario
  </li>
  <li>
  <c>noexec</c> - Deshabilitará la ejecución de ficheros en esta
  partición
  </li>
  <li>
  <c>nodev</c> - Ignora dispositivos
  </li>
</ul>

<p>
Desafortunadamente, esas opciones pueden ser fácilmente burladas
ejecutando una trayectoria indirecta. Sin embargo, estableciendo
<path>/tmp</path> como noexec parará la mayoría de los intentos de
explotación (exploits) diseñados para ser ejecutados directamente
desde <path>/tmp</path>.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p/>
<warn>
Estableciendo <path>/tmp</path> en modo <c>noexec</c> puede hacer que
ciertos scripts no ejecuten correctamente.
</warn>

<p/>
<note>
Referente a las cuotas de disco mire la sección <uri link="#doc_chap6_sect3">Cuotas</uri>.
</note>

<p/>
<note>
Yo no configuro <path>/var</path> en modo <c>noexec</c> o
<c>nosuid</c>, incluso si nunca se ejecutan ficheros desde este punto
de montaje. La razón de esto es que qmail se instala en
<path>/var/qmail</path> y debe tener permitido ejecutar y acceder a un
fichero SUID. Yo establezco <path>/usr</path> en modo de sólo lectura
ya que nunca escribo nada en él excepto cuando quiero actualizar
Gentoo. Entonces vuelvo a montar el sistema de ficheros en modo de
lectura-escritura, actualizo y lo vuelvo a montar nuevamente.
</note>

<p/>
<note>
Incluso si usted no utiliza qmail, Gentoo continua necesitando tener
activado el bit de ejecución en <path>/var/tmp</path> ya que los
ebuilds se construyen ahí. Pero se puede establecer una trayectoria 
alternativa si insiste en tener <path>/var</path> montado en modo
<c>noexec</c>.
</note>
</body>
</section>
</chapter>

<chapter>
<title>Limitaciones de usuario/grupo</title>
<section id="limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
El control de uso de recursos puede ser muy efectivo para prevenir
denegaciones de servicio locales o limitar el máximo de entradas
permitidas a un grupo o usuario.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Si quiere establecer <c>nproc</c> o <c>maxlogins</c> a 0, quizás sea
mejor borrar el usuario. En el ejemplo anterior se configura el grupo
<c>dev</c> para procesos, fichero core y <c>maxlogins</c>. El resto se
configura con el valor predeterminado.
</p>

<note>
<path>/etc/security/limits.conf</path> forma parte del paquete PAM y
será sólo aplicable a paquetes que utilicen PAM.
</note>
</body>
</section>

<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> es muy similar al fichero de limitaciones
<path>/etc/security/limits.conf</path>. Las únicas diferencias son el
formato y que sólo trabaja con usuarios o comodines (no
grupos). Echemos un vistazo a una configuración de ejemplo:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Aquí establecemos la configuración por defecto y una configuración
específica para el usuario kn. Limits forma parte del paquete
sys-apps/shadow. No es necesario configurar ningún límite en este
archivo si usted ha deshabilitado <c>pam</c> en <path>make.conf</path>
o no ha configurado PAM correctamente.
</p>
</body>
</section>

<section>
<title>Cuotas</title>
<body>

<warn>
Asegúrese que los sistemas de ficheros con los que trabaja soportan
cuotas. Para utilizarlas con ReiserFS debe parchear su kernel con los
parches disponibles en <uri link="ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">Namesys</uri>. Las herramientas de usuario están disponibles en <uri link="http://www.sf.net/projects/linuxquota/">El proyecto Linux Cuota
de Disco</uri>. Hasta que las cuotas no estén operativas con ReiserFS,
debería encontrar otras alternativas mientras trate de
utilizarlas. ¡Está avisado!
</warn>

<p>
Establecer cuotas en un sistema de ficheros restringe el uso de disco
en un esquema por usuario o por grupo. Las cuotas se habilitan en el
kernel y se añaden a un punto de montaje en
<path>/etc/fstab</path>. La opción del kernel se habilita en la
configuración del kernel en <c>File systems->Quota
support</c>. Aplique la siguiente configuración, recompile el kernel y
reinicie usando el nuevo kernel.
</p>

<p>
Empiece instalando cuotas con <c>emerge quota</c>. Entonces modifique
el <path>/etc/fstab</path> y añada <c>usrquota</c> y <c>grpquota</c> a
las particiones en las que quiera restringir el uso de disco, como en
el ejemplo siguiente.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
En cada partición en la que haya establecido las cuotas, cree los
ficheros de cuota (<path>aquota.user</path> y <path>aquota.group</path>)
y guárdelos en la raíz de la partición.
</p>

<pre caption="Crear los ficheros de cuota">
# <i>touch /tmp/aquota.user</i>
# <i>touch /tmp/aquota.group</i>
# <i>chmod 600 /tmp/aquota.user</i>
# <i>chmod 600 /tmp/aquota.group</i>
</pre>

<p>
Este paso debe hacerse en cada partición en la que se hayan activado
las cuotas. Después de añadir y configurar los ficheros de cuota,
necesitamos añadir el guión <c>quota</c> al nivel de ejecución boot.
</p>

<pre caption="Añadir cuotas al nivel de ejecución boot">
# <i>rc-update add quota boot</i>
</pre>

<p>
Ahora configuraremos el sistema para comprobar las cuotas una vez a la
semana añadiendo la siguiente línea a <path>/etc/crontab</path>:
</p>

<pre caption="Añadir la comprobación de cuotas en crontab">
0 3 * * 0 /usr/sbin/quotacheck -avug.
</pre>

<p>
Después de reiniciar la máquina, es el momento para establecer las
cuotas de usuarios y grupos. <c>edquota -u kn</c> ejecutará el editor
definido en $EDITOR (por defecto es nano) y le permitirá editar la
cuotas para el usuario kn. <c>edquota -g</c> hará lo mismo para los
grupos.
</p>

<pre caption="Configurando las cuotas para el usuario kn">
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
 inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Para más detalles lea <c>man edquota</c> o el <uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Quota mini
howto</uri>.
</p>
</body>
</section>

<section>
<title>/etc/login.defs</title>
<body>

<p>
Si las políticas de seguridad indican que los usuarios deben cambiar
su contraseña cada dos semanas, cambie el valor <c>PASS_MAX_DAYS</c> a
14 y <c>PASS_WARN_AGE</c> a 7. Es recomendable que use la caducidad de
contraseñas puesto que los ataques por fuerza bruta permiten encontrar
cualquier contraseña, es sólo cuestión de tiempo. También le alentamos
a que establezca <c>LOG_OK_LOGINS</c> a sí.
</p>
</body>
</section>

<section>
<title>/etc/login.access</title>
<body>

<p>
El fichero <path>login.access</path> también pertenece al paquete
sys-apps/shadow, que proporciona una tabla de control de acceso. La
tabla se usa para controlar quien puede y quien no puede acceder
basándose en el nombre de usuario, nombre de grupo o nombre de
host. Por defecto, todos los usuarios del sistema tienen permitido
hacer login por lo que el fichero consiste sólo en comentarios y
ejemplos. Si usted está asegurando su servidor o estación de trabajo,
le recomendamos que configure este fichero para que nadie más que
usted (el administrador) tenga acceso a la consola.
</p>

<note>
Esta configuración no se aplica al usuario root.
</note>

<p/>
<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<p/>
<impo>
Tenga cuidado cuando configure estas opciones, puesto que ciertos
errores podrán impedirle acceder a la máquina si usted no tiene acceso
de root.
</impo>

<p/>
<note>
Estas configuraciones no se aplican a SSH, puesto que SSH no ejecuta
por defecto <c>/bin/login</c>. Pero se puede habilitar usando
<c>UseLogin yes</c> en <path>/etc/ssh/sshd_config</path>.
</note>

<p>
Esto permitirá a los miembros del grupo wheel el acceso local o desde
el dominio gentoo.org. Puede que sea paranoico, pero mejor prevenir
que curar.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Permisos de ficheros</title>
<section>
<title>Lectura para todos</title>
<body>

<p>
Los usuarios normales no deberían tener acceso a los archivos de
configuración o contraseñas. Un atacante puede robar contraseñas de
bases de datos o sitios web y usarlos para alterar --o incluso peor,
borrar-- datos. Por esto es importante que los permisos de ficheros
sean correctos. Si usted está seguro que un archivo sólo es usado por
root, asígnele los permisos <c>0600</c> y asigne el usuario correcto
al fichero con <c>chown</c>.
</p>
</body>
</section>

<section>
<title>Escritura para todos/grupos</title>
<body>
<pre caption="Buscando ficheros y directorios con escritura para todos">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Esto creará un fichero enorme con los permisos de todos los archivos
que tienen tanto permiso de escritura para el grupo a para
todos. Verifique los permisos y elimine los permisos de escritura para
todos ejecutando <c>/bin/chmod o-w</c> en cada fichero.
</p>
</body>
</section>

<section>
<title>Ficheros SUID/SGID</title>
<body>

<p>
Los ficheros con el bit SUID o SGID habilitado se ejecutan con los
privilegios del usuario o grupo <e>propietario</e> y no del usuario
que ejecuta el archivo. Normalmente esos bits se usan en archivos que
necesitan ejecutarse como root para hacer su labor. Esos archivos
pueden provocar un compromiso de root (si contienen agujeros de
seguridad). Los ficheros con el bit SUID o SGID activado resultan
peligrosos y deberían ser evitados a toda costa.  Si usted no usa
estos ficheros utilice en ellos <c>chmod 0</c> o desinstale (unmerge)
el paquete de donde provienen (verifique a qué paquete pertenecen
usando <c>equery</c>; si todavía no lo tiene instalado simplemente
escriba <c>emerge gentoolkit</c>). En cualquier caso, basta desactivar
el bit SUID con <c>chmod -s</c>.
</p>

<pre caption="Buscando ficheros setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Esto creará un archivo conteniendo la lista de los ficheros
SUID/SGID.
</p>

<pre caption="Listado de los binarios setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Por defecto, Gentoo Linux no tiene muchos ficheros SUID (aunque
depende de lo que haya instalado), pero usted debería obtener una
lista similar a la anterior. Muchos de los comandos no deben ser
utilizados por los usuarios normales, sólo por root. Desactive el bit
SUID en <c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>,
<c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> y
<c>traceroute</c> usando <c>chmod -s</c> en cada fichero. No desactive
el bit en <c>su</c>, <c>qmail-queue</c> o
<c>unix_chkpwd</c>. Desactivar setuid de estos ficheros le impedirá
hacer 'su' y recibir correo. Desactivando el bit (donde es seguro
hacerlo) usted elimina la posibilidad de que un usuario normal (o un
atacante) consiga acceso de root a través de estos archivos.
</p>
<p>
Los únicos ficheros SUID que tengo en mi sistema són <c>su</c>,
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c>
y <c>pwdb_chkpwd</c>. Pero si usted está ejecutando X, necesita tener
alguno más, puesto que X necesita el privilegiado acceso proporcionado
por SUID.
</p>
</body>
</section>
<section>
<title>Binarios SUID/SGID y enlaces rígidos</title>
<body>
<p>
Sólo se considera borrado un fichero cuando no tiene más enlaces apuntándole. Esto podría sonar un poco raro, pero tenga en cuenta que un nombre de fichero como <path>/usr/bin/perl</path> es actualmente un enlace a el inodo donde los datos están almacenados. Cualquier número de enlaces puede apuntar al fichero, y sólo hasta el último de ellos no desaparezca, el fichero continua existiendo.
</p>
<p>
Si sus usuarios tienen acceso a una partición que no está montada con <c>nosuid</c> o <c>noexec</c> (por ejemplo, si <path>/tmp</path>, <path>/home</path> o <path>/var/tmp</path> no están en particiones separadas) debe tener cuidado asegurándose que sus usuarios no creen enlaces rígidos (hardlinks, en inglés) a binarios SUID o SGID, porque después que Portage los haya actualizado, los usuarios continuarían teniendo acceso a las versiones antiguas.
</p>
<warn>
Si ha recibido una advertencia de Portage acerca de que quedan enlaces rígidos, y sus usuarios pueden escribir en una partición que permita la ejecución de ficheros SUID/SGID, deberá leer esta sección cuidadosamente.Uno de sus usuarios podría intentar burlar una actualización manteniendo una versión antigua de un programa. Si sus usuarios no crean sus propios ficheros SUID, o sólo pueden ejecutar programas mediante el cargador dinámico (particiones montadas como <c>noexec</c>), no tiene por qué preocuparse.
</warn>
<note>
Los usuarios no necesitan acceso de lectura a un fichero para enlazarlo, sólo necesitan permiso de lectura al directorio que lo contiene.
</note>
<p>
Para comprobar cuantos enlaces a ficheros tiene, puede usar el comando <c>stat</c>.
</p>
<pre caption="Comando stat" >
$ stat /bin/su
  File: `/bin/su'
  Size: 29350           Blocks: 64         IO Block: 131072 regular file
Device: 900h/2304d      Inode: 2057419     Links: 1
Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2005-02-07 01:59:35.000000000 +0000
Modify: 2004-11-04 01:46:17.000000000 +0000
Change: 2004-11-04 01:46:17.000000000 +0000
</pre>
<p>
Para encontrar los ficheros SUID y SGID con múltiples enlaces, puede usar <c>find</c>.
</p>
<pre caption="Buscar binarios suid/sgid multi-enlazados" >
$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls
</pre>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM es un conjunto de librerías compartidas que proporcionan una forma
alternativa para la autentificación de usuarios en los programas. El
parámetro USE <c>pam</c> está activado por defecto. Los parámetros de
PAM en Gentoo Linux son bastante razonables, pero siempre se puede
mejorar. Primero instale cracklib.
</p>

<pre caption="Instalación de cracklib">
# <i>emerge cracklib</i>
</pre>

<p/>
<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Lo que añadirá cracklib y obligará a los usuarios a que utilicen una
contraseña con un mínimo de 8 caracteres y que contenga como mínimo 2
números, 2 caracteres de otro tipo y que hayan al menos 3 caracteres
distintos respecto a la última contraseña. Lo que fuerza al usuario a
elegir una buena contraseña (política de contraseñas). Revise la
documentación de <uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri> para más opciones.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Cada servicio no configurado con un fichero PAM en
<path>/etc/pam.d</path> utilizará las reglas de
<path>/etc/pam.d/other</path>. Los parámetros por defecto se
establecen a <c>deny</c>, como debería ser. Pero me gusta tener muchos
logs y esto es por lo que he añadido <c>pam_warn.so</c>. La última
configuración es <c>pam_limits</c> que está controlada por
<path>/etc/security/limits.conf</path>. Mire <uri link="#limits_conf">la sección /etc/security/limits.conf</uri> para más detalles acerca
de estas opciones.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>
</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
Esta es una forma de controlar el acceso a los servicios normalmente
ejecutados por inetd (del que Gentoo no dispone) pero que también
puede ser usado por xinetd y otros servicios.
</p>

<note>
El servicio debería ejecutar tcpd en su argumento de servidor (en
xinetd). Vea el capítulo de xinetd para más información.
</note>

<p/>
<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<p/>
<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Como puede ver el formato es muy similar al de
<path>/etc/login.access</path>. Tcpd soporta un servicio específico;
no se solapa con <path>/etc/login.access</path>. Estas configuraciones
sólo se aplican a los servicios que utilizan tcp wrappers.
</p>

<p>
También es posible ejecutar comandos cuando se accede a un servicio
(puede ser usado cuando se activa el reenvío de llamadas entrantes de
usuarios) pero no se recomienda, puesto que se tiende a crear más
problemas de los que está tratando de resolver. Un ejemplo podría ser
cuando configura un guión (&quot;script&quot;) para enviar un mensaje
cada vez que alguien entre en un regla de denegación (deny rule),
entonces un atacante puede lanzar un ataque de denegación de servicio
(DoS) que busque activar dicha regla de denegación. Esto creará un
montón de I/O y mensajes. Por tanto ¡no lo haga! Lea <c>man 5
hosts_access</c> para más información.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Seguridad del Kernel</title>
<section>
<title>Eliminado funcionalidad</title>
<body>

<p>
La regla básica cuando se configura el kernel es eliminar todo lo que
no se necesite. Esto no creará sólo un kernel pequeño sino también
eliminará las vulnerabilidades que puedan encontrarse en drivers y
otras características.
</p>

<p>
Considere también desactivar el soporte para módulos cargables. Aunque
incluso es posible añadir &quot;root kits&quot; sin esta
característica activada, se hace más difícil para los atacantes
normales instalar &quot;root kits&quot; sin poder hacerlo a través de
módulos del kernel.
</p>
</body>
</section>

<section>
<title>El sistema de ficheros proc</title>
<body>

<p>
Muchos de los parámetros del kernel pueden cambiarse a través del
sistema de ficheros <path>/proc</path> o usando <c>sysctl</c>.
</p>

<p>
Para cambiar dinámicamente parámetros y variables del núcleo al vuelo
necesita tener definido <c>CONFIG_SYSCTL</c> en el kernel. Lo que está
activado por defecto en un kernel 2.4 estándar.
</p>

<p>
Asegúrese que IP forwarding está desactivado. Sólo lo queremos en un
equipo que tenga más de una conexión de red (&quot;multi-homed
host&quot;). Le advertimos que active o desactive este parámetro antes
que cualquier otro, puesto que también activa/desactiva otros
parámetros.
</p>

<pre caption="Descartar los paquetes de ping">
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Esto hará que el kernel simplemente ignore todos los mensajes de ping
(también conocidos como mensajes ICMP tipo 0). La razón para hacer
esto está en que el paquete IP que lleva el mensaje ICMP puede
contener información distinta de la que debería. Los administradores
usan ping como una herramienta de diagnóstico y frecuentemente se
quejan si se deshabilita, pero no hay ninguna razón para que alguien
desde fuera pueda mandar un ping. Sin embargo, a veces puede ser
práctico que desde dentro sí se puedan hacer pings, entonces lo que
puede hacer es deshabilitar el ICMP tipo 0 en el cortafuegos
(permitiendo continuar utilizando esta herramienta a los
administradores locales).
</p>

<pre caption="Ignorar pings de broadcast">
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Esto deshabilita la respuesta a &quot;broadcasts&quot; ICMP y
prevendrá de ataques &quot;Smurf&quot;. El ataque Smurf consiste en
enviar un ICMP tipo 0 (ping) a la dirección de broadcast de una
red. Por regla general el atacante usará una dirección de origen
falseada (&quot;spoofed&quot;). Todos los ordenadores de la red
responderán al mensaje de ping y de ese modo inundarán al host cuya
dirección se ha falsificado.
</p>

<pre caption="Deshabilitar paquetes enrutados desde el origen">
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
No acepte paquetes enrutados desde el origen. Los atacantes pueden
usar enrutamiento desde el origen para generar tráfico que pretende
ser originado dentro de su red, pero que es actualmente enrutando
hacia el origen por el camino por el que ha venido, de esta forma los
atacantes pueden comprometer su red. El enrutamiento desde el origen
es raramente utilizado para fines legítimos, por ello es seguro
desactivarlo.
</p>

<pre caption="Deshabilitar la aceptación de redirección">
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
# <i>/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/conf/all/secure_redirects</i>
</pre>

<p>
No acepte paquetes de redirección ICMP. La redirección ICMP puede ser
usada para alterar sus tablas de enrutamiento, posiblemente con una
una mala finalidad.
</p>

<pre caption="Protección contra mensajes de error falsos">
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Habilite la protección contra respuestas de mensajes de error falsos.
</p>

<pre caption="Activar el filtrado inverso de paths">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
/bin/echo &quot;1&quot; > $i/rp_filter
done</i>
</pre>

<p/>
<p>
Active el filtrado inverso para trayectorias. Esto ayuda a estar
seguros que los paquetes usan una dirección de origen legítima
rechazando automáticamente los paquetes entrantes si la entrada
correspondiente a la dirección origen en la tabla de enrutamiento no
coincide con la interfaz de red por la que llegan. Lo cual tiene
ventajas de seguridad porque previene el falseamiento de IP (&quot;IP
spoofing&quot;). Necesitamos activarlo en cada
<path>net/ipv4/conf/*</path>, puesto que en caso contrario la
validación del origen no es totalmente funcional.
</p>

<warn>
No obstante, activar el filtrado inverso de paths puede ser un
problema si usted utiliza el enrutamiento asimétrico (los paquetes que
usted envía a un host toman un camino diferente que los paquetes que
le envía a usted ese host) o si opera en un host que no enruta y que
tiene varias direcciones IP en distintas interfaces.
</warn>

<p/>
<pre caption="Registre todos los paquetes falsificados (spoofed), enrutados en el origen y paquetes de redirección">
# <i>/bin/echo &quot;1&quot; > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Registre todos los paquetes falsificados (spoofed), enrutados en el
origen y paquetes de redirección.
</p>

<p>
Todos estos ajustes se perderán cuando la máquina se reinicie. Le
sugiero que los añada a <path>/etc/sysctl.conf</path> el cual es
automáticamente inicializado por el guión de inicio
<path>/etc/init.d/bootmisc</path>.
</p>

<p>
La sintaxis para <path>/etc/sysctl.conf</path> es bastante
simple. Elimine el <path>/proc/sys/</path> de los paths anteriormente
mencionados y sustituya <path>/</path> por <path>.</path>:
</p>

<pre caption="Trasladando a sysctl.conf">
  <comment>(Uso manual de echo):</comment>
/bin/echo &quot;0&quot; > /proc/sys/net/ipv4/ip_forward

<comment>(Automático en sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>
</body>
</section>

<section>
<title>Grsecurity</title>
<body>

<p>
El parche de <uri link="http://grsecurity.net">Grsecurity</uri> es un
estándar en las fuentes del kernel de Gentoo pero está deshabilitado
por defecto. Configure su kernel como lo hace normalmente y luego
configure las opciones de Grsecurity. Una explicación en profundidad
de las opciones disponibles en Grsecurity (versión 1.9) está
disponible en la página del proyecto <uri link="/proj/en/hardened">Gentoo Hardened</uri>.
</p>

<p>
Las recientes <c>grsec-sources</c> proporcionan la versión 2.* de
Grsecurity. Para más información de este parche de Grsecurity
mejorado, por favor consulte la documentación disponible en <uri link="http://www.grsecurity.net/">Grsecurity homepage</uri>.
</p>
</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> es un parche que
añade cifrado al kernel existente. Parcheando el kernel conseguiremos
nuevas opciones como cifradores criptográficos, algoritmos digest y
bucles de filtros criptográficos.
</p>

<warn>
Actualmente el parche kerneli no es una versión estable en el último
kernel, por tanto tenga cuidado cuando lo use.
</warn>
</body>
</section>

<section>
<title>Otros parches para el kernel</title>
<body>

<ul>
  <li>
  <uri link="http://www.openwall.com">El proyecto OpenWall</uri>
  </li>
  <li>
  <uri link="http://www.lids.org">Sistema de detección de intrusos en Linux</uri>
  </li>
  <li>
  <uri link="http://www.rsbac.org">Conjunto de reglas de control de acceso</uri>
  </li>
  <li>
  <uri link="http://www.nsa.gov/selinux">Mejoras de seguridad en el kernel de la NSA (agencia de seguridad estadounidense)</uri>
  </li>
  <li>
  <uri link="http://sourceforge.net/projects/wolk/">Wolk</uri>
  </li>
</ul>

<p>
Y probablemente haya bastantes más.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Asegurando los servicios</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) viene con un más que decente fichero de configuración
pero todavía necesitamos mejorar algunas cosas, como enlazar Apache a
una dirección y prevenir fugas de información. A continuación se
describen las opciones que debería aplicar en el fichero de
configuración:
</p>

<p>
Si usted no deshabilita <c>ssl</c> en su <path>/etc/make.conf</path>
antes de instalar Apache, debería tener habilitado el acceso al
servidor mediante ssl. Sólo tiene que añadir la siguiente línea para
activarlo:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS=&quot;-D SSL&quot;
</pre>

<p/>
<pre caption="/etc/apache/conf/apache.conf">
#Indica si escucha en su ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#No es una buena idea usar nobody o nogroup
#en cualquier servicio que no corra como root
#(basta añadir el usuario apache con el grupo apache)
User apache
Group apache
#Le indica a apache que no revele la versión
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache está compilado con <c>--enable-shared=max</c> y
<c>--enable-module=all</c>. Esto activará por defecto todos los
módulos, así que puede &quot;comentar&quot; todos los módulos en la
sección<c>LoadModule</c> (<c>LoadModule</c> y <c>AddModule</c>) que no
use. Reinicie el servicio ejecutando <c>/etc/init.d/apache
restart</c>.
</p>

<p>
Puede encontrar más información en <uri>http://www.apache.org</uri>.
</p>
</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
Puede encontrar información en <uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri>. El Manual de referencia del administrador en BIND 9
lo puede encontrar también en <path>doc/arm</path>.
</p>

<p>
Los nuevos &quot;ebuilds&quot; de BIND soportan el chrooting fuera del
entorno. Después de instalar (emerge) <c>bind</c> siga estos sencillos
pasos:
</p>

<pre caption="Chrooting BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`&quot;
<comment>(Antes de ejecutar el comando anterior debe tratar de cambiar)</comment>
<comment>(el directorio de chroot en /etc/conf.d/named.)</comment>
<comment>(En caso contrario será usado /chroot/dns.)</comment>
<comment>(Puede necesitar sustituir el número de versión por el número de versión actual.)</comment>
</pre>
</body>
</section>

<section>
<title>Djbdns</title>
<body>

<p>
Djbdns es una implementación de DNS en cuya seguridad su autor está
dispuesto a apostar <uri link="http://cr.yp.to/djbdns/guarantee.html">dinero</uri>. Trabaja de forma muy diferente a Bind 9 pero vale la
pena probarlo. Puede obtener más información en
<uri>http://www.djbdns.org</uri>.
</p>
</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Generalmente, usar FTP (File Transfer Protocol) es una mala
idea. Porque no cifra los datos (por ejemplo, las contraseñas circulan
en texto claro), escucha en dos puertos (normalmente el 20 y el 21), y
los atacantes buscan frecuentemente accesos anónimos para intercambiar
warez. Puesto que protocolo FTP tiene varios problemas de seguridad,
debería utilizar en su lugar <c>sftp</c> o HTTP . Si no lo hace,
asegure tan bien como pueda sus servicios y prepárese.
</p>
</body>
</section>

<section>
<title>Mysql</title>
<body>

<p>
Si sólo necesita que las aplicaciones locales accedan a la base de
datos <c>mysql</c> &quot;descomente&quot; la siguiente línea en
<path>/etc/mysql/my.cnf</path>.
</p>
<pre caption="Deshabilitar el acceso de red">
skip-networking
</pre>

<p>
Luego, deshabilitemos el uso del comando LOAD DATA LOCAL INFILE.Lo que
nos prevendrá contra la lectura no autorizada de ficheros
locales. Esto toma relevancia cuando se encuentran nuevas
vulnerabilidades de Inyección SQL en PHP.
</p>

<pre caption="Deshabilitar LOAD DATA LOCAL INFILE en la sección [mysqld]">
set-variable=local-infile=0
</pre>

<p>
A continuación, vamos a borrar la base de datos de ejemplo (test) y
todas las cuentas excepto la cuenta local de <c>root</c>.
</p>

<pre caption="Borrando la base de datos de ejemplo y todos los usuarios innecesarios">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host=&quot;localhost&quot; and user=&quot;root&quot;);</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Tenga cuidado con lo anterior si usted previamente ya ha configurado
cuentas de usuario.
</warn>

<note>
Si ha cambiado las contraseñas desde la línea de introducción de comandos de MySQL deberá borrar siempre <path>~/.mysql_history</path> y <path>/var/log/mysql/mysql.log</path> puesto que almacenan los comandos SQL ejecutados con las contraseñas en texto claro.
</note>
</body>
</section>

<section>
<title>Proftpd</title>
<body>

<p>
Proftpd ha tenido bastantes problemas de seguridad, pero parece que se
han resuelto muchos de ellos. Aún así, es buena idea aplicar algunas
mejoras:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName &quot;My ftp daemon&quot;
# No muestre la identidad del servidor
ServerIdent on &quot;Go away&quot;

# Hace más fácil crear usuarios virtuales
RequireValidShell off

# Use unos ficheros de contraseñas y grupos alternativos (passwd usa cifrado)
AuthUserFile &quot;/etc/proftpd/passwd&quot;
AuthGroupFile &quot;/etc/proftpd/group&quot;

# Permisos
Umask 077

# Timeouts y limitaciones
MaxInstances 30
MaxClients 10 &quot;Only 10 connections allowed&quot;
MaxClientsPerHost 1 &quot;You have already logged on once&quot;
MaxClientsPerUser 1 &quot;You have already logged on once&quot;
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# Chroot todo el mundo
DefaultRoot ~

# No lo ejecute como root
User  nobody
Group nogroup

# Registre cada transacción
TransferLog /var/log/transferlog

# Problemas con globbing
DenyFilter \*.*/
</pre>

<p>
Puede encontrar más documentación en
<uri>http://www.proftpd.org</uri>.
</p>
</body>
</section>

<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd es una variante del trollftpd original, modificado por Frank
Dennis por razones de seguridad y funcionalidad.
</p>

<p>
Utilice usuarios virtuales (nunca cuentas del sistema) habilitando la
opción <c>AUTH</c>. Configure esto con
<c>-lpuredb:/etc/pureftpd.pdb</c> y cree sus usuarios mediante
<c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH=&quot;-lpuredb:/etc/pureftpd.pdb&quot;

## Misc. Others ##
MISC_OTHER=&quot;-A -E -X -U 177:077 -d -4 -L100:5 -I 15&quot;
</pre>

<p>
Configure la opción <c>MISC_OTHER</c> para no permitir accesos anónimos (<c>-E</c>), hacer chroot para todos (<c>-A</c>), para que los usuarios no puedan leer o escribir en los archivos que empiezan por . (punto) (<c>-X</c>), el tiempo máximo 'idle' (<c>-I</c>), el límite de recursión (<c>-L</c>), y una razonable <c>umask</c>.
</p>

<warn>
¡<e>No</e> use las opciones <c>-w</c> or <c>-W</c>! Si usted quiere
tener un sitio de warez, ¡no lea más esta guía!
</warn>

<p>
Puede encontrar más documentación en
<uri>http://www.pureftpd.org</uri>.
</p>
</body>
</section>

<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (siglas de &quot;very secure ftp&quot;, ftp realmente seguro)
es un pequeño demonio ftp que se ejecuta con una razonable
configuración por defecto. Es sencillo y no tiene algunas de las
características de pureftp o proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#sólo escritura
write_enable=NO

#permite el registro de transacciones
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Como puede ver, no hay forma en este servicio de tener permisos individuales, pero cuando se prepara con una configuración anónima es bastante bueno. Algunas veces es bueno tener un ftp anónimo (para compartir programas de código abierto) y entonces vsftpd hace muy buen papel.
</p>
</body>
</section>

<section>
<title>Qmail</title>
<body>

<p>
Qmail está frecuentemente considerado como un servidor de correo muy
seguro. Está escrito pensando en la seguridad (y en la paranoia). Por
defecto no permite el reenvío y no ha tenido un sólo agujero de
seguridad desde 1996. ¡Simplemente instálelo con <c>emerge qmail</c>
y configúrelo! 
</p>
</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
Samba es un protocolo para compartir ficheros con redes Microsoft y
Novell y <e>no</e> debería usarse a través de Internet. Aún así,
continua necesitando ser asegurado.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Enlace a una interface
  interfaces = eth0 10.0.0.1/32

  #Indica el uso de contraseñas cifradas
  encrypt passwords = yes
  directory security mask = 0700

  #Permite el tráfico desde 10.0.0.*
  hosts allow = 10.0.0.

  #Habilita el modo de autentificación por usuario
  #(no use el modo compartido)
  security = user

  #Deshabilita las cuentas con privilegios
  invalid users = root @wheel

  #Tamaño máximo que smb muestra para un recurso compartido
  #(no es un límite)
  max disk size = 102400

  #Política de contraseñas
  min password length = 8
  null passwords = no

  #Uso de PAM (si se ha añadido su soporte)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Asegúrese que los permisos están correctamente establecidos en cada
recurso compartido y recuerde leer la <uri link="http://www.samba.org">documentación</uri>.
</p>

<p>
Ahora reinicie el servidor y añada los usuarios que deban tener acceso
a este servicio. Esto se hace mediante el comando
<path>/usr/bin/smbpasswd</path> con el parámetro -a.
</p>
</body>
</section>

<section>
<title>ssh</title>
<body>

<p>
La única seguridad que OpenSSH necesita es habilitar la
autentificación fuerte basada en cifrado de clave pública. Demasiados
sitios (como <uri>http://www.sourceforge.net</uri>,
<uri>http://www.php.net</uri> y<uri>http://www.apache.org</uri>) han
sufrido accesos no autorizados debidos a filtraciones de contraseñas o
a malas contraseñas.
</p>

<pre caption="/etc/ssh/sshd_config">
#Sólo habilitar la versión 2
Protocol 2

#No permitir el acceso directo a root
PermitRootLogin no

#Habilitar la autentificación de clave pública
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Deshabilitar los ficheros .rhost y la autentificación normal con contraseña
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

#Sólo los usuarios en los grupos wheel o admin pueden obtener acceso
AllowGroups wheel admin

#En dichos grupos sólo permite el acceso de los siguienes usuarios
#El @&lt;nombre_de_dominio> es opcional, pero reemplaza la
#anterior directiva AllowHosts
AllowUsers kn@gentoo.org bs@gentoo.org

#Añadir registro de actividad
SyslogFacility AUTH
LogLevel INFO

#Enlace
ListenAddress 127.0.0.1
</pre>

<p>
Verifique también que no tiene <c>UsePAM yes</c> en su fichero de configuración porque sobreescribe el mecanismo de autentificación de clave pública.
</p>

<p>
Ahora todo lo que sus usuarios tienen que hacer es crear una clave (en
el ordenador desde el que se van a conectar) usando el comando
siguiente:
</p>

<pre caption="Crea un par de claves DSA">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Y teclear una contraseña-frase (passphrase).
</p>

<pre caption="Salida de ssh-keygen">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Pulse enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Escriba la frase de paso]</i>
Enter same passphrase again: <i>[Vuelva a escribir la frase de paso]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Esto añadirá dos archivos a su directorio <path>~/.ssh/</path>,
llamados <path>id_dsa</path> y <path>id_dsa.pub</path>. El archivo
<path>id_dsa</path> es su clave privada y debe ser accesible sólo por
usted. El otro fichero <path>id_dsa.pub</path> debe ser distribuido en
cada servidor al cual tenga acceso. Añada la clave en el directorio
home del usuario en <path>~/.ssh/authorized_keys</path> y el usuario
debería ser capaz de hacer login.
</p>

<p>
Ahora, sus usuarios deberían salvaguardar su clave privada
convenientemente. Poniéndola en un dispositivo que ellos lleven
siempre encima o dejarla en su estación de trabajo (añada esto a las
políticas de <uri link="#security_policies">Contraseñas</uri>).
</p>

<p>
Para más información visite la página web de <uri link="http://www.openssh.org">OpenSSH</uri>.
</p>
</body>
</section>

<section>
<title>Uso de xinetd</title>
<body>

<p>
xinetd es un sustituto de <c>inetd</c> (del cual no dispone Gentoo),
el demonio de servicios de Internet. Soporta control de acceso basado
en la dirección del host remoto y el tiempo de acceso. También
proporciona extensas posibilidades de log, incluyendo una hora de
arranque del servidor, dirección de host remoto, nombre de usuario
remoto, tiempo de ejecución del servidor, y acciones solicitadas.
</p>

<p>
Como en todos los demás servicios es importante tener una buena
configuración por defecto. Pero desde el momento que <c>xinetd</c> se
ejecuta como root y soporta protocolos que puede que usted no conozca
como funcionan, le recomendamos que no lo utilice. Pero si a pesar de
todo lo quiere utilizar, aquí le explicamos como puede añadirle algo
de seguridad:
</p>

<pre caption="Instale xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Y edite el fichero de configuración:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps    = 25 30
}

# Esto configurará pserver (cvs) via xinetd con los siguientes parámetros:
# un máximo de 10 instancias (10 conexiones simultáneas)
# limita pserver a conexiones tcp solamente
# utiliza el usuario cvs para ejecutar este servicio
# enlaza una sola dirección IP en las interfaces de red
# permite el acceso desde 10.0.0.*
# limita el tiempo que los desarrolladores pueden usar cvs: desde 8am a 5pm
# usa tcpd wrappers (control de acceso especificado en 
# <i>/etc/hosts.allow</i> y <i>/etc/hosts.deny</i>)
# la carga máxima del sistema se establece a 1.0
# el disable flag está a no por defecto, pero preferimos tenerlo
# en caso de querer desactivarlo
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>
<p>
Para más información consulte <c>man 5 xinetd.conf</c>.
</p>
</body>
</section>

<section>
<title>X</title>
<body>

<p>
Por defecto Xorg está configurado para actuar como un servidor
X. Esto puede resultar peligroso puesto que X usa conexiones TCP no
cifradas y está a la escucha para clientes X.
</p>

<impo>
Si usted no necesita este servicio, ¡deshabilítelo!
</impo>

<p>
Pero si piensa usar su estación de trabajo como servidor X use el
comando <c>/usr/X11R6/bin/xhost</c> con precaución. Este comando
permite a clientes desde otros hosts conectarse y usar su pantalla. Lo
que puede ser práctico si usted necesita una aplicación X de un equipo
diferente y la única manera de utilizarla es a través de la red, pero
lo que también puede permitir ser aprovechado por un atacante. La
sintaxis es <c>/usr/X11R6/bin/xhost +nombre_de_host</c>
</p>

<warn>
¡No use nunca la opción <c>xhost +</c>! Esto permitirá a cualquier
cliente conectarse y tomar el control de sus X. Si un atacante puede
tener acceso a sus X, puede registrar lo que teclee y tomar el control
de su escritorio. Recuerde especificar siempre un host si usted debe
utilizarlo.
</warn>

<p>
Un solución más segura es deshabilitar completamente esta
característica arrancando X con <c>startx -- -nolisten tcp</c> o
deshabilitándola permanentemente en la configuración.
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs=&quot;-nolisten tcp&quot;
</pre>

<p>
Para asegurarse de que <path>startx</path> no será sobreescrito al
'emerger' una nueva versión de Xorg debe protegerlo. Añada la
siguiente línea a <path>/etc/make.conf</path>:
</p>

<pre caption="/etc/make.conf">
CONFIG_PROTECT_MASK=&quot;/usr/X11R6/bin/startx&quot;
</pre>

<p>
Si usted usa un gestor gráfico de login necesitará cambiar otros
archivos.
</p>

<p>
Para <c>gdm</c> (Gnome Display Manager):
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Para <c>xdm</c> (X Display Manager) y <c>kdm</c> (Kde Display
Manager):
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Chroot o servidores virtuales</title>
<section>
<title>Chrooting</title>
<body>

<p>
Hacer chroot a un servicio es la manera de limitar el entorno de un
servicio (o usuario) para que acceda sólo a lo que debería y para que
no escale acceso (o consiga información) que le permita un acceso de
root. Ejecutando el servicio como un usuario distinto de <c>root</c>
(<c>nobody</c>, <c>apache</c>, <c>named</c>) un atacante sólo podrá
acceder a los ficheros con permisos para dicho usuario. Lo que
significa que un atacante no conseguirá el acceso de root incluso si
los servicios tuvieran algún defecto de seguridad.
</p>

<p>
Algunos servicios como <c>pure-ftpd</c> y <c>bind</c> tienen
características para hacer chroot, pero otros no. Si el servicio lo
soporta, úselo, si no usted tiene que saber como crearse el suyo
propio. Veamos como crear un chroot. Para una comprensión elemental de
como trabaja un chroot, vamos a probarlo con <c>bash</c> (la manera
fácil de aprenderlo)
</p>

<p>
Cree el directorio <path>/chroot</path> (<c>mkdir chroot</c>). Y
averigüe con qué librerías dinámicas está compilado <c>bash</c> (este
paso no es necesario si está compilado con <c>-static</c>).
</p>

<p>
El siguiente comando creará una lista con las librerías usadas por
bash.
</p>

<pre caption="Obtener la lista de librerías usadas">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Ahora creemos el entorno para bash.
</p>

<pre caption="Crear el entorno chroot para bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Luego copie los ficheros usados por <c>bash</c> (<path>/lib</path>) al
directorio <path>lib</path> del chroot y copie también el comando bash
al directorio <path>bin</path> del chroot. Esto creará exactamente el
mismo entorno, pero con menos funcionalidad. Después de copiarlo
pruébelo:<c>chroot /chroot/bash /bin/bash</c>. Si obtiene un prompt
indicado <path>/</path> ¡funciona! En caso contrario le informará
adecuadamente de qué fichero falta. Algunas librerías compartidas
dependen unas de otras.
</p>

<p>
Se dará cuenta que dentro del chroot sólo funciona <c>echo</c>. Esto
ocurre porque no tenemos otros comandos dentro del entorno chroot que
no sean bash y <c>echo</c> que es una funcionalidad incorporada.
</p>

<p>
Esta es básicamente la manera en la que usted podría crear un servicio
ejecutado con chroot. La única diferencia es que los servicios a veces
depende de servicios y ficheros de configuración en
<path>/etc</path>. Simplemente cópielos (los dispositivos pueden
copiarse con <c>cp -a</c>) en el entorno de chroot, edite el guión de
inicio init para que use chroot antes de ejecutarlo. Puede resultar
difícil encontrar qué dispositivos y ficheros de configuración
necesita un servicio. Para esto es práctico el comando
<c>strace</c>. Inicie el servicio en bash con <c>/usr/bin/strace</c> y
busque los open, read, stat y puede que connect. Lo que le dará una
pista de qué ficheros copiar. Pero en muchos casos basta copiar el
fichero de contraseñas (passwd) (edite la copia y borre los usuarios
que no tienen nada que ver con el servicio), <path>/dev/zero</path>,
<path>/dev/log</path> y <path>/dev/random</path>.
</p>
</body>
</section>

<section>
<title>User Mode Linux</title>
<body>

<p>
Otra forma de crear un entorno más seguro es ejecutar una máquina
virtual. Una máquina virtual, como su nombre implica, es un proceso
que se ejecuta en el nivel más alto de su sistema operativo real,
proporcionando un entorno de hardware y sistema operativo que parece
ser el propio de una única máquina. Su beneficio de seguridad está en
que si es comprometido el servidor ejecutado en la máquina virtual,
sólo se ve afectado este servidor virtual no la instalación padre.
</p>

<p>
Para más información acerca de como instalar User Mode Linux consulte <uri link="http://www.gentoo.org/doc/en/uml.xml">User Mode Linux Guide</uri>.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Cortafuegos</title>
<section>
<title>Acerca de los cortafuegos</title>
<body>

<p>
Mucha gente piensa a menudo que un cortafuegos (firewall) es la máxima
expresión de la seguridad, pero están equivocados. En muchos casos un
cortafuegos mal configurado da menos seguridad que no tener uno
instalado. Un cortafuegos también es un componente de software y
debería tratarse de la misma manera que cualquier otro software,
porque puede contener agujeros de seguridad.
</p>

<p>
¡Así que piénselo antes de implementar un cortafuegos! ¿Realmente lo
necesita? Si cree que lo necesita, escriba una política sobre cómo
debería funcionar, qué tipo de cortafuegos, y cómo debería
operar. Pero primero lea esta guía.
</p>

<p>
Los cortafuegos se usan con dos propósitos:
</p>

<ul>
  <li>Para mantener a los usuarios (gusanos/atacantes) fuera</li>
  <li>Para mantener a los usuarios (empleados/niños) dentro</li>
</ul>

<p>
Básicamente hay tres tipos de cortafuegos:
</p>

<ul>
  <li>Filtrado de paquetes</li>
  <li>Circuit relay</li>
  <li>Aplicación de puerta de enlace</li>
</ul>

<p>
Un cortafuegos debería ser una máquina dedicada que no ejecute otros
servicios (<c>sshd</c> es el único) y asegurada tal como recomienda
esta guía.
</p>
</body>
</section>

<section>
<title>Filtrado de paquetes</title>
<body>

<p>
Todo el tráfico de la red se transmite como paquetes. Grandes
cantidades de tráfico se dividen en paquetes pequeños para un mejor
manejo y se juntan cuando llegan a su destino. La cabecera de cada
paquete contiene la información de cómo y dónde debe ser entregado. Y
estas informaciones son exactamente las que un cortafuegos de filtrado
de paquetes utiliza. El filtrado se basa en:
</p>

<ul>
  <li>Permitir o denegar los paquetes basados en la dirección IP
  origen/destino</li>
  <li>Permitir o denegar los paquetes basados en un puerto de
  origen/destino</li>
  <li>Permitir o denegar los paquetes basados en un protocolo</li>
  <li>Permitir o denegar los paquetes basados en parámetros
  específicos del protocolo</li>
</ul>

<p>
En otras palabras, este filtrado se fundamenta en la información de la
cabecera del paquete y no en su contenido.
</p>

<p>
Debilidades:
</p>

<ul>
  <li>
  La dirección de un paquete puede ser potencialmente falsa (o como se
  suele decir <e>spoofed</e>) por el remitente</li>
  <li>
  Los datos o peticiones contenidos en un paquete permitido pueden
  contener datos no esperados que el atacante puede usar para explotar
  fallos en servicios en el cortafuegos o a través de él 
  </li>
  <li>Normalmente es un punto único de fallo</li>
</ul>

<p>
Ventajas:
</p>

<ul>
  <li>Simple y fácil de implementar</li>
  <li>Puede avisar de posibles ataques antes de que ocurran (por
  ejemplo detectando sondeos de puertos)</li>
  <li>Son buenos para parar ataques SYN</li>
</ul>

<p>
Ejemplos de cortafuegos de filtrado de paquetes libres en Linux:
</p>
<ul>
  <li>
  <uri link="http://www.iptables.org">Iptables</uri>
  </li>
  <li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
  </li>
  <li>
  <uri link="http://www.smoothwall.org">SmoothWall</uri>
  </li>
</ul>

<!--FIXME: should SmoothWall really be included, since it uses iptables?-->

<note>
Se recomienda utilizar iptables. Ipchains es obsoleto.
</note>
</body>
</section>

<section>
<title>Circuit relay</title>
<body>

<p>
Un circuito de nivel de puerta de enlace es un cortafuegos que valida
las conexiones antes de permitir el intercambio de datos. Esto
significa que simplemente no permite o deniega paquetes basándose en
su cabecera si no que determina si la conexión entre los dos extremos
es válida de acuerdo a las reglas configuradas antes de abrir una
sesión y permitir que los datos sean intercambiados. El filtrado está
basado en:
</p>

<ul>
  <li>Dirección IP de origen/destino</li>
  <li>Puerto de origen/destino</li>
  <li>Periodo de tiempo</li>
  <li>Protocolo</li>
  <li>Usuario</li>
  <li>Contraseña</li>
</ul>

<p>
Todo el tráfico es validado y monitorizado, y el tráfico no deseado se
descarta.
</p>

<p>
Debilidades:
</p>

<ul>
  <li>
  Opera en la Capa de Trasporte y puede requerir una modificación
  sustancial en el programa que normalmente provee de las funciones de 
  transporte.</li>
</ul>
</body>
</section>

<section>
<title>Aplicación de puerta de enlace</title>
<body>

<p>
La pasarela de aplicación de puerta de enlace es un &quot;proxy&quot;
para aplicaciones, que intercambian datos con los sistemas remotos en
nombre de sus clientes. Suele estar a salvo detrás de una DMZ
(&quot;zona desmilitarizada&quot;: la porción de una red privada que
es visible a través del cortafuegos) o de un cortafuegos que no
permite conexiones desde el exterior. El filtrado está basado en:
</p>

<ul>
  <li>Permitir o denegar basándose en direcciones IP del origen/destino</li>
  <li>Basándose en el contenido del paquete</li>
  <li>Limitar el acceso a ficheros basándose en su tipo o su extensión</li>
</ul>

<p>
Ventajas:
</p>

<ul>
  <li>Puede hacer &quot;cache&quot; de archivos, incrementando el rendimiento de red</li>
  <li>Detallado registro de todas las conexiones</li>
  <li>Crece bien (algunos proxys de servidores pueden
&quot;compartir&quot; los datos en cache)</li>
  <li>No hay acceso directo desde el exterior</li>
  <li>Pueden alterar el contenido del paquete al vuelo</li>
</ul>

<p>
Debilidades:
</p>

<ul>
  <li>La configuración es compleja</li>
</ul>

<p>
Las aplicaciones de pasarela están consideradas la mejor solución
segura puesto que no tienen que ser ejecutadas como root y los hosts
tras ellos no son accesibles desde Internet.
</p>

<p>
Ejemplo de una aplicación de pasarela libre:
</p>

<ul>
  <li>
  <uri link="http://www.squid-cache.org/">Squid</uri>
  </li>
</ul>
</body>
</section>

<section>
<title>Iptables</title>
<body>

<p>
Para poner en funcionamiento iptables, tiene que estar habilitado en
el kernel. Yo lo he añadido como módulo (el comando <c>iptables</c> lo
cargará como se necesita) y he recompilado mi núcleo (pero puede
compilarlo embebido, si quiere deshabilitar los Módulos Cargables del
Núcleo como se indicaba anteriormente). Para más información al
respecto de como configurar su kernel para iptables vea a <uri link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables Tutorial Chapter 2: Preparations</uri>. Después de que haya
compilado su nuevo kernel (o mientras lo compila) tiene que añadir el
comando <c>iptables</c> . Simplemente con <c>emerge iptables</c> ya
debería funcionar.
</p>

<p>
Ahora compruebe que funciona ejecutando <c>iptables -L</c>. Si falla,
algo está mal y deberá revisar su configuración una vez más.
</p>

<p>
Iptables es el nuevo y fuertemente mejorado filtro de paquetes en el
kernel de Linux 2.4.x. Es el sucesor del anterior filtro de paquetes
ipchains del kernel de linux 2.2.x. Una de las más grandes mejoras es
que iptables es capaz de realizar filtrado de estado de paquetes. Con
el filtrado de estado es posible mantener el registro de cada conexión
TCP establecida.
</p>

<p>
Una conexión TCP consiste en una serie de paquetes que contienen
información respecto la dirección IP origen, la IP de destino, puerto
de origen, puerto de destino, y un número de secuencia para que los
paquetes puedan juntarse sin perder datos. TCP es un protocolo
orientado a la conexión en contraste a UDP que es &quot;sin
conexión&quot;.
</p>

<p>
Examinando la cabecera del paquete TCP, un filtro de estado de
paquetes puede determinar si un paquete TCP recibido es parte de una
conexión ya establecida o no y decidir si aceptarlo o rechazarlo.
</p>

<p>
Es posible engañar a un filtro de paquetes que no verifique el estado
de los mismos para que acepte paquetes que deberían ser desechados si
se manipula la cabecera del paquete TCP. Esto puede hacerse alterando
el indicador SYN u otros indicadores en la cabecera TCP para fabricar
un paquete malicioso que parezca formar parte de una conexión
establecida (puesto que el filtro de paquetes por si mismo no hace un
seguimiento de la conexión). Con un filtro de estado de paquetes es
posible descartar aquellos paquetes que no formen parte de una
conexión ya establecida. Esto detendrá también la posibilidad de
&quot;escaneos pasivos&quot;, un tipo de exploración de puertos en la
cual quien realiza la exploración envía paquetes con indicadores que
están lejos de ser registrados por un cortafuegos ordinario.
</p>

<p>
Iptables proporciona otras prestaciones como NAT (Network Address
Translation) y limitación de tasas. La limitación de tasas es muy
práctica para prevenir ciertos ataques DoS (&quot;Denial of
Service&quot;, denegación de servicio) como las inundaciones SYN
(&quot;SYN floods&quot;)
</p>

<p>
Una conexión TCP se establece con una &quot;conversación en tres
fases&quot;. Para iniciar la conexión TCP la parte de cliente envía un
paquete al servidor con el flag SYN habilitado. Cuando el servidor
recibe el paquete con el SYN responde enviando un paquete SYN+ACK de
vuelta al cliente. Entonces el SYN+ACK es recibido en el cliente que
responde con un tercer paquete ACK reconociendo la conexión.
</p>

<p>
Un ataque de inundación SYN se realiza enviando paquetes SYN de forma
que no se responda el correspondiente paquete SYN+ACK. El cliente
puede crear un paquete con una dirección IP origen falsa puesto que no
necesita la respuesta. El sistema del servidor añadirá una entrada en
la cola de las conexiones pendientes de establecer cuando se reciba el
paquete SYN y esperará a recibir el paquete final ACK antes de borrar
esta entrada de la cola. La cola tiene un número limitado de
posiciones (slots) y si todas estas posiciones están ocupadas no podrá
abrir nuevas conexiones. Si el paquete ACK no se recibe antes de un
tiempo determinado la entrada se borrará automáticamente de la
cola. Este tiempo de espera es variable, pero normalmente es de 30 a
60 segundos o incluso más.  La parte de cliente inicia el ataque
enviando gran número de paquetes SYN con diferentes IP origen y
enviándolos a la IP objetivo todo lo rápido que pueda y de ese modo
llenará la cola de las conexiones pendientes de establecer y por tanto
impedirá que otros clientes establezcan una conexión legítima con el
servidor.
</p>

<p>
Aquí es donde la limitación de tasas se vuelve útil. Es posible
limitar la tasa de paquetes SYN aceptados usando <c>-m limit --limit
1/s</c>. Esto limitará el número de paquetes SYN aceptados a uno por
segundo y por tanto evitará el riesgo de inundaciones SYN en nuestros
equipos.
</p>

<note>
Otra opción para prevenir inundaciones SYN es <uri link="http://cr.yp.to/syncookies.html">SYN cookies</uri>, que permite a su ordenador responder a paquetes SYN sin llenar el espacio de la cola de conexiones. Las galletas (cookies) SYN pueden ser habilitadas en la configuración del Núcleo de Linux, pero hoy en día todavía están consideradas como experimentales.
</note>

<p>
¡Ahora algunas prácticas!
</p>

<p>
Cuando iptables se activa en el kernel proporciona 5 lugares donde
especificar las reglas. Estos lugares se llaman <c>INPUT</c>,
<c>OUTPUT</c>, <c>FORWARD</c>, <c>PREROUTING</c> y
<c>POSTROUTING</c>. Cada uno de ellos es a su vez una cadena que
consiste en una serie de reglas. Cada regla especifica una cabecera de
paquete con la que compararse, después indica qué hacer con el
paquete. Si la regla no coincide con el paquete se consulta la
siguiente regla en la cadena.
</p>

<p>
Usted puede añadir reglas directamente en estas 5 cadenas principales
o crear nuevas cadenas y añadirlas como si fueran reglas a una cadena
existente. Iptables admite las siguientes opciones.
</p>

<table>
  <tr>
  <th>Opción:</th>
  <th>Descripción:</th>
  </tr>
  <tr>
  <ti>-A</ti>
  <ti>Añadir</ti>
  </tr>
  <tr>
  <ti>-D</ti>
  <ti>Borrar</ti>
  </tr>
  <tr>
  <ti>-I</ti>
  <ti>Insertar</ti>
  </tr>
  <tr>
  <ti>-R</ti>
  <ti>Reemplazar</ti>
  </tr>
  <tr>
  <ti>-L</ti>
  <ti>Listar</ti>
  </tr>
  <tr>
  <ti>-F</ti>
  <ti>Borra todas las reglas de una o de todas las cadenas</ti>
  </tr>
  <tr>
  <ti>-Z</ti>
  <ti>Pone a cero los contadores en una o en todas las cadenas</ti>
  </tr>
  <tr>
  <ti>-C</ti>
  <ti>Verifica ese paquete en la cadena</ti>
  </tr>
  <tr>
  <ti>-N</ti>
  <ti>Crea una nueva cadena definida por el usuario</ti>
  </tr>
  <tr>
  <ti>-X</ti>
  <ti>Borra una cadena definida por el usuario</ti>
  </tr>
  <tr>
  <ti>-P</ti>
  <ti>Cambia la forma de actuar de una cadena respecto un objetivo</ti>
  </tr>
  <tr>
  <ti>-E</ti>
  <ti>Cambia el nombre de la cadena</ti>
  </tr>
  <tr>
  <ti>-p</ti>
  <ti>Protocolo</ti>
  </tr>
  <tr>
  <ti>-s</ti>
  <ti>Dirección o máscara de origen</ti>
  </tr>
  <tr>
  <ti>-d</ti>
  <ti>Dirección o máscara de destino</ti>
  </tr>
  <tr>
  <ti>-i</ti>
  <ti>Nombre de entrada (nombre ethernet)</ti>
  </tr>
  <tr>
  <ti>-o</ti>
  <ti>Nombre de salida (nombre ethernet)</ti>
  </tr>
  <tr>
  <ti>-j</ti>
  <ti>Salto (objetivo de la regla)</ti>
  </tr>
  <tr>
  <ti>-m</ti>
  <ti>Coincidencia extendida (puede usar una extensión)</ti>
  </tr>
  <tr>
  <ti>-n</ti>
  <ti>Salida numérica para las direcciones y puertos</ti>
  </tr>
  <tr>
  <ti>-t</ti>
  <ti>Tabla a manipular</ti>
  </tr>
  <tr>
  <ti>-v</ti>
  <ti>Modo de información detallada</ti>
  </tr>
  <tr>
  <ti>-x</ti>
  <ti>Expande los números (muestra valores exactos)</ti>
  </tr>
  <tr>
  <ti>-f</ti>
  <ti>Sólo hacer coincidir el segundo fragmento o posteriores</ti>
  </tr>
  <tr>
  <ti>-V</ti>
  <ti>Versión de paquete</ti>
  </tr>
  <tr>
  <ti>--line-numbers</ti>
  <ti>Muestra los números de línea al listar</ti>
  </tr>
</table>

<p>
Primero trataremos de bloquear todos los paquetes ICMP en nuestra
máquina, sólo para familiarizarnos con iptables.
</p>

<pre caption="Bloquear todos los paquetes ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Primero indicamos la cadena o regla donde debe ser añadida, después el
protocolo de los paquetes, y finalmente el destino. El destino puede
ser el nombre de una cadena definida por el usuario o uno de los
siguientes <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>,
<c>QUEUE</c>, <c>MASQUERADE</c>. En este ejemplo usamos <c>DROP</c>
que desechará el paquete sin responder al cliente.
</p>

<note>
El destino <c>LOG</c> es del tipo conocido como
&quot;non-terminating&quot;. Si un paquete concuerda con una regla con
el destino <c>LOG</c>, en lugar de para la evaluación, el paquete
continua siendo comparado con las otras reglas. Esto le permite
registrar el paquete mientras se se procesa con normalidad.
</note>

<p>
Ahora intente <c>ping localhost</c>. No recibirá ninguna respuesta
puesto que iptables desechará todos los paquetes ICMP entrantes. No
podrá hacer ping a otras máquinas puesto que los paquetes ICMP de
respuesta también son desechados. Ahora elimine la cadena para
permitir el tráfico ICMP de nuevo.
</p>

<pre caption="Elimina todas las reglas">
# <i>iptables -F</i>
</pre>

<p>
Ahora veamos el filtrado de paquetes de estado en iptables. Si
buscamos activar una inspección de estado en los paquetes entrantes en
eth0, podríamos activarlo con el comando:
</p>

<pre caption="Acepta paquetes originados en una conexión entrante o ya establecida">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Esto aceptará cualquier paquete de una conexión ya establecida o con
relación a la cadena INPUT. Usted también puede desechar cualquier
paquete que no esté en la tabla de estado indicando <c>iptables -A
INPUT -i eth0 -m state --state INVALID -j DROP</c> justo antes del
comando anterior. Esto habilita el filtrado de estado de paquetes en
ipetables cargando la extensión &quot;estate&quot;. Si quiere permitir
a otros conectarse a su máquina puede usar el indicador <c>--state
NEW</c>. Iptables contiene algunos módulos con propósitos
diversos. Algunos de ellos son:
</p>

<table>
  <tr>
  <th>Módulo/Concordancia</th>
  <th>Descripción</th>
  <th>Opciones extendidas</th>
  </tr>
  <tr>
  <ti>mac</ti>
  <ti>Comprueba la extensión para los paquetes que provienen de esa dirección mac.</ti>
  <ti>--mac-source</ti>
  </tr>
  <tr>
  <ti>state</ti>
  <ti>Activa la inspección de estado</ti>
  <ti>--state (los estados son ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
  <ti>limit</ti>
  <ti>Limitación de tasas</ti>
  <ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
  <ti>owner</ti>
  <ti>Intenta comparar varias características del creador de los paquetes</ti>
  <ti>--uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner sessionid</ti>
  </tr>
  <tr>
  <ti>unclean</ti>
  <ti>Varios chequeos aleatorios en los paquetes</ti>
  <ti/>
  </tr>
</table>

<p>
Intentemos crear una cadena definida por el usuario y añadirla a una
de las ya existentes:
</p>

<pre caption="Creación de una cadena definida por el usuario">
  <comment>(Creamos una nueva cadena con una regla)</comment>
# <i>iptables -X micadena</i>
# <i>iptables -N micadena</i>
# <i>iptables -A micadena -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
  <comment>(El comportamiento por defecto es permitir todo el tráfico saliente. El entrante es desechado.)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
  <comment>(Y la añadimos a la cadena INPUT)</comment>
# <i>iptables -A INPUT -j micadena</i>
</pre>

<p>
Aplicando la regla a la cadena input obtenemos la política: Se permite
todos los paquetes salientes y se desechan todos los entrantes.
</p>

<p>
Puede encontrar más documentación en <uri link="http://www.iptables.org/documentation/index.html#HOWTO">Documentación sobre netfilter/iptables</uri>.
</p>

<p>
Veamos ahora un ejemplo completo. En este caso el comportamiento de mi
cortafuegos/puerta de enlace indica:
</p>

<ul>
  <li>Sólo se permiten las conexiones hacia el cortafuegos a través de
SSH (puerto 22)</li>
  <li>La red local debe tener acceso a HTTP, HTTPS y SSH (DNS puede
también permitirse)</li>
  <li>El tráfico ICMP puede contener carga no deseada y no debe ser
permitido. Por supuesto deberemos permitir cierto tráfico ICMP</li>
  <li>Los sondeos de puertos deben ser detectados y registrados</li>
  <li>Los ataques SYN deben ser prevenidos</li>
  <li>El tráfico restante debe ser desechado y registrado</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#interior
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#exterior
OIP=217.157.156.144
OINTERFACE=eth1

opts=&quot;${opts} showstatus panic save restore showoptions rules&quot;

depend() {
  need net
}

rules() {
  stop
  ebegin &quot;Estableciendo las reglas internas&quot;

  einfo &quot;Estableciendo la regla por defecto para drop&quot;
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # Regla por defecto
  einfo &quot;Creando las cadenas de estado&quot;
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      &quot;Bad packet from ${IINTERFACE}:&quot;
  $IPTABLES -A allowed-connection -j DROP

  # Tráfico ICMP
  einfo &quot;Creando la cadena icmp&quot;
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix &quot;Bad ICMP traffic:&quot;
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # Tráfico entrante
  einfo &quot;Creando la cadena para el tráfico ssh entrante&quot;
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Protección &quot;Flood&quot;
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  # Tráfico saliente
  einfo &quot;Creando la cadena para el tráfico ssh saliente&quot;
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo &quot;Creando la cadena para el tráfico DNS saliente&quot;
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo &quot;Creando la regla para el tráfico http/https saliente&quot;
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # Detección de scanners de puertos
  einfo &quot;Creando la cadena de detección de scanner de puertos&quot;
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix &quot;NMAP-XMAS:&quot; 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix &quot;XMAS:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix &quot;XMAS-PSH:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix &quot;NULL_SCAN:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix &quot;SYN/RST:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix &quot;SYN/FIN:&quot;
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Aplicando y añadiendo estados no válidos a las cadenas
  einfo &quot;Aplicando cadenas en INPUT&quot;
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo &quot;Aplicando cadenas en FORWARD&quot;
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo &quot;Aplicando cadenas en OUTPUT&quot;
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # Permite a los clientes enrutar a través de NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin &quot;Iniciando el cortafuegos&quot;
  if [ -e &quot;${FIREWALL}&quot; ]; then
    restore
  else
    einfo &quot;${FIREWALL} no existe. Usando las reglas por defecto.&quot;
    rules
  fi
  eend $?
}

stop() {
  ebegin &quot;Parando el cortafuegos&quot;
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin &quot;Estatus&quot;
  $IPTABLES -L -n -v --line-numbers
  einfo &quot;Estatus NAT&quot;
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin &quot;Estableciendo reglas 'panic'&quot;
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin &quot;Guardando las reglas del cortafuegos&quot;
  $IPTABLESSAVE > $FIREWALL
  eend $?
}

restore() {
  ebegin &quot;Restaurando las reglas del cortafuegos&quot;
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo &quot;Usage: $0 {start|save|restore|panic|stop|restart|showstatus}&quot;
  echo &quot;start)      restaura si existe y si no fuerza las reglas&quot;
  echo &quot;stop)       elimina todas las reglas y lo permite todo&quot;
  echo &quot;rules)      fuerza el establecimiento de nuevas reglas&quot;
  echo &quot;save)       gruada la configuración en ${FIREWALL}&quot;
  echo &quot;restore)    restaura la configuración desde ${FIREWALL}&quot;
  echo &quot;showstatus) muestra el estatus&quot; 
}
</pre>

<p>
Algunos consejos para cuando cree un cortafuegos:
</p>

<ol>
  <li>Cree su política de cortafuegos antes de implementarlo</li>
  <li>Hágalo simple</li>
  <li>Conozca cómo trabajan los protocolos (lea lo más relevante de <uri link="http://www.ietf.org/">RFC</uri> (Request For Comments))</li>
  <li>Tenga bien presente que un cortafuegos sólo es otro software
ejecutándose como root</li>
  <li>Compruebe su cortafuegos</li>
</ol>

<p>
Si piensa que iptables es difícil de comprender o le lleva mucho
tiempo configurar un cortafuegos decente, puede usar <uri link="http://www.shorewall.net">Shorewall</uri>. Básicamente utiliza
iptables para generar las reglas del cortafuegos, pero se concentra en
reglas y no en protocolos específicos.
</p>
</body>
</section>

<section>
<title>Squid</title>
<body>

<p>
Squid es un servidor proxy muy potente. Puede filtrar el tráfico
atendiendo a: tiempo, expresiones regulares en la ruta/URI, dirección
IP de origen y destino, dominio, navegador, nombre de usuario
autentificado, mime-type y número de puerto (protocolo). Probablemente
olvido algunas características, pero puede ser pesado cubrir aquí la
lista entera de características.
</p>

<p>
En el ejemplo siguiente he añadido un filtrado de pancartas
(&quot;banners&quot;) en lugar de un filtro basado en sitios porno. La
razón de esto es que Gentoo.org <e>no</e> debe ser catalogado como un
sitio pornográfico. Y yo no quiero malgastar mi tiempo intentando
buscar algunos buenos sitios para usted.
</p>

<p>
En este caso, mi política de acceso es:
</p>

<ul>
  <li>La navegación (HTTP/HTTPS) está permitida durante las horas de trabajo (lunes a viernes de 8 a 17 y sábado de 8 a 13 horas), si alguien está más tarde debería trabajar, no navegar.</li>
  <li>No está permitido descargar ficheros (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg, etc.)</li>
  <li>No nos gustan las pancartas, por lo que son filtradas y reemplazadas por un gif transparente (¡aquí es donde puede ser creativo!)</li>
  <li>Cualquier otra conexión hacia o desde Internet no está permitida</li>
</ul>

<p>
Esto se implementa en 4 pasos <e>fáciles</e>.
</p>

<pre caption="/etc/squid/squid.conf">
# Enlaza con una IP y un puerto
http_port 10.0.2.1:3128

# Configuración standard 
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Añade listas de control de acceso básico
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Añade quien puede acceder a este servidor proxy
acl localnet src 10.0.0.0/255.255.0.0

# Y los puertos
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Añade una lista de control de acceso basada en
# expresiones regulares mediante urls
acl archives urlpath_regex &quot;/etc/squid/files.acl&quot;
acl url_ads url_regex &quot;/etc/squid/banner-ads.acl&quot;

# Añade una lista de control de acceso basada en día y hora
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Permite el acceso administrativo desde localhost
http_access allow manager localhost
http_access deny manager

# Solo permite purgar peticiones desde localhost
http_access allow purge localhost
http_access deny purge

# Deniega peticiones hacia puertos desconocidos
http_access deny !Safe_ports

# Deniega CONNECT a otros puertos distintos de SSL
http_access deny CONNECT !SSL_ports

# Mis propias reglas

# Añade una página para ser mostrada cuando
# se elimina una pancarta
deny_info NOTE_ADS_FILTERED url_ads

# Entonces lo rechaza
http_access deny url_ads

# Deniega todos los archivos
http_access deny archives

# Restringe el acceso a las horas de trabajo
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Deniega el resto
http_access deny all
</pre>
<p>
Después complete los ficheros que no quiere que sus usuarios
descarguen. Yo he indicado zip, viv, exe, mp3, rar, ace, avi, mov,
mpg, mpeg, au, ra, arj, tar, gz and z files.
</p>
<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>
<p/>

<note>
Por favor, tenga en cuenta los [ ] con mayúsculas y minúsculas en cada
carácter. Esto sirve para que alguien no se salte las reglas
accediendo a un fichero llamado AvI en lugar de avi.
</note>

<p>
Ahora vamos a añadir las expresiones regulares para identificar a las
pancartas. Probablemente usted será más creativo que yo:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Y como último paso, queremos que este fichero sea mostrado cuando una
pancarta sea eliminada. Básicamente es un medio archivo html con una
imagen gif transparente de 4x4 pixels.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML>
&lt;HEAD>
&lt;META HTTP-EQUIV=&quot;REFRESH&quot; CONTENT=&quot;0; URL=http://localhost/images/4x4.gif&quot;>
&lt;TITLE>ERROR: La URL solicitada no puede ser recuperada&lt;/TITLE>
&lt;/HEAD>
&lt;BODY>
&lt;H1>Anuncio filtrado&lt;/H1>
</pre>
<p/>

<note>
No cierre los tags &lt;HTML> &lt;BODY>. Eso lo hará squid.
</note>

<p>
Como puede ver, Squid tiene muchas posibilidades y es muy efectivo
tanto como filtro como proxy. Incluso se pueden usar proxies Squid
encadenados para escalar en redes muy grandes. La configuración que he
indicado aquí es muy conveniente para una pequeña red de 1 a 20
usuarios.
</p>

<p>
Pero combinar el filtrado de paquetes (iptables) y una pasarela de
aplicaciones (Squid) es probablemente la mejor solución, incluso si
Squid está ubicado en un lugar seguro y donde nadie pueda acceder
desde el exterior. Continuamos teniendo que preocuparnos de los
ataques desde dentro.
</p>

<p>
Ahora tiene que configurar los navegadores en los clientes para usar
el servidor proxy. La puerta de enlace evitará que los usuarios tengan
cualquier contacto con el exterior salvo que usen el proxy.
</p>

<note>
En Mozilla se consigue en Edición->Preferencias->Advanzadas->Proxies.
</note>

<p>
También se conseguir un proxy transparente usando iptables dirigiendo
todo el tráfico saliente a un proxy Squid. Esto se hace añadiendo una
regla de forwarding/prerouting en la pasarela:
</p>

<pre caption="Activa el portforwarding hacia nuestro servidor proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Si el proxy se está ejecutando en el host que hace el filtrado de
paquetes --y aunque que no se recomienda, puede ser necesario si no
tiene suficientes máquinas disponibles-- use un destino
<c>REDIRECT</c> en lugar de <c>DNAT</c> (<c>REDIRECT</c> dirige los
paquetes al localhost).
</note>
</body>
</section>

<section>
<title>Lecciones aprendidas</title>
<body>

<p>
Hemos aprendido esto:
</p>

<ol>
  <li>Un cortafuegos puede representar un riesgo por si mismo. Un
cortafuegos mal configurado es peor que no tenerlo</li>
  <li>Cómo configurar una pasarela básica y un proxy transparente</li>
  <li>La clave para tener un buen cortafuegos es conocer el protocolo
que queremos permitir</li>
  <li>Que el tráfico IP puede contener datos no legítimos, por ejemplo
los paquetes ICMP pueden llevar una carga oculta</li>
  <li>Cómo prevenir un ataque SYN</li>
  <li>El filtrado de tráfico HTTP quitando imágenes no adecuadas,
descargas de ficheros de virus</li>
  <li>Combinar filtros de paquetes y pasarelas de aplicaciones
proporcionan mayor control</li>
</ol>

<p>
Entonces si <e>realmente</e> necesita usted un cortafuegos, cree uno
que satisfaga sus necesidades.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Detección de intrusos</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment, Entorno Avanzado de Detección de Intrusos)</title>
<body>

<p>
AIDE es un sistema de detección de intrusos basado en host (HIDS,
Host-Based Intrusion Detection System), una alternativa libre a
Tripwire (si usted ya conoce Tripwire no debería tener dificultades
para aprender a configurar AIDE). Los HIDS se usan para detectar
cambios en los ficheros de configuración y binarios importantes,
generalmente generando un resumen cifrado (&quot;hash&quot;) único de
los ficheros a ser verificados, y almacenándolos en un lugar
seguro. Con un procedimiento regular (tal que una vez al día), los
resúmenes &quot;buenos&quot; se comparan con los generados a partir de
la copia actual de cada fichero, para determinar si el fichero ha
cambiado. Los HIDS son una gran herramienta para detectar cambios no
permitidos en un sistema, pero necesitan un poco de trabajo para
implementarlos adecuadamente y hacer un buen uso de ellos.
</p>

<p>
El fichero de configuración está basado en expresiones regulares,
macros y reglas para ficheros y directorios. Tenemos la macros
siguientes:
</p>

<table>
  <tr>
  <th>Macro</th>
  <th>Descripción</th>
  <th>Sintaxis</th>
  </tr>
  <tr>
  <ti>ifdef</ti>
  <ti>Si está definido</ti>
  <ti>@@ifdef &quot;name&quot;</ti>
  </tr>
  <tr>
  <ti>ifndef</ti>
  <ti>Si no está definido</ti>
  <ti>@@ifndef &quot;name&quot;</ti>
  </tr>
  <tr>
  <ti>define</ti>
  <ti>Define una variable </ti>
  <ti>@@define &quot;name&quot; &quot;value&quot;</ti>
  </tr>
  <tr>
  <ti>undef</ti>
  <ti>Elimina la definición de una variable</ti>
  <ti>@@undef &quot;name&quot;</ti>
  </tr>
  <tr>
  <ti>ifhost</ti>
  <ti>Si &quot;hostname&quot;</ti>
  <ti>@@ifhost &quot;hostname&quot;</ti>
  </tr>
  <tr>
  <ti>ifnhost</ti>
  <ti>Si no &quot;hostname&quot;</ti>
  <ti>@@ifnhost &quot;hostname&quot;</ti>
  </tr>
  <tr>
  <ti>endif</ti>
  <ti>Endif puede ser usado después de cualquiera de las macros
anteriores excepto define y undef</ti>
  <ti>@@endif</ti>
  </tr>
</table>

<p>
Esas macros se convierten en algo muy práctico si usted tiene más de
un sistema Gentoo y quiere usar AIDE en todos ellos, pero no todas las
máquinas ejecutan los mismos servicios o incluso tienen los mismos
usuarios.
</p>

<p>
A continuación tenemos conjuntos de marcas (&quot;flags&quot;) para
comprobar en ficheros y directorios. Son una combinación de permisos,
propiedades de archivos y resúmenes criptográficos (es decir, sumas de
control).
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Descripción</th>
  </tr>
  <tr>
  <ti>p</ti>
  <ti>permisos</ti>
  </tr>
  <tr>
  <ti>i</ti>
  <ti>inode</ti>
  </tr>
  <tr>
  <ti>n</ti>
  <ti>número de enlaces</ti>
  </tr>
  <tr>
  <ti>u</ti>
  <ti>usuario</ti>
  </tr>
  <tr>
  <ti>g</ti>
  <ti>grupo</ti>
  </tr>
  <tr>
  <ti>s</ti>
  <ti>tamaño</ti>
  </tr>
  <tr>
  <ti>b</ti>
  <ti>'block count'</ti>
  </tr>
  <tr>
  <ti>m</ti>
  <ti>mtime</ti>
  </tr>
  <tr>
  <ti>a</ti>
  <ti>atime</ti>
  </tr>
  <tr>
  <ti>c</ti>
  <ti>ctime</ti>
  </tr>
  <tr>
  <ti>S</ti>
  <ti>verifica el tamaño creciente</ti>
  </tr>
  <tr>
  <ti>md5</ti>
  <ti>suma de control md5</ti>
  </tr>
  <tr>
  <ti>sha1</ti>
  <ti>suma de control sha1</ti>
  </tr>
  <tr>
  <ti>rmd160</ti>
  <ti>suma de control rmd160</ti>
  </tr>
  <tr>
  <ti>tiger</ti>
  <ti>suma de control tiger</ti>
  </tr>
  <tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
  </tr>
  <tr>
  <ti>E</ti>
  <ti>Grupo vacío</ti>
  </tr>
  <tr>
  <ti>></ti>
  <ti>Crecimiento del fichero de log p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
Y si AIDE se compila con soporte para mhash también soporta otras
características:
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Descripción</th>
  </tr>
  <tr>
  <ti>haval</ti>
  <ti>suma de control haval</ti>
  </tr>
  <tr>
  <ti>gost</ti>
  <ti>suma de control gost</ti>
  </tr>
  <tr>
  <ti>crc32</ti>
  <ti>suma de control crc32</ti>
  </tr>
</table>

<p>
Ahora puede crear sus propias reglas basadas en los indicadores
anteriores, combinándolas tal que así:
</p>

<pre caption="Creación de un conjunto de reglas para AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Lo último que necesita para crear su propio fichero de configuración
es ver cómo añadir una regla a un fichero o directorio. para
introducir una regla, combine el nombre de fichero o directorio y la
regla. AIDE añadirá todos los archivos recursivamente a no ser que
usted especifique alguna regla alternativa.
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Descripción</th>
  </tr>
  <tr>
  <ti>!</ti>
  <ti>No añadir este fichero o directorio.</ti>
  </tr>
  <tr>
  <ti>=</ti>
  <ti>Añadir este directorio, pero sin recursividad.</ti>
  </tr>
</table>

<p>
Veamos, pues, un ejemplo completo:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# La ubicación de la base de datos a ser leída
database=file:@@{AIDEDIR}/aide.db

# La ubicación de la base de datos donde escribir
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Definición de reglas
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
En el ejemplo anterior especificamos con algunas macros donde comienza
el directorio de nivel superior y donde está el directorio de
AIDE. AIDE comprueba el fichero <path>/etc/aide/aide.db</path> cuando
comprueba la integridad de un fichero. Pero cuando actualiza o crea un
nuevo fichero almacena la información en
<path>/etc/aide/aide.db.new</path>. Esto se hace porque no se puede
sobrescribir automáticamente el antiguo fichero de base de datos. La
opción <c>report_URL</c> no está todavía implementada, pero la
intención del autor es que sea capaz de enviar correo electrónico o
quizá también ejecutar guiones (&quot;scripts&quot;).
</p>

<p>
Después de editar la configuración usted debe crear su fichero de base
de datos mediante la ejecución de <c>aide -i</c> y entonces copiar el
fichero <path>/etc/aide/aide.db.new</path> como
<path>/etc/aide/aide.db</path> y comprobar cron ejecutando <c>crontab
-e</c> como root.
</p>

<note>
Dependiendo de su CPU, velocidad de acceso a disco y los indicadores
configurados para los ficheros, el proceso puede llevar algún tiempo.
</note>

<p/>
<pre caption="Planificar aide como un trabajo de cron">
0 3   * * * /usr/bin/aide -u
</pre>

<p/>
<note>
Recuerde establecer una alias para leer los mensajes de correo para
root. En caso contrario nunca conocerá lo que está informando AIDE.
</note>

<p>
En este caso se ejecuta una vez a las 3 de la mañana. Lo he programado
de esta manera para no molestar a los usuarios mientras trabajan. Note
que estoy usando la opción <c>-u</c> (Actualización) en lugar de
<c>-C</c> (Verificación). Como <c>-u</c> comprueba también los
ficheros y no sobrescribe el fichero de base de datos original ahorra
algún tiempo porque todo lo que usted necesita hacer es copiar el
fichero cuando se detecta algún cambio. ¡Sólo compruebe los cambios
mirando si fue usted mismo quien los hizo o fue algún atacante antes
de que usted lo copiara!
</p>

<p>
Note que almacenar localmente los ficheros de base de datos tiene
algunos riesgos, puesto que los atacantes (si conocen que AIDE está
instalado) intentarán sin duda alterar el fichero de base de datos,
actualizarlo o modificar <path>/usr/bin/aide</path>. Por esto, debería
crear un CD o otro medio donde dejar una copia del fichero .db y los
binarios de AIDE.
</p>

<p>
Puede encontrar más información en la página del proyecto <uri link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>
</body>
</section>

<section>
<title>Snort</title>
<body>

<p>
Snort es un Sistema de Detección de Intrusiones de Red (Network
Intrusion Detection System, NIDS). Para instalarlo y configurarlo use
los ejemplos siguientes.
</p>

<pre caption="Añadir el usuario snort al sistema">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<p/>
<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE=&quot;full&quot;
NETWORK=&quot;10.0.0.0/24&quot;
LOGDIR=&quot;/var/log/snort&quot;
CONF=/etc/snort/snort.conf
SNORT_OPTS=&quot;-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF&quot;
</pre>

<p/>
<pre caption="/etc/snort/snort.conf">
<comment>(Step 1)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(Step 2)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(Step 3)</comment>
include classification.config

<comment>(Step 4)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<p/>
<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Más información en el sitio web de <uri link="http://www.snort.org">Snort</uri>.
</p>
</body>
</section>

<section>
<title>Detección de malware con chkrootkit</title>
<body>

<p>
Tanto HIDS como AIDE son una gran forma de detectar cambios en su
sistema, pero nunca perjudica tener otra línea de
defensas. <c>chkrootkit</c> es una utilidad que que examina los
ficheros de sistema comunes buscando rootkits --software diseñado para
esconder las acciones de un intruso y permitirle conservar el acceso--
y examina el sistema buscando trazas de registradores de teclados
(&quot;keyloggers&quot;) y otro &quot;malware&quot;. <c>chkrootkit</c>
y alternativas como <c>rkhunter</c> son herramientas prácticas, tanto
para el mantenimiento del sistema como seguimiento de un intruso tras
un ataque, sin embargo no garantizan que su sistema sea seguro.
</p>

<p>
La mejor manera para emplear <c>chkrootkit</c> como detección de
intrusos es ejecutarlo rutinariamente desde <c>cron</c>. Para empezar,
instale <path>app-admin/chkrootkit</path>. <c>chkrootkit</c> puede
ejecutarse desde la línea de comandos con el comando del mismo nombre,
o desde <c>cron</c> con un línea tal que ésta:
</p>

<pre caption="Schedule chkrootkit as a cronjob">
0 3 * * * /usr/sbin/chkrootkit
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Manteniendo el sistema actualizado</title>
<section>
<body>

<p>
Una vez que ha instalado satisfactoriamente su sistema y conseguido un
buen nivel de seguridad no lo ha hecho todo. La seguridad es un
proceso continuo; la gran mayoría de intrusiones se producen como
consecuencia de vulnerabilidades conocidas en sistemas no
actualizados. Mantener el sistema actualizado es el único y más
valioso paso que se puede dar para obtener la mejor seguridad.
</p>

<p>
Si tiene una versión reciente del <c>portage</c> instalada, primero
debe sincronizar su árbol del portage mediante <c>emerge --sync</c> y
entonces ejecutar el comando <c>glsa-check --list</c> para comprobar
si su sistema está actualizado en cuanto a la seguridad.
<c>glsa-check</c> forma parte de <c>app-portage/gentoolkit</c>.
</p>

<pre caption="Ejemplo de salida de glsa-check -l">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.
  
[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.
 
200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
  <c>glsa-check</c> es todavía experimental, por lo que si la seguridad
es realmente su máxima prioridad sería juicioso contrastar la lista
con otras fuentes.
</warn>

<p>
Todas las líneas con <c>[A]</c> y <c>[U]</c> pueden ser ignoradas casi
sin peligro ya que el sistema no está afectado por este GLSA.
</p>

<p>
Algunas personas todavía prefieren usar <c>emerge
nombre_de_paquete</c> en lugar de <c>glsa-check -f</c> por esto todos
los GLSA están listados como <c>[N]</c>.
</p>

<p>
Si usted quiere recibir un mensaje cada vez que se libera un GLSA,
subscríbase a la lista de correo <c>gentoo-announce</c>. Las
instrucciones para unirse así como otras buenas listas de correo las
pude encontrar en <uri link="/main/en/lists.xml">Gentoo Linux Mailing
List Overview</uri>.
</p>

<p>
Otro buen recurso de seguridad es <uri link="http://www.securityfocus.com/archive/1">Bugtraq
mailinglist</uri>.
</p>
</body>
</section>
</chapter>
</guide>
