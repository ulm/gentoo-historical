<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/postgres-howto.xml,v 1.1 2006/11/11 20:48:22 chiguire Exp $ -->

<guide link="/doc/en/postgres-howto.xml" lang="es">
<title>PostgreSQL Guide</title>

<author title="Autor">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Editor">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Traductor">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>


<abstract>
La intención de esta guía es mostrar la configuración básica de
PostgreSQL. La configuración descrita aquí debería ser suficiente para
usar en aplicaciones web básicas y cualquier otro programa que
proporcione soporte para PostgreSQL.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2006-03-14</date>

<chapter>
<title>Introduction</title>
<section>
<title>PostgreSQL introduction</title>
<body>

<p>
Al conversar con la mayoría de los desarrolladores acerca del uso de
distintas soluciones al manejo de bases de datos, los dos principales
manejadores de bases de datos formarán la respuesta. Una sería
<c>MySQL</c> y la otra sería la materia de este documento,
<c>PostgreSQL</c>. Las ventajas de uno sobre el otro suele traer un
debate largo y tendido, sin embargo es justo decir que PostgreSQL ha
tenido una concepción más firme de lo que supone son las verdaderas
estructuras que corresponden a un manejadore de bases de datos
relacional que MySQL. La mayoría de las características standard como
<b>FOREIGN KEY</b> fueron apenas agregados en MySQL versión 5. Sin
embargo, cualesquiera sea el caso, este documento asume que ha
seleccionado PostgreSQL como el manejador de bases de dato que va a
utilizar. El primer lugar donde comenzar es el proceso
<c>emerge</c>. En la siguiente sección, el proceso de instalación
usando emerge será descrito, al igual que la configuración básica.
</p>
</body>
</section>

<section>
<title>Instalación de PostgreSQL</title>
<body>

<p>
Para comenzar debemos primero hacer <c>emerge</c> al paquete
PostgreSQL. Para hacer esto, ejecute primero el siguiente comando para
asegurar que las opciones necesarios están correctamente configuradas:
</p>

<pre caption="Revisando las opciones para construir PostgreSQL">
# <i>emerge -pv postgresql</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +libg++ +nls +pam +perl
-pg-hier -pg-intdatetime +python +readline (-selinux) +ssl -tcltk +xml2 +zlib 0 kB
</pre>

<p>
Aquí está una lista de lo que significa cada una de las distintas opciones de construcción:
</p>

<table>
<tr>
  <th>Parámetro USE</th>
  <th>Significado</th>
</tr>
<tr>
  <ti>doc</ti>
  <ti>
    Este parámetro USE activa o desactiva la instalación de la
    documentación, aparte de las páginas man. La única buena razón
    para desactivar esta opción es si no dispone de mucho espacio en
    disco o alternativamente tiene otra forma de acceso a la
    documentación (en línea, etc.)
  </ti>
</tr>
<tr>
  <ti>kerberos</ti>
  <ti>
    Al conectarse a la base de datos con esta opción activada, el
    administrador tiene la opción de usar el sistema <c>kerberos</c>
    para autentificar los usuarios/servicios a la base de datos.
  </ti>
</tr>
<tr>
  <ti>libg++</ti>
  <ti>
    Al activar esta opción se construirán los enlaces para
    C++. Construirá libpq++ para ser utilizado para linquear con
    programas en C++.
  </ti>
</tr>
<tr>
  <ti>nls</ti>
  <ti>
    Si se activa esta opción, PostgreSQL puede utilizar cadenas
    traducidas para los usuarios que no hablan inglés.
  </ti>
</tr>
<tr>
  <ti>pam</ti>
  <ti>
    Si se activa esta opción y si el administrador la configura
    correctamente, los usuarios/servicios podrán hacer login a una
    base de datos PostgreSQL usando <c>PAM</c> (Pluggable
    Authentication Module).
  </ti>
</tr>
<tr>
  <ti>perl</ti>
  <ti>
    Si se activa esta opción se construirán los enlaces de <c>perl</c>
    para PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>pg-hier</ti>
  <ti>
    Si habilitamos esta opción, se aplicará un parche para posibilitar
    consultas jerárquicas, como las que se ven en el enunciado
    <c>CONNECT</c> en los servidores de bases de datos
    <c>Oracle</c>. Más información acerca de las consultas jerárquicas
    (en inglés) en <uri
    link="http://www.lc.leidenuniv.nl/awcourse/oracle/server.920/a96540/
    queries4a. htm">Guía de Referencia Oracle</uri>.
  </ti>
</tr>
<tr>
  <ti>pg-intdatetime</ti>
  <ti>
    Si activamos esta opción PostgreSQL soportará enteros de 64 bits.
  </ti>
</tr>
<tr>
  <ti>python</ti>
  <ti>
    Si se activa esta opción se construirán PostgreSQL con enlaces
    para <c>python</c>.
  </ti>
</tr>
<tr>
  <ti>readline</ti>
  <ti>
    Si se activa esta opción, PostgreSQL soportará la edición de línea
    de comando estilo <c>readline</c>. Esto incluye historial de
    comando e isearch.
  </ti>
</tr>
<tr>
  <ti>selinux</ti>
  <ti>
    Si activamos esta opción, se instalará una política <c>selinux</c>
    para PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>ssl</ti>
  <ti>
    Si activamos esta opción, PostgreSQL usará la librería
    <c>OpenSSL</c> para encriptar el tráfico entre clientes y
    servidores PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>tcltk</ti>
  <ti>
    Si se activa esta opción se construirá PostgreSQL con enlaces para
    <c>tcl/tk</c>.
  </ti>
</tr>
<tr>
  <ti>xml2</ti>
  <ti>
    Si activamos esta opción, se construirá soporte al estilo
    <c>XPATH</c>. Para más información acerca del soporte de XML con
    PostgreSQL, vea:
     <uri link="http://www.throwingbeans.org/tech/postgresql_and_xml.html">
    PostgreSQL and XML</uri>.
  </ti>
</tr>
<tr>
  <ti>zlib</ti>
  <ti>
    Esta opción realmente no se utiliza por PostgreSQL, sino por el
    comando <c>pg_dump</c> para comprimir las descargas de data
    producidas.
  </ti>
</tr>
</table>

<note>
El autor del parche <c>pg-hier</c> no ha continuado trabajando en el,
por lo que probablemente será removido en futuras versiones.
</note>

<p>
Una vez afinado la construcción de PostgreSQL a sus necesidades
específicas, continúe con el <c>emerge</c>:
</p>

<pre caption="Haciendo el emerge de PostgreSQL">
# <i>emerge postgresql</i>
<comment>(Esta salida ha sido recortada)</comment>
>>> /usr/lib/libecpg.so.5 -> libecpg.so.5.0
>>> /usr/bin/postmaster -> postgres
 * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell
 *
 * Execute the following command
 * emerge --config =postgresql-8.0.4
 * to setup the initial database environment.
 *
>>> Regenerating /etc/ld.so.cache...
>>> dev-db/postgresql-8.0.4 merged.
</pre>

<p>
Tal como se evidencia en la salida einfo, hay configuraciones
post-instalación que deben ser atendidas. El siguiente capítulo
tratará la configuración de PostgreSQL.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Configuración de PostgreSQL</title>
<section>
<title>Estableciendo el entorno inicial de base de datos</title>
<body>

<p>
Tal como notamos en la salida del <c>emerge</c> recién hecho, debemos
establecer el entorno inicial para las bases de datos. Sin embargo,
antes de hacer esto, debemos considerar un asunto. A diferencia de
MySQL, la contraseña del usuario "root" de PostgreSQL es la de usuario
actual, aunque el ebuild solo crea el usuario <e>no</e> la
contraseña. Así que, antes de comenzar, debemos establecer la
contraseña para el usuario postgres:
</p>

<pre caption="Estableciendo la contraseña">
# <i>passwd postgres</i>
New UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</pre>

<p>
Ahora que esto está configurado, podemos continuar con la creación del
entorno inicial para las bases de datos:
</p>

<pre caption="Configurando el entorno para las bases de datos con emerge --config">
# <i>emerge --config =postgresql-8.0.4</i>


Configuring pkg...

 * Creating the data directory ...
 * Initializing the database ...
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale C.

fixing permissions on existing directory /var/lib/postgresql/data ... ok
creating directory /var/lib/postgresql/data/global ... ok
creating directory /var/lib/postgresql/data/pg_xlog ... ok
creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok
creating directory /var/lib/postgresql/data/pg_clog ... ok
creating directory /var/lib/postgresql/data/pg_subtrans ... ok
creating directory /var/lib/postgresql/data/base ... ok
creating directory /var/lib/postgresql/data/base/1 ... ok
creating directory /var/lib/postgresql/data/pg_tblspc ... ok
selecting default max_connections ... 100
selecting default shared_buffers ... 1000
creating configuration files ... ok
creating template1 database in /var/lib/postgresql/data/base/1 ... ok
initializing pg_shadow ... ok
enabling unlimited row size for system tables ... ok
initializing pg_depend ... ok
creating system views ... ok
loading pg_description ... ok
creating conversions ... ok
setting privileges on built-in objects ... ok
creating information schema ... ok
vacuuming database template1 ... ok
copying template1 to template0 ... ok

WARNING: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the -A option the
next time you run initdb.

Success. You can now start the database server using:

    /usr/bin/postmaster -D /var/lib/postgresql/data
or
    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start

 *
 * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.
 *
</pre>

<p>
Ahora que configuramos el entorno inicial, la siguiente sección
tratará cómo verificar la instalación y configurar usuarios para que
tengan acceso a la base de datos.
</p>
</body>
</section>

<section>
<title>Configuración de base de datos PostgreSQL</title>
<body>

<p>
Ahora que configuramos PostgreSQL, es una buena idea verificar la
instalación en esta coyuntura. Primero, veamos si el servicio arranca
bien:
</p>

<pre caption="Iniciando el servicio PostgreSQL">
# <i>/etc/init.d/postgresql start</i>
* Starting PostgreSQL ...                                          [ ok ]
</pre>

<p>
Una vez verificado esto, es una buena idea agregarlo al nivel de
ejecución por defecto, para que inicie el servicio al arrancar la
máquina:
</p>

<pre caption="Agregando el servicio al nivel de ejecución default">
# <i>rc-update add postgresql default</i>
* postgresql added to runlevel default
</pre>

<p>
Ahora que el servicio ha iniciado, es hora de intentar establecer una
base de datos de prueba. Para empezar, creémos una base de datos de
prueba usando el comando <c>createdb</c>. Pasaremos la opción
<c>-U</c> para configurar el usuario (por defecto toma el nombre del
usuario actual) y la opción <c>-W</c> para solicitar la contraseña
creada anteriormente y finalmente le damos el nombre a la base de
datos que queremos crear:
</p>

<pre caption="Creando una base de datos con createdb">
$ <i>createdb -U postgres -W test</i>
Password:
CREATE DATABASE
</pre>

<p>
La base de datos fue creata exitosamente y podremos confirmar que la
base de datos puede llevar a cabo tareas básica. Seguiremos haciendo
un drop (borrando) la base de datos con el comando <c>dropdb</c> y
crearemos una nueva para usar más adelante:
</p>

<pre caption="Borrando una base de datos con dropdb">
$ <i>dropdb -U postgres -W test</i>
Password:
DROP DATABASE
</pre>

<p>
En este momento, solo el usuario postgres puede ejecutar
comandos. Obviamente este no es el tipo de configuración que uno
necesita en un entorno multi-usuario. La siguiente sección tratará el
trabajo con cuentas de suarios.
</p>
</body>
</section>

<section>
<title>Estableciendo cuentas de usuario para bases de datos</title>
<body>

<p>
Tal como mensionamos anteriormente, teniendo que hacer login como el
usuario postgres no es deseable en un entorno multi-usuario. In la
mayoría de los casos habrán varios usuarios y servicios con acceso al
servidor y cada uno tendrá distintas necesidades y permisos. Para
manejar esta sicuación se utiliza el comando <c>createuser</c>. Est
comando es una alternativa al uso de algunas consultas SQL y es más
flexible desde el punto de vista del administrador. Continuaremos
creando dos usuarios, un 'superusario' que a su vez puede agregar
otros usuarios y administrar la base de datos y un usuario normal:
</p>

<pre caption="Configurando un superuser">
<comment>(reemplace a chris con el usuario que desea usar)</comment>
$ <i>createuser -a -d -P -E -U postgres -W chris</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Listo, ya hemos creado el superusuario. La opción <c>-a</c> en la
línea de comando especifica que este usuario puede agregar otros
usuarios. La <c>-d</c> significa que puede crear otras bases de
datos. La <c>-P</c> permite ingresar una contraseña para el usuario y
la <c>-E</c> lo encriptará para fines de seguridad. Ahora probaremos
los permisos de este usuario creando un usuario normal:
</p>

<pre caption="Configurando un usuario normal">
<comment>(reemplace a chris con el usuario recién creado)</comment>
$ <i>createuser -A -D -P -E -U chris -W testuser</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
¡Éxito! Nuestro nuevo usuario fue creado usando el superusuario
previamente creado. Las opciones <c>-A</c> y <c>-D</c> hacen lo
opuesto de <c>-a</c> y <c>-d</c> y al contrario, niegan al usuario la
posibilidad de crear usuarios y bases de datos. Ahora que tenemos unos
usuarios con los cuales trabajar y cómo crear bases de datos, veremos
en el siguiente capítulo como usar una nueva base de datos.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Usando PostgreSQL</title>
<section>
<title>Estableciendo los permisos</title>
<body>

<p>
Creando una nueva base de datos, tenemos un usuario que puede crear
bases de datos y agregar otros usuarios y el principal usuario
postgres que puede hacer cualquier cosa. El usuario creado
anteriormente puede hacer login al servidor y eso es todo. En general,
los usuarios necesita insertar y recuperar datos y a veces otras
tareas. De manera que, para que este usuario nuevo pueda hacer algo,
debemos establecer los permisos adecuados. Esto se puede hacer
fácilmente pasando el parámetro <c>-O</c> al comando
<c>createdb</c>. Comenzaremos creando una nueva base de datos,
<b>MyDB</b> con nuestro superusuario cuyo dueño será el previo usuario
testuser:
</p>

<pre caption="Creando la base de datos MyDB">
$ <i>createdb -O testuser -U chris -W MyDB</i>
Password:
CREATE DATABASE
</pre>

<p>
Bien, ahora tenemos la base de datos MyDB y al usuario testuser que
tiene acceso a ella. Para probar esto, haremos login como testuser a
la nueva base de datos con el programa <c>psql</c>. Este programa es
lo usado para conectarse a una base de datos PostgreSQL desde la línea
de comando. Para establecer la conexión a la nueva base de datos
haremos:
</p>

<pre caption="Haciendo login a la base de datos MyDB como testuser">
$ <i>psql -U testuser -W MyDB</i>
Password:
Welcome to psql 8.0.4, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

MyDB=&gt;
</pre>

<p>
Ahora que testuser está conectado al la base de datos puede comenzar a
ejecutar algunos comandos. Para ir viendo cómo es el manejo de
PostgreSQL, la siguiente sección mostrará algunos de los comandos
básicos al nacegar con el cliente <c>psql</c>.
</p>
</body>
</section>

<section>
<title>Comandos básicos de PostgreSQL y creación de una tabla</title>
<body>

<p>
Los que estén acostumbrados al uso de MySQL deberían leer esta
sección. Es aquí donde se empiezan a ver las características únicas de
PostgreSQL respecto a la manera de ejecutar comando. Para empezar,
aquí presentamos una lista de comandos que discutiremos:
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Usoe</th>
  <th>Equivalente MySQL</th>
</tr>
<tr>
  <ti>\c[onnect] [DBNAME|- [USER]]</ti>
  <ti>Conecta a otra base de datos</ti>
  <ti>USE DATABASE</ti>
</tr>
<tr>
  <ti>\q</ti>
  <ti>Salir de cliente <c>psql</c></ti>
  <ti>quit</ti>
</tr>
<tr>
  <ti>\i FILE</ti>
  <ti>Ejecuta comandos del archivo <c>FILE</c></ti>
  <ti>source FILE</ti>
</tr>
<tr>
  <ti>\o [FILE]</ti>
  <ti>Envíe los resultados de la consulta al archivo <c>FILE</c></ti>
  <ti>INTO OUTFILE, pero graba todo (no solo los SELECT)</ti>
</tr>
<tr>
  <ti>\d [NAME]</ti>
  <ti>Describe una base de datos o tabla (otros ítems también)</ti>
  <ti>DESC(RIBE)</ti>
</tr>
<tr>
  <ti>\db [PATTERN]</ti>
  <ti>
    Lista las tablas disponibles que concuerden con el patrón
    <c>PATTERN</c> (a todas, si no hay patrón)
  </ti>
  <ti>SHOW TABLES</ti>
</tr>
</table>

<p>
Con la excepción de <c>\c[onnect]</c>, todos los comandos se usarán más adelante en esta sección. Hasta ahora, la base de datos está vacía y dicho esto, necesitamos insertar alguna data. Sin embargo, el primer paso para insertar data es colocarla en una tabla. En este momento no tenemos tablas en la base de datos, por lo que debemos crear una. Esto lo hacemos con el comando <c>CREATE TABLE</c>.  Crearemos una table de ítems, que contendrá los campos Product ID, Description y price:
</p>

<pre caption="Creando la tabla products">
MyDB=> CREATE TABLE products (
MyDB(&gt;   product_id SERIAL,
MyDB(&gt;   description TEXT,
MyDB(&gt;   price DECIMAL
MyDB(&gt; );
NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"
for serial column "products.product_id"
CREATE TABLE
</pre>

<p>
Puede ignorar la advertencia (NOTICE), no hay problema. Mirando la
última línea de la función, el comando <c>CREATE TABLE</c> parece
indicar que ha concluido exitosamente, sin embargo, verifiquemos que
la tabla fue creada correctamente con el comando <c>\d</c>:
</p>

<pre caption="Examinando la tabla recién creada">
MyDB=&gt; <i>\d products</i>
                                 Table "public.products"
   Column    |  Type   |                            Modifiers
-------------+---------+------------------------------------------------------------------
 product_id  | integer | not null default nextval('public.products_product_id_seq'::text)
 description | text    |
 price       | numeric |
</pre>

<p>
De hecho, la tabla fue creada exitosamente. Habiendo cumplido este
paso, debe ser poblada con data. La siguiente sección tratará este
tema.
</p>
</body>
</section>

<section>
<title>Insertando la data en la base de datos</title>
<body>

<p>
Esta sección examinará dos maneras de poblar la tabla recién creada
con data. Primero veamos el comando más básico, <c>INSERT</c>:
</p>

<pre caption="Sintaxis de INSERT">
INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)
</pre>

<p>
<c>tablename</c> contiene el nombre de la tabla a la cual insertaremos
data. (column1,column2,column3) permite especificar las columnas
específicas a las cuales insertar los
valores. VALUES(value1,value2,value3) es el listado de los
valores. Estos valores estan en el mismo orden que el orden de las
columnas (column1 recibe value1, column2 recibe value2, column3 recibe
value3). La cuenta de columnas y valores <e>debe</e> ser
igual. Continuemos e insertemos un ítem en la tabla:
</p>

<impo>
En base a mi experiencia trabajando con bases de datos desde hace
largo tiempo, personalmente recomiendo especificar los enunciados
<c>INSERT</c> exactamente de esta manera. Algunos desarrolladores a
veces cometen la equivocación de usar <c>INSERT INTO</c> sin
especificar las columnas. Esto es improductivo, como si se agregara
una nueva columna a la base de datos, causará un error si el valor de
cuenta de columnas no es igual. Debe <e>siempre</e> especificar las
columnas a no ser que esté 300% seguro que nunca agregará una columna.
</impo>

<pre caption="Insertando data en la tabla">
MyDB=&gt; <i>INSERT INTO products (description,price) VALUES('A test product', 12.00);</i>
INSERT 17273 1
</pre>

<p>
La última línea requiere algo de explicación. El retorno de un comando
insert es un OID (Object Identifier, en inglés o identificador de
objeto) y la cantidad de hileras insertadas. Los OID están algo más
allá de alcance de esta guía, pero puede obtener buena información en
el <uri
link="http://www.postgresql.org/docs/8.1/static/datatype-oid.html">manual
PostgreSQL</uri>. Ahora, en una situación donde tiene 20.000
productos, estos enunciados de inserción pueden ser algo tediosos. Sin
embargo, no todo está perdido. El comando <c>COPY</c> puede utilizarse
para insertar datos en una tabla desde un archivo o desde stdin. En
este ejemplo asumamos que dispone de un archivo csv (valores separados
por comas) que contiene el id del producto, la descripción y el
precio. El archivo se parecería algo así:
</p>

<pre caption="Archivo products.csv">
2,meat,6.79
3,soup,0.69
4,soda,1.79
</pre>

<p>
Ahora usaremos el comando <c>COPY</c> para poblar nuestra tabla con
data:
</p>

<impo>
El comando <c>COPY FROM STDIN</c> se usa porque solamente el usuario
postgres puede insertar data de un archivo (obviamente por razones de
seguridad).
</impo>

<pre caption="Usando COPY para poblar la tabla products">
MyDB=&gt; <i>COPY products FROM STDIN WITH DELIMITER AS ',';</i>
Enter data to be copied followed by a newline.
End with a backslash and a period on a line by itself.
>> <i>2,meat,6.79</i>
>> <i>3,soup,0.69</i>
>> <i>4,soda,1.79</i>
>> <i>\.</i>
</pre>

<p>
Desafortunadamente esta línea no retorna la misma información de
resultado que el enunciado <c>INSERT INTO</c>. Entonces ¿cómo sabremos
si la data fue insertada? La siguiente sección examinará cómo realizar
consultas para revisar nuestra data.
</p>
</body>
</section>

<section>
<title>Usando consultas en PostgreSQL</title>
<body>

<p>
Esta sección mostrará cómo usar el enunciado <c>SELECT</c> para
visualizar la data en nuestras tablas. El formato básico <c>SELECT</c>
es así:
</p>

<pre caption="Sintaxis de SELECT">
SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]
</pre>

<p>
Existen dos manera de seleccionar columnas. La primera usa el <c>*</c>
para seleccionar todas la columnas y la segunda especifica una lista
de columnas que desea ver. La segunda es muy práctica cuando desea
encontrar una columna específica en una lista larga. Comenzamos usando
<c>SELECT</c> con el <c>*</c> para buscar todas las columnas:
</p>

<pre caption="Visualizando la tabla products">
MyDB=&gt; <i>SELECT * FROM products;</i>
 product_id |  description   | price
------------+----------------+-------
          1 | A test product | 12.00
          2 | meat           |  6.79
          3 | soup           |  0.69
          4 | soda           |  1.79
(4 rows)
</pre>

<p>
Como vemos, todos los datos insertados anteriormente estan en la
tabla. Ahora digamos que solamente queremos ver las descripciones y el
precio y que no nos importa el id del producto. En este caso usaremos
la forma de SELECT donde podamos escoger las columnas:
</p>

<pre caption="Visualizando columnas específicas de la tabla products">
MyDB=&gt; <i>SELECT description,price FROM products;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
 soup           |  0.69
 soda           |  1.79
(4 rows)
</pre>

<p>
Ahora solo aparecen el producto y el precio, permitiéndonos enfocar
solamente en los datos más importantes. Digamos que solamente queremos
ver los ítems cuyo precio sea mayor a $2.00. Aquí es donde entra en
juego la cláusula <c>WHERE</c>:
</p>

<pre caption="Visualizando hileras específicas de la tabla products">
MyDB=&gt; <i>SELECT description,price FROM products WHERE price > 2.00;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
(2 rows)
</pre>

<p>
Ahora vemos un listdo de productos cuyo precio es mayor a $2.00,
permitiéndonos enfocar aún más en la data. Esta formas de consulta de
información son muy poderosas y pueden ayudar a crear informes
extremadamente útiles.
</p>
</body>
</section>

<section>
<title>Conclusión</title>
<body>

<p>
Esto concluye la Guía PostgreSQL. Deseo darle un gran agradecimiento a
Masatomo Nakano, el desarrollador Gentoo a cargo de mantener
PostgreSQL por su ayuda respondiendo mis preguntas. Cualquier
sugerencia acerca de esta guía puede ser enviada a
<mail>chriswhite@gentoo.org</mail>. Para información más extensa, vea
la página web de <uri
link="http://www.postgresql.org">PostgreSQL</uri>.
</p>
</body>
</section>
</chapter>
</guide>
