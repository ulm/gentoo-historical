<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/kernel-config.xml,v 1.9 2012/12/17 10:36:26 nimiux Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide lang="es">
<title>Guía de Configuración del Núcleo en Gentoo Linux</title>

<author title="Autor">
  <mail link="dsd@gentoo.org">Daniel Drake</mail>
</author>
<author title="Contribuyente">
  <mail link="curtis119@gentoo.org">Curtis Napier</mail>
</author>
<author title="Contribuyente">
  <mail link="jdr@xemoka.net">Justin Robinson</mail>
</author>
<author title="Contribuyente">
  <mail link="rane@gentoo.org">Łukasz Damentko</mail>
</author>
<author title="Editor">
  <mail link="smithj@gentoo.org">Jonathan Smith</mail>
</author>
<author title="Editor">
  <mail link="nightmorph"/>
</author>
<author title="Traductor">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>
<author title="Traductor">
  <mail link="mcklaren@gmail.com">Manuel Peral González</mail>
</author>
<author title="Traductor">
  <mail link="enrique@barbeito.org">Enrique Barbeito Garcia</mail>
</author>
<author title="Traductor">
  <mail link="nimiux"/>
</author>

<abstract>
Este documento tiene la finalidad de presentar conceptos acerca de la
configuración manual del núcleo y detallar algunos de las fallas más
comunes de configuración.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>3</version>
<date>2012-12-16</date>

<chapter>
<title>Introducción</title>
<section>
<body>

<p>
Gentoo proporciona dos maneras para manejar la instalación y
actualización del núcleo: la <e>automática</e> (con genkernel) y la
<e>manual</e>. Aunque el método automático podría ser visto como
<e>más fácil</e> para el usuario, hay un gran número de razones por
las cuales una gran proporción de usuarios Gentoo escogen configurar
su núcleo manualmente: mayor flexibilidad, menor tamaño del núcleo,
tiempos de compilación más cortos, mejor experiencia didáctica,
aburrimiento severo, etc.  etc.
</p>

<p>
Esta guía no cubre la manera automática (con genkernel). Si prefiere
usar genkernel para compilar e instalar su núcleo, diríjase a la <uri
link="/doc/es/genkernel.xml">documentación de Genkernel</uri>.
</p>

<p>
Esta guía no intenta documentar el proceso de configuración manual
desde el inicio hasta el final -- el proceso de configuración depende
en mayor grado en el sentido común y un grado de conocimiento técnico
relativamente alto acerca de su sistema. En vez de eso, este documento
introducirá los conceptos de la configuración manual y detallará los
problemas más comunes que enfrentarán los usuarios.
</p>

<p>
Este documento está escrito tomando en cuenta las versiones más
recientes del núcleo, para las arquitecturas de computadora más
comunes. Algunos detalles pueden ser distintos para núcleos más
antiguos o para arquitecturas más exóticas, pero la mayor parte del
contenido seguirá siendo relevante.
</p>

<p>
En esta coyuntura, asumiremos que tiene las fuentes del núcleo Linux
desempacadas en el disco duro (usualmente por ahí por <c>/usr/src</c>)
y esperamos que conozca cómo ingresar a la herramienta de
configuración <c>menuconfig</c> y navegar a través de su sistema de
menús. Si no se encuentra ya en esta etapa, hay otros documentos
disponibles para ayudarlo.
</p>

<ul>
  <li>
    La <uri link="/doc/es/gentoo-kernel.xml">Guía del Núcleo</uri>
    lista los paquetes de fuentes del núcleo del que disponemos
  </li>
  <li>
    La <uri link="/doc/es/kernel-upgrade.xml">Guía de Actualización
    del Núcleo</uri> explica cómo actualizar el núcleo o cambiar de un
    núcleo a otro.
  </li>
  <li>
    El <uri link="/doc/es/handbook/index.xml">Manual Gentoo</uri>
    también cubre aspectos de la instalación del núcleo.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Conceptos de Configuración</title>
<section>
<title>Lo básico</title>
<body>

<p>
El proceso general es realmente simple: se presentan una serie de
opciones categorizadas en menús individuales y sub-menús y entonces
uno selecciona el soporte de hardware y características relevantes del
núcleo para su sistema.
</p>

<p>
El núcleo incluye una <e>configuración por defecto</e>, que es
presentada la primera vez que ejecute menuconfig sobre un conjunto
particular de fuentes. Los valores por defecto son generalmente
amplios y con sentido común, lo cual significa que la mayoría de los
usuarios solamente tendrán que hacer una pequeña cantidad de cambios a
la configuración base. Si decide desactivar una opción activada por
defecto, asegúrese de comprender exactamente qué hace esa opción y las
consecuencias de su desactivación.
</p>

<p>
Si esta es su primera vez configurando un núcleo Linux, debe apuntar a
ser algo conservador: no sea demasiado aventuroso y mientras sea
posible, trate de no hacer demasiadas modificaciones a los valores por
defecto. Al mismo tiempo, tome en cuenta que hay ciertas partes de la
configuración que absolutamente deben afinarse a su sistema ¡solo para
arrancar!
</p>

</body>
</section>

<section>
<title>Inclusión vs modular</title>
<body>

<p>
La mayoría de las opciones de configuración tienen <e>tres
estados</e>: pueden no ser construidas, pueden ser construidas para
formar parte integral del núcleo (Y) o construidas como un módulo
(M). Los módulos se almacenan externamente en el sistema de archivos,
mientras que los ítems integrales forman parte de la imagen del
núcleo.
</p>

<p>
Hay una diferencia importante entre integrales y modulates: con pocas
excepciones, el núcleo no hace intento alguno de cargar módulos
externos cuando haga falta (esto se deja a cuenta del
usuario). Mientras que otras partes del sistema puedan cargar módulos
según demanda, se recomienda que construya las opciones de soporte de
hardware y características del núcleo de manera integral. El núcleo
entonces puede asegurar que la funcionalidad y soporte de hardware
estén siempre disponibles cuando hagan falta.
</p>

<p>
Por supuesto que para algunas partes de la configuración, la
construcción integral es un requerimiento absoluto. Por ejemplo, si su
partición raíz es un sistema de archivos <c>ext2</c>, el sistema no va
a arrancar si el soporte para ext2 fue construido como un módulo (ya
que el sistema tendría que buscar en la misma partición raíz para
encontrar el módulo ext2, pero no puede ver la partición raíz ¡hasta
que tenga cargado el módulo de soporte ext2 cargado!).
</p>

</body>
</section>

<section>
<title>Soporte de Hardware</title>
<body>

<p>
Más allá de detectar el <e>tipo de arquitectura</e> del sistema, la
herramienta de configuración no hace ningún intento para identificar
qué hardware está presente en el sistema. Mientras que hay una
configuración por defecto para algún soporte de hardware, es
obligatorio encontrar y seleccionar las opciones de configuración
relevantes a la configuración de hardware del sistema.
</p>

<p>
Esto simplemente requiere un conocimiento de los componentes adentro y
conectados al computado, o para que identifique estos
componentes. Para la mayoría de los componentes internos, necesita
identificar el <e>chipset</e> usado en cada uno, en vez de el nombre
de mercado del producto.
</p>

<p>
Existen algunas herramientas disponibles que pueden ser de ayuda.
<c>lspci</c> (parte del paquete <c>sys-apps/pciutils</c>) identificará
su hardware PCI y AGP, incluyendo componentes construidos en la propia
tarjeta madre. <c>lsusb</c> (del paquete <c>sys-apps/usbutils</c>)
identificará los dispositivos conectados a los puertos USB.
</p>

<p>
La situación es algo confusa por la variación de grados de
estandarización en el mundo del hardware. A no ser que haya una
verdadera desviación de las normas, los discos IDE "sencillamente
funcionarán". al igual que los teclados y ratón PS/2 o USB. Obtendrá
soporte para una pantalla básica VGA. Sin embargo, algunos
dispositivos, tales como adaptadores ethernet prácticamente no tienen
estandarización, así que tendrá que identificar el chipset ethernet y
seleccionar el soporte apropiado de hardware para la tarjeta
específica para poder obtener acceso a la red.
</p>

<p>
Adicionalmente, mientras que algunas cosas apenas funcionan con la
configuración por defecto, tal vez tenga que seleccionar opciones más
especializadas para obtener el potencial pleno de su sistema. Por
ejemplo, si no activa el soporte para el chipset IDE apropiado, los
discos IDE correrán <e>muy</e> lentamente.
</p>

</body>
</section>

<section>
<title>Características del Núcleo</title>
<body>

<p>
Al igual que el soporte de hardware, también hace falta pensar en
términos de las características del software requeridos del núcleo. Un
importante ejemplo de este tipo de característica es soporte para
sistemas de archivos: hará falta seleccionar soporte para los sistemas
de archivos usados en el disco duro, al igual que cualquier otro
sistema de archivo utilizado en almacenamiento externo (por ejemplo,
VFAT en pen drives USB).
</p>

<p>
Otro ejemplo común es la funcionalidad avanzada de redes. Si desea
hacer algún tipo de enrutamiento o trabajar con un cortafuego, debe
asegurar que los ítems relevantes de la configuración del núcleo
estará incluidos.
</p>

</body>
</section>

<section>
<title>Listo?</title>
<body>

<p>
Ahora que hemos introducido los conceptos, podremos empezar a
identificar el hardware y navegar a través de los menús de
configuración, seleccionando las opciones requeridas para el núcleo
del sistema.
</p>

<p>
El resto de esta página tratará de clarificar algunas áreas comunes de
confusión y proporcionar consejos para evitar problemas comunes que
los usuarios a menudo encuentran. ¡Buena suerte!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemas y áreas de confusión comunes</title>

<section>
<title>Los discos SATA son SCSI</title>
<body>

<p>
La mayoría de sistemas de escritorio modernos vienen con dispositivos
de almacenamiento (discos duros y discos CD/DVD) en un
bus <uri link="http://es.wikipedia.org/wiki/SATA">Serial ATA</uri>, en
vez del más antiguo bus
tipo <uri link="http://es.wikipedia.org/wiki/Ata">IDE</uri>
(cable plano).
</p>

<p>
El soporte SATA en Linux está implementado en una capa llamada
<e>libata</e>, el cual se siente debajo del subsistema SCSI. Por esta
razón los manejadores SATA se encuentran en la sección de
configuración de manejadores SCSI. Además, los dispositivos de
almacenamiento serán tratado como dispositivos SCSI, lo cual significa
que también se requiere soporte para discos y cdroms SCSI. El disco
duro SATA será nombrado (por ejemplo) <c>/dev/sda</c> y el disco
CD/DVD SATA será nombrado (por ejemplo) <c>/dev/sr0</c>.
</p>

<p>
Aunque la mayoría de estos manejadores son para controladores SATA,
libata no fue diseñado para ser específica a SATA. Todos los
manejadores IDE comunes también serán porteados a libata en el futuro
cercano y en ese punto, las consideraciones antes mencionadas aplicarán
también a usuarios de IDE.
</p>

<pre caption="Opciones de configuración para libata">
Device Drivers  ---&gt;
 SCSI device support  ---&gt;
  &lt;*&gt; SCSI device support
  &lt;*&gt;   SCSI disk support
  &lt;*&gt;   SCSI CDROM support

  SCSI low-level drivers  ---&gt;
   &lt;*&gt; Serial ATA (SATA) support
    <comment>Seleccione el chipset de las opciones listadas debajo de
    la opción anterior</comment>
</pre>

</body>
</section>

<section>
<title>Chipsets IDE y DMA</title>
<body>

<p>
A pesar de la introducción de SATA, los dispositivos IDE todavía son
muy comunes y muchos dependen de ellos. IDE es un tecnología bastante
genérica y como tal, Linux soporta casi todos los controladores IDE
tal cual sin seleccionar opciones específicas a determinados
controladores.
</p>

<p>
Sin embargo, IDE es una tecnología vieja y en su
encarnación <e>Programmed Input/Output</e>, no logra proporcionar las
tasas de transferencia requeridas para acceso rápido a dispositivos
modernos de almacenamiento. El manejador genérico IDE está limitado a
usar el modo de transferencia PIO, lo cual resulta en tasas de
transferencia lentas y un uso significativamente alto de la CPU
mientras los datos son transferidos desde/hacia el disco.
</p>

<p>
A no ser que esté tratando con un sistema anterior a 1995, el
controlado IDE también soportará un modo alternativo de transferencia
conocido como <e>Direct Memory Access</e> (DMA). El modo DMA es mucho
más rápido y la utilización de la CPU casi no se nota mientras se
efectúan transferencias. Si sufre de un desempeño realmente pobre y
está usando un disco IDE, es muy posible que no esté usando DMA.
</p>

<note>
Como se ha mencionado anteriormente, libata está también disponible para
discos IDE. Si estás usando libata, entonces todos tus discos, incluyendo
los discos IDE, deberán usar DMA. Para hacer esto no necesitas más
comprobaciones ni configuraciones.
</note>

<p>
Si no estás usando libdata para tus discos IDE, entonces necesitarás
comprobarlo para usar el DMA y activarlo.
</p>

<pre caption="Revisando si el DMA está activado en su disco IDE">
# <i>hdparm -d /dev/hda</i>

/dev/hda:
 using_dma    =  0 (off)
</pre>

<p>
Para activar DMA en dispositivos IDE devices, debe activar la opción
de configuración del controlador IDE.
</p>

<pre caption="Opciones de configuración para controladores IDE">
Device Drivers  ---&gt;
 ATA/ATAPI/MFM/RLL support  ---&gt;
  &lt;*&gt; ATA/ATAPI/MFM/RLL support
  &lt;*&gt;   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
  [*]     PCI IDE chipset support
  [*]       Generic PCI bus-master DMA support

    <comment>Seleccione el chipset de las opciones listadas debajo de
    la opción anterior</comment>
</pre>

</body>
</section>

<section>
<title>Controladores de anfitrión USB</title>
<body>

<p>
El <uri link="http://es.wikipedia.org/wiki/USB">USB</uri> es un bus
ampliamente adoptado para conectar periféricos externos al
computador. Una de las razones por el éxito de USB es que es un
protocolo estandarizado, sin embargo, los <e>dispositivos
controladores de anfitrión</e> (HCDs) USB implementado en el
computador anfitrión varían un poco. Existen tres tipos distintos:
</p>

<ul>
  <li>
    <c>UHCI</c> es el Interfaz Universal Controlador de Anfitriones o
    Universal Host Controller Interface, en inglés. Soporta USB 1.1 y
    usualmente lo encontramos en tarjetas madre basados en un chipset
    VIA o Intel.
  </li>
  <li>
    <c>OHCI</c> es el Interfaz Abierto Controlador de Anfitriones o
    Open Host Controller Interface, en inglés. Soporte USB 1.1 y se
    encuentra usualmente en tarjetas madre basadas en un chipset
    Nvidia o SiS.
  </li>
  <li>
    <c>EHCI</c> es el Interfaz Controlador de Anfitriones Extendido o
    Extended Host Controller Interface, en inglés. Es el único
    controlador de anfitriones común que soporta USB 2.0 y puede ser
    encontrado en cualquier computador que soporte USB 2.0.
  </li>
</ul>

<p>
La mayoría de los sistemas tendrán uno de los dos tipos de interfaz: EHCI
(USB 2.0) además de UHCI o OHCI (USB 1.1). Es importante que
selecciones ambos tipos presentes en su sistema. Mientras que todos
los dispositivos USB 2.0 son compatibles con USB 1.1, una gran
proporción de dispositivos USB (aún los que se fabrican actualmente)
están basados en el interfaz USB 1.1 - ¿porqué un ratón USB podría
necesitar más que 1,5 megabits/segundo?
</p>

<p>
Si no selecciona las opciones relevantes que corresponde a los tipos
de HCD USB disponibles en su sistema, puede experimentar puertos USB
'muertos': se enchufa un dispositivo, pero ni prende ni responde de
forma alguna.
</p>

<p>
Un excelente truco usando <c>lspci</c> (del paquete
<c>sys-apps/pciutils</c>) hace que sea relativamente sencillo detectar
cuáles HCDs están disponibles en su sistema. Sin tomar en cuenta el
controlador FireWire que también aparece, es sencillo determinar que
mi sistema requiere soporte OHCI y EHCI:
</p>

<pre caption="Usando lspci para detectar el tipo de HCD">
# <i>lspci -v | grep HCI</i>
00:02.0 USB Controller: nVidia Corporation CK804 USB Controller (rev a2) (prog-if 10 <i>[OHCI]</i>)
00:02.1 USB Controller: nVidia Corporation CK804 USB Controller (rev a3) (prog-if 20 <i>[EHCI]</i>)
01:0b.0 FireWire (IEEE 1394): Agere Systems FW323 (rev 61) (prog-if 10 [OHCI])
</pre>

<pre caption="Configuración de HCDs USB">
Device Drivers  ---&gt;
 USB support  ---&gt;
  &lt;*&gt; Support for Host-side USB
  ---   USB Host Controller Drivers
  &lt;*&gt;   EHCI HCD (USB 2.0) support
  &lt;*&gt;   OHCI HCD support
  &lt;*&gt;   UHCI HCD (most Intel and VIA) support
  <comment>Selecciones los HCD presentes en su sistema, o los 3 si no está seguro.</comment>
</pre>

</body>
</section>

<section>
<title>Sistemas Multiprocesador, Hyper-Threading y de Múltiples Núcleos</title>
<body>

<p>
Muchos sistemas usan procesadores múltiples, aunque no siempre en
maneras inmediatamente obvias.
</p>

<ul>
  <li>
    Muchas CPUs de Intel soportan una tecnología que ellos llaman <uri
    link="http://es.wikipedia.org/wiki/Hyperthreading">hyper-threading</uri>,
    que hace que el sistema vea la CPU como si fueran dos procesadores
    <e>lógicos</e>.
  </li>
  <li>
    Actualmente, la mayoría de las CPUs Intel/AMD contienen varios
    procesadores físicos dentro del mismo chip. Se conocen como
    procesadores
    <uri link="http://es.wikipedia.org/wiki/Procesador_multin%C3%BAcleo">
    multinúcleo</uri>.
  </li>
  <li>
    Algunos sistema de alto desempeño tienen de hecho múltiples
    procesadores físicos instalados en tarjetas madres especializadas
    para proporcionar un aumento de desempeño significativo sobre un
    sistema con <e>un procesador</e>. Probablemente sabrá si tiene uno
    de estos sistemas, ya que no tienen nada de barato.
  </li>
</ul>

<p>
En todos estos casos debe seleccionar las opciones apropiadas del
núcleo para obtener el óptimo desempeño de estos equipos.
</p>

<pre caption="Configuración para multi-procesamiento">
Processor type and features  ---&gt;
 [*] Symmetric multi-processing support
 <comment>Seleccione la opción anterior si está en cualquier tipo de sistema multi-procesador</comment>
 [*]   SMT (Hyperthreading) scheduler support
 <comment>Seleccione la opción anterior si está usando una CPU Intel con Hyper-Threading</comment>
 [*]   Multi-core scheduler support (NEW)
 <comment>Seleccione la opción anterior si la CPU es de múltiples núcleos</comment>
Power management and ACPI options  ---&gt;
 [*] ACPI (Advanced Configuration and Power Interface) Support
 <comment>La opción anterior no solo habilita características de gestión de
 energía, además podría ser un requisito para que todas las CPUs de su sistema
 estén disponibles</comment>
</pre>

</body>
</section>

<section>
<title>Soporte para memoria alta en x86</title>
<body>

<p>
Debido a limitaciones en el espacio de direcciones de 32 bits de la
arquitectura x86, un núcleo con la configuración por defecto solo
puede soportar hasta 896mb RAM. Si su sistema tiene más memoria, solo
serán visibles los primeros 896mb, a no ser que active el soporte para
memoria alta.
</p>

<note>
Esta limitación es específica a la arquitectura x86 (IA32). Las demás
arquitecturas soportan naturalmente grandes cantidades de memoria, sin
requerir afinamientos en la configuración.
</note>

<p>
El soporte para la memoria alta no está activada por defecto porque
introduce un pequeño costo en términos de desempeño. No se distraiga
por esto, ¡esta carga es insignificante en comparación con el aumento
de desempeño por disponer de la memoria adicional!
</p>

<pre caption="Activando el soporte para memoria alta en un x86">
Processor type and features  ---&gt;
 High Memory Support  ---&gt;
  (X) 4GB
  ( ) 64GB
  <comment>Escoja la opción de 4GB, a no ser que tenga más que 4GB de memoria RAM.</comment>
</pre>

</body>
</section>
</chapter>

<chapter id="shorthand">
<title>Notación corta para la configuración del núcleo</title>
<section>
<title>Introducción</title>
<body>

<p>
Cuando lea sobre las configuraciones del núcleo, verá a menudo que los
ajustes se describen como <c>CONFIG_&lt;algo&gt;</c>. Esta notación corta
es lo que realmente utiliza internamente el núcleo, y es lo que encontrará
en el fichero de configuración del núcleo (bien esté en
<path>/usr/src/linux/.config</path> o en el fichero autogenerado
<path>/proc/config.gz</path> file). Desde luego, el hecho de utilizar la
notación corta no sería de muy útil si no se puede traducir a la
localización real en la configuración del núcleo. Afortunadamente, la
herramienta <c>make menuconfig</c> le permite hacer precisamente esto.
</p>

</body>
</section>
<section>
<title>Traduciendo CONFIG_FOO a la localización real de la configuración</title>
<body>

<p>
Suponga que necesita habilitar <c>CONFIG_TMPFS_XATTR</c>, lance el menú
de configuración del núcleo (<c>make menuconfig</c>) y teclee <c>/</c>.
Esto abrirá la caja de búsqueda. En esta caja, escriba
<c>CONFIG_TMPFS_XATTR</c> (puede incluso omitir la parte <c>CONFIG_</c>).
El siguiente listado de código muestra el resultado de esta búsqueda.
</p>

<pre caption="Resultado de buscar CONFIG_TMPFS_XATTR">
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] &amp;&amp; TMPFS [=y]
</pre>

<p>
Esta salida muestra cantidad de información interesante.
</p>

<table>
<tr>
  <th>Entrada</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti>Symbol: TMPFS_XATTR [=n]</ti>
  <ti>
    Esto identifica la entrada de la configuración del núcleo que está
    buscando. También le indicate que el ajuste <e>no está habilitado</e>
    actualmente ([=n]).
  </ti>
</tr>
<tr>
  <ti>Type: boolean</ti>
  <ti>
    El ajuste que buscó es un booleano (lo que significa que puede
    habilitarlo o deshabilitarlo). Algunos ajustes son números o cadenas
    de caracteres.
  </ti>
</tr>
<tr>
  <ti>Prompt: Tmpfs extended attributes</ti>
  <ti>
    Este es el texto que encontrarán en <c>make menuconfig</c> y como tal,
    es la entrada que estaba buscando en un formato que es legible mejor
    por los humanos.
  </ti>
</tr>
<tr>
  <ti>Depends on: TMPFS [=y]</ti>
  <ti>
    Antes de que pueda ver esta entrada, necesitará tener habilitado el
    ajuste <c>CONFIG_TMPFS</c>. En este caso, esto ya se ha realizado (de
    ahí el [=y]), sin embargo, si este no es el caso, necesitará en primer
    lugar buscar (y habilitar) <c>CONFIG_TMPFS</c>.
  </ti>
</tr>
<tr>
  <ti>Location: ...</ti>
  <ti>
    Esta es la localización en la estructura <c>make menuconfig</c> en la
    cual se puede encontrar el ajuste. Recuerde, el ajuste que está buscando
    es <e>Tmpfs extended attributes</e>.
  </ti>
</tr>
<tr>
  <ti>Selected by: TMPFS_POSIX_ACL [=n] &amp;&amp; TMPFS [=y]</ti>
  <ti>
    Si los ajustes descritos aquí están ambos habilitados (en nuestro caso,
    el primero no lo está), entonces, <c>CONFIG_TMPFS_XATTR</c> se activará
    automáticamente y no podrá deshabilitarlo.
  </ti>
</tr>
</table>

<p>
Con esta información, debería poder traducir cualquier requerimientos
<c>CONFIG_*</c> con los que se encuentre. Resumiendo, esto significa que
</p>

<ol>
  <li>necesita habilitar los ajustes en el campo <e>Depends on</e></li>
  <li>navegar a dónde <e>Location:</e> le indica</li>
  <li>activar el valor indicado por <e>Prompt:</e></li>
</ol>

</body>
</section>
</chapter>

<chapter>
<title>Otra documentación sobre la configuración del núcleo</title>
<section>
<body>

<p>
Hasta ahora solamente hemos discutido conceptos generales y problemas
específicos relacionados con la configuración del núcleo, sin entrar
en detalles precisos (¡estos detalles están para ser
descubiertos!). Sin embargo, otros partes de la documentación Gentoo
proporcionan detalles especializados para las materias a la mano.
</p>

<p>
Podrá darse cuenta que estos documentos son de utilidad al configurar
áreas específicas, pero si es un principiante en la configuración del
núcleo, no sea demasiado aventurado. Comience echando a andar un
sistema básico ya que siempre puede volver más tarde para agregar
soporte para audio, impresión, etc.
</p>

<ul>
  <li>
    La <uri link="/doc/es/alsa-guide.xml">Guía ALSA</uri> detalla las
    opciones de configuración necesarias para dar soporte a una
    tarjeta de sonido. Note que ALSA es una excepción al esquema de no
    construir las cosas como módulos: el ALSA es de hecho más sencillo
    de configurar cuando los componentes son modulares.
  </li>
  <li>
    El artículo wiki
    <uri link="https://wiki.gentoo.org/wiki/Bluetooth">Bluetooth</uri>
    (en inglés), detalla las opciones que necesita para utilizar
    dispositivos bluetooth en su sistema.
  </li>
  <li>
    La <uri link="/doc/es/ipv6.xml">Guía del enrutador IPv6 en Gentoo</uri>
    describe cómo configurar el núcleo para enrutar usando el esquema
    de direccionamiento de redes de próxima generación.
  </li>
  <li>
    Si va a usar el manejador gráfico propietario de nVidia para
    obtener mejor desempeño gráfico, la <uri
    link="/doc/es/nvidia-guide.xml">Guía nVidia</uri> lista las
    opciones que deben y no deben seleccionarse en el sistema.
  </li>
  <li>
    Entre otras cosas, la <uri
    link="/doc/es/power-management-guide.xml">Guía de Administración
    de Energía</uri> explica la configuración del núcleo para ajusta
    la frecuencia de la CPU y para activar la funcionalidad de
    suspensión e hibernación.
  </li>
  <li>
    Si trabaja con un sistema PowerPC, el <uri
    link="/doc/es/gentoo-ppc-faq.xml">PUF (FAQ) PPC</uri> tiene
    algunas secciones acerca de la configuración del núcleo.
  </li>
  <li>
    La <uri link="/doc/es/printing-howto.xml">Guía de Impresión
    Gentoo</uri> lista las opciones del núcleo necesarias para
    soportar la impresión en Linux.
  </li>
  <li>
    La <uri link="/doc/es/usb-guide.xml">Guía USB</uri> detalla la
    configuración necesaria para utilizar dispositivos USB comunes
    como teclados/ratones, dispositivos de almacenamiento e
    impresoras.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Solucionando problemas</title>
<section>
<title>Cambios de Configuración que no tienen efecto</title>
<body>

<p>
Es muy común que los usuarios hagan algún cambio de configuración,
pero que hacen un pequeño error en el proceso a partir de este
punto. Ellos arrancan con una imagen de núcleo que no es la recién
reconfigurada, observan que el problema que intentaban solucionar
todavía existe y concluyen que el cambio de configuración no era la
solución del problema.
</p>

<p>
El proceso de compilar e instalar núcleos está más allá de este
documento, debe referirse a la <uri
link="/doc/es/kernel-upgrade.xml">Guía de Actualización del
Núcleo</uri> para orientación general. En pocas palabras, el proceso
es: configuración, compilación, montar /boot (si no está montada ya),
copiar la nueva imagen del núcleo y reiniciar la máquina. Si salta
algunos de estos pasos finales, ¡los cambios realizados no tomarán
efecto!
</p>

<p>
Es posible verificar que el núcleo con el que arrancó es igual al
núcleo compilado en el disco duro examinando la fecha y hora de la
compilación. Asumiendo que su arquitectura es x86 y las fuentes del
núcleo están instaladas en <path>/usr/src/linux</path>:
</p>

<pre caption="Verificando si arrancó del núcleo modificado">
# <i>uname -v</i>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
<comment>La orden anterior muestra la fecha y hora en que fue compilado el núcleo del cual arrancó.</comment>

# <i>ls -l /usr/src/linux/arch/i386/boot/bzImage</i>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
<comment>La orden anterior muestra la fecha y la hora en que se compiló por última vez la imagen del núcleo en el disco duro.</comment>
</pre>

<p>
Si las horas de las dos órdenes anteriores difieren en más de dos
minutos, indica que se ha equivocado en la reinstalación del núcleo y
¡no ha arrancado con la imagen del núcleo que creía!
</p>

</body>
</section>

<section>
<title>Los módulos no son cargados automáticamente</title>
<body>

<p>
Como mencionamos antes, en este mismo documento, el sistema de
configuración del núcleo esconde un grn cambio de comportamiento
cuando uno selecciona compilar un componente como módulo (M) en vez de
integrarlo (Y). Vale la pena repetir esto porque muchos usuarios caen
en esta trampa.
</p>

<p>
Al seleccionar un componente como integrado, el código forma parte de
la imagen del núcleo (bzImage). Cuando el núcleo necesita usar ese
componente lo puede inicializar y cargar automáticamente sin
intervención por parte del usuario.
</p>

<p>
Cuando selecciona un componente como módulo, el código se construye
como un archivo de módulo del núcleo aparte instalado en el sistema de
archivos. En general, cuando el núcleo necesita usar ese componente,
¡no podrá! Con algunas excepciones, el núcleo no hace esfuerzo alguno
para cargar estos módulos - esa tarea queda en manos del usuario.
</p>

<p>
De manera tal que, si construye el soporte para la tarjeta de red como
un módulo y entonces encuentra que no tiene acceso a la red, es
probable que el módulo no esté cargado - debe hacerlo manualmente o
configurar su sistema para cargarlo automáticamente al arrancar.
</p>

<p>
A no ser que tenga razones para hacerlo de otra manera, ahórrese algo
de tiempo construyendo estos componentes de manera integrada en la
imagen del núcleo, para que el núcleo pueda hacer todo
automáticamente.
</p>

</body>
</section>
</chapter>
</guide>
