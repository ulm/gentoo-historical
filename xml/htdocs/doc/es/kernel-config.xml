<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/kernel-config.xml,v 1.1 2006/11/10 17:33:03 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/kernel-config.xml" lang="es">
<title>Gentoo Linux Kernel Configuration Guide</title>

<author title="Autor">
  <mail link="dsd@gentoo.org">Daniel Drake</mail>
</author>
<author title="Contribuyente">
  <mail link="curtis119@gentoo.org">Curtis Napier</mail>
</author>
<author title="Contribuyente">
  <mail link="jdr@xemoka.net">Justin Robinson</mail>
</author>
<author title="Contribuyente">
  <mail link="rane@gentoo.org">Łukasz Damentko</mail>
</author>
<author title="Editor">
  <mail link="smithj@gentoo.org">Jonathan Smith</mail>
</author>
<author title="Traductor">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>

<abstract>
Este documento tiene la finalidad de presentar conceptos acerca de la
configuración manual del kernel y detallar algunos de las fallas más
comunes de configuración.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2006-07-16</date>

<chapter>
<title>Introducción</title>
<section>
<body>

<p>
Gentoo proporciona dos maneras para manejar la instalación y
actualización del kernel: la <e>automática</e> (con genkernel) y la
<e>manual</e>. Aunque el método automático podría ser visto como
<e>más fácil</e> para el usuario, hay un gran número de razones por
las cuales una gran proporción de usuarios Gentoo escogen configurar
su kernel manualmente: mayor flexibilidad, menor tamaño del kernel,
tiempos de compilación más cortos, mejor experiencia didáctica,
aburrimiento severo, etc.  etc.
</p>

<p>
Esta guía no cubre la manera automática (con genkernel). Si prefiere
usar genkernel para compilar e instalar su kernel, diríjase a la <uri
link="/doc/es/genkernel.xml">documentación de Genkernel</uri>.
</p>

<p>
Esta guía no intenta documentar el proceso de configuración manual
desde el inicio hasta el final -- el proceso de configuración depende
en mayor grado en el sentido común y un grado de conocimiento técnico
relativamente alto acerca de su sistema. En vez de eso, este documento
introducirá los conceptos de la configuración manual y detallará los
problemas más comunes que enfrentarán los usuarios.
</p>

<p>
Este documento está escrito tomando en cuenta las versiones más
recientes del kernel, para las arquitecturas de computadora más
comunes. Algunos detalles pueden ser distintos para kernels más
antiguos o para arquitecturas más exóticas, pero la mayor parte del
contenido seguirá siendo relevante.
</p>

<p>
En esta coyuntura, asumiremos que tiene las fuentes del kernel Linux
desempacadas en el disco duro (usualmente por ahí por <c>/usr/src</c>)
y esperamos que conozca cómo ingresar a la herramienta de
configuración <c>menuconfig</c> y navegar a través de su sistema de
menús. Si no se encuentra ya en esta etapa, hay otros documentos
disponibles para ayudarlo.
</p>

<ul>
  <li>
    La <uri link="/doc/es/gentoo-kernel.xml">Guía del Kernel</uri>
    lista los paquetes de fuentes del kernel del que disponemos
  </li>
  <li>
    La <uri link="/doc/es/kernel-upgrade.xml">Guía de Actualización
    del</uri> explica cómo actualizar el kernel o cambiar de un kernel
    a otro.
  </li>
  <li>
    El <uri link="/doc/es/handbook/index.xml">Manual Gentoo</uri>
    también cubre aspectos de la instalación del kernel.
  </li>
</ul>
</body>
</section>
</chapter>

<chapter>
<title>Conceptos de Configuración</title>
<section>
<title>Lo básico</title>
<body>

<p>
El proceso general es realmente simple: se prensentan una serie de
opciones categorizadas en menús individuales y sub-menús y entonces
uno selecciona el soporte de hardware y características relevantes del
kernel para su sistema.
</p>

<p>
El kernel incluye una <e>configuración por defecto</e>, que es
presentada la primera vez que ejecute menuconfig sobre un conjunto
particular de fuentes. Los valores por defecto son generalmente
amplios y con sentido común, lo cual significa que la mayoría de los
usuarios solamente tendrán que hacer una pequeña cantidad de cambios a
la configuración base. Si decide desctivar una opción activada por
defecto, asegúrese de comprender exactamente qué hace esa opción y las
consecuencias de su desactivación.
</p>

<p>
Si esta es su primera vez configurando un kernel Linux, debe apuntar a
ser algo conservador: no sea demasiado aventuroso y mientras sea
posible, trate de no hacer demasiadas modificaciones a los valores por
defecto. Al mismo tiempo, tome en cuenta que hay ciertas partes de la
configuración que absolutamente deben afinarse a su sistema ¡solo para
arrancar!
</p>
</body>
</section>

<section>
<title>Inclusión vs modular</title>
<body>

<p>
La mayoría de las opciones de configuración tienen <e>tres
estados</e>: pueden no ser construidas, pueden ser construidas para
formar parte integral del kernel (Y) o construidas como un módulo
(M). Los módulos se almacenan externamente en el sistema de archivos,
mientras que los ítems integrales forman parte de la imagen del
kernel.
</p>

<p>
Hay una diferencia importante entre integrales y modulates: con pocas
excepciones, el kernel no hace intento alguno de cargar módulos
externos cuando haga falta (esto se deja a cuenta del
usuario). Mientras que otras partes del sistema puedan cargar módulos
según demanda, se recomienda que construya las opciones de soporte de
hardware y características del kernel de manera integral. El kernel
entonces puede asegurar que la funcionalidad y soporte de hardware
esten siempre disponibles cuando hagan falta.
</p>

<p>
Por supuesto que para algunas partes de la configuración, la
construcción integral es un requerimiento absoluto. Por ejemplo, si su
partición raíz es un sistema de archivos <c>ext2</c>, el sistema no va
a arrancar si el soporte para ext2 fue construido como un módulo (ya
que el sistema tendría que buscar en la misma partición raíz para
encontrar el módulo ext2, pero no puede ver la partición raíz ¡hasta
que tenga cargado el módulo de soporte ext2 cargado!).
</p>
</body>
</section>

<section>
<title>Soporte de Hardware</title>
<body>

<p>
Más allá de detectar el <e>tipo de arquitectura</e> del sistema, la
herramienta de configuración no hace ningún intento para identificar
qué hardware está presente en el sistema. Mientras que hay una
configuración por defecto para algún soporte de hardware, es
obligatorio encontrar y seleccionar las opciones de configuración
relevantes a la configuración de hardware del sistema.
</p>

<p>
Esto simplemente requiere un conocimiento de los componentes adentro y
conectados al computado, o para que identifique estos
componentes. Para la mayoría de los componentes internos, necesita
identificar el <e>chipset</e> usado en cada uno, en vez de el nombre
de mercado del producto.
</p>

<p>
Existen algunas herramientas disponibles que pueden ser de ayuda. 
<c>lspci</c> (parte del paquete <c>sys-apps/pciutils</c>) identificará
su hardware PCI y AGP, incluyendo componentes construidos en la propia
tarjeta madre. <c>lsusb</c> (del paquete <c>sys-apps/usbutils</c>)
identificará los dispositivos conectados a los puertos USB.
</p>

<p>
La situación es algo confusa por la variación de grados de
estandarización en el mundo del hardware. A no ser que haya una
verdadera desviación de las normas, los discos IDE "sencillamente
funcionarán". al igual que los teclados y ratón PS/2 o USB. Obtendrá
soporte para una pantalla básica VGA. Sin embargo, algunos
dispositivos, tales como adaptadores ethernet prácticamente no tienen
estandarización, así que tendrá que identificar el chipset ethernet y
seleccionar el soporte apropiado de hardware para la tarjeta
específica para poder obtener acceso a la red.
</p>

<p>
Adicionalmente, mientras que algunas cosas apenas funcionan con la
configuración por defecto, tal vez tenga que seleccionar opciones más
especializadas para obtener el potencial pleno de su sistema. Por
ejemplo, si no activa el soporte para el chipset IDE apropiado, los
discos IDE correrán <e>muy</e> lentamente.
</p>
</body>
</section>

<section>
<title>Características del Kernel</title>
<body>

<p>
Al igual que el soporte de hardware, también hace falta pensar en
términos de las características del software requeridos del kernel. Un
importante ejemplo de este tipo de característica es soporte para
sistemas de archivos: hará falta seleccionar soporte para los sistemas
de archivos usados en el disco duro, al igual que cualquier otro
sistema de archivo utilizado en almacenamiento externo (por ejemplo,
VFAT en pen drives USB).
</p>

<p>
Otro ejemplo común es la funcionalidad avanzada de redes. Si desea
hacer algún tipo de enrutamiento o trabajar con un cortafuego, debe
asegurar que los ítems relevantes de la configuración del kernel
estará incluidos.
</p>
</body>
</section>

<section>
<title>Listo?</title>
<body>

<p>
Ahora que hemos introducido los conceptos, podremos empezar a
identificar el hardware y navegar a través de los menús de
configuración, seleccionando las opciones requeridas para el kernel
del sistema.
</p>

<p>
El resto de esta página tratará de clarificar algunas áreas comunes de
confusión y proporcionar consejos para evitar problemas comunes que
los usuarios a menudo encuentran. ¡Buena suerte!
</p>
</body>
</section>
</chapter>

<chapter>
<title>Problemas y áreas de confusión comunes</title>

<section>
<title>Los discos SATA son SCSI</title>
<body>

<p>
La mayoría de sistemas de escritorio modernos vienen con dispositivos
de almacenamiento (discos duros y discos CD/DVD) en un
bus <uri link="http://es.wikipedia.org/wiki/SATA">Serial ATA</uri>, en
vez del más antiguo bus
tipo <uri link="http://en.wikipedia.org/wiki/Parallel_ATA">IDE</uri>
(cable plano).
</p>

<p>
El soporte SATA en Linux está implementado en una capa llamada 
<e>libata</e>, el cual se siente debajo del subsistema SCSI. Por esta
razón los manejadores SATA se encuentran en la sección de
configuración de manejadores SCSI. Además, los dispositivos de
almacenamiento serán tratado como dispositivos SCSI, lo cual significa
que también se requiere soporte para discos y cdroms SCSI. El disco
duro SATA será nombrado (por ejemplo) <c>/dev/sda</c> y el disco
CD/DVD SATA será nombrado (por ejemplo) <c>/dev/sr0</c>.
</p>

<p>
Aunque la mayoría de estos manejadores son para controladores SATA,
libata no fue diseñado para ser específica a SATA. Todos los
manejadores IDE comunes también serán porteados a libata en el futuro
cercano y en ese punto, las cosideraciones antes mencionadas aplicarán
tmbién a usuarios de IDE.
</p>

<pre caption="Opciones de configuración para libata">
Device Drivers  ---&gt;
 SCSI device support  ---&gt;
  &lt;*&gt; SCSI device support
  &lt;*&gt;   SCSI disk support
  &lt;*&gt;   SCSI CDROM support

  SCSI low-level drivers  ---&gt;
   &lt;*&gt; Serial ATA (SATA) support
    <comment>Seleccione el chipset de las opciones listadas debajo de
    la opción anterior</comment>
</pre>
</body>
</section>

<section>
<title>Chipsets IDE y DMA</title>
<body>

<p>
A pesar de la introducción de SATA, los dispositivos IDE todavía son
muy comunes y muchos dependen de ellos. IDE es un tecnología bastante
genérica y como tal, Linux soporta casi todos los controladores IDE
tal cual sin seleccionar opciones específicas a determinados
controladores.
</p>

<p>
Sin embargo, IDE es una tecnología vieja y en su
encarnación <e>Programmed Input/Output</e>, no logra proporcionar las
tasas de transferencia requeridas para acceso rápido a dispositivos
modernos de almacenamiento. El manejador genérico IDE está limitado a
usar el modo de transferencia PIO, lo cual resulta en tasas de
transferencia lentas y un uso significativamente alto del CPU mientras
la data es transferida desde/hacia el disco.
</p>

<p>
A no ser que esté tratando con un sistema anterior a 1995, el
controlado IDE también soportará un modo alternativo de transferencia
conocido como <e>Direct Memory Access</e> (DMA). El modo DMA es mucho
más rápido y la utilización del CPU casi no se nota mientras se
efectúan transferencias. Si sufre de un desempeño realmente pobre y
está usando un disco IDE, es muy posible que no esté usando DMA.
</p>

<pre caption="Revisando que DMA esté activado en un disco IDE">
# <i>hdparm -d /dev/hda</i>

/dev/hda:
 using_dma    =  0 (off)
</pre>

<p>
Para activar DMA en dispositivos IDE devices, debe activar la opción
de configuración del controlador IDE.
</p>

<pre caption="Opciones de configuración para controladores IDE">
Device Drivers  ---&gt;
 ATA/ATAPI/MFM/RLL support  ---&gt;
  &lt;*&gt; ATA/ATAPI/MFM/RLL support
  &lt;*&gt;   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
  [*]     PCI IDE chipset support
  [*]       Generic PCI bus-master DMA support
  [*]         Use PCI DMA by default when available
    <comment>Select your chipset from the choices listed below the above option</comment>
</pre>
</body>
</section>

<section>
<title>Controladores de anfitrión USB</title>
<body>

<p>
El <uri link="http://es.wikipedia.org/wiki/USB">USB</uri> es un bus
ampliamente adoptado para conectar periféricos externos al
computador. Una de las razones por el éxito de USB es que es un
protocolo estandarizado, sin embargo, los <e>dispositivos
controladores de anfitrión</e> (HCDs) USB implementado en el
computador anfitrión varían un poco. Existen tres tipos distintos:
</p>

<ul>
  <li>
    <c>UHCI</c> es el Interfaz Universal Controlador de Anfitriones o
    Universal Host Controller Interface, en inglés. Soporta USB 1.1 y
    usualmente lo encontramos en tarjetas madre basados en un chipset
    VIA o Intel.
  </li>
  <li>
    <c>OHCI</c> es el Interfaz Abierto Controlador de Anfitriones o
    Open Host Controller Interface, en inglés. Soporte USB 1.1 y se
    encuentra usualmente en tarjetas madre basadas en un chipset
    Nvidia o SiS.
  </li>
  <li>
    <c>EHCI</c> es el Interfaz Controlador de Anfitriones Extendido o
    Extended Host Controller Interface, en inglés. Es el único
    controlador de anfitriones común que soporta USB 2.0 y puede ser
    encontrado en cualquier computador que soporte USB 2.0.
  </li>
</ul>

<p>
La mayoría de los sistemas tendrán uno de los dos tipos de interfaz: EHCI
(USB 2.0) además de UHCI o OHCI (USB 1.1). Es importante que
selecciones ambos tipos presentes en su sistema. Mientras que todos
los dispositivos USB 2.0 son compatibles con USB 1.1, una gran
proporción de dispositivos USB (aún los que se fabrican actualmente)
estan basados en el interfaz USB 1.1 - ¿porqué un ratón USB podría
necesitar más que 1,5 megabits/segundo?
</p>

<p>
Si no selecciona las opciones relevantes que corresponde a los tipos
de HCD USB disponibles en su sistema, puede experimentar puertos USB
'muertos': se enchufa un dispositivo, pero ni prende ni responde de
forma alguna.
</p>

<p>
Un excelente truco usando <c>lspci</c> (del paquete
<c>sys-apps/pciutils</c>) hace que sea relativamente sencillo detectar
cuáles HCDs estan disponibles en su sistema. Sin tomar en cuenta el
controlador FireWire que también aparece, es sencillo determinar que
mi sistema requiere soporte OHCI y EHCI:
</p>

<pre caption="Usando lspci para detectar el tipo de HCD">
# <i>lspci -v | grep HCI</i>
00:02.0 USB Controller: nVidia Corporation CK804 USB Controller (rev a2) (prog-if 10 <i>[OHCI]</i>)
00:02.1 USB Controller: nVidia Corporation CK804 USB Controller (rev a3) (prog-if 20 <i>[EHCI]</i>)
01:0b.0 FireWire (IEEE 1394): Agere Systems FW323 (rev 61) (prog-if 10 [OHCI])
</pre>

<pre caption="Configuración de HCDs USB">
Device Drivers  ---&gt;
 USB support  ---&gt;
  &lt;*&gt; Support for Host-side USB
  ---   USB Host Controller Drivers
  &lt;*&gt;   EHCI HCD (USB 2.0) support
  &lt;*&gt;   OHCI HCD support
  &lt;*&gt;   UHCI HCD (most Intel and VIA) support
  <comment>Selecciones los HCD presentes en su sistema, o los 3 si no está seguro.</comment>
</pre>
</body>
</section>

<section>
<title>Sistemas Multiprocesadores, Hyper-Threading y de Doble Núcleo</title>
<body>

<p>
Muchos sistemas usan procesadores múltiples, aunque no siempre en
maneras inmediatamente obvias.
</p>

<ul>
  <li>
    Muchos CPUs de Intel soportan una tecnología que ellos llaman <uri
    link="http://en.wikipedia.org/wiki/Hyperthreading">hyper-threading</uri>,
    que hace que el sistema vea el CPU como si fueran dos procesadores
    <e>lógicos</e>.
  </li>
  <li>
    Algunos de los CPUs más recientes de Intel/AMD CPUs de ehcho
    consisten en múltiples procesadores dentro de un solo paquete,
    conocidos como procesadores de <uri
    link="http://en.wikipedia.org/wiki/Dual_core">doble núcleo</uri>.
  </li>
  <li>
    Algunos sistema de alto desempeño tienen de hecho múltiples
    procesadores físicos instalados en tarjetas madres especializadas
    para proporcionar un aumento de desempeño significativo sobre un
    sistema con <e>un procesador</e>. Probablemente sabrá si tiene uno
    de estos sistemas, ya que no tienen nada de barato.
  </li>
</ul>

<p>
En todos estos casos debe seleccionar las opciones apropiadas del
kernel para obtener el óptimo desempeño de estos equipos.
</p>

<pre caption="Configuración para multi-procesamiento">
Processor type and features  ---&gt;
 [*] Symmetric multi-processing support
 <comment>Seleccione la opción anterior si está en cualquier tipo de sistema multi-procesador</comment>
 [*]   SMT (Hyperthreading) scheduler support
 <comment>Seleccione la opción anterior si está usando un CPU Intel con Hyper-Threading</comment>
 [*]   Multi-core scheduler support (NEW)
 <comment>Seleccione la opción anterior si el CPU es de doble núcleo</comment>
</pre>
</body>
</section>

<section>
<title>Soporte para memoria alta en x86</title>
<body>

<p>
Debido a limitaciones en el espacio de direcciones de 32 bits de la
arquitectura x86, un kernel con la configuración por defecto sólo
puede soportar hasta 896mb RAM. Si su sistema tiene más memoria, solo
serán visibles los primeros 896mb, a no ser que active el soporte para
memoria alta.
</p>

<note>
Esta limitación es específica a la arquitectura x86 (IA32). Las demás
arquitecturas soportan naturalmente grandes cantidades de memoria, sin
requerir afinamientos en la configuración.
</note>

<p>
El soporte para la memoria alta no está activada por defecto porque
introduce un pequeño costo en términos de desempeño. No se distraiga
por esto, ¡esta carga es insignificante en comparación con el aumento
de desempeño por disponer de la memoria adicional!
</p>

<pre caption="Activando el soporte para memoria alta en un x86">
Processor type and features  ---&gt;
 High Memory Support  ---&gt;
  (X) 4GB
  ( ) 64GB
  <comment>Escoja la opción de 4GB, a no ser que tenga más que 4GB de memoria RAM.</comment>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Otra documentación sobre la configuración del kernel</title>
<section>
<body>

<p>
Hasta ahora solamente hemos discutido conceptos generales y problemas
específicos relacionados con la configuración del kernel, sin entrar
en detalles precisos (¡estos detalles estan para ser
descubiertos!). Sin embargo, otros partes de la documentación Gentoo
proporcionan detalles especializados para las materias a la mano.
</p>

<p>
Podrá darse cuenta que estos documentos son de utilidad al configurar
áreas específicas, pero si es un principiante en la configuración del
kernel, no sea demasiado aventurado. Comienze echando a andar un
sistema básico ya que siempre puede volver más tarde para agregar
soporte para audio, impresión, etc.
</p>

<ul>
  <li>
    La <uri link="/doc/es/alsa-guide.xml">Guía ALSA</uri> detalla las
    opciones de configuración necesarias para dar soporte a una
    tarjeta de sonido. Note que ALSA es una excepción al esquema de no
    construir las cosas como módulos: el ALSA es de hecho más sencillo
    de configurar cuando los componentes son modulares.
  </li>
  <li>
    La <uri link="/doc/es/bluetooth-guide.xml">Guía Bluetooth</uri>
    detalla las opciones necesarias para usar dispositivos bluetooth
    en su sistema.
  </li>
  <li>
    La <uri link="/doc/es/ipv6.xml">Guía de Enrutación IPv6</uri>
    describe cómo configurar el kernel para enrutar usando el esquema
    de direccionamiento de redes de próxima generación.
  </li>
  <li>
    Si va a usar el manejador gráfico propietario de nVidia para
    obtener mejor desempeño gráfico, la <uri
    link="/doc/es/nvidia-guide.xml">Guía nVidia</uri> lista las
    ocpiones que deben y no deben seleccionarse en el sistema.
  </li>
  <li>
    Entre otras cosas, la <uri
    link="/doc/es/power-management-guide.xml">Guía de Administración
    de Energía</uri> explica la configuración del kernel para ajusta
    la frecuencia del CPU y para activar la funcionalidad de
    suspensión e hibernación.
  </li>
  <li>
    Si trabajao con un sistema PowerPC, el <uri
    link="/doc/es/gentoo-ppc-faq.xml">PUF (FAQ) PPC</uri> tiene
    algunas secciones acerca de la configuración del kernel.
  </li>
  <li>
    La <uri link="/doc/es/printing-howto.xml">Guía de Impresión
    Gentoo</uri> lista las opciones del kernel necesarias para
    soportar la impresión en Linux.
  </li>
  <li>
    La <uri link="/doc/es/usb-guide.xml">Guía USB</uri> detalla la
    configuración necesaria para utilizar dispositivos USB comunes
    como teclados/ratones, dispositivos de almacenamiento e
    impresoras.
  </li>
</ul>
</body>
</section>
</chapter>

<chapter>
<title>Solucionando problemas</title>
<section>
<title>Cambios de Configuración que no tienen efecto</title>
<body>

<p>
Es muy común que los usuarios hagan algún cambio de configuración,
pero que hacen un pequeño error en el proceso a partir de este
punto. Ellos arrancan con una imagen de kernel que no es la recien
reconfigurada, observan que el problema que intentaban solucionar
todavía existe y concluyen que el cambio de configuración no era la
solución del problema.
</p>

<p>
El proceso de compilar e instalar kernels está más allá de este
documento, debe referirse a la <uri
link="/doc/es/kernel-upgrade.xml">Guía de Actualización del
Kernel</uri> para orientación general. En pocas palabras, el proceso
es: configuración, compilación, montar /boot (si no está montada ya),
copiar la nueva imagen del kernel y reiniciar la máquina. Si salta
algunos de estos pasos finales, ¡los cambios realizados no tomarán
efecto!
</p>

<p>
Es posible verificar que el kernel con el que arrancó es igual al
kernel compilado en el disco duro examinando la fecha y hora de la
compilación. Asumiendo que su arquitectura es x86 y las fuentes del
kernel estan instaladas en <path>/usr/src/linux</path>:
</p>

<pre caption="Verificando si arrancó del kernel modificado">
# <i>uname -v</i>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
<comment>El comando anterior muestra la fecha y hora en que fue compilado el kernel del cual arrancó.</comment>

# <i>ls -l /usr/src/linux/arch/i386/boot/bzImage</i>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
<comment>El comando anterior muestra la fecha y la hora en que se compiló por última vez la imagen del kernel en el disco duro.</comment>
</pre>

<p>
Si las horas de los dos comandos anteriores difieren por más de 2
minutos, indica que se ha equivocado en la reinstalación del kernel y
¡no ha arrancado con la imagen del kernel que creía!
</p>
</body>
</section>

<section>
<title>Los módulos no son cargados automáticamente</title>
<body>

<p>
Como mencionamos antes, en este mismo documento, el sistema de
configuración del kernel esconde un grn cambio de comportamiento
cuando uno selecciona compilar un componente como módulo (M) en vez de
integrarlo (Y). Vale la pena repetir esto porque muchos usuarios caen
en esta trampa.
</p>

<p>
Al seleccionar un componente como integrado, el código forma parte de
la imagen del kernel (bzImage). Cuando el kernel necesita usar ese
componente lo puede inicializar y cargar automáticamente sin
intervención por parte del usuario.
</p>

<p>
Cuando selecciona un componente como módulo, el código se construye
como un archivo de módulo del kernel aparte instalado en el sistema de
archivos. En general, cuando el kernel necesita usar ese componente,
¡no podrá! Con algunas excepciones, el kernel no hace esfuerzo alguno
para cargar estos módulos - esa tarea queda en manos del usuario.
</p>

<p>
De manera tal que, si construye el soporte para la tarjeta de red como
un módulo y entonces encuentra que no tiene acceso a la red, es
probable que el módulo no esté cargado - debe hacerlo manualmente o
configurar su sistema para cargarlo automáticamente al arrancar.
</p>

<p>
A no ser que tenga razones para hacerlo de otra manera, ahórrese algo
de tiempo construyendo estos componentes de manera integrada en la
imagen del kernel, para que el kernel pueda hacer todo
automáticamente.
</p>
</body>
</section>
</chapter>
</guide>
