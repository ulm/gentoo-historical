<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/Attic/kde-split-ebuilds.xml,v 1.1 2005/04/05 21:30:50 bass Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/kde-split-ebuilds.xml">

<title>El COMO de los Ebuilds separados de KDE</title>

<author title="Author">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Editor">
    <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
</author>
<author title="Traductor">
    <mail link="nmiyasato@datafull.com">Nicolás Miyasato</mail>
</author>

<abstract>
Con el lanzamiento del KDE 3.4, fueron introducidos a portage los 'ebuilds
separados'. Esta página documenta las razones detrás de esta transición y las
nuevas funcionalidades brindadas por la misma.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.1</version>
<date>19 de febrero del 2005</date>

<chapter>
<title>Los ebuild separados del KDE</title>
<section>
<title>Que es lo que son</title>
<body>

<p>
Antes de Enero del 2005, los únicos ebuilds de KDE en portage eran los
'monolíticos'. Eso significa que solamente existían 15 ebuilds, y cada uno de
ellos instalaba muchas aplicaciones que, de hecho, no dependían uno del otro.
Esto era claramente una situación no muy óptima que digamos, y no sigue la
filosofía Gentoo; fue tolerado por un largo tiempo, hasta hoy.
</p>

<p>
Los nuevos ebuilds 'separados' han enderezado esta situación, nos
proveen ebuilds separados para todas las aplicaciones del KDE. Esto nos da un
total de 330 nuevos ebuilds en la categoría kde-base.
</p>

<p>
Todavía se proveen ebuilds 'monolíticos' para KDE 3.4 e interoperan con los
'separados' transparentemente. Sin embargo, los ebuild separados son el nuevo
valor por defecto, y no habrán más ebuilds monolíticos para cuando salga el KDE
4.0.
</p>

<p>
También se encuentran los ebuilds separados para el Koffice. Estos nos proveen
de kword, kugar, etc.. como paquetes separados.
</p>

</body>
</section>
<section>
<title>Como usarlos</title>
<body>

<p>
En el momento de la edición de este documento, la última versión de KDE 3.4.0
es 3.4.0_beta1. En portage se encuentran los correspondientes ebuilds separados
(y monolíticos) enmascarados.
</p>

<ul>
  <li>
    Para realizar un emerge de un paquete particular, como kmail, simplemente
    debes de escribir <c>emerge kmail</c>.
  </li>
  <li>
   Para realizar un emerge del entorno básico del KDE en donde puedas realizar
   un login del una sesión minimalística del KDE, tienes que ejecutar <c>emerge
   kdebase-startkde</c>
  </li>
  <li>
    Finalmente, el equivalente a lo que realiza un ebuild monolítico (por
    ejemplo, para instalar todas las aplicaciones incluídas en
    <c>kdebase</c>) utilizando los ebuilds separados, debes de ejecutar
    <c>emerge kdebase-meta</c> (o kdepim-meta, etc.). Para instalar
    absolutamente todo el paquete KDE ejecuta <c>emerge kde-meta</c>
  </li>
</ul>

</body>
</section>
<section>
<title>Ventajas de utilizar los ebuilds separados</title>
<body>

<p>
Aquí se encuentra una breve lista de los beneficios obtenidos al pasarnos a
los ebuilds separados:
</p>

<ul>
  <li>
    La mayoría  de los paquetes no cambian entre versiones del KDE
    menores. Por ejemplo, al realizar una actualización del 3.3.1 al 3.3.2,
    apenas cambian alrededor de 100 de los 320 paquetes. Los paquetes separados
    nos permiten crear nuevos ebuilds solamente para aquellos paquetes que
    realmente cambian, ahorrándonos (en este ejemplo) más de dos terceras
    partes del tiempo en compilación en la actualización.
  </li>
  <li>
    Los parches usualmente afectan a un paquete en particular. Con los ebuilds
    separados, pueden ser probados y realizar un commit de ellos más rápido,
    y los desarrolladores tienen menos cosas para hacer; y como en el item
    anterior, el usuario se ahorraría tiempo en compilación al actualizar el
    KDE. En particular, esto es muy importante para las actualizaciones de
    seguridad.
  </li>
  <li>
    Los usuarios de otros entornos de escritorios y manejadores de ventanas mas
    simples, pueden realizar un emerge de las aplicaciones que ellos quieran
    sin la necesidad de instalar todas las demás aplicaciones de, por ejemplo,
    kdebase o kdepim.
  </li>
  <li>
    Los usuarios tienen un control más detallado con respecto a los paquetes que
    tienen instalados. Las razones por las cuales querrás esto son:
    
    <ul>
      <li>
        Te importa el tiempo de compilación. <c>emerge kdebase kdepim
        kdenetwork</c> tarda mucho tiempo cuando lo único que necesitas es
        konqueror, kmail y kopete.
      </li>
      <li>
        Te importa el uso del espacio en el disco.  Cada paquete que no es
        usado, malgasta muchos megabytes de tu disco, "tapando sus poros". Un
        disco con más espacio libre puede "respirar mejor"; es un disco
        rígido feliz :).
      </li>
      <li>
        Te importa la seguridad de tu sistema. Todo el software instalado es
	una fuente potencial de vulnerabilidades, y no existe excusa alguna
        para andar teniendo software por ahí en tu sistema sin ser usado.
      </li>
      <li>
        Tu sigues fielmente la
        <uri link="http://www.gentoo.org//main/en/philosophy.xml">filosofía de
Gentoo</uri> al hacer las cosas, y no soportas el hecho de que muchos
programas estén en un enorme paquete, forzándote a instalarlos.
      </li>
    </ul>
  </li>
  <li>
    Finalmente, los ebuilds separados también nos permiten más flexibilidad con
    respecto al tiempo de compilación y el uso de los parámetros USE (USE flags).
  </li>
</ul>

</body>
</section>
<section>
<title>Interoperabilidad entre los ebuilds separados y monolíticos</title>
<body>

<p>
Los ebuilds monolíticos y separados pueden ser mezclados libremente. La única
restricción es que un ebuild monolítico no puede ser instalado al mismo tiempo
que un ebuild separado derivado de este. Existen dependencias que bloquean en
los ebuilds que refuerzan esto, así que solo podrás hacer cualquier cosa que
emerge te permita.
</p>

<p>
Sin embargo, por lo general, no existe razón alguna para utilizar una
configuración mixta. De hecho, excepto en casos especiales, como que
la compilación tarde demasiado (CPUs mips), deberías utilizar los ebuilds
separados.
</p>

<p>
Los ebuilds separados son los ebuilds por defecto. Esto significa que cuando
otro ebuild dependa de una aplicación de KDE, querra instalar un ebuild
separado. Sin embargo, el ebuild monolítico equivalente también cumpliría con la
dependencia, de manera que puedes realizar un emerge del ebuild monolítico
manualmente y luego realizar el emerge del ebuild que depende del mismo.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Inconvenientes de rendimiento</title>
<section>
<title>Porque los ebuilds separados son lentos</title>
<body>

<p>
Se ha <uri link="http://bugs.gentoo.org/show_bug.cgi?id=11123">dicho</uri> que
debido a la sobrecarga de descomprimir y ejecutar 'configure' por
cada paquete los ebuilds separados tomarán mucho más tiempo en realizar un
emerge que los monolíticos. Un <c>emerge kde-meta</c> podría tomar un 20-30%
más que el clásico <c>emerge kde</c>, el cual es inaceptable debido al ya largo
tiempo de compilación.
</p>

<p>
Además, en este momento los ebuilds separados siempre ejecutan <c>make -f
admin/Makefile.cvs</c> (esto significa ejecutar autoconf, automake, etc. y demás
scripts relacionados al kde). El tiempo que esto toma, se encuentra en el
mismo orden que tarda el configure para ejecutarse.
</p>

<p>
A simple vista se puede observar que este análisis es méramente superficial y no
es muy detallado. Muchos de los factores causantes de esta relentización, serán
detallados en las próximas secciones.
</p>

<p>
Vale la pena reiterar que con los ebuilds separados el tiempo de actualización
del KDE puede ser 2 veces mas rápido, y en algunos casos 10 o más veces,
con el simple hecho de realizar una actualización de los paquetes que realmente
cambian. El beneficio de una nica actualización por lo general hace valer la
pena pasar por la sobrecarga inicial de la instalación.
</p>

<p>
Finalmente, instalar todo el KDE tiene sentido si quieres explorar los paquetes
disponibles o si estás configurando un entorno multi-usuario; sin embargo, la
mayoría de las personas utilizan algunas de las más de 300 aplicaciones disponibles
del KDE. Cualquier persona a quien le importe el tiempo de compilación, como
los usuarios que poseen máquinas viejas, pueden ganar mas tiempo seleccionando
solamente los paquetes que quieran.
</p>

</body>
</section>
<section>
<title>Que se hará para acelerar los ebuilds separados</title>
<body>

<p>
La mejora más obvia será la de distribuir archivos .tar.gz/tar.bz2 
(tarballs) para los ebuilds separados, evitando así el hecho de descomprimir
piezas de los tarballs de los ebuilds monolíticos (kdebase, etc...) que son
distribuidos oficialmente. Esto eliminaría dos de los tres factores que influyen
en la sobrecarga del sistema: la repetida extracción de enormes tarballs y la
regeneración de los archivos makefile ( la etapa de <c>make -f
admin/Makefile.cvs</c> descripta arriba).
</p>

<p>
Esto nos deja solamente con el inconveniente de ejecutar repetidamente
 <c>configure</c>. La solución apropiada a este problema es confcache: es un
cache de configure que se comparte entre ejecuciones del emerge. Ya existe una
implementación en la rama de desarrollo de portage (la herramienta, no el árbol
de paquetes); se espera una versión estable de confcache para dentro de
aproximadamente 6 meses.
</p>

</body>
</section>
<section>
<title>Otros factores que relentizan los ebuilds separados.
</title>
<body>

<p>
En la sección anterior se mencionan métodos para mejorar el rendimiento de los
ebuilds separados en particular. A continuación, mencionaremos algunas mejoras
que son igualmente aplicables a los ebuilds monolíticos como a los separados.
Estas mejoras ayudan a que los ebuilds separados sean lo 'suficientemente
rápidos'.
</p>

<ul>
  <li>
    KDE 4.0 tendría que ser capaz de utilizar <uri
    link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri> en vez
    de automake, que en algunos casos acelera la compilación;
    eventualmente nuestros ebuilds del KDE 3.4 también utilizarán unsermake.
  </li>
  <li>
    Los ebuilds separados soportan el parámetro USE llamada 'kdexdeltas', que
    permite bajar archivos diff binarios entre versiones del KDE, de manera
    que se pueda ahorrar el uso del ancho de banda.
  </li>
  <li>
    Todas las demás herramientas involucradas en la construcción serán aún mas
    rápidas con el pasar del tiempo, y consecuentemente los tiempos de
    compilación de varios paquetes relacionados con kde serán menores. La nueva
    funcionalidad del GCC 4.0 (visibility=hidden) y las cabeceras precompiladas
    son dos ejemplos actuales. No son algo que uno gana debido al hecho de
    utilizar ebuilds separados; solo significa que ahora podemos sobrellevar
    compilaciones que utilizan más la CPU.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Preguntas Frecuentes de los ebuilds separados</title>
<section>
<title>Actualmente, ¿no se puede hacer esto con DO_NOT_COMPILE?</title>
<body>

<p>
DO_NOT_COMPILE es una variable interna de entorno que usa el sistema de
construcción de KDE. Permite seleccionar los directorios que no queremos que se
compilen. Algunas personas lo usaban para compilar un subconjunto de los ebuilds
monolíticos del KDE. Por ejemplo, si ejecutamos 
 <c>DO_NOT_COMPILE=konqueror emerge kdebase</c>, entonces instalaríamos a
kdebase sin la aplicación konqueror.
</p>

<p>
Sin embargo, DO_NOT_COMPILE nunca fue diseñado para interactuar de manera
alguna con ningún sistema de manejo de paquetes, en particular portage. No
funciona, puede romper tu sistema y jamás fue soportado. Les pedimos a todos
que desistan de su uso.
</p>

<p>
Aquí se detalla una lista parcial de los problemas que ocasiona DO_NOT_COMPILE:
</p>

<ul>
  <li>
    Rompe completamente con el sistema de localización de depenencias de
    portage. Portage no sabe nada acerca de DO_NOT_COMPILE, y piensa que el
    paquete monolítico entero fue instalado y puede satisfacer una dependencia
    de otro paquete. Esto puede causar que otros paquetes no puedan ser
    instalados o que no puedan ejecutarse.
  </li>
  <li>
    Obliga al usuario a saber acerca de los nombres y significados de todos los
    subdirectorios de los módulos del KDE. Muy pocos usuarios saben acerca de
    esto, y a menos que sean desarrolladores del KDE, no saben utilizar
    DO_NOT_COMPILE apropiadamente. 
  </li>
  <li>
    Los módulos del KDE pueden tener interdependencias entre ellos, y requieren
    de un orden en particular para poder ser construídos, también requieren que
    otro subdirectorio se encuentre presente incluso si no es necesario
    instalarlo. En este aspecto, hemos puesto mucho trabajo en los ebuilds
    separados, de manera que funcionen correctamente.  DO_NOT_COMPILE no se
    acerca ni un poquito para poder ser una herramienta que consiga los mismos
    resultados que los ebuilds separados, incluso si se le diera suficiente
    información al usuario para poder usarlo. La única cosa que hace es
    deshabilitar la compilación de un par de aplicaciones. Es prácticamente
    imposible que sea utilizado para seleccionar la instalación de determinadas
    aplicaciones de los modulos como kdebase o kdepim.
  </li>
  <li>
    Si ayer instalé kmail y hoy quisiera agregar korn, utilizando
    DO_NOT_COMPILE, nos llevaría a compilar a kmail nuevamente. Esto significa
    que DO_NOT_COMPILE siempre será mas lento que los ebuilds separados.
  </li>
  <li>
    DO_NOT_COMPILE no puede ser usado para realizar paquetes precompilados
    (como el GRP) conteniendo aplicaciones individuales del KDE.
  </li>
</ul>

</body>
</section>
<section>
<title>¿No estarán asignándole demasiado trabajo a los mantenedores de los
paquetes de Gentoo KDE?</title>
<body>

<p>
Sorpresivamente, ésta es una pregunta que siempre hacen. Estoy halagado que los
usuarios sean tan considerados con nosotros los mantenedores. Pero dejenmé
aprovechar esta oportunidad para decirles que nosotros estamos haciendo esto
por nuestra propia voluntad; que creemos que podremos continuar manteniendo los
ebuilds con una buena calidad; y que nadie nos podrá convencer a que dejemos de
hacerlo.
</p>

<p>
Mencionaré que los mantenedores de otras arquitecturas se han quejado por el
gran aumento de trabajo que les toma realizar verificaciones y modificaciones a
tantos ebuilds separados. Estamos trabajando para resolver esto y cabe aclarar
que esto fué una de las grandes razones por las cuales existen ebuilds
monolíticos para el KDE 3.4.
</p>

</body>
</section>
<section>
<title>¿Van a borrar los ebuilds monolíticos?</title>
<body>

<p>
Tenemos la idea de, eventualmente, borrarlos. Sin embargo, existirán los
ebuilds monolíticos y separados para las todas versiones del KDE 3.4.
</p>

<p>
Si prefieres utilizar los ebuilds monolíticos, por favor, 
<uri link="http://bugs.gentoo.org">cuéntanos</uri> tus razones.
</p>

</body>
</section>
<section>
<title>¡Hay tantos ebuilds!, ¿Cómo se supone que voy a encontrar los que
necesito?</title>
<body>

<p>
Bueno, primero que nada, si sabes que el paquete que estás buscando se
encuentra en kdebase, entonces puedes, todavía, ejecutar <c>emerge
kdebase-meta</c>, con casi los mismos resultados que si hubieses realizado un
emerge del ebuild monolítico <c>kdebase</c>. Así que, en realidad, las cosas no
han empeorado para nada debido a la introducción de los ebuilds separados.
</p>

<p>
Obviamente, siguen vigentes todas las maneras de localizar un paquete. ¿Cómo
encontrarías tu ebuild si fuese una aplicación de Gnome?. Mínimamente deberías
de saber, por lo menos, el nombre de la aplicación que estas buscando.
</p>

<p>
Tal vez, la situación podría ser mejorada con la introducción de varios
paquetes -meta. Solamente son listas de dependencias, así que no nos costaría
nada. Esto todavía no ha sido decidido. Sin embargo estaría bien tener la funcionalidad de conjuntos en Portage antes de usar este recurso demasiado.
</p>

</body>
</section>
<section>
<title>¿Cómo puedo realizar un unmerge del KDE viejo?</title>
<body>

<p>
Supongamos que sale la versión 4.0 del KDE y que quieres realizar un unmerge de
todos los ebuilds separados del KDE 3.4. Debido a que corresponden a diferentes
slots, el programa emerge no te permitirá hacer esto, así que se necesita hacerlo de otra forma.
</p>

<p>
Una solución a este problema requiere modificaciones a portage. Una posible
solución se encuentra descrita en <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>. Sin
embargo, antes de que eso esté implementado, deberemos utilizar scripts como el
siguiente:
</p>

<p>
Afortunadamente, todos los ebuilds del KDE pertenecen al directorio kde-base
(y todos los ebuilds en la categoría kde-base provienen de kde.org). Así que el
siguiente código funciona:
</p>

<pre>
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
Lo de arriba parece muy de 'hacker', pero en realidad no lo es, porque lo único
que necesitamos es una lista de ebuilds provenientes de kde-base. Eso es una
tarea simple por lo que siempre existirán maneras fáciles de realizarlo.
</p>

</body>
</section>
<section>
<title>¿Cómo puedo listar y/o realizar un unmerge de todos los ebuilds separados
derivados de un paquete dado?</title>
<body>

<p>
El objetivo aquí es el de listar todos los ebuilds del KDE derivados de, por
ejemplo, el ebuild monolítico kde-base. Una vez más, una implementación
apropiada (como <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>) haría
de esto algo trivial. Sin embargo, hoy, tienes que entender la implementación de
los eclasses del KDE. Así que, si quieres utilizar alguno de estos métodos en
un script que no sea para uso personal, por favor cuéntanos.
</p>

<p>
kde-functions.eclass define las funciones llamadas get-parent-package() y
get-child-packages() que hacen la "traducción" por tí. Estas dos funciones son
la manera correcta de completar satisfactoriamente este trabajo a partir de un
ebuild o de un script de bash externo. Aquí te mostramos un ejemplo:
</p>

<pre>
$ <i>function die() { echo $@; } # se llama para reportar errores</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # no va a funcionar, tienes que especificar el
nombre completo</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug #
el error es mostrado en la salida</i>
$ <i>get-parent-package kde-base/konqueror # nombre completo del
paquete</i>
<i>kde-base/kdebase # el resultado es mostrado por pantalla</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (una enorme lista de paquetes mostrado aquí)</i>
</pre>

<p>
Si tu script no está escrito en bash, puedes realizar un grep del
kde-functions.eclass para extraer la definición (multilínea) de la variable
KDE_DERIVATION_MAP, que las funciones mencionadas usan. Esta variable contiene
una lista de palabras separadas por un espacio en blanco; y cada par de palabras
consecutivas realizan un mapeo entre un paquete "padre" contra un hijo ebuild
separado.
</p>

</body>
</section>
</chapter>
</guide>
