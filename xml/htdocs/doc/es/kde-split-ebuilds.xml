<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/Attic/kde-split-ebuilds.xml,v 1.5 2007/01/25 16:24:24 chiguire Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/kde-split-ebuilds.xml" lang="es">
<title>El COMO de los Ebuilds separados de KDE</title>

<author title="Autor">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Editor">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Traductor">
  <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
</author>
<author title="Traductor">
  <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
</author>
<author title="Traductor">
  <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
</author>
<author title="Traductor">
  <mail link="nmiyasato@datafull.com">Nicolás Miyasato</mail>
</author>
<author title="Traductor">
  <mail link="anpereir@gentoo.com">Andrés Pereira</mail>
</author>

<abstract>
Con el lanzamiento de KDE 3.4, se incorporaron a Portage los 'ebuilds
separados'. Esta página documenta las razones detrás de esta transición, las
nuevas funcionalidades brindadas por la misma y la forma de actualizar 
del viejo estilo de los ebuilds 'monolíticos'.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.9</version>
<date>2006-12-22</date>

<chapter>
<title>Los ebuilds separados de KDE</title>
<section>
<title>¿Qué son?</title>
<body>

<p>
Hasta enero del 2005, los únicos ebuilds de KDE en Portage eran los
'monolíticos'. Eso significa que solamente existían 15 ebuilds
(<c>kdebase</c>, <c>kdenetwork</c>, ...), y cada uno de ellos
instalaba muchas aplicaciones que, de hecho, no dependían uno del
otro. Esto era claramente una situación no muy óptima que digamos, y
no sigue la filosofía Gentoo; pero fue tolerado por un largo tiempo.
</p>

<p>
Los nuevos ebuilds 'separados' (para <c>konqueror</c>, <c>kmail</c>,
...) han rectificado esta situación proporcionando ebuilds separados
para todas las aplicaciones de KDE. Esto nos da un gran total de unos
330 nuevos ebuilds en la categoría kde-base.
</p>

<p>
Todavía proporcionamos ebuilds 'monolíticos' para KDE 3.4 y 3.5 e
interoperan con los 'separados' transparentemente. Sin embargo, los
ebuild separados son nueva manera por defecto y no habrán más ebuilds
monolíticos para KDE 4.0.
</p>

<p>
También se encuentran los ebuilds separados para el Koffice. Estos nos
proveen de <c>kword</c>, <c>kugar</c>, etc. como paquetes separados.
</p>
</body>
</section>

<section>
<title>¿Cómo usarlos?</title>
<body>

<p>
En el momento de edición de este documento, la última versión de KDE
es la 3.5.2. La última versión inestable (~arch) es la 3.5.4. En
Portage se encuentran los correspondientes ebuilds separados y
monolíticos para ambas versiones.
</p>

<ul>
  <li>
    Para realizar un emerge de un paquete particular, como kmail,
    simplemente debe ejecutar <c>emerge kmail</c>.
  </li>
  <li>
   Para realizar un emerge del entorno básico del KDE en donde puedas
   realizar un login del una sesión minimalística del KDE, tienes que
   ejecutar <c>emerge kdebase-startkde</c>
  </li>
  <li>
    Finalmente, para obtener el equivalente exacto a lo realizado por
    un ebuild monolítico (por ejemplo, para instalar todas las
    aplicaciones incluidas en <c>kdebase</c>) con ebuilds separados,
    debe ejecutar <c>emerge kdebase-meta</c> (o <c>kdepim-meta</c>,
    etc.). Para instalar absolutamente todo el paquete KDE ejecute
    <c>emerge kde-meta</c>
  </li>
</ul>
</body>
</section>

<section>
<title>¿Cómo actualizar ebuilds de monolíticos a separados?</title>
<body>
 
<p>
Si tiene instalado KDE 3.3.x, puede simplemente ejecutar <c>emerge
kde-meta</c> para instalar los ebuilds separados de 3.5.x sin afectar su
instalación existente.
</p>
 
<p>
Si tiene instalados los ebuilds monolíticos de KDE 3.4.x ó 3.5.x, debe
desinstalarlos antes de proceder con los ebuilds separados. No
obstante, este proceso puede ser hecho por partes, es decir, puede
desinstalar los ebuilds monolíticos uno a uno sin tener que
desinstalar todo KDE de una vez.
</p>

<p>
Si tiene dudas, recuerde que hay dependencias bloqueantes entre cada ebuild
monolítico y los ebuilds separados que derivan del primero. Portage no
permitirá que se cree un estado ilegal, así que cualquier emerge o unmerge
que permita estará correcto.
</p>
</body>
</section>

<section>
<title>Ventajas de utilizar los ebuilds separados</title>
<body>

<p>
Aquí se encuentra una breve lista de los beneficios obtenidos al
pasarnos a los ebuilds separados:
</p>

<ul>
  <li>
    La mayoría de los paquetes no cambian entre versiones menores de
    KDE. Por ejemplo, al realizar una actualización del 3.3.1 al
    3.3.2, apenas cambian alrededor de 100 de los 320 paquetes. Los
    paquetes separados nos permiten crear nuevos ebuilds solamente
    para aquellos paquetes que realmente cambian, ahorrándonos (en
    este ejemplo) más de dos tercios del tiempo en compilación en la
    actualización.
  </li>
  <li>
    Los parches usualmente afectan a un paquete en particular. Con los
    ebuilds separados, pueden ser probados y realizar un commit de
    ellos más rápido, y los desarrolladores tienen menos cosas para
    hacer; y como en el ítem anterior, el usuario se ahorraría tiempo
    en compilación al actualizar el KDE. En particular, esto es muy
    importante para las actualizaciones de seguridad.
  </li>
  <li>
    Los usuarios de otros entornos de escritorios y administradores de
    ventanas más sencillos, pueden instalar vía emerge las aplicaciones
    que quieran sin necesidad de instalar todas las demás aplicaciones
    de, por ejemplo, <c>kdebase</c> o <c>kdepim</c>.
  </li>
  <li>
    Los usuarios tienen un control más detallado con respecto a los
    paquetes que tienen instalados. Las razones por las cuales querrá
    esto son:
    <ul>
      <li>
        Le importa el tiempo de compilación. <c>emerge kdebase kdepim
        kdenetwork</c> tarda demasiado tiempo cuando lo único que
        necesita es <c>konqueror</c>, <c>kmail</c> y <c>kopete</c>,
        aparte la consideración que el tiempo es dinero ... en alguna
        parte.
      </li>
      <li>
        Le importa el uso del espacio en el disco. Cada paquete no
        usado, malgasta muchos megabytes, "tapando los poros" del
        disco. Un disco con más espacio libre puede "respirar mejor";
        es un disco rígido feliz :).
      </li>
      <li>
        Le importa la seguridad de su sistema. Todo el software instalado es
        una fuente potencial de vulnerabilidades, y no existe excusa alguna
        para andar teniendo software por ahí en su sistema sin ser usado.
      </li>
      <li>
        Es fiel adherente de la <uri
        link="/main/en/philosophy.xml">Filosofía Gentoo</uri> y no
        soporta el hecho que muchos programas estén en un enorme
        paquete forzado sobre los usuarios. Nosotros tampoco lo
        soportamos.
      </li>
    </ul>
  </li>
  <li>
    Finalmente, los ebuilds separados también nos permiten más
    flexibilidad con respecto al tiempo de compilación y el uso de los
    parámetros USE.
  </li>
</ul>
</body>
</section>

<section>
<title>Interoperabilidad entre los ebuilds separados y
monolíticos</title>
<body>

<p>
Los ebuilds monolíticos y separados pueden ser mezclados
libremente. La única restricción es que un ebuild monolítico no puede
ser instalado al mismo tiempo que un ebuild separado derivado de
este. Existen dependencias bloqueantes en los ebuilds que hagan esto,
así que sólo podrá hacer cualquier cosa que emerge le permita.
</p>

<p>
Sin embargo, por lo general, no existe razón alguna para utilizar una
configuración mixta. De hecho, excepto en casos especiales, como que
la compilación tarde demasiado (CPUs mips), debería utilizar los
ebuilds separados.
</p>

<p>
Los ebuilds separados son los ebuilds por defecto. Esto significa que
cuando otro ebuild dependa de una aplicación de KDE, querrá instalar
un ebuild separado. Sin embargo, el ebuild monolítico equivalente
también cumpliría con la dependencia, de manera que puede realizar un
emerge del ebuild monolítico manualmente y luego realizar el emerge
del ebuild que depende del mismo.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Inconvenientes de rendimiento</title>
<section>
<title>¿Por qué los ebuilds separados son lentos?</title>
<body>

<p>
Se ha <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=11123">dicho</uri> que
debido a la sobrecarga de descomprimir y ejecutar 'configure' por cada
paquete los ebuilds separados tomarán mucho más tiempo en realizar un
emerge que los monolíticos. Un <c>emerge kde-meta</c> podría tomar un
20-30% más que el clásico <c>emerge kde</c>, lo cual es inaceptable
debido al ya largo tiempo de compilación.
</p>

<p>
Además, en este momento los ebuilds separados siempre ejecutan <c>make
-f admin/Makefile.cvs</c> (esto significa ejecutar autoconf, automake,
etc. y demás guiones relacionados a KDE). Esto añade una tardanza
adicional aproximadamente del mismo orden que demora al ejecutarse
'configure'.
</p>

<p>
Finalmente, un ebuild separado necesita extraer archivos específicos
desde un archivo tar grande. Esto es más lento que realizar la
extracción desde un archivo tar pequeño y dedicado. No obstante, crear
archivos tar pequeños para el sistema de construcción basado en
autotools del KDE 3.X es difícil.
</p>

<p>
Vale la pena reiterar que con los ebuilds separados, el tiempo de
actualización de KDE puede ser considerablemente reducido con el
simple hecho de realizar una actualización de los paquetes que
realmente cambian. El beneficio de una actualización única por lo
general hace que valga la pena pasar por la sobrecarga inicial de la
instalación.
</p>

<p>
Finalmente, instalar todo el KDE tiene sentido si quiere explorar los
paquetes disponibles o si está configurando un entorno multi-usuario;
sin embargo, la mayoría de las personas utilizan sólo algunas de las
más de 300 aplicaciones disponibles de KDE. Cualquier persona a quien
le importe el tiempo de compilación, como los usuarios que poseen
máquinas viejas, pueden ganar mas tiempo seleccionando solamente los
paquetes que quieran.
</p>
</body>
</section>

<section>
<title>¿Que se hará para acelerar los ebuilds separados?</title>
<body>

<p>
La mayor parte o incluso todos los problemas de rendimiento de los
ebuilds separados se relacionan a autotools - autoconf, automake y
otras herramientas que gestionan el sistema de construcción
<c>./configure;make;make install</c> usado en KDE 3.x.
</p>

<p>
KDE 4 (por lo que podemos decir hasta ahora) adoptará un sistema de
construcción completamente nuevo, que entre otras cosas, reducirá
considerablemente el tiempo que su equivalente <c>make -f
admin/Makefile.common; ./configure</c> tomará. Se espera que esto haga
mucho más fácil la creación de un archivo tar pequeño para cada ebuild
separado reduciendo el costo de generar su equivalente de los guiones
configure (si los hubiese).
</p>
</body>
</section>
</chapter>

<chapter>
<title>PFU (FAQ) de los ebuilds separados</title>
<section>
<title>¿Por qué hay algunos paquetes separados que les faltan las
versiones de ebuilds más nuevas?</title>
<body>

<p>
Como explicamos arriba, no todas las aplicaciones son verdaderamente
actualizadas entre versiones menores de KDE, así no todas las
aplicaciones tienen nuevas versiones de ebuild. Por ejemplo,
libkdenetwork no fue actualizado en 3.5.0_beta2, de forma que el
último ebuild disponible con aquella versión fue 3.5_beta1.
</p>

<p>
Este se hace meramente para reducir el tiempo de compilación durante
una actualización. Si hubiéramos hecho un ebuild
libkdenetwork-3.5.0_beta2, este habría instalado precisamente los
mismos archivos que el ebuild 3.5_beta1. Las varias dependencias son
actualizadas para funcionar correctamente (es decir, no habrá ebuild
alguno que dependa de libkdenetwork-3.5.0_beta2).
</p>
</body>
</section>

<section>
<title>Actualmente, ¿no se puede hacer esto con
DO_NOT_COMPILE?</title>
<body>

<p>
DO_NOT_COMPILE es una variable de entorno interna que usa el sistema
de construcción de KDE. Permite seleccionar los subdirectorios que no
queremos que se compilen. Algunas personas lo usaban para compilar un
subconjunto de los ebuilds monolíticos del KDE. Por ejemplo, si
ejecutamos <c>DO_NOT_COMPILE=konqueror emerge kdebase</c>, entonces
instalaríamos kdebase sin la aplicación <c>konqueror</c>.
</p>

<p>
Sin embargo, DO_NOT_COMPILE nunca fue diseñado para interferir con la
operación alguna con el sistema de administración de paquetes, en
particular, Portage. No funciona, puede romper su sistema y jamás fue
soportado. Les pedimos a todos que desistan de su uso.
</p>

<p>
Aquí se detalla una lista parcial de los problemas que ocasiona
DO_NOT_COMPILE:
</p>

<ul>
  <li>
    Rompe completamente con el sistema de localización de dependencias
    de Portage. Portage no sabe nada acerca de DO_NOT_COMPILE, y
    piensa que el paquete monolítico entero fue instalado y puede
    satisfacer una dependencia de otro paquete. Esto puede causar que
    otros paquetes no puedan ser instalados o que no puedan
    ejecutarse.
  </li>
  <li>
    Obliga al usuario a saber acerca de los nombres y significados de
    todos los subdirectorios de los módulos del KDE. Muy pocos
    usuarios saben acerca de esto, y a menos que sean desarrolladores
    de KDE, no saben utilizar DO_NOT_COMPILE apropiadamente.
  </li>
  <li>
    Los módulos de KDE pueden tener interdependencias entre ellos y
    requieren de un orden en particular para poder ser construidos,
    también requieren que otro subdirectorio se encuentre presente
    incluso si no es necesario instalarlo. En este aspecto, hemos
    puesto mucho trabajo en los ebuilds separados, de manera que
    funcionen correctamente.  DO_NOT_COMPILE no se acerca ni un
    poquito para poder ser una herramienta que consiga los mismos
    resultados que los ebuilds separados, incluso si se le diera
    suficiente información al usuario para poder usarlo. La única cosa
    que hace es deshabilitar la compilación de un par de
    aplicaciones. Es prácticamente imposible que sea utilizado para
    seleccionar la instalación de determinadas aplicaciones de los
    módulos como <c>kdebase</c> o <c>kdepim</c>.
  </li>
  <li>
    Si ayer instalé kmail y hoy quisiera agregar korn, utilizando
    DO_NOT_COMPILE, nos llevaría a compilar a kmail nuevamente. Esto
    significa que DO_NOT_COMPILE siempre será mas lento que los
    ebuilds separados.
  </li>
  <li>
    DO_NOT_COMPILE no puede ser usado para realizar paquetes
    precompilados (como el GRP) conteniendo aplicaciones individuales
    del KDE.
  </li>
</ul>
</body>
</section>

<section>
<title>¿No estarán colocándole demasiada carga a los mantenedores de
Gentoo KDE?</title>
<body>

<p>
Sorpresivamente, ésta es una pregunta que siempre hacen. Estamos
halagados que los usuarios sean tan considerados con nosotros los
mantenedores. Pero permítanos aprovechar esta oportunidad para
decirles que nosotros estamos haciendo esto por nuestra propia
voluntad; que creemos que podremos continuar manteniendo los ebuilds
con una buena calidad; y que nadie nos podrá convencer que dejemos de
hacerlo.
</p>

<p>
Por completitud, mencionamos que los mantenedores de otras
arquitecturas se han quejado por el gran aumento de trabajo que les
toma realizar verificaciones y modificaciones a tantos ebuilds
separados. Estamos trabajando para resolver esto y cabe aclarar que
esto fue una de las grandes razones por las cuales existen todavía
ebuilds monolíticos para el KDE 3.5.
</p>
</body>
</section>

<section>
<title>¿Van a borrar los ebuilds monolíticos?</title>
<body>

<p>
Tenemos la idea de, eventualmente, borrarlos. Sin embargo, existirán
los ebuilds monolíticos y separados para las todas versiones de KDE
3.x.
</p>

<p>
Si prefiere utilizar los ebuilds monolíticos por sobre los separados,
por favor, <uri link="http://bugs.gentoo.org">cuéntenos</uri> sus
razones.
</p>
</body>
</section>

<section>
<title>¡Hay tantos ebuilds!, ¿Cómo se supone que voy a encontrar los
que necesito?</title>
<body>

<p>
Bueno, primero que nada, si sabe que el paquete que está buscando se
encuentra en kdebase, entonces puede, todavía, ejecutar <c>emerge
kdebase-meta</c>, con casi los mismos resultados que si hubiese
realizado un emerge del ebuild monolítico <c>kdebase</c>. Así que, en
realidad, las cosas no han empeorado para nada debido a la
introducción de los ebuilds separados.
</p>

<p>
Obviamente, siguen vigentes todas las maneras de localizar un
paquete. ¿Cómo encontraría su ebuild si fuese una aplicación de
Gnome?. Mínimamente debería de saber, por lo menos, el nombre de la
aplicación que estas buscando.
</p>

<p>
Tal vez, la situación podría ser mejorada con la introducción de
varios paquetes -meta. Solamente son listas de dependencias, así que
no nos costaría nada. Esto todavía no ha sido decidido. Sin embargo
sería bueno tener la funcionalidad de conjuntos en Portage antes de
hacer esto en extenso.
</p>
</body>
</section>

<section>
<title>¿Cómo puedo listar y/o realizar un unmerge de todos los ebuilds
separados derivados de un paquete dado?</title>
<body>

<p>
El objetivo aquí es el de listar todos los ebuilds de KDE derivados
de, por ejemplo, el ebuild monolítico kde-base. Una vez más, una
implementación apropiada (como <uri
link="/proj/en/glep/glep-0021.html">GLEP 21</uri>) haría de esto algo
trivial. Sin embargo, hoy, tiene que entender en cierto grado la
implementación de las eclasses de KDE. Así que, si usa alguno de estos
métodos en un guión que no sea para uso personal, por favor
cuéntenos.
</p>

<p>
kde-functions.eclass define las funciones llamadas
get-parent-package() y get-child-packages() que llevan a cabo la
"traducción". Estas dos funciones son la manera correcta de completar
satisfactoriamente este trabajo a partir de un ebuild o de un guión
de bash externo. Aquí le mostramos un ejemplo:
</p>

<pre caption="Ejemplo de uso de las funciones de kde-functions">
$ <i>function die() { echo $@; } # se llama para reportar errores</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # no va a funcionar, tiene que especificar el
nombre completo</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug # el error es mostrado en la salida</i>
$ <i>get-parent-package kde-base/konqueror # nombre completo del paquete</i>
<i>kde-base/kdebase # el resultado es mostrado por pantalla</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (una enorme lista de paquetes mostrado aquí)</i>
</pre>

<p>
Si su guión no está escrito en bash, puede realizar un grep del
kde-functions.eclass para extraer la definición (multilínea) de la
variable KDE_DERIVATION_MAP, que las funciones mencionadas usan. Esta
variable contiene una lista de palabras separadas por un espacio en
blanco; y cada par de palabras consecutivas realizan un mapeo entre un
paquete "padre" a un hijo ebuild separado.
</p>
</body>
</section>
</chapter>
</guide>
