<?xml version = '1.0' encoding = 'UTF-8' ?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/vserver-howto.xml,v 1.3 2006/04/04 11:03:59 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/vserver-howto.xml" lang="es">
<title>Cómo Gentoo Linux-VServer</title>

<author title="Author" >
  <mail link="hollow@gentoo.org" >Benedikt Boehm</mail>
</author>
<author title="Editor" >
  <mail link="fox2mike@gentoo.org" >Shyam Mani</mail>
</author>
<author title="Traductor" >
  <mail link="chiguire@gentoo.org" >John Christian Stoddart</mail>
</author>
<author title="Traductor" >
  <mail link="yoswink@gentoo.org" >José Luis Rivero</mail>
</author>
<author title="Traductor" >
  <mail link="carles@carles.no-ip.info" >Carles Ferrer Peris</mail>
</author>


<abstract>
En este Cómo aprenderemos a poner en marcha un servidor virtual básico
usando la Tecnología Linux-VServer
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2006-03-17</date>

<chapter>
<title>Introducción</title>
<section>
<title>El concepto Linux-VServer</title>
<body>

<p>
El concepto básico de una solución Linux-VServer es dividir el entorno
de espacio de usuario en unidades separadas (llamadas a veces
Servidores Virtuales Privados, &quot;Virtual Private Servers&quot; en
inglés) de tal forma que cada VPS parece y se comporta como un
servidor verdadero de cara a los procesos contenidos dentro.
</p>

</body>
</section>
<section>
<title>Terminología usada en este Cómo</title>
<body>

<table>
<tr>
  <th>Término</th>
  <th>Descripción</th>
</tr>
<tr>
  <th>Linux-VServer, VServer</th>
  <ti>
    Linux-VServer es el nombre oficial del proyecto y es usado en este
    documento de la misma manera
  </ti>
</tr>
<tr>
  <th>servidor virtual, vserver, sistema huésped, guest</th>
  <ti>
    Son todos términos intercambiables y se refieren a una instancia
    de un servidor (es decir, un servidor virtual)
  </ti>
</tr>
<tr>
  <th>sistema anfitrión, host</th>
  <ti>
    La máquina física que ejecuta Gentoo Linux y albergará todos los
    servidores virtuales
  </ti>
</tr>
<tr>
  <th>util-vserver</th>
  <ti>
    El paquete <c>util-vserver</c> contiene todos los programas
    necesarios para mantener los servidores virtuales
  </ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Configuración del anfitrión</title>
<section>
<title>Instalación del núcleo VServer</title>
<body>

<pre caption="Instalación de vserver-sources" >
# <i>emerge vserver-sources</i>
</pre>

<p>
Después de que las vserver-sources se hayan instalado es el momento de
configurarlas usando <c>make menuconfig</c>.
</p>

<pre caption="Configuración de vserver-sources" >
# <i>cd /usr/src/linux-&lt;KERNELVERSION>-vserver-&lt;VSERVERVERSION></i>
# <i>make menuconfig</i>

Linux VServer ---&gt;
  [ ] Enable Legacy Kernel API
  [*] Disable Legacy Networking Kernel API
<comment>(Altamente recomendado)</comment>
  [*] Enable Proc Security
  [*] Enable Hard CPU Limits
  Persistent Inode Context Tagging (UID24/GID24)  ---&gt;
  [ ] Tag NFSD User Auth and Files
  [ ] Compile Debugging Code
</pre>

<note>
Si utilizamos reiserfs como sistema de ficheros en la partición donde
se almacenan las imágenes de loa huéspedes, deberemos habilitar los
atributos extendidos de reiserfs en la configuración del núcleo y
adicionalmente añadir la opción <c>attrs</c> en
<path>/etc/fstab</path>.
</note>
		
<pre caption="Configurar las opciones de reiserfs">
File systems  --->
  &lt;*&gt; Reiserfs support
  [*]   ReiserFS extended attributes
</pre>
		
<pre caption="Ejemplo de fstab con atributos extendidos">
/dev/hdb /vservers reiserfs noatime,attrs 0 0
</pre>

<p>
Después de haber compilado e instalado el núcleo, hay que actualizar
el gestor de arranque y finalmente reiniciar para ver si el núcleo
arranca correctamente.
</p>

<pre caption="Instalación del kernel" >
<comment>(Compilar el núcleo)</comment>
# <i>make</i>
<comment>(Instalación)</comment>
# <i>make modules_install</i>
# <i>cp arch/&lt;arch&gt;/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
<comment>(Editar el fichero de configuración del gestor de arranque como se necesite y)</comment>
# <i>reboot</i>
</pre>

</body>
</section>
<section>
<title>Configuración del entorno del anfitrión</title>
<body>

<p>
Para mantener los servidores virtuales se necesita el paquete
util-vserver que contiene todos los programas necesarios y algunas
utilidades prácticas.  Hay que tener precaución porque también existe
un paquete llamado <c>vserver-utils</c> que es una nueva versión de la
implementación de espacio de usuario de la API del núcleo de VServer,
pero todava no es usable en entornos de producción.
</p>

<note>
Esta versión del Cómo requiere características sólo disponibles en
<c>&gt;=sys-apps/util-vserver-0.30.210-r6</c>. Primero habrá que 
actualizar o modificar package.keywords.
</note>

<pre caption="Instalar util-vserver" >
# <i>emerge util-vserver</i>
</pre>

<p>
Se debe ejecutar el comando <c>vprocunhide</c> después de cada reinicio
para establecer los permisos adecuados en <path>/proc</path> para el uso 
de vserver. util-vserver instala un guión de inicio y para usarlo se
debe añadir a un nivel de ejecución:
</p>

<pre caption="Guíon de inicio de vserver" >
# <i>rc-update add vservers default</i>
# <i>/etc/init.d/vservers start</i>
</pre>

<note>
Este guión de inicio también arrancará los vservers por defecto. Lea a
continuación para encontrar más información.
</note>

<p>
El guión vshelper se usa para reiniciar correctamente los servidores
virtuales. Hay que indicarle al núcleo dónde está ubicado el guión
vshelper:
</p>

<pre caption="Configuración de vshelper" >
# <i>echo 'kernel.vshelper = /usr/lib/util-vserver/vshelper' &gt;&gt;  /etc/sysctl.conf</i>
# <i>sysctl -p</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Creación de una plantilla para el huésped</title>
<section>
<title>Instalación de un vserver con un stage3</title>
<body>

<p>
Necesitaremos descargar un stage3 preparado para vserver desde uno de
<uri link="/main/en/mirrors.xml">los mirrors de Gentoo</uri>. Estos
stages están situados en el directorio
<path>experimental/&lt;arch&gt;/vserver/</path>.  Luego usaremos el
guión <c>vserver-new</c> para crear el huésped inicial.
</p>

<p>
Hay que elegir un ID de contexto para el vserver (no se aconsejan los
IDs de contexto dinámicos) así como la información necesaria para el
dispositivo de red (en este ejemplo eth0 se configura con
192.168.1.253/24 y el ID de contexto es igual a las dos últimas partes
de la IP de los servidores virtuales).
</p>

<pre caption="Inicio de la instalación de un stage3" >
# <i>vserver-new gentoo-template \</i>
<i>--hostname gentoo \</i>
<i>--context 1253 \</i>
<i>--interface eth0:192.168.1.253/24 \</i>
<i>stage3 /path/to/stage3-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
Para reflejar la configuración de red se deben cambiar dentro del
huésped <path>/etc/conf.d/hostname</path>,
<path>/etc/conf.d/domainname</path> y <path>/etc/hosts</path> tal como
se necesite. Se puede consultar el
<uri link="/doc/es/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect1" >
capítulo 8.b.1</uri> y el
<uri link="/doc/es/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect4" >
capítulo 8.b.4</uri>. El resto de la configuración de red del servidor
virtual se hará en el anfitrión.
</note>

</body>
</section>
<section>
<title>Creación del archivo comprimido de la plantilla</title>
<body>

<p>
No necesitaremos crear un tarball del stage3 para cada huésped. El
guión <c>vserver-new</c> soporta plantillas. Para poder usarlo hay que
crear un archivo comprimido de la instalación de vserver:
</p>

<pre caption="Creación de la plantilla comprimida" >
# <i>cd /vservers/gentoo-template</i>
# <i>tar cjvpf ../gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 ./</i>
</pre>

<p>
Para crear un nuevo huésped usando este archivo comprimido basta usar
<c>vserver-new</c>:
</p>

<pre caption="Usar una plantilla comprimida" >
# <i>cd /vservers</i>
# <i>vserver-new myguest \</i>
<i>--hostname myguest \</i>
<i>--context 1252 \</i>
<i>--interface eth0:192.168.1.252/24 \</i>
<i>template ./gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
Se puede usar un árbol del portage compartido para los distintos
huéspedes y así mantenerlos de pequeño tamaño. Editaremos
<path>/etc/vservers/myguest/fstab</path> y descomentaremos las líneas
para <path>/usr/portage</path> y <path>/usr/portage/distfiles</path>.
Los huéspedes tendrán acceso de sólo lectura a
<path>/usr/portage</path> y de lectura y escritura a
<path>/usr/portage/distfiles</path>.
</note>

</body>
</section>
<section>
<title>Probar el servidor virtual</title>
<body>

<p>
Deberíamos ser capaces de iniciar y entrar en el servidor virtual
usando los siguientes comandos. Si echamos a faltar algunos como
<c>mount</c> o <c>dmesg</c> deberemos hacer <c>emerge util-linux</c>
dentro del servidor virtual puesto que el perfil del vserver no
contiene este paquete por defecto.
</p>

<pre caption="Probar el servidor virtual" >
# <i>vserver myguest start</i>
# <i>vserver-stat</i>
CTX   PROC    VSZ    RSS  userTIME   sysTIME    UPTIME NAME
0       90   1.4G 153.4K  14m00s11   6m45s17   2h59m59 root server
1252     2     3M   286    0m00s45   0m00s42   0m02s91 myguest
# <i>vserver myguest enter</i>
# <i>ps ax</i>
PID   TTY      STAT   TIME COMMAND
    1 ?        S      0:00 init [3]
22887 ?        Ss     0:00 /usr/sbin/syslog-ng
20496 pts/0    S      0:00 /bin/bash -login
20508 pts/0    R+     0:00 ps ax
# <i>logout</i>
</pre>

</body>
</section>
	</chapter>
  	 
<chapter>
<title>Mantenimiento sencillo</title>
<section>
<title>Arrancar huéspedes durante el inicio</title>
<body>
  	 
<p>
Se pueden arrancar algunos huéspedes durante el inicio. Cada
<c>guest</c> puede tener asignada una MARCA (MARK). Entonces, todo lo
que hay que hacer es configurar esas MARCAs en la configuración de los
huéspedes e indicar al guión de inicio que arranque todos los
huéspedes MARCAdos
</p>
  	 
<pre caption="Configurar las MARCAs en cada huésped">
<comment>(Hay que hacer esto en cada huésped que se quiera
iniciar)</comment> # <i>mkdir -p /etc/vservers/myguest/apps/init</i> #
<i>echo "default" > /etc/vservers/myguest/apps/init/mark</i>
</pre>
  	 
<note>
Puesto que todos los huéspedes marcados con "default" son arrancados
por defecto, poco más hay que hacer. Si tuviéramos marcas diferentes
deberíamos también actualizar <path>/etc/conf.d/vservers</path>.
</note>
  	 
</body>
</section>
<section>
<title>Extras Gentoo</title>
<body>
  	 
<p>
El ebuild de util-vserver instala algunos extras en los huéspedes
Gentoo.  Ya conocemos <c>vserver-new</c> del capítulo anterior. En
este, aprenderemos a usar <c>vesync</c> y <c>vemerge</c> para mantener
portage sincronizado así como <c>vupdateworld</c> y
<c>vdispatch-conf</c> para actualizar los huéspedes.
</p>
  	 
</body>
</section>
<section>
<title>Mantener portage sincronizado</title>
<body>
  	 
<p>
El guión <c>vesync</c> nos ayudará a mantener la memoria temporal de 
metadatos y recubrimiento sincronizada. <c>vemerge</c> es un simple 
envoltorio para <c>emerge</c> en los huéspedes
</p>
  	 
<pre caption="Ejemplos">
<comment>(Sincronizar los metadatos en 'myguest')</comment>
# <i>vesync myguest</i>
<comment>(Sincronizar los metadatos en todos los huéspedes)</comment>
# <i>vesync -a</i>
<comment>(Sincronizar los metadatos en todos los huéspedes excepto 'myguest')</comment>
# <i>vesync -a -e myguest</i>
<comment>(Sincronizar 'myoverlay' en todos los huéspedes)</comment>
# <i>vesync -a \</i>
 <i>--overlay /usr/local/overlays/myoverlay \</i>
 <i>--overlay-host rsync://rsync.myhost.com/myoverlay \</i>
 <i>--overlay-only</i>
<comment>(emerge app-editors/vim en 'myguest')</comment>
# <i>vemerge myguest app-editors/vim -va</i>
</pre>
  	 
<note>
Este guión necesita que el árbol de portage esté compartido.
</note>
  	 
</body>
</section>
<section>
<title>Actualizar huéspedes</title>
<body>
  	 
<p>
Los huéspedes Gentoo pueden compartir paquetes para ahorrar tiempo de
compilación. Para usar paquetes compartidos, deberemos crear un
directorio centralizado para los paquetes en el anfitrión. Usaremos
<path>/var/cache/vpackages</path> en el anfitrión y lo montaremos en
cada huésped en <path>/usr/portage/packages</path>.
</p>
  	 
<pre caption="Enlazar la configuración del huésped">
# <i>mkdir -p /var/cache/vpackages</i>
# <i>$EDITOR /etc/vservers/myguest/fstab</i>
<comment>(Añadiremos esta línea al final)</comment>
/var/cache/vpackages /usr/portage/packages none bind,rw 0 0
</pre>
  	 
<p>
Ahora utilizaremos <c>vupdateworld</c> para actualizar cada
huésped. El comando es equivalente a algo como <c>emerge --deep
--update --newuse world</c>.
</p>
  	 
<pre caption="Ejemplos de vupdateworld">
<comment>(Prueba de actualización para 'myguest')</comment>
# <i>vupdateworld -p myguest</i>
<comment>(Actualización de 'myguest' usando paquetes binarios)</comment>
# <i>vupdateworld -k myguest</i>
<comment>(Actualización de todos los huéspedes usando paquetes binarios)</comment>
# <i>vupdateworld -ka</i>
</pre>
  	 
<note>
Para obtener paquetes binarios podemos usar, tanto PORTAGE_BINHOST
(ver <c>man make.conf</c>) o establecer FEATURES="buildpkg" en uno o
más huéspedes.
</note>
  	 
<p>
Después de haber actualizado con éxito, podemos actualizar fácilmente
todos los archivos de configuración con <c>vdispatch-conf</c>, que es
un simple envoltorio para <c>dispatch-conf</c>, comportándose de la
misma forma.
</p>
  	 
<pre caption="Ejemplos de vdispatch-conf">
<comment>(Actualizar los ficheros de configuración de 'myguest')</comment>
# <i>vdispatch-conf myguest</i>
<comment>(Actualizar los ficheros de configuración de todos los huéspedes)</comment>
# <i>vdispatch-conf -a</i>
</pre>
  	 
</body>
</section>
	 
<section>
<title>Contacto</title>
<body>

<p>
No dude en contactar con el <mail
link="hollow@gentoo.org">autor</mail> o crear un bug en <uri
link="http://bugs.gentoo.org" >Bugzilla</uri> en caso de cualquier
problema.
</p>

</body>
</section>
</chapter>
</guide>
