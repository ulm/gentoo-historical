<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/diskless-howto.xml,v 1.9 2006/02/22 12:58:02 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/es/diskless-howto.xml" lang="es">
<title>Nodos sin disco en Gentoo</title>
<author title="Investigador">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Editor">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Editor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Editor Es">
    <mail link="bass@gentoo.org">José Alberto Suárez López</mail>
 </author>
<author title="Editor Es">
    <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
 </author>
<author title="Editor Es">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>
<author title="Traductor">
     <mail link="eduardo_lazo@yahoo.com">Rodrigo Lazo Paz</mail>
</author>

<abstract>
Esta guía te ayudará a configurar nodos sin disco en Gentoo Linux.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.20</version>
<date>2006-02-13</date> 

<chapter>
<title>Introducción</title>
<section>
<title>Acerca de esta Guía</title>
<body>

<p>
Esta guía te ayudará a configurar estaciones de trabajo <e>sin
disco</e> basadas en la distribución Linux Gentoo. Hemos intentado
hacerla fácil de usar y atractiva para el principiante, porque todos
nosotros en algún momento hemos sido uno :). Si bien un usuario
experimentado puede unir varias Guías sobre nodos sin disco y
juntarlas con otras sobre trabajo en red, esperamos que esta guía
facilite la instalación a todos los usuarios interesados, "geeks" o no.
</p>
</body>
</section>

<section>
<title>¿Qué es una máquina sin disco?</title>
<body>

<p>
Una máquina sin disco es una PC sin ninguno de los dispositivos de
arranque tradicionales, como disco duro, disquete o CD-ROMs. Un nodo
sin disco arranca desde la red y por lo tanto necesita un servidor
que le provea con un espacio de almacenamiento que pueda utilizar como
disco local. De ahora en adelante llamaremos al servidor
<e>maestro</e> y a la máquina sin disco <e>esclavo</e>. El nodo
esclavo necesita un adaptador de red que soporte el arranque PXE o
Etherboot; revisa <uri
link="http://www.etherboot.org">Etherboot.org</uri> para ver una lista
de dispositivos soportados. La mayoría de tarjetas actuales soportan
PXE y varios adaptadores incorporados en la tarjeta madre también
funcionarán.
</p>
</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Debes tener instalado Gentoo en tu nodo maestro y tener espacio
suficiente en él para almacenar los sistemas de archivos de los nodos
esclavos a los que vayas a servir. Además, asegúrate de tener una
interfase conectada a Internet separada de la que utilizas para
conectarte a la red local.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Configurando el maestro y el esclavo</title>
<section>
<title>Acerca de los kernels</title>
<body>

<note>
Si vas a utilizar tus nodos para crear un cluster openMosix, asegúrate
de utilizar un kernel parchado para tal motivo. El parche lo puedes
encontrar en el portage dentro de
<path>sys-kernel/openmosix-sources</path>. Además, deberías leer la
<uri link="openmosix-howto.xml">Guía de openMosix</uri> para aprender
a compilar tu kernel para openMosix.
</note>

<p>
El kernel es el software que está entre tu hardware y todo el demás
software que posee tu computadora, es esencialmente el corazón de un
sistema operativo basado en kernel. Cuando inicias tu computadora, el
BIOS ejecuta las instrucciones que están en el espacio reservado para
el arranque en tu disco duro. Estas instrucciones son típicamente un
cargador de arranque que carga tu kernel. Luego de que el kernel ha
sido cargado, este se ocupa de todos los demás procesos.
</p>

<p>
Para más información acerca del kernel o su configuración, tal vez te
interesaría leer la <uri
link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">Guía del
kernel</uri>.
</p>
</body>
</section>

<section>
<title>Configurando el kernel maestro</title>
<body>

<p>
El kernel maestro puede ser tan grande y personalizado como quieras,
pero ten en cuenta que hay ciertas opciones que debes seleccionar. Ve
a tu menú de configuración del kernel ejecutando:
</p>

<pre caption="Editando la configuración del kernel maestro">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Debe aparecer una pantalla azul y gris que ofrece una alternativa
segura a la de editar manualmente el archivo
<path>/usr/src/linux/.config</path>. Si tu kernel actual funciona
correctamente, es recomendable que guardes la configuración, saliendo
de esa interfaz gráfica y ejecutando:
</p>

<pre caption="Haciendo una copia de seguridad de la configuración del 
kernel maestro">
# <i>cp .config .config_working</i>
</pre>

<p>
Ingresa dentro de los siguientes sub-menús y asegúrate que los ítems
listados están marcados como built-in (<e>NO</e> como módulos). Las
opciones mostradas aquí son de la versión 2.6.10 del kernel. Si usas
una versión distinta, el texto o la secuencia podrían diferir. Sólo
asegúrate de seleccionar al menos aquellas opciones mostradas a
continuación.
</p>

<pre caption="Opciones del kernel maestro">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
Device Drivers ---&gt;
Networking options ---&gt;
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
      []  Network packet filtering (replaces ipchains)
  
File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support
<comment>
Si quieres tener acceso a Internet a través de tu nodo maestro y/o
tener un cortafuegos seguro, añade el soporte para iptables.
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Si quieres usar filtrado de paquetes, puedes añadir el resto como
módulos más tarde. Asegúrate de leer <uri
link="/doc/en/security/security-handbook.xml?part=1&amp;chap=12">Guía
de seguridad Gentoo Capítulo 12 Cortafuegos</uri> para saber cómo
configurarlo de manera adecuada.
</p>

<note>
Estas opciones de configuración del kernel deben ser añadidas a las
opciones de configuración específica para tu sistema, no están
diseñadas para reemplazar completamente la configuración de tu kernel.
</note>

<p>
Luego de haber reconfigurado tu kernel maestro, debes recompilarlo:
</p>

<pre caption="Recompilando el kernel maestro y los módulos">
# <i>make &amp;&amp; make modules_install</i>
<comment>(Asegúrate de que la partición /boot esté montada
antes de copiar el kernel)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
</pre>

<p>
Luego añade una opción para este kernel nuevo en
<path>lilo.conf</path> o <path>grub.conf</path> dependiendo de cual
cargador de arranque uses, y haz esta nueva opción la
predeterminada. Ahora que tu bzImage ha sido copiada al directorio de
arranque, todo lo que necesitas hacer para cargar estas nuevas
opciones es reiniciar el sistema.
</p>
</body>
</section>

<section>
<title>Acerca del kernel esclavo</title>
<body>

<p>
Recomendamos que compiles tu kernel esclavo sin módulos, ya que
cargar y configurarlos en un arranque por red es un proceso
dificultoso e innecesario. Además, el kernel esclavo debe ser tan
simple y compacto como sea posible, para hacer el arranque a través de
la red eficiente. Vamos a compilar el kernel esclavo en el mismo lugar
donde configuramos el kernel maestro.
</p>

<p>
Para evitar cualquier confusión y desperdicio de tiempo es una buena
idea hacer una copia de seguridad del archivo de configuración del
kernel maestro ejecutando:
</p>

<pre caption="Haciendo una copia de seguridad de la configuración del kernel maestro">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Ahora configuraremos el kernel esclavo de la misma forma que lo
hicimos con el kernel maestro. Si quieres empezar con un archivo de
configuración nuevo, siempre puedes recuperar el archivo por defecto
<path>/usr/src/linux/.config</path> ejecutando:
</p>

<pre caption="Recuperando la configuración original del kernel">
# <i>cd /usr/src/linux</i>
# <i>cp .config_master .config</i>
</pre>

<p>
Ahora entremos a la configuración visual ejecutando:
</p>

<pre caption="Editando la configuración del kernel esclavo">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Debes asegurarte de seleccionar las siguientes opciones como built-in y
<e>NO</e> como módulos:
</p>

<pre caption="Opciones del kernel esclavo">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
Device Drivers ---&gt;
  [*] Networking support
Networking options ---&gt;
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
  [*]   IP: kernel level autoconfiguration
  [*]     IP: DHCP support (NEW)
File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; file system support 
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
Una alternativa al servidor dhcp es el un servidor BOOTP.
</note>

<impo>
Es importante que añadas tu adaptador de red dentro del kernel (y no
como módulo) en los nodos. Sin embargo, utilizarlo como módulo
generalmente no es un problema para nodos sin disco.
</impo>

<p>
Ahora el kernel esclavo necesita ser compilado. Tienes que ser
cuidadoso en este paso ya que no querrás estropear los módulos (si es
que hay alguno) que compilaste para tu kernel maestro:
</p>

<pre caption="Compilando el kernel esclavo">
# <i>cd /usr/src/linux</i>
# <i>make</i>
</pre>

<p>
Ahora crea el directorio en el maestro que se utilizará para almacenar
los archivos del esclavo además de sus archivos de sistema. Nosotros
utilizamos un directorio <path>/diskless</path> pero tu puedes elegir
la ubicación que prefieras. Ahora, copia la bzImage de tu esclavo
dentro de <path>/diskless</path>:
</p>

<note>
Si estás utilizando distintas arquitecturas tal vez prefieras guardar
cada configuración dentro de un <path>.config_arch</path>. Haz lo
mismo con las imágenes: guárdalas dentro de <path>/diskless</path>
como <path>bzImage_arch</path>.
</note>

<pre caption="Copiando el kernel esclavo">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>
</body>
</section>

<section>
<title>Configurando un sistema de archivos esclavo preliminar</title>
<body>

<p>
Los sistemas de archivos maestro y esclavo pueden ser ajustados y
cambiar bastante, pero por ahora sólo nos interesa tener sistemas de
archivos preliminares con los archivos de configuración apropiados y
los puntos de montaje necesarios. Primero, necesitamos crear un
directorio dentro de <path>/diskless</path> para el primer
esclavo. Cada esclavo necesita su propio sistema de archivos raíz
porque compartir ciertos archivos del sistema causará problemas con
los permisos y caídas del sistema. Les puedes poner a estos
directorios los nombres que desees pero te sugerimos que utilices las
direcciones IP de los esclavos, ya que estas son únicas y no
confusas. La dirección IP estática de tu primer esclavo sería, por
ejemplo, <c>192.168.1.21</c>:
</p>

<pre caption="Creando un directorio raíz remoto">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Varios archivos de configuración dentro de <path>/etc</path> necesitan
ser modificados para que funcionen en el esclavo. Copia tu directorio
maestro <path>/etc</path> en el directorio raíz de tu esclavo
ejecutando:
</p>

<pre caption="Creando /etc para el sistema de archivos del esclavo">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Todavía este sistema de archivos no está listo porque necesita varios
puntos de montaje y directorios. Para crearlos ejecuta:
</p>

<pre caption="Creando los puntos de montaje y los directorios en el sistema de archivos esclavo">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/sys</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
<comment>(sólo para openMosix )</comment>
# <i>mkdir /diskless/192.168.1.21/mfs</i>
</pre>

<p>
La mayoría de estos directorios deben ser familiares para ti; algunos
como <path>/dev</path>, <path>/proc</path> o <path>/sys</path> serán
llenados una vez que el esclavo arranque, los demás serán montados
luego. Además, debes cambiar el archivo
<path>/diskless/192.168.1.21/etc/conf.d/hostname</path> para que este
contenga el nombre del anfitrión del esclavo. Binarios, librerías y
otros archivos serán puestos en su lugar más tarde en esta Guía, luego
de que intentes iniciar el esclavo.
</p>

<p>
Aunque <path>/dev/</path> es luego poblado por <c>udev</c>, necesitas
crear la entrada <path>console</path>. Sino recibirás el error "no es
posible abrir la consola inicial" ("unable to open initial console").
</p>

<pre caption="Creando la entrada de la consola en /dev">
  # <i>mknod /diskless/192.168.1.21/dev/console c 5 1</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Configurando el servidor DHCP</title>
<section>
<title>Acerca del servidor DHCP</title>
<body>

<p>
DHCP son las iniciales (en inglés) de Protocolo Dinámico de
Configuración del Anfitrión. El servidor DHCP es la primera máquina
con la que el esclavo se comunicará en el momento del arranque PXE. El
propósito primario del servidor DHCP es el de asignar las direcciones
IP. El servidor DHCP puede asignar direcciones IP basándose en la
dirección MAC Ethernet del anfitrión. Una vez que el esclavo tiene su
dirección IP, el servidor DHCP le dirá donde conseguir su sistema de
archivos inicial y el kernel.
</p>
</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Hay un par de cosas que debes estar seguro que funcionan antes de
empezar. Primero revisa la conectividad a red:
</p>

<pre caption="Revisando la configuración de la red">
# <i>ifconfig eth0 multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Debes asegurarte de tener un dispositivo <e>eth0</e> funcionando. La
salida del comando anterior debe parecerse algo a esto:
</p>

<pre caption="Un dispositivo eth0 funcionando apropiadamente">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
Es importante que diga <e>MULTICAST</e>, si no lo hace debes
recompilar tu kernel para incluir el soporte para multicast.
</p>
</body>
</section>

<section>
<title>Instalando el servidor DHCP</title>
<body>

<p>
Si tu red no tiene un servidor DHCP instalado, debes instalar uno:
</p>

<pre caption="Instalando el servidor dhcp">
# <i>emerge dhcp</i>
</pre>

<p>
Si tu red ya tiene un servidor DHCP, debes modificar el archivo de
configuración de manera que tenga la función de arranque PXE
correctamente configurada.
</p>
</body>
</section>

<section>
<title>Configurando el servidor DHCP</title>
<body>

<p>
Sólo hay un archivo de configuración que tendrás que modificar antes
de iniciar tu servidor DHCP: <path>/etc/dhcp/dhcpd.conf</path>. Copia
y modifica el archivo de ejemplo que te dan:
</p>

<pre caption="Modificando el archivo de configuración del servidor dhcp">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
La disposición general del archivo se asemeja a esta:
</p>

<pre caption="Ejemplo de la disposición del archivo dhcp.conf">
<comment># Opciones globales aquí</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># Opciones de red compartida aquí</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # Opciones de sub red aquí</comment>
    host slave{
<comment>        # Opciones específicas del anfitrión aquí</comment>
    }
    group {
<comment>        # Opciones específicas del grupo aquí</comment>
    }
}
}
</pre>

<p>
El bloque <c>shared-network</c> es opcional y debe ser utilizado para
las direcciones IP que quieras asignar que pertenecen a la misma
topología de red. Al menos una <c>subred</c> debe ser declarada y el
bloque opcional <c>group</c> te permite agrupar opciones entre
ítems. Un buen ejemplo del <path>dhcpd.conf</path> es:
</p>

<pre caption="Archivo dhcpd.conf de ejemplo">
# DHCP configuration file for DHCP ISC 3.0
 
ddns-update-style none;
 
# Definition of PXE-specific options
# Code 1: Multicast IP address of boot file server
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of seconds a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of seconds a client must listen before trying to restart
#         a MTFTP transfer
 
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
 
subnet 192.168.1.0 netmask 255.255.255.0 {
 
  
  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    option vendor-class-identifier "PXEClient";
    vendor-option-space PXE;
 
    # At least one of the vendor-specific PXE options must be set in
    # order for the client boot ROMs to realize that we are a PXE-compliant
    # server.  We set the MCAST IP address to 0.0.0.0 to tell the boot ROM
    # that we can't provide multicast TFTP (address 0.0.0.0 means no
    # address).
 
    option PXE.mtftp-ip 0.0.0.0;
 
    # This is the name of the file the boot ROMs should download.
    filename "pxelinux.0";
    # This is the name of the server they should get it from.
    <comment># Usa el IP maestro</comment>
    next-server 192.168.1.1;
  }
  <comment># Si estás utilizando etherboot sin una imagen específica </comment>
  class "etherboot" {
        if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
        filename "/diskless/vmlinuz";
        }
  }
  
  pool {
    max-lease-time 86400;
    default-lease-time 86400;
    <comment># Esto evita que máquinas desconocidas reciban un IP</comment>
    deny unknown-clients;
  }
 
  host slave21 {
       <comment># Usa la dirección MAC del esclavo</comment>
       hardware ethernet                00:40:63:C2:CA:C9;
       <comment># Asigna a tu esclavo una dirección IP estática</comment>
       fixed-address                    192.168.1.21;
       server-name                      "master";
       <comment># Indica la dirección IP de la puerta de enlace, si es necesario</comment>
       option routers                   192.168.1.1;
       <comment># Usa el IP de tu DNS, sólo si es necesario</comment>
       option domain-name-servers       192.168.1.1;
       option domain-name               "mydomain.com";
       <comment># Establece el nombre de anfitrión de tu esclavo</comment>
       option host-name                 "slave21";
       
       
       <comment># Etherboot y pxe con una imagen MAC específica</comment>
       option root-path                 "/diskless/192.168.1.21";
       
       if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
                        filename "/vmlinuz_arch";
        } else if substring (option vendor-class-identifier, 0,9) ="PXEClient" {
                        filename "/pxelinux.0";
        }
                                                               
  }
}
</pre>

<note>
No hay nada que prohíba el uso del arranque PXE y Etherboot juntos. El
código anterior es simplemente un ejemplo; si tienes problemas,
consulta tu documentación sobre DHCP.
</note>

<p>
A la dirección IP luego de <c>next-server</c> se le preguntará por el
<c>filename</c>. Esta dirección IP debe ser el IP del servidor tftp,
normalmente la misma dirección que el maestro. El <c>filename</c> es
relativo al directorio <path>/diskless</path> (esto se debe a las
opciones específicas del servidor tftp que serán explicadas más
adelante). Dentro del bloque <c>host</c>, la opción <c>hardware
Ethernet</c> especifica la dirección MAC, y <c>fixed-address</c>
asigna la dirección IP estática a esa dirección MAC en particular. Es
una, probablemente, buena idea la de incluir la opción
<c>host-name</c> ya que es simplemente el nombre de anfitrión de un
esclavo en particular. Hay una muy buena página de manual sobre el
archivo <path>dhcpd.conf</path> con varias opciones que están más allá
del ámbito de esta Guía. La puedes leer ejecutando:
</p>

<pre caption="Viendo la página del manual sobre for dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>
</body>
</section>

<section>
<title>Iniciando el servidor DHCP</title>
<body>

<p>
Antes de ejecutar el guión de inicialización del servidor dhcp,
modifica el archivo <path>/etc/conf.d/dhcp</path> de manera que se
parezca a lo siguiente:
</p>

<pre caption="Ejemplo del archivo /etc/conf.d/dhcp">
IFACE="eth0"
<comment># Inserta cualquier otra opción que necesites</comment>
</pre>

<p>
La variable <c>IFACE</c> es el dispositivo en el cual deseas que el
servidor DHCP funcione, en nuestro caso es <c>eth0</c>. Añadiendo más
argumentos a <c>IFACE</c> puede ser útil en redes de topología
compleja y múltiples tarjetas ethernet. Para arrancar el servidor dhcp
escribe:
</p>

<pre caption="Iniciando el servidor dhcp en el maestro">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Para añadir el servidor dhcp a tus guiones de inicio escribe:
</p>

<pre caption="Añadiendo el servidor dhcp al nivel de ejecución por defecto">
# <i>rc-update add dhcp default</i>
</pre>
</body>
</section>

<section>
<title>Solucionando problemas con el servidor DHCP</title>
<body>

<p>
Para comprobar que un nodo arranca puedes echarle una mirada a
<path>/var/log/syslog.log</path>. Si el nodo arranca exitosamente el
archivo <path>syslog.log</path> debe tener algunas líneas al final
parecidas a estas:
</p>

<pre caption="Ejemplo de las entradas por dhcp en el registro">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
Este archivo de registro también te puede ayudar a descubrir las
direcciones MAC de los esclavos.
</note>

<p>
Si recibes este mensaje, es probable que algo esté mal en el archivo
de configuración pero que el servidor DHCP esté transmitiendo
correctamente.
</p>

<pre caption="Ejemplo de un error en el servidor dhcp">
no free leases on subnet LOCAL-NET
</pre>

<p>
Cada vez que le hagas un cambio al archivo de configuración, debes
reiniciar el servidor DHCP. Para hacerlo, ejecuta:
</p>

<pre caption="Reiniciando el servidor dhcp en el maestro">
# <i>/etc/init.d/dhcpd restart</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Configurando el servidor TFTP y el cargador de arranque PXE y/o Etherboot </title>
<section>
<title>Acerca del servidor TFTP</title>
<body>

<p>
TFTP son las (en inglés) siglas del Protocolo Trivial de Transferencia
de Archivos. El servidor TFTP les va a dar a los esclavos el kernel y
un sistema de archivo inicial. Todos los kernels esclavos y sistemas
de archivos deben estar almacenados en el servidor TFTP, así que es
una buena idea hacer que el maestro también sea el servidor TFTP.
</p>
</body>
</section>

<section>
<title>Instalando el servidor TFTP</title>
<body>

<p>
Un servidor tftp altamente recomendado está disponible en el paquete
tftp-hpa. Este servidor ha sido escrito por el autor de SYSLINUX y
funciona muy bien con pxelinux. Para instalarlo simplemente ejecuta:
</p>

<pre caption="Instalando el servidor tftp">
# <i>emerge tftp-hpa</i>
</pre>
</body>
</section>

<section>
<title>Configurando el servidor TFTP</title>
<body>

<p>
Edita el archivo <path>/etc/conf.d/in.tftpd</path>. Necesitas
especificar el directorio tftproot en la variable <c>INTFTPD_PATH</c>
y cualquier opción de la linea de comando en <c>INTFTPD_OPTS</c>. Debe
parecerse a:
</p>

<pre caption="Ejemplo del /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
La opción <c>-l</c> indica que este servidor escucha en modo stand
alone así que no necesita ejecutar inetd. La <c>-v</c> indica que los
mensajes de registro/error deben ser mostrados. La <c>-s /diskless</c>
especifica el directorio raíz de tu servidor tftp.
</p>
</body>
</section>

<section>
<title>Iniciando el servidor TFTP</title>
<body>

<p>
Para iniciar el servidor tftp ejecuta:
</p>

<pre caption="Iniciando el servidor tftp del maestro">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Este comando debe iniciar el servidor tftp con las opciones que hemos
especificado en <path>/etc/conf.d/in.tftpd</path>. Si quieres que este
servidor se inicie automáticamente al momento de arranque del sistema
ejecuta:
</p>

<pre caption="Añadiendo el servidor tftp al nivel de ejecución por defecto del maestro">
# <i>rc-update add in.tftpd default</i>
</pre>
</body>
</section>

<section>
<title>Acerca de PXELINUX</title>
<body>

<p>
Esta sección no es obligatoria para aquellos que utilizan Etherboot.
PXELINUX es el cargador de arranque por red equivalente a LILO y GRUB
y será distribuido mediante el TFTP. Es esencialmente un conjunto
mínimo de instrucciones que indica al cliente dónde encontrar su kernel y
sistema de archivos inicial y permite varias opciones del kernel.
</p>
</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Necesitas obtener el archivo pxelinux.0 que viene en el paquete
SYSLINUX de H. Peter Anvin. Lo puedes instalar ejecutando:
</p>

<pre caption="Instalando syslinux">
# <i>emerge syslinux</i>
</pre>
</body>
</section>

<section>
<title>Configurando PXE-LINUX</title>
<body>

<note>
Esta parte no es necesaria para Etherboot.
</note>

<p>
Antes de arrancar tu servidor tftp necesitas configurar
pxelinux. Primero copia el binario de pxelinux en tu directorio
<path>/diskless</path>:
</p>

<pre caption="Configurando el cargador de arranque remoto">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Esto creará el archivo de configuración por defecto del cargador de
arranque. El binario <path>pxelinux.0</path> buscará en el directorio
<path>pxelinux.cfg</path>un archivo cuyo nombre sea la dirección IP
del cliente en hexadecimal. Si no lo encuentra removerá el dígito más a
la derecha del nombre del archivo y volverá a intentar hasta que se
quede sin dígitos. Versiones desde la 2.05 y posteriores de syslinux
primero ejecutan una busqueda por un archivo cuyo nombre sea la
dirección MAC. Si este no es encontrado, ejecuta la rutina ya
descrita. Si no lo encuentra, el archivo <path>default</path> es
usado.
</p>

<pre caption="Archivos que PXE busca secuencialmente en pxelinux.cfg">
<comment>(Primer número 01 significa ethernet, los demás son la
dirección MAC del esclavo)</comment> 
01-00-40-63-c2-ca-c9
<comment>(Dirección IP asignada en hexadecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
default
</pre>

<note>
Todos son en minúsculas.
</note>

<p>
Empecemos con el archivo <path>default</path>:
</p>

<pre caption="Ejemplo del pxelinux.cfg/default">
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
La etiqueta <c>DEFAULT</c> le indica a pxelinux dónde está la bzImage
del kernel. La etiqueta <c>APPEND</c> añade las opciones de arranque
para el kernel. Dado que hemos compilado nuestro kernel con
<c>NFS_ROOT_SUPPORT</c>, debemos especificar la dirección raíz del
nfs. El primer IP es el IP del maestro y el segundo es el del
directorio que fue creado en <path>/diskless</path> para almacenar el
sistema de archivos inicial del esclavo.
</p>
</body>
</section>

<section>
<title>Acerca de Etherboot</title>
<body>

<note>
Esta sección no es necesaria para aquellos que utilizan arranque PXE.
</note>

<p>
Los inicios mediante Etherboot cargan la imagen para arrancar desde el
servidor TFTP. Al igual que PXE, es equivalente a LILO o GRUB. La
utilidad <c>mknbi</c> te permite crear distintas imágenes con opciones diferentes.
</p>
</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Necesitas obtener el paquete <c>mknbi</c> (utilidad imágenes del
kernel etiquetadas útiles para el arranque por red) para crear tus
imágenes Etherboot. Esta utilidad creará una imagen del kernel
pre-configurada de tu kernel original. Esta contiene las opciones de
arranque mostradas más adelante.
</p>

<pre caption="Instalando mknbi">
# <i>emerge mknbi</i>
</pre>
</body>
</section>

<section>
<title>Configurando Etherboot</title>
<body>

<p>
En esta sección crearemos una imagen simple de etherboot. Como el
servidor dhcp le indica al cliente la dirección raíz en la opción
"option root-path" del dhcp.conf, no necesitamos incluirla aquí. Más
detalles en el manual de mknbi.
</p>

<pre caption="manual de mknbi">
# <i>man mknbi</i>
</pre>

<p>
Haciendo la imagen de arranque. El siguiente comando creara la imagen
ELF de arranque capaz de pasar el dhcp y la dirección del directorio
raíz al kernel. También obliga al kernel a buscar en la red un
servidor dhcp.
</p>

<pre caption="Haciendo la imagen para el arranque por red">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Para crear una imagen específica para cada arquitectura escribe
<c>bzImage_arch</c> y <c>vmlinuz_arch</c>.
</note>
</body>
</section>

<section>
<title>Solucionando problemas en el proceso de arranque por red</title>
<body>

<p>
Hay un par de cosas que tu puedes hacer para corregir errores en el
proceso de arranque por red. Para empezar puedes utilizar la
herramienta llamada <c>tcpdump</c>. Para instalarla ejecuta:
</p>

<pre caption="Instalando tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Ahora puedes escuchar el tráfico en la red y asegurarte que las
interacciones entre cliente/servidor están funcionando. Si algo está
mal ahí hay un par de cosas que deberías revisar. Primero asegúrate
que el cliente/servidor estén físicamente bien conectados y que los
cables no están dañados. Si tu cliente/servidor no están recibiendo
pedidos a un puerto específico, comprueba la configuración del
Cortafuegos. Para escuchar la interacción entre dos computadores escribe:
</p>

<pre caption="Escuchando la interacción cliente/servidor vía tcpdump">
# <i>tcpdump host </i><comment>client_ip</comment><i> and </i><comment>server_ip</comment>
</pre>

<p>
También puedes utiliza <c>tcpdump</c> para escuchar un puerto en
particular como el puerto tftp ejecutando:
</p>

<pre caption="Escuchando el servidor tftp">
# <i>tcpdump port 69</i>
</pre>

<p>
Un error que comunmente se recibe es "PXE-E32: TFTP open
time-out". Esto es probablemente por problemas con el cortafuegos. Si
estás utilizando <c>TCPwrappers</c>, sería conveniente que revises el
<path>etc/hosts.deny</path> y revisar que está configurado bien. Al
cliente debe permitirse conectarse al servidor.
</p>
</body>
</section>
</chapter>

<chapter>
<title>Configurando el servidor NFS</title>
<section>
<title>Acerca del servidor NFS</title>
<body>

<p>
NFS son las siglas (en inglés) de Sistema de Archivos en Red. El
servidor NFS será utilizado para brindar al esclavo sus
directorios. Esta parte puede ser personalizada más tarde, por ahora
lo que buscamos es tener el nodo esclavo funcionando sin disco.
</p>
</body>
</section>

<section>
<title>Acerca de Portmapper</title>
<body>

<p>
Varios servicios cliente/servidor no escuchan a un puerto en
particular, en cambio utilizan RPCs (llamadas a procedimientos
remotos). Cuando un servicio es inicializado, escucha a un puerto al
azar y luego registra este puerto en la utilidad Portmapper. NFS
utiliza RPCs y por lo tanto requiere tener a Portmapper corriendo para
funcionar.
</p>
</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
El servidor NFS necesita soporte a nivel kernel así que si no lo
incluiste al momento de compilar, debes recompilar el kernel
maestro. Para revisar la configuración de tu kernel maestro ejecuta:
</p>

<pre caption="Revisando por las opciones específicas del NFS">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
La salida debe ser parecida a la siguiente si es que tu kernel está
configurado correctamente:
</p>

<pre caption="Opciones específicas de NFS apropiadas en la configuración del kernel maestro">
CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 # CONFIG_NETFILTER is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>
</body>
</section>

<section>
<title>Instalando el servidor NFS</title>
<body>

<p>
El paquete NFS puede ser instalado mediante el portage escribiendo:
</p>

<pre caption="Instalando nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Este paquete instalará la utilidad portmapping, el servidor nfs, y las
utilidades nfs del cliente y automáticamente manejará la
inicialización de las dependencias.
</p>
</body>
</section>

<section>
<title>Configurando el servidor NFS</title>
<body>

<p>
Hay tres archivos de configuración principales que debes editar:
</p>

<pre caption="Archivos de configuración nfs">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
El archivo <path>/etc/exports</path> especifica como, a quién y qué se
debe exportar a través de NFS. El fstab del esclavo debe ser alterado
de manera que pueda montar el sistema de archivos NFS que el maestro
está exportando.
</p>

<p>
Típicamente el <path>/etc/exports</path> del maestro debe ser parecido
al siguiente:
</p>

<pre caption="Ejemplo del /etc/exports maestro">
<comment># una linea como esta por cada esclavo</comment>
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
<comment># común a todos los esclavos</comment>
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
<comment># Si deseas tener un registro compartido</comment>
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>

<p>
El primer campo indica el directorio que será exportado y el siguiente
indica a quién y cómo. Este campo puede dividirse en dos partes: a
quién se le debe permitir montar ese directorio en particular, y qué
puede hacer el cliente con él: <c>ro</c> de sólo lectura, <c>rw</c> de
lectura y escritura; <c>no_root_squash</c> and <c>no_all_squash</c>
son importantes para clientes sin disco que escriben en el disco de
manera que no sean "apretados" al hacer pedidos de E/S. El archivo
fstab del esclavo, <path>/diskless/192.168.1.21/etc/fstab</path>, debe
ser similar a este:
</p>

<pre caption="Ejemplo del fstab esclavo">
<comment># Estas entradas son esenciales</comment>
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># Útil pero superfluo</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
<comment>(Sólo si estás configurando un cluster openMosix)</comment>
none                            /mfs      mfs     dfsa=1                                       0 0
</pre>

<p>
En este ejemplo, <e>master</e> es sólo el nombre de anfitrión del
maestro pero podría fácilmente ser el IP del maestro. El primer campo
indica el directorio a montar y el segundo indica dónde. El tercer
campo describe el sistema de archivos y debe ser NFS para cualquier
directorio NFS montado. El cuarto campo indica varias opciones que
deben ser utilizadas en el proceso de montaje (revisa mount(1) para
mayor información acerca de las opciones de montaje). Algunas personas
han tenido dificultad con puntos de montaje suaves así que los hemos
echo todos duros, pero debes revisar varias opciones para
<path>/etc/fstab</path> de manera que hagas tu cluster más eficiente.
</p>

<p>
El último archivo que debemos modificar es
<path>/etc/conf.d/nfs</path> que describe las opciones del nfs cuando
es inicializado y es parecido a este:
</p>

<pre caption="Ejemplo del /etc/conf.d/nfs maestro">
# Config file for /etc/init.d/nfs
# Number of servers to be started up by default
RPCNFSDCOUNT=8
# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Debes cambiar <c>RPCNFSDCOUNT</c> por el número de nodos sin disco en la red.
</p>
</body>
</section>

<section>
<title>Arrancando el servidor NFS</title>
<body>

<p>
Debes iniciar el servidor nfs con su guión de inicio localizado en
<path>/etc/init.d</path> ejecutando:
</p>

<pre caption="Iniciando el servidor nfs maestro">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Si quieres que este guión se ejecute al momento de iniciarse el
sistema simplemente ejecuta:
</p>

<pre caption="Añadiendo el servidor nfs al nivel de ejecución por defecto del maestro">
# <i>rc-update add nfs default</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Completando el sistema de archivos del esclavo</title>
<section>
<title>Copiando los archivos faltantes</title>
<body>

<p>
Ahora sincronizaremos el sistema de archivos del esclavo con el del
maestro y proveeremos los binarios necesarios, preservando los
archivos específicos del esclavo.
</p>

<pre caption="Creando el sistema de archivos maestro">
# <i>rsync -avz /bin /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib /diskless/192.168.1.21</i>
</pre>

<note>
La razón por la que utilizamos -avz en vez de cp es la de mantener los
enlaces simbólicos y los permisos.
</note>
</body>
</section>

<section>
<title>Guiones de inicio</title>
<body>

<p>
Los guiones por defecto tratarán de ejecutar <e>checkroot</e>, lo cual
no tiene sentido hacerlo en los nodos esclavos. La manera difícil es
la de manualmente editar el guión
<path>/diskless/192.168.1.21/sbin/rc</path> pero esto es peligroso y
podría malograrse si decides sincronizar el sistema de archivos de tu
nodo nuevamente y te olvidas de dejar este archivo intacto. El truco
es tener un archivo <path>/fastboot</path> cuando tu sistema
arranca. Este archivo le dice a <e>checkroot</e> que no ejecute
ninguna comprobación del sistema de archivos. Pero esto también
causará que el archivo sea eliminado una vez que se haya concluido el
procesos de inicialización, por lo que necesitaremos crearlo de nuevo
al final del proceso init así:
</p>

<pre caption="Previniendo que los guiones de inicio revisen el sistema de archivos">
<comment>(Crea el archivo /fastboot para el siguiente arranque)</comment>
# <i>touch /diskless/192.168.1.21/fastboot</i>
<comment>(Crea el archivo /fastboot para cada arranque)</comment>
# <i>echo "touch /fastboot" &gt;&gt; /diskless/192.168.1.21/etc/conf.d/local.start</i>
</pre>

<p>
Dado que el desmontar los sistemas de archivos de red debe ocurrir tan
tarde como sea posible, tienes que editar el archivo
<path>/etc/init.d/netmount</path> y editar lo siguiente:
</p>
  	 
<pre caption="Editing /etc/init.d/netmount">
 depend() {
    <i>before *</i>
</pre>

<note>
La estructura base desde la versión 1.11.* en adelante no necesitan
este cambio.
</note>

<p>
Si realizas esto en un sistema levantado, no te olvides de ejecutar
<c>depscan.sh</c> para solucionar las dependencias de los
servicios. Puedes ignorar sin preocuparte cualquier advertencia sobre
la colisión con /etc/init.d/checkroot, ya que lo desabilitamos a
través de archivo fastboot que configuramos en el parrafo anterior.
</p>

<p>
Necesitarás tantos guiones de inicio en
<path>/diskless/192.168.1.21/etc/runlevels</path> como servicios tengas
en el nodo sin disco. Todo depende de que quieres que tus esclavos hagan.
</p>

<warn>
No uses <c>rc-update</c> para añadir o remover guiones de los niveles
de ejecución del esclavo cuando estés en el maestro. Esto podría
alterar lo niveles de ejecución del maestro. Necesitas crear enlaces
manualmente o ingresar en tus nodos esclavos utilizando ssh o conectar
una pantalla y teclado a tu esclavo.
</warn>

<pre caption="Niveles de ejecución típicos del esclavo">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
 
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
 
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
 
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
 
/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
Ahora es un buen momento para que inicies tus esclavos y cruces los
dedos. ¿Funciona? Felicitaciones, eres ahora el orgulloso poseedor de
nodo(s) sin disco :)
</p>
</body>
</section>

<!-- 
<section>
<title>Una alternativa: ClusterNFS</title>
<body>

<warn>
Esto se menciona solamente porque el editor de este documento lo está
utilizando.  Esté consciente que Gentoo <e>no</e> soporta Cluster
NFS. No está en el portage y requiere hacer cambios en la distribución
base de los guiones de inicio. <b>Úsalo bajo tu propio riesgo</b>.
</warn>

<p>
Si te no suena atractivo tener un directorio raíz distinto por cada
esclavo porque eso necesitaría algún mantenimiento al momento de
actualizar los archivos desde los directorios maestros, podrías
compartir la misma raíz a través de todos los nodos, maestro y esclavo
incluidos. Esto significa que todas tus máquinas necesitan ser
compatibles porque sólo tendrás un juego de binarios. También debes
tener en cuenta que esto tiene consecuencias en la seguridad porque
toda la raíz del maestro será exportada a través de NFS.
</p>

<p>
Si todavía quieres probar esta alternativa, visita la página oficial
de <uri link="http://clusternfs.sourceforge.net/">ClusterNFS</uri>,
para descargar el software y leer la documentación.
</p>

<p>
Para hacer la historia corta, todos los archivos son compartidos y los
archivos que necesitan ser distintos entre el maestro y todos los
esclavos son copiados a <path>file$$CLIENT$$</path>. Cuando un esclavo
pide el <path>file</path>, ClusterNFS se dará cuenta de la existencia
de <path>file$$CLIENT$$</path>, enviando este último. Los archivos que
necesitan ser distintos en cada nodo son copiados a
<path>file$$IP=192.168.1.21$$</path>. Lo mismo con los directorios.
</p>

<p>
En resumidas cuentas, esto es lo que diferencia este método al
previamente explicado:
</p>

<ul>
  <li>No necesitas el soporte para el servidor NFS en tu kernel maestro</li>
  <li>Instalar ClusterNFS <e>después</e> de emerger nfs-utils</li>
  <li>
  Hacer copias de los archivos y directorios de los esclavos como se describe más adelante
  </li>
  <li>No se crea un directorio raíz distinto para cada nodo</li>
  <li>Sólo se exporta / en tu archivo <path>/etc/exports</path></li>
  <li>
    Sólo se monta / via NFS en el archivo <path>/etc/fstab$$CLIENT$$</path> del esclavo.
  </li>
  <li>Modificar <path>/etc/init.d/nfs</path> como se describe más abajo</li>
  <li>
  Modificar  <path>/etc/conf.d/local.start$$CLIENT$$</path> como se describe más abajo
  </li>
</ul>

<pre caption="Archivos que necesitan ser distintos entre el maestro y los esclavos">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Probablemente vacío)</comment>
/etc/crontab$$CLIENT$$<comment> (Probablemente vacío, el maestro se encarga de esto)</comment>
/etc/exports$$CLIENT$$<comment> (vacío, los esclavos no exportan montajes NFS)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Nombre de tus esclavos)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Separación limpia entre los guiones de arranque del maestro y esclavos
</comment>
/fastboot$$CLIENT$$
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Crea subdirectorios en /var)</comment>
</pre>

<pre caption="Modificando /etc/init.d/nfs">
        ebegin "Starting NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Añade la opción - -translate-names </comment>
                $nfsd - - - -translate-names
        eend $? "Error starting NFS daemon"
         # Check if we support NFSv3
        ebegin "Starting NFS mountd"
<comment># Comenta las siguientes dos lineas (ClusterNFS sólo conoce NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Error starting NFS mountd"
</pre>

<pre caption="Editando /etc/conf.d/local.start$$CLIENT$$">
<comment>(Añade esta linea)</comment>
touch /fastboot\$\$CLIENT\$\$
</pre>
</body>
</section>
-->
</chapter>
</guide>
