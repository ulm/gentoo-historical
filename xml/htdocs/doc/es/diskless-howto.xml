<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/diskless-howto.xml,v 1.18 2013/09/28 12:43:32 nimiux Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide disclaimer="obsolete" redirect="https://wiki.gentoo.org/wiki/Diskless_nodes" lang="es">
<title>Nodos sin disco en Gentoo</title>

<author title="Investigador">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Editor">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Editor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Traductor">
    <mail link="chiguire@gentoo.org">John Christian Stoddart</mail>
 </author>
<author title="Traductor">
    <mail link="yoswink@gentoo.org">José Luis Rivero</mail>
 </author>
<author title="Traductor">
     <mail link="eduardo_lazo@yahoo.com">Rodrigo Lazo Paz</mail>
</author>

<abstract>
Este CÓMO le ayudará a crear configuraciones de nodos sin disco en
Gentoo Linux.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>2</version>
<date>2011-10-30</date>

<chapter>
<title>Introducción</title>
<section>
<title>Acerca de este CÓMO</title>
<body>

<p>
Este CÓMO le ayudará a configurar estaciones de trabajo <e>sin
disco</e> basadas en la distribución Gentoo Linux. Hemos intentado
hacerla fácil de usar y atractiva para el principiante, porque todos
nosotros en algún momento hemos sido uno :). Si bien un usuario
experimentado puede unir varios CÓMOS sobre nodos sin disco y
juntarlos con otros sobre trabajo en red, esperamos que esta guía
facilite la instalación a todos los usuarios interesados, "geeks" o
no.
</p>

</body>
</section>

<section>
<title>¿Qué es una máquina sin disco?</title>
<body>

<p>
Una máquina sin disco es una PC sin ninguno de los dispositivos de
arranque tradicionales, como disco duro, disquete o CD-ROMs. Un nodo
sin disco arranca desde la red y por lo tanto necesita un servidor que
le provea con un espacio de almacenamiento que pueda utilizar como
disco local. De ahora en adelante llamaremos al servidor
<e>maestro</e> y a la máquina sin disco <e>esclavo</e>. El nodo
esclavo necesita un adaptador de red que soporte el arranque PXE o
Etherboot; revise <uri
link="http://www.etherboot.org">Etherboot.org</uri> para ver una lista
de dispositivos soportados. La mayoría de tarjetas actuales soportan
PXE y muchos de los adaptadores incorporados en la placa base también
funcionarán.
</p>

</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Debe tener Gentoo instalado en su nodo maestro y tener espacio
suficiente en él para almacenar los sistemas de ficheros de los
nodos esclavos a los que vaya a servir. Además, asegúrese de tener
una interfase conectada a Internet distinta de la que se utiliza
para la conexión a la red local.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configurar el maestro y los esclavos</title>
<section>
<title>Acerca de los núcleos</title>
<body>

<p>
El núcleo es el software situado entre el hardware y el resto
de software instalado en su máquina, es esencialmente el corazón
de un sistema operativo basado en núcleo. Cuando inicia su
computadora, el BIOS ejecuta las instrucciones que están en el
espacio reservado para el arranque en su disco duro. Estas
instrucciones son típicamente un cargador de arranque que carga
su núcleo. Después de que se ha cargado el núcleo, éste se ocupa
de todos los demás procesos.
</p>

<p>
Para obtener más información acerca del núcleo o de su
configuración, puede que quiera leer el <uri
link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">CÓMO del
núcleo</uri>.
</p>

</body>
</section>

<section>
<title>Configurar el núcleo maestro</title>
<body>

<p>
El núcleo maestro puede ser tan grande y personalizado como se
desee, sin embargo, existen algunas opciones requeridas que
se necesitan seleccionar. Teclee la siguiente orden para
ir al menú de configuración del núcleo:
</p>

<pre caption="Editar la configuración del núcleo maestro">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Debe aparecer una pantalla azul y gris que ofrece una alternativa
segura para editar manualmente el fichero
<path>/usr/src/linux/.config</path>. Si el núcleo actual funciona
correctamente, es recomendable que guarde el fichero de
configuración, para ello puede salir de la interfaz gráfica y
teclear:
</p>

<pre caption="Hacer una copia de seguridad de la configuración del núcleo maestro">
# <i>cp .config .config_working</i>
</pre>

<p>
Entre en los siguientes submenús y asegúrese de que las
opciones listadas se construyen como integradas en el
núcleo (built-in) (y <e>NO</e> como módulos). Las opciones
mostradas abajo se han tomado de la versión 2.6.10 del núcleo.
Si utiliza una versión distinta, el texto o la secuencia podrían
diferir. Simplemente asegúrese de que selecciona al menos
las opciones mostradas a continuación.
</p>

<pre caption="Opciones del núcleo maestro">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
Device Drivers ---&gt;
Networking options ---&gt;
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
      []  Network packet filtering (replaces ipchains)

File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support
<comment>
Si quiere acceder a Internet a través de su nodo maestro o
tener un cortafuegos seguro, añade el soporte para iptables.
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Si quiere activar el filtrado de paquetes, puede añadir el
resto como módulos más tarde. Asegúrese de leer el <uri
link="/doc/es/security/security-handbook.xml?part=1&amp;chap=12">
Manual de seguridad Gentoo Capítulo 12 acerca de los Cortafuegos
</uri> para saber cómo configurarlo de manera adecuada.
</p>

<note>
Se deben añadir estas opciones de configuración del núcleo a las
opciones de configuración específicas para su sistema, no están
diseñadas para reemplazar completamente la configuración de su
núcleo.
</note>

<p>
Después de haber reconfigurado el núcleo maestro, debe
reconstruirlo:
</p>

<pre caption="Recompilar el núcleo maestro y los módulos">
# <i>make &amp;&amp; make modules_install</i>
<comment>(Asegúrese de que la partición /boot esté montada
antes de copiar el núcleo)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
</pre>

<p>
A continuación añada una opción para el nuevo núcleo nuevo en
<path>lilo.conf</path> o <path>grub.conf</path> dependiendo
del cargador de arranque que utilice, y asegúrese de que
el nuevo núcleo es la opción predeterminada. Ahora que la
nueva bzImage se ha copiado al directorio de arranque, todo
lo que necesita hacer para cargar estas nuevas opciones es
reiniciar el sistema.
</p>

</body>
</section>

<section>
<title>Acerca del núcleo esclavo</title>
<body>

<p>
Recomendamos que compile su núcleo esclavo sin módulos, ya que cargar
y configurarlos en un arranque por red es un proceso dificultoso e
innecesario. Además, el núcleo esclavo debe ser tan simple y compacto
como sea posible, para hacer el arranque a través de la red
eficiente. Vamos a compilar el núcleo esclavo en el mismo lugar donde
configuramos el núcleo maestro.
</p>

<p>
Para evitar cualquier confusión y desperdicio de tiempo es una buena
idea hacer una copia de seguridad del fichero de configuración del
núcleo maestro tecleando:
</p>

<pre caption="Hacer una copia de seguridad de la configuración del núcleo maestro">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Ahora configuraremos el núcleo esclavo de la misma forma que lo
hicimos con el núcleo maestro. Si quiere empezar con un fichero de
configuración nuevo, siempre puede recuperar el fichero por defecto
<path>/usr/src/linux/.config</path> tecleando:
</p>

<pre caption="Recuperar la configuración original del núcleo">
# <i>cd /usr/src/linux</i>
# <i>cp .config_master .config</i>
</pre>

<p>
Ahora entremos a la interfaz visual de configuración tecleando:
</p>

<pre caption="Editar la configuración del núcleo esclavo">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Debe asegurarse de seleccionar las siguientes opciones como
integradas (built-in) y <e>NO</e> como módulos de núcleo:
</p>

<pre caption="Opciones del núcleo esclavo">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
Device Drivers ---&gt;
  [*] Networking support
Networking options ---&gt;
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
  [*]   IP: kernel level autoconfiguration
  [*]     IP: DHCP support (NEW)
File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
Una alternativa al servidor dhcp es configurar un servidor BOOTP.
</note>

<impo>
Es importante que añada su adaptador de red dentro del núcleo (y no
como módulo) en los nodos. Sin embargo, utilizarlo como módulo
generalmente no es un problema para nodos sin disco.
</impo>

<p>
Ahora necesitará compilar el núcleo esclavo. Tiene que ser
cuidadoso en este paso ya que seguro que no quiere estropear
los módulos (si es que hay alguno) que compiló para su
núcleo maestro:
</p>

<pre caption="Compilar el núcleo esclavo">
# <i>cd /usr/src/linux</i>
# <i>make</i>
</pre>

<p>
Ahora cree el directorio en el maestro que se utilizará para almacenar
los ficheros del esclavo además de sus ficheros de sistema. Nosotros
utilizamos un directorio <path>/diskless</path> pero puede elegir
la ubicación que prefiera. Ahora, copie la bzImage de su esclavo
dentro de <path>/diskless</path>:
</p>

<note>
Si está utilizando distintas arquitecturas tal vez prefiera guardar
cada configuración dentro de un <path>.config_arch</path>. Haga lo
mismo con las imágenes: guárdelas dentro de <path>/diskless</path>
como <path>bzImage_arch</path>.
</note>

<pre caption="Copiar el núcleo esclavo">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>
</body>
</section>

<section>
<title>Configurar un sistema de ficheros esclavo preliminar</title>
<body>

<p>
Se pueden ajustar los sistemas de ficheros maestro y esclavo y
cambiar bastante, pero por ahora solo nos interesa tener sistemas de
ficheros preliminares con los ficheros de configuración apropiados y
los puntos de montaje necesarios. Primero, necesitamos crear un
directorio dentro de <path>/diskless</path> para el primer
esclavo. Cada esclavo necesita su propio sistema de ficheros raíz
porque compartir ciertos ficheros del sistema causará problemas con
los permisos y caídas del sistema. Les puede poner a estos
directorios los nombres que desee pero le sugerimos que utilice las
direcciones IP de los esclavos, ya que estas son únicas y no
confunden. La dirección IP estática de su primer esclavo sería, por
ejemplo, <c>192.168.1.21</c>:
</p>

<pre caption="Crear un directorio raíz remoto">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Se necesitan modificar varios ficheros de configuración dentro de
<path>/etc</path> para que funcionen en el esclavo. Copie su
directorio maestro <path>/etc</path> en el nuevo directorio raíz
de su esclavo tecleando:
</p>

<pre caption="Crear /etc para el sistema de ficheros del esclavo">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Este sistema de ficheros no está listo aún porque necesita varios
puntos de montaje y directorios. Para crearlos, teclee:
</p>

<pre caption="Crear los puntos de montaje y los directorios en el sistema de ficheros esclavo">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/sys</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
</pre>

<p>
La mayoría de estos directorios le deben resultar familiares.
Algunos como <path>/dev</path>, <path>/proc</path> o
<path>/sys</path> se llenarán una vez haya arrancado el esclavo,
los demás se montarán más tarde. Además, debe cambiar el fichero
<path>/diskless/192.168.1.21/etc/conf.d/hostname</path> para que este
contenga el nombre del anfitrión del esclavo. Los binarios,
librerías y otros ficheros se copiarán más tarde en esta CÓMO
antes de que intente iniciar el esclavo.
</p>

<p>
Aunque más tarde <c>udev</c> se encargará de poblar
<path>/dev/</path>, necesitará crear la entrada <path>console</path>.
En caso contrario, recibirá el error "no es posible abrir la consola
inicial" ("unable to open initial console").
</p>

<pre caption="Crear la entrada de la consola en /dev">
  # <i>mknod /diskless/192.168.1.21/dev/console c 5 1</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configurar el servidor DHCP</title>
<section>
<title>Acerca del servidor DHCP</title>
<body>

<p>
DHCP son las iniciales (en inglés) de Protocolo Dinámico de
Configuración del Anfitrión. El servidor DHCP es la primera máquina
con la que el esclavo se comunicará en el momento del arranque PXE. El
propósito principal del servidor DHCP es el de asignar las direcciones
IP. El servidor DHCP puede asignar direcciones IP basándose en la
dirección MAC Ethernet del anfitrión. Una vez que el esclavo tiene su
dirección IP, el servidor DHCP le dirá donde conseguir su sistema de
ficheros inicial y el núcleo.
</p>

</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Hay un par de cosas de las que debe comprobar su funcionamiento antes
empezar. En primer lugar, revise la conectividad a la red:
</p>

<pre caption="Revisar la configuración de la red">
# <i>ifconfig eth0 multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Debe asegurarse de tener un dispositivo <e>eth0</e> funcionando. La
salida de la orden anterior debe parecerse algo a esto:
</p>

<pre caption="Un dispositivo eth0 funcionando apropiadamente">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
Es importante que indique <e>MULTICAST</e>, si no lo hace deberá
recompilar su núcleo para incluir el soporte para multicast.
</p>

</body>
</section>

<section>
<title>Instalar el servidor DHCP</title>
<body>

<p>
Si su red no tiene un servidor DHCP instalado, deberá instalar uno:
</p>

<pre caption="Instalar el servidor dhcp">
# <i>emerge dhcp</i>
</pre>

<p>
Si su red ya tiene un servidor DHCP, deberá modificar el fichero de
configuración de manera que tenga la función de arranque PXE
correctamente configurada.
</p>

</body>
</section>

<section>
<title>Configurar el servidor DHCP</title>
<body>

<p>
Solo hay un fichero de configuración que tendrá que modificar antes
de iniciar su servidor DHCP: <path>/etc/dhcp/dhcpd.conf</path>. Copie
y modifique el fichero de ejemplo que se ofrece:
</p>

<pre caption="Modificar el fichero de configuración del servidor dhcp">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
La disposición general con sangrías del fichero se asemeja a esta:
</p>

<pre caption="Ejemplo de la disposición del fichero dhcp.conf">
<comment># Opciones globales aquí</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># Opciones de red compartida aquí</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # Opciones de sub red aquí</comment>
    host slave{
<comment>        # Opciones específicas del anfitrión aquí</comment>
    }
    group {
<comment>        # Opciones específicas del grupo aquí</comment>
    }
}
}
</pre>

<p>
El bloque <c>shared-network</c> es opcional y se debe utilizar para
las direcciones IP que quiera asignar y que pertenecen a la misma
topología de red. Al menos se debe declarar una <c>subred</c> y el
bloque opcional <c>group</c> le permitirá agrupar opciones entre
elementos. Un buen ejemplo de <path>dhcpd.conf</path> es:
</p>

<pre caption="Fichero dhcpd.conf de ejemplo">
#
# Ejemplo del fichero dhcpd.conf de los clientes
#

# Desactiva el DNS dinámico
ddns-update-style none;

# Asume una puerta de enlace predeterminada para el tráfico IP
option routers 192.168.1.1;

# Provee información DNS a los clientes
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";

# Especifica el servidor TFTP a utilizar
next-server 192.168.1.1;

# Declara una opción del buffer específica del vendedor para los clientes PXE:
# Código 1: Dirección IP Multicast del servidor de ficheros de arranque
# Código 2: Puerto UDP que el cliente debe monitorear para recibir
#           respuestas MTFTP
# Código 3: Puerto UDP que los servidores MTFTP utilizan para escuchar
#           solicitudes MTFTP
# Código 4: Número de segundos que el cliente debe escuchar por actividad antes
#           de iniciar una nueva transferencia MTFTP
# Código 5: Número de segundos que el cliente debe escuchar antes de reiniciar
#           una transferencia MTFTP

option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;

# Declara la subred en la cual van a existir nuestro nodos sin disco
subnet 192.168.1.0 netmask 255.255.255.0 {

  # Provee a los clientes PXE con la información apropiada
  class "pxeclient" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;

    # Al menos 1 de las opciones PXE específicas del fabricante deben
    # ser definidas para que el ROM de arranque de los clientes se de
    # cuenta que el servidor tienes las características PXE. Definimos
    # la dirección IP MCAST a 0.0.0.0 para indicarle al ROM de arranque
    # que no podemos proveerle un TFTP multicast.

    option PXE.mtftp-ip 0.0.0.0;

    # Este es el nombre del fichero que el ROM arranque debe descargar
    filename "pxelinux.0";
  }
  # Provee a los clientes Etherboot con la información apropiada
  class "etherboot" {
        match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
        filename "vmlinuz_arch";
  }

  # Agrega una declaración por cada máquina sin disco
  host slave21 {
       hardware ethernet                00:02:A5:04:3B:66;
       fixed-address                    192.168.1.21;
  }
}
</pre>

<note>
No hay nada que prohíba el uso del arranque PXE y Etherboot juntos. El
código anterior es simplemente un ejemplo; si tiene problemas,
consulte su documentación sobre DHCPd.
</note>

<p>
A la dirección IP después de <c>next-server</c> se le preguntará
por el <c>filename</c>. Esta dirección IP debe ser la IP del
servidor tftp, normalmente la misma dirección que el maestro.
El <c>filename</c> es relativo al directorio
<path>/diskless</path> (esto se debe a las opciones específicas
del servidor tftp que serán explicadas más adelante). Dentro
del bloque <c>host</c>, la opción <c>hardware Ethernet</c>
especifica la dirección MAC, y <c>fixed-address</c>
asigna la dirección IP estática a esa dirección MAC en particular.
Hay una muy buena página de manual sobre el fichero
<path>dhcpd.conf</path> con varias opciones que están más allá del
ámbito de esta guía. La puede leer escribiendo:
</p>

<pre caption="Ver la página del manual sobre dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>

<section>
<title>Iniciar el servidor DHCP</title>
<body>

<p>
Antes de lanzar el guión de inicialización del servidor dhcp,
modifique el fichero <path>/etc/conf.d/dhcp</path> de manera que se
parezca a lo siguiente:
</p>

<pre caption="Ejemplo del fichero /etc/conf.d/dhcp">
IFACE="eth0"
<comment># Inserte cualquier otra opción que necesite</comment>
</pre>

<p>
La variable <c>IFACE</c> es el dispositivo en el cual desea que el
servidor DHCP funcione, en nuestro caso es <c>eth0</c>. El hecho de
añadir más argumentos a <c>IFACE</c> puede ser útil en redes de topología
compleja y múltiples tarjetas ethernet. Para arrancar el servidor dhcp
escriba:
</p>

<pre caption="Iniciar el servidor dhcp en el maestro">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Para añadir el servidor dhcp a sus guiones de inicio escriba:
</p>

<pre caption="Añadir el servidor dhcp al nivel de ejecución por defecto">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>

<section>
<title>Solucionar problemas con el servidor DHCP</title>
<body>

<p>
Para comprobar que un nodo arranca puede echarle un vistazo a
<path>/var/log/messages</path>. Si el nodo arranca correctamente,
el fichero <path>messages</path> debería mostrar líneas al final
parecidas a estas:
</p>

<pre caption="Ejemplo de las entradas por dhcp en el registro">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
Este fichero de registro también le puede ayudar a averiguar las
direcciones MAC de los esclavos.
</note>

<p>
Si recibe el siguiente mensaje, es probable que algo esté mal
en el fichero de configuración pero que el servidor DHCP esté
transmitiendo correctamente.
</p>

<pre caption="Ejemplo de un error en el servidor dhcp">
no free leases on subnet LOCAL-NET
</pre>

<p>
Cada vez que haga un cambio en el fichero de configuración,
deberá reiniciar el servidor DHCP. Para ello, escriba:
</p>

<pre caption="Reiniciar el servidor dhcp en el maestro">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configurar el servidor TFTP y el cargador de arranque PXE y/o Etherboot</title>
<section>
<title>Acerca del servidor TFTP</title>
<body>

<p>
TFTP son las (en inglés) siglas del Protocolo Trivial de Transferencia
de Ficheros. El servidor TFTP les va a dar a los esclavos el núcleo y
un sistema de fichero inicial. Todos los núcleos esclavos y sistemas
de ficheros deben estar almacenados en el servidor TFTP, así que es
una buena idea hacer que el maestro también sea el servidor TFTP.
</p>

</body>
</section>

<section>
<title>Instalar el servidor TFTP</title>
<body>

<p>
Un servidor tftp altamente recomendado está disponible en el paquete
tftp-hpa. Este servidor lo escribió el autor de SYSLINUX y funciona
muy bien con pxelinux. Para instalarlo simplemente escriba:
</p>

<pre caption="Instalar el servidor tftp">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>

<section>
<title>Configurar el servidor TFTP</title>
<body>

<p>
Edite el fichero <path>/etc/conf.d/in.tftpd</path>. Necesitará
especificar el directorio tftproot en la variable <c>INTFTPD_PATH</c>
y cualquier opción de la linea de comandos en <c>INTFTPD_OPTS</c>.
Debe parecerse a:
</p>

<pre caption="Ejemplo del /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
La opción <c>-l</c> indica que este servidor escucha en modo "stand
alone" así que no necesita ejecutar inetd. La <c>-v</c> indica que
se deben mostrar los mensajes de registro o error.
La <c>-s /diskless</c> especifica el directorio raíz de su servidor
tftp.
</p>

</body>
</section>

<section>
<title>Iniciar el servidor TFTP</title>
<body>

<p>
Para iniciar el servidor tftp, escriba:
</p>

<pre caption="Iniciar el servidor tftp del maestro">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Esta orden debe iniciar el servidor tftp con las opciones que hemos
especificado en <path>/etc/conf.d/in.tftpd</path>. Si quiere que este
servidor se inicie automáticamente cuando arranque el sistema,
escriba:
</p>

<pre caption="Añadir el servidor tftp al nivel de ejecución por defecto del maestro">
# <i>rc-update add in.tftpd default</i>
</pre>

</body>
</section>

<section>
<title>Acerca de PXELINUX</title>
<body>

<p>
Esta sección no es obligatoria para aquellos que utilizan Etherboot.
PXELINUX es el cargador de arranque por red equivalente a LILO y GRUB
y será distribuido mediante el TFTP. Es esencialmente un conjunto
mínimo de instrucciones que indica al cliente dónde encontrar su
núcleo y sistema de ficheros inicial y permite varias opciones del
núcleo.
</p>

</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Necesita obtener el fichero pxelinux.0 que viene en el paquete
SYSLINUX de H. Peter Anvin. Lo puede instalar escribiendo:
</p>

<pre caption="Instalar syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>

<section>
<title>Configurar PXELINUX</title>
<body>

<note>
Esta parte no es necesaria para Etherboot.
</note>

<p>
Antes de arrancar su servidor tftp necesita configurar
pxelinux. En primer lugar, copie el binario de pxelinux en su directorio
<path>/diskless</path>:
</p>

<pre caption="Configurar el cargador de arranque remoto">
# <i>cp /usr/share/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Esto creará el fichero de configuración por defecto del cargador de
arranque. El binario <path>pxelinux.0</path> buscará en el directorio
<path>pxelinux.cfg</path> un fichero cuyo nombre sea la dirección IP
del cliente en hexadecimal. Si no lo encuentra, eliminará el dígito
más a la derecha del nombre del fichero y lo volverá a intentar hasta
que se terminen los dígitos. Las versiones a partir de la 2.05
de syslinux realizan en primer lugar una búsqueda de un fichero
cuyo nombre sea la dirección MAC. Si no se encuentra, ejecuta la
rutina ya descrita. Si no se localiza ningún fichero, se utiliza
<path>default</path>.
</p>

<pre caption="Ficheros que busca PXE secuencialmente en pxelinux.cfg">
<comment>(El 01 del comienzo indica ethernet, los demás son la dirección MAC del esclavo)</comment>
01-00-40-63-c2-ca-c9
<comment>(Dirección IP asignada en hexadecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
default
</pre>

<note>
Todos son en minúsculas.
</note>

<p>
Comencemos con el fichero <path>default</path>:
</p>

<pre caption="Ejemplo de pxelinux.cfg/default">
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
La etiqueta <c>DEFAULT</c> le indica a pxelinux dónde está la bzImage
del núcleo. La etiqueta <c>APPEND</c> añade las opciones de arranque
para el núcleo. Dado que hemos compilado nuestro núcleo con
<c>NFS_ROOT_SUPPORT</c>, debemos especificar la dirección raíz del
nfs. La primera dirección IP es la del maestro y la segunda es el
directorio que se creó en <path>/diskless</path> para almacenar el
sistema de ficheros inicial del esclavo.
</p>

</body>
</section>

<section>
<title>Acerca de Etherboot</title>
<body>

<note>
Esta sección no es necesaria para aquellos que utilizan arranque PXE.
</note>

<p>
Los inicios mediante Etherboot cargan la imagen para arrancar desde el
servidor TFTP. Al igual que PXE, es equivalente a LILO o GRUB. La
utilidad <c>mknbi</c> le permite crear distintas imágenes con opciones
diferentes.
</p>

</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
Necesitará obtener el paquete <c>mknbi</c> (utilidad para crear
imágenes etiquetadas del núcleo que son útiles para el arranque
por red) para crear sus imágenes Etherboot. Esta utilidad creará
una imagen del núcleo pre-configurada de su núcleo original.
Esta contiene las opciones de arranque mostradas más adelante.
</p>

<pre caption="Instalar mknbi">
# <i>emerge mknbi</i>
</pre>

</body>
</section>

<section>
<title>Configurar Etherboot</title>
<body>

<p>
En esta sección crearemos una imagen simple de etherboot. Como el
servidor dhcp le indica al cliente la dirección raíz en la opción
"option root-path" del dhcp.conf, no necesitamos incluirla aquí. Más
detalles en el manual de mknbi.
</p>

<pre caption="manual de mknbi">
# <i>man mknbi</i>
</pre>

<p>
Crear la imagen de arranque. La siguiente orden creará la imagen
ELF de arranque capaz de pasar el dhcp y la dirección del directorio
raíz al núcleo. También obliga al núcleo a buscar en la red un
servidor dhcp.
</p>

<pre caption="Crear la imagen para el arranque por red">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Para crear una imagen específica para cada arquitectura escriba:
<c>bzImage_arch</c> y <c>vmlinuz_arch</c>.
</note>

</body>
</section>

<section>
<title>Solucionar problemas en el proceso de arranque por red</title>
<body>

<p>
Hay un par de cosas que puede hacer para corregir errores en el
proceso de arranque por red. Para empezar puede utilizar una
herramienta llamada <c>tcpdump</c>. Para instalarla, escriba:
</p>

<pre caption="Instalar tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Ahora puede escuchar el tráfico en la red y asegurarse
de que las interacciones entre el cliente y el servidor
funcionan correctamente. Si algo está mal hay un par de
cosas que debería revisar. Primero asegúrese de que el
cliente y el servidor estén físicamente bien conectados
y que los cables no están dañados. Si su cliente o su
servidor no están recibiendo pedidos a un puerto
específico, compruebe la configuración del cortafuegos.
Para escuchar la interacción entre dos computadores
escriba:
</p>

<pre caption="Escuchar la interacción cliente/servidor vía tcpdump">
# <i>tcpdump host </i><comment>client_ip</comment><i> and </i><comment>server_ip</comment>
</pre>

<p>
También puede utilizar <c>tcpdump</c> para escuchar un puerto en
particular como el puerto tftp. Para ello, escriba:
</p>

<pre caption="Escuchar el servidor tftp">
# <i>tcpdump port 69</i>
</pre>

<p>
Un error que comúnmente se recibe es "PXE-E32: TFTP open
time-out". Esto es probablemente debido a problemas con el
cortafuegos. Si está utilizando <c>TCPwrappers</c>, sería
conveniente revisar los ficheros <path>etc/hosts.allow</path>
y <path>etc/hosts.deny</path> para asegurarse de que
están bien configurados. Se debe permitir al cliente
conectarse al servidor.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configurar el servidor NFS</title>
<section>
<title>Acerca del servidor NFS</title>
<body>

<p>
NFS son las siglas (en inglés) de Sistema de Ficheros en Red.
El servidor NFS será utilizado para ofrecer al esclavo sus
directorios. Esta parte se puede personalizar más tarde, por
ahora, lo que buscamos es tener el nodo esclavo funcionando sin disco.
</p>

</body>
</section>

<section>
<title>Acerca de Portmapper</title>
<body>

<p>
Algunos servicios cliente/servidor no escuchan en un puerto en
particular, en cambio utilizan RPCs (llamadas a procedimientos
remotos). Cuando se inicializa un servicio, escucha en un puerto
al azar y luego registra este puerto en la utilidad Portmapper. NFS
utiliza RPCs y por lo tanto requiere tener a Portmapper corriendo
antes de su inicio.
</p>

</body>
</section>

<section>
<title>Antes de empezar</title>
<body>

<p>
El servidor NFS necesita soporte a nivel núcleo así que si no lo
incluyó en el momento de compilar, debe recompilar el núcleo
maestro. Para revisar la configuración de su núcleo maestro,
escriba:
</p>

<pre caption="Revisar las opciones específicas del NFS">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
La salida debe ser parecida a la siguiente si su núcleo está
correctamente configurado:
</p>

<pre caption="Opciones específicas de NFS apropiadas en la configuración del núcleo maestro">
CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 # CONFIG_NETFILTER is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>

</body>
</section>

<section>
<title>Instalar el servidor NFS</title>
<body>

<p>
El paquete NFS se puede instalar mediante portage escribiendo:
</p>

<pre caption="Instalar nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Este paquete instalará la utilidad portmapping, el servidor nfs,
y las utilidades nfs del cliente y automáticamente gestionará la
inicialización de las dependencias.
</p>

</body>
</section>

<section>
<title>Configurar el servidor NFS</title>
<body>

<p>
Hay tres ficheros de configuración principales que deberá
editar:
</p>

<pre caption="Ficheros de configuración nfs">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
El fichero <path>/etc/exports</path> especifica como, a quién y
qué se debe exportar a través de NFS. Se debe modificar el fstab
del esclavo para que pueda montar el sistema de ficheros NFS que
el maestro está exportando.
</p>

<p>
Un fichero <path>/etc/exports</path> típico del maestro se parece
a esto:
</p>

<pre caption="Ejemplo del /etc/exports maestro">
<comment># una linea como esta por cada esclavo</comment>
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
<comment># común a todos los esclavos</comment>
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
<comment># Si deseas tener un registro compartido</comment>
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>

<p>
El primer campo indica el directorio que será exportado y el siguiente
indica a quién y cómo. Este campo puede dividirse en dos partes: a
quién se le debe permitir montar ese directorio en particular, y qué
puede hacer el cliente con él: <c>ro</c> de solo lectura, <c>rw</c> de
lectura y escritura; <c>no_root_squash</c> y <c>no_all_squash</c>
son importantes para clientes sin disco que escriben en el disco de
manera que no sean "apretados" al hacer pedidos de E/S. El fichero
fstab del esclavo, <path>/diskless/192.168.1.21/etc/fstab</path>, debe
ser similar a este:
</p>

<pre caption="Ejemplo del fstab esclavo">
<comment># Estas entradas son esenciales</comment>
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># Útil pero superfluo</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
</pre>

<p>
En este ejemplo, <e>master</e> es solo el nombre de anfitrión del
maestro pero podría fácilmente ser la dirección IP del maestro.
El primer campo indica el directorio a montar y el segundo indica
dónde. El tercer campo describe el sistema de ficheros y debe ser
NFS para cualquier directorio NFS montado. El cuarto campo indica
varias opciones que deben ser utilizadas en el proceso de montaje
(eche un vistazo a mount(1) para obtener más información acerca de
las opciones de montaje). Algunos usuarios han tenido dificultad
con puntos de montaje suaves así que los hemos hecho todos duros,
pero debe revisar varias opciones para <path>/etc/fstab</path>
de manera que haga su cluster más eficiente.
</p>

<p>
El último fichero que se debe modificar es
<path>/etc/conf.d/nfs</path> que describe las opciones del
nfs cuando es inicializado y es parecido a este:
</p>

<pre caption="Ejemplo del /etc/conf.d/nfs maestro">
# Config file for /etc/init.d/nfs
# Number of servers to be started up by default
RPCNFSDCOUNT=8
# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Debe cambiar <c>RPCNFSDCOUNT</c> por el número de nodos sin
disco en la red.
</p>

</body>
</section>

<section>
<title>Arrancar el servidor NFS</title>
<body>

<p>
Debe iniciar el servidor nfs con su guión de inicio localizado en
<path>/etc/init.d</path>, escribiendo:
</p>

<pre caption="Iniciar el servidor nfs maestro">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Si quiere que este guión se ejecute cuando se inicie el sistema,
simplemente escriba:
</p>

<pre caption="Añadir el servidor nfs al nivel de ejecución por defecto del maestro">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Completar el sistema de ficheros del esclavo</title>
<section>
<title>Copiar los ficheros que faltan</title>
<body>

<p>
Ahora sincronizaremos el sistema de ficheros del esclavo con el del
maestro y ofreceremos los binarios necesarios, preservando los
ficheros específicos del esclavo.
</p>

<pre caption="Crear el sistema de ficheros maestro">
# <i>rsync -avz /bin /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib /diskless/192.168.1.21</i>
</pre>

<note>
La razón por la que utilizamos -avz en vez de cp es la de mantener los
enlaces simbólicos y los permisos.
</note>

</body>
</section>

<section>
<title>Configurar la red sin disco</title>
<body>

<p>
Para evitar que el guión de inicio de red corte la conexión a
su servidor NFS, necesitará agregar una opción al fichero
<path>/etc/conf.d/net</path> del sistema de ficheros de su
cliente sin disco.
</p>

<pre caption="Editar /etc/conf.d/net">
<comment>(Agregue esta opción a las ya existentes para la interfaz de su cliente)</comment>
config_eth0=( "noop" )
</pre>

<note>
Para obtener más información, por favor, lea
<path>/usr/share/doc/openrc-*/net.example.bz2</path>.
</note>

</body>
</section>

<section>
<title>Guiones de inicio</title>
<body>

<p>
Necesitará tantos guiones de inicio en
<path>/diskless/192.168.1.21/etc/runlevels</path> como
servicios tenga en el nodo sin disco. Todo depende de lo
que desee que hagan sus esclavos.
</p>

<warn>
No use <c>rc-update</c> para añadir o eliminar guiones de los
niveles de ejecución del esclavo cuando esté en el maestro.
Esto podría alterar lo niveles de ejecución del maestro. Necesita
crear enlaces manualmente o ingresar en tus nodos esclavos
utilizando ssh o conectar una pantalla y teclado a su esclavo.
</warn>

<pre caption="Niveles de ejecución típicos del esclavo">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single

/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom

/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron

/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local

/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
Ahora es un buen momento para que iniciar sus esclavos y cruce los
dedos. ¿Funciona? Felicidades, ahora es un orgulloso poseedor de
nodo(s) sin disco :)
</p>

</body>
</section>

<!--
<section>
<title>Una alternativa: ClusterNFS</title>
<body>

<warn>
Esto se menciona solamente porque el editor de este documento
lo está utilizando.  Esté consciente que Gentoo <e>no</e> soporta
Cluster NFS. No está en el portage y requiere hacer cambios en la
distribución base de los guiones de inicio. <b>Úsalo bajo tu propio
riesgo</b>.
</warn>

<p>
Si te no suena atractivo tener un directorio raíz distinto por cada
esclavo porque eso necesitaría algún mantenimiento al momento de
actualizar los ficheros desde los directorios maestros, podrías
compartir la misma raíz a través de todos los nodos, maestro y esclavo
incluidos. Esto significa que todas tus máquinas necesitan ser
compatibles porque solo tendrás un juego de binarios. También debes
tener en cuenta que esto tiene consecuencias en la seguridad porque
toda la raíz del maestro será exportada a través de NFS.
</p>

<p>
Si todavía quieres probar esta alternativa, visita la página oficial
de <uri link="http://clusternfs.sourceforge.net/">ClusterNFS</uri>,
para descargar el software y leer la documentación.
</p>

<p>
Para hacer la historia corta, todos los ficheros son compartidos y los
ficheros que necesitan ser distintos entre el maestro y todos los
esclavos son copiados a <path>file$$CLIENT$$</path>. Cuando un esclavo
pide el <path>file</path>, ClusterNFS se dará cuenta de la existencia
de <path>file$$CLIENT$$</path>, enviando este último. Los ficheros que
necesitan ser distintos en cada nodo son copiados a
<path>file$$IP=192.168.1.21$$</path>. Lo mismo con los directorios.
</p>

<p>
En resumidas cuentas, esto es lo que diferencia este método al
previamente explicado:
</p>

<ul>
  <li>No necesitas el soporte para el servidor NFS en tu núcleo maestro</li>
  <li>Instalar ClusterNFS <e>después</e> de emerger nfs-utils</li>
  <li>
    Hacer copias de los ficheros y directorios de los esclavos como se
    describe más adelante
  </li>
  <li>No se crea un directorio raíz distinto para cada nodo</li>
  <li>Solo se exporta / en tu fichero <path>/etc/exports</path></li>
  <li>
    Solo se monta / vía NFS en el fichero <path>/etc/fstab$$CLIENT$$</path>
    del esclavo.
  </li>
  <li>Modificar <path>/etc/init.d/nfs</path> como se describe más abajo</li>
  <li>
    Modificar  <path>/etc/conf.d/local.start$$CLIENT$$</path> como se
    describe más abajo
  </li>
</ul>

<pre caption="Ficheros que necesitan ser distintos entre el maestro y los esclavos">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Probablemente vacío)</comment>
/etc/crontab$$CLIENT$$<comment> (Probablemente vacío, el maestro se encarga de esto)</comment>
/etc/exports$$CLIENT$$<comment> (vacío, los esclavos no exportan montajes NFS)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Nombre de tus esclavos)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Separación limpia entre los guiones de arranque del maestro y esclavos
</comment>
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Crea subdirectorios en /var)</comment>
</pre>

<pre caption="Modificar /etc/init.d/nfs">
        ebegin "Starting NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Añade la opción - -translate-names </comment>
                $nfsd - - - -translate-names
        eend $? "Error starting NFS daemon"
         # Check if we support NFSv3
        ebegin "Starting NFS mountd"
<comment># Comenta las siguientes dos lineas (ClusterNFS solo conoce NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Error starting NFS mountd"
</pre>

</body>
</section>
-->
</chapter>
</guide>
