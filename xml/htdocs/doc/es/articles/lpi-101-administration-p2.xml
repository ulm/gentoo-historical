<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/articles/lpi-101-administration-p2.xml,v 1.1 2011/05/02 18:42:22 nimiux Exp $-->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide lang="es" disclaimer="articles">
<title>Preparación para el examen de certificación 101 del LPI (segundo
lanzamiento), Parte 2</title>

<author title="Author">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Author">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Author">
  Aron Griffis
</author>
<!--<author title="Editor">
  <mail link="smithj@gentoo.org">Jonathan Smith</mail>
</author>-->
<author title="Traductora">
  <mail link="nilda_46@hotmail.com">Gabriela Villanueva</mail>
</author>

<abstract>
En este tutorial, aprenderá como utilizar expresiones regulares para
buscar patrones de texto en archivos, cómo localizar archivos en su
sistema y cómo tener control total de los procesos Linux. También
tendrá una introducción rápida a tuberías de la interfaz de comandos,
redireccionamiento y órdenes de procesamiento de texto. Al final de
este tutorial, tendrá una base sólida en administración básica de
Linux y estará listo para comenzar con administración avanzada de
sistemas Linux en la siguiente parte de este tutorial.
</abstract>

<!-- La versión original de este artículo fue publicada originalmente
por IBM developerWorks y es propiedad de Westtech Information
Services. Este documento es una versión actualizada del artículo
original y contiene mejoras realizadas por el equipo de documentación
de Gentoo Linux -->

<version>2</version>
<date>2010-11-14</date>

<chapter>
<title>Antes de comenzar</title>
<section>
<title>Acerca de este tutorial</title>
<body>

<p>
Bienvenido a “Administración básica”, el segundo de cuatro tutoriales
diseñado para prepararlo para el examen 101 del Instituto Profesional
de Linux (LPI por sus siglas en inglés). En este tutorial, le
mostraremos como utilizar expresiones regulares para buscar archivos
utilizando patrones de texto. Después, haremos una introducción al estándar
de jerarquía del sistema de archivos (FHS, por sus siglas en inglés),
y le mostraremos como encontrar archivos en su sistema. Además le
diremos como tomar control total de los procesos de Linux,
ejecutándolos en segundo plano, listándolos, separándolos de la
terminal y más. También, le daremos una rápida introducción a
tuberías de la interfaz de comandos, redireccionamiento, y órdenes de
procesamiento de texto. Por último, haremos una introducción a los
módulos del núcleo Linux.
</p>

<p>
Este tutorial en particular (parte 2) es ideal para quienes tienen un
buen conocimiento básico de bash y quieren recibir una sólida
introducción a tareas básicas de administración Linux. Si es nuevo en
Linux, le recomendamos que complete la parte 1 de esta serie de
tutoriales antes de continuar. Para algunos, este material será
nuevo, pero los usuarios Linux más experimentados encontrarán en este
tutorial una buena manera de complementar sus conocimientos básicos
de administración Linux.
</p>

<p>
Para aquellos que han tomado el lanzamiento 1 de este tutorial por
razones diferentes a la preparación para el examen LPI, probablemente
no sea necesario tomar esta versión. Sin embargo, si planea presentarse
a los exámenes, debe considerar seriamente leer este tutorial.
</p>

</body>
</section>
<section>
<title>Acerca del autor</title>
<body>

<p>
Con residencia en Albuquerque, Nuevo México, Daniel Robbins es el
arquitecto en jefe de Gentoo Linux, una metadistribución Linux
avanzada basada en puertos (ports). Además escribe artículos,
tutoriales y sugerencias para IBM developerWorks zona Linux y servicios
de desarrollo Intel. También ha contribuido como autor de muchos libros,
incluyendo Samba y SuSE Unleashead. Daniel disfruta pasar tiempo con
su esposa Mary y su hija Hadassha. Puede contactar a Daniel en <mail>
drobbins@gentoo.org</mail>.
</p>

<p>
Chris Houser, conocido por sus amigos como "Chouser," ha sido un
partidario de UNIX desde 1994 cuando se unió al equipo de
administración de la red de informática en la Universidad Taylor en
Indiana, donde obtuvo su licenciatura en Ciencias de la Computación y
Matemáticas. Desde entonces ha trabajado en programación de
aplicaciones web, diseño de interfaz de usuario, soporte para
programas de vídeo profesional y ahora programando el controlador del
dispositivo Tru4 UNIX en Compaq. Además ha contribuido en varios
proyectos de programas libres (recientemente en Gentoo Linux). Vive
con su esposa y dos gatos en New Shapire. Puede contactarlo en
chouser@gentoo.org.
</p>

<p>
Aron Griffis, graduado de la Universidad Taylor con título en
Ciencias de la Computación y premiado con el título "Futuro fundador
de una comunidad UNIX utópica". Trabajando para conseguir ese
objetivo Aron es empleado de Compaq, escribe controladores de red
para Tru64 UNIX y utiliza su tiempo libre tocando melodías en el
piano o desarrollando Gentoo Linux. Vive con su esposa Amy (también
ingeniera UNIX) en Nashua, New Hampshire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Expresiones regulares</title>
<section>
<title>¿Qué es una expresión regular?</title>
<body>

<p>
Una expresión regular (también llamada "regex" o "regexp") es una
sintaxis especial usada para describir patrones de texto. En los
sistemas Linux, las expresiones regulares son comúnmente usadas para
encontrar patrones de texto, así como para realizar operaciones de
buscar y reemplazar en cadenas de texto.
</p>

</body>
</section>
<section>
<title>Comparación con Glob</title>
<body>

<p>
Cuando veamos expresiones regulares, puede notar que la sintaxis de
expresiones regulares es similar a la del archivo de nombre
"englobamiento" que vimos en la parte 1. Sin embargo, no permita que
esto lo confunda, su parecido es solo superficial. Ambos, expresiones
regulares y los patrones de englobamiento, si bien parecen similares
son fundamentalmente diferentes.
</p>

</body>
</section>
<section>
<title>La subcadena simple</title>
<body>

<p>
Con la advertencia anterior, veamos lo más básico de expresiones
regulares, la subcadena simple. Para hacer esto usaremos <c>grep</c>,
una orden que busca en el contenido de un archivo una expresión
regular determinada. <c>grep</c> imprime cada línea que coincide con
la expresión regular e ignora cada línea que no lo hace:
</p>

<pre caption="grep en acción">
$ <i>grep bash /etc/passwd</i>
operator:x:11:0:operator:/root:/bin/bash
root:x:0:0::/root:/bin/bash
ftp:x:40:1::/home/ftp:/bin/bash
</pre>

<p>
Arriba, el primer parámetro <c>grep</c> es una expresión regular; el
segundo es el nombre de un archivo. <c>grep</c> lee cada línea en
/etc/passwd y le aplica la expresión regular subcadena simple bash,
buscando coincidencias. Si una coincidencia es encontrada, <c>grep</c>
imprime cada línea que coincide, de lo contrario, la línea es
ignorada.
</p>

</body>
</section>
<section>
<title>Entendiendo la subcadena simple</title>
<body>

<p>
En general, si está buscando una subcadena, puede especificar el
texto literal sin proporcionar caracteres "especiales". El único
momento en el que necesitará hacer algo especial sería si su
subcadena contiene +, ., *, [, ], o \, en cuyo caso estos caracteres
tendrían que estar entre comillas precedidos por una barra invertida.
Estos son algunos ejemplos de la subcadena simple de expresiones
regulares:
</p>

<ul>
  <li>/tmp (busca por la cadena literal /tmp)</li>
  <li>"\[box\]" (busca por la cadena literal [box])</li>
  <li>"\*funny\*" (busca por la cadena literal *funny*)</li>
  <li>"ld\.so" (busca por la cadena literal ld.so)</li>
</ul>

</body>
</section>
<section>
<title>Metacaracteres</title>
<body>

<p>
Con expresiones regulares, puede realizar búsquedas mucho más
complejas que los ejemplos que hemos visto hasta el momento tomando
ventaja de los metacaracteres. Uno de estos caracteres es el .
(punto) el cual coincide con cualquier carácter:
</p>

<pre caption="El metacarácter punto">
$ <i>grep dev.hda /etc/fstab</i>
/dev/hda3      /              reiserfs      noatime,ro 1 1
/dev/hda1      /boot          reiserfs      noauto,noatime,notail 1 2
/dev/hda2      swap           swap          sw 0 0
#/dev/hda4     /mnt/extra     reiserfs        noatime,rw 1 1
</pre>

<p>
En este ejemplo, el texto literal dev.hda no aparece en ninguna de
las líneas de /etc/fstab. Sin embargo, grep no buscaba la cadena
literal dev.hda, pero si el patrón dev.hda. Recuerde que . coincidirá
con cualquier carácter. Como puede ver el metacarácter . es
equivalente en su funcionamiento al metacarácter ? de las expansiones
"globales".
</p>

</body>
</section>
<section>
<title>Uso de []</title>
<body>

<p>
Si quisiéramos hacer coincidir un carácter más específicamente que
con ., podemos utilizar [ y ] (corchetes) para especificar un
subconjunto de caracteres que pueden coincidir:
</p>

<pre caption="Corchetes en acción">
$ <i>grep dev.hda[12] /etc/fstab</i>
/dev/hda1     /boot        reiserfs        noauto,noatime,notail 1 2
/dev/hda2     swap         swap            sw 0 0
</pre>

<p>
Como puede ver, esta función sintáctica particular funciona idéntica
a [] de expansiones de "englobamiento". De nuevo, esta es una de las
cosas complicadas sobre aprender expresiones regulares -- la sintaxis
es similar pero no idéntica a la de expansiones de "englobamiento", lo
cual hace que las expresiones regulares sean un tanto confusas de
aprender.
</p>

</body>
</section>
<section>
<title>Usando [^]</title>
<body>

<p>
Puede invertir el significado de los corchetes agregando un ^
inmediatamente después de [. En este caso, los corchetes encontrarán
una coincidencia con cualquier carácter que <e>no</e> sea mencionado
dentro de los mismos. Una vez más, note que usamos [^] con
expresiones regulares y [!] con englobamiento:
</p>

<pre caption="Corchetes con negación">
$ <i>grep dev.hda[^12] /etc/fstab</i>
/dev/hda3       /               reiserfs        noatime,ro 1 1
#/dev/hda4      /mnt/extra      reiserfs        noatime,rw 1 1
</pre>

</body>
</section>
<section>
<title>Diferentes sintaxis</title>
<body>

<p>
Es importante notar que la sintaxis entre corchetes es
fundamentalmente diferente de la utilizada en otras partes de la
expresión regular. Por ejemplo, si pone un . dentro de corchetes,
esto le permite encontrar una coincidencia literal con ., justo como
en los ejemplos 1 y 2 mencionados arriba. En cambio, un . literal
fuera de los corchetes se interpreta como un metacarácter  a menos
que sea precedido de una \. Podemos aprovechar este hecho para
imprimir una lista de todas las líneas en <path>/etc/fstab</path> que
contengan la cadena literal dev.hda tecleando:
</p>

<pre caption="Imprimiendo literales usando corchetes">
$ <i>grep dev[.]hda /etc/fstab</i>
</pre>

<p>
Alternativamente podemos escribir:
</p>

<pre caption="Imprimiendo literales usando excepciones">
$ <i>grep "dev\.hda" /etc/fstab</i>
</pre>

<p>
Es probable que ninguna expresión regular coincida con las líneas del
archivo <path>/etc/fstab</path>.
</p>

</body>
</section>
<section>
<title>El metacarácter "*"</title>
<body>

<p>
Algunos metacaracteres no coinciden con nada por si solos, pero
modifican el significado del carácter previo. Un ejemplo de esto es
el metacarácter * (asterisco), el cual es usado para coincidir con
cero o más ocurrencias del carácter anterior. Tenga en cuenta que
esto significa que * tiene un significado diferente en expresiones
regulares que en englobamiento:
</p>

<ul>
  <li>
    ab*c coincide con abbbbc pero no con abqc  (si fuese
    englobamiento, coincidiría con ambas cadenas -- ¿Puede determinar
    por qué?)
  </li>
  <li>
    ab*c coincide con abc pero no con abbqbbc (de nuevo, si fuese
    englobamiento coincidiría con ambas cadenas)
  </li>
  <li>
    ab*c coincide con ac pero no con cba (si fuese englobamiento, ac
    no coincidiría, ni tampoco cba)
  </li>
  <li>
    b[cq]*e coincide con bqe y be (si fuese englobamiento, coincidiría
    bqe pero no be)
  </li>
  <li>
    b[cq]*e coincide con bccqqe pero no con bccc (si fuese
    englobamiento, coincidiría con la primera pero no con la segunda)
  </li>
  <li>
    b[cq]*e coincide con bqqcce pero no con cqe (si fuese
    englobamiento, coincidiría con la primera pero no con la segunda)
  </li>
  <li>
    b[cq]*e coincide con bbbeee (no sería el caso con englobamiento)
  </li>
  <li>
    .* coincide con cualquier cadena. (si fuese englobamiento,
    coincidiría con cualquier cadena que comience con .)
  </li>
  <li>
   foo.* coincidiría con cualquier cadena que comience con foo (si
   fuese englobamiento, coincidiría con cualquier cadena que
   comience con los cuatro caracteres literales foo.)
  </li>
</ul>

<p>
Ahora un pequeño repaso: la línea ac coincide con la expresión
regular ab*c por que el asterisco también le permite a la expresión
anterior (b) aparecer <e>cero</e> veces. Nuevamente, es fundamental
tener en cuenta que el metacarácter * de expresiones regulares se
interpreta de manera fundamentalmente diferente que el carácter * de
englobamiento.
</p>

</body>
</section>
<section>
<title>Principio y final de línea</title>
<body>

<p>
Los últimos metacaracteres que cubriremos aquí a detalle son ^ y $,
utilizados para encontrar coincidencias al principio y al final de la
línea respectivamente. Mediante el uso de ^ al principio de su
expresión regular, puede hacer que su patrón esté "anclado" al inicio
de la línea. En el siguiente ejemplo, usamos la expresión regular ^#
para encontrar cualquier línea que comience con el carácter #:
</p>

<pre caption="Líneas">
$ <i>grep ^# /etc/fstab</i>
# /etc/fstab: static file system information.
#
</pre>

</body>
</section>
<section>
<title>Expresiones regulares de línea completa</title>
<body>

<p>
^ y $ se pueden combinar para coincidir con una línea completa. Por
ejemplo, la siguiente expresión regular coincidirá con una línea que
comience con el carácter  # y termine con el carácter ., con
cualquier número de caracteres entre ellos:
</p>

<pre caption="Encontrando coincidencias en una línea completa">
$ <i>grep '^#.*\.$' /etc/fstab</i>
# /etc/fstab: static file system information.
</pre>

<p>
En el ejemplo anterior, encerramos la expresión regular entre
comillas simples para prevenir que $ sea interpretado por el
intérprete de comandos. Sin las comillas simples, el $ desaparecería
de la expresión regular antes de darle a grep la oportunidad de verlo.
</p>

</body>
</section>
</chapter>

<chapter>
<title>FHS y búsqueda de archivos</title>
<section>
<title>Estándar de jerarquía del sistema de archivos (FHS)</title>
<body>

<p>
El Estándar de Jerarquía del sistema de archivos es un documento que
especifica la disposición de los directorios en un sistema Linux. El
FHS se diseñó para proporcionar un esquema común para simplificar la
distribución de software independiente -- así que este material es en
general el mismo entre las distintas distribuciones de Linux. El FHS
especifica el siguiente árbol de directorios (tomados directamente de
la especificación FHS):
</p>

<ul>
  <li>/     (el directorio root)</li>
  <li>/boot (archivos estáticos del boot loader)</li>
  <li>/dev  (archivos de dispositivos)</li>
  <li>/etc  (anfitrión-configuración específica del sistema)</li>
  <li>/lib  (librerías compartidas esenciales y módulos del núcleo)</li>
  <li>
    /mnt  (punto de montaje para el montaje temporal de un sistema
    de archivos)
  </li>
  <li>/opt  (paquetes de complementos de aplicaciones)</li>
  <li>/sbin (binarios esenciales del sistema)</li>
  <li>/tmp  (archivos temporales)</li>
  <li>/usr  (jerarquía secundaria)</li>
  <li>/var  (datos variables)</li>
</ul>

</body>
</section>
<section>
<title>Las dos categorías independientes del FHS</title>
<body>

<p>
El FHS basa su especificación de diseño en la idea de que existen dos
categorías independientes de archivos: compartidos vs no compartidos,
y variables vs estáticos. Los archivos compartidos pueden, como su
nombre lo dice, ser compartidos entre anfitriones; los datos
no compartidos son específicos de un anfitrión (por ejemplo, los
archivos de configuración). Los datos variables pueden ser
modificados; los estáticos no son modificables (excepto en la
instalación y mantenimiento de un sistema).
</p>

<p>
El siguiente cuadro resume las cuatro combinaciones posibles, con
ejemplos de directorios que pueden formar parte de esas categorías.
Una vez más, esta tabla es tomada directamente de la especificación
FHS:
</p>

<pre caption="FHS">
+----------+-----------------+----------------+
|          | compartidos     | no compartidos |
+----------+-----------------+----------------+
|estáticos | /usr            | /etc           |
|          | /opt            | /boot          |
+----------+-----------------+----------------+
|variables | /var/mail       | /var/run       |
|          | /var/spool/news | /var/lock      |
+----------+-----------------+----------------+
</pre>

</body>
</section>
<section>
<title>Jerarquía secundaria en /usr</title>
<body>

<p>
En <path>/usr</path> encontrará una jerarquía secundaria que luce muy
parecida al sistema de archivos de root. No es crítico para
<path>/user</path> existir cuando la máquina encienda, puede estar
compartido en una red (compartido), o montado en un CD-ROM (estático).
La mayoría de las configuraciones de Linux no hacen uso del intercambio
de <path>/usr</path>, pero es valioso comprender la utilidad de
distinguir entre la jerarquía primaria en un directorio root y la
jerarquía secundaria en <path>/usr</path>.
</p>

<p>
Esto es todo lo que veremos acerca del Estándar de la Jerarquía del
Sistema de Archivos. El documento mismo es bastante fácil de leer,
así que debería de darle un vistazo. Si lo lee, comprenderá mucho más
acerca del sistema de archivos Linux. Puede encontrarlo en
<uri>http://www.pathname.com/fhs/</uri>.
</p>

</body>
</section>
<section>
<title>Búsqueda de archivos</title>
<body>

<p>
Los sistemas frecuentemente contienen cientos de miles de archivos.
Tal vez tiene la experiencia suficiente para no perderles el rastro,
pero es probable que ocasionalmente necesite ayuda para encontrar
alguno. Existen algunas herramientas en Linux para encontrar
archivos. Esta introducción le ayudará a elegir la herramienta
adecuada para este trabajo.
</p>

</body>
</section>
<section>
<title>El PATH</title>
<body>

<p>
Cuando ejecuta un programa en la línea de comandos, bash en realidad
busca dentro de una lista de directorios para encontrar el programa
que solicitó. Por ejemplo cuando teclea <c>ls</c>, <c>bash</c>
intrínsecamente desconoce que el programa ls vive en <path>/usr/bin
</path>. En cambio, bash hace referencia a una variable llamada PATH,
la cual es una lista de directorios separada por dos puntos (:).
Podemos examinar el valor de PATH:
</p>

<pre caption="Viendo PATH">
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin
</pre>

<p>
Considerando este valor de PATH (el suyo puede ser diferente), bash
revisará primero <path>/usr/local/bin</path>, luego
<path>/usr/bin</path> en búsqueda del programa <c>ls</c>. Lo más
probable es que <c>ls</c> se encuentre en <path>/usr/bin</path>, por
lo que bash se detendrá en ese punto.
</p>

</body>
</section>
<section>
<title>Modificando PATH</title>
<body>

<p>
Puede aumentar su PATH asignándolo en la línea de comandos:
</p>

<pre caption="Editando PATH">
$ <i>PATH=$PATH:~/bin</i>
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin:/home/yo/bi
n
</pre>

<p>
También puede eliminar elementos de PATH, aunque no es tan fácil
porque no puede hacer referencia al $PATH existente. Lo mejor es
simplemente escribir el nuevo PATH que desea:
</p>

<pre caption="Eliminando entradas de PATH">
$ <i>PATH=/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:~/bin</i>
$ <i>echo $PATH</i>
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/agriffis/bin
</pre>

<p>
Para hacer que sus cambios en PATH estén disponibles para cualquier
proceso futuro puede comenzar en esta interfaz de comandos, exportar
sus cambios utilizando el comando export:
</p>

<pre caption="Exportando PATH (o cualquier variable, para el mismo caso)">
$ <i>export PATH</i>
</pre>

</body>
</section>
<section>
<title>Todo sobre "which"</title>
<body>

<p>
Puede revisar si existe un programa dado en PATH utilizando <c>which</c>.
Por ejemplo, aquí nos encontramos con que nuestro sistema Linux
no tiene sentido (común):
</p>

<pre caption="Buscando sentido">
$ which <i>sentido</i>
which: no sentido in
(/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin)
</pre>

<p>
En este ejemplo, encontramos <c>ls</c>:
</p>

<pre caption="Buscando ls">
$ <i>which ls</i>
/usr/bin/ls
</pre>

</body>
</section>
<section>
<title>"which -a"</title>
<body>

<p>
Finalmente, debe saber que la bandera <c>-a</c>, ocasiona que
<c>which</c> le muestre todas las instancias de un programa determinado
en su PATH:
</p>

<pre caption="Encontrando todas las instancias de un programa en su PATH">
$ <i>which -a ls</i>
/usr/bin/ls
/bin/ls
</pre>

</body>
</section>
<section>
<title>whereis</title>
<body>

<p>
Si está interesado en conocer más información de un programa en lugar
de su simple ubicación, puede probar el programa <c>whereis</c>:
</p>

<pre caption="Uso de whereis">
$ <i>whereis ls</i>
ls: /bin/ls /usr/bin/ls /usr/share/man/man1/ls.1.gz
</pre>

<p>
Podemos ver que <c>ls</c> aparece en dos lugares binarios comunes,
<path>/bin</path> y <path>/usr/bin</path>. Adicionalmente, estamos
informados de que existe una página de manual localizada en
<path>/usr/share/man</path>. Esta es la página del manual que vería si
teclea <c>man ls</c>.
</p>

<p>
El programa <c>whereis</c> también tiene la habilidad de buscar
fuentes, especificar rutas de búsqueda alternativas y buscar entradas
inusuales. Consulte la página del manual para más información.
</p>

</body>
</section>
<section>
<title>find</title>
<body>

<p>
La orden <c>find</c> es otra herramienta útil para su caja de
herramientas. Con find no está limitado solo a programas; puede buscar
cualquier archivo que desee, utilizando una variedad de criterios de
búsqueda. Por ejemplo, para buscar un archivo de nombre LEEME, que
comienza en <path>/usr/share/doc</path>:
</p>

<pre caption="Using find">
$ <i>find /usr/share/doc -name LEEME</i>
/usr/share/doc/ion-20010523/LEEME
/usr/share/doc/bind-9.1.3-r6/dhcp-dynamic-dns-examples/LEEME
/usr/share/doc/sane-1.0.5/LEEME
</pre>

</body>
</section>
<section>
<title>find y comodines</title>
<body>

<p>
Puede usar los comodines de "englobamiento" en el argumento -name,
siempre que los encierre entre comillas o barras invertidas (así son
buscados intactos y no son ampliados por bash). Por ejemplo, puede
que quiera buscar archivos LEEME con extensiones:
</p>

<pre caption="Uso de find con comodines">
$ <i>find /usr/share/doc -name LEEME\*</i>
/usr/share/doc/iproute2-2.4.7/LEEME.gz
/usr/share/doc/iproute2-2.4.7/LEEME.iproute2+tc.gz
/usr/share/doc/iproute2-2.4.7/LEEME.decnet.gz
/usr/share/doc/iproute2-2.4.7/examples/diffserv/LEEME.gz
/usr/share/doc/pilot-link-0.9.6-r2/LEEME.gz
/usr/share/doc/gnome-pilot-conduits-0.8/LEEME.gz
/usr/share/doc/gimp-1.2.2/LEEME.i18n.gz
/usr/share/doc/gimp-1.2.2/LEEME.win32.gz
/usr/share/doc/gimp-1.2.2/LEEME.gz
/usr/share/doc/gimp-1.2.2/LEEME.perl.gz
[578 líneas adicionales omitidas]
</pre>

</body>
</section>
<section>
<title>Ignorando distinción entre mayúsculas y minúsculas con find</title>
<body>

<p>
Por supuesto, puede querer ignorar la distinción entre mayúsculas y
minúsculas en su búsqueda:
</p>

<pre caption="Ignorando mayúsculas y minúsculas con find">
$ <i>find /usr/share/doc -name '[Ll][Ee][Ee][Mm][Ee]*'</i>
</pre>

<p>
O, más simple:
</p>

<pre caption="Otro método">
$ <i>find /usr/share/doc -iname leeme\*</i>
</pre>

<p>
Como puede ver, <c>-iname</c> realiza una búsqueda insensible a la
distinción entre mayúsculas y minúsculas.
</p>

</body>
</section>
<section>
<title>find y expresiones regulares</title>
<body>

<p>
Si está familiarizado con expresiones regulares, puede utilizar la
opción<c>-regex</c> para limitar los resultados a los nombres de archivos
que coincidan con un patrón. Y similar a la opción <c>-iname</c>,
existe un opción correspondiente <c>-iregex</c> que ignora la
distinción entre mayúsculas y minúsculas en un patrón. Por ejemplo:
</p>

<pre caption="Expresiones regulares y find">
$ <i>find /etc -iregex '.*xt.*'</i>
/etc/X11/xkb/types/extra
/etc/X11/xkb/semantics/xtest
/etc/X11/xkb/compat/xtest
/etc/X11/app-defaults/XTerm
/etc/X11/app-defaults/XTerm-color
</pre>

<p>
Tenga en cuenta que <c>find</c> a diferencia de muchos programas,
requiere que la expresión regular especificada coincida con la ruta
completa, no solo una parte de ella. Por esa razón, es necesario
especificar el .* anterior y posterior; con simplemente xt como
expresión regular no sería suficiente.
</p>

</body>
</section>
<section>
<title>find y tipos</title>
<body>

<p>
La opción <c>-type</c> le permite encontrar objetos del sistema de
archivos de un cierto tipo. Los argumentos posibles para -type son
<c>b</c> (dispositivo de bloques), <c>c</c> (dispositivo de caracteres),
<c>d</c> (directorio), <c>p</c> (tubería con nombre), <c>f</c>
(archivo regular), <c>l</c> (enlace simbólico), y <c>s</c> (socket).
Por ejemplo, para buscar archivos simbólicos en <path>/usr/bin</path>
que contengan la cadena vim:
</p>

<pre caption="Restringiendo find con tipos">
$ <i>find /usr/bin -name '*vim*' -type l</i>
/usr/bin/rvim
/usr/bin/vimdiff
/usr/bin/gvimdiff
</pre>

</body>
</section>
<section>
<title>find y mtimes (tiempo de la última modificación)</title>
<body>

<p>
La opción <c>-mtime</c> le permite seleccionar archivos basada en el
tiempo de su última modificación. El argumento para mtime está dado
en periodos de 24 horas, y es más útil cuando se utiliza un signo más
(que significa "después") o un signo menos (que significa "antes".
Por ejemplo, consideremos el siguiente escenario:
</p>

<pre caption="Escenario">
$ <i>ls -l ?</i>
-rw-------    1 root     root            0 Jan  7 18:00 a
-rw-------    1 root     root            0 Jan  6 18:00 b
-rw-------    1 root     root            0 Jan  5 18:00 c
-rw-------    1 root     root            0 Jan  4 18:00 d
$ <i>date</i>
Mon May  7 18:14:52 EST 2003
</pre>

<p>
Puede buscar archivos que hayan sido creados en las últimas 24 horas:
</p>

<pre caption="Archivos creados en las últimas 24 horas">
$ <i>find . -name \? -mtime -1</i>
./a
</pre>

<p>
O puede buscar archivos que hayan sido creados antes del actual
periodo de 24 horas:
</p>

<pre caption="Archivos creados antes de las últimas 24 horas">
$ <i>find . -name \? -mtime +0</i>
./b
./c
./d
</pre>

</body>
</section>
<section>
<title>La opción -daystart</title>
<body>

<p>
Si adicionalmente especifica la opción <c>-daystart</c>, entonces los
periodos de tiempo inician al comienzo del día actual en lugar de 24
horas atrás. Por ejemplo, aquí se muestra un conjunto de archivos
creados ayer y anteayer.
</p>

<pre caption="Usando -daystart">
$ <i>find . -name \? -daystart -mtime +0 -mtime -3</i>
./b
./c
$ ls -l b c
-rw-------    1 root     root            0 May  6 18:00 b
-rw-------    1 root     root            0 May  5 18:00 c
</pre>

</body>
</section>
<section>
<title>La opción -size</title>
<body>

<p>
La opción <c>-size</c> le permite buscar archivos basados en su
tamaño. De forma predeterminada el argumento de <c>-size</c> es de
bloques de 512 bytes, pero agregando un sufijo puede ser más sencillo.
Los sufijos disponibles son <c>b</c> (bloques de 512 bytes), <c>c</c>
(bytes), <c>k</c> (kilobytes), y <c>w</c> (palabras de 2 bytes).
Además, puede anteponer un signo más ("mayor que") o un signo menos
("menor que").
</p>

<p>
Por ejemplo para buscar archivos regulares en <path>/usr/bin</path>
que son más pequeños que 50 bytes:
</p>

<pre caption="-size en acción">
$ <i>find /usr/bin -type f -size -50c</i>
/usr/bin/krdb
/usr/bin/run-nautilus
/usr/bin/sgmlwhich
/usr/bin/muttbug
</pre>

</body>
</section>
<section>
<title>Procesamiento de los archivos encontrados</title>
<body>

<p>
¡Tal vez se esté preguntando qué puede hacer con todos los archivos
que ha encontrado! Bueno, <c>find</c> tiene la habilidad de actuar
sobre los archivos que encuentra usando la opción <c>-exec</c>. Esta
opción acepta una línea de comandos para ejecutarse como su
argumento, terminado con ;, y reemplaza cualquier ocurrencia de {}
con el nombre del archivo. Esto se entiende mejor con un ejemplo:
</p>

<pre caption="Uso de -exec">
$ <i>find /usr/bin -type f -size -50c -exec ls -l '{}' ';'</i>
-rwxr-xr-x    1 root     root    27 Oct 28 07:13    /usr/bin/krdb
-rwxr-xr-x    1 root     root    35 Nov 28 18:26    /usr/bin/run-nautilus
-rwxr-xr-x    1 root     root    25 Oct 21 17:51    /usr/bin/sgmlwhich
-rwxr-xr-x    1 root     root    26 Sep 26 08:00    /usr/bin/muttbug
</pre>

<p>
Como puede ver, <c>find</c> es una orden muy poderosa. Ha crecido a
través de los años de UNIX y el desarrollo de Linux. Hay muchas más
opciones útiles para realizar búsquedas. Puede aprender más acerca de
ellas en la página del manual find.
</p>

</body>
</section>
<section>
<title>locate</title>
<body>

<p>
Hemos cubierto <c>which</c>, <c>whereis</c>, y <c>find</c>. Tal vez
haya notado que <c>find</c> puede tomar un tiempo en ejecutarse, ya
que necesita leer cada directorio que está buscando. Resulta entonces
que la orden <c>locate</c> puede acelerar las cosas apoyándose en una
base de datos externa generada por <c>updatedb</c> (la cual trataremos
en el siguiente panel).
</p>

<p>
La orden <c>locate</c> puede encontrar una coincidencia con cualquier
parte del nombre de la ruta, no solo con el nombre del archivo. Por
ejemplo:
</p>

<pre caption="locate en acción">
$ <i>locate bin/ls</i>
/var/ftp/bin/ls
/bin/ls
/sbin/lsmod
/sbin/lspci
/usr/bin/lsattr
/usr/bin/lspgpot
/usr/sbin/lsof
</pre>

</body>
</section>
<section>
<title>Uso de updatedb</title>
<body>

<p>
La mayoría de los sistemas Linux tiene un "trabajo programado" para
actualizar la base de datos periódicamente. Si su <c>locate</c>
devuelve un error como el siguiente, entonces debe ejecutar como
usuario root <c>updatedb</c> para generar la base de datos de búsqueda:
</p>

<pre caption="Actualizando su base de datos locate">
$ <i>locate bin/ls</i>
locate: /var/spool/locate/locatedb: No such file or directory
$ <i>su -</i>
Password:
# <i>updatedb</i>
</pre>

<p>
La orden <c>updatedb</c> puede tomar mucho tiempo en ejecutarse. Si
tiene un disco duro ruidoso, escuchará una gran cantidad de ruidos
mientras que el sistema de archivos entero es indexado. :)
</p>


</body>
</section>
<section>
<title>mlocate</title>
<body>

<p>
En muchas distribuciones Linux, la orden <c>locate</c> ha sido
reemplazada por <c>mlocate</c>. Normalmente existe un enlace
simbólico a <c>locate</c>, de modo que no es necesario recordar cual
tiene. <c>mlocate</c> viene de "localización segura". Almacena
información de permisos en la base de datos de manera que los
usuarios normales no pueden inmiscuirse en directorios que, de algún
otro modo, serían incapaces de leer. El uso de la información para
<c>mlocate</c> es esencialmente la misma que para <c>locate</c>,
aunque la salida puede ser diferente dependiendo del usuario que
ejecuta los comandos.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Control de procesos</title>
<section>
<title>Iniciando xeyes</title>
<body>

<p>
Para aprender acerca de control de procesos, primero tenemos que
iniciar un proceso. Asegúrese que está utilizando X y ejecute la
siguiente orden:
</p>

<pre caption="Iniciando un proceso">
$ <i>xeyes -center red</i>
</pre>

<p>
Habrá notado que una ventana xeyes apareció, y que los globos
oculares rojos siguen su ratón por la pantalla. Además habrá notado
que no tiene un nuevo prompt en su terminal.
</p>

</body>
</section>
<section>
<title>Deteniendo un proceso</title>
<body>

<p>
Para tener de nuevo el prompt, puede teclear Control-C (a menudo
escrito como Crtl-C o ^C):
</p>

<p>
De nuevo tiene un prompt bash, pero la ventana xeyes desapareció. De
hecho el proceso entero fue terminado. En lugar de terminarlo con
Control-C, podemos solamente detenerlo con Control-Z:
</p>

<pre caption="Deteniendo un proceso">
$ <i>xeyes -center red</i>
<i>Control-Z</i>
[1]+  Stopped                 xeyes -center red
$
</pre>

<p>
En este momento tiene un nuevo prompt bash, y la ventana xeyes se
mantiene arriba. Sin embargo, si juega un poco con ella, notará que
los globos oculares están estáticos. Si la ventana xeyes es cubierta
por otra ventana y después descubierta de nuevo, notará que ni
siquiera se han redibujado lo ojos. El proceso no está haciendo nada.
De hecho, está "Detenido".
</p>

</body>
</section>
<section>
<title>fg y bg</title>
<body>

<p>
Para tener el proceso "no-detenido" y ejecutándose nuevamente,
podemos traerlo al primer plano con el bash incorporado <c>fg</c>:
</p>

<pre caption="Usando fg">
$ <i>fg</i>
<comment>(pruébelo, luego detenga el proceso de nuevo)</comment>
<i>Control-Z</i>
[1]+  Stopped                 xeyes -center red
$
</pre>

<p>
Ahora continúelo en el segundo plano con el bash incorporado <c>bg</c>:
</p>

<pre caption="Usando bg">
$ <i>bg</i>
[1]+ xeyes -center red &amp;
$
</pre>

<p>
¡Muy bien! El proceso xeyes está ahora ejecutándose en el segundo
plano, y tenemos de nuevo, un prompt bash trabajando.
</p>

</body>
</section>
<section>
<title>Uso de "&amp;"</title>
<body>

<p>
Si deseamos iniciar xeyes en segundo plano dese el inicio (en lugar
de usar Control-Z y bg), podemos agregar un "&amp;" (signo &amp;) al
final de xeyes en la línea de comando:
</p>

<pre caption="Usando &amp; para ejecutar procesos en segundo plano ">
$ <i>xeyes -center blue &amp;</i>
[2] 16224
</pre>

</body>
</section>
<section>
<title>Múltiples procesos en segundo plano</title>
<body>

<p>
Ahora tenemos xeyes rojos y azules ambos ejecutándose en segundo
plano. Podemos listar estos trabajos con el bash incorporado
<c>jobs</c>:
</p>

<pre caption="Uso de jobs">
$ <i>jobs -l</i>
[1]- 16217 Running                 xeyes -center red &amp;
[2]+ 16224 Running                 xeyes -center blue &amp;
</pre>

<p>
Los números en la columna izquierda son los números asignados por
bash cuando fueron iniciados. El trabajo 2 tiene un + (más) para
indicar que este es el "trabajo actual", lo cual significa que
escribiendo <c>fg</c> lo traeremos al primer plano. Puede también
traer a primer plano un trabajo especificando su número; por ejemplo
<c>fg</c> hará a xeyes rojos la tarea de primer plano. La siguiente
columna es el identificador de proceso o pid, incluido en la lista
cortesía de la opción -l de jobs. Finalmente, ambos trabajos estan
actualmente "ejecutándose", y sus líneas de comando son mencionadas a
la derecha.
</p>

</body>
</section>
<section>
<title>Introducción a señales</title>
<body>

<p>
Para terminar, detener o continuar procesos, Linux usa una forma
especial de comunicación llamada "señales". Enviando cierto tipo de
señal a un proceso, puede terminarlo, detenerlo, o hacer otras cosas.
Esto es lo que en realidad hace cuando escribe Control-C, Control-Z o
utiliza los incorporados <c>bg</c> o <c>fg</c> -- está usando bash
para enviar una señal en particular a el proceso. Estas señales
pueden ser enviadas también usando la orden <c>kill</c> y
especificando el pid (identificador de proceso) en la línea de comandos:
</p>

<pre caption="Uso de kill">
$ <i>kill -s SIGSTOP 16224</i>
$ <i>jobs -l</i>
[1]- 16217 Running                 xeyes -center red &amp;
[2]+ 16224 Stopped (signal)        xeyes -center blue
</pre>

<p>
Como puede ver, kill no necesariamente "mata" un proceso, aunque
puede. Usando la opción "-s", <c>kill</c> puede enviar cualquier
señal a un proceso. Linux termina, detiene o continúa procesos cuando
son enviadas las señales SIGINT, SIGSTOP, o SIGCONT respectivamente.
También existen otras señales que puede enviar a un proceso; algunas
de estas señales pueden ser interpretadas de un modo dependiente de
la aplicación. Puede aprender que señales reconoce un proceso en
particular mirando la página del manual y buscando la sección SIGNALS.
</p>

</body>
</section>
<section>
<title>SIGTERM y SIGINT</title>
<body>

<p>
Si desea terminar un proceso, tiene muchas opciones. De manera
predeterminada, kill envía SIGTERM, que no es idéntico al famoso
SIGINT de Control-C, pero usualmente tiene los mismos resultados:
</p>

<pre caption="Usando kill para terminar un proceso">
$ <i>kill 16217</i>
$ <i>jobs -l</i>
[1]- 16217 Terminated              xeyes -center red
[2]+ 16224 Stopped (signal)        xeyes -center blue
</pre>

</body>
</section>
<section>
<title>El gran kill</title>
<body>

<p>
Los procesos pueden ignorar tanto SIGTERM como SIGINT, ya sea por
elección o porque están detenidos o de alguna manera "atascados". En
estos casos puede ser necesario utilizar artillería pesada, la señal
SIGKILL. Un proceso no puede ignorar SIGKILL:
</p>

<pre caption="Usando kill para destruir un proceso">
$ <i>kill 16224</i>
$ <i>jobs -l</i>
[2]+ 16224 Stopped (signal)        xeyes -center blue
$ <i>kill -s SIGKILL</i>
$ <i>jobs -l</i>
[2]+ 16224 Interrupt               xeyes -center blue
</pre>

</body>
</section>
<section>
<title>nohup</title>
<body>

<p>
La terminal donde inicia un trabajo es llamada la terminal
controladora del trabajo. Algunas interfaces de comandos (no bash por
omisión), enviarán una señal SIGHUP para enviar a segundo plano
trabajos cuando cierre sesión, ocasionando que terminen. Para
proteger procesos de este comportamiento, use nohup cuando inicie un
proceso:
</p>

<pre caption="nohup en acción">
$ <i>nohup make &amp;</i>
[1] 15632
$ <i>exit</i>
</pre>

</body>
</section>
<section>
<title>Uso de ps para listar procesos</title>
<body>

<p>
La orden <c>jobs</c> que usamos anteriormente solo lista los procesos
que fueron iniciados desde su sesión de bash. Para ver todos los
procesos de su sistema, use <c>ps</c> con las opciones <c>a</c> y <c>x</c>
juntas:
</p>

<pre caption="ps con ax">
$ <i>ps ax</i>
  PID TTY      STAT   TIME COMMAND
    1 ?        S      0:04 init [3]
    2 ?        SW     0:11 [keventd]
    3 ?        SWN    0:13 [ksoftirqd_CPU0]
    4 ?        SW     2:33 [kswapd]
    5 ?        SW     0:00 [bdflush]
</pre>

<p>
Solo fueron listados los primeros porque usualmente es una lista muy
larga. Esto le da una idea rápida de que está haciendo la máquina,
pero es mucha información para filtrar. Si deja fuera a <c>ax</c>,
solo verá los procesos que le pertenecen, y que tienen su control en
una terminal. La orden <c>ps x</c> le mostrará todos los procesos, incluso
aquellos que no son controlados por una terminal. Si usa <c>ps a</c>,
obtendrá una lista de todos los procesos que están unidos a una terminal.
</p>

</body>
</section>
<section>
<title>Mirando el bosque y los árboles</title>
<body>

<p>
Puede además listar información diferente acerca de cada proceso. La
opción <c>--forest</c> hace más fácil ver la jerarquía del proceso,
la cual le da una indicación de como se interrelacionan los diversos
procesos en su sistema. Cuando un proceso inicia un nuevo proceso, el
nuevo proceso es llamado proceso "hijo". En un listado de <c>--forest
</c>, los padres aparecen en la izquierda y los hijos aparecen como
ramas del lado derecho:
</p>

<pre caption="Usando forest">
$ <i>ps x --forest</i>
  PID TTY      STAT   TIME COMMAND
  927 pts/1    S      0:00 bash
 6690 pts/1    S      0:00  \_ bash
26909 pts/1    R      0:00      \_ ps x --forest
19930 pts/4    S      0:01 bash
25740 pts/4    S      0:04  \_ vi processes.txt
</pre>

</body>
</section>
<section>
<title>Las opciones "u" y "l" de ps</title>
<body>

<p>
Las opciones <c>u</c> y <c>l</c> pueden ser agregadas a la
combinación de <c>a</c> y <c>x</c> con el objetivo de incluir más
información acerca de cada proceso:
</p>

<pre caption="Opción au">
$ <i>ps au</i>
USER       PID %CPU %MEM   VSZ  RSS TTY   STAT START  TIME  COMMAND
agriffis   403  0.0  0.0  2484   72 tty1  S     2001  0:00  -bash
chouser    404  0.0  0.0  2508   92 tty2  S     2001  0:00  -bash
root       408  0.0  0.0  1308  248 tty6  S     2001  0:00  /sbin/agetty 3
agriffis   434  0.0  0.0  1008    4 tty1  S     2001  0:00  /bin/sh/usr/X
chouser    927  0.0  0.0  2540   96 pts/1 S     2001  0:00  bash
</pre>

<pre caption="Opción al">
$ <i>ps al</i>
  F   UID  PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY    TIME  COMMAND
100  1001  403     1   9   0  2484   72 wait4  S    tty1   0:00  -bash
100  1000  404     1   9   0  2508   92 wait4  S    tty2   0:00  -bash
000     0  408     1   9   0  1308  248 read_c S    tty6   0:00   /sbin/ag
000  1001  434   403   9   0  1008    4 wait4  S    tty1   0:00   /bin/sh
000  1000  927   652   9   0  2540   96 wait4  S    pts/1  0:00   bash
</pre>

</body>
</section>
<section>
<title>Usando top</title>
<body>

<p>
Si se encuentra ejecutando ps varias veces en fila, intentando ver
cambios, lo que probablemente quiera es <c>top</c>. <c>top</c>
despliega continuamente una lista actualizada de procesos, junto con
un resumen de información útil:
</p>

<pre caption="top">
$ <i>top</i>
 10:02pm  up 19 days,  6:24,  8 users,  load average: 0.04, 0.05, 0.00
75 processes: 74 sleeping, 1 running, 0 zombie, 0 stopped
CPU states:  1.3% user,  2.5% system,  0.0% nice, 96.0% idle
Mem:   256020K av,  226580K used,  29440K free, 0K shrd,  3804K buff
Swap:  136544K av,   80256K used,  56288K free            101760K
cached

  PID USER    PRI NI  SIZE  RSS SHARE STAT LIB %CPU %MEM  TIME  COMMAND
  628 root     16  0  213M  31M  2304 S      0  1.9 12.5  91:43 X
26934 chouser  17  0  1272 1272  1076 R      0  1.1  0.4   0:00 top
  652 chouser  11  0 12016 8840  1604 S      0  0.5  3.4   3:52 gnome-termin
  641 chouser   9  0  2936 2808  1416 S      0  0.1  1.0   2:13 sawfish
</pre>

</body>
</section>
<section>
<title>nice</title>
<body>

<p>
Cada proceso tiene una definición de prioridades que Linux utiliza
para determinar cómo son compartidas las porciones de tiempo del CPU.
Puede fijar la prioridad de un proceso iniciándolo con la orden <c>nice</c>:
</p>

<pre caption="Un proceso con nice">
$ <i>nice -n 10 oggenc /tmp/song.wav</i>
</pre>

<p>
Dado que la definición de prioridad es llamada <c>nice</c>, debe ser
sencillo recordar que un valor mayor será mejor que otros procesos,
lo que les permite tener prioridad para acceder al CPU. De forma
predeterminada, los procesos inician con un valor de 0, por lo que el
darles un valor de 10 significa que oggenc le dará facilidad a otros
procesos en el CPU. En general, esto significa que oggenc le
permitirá a otros procesos funcionar a su velocidad normal,
independientemente de cómo sea el hambre de CPU de oggenc. Puede ver
los niveles mejorados en la columna NI en el ps y top listados arriba.
</p>

</body>
</section>
<section>
<title>renice</title>
<body>

<p>
La orden <c>nice</c> solo puede cambiar la prioridad de un proceso
cuando este se inicia. Si desea cambiar la definición de prioridad de
un proceso que está en ejecución, use <c>renice</c>:
</p>

<pre caption="Usando renice">
$ <i>ps l 641</i>
  F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY   TIME COMMAND
000  1000   641     1   9   0  5876 2808 do_sel S    ?     2:14 sawfish
$ <i>renice 10 641</i>
641: old priority 0, new priority 10
$ <i>ps l 641</i>
  F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY   TIME COMMAND
000  1000   641     1   9  10  5876 2808 do_sel S    ?     2:14 sawfish
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Procesamiento de texto</title>
<section>
<title>Redirección revisada</title>
<body>

<p>
Anteriormente en esta serie de tutoriales, vimos un ejemplo de cómo
usar el operador <c>></c> para redireccionar la salida de una orden a
un archivo, como se muestra a continuación:
</p>

<pre caption="Uso del operador >">
$ <i>echo "primerarchivo" > copiame</i>
</pre>

<p>
Además de redirigir una salida a un archivo, podemos tomar ventaja de
una poderosa característica de la interfaz de comandos llamada
tuberías. Con el uso de tuberías podemos pasar la salida de una orden
a la entrada de otra orden. Considere el siguiente ejemplo:
</p>

<pre caption="Introducción a tuberías">
$ <i>echo "hola" | wc</i>
     1       2       9
</pre>

<p>
El carácter <c>|</c> es usado para conectar la salida de la orden de
la izquierda a la entrada de la orden de la derecha. En el ejemplo
de arriba, la orden <c>echo</c> imprime la cadena "hola" seguido de
un salto de línea. Esta salida normalmente aparecería en la terminal,
pero el tubo lo redirecciona a la orden <c>wc</c>, la cual despliega
el número de líneas, palabras y caracteres de su entrada.
</p>

</body>
</section>
<section>
<title>Un ejemplo de tubería</title>
<body>

<p>
Aquí está otro ejemplo simple:
</p>

<pre caption="tuberías en acción">
$ <i>ls -s | sort -n</i>
</pre>

<p>
En este caso, <c>ls -s</c> normalmente imprimiría una lista del
directorio actual en la terminal, con cada archivo precedido por su
tamaño. Pero en su lugar enviamos por la tubería la salida a <c>sort -n</c>,
el cual ordena la salida numéricamente. ¡Esto es una manera
realmente útil de encontrar archivos grandes en su directorio home!
</p>

<p>
Los siguientes ejemplos son más complejos, pero demuestran el poder
que puede ser aprovechado usando tuberías. Vamos a utilizar algunas
órdenes que no hemos cubierto aun, pero no deje que eso lo haga más
lento. Concéntrese en entender cómo funcionan las tuberías, así podrá
emplearlas en sus tareas Linux cotidianas.
</p>

</body>
</section>
<section>
<title>La tubería de descompresión</title>
<body>

<p>
Normalmente para descomprimir y desempaquetar un archivo, puede hacer
los siguiente:
</p>

<pre caption="Desempaquetando un archivo">
$ <i>bzip2 -d linux-2.4.16.tar.bz2</i>
$ <i>tar xvf linux-2.4.16.tar</i>
</pre>

<p>
La desventaja de este método es que requiere de la creación de un
archivo intermediario y descomprimido en su disco. Dado que <c>tar</c>
tiene la habilidad de leer directamente desde su entrada (en lugar
de especificar un archivo), podemos producir el mismo resultado
usando una tubería:
</p>

<pre caption="Desempaquetar usando una tubería">
$ <i>bzip2 -dc linux-2.4.16.tar.bz2 | tar xvf -</i>
</pre>

<p>
¡Hurra! Nuestro archivo tar comprimido se ha extraído y no hemos
necesitado de un archivo intermedio.
</p>

</body>
</section>
<section>
<title>Una tubería más larga</title>
<body>

<p>
Aquí está otro ejemplo de tubería:
</p>

<pre caption="Tuberías más largas">
$ <i>cat miarchivo.txt | sort | uniq | wc -l</i>
</pre>

<p>
Usamos <c>cat</c> para enviar el contenido de <path>miarchivo.txt</path>
a la orden <c>sort</c>. Cuando la orden <c>sort</c> recibe la
entrada, ordena todas las líneas para que estén en orden alfabético,
y envía la salida a <c>uniq</c>. <c>uniq</c> elimina cualquier línea
duplicada (por cierto, requiere que la entrada esté ordenada)
enviando la salida que ya ha sido borrada a <c>wc -l</c>. Hemos visto
la orden <c>wc</c> anteriormente, pero sin las opciones de la línea
de comando. Cuando se da la opción <c>-l</c>, solamente imprime el
número de líneas en su entrada, en lugar de incluir también palabras
y caracteres. Como puede ver esta tubería imprime el número líneas
únicas (no idénticas) en un archivo de texto.
</p>

<p>
Trate de crear un par de archivos de prueba con su editor de texto
favorito y utilice esta tubería para ver qué resultados obtiene.
</p>

</body>
</section>
<section>
<title>El curso exprés de procesamiento de texto comienza</title>
<body>

<p>
Ahora nos embarcamos en un viaje relámpago a las órdenes estándar
Linux de procesamiento de texto. Debido a que estamos cubriendo mucho
material en este tutorial, no tenemos el espacio para dar ejemplos de
cada orden. En cambio, lo animamos para que lea cada página del
manual de las ordenes (escribiendo <c>man echo</c>, por ejemplo) y
aprenda cada orden y como trabajan sus opciones jugando un rato con
cada una. Como regla, estas órdenes imprimen los resultados de
cualquier procesamiento a una terminal en vez de modificar algún
archivo. Después de haber tomado nuestro un viaje relámpago a las
órdenes estándar Linux de procesamiento de texto, veremos más de
cerca la redirección de la salida y entrada. Así que sí, hay una luz
al final del túnel :).
</p>

<p>
<c>echo</c> imprime sus argumentos a la terminal. Use la opción <c>-e</c>
si quiere integrar secuencias de escape con la barra invertida;
por ejemplo <c>echo -e "foo\nfoo"</c> imprimirá foo, luego un salto
de línea y después foo otra vez. Use la opción <c>-n</c> para decirle
a echo que omita el salto de línea final que es anexado a la salida
por defecto.
</p>

<p>
<c>cat</c> imprimirá en la terminal el contenido de los archivos
especificados como argumentos. Es útil como primer comando de una
tubería, por ejemplo, <c>cat foo.txt | bla</c>.
</p>

<p>
<c>sort</c> imprimirá el contenido de un archivo especificado en la
línea de comandos en orden alfabético. Por supuesto, <c>sort</c>
también acepta entradas desde una tubería. Escriba <c>man sort</c>
para familiarizarse con las diversas opciones que controlan la
conducta del ordenamiento.
</p>

<p>
<c>uniq</c> toma un archivo <e>ya ordenado</e> o una secuencia de
datos (a través de una tubería) y elimina las líneas duplicadas.
</p>

<p>
<c>wc</c> imprime el número de líneas, palabras y bytes en un archivo
determinado o en la secuencia de entrada (de una tubería). Escriba
<c>man wc</c> para aprender como ajustar los resultados que son
desplegados.
</p>

<p>
<c>head</c> imprime las primeras diez líneas de un archivo o una
secuencia. Use la opción <c>-n</c> para especificar cuantas líneas se
desea mostrar.
</p>

<p>
<c>tail</c> imprime las últimas diez líneas de un archivo o
secuencia. Use la opción <c>-n</c> para especificar cuantas líneas se
desea mostrar.
</p>

<p>
<c>tac</c> es como <c>cat</c>, pero imprime todas las líneas en orden
inverso; en otras palabras, la última línea se imprime primero.
</p>

<p>
<c>expand</c> convierte las tabulaciones en espacios. Use la opción
<c>-t</c> para especificar la posición del tabulador.
</p>

<p>
<c>unexpand</c> convierte los espacios de entrada en tabulaciones.
Use la opción <c>-t</c> para especificar la posición del tabulador.
</p>

<p>
<c>cut</c> es usado para extraer campos delimitados por caracteres de
cada línea de un archivo de entrada o secuencia.
</p>

<p>
La orden <c>nl</c> agrega una número a cada línea de entrada. Útil
para impresiones.
</p>

<p>
<c>pr</c> es usado para romper archivos en varias páginas de salida;
normalmente es usado para impresión.
</p>

<p>
<c>tr</c> es una herramienta de traducción de caracteres; es usada
para asignar a ciertos caracteres de la secuencia de entrada otros
caracteres en la secuencia de salida.
</p>

<p>
<c>sed</c> es un poderoso editor de texto orientado a secuencias.
Puede aprender más acerca de sed en los siguientes artículos de IBM
developerWorks:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/l-sed1.xml">Sed mediante ejemplos,
    Parte 1</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/l-sed2.xml">Sed mediante ejemplos,
    Parte 2</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/l-sed3.xml">Sed mediante ejemplos,
    Parte 3</uri>
  </li>
</ul>

<p>
Si está planeando tomar el examen LPI, asegúrese de leer los primeros
dos artículos de esta serie.
</p>

<p>
<c>awk</c> es un lenguaje práctico de procesamiento de texto. Para
aprender más acerca de awk, lea los siguientes artículos de IBM
developerWorks:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/l-awk1.xml">Awk mediante ejemplos,
    Parte 1</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/l-awk2.xml">Awk mediante ejemplos,
    Parte 2</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/l-awk3.xml">Awk mediante ejemplos,
    Parte 3</uri>
  </li>
</ul>

<p>
<c>od</c> está diseñado para transformar una secuencia de entrada en
un formato octal o hexadecimal "volcado".
</p>

<p>
<c>split</c> es una orden utilizada para dividir un archivo grande en
pedazos más pequeños y más manejables.
</p>

<p>
<c>fmt</c> dará formato a párrafos para que estos se ajusten al
margen. Hoy en día es menos útil, ya que esta habilidad la poseen la
mayoría de los editores de texto, pero aún así es bueno saber.
</p>

<p>
<c>paste</c> toma dos o más archivos como entrada, concatena cada
línea secuencial de los archivos de entrada, e imprime las líneas
resultantes. Puede ser útil para crear tablas o columnas de texto.
</p>

<p>
<c>join</c> es similar a paste, pero utiliza un campo (el primero de modo
predeterminado) en cada línea para que coincida lo que debe combinarse
en una sola línea.
</p>

<p>
<c>tee</c> imprime su entrada tanto en un archivo como en la
pantalla. Esto es útil cuando quiera crear un registro de algo, pero
además quiere verlo en pantalla.
</p>

</body>
</section>
<section>
<title>¡El curso exprés termina!. Redirección</title>
<body>

<p>
Similar a usar <c>&gt;</c> en la línea de comando de bash, puede usar
para redireccionar un archivo a una orden. Para muchas órdenes, puede
simplemente especificar el nombre de archivo en la línea de comando,
sin embargo algunas órdenes solo funcionan desde la entrada estándar.
</p>

<p>
Bash y otros intérpretes de comando respaldan el concepto de un
"archivoaquí". Esto le permite especificar la entrada de una orden en
las líneas siguientes a la invocación de la orden, terminándola con
un valor especial. Es más fácil mediante un ejemplo:
</p>

<pre caption="Redirección en acción">
$ <i>sort &lt;&lt;END</i>
manzana
arándano
plátano
END
arándano
manzana
plátano
</pre>

<p>
En el ejemplo de arriba, escribimos las palabras manzana, arándano y
plátano seguidos por "END" lo que significa el fin de la entrada. El
programa <c>sort</c> regresa nuestras palabras ordenadas
alfabéticamente.
</p>

</body>
</section>
<section>
<title>Uso de &gt;&gt;</title>
<body>

<p>
Tal vez esperaría que <c>&gt;&gt;</c> fuera de alguna manera análogo
a <c>&lt;&lt;</c>, pero en realidad no lo es. Significa simplemente
agregar la salida a un archivo, en lugar de sobreescribir como <c>&gt;
</c> lo haría. Por ejemplo:
</p>

<pre caption="Redireccionando a un archivo">
$ <i>echo Hola &gt; miarchivo</i>
$ <i>echo allá. &gt; miarchivo</i>
$ <i>cat miarchivo</i>
allá.
</pre>

<p>
¡Uy! ¡Perdimos la porción "Hola"! Lo que queríamos decir era esto:
</p>

<pre caption="Anexar a un archivo">
$ <i>echo Hola &gt; miarchivo</i>
$ <i>echo allá. &gt;&gt; miarchivo</i>
$ <i>cat miarchivo</i>
Hola
allá.
</pre>

<p>
¡Mucho mejor!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Módulos del núcleo</title>
<section>
<title>Conozca "uname"</title>
<body>

<p>
La orden <c>uname</c> le provee una variedad de información
interesante acerca de su sistema. Aquí está lo que se despliega en mi
estación de desarrollo cuando tecleo <c>uname -a</c> el cual le dice
a la orden <c>uname</c> que imprima toda la información de una sola
vez:
</p>

<pre caption="uname -a">
$ <i>uname -a</i>
Linux inventor 2.4.20-gaming-r1 #1 Fri Apr 11 18:33:35 MDT 2003 i686
AMD Athlon(tm) XP 2100+ AuthenticAMD GNU/Linux
</pre>

</body>
</section>
<section>
<title>Más locura uname</title>
<body>

<p>
Ahora, veamos la información que provee <c>uname</c>:
</p>

<pre caption="Información de uname">
info. opción                   arg     ejemplo
nombre de núcleo               -s      "Linux"
nombre del anfitrión           -n      "inventor"
revisión del núcleo            -r      "2.4.20-gaming-r1"
versión de núcleo              -v      "#1 Fri Apr 11 18:33:35 MDT 2003"
máquina                        -m      "i686"
procesador                     -p      "AMD Athlon(tm) XP 2100+"
plataforma de hardware         -i      "AuthenticAMD"
sistema operativo              -o      "GNU/Linux"
</pre>

<p>
¡Intrigante! ¿Qué imprime la salida de su orden <c>uname -a</c>?
</p>

</body>
</section>
<section>
<title>La revisión del núcleo</title>
<body>

<p>
He aquí un truco de magia. Primero, escriba <c>uname -r</c> para que
la orden uname imprima la revisión del núcleo Linux que se está
ejecutando actualmente.
</p>

<p>
Ahora, mire en el directorio <path>/lib/modules</path> y, ¡presto!
¡Apuesto que encontrará un directorio con el mismo nombre! Está bien,
no es tan mágico, pero ahora es un buen momento para hablar del
significado de los directorios en <path>/lib/modules</path> y
explicar que son los módulos.
</p>

</body>
</section>
<section>
<title>El núcleo</title>
<body>

<p>
El núcleo Linux es el corazón de lo que comúnmente llamamos "Linux"
-- es la pieza de código que accede a su hardware directamente y
provee abstracciones para que los programas regulares antiguos puedan
ejecutarse. Gracias al núcleo, su editor de texto no necesita
preocuparse acerca de si está escribiendo en un disco SCSI o IDE -- o
incluso en un disco RAM. Simplemente escribe a un archivo de sistema,
y el núcleo se encarga del resto.
</p>

</body>
</section>
<section>
<title>Introducción a los módulos del núcleo</title>
<body>

<p>
Entonces, ¿qué son los módulos del núcleo? Bueno, son partes del
núcleo que han sido almacenadas en el disco con un formato especial.
A su orden, podrán ser cargados en el núcleo en ejecución y proveer
funcionalidades adicionales.
</p>

<p>
Debido a que los módulos del núcleo son cargados a demanda, puede
tener en su núcleo soporte para una gran cantidad de funciones
adicionales que normalmente no quiere tener habilitadas. Pero en
alguna rara ocasión, aquellos módulos del núcleo pueden sernos útiles
y pueden cargarse -- a menudo de manera automática -- para apoyar ese
raro sistema de archivos o dispositivo que raramente usa.
</p>

</body>
</section>
<section>
<title>Módulos del núcleo en pocas palabras</title>
<body>

<p>
En resumen, los módulos del núcleo le permiten al núcleo en ejecución
habilitar capacidades en base a la demanda. Sin los módulos del
núcleo, tendría que compilar un nuevo núcleo completo y reiniciar
para tener el apoyo de las nuevas características.
</p>

</body>
</section>
<section>
<title>lsmod</title>
<body>

<p>
Para ver cuales módulos están cargados actualmente en su sistema, use
la orden <c>lsmod</c>:
</p>

<pre caption="Uso de lsmod">
# <i>lsmod</i>
Module                  Size  Used by    Tainted: PF
vmnet                  20520   5
vmmon                  22484  11
nvidia               1547648  10
mousedev                3860   2
hid                    16772   0  (unused)
usbmouse                1848   0  (unused)
input                   3136   0  [mousedev hid usbmouse]
usb-ohci               15976   0  (unused)
ehci-hcd               13288   0  (unused)
emu10k1                64264   2
ac97_codec              9000   0  [emu10k1]
sound                  51508   0  [emu10k1]
usbcore                55168   1  [hid usbmouse usb-ohci ehci-hcd]
</pre>

</body>
</section>
<section>
<title>Listado de módulos</title>
<body>

<p>
Como puede ver, mi sistema tiene unos cuantos módulos cargados. Los
módulos vmnet y vmmon proveen la funcionalidad necesaria para mi
programa <uri link="http://www.vmware.com/">VMWare</uri>, el cual me
permite ejecutar una PC virtual en una ventana del escritorio. El
módulo de "nvidia" viene de la corporación
<uri link="http://www.nvidia.com/">NVIDIA</uri> la cual me permite
utilizar mi tarjeta de gráficos de gran desempeño con aceleración para 3D
bajo Linux al tiempo que toma ventaja de sus características.
</p>

<p>
Además tengo un montón de módulos usados para darle respaldo a mis
dispositivos de entrada basados en USB --llamados "mousedev", "hid",
"usbmouse", "input", "usb-ohci", "ehci-hcd" y "usbcore." Algunas
veces tiene sentido configurar su núcleo para darle soporte al USB en
forma de módulos. ¿Por qué? Porque los dispositivos USB son del tipo
"conecta y usa" y cuando tiene el respaldo USB como módulo, entonces
puede ir a comprar un nuevo dispositivo USB, conectarlo a su sistema,
y que el sistema cargue automáticamente los módulos apropiados para
habilitar ese dispositivo. Es práctico hacer las cosas de esta manera.
</p>

</body>
</section>
<section>
<title>Módulos de terceras partes</title>
<body>

<p>
Para completar mi lista de módulos están "emu10k1", "ac97_codec" y
"sound", que juntos proveen soporte para mi tarjeta de sonido
SoundBlaster Audigy.
</p>

<p>
Cabe señalar que algunos de mis módulos de núcleo provienen de las
fuentes del núcleo mismo. Por ejemplo, todos los módulos relacionados
al USB son compilados desde las fuentes del núcleo estándar de
Linux. Sin embargo, el nvidia, emul10k1 y los relacionados a VMWare,
provienen de otras fuentes. Esto resalta otra ventaja importante de
los módulos del núcleo -- permiten a terceras partes proveer
funcionalidades necesarias al núcleo y además permiten la
funcionalidad de "conectarse" a un núcleo Linux que se encuentra
ejecutándose. No es necesario reiniciar el sistema.
</p>

</body>
</section>
<section>
<title>depmod y amigos</title>
<body>

<p>
En el directorio <path>/lib/modules/2.4.20-gaming-r1/</path>, tengo
un número de archivos que inician con la cadena "modules.":
</p>

<pre caption="Otros módulos">
$ <i>ls /lib/modules/2.4.20-gaming-r1/modules.*</i>
/lib/modules/2.4.20-gaming-r1/modules.dep
/lib/modules/2.4.20-gaming-r1/modules.generic_string
/lib/modules/2.4.20-gaming-r1/modules.ieee1394map
/lib/modules/2.4.20-gaming-r1/modules.isapnpmap
/lib/modules/2.4.20-gaming-r1/modules.parportmap
/lib/modules/2.4.20-gaming-r1/modules.pcimap
/lib/modules/2.4.20-gaming-r1/modules.pnpbiosmap
/lib/modules/2.4.20-gaming-r1/modules.usbmap
</pre>

<p>
Estos archivos contienen algunas porciones de información de
dependencias. Por un lado, registran la información de *dependencia*
para módulos -- algunos módulos requieren que otros módulos sean
cargados antes de ejecutarse. Esta información es almacenada en estos
archivos.
</p>

</body>
</section>
<section>
<title>¿Cómo obtener módulos?</title>
<body>

<p>
Algunos módulos del núcleo están diseñados para trabajar con
dispositivos específicos de hardware, como mi módulo "emuk10k1", el
cual es para mi tarjeta SoundBlaster Audigy. Para ese tipo de módulos,
existen archivos que además graban los identificadores PCI y marcas
de identificación de los dispositivos de hardware que respaldan. Esta
información puede ser utilizada para actividades como los scripts
"conexión rápida" (de los cuales hablaremos en los siguientes
tutoriales) para autodetectar hardware y cargar los módulos
apropiados para respaldar dicho hardware de manera automática.
</p>

</body>
</section>
<section>
<title>Uso de depmod</title>
<body>

<p>
Si alguna vez ha instalado un módulo nuevo, la información de
dependencia puede estar obsoleta. Para actualizarla simplemente teclee
<c>depmod -a</c>. El programa <c>depmod</c> hará un análisis de todos
los módulos en los directorios <path>/lib/modules</path> y
actualizará la información de dependencias. Esto se logra analizando
los archivos de módulos en <path>/lib/modules</path> y revisando lo
que se le conoce como "símbolos" dentro de los módulos.
</p>

</body>
</section>
<section>
<title>Localizando módulos del núcleo</title>
<body>

<p>
Entonces, ¿qué apariencia tienen los módulos del núcleo?, Para los
núcleos 2.4, los módulos son generalmente cualquier archivo del árbol
<path>/lib/modules</path> que termine en ".o". Para ver todos los
módulos en <path>/lib/modules</path>, escriba lo siguiente:
</p>

<pre caption="Módulos del núcleo en /lib/modules">
# <i>find /lib/modules -name '*.o'</i>
/lib/modules/2.4.20-gaming-r1/misc/vmmon.o
/lib/modules/2.4.20-gaming-r1/misc/vmnet.o
/lib/modules/2.4.20-gaming-r1/video/nvidia.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/vfat/vfat.o
/lib/modules/2.4.20-gaming-r1/kernel/fs/minix/minix.o
[lista truncada para hacerla más breve]
</pre>

</body>
</section>
<section>
<title>insmod vs. modprobe</title>
<body>

<p>
Bien, ¿cómo se realiza la carga de un módulo en un núcleo en
ejecución? Un modo es utilizar la orden <c>insmod</c> para
especificar la ruta completa a el módulo que se desea cargar:
</p>

<pre caption="Uso de insmod">
# <i>insmod /lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o</i>
# <i>lsmod | grep fat</i>
fat                    29272   0  (unused)
</pre>

<p>
Sin embargo, normalmente las cargas de módulos se realizan usando la
orden <c>modprobe</c>. Una de las cosas buenas acerca de la orden
<c>modprobe</c> es que automáticamente se encarga de cargar módulos
dependientes. Además, no es necesario especificar la ruta al módulo
que desee cargar, ni especificar al final el ".o".
</p>

</body>
</section>
<section>
<title>rmmod y modprobe en acción</title>
<body>

<p>
Descarguemos nuestro módulo "fat.o" y carguémoslo de nuevo usando
<c>modprobe</c>:
</p>

<pre caption="rmmod y modprobe en acción">
# <i>rmmod fat</i>
# <i>lsmod | grep fat</i>
# <i>modprobe fat</i>
# <i>lsmod | grep fat</i>
fat                    29272   0  (unused)
</pre>

<p>
Como puede ver, la orden <c>rmmod</c> trabaja de manera similar a
modprobe, pero tiene el efecto contrario: desactivar el módulo que
le ha especificado.
</p>

</body>
</section>
<section>
<title>Sus amigos modinfo y modules.conf</title>
<body>

<p>
Puede utilizar la orden <c>modinfo</c> para aprender cosas
interesantes acerca de sus módulos favoritos:
</p>

<pre caption="Uso de modinfo">
# <i>modinfo fat</i>
filename:    /lib/modules/2.4.20-gaming-r1/kernel/fs/fat/fat.o
description: &lt;none&gt;
author:      &lt;none&gt;
license:     "GPL"
</pre>

<p>
Tome nota especial del archivo <path>/etc/modules.conf</path>. Este
archivo contiene información de configuración para <c>modprobe</c>.
Le permite ajustar la funcionalidad de <c>modprobe</c> mencionando
cuales módulos debe ser cargados antes/después de cargar otros,
ejecutar scripts antes/después de cargar módulos y más.
</p>

</body>
</section>
<section>
<title>Aspectos relevantes de modules.conf</title>
<body>

<p>
La sintaxis y funcionalidad de <path>modules.conf</path> es un poco
complicada y no veremos su sintaxis ahora (teclee <c>man modules.conf</c>
para ver todos los detalles), pero aquí están algunas cosas que
*debería* saber acerca de este archivo.
</p>

<p>
Muchas distribuciones generan este archivo de manera automática a
partir de un grupo de archivos en otro directorio, como
<path>/etc/modules.d/</path>. Por ejemplo, Gentoo Linux tiene un directorio
<path>/etc/modules.d/</path>, y al ejecutar la orden <c>update-modules</c>
tomará cada archivo en <path>/etc/modules.d/</path> y los
concatenará para producir un nuevo <path>/etc/modules.conf/</path>.
Por lo tanto, haga sus cambios a los archivos en
<path>/etc/modules.d/</path> y ejecute update-modules si está usando
Gentoo. Si está usando Debian, el procedimiento es similar excepto que el
directorio es llamado <path>/etc/modutils/</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Resumen y bibliografía</title>
<section>
<title>Resumen</title>
<body>

<p>
¡Felicidades; ha alcanzado el final de este tutorial en administración
Linux básica! Esperamos que le haya ayudado a reafirmar sus
conocimientos fundamentales de Linux. Por favor, únase a nosotros en
el siguiente tutorial que cubre administración intermedia donde, partiendo
de los fundamentos vistos aquí, veremos temas como permisos de Linux y el
modelo de propiedad, manejo de cuentas de usuario, creación y montaje de
sistema de archivos y más. Y recuerde, continuando con esta serie de
tutoriales, pronto estará listo para obtener su certificación LPIC Nivel 1
del Instituto Profesional Linux.
</p>

</body>
</section>
<section>
<title>Bibliografía</title>
<body>

<p>
Hablando de certificación LPIC, si es algo en lo que está interesado,
entonces le recomendamos que estudie la siguiente bibliografía, la
cual ha sido seleccionada cuidadosamente para aumentar el material
cubierto en este tutorial:
</p>

<p>
Existe gran cantidad de buena bibliografía de expresiones regulares
en Internet. Aquí hay dos que hemos encontrado:
</p>

<ul>
  <li>
    <uri link="http://www.zvon.org/other/reReference/Output/">Regular
    Expressions Reference</uri>
  </li>
  <li>
    <uri link="http://zez.org/article/articleview/11/">Regular
    Expressions Explained</uri>
  </li>
</ul>

<p>
Asegúrese de leer el Estándar de la jerarquía del sistema de archivos
en <uri>http://www.pathname.com/fhs/</uri>.
</p>

<p>
En <uri link="/doc/es/articles/bash-by-example-p1.xml">Bash con
ejemplos, serie de artículos</uri>, le mostraré como usar
programación de bash para crear sus propios scripts. Esta serie
(particularmente parte uno y dos) le darán una buena preparación para
el examen nivel 1 del LPIC:
</p>

<p>
Puede aprender más acerca de <c>sed</c> en los <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-sed1.html?dwzone=linux">
relevent IBM developerWorks articles</uri>. Si está planeando
tomar el examen LPI, asegúrese de leer los dos primeros artículos de
esta serie.
</p>

<p>
Para aprender más acerca de <c>awk</c>, lea <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-awk1.html?dwzone=linux">
relevent IBM developerWorks articles</uri>.
</p>

<p>
Es altamente recomendable revisar <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/index.html">
Technical FAQ for Linux users</uri>, un listado de 50 páginas que
muestran la lista de preguntas más frecuentes de Linux con respuestas
detalladas. El FAQ es un archivo formato PDF (Acrobat). Si es un
usuario Linux principiante o intermedio, definitivamente debe revisar
este FAQ.
</p>

<p>
Si no está familiarizado con el editor <c>vi</c>, es altamente
recomendable que revise el tutorial
<uri link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">
Vi -- the cheat sheet method</uri>. Este tutorial le da una introducción
rápida a este poderoso editor de texto. Considérelo como un material
del tipo "debe leer" si no sabe cómo utilizar <c>vi</c>.
</p>

</body>
</section>
</chapter>
</guide>
