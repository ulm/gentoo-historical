<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/articles/lpi-101-advanced-p4.xml,v 1.1 2011/10/25 15:37:19 nimiux Exp $-->

<guide disclaimer="articles" lang="es">
<title>Preparación para el examen de certificación 101 del LPI (segundo
lanzamiento), Parte 4</title>

<author title="Autor">
<mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autor">
<mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Autor">
<mail link="agriffis@gentoo.org">Aron Griffis</mail>
</author>
<author title="Traductora">
<mail link="nilda_46@hotmail.com">Gabriela Villanueva</mail>
</author>

<abstract>
En este tutorial, haremos una introducción a todos los sistemas de
archivos populares en Linux. Le enseñaremos cómo montar y desmontar
dispositivos. En el siguiente capítulo aprenderá cómo arrancar el sistema
y cómo trabajar con los niveles de ejecución. En la siguiente sección de
este tutorial, introduciremos las cuotas del sistema de archivos, le
enseñaremos cómo definirlas y cómo configurarlas. Al final de este
tutorial conocerá los registros del sistema.
</abstract>


<!-- La versión original de este artículo fue publicada en IBM
developerWorks y es propiedad de Westtech Information Services. Este
documento es una versión actualizada del artículo original y contiene
mejoras introducidas por el Equipo de Documentación de Gentoo. -->

<version>1.0</version>
<date>2005-12-17</date>

<chapter>
<title>Antes de comenzar</title>
<section>
<title>Acerca de este tutorial</title>
<body>

<p>
Bienvenido a "Administración avanzada", el último de cuatro tutoriales
diseñado para prepararlo para el examen 101 del Instituto Profesional de
Linux (LPI por sus siglas en inglés). En este tutorial (parte 4),
reforzaremos sus conocimientos de administración avanzada Linux cubriendo
una gran variedad de temas incluyendo sistemas de archivos Linux, el
proceso de arranque de Linux, niveles de ejecución, cuotas del sistema de
archivos, y registros del sistema.
</p>

<p>
Este tutorial es particularmente apropiado para alguien que este actuando
por primera vez como administrador principal del sistema ya que cubrimos
una gran cantidad de problemas de bajo nivel que todo administrador de
sistemas debería conocer. Si es nuevo en Linux, recomendamos que comience
con la <uri link="/doc/es/articles/lpi-101-fundamentals-p1.xml">Parte 1</uri>
y trabaje con la serie a partir de ahí. Para algunos, este material será
nuevo, pero los usuarios Linux más experimentados encontrarán en este
tutorial una buena manera de complementar sus conocimientos básicos de
administración Linux y prepararse para el siguiente nivel de certificación
LPI.
</p>

<p>
Al final de esta serie de tutoriales (ocho en total, cubriendo los
exámenes LPI 101 y 102), tendrá el conocimiento necesario para ser un
administrador de sistemas Linux y estará listo para obtener una
certificación LPIC nivel 1 del Instituto de Profesionales Linux si así lo
desea.
</p>

<p>
Para aquellos que han tomado el <uri link=
"http://www-106.ibm.com/developerworks/edu/l-dw-linuxlpi4-i.html">release
1 version</uri> de este tutorial por razones diferentes a la preparación
para el examen LPI, probablemente no sea necesario tomar esta versión. Sin
embargo, si planea presentarse a los exámenes, debe considerar seriamente
leer este tutorial.
</p>

<p>
El logotipo LPI es una marca registrada del Instituto Profesional de Linux.
</p>

</body>
</section>
<section>
<title>Acerca de los autores</title>
<body>

<p>
Para preguntas técnicas acerca del contenido de este tutorial, puede
contactar con los autores:
</p>

<ul>
  <li>Daniel Robbins, en <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, en <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, en <mail>agriffis@gentoo.org</mail></li>
</ul>

<p>
Daniel Robbins vive en Albuquerque, Nuevo México, y es el Arquitecto jefe
de <uri link="http://www.gentoo.org/">Gentoo Technologies, Inc.</uri>, el
creador de Gentoo Linux, un Linux avanzado para PC, y el sistema Portage,
una nueva generación de sistemas de puertos (ports) para Linux. También ha
contribuido como autor de los libros Macmillan Caldera OpenLinux
Unleashed, SuSE Linux Unleashed, y Samba Unleashed. Daniel ha estado
involucrado con las computadoras de alguna manera desde el segundo grado,
cuando fue expuesto por primera vez al lenguaje de programación Logo, así
como a una dosis potencialmente peligrosa de Pac-Man. Posiblemente esto
explica porqué desde entonces ha servido como artista líder de gráficos en
SONY Electronic Publishing/Psygnosis. Daniel disfruta su tiempo libre con
su esposa, Mary, y su hija, Hadassha.
</p>

<p>
Chris Houser, conocido por sus amigos como "Chouser," ha sido partidario
de UNIX desde 1994 cuando se unió al equipo de administración
de la red de informática en la Universidad Taylor en Indiana, donde obtuvo
su licenciatura en Ciencias de la Computación y Matemáticas. Desde
entonces ha trabajado en programación de aplicaciones web, diseño de
interfaz de usuario, soporte para programas de vídeo profesional y ahora
programando el controlador del dispositivo Tru4 UNIX en <uri
link="http://www.compaq.com/">Compaq</uri>. Además ha contribuido en varios
proyectos de programas libres (recientemente en <uri
link="http://www.gentoo.org/">Gentoo Linux</uri>). Vive con su esposa y dos
gatos en New Hampshire.
</p>

<p>
Aron Griffis, graduado de la Universidad Taylor con título en Ciencias de
la Computación y premiado con el título "Futuro fundador de una comunidad
UNIX utópica". Trabajando para conseguir ese objetivo Aron es empleado de
<uri link="http://www.compaq.com/">Compaq</uri>, escribe controladores de
red para Tru64 UNIX y utiliza su tiempo libre tocando melodías en el piano
o desarrollando <uri link="http://www.gentoo.org/">Gentoo Linux</uri>.
Vive con su esposa Amy (también ingeniera UNIX) en Nashua, NH.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sistemas de archivos, particiones y dispositivos de bloques</title>
<section>
<title>Introducción a los dispositivos de bloques</title>
<body>

<p>
En esta sección, echaremos un buen vistazo a los aspectos Linux orientados
al disco, incluyendo sistemas de archivos Linux, particiones y
dispositivos de bloques. Una vez que esté familiarizado con las entradas y
salidas de discos y sistemas de archivos, le guiaremos a través del
proceso de creación de particiones y sistemas de archivos Linux.
</p>

<p>
Para comenzar, haré una introducción a "dispositivos de bloques". El
dispositivo de bloques más famoso es probablemente el que representa la
primera unidad de disco IDE en un sistema Linux:
</p>

<pre caption="La primera unidad de disco IDE en Linux">
/dev/hda
</pre>

<p>
Si su sistema utiliza unidades SCSI, entonces el primer disco duro será el
siguiente:
</p>

<pre caption="La primera unidad de disco SCSI en Linux">
/dev/sda
</pre>

</body>
</section>
<section>
<title>Capas de abstracción</title>
<body>

<p>
Los dispositivos de bloques mencionados anteriormente representan una
interfaz abstracta en el disco. Los programas de usuario pueden utilizar
estos dispositivos de bloques para interaccionar con el disco sin
preocuparse acerca de si sus unidades son IDE, SCSI, o cualquier otra
cosa. El programa simplemente puede direccionar el almacenamiento en el
disco como un grupo de bloques de 512 bytes contiguos, accesibles
aleatoriamente.
</p>

</body>
</section>
<section>
<title>Particiones</title>
<body>

<p>
Bajo Linux, creamos sistemas de archivos mediante un comando especial
llamado <c>mkfs</c> (o <c>mke2fs</c>, <c>mkreiserfs</c>, etc.),
especificando un dispositivo de bloques particular como argumento en la
línea de comandos.
</p>

<p>
Sin embargo, aunque teóricamente es posible usar un dispositivo de bloques
de "disco completo" (uno que represente todo el disco) como
<path>/dev/hda</path> o <path>/dev/sda</path> para albergar un único sistema
de archivos, esto casi nunca se hace en la práctica. En cambio, los discos
completos de dispositivos de bloques están divididos en dispositivos de
bloques más pequeños y manejables llamados particiones. Las particiones
son creadas utilizando una herramienta llamada <c>fdisk</c>, la cual es
usada para crear y editar la tabla de particiones que está almacenada en
cada disco. La tabla de particiones define exactamente como dividir el disco
completo.
</p>

</body>
</section>
<section>
<title>Introducción a fdisk</title>
<body>

<p>
Podemos echar un vistazo a la tabla de particiones de un disco ejecutando
<c>fdisk</c>, especificando como argumento el dispositivo de bloques que
representa el disco completo.
</p>

<note>
Interfaces alternativas a la tabla de partición del disco incluyen
<c>cfdisk</c>, <c>parted</c>, y <c>partimage</c>. Le recomiendo que evite el
uso de <c>cfdisk</c> (a pesar de lo que pueda decir la página de manual de
fdisk) ya que algunas veces calcula la geometría del disco de manera
incorrecta.
</note>

<pre caption="Usar fdisk en la unidad IDE">
# <i>fdisk /dev/hda</i>
</pre>

<pre caption="Usar fdisk en la unidad SCSI">
# <i>fdisk /dev/sda</i>
</pre>

<impo>
No debe guardar o hacer cambios en la tabla de particiones del disco si
alguna de sus particiones contienen sistemas de archivos que están en uso o
datos importantes. Hacerlo, generalmente ocasiona que los datos
en el disco se pierdan.
</impo>

</body>
</section>
<section>
<title>Dentro de fdisk</title>
<body>

<p>
Una vez en <c>fdisk</c>, le dará la bienvenida un símbolo de espera de
órdenes parecido a este:
</p>

<pre caption="Símbolo de espera de órdenes de bienvenida de fdisk">
Command (m for help):
</pre>

<p>
Teclee <c>p</c> para desplegar la configuración actual de la tabla de
particiones del disco:
</p>

<pre caption="Desplegar la configuración actual de las particiones">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
Este disco en particular está configurado para albergar siete sistemas de
archivos Linux (cada uno con su partición correspondiente listada como
"Linux") así como una partición de intercambio ("listada como Linux swap").
</p>

</body>
</section>
<section>
<title>Resumen de dispositivos de bloques y particionamiento</title>
<body>

<p>
Observe el nombre correspondiente a la partición del dispositivo de
bloques en el lado izquierdo, comenzando con <path>/dev/hda1</path> y
siguiendo hasta <path>/dev/hda9</path>. En los primeros días de la PC, el
software de particionamiento solo permitía un máximo de cuatro particiones
(llamadas particiones primarias). Esto limitaba demasiado, por lo que
fue creada una solución temporal llamada partición extendida. Una
partición extendida es muy similar a la partición primaria, y cuenta para
el límite de cuatro particiones primarias. Sin embargo, la partición
extendida puede contener cualquier número de las llamadas particiones
lógicas dentro de ella, dando así un medio eficaz para trabajar con el
límite de cuatro particiones.
</p>

</body>
</section>
<section>
<title>Resumen de particionamiento, continuación</title>
<body>

<p>
Todas las particiones hda5 y superiores son particiones lógicas. Los
números del 1 al 4 están reservados para particiones primarias o extendidas.
</p>

<p>
En nuestro ejemplo, hda1 hasta hda3 son particiones primarias. hda4 es una
partición extendida que contiene las particiones lógicas hda5 hasta hda9.
Realmente nunca utilizará <path>/dev/hda4</path> para almacenar cualquier
sistema de archivos, simplemente actúa como contenedor para las
particiones hda5 hasta hda9.
</p>

</body>
</section>
<section>
<title>Tipos de partición</title>
<body>

<p>
También observe que cada partición tiene un "identificador" ("Id"),
también llamado tipo de partición. Siempre que crea una nueva partición,
debe asegurarse que el tipo de partición está definido correctamente. 83
es el tipo correcto de partición para particiones que albergarán sistemas
de archivos Linux, y 82 es el tipo correcto de partición para las
particiones de intercambio Linux. Puede establecer el tipo de partición
usando la opción t en <c>fdisk</c>. El núcleo Linux utiliza la
configuración del tipo de partición para autodetectar los sistemas de
archivos y dispositivos de intercambio en el disco durante el arranque.
</p>

</body>
</section>
<section>
<title>Usar fdisk para crear las particiones</title>
<body>

<p>
Ahora que ya tiene una introducción al modo en que se crean las
particiones del disco en Linux, es hora de caminar a través del proceso de
crear las particiones del disco y los sistemas de archivos para una nueva
instalación de Linux. En este proceso, configuraremos un disco con nuevas
particiones y después crearemos sistemas de archivos en ellas. Estos pasos
nos darán como resultado un disco completamente limpio, sin datos,
que puede ser utilizado como la base de una nueva instalación de Linux.
</p>

<impo>
Para seguir estos pasos, debe tener un disco duro que no contenga ningún
dato importante, ya que estos pasos <e>borrarán</e> los datos del disco.
Si esto le es nuevo, debería considerar solo leer los pasos, o usar un
disco de arranque Linux en un sistema de prueba donde ningún dato corra
peligro.
</impo>

</body>
</section>
<section>
<title>Cómo debería verse el disco</title>
<body>

<p>
Después de caminar a través del proceso de creación de particiones en el
disco, la configuración de las particiones se verá así:
</p>

<pre caption="Vista del disco después de crear particiones">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1    *        1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

</body>
</section>
<section>
<title>Comentario sobre la partición de ejemplo</title>
<body>

<p>
En nuestra configuración de particiones sugerida tipo "novato", tenemos
tres particiones. La primera de ellas (<path>/dev/hda1</path>) al inicio
del disco es una pequeña partición llamada partición de arranque (boot).
El propósito de la partición de arranque es mantener todos los datos
críticos relacionados con el arranque, información del gestor de arranque
GRUB (si está utilizando GRUB) así como el(los) núcleo(s) Linux. La
partición de arranque nos brinda un lugar seguro para almacenar todo lo
relacionado al arranque de Linux. Durante el uso normal día a día de
Linux, la partición de arranque debe permanecer desmontada por seguridad.
Si está configurando un sistema SCSI, su partición de arranque
probablemente terminará siendo <path>/dev/sda1</path>.
</p>

<p>
Se recomienda tener las particiones de arranque (conteniendo todo lo
necesario para que el gestor de descarga trabaje) en el inicio del disco.
Aunque ya no se requiere necesariamente, es una tradición útil desde los
días en que el gestor de arranque LILO no era capaz de cargar núcleos
desde sistemas de archivos que se extendieran en el disco mas allá del
cilindro 1024.
</p>

<p>
La segunda partición (<path>/dev/hda2</path>) se utiliza para el espacio
de intercambio. El núcleo utiliza el espacio de intercambio como memoria
virtual cuando la memoria RAM es baja. Esta partición, relativamente
hablando, no es muy grande, por lo general se encuentra alrededor de los
512 MB. Si está configurando un sistema SCSI, esta partición probablemente
terminará llamádose <path>/dev/hda2</path>.
</p>

<p>
La tercera partición <path>/dev/hda3</path>) es bastante grande y ocupa el
resto del disco. Esta partición se llama partición raíz (root) y se
utilizará para almacenar el sistema de archivos principal que alberga el
sistema de archivos Linux principal. En un sistema SCSI, esta partición
se llamará <path>/dev/sda3</path>.
</p>

</body>
</section>
<section>
<title>Primeros pasos</title>
<body>

<p>
Bien, ahora vamos a crear las particiones como en el ejemplo y la tabla de
arriba. En primer lugar, entre en fdisk escribiendo <c>fdisk /dev/hda</c>
o <c>fdisk /dev/sda</c>, dependiendo de si está usando IDE o SCSI. A
continuación, teclee <c>p</c> para ver la configuración de particiones
actual. ¿Hay algo en el disco que desee conservar? Si es así, deténgase
ahora. Si continúa con estas instrucciones, todos los datos existentes en
el disco se borrarán.
</p>

<impo>
¡Si sigue las siguientes instrucciones todos los datos en su disco
sean borrados!. Si hay algo en el disco, por favor asegúrese que no sea
información crítica y que no le importe perder. También asegúrese de que
ha seleccionado la unidad correcta para que no se eliminen por error datos
de la unidad equivocada.
</impo>

</body>
</section>
<section>
<title>Eliminar las particiones existentes</title>
<body>

<p>
Ahora, es el momento de eliminar las particiones existentes. Para hacerlo,
escriba d y pulse intro. A continuación se le pedirá el número de
partición que le gustaría borrar. Para eliminar una pre-existente
<path>/dev/hda1</path>, debe escribir:
</p>

<pre caption="Eliminar una partición pre-existente">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
La partición ha sido programada para su eliminación. Ya no aparecerá si
teclea <c>p</c>, pero no será borrada hasta que los cambios sean
guardados. Si comete algún error y quiere abortar sin guardar ninguno de
los cambios, escriba <c>q</c> inmediatamente y oprima intro y la partición
no será eliminada.
</p>

<p>
Ahora, suponiendo que quiere eliminar todas las particiones en el sistema,
repetidamente teclee <c>p</c> para imprimir un listado de las particiones
y después escriba <c>d</c> y el número de la partición a eliminar.
Eventualmente, terminará con una tabla de particiones sin nada en ella:
</p>

<pre caption="Vista de la unidad después de limpiarla">

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

</body>
</section>
<section>
<title>Crear una partición de arranque</title>
<body>

<p>
Ahora que la tabla de particiones en memoria está vacía, estamos listos
para crear una partición de arranque. Para hacerlo, escriba <c>n</c> para
crear una partición nueva, después <c>p</c> para decirle a fdisk que
quiere una partición primaria. Después escriba <c>1</c> para crear la
primera partición primaria. Cuando se le pida el primer cilindro, pulse
intro. Cuando se le pida el último cilindro, teclee <c>+100M</c> para
crear una partición de 100MB de tamaño. Aquí está la salida de estos pasos:
</p>

<pre caption="Crear una partición de arranque">
Command (m for help): <i>n</i>
Command action
e   extended
p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876):<i>+100M</i>
</pre>

<p>
Ahora, cuando teclee <c>p</c>, deberá ver la siguiente impresión de la
partición:
</p>

<pre caption="Listado de la partición">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

</body>
</section>
<section>
<title>Crear la partición de intercambio</title>
<body>

<p>
A continuación, crearemos la partición de intercambio (swap). Para hacer
esto, teclee <c>n</c> para crear una nueva partición, después <c>n</c>
para decirle a fdisk que desea una partición primaria. Después teclee
<c>2</c> para crear la segunda partición primaria, <path>/dev/hda2</path>
en nuestro caso. Cuando se le pida el primer cilindro, pulse intro. Cuando
se le pida el último cilindro, teclee <c>+512M</c> para crear una
partición de 512MB de tamaño. Después de hacer esto, teclee <c>t</c>
para establecer el tipo de partición, y luego escriba <c>82</c> para
establecer el tipo de partición a "Intercambio Linux". Después de
completar estos pasos, al teclear <c>p</c> se debería mostrar una tabla de
partición parecida a la siguiente:
</p>

<pre caption="Tabla de particiones">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

</body>
</section>
<section>
<title>Hacer la partición arrancable</title>
<body>

<p>
Por último, tenemos que definir la bandera "de arranque" en nuestra
partición de arranque y después escribir los cambios en el disco. Para
etiquetar <path>/dev/hda1</path> como partición "de arranque", escriba
<c>a</c> en el menú y después escriba 1 para el número de partición. Si
escribe <c>p</c> ahora, verá que <path>/dev/hda1</path> tiene un "*" en la
columna "Boot". Ahora, vamos a escribir los cambios en el disco. Para
hacerlo, escriba <c>w</c> y pulse intro. Las particiones del disco están
configuradas correctamente para la instalación de Linux.
</p>

<note>
Si fdisk le indica que debe hacerlo, por favor, reinicie el sistema para
permitir que su sistema detecte la nueva configuración de las particiones.
</note>

</body>
</section>
<section>
<title>Particionamiento extendido y lógico</title>
<body>

<p>
En el ejemplo de arriba, creamos una partición primaria que contiene un
sistema de archivos utilizado para almacenar todos nuestros datos. Esto
significa que después de instalar Linux, este sistema de archivos
principal se montará en "<path>/</path>" y albergará un árbol de
directorios que contiene todos nuestros archivos.
</p>

<p>
Si bien esto es una forma común de configurar un sistema Linux, existe
otro enfoque que debe conocer. Este método utiliza varias particiones que
albergan múltiples sistemas de archivos que son "enlazados" juntos para
formar un árbol cohesivo de sistemas de archivos. Por ejemplo, es común
poner <path>/home</path> y <path>/var</path> en sus propios sistemas de
archivos.
</p>

<p>
Podríamos haber creado hda2 como una partición extendida en lugar de una
primaria. En este caso, podríamos haber creado las particiones lógicas hda5,
hda6 y hda7 (que técnicamente estarían "dentro" de hda2), las cuales
albergarían los sistemas de archivos <path>/</path>, <path>/home</path>,
y <path>/var</path> respectivamente.
</p>

<p>
Puede aprender más acerca de este tipo de configuración de múltiples
sistemas de archivos mediante el estudio de la bibliografía listada más
abajo.
</p>

</body>
</section>
<section>
<title>Bibliografía de particionamiento</title>
<body>

<p>
Para más información acerca de particionamiento, eche un vistazo a los
siguientes consejos de particionamiento:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/partition-planning-tips.xml">Planificación
    de Particiones</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/partitioning-p2.xml">Particionamiento en
    acción: Consolidando los datos</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/partitioning-p1.xml">Particionamiento en
    acción: Moviendo /home</uri>.
  </li>
</ul>

</body>
</section>
<section>
<title>Creación de sistemas de archivos</title>
<body>

<p>
Ahora que hemos creado las particiones, es hora de crear sistemas de
archivos en las particiones de arranque y raíz para que se puedan
montar y utilizar para almacenar datos. Además configuraremos la
partición de intercambio para que funcione como un almacén de intercambio.
</p>

<p>
Linux soporta una gran variedad de diferentes tipos de sistemas de
archivos, cada tipo tiene sus fortalezas y debilidades y su propio
conjunto de características de desempeño. En este tutorial, cubriremos la
creación de sistemas de archivos ext2, ext3, XFS, JFS y ReiserFS.
Antes de crear sistemas de archivos en nuestro sistema de ejemplo, hagamos
un breve repaso de los sistemas de archivos disponibles en Linux. Veremos
con más detalle los sistemas de archivos más adelante en este tutorial.
</p>

</body>
</section>
<section>
<title>El sistema de archivos ext2</title>
<body>

<p>
ext2 es el sistema de archivos Linux confiable y de sobra probado, pero no
tiene registro de metadatos (metadata journaling), lo que significa que las
revisiones de rutina del sistema de archivos ext2 en el inicio pueden
consumir mucho tiempo. En la actualidad existe una gran selección de
sistemas de archivos de nueva generación que pueden revisar la consistencia
con mucha rapidez y por lo general son los preferidos sobre sus
contrapartes sin registro diario (journaling). Los sistemas con registro
diario evitan largas esperas cuando el sistema arranca y el sistema de
archivos resulta estar en un estado inconsistente.
</p>

</body>
</section>
<section>
<title>El sistema de archivos ext3</title>
<body>

<p>
ext3 es la versión con registro diario del sistema de archivos
ext2, proporciona registro de metadatos para una rápida recuperación además
de otros modos de registro diario mejorados, tales como datos de
registro completos y ordenados. ext3 es un sistema de archivos muy bueno
y confiable. En general ofrece un desempeño decente en la mayoría de las
condiciones. Debido a que no emplea ampliamente el uso de "árboles" en su
diseño interno, no se escala muy bien, lo que significa que no es la opción
ideal para sistemas de archivos muy grandes o grandes cantidades de archivos
en un solo directorio. Pero cuando es usado dentro de sus parámetros de
diseño, ext3 es un excelente sistema de archivos.
</p>

<p>
Una de las cosas buenas de ext3 es que los sistemas de archivos existentes
ext2 pueden ser actualizados "in situ" a ext3 con bastante facilidad. Esto
permite un camino de actualización sin problemas para sistemas Linux que
ya están usando ext2.
</p>

</body>
</section>
<section>
<title>El sistema de archivos ReiserFS</title>
<body>

<p>
ReiserFS es un sistema de archivos basado en árboles-B que tiene un
desempeño general muy bueno y supera en gran medida a ext2 y ext3 cuando 
se trata de archivos pequeños (archivos de menos de 4k), a menudo por un 
factor de 10x-15x. ReiserFS además se escala sumamente bien y tiene 
registro de metadatos. A partir del núcleo 2.4.18+, ReiserFS es sólido 
como una roca y altamente recomendado para usarlo tanto como sistema de 
archivos de uso general como en casos extremos, como la creación de 
sistemas de archivos grandes, el uso de muchos archivos pequeños, 
archivos muy grandes, y directorios que contengan decenas de miles de 
archivos. ReiserFs es el sistema de archivos que recomendamos de forma 
predeterminada para todas las particiones que no sean de arranque.
</p>

</body>
</section>
<section>
<title>El sistema de archivos XFS</title>
<body>

<p>
XFS es un sistema de archivos con registro de metadatos. Viene con un 
conjunto de características robusto y está optimizado para la 
escalabilidad. Solo recomendamos utilizar este sistema de archivos en 
sistemas Linux con SCSI de alto nivel y/o almacenamiento en canal de 
fibra y un sistema de alimentación ininterrumpido. Debido a que XFS 
obtiene datos en tránsito en RAM agresivamente, los programas mal 
diseñados (aquellos que no toman las debidas precauciones cuando escriben 
archivos al disco, y hay un buen número de ello) pueden perder una buena 
cantidad de datos si el sistema se apaga de manera inesperada.
</p>

</body>
</section>
<section>
<title>El sistema de archivos JFS</title>
<body>

<p>
JFS es el sistema de archivos transaccional de alto rendimiento propio de 
IBM. Ha sido liberado recientemente, y nos gustaría ver un historial más
largo antes de comentar de manera positiva o negativa su estabilidad
general en este punto.
</p>

</body>
</section>
<section>
<title>Recomendaciones de sistema de archivos</title>
<body>

<p>
Si está buscando el sistema de archivos transaccional más resistente, use
ext3. Si busca un sistema de archivos de alto rendimiento de propósito
general con soporte de registro de datos, use ReiserFs; tanto ext3 como
ReiserFS son maduros, refinados y recomendados para uso general.
</p>

<p>
Basados en nuestro ejemplo anterior, usaremos las siguientes órdenes para
inicializar todas las particiones para su uso:
</p>

<pre caption="Inicializar particiones">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
Elegimos ext3 para la partición de arranque <path>/dev/hda1</path> debido
a que es un sistema de archivos transaccional robusto que puede ser
utilizado con todos los gestores de arranque principales. Usamos
<c>mkswap</c> para la partición de intercambio <path>/dev/hda2</path>, aquí
la elección es obvia. Y para el sistema de archivos raíz principal en
<path>/dev/hda3</path> elegimos ReiserFS, ya que es un sistema de archivos
transaccional que ofrece un excelente rendimiento. Ahora, continúe e
inicialice las particiones.
</p>

</body>
</section>
<section>
<title>Hacer el intercambio</title>
<body>

<p>
<c>mkswap</c> es la orden utilizada para inicializar las particiones de
intercambio:
</p>

<pre caption="Inicializar la partición de intercambio">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
A diferencia de los sistemas de archivos regulares, las particiones de
intercambio no se montan. En cambio, son habilitadas utilizando la orden
<c>swapon</c>:
</p>

<pre caption="Habilitar partición de intercambio">
# <i>swapon /dev/hdc6</i>
</pre>

<p>
Los guiones de inicio del sistema Linux se harán cargo de habilitar
automáticamente las particiones de intercambio. Por lo tanto, la orden
<c>swapon</c> por lo general solo se necesita cuando es necesario agregar
inmediatamente alguna partición de intercambio recién creada. Para ver los
dispositivos de intercambio habilitados actualmente, teclee
<c>cat/proc/swaps</c>.
</p>

</body>
</section>
<section>
<title>Crear sistemas de archivos ext2, ext3, y ReiserFS</title>
<body>

<p>
Puede usar la orden <c>mke2fs</c> para crear sistemas de archivos ext2:
</p>

<pre caption="Crear sistemas de archivos ext2">
# <i>mke2fs /dev/hda1</i>
</pre>

<p>
Si desea utilizar ext3, puede crear sistemas de archivos ext3 usando
<c>mke2fs -j</c>:
</p>

<pre caption="Crear sistemas de archivos ext3">
# <i>mke2fs -j /dev/hda3</i>
</pre>

<note>
Puede saber más acerca del uso de ext3 en Linux 2.4 en <uri
link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">este sitio</uri>
desarrollado por Andrew Morton.
</note>

<p>
Para crear sistemas de archivos ReiserFS, use la orden <c>mkreiserfs</c>:
</p>

<pre caption="Crear sistemas de archivos ReiserFS">
# <i>mkreiserfs /dev/hda3</i>
</pre>

</body>
</section>
<section>
<title>Crear sistemas de archivos XFS y JFS</title>
<body>

<p>
Para crear un sistema de archivos XFS, use la orden <c>mkfs.xfs</c>:
</p>

<pre caption="Crear sistemas de archivos XFS">

# <i>mkfs.xfs /dev/hda3</i>
</pre>

<note>
Es posible que desee agregar un par de opciones adicionales a la orden
mkfs.xfs: <c>-d agcount=3 -l size=32m</c>. La orden <c>-d agcount=3</c>
disminuirá el número de grupos asignados. XFS insistirá en al menos un
grupo asignado por 4GB de la partición, por lo que, por ejemplo, si tiene
una partición de 20GB necesitará un agcount mínimo de 5. La orden
<c>lsize=32m</c> aumenta el tamaño de registro a 32MB, incrementando el
rendimiento.
</note>

<p>
Para crear sistemas de archivos JFS, use la orden <c>mkfs.jfs</c>:
</p>

<pre caption="Crear sistemas de archivos JFS">
# <i>mkfs.jfs /dev/hda3</i>
</pre>

</body>
</section>
<section>
<title>Montar sistemas de archivos</title>
<body>

<p>
Una vez que se ha creado el sistema de archivos, podemos montarlo utilizando
la orden <c>mount</c>:
</p>

<pre caption="Montar el sistema de archivos">
# <i>mount /dev/hda3 /mnt</i>
</pre>

<p>
Para montar un sistema de archivos, especifique la partición del
dispositivo de bloques como primer argumento y un "sitio para el montaje"
como segundo argumento. El sistema de archivos nuevo se "injerta en" ese
punto de montaje. Esto también tiene el efecto de "esconder" cualquier
archivo que esté en el directorio <path>/mnt</path> en el sistema de
archivos padre. Después, cuando se desmonta el sistema de archivos,
estos archivos reaparecen. Después de ejecutar la orden de mount,
cualquier archivo creado o copiado dentro de <path>/mnt</path> será
almacenado en el nuevo sistema de archivos ReiserFS que montó.
</p>

<p>
Digamos que queremos montar nuestra partición de arranque dentro de
<path>/mnt</path>. Podemos hacerlo realizando los siguientes pasos:
</p>

<pre caption="Montar partición de arranque en /mnt">
# <i>mkdir /mnt/boot</i>
# <i>mount /dev/hda1 /mnt/boot</i>
</pre>

<p>
Ahora, nuestro sistema de archivos está disponible dentro de /mnt/boot. Si
creamos archivos dentro de <path>/mnt/boot</path>, serán almacenados en
nuestro sistema de archivos ext3 que físicamente reside en
<path>/dev/hda1</path>. Si creamos un archivo dentro de <path>/mnt</path>
pero no en <path>/mnt/boot</path>, entonces serán almacenados en nuestro
sistema de archivos ReiserFS que reside en <path>/dev/hda3</path>. Y si
creamos archivos fuera de <path>/mnt</path>, no se pueden almacenar en
cualquiera de los sistemas de archivos sino en el sistema de archivos de
nuestro sistema actual Linux o en el disco de arranque.
</p>

<p>
Para ver cuales sistemas de archivos están montados, escriba <c>mount</c>.
Aquí está la salida de <c>mount</c> en uno de nuestros sistemas Linux
actualmente en ejecución, el cual tiene las particiones configuradas
de forma similar a las del ejemplo de arriba:
</p>

<pre caption="Salida de la orden mount">
/dev/root on / type reiserfs (rw,noatime)
none on /dev type devfs (rw)
proc on /proc type proc (rw)
tmpfs on /dev/shm type tmpfs (rw)
usbdevfs on /proc/bus/usb type usbdevfs (rw)
/dev/hde1 on /boot type ext3 (rw,noatime)
</pre>

<p>
También puede ver información similar escribiendo cat
<path>/proc/mounts</path>. El sistema de archivos raíz,
<path>/dev/hda3</path> lo monta automáticamente el núcleo en el
momento de arrancar, y recibe el nombre simbólico <path>/dev/hda3</path>.
En nuestro sistema, tanto <path>/dev/hda3</path> y <path>/dev/root</path>
señalan al mismo dispositivo de bloques usando un enlace simbólico:
</p>

<pre caption="Enlaces simbólicos">
# <i>ls -l /dev/root</i>
lr-xr-xr-x   1 root   root   33 Mar 26 20:39 /dev/root ->
ide/host0/bus0/target0/lun0/part3

# <i>ls -l /dev/hda3</i>
lr-xr-xr-x   1 root   root   33 Mar 26 20:39 /dev/hde3 ->
ide/host0/bus0/target0/lun0/part3
</pre>

</body>
</section>
<section>
<title>Aún más cosas de montaje</title>
<body>

<p>
Entonces, ¿qué es este archivo "<path>/dev/ide/host0</path>...."? Sistemas
como el mío que utilizan el dispositivo de administración de sistemas de
archivos devfs para <path>/dev</path>, tienen nombres oficiales más largos
para la partición y los dispositivos de bloques del disco que los que
solía tener Linux. Por ejemplo,
<path>/dev/ide/host0/bus1/target0/lun0/part7</path> es el nombre oficial para
<path>/dev/hdc7</path>, y <path>/dev/hdc7</path> es en sí un enlace
simbólico al dispositivo de bloques oficial. Puede determinar si su
sistema utiliza devfs revisando si el archivo <path>/dev/.devfsd</path>
existe; si es así, entonces devfs está activo.
</p>

<p>
Cuando se utiliza la orden mount para montar sistemas de archivos, ésta
intenta autodetectar el tipo de sistema de archivos. Algunas veces, esto
no funciona y tendrá que especificar manualmente el tipo de sistema de
archivos a ser montado utilizando la opción -t, de la siguiente manera:
</p>

<pre caption="Montar un sistema de archivos ext3 manualmente con la opción -t">
# <i>mount /dev/hda1 /mnt/boot -t ext3</i>
</pre>

<p>or</p>

<pre caption="Montar un sistema de archivos reiserfs manualmente con la opción -t">
# <i>mount /dev/hda3 /mnt -t reiserfs</i>
</pre>

</body>
</section>
<section>
<title>Opciones de montaje</title>
<body>

<p>
También es posible personalizar varios atributos del sistema de archivos que
se quiere montar, especificando las opciones de montaje. Por ejemplo, puede
montar un sistema de archivos de "solo lectura" utilizando la opción "ro":
</p>

<pre caption="Montar un sistema de archivos de solo lectura">
# <i>mount /dev/hdc6 /mnt -o ro</i>
</pre>

<p>
Con <path>/dev/hdc6</path> montado como solo lectura, no hay archivos que
puedan ser modificados en <path>/mnt</path>, solo lectura. Si su sistema
de archivos está montado como "lectura/escritura" y desea cambiar al modo
de solo lectura, puede utilizar la opción "remount" para evitar tener que
montar y desmontar el sistema de archivos otra vez:
</p>

<pre caption="Usar la opción remount">
# <i>mount /mnt -o remount,ro</i>
</pre>

<p>
Tenga en cuenta que no necesitamos especificar la partición del
dispositivo de bloques debido a que el sistema de archivos ya está montado
y <c>mount</c> sabe que <path>/mnt</path> está asociado con
<path>/dev/hdc6</path>. Para hacer el sistema de archivos de escritura otra
vez, podemos montarlo nuevamente como lectura y escritura:
</p>

<pre caption="Remontar un sistema de archivos como lectura-escritura">
# <i>mount /mnt -o remount,rw</i>
</pre>

<p>
Tenga en cuenta que las ordenes remount no se completarán correctamente si
cualquier proceso ha abierto archivos o directorios en <path>/mnt</path>.
Para familiarizarse con todas las opciones de montaje disponibles en
Linux, escriba <c>man mount</c>.
</p>

</body>
</section>
<section>
<title>Introducción a fstab</title>
<body>

<p>
Hasta ahora, hemos visto cómo particionar un disco de ejemplo y montar
sistemas de archivos manualmente desde un disco de arranque. Pero una vez
que tengamos un sistema Linux instalado, ¿cómo podemos configurar ese
sistema Linux para montar los sistemas de archivos correctos en el momento
adecuado? Por ejemplo, digamos que instalamos Gentoo Linux en nuestra
configuración actual del sistema de archivos de ejemplo. ¿Cómo sabría
nuestro sistema cómo encontrar el sistema de archivos raíz en
<path>/dev/hda3</path>? Y si algún otro sistema de archivos, como el de
intercambio, necesita ser montado en el momento de arranque, ¿cómo sabría
cuáles?
</p>

<p>
Bien, el gestor de arranque le indica al núcleo de Linux qué sistema de
archivos raíz usar, y le daremos un vistazo a los gestores de arranque de
Linux después en este tutorial. Pero para todo lo demás, su sistema Linux
tiene un archivo llamado <path>/etc/fstab</path> que indica qué 
sistemas de archivos están disponibles para el montaje. Echemos un vistazo.
</p>

</body>
</section>
<section>
<title>Una muestra de fstab</title>
<body>

<p>
Veamos una muestra del archivo <path>/etc/fstab</path>:
</p>

<pre caption="Muestra del archivo /etc/fstab">
&lt;fs&gt; &lt;mountpoint&gt; &lt;type&gt;    &lt;opts&gt;
&lt;dump/pass&gt;

/dev/hda1       /boot           ext3            noauto,noatime          1 1
/dev/hda3       /               reiserfs        noatime                 0 0
/dev/hda2       none            swap            sw                      0 0
/dev/cdrom      /mnt/cdrom      iso9660         noauto,ro,user          0 0
# /proc should always be enabled
proc            /proc           proc            defaults                0 0
</pre>

<p>
Arriba, cada línea no comentada en <path>/etc/fstab</path> especifica una
partición del dispositivo de bloques, un sitio para montaje, un tipo de
sistema de archivos, las opciones para usar cuando se monte el sistema de
archivos, y dos campos numéricos. El primer campo numérico se usa para
indicarle a la orden de respaldo <c>dump</c> el sistema de archivos que
debe ser respaldado. Por supuesto, si no planea utilizar <c>dump</c> en su
sistema, entonces puede ignorar sin peligro este campo. El último campo es
usado por el programa de revisión de integridad del sistema de archivos
<c>fsck</c>, e indica el orden en que sus sistemas de archivos deben ser
revisados en el arranque. Tocaremos el tema <c>fsck</c> de nuevo en unos
cuantos paneles.
</p>

<p>
Mire la línea <path>/dev/hda1</path>; verá que <path>/dev/hda1</path> es
un sistema de archivos ext3 que debe ser montado en el sitio para montaje
<path>/boot</path>. Ahora mire las opciones de montaje de
<path>/dev/hda1</path> en la columna opts. La opción noauto le indica al
sistema no montar <path>/dev/hda1</path> de manera automática en el momento
del arranque del sistema.
</p>

<p>
También, observe que la opción noauto, desactiva la grabación de la
información atime (tiempo del último acceso) en el disco. Esta información
por lo general no es necesaria, y desactivar las actualizaciones de atime
tiene un efecto positivo en el desempeño del sistema de archivos.
</p>

<p>
Ahora, eche un vistazo a la línea <path>/proc</path> y tenga en cuenta la
opción defaults. Use defaults siempre que desee que un sistema de archivos
se monte solo con las opciones estándar. Debido a que
<path>/etc/fstab</path> tiene campos múltiples, no podemos simplemente
dejar el campo de la opción en blanco.
</p>

<p>
Observe también la línea para <path>/dev/hda2</path> en
<path>/etc/fstab</path>.  Esta línea define a <path>/dev/hda2</path> como
un dispositivo de intercambio. Debido a que los dispositivos de intercambio
no se montan como sistemas de archivos, se especifica none (ninguno) en el
campo mountpoint (punto de montaje). Gracias a esta entrada de
<path>/etc/fstab</path>, nuestro dispositivo de intercambio
<path>/dev/hda2</path> se habilitará automáticamente cuando se inicie el
sistema.
</p>

<p>
Con una entrada para <path>/dev/cdrom</path> en <path>/etc/fstab</path>
como la de arriba, montar la unidad CD-ROM es más sencillo. En lugar de
escribir:
</p>

<pre caption="Montar CD-ROM sin la entrada en fstab">
# <i>mount -t iso9660 /dev/cdrom /mnt/cdrom -o ro</i>
</pre>

<p>
Podemos escribir:
</p>

<pre caption="Montar CD-ROM con la entrada en fstab">
# <i>mount /dev/cdrom</i>
</pre>

<p>
De hecho, usar <path>/etc/fstab</path> nos permite tomar ventaja de la
opción user (usuario). La opción de montaje user le indica al sistema que
debe permitir que cualquier usuario pueda montar ese sistema de archivos
en particular. Esto resulta útil para los medios extraíbles como las
unidades CD-ROM. Sin esta opción de montaje de fstab, solo el superusuario
podría utilizar la unidad CD-ROM.
</p>

</body>
</section>
<section>
<title>Desmontar sistemas de archivos</title>
<body>

<p>
Por lo general, todos los sistemas de archivos montados son desmontados
automáticamente por el sistema cuando se reinicia o se apaga. Cuando se
desmonta un sistema de archivos, cualquier dato de ese sistema de archivos
que se haya almacenado en memoria se vacía al disco.
</p>

<p>
Sin embargo, también es posible desmontar sistemas de archivos
manualmente. Antes de que un sistema de archivos se pueda desmontar,
primero debe asegurarse de que no hay otros procesos en ejecución que
tengan archivos abiertos del sistema de archivos en cuestión. Después,
utilice la orden <c>umount</c>, especificando el nombre del dispositivo o
el sitio de montaje como argumento:
</p>

<pre caption="Usar la orden umount">
# <i>umount /mnt</i>
</pre>

<p>
o
</p>

<pre caption="Usar la orden umount">
# <i>umount /dev/hda3</i>
</pre>

<p>
Una vez desmontado, cualquier archivo en <path>/mnt</path> que se 
"tapó" por el sistema de archivos previamente montado reaparecerá.
</p>

</body>
</section>
<section>
<title>Introducción a fsck</title>
<body>

<p>
Si el sistema se cae o se bloquea por alguna razón, éste no tiene
oportunidad de desmontar limpiamente los sistemas de archivos. Cuando esto
sucede, los sistemas de archivos quedan en un estado inconsistente
(impredecible). Cuando el sistema reinicia, el programa <c>fsck</c>
detectará que los sistemas de archivos no fueron desmontados limpiamente y
realizará una revisión de consistencia de los sistemas de archivos
que figuran en <path>/etc/fstab</path>.
</p>

<impo>
Para que <c>fsck</c> revise un sistema de archivos, debe tener un
número diferente de cero en el campo "pass" (el último campo) en
<path>/etc/fstab</path>. Normalmente, el sistema de archivos raíz se define
con un número pass 1, especificando que debe ser revisado primero. Todos los
otros sistemas de archivos que deben ser revisados al inicio deben tener
un número pass de 2 o superior. Para algunos sistemas de archivos
transaccionales como ReiserFS, es seguro tener un número pass 0 ya que el
código de registro diario (y no un <c>fsck</c> externo)
se encarga de hacer al sistema de archivos consistente de nuevo.
</impo>

<p>
A veces, es posible que después de reiniciar sea incapaz de reparar
totalmente un sistema de archivos dañado parcialmente. En estos casos, lo
que necesita hacer es bajar su sistema a un modo de mono-usuario y
ejecutar <c>fsck</c> manualmente, suministrando la partición del
dispositivo de bloques como argumento. Como <c>fsck</c> realiza la
reparación de su sistema de archivos, es posible que le pregunte si desea
reparar defectos particulares del sistema de archivos. En general, debe
decir <c>y</c> (si) a todas las preguntas y permitirle a <c>fsck</c> hacer
su trabajo.
</p>

</body>
</section>
<section>
<title>Problemas con fsck</title>
<body>

<p>
Uno de los problemas con el análisis de <c>fsck</c> es que puede tomar
mucho tiempo para completarse, ya que se necesita analizar la totalidad de
los metadatos (estructura de datos interna) del sistema de archivos con el
fin de asegurar su consistencia. Con sistemas de archivos muy grandes,
no es raro que un fsck exhaustivo tome más de una hora.
</p>

<p>
Para resolver este problema, se diseñó un nuevo tipo de sistema de
archivos, llamado sistema de archivos transaccional. Los sistemas de
archivos transaccionales guardan un registro en disco de los cambios
recientes de los metadatos del sistema de archivos. En caso de una caída,
el controlador del sistema de archivos inspecciona el registro. Debido a
que el registro contiene un relato preciso de los últimos cambios en el
disco, solo esas partes de los metadatos del sistema de archivos
necesitarán revisarse para buscar errores. Gracias a esta importante
diferencia de diseño, revisar la consistencia del sistema de archivos
transaccional generalmente solo toma unos segundos, sin importar el tamaño
del sistema de archivos. Por esta razón, los sistemas de archivos
transaccionales están ganando popularidad en la comunidad Linux. Para más
información de sistemas de archivos transaccionales, vea <uri
link="http://www-106.ibm.com/developerworks/library/l-fs.html">Advanced
filesystem implementor's guide, part 1: Journaling and ReiserFS</uri>.
</p>

<p>
Vamos a cubrir la mayoría de los sistemas de archivos disponibles en
Linux, junto con sus ordenes y opciones asociadas.
</p>

</body>
</section>
<section>
<title>El sistema de archivos ext2</title>
<body>

<p>
El sistema de archivos ext2 ha sido el estándar de los sistemas de
archivos durante muchos años. Generalmente tiene un buen desempeño para la
mayoría de las aplicaciones, pero no ofrece ninguna capacidad de registro
diario. Esto lo hace inadecuado para sistemas de archivos muy grandes, debido
a que <c>fsck</c> puede tomar un tiempo extremadamente largo. Además, ext2
tiene algunas limitaciones incorporadas por el hecho de que todo sistema
de archivos ext2 tiene un número fijo de inodos que puede contender. Dicho
esto, ext2 es considerado generalmente un sistema de archivos no
transaccional extremadamente robusto y eficiente.
</p>

<ul>
  <li>En núcleos: 2.0+</li>
  <li>Registro diario: no</li>
  <li>Orden mkfs: mke2fs</li>
  <li>Ejemplo mkfs: mke2fs /dev/hdc7</li>
  <li>Ordenes relacionadas: debugfs, tune2fs, chattr</li>
  <li>Opciones de montaje relacionadas con el desempeño: noatime.</li>
</ul>

</body>
</section>
<section>
<title>El sistema de archivos ext3</title>
<body>

<p>
El sistema de archivos ext3 utiliza el mismo formato en disco que ext2,
pero agrega capacidades de registro diario. De hecho, de todos los sistemas
de archivos Linux, ext3 tiene el soporte más amplio de registro diario, 
soportando no solo el registro de metadatos, sino también el registro de
datos ordenados (el modo predeterminado) y registro completo de datos y
metadatos. Esos modos "especiales" de registro ayudan a asegurar la
integridad de los datos, no solo para fscks más cortos como otras
implementaciones de registros diarios. Por esta razón, ext3 es el mejor
sistema de archivos para usar si la integridad de los datos es la primera
y absoluta prioridad. Sin embargo, estas características de integridad de
datos causan un poco de impacto en el desempeño. Además puesto que ext3
utiliza el mismo formato en disco que ext2, todavía sufre de las mismas
limitaciones de escalamiento que su primo no-transaccional. Ext3 es una
buena elección si está buscando un buen sistema de archivos transaccional
de propósito general que además es muy robusto.
</p>

<ul>
  <li>En núcleos: 2.4.16+</li>
  <li>
    Registro diario: metadatos, escritura de datos ordenados,
    metadatos+datos completos
  </li>
  <li>Orden mkfs: mke2fs -j</li>
  <li>Ejemplo mkfs: mke2fs -j /dev/hdc7</li>
  <li>Ordenes relacionadas: debugfs, tune2fs, chattr</li>
  <li>Opciones de montaje relacionadas con el desempeño: noatime</li>
  <li>Otras opciones de montaje:
    <ul>
      <li>data=writeback (desactivar registro diario)</li>
      <li>
        data=ordered (el predeterminado, registro de metadatos y datos son
        escritos al disco con metadatos)
      </li>
      <li>
        data=journal (registro completo de datos para la integridad de datos
        y metadatos. Reduce a la mitad el desempeño de escritura.)
      </li>
    </ul>
  </li>
  <li>
    Bibliografía de ext3:
    <ul>
      <li>
        <uri
        link="http://www.zip.com.au/~akpm/linux/ext3/">Andrew Morton's ext3
        page
        </uri>
      </li>
      <li>
        <uri
        link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">Andrew
        Morton's excellent ext3 usage documentation (recommended)
        </uri>
      </li>
      <li>
        <uri
        link="http://www.gentoo.org/doc/es/articles/afig-ct-ext3-intro.xml">
        Guía avanzada de implementación de Sistemas de Ficheros: Introducción
        a ext3
        </uri>
      </li>
      <li>
        <uri
        link="http://www.gentoo.org/doc/es/articles/l-afig-p8.xml">Guía
        avanzada de implementación de Sistemas de Ficheros, Parte 8
        </uri>
      </li>
    </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>El sistema de archivos ReiserFS</title>
<body>

<p>
ReiserFS es un sistema de archivos relativamente nuevo que ha sido
diseñado con el propósito de proveer un buen desempeño en archivos
pequeños, muy buen desempeño general y ser muy escalable. En general,
ReiserFS ofrece un muy buen rendimiento en la mayoría de las situaciones.
ReiserFS es el preferido de muchos por su velocidad y escalabilidad.
</p>

<ul>
  <li>En núcleos: 2.4.0+ (2.4.18+ altamente recomendado)</li>
  <li>Registro diario: metadatos</li>
  <li>Orden mkfs: mkreiserfs</li>
  <li>Ejemplo mkfs: mkreiserfs /dev/hdc7</li>
  <li>Opciones de montaje relacionadas con el desempeño: noatime, notail</li>
  <li>
    Bibliografía de ReiserFS:
    <ul>
      <li>
        <uri link="http://www.namesys.com/">The home of ReiserFS</uri>
      </li>
      <li>
        <uri
        link="http://www-106.ibm.com/developerworks/library/l-fs.html">
        Advanced filesystem implementor's guide, part 1: Journaling and
        ReiserFS
        </uri>
      </li>
      <li>
        <uri
        link="http://www-106.ibm.com/developerworks/library/l-fs2.html">
        Advanced filesystem implementor's guide, part 2: Using ReiserFS and
        Linux 2.4.
        </uri>
      </li>
    </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>El sistema de archivos XFS</title>
<body>

<p>
El sistema de archivos XFS es un sistema de archivos transaccional de
clase empresarial que se está portando a Linux por SGI. XFS es un
sistema de archivos transaccional, completo, escalable y es una buena
opción para hardware de una gama alta, fiable (ya que depende en gran
medida del almacenamiento de datos en la RAM), pero no es una buena opción
para hardware de gama baja.
</p>

<ul>
  <li>
    En núcleos: 2.5.34+ solamente, requiere un parche para las series 2.4
  </li>
  <li>Registro diario: metadatos</li>
  <li>Orden mkfs: mkfs.xfs</li>
  <li>Ejemplo mkfs: mkfs.xfs /dev/hdc7</li>
  <li>Opciones de montaje relacionadas con el desempeño: noatime</li>
  <li>
    Bibliografía de XFS:
    <ul>
      <li>
        <uri
        link="http://oss.sgi.com/projects/xfs/">The home of XFS (sgi.com)
        </uri>
      </li>
      <li>
        <uri
        link="http://www-106.ibm.com/developerworks/library/l-fs9.html">
        Advanced filesystem implementor's guide, part 9: Introducing XFS
        </uri>
      </li>
      <li>
        <uri
        link="http://www-106.ibm.com/developerworks/library/l-fs10.html">
        Advanced filesystem implementor's guide, part 10: Deploying XFS.
        </uri>
      </li>
    </ul>
  </li>
</ul>

</body>
</section>
<section>
<title>El sistema de archivos JFS</title>
<body>

<p>
JFS es un sistema de archivos transaccional de alto desempeño portado a
Linux por IBM. JFS es utilizado por los servidores empresariales IBM y
está diseñado para aplicaciones de alto rendimiento. Puede aprender más
acerca de JFS en <uri
link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">el sitio
Web del proyecto JFS</uri>.
</p>

<ul>
  <li>En núcleos: 2.4.20+</li>
  <li>Registro diario: metadatos</li>
  <li>Orden mkfs: mkfs.jfs</li>
  <li>Ejemplo mkfs: mkfs.jfs /dev/hdc7</li>
  <li>Opciones de montaje relacionadas con el desempeño: noatime</li>
  <li>
    Bibliografía de JFS: <uri
    link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">el
    sitio Web del proyecto JFS (IBM).</uri>
  </li>
</ul>

</body>
</section>
<section>
<title>VFAT</title>
<body>

<p>
El sistema de archivos VFAT no es realmente un sistema de archivos que
elegiría para almacenar archivos Linux. En cambio, es un sistema de
archivos compatible con DOS que le permite montar e intercambiar datos con
los sistemas de archivos DOS y Windows basados en FAT. El sistema de
archivos VFAT está presente en el núcleo estándar Linux.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Arrancar el sistema</title>
<section>
<title>Acerca de esta sección</title>
<body>

<p>
Esta sección hace una introducción al procedimiento de arranque de Linux.
Cubriremos el concepto de gestor de arranque, cómo definir las opciones
del núcleo al arranque, y cómo examinar el registro de arranque para
localizar errores.
</p>

</body>
</section>
<section>
<title>El MBR</title>
<body>

<p>
Los procesos de arranque son similares para todas las máquinas,
independientemente de cuál distribución está instalada. Considere el
siguiente disco duro de ejemplo:
</p>

<pre caption="Estructura de un disco duro">
+----------------+
|      MBR       |
+----------------+
|  Partición 1:  |
| Raíz Linux (/) |
|   contiene el  |
|   núcleo y el  |
|    sistema.    |
+----------------+
|  Partición 2:  |
|   Linux swap   |
+----------------+
|  Partición 3:  |
|   Windows 3.0  |
|(último arranque|
|    en 1992)    |
+----------------+
</pre>

<p>
En primer lugar, el BIOS de la computadora lee los primeros sectores del
disco duro. Estos sectores contienen un programa muy pequeño, llamado
"registro principal de arranque", o "MBR" (por sus siglas en inglés). El
MBR tiene almacenada la localización del núcleo Linux en el disco duro
(partición 1 en el ejemplo de arriba), por lo que carga el núcleo en la
memoria y lo inicia.
</p>

</body>
</section>
<section>
<title>El proceso de arranque del núcleo</title>
<body>

<p>
La siguiente cosa que verá (aunque es probable que parpadee rápidamente)
es una línea similar a la siguiente:
</p>

<pre caption="Línea de proceso de arranque">
Linux version 2.4.16 (root@time.flatmonk.org) (gcc version 2.95.3 20010315
(release)) #1 Sat Jan 12 19:23:04 EST 2002
</pre>

<p>
Esta es la primera línea impresa por el núcleo cuando este empieza a
ejecutarse. La primera parte es la versión del núcleo, seguido por la
identificación del usuario que construyó el núcleo (generalmente el
superusuario), el compilador que lo construyó, y la fecha en que fue
construido.
</p>

<p>
Seguido a esta línea está un gran cantidad de salidas desde el núcleo con
respecto al hardware en el sistema: el procesador, la línea de datos PCI,
el controlador del disco, discos, puertos seriales, unidad de disquete,
dispositivos USB, adaptadores de red, tarjetas de sonido, y posiblemente
otros que en su turno reportan su estado.
</p>

</body>
</section>
<section>
<title>/sbin/init</title>
<body>

<p>
Cuando el núcleo termina de cargar, inicia un programa llamado <c>init</c>.
Este programa permanece ejecutándose hasta que el sistema es apagado.
Siempre tiene asignado el identificador (ID) de proceso 1, como puede ver:
</p>

<pre caption="ID del proceso init">
$ <i>ps --pid 1</i>
PID TTY          TIME CMD
1 ?        00:00:04 init.system
</pre>

<p>
El programa <c>init</c> arranca el resto de la distribución ejecutando una
serie de guiones. Estos guiones por lo general viven en
<path>/etc/rc.d/init.d</path> o <path>/etc/init.d</path>, y realizan
servicios como definir el nombre del sistema anfitrión, revisar el sistema
de archivos en busca de errores, montar sistemas de archivos adicionales,
habilitar la red, inicializar servicios de impresión, etc. Cuando los
guiones están completos, <c>init</c> inicia un programa llamado
<c>getty</c> el cual despliega el símbolo de espera de órdenes de inicio, y
¡ya está listo!
</p>

</body>
</section>
<section>
<title>Cavando en: LILO</title>
<body>

<p>
Ahora que hemos dado un rápido recorrido a través del proceso de arranque,
veamos más de cerca la primera parte: el MBR y la carga del núcleo. El
mantenimiento del MBR es responsabilidad del "gestor de arranque". Los dos
gestores de arranque más populares para Linux basados en x86 son "LILO"
(LInux LOader) y "GRUB" (GRand Unified Bootloader).
</p>

<p>
De los dos, LILO es gestor de arranque mayor y el más común. La presencia
de LILO en el sistema se reporta en el arranque, con el breve símbolo de
espera de órdenes: "LILO boot:". Tenga en cuenta que posiblemente deba
mantener pulsada la tecla mayúsculas durante el arranque para obtener el
símbolo de espera de órdenes, debido a que muchas veces el sistema está
configurado para pasar rápido y directo sin detenerse.
</p>

<p>
No hay mucha fanfarria en el símbolo de espera de órdenes de LILO, pero si
pulsa la tecla &lt;tabulador&gt;, se le presentará una lista de núcleos
potenciales (u otros sistemas operativos) para arrancar. A menudo solo hay
uno en la lista. Puede arrancar uno de ellos escribiéndolo y presionando
&lt;intro&gt;. De manera alternativa puede simplemente pulsar &lt;intro&gt;
y el primer elemento de la lista arrancará de manera predeterminada.
</p>

</body>
</section>
<section>
<title>Usar LILO</title>
<body>

<p>
Es ocasiones es posible que desee pasarle una opción al núcleo en el
momento de arranque. Algunas de las opciones más comunes son <c>root=</c>
para especificar un sistema de archivos raíz alternativo, <c>init=</c>
para especificar un programa init alternativo (como <c>init=/bin/sh</c>
para rescatar un sistema mal configurado), y <c>mem=</c> para especificar
la cantidad de memoria en el sistema (por ejemplo <c>mem=512M</c> en caso
de que Linux autodetecte solo 128M). Puede pasarle al núcleo estas
opciones en el símbolo de espera de órdenes de arranque de LILO:
</p>

<pre caption="Símbolo de espera de órdenes de arranque LILO">
LILO boot: linux root=/dev/hdb2 init=/bin/sh mem=512M
</pre>

<p>
Si necesita especificar estas opciones en la línea de comandos, debe
considerar agregarlas a <path>/etc/lilo.conf</path>. El formato de este
archivo está descrito en la página de manual <path>lilo.conf</path>(5).
</p>

</body>
</section>
<section>
<title>Una advertencia importante de LILO</title>
<body>

<p>
Antes de pasar a GRUB, hay una advertencia importante de LILO. Siempre que
haga cambios en <path>/etc/lilo.conf</path>, o cada vez que instale un
nuevo núcleo, debe ejecutar <c>lilo</c>. El programa <c>lilo</c> reescribe
el MBR para reflejar los cambios que ha hecho, incluyendo la grabación de
la ubicación absoluta del núcleo en el disco. El ejemplo siguiente hace
uso de la opción -v para verbosidad:
</p>

<pre caption="Usar la orden lilo con la opción -v">
# <i>lilo -v</i>
LILO version 21.4-4, Copyright (C) 1992-1998 Werner Almesberger
'lba32' extensions Copyright (C) 1999,2000 John Coffman

Reading boot sector from /dev/hda
Merging with /boot/boot.b
Mapping message file /boot/message
Boot image: /boot/vmlinuz-2.2.16-22
Added linux *
/boot/boot.0300 exists - no backup copy made.
Writing boot sector.
</pre>

</body>
</section>
<section>
<title>Cavando en: GRUB</title>
<body>

<p>
Se puede considerar a GRUB como la siguiente generación de gestores de
arranque, después de LILO. Más visible a los usuarios, ofrece una interfaz
con un menú en lugar de el primitivo símbolo de espera de órdenes de LILO.
Para administradores de sistemas, los cambios son más significativos. GRUB
soporta más sistemas operativos que LILO, y proporciona cierta seguridad
basada en contraseñas en el menú de arranque, también es más sencillo de
administrar.
</p>

<p>
GRUB se instala usualmente con la orden <c>grub-install</c>. Una vez
instalado, el menú de GRUB es administrado por medio de la edición del
archivo <path>/boot/grub/grub.conf</path>. Estas dos tareas están fuera
del alcance de este documento; debería leer las páginas de información de
GRUB antes de intentar instalar o administrar GRUB.
</p>

</body>
</section>
<section>
<title>Usar GRUB</title>
<body>

<p>
Para darle parámetros al núcleo, puede pulsar <c>e</c> en el menú de
arranque. Esto le da la oportunidad de editar (presionando nuevamente
<c>e</c>) tanto el nombre del núcleo a cargar como los parámetros para
pasarle. Cuando termine la edición, pulse &lt;intro&gt; después <c>b</c>
para arrancar con los cambios.
</p>

</body>
</section>
<section>
<title>dmesg</title>
<body>

<p>
Los mensajes de arranque del núcleo y los guiones de inicio por lo general
se despliegan rápidamente. Puede que observe un error, pero se ha ido
antes de que pueda leerlo correctamente. En este caso, hay dos lugares que
puede ver después de que el sistema arranca para ver qué salió mal (y
esperemos tener una idea de cómo solucionarlo).
</p>

<p>
Si el error ocurrió mientras que el núcleo se cargaba o probando los
dispositivos de hardware, puede obtener una copia del registro del núcleo
utilizando la orden <c>dmesg</c>:
</p>

<pre caption="Obtener el registro del núcleo utilizando la orden dmesg">
Linux version 2.4.16 (root@time.flatmonk.org) (gcc version 2.95.3 20010315
(release)) #1 Sat Jan 12 19:23:04 EST 2002
</pre>

<p>
Vaya, ¡reconocemos esa línea! Es la primera que el núcleo imprime cuando
carga. En efecto, si envía por una tubería la salida de <c>dmesg</c>
a un paginador, puede ver todos los mensajes escritos por el núcleo
durante el arranque, además de los mensajes que el núcleo ha impreso en la
consola mientras tanto.
</p>

</body>
</section>
<section>
<title>/var/log/messages</title>
<body>

<p>
El segundo lugar para buscar información es el archivo
<path>/var/log/messages</path>. Este archivo lo modifica el demonio
syslog, el cual acepta entradas desde librerías, demonios, y el núcleo.
Cada línea en el archivo de mensajes tiene fecha y hora. Este archivo es
un buen lugar para buscar errores que ocurrieron durante la etapa de
arranque de los guiones de inicio. Por ejemplo, para ver los últimos
mensajes desde el servidor de nombres:
</p>

<pre caption="Usar grep en el archivo /var/log/messages">
# <i>grep named /var/log/messages | tail -3</i>
Jan 12 20:17:41 time /usr/sbin/named[350]: listening on IPv4 interface lo,
127.0.0.1#53
Jan 12 20:17:41 time /usr/sbin/named[350]: listening on IPv4 interface
eth0, 10.0.0.1#53
Jan 12 20:17:41 time /usr/sbin/named[350]: running
</pre>

</body>
</section>
<section>
<title>Información adicional</title>
<body>

<p>
Información adicional relacionada con esta sección se puede encontrar aquí:
</p>

<ul>
  <li>
    Tutorial: <uri
    link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxgrub-i.html">
    Getting to know GRUB</uri>
  </li>
  <li>
    <uri link="http://en.tldp.org/HOWTO/LILO.html">LILO Mini-HOWTO</uri>
  </li>
  <li><uri link="http://www.gnu.org/software/grub/">GRUB home</uri></li>
  <li>
    Opciones del núcleo en línea de comandos en
    <path>/usr/src/linux/Documentation/kernel-parameters.txt</path>.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Niveles de ejecución</title>
<section>
<title>Modo mono-usuario</title>
<body>

<p>
Recordemos de la sección con respecto a los gestores de arranque que es
posible pasarle parámetros al núcleo cuando arranca. Uno de los parámetros
más usados es <c>s</c>, el cual hace que el sistema inicie en modo
"mono-usuario". Este modo por lo general solo monta el sistema de archivos
raíz, inicia un subconjunto mínimo de los guiones de inicio e inicia una
interfaz de comandos en lugar de proporcionar un símbolo de espera de
órdenes de inicio. Además la red no está configurada, por lo que no hay
ninguna posibilidad de que factores externos afecten su trabajo.
</p>

</body>
</section>
<section>
<title>Entendiendo el modo mono-usuario</title>
<body>

<p>
Entonces, ¿qué "trabajo" se puede hacer con el sistema en ese estado? Para
responder a esta pregunta, debemos tener en cuenta una gran diferencia
entre Linux y Windows. Windows está diseñado para ser utilizado por lo
general por una sola persona a la vez, sentado en la consola. En efecto,
siempre está en un modo "mono-usuario". Por otro lado, Linux se utiliza
con más frecuencia para servir a las aplicaciones de red, o proveer
interfaz de comandos o sesiones de X a usuarios remotos en la red. Estas
variables adicionales no son deseables cuando se desean realizar
operaciones de mantenimiento tales como la restauración desde una copia de
seguridad, creación o modificación de sistemas de archivos, actualización
del sistema desde un CD, etc. En estos casos debe usar el modo mono-usuario.
</p>

</body>
</section>
<section>
<title>Niveles de ejecución</title>
<body>

<p>
De hecho, no es realmente necesario reiniciar para poder llegar a un modo
mono-usuario. El programa <c>init</c> gestiona el modo actual, o "nivel de
ejecución", para el sistema. Los niveles de ejecución estándar en un
sistema Linux se definen como sigue:
</p>

<ul>
  <li>0: Detener la computadora </li>
  <li>1 o s: Modo mono-usuario</li>
  <li>2: Multi-usuario, no red</li>
  <li>3: Multi-usuario, consola de texto</li>
  <li>4: Multi-usuario, consola gráfica </li>
  <li>5: El mismo que 4</li>
  <li>6: Reiniciar la computadora.</li>
</ul>

<p>
Estos niveles de ejecución varían entre las distribuciones, así que
asegúrese de consultar la documentación de su distribución.
</p>

</body>
</section>
<section>
<title>telinit</title>
<body>

<p>
Para cambiar a modo mono-usuario, use la orden <c>telinit</c>, la cual le
indica a <c>init</c> cambiar los niveles de ejecución:
</p>

<pre caption="Usar la orden telinit">
# <i>telinit 1</i>
</pre>

<p>
Puede ver en la tabla anterior que también se puede apagar o reiniciar el
sistema de esta manera. <c>telinit 0</c> detiene la computadora;
<c>telinit 6</c> reiniciará la computadora. Cuando se ejecuta la orden
<c>telinit</c> para cambiar los niveles de ejecución, un subconjunto de los
guiones <c>init</c> se ejecutarán para apagar o iniciar los servicios del
sistema.
</p>

</body>
</section>
<section>
<title>Etiqueta del nivel de ejecución</title>
<body>

<p>
Sin embargo, tenga en cuenta que esto no es de buen gusto si hay usuarios
conectados al sistema en ese momento (que se pueden enojar bastante). La
orden <c>shutdown</c> proporciona un método para cambiar los niveles de
ejecución en una manera que trata a los usuarios de un modo razonable.
Similar a la habilidad de la orden <c>kill</c> para mandar una variedad de
señales a los procesos, se puede usar <c>shutdown</c> para detener,
reiniciar, o cambiar a modo mono-usuario. Por ejemplo, para cambiar a modo
mono-usuario en 5 minutos:
</p>

<pre caption="Cambiar a modo mono-usuario con una demora de 5 minutos">
# <i>shutdown 5</i>
Broadcast message from root (pts/2) (Tue Jan 15 19:40:02 2002):
The system is going DOWN to maintenance mode in 5 minutes!
</pre>

<p>
Si pulsa &lt;control-c&gt; en ese momento, puede cancelar el cambio
pendiente a modo mono-usuario. El mensaje anterior aparecería en todas las
terminales del sistema, de modo que los usuarios tendrían una cantidad de
tiempo razonable para guardar sus trabajo y cerrar sesión. (Algunos
podrían argumentar si 5 minutos es "razonable" o no).
</p>

</body>
</section>
<section>
<title>"Now" y halt</title>
<body>

<p>
Si es la única persona en el sistema, puede usar "now" (ahora) en lugar
del argumento en minutos. Por ejemplo, para reiniciar el sistema en este
momento:
</p>

<pre caption="Usar la orden shutdown con la opción now">
# <i>shutdown -r now</i>
</pre>

<p>
No hay posibilidad de oprimir &lt;control-c&gt; en este caso, el sistema
ya se encuentra en el camino a apagarse. Por último, la opción -h detendrá
el sistema:
</p>

<pre caption="Detener el sistema">
# <i>shutdown -h 1</i>
Broadcast message from root (pts/2) (Tue Jan 15 19:50:58 2002):
The system is going DOWN for system halt in 1 minute!
</pre>

</body>
</section>
<section>
<title>El nivel de ejecución predeterminado</title>
<body>

<p>
Probablemente en este punto ha concluido que el programa <c>init</c> es
muy importante en un sistema Linux. Puede configurarlo editando el archivo
<path>/etc/inittab</path>, el cual es descrito en la página de manual
inittab(5). Solo veremos una de las líneas clave en este archivo:
</p>

<pre caption="Editar el archivo de configuración init">
# <i>grep ^id: /etc/inittab</i>
id:3:initdefault:
</pre>

<p>
En mi sistema, el nivel de ejecución 3 es el nivel de ejecución
predeterminado. Puede ser útil cambiar este valor si prefiere que su
sistema arranque de inmediato en un inicio de sesión gráfico (por lo
general el nivel de ejecución de 4 o 5). Para ello, basta con editar el
archivo y cambiar el valor de esa línea. ¡Pero cuidado! Si lo cambia a
algún valor no válido, probablemente tendrá que emplear el truco de
<c>init=/bin/sh</c> que mencioné anteriormente.
</p>

</body>
</section>
<section>
<title>Información adicional</title>
<body>

<p>
Información adicional relacionada con esta sección se puede encontrar en:
</p>

<ul>
  <li>
    <uri link=
    "http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/s1-init-boot-shutdown-init.html">
    Sysvinit docs at Red Hat</uri>
  </li>
  <li>
    <uri link="http://www.linuxdoc.org/LDP/sag/init.html">Linux System
    Administrator's Guide section on init</uri>.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Cuotas del sistema de archivos</title>
<section>
<title>Introducción a cuotas</title>
<body>

<p>
Las cuotas son una característica de Linux que permite limitar el uso del
disco por usuario o por grupo. Son útiles para impedir que cualquier
usuario o grupo use una parte injusta de un sistema de archivos, o de
llenarlo por completo. Las cuotas solo se pueden habilitase y gestionarse
por medio del superusuario. En esta sección, voy a describir cómo
configurar las cuotas en el sistema Linux y gestionarlas de manera efectiva.
</p>

</body>
</section>
<section>
<title>Apoyo del núcleo</title>
<body>

<p>
Las cuotas son una característica del sistema de archivos, por lo tanto,
requieren el apoyo del núcleo. Lo primero que hay que hacer es comprobar
que tiene soporte de cuotas en el núcleo. Puede hacerlo usando grep:
</p>

<pre caption="Comprobación de la configuración del núcleo para el soporte de cuotas">
# <i>cd /usr/src/linux</i>
# <i>grep -i quota .config</i>
CONFIG_QUOTA=y
CONFIG_XFS_QUOTA=y
</pre>

<p>
Si esta orden regresa algo menos concluyente (como CONFIG_QUOTA is not
set) entonces debe reconstruir el núcleo para incluir soporte de cuotas.
No es un proceso difícil, pero se encuentra fuera del alcance de esta
sección del tutorial. Si no está familiarizado con los pasos para
construir e instalar un nuevo núcleo, puede considerar la referencia a
este <uri link="/doc/es/articles/linux-kernel-compiling.xml">tutorial</uri>.
</p>

</body>
</section>
<section>
<title>Apoyo del sistema de archivos</title>
<body>

<p>
Antes de profundizar en la administración de cuotas, por favor, tenga en
cuenta que el soporte de cuotas en Linux en las series del núcleo 2.4.x no
está completo. Actualmente hay problemas con las cuotas en los sistemas de
archivos ext2 y ext3, y ReiserFS parece no apoyar las cuotas en absoluto.
Este tutorial basa sus ejemplos en XFS, <uri
link="http://oss.sgi.com/projects/xfs/faq.html#quotaswork">support quotas
</uri>, que parece soportar cuotas apropiadamente.
</p>

</body>
</section>
<section>
<title>Configurar cuotas</title>
<body>

<p>
Para comenzar a configurar las cuotas en el sistema, debe editar
<path>/etc/fstab</path> para montar los sistemas de archivos afectados con
cuotas habilitadas. Para nuestro ejemplo, usamos un sistema de archivos
XFS montado con cuotas habilitadas para usuario y grupo:
</p>

<pre caption="Configurar cuotas">
# <i>grep quota /etc/fstab</i>
/usr/users   /mnt/hdc1    xfs    usrquota,grpquota,noauto   0 0
# <i>mount /usr/users</i>
</pre>

<p>
Tenga en cuenta que las opciones usrquota y grpquota no necesariamente
habilitan cuotas en el sistema de archivos. Puede asegurarse de que las
cuotas se habiliten usando la orden <c>quotaon</c>:
</p>

<pre caption="Habilitar cuotas">
# <i>quotaon /usr/users</i>
</pre>

<p>
Hay una orden correspondiente <c>quotaoff</c> si desea deshabilitar las
cuotas en el futuro:
</p>

<pre caption="Deshabilitar quotas">
# <i>quotaoff /usr/users</i>
</pre>

<p>
Pero por el momento, si está intentando algunos de los ejemplos de este
tutorial, asegúrese de tener cuotas habilitadas.
</p>

</body>
</section>
<section>
<title>La orden quota</title>
<body>

<p>
La orden <c>quota</c> muestra el uso del disco de un usuario y los límites
para todos los sistemas de archivos montados actualmente. La opción -v
incluye en la lista los sistemas de archivos donde las cuotas están
habilitadas, pero no el almacenamiento que está asignado para el usuario.
</p>

<pre caption="Usar la orden quota">
# <i>quota -v</i>

Disk quotas for user root (uid 0):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
/dev/hdc1       0       0       0               3       0       0
</pre>

<p>
La primera columna, "blocks", muestra la cantidad de espacio en disco que el
superusuario está utilizando en cada sistema de archivos en la lista. Las
siguientes columnas, "quote" y "limit", hacen referencia a los límites
vigentes del espacio en disco. Vamos a explicar la diferencia entre cuota
y límite, y el significado de la columna "grace" después. La columna "files"
muestra el número de archivos que le pertenecen al superusuario en el
sistema de archivos particular. Las siguientes columnas "quota" y "limit" se
refieren al límite de los archivos.
</p>

</body>
</section>
<section>
<title>Ver la cuota</title>
<body>

<p>
Cualquier usuario puede utilizar la orden <c>quota</c> para ver su propio
reporte de cuota como se muestra en el ejemplo anterior. Sin embargo, solo
el superusuario puede ver las cuotas de otros usuarios y grupos. Por
ejemplo, digamos que tenemos un sistema de archivos, <path>/dev/hdc1</path>
montado en <path>/usr/users</path>, con dos usuarios: jane y john.
Primero, veamos los límites y el espacio de disco utilizado por jane.
</p>

<pre caption="Ver la cuota para un usuario">
# <i>quota -v jane</i>

Disk quotas for user jane (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
/dev/hdc1    4100       0       0               6       0       0
</pre>

<p>
En este ejemplo, podemos ver que las cuotas de jane están definidas como
cero, lo que indica que no tiene un límite.
</p>

</body>
</section>
<section>
<title>edquota</title>
<body>

<p>
Ahora digamos que queremos darle al usuario jane una cuota. Haremos esto
con la orden <c>edquota</c>. Antes de comenzar a editar las cuotas, veamos
cuanto espacio disponible hay disponible en <path>/usr/users</path>:
</p>

<pre caption="Revisar el espacio disponible en /usr/users">
# <i>df /usr/users</i>

Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hdc1               610048      4276    605772   1% /usr/users
</pre>

<p>
Este no es un sistema de archivos particularmente grande, solo 600 MB
aproximadamente. Parece prudente darle a jane una cuota para que no pueda
usar más de una parte justa. Cuando ejecuta <c>edquota</c>, se crea un
archivo temporal para cada uno de los usuarios o grupos que especifica en
la línea de comandos.
</p>

<p>
La orden <c>edquota</c> lo envía a un editor, el cual lo habilita para
agregar y/o modificar cuotas por medio de este archivo temporal.
</p>

<pre caption="Modificar cuota">
# <i>edquota jane</i>

Disk quotas for user jane (uid 1003):
Filesystem         blocks       soft       hard     inodes     soft     hard
/dev/hdc1           4100          0          0          6        0        0
</pre>

<p>
Parecido a la salida de la orden <c>quota</c> de arriba, las columnas
"block" e "inodes" en este archivo temporal hacen referencia al espacio del
disco y el número de archivos que jane está utilizando. No puede modificar
el número de bloques o inodos, cualquier intento de hacerlo será
descartado por el sistema. Las columnas "soft" y "hard" muestran la cuota
de jane, la cual podemos ver actualmente como ilimitada (de nuevo, cero
indica que no hay una cuota).
</p>

</body>
</section>
<section>
<title>Entendiendo edquota</title>
<body>

<p>
El límite soft es la cantidad máxima de uso de disco que jane ha asignado
para su sistema (en otras palabras, su cuota). Si jane utiliza más espacio
de disco del que está asignado a su límite soft, se emitirán advertencias
sobre su violación de cuotas vía correo electrónico. El límite hard indica
el límite absoluto del uso del disco, que el usuario no puede exceder. Si
jane trata de usar más espacio en disco del que está especificado en el
límite hard, recibirá un error "Límite de cuota excedido" ("Disk quota
exceeded") y no podrá completar la operación.
</p>

</body>
</section>
<section>
<title>Hacer cambios</title>
<body>

<p>
Así que aquí cambiamos los límites soft y hard de Jane y guardamos el
archivo:
</p>

<pre caption="Cambiar los límites soft y hard">

Disk quotas for user jane (uid 1003):
Filesystem         blocks       soft       hard     inodes     soft     hard
/dev/hdc1           4100      10000      11500          6     2000     2500
</pre>

<p>
Al ejecutar la orden <c>quota</c>, podemos inspeccionar las modificaciones:
</p>

<pre caption="Revisar la cuota para el usuario jane">
# <i>quota jane</i>

Disk quotas for user jane (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
/dev/hdc1    4100   10000   11500               6    2000    2500
</pre>

</body>
</section>
<section>
<title>Copiar cuotas</title>
<body>

<p>
Recordará que también tenemos otro usuario en este sistema de archivos,
john. Si quiere darle a john la misma cuota a que le dio a jane, podemos
usar la opción -p en <c>edquota</c>, la cual utiliza las cuotas de jane
como un prototipo para los siguientes usuario en la línea de comandos. Es
una manera fácil de definir cuotas para los grupos de usuarios.
</p>

<pre caption="Copiar quotas">
# <i>edquota -p jane john</i>
# <i>quota john</i>

Disk quotas for user john (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
/dev/hdc1       0   10000   11500               1    2000    2500
</pre>

</body>
</section>
<section>
<title>Restricciones de los grupos</title>
<body>

<p>
También podemos usar <c>edquota</c> para restringir la asignación del
espacio en disco basados en la propiedad de grupo de los archivos. Por
ejemplo, para editar las cuotas para el grupo users:
</p>

<pre caption="Editar cuotas para el grupo users">
# <i>edquota -g users</i>
Disk quotas for group users (gid 100):
Filesystem blocks soft hard inodes soft hard
/dev/hdc1 4100 500000 510000 7 100000 125000
</pre>

<p>
A continuación, para ver las cuotas modificadas para el grupo users
</p>

<pre caption="Ver las cuotas modificadas">
# <i>quota -g users</i>
Disk quotas for group users (gid 100):
Filesystem blocks quota limit grace files quota limit grace
/dev/hdc1 4100 500000 510000 7 100000 125000
</pre>

</body>
</section>
<section>
<title>La orden repquota</title>
<body>

<p>
Ver las cuotas de cada uno de los usuarios utilizando la orden <c>quota</c>
puede ser tedioso si hay muchos usuarios dentro del sistema de archivos.
La orden <c>repquota</c> resume las cuotas de un sistema de archivos en un
lindo reporte. Por ejemplo para ver las cuotas para todos los usuarios y
grupos en <path>/usr/users</path>:
</p>

<pre caption="Resumir cuotas">
# <i>repquota -ug /usr/users</i>
*** Report for user quotas on device /dev/hdc1
Block grace time: 7days; Inode grace time: 7days
Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --       0       0       0              3     0     0
john      --       0   10000   11500              1  2000  2500
jane      --    4100   10000   11500              6  2000  2500

*** Report for group quotas on device /dev/hdc1
Block grace time: 7days; Inode grace time: 7days
Block limits             File limits
Group           used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --       0       0      0               3     0     0
users     --    4100  500000 510000               7 100000 125000
</pre>

</body>
</section>
<section>
<title>Opciones de repquota</title>
<body>

<p>
Hay un par de opciones más para repquota que vale la pena mencionar.
<c>repquota -a</c> informará sobre todos los sistemas de archivos de lectura
y escritura montados que tienen cuotas habilitadas. <c>repquota -n</c> no
resolverá uids y gids para los nombres. Esto aumentará la velocidad de la
salida para listas grandes.
</p>

</body>
</section>
<section>
<title>Monitorizar cuotas</title>
<body>

<p>
Si es administrador de un sistema, debe tener un modo de monitorizar las
cuotas para asegurarse de que no están siendo excedidas. Una manera fácil
de hacer esto es usar <c>warnquota</c>. La orden <c>warnquota</c> envía un
correo electrónico a los usuarios que han excedido su límite soft. Por lo
general <c>warnquota</c> se ejecutará como un trabajo preprogramado bajo
el control del demonio cron.
</p>

<p>
Cuando un usuario excede su límite soft, la columna grace en la salida de
la orden <c>quota</c> le indicará el periodo de gracia, es decir el tiempo
antes de que el sistema de archivos force el límite soft.

</p>

<pre caption="Revisar el periodo de gracia">
Disk quotas for user jane (uid 1003):
Filesystem  blocks   quota   limit   grace   files   quota   limit
grace
/dev/hdc1   10800*  10000   11500    7days      7     2000    2500
</pre>

<p>
De manera predeterminada, el periodo de gracia para bloques e inodos es de
siete días.
</p>

</body>
</section>
<section>
<title>Modificar el período de gracia</title>
<body>

<p>
Puede modificar el período de gracia para el sistema de archivos utilizando
<c>equota</c>:
</p>

<pre caption="Modificar el período de gracia">
# <i>edquota -t</i>
</pre>

<p>
Esto lo coloca en el editor de un archivo temporal parecido a esto:
</p>

<pre caption="Vista del editor grace">
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem             Block grace period     Inode grace period
/dev/hdc1                    7days                  7days
</pre>

<p>
El texto en el archivo es muy explicativo. ¡Asegúrese de darle a los
usuarios el tiempo suficiente para recibir su correo electrónico de
advertencia y encontrar algunos archivos para eliminar!
</p>

</body>
</section>
<section>
<title>Revisar cuotas en el arranque</title>
<body>

<p>
También es posible que desee revisar las cuotas en el arranque. Puede
hacer esto utilizando un guión para ejecutar la orden <c>quotacheck</c>;
hay un guión de ejemplo en <uri
link="http://en.tldp.org/HOWTO/Quota.html">Quota Mini HOWTO</uri>. La
orden <c>quotacheck</c> también tiene la habilidad de reparar archivos de
cuota dañados; familiarícese con ella leyendo la página de manual de
quotacheck(8).
</p>

<p>
También recuerde lo que mencionamos anteriormente sobre <c>quotaon</c> y
<c>quotaoff</c>. Debe incorporar <c>quotaon</c> en su guión de arranque
para que las cuotas se habiliten. Para habilitar las cuotas en todos los
sistemas de archivos donde las cuotas son compatibles, utilice la opción
-a:
</p>

<pre caption="Usar la opción -a">
# <i>quotaon -a</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Registros del sistema</title>
<section>
<title>Introducción a syslogd</title>
<body>

<p>
El demonio syslog ofrece un mecanismo maduro de cliente-servidor para el
registro de mensajes desde programas ejecutándose en el sistema. Syslog
recibe un mensaje desde un demonio o programa, categoriza el mensaje por
prioridad y tipo, entonces lo registra de acuerdo a las reglas
configurables por el administrador. El resultado es un enfoque robusto y
unificado para la gestión de registros.
</p>

</body>
</section>
<section>
<title>Leer registros</title>
<body>

<p>
Saltemos justo ahí y veamos el contenido de un archivo de registro grabado
por syslog. El FHS (vea <uri link=
"/doc/es/articles/lpi-101-administration-p2.xml">Parte 2</uri> de esta
serie de tutoriales) indica que los archivos de registro deben estar en
<path>/var/log</path>. Aquí usamos la orden <c>tail</c> para desplegar las
últimas 10 líneas en el archivo "messages":
</p>

<pre caption="Leer registros">
# <i>cd /var/log</i>
# <i>tail messages</i>
Jan 12 20:17:39 bilbo init: Entering runlevel: 3
Jan 12 20:17:40 bilbo /usr/sbin/named[337]: starting BIND 9.1.3
Jan 12 20:17:40 bilbo /usr/sbin/named[337]: using 1 CPU
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: loading configuration from
'/etc/bind/named.conf'
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: no IPv6 interfaces found
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: listening on IPv4 interface
lo, 127.0.0.1#53
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: listening on IPv4 interface
eth0, 10.0.0.1#53
Jan 12 20:17:41 bilbo /usr/sbin/named[350]: running
Jan 12 20:41:58 bilbo gnome-name-server[11288]: starting
Jan 12 20:41:58 bilbo gnome-name-server[11288]: name server starting
</pre>

<p>
Puede que recuerde del curso exprés de procesamiento de texto que la orden
<c>tail</c> muestra las últimas líneas de un archivo. En este caso,
podemos ver que el servidor de nombres named se inicializó
recientemente en este sistema, el cual se llama bilbo. Si estuviéramos
implementando IPv6, se puede notar que named no encontró las interfaces de
IPv6, lo que indica un problema potencial. Además, podemos ver que un
usuario puede haber iniciado recientemente GNOME, indicado por la
presencia de gnome-name-server.
</p>

</body>
</section>
<section>
<title>Usar tail con archivos de registro</title>
<body>

<p>
Un administrador de sistemas con experiencia puede utilizar <c>tail -f</c>
para dirigir la salida a un archivo de registro tal como se presenta:
</p>

<pre caption="Usar la orden tail -f">
# <i>tail -f /var/log/messages</i>
</pre>

<p>
Por ejemplo, en caso de depurar nuestro problema teórico del IPv6,
ejecutar la orden de arriba en una terminal mientras detiene e inicia
named desplegará inmediatamente los mensajes desde ese demonio. Puede ser
una técnica útil mientras depura. Algunos administradores incluso
mantienen en ejecución constante los mensajes <c>tail -f</c> en una
terminal donde pueden vigilar los eventos del sistema.
</p>

</body>
</section>
<section>
<title>Hacer grep a los registros</title>
<body>

<p>
Otra técnica útil es buscar un archivo de registro utilizando la utilidad
<c>grep</c>, descrita en la <uri link=
"/doc/es/articles/lpi-101-administration-p2.xml">Parte 2</uri> de esta
serie de tutoriales. En el caso de arriba, podemos usar grep para
encontrar donde ha cambiado el comportamiento de "named":
</p>

<pre caption="Hacer grep a los registros">
# <i>grep named /var/log/messages</i>
</pre>

</body>
</section>
<section>
<title>Resumen de registros</title>
<body>

<p>
Lo siguiente resume los archivos de registros generalmente encontrados en
<path>/var/log</path> y mantenidos por syslog:
</p>

<ul>
  <li>
    <path>messages</path>: Mensajes de información y de errores desde los
    programas y demonios del sistema general.
  </li>
  <li>
    <path>secure</path>: Mensajes y errores de autenticación,
    manténgalos separados de <path>messages</path> para seguridad extra.
  </li>
  <li><path>maillog</path>: Mensajes relacionados al correo y errores.</li>
  <li><path>cron</path>: Mensajes relacionados con Cron y errores.</li>
  <li>
    <path>spooler</path>: Mensajes relacionados con noticias y UUCP y
    errores.
  </li>
</ul>

</body>
</section>
<section>
<title>syslog.conf</title>
<body>

<p>
A decir verdad, ahora sería un buen momento para investigar el archivo de
configuración de syslog, <path>/etc/syslog.conf</path>. (Nota: Si no tiene
<path>syslog.conf</path>, siga leyendo en aras de la información ya que
puede estar utilizando un demonio syslog alternativo). Buscando ese
archivo, veremos que hay entradas para cada uno de los archivos de
registro comunes mencionados arriba, además de posiblemente otras
entradas. El archivo tiene el formato facility.priority action, donde los
campos se definen de la siguiente manera:
</p>

<p>
facility (instalación): Especifica el subsistema que produjo el mensaje.
Las palabras clave válidas para facility son auth, authpriv, cron, daemon,
kern, lpr, mail, news, syslog, user, uucp y local0 hasta local7.
</p>

<p>
priority (prioridad): Especifica la gravedad mínima del mensaje, lo que
significa que los mensajes de esta y mayor prioridad coincidirán con esta
regla. Las palabras clave válidas para priority son debug, info, notice,
warning, err, crit, alert, y emerg.
</p>

<p>
action (acción): El campo action puede ser un nombre de archivo, tty
(tal como <path>/dev/console</path>), una máquina remota con el prefijo @,
una lista de usuarios separados por coma, o el envío del mensaje a todos
los que han iniciado sesión. La acción mas común es un simple nombre de
archivo.
</p>

</body>
</section>
<section>
<title>Recarga e información adicional</title>
<body>

<p>
Esperamos que este resumen del archivo de configuración le ayude a tener
noción de la fortaleza del sistema syslog. Debería leer la página de
manual syslog.conf(5) para más información antes de realizar cambios. De
forma adicional, la página de manual de syslogd(8) brinda información
mucho más detallada.
</p>

<p>
Tome en cuenta que necesita informar al demonio syslog de los cambios del
archivo de configuración antes de que se pongan en práctica. Enviar una
señal SIGHUP es el método correcto, y puede utilizar la orden
<c>killall</c> para hacerlo fácilmente:
</p>

<pre caption="Usar la orden killall">
# <i>killall -HUP syslogd</i>
</pre>

</body>
</section>
<section>
<title>Una nota de seguridad</title>
<body>

<p>
Debe tener cuidado ya que syslogd creará sus archivos de registro si no
existen. Independientemente de su configuración actual de umask, los
archivos se crearán para que todo el mundo los pueda leer. Si le preocupa
la seguridad, debe aplicar chmod a los archivos para que solo el
superusuario pueda leer y escribir en estos archivos. Además, el programa
<c>logrotate</c> (descrito más adelante) se puede configurar para crear
nuevos archivos de registro con los permisos apropiados. El demonio syslog
siempre conserva los atributos actuales de un archivo de registro existente,
así que no tiene por que preocuparse una vez que se ha creado el archivo.
</p>

</body>
</section>
<section>
<title>logrotate</title>
<body>

<p>
Los archivos de registro en <path>/var/log</path> crecerán con el tiempo,
y potencialmente pueden llenar el sistema de archivos. Es recomendable
emplear un programa como <c>logrotate</c> para gestionar el archivado
automático de los registros. El programa <c>logrotate</c> usualmente se
ejecuta como una tarea diaria controlada por el demonio cron, y se puede
configurar para rotar, comprimir, eliminar o enviar por correo los
archivos de registro.
</p>

<p>
Por ejemplo, una configuración predeterminada de logrotate puede rotar los
registros semanalmente, manteniendo cuatro semanas el valor de los
registros anteriores (agregando un número secuencial al nombre del
archivo), y comprimir los registros anteriores para ahorrar espacio.
Además, el programa se puede configurar para que envíe una señal SIGHUP a
syslogd de modo que el demonio sepa que los archivos de registro están
ahora vacíos y los debe ligar apropiadamente.
</p>

<p>
Para más información sobre <c>logrotate</c>, consulte la página de manual
logrotate(8), que contiene una descripción del programa y la sintaxis del
archivo de configuración.
</p>

</body>
</section>
<section>
<title>Tema avanzado, klogd</title>
<body>

<p>
Antes de alejarnos de syslog, me gustaría señalar un par de temas
avanzados para los lectores ambiciosos. Estos consejos pueden ahorrarle
algo de dolor cuando intente entender temas relacionados a syslog.
</p>

<p>
En primer lugar, el demonio syslog es en realidad parte del paquete
sysklogd, el cual contiene un segundo demonio llamado klogd. El trabajo de
klogd es recibir información y mensajes de error desde el núcleo, y
pasarlos a syslogd para la clasificación y registro. Los mensajes
recibidos por klogd son exactamente los mismos que puede recuperar con la
orden <c>dmesg</c>. La diferencia es que <c>dmesg</c> imprime el contenido
actual de un búfer de anillo en el núcleo, mientras que klogd está pasando
los mensajes a syslog para que no se pierdan cuando el anillo se envuelve.
</p>

</body>
</section>
<section>
<title>Tema avanzado, gestores de registro de actividades alternativos
</title>
<body>

<p>
En segundo lugar, hay alternativas al paquete estándar sysklogd. Las
alternativas intentan ser más eficientes, fáciles de configurar, y
posiblemente con más características que el paquete sysklogd. <uri
link="http://www.balabit.hu/en/downloads/syslog-ng/">Syslog-ng</uri> y
<uri link="http://metalog.sourceforge.net/">Metalog</uri> parecen ser
algunas de las alternativas más populares; puede investigarlas si
descubre que sysklogd no le ofrece el poder que requiere.
</p>

<p>
En tercer lugar, puede registrar los mensajes en sus guiones usando la
orden logger. Vea la página de manual logger(1) para más información.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Resumen y bibliografía</title>
<section>
<title>Resumen</title>
<body>

<p>
¡Felicidades, ha llegado al final de este tutorial! Bueno, casi. Hay un
par de temas que no hemos podido incluir en nuestros primeros cuatro
tutoriales debido a las limitaciones de espacio. Afortunadamente, tenemos
un buen par de recursos que lo ayudarán a ponerse al día sobre estos temas
en poco tiempo. Asegúrese de cubrir estos tutoriales, en particular si está
planeando obtener su certificación LPIC nivel 1.
</p>

<p>
No teníamos espacio suficiente en este tutorial para cubrir el importante
tema del respaldo de sistemas. Afortunadamente, IBM developerWorks ya
cuenta con un tutorial sobre este tema, llamado <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxbu-i.html">
Backing up your Linux machines</uri>. En este tutorial, aprenderá como
respaldar sistemas Linux usando una variante de <c>tar</c> llamada star.
Además aprenderá cómo usar la orden <c>mnt</c> para controlar las funciones
tape.
</p>

<p>
El segundo tema que no fuimos capaces de integrar fue la planificación
periódica. Afortunadamente, hay buena documentación de <uri link=
"http://www.ussg.iu.edu/usail/automation/cron.html">cron</uri> disponible
en la Universidad de Indiana. <c>cron</c> se utiliza para programar los
trabajos para que se ejecuten en un momento determinado, y es una
herramienta importante para cualquier administrador de sistemas.
</p>

<p>
Más abajo, encontrará una serie de recursos que le serán útiles para
aprender más sobre los temas presentados en este tutorial.
</p>

</body>
</section>
<section>
<title>Bibliografía</title>
<body>

<p>
Para obtener más información sobre el soporte de cuotas en Linux,
asegúrese de revisar el <uri
link="http://en.tldp.org/HOWTO/Quota.html">Linux Quota mini-HOWTO</uri>.
También asegúrese de consultar las páginas de manual quota(1), edquota(8),
repquota(8), quotacheck(8), y quotaon(8) en su sistema.
</p>

<p>
Información adicional del proceso de arranque del sistema y de los
gestores de arranque se puede encontrar en:
</p>

<ul>
  <li>
    El tutorial de IBM developerWorks <uri
    link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxgrub-i.html">
    Getting to know GRUB</uri>
  </li>
  <li>
    <uri link="http://en.tldp.org/HOWTO/LILO.html">LILO Mini-HOWTO</uri>
  </li>
  <li><uri link="http://www.gnu.org/software/grub/">GRUB home</uri></li>
  <li>
    Opciones del núcleo en línea de comandos en
    <path>/usr/src/linux/Documentation/kernel-parameters.txt</path>
  </li>
  <li>
    <uri link=
    "http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/s1-init-boot-shutdown-init.html">
    Sysvinit docs at Redhat</uri>.
  </li>
</ul>

<p>
Para obtener más información acerca de los sistemas de archivos Linux, lea
la guía avanzada de múltiples partes del implementador del sistema de
archivos en la zona Linux de IBM developerWorks, que abarca:
</p>

<ul>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs.html">
    The benefits of journalling and ReiserFS (Part 1)</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs2.html">
    Setting up a ReiserFS system (Part 2)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs3.html">
    Using the tmpfs virtual memory filesystem and bind mounts (Part 3)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs4.html">
    The benefits of devfs, the device management filesystem (Part 4)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/library/l-fs5.html">
    Beginning the conversion to devfs (Part 5)</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">
    Completing the conversion to devfs using an init wrapper (Part 6)</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/afig-ct-ext3-intro.xml">Guía avanzada de
    implementación de Sistemas de Ficheros: Introducción a ext3</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/l-afig-p8.xml">Guía avanzada de
    implementación de Sistemas de Ficheros, Parte 8</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/linux/library/l-fs9.html">
    An introduction to XFS (Part 9)</uri>.
  </li>
</ul>

<p>
Para más información sobre particionamiento, echar un vistazo a los
siguientes consejos sobre particionamiento en la zona Linux de IBM
developerWorks:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/partition-planning-tips.xml">Planificación
    de Particiones</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/partitioning-p1.xml">Particionamiento en
    acción, Parte 1</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/partitioning-p2.xml">Particionamiento en
    acción, Parte 2</uri>.
  </li>
</ul>

<p>
Bibliografía de ReiserFS:
</p>

<ul>
  <li><uri link="http://www.namesys.com/">The home of ReiserFS</uri></li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs.html">
    Advanced filesystem implementor's guide, Part 1: Journalling and
    ReiserFS on developerWorks</uri>
  </li>
  <li>
    <uri
    link="http://www-106.ibm.com/developerworks/library/l-fs2.html">
    Advanced filesystem implementor's guide, Part 2: Using ReiserFS and
    Linux 2.4 on developerWorks</uri>.
  </li>
</ul>

<p>
Bibliografía de ext3:
</p>

<ul>
  <li>
    <uri link="http://www.zip.com.au/~akpm/linux/ext3/">Andrew Morton's ext3
    page</uri>
  </li>
  <li>
    <uri link="http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html">
    Andrew Morton's excellent ext3 usage documentation (recommended).</uri>
  </li>
</ul>

<p>
Bibliografía de XFS y JFS:
</p>

<ul>
  <li>
    <uri link="http://oss.sgi.com/projects/xfs">SGI XFS projects page</uri>
  </li>
  <li>
    <uri link="http://www-124.ibm.com/developerworks/oss/jfs/index.html">
    JFS project Web site</uri> de IBM.
  </li>
</ul>

<p>
No olvide <uri link="http://en.tldp.org/">linuxdoc.org</uri>. Encontrará
su colección de guías, COMOs, FAQs, y páginas de manual como un recurso
invaluable. Revise también
<uri link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri> y
<uri link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>.
</p>

<p>
La guía del administrador de sistemas Linux, disponible en <uri
link="http://en.tldp.org/guides.html">Linuxdoc.org's "Guides" section
</uri>, es un buen complemento a esta serie de tutoriales, ¡Léalo!.
También
<uri link="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">
Unix and Internet Fundamentals HOWTO</uri> de Eric S. Raymond le será de
gran ayuda.
</p>

<p>
En la serie de artículos “Bash con ejemplos” de developerWorks, Daniel le
muestra cómo usar los programas constructores de bash para escribir sus
propios guiones de bash. Esta serie (particularmente la parte 1 y 2) será
una buena preparación para el examen LPIC nivel 1:
</p>

<ul>
  <li>
    <uri
    link="http://www.gentoo.org/doc/en/articles/bash-by-example-p1.xml">
    Bash con ejemplos, parte 1: Programación fundamental en la "Bourne again
    shell" (bash).</uri>
  </li>
  <li>
    <uri
    link="http://www.gentoo.org/doc/en/articles/bash-by-example-p2.xml">
    Bash con ejemplos, parte 2: Más fundamentos de programación en bash.</uri>
  </li>
  <li>
    <uri
    link="http://www.gentoo.org/doc/en/articles/bash-by-example-p3.xml">
    Bash con ejemplos, parte 3: Explorando el sistema de ebuilds.</uri>
  </li>
</ul>

<p>
Recomendamos ampliamente el <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/">Technical
FAQ by Linux Users</uri> de Mark Chapman, un listado de 50 páginas que
muestran la lista de preguntas más frecuentes de Linux con respuestas
detalladas. El FAQ es un archivo formato PDF (Acrobat). Si es un usuario
Linux principiante o intermedio, definitivamente debe revisar este FAQ.
También recomendamos el <uri link=
"http://www-106.ibm.com/developerworks/linux/library/l-gloss/index.html">
Linux glossary for Linux users</uri>, también de Mark.
</p>

<p>
Si no está familiarizado con el editor vi, revise <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">Vi
intro -- the cheat sheet method tutorial</uri> de Daniel. Este tutorial le
dará una gentil y rápida introducción a este poderoso editor de texto.
Considere este material como un "debe leer" si desconoce cómo utilizar vi.
</p>

</body>
</section>
<section>
<title>Comentarios</title>
<body>

<p>
Por favor envíe cualquier comentario acerca de este tutorial a los autores:
</p>

<ul>
  <li>Daniel Robbins, en <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, en <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, en <mail>agriffis@gentoo.org</mail>.</li>
</ul>

</body>
</section>
</chapter>
</guide>
