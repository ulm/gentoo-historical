<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/articles/lpi-101-intermediate-p3.xml,v 1.2 2011/09/09 17:03:57 nimiux Exp $-->

<guide disclaimer="articles" lang="es">
<title>Preparación para el examen de certificación 101 del LPI (segundo
lanzamiento), Parte 3</title>

<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autor">
  <mail link="chouser@gentoo.org">Chris Houser</mail>
</author>
<author title="Autor">
  <mail link="agriffis@gentoo.org">Aron Griffis</mail>
</author>
<author title="Traductora">
  <mail link="nilda_46@hotmail.com">Nilda Gabriela Villanueva Chacón</mail>
</author>

<abstract>
En este tutorial le daremos una introducción a la documentación del sistema
Linux. Le mostraremos cómo cambiar permisos y cómo manejar las cuentas
Linux. Al final aprenderá como ajustar su entorno.
</abstract>

<!-- La vesión original de este artículo fue publicada en IBM developerWorks,
y es propiedad de Westtech Information Services. Este documento es una
versión actualizada del artículo original, y contiene varias mejoras
realizadas por el Equipo de Documentación de Gentoo Linux -->

<version>1.1</version>
<date>2007-06-20</date>

<chapter>
<title>Antes de comenzar</title>
<section>
<title>Acerca de este tutorial</title>
<body>

<p>
Bienvenido a "Administración intermedia", el tercero de cuatro tutoriales
diseñado para prepararlo para el examen 101 del Instituto Profesional de
Linux (LPI por sus siglas en inglés). Este tutorial (parte 3) es ideal para
quienes quieren mejorar su conocimiento de los fundamentos de
administración Linux. Cubriremos una variedad de tópicos, incluyendo
documentación del sistema y de Internet, el modelo de permisos Linux,
manejo de cuentas de usuario y el ajuste de su entorno de inicio.
</p>

<p>
Si es nuevo en Linux, le recomendamos que inicie con la <uri link=
"/doc/es/articles/lpi-101-fundamentals-p1.xml">Parte 1</uri> y la
<uri link="/doc/es/articles/lpi-101-administration-p2.xml">Parte 2</uri>.
Para algunos, este material será nuevo, pero los usuarios Linux más
experimentados encontrarán en este tutorial una buena manera de
complementar sus conocimientos básicos de administración Linux.
</p>

<p>
Al final de esta serie de tutoriales (ocho en total, cubriendo los exámenes
101 y 102), tendrá el conocimiento necesario para ser un administrador de
sistemas Linux y estará listo para obtener una certificación LPIC nivel 1
del Instituto de Profesionales Linux si usted lo desea.
</p>

<p>
Para aquellos que han tomado la <uri 
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxlpi3-i.html">
release 1 version</uri> de este tutorial por razones
diferentes a la preparación para el examen LPI, probablemente no sea
necesario tomar esta versión. Sin embargo, si planea presentarse a los
exámenes, debe considerar seriamente leer este tutorial.
</p>

</body>
</section>
<section>
<title>Acerca de los autores</title>
<body>

<p>
Para preguntas técnicas acerca del contenido de este tutorial, puede
contactar con los autores:
</p>

<ul>
  <li>Daniel Robbins, en <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, en <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, en <mail>agriffis@gentoo.org</mail></li>
</ul>

<p>
Con residencia en Albuquerque, Nuevo Mexico, Daniel Robbins es el
arquitecto en jefe de <uri link="http://www.gentoo.org/">Gentoo Linux</uri>,
una metadistribución Linux avanzada basada en puertos (ports). Además
escribe artículos, tutoriales y sugerencias para IBM developerWorks zona
Linux y servicios de desarrollo Intel. También ha contribuido como autor de
muchos libros, incluyendo Samba y SuSE Unleashead. Daniel disfruta pasar
tiempo con su esposa Mary y su hija Hadassha. Puede contactar con Daniel en
<mail>drobbins@gentoo.org</mail>.
</p>

<p>
Chris Houser, conocido por sus amigos como "Chouser," ha sido un
partidario de UNIX desde 1994 cuando se unió al equipo de
administración de la red de informática en la Universidad Taylor en
Indiana, donde obtuvo su licenciatura en Ciencias de la Computación y
Matemáticas. Desde entonces ha trabajado en programación de
aplicaciones web, diseño de interfaz de usuario, soporte para
programas de vídeo profesional y ahora programando el controlador del
dispositivo Tru4 UNIX en <uri link="http://www.compaq.com/">Compaq</uri>.
Además ha contribuido en varios proyectos de programas libres
(recientemente en <uri link="http://www.gentoo.org/">Gentoo Linux</uri>).
Vive con su esposa y dos gatos en New Shapire. Puede contactar con él en
<mail>chouser@gentoo.org</mail>.
</p>

<p>
Aron Griffis, graduado de la Universidad Taylor con título en Ciencias de
la Computación y premiado con el título "Futuro fundador de una comunidad
UNIX utópica". Trabajando para conseguir ese objetivo Aron es empleado de
<uri link="http://www.compaq.com/">Compaq</uri>, escribe controladores de
red para Tru64 UNIX y utiliza su tiempo libre tocando melodías en el piano
o desarrollando <uri link="http://www.gentoo.org/">Gentoo Linux</uri>. Vive
con su esposa Amy (también ingeniera UNIX) en Nashua, New Hampshire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Documentación de red y del sistema</title>
<section>
<title>Tipos de documentación del sistema Linux</title>
<body>

<p>
Existen esencialmente tres fuentes de documentación en un sistema Linux:
páginas del manual, páginas de información y documentación incluida en las
aplicaciones en <path>/usr/share/doc</path>. En esta sección, exploraremos
cada una de esas fuentes antes de buscar más información "fuera de la caja".
</p>

</body>
</section>
<section>
<title>Páginas de manual</title>
<body>

<p>
Las página de manual, o "man pages" (en inglés), son la forma clásica de la
documentación de referencia de UNIX y Linux. Idealmente, puede consultar en
las páginas de manual cualquier orden, archivo de configuración o rutina de
librería. En la práctica Linux es software libre y algunas páginas aún
no han sido escritas o demuestran su edad. Sin embargo, las páginas de
manual son el primer lugar en donde buscar cuando necesite ayuda.
</p>

<p>
Para acceder a las páginas de manual, simplemente teclee <c>man</c> seguido
por el tema de su investigación. Un localizador comenzará, por lo que
necesita presionar <c>q</c> cuando termine de leer. Por ejemplo, para
buscar información acerca de la orden <c>ls</c>, puede teclear:
</p>

<pre caption="Buscando en páginas del manual">
$ <i>man ls</i>
</pre>

<p>
Conocer la estructura de una página de manual puede ser útil para acceder
rápidamente a la información que necesita. En general encontrará las
siguientes secciones dentro de una página <c>man</c>:
</p>

<table>
<tr>
  <ti>NAME</ti>
  <ti>Nombre y descripción de la orden en una línea</ti>
</tr>
<tr>
  <ti>SYNOPSIS</ti>
  <ti>Cómo utilizar la orden</ti>
</tr>
<tr>
  <ti>DESCRIPTION</ti>
  <ti>Discusión a fondo sobre la funcionalidad de la orden</ti>
</tr>
<tr>
  <ti>EXAMPLES</ti>
  <ti>Sugerencias de cómo utilizar la orden</ti>
</tr>
<tr>
  <ti>SEE ALSO</ti>
  <ti>Tópicos relacionados (normalmente páginas de manual)</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Secciones de las páginas de manual</title>
<body>

<p>
Los archivos que componen las páginas de manual se almacenan en <path>
/usr/share/man</path> (o en <path>/usr/man</path> en algunos sistemas
antiguos). Dentro de ese directorio, puede encontrar que las páginas de
manual están organizadas en las siguientes secciones:
</p>

<table>

<tr>
  <ti>man1</ti>
  <ti>Programas de usuario</ti>
</tr>
<tr>
  <ti>man2</ti>
  <ti>Llamadas al sistema</ti>
</tr>
<tr>
  <ti>man3</ti>
  <ti>Funciones de librerías</ti>
</tr>
<tr>
  <ti>man4</ti>
  <ti>Archivos especiales</ti>
</tr>
<tr>
  <ti>man5</ti>
  <ti>Formatos de archivo</ti>
</tr>
<tr>
  <ti>man6</ti>
  <ti>Juegos</ti>
</tr>
<tr>
  <ti>man7</ti>
  <ti>Misceláneos</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Páginas de manual múltiples</title>
<body>

<p>
Algunos temas existen en más de una sección. Para mostrar esto, vamos a
usar la orden <c>whatis</c>, que muestra todas las páginas de manual para
un tema:
</p>

<pre caption="Uso de la orden whatis">
$ <i>whatis printf</i>
printf               (1)  - format and print data
printf               (3)  - formatted output conversion
</pre>

<p>
En este caso, <c>man printf</c> de manera predeterminada mostrará la página
en la sección 1 ("programas de usuario"). Si escribiésemos un programa en
C, puede que nos interese más la página de la sección 3 ("funciones de
librerías). Puede llamar la página de manual de una determinada sección
especificándolo en la línea de comandos, por lo que para ver
<e>printf(3)</e>, escribiríamos:
</p>

<pre caption="Especificando la sección en la orden man">
$ <i>man 3 printf</i>
</pre>

</body>
</section>
<section>
<title>Encontrar la página correcta del manual</title>
<body>

<p>
Algunas veces es difícil encontrar la página correcta del manual para un
tema determinado. En ese caso, puede intentar <c>man -k</c> para buscar la
sección NAME de las páginas de manual. Tome en cuenta que se trata de una
búsqueda de subcadena, por lo que ejecutar algo como <c>man -k ls</c> ¡le
dará una gran cantidad de datos de salida! Aquí hay un ejemplo con una
consulta más específica:
</p>

<pre caption="Buscando páginas de manual utilizando la orden man -k">
$ <i>man -k whatis</i>
apropos              (1)  - search the whatis database for strings
makewhatis           (8)  - Create the whatis database
whatis               (1)  - search the whatis database for complete words
</pre>

</body>
</section>
<section>
<title>Todo acerca de apropos</title>
<body>

<p>
El ejemplo del panel anterior nos lleva a unos cuantos puntos más. Primero,
la orden <c>apropos</c> es exactamente equivalente a <c>man -k</c>. (De
hecho, voy a contarle un pequeño secreto. Cuando ejecuta <c>man -k</c>, en
realidad se ejecuta <c>apropos</c> detrás del escenario.) El segundo punto
es la orden <c>makewhatis</c>, la cual explora todas las páginas de manual
de su sistema Linux y construye una base de datos para <c>whatis</c> y <c>
apropos</c>. Por lo general se ejecuta periódicamente por root para
mantener la base de datos actualizada:
</p>

<pre caption="Construyendo la base de datos de whatis y apropos">
# <i>makewhatis</i>
</pre>

<p>
Para más información sobre "man" y sus amigos, debe comenzar con la siguiente
página del manual:
</p>

<pre caption="Iniciando la página de manual para man">
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>La MANPATH</title>
<body>

<p>
De manera predeterminada, el programa <c>man</c> buscará en las páginas de
manual en <path>/usr/share/man</path>, <path>/usr/local/man</path>, <path>
/usr/X11R6/man</path>, y posiblemente en <path>/opt/man</path>. Algunas
veces, podrá necesitar agregar un elemento adicional a esta ruta de
búsqueda. En ese caso, simplemente edite <path>/etc/man.conf</path> en un
editor de textos y agregue una línea como la siguiente:
</p>

<pre caption="/etc/man.conf">
MANPATH /opt/man
</pre>

<p>
De este punto en adelante, cualquier página de manual en los directorios
<path>/opt/man/man*</path> será encontrada. Recuerde que necesitará
ejecutar nuevamente <c>makewhatis</c> para agregar estas nuevas páginas de
manual a la base de datos de whatis.
</p>

</body>
</section>
<section>
<title>Información GNU</title>
<body>

<p>
Una deficiencia de las páginas de manual es que no son compatibles con
hipertexto, por lo que no puede pasar fácilmente de una a otra. La gente de
GNU reconoció este defecto, por lo que inventaron otro formato de
documentación: páginas "info". Muchos de los programas GNU vienen con una
amplia documentación en el formato de páginas de información. Puede
comenzar a leer las páginas de información con la orden <c>info</c>:
</p>

<pre caption="Uso de la orden info">
$ <i>info</i>
</pre>

<p>
Llamando a <c>info</c> de esta manera, se abrirá un índice de las páginas
disponibles en el sistema. Puede moverse con las flechas de teclado, seguir
los enlaces (señalados con una estrella) utilizando la tecla Intro y salir
presionando <c>q</c>. Las teclas están basadas en Emacs, por lo que podrá
navegar fácilmente si está familiarizado con ese editor. Para una
introducción al editor Emacs, eche un vistazo al tutorial de
developerWorks <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">
Living in Emacs</uri>.
</p>

<p>
También puede especificar una página de información en la línea de comandos:
</p>

<pre caption="Especificar la orden en info">
$ <i>info diff</i>
</pre>

<p>
Para más información acerca del uso del lector <c>info</c>, pruebe leyendo
su página de información. Debe poder navegar utilizando las pocas teclas
que ya he mencionado:
</p>

<pre caption="Leyendo la página de información info">
$ <i>info info</i>
</pre>

</body>
</section>
<section>
<title>/usr/share/doc</title>
<body>

<p>
Hay una última fuente de ayuda dentro de su sistema Linux. Muchos programas
son entregados con documentación adicional en otros formatos: text, PDF,
PostScript, HTML, por nombrar algunos. Eche un vistazo en
<path>usr/share/doc</path> (o <path>usr/doc</path> para sistemas más
antiguos). Encontrará una larga lista de directorios, cada uno de ellos
proviene de una aplicación del sistema determinada. Buscar dentro de esta
documentación puede revelar algunas joyas que no están disponibles en las
páginas de manual o de información, como tutoriales o documentación técnica
adicional. Una revisión rápida revela que existe una gran cantidad de
material de lectura disponible:
</p>

<pre caption="/usr/share/doc/">
$ <i>cd /usr/share/doc</i>
$ <i>find . -type f | wc -l</i>
7582
</pre>

<p>
¡Menos mal! Su tarea de esta tarde es leer solo la mitad (3791) de esos
documentos. Espere un examen mañana. ;-)
</p>

</body>
</section>
<section>
<title>El proyecto de documentación Linux (LDP)</title>
<body>

<p>
Además de la documentación del sistema, hay una serie de excelentes
recursos en Internet. El <uri link="http://www.tldp.org/">Linux
Documentation Project</uri> es un grupo de voluntarios que trabajan para
agrupar el conjunto completo de la documentación libre de Linux. Este
proyecto existe para concentrar varias piezas de la documentación Linux en
una ubicación que sea fácil de buscar y usar.
</p>

</body>
</section>
<section>
<title>Una vista general del LDP</title>
<body>

<p>
El LDP está formado por las siguientes áreas:
</p>

<ul>
  <li>
    Guías - libros más largos, más en profundidad, como <uri
    link="http://www.tldp.org/LDP/lpg/index.html">The Linux Programmer's
    Guide</uri>
  </li>
  <li>
    COMOs - ayuda sobre temas específicos, tal como <uri
    link="http://www.tldp.org/HOWTO/DSL-HOWTO/index.html">DSL HOWTO</uri>
  </li>
  <li>
    FAQs - Preguntas hechas frecuentemente con respuestas, tal como <uri
    link="http://www.tldp.org/FAQ/faqs/BLFAQ">Brief Linux FAQ</uri>
  </li>
  <li>
    Páginas de manual - ayuda sobre órdenes individuales (estas son las
    mismas páginas que obtiene del sistema Linux cuando utiliza la orden
    <c>man</c>).
  </li>
</ul>

<p>
Si no está seguro de qué sección debe leer, puede aprovechar la caja de
búsqueda, la cual le permite encontrar la información por tema.
</p>

<p>
El LDP ofrece adicionalmente una lista de enlaces y recursos como <uri
link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri> (ver enlaces
en <uri link="#resources">Bibliografía</uri>) y <uri
link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>, además
de enlaces a listas de correos y archivos de noticias.
</p>

</body>
</section>
<section>
<title>Listas de correo</title>
<body>

<p>
Las listas de correo ofrecen probablemente el punto de colaboración más
importante para desarrolladores Linux. A menudo los proyectos son
desarrollados por contribuyentes que viven lejos, posiblemente incluso en
lados opuestos del globo. Las listas de correo proporcionan un método para
que cada desarrollador de un proyecto pueda contactar a los demás, y
mantener discusiones grupales vía correo electrónico. Una de las listas de
correo de desarrollo más famosas es <uri link="http://www.tux.org/lkml/">
Linux Kernel Mailing List</uri>.
</p>

</body>
</section>
<section>
<title>Más acerca de listas de correo</title>
<body>

<p>
Además del desarrollo, las listas de correo pueden proporcionar un método
para hacer preguntas y recibir respuestas de desarrolladores expertos, o
incluso otros usuarios. Por ejemplo, las distribuciones individuales
usualmente proveen listas de correo para los recién llegados. Puede revisar
el sitio web de su distribución para obtener información acerca de las
listas de correo que ofrece.
</p>

<p>
Si se tomó el tiempo para leer el FAQ LKML en el enlace del panel anterior,
puede haber notado que los subscriptores de la lista de correo a menudo no
toman amablemente las preguntas que se hacen repetidamente. Siempre es
prudente buscar en los archivos de las listas de correo antes de escribir
su pregunta. ¡Lo más probable es que también le ahorre tiempo!
</p>

</body>
</section>
<section>
<title>Grupos de noticias</title>
<body>

<p>
Los grupos de noticias de Internet son similares a las listas de correo,
pero están basadas en un protocolo llamado NNTP (Protocolo de Transferencia
de Noticias de la Red, por sus siglas en inglés) en lugar de correos
electrónicos. Para participar, debe de usar un cliente NNTP como <c>slrn</c>
o <c>pan</c>. La ventaja principal es que solo toma parte en la discusión
cuando así lo desea, en lugar de que continuamente lleguen a su bandeja de
entrada. :-)
</p>

<p>
Los grupos de noticias de interés primordial comienzan con comp.os.linux.
Puede leer la <uri link="http://www.tldp.org/links/#ng">lista en el sitio
LDP</uri>.
</p>

<p>
Tal como las listas de correos, las discusiones de grupos de noticias son
archivadas. Un sitio popular de archivos de grupos de noticias es <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

</body>
</section>
<section>
<title>Sitios web de proveedores y terceros</title>
<body>

<p>
Los sitios web de algunas distribuciones Linux a menudo proporcionan
documentación actualizada, instrucciones de instalación, declaraciones de
compatibilidad/incompatibilidad de hardware, y otros tipos de apoyo como
una herramienta de búsqueda de base de datos. Por ejemplo:
</p>

<ul>
  <li><uri link="http://www.redhat.com/">Redhat Linux</uri></li>
  <li><uri link="http://www.debian.org/">Debian Linux</uri></li>
  <li><uri link="http://www.gentoo.org/">Gentoo Linux</uri></li>
  <li><uri link="http://www.suse.com/">SuSE Linux</uri></li>
  <li><uri link="http://www.caldera.com/">Caldera</uri></li>
  <li><uri link="http://www.turbolinux.com/">Turbolinux</uri></li>
</ul>

</body>
</section>
<section>
<title>Proveedores de hardware y software</title>
<body>

<p>
Muchos proveedores de hardware y software han agregado soporte para Linux
en sus productos en los últimos años. En sus sitios, puede encontrar
información acerca del hardware que soporta Linux, herramientas de
desarrollo de software, fuentes que han sido liberadas, descargas de
controladores Linux para hardware específico, y otros proyectos Linux
especiales. Por ejemplo:
</p>

<ul>
  <li><uri link="http://www.ibm.com/linux/">IBM and Linux</uri></li>
  <li>
    <uri link="http://www.compaq.com/products/software/linux/">Compaq and</uri>
  </li>
  <li>
    <uri link="http://www.sgi.com/developers/technology/linux/">SGI and</uri>
  </li>
  <li><uri link="http://www.hp.com/products1/linux/">HP and</uri></li>
  <li><uri link="http://www.sun.com/linux/">Sun and</uri></li>
  <li>
    <uri link="http://technet.oracle.com/tech/linux/content.html">Oracle and 
    Linux</uri>.
  </li>
</ul>

</body>
</section>
<section>
<title>Recursos para desarrolladores</title>
<body>

<p>
Además, muchos proveedores de hardware y software han desarrollado
maravillosos recursos para desarrolladores y administradores Linux. A
riesgo de sonar como una autopromoción, uno de los recursos más valiosos
de Linux a cargo de un proveedor de hardware/software es la <uri
link="http://www.ibm.com/developerworks/linux/">IBM developerWorks Linux
zone</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>El modelo de permisos Linux</title>
<section>
<title>Un usuario, un grupo</title>
<body>

<p>
En esta sección, echaremos un vistazo al modelo de permisos y propiedad
Linux. Como vimos anteriormente cada archivo es propiedad de un usuario y
de un grupo. Esta es la esencia del modelo de permisos en Linux. Puede ver
el usuario y grupo de un archivo en un listado <c>ls -l</c>:
</p>

<pre caption="Listado de archivos">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
En este ejemplo en particular, el ejecutable <path>/bin/bash</path> es
propiedad de root y está en el grupo wheel. El modelo de permisos Linux
funciona permitiendo fijar tres niveles independientes de permisos para
cada objeto del sistema de archivos, para el propietario del archivo, el
grupo del archivo y todos los demás usuarios.
</p>

</body>
</section>
<section>
<title>Entendiendo "ls -l"</title>
<body>

<p>
Veamos nuestra salida de <c>ls -l</c> e inspeccionemos la primera columna
del listado:
</p>

<pre caption="Inspeccionando la orden ls -l">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
El primer campo <e>-rwxr-xr-</e> contiene una representación simbólica de
los permisos de este archivo en particular. El primer carácter (-) en este
campo especifica el tipo de archivo, que en este caso es un archivo normal.
Otros posibles primeros caracteres:
</p>

<pre caption="Primeros caracteres">
'd' directorio
'l' enlace simbólico
'c' dispositivo especial de carácter
'b' dispositivo especial de bloques
'p' fifo
's' socket
</pre>

</body>
</section>
<section>
<title>Tres tripletas</title>
<body>

<pre caption="ls -l /bin/bash">
$ <i>ls -l /bin/bash</i>
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
</pre>

<p>
El resto del campo se compone de tres tripletas de caracteres. La primera
tripleta representa los permisos del propietario del archivo, la segunda
representa los permisos para el grupo del archivo, y la tercera representa
permisos para todos los usuarios:
</p>

<pre caption="Tripletas en la orden ls -l">
"rwx"
"r-x"
"r-x"
</pre>

<p>
Arriba, la r significa que la lectura (mirar en los datos del archivo) está
permitido, la w significa que la escritura (modificar el archivo, así como
borrarlo) está permitido, y la x significa que "ejecutar" (ejecutar el
programa) está permitido. Juntando toda esta información, vemos que todo el
mundo es capaz de leer el contenido y ejecutar este archivo, pero solamente
el propietario (root) puede modificar de alguna manera este archivo. Así,
mientras los usuarios normales pueden copiar el archivo, solo root puede
actualizarlo o borrarlo.
</p>

</body>
</section>
<section>
<title>¿Quién soy?</title>
<body>

<p>
Antes de que veamos cómo cambiar el usuario y grupo propietario de un
archivo, echemos un vistazo a la manera de aprender su nombre de usuario y
grupo actual. A menos que haya utilizado la orden <c>su</c> recientemente,
su nombre de usuario es el mismo que utilizó para iniciar sesión en su
sistema. Sin embargo, si usa <c>su</c> con frecuencia, podría olvidar su
nombre actual efectivo. Para verlo, teclee <c>whoami</c>:
</p>

<pre caption="Uso de la orden whoami">
# <i>whoami</i>
root
# <i>su drobbins</i>
$ <i>whoami</i>
drobbins
</pre>

</body>
</section>
<section>
<title>¿A qué grupos pertenezco?</title>
<body>

<p>
Para ver a qué grupos pertenece, use la orden <c>groups</c>:
</p>

<pre caption="Uso de la orden groups">
$ <i>groups</i>
drobbins wheel audio
</pre>

<p>
En el ejemplo de arriba, soy miembro de los grupos drobbins, wheel y audio.
Si quiere ver a qué grupos pertenecen otros usuarios, especifique sus
nombres de usuario como argumentos:
</p>

<pre caption="Especificando nombres de usuario como argumento">
$ <i>groups root daemon</i>
root : root bin daemon sys adm disk wheel floppy dialout tape video
daemon : daemon bin adm
</pre>

</body>
</section>
<section>
<title>Cambiar el usuario y grupo propietario</title>
<body>

<p>
Para cambiar el usuario o grupo de un archivo u otro objeto del sistema de
archivos, use <c>chown</c> o <c>chgrp</c>, respectivamente. Cada una de
esas órdenes toma un nombre seguido de uno o más nombres de archivos.
</p>

<pre caption="Uso de las órdenes chown y chgrp">
# <i>chown root /etc/passwd</i>
# <i>chgrp wheel /etc/passwd</i>
</pre>

<p>
Además puede fijar el usuario y grupo simultáneamente con una forma
alternativa del comando <c>chown</c>:
</p>

<pre caption="Definir propietario y grupo simultáneamente">
# <i>chown root:wheel /etc/passwd</i>
</pre>

<p>
No puede usar <c>chown</c> a menos que sea superusuario, pero <c>chgrp</c>
puede ser usado por cualquiera para cambiar el grupo propietario de un
archivo a un grupo al que pertenece.
</p>

</body>
</section>
<section>
<title>Cambios de propiedad recursivos</title>
<body>

<p>
Tanto <c>chown</c> como <c>chgrp</c> tienen una opción -R que se puede
usar para indicarles que apliquen los cambios de propiedad y grupo
a un directorio entero recursivamente. Por ejemplo:
</p>

<pre caption="Uso de chown y chgrp con la opción -R">
# <i>chown -R drobbins /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Introducción a chmod</title>
<body>

<p>
Se pueden usar <c>chown</c> y <c>chgrp</c> para cambiar el propietario y
el grupo de un objeto del sistema de archivos, sin embargo, para cambiar
los permisos rwx que pueden verse en un listado <c>ls -l</c>, se usa otro
programa llamado <c>chmod</c>. La orden <c>chmod</c> toma dos o más
argumentos: un "modo", que describe cómo deben ser cambiados los permisos,
seguido de un archivo o lista de archivos que serán afectados:
</p>

<pre caption="Agregando el permiso x con chmod">
$ <i>chmod +x scriptfile.sh</i>
</pre>

<p>
En el ejemplo de arriba, nuestro "modo" es +x. Como puede imaginar, un modo
+x le indica a <c>chmod</c> hacer a este archivo en particular ejecutable,
tanto para el usuario como para el grupo, y para nadie más.
</p>

<p>
Si deseamos quitar todos los permisos de ejecución de un archivo, haremos
lo siguiente:
</p>

<pre caption="Eliminar los permisos x con chmod">
$ <i>chmod -x scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>Granularidad usuario/grupo/otros</title>
<body>

<p>
Hasta ahora, nuestros ejemplos <c>chmod</c> han afectado los permisos para
las tres tripletas, el usuario, el grupo, y los demás. A menudo, es útil
modificar una o dos de las tripletas a la vez. Para hacer esto, simplemente
debe especificar el carácter simbólico para la tripleta en particular que
le gustaría modificar antes del signo + o -. Use u para la tripleta
"usuario", g para la tripleta "grupo", y o para la tripleta "otros/todos":
</p>

<pre caption="Usando tripletas">
$ <i>chmod go-w scriptfile.sh</i>
</pre>

<p>
Acabamos de eliminar los permisos de escritura para el grupo y todos los
demás usuarios, pero dejamos los permisos de "propietario" sin tocar.
</p>

</body>
</section>
<section>
<title>Redefinir permisos</title>
<body>

<p>
Además de voltear los bits encendido y apagado de permiso, también podemos
definirlos por completo. Usando el operador =, podemos decirle a <c>
chmod</c> que queremos los permisos especificados y no otros:
</p>

<pre caption="Volteando bits de permisos">
$ <i>chmod =rx scriptfile.sh</i>
</pre>

<p>
Arriba, hemos fijado todos los bits "lectura" y "ejecución", y removido los
bits "escritura". Si queremos definir de nuevo una tripleta en particular,
podemos especificar el nombre simbólico para la tripleta antes de = como
se puede ver a continuación:
</p>

<pre caption="Redefinir una tripleta">
$ <i>chmod u=rx scriptfile.sh</i>
</pre>

</body>
</section>
<section>
<title>Modos numéricos</title>
<body>

<p>
Hasta ahora, hemos usado lo que se llama modo simbólico para especificar
los cambios de permiso a <c>chmod</c>. Sin embargo, existe otra manera
común de especificar permisos: usando un número de 4 dígitos octales.
Usando esta sintaxis, llamada sintaxis de permisos numérica, cada dígito
representa los permisos de una tripleta. Por ejemplo en 1777, el 777
establece las banderas "propietario", "grupo", y "otros" que hemos
discutido en esta sección. El 1 se usa para establecer los bits de permisos
especiales, los cuales cubriremos adelante (vea "<uri
link="https://www6.software.ibm.com/developerworks/education/l-lpir23/l-lpir23-3-23.html">
The elusive first digit</uri>" al final de esta sección). Este cuadro muestra
cómo son interpretados los siguientes cuatro dígitos (777):
</p>

<table>
<tr>
  <th>Modo</th>
  <th>Dígito</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Sintaxis numérica de permisos</title>
<body>

<p>
La sintaxis numérica de permisos es especialmente útil cuando necesita
especificar todos los permisos para un archivo, como se muestra en el
siguiente ejemplo:
</p>

<pre caption="Agregando permisos numéricos">
$ <i>chmod 0755 scriptfile.sh</i>
$ <i>ls -l scriptfile.sh</i>
-rwxr-xr-x    1 drobbins drobbins        0 Jan  9 17:44 scriptfile.sh
</pre>

<p>
En este ejemplo, usamos el modo 0755, el cual se expande a la configuración
completa de permisos -rwxr-xr-x.
</p>

</body>
</section>
<section>
<title>La umask</title>
<body>

<p>
Cuando un proceso crea un nuevo archivo, este especifica los permisos que
debería tener el nuevo archivo. Generalmente, el modo requerido es 0666
(puede ser leído y escrito por cualquiera), el cual genera más permisos de
lo que nos gustaría. Afortunadamente, Linux consulta algo llamado "umask"
cada vez que un nuevo archivo es creado. El sistema utiliza el valor de
umask para reducir los permisos especificados originalmente a algo más
razonable y seguro. Puede ver su umask actual escribiendo umask en la línea
de comandos:
</p>

<pre caption="Viendo la umask actual">
$ <i>umask</i>
0022
</pre>

<p>
En los sistemas Linux, la umask por omisión habitualmente es 0022, la cual
le permite a otros leer sus nuevos archivos (si es que pueden llegar a
ellos) pero no modificarlos.
</p>

<p>
Para generar archivos nuevos más seguros de manera predeterminada, puede
cambiar la configuración de la umask:
</p>

<pre caption="Cambiando la configuración de umask">
$ <i>umask 0077</i>
</pre>

<p>
Esta umask se asegurará de que el grupo y otros no tengan absolutamente
ningún permiso para los archivos recién creados. Así que, ¿cómo funciona
umask? A diferencia de los permisos "regulares" en archivos, la umask
especifica qué permisos deben ser apagados. Vamos a consultar nuestra tabla
de mapeo "modo a dígito" para que podamos entender lo que significa la umask
0077:
</p>

<table>
<tr>
  <th>Modo</th>
  <th>Dígito</th>
</tr>
<tr>
  <ti>rwx</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>rw-</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>r-x</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>r--</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>-wx</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>-w-</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>--x</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>---</ti>
  <ti>0</ti>
</tr>
</table>

<p>
Usando nuestra tabla, los últimos tres dígitos de 0077 son expandidos a
---rwxrwx. Ahora, recuerde que la <c>umask</c> le indica al sistema qué
permisos debe deshabilitar. Poniendo juntos dos y dos, podemos observar
que todos los permisos de "grupo" y "otros" son apagados, mientras que
los permisos de "usuario" permanecen intactos.
</p>

</body>
</section>
<section>
<title>Introducción a suid y sgid</title>
<body>

<p>
Cuando inicia sesión por primera vez, un nuevo proceso de interfaz de
comandos se inicia. Ya lo sabe, pero lo que probablemente desconoce es que
este nuevo proceso de interfaz de comandos (normalmente bash) se ejecuta
utilizando su identificador de usuario. Como tal, el programa bash puede
acceder a todos los archivos y directorios que le pertenecen. De hecho,
nosotros como usuarios somos totalmente dependientes de otros programas
para realizar operaciones en nuestro nombre. Debido a que los programas
inician heredando su identificador de usuario, no pueden acceder a
cualquier objeto del sistema de archivos para el cual no posea acceso.
</p>

<p>
Por ejemplo, el archivo passwd no puede ser cambiado por un usuario normal
directamente, debido a que la bandera "escribir" está apagada para
cualquier usuario excepto root:
</p>

<pre caption="ls -l /etc/passwd">
$ <i>ls -l /etc/passwd</i>
-rw-r--r--    1 root     wheel        1355 Nov  1 21:16 /etc/passwd
</pre>

<p>
Sin embargo, los usuarios normales necesitan modificar /etc/passwd (al
menos indirectamente) cada vez que necesiten cambiar su contraseña. Pero,
si el usuario no tiene la capacidad de modificar este archivo, ¿cómo
funciona esto exactamente?
</p>

</body>
</section>
<section>
<title>suid</title>
<body>

<p>
Afortunadamente, el modelo de permisos Linux tiene dos bits especiales
llamados <c>suid</c> y <c>sgid</c>. Cuando un programa ejecutable tiene
activado el bit <c>suid</c>, se ejecutará por medio del propietario del
ejecutable, y no en nombre de la persona que inició el programa.
</p>

<p>
Ahora, de regreso al problema de <path>/etc/passwd</path>. Si echamos un
vistazo al ejecutable <c>passwd</c>, podemos ver que no es propiedad de root:
</p>

<pre caption="Revisar el propietario del archivo /usr/bin/passwd">
$ <i>ls -l /usr/bin/passwd</i>
-rwsr-xr-x    1 root     wheel       17588 Sep 24 00:53 /usr/bin/passwd
</pre>

<p>
Debe notar también, que en lugar de una x en la tripleta de permisos del
usuario, hay una s. Eso indica que, para este programa en particular, el
bit <c>suid</c> y el ejecutable han sido establecidos. Debido a esto,
cuando <c>passwd</c> es ejecutado, se ejecutará en nombre del usuario root
(con total acceso de superusuario) en lugar del usuario que lo ejecutó. Y
ya que <c>passwd</c> se ejecuta con acceso de root, es capaz de modificar
el archivo <path>/etc/passwd</path> sin ningún problema.
</p>

</body>
</section>
<section>
<title>Advertencias sobre suid/sgid</title>
<body>

<p>
Hemos visto cómo funciona <c>suid</c>. <c>sgid</c> funciona de un modo
similar. Le permite a los programas heredar el grupo propietario en lugar
del usuario actual.
</p>

<impo>
Aquí hay alguna información diversa importante acerca de <c>suid</c> y
<c>sgid</c>. En primer lugar, los bits <c>suid</c> y <c>sgid</c> ocupan
el mismo espacio que los bits x en un listado ls -l. Si se ha activado
también el bit x, los bits respectivos se mostrarán como una s (en
minúsculas). Sin embargo, si el bit x no ha sido definido, se mostrará
como una S (en mayúsculas).
</impo>

<impo>
Otra nota importante: suid y sgid son útiles en muchas circunstancias, pero
el uso indebido de estos bits puede permitir que la seguridad de un sistema
sea violada. Lo mejor es tener la menor cantidad posible de programas suid.
La orden passwd es una de las pocas que deben ser suid.
</impo>

</body>
</section>
<section>
<title>Cambiando suid y sgid</title>
<body>

<p>
Activar y desactivar los bits <c>suid</c> y <c>sgid</c> es bastante sencillo.
Aquí, activamos el bit suid:
</p>

<pre caption="Activando el bit suid">
# <i>chmod u+s /usr/bin/miaplicacion</i>
</pre>

<p>
Y aquí, eliminamos el bit <c>sgid</c> de un directorio. Veremos como el bit
<c>sgid</c> afecta a los directorios en unos cuantos paneles más:
</p>

<pre caption="Eliminando el bit sgid">
# <i>chmod g-s /home/drobbins</i>
</pre>

</body>
</section>
<section>
<title>Permisos y directorios</title>
<body>

<p>
Hasta ahora, hemos buscado en los permisos desde la perspectiva de los
archivos normales. Cuando se trata de directorios, las cosas son un poco
diferentes. Los directorios usan las mismas banderas, pero son
interpretadas de un modo ligeramente diferente.
</p>

<p>
En el caso de un directorio, si la bandera "leer" es activada, puede
listar el contenido del directorio; "escribir" significa que puede crear
archivos dentro del directorio; y "ejecutar" significa que puede entrar al
directorio y acceder a cualquier subdirectorio interno. Sin la bandera
"ejecutar", los objetos del sistema de archivos dentro de un directorio no
son visibles, pero los objetos dentro del directorio aún pueden accederse
mientras alguien conozca la ruta completa al objeto en el disco.
</p>

</body>
</section>
<section>
<title>Directorios y sgid</title>
<body>

<p>
Y, si un directorio tiene la bandera "sgid" activada, cualquier objeto del
sistema de archivos creado dentro de él heredarán el grupo del directorio.
Esta característica en particular le será útil cuando necesite crear un
árbol de directorio para ser usado por un conjunto de personas que
pertenecen al mismo grupo. Simplemente haga lo siguiente:
</p>

<pre caption="Crear un directorio para un grupo de personas">
# <i>mkdir /home/espaciogrupal</i>
# <i>chgrp migrupo /home/espaciogrupal</i>
# <i>chmod g+s /home/espaciogrupal</i>
</pre>

<p>
Ahora, cualquier usuario en el grupo migrupo puede crear archivos y
directorios dentro de <path>/home/espaciogrupal</path>, y además les será
asignada automáticamente la propiedad del grupo migrupo. Dependiendo de la
configuración de umask de los usuarios, los nuevos objetos del sistema de
archivos podrán ser o no ser leídos, escritos, o ejecutados por otros
miembros del grupo migrupo.
</p>

</body>
</section>
<section>
<title>Directorios y borrado</title>
<body>

<p>
De manera predeterminada, los directorios de Linux se comportan de una
manera que puede no ser ideal para todas las situaciones. Habitualmente,
cualquiera puede renombrar o eliminar un archivo dentro de un directorio,
siempre y cuando tenga acceso de escritura a ese directorio. Para
directorios utilizados por usuarios individuales, este comportamiento por
lo general es correcto.
</p>

<p>
Sin embargo, para directorios que son utilizados por muchos usuarios,
especialmente <path>/tmp</path> y <path>/var/tmp</path>, este
comportamiento puede ser una mala noticia. Ya que cualquiera puede
escribir en esos directorios, cualquiera puede borrar o renombrar cualquier
archivo de los demás, ¡incluso si no le pertenece! Obviamente, es difícil
usar <path>/tmp</path> para algo importante si otro usuario puede escribir
<c>rm -rf /tmp/*</c> en cualquier momento y destruir los archivos de todos.
</p>

<p>
Afortunadamente, Linux tiene algo llamado el bit pegajoso (sticky). Cuando
<path>/tmp</path> tiene el bit pegajoso activado (con un <c>chmod +t</c>),
las únicas personas que son capaces de borrar o renombrar archivos en el
directorio <path>/tmp</path> son los propietarios del directorio
(generalmente root), los propietarios del archivo, o root. Prácticamente
todas las distribuciones de Linux habilitan de manera predeterminada el bit
pegajoso en <path>/tmp</path>, pero este bit puede ser de utilidad en otras
situaciones.
</p>

</body>
</section>
<section>
<title>El escurridizo primer dígito</title>
<body>

<p>
Y para concluir esta sección, finalmente veremos el escurridizo primer
dígito de un modo numérico. Como puede ver, el primer dígito es usado para
definir los bits pegajoso, <c>suid</c>, y <c>sgid</c>:
</p>

<table>
<tr>
  <th>suid</th>
  <th>sgid</th>
  <th>pegajoso</th>
  <th>modo de dígitos</th>
</tr>
<tr>
  <ti>encendido</ti>
  <ti>encendido</ti>
  <ti>encendido</ti>
  <ti>7</ti>
</tr>
<tr>
  <ti>encendido</ti>
  <ti>encendido</ti>
  <ti>apagado</ti>
  <ti>6</ti>
</tr>
<tr>
  <ti>encendido</ti>
  <ti>apagado</ti>
  <ti>encendido</ti>
  <ti>5</ti>
</tr>
<tr>
  <ti>encendido</ti>
  <ti>apagado</ti>
  <ti>apagado</ti>
  <ti>4</ti>
</tr>
<tr>
  <ti>apagado</ti>
  <ti>encendido</ti>
  <ti>encendido</ti>
  <ti>3</ti>
</tr>
<tr>
  <ti>apagado</ti>
  <ti>encendido</ti>
  <ti>apagado</ti>
  <ti>2</ti>
</tr>
<tr>
  <ti>apagado</ti>
  <ti>apagado</ti>
  <ti>encendido</ti>
  <ti>1</ti>
</tr>
<tr>
  <ti>apagado</ti>
  <ti>apagado</ti>
  <ti>apagado</ti>
  <ti>0</ti>
</tr>
</table>

<p>
He aquí un ejemplo de cómo utilizar un modo numérico de 4 dígitos para
definir permisos para un directorio que será usado por un grupo de
trabajo:
</p>

<pre caption="Definir permisos numéricos">
# <i>chmod 1775 /home/archivosdelgrupo</i>
</pre>

<p>
Como tarea, averigüe el significado de la configuración de permiso numérico
1755. :)
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestión de cuentas en Linux</title>
<section>
<title>Introducción a /etc/passwd</title>
<body>

<p>
En esta sección, vamos a ver el mecanismo de gestión de cuentas en Linux,
comenzando con el archivo <path>/etc/passwd</path>, el cual define todos
los usuarios que existen en el sistema Linux. Puede ver su propio archivo
<path>/etc/passwd</path> tecleando less <path>/etc/passwd</path>.
</p>

<p>
Cada línea en <path>/etc/passwd</path> define una cuenta de usuario. He
aquí una línea muestra de mi archivo <path>/etc/passwd</path>:
</p>

<pre caption="/etc/passwd">
drobbins:x:1000:1000:Daniel Robbins:/home/drobbins:/bin/bash
</pre>

<p>
Como puede ver, hay un bastante información en esta línea. De hecho, cada
línea de <path>/etc/passwd</path> consiste en múltiples campos, cada uno
separado por :.
</p>

<p>
El primer campo define el nombre de usuario (drobbins), y el segundo campo
contiene una x. En los antiguos sistemas Linux, este campo contiene una
contraseña cifrada usada para la autenticación, pero prácticamente todos
los sistemas Linux ahora almacenan esta información de la contraseña en
otro archivo.
</p>

<p>
El tercer campo (1000) define el identificador numérico de usuario asociado
con este usuario en particular, y el cuarto campo (1000) asocia este
usuario con un grupo en particular; en unos cuantos paneles más abajo,
veremos dónde se define el grupo 1000.
</p>

<p>
El quinto campo contiene una descripción textual de esta cuenta, en este
caso, el nombre del usuario. El sexto campo define el directorio home del
usuario, y el séptimo campo especifica la interfaz de comandos
predeterminada del usuario, la que se iniciará automáticamente cuando el
usuario inicia sesión.
</p>

</body>
</section>
<section>
<title>Consejos y trucos sobre /etc/passwd</title>
<body>

<p>
Probablemente habrá observado que se han definido muchas más cuentas de
usuario en <path>/etc/passwd</path> de las que realmente inician sesión
en su sistema. Esto es porque varios componentes de Linux utilizan las
cuentas de usuario para mejorar la seguridad. Por lo general, estas cuentas
del sistema tienen un identificador de usuario ("uid") menor que 100, y
muchas de ellas tendrán algo parecido a /bin/false como su interfaz de
comandos predeterminada. Debido a que el programa <path>/bin/false</path>
no hace nada más que dar la salida de un error de código, previene
eficazmente que estas cuentas puedan ser utilizadas como cuentas para
inicio de sesión, son solo para uso interno.
</p>

</body>
</section>
<section>
<title>/etc/shadow</title>
<body>

<p>
Por lo tanto, las cuentas de usuario en sí son definidas en <path>
/etc/passwd</path>. Los sistemas Linux contienen un archivo que acompaña a
<path>/etc/passwd</path> llamado <path>/etc/shadow</path>. Este archivo, a
diferencia de <path>/etc/passwd</path>, es legible solamente para root y
contiene la información cifrada de las contraseñas. Veamos una línea de
ejemplo de <path>/etc/shadow</path>:
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Cada línea define información de la contraseña para una cuenta en
particular, y nuevamente, cada campo está separado por :. El primer campo
define la cuenta de un usuario en particular a la cual esta entrada de
shadow se asocia. El segundo campo contiene la contraseña cifrada. Los
campos restantes son descritos en la siguiente tabla:
</p>

<table>
<tr>
  <ti>campo 3</ti>
  <ti>
    número de días desde el 1/1/1970 en que la contraseña fue modificada
  </ti>
</tr>
<tr>
  <ti>campo 4</ti>
  <ti>
    número de días antes de que se permita cambiar la contraseña (0 para
    "cambiar en cualquier momento")
  </ti>
</tr>
<tr>
  <ti>campo 5</ti>
  <ti>
    número de días antes de que el sistema obligue al usuario a cambiar su
    contraseñan por una nueva (-1 para "nunca")
  </ti>
</tr>
<tr>
  <ti>campo 6</ti>
  <ti>
    número de días antes de que el usuario reciba un aviso sobre el
    vencimiento de su contraseña (-1 para "sin previo aviso")
  </ti>
</tr>
<tr>
  <ti>campo 7</ti>
  <ti>
    número de días que deben transcurrir después de caducada la contraseña
    para que la cuenta sea desactivada (-1 para "nunca desactivar")
  </ti>
</tr>
<tr>
  <ti>campo 8</ti>
  <ti>
    número de días en que la cuenta será deshabilitada (-1 para "esta cuenta
    está habilitada")
  </ti>
</tr>
<tr>
  <ti>campo 9</ti>
  <ti>Reservado para un uso futuro</ti>
</tr>
</table>

</body>
</section>
<section>
<title>/etc/group</title>
<body>

<p>
A continuación, echaremos un vistazo al archivo <path>/etc/group</path>,
el cual define todos los grupos de un sistema Linux. Aquí hay una línea de
muestra:
</p>

<pre caption="/etc/group">
drobbins:x:1000:
</pre>

<p>
El formato de los campos de <path>/etc/group</path> se describe a
continuación. El primer campo define el nombre del grupo; el segundo campo
es un vestigio del campo de contraseña que ahora simplemente tiene una x, y
el tercer campo define el identificador numérico de este grupo en particular.
El cuarto campo (vacío en el ejemplo anterior) define los usuarios miembros
del grupo.
</p>

<p>
Recordará que nuestra línea muestra de <path>/etc/passwd</path> hacía
referencia a un identificador de grupo de 1000. Esto tiene el efecto de
colocar el usuario drobbins en el grupo drobbins, incluso cuando el nombre
de usuario drobbins no aparezca en el cuarto campo de
<path>/etc/group</path>.
</p>

</body>
</section>
<section>
<title>Notas de grupos</title>
<body>

<p>
Una nota sobre la asociación de usuarios con grupos: en algunos sistemas,
encontrará que cada nueva cuenta de inicio de sesión está asociada con un
grupo con el mismo nombre (y generalmente la misma numeración). En otros
sistemas, todas las cuentas de inicio de sesión pertenecen a un grupo de
usuarios. Se puede decidir el enfoque que utilizará el sistema a administrar.
Crear grupos que correspondan a cada usuario tiene la ventaja de
permitirles a los usuarios controlar con mayor facilidad el acceso a sus
propios archivos colocando a sus amigos de confianza en su grupo personal.
</p>

</body>
</section>
<section>
<title>Agregar un usuario y un grupo manualmente</title>
<body>

<p>
Ahora, le mostraré cómo crear su propia cuenta de usuario y grupo. La mejor
manera de aprender cómo hacer esto es agregar un nuevo usuario al sistema
manualmente. Para comenzar, primero asegúrese que su variable de ambiente
EDITOR está ajustada a su editor de texto favorito:
</p>

<pre caption="Revisar la variable del editor de texto favorito">
# <i>echo $EDITOR</i>
vim
</pre>

<p>
Si no es así, puede definir EDITOR escribiendo algo como:
</p>

<pre caption="Definir la variable EDITOR">
# <i>export EDITOR=/usr/bin/emacs</i>
# <i>vipw</i>
</pre>

<p>
Ahora debe encontrarse en su editor de texto favorito con el archivo
<path>/etc/passwd</path> cargado en la pantalla. Cuando modifiquemos los
archivos del sistema <path>passwd</path> y <path>group</path>, es muy
importante usar las órdenes <c>vipw</c> y <c>vigr</c>. Estas órdenes toman
precauciones adicionales para asegurar que sus archivos fundamentales <path>
passwd</path> y <path>group</path> sean cerrados correctamente y no se
corrompan.
</p>

</body>
</section>
<section>
<title>Editar /etc/passwd</title>
<body>

<p>
Ahora que tiene abierto el archivo <path>/etc/passwd</path>, agregue la
siguiente línea:
</p>

<pre caption="/etc/passwd">
usuariodeprueba:x:3000:3000:Usuario de prueba del tutorial LPI:/home/usuariodeprueba:/bin/false
</pre>

<p>
Acabamos de agregar un usuario "usuariodeprueba" con un UID de 3000. Lo
agregamos al grupo con un GID de 3000, que aún no creamos. Como otra
opción, podríamos asignar este usuario a el GID del grupo users si
quisiéramos. Este nuevo usuario tiene un comentario que dice Usuario de
prueba del tutorial LPI; el directorio home del usuario está establecido
con la ruta <path>/home/usuariodeprueba</path>, y la interfaz de comandos
asignada está establecida como <path>/bin/false</path> por motivos de
seguridad. Si creáramos una cuenta que no sea de prueba, debemos establecer
la interfaz de comandos a <path>/bin/bash</path>. Continúe guardando los
cambios y saliendo de la aplicación.
</p>

</body>
</section>
<section>
<title>Editar /etc/shadow</title>
<body>

<p>
Ahora, tenemos que agregar una entrada en <path>/etc/shadow</path> para
este usuario en particular. Para hacerlo, teclee <c>vipw -s</c>. Le dará la
bienvenida su editor favorito, el cual ahora contiene el archivo
<path>/etc/shadow</path>. Ahora, siga adelante y copie la línea de una
cuenta de usuario existente (una que tiene contraseña y es más larga que
las entradas de las cuentas estándar del sistema):
</p>

<pre caption="/etc/shadow">
drobbins:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Ahora, cambie el nombre de usuario en la línea copiada por el nombre del
nuevo usuario, y asegúrese de que todos los campos (particularmente el de
la vigencia de la contraseña) están definidos a su gusto:
</p>

<pre caption="/etc/shadow modificado">
usuariodeprueba:$1$1234567890123456789012345678901:11664:0:-1:-1:-1:-1:0
</pre>

<p>
Ahora, guarde y salga.
</p>

</body>
</section>
<section>
<title>Establecer una contraseña</title>
<body>

<p>
Regresará al prompt. Ahora, es el momento de establecer una contraseña para
el nuevo usuario:
</p>

<pre caption="Establecer una contraseña para un nuevo usuario">
# <i>passwd usuariodeprueba</i>
Enter new UNIX password: <comment>(introduzca la contraseña para
usuariodeprueba)</comment>
Retype new UNIX password: <comment>(introduzca de nuevo la contraseña de
usuariodeprueba)</comment>
</pre>

</body>
</section>
<section>
<title>Editar /etc/group</title>
<body>

<p>
Ahora que <path>/etc/passwd</path> y <path>/etc/shadow</path> están
definidos, es el momento de configurar apropiadamente
<path>/etc/group</path>. Para ello, escriba:
</p>

<pre caption="Configurar /etc/group">
# <i>vigr</i>
</pre>

<p>
Su archivo <path>/etc/group</path> aparecerá, listo para ser editado. Ahora,
si opta por asignar su usuario de prueba en particular a un grupo
predeterminado de usuarios, no es necesario añadir ningún grupo a
<path>/etc/groups</path>. Sin embargo, si optó por crear un grupo nuevo
para este usuario, continúe y agregue la siguiente línea:
</p>

<pre caption="Agregar un grupo nuevo manualmente">
usuariodeprueba:x:3000:
</pre>

<p>
Ahora guarde y salga.
</p>

</body>
</section>
<section>
<title>Crear un directorio home</title>
<body>

<p>
Estamos a punto de terminar. Escriba las siguientes órdenes para crear el
directorio home de usuariodeprueba:
</p>

<pre caption="Crear el directorio home">
# <i>cd /home</i>
# <i>mkdir usuariodeprueba</i>
# <i>chown usuariodeprueba.usuariodeprueba usuariodeprueba</i>
# <i>chmod o-rwx usuariodeprueba</i>
</pre>

<p>
Nuestro directorio home del usuario ya está en su lugar, y la cuenta está
lista para su uso. Bueno, casi lista. Si desea utilizar esta cuenta, tendrá
que utilizar vipw para cambiar el intérprete de comandos por defecto de
usuariodeprueba a <path>/bin/bash</path> para que el usuario pueda iniciar
sesión.
</p>

</body>
</section>
<section>
<title>Utilidades de la administración de cuentas</title>
<body>

<p>
Ahora que sabe cómo agregar una nueva cuenta y un grupo manualmente, vamos
a revisar las diversas utilidades de administración de cuentas disponibles
en Linux que permiten ahorrar tiempo. Debido a las limitaciones de espacio,
no vamos a cubrir con gran detalle estas órdenes. Recuerde que siempre puede
obtener más información sobre una orden, revisando la página del manual. Si
está planeando tomar el examen LPIC 101, debe pasar algún tiempo
familiarizándose con cada una de estas órdenes.
</p>

<p>
newgrp
</p>

<p>
De manera predeterminada, los archivos que un usuario crea son asignados al
grupo del usuario especificado en <path>/etc/passwd</path>. Si el usuario
pertenece a otros grupos, el o ella pueden escribir newgrp estegrupo para
establecer la pertenencia actual de grupo al grupo estegrupo. Entonces, los
archivos nuevos creados heredarán la pertenencia a estegrupo.
</p>

<table>
<tr>
  <ti><c>chage</c></ti>
  <ti>
    La orden <c>chage</c> se utiliza para ver y cambiar la configuración del
    tiempo que lleva la contraseña almacenada en <path>/etc/shadow</path>.
  </ti>
</tr>
<tr>
  <ti><c>gpasswd</c></ti>
  <ti>Una herramienta de administración de grupos de uso general.</ti>
</tr>
<tr>
  <ti><c>groupadd</c>/<c>groupdel</c>/<c>groupmod</c></ti>
  <ti>
    Utilizadas para agregar/borrar/modificar grupos en
    <path>/etc/group</path>
  </ti>
</tr>
<tr>
  <ti><c>useradd</c>/<c>userdel</c>/<c>usermod</c></ti>
  <ti>
    Utilizadas para agregar/borrar/modificar usuarios en
    <path>/etc/passwd</path>. Estas órdenes también desempeñan otras
    funciones prácticas. Vea las páginas del manual para más información.
  </ti>
</tr>
<tr>
  <ti><c>pwconv</c>/<c>grpconv</c></ti>
  <ti>
    Se utilizan para convertir los archivos <path>passwd</path> y
    <path>group</path> al "nuevo estilo" de contraseñas ocultas.
    Prácticamente todos los sistemas Linux ya utilizan contraseñas ocultas,
    por lo que probablemente nunca necesite utilizar estas órdenes.
  </ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Ajustar el entorno de usuario</title>
<section>
<title>Introducción a "fortune"</title>
<body>

<p>
Su intérprete de comandos tiene muchas opciones útiles que se pueden
configurar para adaptarse a sus preferencias personales. Hasta ahora, sin
embargo, no hemos hablado de alguna manera para que estas configuraciones
se establezcan de forma automática cada vez que inicie sesión, a excepción
de escribirlas de nuevo cada vez. En esta sección vamos a ver el ajuste de
su entorno de inicio de sesión, modificando los archivos de inicio.
</p>

<p>
En primer lugar, vamos a añadir un mensaje amistoso para la primera vez que
inicie sesión. Para ver un mensaje de ejemplo, ejecute <c>fortune</c>:
</p>

<pre caption="Ejecutar la orden fortune">
$ <i>fortune</i>
No amount of careful planning will ever replace dumb luck.
(Ninguna cantidad de cuidadosa planificación sustituirá jamás la suerte.)
</pre>

</body>
</section>
<section>
<title>.bash_profile</title>
<body>

<p>
Ahora, vamos a configurar <c>fortune</c> para que se ejecute cada vez que
inicie sesión. Use su editor de texto favorito para editar un archivo
llamado <path>.bash_profile</path> en su directorio home. Si el archivo no
existe todavía, créelo. Agregue una línea en la parte superior:
</p>

<pre caption="~/.bash_profile">
fortune
</pre>

<p>
Intente salir y regresar. A menos de que esté ejecutando un gestor de
ventanas como xdm, gdm, o kdm, será saludado con alegría cuando inicie
sesión:
</p>

<pre caption="Resultados de la orden fortune en el archivo .bash_profile">
mycroft.flatmonk.org login: chouser
Password:
Freedom from incrustations of grime is contiguous to rectitude.
(La ausencia de incrustaciones de suciedad es contigua a la rectitud.)
$
</pre>

</body>
</section>
<section>
<title>El intérprete de comandos de inicio de sesión</title>
<body>

<p>
Cuando bash inicia, pasa a través del archivo <path>.bash_profile</path>
del directorio home, ejecutando cada línea como si hubiera sido escrita en
el prompt bash. A esto se le llama abastecimiento (sourcing) de un archivo.
</p>

<p>
Bash actúa algo diferente dependiendo de cómo se inicia. Si es iniciado
como un intérprete de comandos de inicio, actuará como lo hizo arriba,
primero abasteciendo todo el sistema <path>/etc/profile</path>, y luego su
<path>~/.bash_profile</path> personal.
</p>

<p>
Hay dos maneras de decirle a bash que se ejecute como intérprete de
comandos de inicio de sesión. Una manera es en su primer inicio de sesión:
bash es inicializado con el nombre de proceso -bash. Puede ver que este es
su lista de procesos:
</p>

<pre caption="Listado de procesos">
$ <i>ps u</i>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
chouser    404  0.0  0.0  2508  156 tty2     S     2001   0:00 -bash
</pre>

<p>
Probablemente verá una lista mucho mas larga, pero debe tener al menos un
COMMAND con un guión antes del nombre de su intérprete de comandos, como
-bash en el ejemplo anterior. Este guión es utilizado por el intérprete de
comandos para determinar si está ejecutándose como un intérprete de
comandos de inicio de sesión.
</p>

</body>
</section>
<section>
<title>Entendiendo --login</title>
<body>

<p>
La segunda manera de decirle a bash que se ejecute como un intérprete de
comandos de inicio de sesión es con la orden <c>--login</c>. Esto es
utilizado algunas veces por los emuladores de terminales (como xterm) para
hacer que sus sesiones de bash actúen como una sesión de inicio.
</p>

<p>
Después de haber iniciado sesión, se ejecutarán más copias de su intérprete
de comandos. A menos que se hayan iniciado con <c>--login</c> o tengan un
guión en su nombre de proceso, estas sesiones no serán intérpretes de
comandos de inicio de sesión. Si le dan un prompt, sin embargo, se llaman
intérpretes de comandos interactivos. Si bash se inicia como interactivo,
pero no de inicio de sesión, ignorará <path>/etc/profile</path> y
<path>~/.bash_profile</path> y utilizará <path>~/.bashrc</path>.
</p>

<table>
<tr>
  <th>interactivo</th>
  <th>inicio</th>
  <th>perfil</th>
  <th>rc</th>
</tr>
<tr>
  <ti>si</ti>
  <ti>si</ti>
  <ti>fuente</ti>
  <ti>ignorar</ti>
</tr>
<tr>
  <ti>si</ti>
  <ti>no</ti>
  <ti>ignorar</ti>
  <ti>fuente</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>si</ti>
  <ti>fuente</ti>
  <ti>ignorar</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>no</ti>
  <ti>ignorar</ti>
  <ti>ignorar</ti>
</tr>
</table>

</body>
</section>
<section>
<title>Pruebas de interactividad</title>
<body>

<p>
Algunas veces bash abastece su <path>~/.bashrc</path>, aunque no es
realmente interactivo, como cuando utiliza órdenes como rsh y scp. Esto es
importante tenerlo en cuenta porque la impresión de texto, como lo
hicimos antes con la orden fortune, puede estropear las sesiones
no interactivas de bash. Es una buena idea usar la variable PS1 para
detectar si el intérprete de comandos actual es realmente interactivo antes
de imprimir texto desde un archivo de inicio:
</p>

<pre caption="Comprobar la variable PS1 ">
if [ -n "$PS1" ]; then
fortune
fi
</pre>

</body>
</section>
<section>
<title>/etc/profile y /etc/skel</title>
<body>

<p>
Como administrador del sistema, está a cargo de <path>/etc/profile</path>.
Debido a que es abastecido por todos cuando inician sesión, es importante
mantenerlo en orden su funcionamiento. Es también una herramienta poderosa
para hacer que las cosas funcionen correctamente para los nuevos usuarios
tan pronto como ingresan a su nueva cuenta.
</p>

<p>
Sin embargo, hay algunas opciones que puede desear que los usuarios nuevos
tengan de manera predeterminada, pero también puedan cambiar con facilidad.
Aquí es donde el directorio <path>/etc/skel</path> entra en juego. Cuando
usa la orden <c>useradd</c> para crear una nueva cuenta de usuario, copia
todos los archivos de <path>/etc/skel</path> en el nuevo directorio home
del usuario. Esto significa que puede poner archivos útiles
<path>.bash_profile</path> y <path>.bashrc</path> en <path>/etc/skel</path>
para darles a los nuevos usuarios un buen inicio.
</p>

</body>
</section>
<section>
<title>export</title>
<body>

<p>
Las variables en bash pueden marcarse para ser las mismas en cualquier
intérprete de comandos nuevo que inicie; a esto se le llama: marcadas para
exportar. Puede tener una lista de todas las variables que actualmente
están marcadas para exportar a su sesión del intérprete de comandos:
</p>

<pre caption="Resultados de la orden export">
$ <i>export</i>
declare -x EDITOR="vim"
declare -x HOME="/home/chouser"
declare -x MAIL="/var/spool/mail/chouser"
declare -x PAGER="/usr/bin/less"
declare -x PATH="/bin:/usr/bin:/usr/local/bin:/home/chouser/bin"
declare -x PWD="/home/chouser"
declare -x TERM="xterm"
declare -x USER="chouser"
</pre>

</body>
</section>
<section>
<title>Marcar variables para export</title>
<body>

<p>
Si una variable no es marcada para exportar, cualquier intérprete de
comandos que inicie no tendrá esa variable establecida. Sin embargo, puede
marcar una variable para exportar pasándola por la orden incorporada
<c>export</c>:
</p>

<pre caption="Marcar variables para exportar">
$ <i>FOO=foo</i>
$ <i>BAR=bar</i>
$ <i>export BAR</i>
$ <i>echo $FOO $BAR</i>
foo bar
$ <i>bash</i>
$ <i>echo $FOO $BAR</i>
bar
</pre>

<p>
En este ejemplo, se han definido las variables FOO y BAR, pero solo BAR
fue marcada para exportar. Cuando un nuevo bash inicia, ha perdido el valor
de FOO. Si sale de este nuevo bash, verá que el original aún posee los
valores tanto para FOO como para BAR:
</p>

<pre caption="Revisar los ajustes en el bash original">
$ <i>exit</i>
$ <i>echo $FOO $BAR</i>
foo bar
</pre>

</body>
</section>
<section>
<title>Exportar y establecer -x</title>
<body>

<p>
Debido a este comportamiento, las variables se pueden definir en
<path>~/.bash_profile</path> o en <path>/etc/profile</path> y marcarlas para
exportar, y nunca será necesario definirlas de nuevo. Hay algunas
opciones que no se pueden exportar, sin embargo, deben ponerse en su
<path>~/.bashrc</path> y en su <e>profile</e> con el fin de definirlas
constantemente. Estas opciones son ajustadas con la orden incorporada set:
</p>

<pre caption="Usar la orden set">
$ <i>set -x</i>
</pre>

<p>
La opción <c>-x</c> ocasiona que bash imprima cada orden que va a ejecutar:
</p>

<pre caption="Comprobar los resultados de la opción -x">
$ <i>echo $FOO</i>
$ <i>echo foo</i>
foo
</pre>

<p>
Esto es muy útil para entender un comportamiento inesperado o errores
similares. Para deshabilitar la opción <c>-x</c>, utilice <c>set +x</c>.
Vea la página de manual bash para todas las opciones de la orden incorporada
set.
</p>

</body>
</section>
<section>
<title>Definir variables con "set"</title>
<body>

<p>
La orden incorporada <c>set</c> también se puede usar para definir
variables, pero el uso de esta forma es opcional. La orden de bash
<c>set FOO=foo</c> significa exactamente lo mismo que <c>FOO=foo</c>.
Para dejar una variable sin definir utilice la orden incorporada
<c>unset</c>:
</p>

<pre caption="Dejar una variable sin definir">
$ <i>FOO=bar</i>
$ <i>echo $FOO</i>
bar
$ <i>unset FOO</i>
$ <i>echo $FOO</i>
</pre>

</body>
</section>
<section>
<title>Unset contra FOO=</title>
<body>

<p>
<e>No</e> es lo mismo que definir una variable a nada, algunas veces es
difícil notar la diferencia. Una manera de saberlo es usar la orden
incorporada <c>set</c> sin parámetros para listar las variables actuales:
</p>

<pre caption="Comparación de unset y FOO=">
$ <i>FOO=bar</i>
$ <i>set | grep ^FOO</i>
FOO=bar
$ <i>FOO=</i>
$ <i>set | grep ^FOO</i>
FOO=
$ <i>unset FOO</i>
$ <i>set | grep ^FOO</i>
</pre>

<p>
El uso de <c>set</c> sin parámetros como estos es similar a usar la orden
incorporada <c>export</c>, excepto que <c>set</c> lista todas las variables
en lugar de las marcadas para exportar.
</p>

</body>
</section>
<section>
<title>Exportar para cambiar el comportamiento de una orden</title>
<body>

<p>
También, el comportamiento de las órdenes puede ser alterado fijando
variables del entorno. Al igual que en las nuevas sesiones de bash, otros
programas que inician desde su prompt de bash solo podrán ver variables que
son marcadas para exportar. Por ejemplo, la orden <c>man</c> revisa la
variable PAGER para ver qué programa debe usar para pasar a través del texto
de una página a la vez.
</p>

<pre caption="Exportar la variable PAGER">
$ <i>PAGER=less</i>
$ <i>export PAGER</i>
$ <i>man man</i>
</pre>

<p>
Con PAGER fijado a <c>less</c>, verá una página a la vez, y presionando la
barra espaciadora se moverá a la siguiente página. Si cambia PAGER a
<c>cat</c>, el texto será desplegado totalmente de una sola vez, sin
detenerse.
</p>

<pre caption="Fijar la variable PAGER a cat">
$ <i>PAGER=cat</i>
$ <i>man man</i>
</pre>

</body>
</section>
<section>
<title>Uso de "env"</title>
<body>

<p>
Desafortunadamente, si olvida volver a definir PAGER a <c>less</c>,
<c>man</c> (así como otras órdenes) seguirán desplegando su contenido sin
detenerse. Si quiere asignar <c>cat</c> a PAGER solo una vez, debe usar
la orden <c>env</c>:
</p>

<pre caption="Usar la orden env para definir una variable">
$ <i>PAGER=less</i>
$ <i>env PAGER=cat man man</i>
$ <i>echo $PAGER</i>
less
</pre>

<p>
Esta vez, PAGER fue exportado a <c>man</c> con un valor de <c>cat</c>, pero
la variable PAGER permanece sin cambios en la sesión de bash.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Resumen y recursos</title>
<section>
<title>Resumen</title>
<body>

<p>
¡Felicitaciones por terminar la parte 3 de esta serie de tutoriales! En
este punto, debe saber cómo localizar información en documentación del
sistema y de Internet, y debe tener una buena comprensión del modelo de
permisos Linux, manejo de cuentas de usuario y ajuste del entorno de
inicio de sesión.
</p>

</body>
</section>
<section id="resources">
<title>Recursos</title>
<body>

<p>
Asegúrese de revisar los recursos bibliográficos cubiertos en este tutorial,
particularmente el <uri link="http://www.tldp.org/">Linux Documentation
Project</uri>. Encontrará su colección de guías, COMOs, FAQs, y páginas de
manual como un recurso invaluable. Revise también
<uri link="http://www.tldp.org/LDP/LG/current/">Linux Gazette</uri>
y <uri link="http://www.tldp.org/linuxfocus/index.html">LinuxFocus</uri>.
</p>

<p>
La guía <uri link="http://www.tldp.org/guides.html">Linux System
Administrators</uri> (disponible en la sección "Guías" de www.tldp.org) es
un buen complemento a esta serie de tutoriales, ¡dele una leída!
También <uri
link="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix
and Internet Fundamentals HOWTO</uri> de Eric S. Raymond le será de gran ayuda.
</p>

<p>
Puede leer el proyecto de documentación GNU en línea para el sistema de
información GNU (conocido también como "texinfo") en la página de
documentación <uri link="http://www.gnu.org/manual/texinfo/index.html">GNU's
texinfo</uri>.
</p>

<p>
Busque <uri link="http://www.tldp.org/links/#ng">Linux newsgroup list</uri>
en el sitio de LDP, y el archivo de noticias de grupo en <uri
link="http://groups.google.com/googlegroups/deja_announcement.html">Deja
News</uri>.
</p>

<p>

En la serie de artículos “Bash con ejemplos” de developerWorks, Daniel le
muestra cómo usar los programas constructores de bash para escribir sus
propios guiones de bash. Esta serie (particularmente la parte 1 y 2) será
una buena preparación para el examen LPIC nivel 1 y refuerza los conceptos
cubiertos en la sección "Ajustando el ambiente de usuario" de este tutorial:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p1.xml"> Bash con
    ejemplos, parte 1: Programación fundamental en la "Bourne again
    shell" (bash).</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p2.xml"> Bash con
    ejemplos, parte 2: Más fundamentos de programación en bash.</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p3.xml">Bash con
    ejemplos, parte 3: Explorando el sistema de ebuilds.</uri>
  </li>
</ul>

<p>
Recomendamos ampliamente el <uri
link="http://www-106.ibm.com/developerworks/linux/library/l-faq/">Technical
FAQ by Linux Users</uri> de Mark Chapman, un listado de 50 páginas que
muestran la lista de preguntas más frecuentes de Linux con respuestas
detalladas. El FAQ es un archivo formato PDF (Acrobat). Si es un usuario
Linux principiante o intermedio, definitivamente debe revisar este FAQ.
También recomendamos el <uri link=
"http://www-106.ibm.com/developerworks/linux/library/l-gloss/index.html">
Linux glossary for Linux users</uri>, también de Mark.
</p>

<p>
Si no está familiarizado con el editor vi, revise <uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxvi-i.html">Vi intro
-- the cheat sheet method tutorial</uri> de Daniel. Este tutorial le dará
una gentil y rápida introducción a este poderoso editor de texto. Considere
este material como un "debe leer" si desconoce cómo utilizar vi.
</p>

<p>
Para una introducción al editor Emacs, vea el tutorial de developerWorks,
<uri
link="http://www-106.ibm.com/developerworks/edu/l-dw-linuxemacs-i.html">
Living in Emacs</uri>.
</p>

</body>
</section>
<section>
<title>Comentarios</title>
<body>

<p>
Por favor permítanos conocer si este tutorial le fue de ayuda y cómo
podríamos mejorarlo. También nos gustaría saber qué otros temas le
gustaría que fueran cubiertos por los tutoriales de developerWorks.
</p>

<p>
Para preguntas sobre el contenido de este tutorial, contacte con los autores:
</p>

<ul>
  <li>Daniel Robbins, en <mail>drobbins@gentoo.org</mail></li>
  <li>Chris Houser, en <mail>chouser@gentoo.org</mail></li>
  <li>Aron Griffis, en <mail>agriffis@gentoo.org</mail>.</li>
</ul>

</body>
</section>
</chapter>
</guide>
