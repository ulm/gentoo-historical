<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/articles/lpi-101-fundamentals-p1.xml,v 1.1 2011/03/24 20:41:23 nimiux Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide lang="es" disclaimer="articles">

<title>Preparación para el examen de certificación 101 LPI (segundo
lanzamiento), Parte 1</title>

<author title="Author">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<!--<author title="Editor">
  <mail link="curtis119@gentoo.org">M Curtis Napier</mail>
</author>-->
<author title="Traductor">
  <mail link="nilda_46@hotmail.com">Gabriela Chacón Villanueva</mail>
</author>

<abstract>
Este tutorial es una introducción a bash (intérprete de comandos
estándar de Linux), se muestra como sacar el máximo provecho de
órdenes estándar de Linux como ls, cp y mv. Además contiene una
explicación de inodos, enlaces simbólicos, enlaces rígidos y mucho
más. Al final de este tutorial, tendrá una base sólida en los
fundamentos de Linux y estará listo para aprender algunas tareas
básicas de administración.
</abstract>

<!-- La versión original de este artículo fue publicada
originalmente por IBM developerWorks y es propiedad de Westtech
Information Services.
Este documento es una versión actualizada del artículo original y
contiene mejoras realizadas por el equipo de documentación de
Gentoo Linux -->

<version>1.4</version>
<date>2005-10-12</date>

<chapter>
<title>Antes de comenzar</title>
<section>
<title>Acerca de este tutorial</title>
<body>

<p>
Bienvenido a “Fundamentos de Linux”, el primero de cuatro
tutoriales diseñado para prepararlo para el examen 101 del
Instituto Profesional de Linux (Linux Professional Institute). En
este tutorial, haremos una introducción a bash (el intérprete de
comandos estándar de Linux), le mostraremos como tomar ventajas
de las órdenes estándar Linux (como ls, cp o mv), explicaremos
inodos, enlaces simbólicos y rígidos (soft y hard links), y mucho
más. Al final de este tutorial, tendrá una base sólida en los
fundamentos de Linux, y estará listo para aprender algunas tareas
básicas de administración de su sistema Linux. Cuando finalice
esta serie de tutoriales (ocho en total) tendrá el conocimiento
necesario para ser un Administrador de Sistemas Linux, y estará
preparado para, si así lo quisiera, la certificación LPIC de nivel
1 del Linux Professional Institute.
</p>

<p>
Este tutorial en particular (parte I) es ideal para aquellos que
son nuevos en Linux, o para aquellos que quieran revisar o
incrementar sus conocimientos de los conceptos fundamentales de
Linux, tales como copiar y mover archivos, crear enlaces simbólicos
y rígidos, o usar las órdenes estándar de Linux para procesamiento
de textos junto con tuberías (pipelines) y redirecciones.
A lo largo del camino aparecerán consejos, trucos y sugerencias
para  mantener el tutorial interesante y práctico, aún para
aquellos con una buena experiencia en Linux. Para los principiantes
este material resultará nuevo, pero los usuarios más experimentados
de Linux verán que este tutorial completará su conocimiento de los
fundamentos de Linux.
</p>

<p>
Para aquellos quienes han leído la versión 1 de este tutorial por
razones diferentes a las de prepararse para el examen LPI, es
probable que no necesiten leer esta versión. Sin embargo, si
planea presentar los exámenes, debe considerar seriamente
la lectura de este tutorial.
</p>

</body>
</section>
<section>
<title>Acerca del autor</title>
<body>

<p>
Residiendo en Albuquerque, Nuevo México, Daniel Robbins es el
Arquitecto en jefe de la metadistribución Gentoo Linux. También
escribe artículos y seminarios para IBM developerWorks y
Servicios de Desarrollo de Intel, y ha contribuido en la edición
de distintos libros como Samba y Linux SuSE Unleashed. Daniel
disfruta su tiempo con su esposa Mary y su hija Hadassah. Puede
contactarlo en la siguiente dirección: drobbins@gentoo.org.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Introducción a bash</title>
<section>
<title>El intérprete de comandos</title>
<body>

<p>
Si ha usado un sistema Linux, sabrá que cuando ingresa
al sistema (log in) es saludado con un prompt que luce más o
menos así:
</p>

<pre caption="El prompt">
$
</pre>

<p>
El prompt que realmente ve puede lucir un tanto diferente.
Puede contener el nombre de anfitrión de su sistema (hostname),
el nombre de directorio actual de trabajo o ambos. Más allá de
como se vea su prompt lo importante es saber lo siguiente: el
programa que imprimió ese prompt se llama “intérprete de comandos”,
y es muy probable que su intérprete de comandos particular sea uno
llamado <c>bash</c>.
</p>

</body>
</section>
<section>
<title>¿Está utilizando bash?</title>
<body>

<p>
Puede revisar si está utilizando <c>bash</c> tecleando:
</p>

<pre caption="La variable SHELL">
$ <i>echo $SHELL</i>
/bin/bash
</pre>

<p>
Si con la línea de arriba obtuvo un mensaje de error o no
respondió de la misma forma que en nuestro ejemplo, entonces
está usando algún otro intérprete de comandos. En ese caso la mayor
parte de este tutorial puede aplicarse, pero si se está preparando
para el examen 101, le recomendamos cambiar a <c>bash</c>.
<!--(En el siguiente tutorial de la serie, en administración básica,
se muestra cómo cambiar su intérprete de comandos usando la orden
<c>chsh</c>.)-->
</p>

</body>
</section>
<section>
<title>Acerca de bash</title>
<body>

<p>
Bash, es un acrónimo para intérprete de comandos renacido
(Bourne-again-shell), es el intérprete de comandos por omisión en la
mayoría de los sistemas Linux. El trabajo de un intérprete de
comandos es obedecer sus órdenes de manera que pueda interactuar con
su sistema Linux. Cuando termine de introducir órdenes, puede
solicitarle a su intérprete de comandos salir a través de exit o
logout. En ese momento regresará al prompt de inicio de sesión.
</p>

<p>
A propósito, también puede salir de su sesión tecleando control-D
en el prompt de su bash.
</p>

</body>
</section>
<section>
<title>Usando "cd"</title>
<body>

<p>
Como seguramente habrá notado, situarse en el prompt de su bash
no es la cosa mas emocionante. Así que comencemos a usar bash
para navegar en nuestro sistema de archivos (filesystem). En el
prompt, teclee lo siguiente (sin incluir el <c>$</c>):
</p>

<pre caption="Cambiar de directorio">
$ <i>cd /</i>
</pre>

<p>
Con esto le ha dicho a bash que quiere trabajar en el
directorio /, también conocido como raíz. Todos los directorios
en el sistema forman un árbol, y / es considerado la raíz de
éste. cd establece el directorio donde trabaja actualmente,
también conocido como “directorio actual de trabajo” (current
working directory).
</p>

</body>
</section>
<section>
<title>Rutas</title>
<body>

<p>
Para ver el directorio actual de trabajo de bash, escriba:
</p>

<pre caption="Directorio actual de trabajo">
$ <i>pwd</i>
/
</pre>

<p>
En el ejemplo de arriba,  el argumento / es llamado <e>path</e>,
el cual indica hacia donde queremos dirigirnos. En particular,
el argumento / es un path <e>absoluto</e>, es decir especifica
la ubicación relativa a la raíz del árbol del sistema de archivos.
</p>

</body>
</section>
<section>
<title>Rutas absolutas</title>
<body>

<p>
Aquí se muestran otras rutas absolutas:
</p>

<pre caption="Ejemplos de rutas absolutas">
/dev
/usr
/usr/bin
/usr/local/bin
</pre>

<p>
Como puede ver, lo único que estas rutas absolutas tienen en
común es que todas comienzan con /. Si le damos a cd el path
/usr/local/bin, primero cd entrará al directorio /, desde allí
luego entrará al directorio usr, y recién desde allí entrará a
bin. Las rutas absolutas siempre son evaluadas a partir de /.
</p>

</body>
</section>
<section>
<title>Rutas relativas</title>
<body>

<p>
El otro tipo de rutas es el de las <e>rutas relativas</e>. <c>
bash</c>, <c>cd</c>, y otras órdenes siempre interpretan este
tipo de rutas como relativas al directorio actual de trabajo.
Las rutas relativas nunca comienzan con /. Así que si estamos en
/usr:
</p>

<pre caption="Cambiar de directorio con rutas absolutas">
$ <i>cd /usr</i>
</pre>

<p>
Entonces, puede usar una ruta relativa para cambiar el
directorio actual a /usr/local/bin:
</p>

<pre caption="Cambiar de directorio con rutas relativas">
$ <i>cd local/bin</i>
$ <i>pwd</i>
/usr/local/bin
</pre>

</body>
</section>
<section>
<title>Uso de ..</title>
<body>

<p>
Las rutas relativas pueden contener uno o mas directorios .. El
directorio .. es un directorio especial que apunta al directorio
padre del actual. De esta manera, y continuando con el ejemplo
anterior:
</p>

<pre caption="Uso de la notación del 'directorio padre'">
$ <i>pwd</i>
/usr/local/bin
$ <i>cd ..</i>
$ <i>pwd</i>
/usr/local
</pre>

<p>
Como puede ver, el directorio actual de trabajo ahora es
/usr/local. De esta forma podemos “volver atrás” un directorio
con respecto al cual estamos situados.
</p>

<p>
Además, podemos incluir el directorio .. en alguna ruta relativa,
permitiéndonos ir a algún directorio que se encuentre en alguna
rama lateral del árbol de directorios. Por ejemplo:
</p>

<pre caption="Uso de la notación del directorio padre en rutas
relativas">
$ <i>pwd</i>
/usr/local
$ <i>cd ../share</i>
$ <i>pwd</i>
/usr/share
</pre>

</body>
</section>
<section>
<title>Ejemplos de rutas relativas</title>
<body>

<p>
Las rutas relativas pueden volverse un tanto complejas. Aquí van
algunos ejemplos, ninguno muestra el directorio objetivo.
Intente entender donde quedará situado después de teclear cada
una de estas órdenes:
</p>

<pre caption="Ejemplos de rutas relativas">
$ <i>cd /bin</i>
$ <i>cd ../usr/share/zoneinfo</i>


$ <i>cd /usr/X11R6/bin</i>
$ <i>cd ../lib/X11</i>


$ <i>cd /usr/bin</i>
$ <i>cd ../bin/../bin</i>
</pre>

<p>
Ahora, inténtelo y verifique si sus respuestas son las correctas
:).
</p>

</body>
</section>
<section>
<title>Entendiéndolo</title>
<body>

<p>
Antes de terminar con la orden cd hay algunas cosas más que vale la
pena mencionar. Primero hablaremos de otro directorio especial
llamado ., que se refiere al directorio actual. Aunque este
directorio no suele ser utilizado con la orden cd, si es útil,
por ejemplo, para ejecutar algún programa situado en el
directorio actual, como se ve a continuación:
</p>

<pre caption="Correr programa desde la ubicación actual">
$ <i>./miprograma</i>
</pre>

<p>
En el ejemplo anterior, se ejecutará el archivo ejecutable
miprograma que reside en el directorio actual de trabajo.
</p>

</body>
</section>
<section>
<title>cd y el directorio home</title>
<body>

<p>
Si lo que quiere es cambiar el directorio actual a su
directorio home, entonces escriba:
</p>

<pre caption="Ir al directorio HOME">
$ <i>cd</i>
</pre>

<p>
Cuando utilice la orden cd sin argumentos, este lo llevará a su
directorio home. Será el directorio /root para el super-usuario,
y /home/nombredeusuario para usuarios comunes. Ahora bien...
¿qué sucede si lo que quiere es referirse a un archivo
situado en su directorio home? Quizás lo que quiera sea
pasar un archivo como argumento a su ejecutable <c>miprograma</c>.
Si el archivo está en su directorio home, entonces puede escribir:
</p>

<pre caption="Ejecutar un programa en el directorio actual">
$ <i>./miprograma /home/juanperez/miarchivo.txt</i>
</pre>

<p>
Sin embargo, usar rutas absolutas no es siempre lo más conveniente.
Afortunadamente, puede hacer uso del carácter ~ para hacer lo mismo:
</p>

<pre caption="Uso de la notación 'directorio home'">
$ <i>./miprograma ~/miarchivo.txt</i>
</pre>

</body>
</section>
<section>
<title>Directorios home de otros usuarios</title>
<body>

<p>
bash expandirá un simple ~ (tilde) para apuntar a su directorio
home, pero también puede usar el tilde para apuntar a los
directorio home de los otros usuarios. Por ejemplo, si quiere
referirse a un archivo llamado archivodejuan.txt en el directorio
home de juan, entonces puede teclear lo siguiente:
</p>

<pre caption="Ejemplo del uso de la notación de 'directorio home'">
$ <i>./miprograma ~juan/archivodejuan.txt</i>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Uso de órdenes Linux</title>
<section>
<title>Introducción a ls</title>
<body>

<p>
Ahora, vamos a darle una pequeña mirada a la orden ls. Muy
probablemente ya haya tenido contacto con la orden ls, y
sabe que teclearlo mostrará el contenido del directorio actual
de trabajo:
</p>

<pre caption="Listado de archivos">
$ <i>cd /usr</i>
$ <i>ls</i>
X11R6      doc         i686-pc-linux-gnu  lib      man
sbin   ssl
bin        gentoo-x86  include            libexec  portage
share  tmp
distfiles  i686-linux  info               local    portage.old  src
</pre>

<p>
Especificando la opción -a, podrá ver todos los archivos del
directorio, incluyendo los archivos ocultos (aquellos que
comienzan con .). Como se ve en el siguiente ejemplo, ls -a
muestra también los enlaces a directorios especiales . y ..
</p>

<pre caption="Listado de archivos, incluyendo los ocultos">
$ <i>ls -a</i>
.      bin        gentoo-x86         include  libexec  portage
share  tmp
..     distfiles  i686-linux         info     local    portage.old
src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin
ssl
</pre>

</body>
</section>
<section>
<title>Listado completo de información</title>
<body>

<p>
A la orden <c>ls</c> le puede especificar uno o más
archivos o directorios a través de la línea de comandos. Si
especifica un archivo, <c>ls</c> sólo mostrará este archivo,
pero si especifica un directorio, entonces <c>ls</c> listará el
<e>contenido</e> de ese directorio. La opción <c>-l</c> le
resultará de gran utilidad cuando quiera ver información sobre
permisos, tiempos de modificación, tamaño de los contenidos
listados.
</p>

<p>
En el siguiente ejemplo, se utiliza la opción <c>-l</c> para
desplegar un listado completo del directorio /usr..
</p>

<pre caption="Listado de archivos con información completa">
$ <i>ls -l /usr</i>
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -&gt;
share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17
i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -&gt;
share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -&gt;
share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage
-&gt; gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -&gt;
../var/tmp
</pre>

<p>
La primera columna muestra la información sobre permisos para cada
elemento en la lista. La columna siguiente lista el número de
enlaces para cada objeto del sistema de archivos. La tercer y cuarta
columna listan el propietario del elemento, y el grupo al cual
pertenece, respectivamente. La quinta muestra el tamaño de los
objetos, mientras que la sexta menciona cuando fue realizada la
última modificación del objeto (“last modified time” o “mtime”).
La última columna es el nombre del objeto.
Si el archivo es un enlace simbólico, entonces verá una
flecha -&gt; y la ruta hacia donde apunta el enlace simbólico.
</p>

</body>
</section>
<section>
<title>Mirando los directorios</title>
<body>

<p>
A veces, querrá mirar los directorios, en vez de dentro de
ellos. Para estas situaciones puede especificar la opción <c>-d
</c>, la cual le dirá a ls que mire los directorios, y no dentro
de ellos como normalmente sucede:
</p>

<pre caption="Listando directorios">
$ <i>ls -dl /usr /usr/bin /usr/X11R6/bin ../share</i>
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52
/usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
</pre>

</body>
</section>
<section>
<title>Listados recursivos y de inodos</title>
<body>

<p>
Puede usar <c>-d</c> para mirar un directorio, o puede
utilizar <c>-R</c> para hacer lo opuesto: no sólo mirar dentro
de un directorio, sino que puede mirar recursivamente dentro de
todos los directorios que a su vez se encuentran dentro del
actual. No incluiremos ningún ejemplo de la salida que produce
esta opción (ya que generalmente es muy grande), pero
puede probar con las ordenes <c>ls -R</c> y <c>ls -Rl</c> para
tener una idea de cómo trabajan.
</p>

<p>
Finalmente, la opción <c>-i</c> para la orden ls puede ser usada
para mostrar el número de inodos de los objetos del sistema de
archivos listados:
</p>

<pre caption="Listado de inodos">
$ <i>ls -i /usr</i>
   1409 X11R6        314258 i686-linux           43090
libexec        13394 sbin
   1417 bin            1513 i686-pc-linux-gnu     5120
local          13408 share
   8316 distfiles      1517 include                776
man            23779 src
     43 doc            1386 info                 93892
portage        36737 ssl
  70744 gentoo-x86     1585 lib                   5132
portage.old      784 tmp
</pre>

</body>
</section>
<section>
<title>Entendiendo inodos</title>
<body>

<p>
Cada objeto dentro del sistema de archivos tiene asignado un índice único,
llamado un número de <e>inodo</e>. Esto parecería ser trivial,
pero entender el concepto de inodos es esencial para comprender
muchas de las operaciones de un sistema de archivos. Por ejemplo,
considere los links . y .. que aparecen en cada directorio. Para
tener completo entendimiento de qué es realmente el directorio..
primero veamos el número de inodo de /usr/local:
</p>

<pre caption="Listado de inodo para un directorio">
$ <i>ls -id /usr/local</i>
   5120 /usr/local
</pre>

<p>
El directorio /usr/local tiene el número de inodo 5120. Ahora,
revisemos el número de inodo de /usr/local/bin/.. :
</p>

<pre caption="Listado de inodo para un directorio">
$ <i>ls -id /usr/local/bin/..</i>
   5120 /usr/local/bin/..
</pre>

<p>
Como puede ver, /usr/local/bin/.. tiene el mismo número de inodo
que /usr/local. Veamos como explicar esta impactante revelación.
Hace poco, considerábamos a /usr/local como un directorio.
Ahora, descubrimos que el inodo 5120, es en realidad el
verdadero directorio, y además encontramos dos entradas en el
directorio (también llamadas enlaces), que apuntan a este inodo.
Tanto /usr/local/ como /usr/local/bin/.. son enlaces al inodo
5120. A pesar de que el inodo 5120 existe solamente en un lugar
del disco duro, múltiples enlaces pueden apuntar a él. El inodo
5120 es la verdadera entrada en el disco.
</p>

<p>
De hecho, es posible ver el número total de veces que el inodo
5120 es referenciado, usando la orden <c>ls -dl</c>:
</p>

<pre caption="Listado de las referencias al inodo">
$ <i>ls -dl /usr/local</i>
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
</pre>

<p>
Si tomamos la segunda columna de la izquierda, veremos que el
directorio /usr/local (inodo 5120) es referenciado ocho veces.
Aquí va una lista de algunas rutas que, en mi sistema, apuntan a
ese inodo:
</p>

<pre caption="Referencias al inodo">
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
</pre>

</body>
</section>
<section>
<title>mkdir</title>
<body>

<p>
Ahora, veamos brevemente la orden mkdir que puede ser usada para
crear directorios nuevos. El siguiente ejemplo crea tres
directorios nuevos, piedra, papel y tijera, todos dentro de /tmp:
</p>

<pre caption="Crear directorios">
$ <i>cd /tmp</i>
$ <i>mkdir piedra papel tijera</i>
</pre>

<p>
De forma predeterminada, el comando mkdir no creará directorios
padre; la ruta completa hasta el penúltimo elemento
debe existir previamente. De modo que si quiere crear los
directorios <path> ma/ra/villa</path>, tendrá que enviar tres
órdenes separadas de <c>mkdir</c>:
</p>

<pre caption="Crear directorios padres">
$ <i>mkdir ma/ra/villa</i>
mkdir: cannot create directory `ma/ra/villa': No such file or
directory
$ <i>mkdir ma</i>
$ <i>mkdir ma/ra</i>
$ <i>mkdir ma/ra/villa</i>
</pre>

<p>
Sin embargo, mkdir tiene una opción, -p que le indica crear
cualquier directorio padre faltante, como se ve a continuación:
</p>

<pre caption="Creando directorios padres sobre la marcha">
$ <i>mkdir -p asi/de/facil</i>
</pre>

<p>
Bastante sencillo, ¿no?. Para aprender más sobre la orden mkdir
escriba <c>man mkdir</c>, para leer la página de manual. Esto
sirve para casi todos las órdenes que veremos aquí (por ejemplo
<c>man ls</c>), excepto para cd ya que este es una orden interna
(built-in) de bash.
</p>

</body>
</section>
<section>
<title>touch</title>
<body>

<p>
Ahora, revisemos rápidamente las órdenes <c>cp</c> y <c>mv</c>,
usadas para copiar, renombrar y mover archivos y directorios.
Para comenzar, usaremos la orden <c>touch</c> para crear un
archivo en /tmp:
</p>

<pre caption="Crear un archivo">
$ <i>cd /tmp</i>
$ <i>touch copiame</i>
</pre>

<p>
La orden touch actualiza el "mtime" de un archivo si este ya
existe (ver la sexta columna de la salida de la orden <c>ls -l
</c>). Si el archivo no existía, un nuevo archivo vacío es creado.
Ahora debe de tener el archivo <path>/tmp/copiame</path> con un
tamaño de cero.
</p>

</body>
</section>
<section>
<title>echo</title>
<body>

<p>
Ahora que el archivo existe, le agregaremos algunos datos. Esto
lo podemos hacer mediante la orden echo, que toma sus argumentos
y los imprime en la salida estándar. Primero, sólo la orden echo:
</p>

<pre caption="Creando un archivo utilizando 'echo'">
$ <i>echo "primerarchivo"</i>
primerarchivo
</pre>

<p>
Ahora, la misma orden echo pero redireccionando su salida:
</p>

<pre caption="Redireccionando la salida">
$ <i>echo "primerarchivo" &gt; copiame</i>
</pre>

<p>
El signo mayor que &gt; le dice al intérprete de comandos que
escriba la salida de echo a un archivo llamado copiame. Este
archivo será creado si no existe, y será sobrescrito si
existía  previamente. Escribiendo  <c>ls-l</c>, podemos ver
que ahora el archivo copiame tiene 14 bytes de tamaño, ya que
contiene la palabra primerarchivo y el carácter salto de línea:
</p>

<pre caption="Ver la información del archivo">
$ <i>ls -l copiame</i>
-rw-r--r--    1 root     root           10 Dec 28 14:13 copiame
</pre>

</body>
</section>
<section>
<title>cat y cp</title>
<body>

<p>
Para ver los contenidos de un archivo en una terminal, use la
orden cat:
</p>

<pre caption="Ver contenido del archivo">
$ <i>cat copiame</i>
primerarchivo
</pre>

<p>
Ahora podemos hacer una invocación básica de la orden <c>cp</c>
para crear el archivo copiado, siendo este una copia del
original copiame.
</p>

<pre caption="Copiar archivos">
$ <i>cp copiame copiado</i>
</pre>

<p>
Si investigamos, veremos que son distintos archivos, pues sus
números de inodos son diferentes:
</p>

<pre caption="Revisando las diferencias de inodo">
$ <i>ls -i copiame copiado</i>
  648284 copiame   650704 copiado
</pre>

</body>
</section>
<section>
<title>mv</title>
<body>

<p>
Usemos ahora la orden mv para renombrar “copiame” a “renombrado”.
El número de inodo permanecerá igual; sin embargo, el nombre del
archivo que apunta a él si cambiará.
</p>

<pre caption="Renombrar un archivo">
$ <i>mv copiame renombrado</i>
$ <i>ls -i renombrado</i>
  648284 renombrado
</pre>

<p>
Un número de inodo de un archivo movido o renombrado permanecerá
igual mientras el archivo resida en el mismo sistema de archivos que el
archivo fuente. (Veremos más de cerca los sistemas de archivos
en la Parte 3 de esta serie de tutoriales).
</p>

<p>
Hablando de mv, veamos otra manera de usar la orden mv, ya que
además de permitirnos renombrar archivos, nos permite mover uno
o más archivos hacia otra ubicación en la jerarquía de
directorios. Por ejemplo, para mover <path>/var/tmp/miarchivo.txt
</path> a <path>/home/juanperez</path>, escribiremos:
</p>

<pre caption="Mover un archivo a una ubicación direfente">
$ <i>mv /var/tmp/miarchivo.txt /home/juanperez</i>
</pre>

<p>
Después de teclear la orden, miarchivo.txt será movido a <path>
/var/tmp/miarchivo.txt</path>. Si <path>/home/juanperez</path>
está en un sistema de archivos distinto del de /home/juanperez,
la orden mv se encargará de copiar miarchivo.txt al nuevo
sistema de archivos, y luego borrar el antiguo del sistema de
archivo. Como estará imaginando, cuando miarchivo.txt se
traslada entre sistemas de archivos, el nuevo archivo
miarchivo.txt en la nueva ubicación tendrá un nuevo número de
inodo. Esto es porque cada sistema de archivos tiene su propio
conjunto de inodos independiente.
</p>

<p>
También podemos usar la orden mv para mover varios archivos a un
mismo directorio. Por ejemplo, para mover miarchivo1.txt y
miarticulo2.txt a /home/juanperez, puede teclear:
</p>

<pre caption="Mover multiples archivos">
$ <i>mv /var/tmp/miarchivo1.txt /var/tmp/miarticulo2.txt
/home/juanperez</i>
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Creando enlaces y eliminando archivos </title>
<section>
<title>Enlaces rígidos (Hard links)</title>
<body>

<p>
Hemos mencionado ya el término "enlace" cuando nos referimos a la
relación entre las entradas en los directorios (los nombres que
escribimos) y los inodos (el número de índice en el sistema de
archivos subyacente que usualmente ignoramos). En realidad hay
dos clases de enlaces en Linux, la clase que hemos discutido
hasta aquí son llamados hard links. Un número de inodo dado
puede tener cualquier número de enlaces rígidos, y el inodo
persistirá en el sistema de archivos hasta que el enlace
permanente desaparezca. Cuando el último enlace permanente
desaparece y ningún programa mantiene el archivo abierto, Linux
eliminará el archivo automáticamente. Para crear un nuevo enlace
permanente se utiliza la orden <c>ln</c>:
</p>

<pre caption="Enlace de archivos">
$ <i>cd /tmp</i>
$ <i>touch primerenlace</i>
$ <i>ln primerenlace segundoenlace</i>
$ <i>ls -i primerenlace segundoenlace</i>
  15782 primerenlace    15782 segundoenlace
</pre>

<p>
Como podrá ver, los enlaces rígidos trabajan en el nivel de los
inodos para apuntar a un archivo en particular. En los sistemas
Linux, los enlaces rígidos, tienen varias limitaciones. Uno es
que sólo se pueden hacer enlaces rígidos a archivos, y no a
directorios. Así es, aunque . y .. son enlaces rígidos a
directorios creados por el sistema, (ni siquiera como root)
no tiene permitido crear alguno propio. La segunda limitación es
que no pueden expandirse a través de distintos sistemas de
archivos. Esto significa que no puede crear un enlace permanente
desde /usr/bin/bash hacia /bin/bash si sus directorios / y /usr
pertenecen a distintos sistemas de archivos.
</p>

</body>
</section>
<section>
<title>Enlaces simbólicos (Symbolic links)</title>
<body>

<p>
En la práctica, los enlaces simbólicos (<e>symlinks</e>)
usualmente son más utilizados que los enlaces rígidos. Los
enlaces simbólicos son un tipo de archivo especial, donde el enlace se
refiere a otro archivo a través de su nombre, en vez de hacerlo
directamente al inodo. Los enlaces simbólicos no evitan que un archivo sea
borrado, pues si elimina el archivo hacia el cual apunta el
enlace, entonces el enlace simbólico deja de ser útil: se lo considera
roto o inutilizable.
</p>

<p>
Un enlace simbólico puede ser creado agregando la opción -s a la
orden ln.
</p>

<pre caption="Ver enlaces simbólicos">
$ ln -s segundoenlace  tercerenlace
$ ls -l primerenlace  segundoenlace  tercerenlace
-rw-rw-r--    2 arturo arturo        0 Dec 31 19:08 primerenlace
-rw-rw-r--    2 arturo arturo        0 Dec 31 19:08 segundoenlace
lrwxrwxrwx    1 arturo arturo       10 Dec 31 19:39 tercerenlace
-&gt; segundoenlace
</pre>

<p>
En la salida de <c>ls -l</c> los enlaces simbólicos pueden ser
diferenciados de los archivos comunes de tres formas. Por un
lado, en la primer columna un carácter l indica que se trata de
un enlace simbólico. Segundo, el tamaño de un enlace simbólico
es el número de caracteres del archivo apuntado (<c>segundoenlace</c>
en nuestro caso). Por último, en la última columna se ve el
archivo apuntado precedido por una linda flechita -&gt;.
</p>

</body>
</section>
<section>
<title>Profundizando enlaces simbólicos</title>
<body>

<p>
Los enlaces simbólicos son por lo general mucho más flexibles que
los rígidos. Puede crear un enlace simbólico que apunte a
cualquier tipo de objeto del sistema de archivos, incluso
directorios. Y como la implementación de los enlaces simbólicos
está basada en rutas (y no inodos), es perfectamente posible
crear un enlace simbólico que apunte a un objeto de otro sistema
de archivos. Sin embargo, esto también puede hacer más difíciles
de entenderlos.
</p>

<p>
Considere una situación donde quiere crear un enlace en
/tmp que apunte a /usr/local/bin. Debería escribir algo como esto:
</p>

<pre caption="Enlazar directorios, primer intento">
$ <i>ln -s /usr/local/bin bin1</i>
$ <i>ls -l bin1</i>
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -&gt;
/usr/local/bin
</pre>

<p>
O alternativamente:
</p>

<pre caption="Enlazar directorios, segundo intento">
$ <i>ln -s ../usr/local/bin bin2</i>
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt;
../usr/local/bin
</pre>

<p>
Como podrá ver, ambos enlaces simbólicos apuntan al mismo
directorio. Sin embargo, si el segundo enlace es movido a
otro directorio, entonces quedará "roto" pues la ruta relativa
será incorrecta:
</p>

<pre caption="Romper un enlace simbólico">
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt;
../usr/local/bin
$ <i>mkdir nuevodir</i>
$ <i>mv bin2 nuevodir</i>
$ <i>cd nuevodir</i>
$ <i>cd bin2</i>
bash: cd: bin2: No such file or directory
</pre>

<p>
Como el directorio /tmp/usr/local/bin no existe, entonces ya
no podrá cambiar de directorio hacia bin2; en otras
palabras, bin2 ahora está roto.
</p>

<p>
Por esta razón, es buena idea evitar crear enlaces
simbólicos con rutas relativas. Sin embargo, hay muchos
casos en que sí será útil. Considere por ejemplo el caso que
quiera crear un nombre alternativo para un programa
dentro de /usr/bin:
</p>

<pre caption="Ver la información del archivo llavero">
# <i>ls -l /usr/bin/llavero</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09
/usr/bin/llavero
</pre>

<p>
Como usuario root, podría querer crear un nombre
alternativo para “llavero”, como por ejemplo “llave”. En
este ejemplo, teniendo acceso de root (como queda
evidenciado por el prompt de bash: un #). Necesitará poseer
los privilegios de root porque los usuarios comunes no
tienen permitido crear archivos en /usr/bin. Siendo root,
puede crear un nombre alternativo para llavero de la
siguiente manera:
</p>

<pre caption="Crear enlace simbólico para llavero">
# <i>cd /usr/bin</i>
# <i>ln -s /usr/bin/llavero llave</i>
# <i>ls -l llavero</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09
/usr/bin/llavero
# <i>ls -l llave</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 llave -&gt;
/usr/bin/llavero
</pre>

<p>
En este ejemplo, creamos un enlace simbólico llamado llave que
apunta a al archivo /usr/bin/llavero.
</p>

<p>
Aunque la solución recién dada funciona, puede llegar a
traernos problemas si decidiéramos mover ambos archivos
(/usr/bin/llavero y /usr/bin/llave) a /usr/local/bin:
</p>

<pre caption="Mover el enlace simbólico">
# <i>mv /usr/bin/llavero  /usr/bin/llave /usr/local/bin</i>
# <i>ls -l /usr/local/bin/llavero </i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09
/usr/local/bin/llavero
# <i>ls -l /usr/local/bin/llave</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 llave -&gt;
/usr/bin/llavero
</pre>

<p>
Como hemos usado una ruta absoluta para crear nuestro enlace
permanente, llave aún sigue apuntando a /usr/bin/llavero, y
como acababa de ser trasladado, /usr/bin/llavero no existe
más, pues ahora su ruta es /usr/local/bin/llavero.
</p>

<p>
Esto entonces significa que llave ahora es un enlace simbólico roto.
Por lo visto tanto los enlaces simbólicos con rutas absolutas como
aquellos con rutas relativas tienen sus méritos, y
deberá elegir el tipo de ruta apropiado para su aplicación.
Frecuentemente ambos tipos de rutas funcionarán bien. El
siguiente ejemplo funcionará aún después de que ambos
archivos sean traslados:
</p>

<pre caption="Mover archivos con enlaces simbólicos">
# <i>cd /usr/bin</i>
# <i>ln -s llavero llave</i>
# <i>ls -l llave</i>
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 llave -&gt;
llavero
# <i>mv llavero  llave /usr/local/bin</i>
# <i>ls -l /usr/local/bin/llavero </i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09
/usr/local/bin/llavero
# <i>ls -l /usr/local/bin/llave</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 llave -&gt;
llavero
</pre>

<p>
Ahora, escribiendo /usr/local/bin/llave puede ejecutar
el programa llavero. /usr/local/bin/llave apunta al programa
llavero que está en el mismo directorio que llave.
</p>

</body>
</section>
<section>
<title>rm</title>
<body>

<p>
Ahora que conocemos cómo usar las ordenes cp, mv y ln, es
hora de aprender a eliminar objetos de nuestro sistema de
archivos. Usualmente esto puede llevarse a cabo con la orden
<c>rm</c>. Para eliminar archivos, simplemente
especifíquelos con en la línea de comandos:
</p>

<pre caption="Eliminar archivos">
$ <i>cd /tmp</i>
$ <i>touch arch1  arch2</i>
$ <i>ls -l arch1  arch2</i>
-rw-r--r--    1 root     root            0 Jan  1 16:41 arch1
-rw-r--r--    1 root     root            0 Jan  1 16:41 arch2
$ <i>rm arch1  arch2</i>
$ <i>ls -l arch1  arch2</i>
ls: arch1 : No such file or directory
ls: arch2: No such file or directory
</pre>

<p>
Es importante destacar que en Linux, una vez que un archivo es
eliminado, generalmente es para siempre. Por esta razón, muchos
administradores principiantes utilizan la opción -i cuando eliminan
archivos. La opción -i le dice a rm que elimine archivos de modo
interactivo, esto es, preguntando antes de eliminar cada archivo.
Por ejemplo:
</p>

<pre caption="Eliminar archivos y pedir confirmación">
$ <i>rm -i arch1 arch2</i>
rm: remove regular empty file `arch1'? y
rm: remove regular empty file `arch2'? y
</pre>

<p>
En el ejemplo, la orden rm pregunta por cada archivo especificado
si se desea realmente borrar el archivo. Si la respuesta es sí,
deberá teclear una “y” (de yes) seguida de un Enter para cada
pregunta. Si escribe una “n”, el archivo entonces no será removido.
Si hubiera hecho algo realmente mal, podrá abortar la orden en
ejecución (rm -i en nuestro caso) tecleando Control-C. Al
abortarlo, todos los cambios y modificaciones que hubiere
ocasionado ya estarán hechos, pero impediremos que continúe hasta
el final.
</p>

<p>
Si recién está comenzando a familiarizarse con la orden rm,
puede ser de gran ayuda que agregue la siguiente línea a su archivo
~/.bashrc usando el editor de textos que prefiera, y luego salir y
volver a entrar a la sesión. Ahora, cada vez que escriba rm,
su intérprete de comandos bash lo convertirá automáticamente en la
orden rm -i. De esta manera, rm siempre funcionará de modo
interactivo:
</p>

<pre caption="Fijar el alias 'rm -i'">
<i>alias rm="rm -i"</i>
</pre>

</body>
</section>
<section>
<title>rmdir</title>
<body>

<p>
Para remover directorios, tenemos dos opciones. Una es eliminar
primero todo el contenido del directorio y luego usar la orden
<c>rmdir</c> para borrar el directorio mismo:
</p>

<pre caption="Eliminar directorios">
$ <i>mkdir midir</i>
$ <i>touch midir/arch1</i>
$ <i>rm midir/arch1</i>
$ <i>rmdir midir</i>
</pre>

<p>
Este método es comúnmente llamado “eliminación de directorios para
tontos”. Todos los usuarios experimentados y administradores
respetables utilizan la orden <c>rm -rf</c> que veremos a
continuación.
</p>

<p>
La mejor forma de eliminar un directorio es usando <e>fuerza
recursiva</e> (recursive force) de rm. De esta manera se le indica
a la orden rm que remueva el directorio especificado como así
también todos los objetos dentro del mismo:
</p>

<pre caption="Eliminar un directorio completamente">
$ <i>rm -rf midir</i>
</pre>

<p>
Generalmente, rm -rf es el método preferido para eliminar un árbol
de directorios. Tenga cuidado usando rm -rf ya que su poder puede
ser usado para bien o para mal :).
</p>

</body>
</section>
</chapter>
<chapter>
<title>Usar comodines (Wild cards)</title>
<section>
<title>Introducción a comodines</title>
<body>

<p>
En el uso diario de Linux, hay muchas ocasiones en que
necesitará llevar a cabo alguna operación simple (rm por ejemplo)
en muchos elementos del sistema de archivos simultáneamente. En
estas situaciones, puede llegar a ser tedioso y molesto tener que
teclear cada uno de los archivos en la línea de comandos:
</p>

<pre caption="Eliminar archivos individualmente">
$ <i>rm arch1 arch2 arch3 arch4 arch5 arch6 arch6 arch8</i>
</pre>

<p>
Para resolver este problema, puede tomar ventaja del soporte
de comodines de Linux. Este soporte, también llamado “globbing”
(por razones históricas), le permite a especificar múltiples
archivos al mismo tiempo usando un patrón de comodín (<e>wildcard
pattern</e>). Bash y otras órdenes de Linux interpretarán este
patrón buscando en el disco y encontrarán los archivos que
coincidan con él. Así, si tiene archivos arch1,
arch2,...,arch8 en el directorio actual de trabajo, podrá borrarlos
todos juntos tecleando:
</p>

<pre caption="Eliminación de archivos usando terminación">
$ <i>rm arch[1-8]</i>
</pre>

<p>
O, si quisiera simplemente remover todos los archivos que
comenzaran con arch o que directamente se llamen arch, puede
teclear:
</p>

<pre caption="Eliminación de archivos usando terminación con *">
$ <i>rm arch*</i>
</pre>

<p>
El comodín * coincide con cualquier carácter o secuencia de
caracteres, e incluso con “ningún carácter”. Por supuesto, los
comodines pueden ser usados para muchas cosas además de una simple
eliminación de archivos, como veremos más adelante.
</p>

</body>
</section>
<section>
<title>Entendiendo las no-coincidencias (non-matches)</title>
<body>

<p>
Si quisiera listar todos los objetos del sistema de archivos
de /etc que comiencen con g, como así también que se llame
solamente g, puede teclear:
</p>

<pre caption="Ejemplo del uso de * ">
$ <i>ls -d /etc/g*</i>
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome
/etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
</pre>

<p>
Ahora, veamos que sucede su especificamos un patrón que no coincide
con ningún objeto de sistema de archivos. En el ejemplo siguiente,
trataremos de listar todos los archivos de /usr/bin que comiencen
con asdf y termine con jkl, incluyendo potencialmente el archivo
asdfjkl:
</p>

<pre caption="Otro ejemplo del uso de *">
$ <i>ls -d /usr/bin/asdf*jkl</i>
ls: /usr/bin/asdf*jkl: No such file or directory
</pre>

<p>
Aquí vimos que ocurre. Normalmente, cuando especificamos un patrón,
ese patrón coincide con uno o más archivos del subyacente sistema
de archivos, y <e>bash reemplaza el patrón por una lista de todos
los objetos coincidentes separados entre sí por un espacio vacío</e>
. Sin embargo, cuando no se produce ninguna coincidencia, <e>bash
deja el argumento, comodín y todo, tal cual</e>. Así, cuando
ls no encuentra el archivo /usr/bin/asdf*jkl nos muestra el mensaje
apropiado de error. La regla operativa aquí es que <e>los patrones
deben ser expandidos sólo si coinciden con elementos del sistema de
archivos</e>. De otro modo, permanecen como son y pasan
literalmente al programa con que fueron llamados.
</p>

</body>
</section>
<section>
<title>Sintaxis de comodines: * y ?</title>
<body>

<p>
Ahora que hemos visto como trabaja el englobamiento (globbing)
echaremos una mirada a la sintaxis de los comodines. Puede
usar caracteres especiales para expansión:
</p>

<p>
* coincidirá con cero o más caracteres. Esto significa que
“cualquier cosa puede ir aquí, incluido nada”. Veamos algunos
ejemplos:
</p>

<ul>
  <li>
    /etc/g* coincidirá con todos los archivos del directorio /etc
    que comiencen con g, o archivos llamados g.
  </li>
  <li>
    /tmp/mi*1 coincidirá con los archivos de /tmp que comiencen con
    mi y terminen con 1, incluyendo el archivo mi1.
  </li>
</ul>

<p>
? coincide con cualquier carácter simple. Por ejemplo:
</p>

<ul>
  <li>
    miarchivo? coincidirá con todos los archivos cuyo nombre consista
    de miarchivo seguido de un solo carácter.
  </li>
  <li>
    /tmp/notas?txt coincidirá tanto con /tmp/notas.txt como con
    notas_txt si ambos existieran.
  </li>
</ul>

</body>
</section>
<section>
<title>Sintaxis de comodines: []</title>
<body>

<p>
Este tipo de comodín es similar a ?, pero permite ser más
específico. Para usar este comodín, coloque los caracteres que
quisiera hacer coincidir dentro de los corchetes []. La
expresión resultante coincidirá con la ocurrencia de alguno de
esos caracteres. También podrá usar un guión - para especificar un
rango e incluso una combinación de estos. Veamos algunos ejemplos:
</p>

<ul>
  <li>
    miarch[12] coincidirá con miarch1 y con miarch2. El comodín se
    expandirá mientras aún exista alguno de estos archivos en el
    directorio actual.
  </li>
  <li>
    [Cc]hange[Ll]og coincidirá con Changelog, ChangeLog, changeLog y
    changelog. Como podrá ver, usar los comodines corchetes es de gran
    utilidad para hacer coincidencias con variaciones en letras
    mayúsculas.
  </li>
  <li>
    ls /etc/[0-9]* listará todos los objetos del sistema de archivos
    del directorio /etc que comiencen con un número.
  </li>
  <li>
    ls /tmp/[A-Za-z]* listará todos los objetos del sistema de archivos
    del directorio /tmp que comiencen con un carácter alfabético
    (mayúscula o minúscula).
  </li>
</ul>

<p>
La construcción [!] es similar a [], excepto en que en vez de
coincidir con cualquier carácter de los listados dentro de los
corchetes, coincidirá con los que no han sido listados entre [! y
]. Ejemplo:
</p>

<ul>
  <li>
    rm miarch[!9] removerá todos los archivos llamados miarch seguido
    de algún único carácter, excepto miarch9.
  </li>
</ul>

</body>
</section>
<section>
<title>Advertencias sobre el uso de comodines</title>
<body>

<p>
Aquí están algunas advertencias para el uso de comodines. Como bash
trata de modo especial los caracteres comodines (?, [, ] y *),
necesitaremos tener cuidado al escribir argumentos de una orden que
contengan algunos de estos caracteres. Por ejemplo, si quisiera
crear un archivo que contenga la cadena de texto [fo]*, la
siguiente línea de comando no lo logrará:
</p>

<pre caption="Mal uso de caracteres especiales">
$ <i>echo [fo]* &gt; /tmp/archivonuevo.txt</i>
</pre>

<p>
Si el patrón [fo]* coincide con algún objeto del directorio actual
de trabajo, entonces encontrará el nombre de estos archivos
dentro de /tmp/archivonuevo.txt en vez de ver literalmente [fo]*
como hubiéramos querido. Para solucionarlo una posibilidad es
rodear los caracteres con comillas simples. De esta manera se le
indica a bash que no realice ninguna expansión de comodines:
</p>

<pre caption="Evadiendo caracteres especiales">
$ <i>echo '[fo]*' &gt; /tmp/archivonuevo.txt</i>
</pre>

<p>
Si utiliza las comillas simples, su nuevo archivo contendrá la
cadena [fo]* como se esperaba. Alternativamente, puede usar
sentencias de escape con barras invertidas para indicarle a bash
que [, ] y * deben ser tratados literalmente en lugar de comodines:
</p>

<pre caption="Evadiendo caracteres especiales, segunda posibilidad">
$ <i>echo \[fo\]\* &gt; /tmp/archivonuevo.txt</i>
</pre>

<p>
Las dos soluciones (comillas simples y sentencias de escape) tienen
el mismo efecto. Y ya que estamos hablando de expresiones con barras
invertidas, es buen momento de mencionar que si quiere
especificar un carácter \, deberá encerrarlo entre comillas simples
o precederlo de otra barra invertida \\ (que será expandido a \).
</p>

<note>
Las comillas dobles funcionan de modo similar a las comillas
sencillas, pero le permiten a bash hacer expansiones limitadas. Por
lo tanto, comillas simples son la mejor opción cuando está
realmente interesado en pasar texto literalmente a una orden. Para
obtener mayor información sobre expansiones de comodines teclee <c>
man 7 glob</c>. Para información sobre comillas escriba <c>man 8
glob</c> y lea la sección titulada QUOTING (COMILLAS). Si está
realmente planeando rendir los exámenes LPI considere esto una
tarea :).
</note>

</body>
</section>
</chapter>

<chapter>
<title>Resumen y bibliografía</title>
<section>
<title>Resumen</title>
<body>

<p>
Felicitaciones; ha llegado al final de nuestra reseña sobre los
fundamentos de Linux. Esperamos que haya sido de ayuda para
reafirmar sus conocimientos de Linux. Los temas que ha aprendido
aquí, las bases de bash, órdenes básicas de Linux, enlaces y
comodines, sientan las bases para el próximo tutorial sobre
administración básica. En él se cubren temas como expresiones
regulares, permisos y propiedad y gerenciamiento de cuentas de
usuarios entre otras cosas.
</p>

<p>
Continuando con esta serie de tutoriales, pronto estará listo
para probar el nivel 1 de Certificación del Linux Professional
Institute. Y hablando de la certificación LPIC, si esto es algo que
le interesa, entonces le recomendamos que estudie las bibliografías
sugeridas de la siguiente sección, las cuales han sido
cuidadosamente seleccionadas para aumentar y reforzar lo cubierto
en este tutorial.
</p>

</body>
</section>
<section>
<title>Bibliografía</title>
<body>

<p>
En la serie de artículos “Bash con ejemplos” de developerWorks, se
muestra cómo usar los programas constructores de bash para escribir
sus propios scripts de bash. Esta serie (particularmente la parte 1
y 2) será una buena preparación para el examen LPIC nivel 1:
</p>

<ul>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p1.xml">Bash con
    ejemplos, parte 1: Programación fundamental en la "Bourne again
    shell" (bash)</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p2.xml">Bash con
    ejemplos, parte 2: Más fundamentos de programación en bash</uri>
  </li>
  <li>
    <uri link="/doc/es/articles/bash-by-example-p3.xml">Bash con
    ejemplos, parte 3: Explorando el sistema de ebuilds</uri>
  </li>
</ul>

<p>
Si es un usuario Linux principiante o intermedio, es
altamente recomendable revisar las preguntas técnicas para usuarios
Linux, un listado de 50 páginas que muestran la lista de preguntas
más frecuentes de Linux con respuestas detalladas. El FAQ es un
archivo formato PDF (Acrobat).
</p>

<p>
Si no está familiarizado con el editor vi, vea el tutorial de
developerWorks "Intro to vi". Este tutorial le da una introducción
rápida a este poderoso editor de texto. Considérelo como un
material del tipo "debe leer" si no sabe cómo utilizar vi.
</p>

</body>
</section>
</chapter>
</guide>
