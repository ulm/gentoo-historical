<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/es/gcc-optimization.xml,v 1.7 2009/08/18 14:05:44 chiguire Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/es/gcc-optimization.xml" lang="es">

<title>Guía de Compilación Optimizada</title>

<author title="Autor">
  <mail link="nightmorph@gentoo.org">Joshua Saddler</mail>
</author>
<author title="Traductor">
  <mail link="nordri@gmail.com">Federico Díaz</mail>
</author>
<author title="Traductor">
  <mail link="srinclan@gmail.com">Sergio D. Rodríguez Inclan</mail>
</author>
<author title="Traductor">
  <mail link="gentoo@nimiux.org">José María Alonso</mail>
</author>

<abstract>
Esta guía proporciona una introducción a la compilación optimizada
usando CFLAGS y CXXFLAGS seguras y sanas. Al tiempo que se describe la
teoria detrás de la optimización en general.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.11</version>
<date>2009-07-18</date>

<chapter>
<title>Introducción</title>
<section>
<title>¿Qué son CFLAGS y CXXFLAGS?</title>
<body>

<p>
CFLAGS y CXXFLAGS son variables de entorno usadas para decirle a la
Colección de Compiladores GNU, <c>gcc</c>, que tipo de parámetros usar
cuando compila código fuente. Las CFLAGS son para código escrito en C,
mientras que CXXFLAGS son para código escrito en C++.
</p>

<p>
Pueden usarse para disminuir la cantidad de mensajes de depuración
para un programa, aumentar los niveles de aviso de errores, y por
supuesto, optimizar el código producido. El <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Invoking-GCC.html#Invoking-GCC">
Cuaderno de GNU gcc </uri> mantiene una completa lista de opciones
disponibles y sus propósitos.
</p>
</body>
</section>

<section>
<title>¿Cómo se usan?</title>
<body>

<p>
CFLAGS y CXXFLAGS pueden ser usados de dos maneras. La primera, pueden
usarse por programa con los Makefiles generados por automake.
</p>

<p>
Sin embargo, esto no debería usarse cuando instalamos paquetes
encontrados en el árbol del Portage. En su lugar, establezca sus
CFLAGS y CXXFLAGS en <path> /etc/make.conf</path>. De esta manera
todos los paquetes se compilaran con las opciones que especifique.
</p>

<pre caption="CFLAGS en /etc/make.conf">
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Como puede ver, CXXFLAGS se establece para usar todas las opciones
presentes en CFLAGS. Esto es lo que deseara casi seguro. No debería
necesitar especificar opciones adicionales en CXXFLAGS nunca.
</p>
</body>
</section>

<section>
<title>Conceptos generales</title>
<body>

<p>
Mientras CFLAGS y CXXFLAGS pueden ser muy efectivos tomando el código
fuente para producir binarios pequeños y/o rápidos, también pueden
deteriorar la función de su código, inflar su tamaño, relentizar su
ejecución, o incluso causar errores de compilación.
</p>

<p>
CFLAGS no es una solución mágica; no hará que su sistema corra más
rápido o sus binarios sean más pequeños automáticamente. Añadir más y
más parámetros en un intento de optimización (o "rizar") su sistema es una
receta segura para el fallo. Hay un punto en el cual permanecerá dando
vueltas.
</p>

<p>
A pesar de la jactancia que pueden encontrar en Internet, unas
variables CFLAGS y CXXFLAGS agresivas están más cerca de dañar sus
programas que de hacerles algún bien. Recuerde que la razón para la
cual existen los parámetros en primer lugar es porque están diseñadas
para usarse en sitios específicos para propósitos específicos. ¡Sólo
porque una CFLAG particular sea buena para un fragmento de código no
significa que esté diseñada para compilar todo lo que quiera instalar
en su máquina¡.
</p>
</body>
</section>

<section>
<title>¿Preparado?</title>
<body>

<p>
Ahora que está advertido de algunos de los riesgos involucrados,
echemos un vistazo a algo sano, optimizaciones seguras para su
ordenador. Esto le será útil y lo agradecerán los desarrolladores la
próxima vez que reporte un problema en <uri
link="http://bugs.gentoo.org">Bugzilla</uri>. (Los desarrolladores
suelen pedir que recompile un paquete con los CFLAGS mínimos para ver
si el problema persiste. Recuerde que los parámetros agresivos pueden
arruinar el código.)
</p>
</body>
</section>
</chapter>

<chapter>
<title>Optimizando</title>
<section>
<title>Lo básico</title>
<body>

<p>
La meta detrás de usar CFLAGS y CXXFLAGS es crear código específico
para su sistema; debería funcionar perfectamente mientra es ligero y
rápido, si es posible. Algunas veces estás condiciones son mutuamente
excluyentes, pero nosotros jugaremos con combinaciones que sabemos que
funcionan bien. Idealmente, las mejores están disponibles para cada
arquitectura de CPU. Mencionaremos más adelante los parámetros
agresivos para que se sepa con cuales tener cuidado. No discutiremos
cada opción listada en el manual de <c>gcc</c> (hay cientos), pero
hablaremos de las básicas, los más comunes.
</p>

<note>
Si no está seguro qué hace el parámetro, revise el capítulo relevante
en el <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options">
manual de gcc</uri> y si aún continúa atascado, pruebe Google, o
revise las <uri link="http://gcc.gnu.org/lists.html">listas de
correo</uri> de <c>gcc</c>.
</note>
</body>
</section>

<section>
<title>-march</title>
<body>

<p>
La primera y más importante opción es <c>-march</c>. Esta le dice al
compilador que código debería producirse para su <uri
link="http://en.wikipedia.org/wiki/Microarchitecture">arquitectura</uri>
de procesador (o <e>arch</e>); dice que debería producir código para
un cierto tipo de CPU. Diferentes CPUs tienen diferentes
características, soportan diferentes conjunto de instrucciones y
tienen diferentes formas de ejecutar código. El parámetro
<c>-march</c> mandará al compilador producir código específico para su
CPU, tomando en cuenta todas sus capacidades, características,
conjuntos de instrucciones, caprichos y demás.
</p>

<p>
A pesar que la variable CHOST en <path>/etc/make.conf</path>
especifica la arquitectura general usada, <c>-march</c> también se usa
para que sus programas sean optimizados para su procesador
específico. Las arquitecturas x86 y x86-64 (entre otras) también
deberían hacer uso del parámetro <c>-march</c>.
</p>

<p>
¿Qué tipo de CPU tiene? Para averiguar, ejecute el siguiente
comando:
</p>

<pre caption="Examinando la información de la CPU">
$ <i>cat /proc/cpuinfo</i>
</pre>

<p>
Ahora veamos <c>-march</c> en acción. Este ejemplo es para un viejo
Pentium III:
</p>

<pre caption="/etc/make.conf: Pentium III">
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Aquí hay otro para una CPU de 64-bit AMD:
</p>

<pre caption="/etc/make.conf: AMD:64">
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Si todavía no está seguro qué tipo de CPU tiene, tal vez quiera usar
la opción <c>-march=native</c>. Al usarla, GCC detectará el procesador
y automáticamente usará las opciones apropiadas.<brite>Sin embargo, no
use esta opción si la intención es ¡compilar paquetes para un CPU
diferente!</brite>
</p>

<p>
De manera que, si está compilando paquetes en una computadora, pero
piensa ejecutarlos en una computadora diferente (usando, por ejemplo,
una computadora rápida para construir paquetes para una máquina más
vieja y lenta), entonces <e>no</e> use la opción
<c>-march=native</c>. La palabra "native" significa que el código
producido podrá ejecutarse <e>solamente</e> en ese tipo de CPU. Las
aplicaciones construidas con <c>-march=native</c> en un CPU AMD Athlon
64 CPU no podrán ejecutarse en un CPU VIA C3 más antiguo.
</p>

<p>
También están disponibles los parámetros <c>-mcpu</c> y
<c>-mtune</c>. Cada uno de ellos <e>sólo</e> se usará cuando no haya
otra opción <c>-march</c> disponible. Ciertas arquitecturas de
procesador pueden requerir <c>-mtune</c> o incluso de
<c>-mcpu</c>. Desgraciadamente, el comportamiento de <c>gcc</c> no es
muy consistente con la manera que cada parámetro se comporta de una
arquitectura a la otra.
</p>

<p>
En CPUs x86 y x86-64, <c>-mcpu</c> generará código epecífico para esta
CPU usando todas sus instrucciones disponibles y el ABI correcto; no
tendrá compatibilidad hacia atrás para CPUs antiguas/diferentes. Si no
necesita ejecutar código en otro sitio que en el sistema que está
corriendo Gentoo, continue para usar <c>-march</c>. Sólo debería
considerar usar <c>-mtune</c> cuando necesite generar código para CPUs
antiguas como i386 e i486. <c>-mtune </c> produce un código más
genérico que <c>-march</c>; aunque afinará el código para cierto CPU,
no tendrá en cuenta los conjuntos de instrucciones disponibles y ABI. No
use <c>-mcpu</c> en sistemas x86 o x86-64, ya que está obsoleto para
estas arquitecturas.
</p>

<p>
Sólo CPUs no x86/x86-64 (como Sparc, Alpha y PowerPC) pueden requerir
<c>-mtune </c> o <c>-mcpu</c> en lugar de <c>-march</c>. En estas
arquitecturas, <c>-mtune</c>/<c>-mcpu</c> algunas veces se comportará
como <c>-march</c> en (x86/x86-64) ... pero con un nombre distinto. De
nuevo, el comportamiento de <c>gcc</c> y los nombres de los parámetros
no es consistente entre arquitecturas, así que asegúrese de revisar el
<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Submodel-Options.html#Submodel-Options">
manual</uri> de <c>gcc</c> para determinar cual de
ellos se ajusta a su sistema.
</p>

<note>
Para más sugerencias de configuraciones de
<c>-march</c>/<c>-mtune</c>/ <c>-mcpu</c>, por favor lea el capítulo 5
de la <uri link="/doc/es/handbook/">Guía de Instalación de Gentoo
</uri> apropiada a su arquitectura. También, lea el manual de
<c>gcc</c> listado en la página <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Submodel-Options.html#Submodel-Options">
opciones específicas por arquitectura</uri>, con
explicaciones más detalladas sobre las diferencias entre
<c>-march</c>, <c>-mcpu</c>, y <c>-mtune</c>.
</note>

</body>
</section>
<section>
<title>-O</title>
<body>

<p>
Lo siguiente es la variable <c>-O</c>. Controla el total de niveles de
optimización. Hace que la compilación de código tome algo más de
tiempo, y puede tomar mucha más memoria, especialmente al incrementar
el nivel de optimización.
</p>

<p>
Hay cinco configuraciones para <c>-O</c>: <c>-O0</c>, <c>-O1</c>,
<c>-O2</c>, <c>-O3</c> y <c>-Os</c>. Debería usar solamente una de
ellas en <path>/etc/make.conf</path>.
</p>

<p>
Con la excepción de <c>-O0</c>, la configuración de <c>-O</c> activa
varios parámetros adicionales, así que asegúrese de leer el capítulo
del manual de gcc en <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options">
opciones de optimización</uri> para aprender cuales
parámetros se activan en cada nivel <c>-O</c>, así como algunas
explicaciones sobre lo que hacen.
</p>

<p>
Examinemos cada nivel de optimización:
</p>

<ul>
  <li>
    <c>-O0</c>: Este nivel (la letra "O" seguida de un cero)
    desconecta por completo la optimización y es el predeterminado si
    no se especifica ningún nivel <c>-O</c> en CFLAGS o CXXFLAGS. El
    código no será optimizado. Esto, normalmente, no es lo que se
    desea.
  </li>
  <li>
    <c>-O1</c>: Este es el nivel de optimización más básico. El
    compilador intentará producir un código rápido y pequeño sin tomar
    mucho tiempo de compilación. Es bastante básico, pero conseguirá
    acabar el trabajo siempre.
  </li>
  <li>
    <c>-O2</c>: Un paso por encima de <c>-O1</c>. Este es el nivel
    <e>recomendado</e> de optimización, a no ser que tenga necesidades
    especiales. <c>-O2</c> activará unos pocos parámetros añadidos a
    los que se activan con <c>-O1</c>. Con <c>-O2</c>, el compilador
    intentará aumentar el rendimiento del código sin comprometer el
    tamaño y sin tomar mucho más tiempo de compilación.
  </li>
  <li>
    <c>-O3</c>: Este es el más alto nivel de optimización posible, y
    también el más arriesgado. Tomará muchísimo tiempo compilar su
    código con esta opción, y de hecho, no debería usarse a través de
    todo el sistema con <c>gcc</c> <e>4.x</e>. El comportamiento de
    <c>gcc</c> ha cambiado significativamente desde la versión 3.x,
    donde con <c>-O3</c> se había demostrado producir código con
    tiempos de ejecución marginalmente menores sobre <c>-O2</c>, pero
    este ya no es el caso con <c>gcc</c> 4.x. Compilar todos sus
    paquetes con <c>-O3</c> <e>resultará</e> en grandes binarios que
    requerirán mucha memoria e incrementará significativamente los
    extraños fallos de compilación o los comportamientos inesperados
    de los programas (incluidos los errores). Las desventajas
    compensan las ventajas. <b>No se recomienda usar <c>-O3</c> con
    <c>gcc</c> 4.x.</b>
  </li>
  <li>
    <c>-Os</c>: Este nivel optimizará su código para el tamaño. Activa
    todas las opciones de <c>-O2</c> que no aumenten el tamaño del
    código generado. Es útil para máquinas con capacidad limitada de
    disco y/o con CPUs con poca caché. Sin embargo, puede causar
    algunos problemas porque es filtrado por muchos ebuilds del
    árbol. No aconsejamos usar <c>-Os</c>.
  </li>
</ul>

<p>
Como se comentó anteriormente, <c>-O2</c> es el nivel de optimización
recomendado. Si un paquete muestra errores de compilación, asegúrese
que no está usando <c>-O3</c>. Como opción de marcha atrás, pruebe
configurando CFLAGS y CXXFLAGS a un nivel de optimización inferior,
como <c>-O1</c> o incluso <c>-O0 -g2 -ggdb</c> (para reportar errores
y comprobar posibles problemas) y recompile el paquete.
</p>

</body>
</section>
<section>
<title>-pipe</title>
<body>

<p>
Un parámetro divertido y seguro es <c>-pipe</c>. Realmente no tiene
efecto sobre el código que se produce, pero hace que el proceso de
compilación sea más rápido. Indica al compilador que use tuberías en
lugar de archivos temporales durante los diferentes estados de
compilación.
</p>

</body>
</section>
<section>
<title>-fomit-frame-pointer</title>
<body>

<p>
Esta es un parámetro muy común diseñada para reducir el tamaño del
código generado. Está activado para todos los niveles de <c>-O</c>
(excepto <c>-O0</c>) en arquitecturas donde no interfiera con el
depurado (como x86-64), pero puede hacer falta activarlo uno mismo,
añadiéndolo a sus parámetros. Aunque el manual de GNU <c>gcc</c> no
especifica todas las arquitecturas en las que está activado al usar
<c>-O</c>, hay que activarlo explícitamente en un x86. Sin embargo,
usando este parámetro hará que la depuración sea de dura a imposible.
</p>

<p>
En particular, provoca que localizar problemas en aplicaciones
escritas en Java sea mucho más complicada, aunque Java no es el único
código afectado al usar este parámetro. Así, aunque este parámetro
puede ayudar, el depurado será duro; los "backtraces" en particular
serán inútiles. Sin embargo, si no planea hacer muchas depuraciones y
no tiene añadida ninguna otra CFLAG relacionada con la depuración como
<c>-ggdb</c> (y no está instalando paquetes con la variable USE
<c>debug</c>), entonces intente usar <c>-fomit-frame-pointer</c>.
</p>

<impo>
<e>No</e> combine <c>-fomit-frame-pointer</c> con el parámetro de
nombre similar <c>-momit- leaf-frame-pointer</c>. El uso de este
último está desaconsejado, ya que <c>-fomit-frame-pointer</c> ya hace
el trabajo apropiado. Es más, <c>-momit-leaf-frame-pointer</c> ha
demostrado que impacta negativamente en el rendimiento del código.
<!--
Fuente de esta información:
http://www.coyotegulch.com/products/acovea/aco5p4gcc40.html
-->
</impo>

</body>
</section>
<section>
<title>-msse, -msse2, -msse3, -mmmx, -m3dnow</title>
<body>

<p>
Estos parámetros activan los conjuntos de instrucciones <uri
link="http://es.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</uri>,
<uri link="http://es.wikipedia.org/wiki/SSE2">SSE2</uri>, <uri
link="http://en.wikipedia.org/wiki/SSSE3">SSE3</uri>, <uri
link="http://es.wikipedia.org/wiki/MMX">MMX</uri>, and <uri
link="http://es.wikipedia.org/wiki/3DNow%21">3DNow!</uri> para
arquitecturas x86-64. Son útiles principalmente en multimedia, juegos
y otras tareas intensivas de computación en punto flotante, aunque
también contienen muchos otros realces matemáticos. Estos conjuntos de
instrucciones se encuentran en las más modernas CPUs.
</p>

<impo>
Asegúrese de verificar si su CPU los soporta ejecutando <c>cat
/proc/cpuinfo</c>. La salida incluirá cualquier conjunto de
instrucciones adicionales. Note que <b>pni</b> es sólo otro nombre
para SSE3.
</impo>

<p>
Normalmente no necesita añadir ninguno de estos parámetros a
<path>/etc/make.conf </path> mientras esté usando la <c>-march</c>
correcta (por ejemplo, <c>-march= nocona</c> implica
<c>-msse3</c>). Algunas excepciones notables son los CPUs nuevos VIA y
AMD64 que soportan instrucciones no implicadas por <c>-march</c> (como
SSE3). Para CPUs como estos necesitará habilitar parámetros
adicionales donde sea apropiado después de verificar la salida de
<c>cat /proc/cpuinfo</c>.
</p>

<note>
Revise la <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options">
lista</uri> de parámetros
específicos para x86 y x86-64 para ver cuales de estos conjuntos de
instrucciones son activados por la propia configuración del tipo de
CPU. Si una instrucción está listada, entonces no necesita
especificarla; se activará al usar la configuración de <c>-march </c>
apropiada.
</note>

</body>
</section>
</chapter>

<chapter>
<title>PUFs de Optimización</title>
<section>
<title>¡Pero tengo un mejor rendimiento con -funroll-loops -fomg-optimize!
</title>
<body>

<p>
No, solo <e>piensa</e> que lo hace porque alguien le ha convencido que
más parámetros es mejor. Los parámetros agresivos solo dañaran sus
aplicaciones cuando use un sistema completo. Incluso el <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options">
manual</uri> de <c>gcc</c> dice que usar
<c>-funroll-loops </c> y <c>-funroll-all-loops</c> crea código más
grande y que corre más lento. Aún por algunas razones, estos dos
parámetros, junto con <c>-ffast-math</c>, <c>-fforce-mem</c>,
<c>-fforce-addr</c>, y similares, continúan siendo muy populares entre
pardillos que quieren saber más que nadie.
</p>

<p>
La verdad es que son parámetros peligrosamente agresivos. Eche un
vistazo a los <uri link="http://forums.gentoo.org">Foros de
Gentoo</uri> y <uri link="http://bugs.gentoo.org">Bugzilla</uri> para
ver que hacen estas variables: ¡nada bueno!
</p>

<p>
No necesita usar estos parámetros globalmente en CFLAGS o
CXXFLAGS. Sólo dañarán el rendimiento. Puede sonarle como que tiene un
sistema avanzado de alto rendimiento, pero no hará más que inflar su
código y marcar sus informes de errores como INVALID o WONTFIX.
</p>

<p>
No necesita parámetros peligrosos como estas. <b>No las
use</b>. Quédese con las básicas: <c>-march</c>, <c>-O</c>, y
<c>-pipe</c>.
</p>

</body>
</section>
<section>
<title>¿Qué pasa con los niveles -O mayores que 3?</title>
<body>

<p>
Algunos usuarios alardean que obtienen mejor rendimiento usando
<c>-O4</c>, <c>-O9</c>, y así, pero la realidad es que niveles de
<c>-O</c> mayores que 3 no tienen efecto. El compilador puede aceptar
CFLAGS como <c>-O4</c>, pero realmente no hace nada con el. Solo
realiza la optmización para <c>-O3</c>, nada más.
</p>

<p>
¿Necesita más pruebas? Examine el <uri
link="http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&amp;view=
markup">código fuente</uri> de <c>gcc</c>:
</p>

<pre caption="Código fuente de -O">
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>

<p>
Como puede ver, cualquier valor por encima de 3 es tratado como sólo
<c>-O3</c>.
</p>

</body>
</section>
<section>
<title>¿Qué pasa con los parámetros redundantes?</title>
<body>

<p>
A menudo CFLAGS y CXXFLAGS que están activadas en varios niveles de
<c>-O</c> están especificadas redundantemente en
<path>/etc/make.conf</path>. Algunas veces esto ocurre por ignorancia,
pero también ocurre para permitir el filtrado o el reemplazo de
parámetros.
</p>

<p>
Muchos de los ebuilds del árbol del Portage contienen
filtrado/reemplazo de parámetros. Suele hacerse porque hay paquetes
que fallan en ciertos niveles de <c>-O</c>, o cuando el código fuente
es muy sensible para ser usado para cualquier parámetro adicional. El
ebuild podrá cada vez filtrar para algunas o todas las CFLAGS y
CXXFLAGS, o puede reemplazar <c>-O</c> con un nivel diferente.
</p>

<p>
El <uri
link="http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-
environment/index.html">Manual del Desarrollador de Gentoo</uri>
resume dónde y cómo trabaja el filtrado/reemplazo de parámetros.
</p>

<p>
Es posible evitar el filtrado de <c>-O</c> por el listado redundante
de parámetros para un cierto nivel, como <c>-O3</c>, haciendo cosas
como:
</p>

<pre caption="Especificando CFLAGS redundantes">
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>

<p>
Sin embargo, <brite>hacer esto no es inteligente</brite>. ¡Las CFLAGS
son filtradas por una razón! Cuando estos parámetros son filtrados es
porque es inseguro construir paquetes con ellos. Claramente, <e>no</e>
es seguro compilar su sistema completo con <c>-O3</c> si alguno de
estos parámetros está activada para este nivel causará problemas con
ciertos paquetes. Por lo tanto, no debería intentar "saber más" que
los desarrolladores que mantienen estos paquetes. <e>Confíe en
ellos</e>. ¡El filtrado y reemplazo de parámetros se hace por su bien!
Si un ebuild especifica parámetros alternativos, entonces no intente
convencerlo.
</p>

<p>
No encontrará más que problemas cuando construya un paquete con
parámetros inaceptables. Cuando reporte sus problemas en Bugzilla, los
parámetros que usó en <path>/etc/make.conf</path> serán fácilmente
visibles y se le instará a recompilar sin ellos. ¡Protéjase de los
problemas de recompilar no usando parámetros redundantes en primer
lugar! No asuma automáticamente que sabe más que los desarrolladores.
</p>

</body>
</section>
<section>
<title>¿Qué pasa con LDFLAGS?</title>
<body>

<p>
Los desarrolladores de Gentoo ya han configurado LDFLAGS básicas y
seguras en los perfiles base, de tal manera que no necesita cambiarlas.
</p>

</body>
</section>
<section>
<title>¿Puedo usar parámetros por paquete?</title>
<body>

<p>
No hay ningún método soportado para usar CFLAGS u otras variables en
una base por paquete, aunque hay algunos métodos <uri
link="http://forums.gentoo.org/viewtopic-p-3832057.html#3832057">bastante
abusivos</uri> para forzar a Portage a hacerlo.
</p>

<p>
No <e>debería</e> intentar forzar a Portage a usar parámetros por
paquete, ya que no está soportado y complicará mucho los informes de
errores. Sólo establezca sus parámetros en <path>/etc/make.conf</path>
para que usen como base del sistema entero.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Recursos</title>
<section>
<body>

<p>
Los siguientes recursos son un poco de ayuda en aras de comprender la
optimización:
</p>

<ul>
  <li>
    El <uri link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/">Manual de
    GNU gcc</uri>
  </li>
  <li>
    Capítulo 5 del <uri link="/doc/es/handbook/">Manual de Instalación
    de Gentoo</uri>
  </li>
  <li><c>man make.conf</c></li>
  <li><uri link="http://es.wikipedia.org">Wikipedia</uri></li>
  <li>
    <uri
    link="http://www.coyotegulch.com/products/acovea/">Acovea</uri>,
    una comparativa y conjunto de pruebas que pueden ser útiles para
    determinar cómo diferentes parámetros de compilación interactúan y
    afectan al código generado, aunque sus sugerencias sobre el código
    no son adecuadas para un sistema completo. Está disponible en
    Portage: <c>emerge acovea</c>.
  </li>
  <li>Los <uri link="http://forums.gentoo.org">Foros de Gentoo</uri></li>
</ul>

</body>
</section>
</chapter>
</guide>
