<?xml version = '1.0' encoding = 'UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/hu/rc-scripts.xml" >
<title>Gentoo Linux 1.0 Init Rendszer</title>
<author title="Author" >
<mail link="azarah@gentoo.org" >Martin Schlemmer</mail>
</author>
<author title="Proof-reader" >
<mail link="seemant@gentoo.org" >Seemant Kulleen</mail>
</author>
<author title="Hungarian translator" >
<mail link="strangedr@gentoo.org" >Thomas Ferencz</mail>
</author>
<abstract>Ez az útmutató betekintést ad a Gentoo Linux initrendszerébe, és segítségével megismerkedhetünk az rc szkriptek írásával is.</abstract>
<license/>
<version>1.0.2</version>
<date>8 April 2002</date>
<chapter>
<title>Bevezetés</title>
<section>
<body>
<p>A Gentoo Linux által használt initrendszer nagyrészt függőségeken keresztül vezérlődik.
Könnyű karbantartani, mégis erőteljes, és kellően rugalmasan alakítható bármilyen konfigurációhoz.
Ebben az útmutatóban nem annyira a belső működésekkel foglalkozunk; tekintsük inkább gyorstalpalónak a Gentoo initrendszerének megismeréséhez.
Aki kíváncsi a belső működésekre... olvassa el a forráskódot:-)</p>
</body>
</section>
</chapter>
<chapter>
<title>Futási szintek</title>
<section>
<body>
<p>Más initrendszerekkel ellentétben, a Gentoo futási szintjeinek nincs kötött nevük vagy számuk,
hanem egyedi neveket rendeltünk a standard szintekhez.
</p>
<note>Alapállapotban három futási szint van, nevezetesen <e>&quot;boot&quot;</e>, <e>&quot;default&quot;</e>
és a<e>&quot;nonetwork&quot;</e>.</note>
<p>A &quot;boot&quot; futási szint a legtöbb konfigon alapvető kellene, hogy legyen, és amint neve is mutatja,
ez az első szint, amely rendszerinduláskor végrehajtódik. A következő a <e>&quot;default&quot;</e>, amely,
neve alapján is, a boot után életbe lépő fő futási szint. Az utolsó a <e>&quot;nonetwork&quot;</e>,
amely pusztán gyakorlási célokat szolgál.
</p>
<p>A futási szintek az<path>/etc/runlevels</path> alatt laknak, a szint nevével megegyező alkönyvtárban;
ebben az alkönyvtárban szimbolikus linkek vannak, a futási szint tulajdonában lévő szolgáltatások felé.
</p>
<note>Arról, hogy mi a javasolt módja a szolgáltatások hozzáadásának/törlésének, a
&quot;Segédprogramok és -szkriptek&quot; fejezetben lesz szó.</note>
<p>Amint már szó esett róla, a szint nevét akármire meg lehet változtatni,
ha a megfelelő bejegyzést az <path>/etc/inittab</path> fileban szintén megváltoztatjuk, hogy tükrözze a futási szint új nevét.
</p>
<impo>Lényeges kivételt képez azonban ez alól a <e>&quot;boot&quot;</e> futási szint.</impo>
<warn>Kérjük, NE változtasd meg a nevét a <e>&quot;boot&quot;</e> futási szintnek,
mert az tönkretehet dolgokat!</warn>
<p>Az <path>/sbin/rc</path> szkript tesz arról, hogy mindez működjön, és segítségével futásidő alatt is lehet futási szintet váltani.
</p>
</body>
</section>
<section>
<title>Virtuális futási szintek</title>
<body>
<p>Mivel a futási szintek nincsenek statikusan hozzárendelve az inithez, sokkal több futási szint is lehet, mint amennyit az init támogat.
 Ez lehetővé teszi, hogy a felhasználó szükség szerint virtuális futási szinteket avagy profilokat hozzon létre.
</p>
<p>Például, egy laptop tulajdonosnak lehet két default futási szintje, &quot;online&quot;
és &quot;offline&quot; néven. Így az egyik futási szint akkor lehet aktív, amikor a PCMCIA hálókártya csatlakoztatva van, a másik pedig akkor, amikor nincs.
 A PCMCIA szkripteket aztán be lehet úgy állítani,
 hogy meghívják az <c>&quot;/sbin/rc online&quot;</c> vagy az <c>&quot;/sbin/rc offline&quot;</c>
parancsot szükség szerint, hogy elindítsa vagy leállítsa a megfelelő szolgáltatást,
 a PCMCIA kártya állapotától függően.
</p>
</body>
</section>
<section>
<title>A futási szintek és az XFree86</title>
<body>
<p>A Gentooban nincs az X futtatásához kirendelt saját futási szint,
ehelyett egy indítószkriptet használunk. Ennek a neve &quot;xdm&quot; és ahhoz a futási szinthez rendelhető, amelyikhez a felhasználó akarja.
</p>
<note>Ennek a felhasználó kívánsága szerinti fő futásszintnek kell lennie.</note>
<warn>Ha a boot futásszinthez adjuk, annak kellemetlen következményei lehetnek.</warn>
<p>Alapesetben, ha az xdm-et, gdm-et vagy a kdm-et azelőtt indítanád, mielőtt a gettyk elindulnának,
az X a legközelebbi elérhető terminálon indulna. Lassabb gépeken ez nem okoz gondot,
ha a Desktop Manager szolgáltatás valahol a futási szint init folyamatának végefelé indítódik.
A gettyk ilyenkor az X előtt indulnak, az pedig a 7-es terminálon, ahogy kell is neki.
Gyorsabb gépeken azonban nem ez történik. Az X elindul még az előtt a getty előtt, amelyik szokásosan a 2-es terminálon indulna.
 Amikor aztán a getty elindul, átveszi a billentyűzet vezérlését, a Desktop Manager pedig elveszti a billentyűzethez való hozzáférését.</p>
<p>Ezt úgy kerüljük ki, hogy a DM indítószkriptjét az init egyik extra futási szintjéről, nevezetesen az &quot;a&quot; futásszintről indítjuk.
 Ez valójában nem igazi futási szint, az xdm egyszerűen csak meghívja a <c>&quot;telinit a&quot;</c> parancsot. Ez az &quot;a&quot; futási szinten szereplő összes szolgáltatás indítását a futó szint utánra időzíti,
 tehát miután a gettyk már elindultak.
</p>
<note>Az &quot;a&quot; futási szintről további információt az init man oldalaiból nyerhetsz..</note>
</body>
</section>
</chapter>
<chapter>
<title>RC-Szkriptek</title>
<section>
<body>
<p>Az rc-szkriptek olyan szkriptek, amelyek meghatározzák az egyes szolgáltatások indulásához szükséges
 alapvető függvényeket és függőségeket. Tartózkodási helyük az <path>/etc/init.d/</path>.
</p>
</body>
</section>
<section>
<title>Az rc-szkriptek alapfelépítése</title>
<body>
<pre caption="Az rc-szkript felépítése" >
#!/sbin/runscript
 
depend() {
    need bar
}
 
start() {
    ebegin &quot;Starting foo&quot;
    /sbin/foo
    eend $? &quot;Failed to start foo&quot;
}
 
stop() {
    ebegin &quot;Stopping foo&quot;
    kill $(cat /var/run/foo.pid)
    eend $? &quot;Failed to stop foo&quot;
}
</pre>
<note>Az interpreter az &quot;/sbin/runscript&quot;.</note>
<note>A &quot;depend&quot; függvény opcionális.</note>
<note>Minden rc-szkriptbe kell legalább egy &quot;start&quot; függvény.</note>
</body>
</section>
<section>
<title>A rendszerfelállás vezérlése</title>
<body>
<p>Általában véve a futási szintben lévő szolgáltatások ábécé sorrendben indulnak.
Ezt a <path>/bin/ls</path> kimenete határozza meg.
</p>
<p>Az alap indulási sorrendtől való eltérés elsődleges módja a függőségek használata.
Ha nincs az egyes szolgáltatások közt kapcsolat, sorrendi típusokat használhatunk.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Függőségi típusok</title>
<section>
<body>
<p>A legtöbb szolgáltatás kapcsolatban áll egy másikkal vagy éppen függ tőle.
</p>
<p>A postfixnek például szüksége van arra, hogy fusson a hálózat is és egy rendszerloggoló szolgáltatás is.
</p>
<p>A sambának a hálózat kell.Ha viszont nyomtatásra a CUPS-ot használjuk,
annak is a samba előtt kell elindulnia. Nota bene: a CUPS nem feltétlenül szükséges a samba futásához.
</p>
<p>Így hát két módunk is van arra, hogy a különféle szolgáltatások közti kapcsolatokat meghatározzuk.
Ezek a függőségek mindig érvényesek, akkor is, ha a futási szint maga egészében megváltozik,
vagy ha valamelyik szolgáltatást kézzel indítjuk el vagy állítjuk le boot után.
</p>
</body>
</section>
<section>
<title>A NEED függőségi típus</title>
<body>
<p>Ezt akkor használjuk, ha valamely szolgáltatás megléte kritikus a jelen szolgáltatás futtatása szempontjából.</p>
<pre caption="loggoló és net hozzáadása NEED függőségként" >
depend() {
    need net logger
}
</pre>
<note>Azok a szolgáltatások, amelyek a <e>NEED</e> után vannak felsorolva, kritikusak az aktuális szolgáltatás indítása szempontjából.
 Így tehát, ha azok elakadnak, a jelen szolgáltatás sem fog elindulni.</note>
<impo>Minden olyan szolgáltatás, amelyik a <e>NEED</e> sorban fel van sorolva, akkor is el fog indulni, ha nincs hozzárendelva az aktuális vagy a
<e>&quot;boot&quot;</e> futási szinthez.</impo>
<p>
<e>A NEED</e> ezért &quot;erős&quot; függőség.
</p>
</body>
</section>
<section>
<title>A USE függőségi típus</title>
<body>
<p>Jelen esetben a szolgáltatás megléte nem kritikus az aktuális futása szempontjából, 
 de ha használjuk, akkor a jelenlegi szolgáltatás előtt kell indulnia.
</p>
<pre caption="portmap hozzáadása a netmounthoz USE függőségként" >
depend() {
    use portmap
}
</pre>
<p>A netmount alapból képes kezelni az NFS csatolásokat, de a portmaptól csak akkor fog függeni, ha azt hozzáadjuk az aktuális futási szinthez.
 Minden felhasználó, aki NFS-t használ a rendszerében, hozzá kell, hogy adja a portmapot a default futási szinthez,
 így elérve, hogy a netmount a portmapet mint USE függőséget lássa, és önmaga előtt indítsa el.
</p>
<impo>Minden olyan szolgáltatás, amely a <e>USE</e> sorban szerepel, benne<e> *kell*</e> , hogy legyen az aktuális vagy a boot futási szintek szolgáltatásai között ahhoz, hogy érvényes <e>USE</e> függőségnek ismerje fel a rendszer.</impo>
<p>
<e>USE</e> Ezért ebben az esetben &quot;gyenge&quot; függőségről beszélünk.
</p>
<note>Ha a  <e>USE</e> sorban szereplő bármely szolgáltatás nem indul el, attól az aktuális még el fog indulni,
mivel a <e>USE</e> sorban szereplő szolgáltatásoknak nem szabad kritikusaknak lenniük a rendszerindulás szempontjából.</note>
</body>
</section>
</chapter>
<chapter>
<title>A sorrend vezérlése függőségek nélkül</title>
<section>
<body>
<p>Ha két szolgáltatás közt nincs függő viszony, de szükséges vagy kívánatos, hogy az egyik kifejezetten a másik után induljon el,
 az <e>AFTER</e> és <e>BEFORE</e> kulcsszavakat használhatjuk.
</p>
<note>Ez a két típus csak futásszint-váltáskor él.</note>
<p>Opcionálisan e két kulcsszó után a (*) is szerepelhet, valamennyi egyéb szolgáltatást magában foglalandó:
</p>
<pre caption="általános példa az AFTER kulcsszóra" >
depend() {
    after *
}
</pre>
<p>Ily módon a local szkript az <e>*after*</e> hatására az összes egyéb szolgáltatás után fog elindulni.
</p>
</body>
</section>
<section>
<title>A BEFORE rendezőtípus</title>
<body>
<p>Az aktuális szolgáltatás a  <e>*before*</e> hatására a  <e>BEFORE</e> sorban felsoroltak előtt indul.
</p>
<pre caption="induljon a foo a bar előtt (a foo részlete)" >
depend() {
   before bar
}
</pre>
</body>
</section>
<section>
<title>Az AFTER rendezőtípus</title>
<body>
<p>Az aktuális szolgáltatás az  <e>*after*</e> hatására az <e>AFTER</e> sorban felsoroltak után fog elindulni.
</p>
<pre caption="induljon a bar a foo után (a bar részlete)" >
depend() {
    after foo
}
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Virtuális szolgáltatások</title>
<section>
<body>
<p>A szolgáltatások, mint mostanában a legtöbb dolog a *nix világban, sokféle színben és ízben hozzáférhetők.
Általában a felhasználó/adminisztrátor döntésén múlik, melyiket is használja.
</p>
<p>Példa erre a rendszerloggolók esete. E cikk írása idején a Gentoo felhasználók 4 különféle típus közül választhatnak. Mármost valamennyi szolgáltatás, amelynek szükséges van rendszerloggolóra, nem teheti be a  <e>NEED</e>
sorba mind a négyet. A <e>USE</e> szintén nem volna elegendő.
</p>
<p>Itt lépnek be a képbe a virtuális szolgáltatások és a <e>PROVIDE</e> típus.
</p>
</body>
</section>
<section>
<title>A PROVIDE típus</title>
<body>
<p>A <e>PROVIDE</e> típus kijelöl egy virtuális szolgáltatást, amelyet a többi szolgáltatás betehet a       <e>NEED</e> vagy a  <e>USE</e> sorba.
</p>
<pre caption="sysklogd biztosítja a loggolót" >
depend() {
    provide logger
}
</pre>
</body>
</section>
<section>
<title>A LOGGER virtuális szolgáltatás</title>
<body>
<p>
<e>A LOGGER</e> egy előre definiált virtuális szolgáltatás, amelyet valamennyi rendszerloggoló használ.
Használható mind a  <e>NEED,</e> mind a  <e>USE</e> függőségi típusokkal.
</p>
</body>
</section>
<section>
<title>A NET virtuális szolgáltatás</title>
<body>
<p>A <e>NET</e> szolgáltatás szintén virtuális, de ellentétben a  <e>LOGGER</e>-ral, nem kifejezetten  <e>biztosít</e> másik szolgáltatást.
</p>
<p>Hogy biztosítani tudja a  <e>NET</e> virtuális szolgáltatást, a szolgáltatásnak meg kell felelnie a következőknek:
</p>
<ul>
<li>Hozzá kell rendelni az aktuális vagy a boot futásszinthez.</li>
<li>A nevében a net. előtagnak szerepelnie kell.</li>
<li>A net. utáni rész egy létező hálózati interfész neve kell, hogy legyen (pl. net.eth1).</li>
</ul>
<p>Minden egyes érvényes net.* szolgáltatás esetén, a $IFACE változó felveszi a hálózati interfész nevét
(&quot;eth0&quot; a net.eth0 esetén például).
</p>
</body>
</section>
</chapter>
<chapter>
<title>Default parancssori opciók</title>
<section>
<body>
<p>A default opciók valamennyi szolgáltatás esetében használhatók. Valamennyi már előre definiálva van,
kivéve a      <e>START</e> és a  <e>STOP</e> opciókat, melyeket a felhasználónak kell függvényként definiálnia az rc-szkriptekben.
</p>
<impo>A <e>start()</e> függvényt <e> kötelező</e> definiálni.</impo>
<note>A  <e>stop()</e> függvény kevésbé fontos, és elhagyható.</note>
<note>A felhasználó általában csak a     <e>start()</e>,<e>stop()</e> és 
<e>restart()</e>függvényeket definiálja.  A többi belső funkció, és legjobb békén hagyni.</note>
<pre caption="a httpd szolgáltatás indítása" >
# <i>/etc/init.d/httpd start</i>
</pre>
<note>A parancssori opciók halmozhatók.</note>
<pre caption="pause/start net.eth0" >
# <i>/etc/init.d/net.eth0 pause start</i>
</pre>
</body>
</section>
<section>
<title>A START/STOP opciók</title>
<body>
<p>
<e>Indítják (START)</e> a szolgáltatást a függőségekkel együtt.
</p>
<p>
<e>Leállítják (STOP) </e> a szolgáltatást a függőségekkel együtt.
</p>
</body>
</section>
<section>
<title>A RESTART opció</title>
<body>
<p>A szolgáltatásnak futnia kell ahhoz, hogy a  <e>RESTART</e> működjön.
Hatására újraindul a szolgáltatás és a függőségek is.
</p>
<impo>Egyedi  <e>restart()</e> függvény definiálása esetén, a felhasználónak a  <e>&quot;svc_start()&quot;</e>
és  <e>&quot;svc_stop()&quot;</e> függvényeket kell használnia a szolgáltatás indításához és leállításához.</impo>
<note>Ez a függőségek helyes kezelése végett van így.</note>
</body>
</section>
<section>
<title>A PAUSE opció</title>
<body>
<p>Ez leállítja a szolgáltatást, de ellentétben a  <e>STOP</e> opcióval, a függőségek nem állnak le. </p>
</body>
</section>
<section>
<title>A ZAP opció</title>
<body>
<p>A szolgáltatás állapotát &quot;leállított&quot; értékre állítja be. 
</p>
<note>Ilyenkor a  <e>stop()</e> függvényben lévő egyik parancs sem hajtódik végre.
Ezeket szükség szerint a felhasználónak kell elvégeznie.</note>
</body>
</section>
<section>
<title>Az INEED/NEEDSME opciók</title>
<body>
<p>
<e>Az INEED</e> felsorolja mindazokat a szolgáltatásokat, melyekre az aktuálisnak    <e>SZÜKSÉGE VAN</e>.
</p>
<p>
<e>A NEEDSME</e> felsorolja mindazokat a szolgáltatásokat, melyek  <e>IGÉNYLIK</e> az aktuális szolgáltatást.
</p>
</body>
</section>
<section>
<title>Az IUSE/USESME opciók</title>
<body>
<p>
<e>Az IUSE</e> felsorolja mindazokat a szolgáltatásokat, melyeket az aktuális  <e>HASZNÁL</e>.
</p>
<p>
<e>A USESME</e> felsorolja mindazokat a szolgáltatásokat, melyek az aktuálisat <e>HASZNÁLJÁK</e>.
</p>
</body>
</section>
<section>
<title>A BROKEN opció</title>
<body>
<p> Ez felsorolja mindazokat a hiányzó szolgáltatásokat (ha vannak ilyenek), melyekre az aktuálisnak  <e>SZÜKSÉGE</e> lenne.
</p>
</body>
</section>
</chapter>
<chapter>
<title>Egyedi parancssori opciók hozzáadása</title>
<section>
<body>
<p>Viszonylag egyszerű egyedi parancssori opciókat alkalmazni. Az rc-szkriptben definiálni kell egy függvényt, amely tartalmazza az opció nevét, és hozzá kell adni a  <e>$opts</e> változóhoz, amint az alább látható.
</p>
<pre caption="foo mint egyedi opció" >
opts=&quot;${opts} foo&quot;
 
foo() {
    ............
}
</pre>
</body>
</section>
</chapter>
<chapter>
<title>Beállítás</title>
<section>
<body>
<p>A beállításokat általában környezeti változók segítségével kell elvégezni. Ezeket azonban nem az rc-szkriptben kell megadni,
 hanem a három lehetséges konfigurációs file egyikében.
</p>
<p>Egyikük specifikusan az rc-szkriptekhez tartozik, a másik kettő globális konfigurációs file:
</p>
<pre caption="rc-szkriptek konfig fájljai" >
/etc/conf.d/&lt;az rc-szkript neve>
/etc/conf.d/basic
/etc/rc.conf
</pre>
<note>Ez a három konfigurációs file a felsorolt sorrendben automatikusan kerülnek feldolgozásra.</note>
<impo>Valamennyi <e>NET</e> szolgáltatás meghívja a  <path>/etc/conf.d/net-t is.</path>
</impo>
</body>
</section>
</chapter>
<chapter>
<title>Segédprogramok és -szkriptek</title>
<section>
<title>Az rc-update segédprogram</title>
<body>
<p>Az rc-update az elsődleges eszköze a szolgáltatások futási szinthez való hozzáadásának illetve onnan való elvételének.
Ezenkívül meghívja a &quot;depscan.sh&quot;-t, hogy frissítse a függőségi cache-t. </p>
<pre caption="a metalog hozzáadása a default futásszinthez" >
# <i>rc-update add metalog default</i>
</pre>
<pre caption="a metalog eltávolítása a default futásszintről" >
# <i>rc-update del metalog default</i>
</pre>
<note>Ha paraméterek nélkül futtatod az rc-update-et, további segítséget kapsz.</note>
</body>
</section>
<section>
<title>A depscan.sh segédszkript</title>
<body>
<p>A teljesség kedvéért itt említjük meg a depscan.sh-t is.Ezzel egy cache jön létre, amely gyakorlatilag a függőségek térképét tartalmazza. 
</p>
<p>Mindannyiszor futtatni kell, ahányszor új rc-szkriptet adunk a  <path>/etc/init.d/</path> könyvtárhoz,
de mivel az rc-update automatikusan meghívja, a legtöbb felhasználónak nem lesz szüksége rá, hogy önállóan futtassa.</p>
</body>
</section>
</chapter>
</guide>
