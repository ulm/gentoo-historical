<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/bugzilla-howto.xml,v 1.2 2005/10/19 23:08:56 rane Exp $ -->

<guide link="/doc/pl/bugzilla-howto.xml" lang="pl">
<title>Zgłaszanie błędów w Gentoo</title>

<author title="Autor">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Redaktor">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Tłumaczenie">
  <mail link="jbozanowski@gmail.com">Kuba Bożanowski</mail>
</author>

<abstract>
Niniejszy dokument przedstawia prawidłowy sposób zgłaszania błędów przy użyciu
Bugzilli.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2005-08-29</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Przedmowa</title>
<body>

<p>
Jeden z czynników, który opóźnia naprawienie błędu to sposób, w jaki błąd
został zgłoszony. Tworzymy ten przewodnik z myślą o usprawnieniu komunikacji
między deweloperami a użytkownikami przy poprawianiu błędów, ponieważ jest to
ważna, o ile nie najważniejsza część procesu zapewniania jakości w każdym
projekcie. Mamy nadzieję, że niniejszy przewodnik przyczyni się do jego
sukcesu.
</p>

</body>
</section>
<section>
<title>Błędy!!!</title>
<body>

<p>
Instalujemy paczkę lub pracujemy z programem i nagle staje się najgorsza rzecz
-- znajdujemy błąd. Jest wiele rodzajów błędów, jak na przykład awarie
instalacji przy użyciu narzędzia emerge albo naruszenia ochrony pamięci (ang.
segmentation fault). Cokolwiek jest przyczyną ich wystąpienia, pozostaje 
fakt, iż muszą one zostać poprawione. Oto kilka przykładów takich błędów.
</p>

<pre caption="Błąd podczas wykonywania">
$ <i>./zepsuty_kod `perl -e 'print Ax100'`</i>
Segmentation fault
</pre>

<pre caption="Awaria w czasie działania narzędzia emerge">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Błędy te mogą przysporzyć wielu problemów. Co jednak należy zrobić gdy już się
je spotka? W tym rozdziale przyjrzymy się dwóm ważnym narzędziom do obsługi
błędów występujących podczas wykonywania kodu (ang. runtime error). Następnie 
omówimy błędy kompilacji i jak sobie z nimi poradzić. Zacznijmy jednak od 
pierwszego narzędzia do "odpluskwiania" działającego kodu -- <c>gdb</c>
</p>

</body>
</section>
</chapter>

<chapter>
<title>Debugowanie przy pomocy GDB</title>
<section>
<title>Wprowadzenie</title>
<body>

<p>
GDB, czyli (G)NU (D)e(B)ugger to narzędzie do znajdywania błędów w uruchomionym
programie. Zwykle błędy te wynikają z naruszeń pamięci. Najpierw przyjrzyjmy
się co debugowanie za sobą pociąga. Jedną z podstawowych czynności, jakie
należy wykonać aby móc debugować program jest skompilowanie go narzędziem
<c>emerge</c> ze zmienną <c>FEATURES="nostrip"</c>. Zapobiega to usunięciu
symboli debugowania. Dlaczego symbole te domyślnie usuwa się z programów? Powód
jest ten sam jak w przypadku kompresowania stron man programem gzip --
oszczędność miejsca. Oto jak zmienia się rozmiar programu z symbolami
debugowania pozostawionymi i usuniętymi.
</p>

<pre caption="Porównanie rozmiaru pliku">
<comment>(symbole debugowania usunięte)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 zepsuty_kod
<comment>(symbole debugowania pozostawione)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 zepsuty_kod
</pre>

<p>
Nawiasem mówiąc, program <e>zepsuty_kod</e> jest tym samym, który będziemy 
później debugować za pomocą narzędzia <c>gdb</c>. Jak widać, program bez
symboli debugowania zajmuje 3140 bajtów, podczas gdy z nimi ma już 6374
bajty. To prawie dwa razy więcej! Możemy zrobić jeszcze dwie rzeczy z myślą o
debugowaniu. Pierwszą z nich jest dodanie ggdb3 do zmiennych CFLAGS i
CXXFLAGS.  Flaga ta dodaje więcej informacji przydatnych przy debugowaniu niż
jest zwykle dodawanych. Wkrótce dowiemy się co to oznacza. Oto jak <e>może</e>
wyglądać plik <path>/etc/make.conf</path> z nowo dodanymi flagami.
</p>

<pre caption="ustawienia w pliku make.conf">
CFLAGS="-O1 -pipe -g -ggdb"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Wreszcie, możemy dodać flagę USE debug dla danej paczki. Dokonamy tego za
pomocą pliku <path>package.use</path>. 
</p>

<pre caption="Użycie pliku package.use w celu dodania flagi debug">
# <i>echo "kategoria/paczka debug" >> /etc/portage/package.use</i>
</pre>

<note>
Domyślnie katalog <path>/etc/portage</path> nie istnieje i możliwe, że będziemy
musieli go utworzyć, o ile jeszcze tego nie zrobiliśmy. Jeśli zaś paczka już ma
ustawione flagi USE w pliku <path>package.use</path>, trzeba będzie ręcznie
zmodyfikować je za pomocą ulubionego edytora tekstu.
</note>

<p>
Następnie ponownie instalujemy paczkę wraz z dokonanymi wyżej modyfikacjami.
</p>

<pre caption="Ponowna instalacja paczki z włączonym debugowaniem">
# <i>FEATURES="nostrip" emerge package</i>
</pre>

<p>
Teraz gdy symbole debugowania są już na miejscu, możemy przejść do debugowania
programu.
</p>

</body>
</section>
<section>
<title>Uruchamianie programu przez GDB</title>
<body>

<p>
Załóżmy, że mamy program nazywający się "zepsuty_kod". Ktoś twierdzi, że
program ten wywala się i podaje jak to zrobić. Spróbujmy więc:
</p>

<pre caption="Psucie programu">
$ <i>./zepsuty_kod `perl -e 'print Ax100'`</i>
Segmentation fault
</pre>

<p>
Wygląda na to, że ten ktoś miał rację. Skoro program rzeczywiście jest wadliwy,
znaleźliśmy błąd. Czas więc użyć <c>gdb</c> aby pomógł nam rozwiązać ten
problem. Uruchamiamy więc program <c>gdb</c> z parametrem <c>--args</c>,
podając mu następnie pełną nazwę programu wraz z argumentami, jak podano
poniżej:
</p>

<pre caption="Uruchamianie naszego programu poprzez GDB">
$ <i>gdb --args ./zepsuty_kod `perl -e 'print Ax100'`</i>
GNU gdb 6.3
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu"...Using host libthread_db library "/lib/libthread_db.so.1".
</pre>

<note>
Można także debugować przy pomocy zrzutów core (ang. core dumps). Pliki te
zawierają te same informacje, które podałby program uruchomiony przez gdb.
Chcąc debugować program zepsuty_kod przy pomocy zrzutu core, należałoby wykonać
polecenie <c>gdb ./zepsuty_kod core</c>, gdzie core to nazwa pliku ze zrzutem.
</note>

<p>
Powinniśmy teraz ujrzeć działający debugger czekający na nasze polecenia po
znaku zachęty "(gdb)". Najpierw uruchamiamy program. W tym celu należy wpisać
polecenie <c>run</c>, co zaowocuje informacją podobną do poniższej:
</p>

<pre caption="Uruchamianie programu przez GDB">
(gdb) <i>run</i>
Starting program: /home/chris/zepsuty_kod

Program received signal SIGSEGV, Segmentation fault.
0xb7ec6dc0 in strcpy () from /lib/libc.so.6
</pre>

<p>
Widzimy tu uruchamianie programu, a także powiadomienie go o sygnale SIGSEGV,
czyli błędzie segmentacji (ang. segmentation fault). W ten sposób GDB mówi nam,
że program wywalił się. Dostajemy także informację o ostatniej funkcji, jaką
można było wyśledzić, kiedy program kończył działanie. Niestety, niekoniecznie
będzie to użyteczna informacja, ponieważ w programie może być wiele funkcji
strcpy, co utrudni deweloperom odnalezienie tej, w której rzeczywiście wystąpił
błąd. Aby pomóc im w tym, wykonujemy coś, co określa się jako śledzenie wsteczne
(ang. backtrace). Poprzez śledzenie wsteczne poruszamy się do tyłu poprzez
wszystkie funkcje, które zostały wywołane w trakcie pracy programu, aż do tej, w
której wystąpił błąd. Funkcje, które zwracają dane (i nie powodują awarii
programu) nie pojawią się. Aby dokonać śledzenia wstecznego należy wpisać w gdb
polecenie <c>bt</c>. Otrzymamy wynik zbliżony do tego:
</p>

<pre caption="Backtrace programu">
(gdb) <i>bt</i>
#0  0xb7ec6dc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it ()
#2  0x080483ba in main ()
</pre>

<p>
Teraz łatwo zobaczyć co się dzieje. Najpierw wywoływana jest funkcja main(),
następnie run_it(), a gdzieś w run_it() nasz winowajca, czyli funkcja 
strcpy(). To właśnie w ten sposób możemy naprowadzić deweloperów na konkretny
ślad błędu. Należy zwrócić jednak uwagę na kilka rzeczy. Po pierwsze, jeśli
zapomnimy o włączeniu symboli debugowania za pomocą <c>FEATURES="nostrip"</c>,
gdb wypisze nam coś takiego:
</p>

<pre caption="Backtrace programu bez symboli debugowania">
(gdb) <i>bt</i>
#0  0xb7e2cdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in ?? ()
#2  0xbfd19510 in ?? ()
#3  0x00000000 in ?? ()
#4  0x00000000 in ?? ()
#5  0xb7eef148 in libgcc_s_personality () from /lib/libc.so.6
#6  0x080482ed in ?? ()
#7  0x080495b0 in ?? ()
#8  0xbfd19528 in ?? ()
#9  0xb7dd73b8 in __guard_setup () from /lib/libc.so.6
#10 0xb7dd742d in __guard_setup () from /lib/libc.so.6
#11 0x00000006 in ?? ()
#12 0xbfd19548 in ?? ()
#13 0x080483ba in ?? ()
#14 0x00000000 in ?? ()
#15 0x00000000 in ?? ()
#16 0xb7deebcc in __new_exitfn () from /lib/libc.so.6
#17 0x00000000 in ?? ()
#18 0xbfd19560 in ?? ()
#19 0xb7ef017c in nullserv () from /lib/libc.so.6
#20 0xb7dd6f37 in __libc_start_main () from /lib/libc.so.6
#21 0x00000001 in ?? ()
#22 0xbfd195d4 in ?? ()
#23 0xbfd195dc in ?? ()
#24 0x08048201 in ?? ()
</pre>

<p>
Powyższe śledzenie wsteczne zawiera wiele podwójnych znaków zapytania. Dzieje
się tak, ponieważ bez symboli debugowania <c>gdb</c> nie wie jak program był
wykonywany. Dlatego tak bardzo ważne jest aby ich <e>nie</e> usuwać. Teraz
przypomnijmy sobie o fladze -ggdb, o której wspominaliśmy nie tak dawno.
Zobaczmy co wypisze gdb, jeśli ją włączymy:
</p>

<pre caption="Śledzenie wsteczne programu z flagą -ggdb3">
(gdb) <i>bt</i>
#0  0xb7e4bdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it (input=0x0) at zepsuty_kod.c:7
#2  0x080483ba in main (argc=1, argv=0xbfd3a434) at zepsuty_kod.c:12
</pre>

<p>
Na powyższym przykładzie widać o ile więcej informacji dostępnych jest dla
deweloperów. Wyświetlane są nie tylko informacje o funkcjach, ale także numery
linii plików źródłowych. Jeśli jesteśmy sobie w stanie pozwolić na zużycie
większej ilości miejsca na dysku przez program, jest to zdecydowanie najlepsza
metoda. Oto jak zmienia się rozmiar pliku binarnego w zależności od sposobu
kompilacji.
</p>

<pre caption="Różnice w rozmiarze z flagą -ggdb">
<comment>(bez symboli debugowania)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 zepsuty_kod
<comment>(z symbolami debugowania)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 zepsuty_kod
<comment>(włączona flaga -ggdb)</comment>
-rwxr-xr-x  1 chris users 19552  6/28 13:11 zepsuty_kod
</pre>

<p>
Jak widać, włączenie flagi -ggdb dodaje około <e>13178</e> bajtów do rozmiaru
pliku w stosunku do pliku, w którym włączone są jedynie symbole debugowania.
Jednakże, jak pokazaliśmy wyżej, ten wzrost rozmiaru jest usprawiedliwiony
jeśli chcemy pokazać efekty debugowania deweloperom. Wynik śledzenia wstecznego
może być zapisany do pliku poprzez skopiowanie i wklejenie z terminala (możemy
użyć gpm, jeśli nie korzystamy z terminala pod x. Aby nie komplikować
niniejszego dokumentu, sugerujemy poszukać dodatkowych informacji o kopiowaniu i
wklejaniu za pomocą gpm w jego dokumentacji). Zakończyliśmy już pracę z
<c>gdb</c>, możemy więc go wyłączyć.
</p>

<pre caption="Wyłączanie GDB">
(gdb) <i>quit</i>
The program is running. Exit anyway? (y or n) <i>y</i>
$
</pre>

<p>
W ten oto sposób zakończyliśmy nasz krótki kurs korzystania z narzędzia
<c>gdb</c>. Mamy nadzieję, że dzięki niemu powstaną lepsze raporty o błędach. Są
jednakże inne typy błędów, które mogą spowodować awarię programu w trakcie jego
działania. Może się to stać na przykład na skutek niewłaściwego odwoływania się
do pliku. Takie błędy odnajdziemy przy pomocy narzędzia o nazwie <c>strace</c>. 
</p>

</body>
</section>
</chapter>

<chapter>
<title>Znajdywanie błędów w dostępie do plików przy pomocy strace</title>
<section>
<title>Wprowadzenie</title>
<body>

<p>
Programy często korzystają z plików w celu odczytywania konfiguracji, uzyskania
dostępu do sprzętu lub zapisywania logów. Czasem program próbuje odwołać się do
takich plików w niewłaściwy sposób. Narzędzie o nazwie <c>strace</c> stworzono
właśnie po to, by radzić sobie z takimi błędami. Śledzi ono wywołania systemowe
(ang. "to trace" -- śledzić, tropić -- stąd nazwa), a więc odwołania do pamięci
i plików. W ramach przykładu użyjemy programu foobar2, który jest nowszą wersją
programu foobar. Jednakże po przesiadce na foobar2 zauważamy brak naszej
konfiguracji! W pierwszej wersji programu ustawiliśmy go tak aby wypisywał
napis "bla", jednak teraz wypisuje domyślne "fuj".
</p>

<pre caption="foobar2 z niewłaściwą konfiguracją">
$ <i>./foobar2</i>
Konfiguracja mówi: fuj
</pre>

<p>
Przy poprzedniej konfiguracji ta sama opcja miała wartość bla, użyjmy więc
narzędzia <c>strace</c> aby dowiedzieć się o co chodzi.
</p>

</body>
</section>
<section>
<title>Użycie programu strace do znalezienia błędu</title>
<body>

<p>
Chcemy aby <c>strace</c> zalogował rezultat wywołań systemowych. Aby tego
dokonać uruchamiamy program <c>strace</c> z parametrem -o[plik]. Wypróbujmy to
na programie foobar2.
</p>

<pre caption="Uruchamianie foobar2 poprzez strace">
# <i>strace -ostrace.log ./foobar2</i>
</pre>

<p>
W bieżącym katalogu powstaje plik <path>strace.log</path>. Oglądamy jego
zawartość. Poniżej znajdują się najistotniejsze dla naszej sytuacji wiersze. 
</p>

<pre caption="Zaglądamy do pliku z logiem strace">
open(".foobar2/config", O_RDONLY)       = 3
read(3, "fuj", 3)                       = 3
</pre>

<p>
Acha! Więc w tym tkwi problem. Ktoś zmienił katalog z konfiguracją z 
<path>.foobar</path> na <path>.foobar2</path>. Widzimy także, że program
prawidłowo czyta "fuj" z pliku. W tym przypadku najlepiej będzie powiadomić
osobę, która odpowiada za plik ebuild aby dodała ostrzeżenie o tej zmianie.
Jednak na razie możemy skopiować plik konfiguracyjny z katalogu 
<path>.foobar</path> we właściwe miejsce. 
</p>

</body>
</section>
<section>
<title>Podsumowanie</title>
<body>

<p>
W ten sposób zakończyliśmy temat błędów pojawiających się w czasie działania
programu. Jednak, pomimo iż błędy te przysparzają wielu problemów, będą one
naszym ostatnim zmartwieniem, gdy program nie będzie się nawet kompilował.
Przyjrzyjmy się więc jak można poradzić sobie z błędami kompilacji w czasie 
używania narzędzia <c>emerge</c>. 
</p>

</body>
</section>
</chapter>

<chapter>
<title>Jak poradzić sobie z błędami emergowania</title>
<section>
<title>Wprowadzenie</title>
<body>

<p>
Błędy przy używaniu <c>emerge</c>, jak ten, który pokazaliśmy na początku, mogą
być główną przyczyną frustracji użytkowników. Zgłaszanie ich jest uznawane za
jeden z najważniejszych sposobów troszczenia się o Gentoo. Przyjrzyjmy się zatem
przykładowemu procesowi instalacji programu foobar2, w czasie którego wystąpią
błędy kompilacji.
</p>

</body>
</section>
<section id="emerge_error">
<title>Szacowanie błędów emerge</title>
<body>

<p>
Zwróćmy uwagę na ten prosty błąd <c>emerge</c>:
</p>

<pre caption="Błąd emerge">
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2.o foobar2.c
foobar2.c:1:17: ogg.h: No such file or directory
make: *** [foobar2.o] Error 1

!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
Program kompilował się bez problemów do czasu gdy nagle przedstawił nam
komunikat błędu. Ten konkretny komunikat możemy podzielić na trzy sekcje,
przedstawione poniżej: komunikaty kompilatora, błąd budowania i komunikat błędu
emerge.
</p>

<pre caption="Części błędu">
<comment>(Komunikaty kompilatora)</comment>
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod   -c -o foobar2.o foobar2.c

<comment>(Błąd budowania)</comment>
foobar2.c:1:17: ogg.h: No such file or directory
make: *** [foobar2.o] Error 1

<comment>(Błąd emerge)</comment>
!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
Komunikaty kompilatora poprzedzają wystąpienie błędu. Najczęściej dobrze będzie
dołączyć przynajmniej 10 ostatnich linii informacji o kompilacji aby deweloper
wiedział w którym momencie tego procesu wystąpił błąd. 
</p>

<p>
Błędy w działaniu narzędzia make to błędy właściwe i właśnie tej informacji
potrzebuje deweloper. Widząc napis "make: ***" najczęściej możemy poznać miejsce
wystąpienia błędu. Zwykle wystarczy, że skopiujemy 10 linijek powyżej tego
miejsca i deweloper poradzi sobie z naprawieniem problemu. Czasem jednak okaże
się, że to za mało i wkrótce przyjrzymy się alternatywom.
</p>

<p>
Ostatni komunikat jest błędem zgłaszanym przez <c>emerge</c>. Czasami on również
zawiera przydatne informacje, jednak często się zdarza, że zgłaszany jest tylko
ten komunikat i nic więcej. To za mało, jednak mając jeszcze komunikat błędu
make i komunikaty kompilatora deweloper zorientuje się jaka aplikacja i która
wersja paczki jest wadliwa. Na marginesie, make jest najczęściej używanym
narzędziem do budowania programów, <b>jednak nie jedynym</b>. Jeśli nie widać
nigdzie komunikatu "make: ***", należy po prostu przekopiować 20 linijek przed
komunikatem emerge. Ten sposób powinien wystarczyć w przypadku większości
komunikatów o błędach. Jeśli jednak jest ich bardzo wiele, 10 linii może nie
objąć wszystkiego. Wówczas musimy zainteresować się zmienną PORT_LOGDIR.
</p>

</body>
</section>
<section>
<title>emerge i zmienna PORT_LOGDIR</title>
<body>

<p>
PORT_LOGDIR to zmienna systemu portage, która definiuje katalog z logami
narzędzia emerge. Najpierw spróbujmy uruchomić proces instalacji ze zmienną
PORT_LOGDIR ustawioną na nasz ulubiony katalog z logami. Załóżmy, że istnieje
katalog <path>/var/log/portage</path>.  Użyjemy go jako miejsca na logi:
</p>

<note>
Domyślnie katalog <path>/var/log/portage</path> nie istnieje i należy utworzyć
go ręcznie. Jeśli tego nie zrobimy, portage nie zapisze logów.
</note>

<pre caption="Instalowanie ze zmienną PORT_LOGDIR">
# <i>PORT_LOGDIR=/var/log/portage emerge foobar2</i>
</pre>

<p>
Oczywiście proces znowu kończy się niepowodzeniem, tym razem jednak mamy log,
który możemy potem dołączyć do buga. Zajrzyjmy do katalogu.
</p>

<pre caption="Zawartość katalogu PORT_LOGDIR">
# <i>ls -la /var/log/portage</i>
total 16
drwxrws---   2 root root 4096 Jun 30 10:08 .
drwxr-xr-x  15 root root 4096 Jun 30 10:08 ..
-rw-r--r--   1 root root 7390 Jun 30 10:09 2115-foobar2-1.0.log
</pre>

<p>
Pliki logów mają format [licznik]-[nazwa-paczki]-[wersja].log. Licznik to
specjalna zmienna, dzięki której wiemy, że ta paczka jest n-tą, którą
instalowaliśmy. Dzięki temu nie pojawiają się powielone pliki z logami. Jeśli
zajrzymy do pliku, ujrzymy cały proces instalacji. Później dowiemy się jak
dołączyć go przy zgłaszaniu błędu. Teraz jednak, skoro mamy już informacje
potrzebne do zgłoszenia buga, możemy się za to zabrać. Najpierw musimy się tylko
upewnić, czy nikt nie zgłosił już tego problemu przed nami. Przyjrzyjmy się więc
procesowi szukania błędów.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Przeszukiwanie Bugzilli</title>
<section>
<title>Wprowadzenie</title>
<body>

<p>
W projekcie Gentoo używamy <uri link="http://www.bugzilla.org">Bugzilli</uri> do
zgłaszania błędów. Nasza Bugzilla dostępna jest przez protokoły HTTPS i HTTP.
HTTPS dostępne jest głównie dla osób w niezabezpieczonych sieciach lub dla
paranoików, jednak aby zachować spójność, w następnych przykładach będziemy
używać właśnie tej wersji. Zajrzyjmy teraz na stronę <uri
link="https://bugs.gentoo.org">Gentoo Bugs</uri> aby zapoznać się z jej
wyglądem.
</p>

<p>
Znajdywanie powtarzających się zgłoszeń błędów jest jedną z najbardziej
frustrujących rzeczy dla deweloperów i osób poprawiających błędy. Kosztują ich
one czas, który mogliby poświęcić pracy nad poważnymi błędami. Najczęściej
zgłaszaniu wielokrotnie tych samych błędów można zapobiec dokonując kilku
prostych wyszukiwań. Przyjrzymy się więc kwestii szukania błędów i zorientowania
się, że jest już zgłoszony identyczny jak nasz. W ramach przykładu wykorzystamy
użyty już wcześniej błąd w czasie instalowania programu xclass. 
</p>

<pre caption="Błąd w przy instalacji xclass">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Aby rozpocząć poszukiwania, musimy udać się na <uri
link="https://bugs.gentoo.org/">stronę główną Bugzilli</uri>.
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Strona główna Bugzilli"/>

<p>
Kliknijmy na odnośnik "Query Existing bug reports". Wybieramy tę
opcję zamiast podstawowej funkcji szukania bugów, ponieważ ta druga daje zbyt
ogólne wyniki i utrudnia przeszukiwanie rezultatów i odnajdywanie zduplikowanego
błędu. Po kliknięciu na odnośnik dotrzemy do następnej strony:
</p>

<figure link="/images/docs/bugzie-search.png" caption="Strona przeszukiwania Bugzilli"/>

<note>
Jeśli kiedykolwiek wcześniej używaliśmy opcji Advanced Search,
najprawdopodobniej to właśnie ją ujrzymy.
</note>

<p>
Przejdźmy dalej, klikając na odnośnik "Advanced Search" aby wejść na stronę
zaawansowanego wyszukiwania.
</p>

<figure link="/images/docs/bugzie-adv-search.png" caption="Strona Advanced Search"/>

<p>
Tak wygląda strona Advanced Search. Na pierwszy rzut oka może wyglądać nieco
przytłaczająco, ale przyjrzymy się jedynie kilku prostym obszarom aby zawęzić
zbyt ogólne wyniki wyszukiwania zwykle zwracane przez Bugzillę.
</p>

<figure link="/images/docs/bugzie-content.png" caption="Zawartość"/>

<p>
Pierwsze pole to podsumowanie buga. Wpiszemy tu po prostu nazwę paczki, która
ma błędy. Jeśli nie otrzymamy wyników, spróbujmy usunąć nazwę paczki, na
wypadek, gdyby ktoś nie podał jej w podsumowaniu (mało prawdopodobne, ale
widzieliśmy już wiele dziwnych raportów o błędach). 
</p>

<p>
W polach Product (produkt), Component (składnik), i Version (wersja)
powinniśmy pozostawić wartości domyślne. Unikniemy w ten sposób bycia zbyt
dokładnymi i pominięcia jakichś bugów. 
</p>

<p>
Pole Comment (komentarz) jest istotne. Przy jego pomocy podamy to, co wydaje się
być charakterystyczne dla danego błędu. Generalnie nie należy wpisywać rzeczy
typu początek komunikatu o błędzie budowania. Należy odnaleźć linię wcześniej,
która mówi o prawdziwym błędzie. Musimy także odfiltrować znaki interpunkcyjne,
inaczej Bugzilla może zinterpretować komentarz w inny sposób, niż byśmy tego
sobie życzyli. Oto przykład z naszego błędu instalowania programu xclass:
</p>

<pre caption="Zawartość pola Comment">
menudef.h:78: error: brace-enclosed initializer used to initialize `OXPopupMenu'
<comment>(Pozbywamy się apostrofów ' ')</comment>
menudef.h 78 error brace-enclosed initializer used to initialize OXPopupMenu
</pre>

<p>
Powyższe jest wystarczająco dokładne aby nie musieć przebijać się przez
pozostałe błędy kompilacji programu xclass. 
</p>

<p>
Pola URI, Whiteboard i Keywords możemy zostawić w spokoju. To co do tej pory
wpisaliśmy powinno wystarczyć. Przyjrzyjmy się danym, które wprowadziliśmy.
</p>

<figure link="/images/docs/bugzie-comp-search.png" 
caption="Gotowy formularz wyszukiwania"/>

<p>
Kliknijmy więc na przycisku Search (szukaj) aby otrzymać wyniki...
</p>

<figure link="/images/docs/bugzie-search-result.png" 
caption="Wyniki wyszukiwania"/>

<p>
Tylko 2 bugi! Z nimi będzie nam o wiele łatwiej sobie poradzić. Kliknijmy na
pierwszy z nich. No proszę! Właśnie tego szukaliśmy. 
</p>

<figure link="/images/docs/bugzie-located.png" caption="Bug znaleziony"/>

<p>
Nie tylko o ten bug nam chodziło, ale na dodatek został on już rozwiązany.
Czytając ostatni komentarz dowiemy się w jaki sposób się to udało i co sami
musimy zrobić. Zobaczmy zatem co by było, gdybyśmy nie użyli opcji
zaawansowanego szukania.
</p>

<figure link="/images/docs/bugzie-basic-search-result.png" 
caption="Wyniki prostego szukania"/>

<p>
Musielibyśmy przyjrzeć się czterem bugom więcej! W przypadku dużych paczek jest
jeszcze gorzej. Jednakże przy użyciu omówionych narzędzi możemy znacznie zawęzić
wyniki wyszukiwania i znaleźć konkretny bug.
</p>

</body>
</section>
<section>
<title>Podsumowanie</title>
<body>

<p>
Załóżmy że szukaliśmy na wszystkie sposoby, ale nie mogliśmy znaleźć już
istniejącego buga. Znaleźliśmy zatem nowy. W takim razie przyjrzyjmy się
procesowi zgłaszania błędów aby go zgłosić.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Zgłaszanie błędów</title>
<section>
<title>Wprowadzenie</title>
<body>

<p>
W tym rozdziale dowiemy się jak za pomocą Bugzilli zgłosić nowy błąd. Przejdźmy
na stronę <uri link="https://bugs.gentoo.org">Gentoo Bugs</uri> i...
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Strona główna Bugzilli"/>

<p>
Kliknijmy na odnośniku "Report a Bug - Using the guided format" (Zgłoś błąd krok
po kroku)
</p>

<figure link="/images/docs/bugzie-prod-select.png" caption="Wybór produktu"/>

<p>
Jak widać, położono <b>duży</b> nacisk na to aby bug został poprawnie
przydzielony. Większość bugów trafia pod "Gentoo Linux". 
</p>

<p>
Pomimo tego niektórzy zgłaszają bugi dotyczące ebuildów do kategorii "portage
development" (zakładając, że zespół odpowiedzialny za portage zajmuje się
również drzewem) lub infra (sądząc, że ten, kto odpowiada za infrastrukturę ma
dostęp do serwerów lustrzanych i rsync i może bezpośrednio poprawić błąd). To
nie tak działa.
</p>

<p>
Często tego rodzaju nieporozumienia dotyczą też bugów dokumentacji. Założmy, że
użytkownik znajduje błąd w <uri link="/proj/en/releng/catalyst/">dokumentacji 
Catalyst</uri>. Zwykle bug przypisywany jest do Docs-user, gdzie zostanie
przydzielony do <uri link="http://gdp.gentoo.org">GDP</uri>, podczas gdy w
rzeczywistości powinien trafić do któregoś z członków zespołu <uri
link="/proj/en/releng/">Release Engineering</uri>. Generalnie należy przyjąć, że
dokumentacja znajdująca się w podkatalogach
<path>http://www.gentoo.org/doc/*</path> powinna trafić do GDP, zaś teksty z
<path>http://www.gentoo.org/proj/*</path> trafiają każdy do swojego
macierzystego zespołu.
</p>

<note>
Korzystniejszym scenariuszem będzie przydzielenie buga do produktu Gentoo Linux,
pomimo iż powinien trafić gdzie indziej, niż żeby coś, co należy do Gentoo Linux
trafiło do innej kategorii. Oczywiście wolelibyśmy aby bugi były przydzielane
poprawnie, jednak z dwojga złego pierwsza opcja jest korzystniejsza i bardziej
zrozumiała (z wyjątkiem błędów dotyczących strony www... tu mielibyśmy problem).
</note>

<p>
Nasz bug to problem z plikiem ebuild, trafia więc do produktu Gentoo Linux. Tam
też kierujemy nasze kroki, gdzie zostaje nam przedstawiony składający się z
kilku kroków proces zgłaszania buga. Zacznijmy od kroku pierwszego...
</p>

<figure link="/images/docs/bugzie-guide-step1.png" caption="Format przewodnika,
krok pierwszy"/>

<p>
Czerwony napis sugeruje nam, że pierwszy krok jest bardzo istotny. To tutaj
szukamy, czy ktoś nie natknął się na ten sam błąd co my i już go nie zgłosił.
Jeśli opuścilibyśmy ten krok a bug taki jak nasz już by istniał, nasz zostanie
oznaczony flagą DUPLICATE (duplikat) i zmarnuje tylko czas ludziom zajmującym
się zapewnianiem jakości. Przekreślone numery bugów u góry to właśnie duplikaty
błędów. Przechodzimy teraz do kroku drugiego, w którym podajemy informacje.
</p>

</body>
</section>
<section>
<title>Wymagane dane</title>
<body>

<figure link="/images/docs/bugzie-basic.png" caption="Podstawowe dane"/>

<p>
Przyjrzyjmy się bliżej co jest czym.
</p>

<ul>
  <li>
    Po pierwsze, Produkt. Pole to zawęzi bug do określonego obszaru Gentoo,
    takiego jak Bugzilla (błędy dotyczące bugs.gentoo.org), Docs-user
    (dokumentacja użytkownika) lub Gentoo Linux (pliki ebuild i tym podobne).
  </li>
  <li>
    W polu Component określamy gdzie dokładnie występuje problem, a właściwie w
    której części wybranego produktu. To ułatwia klasyfikację.
  </li>
  <li>
    W polu "Hardware platform" (platforma sprzętowa) informujemy na jakiej
    pracujemy architekturze. Na przykład jeśli nasz sprzęt to SPARC, to właśnie
    tak ustawiamy to pole.
  </li>
  <li>
    W "Operating System" wpisujemy jakiego systemu operacyjnego używamy. Gentoo
    jest nazywane "Meta-dystrybucją", a więc może pracować systemach
    operacyjnych innych niż Linux.
  </li>
</ul>

<p>
Tak więc dla naszego przykładowego buga podajemy:
</p>

<ul>
  <li>Product - Gentoo Linux (Ponieważ problem dotyczy pliku ebuild)</li>
  <li>Component - Application [aplikacja] (Błąd występuje w aplikacji, foobar2)</li>
  <li>Hardware Platform - All [wszystkie] (Ten błąd może wystąpić na
  którejkolwiek z architektur)</li>
  <li>Operating System - All [wszystkie] (Może dotyczyć każdego systemu)</li>
</ul>

<figure link="/images/docs/bugzie-basic-comp.png" caption="Podstawowe dane wypełnione"/>

<ul>
  <li>
    Pole "Build Identifier" to po prostu stała napisowa User Agent przeglądarki
    internetowej, za pomocą której zgłaszany jest bug (w celach logowania).
    Możemy pozostawić to pole bez zmian.
  </li>
  <li>
    "URL" to opcjonalne pole, którego można użyć, jeśli przechowujemy dane o
    błędach gdzieś w sieci (strona pastebin.com, itp.). Lepiej jednak podać
    takie dane wewnątrz buga, dzięki czemu deweloper będzie miał stały i wygodny
    dostęp do nich. 
  </li>
  <li>
    W polu "Summary" (podsumowanie) powinniśmy podać kategorię paczki, jej nazwę
    i numer wersji.
  </li>
</ul>

<p>
Nie jest dużym błędem pominięcie kategorii w podsumowaniu, warto jednak o niej
pamiętać. Natomiast koniecznie powinniśmy podać nazwę paczki, inaczej nikt nie
będzie wiedział do czego tak naprawdę zgłaszamy buga i będzie musiał nas później
o to spytać. Numer wersji jest ważny dla ludzi szukających bugów. Gdyby 20 osób
zgłosiło bugi i nikt nie uwzględniłby numeru wersji, ludzie szukający podobnych
błędów nie wiedziałoby który ich dotyczy. Jeśli bugów byłoby 200, dowiedzenie
się tego nie byłoby proste... Na koniec dobrze będzie umieścić krótki opis
zdarzenia. Oto przykład:
</p>

<figure link="/images/docs/bugzie-summary.png" caption="Podsumowanie"/>

<p>
Tych kilka prostych zasad znacznie ułatwi obsługę bugów. Teraz zajmiemy się
szczegółami. Tutaj podajemy informację o błędzie. Zademonstrujemy to na
przykładzie:
</p>

<figure link="/images/docs/bugzie-details.png" caption="Szczegóły"/>

<p>
Teraz deweloper będzie wiedział dlaczego wypełniamy buga. Może wówczas spróbować
powtórzyć błąd. Powtarzalność mówi jak często byliśmy w stanie sprawić, by
problem wystąpił. W naszym przykładzie problem powtarza się za każdym
uruchomieniem programu foobar2. Napiszmy więc o tym.
</p>

<figure link="/images/docs/bugzie-reprod.png" caption="Powtarzalność"/>

<p>
Wyjaśniliśmy w jaki sposób natknęliśmy się na błąd. Następnym krokiem jest
opisanie jakie wyniki otrzymujemy, a jakie powinniśmy byli otrzymać.
</p>

<figure link="/images/docs/bugzie-results.png" caption="Wyniki"/>

<p>
Następnie powinniśmy podać dodatkowe informacje w postaci wyników śledzenia
stosu (ang. "stack traces"), <b>fragmentów</b> logów programu strace (ponieważ
całe logi zwykle są obszerne i przez to nieprzydatne), a także, o czym
koniecznie należy pamiętać, wynik polecenia <c>emerge --info</c>. Oto przykład:
</p>

<figure link="/images/docs/bugzie-addl-info.png" caption="Dodatkowe informacje"/>

<p>
W końcu wybieramy wagę buga. Należy przyjrzeć się temu bardzo uważnie. W
większości przypadków można pozostawić tę opcję w spokoju i ktoś podniesie albo
opuści wagę za nas. Jeśli jednak chcemy zrobić to sami, należy dokładnie
zapoznać się z poniższą listą i upewnić się, że nie popełniamy błędu. Oto
poszczególne poziomy ważności.
</p>

<ul>
  <li>
    Blocker (blokujący) - program po prostu nie chce się zainstalować lub
    znacznie zakłóca działanie systemu. Na przykład problem z <c>baselayout</c>,
    który uniemożliwiałby uruchomienie systemu byłby pewnym kandydatem do
    opisania go jako blocker.
  </li>
  <li>
    Critical (krytyczny) - program traci dane lub gubi pamięć w czasie pracy.
    Ważny program, jak na przykład <c>net-tools</c>, który nie daje się
    skompilować może być oznaczony jako krytyczny. Nie uniemożliwi to
    uruchomienia systemu, ale znacznie utrudni jego normalne funkcjonowanie.
  </li>
  <li>
    Major (ważny) - Program wywala się, ale nie dzieje się nic, co
    poważnie uszkadzałoby system lub powodowało utratę danych.
  </li>
  <li>
    Minor (mało ważny) - nasz program "wykrzacza się" od czasu do czasu, można
    tego jednak nawet czasem uniknąć.
  </li>
  <li>
    Normal - Opcja domyślna. Jeśli nie jesteśmy pewni, należy pozostawić właśnie
    to ustawienie, chyba że mamy do czynienia z nowym programem, albo zmiana
    jest kosmetyczna. W takim układzie niżej znajdziemy lepszą opcję.
  </li>
  <li>
    Trivial (trywialny) - mało istotne rzeczy typu literówki albo poprawki
    białych znaków.
  </li>
  
  <li>
    Enhancement (udoskonalenie) - Prośba o dołączenie nowej funkcji programu
    albo o <e>nowe ebuildy</e>.
  </li>
</ul>

<figure link="/images/docs/bugzie-sev.png" caption="Waga"/>

<p>
W naszym przypadku pozostajemy przy domyślnej opcji Normal.
</p>

<p>
Możemy teraz zgłosić buga klikając przycisk "Submit Bug Report". Po chwili
ukaże nam się na ekranie. Rezultat możemy obejrzeć jako <uri
link="https://bugs.gentoo.org/show_bug.cgi?id=97265">Bug 97561</uri>. Skoro więc
już go zgłosiliśmy, zobaczmy jak zostanie obsłużony.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prace nad bugiem</title>
<section>
<body>

<p>
Oglądając zawartość zgłoszonego buga zauważamy, że został on przydzielony do
bug-wranglers@gentoo.org. Jest to domyślne miejsce dla bugów składnika
Application. 
</p>

<figure link="/images/docs/bugzie-new-basic.png" 
caption="Podstawowe informacje o nowym bugu"/>

<p>
Dostępne są także szczegóły, które wpisaliśmy.
</p>

<figure link="/images/docs/bugzie-new-details.png" 
caption="Szczegóły nowego buga"/>

<p>
Jednakże bug-wranglers (zwykle) nie poprawiają naszych bugów, przydzielimy go
więc komuś, kto to zrobi (możemy też pozwolić grupie bug-wranglers przydzielić
go za nas). W tym celu skorzystamy z pliku metadata.xml danej paczki. Zwykle
można go znaleźć według schematu
<path>/usr/portage/kategoria/paczka/metadata.xml</path>. Oto plik, który
przygotowałem dla programu foobar2.
</p>

<note>
Aby móc zmieniać przydziały bugów musimy być tymi, którzy danego buga zgłosili,
bądź też być członkami odpowiedniej grupy w Bugzilli Gentoo (na przykład Gentoo
Developers).
</note>

<pre caption="metadata.xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd"&gt;
&lt;pkgmetadata&gt;
&lt;herd&gt;chriswhite&lt;/herd&gt;
&lt;maintainer&gt;
&lt;email&gt;chriswhite@gentoo.org&lt;/email&gt;
&lt;name&gt;Chris White&lt;/name&gt;
&lt;/maintainer&gt;
&lt;longdescription lang="en"&gt;
Foobar2 is a package that uses a configuration file to display a word.
&lt;/longdescription&gt;
&lt;/pkgmetadata&gt;
</pre>

<p>
Zwróćmy uwagę na sekcję maintainer (opiekun). W niej wyszczególniony jest
opiekun paczki, którym w tym przypadku jest autor niniejszego tekstu, Chris
White. Jego adres email to chriswhite@gentoo.org. Użyjemy go do zmiany
przydziału buga do odpowiedniej osoby. Aby tego dokonać, kliknijmy na
przełącznik obok "Reassign bug to" i wpiszmy adres email.
</p>

<note>
Jeśli paczka nie posiada pliku metadata.xml, powinniśmy zmienić przydział na
maintainer-needed@gentoo.org, zaś dla paczki, która potrzebuje dewelopera Gentoo
jako opiekuna odpowiednim przydziałem będzie maintainer-wanted@gentoo.org
</note>

<figure link="/images/docs/bugzie-reassign.png" caption="Zmiana przydziału buga"/>

<p>
Kliknijmy teraz przycisk Commit aby zatwierdzić zmiany. Bug został przydzielony
do mnie. Niedługo później zostaniemy powiadomieni (zwykle przez email), że
odpowiedziałem na buga. Napisałem, że chciałbym obejrzeć log strace aby
dowiedzieć się jak program próbuje dotrzeć do naszego pliku konfiguracyjnego.
Użyjemy wcześniej podanych instrukcji w celu użycia programu strace i
wygenerowania loga. Teraz powinniśmy dołączyć go do buga. Aby to zrobić, musimy
kliknąć odnośnik "Create A New Attachment" (utwórz nowy załącznik).
</p>

<figure link="/images/docs/bugzie-new-attach.png" caption="Nowy załącznik"/>

<p>
Chcemy teraz dołączyć log. Zróbmy to krok po kroku.
</p>

<ul>
  <li>
    File (plik) - Tu podajemy położenie pliku na naszym komputerze, a w tym
    przypadku położenie pliku <path>strace.log</path>. Możemy użyć przycisku
    "Browse..." aby wybrać plik, ewentualnie wpisać ścieżkę ręcznie w polu
    tekstowym. 
  </li>
  <li>
    Description (opis) - kilka słów opisujących załącznik. Wpiszmy tu po prostu
    strace.log, to wszystko wyjaśni.
  </li>
  <li>
    Content Type (typ zawartości) - Rodzaj pliku, który dołączamy do buga.
  </li>
  <li>
    Obsoletes (unieważnia) - Gdyby do buga zostały wcześniej dołączone jakieś
    załączniki, mamy możliwość zaznaczenia, że nasz załącznik ma je zastąpić, a
    więc sprawić, że staną się zbędne. Nasz bug nie zawiera żadnych innych
    załączników, więc nie zmieniamy tej opcji.
  </li>
  <li>
    Comment (komentarz) - Tu możemy dopisać komentarz, który będzie widoczny
    obok załącznika. Jeśli zaistniałaby taka potrzeba, można dokładnie omówić
    załączany plik.
  </li>
</ul>

<p>
Jeszcze kilka szczegółów na temat pola Content Type. Możemy zaznaczyć pole
"patch", jeśli dołączamy łatkę. Możemy też poprosić Bugzillę o "auto-detekcję"
typu pliku (jest to niewskazane). Inne możliwości to "select from list" (wybierz
z listy), która jest najczęściej używana. Do <e>większości</e> załączników używa
się czystego tekstu (text/plain). Inne typy to image/gif, image/jpeg lub
image/png dla obrazków (w zależności od typu) i application/octet-stream dla
plików skompresowanych, jak na przykład .tar.bz2.
</p>


<figure link="/images/docs/bugzie-new-attach-comp.png" 
caption="Nowy załącznik jest gotowy"/>

<p>
Dołączyliśmy plik <path>strace.log</path> i teraz widać go przy naszym bugu.
</p>

<figure link="/images/docs/bugzie-strace.png" caption="Dołączony log strace"/>

<p>
Wspomnieliśmy wcześniej, że czasem podczas błędu procesu instalacji zostaniemy
poproszeni przez plik ebuild o dołączenie pliku przy zgłaszaniu buga. Poniżej
widzimy przykład.
</p>

<pre caption="Przykładowa prośba o dołączenie pliku">
configure: error: PNG support requires ZLIB. Use --with-zlib-dir=&lt;DIR&gt;

!!! Please attach the config.log to your bug report:
!!! /var/tmp/portage/php-5.0.3-r1/work/php-5.0.3/config.log

!!! ERROR: dev-php/php-5.0.3-r1 failed.
!!! Function econf, Line 485, Exitcode 0
!!! econf failed
!!! If you need support, post the topmost build error, NOT this status message.
</pre>

<p>
Powinniśmy dołączyć każdy taki plik zgłaszając bug.
</p>

<p>
Załóżmy że kiedy zrobiliśmy już to wszystko, ktoś inny znajduje nasz bug szukając w
Bugzilli i z ciekawości chciałby wiedzieć co się dalej z tym bugiem stanie. Może
zrobić to dodając swój email w polu Add CC, tak jak pokazano to niżej. Możemy
także śledzić inne bugi w ten sam sposób.
</p>

<figure link="/images/docs/bugzie-add-email.png" caption="Dodawanie emaila do
pola CC:"/>

<note>
Adresy email muszą być zarejestrowane w Bugzilli Gentoo. Aby dodać kilka adresów
rozdzielmy je przecinkami lub spacjami.
</note>

<p>
Po całej tej pracy nasz bug może uzyskać rozmaite oznaczenia statusu. Zwykle
robią to deweloperzy Gentoo, a czasem zgłaszający. Poniżej znajdziemy różne
możliwe statusy, przez które bug może przejść w czasie swojego istnienia.
</p>

<ul>
  <li>
    UNCONFIRMED (niepotwierdzony) - Jest to raczej rzadko spotykany status.
    Oznacza on, że zgłaszający otworzył buga używając zaawansowanej metody i nie
    jest pewny czy to rzeczywiście prawdziwy błąd.
  </li>
  <li>NEW (nowy) - W ten sposób oznaczane są bugi zaraz po otwarciu.</li>
  <li>
    ASSIGNED (przydzielony) - Gdy osoba, której przydzieliliśmy buga również go
    potwierdzi, najczęściej zmieni jest status na ASSIGNED podczas pracy nad
    nim. Możemy w ten sposób poznać, że nasz bug został zaakceptowany jako
    prawdziwy problem.
  </li>
  <li>
    REOPENED (otwarty ponownie) - Ktoś rozwiązał już buga, ale wydaje nam się,
    że rozwiązanie nie jest właściwe i problem wciąż istnieje. W tym momencie
    możemy otworzyć buga ponownie. Prosimy <b>tego nie nadużywać</b>. Jeśli
    deweloper zamknie buga po raz drugi lub trzeci, najprawdopodobniej
    rzeczywiście bug powinien być zamknięty.
  </li>
  <li>
    RESOLVED (rozwiązany) - Została podjęta decyzja co do buga. Najczęściej
    uzyskuje on również status FIXED (naprawiony), wskazując, że znaleziono
    rozwiązanie. Możliwe są również inne oznaczenia statusu, wkrótce je omówimy
  </li>
  <li>
    VERIFIED (potwierdzony) - Kroki potrzebne do odtworzenia buga są poprawne.
  </li>
  <li>
    CLOSED (zamknięty) - Najczęściej oznacza to koniec życia naszego buga.
    Zostanie on pogrzebany pod nigdy nie kończącą się listą nowych bugów.
  </li>
</ul>

<p>
Wkrótce potem ktoś z deweloperów znajduje błąd w logu strace, naprawia go i
ustawia status buga na RESOLVED FIXED, wspominając, że zmieniło się położenie
plików konfiguracyjnych, a opiekun (czyli ja) uaktualni plik ebuild tak aby
ostrzegał o tym fakcie. Bug jest rozwiązany, a nam wyświetla się poniższy ekran.
</p>

<figure link="/images/docs/bugzie-reso.png" caption="Rozwiązany bug"/>

<p>
Trochę niżej ujrzymy następujące opcje:
</p>

<figure link="/images/docs/bugzie-options.png" caption="Opcje buga"/>

<p>
Daje nam to możliwość ponownego otwarcia buga, jeśli tego chcemy (tzn. jeśli
deweloperowi wydaje się, że błąd został naprawiony, ale nam takie rozwiązanie
nie odpowiada). Nasz bug został poprawiony! Istnieć mogą jednak różne możliwe
rozwiązania. Oto krótka lista:
</p>

<ul>
  <li>
    FIXED - Bug jest poprawiony. Aby naprawić nasz błąd, powinniśmy zastosować
    się do instrukcji.
  </li>
  <li>
    INVALID - Błąd wystąpił z naszej winy, nie zrobiliśmy czegoś zgodnie z
    dokumentacją.
  </li>
  <li>
    DUPLICATE - Nie skorzystaliśmy z niniejszego poradnika i zgłosiliśmy już
    istniejący błąd.
  </li>
  <li>
    WORKSFORME - Deweloper lub osoba, której przydzielony został bug nie jest w
    stanie odtworzyć błędu.
  </li>
  <li>
    CANTFIX - Z jakiegoś powodu problem nie może zostać rozwiązany. Powody
    zostaną podane przez osobę, do której został przypisany bug.
  </li>
  <li>
    WONTFIX - Najczęściej spotykany przy nowych plikach ebuild lub prośbach o
    nową funkcjonalność. Zwykle oznacza to, że deweloper nie chce dodać danej
    opcji, ponieważ nie jest ona potrzebna, istnieje lepsza alternatywa albo po
    prostu nie będzie ona działać. Czasem otrzymamy rozwiązanie naszego
    problemu.
  </li>
  <li>
    UPSTREAM - Bug nie może zostać poprawiony przez deweloperów Gentoo i
    poprosili oni, abyśmy zgłosili go autorom danego programu. Mogą oni mieć
    różne sposoby na zgłaszanie błędów, jak na przykład mailowe listy
    dyskusyjne, kanały irc, a nawet własne systemy takie jak Bugzilla. Jeśli nie
    jesteśmy pewni jak się z nimi skontaktować, wystarczy spytać w komentarzach
    do buga.
  </li>
</ul>

<p>
Czasem zdarzy się, że zanim bug będzie mógł zostać rozwiązany, deweloper poprosi
nas, byśmy przetestowali uaktualniony plik ebuild. W następnym rozdziale
przyjrzymy się testowaniu ebuildów.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Testowanie plików ebuild</title>
<section>
<title>Pobieranie plików</title>
<body>

<p>
Załóżmy, że zgłosiliśmy wcześniejszego buga w sprawie poprawienia kompilacji.
Deweloperzy zorientowali się na czym polega problem i chcą abyśmy przetestowali
plik ebuild aby upewnić się, że prawidłowo rozwiązuje nasz problem:
</p>

<figure link="/images/docs/bugzie-ebuild-request.png" 
caption="Prośba o przetestowanie pliku ebuild"/>

<p>
Użyto tu słów, które mogą sprawić nieco problemów. Po pierwsze, dowiedzmy się co
to jest overlay (nakładka). Jest specjalny katalog taki jak
<path>/usr/portage</path>, z tą różnicą, że gdy wykonamy <c>emerge sync</c>,
pliki w nim nie zostaną skasowane. Specjalnie do tego celu tworzy się katalog
<path>/usr/local/portage</path>. Ustawmy naszą nakładkę na portage w pliku
<path>/etc/make.conf</path>, dopisując w nim tę linijkę pod koniec.
</p>

<pre caption="Ustawianie opcji PORTDIR_OVERLAY">
PORTDIR_OVERLAY="/usr/local/portage"
</pre>

<p>
Musimy teraz stworzyć odpowiednie katalogi, w których umieścimy nasz testowy
plik ebuild. W tym przypadku powinniśmy umieścić go w sys-apps/foobar2. Należy
zwrócić uwagę, że w drugim komentarzu mowa jest o katalogu files, w którym
umieścić należy łatkę. Katalog files zawiera pliki digest (sumy md5 plików z
danej wersji paczki) i pozostałe wymagane pliki, które nie są dołączone do
standardowego archiwum ze źródłami (poprawki, skrypty init.d, itd). Jest to
podkatalog katalogu z paczką. Utwórzmy teraz wszystkie katalogi:
</p>

<pre caption="Tworzenie katalogów kategorii i paczki">
# <i>mkdir -p /usr/local/portage/sys-apps/foobar2/files</i>
</pre>

<note>
Parametr -p do polecenia mkdir spowoduje utworzenie nie tylko docelowego
katalogu, ale także wszystkich brakujących katalogów macierzystych po drodze 
(w tym przypadku sys-apps i foobar2).
</note>

<p>
Teraz możemy pobrać pliki. Po pierwsze ściągnijmy plik ebuild do
<path>/usr/local/portage/sys-apps/foobar2</path> a następnie patch do
<path>/usr/local/portage/sys-apps/foobar2/files</path>. Skoro mamy pliki, możemy
zabrać się do testowania pliku ebuild. 
</p>

</body>
</section>
<section>
<title>Testowanie pliku ebuild</title>
<body>

<p>
Proces tworzenia ebuilda, który będzie mógł zostać użyty w portage jest
dość prosty. Musimy utworzyć plik Manifest oraz pliki digest dla ebuilda.
Dokonamy tego poleceniem ebuild uruchomionym jak poniżej.
</p>

<pre caption="Tworzenie plików Manifest i digest">
# <i>ebuild foobar2-1.0.ebuild digest</i>
&gt;&gt;&gt; Generating digest file...
&lt;&lt;&lt; foobar2-1.0.tar.bz2
&gt;&gt;&gt; Generating manifest file...
&lt;&lt;&lt; foobar2-1.0.ebuild
&lt;&lt;&lt; files/digest-foobar2-1.0
&lt;&lt;&lt; files/foobar2-1.0-Makefile.patch
&gt;&gt;&gt; Computed message digests.
</pre>

<p>
Sprawdźmy teraz czy plik ebuild działa tak jak powinien.
</p>

<pre caption="Testowanie za pomocą polecenia emerge -pv">
# <i>emerge -pv foobar2</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] sys-apps/foobar2-1.0  0 kB [1]

Total size of downloads: 0 kB
Portage overlays:
 [1] /usr/local/portage
</pre>

<p>
Wygląda na to, że działa! Zwróćmy uwagę na oznaczenie [1] w linii zawierającej
[ebuild]. Wskazuje ono na <path>/usr/local/portage</path>, czyli nakładkę, którą
stworzyliśmy wcześniej. Teraz możemy śmiało zainstalować paczkę.
</p>

<pre caption="Wynik instalacji">
# <i>emerge foobar2</i>
 Calculating dependencies ...done!
<comment>(ucięte komunikaty kompilacji)</comment>
>>> Unpacking foobar2-1.0.tar.bz2 to /var/tmp/portage/foobar2-1.0/work
 * Applying foobar2-1.0-Makefile.patch ...                                    [ ok ]
<comment>(ucięte komunikaty kompilacji)</comment>
>>> Merging sys-apps/foobar2-1.0 to /
>>> chris +sandbox(preinst)
--- /usr/
--- /usr/bin/
>>> /usr/bin/foobar2
</pre>

<p>
Na początku widzimy, że emerge działa tak jak do tej pory. Następnie widać, że
nasza łatka nałożyła się poprawnie, o czym informuje nas komunikat "[ ok ]" po
prawej stronie. Na końcu widzimy, że program skompilował się poprawnie. Łatka
działa! Możemy teraz powiadomić dewelopera, że jego łatka działa i może
zamieścić poprawkę błędu w drzewie portage.
</p>

</body>
</section>
<section>
<title>Podsumowanie</title>
<body>

<p>
W ten sposób doszliśmy do końca niniejszego dokumentu o pracy z Bugzillą. Mamy
nadzieję, że był on użyteczny. W razie jakichkolwiek pytań, komentarzy lub
pomysłów do tego dokumentu, prosimy o przesłanie ich pod adres
<mail>chriswhite@gentoo.org</mail>. Specjalne podziękowania należą się moreonowi
za uwagi o flagach -g i błędach kompilacji, ludziom na kanale #gentoo-bugs za
pomoc z usuwaniem bugów, Griffon26 za uwagi na temat maintainer-needed, robbat2
za ogólne sugestie oraz fix2mike'owi za poprawienie niniejszego dokumentu i
dodawanie do niego nowych rzeczy w miarę potrzeb.
</p>

</body>
</section>
</chapter>
</guide>
