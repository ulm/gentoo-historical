<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/udev-guide.xml,v 1.11 2006/04/09 17:04:47 rane Exp $ -->

<guide link="/doc/pl/udev-guide.xml" lang="pl">
<title>Praca z udev w Gentoo</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Współpracownik">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Tłumaczenie">
  <mail link="edi15ta@gazeta.pl">Mateusz Kotyrba</mail>
</author>

<abstract>
Ten dokument wyjaśnia czym jest udev oraz opisuje jak go używać, aby sprostał
naszym wymaganiom.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.23</version>
<date>2006-03-25</date>

<chapter>
<title>Czym jest udev?</title>
<section>
<title>Katalog /dev</title>
<body>

<p>
Kiedy użytkownicy Linuksa rozmawiają o ich sprzęcie w pobliżu ludzi, którzy
wierzą, że Linux jest pewnego rodzaju wirusem lub gatunkiem kawy, użycie słów
"ukośnik dev ukośnik cośtam" spowoduje, że zaczną się oni dziwnie na nich
patrzeć. Ale szczęśliwy użytkownik (i to jesteśmy my) używając
<path>/dev/hda1</path> skrótowo wyjaśnia, że rozmowa tyczy się pierwszej
partycji dysku, który jest podpięty jako primary master. Czy nie mam racji?
</p>

<p>
Wszyscy wiemy czym jest plik urządzenia. Niektórzy nawet wiedzą dlaczego pliki
urządzeń posiadają specjalne numery, które widać wykonując polecenie
<c>ls -l</c> w <path>/dev</path>. Ale zawsze dysk podpięty jako primary master
jest widoczny jako <path>/dev/hda</path>. Można tego nie widzieć w ten sposób,
ale jest to wada projektu.
</p>

<p>
Pomyślmy o urządzeniach podłączanych podczas pracy takich jak USB, IEEE1394,
PCI... Co jest pierwszym urządzeniem? I na jak długo? Jak będą inne urządzenia
nazwane, kiedy to pierwsze zniknie? Jaki to będzie miało wpływ na inne procesy?
Czyż nie byłoby to zabawne gdyby zadanie do drukowania zostało nagle
przeniesione z naszej nowiutkiej drukarki laserowej do naszej zrupieciałej
drukarki mozaikowej, ponieważ mama zdecydowała się wyciągnąć wtyczkę drukarki
laserowej, która była pierwszą drukarką, z kontaktu?
</p>

<p>
Wchodzimy do <e>udev</e>. Główne cele projektu udev są zarówno ciekawe jak i
konieczne:
</p>

<ul>
  <li>Działa w przestrzeni użytkownika</li>
  <li>Dynamicznie tworzy lub usuwa pliki urządzeń</li>
  <li>Dostarcza spójne nazewnictwo</li>
  <li>Dostarcza interfejsu API przestrzeni użytkownika</li>
</ul>

<p>
Aby dostarczyć te cechy, udev jest rozwijany w trzech odrębnych projektach:
<e>namedev</e>, <e>libsysfs</e> oraz <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev pozwala zdefiniować odrębne nazewnictwo niż to w udev. To pozwala na
elastyczne polityki i schematy nazewnictwa rozwijane przez odrębne jednostki.
Ten podsystem nazewnictwa urządzeń dostarcza standardowego interfejsu, którego
może używać udev.
</p>

<p>
Obecnie namedev dostarcza tylko jeden schemat nazewnictwa - LANANA, który jest
używany przez większość obecnych systemów Linuksowych, a zatem pasuje on
większości użytkowników Linuksa.
</p>

<p>
Namedev używa pięciostopniowej procedury pozyskiwania nazwy urządzenia. Jeśli
nazwa urządzenia zostanie znaleziona w tych pięciu krokach, wtedy zostanie ona
użyta. Są nimi:
</p>

<ul>
  <li>etykieta lub numer seryjny</li>
  <li>numer urządzenia magistrali</li>
  <li>topologia magistrali</li>
  <li>statycznie przydzielana nazwa</li>
  <li>nazwa dostarczona przez jądro</li>
</ul>

<p>
Krok <e>etykieta lub numer seryjny</e> sprawdza czy urządzenie posiada
jednoznaczny identyfikator. Na przykład urządzenia USB posiadają unikalny numer
seryjny, urządzenia SCSI posiadają unikalny UUID. Jeśli namedev znajdzie
odpowiednią nazwę wtedy zostanie ona użyta.
</p>

<p>
Krok <e>numer urządzenia magistrali</e> sprawdza numer urządzenia magistrali.
Dla systemów, które nie mają możliwości podłączania urządzeń w trakcie pracy,
ten krok jest wystarczający.  Ponieważ numery magistrali bardzo rzadko są
zmieniane. Ponownie jeśli namedev znajdzie odpowiednią nazwę wtedy zostanie ona
użyta. 
</p>

<p>
Podobnie krok <e>topologia magistrali</e> jest statycznym sposobem
przydzielania nazw, pod warunkiem, że użytkownik nie zamieni urządzeń. Jeśli
pozycja urządzenia będzie zgodna z tym co podał użytkownik, wtedy towarzysząca
temu nazwa zostanie użyta.
</p>

<p>
Krok czwarty, <e>statycznie przydzielana nazwa</e>, jest prostym zastępowaniem
ciągów znaków. Kiedy nazwa dostarczona przez jądro (domyślna nazwa) pasuje do
danego ciągu znaków, wtedy ten ciąg zostanie zastąpiony.
</p>

<p>
Ostatnim krokiem (<e>nazwa dostarczona przez jądro</e>) jest nadanie wszystkim
urządzeniom domyślnej nazwy dostarczonej wraz z jądrem. Większości systemów
Linuksowych ten krok jest wystarczający.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev komunikuje się z jądrem poprzez pseudo system plików sysfs. Projekt
libsysfs dostarcza interfejsu API, który zezwala na dostęp do informacji danych
przez system plików sysfs. To pozwala na sprawdzenie całego sprzętu bez
konieczności posiadania wiedzy jakiego typu sprzęt jest sprawdzany.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Za każdym razem kiedy jądro zauważy zmianę w drzewie urządzeń, przywołuje ono
program <path>/sbin/hotplug</path>. Hotplug uruchamia aplikacje dowiązane w
katalogu <path>/etc/hotplug.d/default</path>, w którym to znajdziemy również
dowiązanie symboliczne do aplikacji udev. Hotplug przekierowuje informacje
dane przez jądro do aplikacji udev, która wykona wymagane czyności na strukturze
<path>/dev</path> (tworząc lub usuwając pliki urządzeń).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Praca z udev w Gentoo</title>
<section>
<title>Wymagania</title>
<body>

<p>
udev został stworzony do pracy wraz jądrem 2.6 (na przykład
<c>vanilla-sources</c> lub <c>gentoo-sources</c> w domyślnym profilu 2005.0).
Jeśli używamy takiego jądra, wtedy należy się upewnić, że posiadamy najnowszą
wersję pakietu <c>sys-apps/baselayout</c>.
</p>

<pre caption="Instalacja udev">
# <i>emerge udev</i>
</pre>

<p>
udev, jako jedną ze swoich zależności, zainstaluje <c>hotplug-base</c>.
Instalacja <c>hotplug</c> nie jest wymagana dopóki nie będziemy chcieli mieć
automatycznie ładowanych modułów po podpięciu dowolnego urządzenia.
<c>hotplug</c> zarządza również zautomatyzowanym uruchamianiem urządzeń
sieciowych oraz ściąganiem oprogramowania sieciowego.
</p>

<pre caption="Opcjonalna instalacja skryptów hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Jeśli chcielibyśmy automatycznie załadować moduły dla urządzeń, które
podłączyliśmy przed uruchomieniem komputera, wtedy należy użyć pakietu coldplug:
</p>

<pre caption="Instalacja pakietu coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Nie należy zapomnieć o dodaniu <c>coldplug</c> do poziomu uruchamiania o nazwie
"boot":
</p>

<pre caption="Dodawanie coldplug do poziomu uruchamiania o nazwie boot">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Użytkownicy korzystający z ręcznie skompilowanego jądra muszą włączyć
następujące opcje:
</p>

<pre caption="Wymagane opcje jądra">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Opcję <c>/dev file system support (OBSOLETE)</c> można zostawić włączoną, przy
czym opcja "Automatically mount at boot" musi być wyłączona:
</p>

<pre caption="Nie należy montować automatycznie devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Użytkownicy <c>genkernela</c>, muszą uruchomić ten skrypt z flagą <c>--udev</c>,
aby włączyć wszystkie instrukcje konfigurujące jądro. Jednak domyślna
konfiguracja wykonana przez samo polecenie <c>genkernel</c> również wystarczy do
prawidłowego uruchomienia systemu.
</p>

</body>
</section>
<section>
<title>Konfiguracja</title>
<body>

<p>
Jeśli chcemy, aby poprawki dodane przez deweloperów Gentoo ułatwiły nam życie
wtedy należy ominąć ten rozdział. Gentoo będzie używał udev, ale katalog 
<path>/dev</path> będzie statyczny, żebyśmy nigdy nie doświadczyli braku
jakiegokolwiek węzła urządzenia. W tym wariancie skrypty Gentoo nie uruchomią
demona devfs i zdezaktywują devfs podczas uruchamiania systemu.
</p>

<p>
Jeśli jesteśmy twardzi i chcemy, aby nasz system używał tylko i wyłącznie udev
(mogą pojawić się brakujące węzły urządzeń spowodowane przez brak wsparcia ze
strony udev), wtedy należy czytać dalej.
</p>
<p>
Zdezaktywujemy reguły, które zachowują węzły urządzeń do pliku: edytujemy
zmienną <c>RC_DEVICE_TARBALL</c> w <path>/etc/conf.d/rc</path> i ustawiamy ją na
<c>no</c>: </p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Jeśli włączyliśmy w jądrze wsparcie dla devfs, możemy je wyłączyć dopisując do
parametrów jądra w pliku konfiguracyjnym bootloadera: <c>gentoo=nodevfs</c>.
Jeśli chcemy używać devfs i zdezaktywować udev, wtedy jako parametr jądra
dodajemy <c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Znane problemy</title>
<section>
<title>Brakujące pliki węzła urządzenia podczas ładowania systemu</title>
<body>

<p>
Jeśli nie potrafimy pomyślnie zakończyć procesu uruchamiania systemu ponieważ
wyskakuje nam błąd o nie znalezieniu <path>/dev/null</path> lub ponieważ brakuje
konsoli startowej, wtedy problemem jest brak pewnych plików urządzeń, które
musza być dostępne <e>przed</e> zamontowaniem katalogu <path>/dev</path>.
</p>

<p>
Jeśli posiadamy <c>sys-apps/baselayout-1.8.12</c> lub nowszy, wtedy ten problem
jest złagodzony ponieważ proces uruchamiania systemu powinien zakończyć się
powodzeniem. Jednakże, aby pozbyć się tych denerwujących ostrzeżeń, należy
stworzyć brakujące węzły urządzeń tak jak jest to przedstawione poniżej.
</p>

<p>
Aby sprawdzić które węzły urządzeń są obecne przed zamontowaniem
katalogu <path>/dev</path> należy wykonać następujące polecenia:
</p>

<pre caption="Wyświetlanie węzłów urządzeń dostępnych podczas uruchamiania systemu">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Urządzenia wymagane do pomyślnego załadowania systemu są umieszczone w
<path>/dev/null</path> oraz w <path>/dev/console</path>. Jeśli się nie pojawiły,
to należy je stworzyć ręcznie. Będąc w katalogu <path>test/dev/</path> należy
wykonać:
</p>

<pre caption="Tworzenie wymaganych plików węzłów urządzeń">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Kiedy skończymy nie należy zapomnieć o odmontowaniu katalogu <path>test/</path>:
</p>

<pre caption="Odmontowywanie katalogu test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev i nVidia</title>
<body>

<p>
Jeśli używamy odpowiednich sterowników nVidii, ale serwer X nie uruchamia się,
wtedy należy upewnić się, że mamy:
</p>

<ul>
  <li>
    moduł <c>nvidia</c> w <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    wersję <c>nvidia-kernel</c> równą lub wyższą
    <c>media-video/nvidia-kernel-1.0.5336-r2</c> </li>
  <li>
    wersję baselayout równą lub wyższą <c>sys-apps/baselayout-1.8.12</c>
    </li> 
 </ul>

<p>
Jeśli <c>xorg-x11</c> nie chce się uruchomić, może to być spowodowane tym, że
nie istnieje plik urządzenia <path>/dev/nvidia</path>. W takim wypadku należy
uruchomić program <path>/sbin/NVmakedevices.sh</path>, który go stworzy na
nowo.
</p>

</body>
</section>
<section>
<title>Nazwy LVM2 znikają</title>
<body>

<p>
Jeśli używamy razem <c>udev</c> i LVM2, wtedy można zauważyć, że grupy oraz
woluminy logiczne zniknęły. W rzeczywistości jest to nieprawdą gdyż są one
nazwane <path>/dev/dm-#</path> gdzie #=0,1,...
</p>

<p>
Aby to naprawić, należy edytować <path>/etc/udev/rules.d/50-udev.rules</path> i
odkomentować następującą linię:
</p>

<pre caption="Odkomentowujemy linię w /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k",
SYMLINK="%c"
</pre>

<p>
Następnie należy zainstalować <c>sys-fs/multipath-tools</c>, który zawiera
aplikację <c>devmap_name</c>.
</p>

<pre caption="Instalacja multipath-tools">
<comment>(W chwili obecnej multipath-tools są zamaskowane :)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt;
/etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>Spójne nazewnictwo pomiędzy DevFS a udev</title>
<body>

<p>
Pomimo naszych starań, aby posiadać spójne nazewnictwo pomiędzy tymi dwoma
dynamicznymi sposobami nazewnictwa urządzeń, czasami pewne różnice w nazwach
występują. 
</p>

<p>
Jednym ze zgłoszonych błędów jest kolizja z kontrolerem HP Smart Array 5i RAID
(a dokładniej modułem jądra <c>cciss</c>). W udev, urządzenia są nazywane
<path>/dev/cciss/cXdYpZ</path> gdzie X, Y i Z są normalnymi liczbami. W devfs
urządzeniami są <path>/dev/hostX/targetY/partZ</path> lub dowiązane symbolicznie
z <path>/dev/cciss/cXdY</path>.
</p>

<p>
W tym przypadku należy pamiętać o zaktualizowaniu pliku <path>/etc/fstab</path>
oraz o konfiguracji plików bootloadera
</p>

<p>
To samo zdarza się The same happens with all-round symlinks that used to exist w
katalogu <path>/dev</path>, takie jak <path>/dev/mouse</path>, których
<c>udev</c> już nie tworzy. Należy się upewnić, że w pliku konfiguracyjnym X-ów
posiadamy odpowiednie ustawienia.
</p>

<p>
Kolejny problemem jest różnica w nazwach terminali pomiędzy devfs i udev.
Terminale w devfs nazywają się <c>tty</c>, a w udev <c>vc</c>. Może to
przysporzyć kłopotu, gdy ogranicza się dostęp do konsoli za pomocą pliku
<path>/etc/securetty</path>. Należy zmienić wpis <c>tty1</c> na <c>vc/1</c> w
pliku <path>/etc/securetty</path>, aby root mógł logować się w konsoli.
</p>

</body>
</section>
<section>
<title>Inne problemy</title>
<body>

<p>
Jeśli węzły urządzeń nie są tworzone podczas ładowania modułu z
<path>/etc/modules.autoload.d/kernel-2.6</path>, ale są tworzone jeśli
załadujemy moduł ręcznie, wtedy powinniśmy spróbować zaktualizować pakiet
baselayout do wersji <c>sys-apps/baselayout-1.8.12</c> lub późniejszej.
</p>

<p>
Wsparcie dla urządzeń bufora ramki (<path>/dev/fb/*</path>) jest w jądrze
2.6.6-rc2 i powyżej.
</p>

<p>
W jądrach starszych od 2.6.4 należy włączyć wsparcie dla systemu plików
<path>/dev/pts</path>.
</p>

<pre caption="Włączanie systemu plików /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Zasoby i podziękowania</title>
<section>
<body>

<p>
Wykład o udev na Linux Symposium (Ottawa, Ontario Canada - 2003) prowadzony
przez Greg Kroah-Hartman (IBM Corporation) dostarczył solidnego zrozumienia
systemu udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">
Decibel's UDEV Primer</uri> jest wyczerpującym źródłem o udev i Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri>
stworzony przez dewelopera Gentoo Daniela Drake jest doskonałym przykładem
dostosowywania systemu udev do własnych potrzeb.
</p>

</body>
</section>
</chapter>

</guide>
