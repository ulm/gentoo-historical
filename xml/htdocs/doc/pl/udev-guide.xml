<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/udev-guide.xml,v 1.7 2005/09/29 01:42:32 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/udev-guide.xml" lang="pl">
<title>Praca z udev w Gentoo</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Współpracownik">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Tłumacz">
  Roman Frołow
</author>

<abstract>
Ten dokument wyjaśnia czym jest udev i jak z niego korzystać.
</abstract>

<license/>

<version>0.21</version>
<date>2005-08-12</date>

<chapter>
<title>Czym jest udev?</title>
<section>
<title>Katalog /dev</title>
<body>

<p>
Kiedy użytkownicy Linuksa mówią o sprzęcie w systemie w otoczeniu ludzi, którzy
wierzą, że Linux jest rodzajem wirusa lub gatunkiem kawy, użycie słów "ukośnik
dev ukośnik coś" zwróci na nas dziwne spojrzenia. Ale dla szczęśliwego
użytkownika Linuksa, użycie <path>/dev/hda1</path> jest po prostu szybkim
sposobem wyjaśnienia, że mówimy o pierwszym slocie IDE z ustawieniem master i
pierwszej partycji. A może nie?
</p>

<p>
Wszyscy wiemy czym jest plik urządzenia. Niektórzy wiedzą nawet czemu pliki
urządzeń mają specjalne numery, kiedy przyjrzymy im się bliżej po wydaniu
polecenia <c>ls -l</c> w <path>/dev</path>. Jedno jest pewne, że dysk na
pierwszym slocie IDE ustawiony na master odnosi się do <path>/dev/hda</path>.
Nie można go zobaczyć w ten sposób, ale to wada powstała na etapie
projektowania.
</p>

<p>
Pomyślmy o wymienialnych podczas pracy urządzeniach takich jak USB, IEEE1394,
wymienialnych podczas pracy kartach PCI... Które jest pierwszym urządzeniem? I
na jak długo? Jak inne urządzenia zostaną nazwane, kiedy pierwsze zniknie? Jak
to wpłynie na będące w toku operacje? Czyż nie byłoby fajnie, gdyby zadanie
drukowania zostało nagle przeniesione z naszej super nowej drukarki laserowej do
prawie martwej drukarki igłowej, ponieważ mama zdecydowała wyciągnąć wtyczkę z
drukarki laserowej, co uczyniło drukarkę igłową pierwszą drukarką?
</p>

<p>
Wchodzimy do <e>udev</e>. Cele projektu udev są zarówno interesujące jak i
potrzebne:
</p>

<ul>
  <li>Działanie w przestrzeni użykownika</li>
  <li>Dynamiczne tworzenie/usuwanie plików urządzeń</li>
  <li>Udostępnienie spójnego nazewnictwa</li>
  <li>Udostępnienie Programistycznego Interfejsu Aplikacji (API)</li>
</ul>

<p>
Aby zapewnić te cechy, udev jest rozwijany w trzech oddzielnych projektach:
<e>namedev</e>, <e>libsysfs</e> i oczywiście <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev umożliwia nam zdefiniowanie nazewnictwa urządzeń oddzielnie od programu
udev. To pozwala na elastyczne schematy i politykę nazewnictwa rozwijane przez
oddzielne jednostki. Ten podsystem nazewnictwa urządzeń udostępnia standardowy
interfejs, który udev może używać.
</p>

<p>
Obecnie tylko pojedynczy schemat nazewnictwa został dostarczony przez namedev;
został on dostarczony przez LANANA, obecnie używany jest przez większość
dystrybucji systemu Linux i dlatego jest on odpowiedni dla większości
użytkowników Linuksa.
</p>

<p>
Namedev stosuje 5-stopniową procedurę do dowiedzenia się nazwy danego
urządzenia. Jeśli nazwa urządzenia jest poznana w jednym z podanych kroków, to
zostaje użyta. Te kroki to:
</p>

<ul>
  <li>etykieta lub numer seryjny</li>
  <li>numer urządzenia magistrali</li>
  <li>topologia magistrali</li>
  <li>statycznie przydzielana nazwa</li>
  <li>nazwa udostępniona przez jądro</li>
</ul>

<p>
Krok <e>etykieta lub numer seryjny</e> sprawdza, czy urządzenie posiada
unikalny identyfikator. Na przykład urządzenia USB posiadają unikalny numer
seryjny USB; urządzenia SCSI posiadają unikalny UUID. Jeśli namedev dopasuje
ten unikalny numer z danym plikiem konfiguracyjnym, używana jest nazwa
dostarczona w pliku konfiguracyjnym.
</p>

<p>
Krok <e>numer urządzenia magistrali</e> sprawdza numer urządzenia magistrali.
Ta procedura jest wystarczająca dla nie-wyjmowalnych-podczas-pracy środowisk do
zidentyfikowania urządzenia sprzętowego. Ponownie, jeśli namedev dopasuje ten
unikalny numer do danego pliku konfiguracyjnego, wtedy zostanie użyta nazwa
dostarczona w pliku konfiguracyjnym.
</p>

<p>
Podobnie <e>topologia magistrali</e> jest raczej statycznym sposobem określania
urządzeń do czasu, gdy użytkownik nie zamieni ich miejscami. Gdy pozycja
urządzenia odpowiada danemu ustawieniu dostarczonemu przez użytkownika, wtedy
użyta zostaje załączona nazwa.
</p>

<p>
Czwarty krok, <e>statycznie dana nazwa</e>, jest prostą zamianą napisów. Kiedy
nazwa jądra (domyślna nazwa) odpowiada danemu zamieniającemu napisowi, zostanie
użyta nazwa zastępcza.
</p>

<p>
Końcowy krok (<e>nazwa udostępniona przez jądro</e>) jest używany kompleksowo:
bierze domyślną nazwę udostępnioną przez jądro. W większości przypadków jest to
wystarczające, jako że dopasowuje do nazewnictwa urządzeń używanego na
aktualnych systemach Linux.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev i jądro współdziałają przez pseudo system plików sysfs. Projekt libsysfs
udostępnia standardowe API, aby uzyskiwać informacje dane przez system plików
sysfs w typowy sposób. To umożliwia odpytywanie wszystkich rodzajów urządzeń
bez robienia przypuszczeń co do rodzaju sprzętu.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Za każdym razem, gdy jądro zauważa uaktualnienie w strukturze urządzeń,
wywołuje program <path>/sbin/hotplug</path>. Hotplug uruchamia aplikacje,
których dowiązania znajdują się w katalogu <path>/etc/hotplug.d/default</path>,
gdzie znajdziemy również dowiązanie symboliczne do aplikacji udev. Hotplug
kieruje informację otrzymaną od jądra do aplikacji udev, która wykonuje
niezbędne operacje na strukturze <path>/dev</path> (tworzenie lub usuwanie
plików urządzeń).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Używanie udev w Gentoo</title>
<section>
<title>Wymagania</title>
<body>

<p>
udev jest przeznaczony do użycia w połączeniu z jądrem 2.6 (takim jak
<c>vanilla-sources</c> lub <c>gentoo-sources</c>). Jeśli używamy
takiego jądra, wtedy należy się upewnić, że posiadamy najnowszą wersję pakietu
<c>sys-apps/baselayout</c>. To wszystko czego potrzebujemy.
</p>

<pre caption="Instalacja udev">
# <i>emerge udev</i>
</pre>

<p>
udev zainstaluje <c>hotplug-base</c> jako jedną ze swoich zależności.  Nie
musimy instalować <c>hotplug</c>, chyba że chcemy, aby moduły były automatycznie
ładowane po podłączeniu urządzenia. <c>hotplug</c> obsługuje również
zautomatyzowane przywracenie urządzeń sieciowych i pobieranie sterowników
firmware.
</p>

<pre caption="Instalacja dodatkowych skryptów hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Jeśli chcemy, aby moduły do podłączonych urządzeń były ładowane przed
uruchomieniem systemu, to należy użyć pakietu coldplug:
</p>

<pre caption="Instalacja pakietu coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Warto pamiętać o dodaniu skryptu startowego <c>coldplug</c> do poziomu
uruchomieniowego o nazwie "boot".
</p>

<pre caption="Dodawanie coldplug na poziom boot">
# <i>rc-update add coldplug boot</i>
</pre>


<p>
Co do jądra, jeśli używamy domyślnych ustawień programu <c>genkernel</c> to
wszystko jest już ustawione. W innym przypadku należy upewnić się, aby uaktywnić
następujące opcje:
</p>

<pre caption="Wymagane opcje jądra">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Możemy zostawić <c>/dev file system support (OBSOLETE)</c> włączone jeśli
chcemy, ale należy się upewnić, że "Automatically mount at boot" jest
wyłączone:
</p>

<pre caption="Wyłączanie automatycznego montowania devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

</body>
</section>
<section>
<title>Konfiguracja</title>
<body>

<p>
Jeśli chcemy użyć podkręceń do udev, które dodaje Gentoo, aby uczynić nasze
życie bardziej komfortowym, to nie należy czytać dalej tego dokumentu. Gentoo
używa udev, ale zatrzymuje statyczne <path>/dev</path>, tak, że nigdy nie
będziemy mieli żadnych brakujących węzłów urządzeń. Skrypty startowe Gentoo nie
uruchomią demona devfsd i wyłączą devfs, podczas uruchamiania systemu.
</p>

<p>
Ale jeśli jesteśmy konserwatywni i chcemy uruchamiać system oparty tylko na
udev, nie podkręcony system (włączając kłopoty z brakującymi węzłami urządzeń,
których udev jeszcze nie wspiera), z całą pewnością należy czytać dalej :).
</p>


<p>
Wyłączymy reguły, które zapisują węzły plików urządzeń: edytujemy zmienną
<c>RC_DEVICE_TARBALL</c> w <path>/etc/conf.d/rc</path> i ustawiamy ją na
<c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Jeśli włączyliśmy wsparcie dla devfs w jądrze, to możemy je wyłączyć w
konfiguracji programu rozruchowego: dodajemy <c>gentoo=nodevfs</c> jako parametr
jądra. Jeśli chcemy używać devfs i wyłączyć udev, dodajemy <c>gentoo=noudev</c>
jako parametr jądra.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Znane problemy</title>
<section>
<title>Brakujące pliki węzłów urządzeń podczas ładowania systemu</title>
<body>

<p>
Jeśli nie możemy pomyślnie uruchomić systemu, ponieważ otrzymujemy błąd
związany z brakiem <path>/dev/null</path> lub konsoli, to problemem jest brak
pewnych plików urządzeń, które muszą być dostępne <e>przed</e> tym jak
<path>/dev</path> jest montowany i obsługiwany przez udev. To jest typowe dla
maszyn Gentoo zainstalowanych na starych nośnikach.
</p>

<p>
Jeśli używamy pakietu <c>sys-apps/baselayout</c> w wersji 1.8.12 lub nowszej, to
ten problem jest złagodzony, ponieważ proces ładowania systemu powinien nadal
być doprowadzany do końca. Jakkolwiek, aby pozbyć się tych denerwujących
ostrzeżeń, powinniśmy utworzyć brakujące węzły urządzeń, tak, jak to opisano
poniżej.
</p>

<p>
Aby zobaczyć, które węzły urządzeń są obecne przed zamontowaniem systemu plików
<path>/dev</path>, używamy następujących poleceń:
</p>

<pre caption="Wyświetlanie węzłów urządzeń dostępnych przy uruchomieniu">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Urządzenia wymagane do pomyślnego załadowania systemu to <path>/dev/null</path>
i <path>/dev/console</path>. Jeśli nie pojawią się one w poprzednim teście,
musimy stworzyć je ręcznie. Wydajemy następujące polecenia w katalogu
<path>test/dev/</path>:
</p>

<pre caption="Tworzenie niezbędnych plików węzłów urządzeń">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Kiedy skończymy, należy pamiętać o odmontowaniu katalogu <path>test/</path>:
</p>

<pre caption="Odmontowywanie katalogu test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev i nvidia</title>
<body>

<p>
Jeśli używamy sterownika od nVidii, a X serwer nie uruchamia się na systemie
zawierającym tylko udev, należy się upewnić, że mamy:
</p>

<ul>
  <li>
    moduł <c>nvidia</c> wykazany w
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    wersję pakietu <c>nvidia-kernel</c> większą lub równą
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    wersję pakietu baselayout większą lub równą 
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>


</body>
</section>
<section>
<title>Znikające Nazwy LVM2</title>
<body>

<p>
Korzystając z <c>udev</c> i LVM2 jednocześnie, można zauważyć, że stworzone
przez nas grupy wolumenów i logiczne wolumeny zniknęły. Cóż, one nie zniknęły,
ale są na nieszczęście przemianowane na <path>/dev/dm-#</path> gdzie zamiast #
są 0, 1, ...
</p>

<p>
Aby to naprawić, edytujemy <path>/etc/udev/rules.d/50-udev.rules</path> i
odkomentowujemy następującą linię:
</p>

<pre caption="Należy odkomentować tę linię z /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
Następnie należy zainstalować pakiet <c>sys-fs/multipath-tools</c>, który
zawiera aplikację <c>devmap_name</c>.
</p>
  
<pre caption="Instalowane multipath-tools">
<comment>(W chwili pisania tego tekstu pakiet ten był dostępny tylko w gałęzi testowej)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>Brak konsekwentnego nazewnictwa pomiędzy DevFS a udev</title>
<body>

<p>
Chociaż naszym zamiarem jest mieć konsekwentny schemat nazewnictwa pomiędzy
obydwoma rozwiązaniami dynamicznego zarządzania urządzeniami, czasami pojawiają
się różnice w nazewnictwie. Jedna ze zgłoszonych kolizji dotyczy kontrolera
RAID HP Smart Array 5i (bardziej precyzyjnie modułu jądra <c>cciss</c>). udev
nazywa urządzenia <path>/dev/cciss/cXdYpZ</path>, gdzie X, Y i Z są zwykłymi
numerami. devfs nazywa je <path>/dev/hostX/targetY/partZ</path> lub dowiązuje
symbolicznie z <path>/dev/cciss/cXdY</path>.
</p>

<p>
Jeśli to jest ten przypadek, należy nie zapomnieć uaktualnić
<path>/etc/fstab</path> i odpowiednich plików konfiguracyjnych programu
rozruchowego.
</p>

</body>
</section>
<section>
<title>Inne problemy</title>
<body>

<p>
Jeśli węzły urządzeń nie są tworzone, podczas ładowania modułu z
<path>/etc/modules.autoload.d/kernel-2.6</path>, ale pojawiają się, po
załadowaniu modułu ręcznie przez modprobe, wtedy powinniśmy uaktualnić pakiet
baselayout do <c>sys-apps/baselayout-1.8.12</c> lub nowszego.
</p>

<p>
Wsparcie dla urządzeń bufora ramki (<path>/dev/fb/*</path>) jest oferowane
przez jądra od wersji 2.6.6-rc2.
</p>

<p>
Dla jąder starszych niż 2.6.4 należy włączyć wsparcie dla systemu plików
<path>/dev/pts</path>.
</p>

<pre caption="Włączanie systemu plików /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Zasoby i Podziękowania</title>
<section>
<body>

<p>
Rozmowa dotycząca udev na Linux Symposium (Ottawa, Ontario Canada - 2003)
udostępniona przez Grega Kroah-Hartmana (IBM Corporation) pomogła porządnie
zrozumieć aplikację udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's
UDEV Primer</uri> jest dogłębnym dokumentem dotyczącym udev i Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri>
kumpla i konstruktora Gentoo Daniela Drake jest doskonałym dokumentem do nauki
jak dopasować instalację udev.
</p>

</body>
</section>
</chapter>

</guide>
