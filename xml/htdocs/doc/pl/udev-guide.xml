<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/udev-guide.xml,v 1.1 2004/11/25 14:06:40 neysx Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/udev-guide.xml" lang="pl">
<title>Przewodnik po Gentoo udev</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Współpracownik">
  <mail link="g.guidi@sns.it">Gregorio Guidi</mail>
</author>
<author title="Tłumacz">
  <mail link="rofrol@gmail.com">Roman Frołow</mail>
</author>

<abstract>
Ten dokument wyjaśnia, czym jest udev i jak używać udev, aby spełniał twoje
wymagania.
</abstract>

<license/>

<version>0.16</version>
<date>2004-10-20</date>

<chapter>
<title>Czym jest udev?</title>
<section>
<title>Katalog /dev</title>
<body>

<p>
Kiedy użytkownicy Linuksa mówią o sprzęcie w swoim systemie w otoczeniu ludzi,
którzy wierzą, że Linux jest rodzajem wirusa lub marką kawy, użycie słów
"ukośnik dev ukośnik coś" zwróci na nas dziwne spojrzenia. Ale dla szczęśliwego
użytkownika (i to dotyczy Ciebie), użycie <path>/dev/hda1</path> jest po prostu
szybkim sposobem wyjaśnienia, że mówimy o pierwszym slocie IDE z ustawieniem
master i pierwszej partycji. A może nie?
</p>

<p>
Wszyscy wiemy czym jest plik urządzenia. Niektórzy wiedzą nawet czemu pliki
urządzeń mają specjalne numery, kiedy przyjrzymy im się bliżej po wydaniu
polecenia <c>ls -l</c> w <path>/dev</path>. Jedno jest pewne, że dysk na
pierwszym slocie IDE ustawiony na master odnosi się do <path>/dev/hda</path>.
Nie możesz go zobaczyć w ten sposób ale to wada powstała na etapie
projektowania.
</p>

<p>
Pomyśl o wymienialnych podczas pracy urządzeniach takich jak USB, IEEE1394,
wymienialnych podczas pracy kartach PCI... Które jest pierwszym urządzeniem? I
na jak długo? Jak inne urządzenia zostaną nazwane, kiedy pierwsze zniknie? Jak
to wpłynie na będące w toku operacje? Czyż nie byłoby fajnie, gdyby zadanie
drukowania zostało nagle przeniesione z twojej super nowej drukarki laserowej
do twojej prawie marwtej drukarki igłowej ponieważ twoja mama zdecydowała
wyciągnąć wtyczkę drukarki laserowej co uczyniło drukarkę igłową pierwszą
drukarką?
</p>

<p>
Wchodzimy do  <e>udev</e>. TCele projektu udev są zarówno interesujące jak i
potrzebne:
</p>

<ul>
  <li>Działanie w przestrzeni użykownika</li>
  <li>Dynamiczne tworzenie/usuwanie plików urządzeń</li>
  <li>Udostępnienie spójnego nazewnictwa</li>
  <li>Udostępnienie Programistycznego Interfejsu Aplikacji (API)</li>
</ul>

<p>
Aby zapewnić te cechy, udev jest rozwijany w trzech odzielnych projektach:
<e>namedev</e>, <e>libsysfs</e> i oczywiście <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev umożliwia Ci zdefiniowanie nazewnictwa urządzeń oddzielnie od programu
udev. To daje elastyczne polityki i schematy nazewnictwa rozwijane przez
oddzielne jednostki. Ten podsystem nazewnictwa urządzeń udostępnia standardowy
interfejs, który udev może używać.
</p>

<p>
Aktualnie tylko pojedynczy schemat jest udostepniany przez namedev; ten
udostępniony przez LANANA, używany przez większość systemów Linux obecnie i
dlatego bardzo odpowiedni dla większości użytkowników Linuksa.
</p>

<p>
Namedev stosuje 5-stopniową procedurę do dowiedzenia się nazwy danego
urządzenia. Jeśli nazwa urządzenia jest poznana w jednym z podanych kroków, to
zostaje użyta. Te kroki to:
</p>

<ul>
  <li>etykieta lub numer seryjny</li>
  <li>numer urządzenia magistrali</li>
  <li>topologia magistrali</li>
  <li>statycznie przydzielana nazwa</li>
  <li>nazwa udostępniona przez jądro</li>
</ul>

<p>
Krok <e>etykieta lub numer seryjny</e> sprawdza, czy urządzenie posiada
unikalny identyfikator. Na przykład urządzenia USB posiadają unikalny numer
seryjny USB; urządzenia SCSI posiadają unikalny UUID. Jeśli namedev dopasuje
ten unikalny numer z danym plikiem konfiguracyjnym, używana jest nazwa
udostępniona w pliku konfiguracyjnym.
</p>

<p>
Krok <e>numer urządzenia magistrali</e> sprawdza numer urządzenia magistrali.
Ta procedura jest wystarczająca dla nie-wyjmowalnych-podczas-pracy środowisk do
zidentyfikowania urządzenia sprzętowego. Ponownie, jeśli namedev dopasuje tą
pozycję do danego pliku konfiguracyjnego, zostanie użyta nazwa udostepniona w
tym pliku.
</p>

<p>
Podobnie <e>topologia magistrali</e> jest raczej statycznym sposobem określania
urządzeń do czasu, gdy użytkownik nie zamieni ich miejscami. Gdy pozycja
urządzenia odpowiada danemu ustawieniu udostępnionemu przez użytkownika, użyta
zostaje załączona nazwa.
</p>

<p>
Czwarty krok, <e>statycznie dana nazwa</e>, jest prostą zamianą napisów. Kiedy
nazwa jądra (domyślna nazwa) odpowiada danemu zamieniającemu napisowi, zostanie
użyta nazwa zastępcza.
</p>

<p>
Końcowy krok (<e>nazwa udostępniona przez jądro</e>) jest używany kompleksowo:
bierze domyślną nazwę udostępnioną przez jądro. W większości przypadków jest to
wystarczające, jako że dopasowuje do nazewnictwa urządzeń używanego na
aktualnych systemach Linux.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev i jądro współdziałają przez pseudo system plików sysfs. Projekt libsysfs
udostępnia standardwe API, aby uzyskiwać informacje dane przez system plików
sysfs w typowy sposób. To umożliwia odpytywanie wszystkich rodzajów urządzeń
bez robienia przypuszczeń co do rodzaju sprzętu.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Za każdym razem, gdy jądro zauważa uaktualnienie w strukturze urządzeń,
wywołuje program <path>/sbin/hotplug</path>. Hotplug uruchamia aplikacje,
których dowiązania znajdują się w katalogu <path>/etc/hotplug.d/default</path>,
gdzie znajdziesz również dowiązanie symboliczne do aplikacji udev. Hotplug
kieruje informację otrzymaną od jądra do aplikacji udev, która wykonuje
niezbędne operacje na strukturze <path>/dev</path> (tworzenie lub usuwanie
plików urządzeń).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Używanie udev w Gentoo</title>
<section>
<title>Wymagania</title>
<body>

<p>
udev jest przeznaczony do użycia w połączeniu z jądrem 2.6 (takim jak
<c>development-sources</c> lub <c>gentoo-dev-sources</c>). Jeśli używasz
takiego jądra, wtedy po prostu upewnij się, że masz ostatnią wersję
<c>sys-apps/baselayout</c>. To wszystko czego potrzebujesz.
</p>

<pre caption="Instalacja udev">
# <i>emerge udev</i>
</pre>

<p>
udev zainstaluje <c>hotplug-base</c> jako jedną ze swoich zależności.  Nie
musisz instalować <c>hotplug</c>, chyba że chcesz aby twoje moduły były
automatycznie ładowane kiedy podłączasz urządzenia. <c>hotplug</c> obsługuje
również zautomatyzowane przywracenie urządzeń sieciowych i pobieranie
sterowników firmware.
</p>

<pre caption="Instalacja dodatkowych skryptów hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Jeśli chcesz, aby moduły do podłączonych urządzeń były ładowane przed
uruchomieniem systemu, użyj pakietu coldplug:
</p>

<pre caption="Instalacja pakietu coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Co do jądra, jeśli używasz domyślnych ustawień programu <c>genkernel</c> to
masz wszystko ustawione. W innym przypadku upewnij się, aby uaktywnić
następujące opcje:
</p>

<pre caption="Wymagane opcje jądra">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Możesz zostawić <c>/dev file system support (OBSOLETE)</c> włączone jeśli
chcesz, ale musisz się upewnić, że "Automatically mount at boot" jest
wyłączone:
</p>

<pre caption="Nie montuj automatycznie devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

</body>
</section>
<section>
<title>Konfiguracja</title>
<body>

<p>
Jeśli chcesz użyć podkręceń do udev, które Gentoo dodaje, aby uczynić twoje
życie bardziej komfortowym, to nie czytaj dalej. Gentoo użyje udev, ale
zatrzyma statyczne <path>/dev</path>, tak, że nigdy nie będziesz miał żadnych
brakujących węzłów urządzeń. Skrypty startowe Gentoo nie uruchomią demona
devfsd i wyłączą devfs, kiedy uruchamiasz system.
</p>

<p>
Ale jeśli jesteś konserwatywny i chcesz uruchamiać oparty tylko na udev, nie
podkręcony system (włączając kłopoty z brakującymi węzłami urządzeń, których
udev jeszcze nie wspiera), z całą pewnością czytaj dalej :)
</p>


<p>
Wyłączymy reguły, które zapisują węzły plików urządzeń: edytuj zmienną
<c>RC_DEVICE_TARBALL</c> w <path>/etc/conf.d/rc</path> i ustaw ją na <c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Jeśli włączyłeś wsparcie devfs w swoje jądro, możesz je wyłączyć w konfiguracji
programu rozruchowego: dodaj <c>gentoo=nodevfs</c> jako parametr jądra.  Jeśli
chcesz używać devfs i wyłączyć udev, dodaj <c>gentoo=noudev</c> jako parametr
jądra.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Znane problemy</title>
<section>
<title>Brakujące podczas uruchomienia pliki węzłów urządzeń</title>
<body>

<p>
Jeśli nie możesz pomyślnie uruchomić systemu, ponieważ otrzymujesz błąd
związany z brakiem <path>/dev/null</path> lub konsoli, problemem jest brak
pewnych plików urządzeń, które muszą być dostępne <e>przed</e> tym jak
<path>/dev</path> jest montowany i obsługiwany przez udev. To jest typowe dla
maszyn Gentoo zainstalowanych na starych nośnikach.
</p>

<p>
Jeśli używasz <c>sys-apps/baselayout-1.8.12</c> lub nowsze, ten problem jest
złagodzony, od kiedy proces uruchomienia powinien nadal być doprowadzany do
końca. Jakkolwiek, aby pozbyć się tych denerwujących ostrzeżeń, powinieneś
utworzyć brakujące węzły urządzeń, tak, jak to opisano poniżej.
</p>

<p>
Aby zobaczyć, które węzły urządzeń są obecne przed zamontowaniem systemu plików
<path>/dev</path>, wydaj następujące komendy:
</p>

<pre caption="Wyświetlanie węzłów urządzen dostępnych przy uruchomieniu">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Urządzenia wymagane do pomyślnego uruchomienia to <path>/dev/null</path> i
<path>/dev/console</path>. Jeśli nie pojawią się w poprzednim teście, musisz
stworzyć je ręcznie. Wydaj następujące polcenia w katalogu
<path>test/dev/</path>:
</p>

<pre caption="Tworzenie niezbędnych plików węzłów urządzeń">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Kiedy skończysz, nie zapomnij odmontować katalogu <path>test/</path>:
</p>

<pre caption="Odmontowywanie katalogu test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev i nvidia</title>
<body>

<p>
Jeśli używasz własnościowego sterownika od nVidii, a X serwer nie uruchamia się
na systemie tylko-udev, upewnij się, że masz:
</p>

<ul>
  <li>
    moduł <c>nvidia</c> wykazany w
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    wersję <c>nvidia-kernel</c> równą lub większą niż
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    wersję baselayout równą lub większą niż
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>


</body>
</section>
<section>
<title>Znikające Nazwy LVM2</title>
<body>

<p>
Kiedy używasz <c>udev</c> i LVM2 razem, możesz zauważyć, że stworzone przez
Ciebie grupy wolumenów i logiczne wolumeny zniknęły. Cóż, one nie zniknęły, ale
są na nieszczęście przemianowane na <path>/dev/dm-#</path> gdzie zamiast # są
0, 1, ...
</p>

<p>
Aby to naprawić, edytuj <path>/etc/udev/rules.d/50-udev.rules</path> i
odkomentuj następującą linię:
</p>

<pre caption="Odkomentuj tą linię z /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

</body>
</section>
<section>
<title>Brak konsekwentnego nazewnictwa pomiędzy DevFS a udev</title>
<body>

<p>
Chociaż naszym zamiarem jest mieć konsekwentny schemat nazewnictwa pomiędzy
obydwoma rozwiązaniami dynamicznego zarządzania urządzeniami, czasami pojawiają
się różnice w nazewnictwie. Jedna ze zgłoszonych kolizji dotyczy kontrolera
RAID HP Smart Array 5i (bardziej precyzyjnie modułu jądra <c>cciss</c>). udev
nazywa urządzenia <path>/dev/cciss/cXdYpZ</path>, gdzie X, Y i Z są zwykłymi
numerami. devfs nazywa je <path>/dev/hostX/targetY/partZ</path> lub dowiązuje
symbolicznie z <path>/dev/cciss/cXdY</path>.
</p>

<p>
Jeśli to jest ten przypadek, nie zapomnij uaktualnić <path>/etc/fstab</path> i
odpowiednich plików konfiguracyjnych programu rozruchowego.
</p>

</body>
</section>
<section>
<title>Inne problemy</title>
<body>

<p>
Jeśli węzły urządzeń nie są tworzone, gdy moduł jest ładowany z
<path>/etc/modules.autoload.d/kernel-2.6</path>, ale raczej pojawiają się,
kiedy załadujesz moduł ręcznie przez modprobe, wtedy powinieneś odnowić system
do <c>sys-apps/baselayout-1.8.12</c> lub nowszego.
</p>

<p>
Wsparcie dla urządzeń bufora ramki (<path>/dev/fb/*</path>) jest oferowane
przez jądra od wersji 2.6.6-rc2.
</p>

<p>
Dla jąder starszych niż 2.6.4 musisz wyraźnie włączyć wsparcie dla systemu
plików <path>/dev/pts</path>.
</p>

<pre caption="Włączanie systemu plików /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Zasoby i Podziękowania</title>
<section>
<body>

<p>
Rozmowa dotycząca udev na Linux Symposium (Ottawa, Ontario Canada - 2003)
udostępniona przez Grega Kroah-Hartmana (IBM Corporation) pomogła porządnie
zrozumieć aplikację udev.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's
UDEV Primer</uri> jest dogłębnym dokumentem dotyczącym udev i Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri>
kumpla i konstruktora Gentoo Daniela Drake jest doskonałym dokumentem do nauki
jak dopasować instalację udev.
</p>

</body>
</section>
</chapter>

</guide>
