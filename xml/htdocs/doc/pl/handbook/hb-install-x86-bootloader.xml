<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- Orig revision: 1.33 -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/Attic/hb-install-x86-bootloader.xml,v 1.7 2005/07/04 20:29:02 smithj Exp $ -->

<!-- Translator: rane <rane@gentoo.pl> -->
<!-- Title: O instalacji Gentoo Linux -->
<!-- Status: Release -->

<!-- $Id: hb-install-x86-bootloader.xml,v 1.7 2005/07/04 20:29:02 smithj Exp $ -->

<sections>
<version>2.4</version>
<date>2005-04-16</date>

<section>
<title>Podejmowanie decyzji</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Gdy skonfigurowałeś jądro i zmodyfikowałeś odpowiednio niezbędne systemowe pliki
konfiguracyjne nadeszła pora zainstalowania programu, który uruchomi jądro w
momencie startu systemu. Taki program nazywa się <e>bootloader</e>. Dla
architektury x86 Gentoo Linux używa dwóch takich programów: <uri
link="#grub">GRUB</uri> i <uri link="#lilo">LILO</uri>. Zanim zainstalujesz
którykolwiek z nich nauczymy Cię jak się konfiguruje framebuffer -
zakładając oczywiście, że go chcesz.
</p>

</body>
</subsection>
<subsection>
<title>Opcjonalnie: Framebuffer</title>
<body>

<p>
<e>Jeżeli</e> skonfigurowałeś jądro z obsługą bufora ramki i chcesz ją wykorzystywać
musisz dodać parametr <c>vga</c> w odpowiednim miejscu pliku konfiguracyjnego
bootloadera. 
</p>

<p>
Najważniejszą informacją jaką należy posiąść przed rozpoczęciem konfiguracji
jest nazwa używanego urządzenia framebuffera. Niektóre jądra, takie jak na
przykład <c>gentoo-sources</c>, posiadają domyślnie obsługę <c>vesafb-tng</c>
jako <e>sterownika typu VESA</e>. Użytkownicy <c>vesafb-tng</c> nie muszą
dodawać parametru <c>vga</c>. Pozostali, używający <c>vesafb</c> wciąż muszą go
dopisywać.
</p>

<p>
Za pomocą parametru <c>vga</c> określa się rozdzielczość oraz głębię kolorów
ekranu framebuffera. Każdy numer określa inną głębię i rozdzielczość, ich lista
znajduje się w dokumencie
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path>, który instaluje się w
systemie wraz ze źródłami jądra.
</p>

<p>
Oto tabela parametrów <c>vga</c> zawierająca wszystkie dostępne rozdzielczości i
głębie kolorów:
</p>

<table>
<tr>
  <ti></ti>
  <th>640x480</th>
  <th>800x600</th>
  <th>1024x768</th>
  <th>1280x1024</th>
</tr>
<tr>
  <th>256</th>
  <ti>0x301</ti>
  <ti>0x303</ti>
  <ti>0x305</ti>
  <ti>0x307</ti>
</tr>
<tr>
  <th>32k</th>
  <ti>0x310</ti>
  <ti>0x313</ti>
  <ti>0x316</ti>
  <ti>0x319</ti>
</tr>
<tr>
  <th>64k</th>
  <ti>0x311</ti>
  <ti>0x314</ti>
  <ti>0x317</ti>
  <ti>0x31A</ti>
</tr>
<tr>
  <th>16M</th>
  <ti>0x312</ti>
  <ti>0x315</ti>
  <ti>0x318</ti>
  <ti>0x31B</ti>
</tr>
</table>

<p>
Parametr <c>video</c> odpowiada za opcje wyświetlania framebuffera. Niezbędna
jest mu nazwa sterownika bufora ramki (<c>vesafb</c> dla jąder 2.6 lub
<c>vesa</c> w 2.4) oraz opcje z jakimi ma być uruchamiany bufor. Wszystkie
zmienne znajdują się w pliku
<path>/usr/src/linux/Documentation/fb/vesafb.txt</path>, oto trzy najważniejsze
z nich:
</p>

<table>
<tr>
  <th>Kontrolka</th>
  <th>Opis</th>
</tr>
<tr>
  <ti>ywrap</ti>
  <ti>
    Włącza zawijanie pamięci karty graficznej.
  </ti>
</tr>
<tr>
  <ti>mtrr</ti>
  <ti>
    Włącza rejestry MTRR
  </ti>
</tr>
<tr>
  <ti><c>mode</c></ti>
  <ti>
    (tylko dla <c>vesafb-tng</c>)<br/>
    Pozwala na ustawienie rozdzielczości, głębii kolorów oraz częstotliwości
    odświeżania. Na przykład <c>1024x768-32@85</c> ustawi rozdzielczość
    1024x768, 32 bitową głębię kolorów i częstotliwość odświeżania 85 Hz.
  </ti>
</tr>
</table>

<p>
Wynik tych działań powinien wyglądać mniej więcej tak: <c>vga=0x318
video=vesafb:mtrr,ywrap</c> lub <c>video=vesafb:mtrr,ywrap,1024x768-32@85</c>.
Warto zapamiętać to ustawienie, wkrótce będzie potrzebne.
</p>

<p>
Kolejny etap to instalacja <uri link="#grub">GRUB</uri> <e>lub</e> <uri
link="#lilo">LILO</uri>.
</p>


</body>
</subsection>
</section>
<section id="grub">
<title>Domyślnie: Użycie programu GRUB</title>
<subsection>
<title>Wyjaśnienie terminologii związanej z GRUB</title>
<body>

<p>
Najważniejszym czynnikiem prowadzącym do zrozumienia programu
GRUB jest pojęcie jego sposobu odnoszenia się do dysków i partycji.
Twoja linuksowa partycja <path>/dev/hda1</path> jest określana
przez GRUB jako <path>(hd0,0)</path>.
Zauważ nawiasy po obu stronach <path>hd0,0</path> - ich użycie jest wymagane.
</p>

<p>
Dyski twarde są liczone od zera, a nie od "a", partycje także zaczynają
się od zera, a nie od jedynki. Bądź świadom także tego, że w grupie
urządzeń pamięci masowej tylko twarde dyski są liczone, nie ma to
natomiast miejsca  w przypadku napędów ATAPI-IDE takich jak cdromy
i nagrywarki. Ta sama sytuacja ma miejsce w przypadku dysków SCSI.
(Normalnie otrzymują one wyższe numery niż dyski IDE, z wyjątkiem
sytuacji, gdy BIOS jest ustawiony na start systemu z urządzenia SCSI).
</p>

<p>
Zakładając, że masz dysk twardy oznaczony jako <path>/dev/hda</path>,
odtwarzacz cdrom <path>/dev/hdb</path>, nagrywarkę <path>/dev/hdc</path>,
drugi dysk twardy <path>/dev/hdd</path> i nie posiadasz dysku SCSI,
urządzenie <path>/dev/hdd7</path> jest rozumiane jako <path>(hd1,6)</path>.
Całość wygląda dość pokrętnie, lecz jak się
niedługo przekonamy GRUB oferuje mechanizm uzupełniania wiersza polecenia
klawiszem TAB, co z pewnością jest wybawieniem dla tych, którzy mają
dużo dysków twardych i partycji, a gubią się nieco w sposobie numeracji
używanym przez program GRUB.
</p>

<p>
Już wiesz co Cię czeka, nadeszła pora zainstalować GRUB'a.
</p>

</body>
</subsection>
<subsection>
<title>Instalowanie GRUB-a</title>
<body>

<p>
Po pierwsze emergujemy program GRUB:
</p>

<pre caption="Instalowanie GRUB-a">
# <i>emerge grub</i>
</pre>

<p>
GRUB został zainstalowany, teraz należy go jeszcze skonfigurować i umieścić w
MBR, tak by automatycznie uruchamiał nowo zainstalowane kernele. Najpierw przy
pomocy nano, lub dowolnego innego edytora utwórz plik
<path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Tworzenie /boot/grub/grub.conf">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
Następnie zredagujmy plik <path>grub.conf</path>. Poniżej
znajdziesz trzy przykłady pliku <path>grub.conf</path>, odpowiadające
schematowi partycjonowania użytemu w tym przewodniku, z obrazem jądra
o nazwie <path>kernel-2.4.24</path>. Wyczerpująco opatrzymy komentarzami
tylko pierwszy <path>grub.conf</path>.
</p>

<ul>
<li>Pierwszy <path>grub.conf</path> jest dla osób, które nie wykorzystały
programu <c>genkernel</c> do budowania jądra.</li>
<li>Drugi <path>grub.conf</path> jest dla tych, którzy użyli programu
<c>genkernel</c> do zbudowania jądra.</li>
</ul>
      
<pre caption="grub.conf dla nie używających genkernela">
<comment># Która pozycja ma być uruchamiana domyślnie? 0 oznacza pierwszą, 1 drugą itd.</comment>
default 0
<comment># Ile sekund oczekiwać przed uruchomieniem pozycji domyślnej.</comment>
timeout 30
<comment># Ładniutki, tłuściutki obrazek na zaostrzenie apetytu :) 
# Zakomentuj jeśli nie masz zainstalowanej karty graficznej</comment>
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux 2.4.24
<comment># Partycja na której znajduje się obraz jądra (lub system operacyjny) </comment>
root (hd0,0)
kernel /kernel-2.4.24 root=/dev/hda3

<comment># Następne trzy linie są potrzebne tylko gdy chcesz uruchamiać także Windows.</comment>
<comment># W tym przypadku Windows znajduje się na /dev/hda6.</comment>
title=Windows XP
rootnoverify (hd0,5)
chainloader +1
</pre>

<pre caption="grub.conf dla użytkowników genkernela">
default 0
timeout 30
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux 2.4.24
root (hd0,0)
kernel /kernel-2.4.24 root=/dev/ram0 init=/linuxrc real_root=/dev/hda3
initrd /initrd-2.4.24

<comment># Tylko, gdy chcesz uruchamiać dwa systemy</comment>
title=Windows XP
rootnoverify (hd0,5)
chainloader +1
</pre>

<note>
Jeśli partycjonowanie wykonałeś w inny sposób i/lub używasz innego obrazu jądra,
dokonaj niezbędnych poprawek. Warto pilnować, aby wszystko co dotyczy urządzenia
z GRUB'em (np. <path>(hd0,0)</path>) było względne w stosunku do punktu
montowania, a nie partycji root. Innymi słowy, <path>(hd0,0)/grub/splash.xpm.gz</path>
w rzeczywistości znaczy <path>/boot/grub/splash.xpm.gz</path>, gdyż <path>(hd0,0)</path>
to partycja <path>/boot</path>.
</note>

<p>
Jeśli chcesz przekazać do jądra przy starcie jakieś dodatkowe opcje po prostu
dopisz je na końcu polecenia kernel. W tym momencie już dodaliśmy jeden
parametr (<c>root=/dev/hda3</c> lub <c>real_root=/dev/hda3</c>), a Ty
bez problemu możesz wzbogacić polecenie o kolejne. Przykładowo
posłużymy się opcją <c>vga</c>, dotyczącą bufora ramki, którą
przedyskutowaliśmy kilka paragrafów wcześniej:
</p>

<p>
Użytkownicy jąder 2.6.7 i nowszych, którzy przy pomocy jumpera ograniczyli
wielkość swojego dysku, ponieważ ich BIOS nie jest w stanie współpracować z
większymi napędami mogą dodać opcję <c>hdx=stroke</c>, aby korzystać z całego
dostępnego na urządzeniu miejsca.
</p>

<p>
Użytkownicy programu <c>genkernel</c> powinni wiedzieć, że jądra, które
zbudowali używają tych samych opcji bootowania co LiveCD. Na przykład jeśli masz
urządzenia SCSI, powinieneś dodać parametr <c>doscsi</c>.
</p>

<p>
Następnie zapisz plik <path>grub.conf</path> i opuść edytor. Kolejnym krokiem
będzie dopisanie GRUB'a do MBR.
</p>

<p>
Twórcy GRUB-a zalecają użycie <c>grub-install</c>. Czasem jednak program ten z
jakiegoś powodu odmówi współpracy wciąż pozostanie Ci możliwość ręcznego
zainstalowania GRUB-a.
</p>

<p>
Teraz przejdź do paragrafu <uri link="#grub-install-auto">Domyślnie: Instalowanie
GRUB'a przy pomocy grub-install</uri> lub <uri link="#grub-install-manual">
Alternatywnie: Ręczne instalowanie GRUB'a</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-auto">
<title>Domyślnie: Instalacja GRUB-a przy pomocy grub-install</title>
<body>

<p>
Żeby zainstalować GRUB'a wpisz komendę <c>grub-install</c>. Nie zadziała to
jednak bez pewnych zmian, bo wciąż działamy w chrootowanym
środowisku. Będziemy musieli uaktualnić plik <path>/etc/mtab</path> (plik z
informacjami dotyczącymi zamontowanych napędów). Na szczęście jest na to prosta
metoda, wystarczy nadpisać ten plik plikiem <path>/proc/mounts</path>.
</p> 

<pre caption="Uaktualnianie /etc/mtab">
# <i>cp /proc/mounts /etc/mtab</i>
</pre>

<p>
Następnie instalujemy GRUB przy pomocy <c>grub-install</c>:
</p>

<pre caption="Uruchamianie grub-install">
# <i>grub-install --root-directory=/boot /dev/hda</i>
</pre>

<p>
Więcej informacji o GRUB'ie znajdziesz w dokumentach:
<uri link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> i <uri
link="http://www.gnu.org/software/grub/manual/">GRUB Manual</uri>.
</p>

<p>
Następnie przejdź do części <uri link="#reboot">Ponowne uruchamianie systemu</uri>.
</p>

</body>
</subsection>
<subsection id="grub-install-manual">
<title>Alternatnie: Ręczna instalacja GRUB'a.</title>
<body>

<p>
Aby zacząć wpisz <c>grub</c>. Znak zachęty zmieni się na taki:
<path>grub&gt;</path>. Teraz wpisujesz serię odpowiednich komend, aby nagrać
program GRUB na swój dysk.
</p>

<pre caption="Uruchamianie powłoki GRUB">
# <i>grub</i>
</pre>

<note>
Jeśli nie masz stacji dyskietek dodaj opcję <c>--no-floppy</c> do powyższego
polecenia, żeby GRUB nie marnował czasu na poszukiwanie nieistniejącego napędu.
</note>

<p>
Wyobraźmy sobie, że chcemy zainstalować GRUB tak aby odczytywał informacje z
bootowalnej partycji <path>/dev/hda1</path> i instalował swój boot record w MBR
twardego dysku, tak żeby pierwszą rzeczą jaką zobaczymy po uruchomieniu
komputera był znak zachęty GRUB'a. Oczywiście powinieneś odpowiednio dostosować
wszystkie opcje do swojej konfiguracji.
</p>

<p>
Mechanizm uzupełniania składni jest bardzo pomocny przy konfigurowaniu GRUB'a. Na
przykład wpisując "<c>root (</c>" i wciskając TAB możemy zobaczyć wszystkie
urządzenia (np. <path>hd0</path>). Jeśli wpiszemy "<c>root (hd0,</c>" i
wciśniemy TAB zobaczymy listę wszystkich dostępnych partycji na urządzeniu (np.
<path>hd0,0</path>).
</p>

<p>
Przy pomocy tego systemu skonfigurowanie GRUB'a powinno być proste. Zróbmy więc to wreszcie ;]
</p>

<pre caption =" Instalacja GRUB in the MBR">
grub&gt; <i>root (hd0,0)</i>          <comment>(Wpisz swoją partycję /boot)</comment>
grub&gt; <i>setup (hd0)</i>           <comment>(Instalacja GRUB'a w MBR)</comment>
grub&gt; <i>quit</i>                  <comment>(Opuszczenie powłoki GRUB)</comment>
</pre>

<note>
Jeśli chcesz mieć GRUB nie w MBR, a na jakieś wybranej partycji musisz
odpowiednio zmienić komendę <c>setup</c> tak by wskazywała na odpowiednie
urządzenie. Na przykład dla GRUB;a zainstalowanego w <path>/dev/hda3</path>
będzie to <c>setup (hd0,2)</c>.
</note>

<p>
Jeśli chcesz dowiedzieć się więcej poszukaj informacji na stronach: <uri
link="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</uri> i <uri
link="http://www.gnu.org/software/grub/manual/">GRUB Manual</uri>.
</p>

<p>
Następnie możesz przejść do sekcji <uri link="#reboot">Ponowne uruchamianie systemu</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternatywnie: Używanie LILO.</title>
<subsection>
<title>Instalowanie LILO.</title>
<body>

<impo>
LILO może być użyte tylko dla architektury x86!
</impo>

<p> 
LILO, czyli LInuxLOader to program naprawdę wypróbowany i używany od bardzo
dawna przez bardzo wielu użytkowników. Brakuje mu jednak niektórych cech posiadanych przez
program GRUB, co jest, między innymi, powodem rosnącej popularności tego drugiego.
Fakt, że na niektórych systemach LILO działa, a GRUB nie, powoduje,
iż LILO jest ciągle w użyciu. Oczywiście nie jest to jedyny powód - niektórzy
po prostu lepiej znają LILO i wolą przy nim pozostać, zamiast uczyć się obsługi
całkiem nowego programu. My jak zawsze wybór pozostawiamy użytkownikom, Gentoo
wspiera obydwa programy, a Ty właśnie wybrałeś LILO.
</p>

<p>
Instalacja LILO jest prosta, używamy do tego polecenia <c>emerge</c>.
</p>


<pre caption = "Instalowanie LILO">
# <i>emerge --usepkg lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>Konfigurowanie LILO.</title>
<body>

<p>
Aby skonfigurować LILO musisz utworzyć plik <path>/etc/lilo.conf</path>. Uruchom
ulubiony edytor (w tym Podręczniku konsekwentnie używamy <c>nano</c>)
i stwórz ten plik.
</p>

<pre caption = "Tworzenie /etc/lilo.conf">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
Kilka rozdziałów temu prosiliśmy Cię o zapamiętanie nazwy utworzonego obrazu jądra.
W naszym przykładowym <path>lilo.conf</path> zakładamy, że nazwą obrazu jest
<path>kernel-2.4.24</path>. Użyjemy w tym przykładzie uprzednio zaprezentowanego
schematu partycjonowania. Przygotowaliśmy dwie części:
</p>

<ul>
  <li>
    Pierwszą dla tych, którzy nie skorzystali z programu <c>genkernel</c> przy
    budowaniu jądra.
  </li>
  <li>
    Drugą dla używających <c>genkernela</c>.
  </li>
</ul>

<pre caption = "Przykładowy /etc/lilo.conf">
boot=/dev/hda             <comment># Instalacja LILO w MBR</comment>
prompt                    <comment># Dajemy użytkownikowi możliwość wyboru innej pozycji</comment>
timeout=50                <comment># Czekamy 5 sekund przed uruchomieniem domyślnej pozycji</comment>
default=gentoo            <comment># Kiedy oczekiwanie się zakończy, uruchamiamy pozycję "gentoo"</comment>
<comment># Tylko jeśli używasz bufora ramki. W przeciwnym wypadku usuń następującą linię:</comment>
vga=788                   <comment># Ustawienia framebuffera. Dopasuj wedle uznania.</comment>

<comment># Dla niekorzystajacych z genkernela</comment>
image=/boot/kernel-2.4.24
label=gentoo            <comment># Nazwa, jaką mianujemy tę pozycję</comment>
read-only               <comment># Zaczynamy z partycją root tylko do odczytu. Nie zmieniać!</comment>
root=/dev/hda3          <comment># Umiejscowienie głównego systemu plików</comment>

<comment># Dla użytkowników genkernela</comment>
image=/boot/kernel-2.4.24
label=gentoo
read-only
root=/dev/ram0
append="init=/linuxrc real_root=/dev/hda3"
initrd=/boot/initrd-2.4.24

<comment># Następne dwie linie są podane na wypadek, gdybyś chciał uruchamiać Windows.</comment>
<comment># W tym przypadku, Windows mieści się na /dev/hda6.</comment>
other=/dev/hda6
label=windows
</pre>

<note>
Parametr <c>udev</c> w na końcu linii "append" jest niezbędny dla obejścia błędu
w pewnych wersjach genkernela, występującego gdy używa się udev na pierwszym
miejscu, co jest zresztą domyślnym ustawieniem.
</note>

<note>
Jeśli używasz innego schematu partycjonowania i/lub obrazu jądra,
dokonaj niezbędnych poprawek.
</note>

<p>
Jakiekolwiek dodatkowe parametry startowe jądra dodajesz po słowie kluczowym
<c>append</c>. Jako przykład, podajemy opcję <c>acpi=off</c> służącą
do wyłączenia obsługi ACPI:
</p>

<pre caption="Dodawanie funkcji jądra poprzez linię append">
image=/boot/kernel-2.4.26-gentoo-r6
  label=gentoo
  read-only
  root=/dev/hda3
  <i>append="vga=788"</i>
</pre>

<p>
Jeśli używasz kernela 2.6.7 lub nowszego i przy pomocy jumperów ograniczyłeś
rozmiar swojego twardego dysku, bo BIOS nie obsługuje tak dużych napędów
dopisz do linii append polecenie <c>hdx=stroke</c>.
</p>

<p>
Użytkownicy programu <c>genkernel</c> powinni wiedzieć, że jądra, które zbudowali,
używają tych samych opcji bootowania co LiveCD. Na przykład jeśli masz urządzenia
SCSI powinieneś dodać parametr <c>doscsi</c>.
</p>

<p>
Kiedy skończysz konfigurowanie zapisz plik i opuść edytor. By zakończyć musisz uruchomić program
<c>/sbin/lilo</c>, LILO zastosuje ustawienia z <path>/etc/lilo.conf</path>
do Twojego systemu (tzn. zainstaluje się na dysk). Zapamiętaj, że będziesz
musiał ponownie wykonać polecenie <c>/sbin/lilo</c> za każdym razem gdy zainstalujesz
nowe jądro!
</p>

<pre caption = "Kończenie instalacji LILO">
# <i>/sbin/lilo</i>
</pre>

<note>
Kiedy instalujesz nowy kernel nie musisz ręcznie kopiować plików. Dokona tego za
Ciebie polecenie <c>make install</c> wprowadzone zaraz po przygotowaniu obrazu 
jądra. Umieści ono automatycznie nowe jądro w odpowiednim miejscu i dokona 
niezbędnych poprawek w konfiguracji LILO.
</note>

<p>
Kiedy skończysz przejdź do rozdziału <uri link="?part=1&amp;chap=10">Instalacja
niezbędnych narzędzi systemowych</uri>.
</p>

</body>
</subsection>
</section>
<section id="reboot">
<title>Ponowne uruchamianie systemu.</title>
<subsection>
<body>

<p>
Opuść teraz chroot i odmonuj wszystkie zamontowane partycje. Następnie wpisz komendę <c>reboot</c>.
</p>

<pre caption="Odmontowywanie partycji i ponowne uruchamianie komputera">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<p>
Nie zapomnij również o wyjęciu płyty z napędu, bo zamiast nowiutkiego Gentoo
znów Ci się zabootuje livecd. 
</p>

<p>
Następnie zakończ proces instalacji zgodnie ze wskazówkami spisanymi w rozdziale <uri
link="?part=1&amp;chap=11">Finalizowanie instalacji Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
