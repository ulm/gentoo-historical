<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-ppc-bootloader.xml,v 1.11 2005/08/20 23:43:48 rane Exp $ -->

<sections>

<version>2.6</version>
<date>2005-08-12</date>

<section>
<title>Wybór bootloadera</title>
<subsection>
<title>Wstęp</title>
<body>

<p>
Gdy jądro zostało już skonfigurowane i skompilowane, do uruchomienia nowego
systemu potrzebny jest <e>bootloader</e>. To, jakiego rodzaju <e>bootloader</e>
należy wykorzystać, zależy od typu posiadanego komputera PPC.
</p>

<p>
Jeśli korzystamy z komputera NewWorld Apple lub IBM, jedyną możliwością jaką 
mamy jest bootloader <uri link="#yaboot">yaboot</uri>. Dla OldWorld Apple 
istnieją dwie opcje: <uri link="#bootx">BootX</uri> (zalecany) i <uri
link="#quik">quik</uri>. Pegasos nie wymaga bootloadera, jednak w jego
przypadku konieczne jest zemergowanie  programu <uri link="#bootcreator">
BootCreator</uri>, aby możliwe było stworzenie bootmenu SmartFirmware.
</p>

</body>
</subsection>
</section>
<section id="yaboot">
<title>Domyślnie: Używanie yaboot</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<impo>
yaboot może być używany tylko na komputerach NewWorld Apple lub IBM.
</impo>

<p>
W celu prawidłowego zlokalizowania aparatu boot, yaboot potrzebuje dostępu do
systemu plików <path>/dev</path>. Aby było to możliwe, należy dokonać dowiązania
systemu plików <path>/dev</path> z LiveCD do <path>/dev</path> w naszym nowym
systemie.
</p>

<pre caption="Dowiązywanie systemu plików /dev">
# <i>exit </i> <comment>(opuszczenie chroot)</comment>
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>/usr/sbin/env-update &amp;&amp; source /etc/profile </i>
</pre>

<p>
Aby skonfigurować yaboota można wykorzystać <c>yabootconfig</c> w celu
automatycznego wygenerowania pliku konfiguracyjnego. Jeśli jednak instalujemy
Gentoo na G5 (na którym <c>yabootconfig</c> nie zawsze działa) lub planujemy
bootować system z urządzeń podłączanych poprzez firewire lub USB, musimy
własnoręcznie przeprowadzić konfigurację yaboota.
</p>

<note>
W przypadku gdy do wygenerowania jądra użyto programu genkernel, konieczna
będzie ręczna edycja pliku yaboot.conf, nawet jeśli wykorzystano yabootconfig.
Sekcja obrazu jądra powinna zostać zmodyfikowana w następujący sposób:
</note>

<pre caption="Dodawanie argumentów właściwych dla jąder wygenerowanych 
programem genkernel do yaboot.conf">
<comment>###########################################################
## Ta sekcja może zostać powielona w przypadku posiadania więcej niż
## jednego jądra, lub zestawu parametrów startowych. Należy zastąpić
## kernel-2.6.12 nazwą posiadanego jądra.
###########################################################</comment>
image=/boot/kernel-2.6.12
  label=Linux
  root=/dev/ram0    <comment># W przypadku użycia programu genkernel jest to /dev/ram0</comment>
  partition=3
  append="real_root=/dev/hda3 init=/linuxrc"  
  <comment># Można dodać inne argumenty dla jądra, jak na przykład rootdelay=10
  # dla bootowania z urządzeń USB/Firewire</comment>
  read-only
<comment>##########################################################</comment>
</pre>

<ul>
  <li><uri link="#yabootconfig">Domyślnie: Użycie yabootconfig</uri></li>
  <li>
    <uri link="#manual_yaboot">Alternatywnie: Ręczna konfiguracja yaboot</uri>
  </li>
</ul>

</body>
</subsection>
<subsection id="yabootconfig">
<title>Domyślnie: Użycie yabootconfig</title>
<body>

<p>
<c>yabootconfig</c> automatycznie wykryje podział na partycje i umożliwi
uruchamianie wybranego z dwóch lub nawet trzech systemów, którymi mogą być
Linux, Mac OS i Mac OS X.
</p>

<p>
Konieczne jest posiadanie na dysku partycji Apple_Bootstrap oraz odpowiednich
wpisów dotyczących istniejących partycji Linuksa w pliku
<path>/etc/fstab</path>, przed użyciem <c>yaboota</c>. Obydwa warunki powinny
być już spełnione - wszystkie operacje zostały opisane w poprzednich
rozdziałach. Ponadto należy upewnić się, że posiadamy najnowszą wersję yaboota,
wykonując polecenie <c>emerge --update yaboot</c>. Jest to konieczne, ponieważ
aktualna wersja bedzie dostępna poprzez Portage, jednak może jej jeszcze nie być
w plikach stage.
</p>

<pre caption="Instalowanie yaboota">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
Następnie opuszczamy chroot i wykonujemy polecenie <c>yabootconfig --chroot
/mnt/gentoo</c>. Zostaniemy poproszeni o potwierdzenie lokalizacji partycji
Apple_Bootstrap. Należy wcisnąć klawisz <c>Y</c> jeśli jest ona poprawna. Jeśli
nie, musimy sprawdzić plik <path>/etc/fstab</path> i upewnić się, że ścieżki do
urządzeń są prawidłowe. Gdy partycja bootstrap zostanie wybrana,
<c>yabootconfig</c> przeskanuje ustawienia systemowe, utworzy plik
<path>/etc/yaboot.conf</path> i uruchomi <c>mkofboot</c>. <c>mkofboot</c> jest
programem, który formatuje partycję Apple_Bootstrap i umieszcza na niej plik
konfiguracyjny yaboota. Gdy operacje te zostaną wykonane powracamy do środowiska
chrootowanego.
</p>

<pre caption="Powrót do chroot">
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>/usr/sbin/env-update &amp;&amp; source /etc/profile</i>
</pre>

<p>
Być może wystąpi potrzeba modyfikacji zawartości pliku
<path>/etc/yaboot.conf</path>. Jeśli zostaną wprowadzone do niego jakieś zmiany
(jak na przykład zmiana domyślnie uruchamianego systemy), konieczne będzie
uruchomienie <c>ybin -v</c>, aby zmiany odniosły skutek na partycji
Apple_Bootstrap.
</p>

<p>
Po wykonaniu tych operacji, kontynuujemy instalację zgodnie z instrukcjami w
podrozdziale <uri link="#reboot">Rebootowanie systemu</uri>.
</p>

</body>
</subsection>
<subsection id="manual_yaboot">
<title>Alternatywnie: Ręczna konfiguracja yaboot</title>
<body>

<p>
Po pierwsze należy upewnić się, że mamy zainstalowaną najnowszą wersję
<c>yaboota</c>.
</p>

<pre caption = "Instalowanie yaboota">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
Poniżej znajduje się przykładowy plik <path>yaboot.conf</path>. Konieczna jest
jego modyfikacja w celu dopasowania do wymagań systemu i użytkownika. Posiadacze
G5, a także ci, którzy bootują z urządzeń firewire/USB muszą pamiętać, że ich
dyski widoczne są dla jądra Linuksa jako urządzenia SCSI, więc konieczne jest
zastąpienie <path>/dev/hda</path> ścieżką <path>/dev/sda</path>.
</p>

<pre caption = "/etc/yaboot.conf">
<comment>## /etc/yaboot.conf
##
## Więcej szczegółów: "man yaboot.conf". Nie należy wprowadzań zmian przed
## zapoznaniem się ze stronami man yaboot.conf!!
## Przykładowe konfiguracje: /usr/share/doc/yaboot/examples
##
## Aby możliwe było uruchamianie innych systemów, należy dodać jedną lub więcej
## z przykładowych pozycji:
## bsd=/dev/hdaX, macos=/dev/hdaY, macosx=/dev/hdaZ

## nasza partycja bootstrap:</comment>

boot=/dev/hda2


<comment>## ofboot w openfirmware służy do wyboru partycji startowej.
## Bez tego parametru, yaboot nie zadziała na G5 (dopóki nie zostaną przekazane
## odpowiednie opcje do programu mkofboot/ybin).
## hd:X oznacza /dev/sdaX (lub /dev/hdaX).
##
## Posiadacze G5 powinni odkomentować tą linię!!

#ofboot=hd:2

## Bootujący z urządzeń firewire powinni użyć linii podobnej do poniższej:
# ofboot=fw/node/sbp-2/disk@0:

## Bootujący z urządzeń USB powinni użyć linii podobnej do poniższej:
# ofboot=usb/disk@0:

## hd: w terminologii OpenFirmware oznacza hda</comment>
device=hd:

<comment>## Bootujący z urządzeń Firewire/USB muszą określić nazwę aparatu OF
## Można ją uzyskać przy użyciu programu ofpath, który jest dołączony do yaboota.

# device=fw/node@0001d200e00d0207/sbp-2@c000/disk@0:
</comment>

delay=5
defaultos=macosx
timeout=30
install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot

<comment>#################
## Ta sekcja może zostać powielona w przypadku posiadania więcej niż
## jednego jądra, lub zestawu parametrów startowych. Należy zastąpić
## kernel-2.6.12 nazwą posiadanego jądra.
#################</comment>
image=/boot/kernel-2.6.9
  label=Linux
  root=/dev/hda3
  partition=3
<comment>#  append="rootdelay=10"  # Wymagane dla bootowania z urządzeń USB/Firewire</comment>
  read-only
<comment>##################

## Użytkownicy G5 i niektórzy użytkownicy G4 powinni wykorzystać ustawienia: 
##   macos=hd:13
##   macosx=hd:12
## zamiast przykładowych wartości.</comment>
macos=/dev/hda13
macosx=/dev/hda12
enablecdboot
enableofboot
</pre>

<p>
Gdy plik <path>yaboot.conf</path> jest prawidłowo skonfigurowany, należy
uruchomić <c>mkofboot -v</c>, czego efektem będzie sformatowanie partycji
Apple_bootstrap i zainstalowanie na niej aktualnej konfiguracji. Jeśli
<path>yaboot.conf</path> zostanie zmodyfikowany po utworzeniu partycji
Apple_bootstrap, konieczne będzie zaktualizowanie ustawień przy użyciu 
polecenia <c>ybin -v</c>.
</p>

<p>
Więcej informacji o yabootcie uzyskać można na stronie <uri
link="http://penguinppc.org/bootloaders/yaboot">projektu yaboot</uri>. Po
skonfigurowaniu bootloadera kontunuujemy instalację zgodnie z instrukcjami w
podrozdziale <uri link="#reboot">Rebootowanie systemu</uri>.
</p>

</body>
</subsection>
</section>
<section id="bootx">
<title>Alternatywnie: BootX</title>
<body>

<impo>
BootX może być używany tylko na systemach OldWorld Apple!
</impo>

<p>
Aby BootX mógł zbootować Linuksa z wnętrza MacOS-a, jądro systemu musi zostać
przekopiowane z partycji Linuksa na partycję MacOS-a. Dokonamy tego montując
najpierw partycję MacOS-a spoza środowiska chrootowanego, a następnie kopiując
kernel do folderu systemowego, aby BootX mógł go odnaleźć. W celu określenia,
na której partycji znajduje się MacOS użyjemy polecenia <c>mac-fdisk -l</c>
(sda6 zostało poniżej użyte jako przykład).
</p>

<pre caption="Kopiowanie jądra na partycję MacOS-a">
# <i>exit</i>
cdimage ~# <i>mkdir /mnt/mac</i>
cdimage ~# <i>mount /dev/sda6 /mnt/mac -t hfs</i>
cdimage ~# <i>cp /mnt/gentoo/usr/src/linux/vmlinux "/mnt/mac/System Folder/Linux Kernels"</i>
</pre>

<p>
Jeśli użyto programu genkernel, to zarówno jądro, jak i initrd muszą zostać
skopiowane na partycję MacOS-a.
</p>

<pre caption="Kopiowanie jądra i initrd wygenerowanych genkernelem na partycję MacOS-a">
# <i>exit</i>
cdimage ~# <i>mkdir /mnt/mac</i>
cdimage ~# <i>mount /dev/sda6 /mnt/mac -t hfs</i>
cdimage ~# <i>cp /mnt/gentoo/boot/kernel-* "/mnt/mac/System Folder/Linux Kernels"</i>
cdimage ~# <i>cp /mnt/gentoo/boot/initramfs-* "/mnt/mac/System Folder"</i>
</pre>

<p>
Gdy jądro zostało skopiowane, musimy zrebootować komputer i skonfigurować BootX.
</p>

<pre caption="Odmontowywanie wszystkich partycji i rebootowanie">
cdimage ~# <i>cd /</i>
cdimage ~# <i>umount /mnt/gentoo/proc /mnt/gentoo /mnt/mac</i>
cdimage ~# <i>reboot</i>
</pre>

<p>
Oczywiście należy usunąć wszystkie bootowalne nośniki, ponieważ teraz powinien
uruchomić się MacOS.
</p>

<p>
Gdy uruchomiony zostanie MacOS, otwieramy panel sterowania BootX. Jeśli nie
korzystaliśmy z genkernela, wybieramy <c>Options</c> i odznaczamy <c>Used
specified RAM disk</c>. Natomiast jeśli użyliśmy genkernela, musimy upewnić się,
że initrd genkernela jest wybrany zamiast initrd płyty instalacyjnej.
Użytkownicy niekorzystający z genkernela mogą określić teraz partycję roota
- podajemy tutaj wartość odpowiadającą naszemu podziałowi dysku. W zależności od
konfiguracji jądra można dodać inne argumenty.
</p>

<p>
Program BootX można skonfigurować tak, aby automatycznie startował Linuksa.
Jeśli się na to zdecydujemy, najpierw zobaczymy ekran ładowania MacOS, a
następnie, już w trakcie wczytywania systemu, BootX załaduje i wystartuje
Linuksa. Więcej informacji uzyskać można na <uri
link="http://penguinppc.org/bootloaders/bootx/">Stronie domowej BootX</uri>.
</p>

<p>
Następnie jeszcze raz restartujemy komputer, uruchamiamy Linuksa i kontunuujemy
instalację zgodnie z instrukcjami w rozdziale <uri
link="?part=1&amp;chap=11">Finalizowanie instalacji Gentoo</uri>.
</p>

</body>
</section>
<section id="quik">
<title>Alternatywnie: quik</title>
<body>

<p>
quik pozwala na bootowanie z pominięciem MacOS-a na komputerach OldWorld.  Nie
jest to jednak dobrze wspierane i zalecane rozwiązanie, gdyż może spowodować
występowanie licznych dziwactw. Jeśli tylko istnieje taka możliwość, zalecane
jest korzystanie z programu BootX zamiast quik, ze względu na znacznie większą
stabilność i łatwiejszą konfigurację tego pierwszego.
</p>

<p>
Jeśli mimo wszystko zdecydujemy się na to rozwiązanie, postępujemy zgodnie z
poniższymi instrukcjami. Po pierwsze musimy zainstalować quik:
</p>

<pre caption="Emergowanie quik">
# <i>emerge quik</i>
</pre>

<p>
Następnie musimy dokonać jego konfiguracji. Edytujemy plik
<path>/etc/quik.conf</path> ustawiając w nim obraz naszego jądra, które
skopiowaliśmy na partycję boot.
</p>

<pre caption="Konfigurowanie quik.conf">
# Przykładowy plik quik.conf
init-message = "Gentoo 2005.1\n"
partition = 2		<comment># Partycja boot</comment>
root = /dev/hda4
timeout = 30
default = gentoo
image = /vmlinux-2.6.12
	label = gentoo
</pre>

<p>
Plik quik.conf <e>musi</e> znajdować się na tym samym dysku co bootowalny obraz,
ale niekoniecznie na tej samej partycji. Jest jednak wskazane, aby przenieść go
do partycji boot.
</p>

<pre caption="Przenoszenie quik.conf do /boot">
# <i>mv /etc/quik.conf /boot/quik.conf</i>
</pre>

<p>
Teraz musimy ustawić zmienne związane z bootowaniem, aby quik był
uruchamiany. Użyjemy do tego programu <c>nvsetenv</c>. To, jakie zmienne musimy
ustawić, zależy od komputera jaki posiadamy. Zaleca się odszukanie <uri
link="http://penguinppc.org/bootloaders/quik/quirks.php">prawidłowych
wartości quirks</uri> przed rozpoczęciem konfiguracji.
</p>

<pre caption="Ustawianie zmiennych związanych z bootowanie">
# <i>nvsetenv auto-boot true</i> <comment># Ustawiamy "false", aby uruchamiać
# OF; nie wszystkie komputery mogą korzystać z trybu OF</comment>
# <i>nvsetenv output-device video</i> <comment># Wartość wybieramy na podstawie
# powyższej strony quirks</comment>
# <i>nvsetenv input-device kbd</i>
# <i>nvsetenv boot-device scsi/sd@1:0</i> <comment># Dla SCSI</comment>
# <i>nvsetenv boot-device ata/ata-disk@0:0</i> <comment># Dla ATA</comment>
# <i>nvsetenv boot-file /boot/vmlinux-2.6.12 root=/dev/hda4</i>
# <comment>Pierwszy element wskazuje ścieżkę do jądra, drugi do partycji root.
# Dodać tu można wszelkie inne opcje jakie chcemy przekazać do jądra.</comment>
# <i>nvsetenv boot-command boot</i> <comment># Ustawiamy "bye" dla MacOS i
# "boot" dla Linuksa</comment>
</pre>

<note>
Możliwa jest także zmiana zmiennych związanych z bootowaniem z poziomu MacOS-a.
W zależności od posiadanego modelu należy użyć <uri
link="http://penguinppc.org/bootloaders/quik/BootVars.sit.hqx">bootvars</uri>
lub <uri
link="ftp://ftp.apple.com/developer/macosxserver/utilities/SystemDisk2.3.1.smi.bin">.
Apple System Disk</uri>. Warto odwiedzić powyższą stronę quirks w celu
uzyskania szerszych informacji na ten temat.
</note>

<p>
Gdy ustawiliśmy już opcje uruchamiania, musimy upewnić się, że bootowalne obrazy
są poprawnie zainstalowane. Uruchamiamy <c>quik -v -C /boot/quik.conf</c>.
Powinniśmy uzyskać informację, że posiadamy boot block QUIK.
</p>

<note>
Jeśli coś poszło nie tak, możemy zresetować PRAM do ustawień domyślnych poprzez
kombinację <c>command + option + p + r</c>, przed uruchomieniem naszego
komputera. Wyczyści to wartości jakie ustawiliśmy przy pomocy programu nvsetenv
i powinno umożwilić uruchomienie zarówno z bootowalnej płyty MacOS-a jak i z
płyty LiveCD Linuksa.
</note>

<p>
Kolejnym krokiem jest <uri link="#reboot">Rebootowanie systemu</uri>.
</p>

</body>
</section>
<section id="bootcreator">
<title>Alternatywnie: BootCreator</title>
<body>

<impo>
BootCreator stworzy boot menu SmartFirmware napisane dla komputerów Pegasos.
</impo>

<p>
Po pierwsze, upewnijmy się, że mamy zainstalowany program <c>bootcreator</c>:
</p>

<pre caption="Instalowanie programu bootcreator">
# <i>emerge bootcreator</i>
</pre>

<p>
Teraz przekopiujmy plik <path>/etc/bootmenu.example</path> do
<path>/etc/bootmenu</path> i zmodyfikujmy go, aby odpowiadał naszym potrzebom:
</p>

<pre caption="Edycja pliku configuracyjnego programu bootcreator">
# <i>cp /etc/bootmenu.example /etc/bootmenu</i>
# <i>nano -w /etc/bootmenu</i>
</pre>

<p>
Poniżej znajduje się przykładowy plik <path>/etc/bootmenu</path>.
</p>

<pre caption="Plik konfiguracyjny programu bootcreator">
<comment>#
# Przykładowy plik dla programu bootcreator 1.1
#</comment>

[VERSION]
1

[TITLE]
Boot Menu

[SETTINGS]
AbortOnKey = false
Timeout    = 9
Default    = 1

[SECTION]
Local HD -> Morphos      (Normal)
ide:0 boot2.img ramdebug edebugflags="logkprintf"

[SECTION]
Local HD -> Linux 2.6.12 (Normal)
ide:0 linux-2.6.12 video=radeonfb:1024x768@70 root=/dev/hda3

[SECTION]
Local HD -> Genkernel (Normal)
ide:0 kernelz-2.6.12 root=/dev/ram0 real_root=/dev/hda3 init=/linuxrc
</pre>

<p>
Następnie zajmiemy się <path>bootmenu</path>. Musimy skopiować go na partycję
boot, aby SmartFirmware mógł go odczytać. Użyjemy to tego programu
<c>bootcreator</c>:
</p>

<pre caption = "Instalowanie bootmenu">
# <i>bootcreator /etc/bootmenu /boot/menu</i>
</pre>

<note>
W czasie rebootowania musimy upewnić się, że <path>menu</path> jest plikiem,
który zostanie załadowany jako domyślny.
</note>

<p>
Następnym etapem instalacji jest <uri link="#reboot">Rebootowanie systemu</uri>.
</p>


</body>
</section>
<section id="reboot">
<title>Rebootowanie systemu</title>
<subsection>
<body>

<p>
Opuszczamy środowisko chrootowane i odmontowujemy wszystkie partycje, aby
możliwy był czysty restart. Nastepnie używamy komendy <c>reboot</c>.
</p>

<pre caption="Opuszczanie chroot, odmontowywanie partycji i rebootowanie">
# <i>exit</i>
livecd ~# <i>umount /mnt/gentoo/proc /mnt/gentoo/dev /mnt/gentoo</i>
livecd ~# <i>reboot</i>
</pre>

<p>
Gdy nasze nowe Gentoo uruchomi się, kończymy instalację zgodnie z instrukcjami w
rozdziale.<uri link="?part=1&amp;chap=11">Finalizowanie instalacji Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
