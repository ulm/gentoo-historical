<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-mips-kernel.xml,v 1.20 2007/01/31 17:07:09 shadoww Exp $ -->
<!-- :vim:ts=2:sts=2:et:tw=80: -->

<sections>

<version>7.0</version>
<date>2006-08-30</date>

<section>
<title>Strefa czasowa</title>
<body>

<p>
Aby system wiedział gdzie się znajduje, należy najpierw wybrać strefę czasową.
Odszukujemy ją w <path>/usr/share/zoneinfo</path>, a następnie kopiujemy do
<path>/etc/localtime</path>. Należy unikać stref czasowych o nazwie
<path>/usr/share/zoneinfo/Etc/GMT*</path>. Ich nazwy są mylące,
na przykład <path>GMT-8</path> to w rzeczywistości GMT+8.
</p>

<pre caption="Konfiguracja strefy czasowej dla Polski">
# <i>cp /usr/share/zoneinfo/Poland /etc/localtime</i>
</pre>

</body>
</section>

<section>
<title>Instalacja źródeł</title>
<subsection>
<title>Wybór jądra</title>
<body>

<p>
Sercem każdej dystrybucji jest jądro Linux. Stanowi ono interfejs pomiędzy
programami i sprzętem. Gentoo dostarcza użytkownikom różne źródła kerneli. Pełna
lista wraz z opisami znajduje się w <uri
link="/doc/pl/gentoo-kernel.xml">Przewodniku jąder Gentoo</uri>.
</p>

<p>
Dla systemów o architekturze MIPS w drzewie Portage istnieje tylko jedna gałąź
jąder - <c>mips-sources</c>. <!-- Jednak do poprawnego działania poszczególne modele
wymagają różnych zestawów patchy. Poniższa tabela prezentuje, jakich flag USE
należy użyć, aby zainstalowane zostały potrzebne poprawki. Jeśli instalujemy
Gentoo na maszynach Indy, Indigo2 (R4k) lub Challenge S, nie potrzebujemy
dodatkowych patchy. --> Zestaw patchy użytych w tym przypadku różni się od tych
użytych w innych architekturach, ponieważ posiada on dużą liczbę poprawkę
specyficznych dla architektury MIPS.
</p>

<!--<table>
<tr>
  <th>Flaga USE</th>
  <th>Model</th>
</tr>
<tr>
  <ti><c>cobalt</c></ti>
  <ti>Cobalt Qube/RaQ</ti>
</tr>
<tr>
  <ti><c>ip27</c></ti>
  <ti>SGI Origin 200/2000 (1)</ti>
</tr>
<tr>
  <ti><c>ip28</c></ti>
  <ti>SGI Indigo2 Impact (R10000) (1,2)</ti>
</tr>
<tr>
  <ti><c>ip30</c></ti>
  <ti>SGI Octane/Octane2 (1)</ti>
</tr>
</table>-->

<note>
Dodanie flagi <c>USE="-doc"</c> sprawia, że nie zostanie zainstalowana
dokumentacja interfejsu API jądra, co uchroni nas przed instalacją dużej liczby
zależności, które nie są potrzebne na tym etapie.
</note>

<pre caption="Instalowanie źródeł jądra...">
<!-- Done by profile?
<comment>(Zamieniamy flagę cobalt na odpowiednią dla naszego systemu)</comment>
# <i>mkdir /etc/portage</i>
# <i>echo "sys-kernel/mips-sources cobalt" &gt;&gt; /etc/portage/package.use</i>
-->
<comment>(Pobieranie, rozpakowywanie i instalacja źródeł jądra)</comment>
# <i>USE="-doc" emerge mips-sources</i>
</pre>

<impo>
<!--(1)--> Użytkownicy Origin 200/2000, Indigo2 Impact (R10000), Octane/Octane2
i O2, muszą skorzystać z 64-bitowego jądra, aby uruchomić system operacyjny.
Jeśli posiadamy jedną z tych maszyn, konieczne jest <!--przełączenie się na profil
<path>default-linux/mips/mips64/RELEASE</path>, poprzez zmianę dowiązania
symbolicznego <path>/etc/make.profile</path>. Następnie--> wykonanie polecenia
<c>emerge gcc-mips64</c>, aby zainstalować kompilator, który posłuży nam do
przygotowania 64-bitowego kernela.
</impo>

<!--<impo>
(2) Indigo2 Impact stanowi szczególny przypadek, ponieważ wymaga oddzielnego
patcha dla <c>gcc</c>, który jest konieczny do poprawnej kompilacji jądra
IP28. Łatka ta dodaje obsługę flagi CFLAG <c>-mip28-cache-barriers</c>,
wykorzystywanej w czasie budowy kernela, aby mógł on działać w obliczu
charakterystycznych dla tego komputera błędów sprzętowych, powstających w czasie
niebezpiecznych wywołań. Stosowna flaga USE może zostać dodana w pliku
<path>/etc/make.conf</path>. Lepszym rozwiązaniem jest jednak skorzystanie z
profilu <path>default-linux/mips/mips64/ip28/RELEASE</path>, który automatycznie
rozwiązuje ten, a także powyższy (1) problem.
</impo>-->

<pre caption="Instalacja kgcc64...">
<!--<comment>(Zakładamy, że zmienna PORTDIR wskazuje na domyślną lokalizację - /usr/portage)</comment>
# <i>rm /etc/make.profile</i>
# <i>ln -s /usr/portage/profiles/default-linux/mips/mips64/2005.0</i> <comment>(lub .../mips64/ip28/2005.0)</comment>

<comment>(Instalacja 64-bitowego toolchainu jądra)</comment>-->
# <i>emerge gcc-mips64</i>
</pre>

<p>
W katalogu <path>/usr/src</path> powinno znajdować się dowiązanie symboliczne o
nazwie <path>linux</path>, wskazujące na źródła naszego aktualnego kernela. W
poniższym przykładzie jest to dowiązanie do <c>mips-sources-2.6.13.4</c>,
jednak należy pamiętać, że może ono wskazywać na katalog z inną wersją jądra.
</p>

<pre caption="Wyświetlanie dowiązania symbolicznego do źródeł jądra.">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.13.4
</pre>

<p>
Jeśli wynik powyższego polecenia jest nieprawidłowy (np. dowiązanie wskazuje na
inną wersję źródeł niż ta, którą chcemy wykorzystać), zmieniamy dowiązanie,
zanim przejdziemy do wykonania kolejnych czynności:
</p>

<pre caption="Zmienianie dowiązania symbolicznego do źródeł jądra">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.6.13.4 linux</i>
</pre>

<p>
Kolejnym krokiem jest konfiguracja i kompilacja jądra.
</p>

</body>
</subsection>
</section>
<section>
<title>Kompilacja i instalacja jądra</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
W przeszłości opisywaliśmy w jaki sposób przeprowadzić ręcznie całą konfigurację
jądra. Obecnie, gdy liczba różnych systemów MIPS, jakie obsługuje Gentoo,
jest duża, w tym paragrafie przedstawiamy jedynie różne źródła przykładowych
plików konfiguracyjnych jądra.
</p>

</body>
</subsection>
<subsection>
<title>Wykorzystanie plików konfiguracyjnych dostarczonych ze źródłami jądra</title>
<body>

<p>
Dla wielu obsługiwanych systemów przykładowe pliki konfiguracyjne dostarczane są
razem ze źródłami jądra. Poniższa tabela przedstawia polecenia, jakie należy
wykonać, aby skorzystać z przykładowej konfiguracji. Modele, które nie zostały
wymienione w tabeli, nie podsiadają przykładowych plików dostarczanych ze
źródłami jądra.
</p>

<table>
<tr>
  <th>Model</th>
  <th>Polecenie</th>
</tr>
<tr>
  <ti>Cobalt Servers</ti>
  <ti><c>make cobalt_defconfig</c></ti>
</tr>
<tr>
  <ti>Indy, Indigo2 (R4k), Challenge S</ti>
  <ti><c>make ip22_defconfig</c></ti>
</tr>
<tr>
  <ti>Origin 200/2000</ti>
  <ti><c>make ip27_defconfig</c></ti>
</tr>
<tr>
  <ti>Indigo2 Impact (R10k)</ti>
  <ti>
    <c>make ip28_defconfig</c> (wymagane źródła <c>mips-sources-2.6.14.5</c> lub
    nowsze)
  </ti>
</tr>
<tr>
  <ti>O2</ti>
  <ti><c>make ip32_defconfig</c></ti>
</tr>
</table>

</body>
</subsection>

<subsection>
<title>Wykorzystanie konfiguracji jądra uruchominego z nośnika instalacyjnego</title>
<body>

<p>
Wszystkie obrazy instalacyjne Gentoo zawierają konfigurację jądra, dostępną
poprzez plik <path>/proc/config.gz</path>. Można ją wykorzystać w wielu
sytuacjach, szczególnie jeśli wersja jądra, którego chcemy użyć, jest zbliżona
do kernela na nośniku instalacyjnym. Aby wykorzystać tę konfigurację,
wypakowujemy ją przy pomocy programu <c>zcat</c>:
</p>

<pre caption="Wypakowywanie /proc/config.gz do pliku .config">
# <i>zcat /proc/config.gz > .config</i>
</pre>

<impo>
Konfiguracja znajdująca się na nośniku instalacyjnym jest przygotowana dla
obrazu netboot. Oznacza to, że jądro będzie oczekiwać, że odnajdzie obraz
głównego systemu pliku w postaci katalogu dla initramfs lub urządzenia
pseudosieci dla initrd. Pamiętajmy aby, po wykonaniu polecenia <c>make
menuconfig</c>, wyłączyć opcje związane z initramfs na zakładce General Setup.
</impo>

</body>
</subsection>

<subsection>
<title>Baza kompatybilności sprzętu</title>
<body>

<p>
Aby pomóc użytkownikom w wybraniu odpowiednich ustawień, stworzona została baza
kompatybilności sprzętu. Znajdują się tam informacje na temat obsługi różnych
urządzeń MIPS. Ponadto użytkownicy mają możliwość przesyłania konfiguracji
jądra, które działają na określonym sprzęcie. Baza znajduje się pod adresem
<uri>http://stuartl.longlandclan.hopto.org/gentoo/mips</uri>.
</p>

<p>
Jeśli baza kompatybilności okaże się dla nas przydatna, możemy przesłać nasze
uwagi i własne pliki .config - być może będą one pomocne dla innych. Pamiętajmy
jednak, że nie ma żadnej gwarancji, że jakiekolwiek pliki konfiguracyjne pobrane
z tej strony będą działać poprawnie.
</p>

</body>
</subsection>

<subsection>
<title>Dostosowywanie konfiguracji</title>
<body>

<p>
Gdy znajdziemy odpowiednią konfigurację, pobieramy ją do katalogu ze źródłami
jądra i zmieniamy jej nazwę na <path>.config</path>. Możemy teraz użyć polecenia
<c>make oldconfig</c>, aby zaktualizować wszystkie informacje i dostosować
konfigurację przed kompilacją.
</p>

<pre caption="Konfiguracja jądra">
# <i>cd /usr/src/linux</i>
# <i>cp /path/to/example-config .config</i>
# <i>make oldconfig</i>
<comment>(Wciskamy ENTER w odpowiedzi na każde pytanie. Dostosujemy ustawienia później.)</comment>
# <i>make menuconfig</i>
</pre>

<impo>
W sekcji Kernel Hacking znajduje się opcja "Are You Using A Cross
Compiler?". Jej wybranie sprawi, że w plikach Makefiles komendy <c>gcc</c> i
<c>as</c> zostaną poprzedzone przedrostkiem "<c>mips-linux-</c>" (lub
<c>mipsel-linux</c> itp.) w czasie kompilacji jądra. Opcja ta powinna być
wyłączona, nawet jeśli korzystamy z kompilacji skrośnej. Zamiast tego korzystać
będziemy ze zmiennej środowiskowej <c>CROSS_COMPILE</c>, co opisano w następnym
paragrafie.
</impo>

<impo>
Znany jest błąd związany z działaniem JFS i ALSA na komputerach Octane,
obiawiający się błędnym działaniem ALSA-y. Mając na uwadzę, eksperymentalny
charakter JFS na architekturze MIPS, zaleca się unikać używania tego
systemu.
</impo>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilacja i instalacja</title>
<body>

<p>
Po konfiguracji kernela przyszła pora na jego skompilowanie i instalację.
Opuszczamy program konfiguracyjny i rozpoczynamy proces kompilacji:
</p>

<note>
Jeśli korzystamy z 64-bitowego komputera, musimy zadeklarować zmienną
środowiskową <c>CROSS_COMPILE=mips64-unknown-linux-gnu-</c> (lub
<c>mips64el-...</c> dla małej endiany), aby używać 64-bitowego kompilatora.
</note>

<pre caption="Kompilowanie jądra">
<comment>(Tylko jądra serii 2.4)</comment>
# <i>make dep</i>

<comment>(Jądra serii 2.4 i 2.6 - kompilacja natywna)</comment>
# <i>make vmlinux modules modules_install</i>

<comment>(Jądra serii 2.4 i 2.6 - kompilacja skrośna na maszynach docelowych)</comment>
<comment>(Dodajemy mips64-unknown-linux-gnu- stosownie do sprzętu)</comment>
# <i>make vmlinux modules modules_install CROSS_COMPILE=mips64-unknown-linux-gnu-</i>

<comment>(W przypadku kompilacji na innym komputerze (np. o architekturze x86), używamy)</comment>
<comment>(poniższych poleceń, aby skompilować jądro i zainstalować moduły w określonym)</comment>
<comment>(katalogu, w celu ich późniejszego przeniesienia na docelowy komputer.)</comment>
# <i>make vmlinux modules CROSS_COMPILE=mips64-unknown-linux-gnu-</i>
# <i>make modules_install INSTALL_MOD_PATH=/somewhere</i>
</pre>

<impo>
Gdy kompilujemy 64-bitowe jądro dla komputerów Indy, Indigo2 (R4k), Challenge
S i O2, wybieramy <c>vmlinux.32</c> zamiast <c>vmlinux</c>. Jeśli tego nie
zrobimy, komputer nie uruchomi się. Jest tak, ponieważ PROM nie rozpoznaje
formatu ELF64.
</impo>

<pre caption="Wybieranie vmlinux.32 jako celu kompilacji">
# <i>make vmlinux.32</i>
<comment>(Utworzony zostanie plik vmlinux.32 - jest to nasze ostateczne jądro)</comment>
</pre>

<p>
Kiedy jądro skończy się kompilować, kopiujemy jego obraz do katalogu
<path>/boot</path>.
</p>

<note>
Na serwerach Cobalt bootloader oczekuje skompresowanego obrazu jądra. Należy
więc pamiętać o wykonaniu kompresji przy pomocy polecenia <c>gzip -9</c>.
</note>

<pre caption="Instalacja jądra">
# <i>cp vmlinux /boot/kernel-2.6.13.4</i>

<comment>(Serwery Cobalt - kompresja obrazu jądra)</comment>
# <i>gzip -9v /boot/kernel-2.6.13.4</i>
</pre>

</body>
</subsection>
</section>
<section id="kernel_modules">
<title>Instalacja osobnych modułów jądra</title>
<subsection>
<title>Konfigurowanie modułów</title>
<body>

<p>
Do jednego z plików przedstawionych poniżej należy wpisać moduły, które chcemy
ładować automatycznie przy starcie systemu. Można również dodać kilka
dodatkowych opcji dla modułów.
</p>

<ul>
  <li>
  <path>/etc/modules.autoload.d/kernel-2.4</path> - Dla jąder z serii 2.4
  </li>
  <li>
  <path>/etc/modules.autoload.d/kernel-2.6</path> - Dla jąder z serii 2.6
  </li>
  <li><path>/etc/modules.autoload</path> - Wszystkie jądra</li>
</ul>

<p>
Zatem, jeżeli chcemy aby moduł jądra, który jest wspólny dla jąder 2.4 i 2.6,
był ładowany automatycznie, umieszczamy wpis w pliku
<path>/etc/modules.autoload</path>. W innym wypadku umieszczamy go w
<path>kernel-2.4</path> lub <path>kernel-2.6</path>.
</p>

<p>
Aby przejrzeć listę wszystkich dostępnych modułów użyjemy komendy <c>find</c>.
Oczywiście należy zastąpić słowa "&lt;wersja jądra&gt;" numerem wersji świeżo
skompilowanego kernela.
</p>

<pre caption="Wyszukiwanie dostępnych modułów">
# <i>find /lib/modules/&lt;wersja jądra&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Przykładowo, aby automatycznie ładować moduł <c>3c59x.o</c>, edytujemy
plik <path>kernel-2.4</path> lub <path>kernel-2.6</path> i wprowadzamy do niego
nazwę modułu bez rozszerzenia.
</p>

<pre caption="Edycja /etc/modules.autoload.d/kernel-2.4">
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 lub kernel-2.6">
3c59x
</pre>

<p>
Poniższe polecenie jest równoważne:
</p>

<pre caption="Dodawanie modułu - metoda jednolinijkowa">
# <i>echo '3c59x' >> /etc/modules.autoload.d/kernel-2.4</i>
<comment>(albo kernel-2.6 lub /etc/modules.autoload...)</comment>
</pre>

<p>
Kolejny krok to <uri link="?part=1&amp;chap=8">Konfiguracja systemu</uri>.
</p>

</body>
</subsection>
</section>
</sections>
