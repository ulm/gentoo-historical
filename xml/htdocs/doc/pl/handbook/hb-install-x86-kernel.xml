<?xml version='1.0' encoding='UTF-8'?> 
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/Attic/hb-install-x86-kernel.xml,v 1.2 2004/12/31 17:14:15 swift Exp $ -->


<sections>

<version>1.26</version>
<date>2004-12-22</date>

<section>
<title>Strefa czasowa.</title>
<body>

<p>
Aby system wiedział gdzie się znajduje powinieneś najpierw wybrać swoją
strefę czasową. Odszukaj ją w <path>/usr/share/zoneinfo</path>, a następnie
za pomocą <c>ln</c> utwórz do niej symlinka <path>/etc/localtime</path>.
</p>

<pre caption="Konfiguracja strefy czasowej">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Zakładając, że chcesz Poland)</comment>
# <i>ln -sf /usr/share/zoneinfo/Poland /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalacja źródeł.</title>
<subsection>
<title>Wybór jądra.</title>
<body>

<p>
Sercem każdej dystrybucji jest jądro Linux. Stanowi ono interfejs pomiędzy
programami i sprzętem. Gentoo dostarcza użytkownikom
różne źródła kerneli. Pełna lista wraz z opisami znajduje się w
<uri link="/doc/en/gentoo-kernel.xml">Przewodniku jąder Gentoo</uri>.
</p>

<p>
Dla architektury x86 udostępniamy następujące jądra: <c>vanilla-sources</c>
(domyślne źródła serii 2.4, rozwijane przez developerów kernela Linuksa),
<c>gentoo-sources</c> (źródła serii 2.4 z nałożonymi poprawkami zwiększającymi
wydajność), <c>gentoo-dev-sources</c> (kernel 2.6 z poprawkami zwiększającymi
wydajność), <c>development-sources</c> ("waniliowe" źródła kernela 2.6) ... i
wiele innych.
</p>

<p>
Jeśli przeprowadzasz instalację bez dostępu do sieci będziesz zmuszony
ograniczyć swoje zainteresowanie tylko do źródeł nagranych na płytę. W wydaniu
2004.3 są to:
</p>

<ul>
  <li>gentoo-sources</li>
  <li>vanilla-sources</li>
  <li>gentoo-dev-sources</li>
  <li>development-sources</li>
</ul>

<p>
Wybierzmy któreś z dostępnych źródeł i zainstalujmy je przy pomocy
<c>emerge</c>:
</p>

<pre caption="Instalowanie źródeł jądra">
# <i>emerge gentoo-sources</i>
</pre>

<p>
W katalogu <path>/usr/src</path> powinieneś mieć mniej więcej taki symlink, o
nazwie <path>linux</path>, wskazujący na źródła Twojego aktualnego kernela:
</p>

<pre caption="Podgląd symlinka do źródeł kernela">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux-&gt;linux-2.4.26-gentoo-r9
</pre>

<p>
Jeśli informacje z symlinka nie pokrywają się z rzeczywistością (np. wskazuje na
inne niż Twoje źródła kernela) to będziesz musiał go poprawić zanim przejdziesz
do dalszych części tego dokumentu.
</p>

<pre caption="Zmiana dowiązania symbolicznego do źródeł jądra">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.4.26-gentoo-r9 linux</i>
</pre>

<p>
Pora na skonfigurowanie i skompilowanie źródeł jądra. Możesz użyć do tego
programu <c>genkernel</c>, który zbuduje uniwersalne jądro, takie jak np.
to używane przez LiveCD. Możesz też przeprowadzić cały proces ręcznie i lepiej
dostostosować kernel do swoich potrzeb. Zaczniemy od omówienia tej drugiej,
znacznie lepszej metody.
</p>

<p>
Jeśli zdecydowałeś się na ręczną konfigurację kernela przejdź do paragrafu <uri
link="#manual">Domyślnie: Ręczna konfiguracja</uri>. Jeżeli natomiast
zdecydowałeś się
złożyć swoją przyszłą w ręce programu <c>genkernel</c> powinieneś przeczytać
<uri link="#genkernel">Alternatywnie: Genkernel</uri>.
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Domyślnie: Ręczna konfiguracja.</title>
<subsection>
<title>Wprowadzenie.</title>
<body>

<p>
Ręczna konfiguracja kernela jest często postrzegana jako najtrudniejsza czynność
jaką użytkownicy Linuksa muszą wykonywać. Nie jest to prawdą, po skompilowaniu
kilku kerneli zapomnicie, że kiedykowiek uważaliście to za trudne zadanie.
</p>

<p>
Nie sposób jednak zaprzeczyć, że należy dobrze znać swój komputer, aby móc
prawidłowo skonfigurować kernel. Większość informacji o maszynie znajdziemy
przeglądając zawartość <path>/proc/pci</path> (lub przy użyciu polecenia
<c>lspci</c> - jeśli działa). Dodatkowe informacje o tym co warto włączyć w swój
kernel można uzyskać dzięki poleceniu <c>lsmod</c>, które pokaże listę
modułów jakie załadowało LiveCD.
</p>

<p>
Kiedy już zbierzemy wszystkie informacje przechodzimy do katalogu ze
źródłami i wpisujemy polecenie <c>make menuconfig</c>. Uruchomi się menu
konfiguracyjne oparte na ncurses.
</p>

<pre caption="Uruchamianie menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Zobaczymy okienko z listą sekcji, na które podzielono cały proces konfiguracji.
Zaczniemy od omówienia opcji, które musisz aktywować, aby zapewnić prawidłowe
działanie Gentoo.
</p>

</body>
</subsection>
<subsection>
<title>Zaznaczanie wymaganych ustawień.</title>
<body>

<p>
Po pierwsze włącz możliwość korzystania z rozwojowych i eksperymentalnych
fragmentów kodu jądra. Jeśli tego nie zrobisz to nawet nie zobaczysz kilku
bardzo ważnych opcji.
</p>

<pre caption="Wybieranie opcji experimental code/drivers">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
Upewnij się, że Twój kernel zostanie skompilowany dla właściwej rodziny
procesorów:
</p>

<pre caption="Wybór rodziny procesorów">
Processor type and features ---&gt;
  <comment>(Change according to your system)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

<p>
Następnie przejdź do <c>File Systems</c> i wybierz wsparcie dla systemów plików,
których zamierzasz używać. Jeśli tego zaniedbasz Gentoo nie będzie w stanie
zamontować partycji, a czasem nawet się nie uruchomi. Pamiętaj również, aby
włączać te sterowniki na stałe do jądra, broń Boże nie kompiluj ich jako
modułów. Przy okazji zaznacz też <c>Virtual memory</c>, <c>/proc file system</c>
i <c>/dev file system</c> + <c>Automatically mount at boot</c>:
</p>

<pre caption="Wybór potrzebnych systemów plików">
<comment>(dla kerneli 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(dla kerneli 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] /dev file system support (OBSOLETE)
    [*]   Automatically mount at boot
    [*] Virtual memory file system support (former shm fs)

<comment>(Wybierz jedną lub kilka z tych opcji zależnie od używanych systemów
plików.)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Jeśli Twój BIOS nie radzi sobie z dużymi dyskami i masz przy pomocy jumpera
ograniczony maksymalny rozmiar napędu na pewno zainteresuje Cię możliwość używania
całego dostępnego miejsca dzięki następującej opcji:
</p>

<pre caption="Wybieranie wsparcia dla Auto-Geometry Resizing">
<comment>(dla kerneli 2.4.x)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

<p>
Jeśli używasz PPPoE do łączenia się z Internetem, lub gdy używasz modemu dial-up
będziesz musiał włączyć następujące opcje:
</p>

<pre caption="Sterowniki niezbędne dla użytkowników PPPoE">
<comment>(dla kerneli 2.4.x)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports

<comment>(dla kerneli 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Obie opcje dotyczące kompresji nie są wprawdzie wymagane, ale również nie
zaszkodzą naszemu systemowi, podobnie zresztą jak opcja <c>PPP over
Ethernet</c>, która jest przydatna tylko gdy skonfigurujesz <c>rp-pppoe</c> do
pracy w trybie jądra PPPoE.
</p>

<p>
Nie zapomnij wkompilować sterownika dla swojej karty sieciowej.
</p>

<p>
Jeśli masz procesor Intela ze wspraciem dla HyperThreading (tm), lub masz system
wieloprocesorowy musisz aktywować "Symmetric multi-processing support":
</p>

<pre caption="Aktywowanie wsparcia dla SMP">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<p>
Jeśli posiadasz urządzenia wejściowe USB (np. klawiaturę lub myszkę) dodaj sterowniki
również dla nich:
</p>

<pre caption="Aktywowanie wsparcia dla urządzeń wejściowych używających USB">
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

<p>
Użytkownicy PCMCIA <e>nie</e> powinni korzystać ze sterowników PCMCIA z kernela
2.4. Nowsze sterowniki są dostępne w pakiecie <c>pcmcia-cs</c>, który
zainstalujemy sobie później. Podobnych problemów nie ma ze sterownikami PCMCIA
jąder serii 2.6.
</p>

<p>
Kiedy skończysz konfigurować swój kernel przejdź do paragrafu
<uri link="#compiling">Kompilacja i instalacja</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilacja i instalacja.</title>
<body>

<p>
Po skonfigurowaniu kernela przyszła pora na jego skompilowanie i
instalację. Opuść program konfiguracyjny i wpisz <c>make dep &amp;&amp; make
bzImage modules modules_install</c>:
</p>

<pre caption="Kompilowanie kernela">
<comment>(dla kerneli 2.4.x)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(dla kerneli 2.6.x)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Kiedy jądro skończy się kompilować przekopiuj jego obraz do katalogu
<path>/boot</path>. W przykładzie zakładamy, że właśnie zostały skompilowane
źródła <c>gentoo-sources</c> w wersji 2.4.26. Możesz używać dowolnie wybranej
przez siebie nazwy obrazu. Zapamiętaj ją, lub zapisz sobie - będzie Ci potrzebna
przy konfiguracji bootloadera.
</p>

<pre caption="Instalowanie kernela">
# <i>cp arch/i386/boot/bzImage /boot/kernel-2.4.26-gentoo-r9</i>
# <i>cp System.map /boot/System.map-2.4.26-gentoo-r9</i>
</pre>

<p>
Zwykle mądrą decyzją jest skopiowanie tam również pliku konfiguracyjnego, który
posłużył do zbudowania jądra.
</p>

<pre caption="Tworzenie kopii zapasowej konfiguracji jądra">
# <i>cp .config /boot/config-2.4.26-gentoo-r9</i>
</pre>

<p>
Kiedy skończysz przejdź do paragrafu <uri link="#kernel_modules">Instalacja
osobnych modułów jądra</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternatywnie: Użycie genkernel.</title>
<body>

<p>
Paragraf jest przeznaczony dla użytkowników, którzy zdecydowali się użyć
programu <c>genkernel</c> do skonfigurowania jądra.
</p>

<p>
Po zainstalowaniu źródeł wypada je skonfigurować. Zrobimy to automatycznie przy
pomocy
programu <c>genkernel</c>. <c>genkernel</c> robi to dokładnie w ten sam sposób w
jaki jest konfigurowany kernel LiveCD. Oznacza to, że kiedy użyjesz
<c>genkernel</c> do budowy jądra Twój system będzie musiał wykrywać dostępny
sprzęt przy każdym uruchomieniu komputera, tak jak na LiveCD. Ponieważ genkernel
nie wymaga od użytkownika żadnych ręcznych poprawek w konfiguracji jest
doskonałym rozwiązaniem dla tych wszystkich, którzy nie są najmocniejsi w
samodzielnym kompilowaniu jądra.
</p>

<p>
Zanim jednak zdradzimy jak używa się tego cudownego programu musimy wytłumaczyć
jak go zainstalować:
</p>

<pre caption="Emergowanie genkernela">
# <i>emerge genkernel</i>
</pre>

<p>
Źródła skompilujemy przy użyciu polecenia <c>genkernel all</c>. Kompilacja
zajmie całe wieki, ponieważ <c>genkernel</c> tworzy uniwersalne jądro,
zawierające wsparcie dla niemal całego dostępnego sprzętu.
</p>

<p>
Jeśli na partycji boot założyłeś system plików inny niż ext2 i ext3 będziesz
musiał dodatkowo wprowadzić kilka ręcznych poprawek do konfiguracji genkernela.
Dokonuje się tego wydając najpierw polecenie <c>genkernel --menuconfig all</c>,
a następnie dopisując wsparcie dla sterowników <e>w</e> kernelu (na stałe, nie
jako moduły).
</p>

<pre caption="Uruchamianie genkernela">
# <i>genkernel all</i>
</pre>

<p>
W toku tego procesu powstanie właściwy plik jądra, zwany dalej obrazem,
ogromna rzesza modułów oraz plik initrd. Nazwy plików kernela i initrd będą
potrzebne przy konfiguracji bootloadera do prawidłowego wypełnienia jego pliku
konfiguracyjnego, więc warto je sobie zapisać. Przy następnym uruchumieniu
komputera zostanie najpierw wykonany plik initrd, który wykryje cały dostępny
sprzęt i wczyta odpowiednie moduły, a następnie uruchomi się właściwy system.
</p>

<pre caption="Sprawdzanie nazwy utworzonych obrazów kernela i initrd">
# <i>ls /boot/kernel* /boot/initrd*</i>
</pre>

<p>
Następna czynność jeszcze bardziej upodobni nasz system do tego dostępnego na
LiveCD, zemergujemy sobie <c>coldplug</c>. Podczas gdy initrd automatycznie
wykrywa sprzęt, co jest niezbędne do uruchomienia systemu, <c>coldplug</c>
będzie wykrywał wszystko inne. Aby zemergować i uaktywnić <c>coldplug</c> wpisz:
</p>

<pre caption="Emergowanie i uruchamianie coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug default</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Instalacja osobnych modułów jądra.</title>
<subsection>
<title>Dodatkowe moduły.</title>
<body>

<p>
Ponadto powinieneś zemergować również wszystkie związane ze swoim sprzętem
ebuildy. Oto lista wszystkich dostępnych modułów:
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="4in"/>
<tcolumn width="2in"/>
<tr>
  <th>Ebuild</th>
  <th>Powód</th>
  <th>Polecenie</th>
</tr>
<tr>
  <ti>nvidia-kernel</ti>
  <ti>Sterowniki dla kart nvidia</ti>
  <ti><c>emerge nvidia-glx</c></ti>
</tr>
<tr>
  <ti>nforce-audio</ti>
  <ti>Sterowniki do kart dzwiękowych zintegrowanych z płytami NVIDIA NForce(2)</ti>
  <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
  <ti>e100</ti>
  <ti>Intel e100 Fast Ethernet Adapters</ti>
  <ti><c>emerge e100</c></ti>
</tr>
<tr>
  <ti>e1000</ti>
  <ti>Intel e1000 Gigabit Ethernet Adapters</ti>
  <ti><c>emerge e1000</c></ti>
</tr>
<tr>
  <ti>emu10k1</ti>
  <ti>Wsparcie dla Creative Sound Blaster Live!/Audigy (tylko dla kerneli 2.4)</ti>
  <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
  <ti>ati-drivers</ti>
  <ti>Sterowniki do kart ATI dla xorg-x11</ti>
  <ti><c>emerge ati-drivers</c></ti>
</tr>
</table>

<p>
Zainstalowanie któregoś z tych pakietów może wiązać się z potrzebą wgrania
sporej ilości jego zależności. Aby dowiedzieć się jakie pakiety zostaną
zainstalowane jako zależności wybranego ebuildu użyj <c>emerge --pretend</c>. Na
przykład dla pakietu <c>emu10k1</c> będzie to:
</p>

<pre caption="Pełna lista pakietów do zainstalowania">
# <i>emerge --pretend emu10k1</i>
</pre>

<p>
Jeśli nie podoba Ci się lista zależności do zainstalowania użyj <c>emerge
--pretend --verbose</c> i sprawdź czy nie da się jakoś jej zredukować ujmując
niektóre flagi USE.
</p>

<pre caption="Przegląd użycia flag USE">
# <i>emerge --pretend --verbose emu10k1</i>
<comment>...</comment>
[ebuild  N    ] media-sound/aumix-2.8  +gpm +nls +gtk +gnome +alsa -gtk2
</pre>

<p>
W powyższym przykładzie widzimy, że jedna z zależności pakietu <c>emu10k1</c>
(<c>aumix</c>) ma włączone flagi <c>gtk</c> i <c>gnome</c>, co sprawia, że przy
instalacji <c>emu10k1</c> będziesz zmuszony zainstalować również oba te pakiety. 
</p>

<p>
Jeśli chcesz się pozbyć z listy niechcianych zależności musisz wyłączyć odpowiednie
flagi USE, na przykład:
</p>

<pre caption="Emergowanie emu10k1 przy wyłączeniu wszystkich flag">
# <i>USE="-gpm -nls -gtk -gnome -alsa" emerge --pretend emu10k1</i>
</pre>

<p>
Jeśli rezultat Cię satysfakcjonuje usuń parametr <c>--pretend</c> i zainstaluj
<c>emu10k1</c>.
</p>

</body>
</subsection>
<subsection>
<title>Konfigurowanie modułów.</title>
<body>

<p>
Lista modułów, które chcesz aby były automatycznie ładowane przy starcie systemu
powinna znajdować się w pliku <path>/etc/modules.autoload.d/kernel-2.4</path>
(lub <path>kernel-2.6</path>). Czasem jeśli chcesz możesz dodać kilka opcji dla
modułów.
</p>

<p>
Żeby przejrzeć listę wszystkich dostępnych użyj komendy <c>find</c>. Oczywiście
powinieneś zastąpić słowa "&lt;wersja jądra&gt;" numerem świeżo skompilowanego
kernela.
</p>

<pre caption="Znajdowanie dostępnych modułów">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Na przykład aby automatycznie ładować do pamięci moduł <c>3c59x.o</c> wyedytuj
plik <path>kernel-2.4</path> lub <path>kernel-2.6</path> i wprowadź do niego
nazwę tego modułu.
</p>

<pre caption="Edycja /etc/modules.autoload.d/kernel-2.4">
<comment>(przykład dla kerneli 2.4)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 lub kernel-2.6">
3c59x
</pre>

<p>
Następnie uruchom <c>modules-update</c>, aby potwierdzić wprowadzone do pliku
<path>/etc/modules.conf</path> zmiany:
</p>

<pre caption="Uruchamianie modules-update">
# <i>modules-update</i>
</pre>

<p>
Kiedy skończysz przejdź do rozdziału <uri link="?part=1&amp;chap=8">Konfiguracja
systemu</uri>.
</p>

</body>
</subsection>
</section>
</sections>
