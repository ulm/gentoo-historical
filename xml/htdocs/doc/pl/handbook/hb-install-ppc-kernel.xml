<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-ppc-kernel.xml,v 1.4 2005/06/10 20:52:13 fox2mike Exp $ -->

<!-- Orig revision: 1.28 -->
<!-- Translator: rane <rane@gentoo.pl> -->
<!-- Title: Konfiguracja jądra dla PPC -->
<!-- Status: Release -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<sections>

<version>2.7</version>
<date>2005-06-09</date>

<section>
<title>Strefa czasowa</title>
<body>

<p>
Aby system wiedział gdzie się znajduje powinieneś najpierw wybrać swoją
strefę czasową. Odszukaj ją w <path>/usr/share/zoneinfo</path>, a następnie
za pomocą <c>ln</c> utwórz do niej symlinka <path>/etc/localtime</path>.
</p>

<pre caption="Konfiguracja strefy czasowej">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Zakładając, że chcesz Poland)</comment>
# <i>ln -sf /usr/share/zoneinfo/Poland /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalacja źródeł.</title>
<subsection>
<title>Wybór jądra.</title>
<body>

<p>
Sercem każdej dystrybucji jest jądro Linux. Stanowi ono interfejs pomiędzy
programami i sprzętem. Gentoo dostarcza użytkownikom
różne źródła kerneli. Pełna lista wraz z opisami znajduje się w
<uri link="/doc/en/gentoo-kernel.xml">Przewodniku jąder Gentoo</uri>.
</p>

<p>
Dla architektury PPC mamy do wyboru jądra <c>vanilla-sources</c> i
<c>gentoo-sources</c> (oba serii 2.6). Dla maszyn Pegasos oferujemy <c>pegasos-dev-sources</c>,
jądro serii 2.6 z nałożonym specjalnym zestawem poprawek dla tego sprzętu.
Wybierzmy sobie któreś i zainstalujmy:
</p>

<pre caption="Instalowanie źródeł jądra">
# <i>emerge gentoo-sources</i>
</pre>

<note>
Źródła dla PowerPC są oparte o jądro 2.6.10-kernel, na które nałożone kilka
poprawek zawartych w jądrach 2.6.11, którego nie można używać ponieważ powoduje
różne problemy na komputerach PowerPC.
</note>

<p>
W katalogu <path>/usr/src</path> powinieneś mieć mniej więcej taki jak poniższy
symlink, o nazwie <path>linux</path>, wskazujący na źródła jądra. W przykładzie
zakładamy, że źródła jądra zostały zainstalowane jako
<c>gentoo-sources-2.6.10-r8</c>:
</p>

<pre caption="Podgląd symlinka do źródeł kernela">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           22  Mar 18 16:23 /usr/src/linux -&gt;linux-2.6.10-gentoo-r8
</pre>

<p>
Jeśli informacje z symlinka nie pokrywają się z rzeczywistością (np. wskazuje na
inne źródła jądra) to będziemy musieli go poprawić przed przejściem
do dalszych części tego dokumentu. Należy również zwrócić uwagę, że
<c>linux-2.6.10-gentoo-r8</c> to tylko przykład.
</p>

<pre caption="Zmiana dowiązania symbolicznego do źródeł jądra">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.6.10-gentoo-r8 linux</i>
</pre>

<p>
Pora na skonfigurowanie i skompilowanie źródeł jądra. Możesz użyć do tego
programu <c>genkernel</c>, który zbuduje uniwersalne jądro, takie jak np.
to używane przez płyty instalacyjne. Możesz też przeprowadzić cały proces
ręcznie i lepiej dostostosować kernel do swoich potrzeb. Zaczniemy od omówienia
tej drugiej, znacznie lepszej metody.
</p>

<p>
Aby ręcznie skonfigurować jądro należy przejść do paragrafu <uri	
link="#manual">Ręczna konfiguracja</uri>, opis pracy z  <c>genkernelem</c>
opisaliśmy w paragrafie <uri link="#genkernel">Alternatywnie: użycie
genkernel</uri>
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Ręczna konfiguracja.</title>
<subsection>
<title>Wprowadzenie.</title>
<body>

<p>
Ręczna konfiguracja kernela jest często postrzegana jako najtrudniejsza czynność
jaką użytkownicy Linuksa muszą wykonywać. Nie jest to prawdą, po skompilowaniu
kilku kerneli zapomnicie, że kiedykowiek uważaliście to za trudne zadanie.
</p>

<p>
Nie sposób jednak zaprzeczyć, że należy dobrze znać swój komputer, aby móc
prawidłowo skonfigurować jądro. Większość informacji można zdobyć poprzez
zemergowanie pakietu pciutils (<c>emerge pciutils</c>) zawierającego program
<c>lspci</c>. Dzięki temu będzie możliwe używanie <c>lspci</c> wewnątrz
chrootowanego środowiska. Podczas pracy z tym programem możne bezpieczenie
zignorować wszelkie ostrzeżenia związane z <e>pcilib</e> (jak np.
"pcilib: cannot open /sys/bus/pci/devices). Ponadto można również uruchomić
<c>lspci</c> poza środowiskiem chroot. Powinno dać to taki sam efekt. Dodatkowe
informacje o sterownikach, które należy włączyć do jądra można uzyskać dzięki
poleceniu <c>lsmod</c>, które pokaże listę modułów jakie załadował system płyty
instalacyjnej.
</p>

<p>
Kiedy już zbierzemy wszystkie informacje przechodzimy do katalogu ze
źródłami i wpisujemy polecenie <c>make menuconfig</c>. Uruchomi się menu
konfiguracyjne oparte na ncurses.
</p>

<pre caption="Uruchamianie menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Zobaczymy okienko z listą sekcji, na które podzielono cały proces konfiguracji.
Zaczniemy od omówienia opcji, które musisz aktywować, aby zapewnić prawidłowe
działanie Gentoo.
</p>

</body>
</subsection>
<subsection>
<title>Zaznaczanie wymaganych ustawień.</title>
<body>

<p>
Po pierwsze włącz możliwość korzystania z rozwojowych i eksperymentalnych
fragmentów kodu jądra. Jeśli tego nie zrobisz to nawet nie zobaczysz kilku
bardzo ważnych opcji.
</p>

<pre caption="Wybieranie opcji experimental code/drivers oraz generalnych
ustawień">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
General setup --->	
  [*] Support for hot-pluggable devices
</pre>

<p>
Następnie przejdź do <c>File Systems</c> i wybierz wsparcie dla systemów plików,
których zamierzasz używać. Jeśli tego zaniedbasz Gentoo nie będzie w stanie
zamontować partycji, a czasem nawet się nie uruchomi. Pamiętaj również, aby
włączać te sterowniki na stałe do jądra, broń Boże nie kompiluj ich jako
modułów. Przy okazji zaznacz też <c>Virtual memory</c> i <c>/proc file
system</c>. <e>Nie należy</e> włączać opcji <c>/dev file system</c>.
</p>

<pre caption="Wybór potrzebnych systemów plików">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [ ] /dev file system support (OBSOLETE)
    [*] Virtual memory file system support (former shm fs)

<comment>(Wybierz jedną lub kilka z tych opcji zależnie od używanych systemów plików.)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Jeśli używasz PPPoE do łączenia się z Internetem, lub gdy używasz modemu dial-up
będziesz musiał włączyć następujące opcje:
</p>

<pre caption="Sterowniki niezbędne dla użytkowników PPPoE">
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Obie opcje dotyczące kompresji nie są wprawdzie wymagane, ale również nie
zaszkodzą naszemu systemowi, podobnie zresztą jak opcja <c>PPP over
Ethernet</c>, która jest przydatna tylko gdy skonfigurujesz <c>rp-pppoe</c> do
pracy w trybie jądra PPPoE.
</p>

<p>
Nie zapomnij wkompilować sterownika dla swojej karty sieciowej.
</p>

<p>
Użytkownicy komputerów OldWorld będą potrzebowali wsparcia dla HFS, aby skopiować
skompilowane jądro na partycję MacOS.
</p>

<pre caption="Aktywowanie wsparcia dla HFS">
File Systems ---&gt;
  [*] HFS Support
</pre>

<p>	
Wywłaszczanie w jądrze wciąż działa niestabilnie na platformie PPC i może spowodować błędy przy kompilacji, czy naruszenia ochrony pamięci. <e>Nie radzimy</e> korzystać z tej opcji. 
</p>	
 	 	
<pre caption="Upewnianie się, że wyłączono wywłaszczanie">	
Platform options ---&gt;	
  [ ] Preemptible Kernel	
</pre>

<p>
Po ukończeniu konfigurowania jądra należy przejść do paragrafu
<uri link="#compiling">Kompilacja i instalacja</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilacja i instalacja.</title>
<body>

<p>
Po skonfigurowaniu kernela przyszła pora na jego skompilowanie i
instalację. Opuść program konfiguracyjny i wpisz następujące polecenia:
</p>

<pre caption="Kompilowanie kernela.">
# <i>make all &amp;&amp; make modules_install</i>
</pre>

<p>
Kiedy jądro skończy się kompilować przekopiuj jego obraz do katalogu
<path>/boot (należy upewnić się, że jest to poprawnie montowane, zwłaszcza na
Pegasosie)</path>.
</p>

<pre caption="Instalowanie kernela">
<comment>Zastąp 2.6.10 wersją swojego jądra</comment>
(Apple/IBM)  # <i>cp vmlinux /boot/kernel-2.6.10</i>
(Pegasos)    # <i>cp arch/ppc/boot/images/zImage.chrp /boot/kernel-2.6.10</i>
</pre>

<p>
Zwykle mądrą decyzją jest skopiowanie tam również pliku konfiguracyjnego, który
posłużył do zbudowania jądra.
</p>

<pre caption="Tworzenie kopii zapasowej konfiguracji jądra">
# <i>cp .config /boot/config-2.6.10-gentoo-r8</i>
</pre>

<p>
Kiedy skończysz przejdź do paragrafu <uri link="#kernel_modules">Instalacja
osobnych modułów jądra</uri>.
</p>

</body>
</subsection>
</section>
<section id="kernel_modules">
<title>Instalacja osobnych modułów jądra.</title>
<subsection>
<title>Konfigurowanie modułów.</title>
<body>

<p>
Lista modułów, które chcesz by były automatycznie ładowane przy starcie systemu
powinna znajdować się w pliku <path>/etc/modules.autoload.d/kernel-2.4</path>
(lub <path>kernel-2.6</path>). Czasem jeśli chcesz możesz dodać kilka opcji dla
modułów.
</p>

<p>
Żeby przejrzeć listę wszystkich dostępnych użyj komendy <c>find</c>. Oczywiście
powinieneś zastąpić słowa "&lt;wersja jądra&gt;" numerem świeżo skompilowanego
kernela.
</p>

<pre caption="Znajdowanie dostępnych modułów">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Na przykład, aby automatycznie ładować do pamięci moduł <c>3c59x.o</c> wyedytuj
plik <path>kernel-2.4</path> lub <path>kernel-2.6</path> i wprowadź do niego
nazwę tego modułu.
</p>

<pre caption="Edycja /etc/modules.autoload.d/kernel-2.4">
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
3c59x
</pre>

<p>
Następnie uruchom <c>modules-update</c>, aby potwierdzić wprowadzone do pliku
<path>/etc/modules.conf</path> zmiany:
</p>

<pre caption="Uruchamianie modules-update">
# <i>modules-update</i>
</pre>

<p>
Od wersji 2004.3 zalecamy używanie udev zamiast devfs. Żeby Twój system działał
musisz zatem emergować udev:
</p>

<pre caption="Emerging udev">
# <i>emerge udev</i>
</pre>

<p>
Kiedy skończysz przejdź do rozdziału <uri link="?part=1&amp;chap=8">Konfiguracja
systemu</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternatywnie: użycie genkernel</title>
<body>

<p>
W tym paragrafie omawiamy proces konfiguracji jądra przy pomocy programu
<c>genkernel</c>.
</p>

<p>
Po zainstalowaniu źródeł należy je skonfigurować. Zrobimy to automatycznie przy
pomocy programu <c>genkernel</c>, który wykonuje cały proces dokładnie w ten sam
sposób w jaki jest konfigurowane jądro na płycie instalacyjnej. Konsekwencją
wyboru genkernela jest to, że system będzie zmuszony do wykrywania dostępnego
sprzętu przy każdym uruchomieniu komputera. W związku z tym, że genkernel nie
wymaga od użytkownika żadnych ręcznych poprawek w konfiguracji, jest doskonałym
rozwiązaniem dla tych wszystkich, którzy nie są najmocniejsi w samodzielnym
kompilowaniu jądra.
</p>

<p>
Zanim jednak zdradzimy jak używa się tego cudownego programu musimy wytłumaczyć
jak go zainstalować:
</p>

<pre caption="Emergowanie genkernela">
# <i>emerge genkernel</i>
</pre>

<p>
Następnie kopiujemy konfigurację jądra z płyty instalacyjnej do miejsca, w
którym znajdzie ją i wykorzysta genkernel:
</p>

<pre caption="Kopiowanie konfiguracji jądra z płyty instalacyjnej">
# <i>zcat /proc/config.gz > /usr/share/genkernel/ppc/kernel-config-2.6</i>
</pre>

<p>
Źródła skompilujemy przy pomocy polecenia <c>genkernel --udev all</c>.
Kompilowanie zajmie mnóstwo czasu, ponieważ <c>genkernel</c> zawiera niemal
wszystkie dostępne sterowniki.
</p>

<p>
Jeśli partycja rozruchowa została sformatowana w innym niż ext2 lub ext3
systemie plików należy ręcznie dodać potrzebne dla nich sterowniki, wybiera się
je przy pomocy menu <c>genkernel --menuconfig all</c>. Sterowniki te muszą być
wkompilowane w jądro <e>na stałe</e>, nie można dodawać ich w postaci modułów.
Użytkownicy EVMS2 lub LVM2 powinni dodać również <c>--evms2</c> lub
<c>--lvm2</c> do listy argumentów.
</p>

<pre caption="Uruchamianie genkernel">
# <i>genkernel --udev all</i>
</pre>

<p>
W toku tego procesu powstanie właściwy plik jądra, initrd (initial root disk)
oraz ogromna rzesza modułów. Nazwy plików jądra i initrd będą potrzebne przy
konfiguracji bootloadera do prawidłowego wypełnienia jego pliku
konfiguracyjnego, więc warto je sobie zapisać. Przy następnym uruchumieniu
komputera zostanie najpierw wykonany plik initrd, który wykryje cały dostępny
sprzęt i wczyta odpowiednie moduły, a następnie uruchomi się właściwy system.
</p>

<pre caption="Sprawdzanie nazw utworzonych plików jądra">
# <i>ls /boot/kernel* /boot/initrd*</i>
</pre>

<p>
Następna czynność jeszcze bardziej upodobni nasz system do tego znajdującego się
na płycie instalacyjnej. Zemergujemy <c>coldplug</c>, który działa na podobnej
zasadzie jak initrd, wykrywający przy starcie wszystkie niezbędne do
uruchomienia systemu urządzenia, z tym, że zajmuje się wszystkimi ich typami.
Aby zemergować i uruchomić <c>coldplug</c> należy wykonać następujące
polecenia:
</p>

<pre caption="Emergowanie i uruchamianie coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Jeśli system ma reagować na zdarzenia hotplug trzeba mu najpierw zainstalować i
skonfigurować ten program:
</p>

<pre caption="Emergowanie i włączanie hotplug">
# <i>emerge hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

<p>
Kolejny etap instalacji to <uri link="?part=1&amp;chap=8">Konfigurowanie
systemu</uri>.
</p>
</body>
</section>
</sections>
