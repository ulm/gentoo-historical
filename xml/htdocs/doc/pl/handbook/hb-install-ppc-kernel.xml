<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-ppc-kernel.xml,v 1.11 2005/08/15 04:29:22 rane Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>

<version>2.12</version>
<date>2005-08-12</date>

<section>
<title>Strefa czasowa</title>
<body>

<p>
Aby system wiedział gdzie się znajduje powinieneś najpierw wybrać swoją
strefę czasową. Odszukaj ją w <path>/usr/share/zoneinfo</path>, a następnie
za pomocą <c>ln</c> utwórz do niej symlinka <path>/etc/localtime</path>.
</p>

<pre caption="Konfiguracja strefy czasowej">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Zakładając, że chcesz Poland)</comment>
# <i>ln -sf /usr/share/zoneinfo/Poland /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalacja źródeł</title>
<subsection>
<title>Wybór jądra</title>
<body>

<p>
Sercem każdej dystrybucji jest jądro Linux. Stanowi ono interfejs pomiędzy
programami i sprzętem. Gentoo dostarcza użytkownikom różne źródła kerneli. Pełna
lista wraz z opisami znajduje się w <uri
link="/doc/pl/gentoo-kernel.xml">Przewodniku jąder Gentoo</uri>.
</p>

<p>
Dla architektury PPC polecamy jądra <c>vanilla-sources</c> i
<c>gentoo-sources</c> (oba serii 2.6). Druga opcja jest dobra dla instalacji bez
dostępu do sieci. Wybierzmy któreś i zainstalujmy:
</p>

<pre caption="Instalowanie źródeł jądra">
# <i>emerge gentoo-sources</i>
</pre>

<note>
W momencie wydawania Gentoo 2005.1 źródła te były w wersjach:
<c>gentoo-sources-2.6.12-r4</c> i <c>vanilla-sources-2.6.12.2</c>.
</note>

<p>
W katalogu <path>/usr/src</path> powinieneś mieć mniej więcej taki jak poniższy
symlink, o nazwie <path>linux</path>, wskazujący na źródła jądra. W przykładzie
zakładamy, że źródła jądra zostały zainstalowane
jako<c>gentoo-sources-2.6.12-r4</c>:
</p>

<pre caption="Podgląd symlinka do źródeł kernela">
# <i>ls -l /usr/src/linux</i> 
lrwxrwxrwx    1 root     root           22  Mar 18 16:23 /usr/src/linux -&gt; linux-2.6.12-gentoo-r4
</pre>

<p>
Jeśli informacje z symlinka nie pokrywają się z rzeczywistością (np. wskazuje na
inne źródła jądra) to będziemy musieli go poprawić przed przejściem do dalszych
części tego dokumentu. Poniżej zakładamy, że zainstalowano jądro
<c>gentoo-sources-2.6.12-r4</c>.
</p>

<pre caption="Zmiana dowiązania symbolicznego do źródeł jądra">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>

</pre>

<p>
Pora na skonfigurowanie i skompilowanie źródeł jądra. Możesz użyć do tego
programu <c>genkernel</c>, który zbuduje uniwersalne jądro, takie jak np.
to używane przez płyty instalacyjne. Możesz też przeprowadzić cały proces
ręcznie i lepiej dostostosować kernel do swoich potrzeb. Zaczniemy od omówienia
tej drugiej, znacznie lepszej metody.
</p>

<p>
Aby ręcznie skonfigurować jądro należy przejść do paragrafu <uri
link="#manual">Ręczna konfiguracja</uri>, opis pracy z  <c>genkernelem</c>
opisaliśmy w paragrafie <uri link="#genkernel">Alternatywnie: użycie
genkernel</uri>
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Ręczna konfiguracja</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Ręczna konfiguracja kernela jest często postrzegana jako najtrudniejsza czynność
jaką użytkownicy Linuksa muszą wykonywać. Nie jest to prawdą, po skompilowaniu
kilku kerneli zapomnicie, że kiedykowiek uważaliście to za trudne zadanie.
</p>

<p>
Nie sposób jednak zaprzeczyć, że należy dobrze znać swój komputer, aby móc
prawidłowo skonfigurować jądro. Większość informacji można zdobyć poprzez
zemergowanie pakietu pciutils (<c>emerge pciutils</c>) zawierającego program
<c>lspci</c>. Dzięki temu będzie możliwe używanie <c>lspci</c> wewnątrz
chrootowanego środowiska. Podczas pracy z tym programem możne bezpieczenie
zignorować wszelkie ostrzeżenia związane z <e>pcilib</e> (jak np.
"pcilib: cannot open /sys/bus/pci/devices). Ponadto można również uruchomić
<c>lspci</c> poza środowiskiem chroot. Powinno dać to taki sam efekt. Dodatkowe
informacje o sterownikach, które należy włączyć do jądra można uzyskać dzięki
poleceniu <c>lsmod</c>, które pokaże listę modułów jakie załadował system płyty
instalacyjnej. Informacje zapisane podczas uruchamiania jądra również mogą
okazać się cennym źródłem informacji. Do ich wyświetlania służy polecenie
<c>dmesg</c>. 
</p>

<p>
Kiedy już zbierzemy wszystkie informacje przechodzimy do katalogu ze
źródłami i wpisujemy polecenie <c>make menuconfig</c>. Uruchomi się menu
konfiguracyjne oparte na ncurses.
</p>

<pre caption="Uruchamianie menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Zobaczymy okienko z listą sekcji, na które podzielono cały proces konfiguracji.
Zaczniemy od omówienia opcji, które musisz aktywować, aby zapewnić prawidłowe
działanie Gentoo.
</p>

</body>
</subsection>
<subsection>
<title>Zaznaczanie wymaganych ustawień</title>
<body>

<p>
Po pierwsze włącz możliwość korzystania z rozwojowych i eksperymentalnych
fragmentów kodu jądra. Jeśli tego nie zrobisz to nawet nie zobaczysz kilku
bardzo ważnych opcji.
</p>

<pre caption="Wybieranie opcji experimental code/drivers oraz generalnych ustawień">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
General setup --->
  [*] Support for hot-pluggable devices
</pre>

<p>
Następnie przejdź do <c>File Systems</c> i wybierz wsparcie dla systemów plików,
których zamierzasz używać. Jeśli tego zaniedbasz Gentoo nie będzie w stanie
zamontować partycji, a czasem nawet się nie uruchomi. Pamiętaj również, aby
włączać te sterowniki na stałe do jądra, broń Boże nie kompiluj ich jako
modułów. Przy okazji zaznacz też <c>Virtual memory</c> i <c>/proc file
system</c>. <e>Nie należy</e> włączać opcji <c>/dev file system</c>.
</p>

<pre caption="Wybór potrzebnych systemów plików">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [ ] /dev file system support (OBSOLETE)
    [*] Virtual memory file system support (former shm fs)

<comment>(Wybierz jedną lub kilka z tych opcji zależnie od używanych systemów plików.)</comment>
  &lt;*&gt; Second extended fs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; Reiserfs support  
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Jeśli używasz PPPoE do łączenia się z Internetem, lub gdy używasz modemu dial-up
będziesz musiał włączyć następujące opcje:
</p>

<pre caption="Sterowniki niezbędne dla użytkowników PPPoE">
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Obie opcje dotyczące kompresji nie są wprawdzie wymagane, ale również nie
zaszkodzą naszemu systemowi, podobnie zresztą jak opcja <c>PPP over
Ethernet</c>, która jest przydatna tylko gdy skonfigurujesz <c>rp-pppoe</c> do
pracy w trybie jądra PPPoE.
</p>

<p>
Nie zapomnij wkompilować sterownika dla swojej karty sieciowej.
</p>

<p>
Użytkownicy zarówno komputerów OldWorld jak i NewWorld będą potrzebowali
wsparcia dla HFS, aby skopiować skompilowane jądro na partycję MacOS.
Użytkownicy NewWorld muszą także dodatkowo skonfigurować partycję
Apple_Bootstrap:
</p>

<pre caption="Aktywowanie wsparcia dla HFS">
File Systems ---&gt;
  [*] HFS Support
</pre>

<p>
Wywłaszczanie w jądrze wciąż działa niestabilnie na platformie PPC i może
spowodować błędy przy kompilacji, czy naruszenia ochrony pamięci. <e>Nie
radzimy</e> korzystać z tej opcji.
</p>

<pre caption="Upewnianie się, że wyłączono wywłaszczanie">
Platform options ---&gt;
  [ ] Preemptible Kernel
</pre>

<p>
Jeśli komputer uruchamiany jest poprzez Firewire, potrzebne będzie włączenie
poniższych opcji. Można użyć w tym celu modułów.
</p>

<pre caption="Enable support for firewire devices on boot">
   Device Drivers ---&gt;
     IEEE 1394 (FireWire) support ---&gt;
       &lt;*&gt; IEEE 1394 (FireWire) support
       &lt;*&gt;   OHCI-1394 support
       &lt;*&gt;   SBP-2 support (Harddisks etc.)
</pre>
 
<p>
Jeśli komputer uruchamiany jest poprzez USB potrzebne będzie włączenie
poniższych opcji. Można użyć w tym celu modułów.
</p>

<pre caption="Enable support for USB devices on boot">
   Device Drivers ---&gt;
      USB support ---&gt;
        &lt;*&gt; Support for Host-side USB
        &lt;*&gt;   OHCI HCD support
        &lt;*&gt;   USB Mass Storage support
</pre>
 
<p>
Nie wolno wyłącza wsparcia dla framebuffera, jest on wymagany do udanego
uruchomienia systemu. Jeśli jest to karta NVIDIA, należy użyć framebuffera
OpenFirmware. Dla kart ATI należy wybrać odpowiedni bufor ramki w zależności od
posiadanego chipsetu karty (Mach64, Rage128 or Radeon).
</p>

<pre caption="Wybieranie sterownika bufora ramki">
   Device Drivers ---&gt;
     Graphics support ---&gt;
       &lt;*&gt; Support for frame buffer devices
       [*] Open Firmware frame buffer device support
       &lt;*&gt; ATI Radeon display support
       &lt;*&gt; ATI Rage128 display support
       &lt;*&gt; ATI Mach64 display support
       Console display driver support ---&gt;
         &lt;*&gt; Framebuffer Console support
</pre>
 
<note>
Jeśli włączy się więcej niż jeden sterownik to przy uruchamianiu może zostać
wybrany niewłaściwy z nich. Należy zatem powstrzymać się od wybierania większej
ilości urządzeń bufora ramki lub wybrać to najbardziej pożądane za pomocą opcji
<c>video=radeonfb</c> podczas rozruchu systemu.
</note>

<p>
Po ukończeniu konfigurowania jądra należy przejść do paragrafu
<uri link="#compiling">Kompilacja i instalacja</uri>.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilacja i instalacja</title>
<body>

<p>
Po skonfigurowaniu kernela przyszła pora na jego skompilowanie i
instalację. Opuść program konfiguracyjny i wpisz następujące polecenia:
</p>

<pre caption="Kompilowanie kernela.">
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Kiedy jądro skończy się kompilować przekopiuj jego obraz do katalogu
<path>/boot (należy upewnić się, że jest to poprawnie montowane, zwłaszcza na
Pegasosie)</path>.
</p>

<pre caption="Instalowanie kernela">
<comment>Zastąp 2.6.12 wersją jądra</comment>
(Apple/IBM)  # <i>cp vmlinux /boot/kernel-2.6.12</i>
(Pegasos)    # <i>cp arch/ppc/boot/images/zImage.chrp /boot/kernel-2.6.12</i>
</pre>

<p>
Zwykle mądrą decyzją jest skopiowanie tam również pliku konfiguracyjnego, który
posłużył do zbudowania jądra.
</p>

<pre caption="Tworzenie kopii zapasowej konfiguracji jądra">
# <i>cp .config /boot/config-2.6.12-gentoo-r4</i>
</pre>

<p>
Kiedy skończysz przejdź do paragrafu <uri link="#kernel_modules">Instalacja
osobnych modułów jądra</uri>.
</p>

</body>
</subsection>
</section>
<section id="kernel_modules">
<title>Instalacja osobnych modułów jądra</title>
<subsection>
<title>Konfigurowanie modułów</title>
<body>

<p>
Lista modułów, które chcesz by były automatycznie ładowane przy starcie systemu
powinna znajdować się w pliku <path>/etc/modules.autoload.d/kernel-2.4</path>
(lub <path>kernel-2.6</path>). Czasem jeśli chcesz możesz dodać kilka opcji dla
modułów.
</p>

<p>
Żeby przejrzeć listę wszystkich dostępnych użyj komendy <c>find</c>. Oczywiście
powinieneś zastąpić słowa "&lt;wersja jądra&gt;" numerem świeżo skompilowanego
kernela.
</p>

<pre caption="Znajdowanie dostępnych modułów">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Na przykład, aby automatycznie ładować do pamięci moduł <c>3c59x.o</c> wyedytuj
plik <path>kernel-2.4</path> lub <path>kernel-2.6</path> i wprowadź do niego
nazwę tego modułu.
</p>

<pre caption="Edycja /etc/modules.autoload.d/kernel-2.4">
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
3c59x
</pre>

<p>
Następnie uruchom <c>modules-update</c>, aby potwierdzić wprowadzone do pliku
<path>/etc/modules.conf</path> zmiany:
</p>

<pre caption="Uruchamianie modules-update">
# <i>modules-update</i>
</pre>

<p>
Od wersji 2004.3 zalecamy używanie udev zamiast devfs. Żeby Twój system działał
musisz zatem emergować udev:
</p>

<pre caption="Emerging udev">
# <i>emerge udev</i>
</pre>

<p>
Kiedy skończysz przejdź do rozdziału <uri link="?part=1&amp;chap=8">Konfiguracja
systemu</uri>.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternatywnie: użycie genkernel</title>
<body>

<p>
W tym paragrafie omawiamy proces konfiguracji jądra przy pomocy programu
<c>genkernel</c>.
</p>

<p>
Po zainstalowaniu źródeł należy je skonfigurować. Zrobimy to automatycznie przy
pomocy programu <c>genkernel</c>, który wykonuje cały proces dokładnie w ten sam
sposób w jaki jest konfigurowane jądro na płycie instalacyjnej. Konsekwencją
wyboru genkernela jest to, że system będzie zmuszony do wykrywania dostępnego
sprzętu przy każdym uruchomieniu komputera. W związku z tym, że genkernel nie
wymaga od użytkownika żadnych ręcznych poprawek w konfiguracji, jest doskonałym
rozwiązaniem dla tych wszystkich, którzy nie są najmocniejsi w samodzielnym
kompilowaniu jądra.
</p>

<p>
Zanim jednak zdradzimy jak używa się tego cudownego programu musimy wytłumaczyć
jak go zainstalować:
</p>

<pre caption="Emergowanie genkernela">
# <i>emerge genkernel</i>
</pre>

<p>
Następnie kopiujemy konfigurację jądra z płyty instalacyjnej do miejsca, w
którym znajdzie ją i wykorzysta genkernel:
</p>

<pre caption="Kopiowanie konfiguracji jądra z płyty instalacyjnej">
# <i>zcat /proc/config.gz > /usr/share/genkernel/ppc/kernel-config-2.6</i>
</pre>

<p>
Jeśli do uruchamiania wykorzystuje się Firewire lub USB, trzeba dodać moduły do
initrd.  W tym celu edytujemy <path>/usr/share/genkernel/ppc/modules_load</path>
i dodajemy <c>MODULES_FIREWIRE="ieee1394 ohci1394 sbp2"</c> dla Firewire lub
<c>MODULES_USB="usbcore ohci-hcd ehci-hcd usb-storage"</c> dla USB.
</p>

<p>
Źródła skompilujemy przy pomocy polecenia <c>genkernel --genzimage all</c>. Na
Pegasosie należy inaczej skonfigurować jądro i zbudować je w formacie zImage
zamiast vmlinux, z którego korzysta się na komputerach Apple.  Kompilowanie
zajmie mnóstwo czasu, ponieważ <c>genkernel</c> zawiera niemal wszystkie
dostępne sterowniki.
</p>

<p>
Jeśli partycja rozruchowa została sformatowana w innym niż ext2 lub ext3
systemie plików należy ręcznie dodać potrzebne dla nich sterowniki, wybiera się
je przy pomocy menu <c>genkernel --menuconfig all</c>. Sterowniki te muszą być
wkompilowane w jądro <e>na stałe</e>, nie można dodawać ich w postaci modułów.
Użytkownicy EVMS2 lub LVM2 powinni dodać również <c>--evms2</c> lub
<c>--lvm2</c> do listy argumentów.
</p>

<pre caption="Uruchamianie genkernel">
# <i>genkernel all</i>
</pre>

<pre caption="Na Pegasosach">
# <i>genkernel --genzimage --kernel-config=/usr/share/genkernel/ppc/Pegasos all</i>
</pre>

<p>
W toku tego procesu powstanie właściwy plik jądra, initrd (initial root disk)
oraz ogromna rzesza modułów. Nazwy plików jądra i initrd będą potrzebne przy
konfiguracji bootloadera do prawidłowego wypełnienia jego pliku
konfiguracyjnego, więc warto je sobie zapisać. Przy następnym uruchumieniu
komputera zostanie najpierw wykonany plik initrd, który wykryje cały dostępny
sprzęt i wczyta odpowiednie moduły, a następnie uruchomi się właściwy system.
</p>

<pre caption="Sprawdzanie nazw utworzonych plików jądra">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Następna czynność jeszcze bardziej upodobni nasz system do tego znajdującego się
na płycie instalacyjnej. Zemergujemy <c>coldplug</c>, który działa na podobnej
zasadzie jak initrd, wykrywający przy starcie wszystkie niezbędne do
uruchomienia systemu urządzenia, z tym, że zajmuje się wszystkimi ich typami.
Aby zemergować i uruchomić <c>coldplug</c> należy wykonać następujące
polecenia:
</p>

<pre caption="Emergowanie i uruchamianie coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Kolejny etap instalacji to <uri link="?part=1&amp;chap=8">Konfigurowanie
systemu</uri>.
</p>

</body>
</section>
</sections>
