<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-mips-bootloader.xml,v 1.13 2006/02/03 15:46:42 shadoww Exp $ -->

<sections>

<version>1.8</version>
<date>2006-01-19</date>

<section id="sgi">
<title>Komputery Silicon Graphics - Konfiguracja Arcboot</title>
<subsection>
<title>Instalowanie arcboot</title>
<body>

<p>
W poprzednich rozdziałach opowiedzieliśmy o tym jak zbudować kernel i umieścić
go w nagłówku woluminu za pomocą <c>dvhtool</c>. Taka konfiguracja ma dwie
poważne wady: 
</p>

<ul>
  <li>Nie jest to obsługiwane przez wszystkie komputery SGI</li>
  <li>Wymaga dużego nagłówka woluminu</li>
</ul>

<p>
Z tego powodu, w celu uruchamiania systemu powstał znacznie wygodniejszy program
ładujący o nazwie <c>arcboot</c>. Zamiast umieszczania jądra w nagłówku woluminu
można zostawić je w katalogu /boot (na partycji ext2/3) i skonfigurować
znajdujący się, właśnie w nagłówku woluminu, program <c>arcboot</c> tak, aby je
tam odnajdywał i uruchamiał. Pierwszą czynnością jaką wykonamy będzie
zainstalowanie całego potrzebnego oprogramowania.
</p>

<pre caption="Instalowanie wymaganych programów">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Zainstalujemy w ten sposób dwa programy: <c>arcboot</c>, który będzie rezydował
w nagłówku woluminu oraz <c>dvhtool</c>, który pomoże w umieszczeniu go tam.
</p>

<p>
Plik, który jest nam potrzebny znajduje się w katalogu
<path>/usr/lib/arcboot</path>. Ma systemach IP22 (Indy, Indigo 2, Challenge S)
ma on nazwę <path>arcboot.ip22</path>. Na innych powinno być podobnie. Musimy go
skopiować do nagłówka woluminu.
</p>

<pre caption="Instalowanie arcboot w nagłówku woluminu">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Potem sprawdzamy czy naprawdę został tam wgrany.
</p>

<pre caption="Sprawdzanie arcboot">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Warto zauważyć, że w tym przypadku do dyspozycji mamy dwa jądra -
<path>linux</path> i <path>newlinux</path>. Jest to pozostałość po poprzedniej
instalacji <c>arcboot</c> i nie ma żadnego praktycznego znaczenia. Jeśli
znajduje się tam <c>arcboot</c>, wszystko jest w porządku.
</note>

</body>
</subsection>
<subsection>
<title>Konfigurowanie arcboot</title>
<body>

<p>
Osoby, które używały wcześniej LILO zauważą, że <c>arcboot</c> posiada bardzo
podobną składnię pliku konfiguracyjnego. Należy pamiętać, że plik konfiguracyjny
<c>arcboot</c> musi znajdować się na partycji EXT2/3 i w miejscu
<path>/etc/arcboot.conf</path>. Najprostszym sposobem zapewnienia tego jest
utworzenie partycji <path>/boot</path> z którymś z tych systemów plików
posiadającej katalog <path>/boot/etc</path>. Przykładowy plik konfiguracyjny
to <path>/etc/arcboot.conf.sample</path>.
</p>

<pre caption="Instalowanie arcboot">
<comment>(Tworzenie katalogu /boot/etc)</comment>
# <i>mkdir /boot/etc</i>

<comment>(Umieszczanie w nim pliku konfiguracyjnego)</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(Tworzenie dowiązania /etc)</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(Tworzenie dowiązania w /boot)</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Teraz można otworzyć do edycji plik <path>/etc/arcboot.conf</path>. Osobiście
stosuję dwa pliki kernela: <path>new</path>, świeżo zbudowany obraz, który może
nie działać poprawnie i <path>working</path>, stary i sprawdzony już plik. Mój
<path>arcboot.conf</path> wygląda następująco:
</p>

<pre caption="Przykładowy arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># wersja zapasowa</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Po skonfigurowaniu trzeba wprowadzić kilka drobnych zmian w SGI PROM. Wszystkie
opisujemy w akapicie dotyczącym <uri link="#reboot">Ponownego
uruchomienia</uri>.  
</p>

</body>
</subsection>
</section>
<section id="cobalt">
<title>Serwery Cobalt - konfiguracja CoLo</title>
<subsection>
<title>Instalowanie CoLo</title>
<body>

<p>
Serwery Cobalt nie posiadają zbyt dobrego firmware, ich BOOTPROM jest prymitywny
i posiada wiele ograniczeń w porównaniu z SGI PROM.
</p>

<ul>
  <li>
    Istnieje limit rozmiaru 675kB dla jądra. Obecny rozmiar jąder serii 2.4
    niemal uniemożliwia budowę kernela o takim rozmiarze, nie mówiąc już o
    jądrach 2.6.
  </li>
  <li>
    Firmware nie obsługuje jąder 64-bitowych (które są już w fazie testów na
    komputerach Cobalt)
  </li>
  <li>
    Powłoka jest naprawdę uproszczona
  </li>
</ul>

<p>
W celu obejścia tych ograniczeń stworzono alternatywne firmware, o nazwie
<uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> (Cobalt
LOader). Jest to obraz BOOTPROM który można zarówno wgrać w chip wewnątrz
serwera jak i wczytać ze starego firmware.
</p>

<note>
Tu omówimy opcję uruchamiania CoLo ze standardowego firmware. Jest to jedyna
bezpieczna i zalecana metoda instalowania CoLo.
</note>

<warn>
Można również, w razie potrzeby, wgrać je do serwera całkowicie zastępując nim
standardowy firmware. W takim przypadku jest się zdanym całkowicie na siebie.
Wymaga to fizycznego wydobycia BOOTPROM z maszyny i przeprogramowania jego
firmware. Jeśli nie jest się pewnym jak dokładnie się to robi <e>NIE NALEŻY</e>
się za to zabierać. Nie bierzemy żadnej odpowiedzialności za uszkodzenia
wynikające ze zignorowania tego ostrzeżenia.
</warn>

<p>
Po krótkim ostrzeżeniu wracamy do instalacji CoLo. Po pierwsze musimy zemergować
pakiet z nim.
</p>

<pre caption="Instalowanie pakietu colo">
# <i>emerge colo</i>
</pre>

<p>
Po zainstalowaniu należy przejść do katalogu <path>/usr/lib/colo</path> i
odszukać dwa pliki, <path>colo-chain.elf</path>, czyli jądro jakie ma wczytywać
domyślny firmware oraz <path>colo-rom-image.bin</path>, czyli obraz ROM który
będziemy umieszczać w BOOTPROM. Zaczynamy od zamontowania partycji /boot i
umieszczenia skompresowanej kopii pliku <path>colo-chain.elf</path> w katalogu
<path>/boot</path>, w którym system będzie go szukał.
</p>

<pre caption="Umieszczenie CoLo w odpowiednim miejscu">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Konfigurowanie CoLo</title>

<body>

<p>
Po uruchomieniu systemu zostanie wczytane CoLo, które wyświetli menu na tylnym
ekranie. Pierwsza opcja (domyślnie wybierana po 5 sekundach) to uruchomienie
komputera z dysku twardego. System spróbuje potem podmontować pierwszą partycję
jaką znajdzie i uruchomić skrypt <path>default.colo</path>. Składnia poleceń
jest udokumentowana w pliku
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path>, gdzie X, YY to numery
zainstalowanej wersji programu.
</p>

<note>
Mała rada: podczas instalowania kerneli należy tworzyć dwa obrazy.
<path>kernel.gz.working</path> - sprawdzony i działający kernel oraz
<path>kernel.gz.new</path> - jądro, które właśnie zostało skompilowane. Można
użyć dowiązań w celu wskazania odpowiednich obrazów lub po prostu zmienić ich
nazwę.
</note>

<pre caption="Plik default.colo">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo odmówi wczytania jakiegokolwiek skryptu jeśli nie będzie się on zaczynał
linią <c>#:CoLo:#</c>. Jest to odpowiednik <c>#!/bin/sh</c> dla skryptów
powłoki.
</note>

<p>
Możliwe jest wyświetlanie zapytania, dotyczącego tego, które jądro i która
konfiguracja ma być wczytana, również z domyślnym okresem oczekiwania przed
uruchomieniem domyślnej opcji. Oto konfiguracja używana na moich serwerach
Cobalt:
</p>

<impo>
Z <c>menu</c> można skorzystać tylko w wersjach CoLO v1.12 lub v1.13. Nie
zadziała na wersji v1.11.
</impo>

<impo>
W CoLo v1.14 polecenie <c>menu</c> zostało zastąpione poleceniem <c>select</c>.
Jeśli wcześniej zainstalowano CoLo, należy zapoznać się z plikiem
<path>menu.colo</path> z podkatalogu <path>examples</path> w paczce CoLo.
</impo>

<pre caption="Konfiguracja menu">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
menu "Which Kernel?" 50 Working working New new
lcd "Loading Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Powyższy skrypt powoduje zapytanie użytkownika, którego jądra chce użyć ("New"
czy "Working"), następnie zostanie wczytany obraz <path>vmlinux.gz.new</path>
lub <path>vmlinux.gz.working</path> w zależności od tego wyboru. Jeśli wyboru
nie dokona się w ciągu 5 sekund zostanie wybrana i uruchomiona pierwsza
możliwość.
</p>

</body>
</subsection>
</section>
<section>
<title>Konfigurowanie konsoli szeregowej</title>
<subsection>
<body>

<p>
Ok, Linux uruchamia się bez problemów, ale zakładanie, że zostaniemy zalogowani
do zwykłego fizycznego terminala jest pomyłką. Na serwerach Cobalt niczego
takiego nie ma.
</p>

<note>
Posiadacze luksusu, jakim jest obsługa framebuffera, mogą pominąć ten akapit.
</note>

<p>
Po pierwsze zatem otwieramy w edytorze plik <path>/etc/inittab</path>. Na dole
pliku znajduje się następujący wpis:
</p>

<pre caption="Konfiguracja inittab">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Zaczynamy od odkomentowania linii z <c>c0</c>. Domyślnie korzysta się z
terminala o 9600 bps. Na serwerach Cobalt można zmienić tę wartość do 115200
tak, aby pasowała do ilości bodów BOOT ROM. Poniżej znajduje się część pliku
konfiguracyjnego z mojego komputera. Na niektórych komputerach zalecane jest
wykomentowanie linii od <c>c1</c> do <c>c6</c>, ponieważ mogą one zachowywać się
dziwnie gdy nie będą w stanie otworzyć <path>/dev/ttyX</path>.
</p>

<pre caption="Przykladowy fragment inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- These are useless on a headless qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Na koniec musimy jeszcze zabezpieczyć system tak, aby lokalny port szeregowy
mógł być uważany za bezpieczny terminal. Plik, który musimy zmienić to
<path>/etc/securetty</path>, zawierający listę zaufanych terminali. Dodamy do
niego dwie linie, które umożliwią logowanie się tam jako <c>root</c>.
</p>

<pre caption="Umożliwianie logowania roota na konsolach szeregowych">
<comment>(/dev/ttyS0 - tradycyjna nazwa konsoli szeregowej)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Linux odwołuje się do /dev/tts/0, zatem musimy dodać także ten wpis)
</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Ponowne uruchomienie komputera</title>
<subsection>
<body>

<p>
Opuszczamy chrootowane środowisko i odmontowujemy wszystkie partycje. Następnie
wpisujemy tak wyczekiwane polecenie: <c>reboot</c>.
</p>

<pre caption="Opuszczanie chroota, odmontowywanie i ponowne uruchamianie">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
Dla <e>użytkowników Cobalt</e>: Pozostała część tekstu dotyczy konfiguracji SGI
PROM tak, aby uruchamiał <c>arcboot</c>, który następnie uruchomi Linuksa. Nie
dotyczy to serwerów Cobalt, na nich praca już jest skończona, nie trzeba
wykonywać żadnej dodatkowej konfiguracji i można przejść do następnego
rozdziału Podręcznika, zatytułowanej <uri link="?part=1&amp;chap=11">Zakończenie
instalacji Gentoo</uri>.
</note>

</body>
</subsection>
</section>
<section>
<title>Konfigurowanie SGI PROM</title>
<subsection>
<body>

<p>
Po ponownym uruchomieniu komputera przechodzimy do <e>System Maintenance
Menu</e> i wybieramy opcję <e>Enter Command Monitor</e> (<c>5</c>). Jeśli chcemy
przetestować świeżo zainstalowane Gentoo, możemy uruchomić polecenie <c>boot -f
&lt;nazwa kernela&gt;</c>. Jeśli uruchamianym domyślnie systemem ma na stałe
pozostać Gentoo potrzebne będzie ustawienie następujących zmiennych w SGI PROM:
</p>

<pre caption="Konfigurowanie PROM do uruchamiania Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

<comment>(&lt;root device&gt; = główna partycja Gentoo np. /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;urządzenie root&gt;</i>

<comment>(Listę dostępnych jąder uzyskujemy poleceniem "ls"</comment>
&gt;&gt; <i>setenv OSLoader &lt;nazwa jądra&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;nazwa jądra&gt;</i>

<comment>(Deklarujemy dodatkowe parametry uruchomieniowe dla jądra)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;parametry jądra&gt;</i>

<comment>(Definiujemy miejsce nagłówka woluminu)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Automatyczne uruchamianie Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Ustawienia strefy czasowej)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Używanie konsoli szeregowej, posiadacze adapterów graficznych powinni
wpisać "g" zamiast "d1"</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>

<p>
To już wszystko, uruchamiamy Gentoo i przechodzimy do rozdziału <uri
link="?part=1&amp;chap=11">Zakończenie instalacji Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
