<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->


<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-portage-tools.xml,v 1.1 2004/12/24 10:55:12 neysx Exp $ -->

<sections>

<version>1.3</version>
<date>2004-10-24</date>

<section>
<title>Etc-update.</title>
<body>

<p>
<c>Etc-update</c> jest narzędziem, które służy do zastępowania plików konfiguracyjnych plikami 
<path>._cfg0000_&lt;nazwa&gt;</path>, umożliwia ich interaktywną edycję, oraz pozwala 
automatycznie dokonać drobnych zmian w owych plikach. Pliki <path>._cfg0000_&lt;nazwa&gt;</path> 
są generowane przez Portage, gdy chce wrzucić jakiś plik do katalogu chronionego zmienną CONFIG_PROTECT.
</p>

<p>
Aby uruchomić <c>etc-update</c> wpisz po prostu:
</p>

<pre caption="Uruchamianie etc-update">
# <i>etc-update</i>
</pre>

<p>
Program automatycznie dokona drobnych zmian w plikach konfiguracyjnych, a potem
pokaże Ci listę plików chronionych i poprosi o decyzję w ich sprawie. Na dole
powinieneś zobaczyć taką listę dostępnych opcji wraz z ich krótkim opisem:
</p>

<pre caption="Opcje etc-update">
Please select a file to
 edit by entering the corresponding number.
              (-1 to exit) 
	      (-3 to auto merge all remaining files)
              (-5 to auto-merge AND not use 'mv -i'):
</pre>

<p>
Jeśli wpiszesz <c>-1</c>, <c>etc-update</c> zakończy działanie nie zmieniając
żadnego pliku. Po wybraniu <c>-3</c> lub <c>-5</c> <e>wszystkie</e> znajdujące
się na liście pliki konfiguracyjne zostaną nadpisane nowszymi wersjami. Dobrym
pomysłem jest zaznaczenie plików, których nie chcesz nadpisywać automatycznie.
Robisz to po prostu wpisując liczbę znajdującą się na lewo od danego pliku.
</p>

<p>
Np. wybieramy sobie plik konfiguracyjny <path>/etc/pear.conf</path> i po
wybraniu jego indeksu widzimy coś takiego:
</p>

<pre caption="Oddzielne uaktualnienie wybranego pliku">
Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<comment>[...]</comment>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update
2) Delete update, keeping original as is
3) Interactively merge original with update
4) Show differences again
</pre>

<p>
W ten sposób można łatwo uzyskać informacje o różnicach pomiędzy oboma plikami.
Jeśli jesteś pewien, że zastąpienie starego pliku nowym to dobry pomysł
naciskasz <c>1</c>. Może zdarzyć się też tak, że nie będziesz chciał nowego
pliku. Wtedy naciskasz <c>2</c> i zapominasz o tym, że była nowsza wersja :)
Jeśli chcesz bliżej zająć się tym plikiem (tzw. metoda interaktywna) wybierasz
<c>3</c>.
</p>

<p>
Nie ma sensu rozpisywać się na temat trzeciej metody - ograniczymy się jedynie
do podania możliwych w tym trybie do wybrania komend. Generalnie wygląda to tak,
że program pokazuje dwie linie - oryginalną i proponowaną i czeka aż wpiszemy
jeden z ciągów znaków:
</p>

<pre caption="Komendy dostępne podczas interaktywnej edycji plików">
ed:     Edycja i użycie obu wersji, każdej z nagłówkiem.
eb:     Edycja i użycie obu wersji.
el:     Edycja i użycie wersji po lewej.
er:     Edycja i użycie wersji po prawej.
e:      Edycja nowej wersji.
l:      Użycie wersji po lewej.
r:      Użycie wersji po prawej.
s:      Dołączenie wspólnych linii bez informoawania o tym.
v:      Dołączenie wspólnych linii z podaniem informacji.
q:      Zakończenie.
</pre>

<p>
Kiedy już skończysz uaktualniać te najważniejsze pliki to nieinteresującą Cię
resztę po prostu zamieniasz w trybie automatycznym. <c>etc-update</c> wyłączy
się kiedy już nie będzie miało żadnych plików do uaktualnienia.
</p>

</body>
</section>
<section>
<title>Dispatch-conf.</title>
<body>

<p>
<c>Dispatch-conf</c> to ciekawa alternatywa dla etc-update. Program posiada
wszystkie opcje swojego pierwowzoru, a ponadto jest w stanie zapamiętać kolejne
zmiany jakich dokonaliśmy w naszych plikach konfiguracyjnych, dzięki czemu w
razie jakiejś katastrofy możemy łatwo wrócić do poprzedniej wersji.
</p>

<p>
Tak jak w <c>etc-update</c>, możesz zażądać, aby program pozostawił dany plik
bez zmian, zastąpić go nowym, edytować osobiście obecny plik, lub użyć do tego
celu trybu interaktywnego. Oprócz tego <c>dispatch-conf</c> ma jeszcze kilka
ciekawych opcji:
</p>

<ul>
<li>
Automatycznie zamienia stare pliki nowymi jeśli zmiany w nich dotyczą jedynie
linii wykomentowanych.
</li>
<li>
Automatycznie zamienia pliki, gdy zmiany dotyczą jedynie pustego miejsca
(spacje, tabulatory, puste wiersze itp.)
</li>
</ul>

<p>
Pracę z programem trzeba zacząć od wprowadzenia odpowiednich ustawień do pliku
<path>/etc/dispatch-conf.conf</path>, w tym przede wszystkim zmiennej
archive-dir, wskazującej katalog gdzie program będzie archiwizował nadpisywane
pliki konfiguracyjne oraz utworzenia owego katalogu.
</p>

<p>
Więcej informacji o programie dostarczy manual <c>dispatch-conf</c>:
</p>

<pre caption="Czytanie manuala dispatch-conf">
$ <i>man dispatch-conf</i>
</pre>

</body>
</section>
<section>
<title>Quickpkg.</title>
<body>

<p>
Program <c>quickpkg</c> umożliwia spakowanie zainstalowanego programu do paczki, 
z której następnie możemy go bezproblemowo i błyskawicznie odtworzyć. Uruchamianie 
<c>quickpkg</c> jest proste: po prostu podajemy nazwy programów do spakowania jako 
parametry i wciskamy enter.
</p>


<p>
Na przykład wybieramy do spakowania: <c>curl</c>, <c>arts</c> i <c>procps</c>:
</p>

<pre caption="Przykład użycia quickpkg">
# <i>quickpkg curl arts procps</i>
</pre>

<p>
Po zakończeniu całego procesu gotowe paczki znajdziemy w
<path>/usr/portage/packages/All</path>. Ponadto dla naszej wygody w
<path>/usr/portage/packages/&lt;kategoria&gt;</path> będą się znajdowały
symlinki do tych paczek.
</p>

</body>
</section>
</sections>

