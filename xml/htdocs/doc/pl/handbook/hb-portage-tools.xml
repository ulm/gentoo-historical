<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Orig revision: 1.7 -->
<!-- Translator: rane <rane@gentoo.org> -->
<!-- Status: Release -->
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-portage-tools.xml,v 1.13 2007/01/30 17:01:00 shadoww Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->


<!-- $Id: hb-portage-tools.xml,v 1.13 2007/01/30 17:01:00 shadoww Exp $ -->

<sections>

<abstract>
Portage zawiera sporo narzędzi, które znacznie ułatwiają codzienną pracę z nim.
W tym rozdziale opisujemy kilka najważniejszych, np. dispatch-conf.
</abstract>

<version>1.4</version>
<date>2005-07-28</date>

<section>
<title>Etc-update</title>
<body>

<p>
<c>Etc-update</c> jest narzędziem, które służy do zastępowania plików
konfiguracyjnych plikami <path>._cfg0000_&lt;nazwa&gt;</path>, umożliwia ich
interaktywną edycję, oraz pozwala automatycznie dokonać drobnych zmian w owych
plikach. Pliki <path>._cfg0000_&lt;nazwa&gt;</path> są generowane przez Portage,
gdy chce nadpisać jakiś plik w katalogu chronionym zmienną CONFIG_PROTECT.
</p>

<p>
Aby uruchomić <c>etc-update</c> wystarczy po prostu wpisać:
</p>

<pre caption="Uruchamianie etc-update">
# <i>etc-update</i>
</pre>

<p>
Program automatycznie dokona drobnych zmian w plikach konfiguracyjnych, a potem
pokaże listę plików chronionych i poprosi o decyzję w ich sprawie. Na dole
pojawi się poniższa lista dostępnych opcji wraz z ich krótkim opisem:
</p>

<pre caption="Opcje etc-update">
Please select a file to
 edit by entering the corresponding number.
              (-1 to exit)
              (-3 to auto merge all remaining files)
              (-5 to auto-merge AND not use 'mv -i'):
</pre>

<p>
Po wybraniu <c>-1</c> <c>etc-update</c> zakończy działanie. Warto pamiętać, że
jest to jedynie polecenie zakończenia programu i nie cofnie żadnych dokonanych
wcześniej zmian. Po wybraniu <c>-3</c> lub <c>-5</c> <e>wszystkie</e> znajdujące
się na liście pliki konfiguracyjne zostaną nadpisane nowszymi wersjami. Dobrym
pomysłem jest zaznaczenie plików, których nie chcemy nadpisywać automatycznie.
Dokonuje się tego po prostu wpisując liczbę znajdującą się na lewo od danego
pliku.
</p>

<p>
Np. wybieramy sobie plik konfiguracyjny <path>/etc/pear.conf</path> i po
wybraniu jego indeksu widzimy coś takiego:
</p>

<pre caption="Oddzielne uaktualnienie wybranego pliku">
Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<comment>[...]</comment>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update
2) Delete update, keeping original as is
3) Interactively merge original with update
4) Show differences again
</pre>

<p>
W ten sposób można łatwo uzyskać informacje o różnicach pomiędzy oboma plikami.
Jeśli jesteśmy pewni, że zastąpienie starego pliku nowym to dobry pomysł,
naciskamy <c>1</c>. Może zdarzyć się też tak, że nie będziemy chcieli nowego
pliku. Wtedy naciskamy <c>2</c> i zapominamy o tym, że była nowsza wersja :)
Jeśli chcemy bliżej zająć się tym plikiem (tzw. metoda interaktywna) wybieramy
<c>3</c>.
</p>

<p>
Nie ma sensu rozpisywać się na temat trzeciej metody - ograniczymy się jedynie
do podania możliwych w tym trybie do wybrania komend. Generalnie wygląda to tak,
że program pokazuje dwie linie - oryginalną i proponowaną i czeka aż wpiszemy
jeden z ciągów znaków:
</p>

<pre caption="Komendy dostępne podczas interaktywnej edycji plików">
ed:     Edycja i użycie obu wersji, każdej z nagłówkiem.
eb:     Edycja i użycie obu wersji.
el:     Edycja i użycie wersji po lewej.
er:     Edycja i użycie wersji po prawej.
e:      Edycja nowej wersji.
l:      Użycie wersji po lewej.
r:      Użycie wersji po prawej.
s:      Dołączenie wspólnych linii bez informowania o tym.
v:      Dołączenie wspólnych linii z podaniem informacji.
q:      Zakończenie.
</pre>

<p>
Kiedy już skończymy uaktualniać te najważniejsze pliki, pozostałe możemy
zamienić w trybie automatycznym. <c>Etc-update</c> wyłączy się kiedy już nie
będzie miało żadnych plików do uaktualnienia.
</p>

</body>
</section>
<section>
<title>Dispatch-conf</title>
<body>

<p>
<c>Dispatch-conf</c> to ciekawa alternatywa dla etc-update. Program posiada
wszystkie opcje swojego pierwowzoru, a ponadto jest w stanie zapamiętać kolejne
zmiany jakich dokonaliśmy w naszych plikach konfiguracyjnych, dzięki czemu w
razie jakiejś katastrofy możemy łatwo wrócić do poprzedniej wersji.
</p>

<p>
Tak jak w <c>etc-update</c>, można zażądać, aby program pozostawił dany plik bez
zmian, zastąpić go nowym, edytować ręcznie obecny plik lub użyć do tego celu
trybu interaktywnego. Oprócz tego <c>dispatch-conf</c> ma jeszcze kilka
ciekawych opcji:
</p>

<ul>
  <li>
    Automatycznie zamienia stare pliki nowymi jeśli zmiany w nich dotyczą
    jedynie linii wykomentowanych.
  </li>
  <li>
    Automatycznie zamienia pliki, gdy zmiany dotyczą jedynie pustego miejsca
    (spacje, tabulatory, puste wiersze itp.)
  </li>
</ul>

<p>
Pracę z programem należy zacząć od wprowadzenia odpowiednich ustawień do pliku
<path>/etc/dispatch-conf.conf</path>, w tym przede wszystkim zmiennej
archive-dir, wskazującej katalog gdzie program będzie archiwizował nadpisywane
pliki konfiguracyjne oraz utworzenia owego katalogu.
</p>

<p>
Więcej informacji o programie dostarczy <c>man dispatch-conf</c>:
</p>

<pre caption="Czytanie manuala dispatch-conf">
$ <i>man dispatch-conf</i>
</pre>

</body>
</section>
<section>
<title>Quickpkg</title>
<body>

<p>
Program <c>quickpkg</c> umożliwia spakowanie zainstalowanego programu do paczki,
z której następnie możemy go bezproblemowo i błyskawicznie odtworzyć.
Uruchamianie <c>quickpkg</c> jest proste: po prostu podajemy nazwy programów do
spakowania jako parametry i wciskamy enter.
</p>


<p>
Na przykład wybieramy do spakowania: <c>curl</c>, <c>arts</c> i <c>procps</c>:
</p>

<pre caption="Przykład użycia quickpkg">
# <i>quickpkg curl arts procps</i>
</pre>

<p>
Po zakończeniu całego procesu gotowe paczki znajdziemy w katalogu
<path>$PKGDIR/All</path> (domyślnie <path>/usr/portage/packages/All</path>).
Ponadto dla naszej wygody w <path>$PKGDIR/&lt;kategoria&gt;</path>
będą się znajdowały dowiązania symboliczne do wszystkich zbudowanych przez nas
paczek.
</p>

</body>
</section>
</sections>

