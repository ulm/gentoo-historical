<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-sparc-kernel.xml,v 1.12 2005/08/28 10:49:35 rane Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>

<version>2.5</version>
<date>2005-08-25</date>

<section>
<title>Strefa czasowa</title>
<body>

<p>
Aby system wiedział gdzie się znajduje powinieneś najpierw wybrać swoją strefę
czasową. Odszukaj ją w <path>/usr/share/zoneinfo</path>, a następnie za pomocą
<c>ln</c> utwórz do niej symlinka <path>/etc/localtime</path>. Należy unikać
stref czasowych o nazwie <path>/usr/share/zoneinfo/Etc/GMT*</path>, ponieważ ich
nazwy mogą być mylące, na przykład <path>GMT-8</path> jest w rzeczywistości
GMT+8.
</p>

<pre caption="Konfiguracja strefy czasowej">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Zakładając, że chcesz Poland)</comment>
# <i>ln -sf /usr/share/zoneinfo/Poland /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Instalacja źródeł.</title>
<subsection>
<title>Wybór jądra.</title>
<body>

<p>
Sercem każdej dystrybucji jest jądro Linux. Stanowi ono interfejs pomiędzy
programami i sprzętem. Gentoo dostarcza użytkownikom
różne źródła kerneli. Pełna lista wraz z opisami znajduje się w
<uri link="/doc/pl/gentoo-kernel.xml">Przewodniku jąder Gentoo</uri>.
</p>

<p>
Dla systemów opartych na architekturze sparc udostępniamy źródła
<c>sparc-sources</c> (zoptymalizowane dla użytkowników sparc) oraz
<c>vanilla-sources</c> (zwykłe źródła, rozwijane przez develeperów jądra
Linux),
</p>

<p>
Wybierzmy któreś z dostępnych źródeł i zainstalujmy je przy pomocy
<c>emerge</c>:
</p>

<p>
Jako przykładu użyjemy <c>sparc-sources</c>. Jeśli wybierzesz inny kernel
zmień odpowiednio wszystkie polecenia:
</p>

<pre caption="Instalowanie źródeł jądra">
# <i>emerge sparc-sources</i>
</pre>

<p>
W katalogu <path>/usr/src</path> powinieneś mieć mniej więcej taki symlink, o
nazwie <path>linux</path>, wskazujący na źródła Twojego aktualnego kernela:
</p>

<pre caption="Podgląd symlinka do źródeł kernela">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt;
linux-2.4.29-sparc
</pre>

<p>
Jeśli informacje z symlinka nie pokrywają się z rzeczywistością (np. wskazuje na
inne niż Twoje źródła kernela) to będziesz musiał go poprawić zanim przejdziesz
do dalszych części tego dokumentu.
</p>

<pre caption="Zmiana dowiązania symbolicznego do źródeł jądra">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.4.29-sparc linux</i>
</pre>

<p>
Pora na skonfigurowanie i skompilowanie źródeł jądra.
</p>

</body>
</subsection>
</section>
<section>
<title>Ręczna konfiguracja.</title>
<subsection>
<title>Wprowadzenie.</title>
<body>

<p>
Ręczna konfiguracja kernela jest często postrzegana jako najtrudniejsza czynność
jaką użytkownicy Linuksa muszą wykonywać. Nie jest to prawdą, po skompilowaniu
kilku kerneli zapomnicie, że kiedykowiek uważaliście to za trudne zadanie.
</p>

<p>
Nie sposób jednak zaprzeczyć, że należy dobrze znać swój komputer, aby móc
prawidłowo skonfigurować jądro. Większość informacji można zdobyć poprzez
zemergowanie pakietu pciutils (<c>emerge pciutils</c>) zawierającego program
<c>lspci</c>. Dzięki temu będzie możliwe używanie <c>lspci</c> wewnątrz
chrootowanego środowiska. Podczas pracy z tym programem możne bezpieczenie
zignorować wszelkie ostrzeżenia związane z <e>pcilib</e> (jak np.
"pcilib: cannot open /sys/bus/pci/devices). Ponadto można również uruchomić
<c>lspci</c> poza środowiskiem chroot. Powinno dać to taki sam efekt. Dodatkowe
informacje o sterownikach, które należy włączyć do jądra można uzyskać dzięki
poleceniu <c>lsmod</c>, które pokaże listę modułów jakie załadował system płyty
instalacyjnej.
</p>

<p>
Kiedy już zbierzemy wszystkie informacje przechodzimy do katalogu ze
źródłami i wpisujemy polecenie <c>make menuconfig</c>. Uruchomi się menu
konfiguracyjne oparte na ncurses.
</p>

<pre caption="Wywoływanie menuconfig">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Zobaczymy okienko z listą sekcji, na które podzielono cały proces konfiguracji.
Zaczniemy od omówienia opcji, które musisz aktywować, aby zapewnić prawidłowe
działanie Gentoo.
</p>

</body>
</subsection>
<subsection>
<title>Zaznaczanie wymaganych ustawień.</title>
<body>

<p>
Po pierwsze włącz możliwość korzystania z rozwojowych i eksperymentalnych
fragmentów kodu jądra. Jeśli tego nie zrobisz to nawet nie zobaczysz kilku
bardzo ważnych opcji.
</p>

<pre caption="Wybieranie opcji experimental code/drivers">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
Następnie przejdź do <c>File Systems</c> i wybierz wsparcie dla systemów plików,
których zamierzasz używać. Jeśli tego zaniedbasz Gentoo nie będzie w stanie
zamontować partycji, a czasem nawet się nie uruchomi. Pamiętaj również, aby
włączać te sterowniki na stałe do jądra, broń Boże nie kompiluj ich jako
modułów. Przy okazji zaznacz też <c>Virtual memory</c>, <c>/proc file system</c>
i <c>/dev file system</c> + <c>Automatically mount at boot</c>:
</p>

<pre caption="Wybór potrzebnych systemów plików">
<comment>(dla kerneli 2.4.x)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(dla kerneli 2.6.x)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] /dev file system support (OBSOLETE)
    [*]   Automatically mount at boot
    [*] Virtual memory file system support (former shm fs)

<comment>(Wybierz jedną lub kilka z tych opcji zależnie od używanych systemów plików)</comment>
  &lt; &gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt; &gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt; &gt; XFS filesystem support
</pre>

<p>
Jeśli używasz PPPoE do łączenia się z Internetem, lub gdy używasz modemu dial-up
będziesz musiał włączyć następujące opcje:
</p>

<pre caption="Sterowniki niezbędne dla użytkowników PPPoE">
<comment>(dla kernela 2.4.x)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports

<comment>(dla kernela 2.6.x)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Obie opcje dotyczące kompresji nie są wprawdzie wymagane, ale również nie
zaszkodzą naszemu systemowi, podobnie zresztą jak opcja <c>PPP over
Ethernet</c>, która jest przydatna tylko gdy skonfigurujesz <c>rp-pppoe</c> do
pracy w trybie jądra PPPoE.
</p>

<p>
Nie zapomnij wkompilować sterownika dla swojej karty sieciowej.
</p>

<p>
Zaznacz właściwe wsparcie dla bus:
</p>

<pre caption="Aktywowanie SBUS/UPA">
Console drivers ---&gt;
  Frame-buffer support ---&gt;
    [*] SBUS and UPA framebuffers
      [*] Creator/Creator3D support     <comment>(Wyłącznie dla slotów UPA używanych w wielu maszynach Ultra)</comment>
    [*] CGsix (GX,TurboGX) support      <comment>(Wyłącznie dla SBUS slot adapter używanego w wielu Sparcach)</comment>
</pre>

<p>
Oczywiście potrzebne będzie też wsparcie dla OBP:
</p>

<pre caption="Aktywowanie wsparcia dla OBP">
Misc Linux/SPARC drivers ---&gt;
  [*]  /dev/openprom device support
</pre>

<p>
Potrzebujesz również wsparcia dla SCSI:
</p>

<pre caption="Aktywowanie wsparcia dla SCSI">
SCSI support ---&gt;
  SCSI low-level drivers ---&gt;
    &lt;*&gt; Sparc ESP Scsi Driver             <comment>(Wyłącznie dla SPARC ESP on-board SCSI adapter)</comment>
    &lt;*&gt; PTI Qlogic, ISP Driver            <comment>(Wyłącznie dla kontrolerów  SBUS SCSI controllers z PTI lub QLogic)</comment>
    &lt;*&gt; SYM53C8XX Version 2 SCSI support  <comment>(Wyłącznie dla Ultra 60 on-board SCSI adapter)</comment>
</pre>

<p>
Aby mieć wsparcie dla karty sieciowej zaznacz jedną z następujących opcji:
</p>

<pre caption="Aktywowanie wsparcia dla karty sieciowej">
Network device support ---&gt;
  Ethernet (10 or 100Mbit) ---&gt;
    &lt;*&gt; Sun LANCE support                   <comment>(Wyłącznie dla SPARCStation, starszych Ultra systems i opcji Sbus)</comment>
    &lt;*&gt; Sun Happy Meal 10/100baseT support  <comment>(Wyłącznie dla Ultra; wspiera rownież "qfe" quad-ethernet na PCI i Sbus)</comment>

 &lt;*&gt; DECchip Tulip (dc21x4x) PCI support <comment>(dla Netra, jak N1)</comment>
Ethernet (1000Mbit) ---&gt;
 &lt;*&gt; Broadcom Tigon3 support <comment>(nowsze Netra i Sun Fire)</comment>
 </pre>


<p>
Jeśli posiadamy komputer z czterema portami Ethernet (10/100 albo 10/100/1000)
to należy zwrócić uwagę, że kolejność tych portów jest różna od tej używanej
przez Solaris. Aby sprawdzić ustawienia należy skorzystać z narzędzi
<c>sys-apps/ethtool</c> i <c>mii-tool</c>.
</p>

<p>
Kiedy skończysz konfigurować jądro przejdź do paragrafu
<uri link="#compiling">Kompilacja i instalacja</uri>. Po kompilacji musisz
pamiętać o sprawdzeniu rozmiaru obrazu jądra:
</p>

<pre caption="Sprawdzanie rozmiaru obrazu jądra">
# <i>ls -lh vmlinux</i>
-rw-r--r--    1 root     root         2.4M Oct 25 14:38 vmlinux
</pre>

<p>
Jeśli (nieskompresowany) obraz jest jest większy niż 2.5 MB (dla Sparc32) lub
3.5 MB (dla Sparc64) musisz przekonfigurować swój kernel, tak aby obraz nie
przekraczał tego limitu. Jednym ze sposobów w jaki możesz to zrobić jest
skompilowanie możliwie jak największej ilości sterowników jako moduły. Jeśli
zignorujesz tą radę to system się nie uruchomi.
</p>

<note>
Jeśli używasz kernela 2.6.3, lub nowszego, to dla sparc64 możesz używać kernela
o maksymalnym rozmiarze 7.5 MB.
</note>

<p>
Jeśli kernel jest tylko odrobinę za duży możesz spróbować zmniejszyć go przy
pomocy polecenia <c>strip</c>
</p>

<pre caption="Stripowanie kernela">
# <i>strip -R .comment -R .note vmlinux</i>
</pre>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilacja i instalacja.</title>
<body>

<p>
Po skonfigurowaniu kernela przyszła pora na jego skompilowanie i
instalację. Opuść program konfiguracyjny i rozpocznij proces
kompilacji:
</p>

<pre caption="Kompilowanie kernela">
<comment>(dla kernela 2.4, sparc32)</comment>
# <i>make dep &amp;&amp; make clean vmlinux modules modules_install</i>

<comment>(dla kernela 2.4, sparc64)</comment>
# <i>make dep &amp;&amp; make clean vmlinux image modules modules_install</i>

<comment>(dla kernela 2.6, sparc32)</comment>
# <i>make &amp;&amp; make modules_install</i>

<comment>(dla kernela 2.6, sparc64)</comment>
# <i>make &amp;&amp; make image modules_install</i>
</pre>

<p>
Kiedy jądro skończy się kompilować przekopiuj jego obraz do katalogu
<path>/boot</path>.
</p>

<pre caption="Instalowanie kernela">
<comment>(dla kernela 2.4, sparc32)</comment>
# <i>cp vmlinux /boot/kernel-2.4.29</i>

<comment>(dla kernela 2.4, sparc64)</comment>
# <i>cp arch/sparc64/boot/image /boot/kernel-2.4.29</i>

<comment>(dla kernela 2.6, sparc32)</comment>
# <i>cp arch/sparc/boot/image /boot/kernel-2.6.11</i>

<comment>(dla kernela 2.6, sparc64)</comment>
# <i>cp arch/sparc64/boot/image /boot/kernel-2.6.11</i>

<comment>(Nie zapomnij o skopiowaniu pliku System.map)</comment>
# <i>cp System.map /boot</i>
</pre>

<p>
Zwykle mądrą decyzją jest skopiowanie tam również pliku konfiguracyjnego, który
posłużył do zbudowania jądra.
</p>

<pre caption="Tworzenie kopii zapasowej konfiguracji jądra">
# <i>cp .config /boot/config-2.4.29</i>
</pre>

<p>
Kiedy skończysz przejdź do paragrafu <uri link="#kernel_modules">Instalacja
osobnych modułów jądra</uri>.
</p>

</body>
</subsection>
</section>
<section id="kernel_modules">
<title>Instalacja osobnych modułów jądra.</title>
<subsection>
<title>Konfigurowanie modułów.</title>
<body>

<p>
Lista modułów, które chcesz aby były automatycznie ładowane przy starcie systemu
powinna znajdować się w pliku <path>/etc/modules.autoload.d/kernel-2.4</path>
(lub <path>kernel-2.6</path>). Czasem jeśli chcesz możesz dodać kilka opcji dla
modułów.
</p>

<p>
Żeby przejrzeć listę wszystkich dostępnych użyj komendy <c>find</c>. Oczywiście
powinieneś zastąpić słowa "&lt;wersja jądra&gt;" numerem świeżo skompilowanego
kernela.
</p>

<pre caption="Znajdowanie dostępnych modułów">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname
# '*.ko'</i>
</pre>

<p>
Na przykład aby automatycznie ładować do pamięci moduł <c>3c59x.o</c> wyedytuj
plik <path>kernel-2.4</path> lub <path>kernel-2.6</path> i wprowadź do niego
nazwę tego modułu.
</p>

<pre caption="Edycja /etc/modules.autoload.d/kernel-2.4">
<comment>(przykład dla kerneli 2.4)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 lub kernel-2.6">
3c59x
</pre>

<p>
Po ukończeniu wszystkich czynności opisanych w tym rozdziale można przejść do
<uri link="?part=1&amp;chap=8">konfigurowania systemu</uri>.
</p>

</body>
</subsection>
</section>
</sections>
