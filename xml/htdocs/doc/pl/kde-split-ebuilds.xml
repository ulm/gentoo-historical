<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/kde-split-ebuilds.xml,v 1.7 2005/09/10 10:41:22 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/kde-split-ebuilds.xml" lang="pl">

<title>Rozdzielone ebuildy KDE</title>

<author title="Autor">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Tłumaczenie">
   Robert Frączek
</author>

<abstract>
Wraz z KDE 3.4 zostały wprowadzone do drzewa Portage rozdzielone ebuildy. Ten
poradnik opisuje nowe możliwości, które one nam dają.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2005-07-02</date>

<chapter>
<title>Rozdzielone ebuildy KDE.</title>
<section>
<title>Czym one są?</title>
<body>

<p>
Do stycznia 2005 roku wszystkie te ebuildy w Portage były monolityczne. Było ich
tylko 15 i każdy instalował wiele aplikacji, które w zasadzie nie były zależne
od siebie. Nie była to do końca optymalna sytuacja i z pewnością niezbyt zgodna
z założeniami Gentoo, jednak była tolerowana przez
długi okres czasu.
</p>

<p>
Nowe rozdzielone pakiety poprawiły tą sytuację dostarczając odseparowane ebuildy
dla każdej poszczególnej aplikacji KDE. To dało nam całkowitą liczbę 330 nowych
ebuildów w kategorii kde-base.
</p>

<p>
Ciągle udostępniamy monolityczne ebuildy dla KDE 3.4. Jednak to te rozdzielone
są nowym standardem i nie przewiduje się tworzenia tych monolitycznych
dla KDE w wersji 4.0.
</p>

<p>
Wreszcie, należało by wspomnieć, że istnieją także rozdzielone ebuildy dla
Koffice. Instalują one osobno takie programy jak kword, kugar itp.
</p>

</body>
</section>
<section>
<title>Jak instalować rozdzielone ebuildy</title>
<body>

<p>
W momencie pisania tego tekstu ostanim stabilnym wydaniem KDE było 3.4.1.
Zamaskowane rozdzielone i monolityczne ebuildy są dostępne w drzewie Portage.
</p>

<ul>
  <li>
    Aby zemergować poszczególne pakiety, takie jak np. kmail, po prostu
    wykonujemy <c>emerge kmail</c>
  </li>
  <li>
    Aby zemergować podstawowe środowisko kde, umożliwiające zalogowanie się do
    minimalnej sesji KDE, wpisujemy <c>emerge kdebase-startkde</c>
  </li>
  <li>
    Aby uzyskać dokładny odpowiednik jednego z monolitycznych pakietów - na
    przykład, aby zainstalować wszystkie aplikacje znajdujące się w
    <c>kdebase</c> za pomocą podzielonych ebuildów - można wykonać <c>emerge
    kdebase-meta</c> (lub kdepim-meta dla kdepim, itd.) Aby zainstalować
    absolutnie wszystkie rozdzielone ebuildy KDE używamy <c>emerge kde-meta</c>.
  </li>
</ul>

</body>
</section>
<section>
<title>Jak przejść z monolitycznego KDE na rozdzielone ebuildy?</title>
<body>

<p>
Kiedy jest zainstalowane KDE 3.3.x, można po prostu wpisać polecenie <c>emerge
kde-meta</c>, aby zainstalować rozdzielone KDE 3.4.x bez naruszania obecnej
instalacji.
</p>

<p>
Jeśli zainstalowane jest monolityczne KDE 3.4.x, trzeba najpierw je usunąć, a
dopiero potem przystąpić do instalacji wersji podzielonej. Można tego
dokonywać tylko na wybranych pakietach, nie trzeba od razu usuwać całości.
</p>

<p>
Nie należy obawiać się, że przejście na rozdzielone ebuildy może cokolwiek
zepsuć. Portage posiada system blokad, które zapewniają, że jeśli coś da się
bezpośrednio zainstalować, to będzie to działało prawidłowo.
</p>

</body>
</section>
<section>
<title>Zalety rozdzielonych ebuildów.</title>
<body>

<p>
Oto krótka lista korzyści z przejścia na rozdzielone ebuildy:
</p>

<ul>
  <li>
    Większość programów KDE nie zmienia się pomiędzy drugorzędnymi wydaniami
    KDE. Na przykład, aktualizacja KDE z wersji 3.3.1 na 3.3.2 zmienia mniej niż
    100 aplikacji z 320. Podzielone paczki, umożliwiają tworzenie nowych
    ebuildów tylko dla paczek, które zostały zmienione, oszczędzając (w tym
    przykładzie) więcej niż dwie trzecie czasu kompilacji na aktualizację.
  </li>
  <li>
    Poprawki zazwyczaj dotyczą konkretnych aplikacji. Dzięki nowej filozofii mogą
    być testowane, zatwierdzane i oddawane szybciej, a więc developerzy będą
    mieli mniej do zrobienia. Poza tym, jak już wyżej napisałem,
    zwykły użytkownik będzie zużywał znacznie mniej czasu na aktualizację, co jest
    to szczególnie ważne przy aktualizacjach związanych z bezpieczeństwem.
  </li>
  <li>
    Użytkownicy innych środowisk graficznych i lżejszych menadżerów okien mogą
    zemergować kilka aplikacji KDE, jeśli zechcą, bez ogromnych zależności, które
    powodowały stare ebuildy takie jak kdebase czy kdepim.
  </li>
  <li>
    Użytkownicy mogą wybrać teraz aplikacje jakie mają zainstalowane. Powody
    mogą być różne:

    <ul>
      <li>
  Zależy im na czasie kompilacji. <c>emerge kdebase kdepim kdenetwork</c>
  trwa strasznie długo, a tak naprawdę potrzebne im są jedynie konqueror,
  kmail i kopete.
      </li>
      <li>
  Zależy im na niezaśmiecaniu dysku. Każda nieużywana aplikacja sprawia, że
  cenne megabajty się marnują. Dysk z większą ilością wolnego miejsca
  też wtedy oddycha swobodniej; jest szybszym i szczęśliwszym dyskiem.
      </li>
      <li>
  Troszczą się o bezpieczeństwo systemu. Każde zainstalowane
  oprogramowanie jest potencjalnym celem ataku i dlatego nie należy
  instalować niczego co nie jest potrzebne.
      </li>
      <li>
  Dokładnie poznali <uri link="/main/en/philosophy.xml">
  filozofię Gentoo</uri> i nie mogą znieść tak wielu programów ściśniętych
  w jeden pakiet? My też nie możemy.
      </li>
    </ul>
  </li>
  <li>
    Ostatecznie, należy zaznaczyć, że rozdzielone ebuildy zapewniają znacznie
    większą elastyczność w definiowaniu dla nich flag USE.
  </li>
</ul>

</body>
</section>
<section>
<title>Współpraca rozdzielonych i monolitycznych ebuildów.</title>
<body>

<p>
Rozdzielone i monolityczne ebuildy mogą swobodnie razem współpracować. Jedynym
ograniczeniem jest to, że ebuild monolityczny nie może być jednocześnie
zainstalowany razem z rozdzielonym pochodzącym od niego. W ebuildach KDE
istnieją mechanizmy blokowania nie zezwalające na to, zatem można robić
wszystko na co tylko emerge pozwoli.
</p>

<p>
Jednak zwykle nie ma powodu, aby używać takich mieszanych konfiguracji. W
rzeczywistości, za wyjątkiem specjalnych przypadków jak na przykład bardzo wolne
komputery (mips), należy używać rozdzielonych ebuildów do wszystkich swoich
potrzeb.
</p>

<p>
Rozdzielone ebuildy są także tymi domyślnymi. Oznacza to, że kiedy jakieś inne
ebuildy zależą od aplikacji KDE to bedą chciały instalować właśnie te rozdzielone
ebuildy. Jednakże monolityczne ebuildy także spełnią te zależności, więc można
zemergować monolityczny ebuild ręcznie i wtedy dopiero ebuild który od niego
zależał.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problemy z wydajnością.</title>
<section>
<title>Dlaczego rozdzielone ebuildy są takie powolne?</title>
<body>

<p>
Mówiliśmy już <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=11123">dawno</uri>, że rozdzielone
ebuildy instalują się dłużej niż te monolityczne, ponieważ dodatkowo dla każdej
aplikacji musi zostać uruchomione rozpakowywanie i uruchamianie skryptu
konfiguracyjnego. Kompletne <c>emerge kde-meta</c> może zabrać około 20-30%
więcej czasu niż klasyczne <c>emerge kde</c>, które i tak zajmowało go już
mnóstwo.
</p>

<p>
Co więcej, teraz każdy z rozdzielonych ebuildów uruchamia <c>make -f
admin/Makefile.cvs</c> (to oznacza uruchomienie autoconf, automake, itd. oraz
kilka powiązanych specyficznych dla KDE skryptów). To powoduje dodatkowe
narzuty czasowe w przybliżeniu równe tym spowodowanym przez skrypt configure.
</p>

<p>
Pozornie te analizy wyglądają mało optymistycznie. Jednak jest też kilka
czynników, które wynagradzają te spowolnienia - omówimy je w następnym paragrafie
</p>

<p>
Warto jeszcze raz podkreślić, że z rozdzielonymi ebuildami czas kompilacji przy
aktualizowaniu KDE może zostać skrócony nawet o połowę, a w niektórych
przypadkach nawet dziesięciokrotnie poprzez aktualizacje tylko tych
aplikacji KDE, które naprawdę się zmieniły. Korzyści jakie dają takie pojedyńcze
aktualizacje aplikacji zwykle wynagradzają z nawiązką czas stracony podczas
pierwszej instalacji KDE z nowych ebuildów.
</p>

<p>
W końcu instalacja całego KDE ma sens tylko jeżeli chcemy zobaczyć jakie
aplikacje zawiera KDE lub jeśli tworzymy środowisko dla wielu użytkowników.
Jednak większość ludzi używa tylko części z ponad 300 dostępnych aplikacji
KDE. Każdy kto naprawdę troszczy się o czas kompilacji, np. właściciele
starszych komputerów, mogą zyskać więcej czasu poprzez selektywną instalację
programów, niż straciliby w związku z dodatkowymi nakładami czasowymi o których
była mowa powyżej.
</p>

</body>
</section>
<section>
<title>W jaki sposób rozdzielone ebuildy mogą być szybsze?</title>
<body>

<p>
Najbardziej oczywistym udoskonaleniem byłoby udostępnianie osobnych pakietów dla
rozdzielonych ebuildów, zamiast wypakowywania części z monolitycznych paczek
(kdebase itp.) narzuconych odgórnie. To wyeliminowałoby dwa z trzech czynników
spowalniających rozdzielone ebuildy: powtarzające się rozpakowywanie ogromnych
paczek oraz fazę ponownego uruchamiania (<c>make -f admin/Makefile.cvs</c>).
</p>

<p>
Pozostaje też jeszcze problem powtarzającego się uruchamiania skryptu
configure. Dobrym rozwiązaniem tego problemu jest confcache: bufor dla skryptów
configure dostępny pomiędzy kolejnymi działaniami emerge. Implementacja
confcache aktualnie istnieje w rozwojowej gałęzi portage (narzędzia, nie drzewa
Portage); stabilne wydanie z funkcją confcache spodziewane jest w połowie tego
roku.
</p>

</body>
</section>
<section>
<title>Pozostałe czynniki powodujące spowolnienia rozdzielonych ebuildów.</title>
<body>

<p>
W poprzedniej sekcji przedstawione zostały potencjalne metody zwiększenia
wydajności rozdzielonych ebuildów. Teraz po krótce wspomnimy o przyszłych
udogodnieniach, które także będą mogły być stosowane dla monolitycznych
ebuildów. Pozwolą one stać się rozdzielonym ebuildom wystarczająco szybkimi,
niezależnie od porównań z wykorzystującymi mniej funkcjonalności monolitycznymi
ebuildami.
</p>

<ul>
  <li>
    KDE 4.0 powinno być w stanie wykorzystywać nowe rozwiązanie <uri
    link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri>
    zamiast automake, które może przyspieszyć kompilację w niektórych
    przypadkach; nasze ebuildy KDE 3.4 bedą także mogły wykorzystać unsermake.
  </li>
  <li>
    Rozdzielone ebuildy posiadają flagę USE kdexdeltas, która pozwala na
    pobieranie binarnych różnic pomiędzy kolejnymi wydaniami pakietów w celu
    zmniejszenia zużycia przepustowości łącz.
  </li>
  <li>
    Wszystkie pozostałe narzędzia zaangażowane w budowanie aplikacji także
    generalnie zwiększą swoją wydajność z czasem, albo umożliwią różne oparte na
    kompilacji KDE przyspieszenia. visibility=hidden (GCC 3.4) oraz
    prekompilowane nagłówki (GCC 4.0) prezentują dwa ostatnie przykłady. Nie są
    one zaletami wynikającymi z używania nowych ebuildów; oznaczają, że możemy
    pozwolić sobie na kompilacje intensywniej wykorzystujące procesor.
  </li>
</ul>

</body>
</section>
</chapter>
<chapter>
<title>Rozdzielone ebuildy - często zadawane pytania.</title>
<section>
<title>Czy nie możemy zrobić teraz tego samego z wykorzystaniem DO_NOT_COMPILE?</title>
<body>

<p>
DO_NOT_COMPILE jest zmienną środowiskową wewnętrznego systemu budowania KDE.
Umożliwia selektywne wyłączanie podkatalogów z kompilacji. Niektórzy ludzie
używali jej do kompilacji tylko części monolitycznego ebuildu KDE. Na przykład,
uruchomienie polecenia <c>DO_NOT_COMPILE=konqueror emerge kdebase</c>
zainstalowałoby kdebase bez konquerora.
</p>

<p>
Jednak DO_NOT_COMPILE nigdy nie było w założeniach narzędziem mającym ingerować
w operacje menadżera automatycznego budowania pakietów. To po prostu nie działa,
może nawet zepsuć system, a poza tym nie było nigdy wspierane. Namawiamy
wszystkich, żeby wystrzegali się używania tego narzędzia.
</p>

<p>
A oto kawałek z listy problemów związanych z DO_NOT_COMPILE:
</p>

<ul>
  <li>
    Kompletnie psuje system śledzenia zależności zaimplementowany w Portage.
    Portage nie wie nic o DO_NOT_COMPILE i myśli że cały monolityczny pakiet
    został skompilowany i zainstalowany, więc uważa, że dana zależność musi
    być spełniona. Może to spowodować, że inne programy nie będą się chciały
    zbudować albo poprostu się nie uruchomią.
  </li>
  <li>
    Wymusza na użytkowniku konieczność znajomości nazw i znaczenia wszystkich
    istniejących podkatalogów z modułów KDE. Bardzo niewielu użytkowników poza
    developerami KDE, posiada o tym wiedzę, a więc mało kto jest w stanie
    odpowiednio używać DO_NOT_COMPILE.
  </li>
  <li>
    Poszczególne moduły w podkatalogach KDE mogą być powiązane między sobą
    zależnościami, mogą wymagać określonego porządku budowania lub obecności
    innego katalogu nawet jeżeli nie ma być on instalowany. Włożyliśmy dużo
    pracy w rozdzielone ebuildy tak, aby działały poprawnie pod
    tym względem. DO_NOT_COMPILE nie jest nawet w części tak dobrym narzędziem,
    żeby potrafiło uzyskać takie rezultaty, nawet z odpowiednią wiedzą ze strony
    użytkownika. Jedyną rzeczą jaką można z nim zrobić jest wyłączenie kilku
    aplikacji z kompilacji. Jest praktycznie niemożliwym, aby z pomocą tego
    narzędzia zainstalować tylko kilka aplikacji z modułu takiego jak kdebase
    czy kdepim.
  </li>
  <li>
    Jeśli zainstalowałem powiedzmy kmail wczoraj i dzisiaj chciałbym
    zainstalować korn używając DO_NOT_COMPILE, pociągnie to za sobą ponowną
    rekompilację kmail. Oznacza to, że DO_NOT_COMPILE jest zawsze dużo
    wolniejsze od rozdzielonych ebuildów.
  </li>
  <li>
    DO_NOT_COMPILE nie może zostać użyte do budowanie prekompilowanych paczek
    (takich jak GRP) zawierających pojedyńcze aplikacje KDE.
  </li>
</ul>

</body>
</section>
<section>
<title>Czy nie powoduje to zbyt wielkiego obciążenia opiekunów KDE w Gentoo?</title>
<body>

<p>
Co ciekawe, to pytanie było zadawane bardzo często. Jest mi bardzo miło, że
użytkownicy tak dbają o nas, opiekunów ebuildów. Korzystając ze sposobności chcę
zapewnić, że zajęliśmy się rozdzielonymi ebuildami KDE z własnej,
nieprzymuszonej woli i że nie ma szans żeby ktoś nas od tego odwiódł. :-)
</p>

<p>
Powinienem jeszcze wspomnieć, że opiekunowie innych architektur rzeczywiście
narzekali, że będą musieli włożyć więcej wysiłku w testowanie i oznaczanie
statusu mnóstwa ebuildów. Pracujemy nad rozwiązaniem tego problemu i właśnie to
jest głównym powodem dla którego monolityczne ebuildy są jeszcze dostępne
dla KDE 3.4.
</p>

</body>
</section>
<section>
<title>Czy zamierzacie całkowicie usunąć stare (monolityczne) ebuildy?</title>
<body>

<p>
Ostatecznie taki jest plan. Jednak, dla wszystkich wydań KDE 3.4 będą dostępne
zarówno stare, jak i nowe wersje ebuildów.
</p>

<p>
Jeśli ktoś preferuje monolityczne ebuildy zamiast tych rozdzielonych, niech <uri
link="http://bugs.gentoo.org">poda</uri> nam swoje powody.
</p>

</body>
</section>
<section>
<title>Teraz jest tyle ebuildów! Jak mam odnaleźć ten, którego właśnie potrzebuję?</title>
<body>

<p>
Więc, po pierwsze, jeśli wiesz, że pakiet jakiego szukasz był w kdebase, możesz
ją otrzymać poprzez <c>emerge kdebase-meta</c> co da taki sam rezultat jak
zemergowanie monolitycznego <c>kdebase</c>. A więc nie ma tu żadnych
niedogodności w związku z nowymi ebuildami.
</p>

<p>
Oczywiście wszystkie standardowe metody wyszukiwania paczek także działają. To
tak samo jak szukanie aplikacji Gnome... Wystarczy znajomość nazwy aplikacji,
której się szuka.
</p>

<p>
Sytuacja mogłaby prawdopodobnie się poprawić dzięki wprowadzenie większej ilości
-meta ebuildów. Są one tylko listami zależności, a więc nie kosztują wiele
pracy. Jednak nie zdecydowaliśmy się jeszcze na to. Byłoby jednak miło gdyby
Portage zyskało odpowiednią funkcjonalność zanim zajmiemy się tym szerzej.
</p>

</body>
</section>
<section>
<title>Jak odmergować stare KDE?</title>
<body>

<p>
Przypuśćmy, że wychodzi KDE 4.0 i chcemy odmergować rozdzielone ebuildy dla
KDE 3.4. Ponieważ przynależą do różnych slotów, emerge nie zrobi tego za nas,
a więc potrzebujemy innego rozwiązania.
</p>

<p>
Dobre rozwiązane tego problemu wymaga modyfikacji Portage. Jedno z możliwych
wyjść jest opisane w <uri link="/proj/en/glep/glep-0021.html">GLEP 21</uri>.
Jednak zanim zostanie to zaimplementowane musimy skorzystać ze skryptów takich
jak ten poniżej.
</p>

<p>
Na szczęście, wszystkie ebuildy KDE należą do katalogu kde-base (i wszystkie
ebuildy w katalogu kde-base pochodzą z kde.org). Zatem poprawny jest poniższy
kod:
</p>

<pre caption="Usuwanie aplikacji z KDE">
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
Powyższy kod wygląda nieco dziwnie, ale ostatecznie to nic strasznego, bo
przecież potrzebujemy tylko listę ebuildów z katalogu kde-base. Proste zadanie -
a więc i proste rozwiązanie.
</p>

</body>
</section>
<section>
<title>Jak wylistować/odmergować wszystkie rozdzielone ebuildy pochodzące z danej paczki?</title>
<body>

<p>
Można to przetłumaczyć na wylistowanie wszystkich rozdzielonych ebuildów KDE
pochodzących z, powiedzmy, monolitycznego ebuilda KDE. Jeszcze raz, odpowiednia
implementacja (taka jak <uri link="/proj/en/glep/glep-0021.html">GLEP 21</uri>)
sprawi, że będzie to trywialne. Jednak dzisiaj, musimy się zapoznać w pewnym
stopniu z implementacją eclass KDE.
</p>

<p>
kde-functions.eclass definiuje funkcje zwane get-parent-package() oraz
get-child-packages() które przeprowadzają tłumaczenie za użytkownika. Te dwie
funkcje są poprawnym rozwiązaniem dla postawionego problemu i mogą zostać
wykonane z jakiegoś ebuilda albo zewnętrznego skryptu bash. Na przykład:
</p>

<pre caption="Implementacja eclass KDE">
$ <i>function die() { echo $@; } # pokazuj błędy</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # nie zadziała, potrzebna jest pełna nazwa</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug # zwrócenie błędu</i>
$ <i>get-parent-package kde-base/konqueror # pełnowartościowa nazwa pakietu</i>
<i>kde-base/kdebase # zwrócony wynik</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (długa lista paczek)</i>
</pre>

<p>
Jeśli skrypt nie został napisany w bashu należy przegrepować
kde-functions.eclass w celu wyodrępnienia definicji zmiennej KDE_DERIVATION_MAP,
której używają wyżej wymienione funkcje. Zmienna ta zawiera oddzieloną białymi
znakami listę słów, każde dwa kolejne słowa przyporządkowują paczkę rodzica
do rozdzielonego pliku ebuild - dziecka.
</p>

</body>
</section>
</chapter>
</guide>
