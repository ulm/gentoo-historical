<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/usb-guide.xml,v 1.3 2005/08/30 06:16:27 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/usb-guide.xml" lang="pl">
<title>Konfiguracja urządzeń USB w Gentoo Linux</title>

<author title="Autor">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Tłumacz">
  Paweł Kwiatkowski
</author>

<abstract>
Dokument pomaga użytkownikom Gentoo zainstalować oraz skonfigurować różne
urządzenia podłączane przez USB.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2005-08-25</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Co to jest USB?</title>
<body>

<p>
USB to skrót od Universal Serial Bus (uniwersalna szyna szeregowa). Jest to
standard zewnętrznego interfejsu, który umożliwia komunikację między
komputerem, a innymi urządzeniami. Obecnie do najpopularniejszych urządzeń USB
zaliczają się klawiatury, myszki, karty pamięci, aparaty cyfrowe, zewnętrzne
napędy CD, nagrywarki DVD, drukarki oraz wiele innych urządzeń.
</p>

<p>
W użyciu są dwie wersje USB, tj. USB 1.1 i USB 2.0. Ze względu na zgodność z
poprzednimi wersjami USB 2.0 jest kompatybilne z USB 1.1. Najnowsze urządzenia
USB są zazwyczaj zgodne ze standardem USB 2.0. Złącze USB 2.0 pozwala na
transmisję z maksymalną prędkością 480 Mbps lub 60 Mbps. Jest to zasadnicza
różnica pomiędzy obydwoma standardami.  Kolejną zaletę USB stanowi fakt, że
wszystkie urządzenia USB są typu <e>hot-pluggable</e>.  Oznacza to, że po
podłączeniu nie musimy ponownie uruchamiać systemu, aby ich używać.
</p>

</body>
</section>
<section>
<title>Spojrzenie techniczne</title>
<body>

<p>
Zanim zajmiemy się dokładną konfiguracją kernela, warto przyjrzeć się trochę
bliżej samemu USB. Jeśli nie mamy na to czasu lub chcemy pominąć ten akapit, to
można przejść od razu do <uri link="#kernel">konfiguracji kernela</uri>.
</p>

<p>
Sieć USB posiada główny kontroler, huby, wśród których wyróżniamy <e>główny
hub</e> i może wspierać do 127 urządzeń USB, wliczając w to huby. Główny
kontroler jest niczym innym, jak interfejsem sprzętowym pomiędzy urządzeniem
USB i systemem operacyjnym. Istnieje kilka takich sprzętowych interfejsów (HCI
- Host Controller Interface), są to: OHCI (Open HCI) Compaq, UHCI (Universal
HCI) oraz EHCI (Enhanced HCI), obydwa Intela. OHCI/UHCI są przemysłowymi
standardami dla interfejsów  USB 1.1, natomiast EHCI jest standardem dla USB
2.0.
</p>

<p>
Producent sprzętu dostarcza programistom interfejs, przez który system może
komunikować się ze sprzętem. Interfejs ten określany jest mianem HCD (Host
Controller Device). Właśnie przez ten interfejs urządzenia komunikują się z
oprogramowaniem systemowym. Poniższy diagram powinien ułatwić zrozumienie
zagadnienia.
</p>

<pre caption="Ogólna architektura USB">
<comment>(Oprogramowanie jak i warstwa sprzętowa składają się z innych
komponentów, które dla uproszczenia nie są tu przedstawione)</comment>

    + ----  Sprzęt    ----   + ----  Oprogramowanie ---- +
    |                        |                           |
    | [USB Dev] -+-> {EHCI} -+--->  ( EHCD )             |
    |            |           |                           |  Użytkownik
    |            `-> {UHCI} -+--->  ( UHCD )             |
    |                        |                           |
    + ----  Sprzęt    ----   + ----  Oprogramowanie ---- +
</pre>

<p>
Urządzenie USB może korzystać z własnego sterownika lub użyć jednego z już
dostępnych w systemie. Oparte jest to na pomyśle <e>klasy</e> urządzeń. Jeśli
urządzenie należy do pewnej <e>klasy</e>, to inne urządzenia należące do tej
samej <e>klasy</e> mogą korzystać z tego samego sterownika. Niektóre z tych
<e>klas</e> to np. USB HID (Human Interface Devices), która obejmuje urządzenia
sterujące takie jak klawiatury i myszki, klasa urządzeń USB masowego
składowania, która obejmuje karty pamięci, aparaty cyfrowe, odtwarzacze audio
itp. oraz klasa USB CDC (Communication Devices Class), która zawiera modemy USB
i podobne urządzenia.
</p>

</body>
</section>
<section>
<title>Co znajduje się na naszej maszynie?</title>
<body>

<p>
To czy nasza maszyna posiada USB 2.0 czy nie, łatwo sprawdzić. W tym celu
posłużymy się komendą <c>lspci</c>.
</p>

<note>
Narzędzie <c>lspci</c> jest częścią pakietu <c>sys-apps/pciutils</c>. Jeśli nie
zainstalowaliśmy tego pakietu, to wykonujemy <c>emerge pciutils</c>. Należy
zaznaczyć, że z komendy <c>lspci</c> korzystamy z konta użytkownika root.
</note>

<pre caption="Różne efekty wywołania lspci">
<comment>(W systemie, który jest zgodny z USB 1.1, widzimy tylko UHCI)</comment>

# <i>lspci -v | grep USB</i>
0000:00:04.2 USB Controller: Intel Corp. 82371AB/EB/MB PIIX4 USB (rev 01) (prog-if 00 [UHCI])

<comment>(System, który jest zgodny z USB 2.0, zauważamy EHCI i UHCI)</comment>

00:1d.0 USB Controller: Intel Corp. 82801DB USB (Hub #1) (rev 01) (prog-if 00 [UHCI])
00:1d.1 USB Controller: Intel Corp. 82801DB USB (Hub #2) (rev 01) (prog-if 00 [UHCI])
00:1d.2 USB Controller: Intel Corp. 82801DB USB (Hub #3) (rev 01) (prog-if 00 [UHCI])
00:1d.7 USB Controller: Intel Corp. 82801DB USB EHCI Controller (rev 01) (prog-if 20 [EHCI])
</pre>

<p>
Używając komendy <c>lspci</c> możemy sprawdzić czy system wspiera USB 2.0. Może
być to użyteczne, gdy będziemy włączać odpowiednie opcje w kernelu.
</p>

</body>
</section>
</chapter>

<chapter id="kernel">
<title>Konfiguracja kernela</title>
<section>
<title>Pobieranie kernela</title>
<body>

<note>
Począwszy od wydania 2005.0, Gentoo Linux używa standardowo kernela z rodziny
2.6. Na <e>większości</e> architektur będzie to pakiet <c>gentoo-sources</c>,
chyba że używamy profilu z wersją 2.4. Sprawdzamy wersję naszego kernela i dalej
postępujemy odpowiednio do niej.
</note>

<p>
Na początku pobieramy wybrane źródła kernela. W podręczniku korzystamy z
<c>gentoo-sources</c>.  Więcej informacji o krenelach dostępnych w Portage
można znaleźć w <uri link="/doc/pl/gentoo-kernel.xml">przewodniku po kernelu w
Gentoo Linux</uri>.
</p>

<pre caption="Pobieranie źródeł kernela">
# <i>emerge gentoo-sources</i>
</pre>

<p>
Zabieramy się do konfiguracji kernela.
</p>

<pre caption="Przejście do źródeł">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<note>
W powyższym przykładzie zakładamy, że dowiązanie symboliczne
<path>/usr/src/linux</path> wskazuje na źródła kernela, które chcemy
wykorzystać. Przed rozpoczęciem musimy się upewnić, że faktycznie tak jest.
</note>

</body>
</section>
<section id="2.6.xconfig">
<title>Opcje konfiguracyjne dla kernela z serii 2.6.x</title>
<body>

<p>
Musimy przyjrzeć się opcjom konfiguracyjnym, które należy włączyć w kernelu
2.6, by zapewnić prawidłowe wsparcie dla naszych urządzeń USB. Jeśli korzystamy
z kernela serii 2.4, to postępujemy zgodnie z <uri link="#2.4.xconfig">opcjami
konfiguracyjnymi dla kerneli z serii 2.4.x</uri>.
</p>

<note>
Przykłady zawarte w tym przewodniku zawierają opcje podstawowego wsparcia dla
USB, a także dla powszechnie używanych urządzeń, np. urządzenia masowego
składowania danych (większość aparatów i kart pamięci USB). W przypadku
posiadania nietypowego urządzenia, które wymaga konfiguracji, zalecamy zapoznać
się z podręcznikiem dołączonym do urządzenia albo poszukać informacji w sieci o
tym czy urządzenie jest obsługiwane przez kernel lub czy istnieją dedykowane
sterowniki, z których możemy skorzystać. W przykładach, dla uproszczenia,
wsparcie dla USB zostało wkompilowane w kernel. Jeśli chcemy posiadać modularny
kernel, to musimy odpowiednio dostosować pliki konfiguracyjne i pamiętać o
różnych modułach.
</note>

<pre caption="Opcje make menuconfig dla kerneli z serii 2.6">
Device Drivers  ---&gt;
  SCSI device support  ---&gt;

<comment>(Wybierając USB Mass Storage możemy być pewni, że obsługa SCSI zostanie
włączona, jednak musimy zadbać o włączenie obsługi dysku)</comment>
---   SCSI support type (disk, tape, CD-ROM)
&lt;*&gt;   SCSI disk support

<comment>(Cofamy się o jeden poziom, do opcji USB support)</comment>
USB support  ---&gt;

<comment>(Główny hub jest wymagany dla wsparcia USB. Jeśli skompilujemy to jako
moduł, będzie dostępny pod nazwą usbcore)</comment>
&lt;*&gt; Support for Host-side USB

<comment>(Wybieramy tę opcję, by urządzenia USB pojawiały się w /proc/bus/usb.
Opcja zalecana.)</comment>
 [*]   USB device filesystem

<comment>(Wybieramy przynajmniej jeden HCD. Jeśli brak nam pewności,
to wybieramy wszystkie)</comment>
--- USB Host Controller Drivers
&lt;*&gt; EHCI HCD (USB 2.0) support
&lt; &gt; OHCI HCD support
&lt;*&gt; UHCI HCD (most Intel and VIA) support

<comment>(Schodząc trochę niżej dochodzimy do urządzeń CDC i urządzeń masowego
składowania danych)</comment>
&lt; &gt; USB Modem (CDC ACM) support
&lt;*&gt; USB Printer support
&lt;*&gt; USB Mass Storage support
 [*]   USB Mass Storage Write-Protected Media Detection (EXPERIMENTAL)

<comment>(Jeśli posiadamy urządzenia USB takie jak: klawiatura, mysz, joystick lub inne urządzenia
sterujące, to musimy zaznaczyć wsparcie dla HID)</comment>
--- USB Input Devices
&lt;*&gt; USB Human Interface Device (full HID) support
 [*]   HID input layer support

<comment>(Jeśli posiadamy kartę sieciową USB, np. RTL8150, to będziemy potrzebować poniższego)</comment>
USB Network Adapters  --->
    &lt;*&gt; USB RTL8150 based ethernet device support (EXPERIMENTAL)

<comment>(Jeśli posiadamy przejściówkę typu złącze szeregowe USB, np. Prolific
2303, to zaznaczamy poniższe opcje)</comment>
USB Serial Converter support  --->
    &lt;*&gt; USB Serial Converter support
    &lt;*&gt; USB Prolific 2303 Single Port Serial Driver (NEW)
</pre>

<p>
Wszystkie opcje zostały ustawione. Teraz możemy zbudować kernel i wsparcie dla
USB powinno funkcjonować po uruchomieniu systemu z nowym kernelem. Możemy teraz
<uri link="#postkern">obejrzeć USB w akcji</uri> i zobaczyć czy wszystko
działa, tak jak powinno.
</p>

</body>
</section>
<section id="2.4.xconfig">
<title>Opcje konfiguracyjne dla kerneli z serii 2.4.x</title>
<body>

<p>
Musimy przyjrzeć się opcjom konfiguracyjnym, które należy włączyć w kernelu z
serii 2.4, by zapewnić prawidłowe wsparcie dla naszych urządzeń USB. Jeśli
korzystamy z kernela z serii 2.6, to zachęcamy do zapoznania się z <uri
link="#2.6.xconfig">opcjami konfiguracyjnymi dla kernela z serii 2.6.x</uri>.
</p>

<note>
Przykłady zawarte w tym przewodniku zawierają opcje podstawowego wsparcia dla
USB, a także dla powszechnie używanych urządzeń, np. urządzenia masowego
składowania danych (większość aparatów i kart pamięci USB). W przypadku
posiadania nietypowego urządzenia, które wymaga konfiguracji, zalecamy zapoznać
się z podręcznikiem dołączonym do urządzenia albo w sieci poszukać informacji,
o tym czy urządzenie jest obsługiwane przez kernel lub czy istnieją dedykowane
sterowniki, z których możemy skorzystać. W przykładach, dla uproszczenia,
wsparcie dla USB zostało wkompilowane w kernel. Jeśli chcemy posiadać modularny
kernel, to musimy odpowiednio dostosować pliki konfiguracyjne i pamiętać o
różnych modułach.
</note>

<pre caption="Opcje make menuconfig dla kerneli z serii 2.4">
<comment>(Następujące opcje konfiguracyjne przeznaczone są tylko dla tych, którzy posiadają
urządzenai sterujące na USB. Opcja Input core support jest później potrzebna dla
USB HID) </comment>
Input core support  ---&gt;
   &lt;*&gt; Input core support
   &lt; &gt;   Keyboard support
   &lt; &gt;   Mouse support
   &lt; &gt;   Event interface support

USB support  ---&gt;

<comment>(Główny hub jest wymagany dla wsparcia USB. Jeśli skompilujemy to jako moduł, będzie dostępny
pod nazwą usbcore.o)</comment>
&lt;*&gt; Support for USB

<comment>(Wybieramy tę opcję, by urządzenia USB pojawiały się w /proc/bus/usb.
Opcja zalecana)</comment>
 [*]   Preliminary USB device filesystem

<comment>(Wybieramy przynajmniej jeden HCD. Jeśl brak nam pewności, to wybieramy
wszystkie)</comment>
--- USB Host Controller Drivers
&lt;*&gt;   UHCI Alternate Driver (JE) support
&lt; &gt;   OHCI (Compaq, iMacs, OPTi, SiS, ALi, ...) support

<comment>(Sekcja z urządzeniami. Wybieramy tylko to czego
potrzebujemy)</comment>
--- USB Device Class drivers
&lt; &gt;   USB Audio support
&lt;*&gt;   USB Mass Storage support
&lt; &gt;   USB Modem (CDC ACM) support
&lt;*&gt;   USB Printer support

<comment>(Następnie sekcja z HID. Zaznaczamy tę opcję, o ile posiadamy
urządzenia sterowania na USB)</comment>
--- USB Human Interface Devices (HID)
&lt;*&gt;   USB Human Interface Device (full HID) support
 [*]     HID input layer support

<comment>(Jeśli posiadamy przejściówkę typu złącze szeregowe-USB, np. Prolific
2303, to zaznaczamy poniższe opcje)</comment>
USB Serial Converter support  --->
    &lt;*&gt; USB Serial Converter support
    &lt;*&gt; USB Prolific 2303 Single Port Serial Driver (NEW)
</pre>

<p>
Wszystkie opcje zostały ustawione. Teraz możemy zbudować kernel i wsparcie dla USB
powinno funkcjonować po uruchomieniu systemu z nowym kernelem.
</p>

</body>
</section>
</chapter>

<chapter id="postkern">
<title>Oglądanie USB w akcji</title>
<section>
<title>dmesg naszym przyjacielem!</title>
<body>

<p>
Nadszedł czas, by zacząć zabawę z urządzeniami USB :) Rozpocznijmy więc.  W
bieżącym rozdziale zobaczymy jak system odpowiada na różne urządzenia USB.
Zaczniemy od podłączenia 512MB karty pamięci USB (ang. memory stick/pen drive).
Można tez użyć podobny urządzeń do masowego składowania danych. Na początku
użyjemy polecenia <c>dmesg</c>, by zobaczyć reakcję systemu na podłączenie
urządzenia.
</p>

<note>
<c>dmesg</c> zazwyczaj dostarcza wielu informacji pochodzących z bufora
przestrzeni jądra. Są tam zawarte wszystkie informacje ze startu systemu. Część
z nich możemy pominąć i odszukać te, które nas interesują. W naszych
przykładach wynik działania polecenia <c>dmesg</c> zawiera tylko istotne
fragmenty oraz dodatkowe znaki odstępu, które mają poprawić czytelność. W razie
potrzeby możemy użyć <c>dmesg | more</c> lub <c>dmesg | less</c>.
</note>

<pre caption="Wynik działania dmesg dla karty pamięci">
<comment>(Wsuwamy kartę pamięci w dostępny port USB, a następnie...)</comment>
# <i>dmesg | less</i>

<comment>(urządzenie jest wykrywane jako zgodne z USB 1.1 i otrzymuje adres.
Pojawia się także informacja, z jakiego HCD korzysta.)</comment>
usb 1-1: new full speed USB device using uhci_hcd and address 2

<comment>(Automatycznie włącza się emulacja SCSI)</comment>
scsi0 : SCSI emulation for USB Mass Storage devices
usb-storage: device found at 2

<comment>(Następnie pobierana jest informacja o urządzeniu, zawierająca numer modelu)</comment>
usb-storage: waiting for device to settle before scanning
  Vendor: JetFlash  Model: TS512MJF2A        Rev: 1.00
  Type:   Direct-Access                      ANSI SCSI revision: 02
SCSI device sda: 1003600 512-byte hdwr sectors (514 MB)

<comment>(Wykrywanie zabezpieczenia przed zapisem jest
EKSPERYMENTALNE, w późniejszych kernelach)</comment>
sda: Write Protect is off
sda: Mode Sense: 0b 00 00 08
sda: assuming drive cache: write through
SCSI device sda: 1003600 512-byte hdwr sectors (514 MB)
/dev/scsi/host0/bus0/target0/lun0: p1
Attached scsi removable disk sda at scsi0, channel 0, id 0, lun 0
Attached scsi generic sg0 at scsi0, channel 0, id 0, lun 0,  type 0
usb-storage: device scan complete
<comment>(Od tego momentu urządzenie jest zazwyczaj dostępne przez zamontowanie /dev/sda1)</comment>

<comment>(Gdy urządzenie jest odłączane, system powiadamia o tym w ten sam sposób)</comment>
usb 1-1: USB disconnect, address 2
</pre>

<p>
Po podłączeniu i zamontowania urządzenia, można się do niego odwoływać jak do
zwykłego dysku twardego. Działają standardowe operacje typu <c>cp</c>,
<c>mv</c>, <c>rm</c> itp. Na karcie pamięci USB możemy także utworzyć system
plików i sformatować go.
</p>

<pre caption="Dostęp do karty pamięci">
# <i>mount /dev/sda1 /mnt/usb</i>
# <i>df -h</i>
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda8             9.4G  7.5G  1.9G  80% /
/dev/hda9              11G  8.1G  2.4G  78% /usr
none                  189M     0  189M   0% /dev/shm
/dev/sda1             490M   34M  457M   7% /mnt/usb
</pre>

<note>
Dostęp do aparatów cyfrowych może być uzyskany w taki sam sposób, jak do kart
pamięci.  Autor niniejszego przewodnika posiada aparat Nikon Coolpix 5200 i
odwołuje się do niego w opisany sposób. Aparaty obecnie przesyłają obrazy na dwa
sposoby: poprzez USB oraz poprzez PTP (Picture Transfer Protocol). Ten aparat
jest ustawiony tak, by zachowywał się jak pamięć masowa i procedura dostępu
wygląda dokładnie tak samo jak opisana wcześniej dla kart pamięci. Warto
zauważyć, że opisany sposób NIE musi działać w przypadku wszystkich aparatów
cyfrowych, które wspierają USB.
</note>

<p>
W jaki sposób będzie widoczna mysz USB, w przypadku gdy taką posiadamy? Pojawi
się jako urządzenie typu HID.
</p>

<pre caption="Optyczna mysz na USB">
# <i>dmesg | grep USB</i>
drivers/usb/input/hid-core.c: v2.0:USB HID core driver
usb 1-1: new low speed USB device using address 2
input: USB HID v1.10 Mouse [Logitech USB-PS/2 Optical Mouse] on usb-0000:00:07.2-1
</pre>

<p>
Kolejnym użytecznym poleceniem, dzięki któremu możemy sprawdzić stan portów
USB, jest <c>lsusb</c>. Stanowi część <c>sys-apps/usbutils</c> i będzie
omówione w następnym akapicie.
</p>

</body>
</section>
</chapter>

<chapter>
<title>USB w przestrzeni użytkownika</title>
<section>
<title>Użyteczne narzędzia</title>
<body>

<p>
Jak dotąd, zobaczyliśmy w jakim stopniu kernel Linuksa wspiera USB. Teraz
nadeszła chwila, by rzucić okiem na wsparcie oferowane przez Gentoo w
przestrzeni użytkownika.
</p>

<p>
Jednym z najbardziej użytecznych narzędzi jest <c>lsusb</c>. Pokazuje wszystkie
urządzenia usb podłączone do systemu. Instalacja zajmuje dosłownie chwilkę.
</p>

<pre caption="Instalacja pakietu usbutils">
# <i>emerge usbutils</i>
</pre>

<p>
Kiedy pakiet zostanie zainstalowany, to możemy uruchomić <c>lsusb</c>, by
otrzymać podstawowe informacje o urządzeniach USB podłączonych do komputera.
</p>

<note>
W większości przypadków wymagane są uprawnienia użytkownika root, by używać
<c>lsusb</c>.
</note>

<warn>
<c>lsusb</c> pobiera informacje o urządzeniach USB z pliku
<path>/proc/bus/usb</path>. Jeśli nie włączyliśmy tego w kernelu, to szanse, że
<c>lsusb</c> zadziała, są nikłe. Musimy się upewnić, że w kernelu jest włączone
wsparcie dla systemu plików <path>/proc</path> oraz że <c>usbfs</c> jest
zamontowany jako <path>/proc/bus/usb</path> (co powinno stać się
automatycznie).
</warn>

<pre caption="lsusb w akcji">
# <i>lsusb</i>
<comment>(512MB karta pamięci Transcend)</comment>
Bus 001 Device 003: ID 0c76:0005 JMTek, LLC. USBdisk
<comment>(myszka optyczna)</comment>
Bus 001 Device 002: ID 046d:c00e Logitech, Inc. Optical Mouse
<comment>(główny hub)</comment>
Bus 001 Device 001: ID 0000:0000
</pre>

<p>
Jeśli lubimy otrzymywać dużą ilość informacji, to mamy możliwość użycia
<c>lsusb -v</c>.  Możemy użyć tej komendy i obejrzeć informacje jakie uzyskamy.
Inną użyteczną opcją <c>lsusb</c> jest możliwość wyświetlenia fizycznej
hierarchii urządzeń USB jako drzewa. Pozwala to zrozumieć dokładną mapę
urządzeń. Ta komenda to <c>lsusb -t</c>. Dla przykładu,
</p>

<pre caption="lsusb - wyświetlanie hierarchii USB">
# <i>lsusb -t</i>
Bus#  1
`-Dev#   1 Vendor 0x0000 Product 0x0000
  |-Dev#   2 Vendor 0x046d Product 0xc00e
  `-Dev#   3 Vendor 0x0c76 Product 0x0005
</pre>

<p>
Możemy z łatwością powiązać wynik działania komend <c>lsusb</c> i <c>lsusb
-t</c>, co ułatwi usuwanie błędów i zrozumienie zasady działania USB.
</p>

</body>
</section>
<section>
<title>Hot czy cold plug??</title>
<body>

<p>
Gentoo używa dwóch pakietów, <c>sys-apps/hotplug</c> i
<c>sys-apps/coldplug</c>, do robienia magicznych sztuczek z urządzeniami typu
<e>hot plug</e>. Jak za większością magicznych trików, tak i za tymi, kryje się
logika. Zobaczymy jak to działa i w efekcie, będziemy w stanie lepiej zrozumieć
zasadę działania hot i cold plug.
</p>

<p>
Mianem firmware określamy oprogramowanie, dołączane do sprzętu, które jest
ładowane i wykonywane, lecz nie może być łatwo modyfikowane. Wiele urządzeń
posiada załączone firmware, by zapewnić prawidłową pracę sprzętu. Często
firmware może zawierać kod, który jest krytyczny do zapewnienia należytego
działania. Firmware jest obecne w szerokiej gamie urządzeń, poczynając od
układów ROM i kończąc na najnowszych kartach PCMCIA oraz USB. Kiedy urządzenie
jest podłączane, wtedy firmware (w niektórych przypadkach może być to po prostu
sterownik) jest ładowane do pamięci i urządzenie może być wykorzystywane przez
system.
</p>

<p>
W skrócie, Gentoo wykorzystuje <c>sys-apps/hotplug</c> do obsługi firmware w
urządzeniach typu <e>hot plug</e>. Pakiet <c>sys-apps/hotplug</c> korzysta z
wymaganego firmware, by urządzenie było dostępne dla systemu. Firmware powinno
być umieszczone w katalogu <path>/lib/firmware</path> i pobierane stamtąd.
Instalacja jest prosta, emerge zrobi to za nas.
</p>

<pre caption="Instalacja pakietu hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
Oczywiste pytanie jakie się może nasunąć to: czym jest coldplug i dlaczego jest
potrzebny? Pakiet <c>sys-apps/coldplug</c> robi to samo co pakiet hotplug, lecz
wykonuje to dla urządzeń, które są podłączone w trakcie uruchamiania systemu.
Dobry przykład może stanowić karta sieciowa na USB. Wcześniej hotplug był
odpowiedzialny za obsługę obydwu przypadków, ale z czasem został rozdzielony na
hotplug i coldplug, z których każdy ma odrębne przeznaczenie. Jeśli posiadamy
urządzenia typu <e>hot plug</e>, które mają być aktywowane podczas startu
systemu, to instalujemy pakiet coldplug.
</p>

<pre caption="Instalacja pakietu coldplug">
# <i>emerge coldplug</i>
<comment>(możemy dodać to, do standardowego poziomu uruchamiania)</comment>
# <i>rc-update add coldplug boot</i>
 * coldplug added to runlevel boot
 * rc-update complete.
</pre>

<note>
Powyższe skrypty startowe robią to, co zwykły robić skrypty hotplug (dla już
dołączonych urządzeń typu hot-plug). Obecny skrypt startowy
<path>/etc/init.d/hotplug</path> nie robi nie poza sprawdzeniem czy w jądrze
włączono opcję CONFIG_HOTPLUG.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Podziękowania dla...</title>
<section>
<title>Odnośniki</title>
<body>

<p>
Do powstania tego przewodnika przyczyniła się spora liczba dokumentów
ogólnodostępnych w sieci. Niektóre z nich są napisane na dużym poziomie
szczegółów technicznych, ale są naprawdę ciekawe.  Zasługują na wzmiankę. Są to
następujące dokumenty.
</p>

<ul>
  <li><uri link="http://www.usb.org">Oficjalna strona USB</uri></li>
  <li><uri link="http://www.usb.org/faq">Często zadawane pytania</uri></li>
  <li>
    <uri
    link="http://h18000.www1.hp.com/productinfo/development/openhci.html">Standard
    OHCI wg Compaq</uri>
  </li>
  <li>
    <uri link="http://developer.intel.com/technology/usb/uhci11d.htm">Standard
    UHCI wg Intela</uri>
  </li>
  <li>
    <uri link="http://www.intel.com/technology/usb/ehcispec.htm">Standard EHCI
    wg Intela</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
