<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/vserver-howto.xml,v 1.9 2006/05/04 11:34:03 rane Exp $ -->

<guide link="/doc/pl/vserver-howto.xml" lang="pl">
<title>Opis technologii Gentoo Linux-VServer</title>

<author title="Autor">
  <mail link="hollow@gentoo.org">Benedikt Boehm</mail>
</author>
<author title="Edytor">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Tłumacz">
   Paweł Kwiatkowski
</author>

<abstract>
W poradniku tym nauczymy się konfigurować podstawowy wirtualny serwer, wykorzystując
do tego technologię Linux-VServer.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2006-03-17</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Idea technologii Linux-VServer</title>
<body>

<p>
U podstaw rozwiązania Linux-VServer leży pomysł rozdzielenia przestrzeni
użytkownika na osobne jednostki (zwane czasem Wirtualnymi Serwerami Prywatnymi
[ang. VPS]), w taki sposób, aby dla procesów uruchomionych w obrębie VPS,
wyglądały i zachowywały się jak prawdziwe serwery,
</p>

</body>
</section>
<section>
<title>Terminologia stosowana w poradniku</title>
<body>

<table>
<tr>
  <th>Zwrot</th>
  <th>Opis</th>
</tr>
<tr>
  <th>Linux-VServer, VServer</th>
  <ti>Linux-VServer to oficjalna nazwa projektu i jest używana w poradniku
  właśnie w tym znaczeniu</ti>
</tr>
<tr>
  <th>wirtualny serwer, vserver</th>
  <ti>stosowane wymiennie, odnoszą się pojedynczej instancji serwera (tj.
    jednego serwera wirtualnego)</ti>
</tr>
<tr>
  <th>komputer host, host</th>
  <ti>fizyczna maszyna, na której zainstalowane jest Gentoo i na której
  będą znajdować się wszystkie wirtualne serwery</ti>
</tr>
<tr>
  <th>util-vserver</th>
  <ti>pakiet <c>util-vserver</c> zawiera programy niezbędne do zarządzania
  naszymi serwerami wirtualnymi</ti>
</tr>
</table>

</body>
</section>
</chapter>

<chapter>
<title>Konfiguracja hosta</title>
<section>
<title>Instalacja kernela wspierającego VServer</title>
<body>

<pre caption="Instalacja kernela obsługującego VServer - vserver-sources">
# <i>emerge vserver-sources</i>
</pre>

<p>
Po tym jak źródła vserver-sources zostały zainstalowane, musimy je skonfigurować
wpisując polecenie <c>make menuconfig</c>.
</p>

<pre caption="Konfiguracja kernela vserver-sources">
# <i>cd /usr/src/linux-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
# <i>make menuconfig</i>

Linux VServer ---&gt;
  [ ] Enable Legacy Kernel API
  [*] Disable Legacy Networking Kernel API
<comment>(Zalecane)</comment>
  [*] Enable Proc Security
  [*] Enable Hard CPU Limits
  Persistent Inode Context Tagging (UID24/GID24)  ---&gt;
  [ ] Tag NFSD User Auth and Files
  [ ] Compile Debugging Code
</pre>

<note>
Jeśli korzysta się z reiserfs jako systemu plików, na którym będą przetrzymywane
obrazy, należy w jądrze uaktywnić opcję "extended attributes for reiserfs" -
rozszerzone funkcje reiserfs oraz dodać opcję <c>attrs</c> do pliku
<path>/etc/fstab</path>.
</note>

<pre caption="Dodawanie funkcji dla reiserfs">
File systems  --->
  &lt;*&gt; Reiserfs support
  [*]   ReiserFS extended attributes
</pre>

<pre caption="Przykładowa linia z fstab z dodatkowymi atrybutami">
/dev/hdb /vserver reiserfs noatime,attrs 0 0
</pre>

<p>
Po zbudowaniu jądra należy uaktualnić konfigurację programu ładującego, a
następnie ponownie uruchomić system i sprawdzić czy kernel startuje poprawnie.
</p>

<pre caption="Instalacja kernela">
<comment>(Budowanie kernela)</comment>
# <i>make</i>
<comment>(Instalacja)</comment>
# <i>make modules_install</i>
# <i>cp arch/&lt;arch&gt;/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
<comment>(Jeśli to potrzebne, to edytujemy plik konfiguracyjny bootloadera i uruchamiamy ponownie system)</comment>
# <i>reboot</i>
</pre>

</body>
</section>
<section>
<title>Konfiguracja środowiska na maszynie host</title>
<body>

<p>
Do zarządzania serwerami wirtualnymi potrzebujemy pakietu util-vserver, który
zawiera wszystkie potrzebne do tego programy. Należy jednak pamiętać, że
istnieje również pakiet <c>vserver-utils</c>, który jest nową implementacją
'VServer kernel API'. Na razie nie jest on jednak dostatecznie dopracowany, aby
można go było normalnie używać.
</p>

<note>
Ta wersja podręcznika wymaga funkcji dostępnych tylko w wersji
<c>&gt;=sys-apps/util-vserver-0.30.208-r3</c>. Może zatem zajść potrzeba
odmaskowania tego pakietu.
</note>

<pre caption="Instalacja pakietu util-vserver">
# <i>emerge util-vserver</i>
</pre>

<p>
W celu zapewnienia odpowiednich praw dostępu do systemu plików
<path>/proc</path>, po każdym ponownym uruchomieniu komputera trzeba będzie
wykonać polecenie <c>vprocunhide</c>. Aby to nieco zautomatyzować można dodać
vservers do domyślnego poziomu uruchamiania:
</p>

<pre caption="Skrypt startowy vservers">
# <i>rc-update add vservers default</i>
# <i>/etc/init.d/vservers start</i>
</pre>

<note>
Powyższy skrypt dodatkowo uruchomi domyślne vservery. Poniżej znajduje się
więcej informacji na ten temat.
</note>

<p>
Skrypt vshelper używany jest do prawidłowego ponownego uruchamiania wirtualnych
serwerów. Musimy wskazać kernelowi lokalizację, w której znajduje się ów skrypt:
</p>

<pre caption="Konfiguracja vshelper">
# <i>echo 'kernel.vshelper = /usr/lib/util-vserver/vshelper' &gt;&gt; /etc/sysctl.conf</i>
# <i>sysctl -p</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Tworzenie szkieletu</title>
<section>
<title>Instalowanie stage3 vservera</title>
<body>

<p>
Konieczne będzie pobranie archiwum stage3 z gotowym vserverem. Pliki te
znajdują się na naszych <uri link="/main/en/mirrors.xml">serwerach
lustrzanych</uri> w katalogu <path>experimental/&lt;arch&gt;/vserver/</path>.
Następnie należy uruchomić skrypt <c>vserver-new</c>.
</p>

<p>
Dla naszego vservera musimy wybrać identyfikator kontekstowy
(odradzamy używania dynamicznych identyfikatorów), a także
ustawić potrzebne parametry urządzenia sieciowego (w tym przykładzie jest to
interfejs eth0, skonfigurowany dla 192.168.1.253/24 oraz identyfikator
kontekstowy, który powstał z dwóch ostatnich części adresu IP wirtualnego serwera).
</p>

<pre caption="Rozpoczynanie instalacji ze stage3">
# <i>vserver-new gentoo-template \</i>
  <i>--hostname gentoo \</i>
  <i>--context 1253 \</i>
  <i>--interface eth0:192.168.1.253/24 \</i>
  <i>stage3 /ścieżka/do/stage3-&lt;arch&gt;-&lt;data&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
By odzwierciedlić konfigurację sieci, powinniśmy dostosować do naszych potrzeb
pliki <path>/etc/conf.d/hostname</path>, <path>/etc/conf.d/domainname</path> i
<path>/etc/hosts</path>. Szczegóły znajdują się w <uri
link="/doc/pl/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect1">
rozdziale 8.b.1</uri> oraz <uri
link="/doc/pl/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect4">
rozdziale 8.b.4</uri>. Pozostała część konfiguracji sieci dla wirtualnych
serwerów zostanie przeprowadzona na maszynie host.
</note>

</body>
</section>
<section>
<title>Tworzenie tarball z szablonem</title>
<body>

<p>
Nie trzeba budować tego pliku dla każdego komputera gościa, ponieważ skrypt
<c>vserver-new</c> umożliwia stworzenie szablonów w postaci tarballi z
istniejącej konfiguracji vservera.
</p>

<pre caption="Tworzenie tarballa szablonu">
# <i>cd /vservers/gentoo-template</i>
# <i>tar cjvpf ../gentoo-template-&lt;arch&gt;-&lt;data&gt;.tar.bz2 ./</i>
</pre>

<p>
Ze skryptu <c>vserver-new</c> korzysta się również do rozpakowywania
powyższego pliku.
</p>

<pre caption="Rozpakowywanie szablonu">
# <i>cd /vservers</i>
# <i>vserver-new myguest \</i>
  <i>--hostname myguest \</i>
  <i>--context 1252 \</i>
  <i>--interface eth0:192.168.1.252/24 \</i>
  <i>template ./gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
</pre>

<note>
Korzystanie ze wspólnego drzewa Portage dla wszystkich gości umożliwi
oszczędzenie sporej ilości wolnego miejsca. W tym celu otwieramy plik
<path>/etc/vservers/myguest/fstab</path> i odkomentowujemy wpisy dla
<path>/usr/portage</path> i <path>/usr/portage/distfiles</path>. Goście będą
mogli dzięki temu czytać i zapisywać w katalogu
<path>/usr/portage/distfiles</path>.
</note>

</body>
</section>
<section>
<title>Testowanie wirtualnego serwera</title>
<body>

<p>
Powinniśmy mieć możliwość uruchomienia wirtualnego serwera, a następnie
przejścia do niego przy pomocy poniższych poleceń. Jeśli brakuje komend takich jak
<c>mount</c> lub <c>dmesg</c> należy zainstalować pakiet util-linux, wydając w
obrębie serwera wirtualnego polecenie <c>emerge util-linux</c>. Standardowo
profil wirtualnego serwera nie zawiera wspomnianego pakietu.
</p>

<pre caption="Testowanie wirtualnego serwera">
# <i>vserver myguest start</i>

# <i>vserver-stat</i>
CTX   PROC    VSZ    RSS  userTIME   sysTIME    UPTIME NAME
0       90   1.4G 153.4K  14m00s11   6m45s17   2h59m59 root server
1252     2     3M   286    0m00s45   0m00s42   0m02s91 myguest
# <i>vserver gentoo enter</i>
# <i>ps ax</i>
PID   TTY      STAT   TIME COMMAND
    1 ?        S      0:00 init [3]
22887 ?        Ss     0:00 /usr/sbin/syslog-ng
20496 pts/0    S      0:00 /bin/bash -login
20508 pts/0    R+     0:00 ps ax
# <i>logout</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Łatwe zarządzanie vserverem</title>
<section>
<title>Uruchamianie gości razem z systemem</title>
<body>

<p>
Jeżeli chcemy, aby niektórzy goście uruchamiali się automatycznie w momencie
startu systemu, możemy oznaczyć je "MARK-iem", a następnie w konfiguracji
gości ustawić, aby skrypt startowy uruchamiał wszystkie "MARK-i".
</p>

<pre caption="Konfigurowanie 'MARK-ów' dla każdego gościa">
<comment>(Poniższe czynności należy wykonać dla każdego gościa, którego chcemy
uruchamiać automatycznie)</comment>
# <i>mkdir -p /etc/vservers/myguest/apps/init</i>
# <i>echo "default" > /etc/vservers/myguest/apps/init/mark</i>
</pre>

<note>
Dopóki wszyscy goście oznaczeni jako "default" są automatycznie uruchamiani,
nie musimy robić nic więcej. Jeżeli mamy różne oznaczenia powinniśmy również
uaktualnić <path>/etc/conf.d/vservers</path>.
</note>

</body>
</section>
<section>
<title>Udogodnienia w Gentoo</title>
<body>

<p>
Ebuild do util-vserver instaluje w Gentoo pewne udogodnienia. Wiemy już z
poprzedniego rozdziału o <c>vserver-new</c>. W tym rozdziale dowiemy się jak
używać <c>vesync</c>, <c>vemerge</c> oraz <c>vupdateworld</c> w celu utrzymania
aktualności portage, a także <c>vdispatch-conf</c> do aktualizowania gości.
</p>

</body>
</section>
<section>
<title>Utrzymanie aktualności Portage</title>
<body>

<p>
Skrypt <c>vesync</c> może nam pomóc w utrzymaniu aktualności cache metadata oraz
"overlayów". <c>vemerge</c> jest prostą nakładką na <c>emerge</c>.
</p>

<pre caption="Przykłady">
<comment>(Aktualizacja metadata dla 'myguest')</comment>
# <i>vesync myguest</i>
<comment>(Aktualizacja metadata dla wszystkich gości)</comment>
# <i>vesync -a</i>
<comment>(Aktualizacja metadata dla wszystkich gości poza 'myguest')</comment>
# <i>vesync -a -e myguest</i>
<comment>(Aktualizacja 'moj_overlay' dla wszystkich gości)</comment>
# <i>vesync -a \</i>
  <i>-overlay /usr/local/overlays/moj_overlay \</i>
  <i>-overlay-host rsync://rsync.mojhost.com/moj_overlay \</i>
  <i>-overlay-only</i>
<comment>(emerge app-editors/vim w 'myguest')</comment>
# <i>vemerge myguest app-editors/vim -va</i>
</pre>

<note>
Skrypt ten wymaga podzielonego drzewa Portage.
</note>

</body>
</section>
<section>
<title>Aktualizacja gości</title>
<body>

<p>
Goście w Gentoo mogą dzielić się pakietami w celu zaoszczędzenia czasu
kompilacji. W celu utworzenia "dzielonych pakietów" należy utworzyć głowny
folder dla pakietów na hoście. Użyjemy do tego celu
<path>/var/cache/vpackages</path> na hoście i podmontujemy go do
<path>/usr/portage/packages</path> dla każdego gościa.
</p>

<pre caption="Dodawanie 'bind mount' do konfiguracji gościa">
# <i> mkdir -p /var/cache/vpackages</i>
# <i>$EDITOR /etc/vservers/myguest/fstab</i>
<comment>(Tę linię dodajemy na końcu)</comment>
/var/cache/vpackages /usr/portage/packages none bind, rw 0 0
</pre>

<p>
Teraz możemy użyć <c>vupdateworld</c> aby zaktualizować każdego gościa.
Polecenie to jest odpowiednikiem <c>emerge --deep --update --newuse world</c>
zależnie od opcji za jakimi zostanie uruchomine.
</p>

<pre caption="Przykłady vupdateworld">
<comment>(Udawanie aktualizacji dla 'myguest')</comment>
# <i>vupdateworld -p myguest</i>
<comment>(Aktualizacja 'myguest' przy użyciu binarnych pakietów)</comment>
# <i>vupdateworld -k myguest</i>
<comment>(Aktualizacja wszystkich gości przy uzyciu binarnych pakietow)</comment>
# <i>vupdateworld -ka</i>
</pre>

<note>
W celu otrzymania binarnych pakietów możemy użyć PORTAGE_BINHOST (więcej
informacji w <c>man make.conf</c>) lub FEATURES="buildpkg" w jednym bądź
większej ilości gości.
</note>

<p>
Po pomyślnym zakończeniu aktualizacji możemy łatwo zaktualizować wszystkie pliki
konfiguracyjne przy użyciu <c>vdispatch-conf</c>. Jest to prosta nakładka na
<c>dispatch-conf</c> i jej działanie jest dokładnie takie samo.
</p>

<pre caption="Przykłady zastosowania vdispatch-conf">
<comment>(Aktualizacja plików koncifuracyjnych dla "myguest")</comment>
# <i>vdispatch-conf myguest</i>
<comment>(Aktualizacja plików konfiguracyjnych dla wszystkich gości)</comment>
# <i>vdispatch-conf -a</i>
</pre>

</body>
</section>

<section>
<title>Kontakt</title>
<body>

<p>
W przypadku problemów można kontaktować się z <mail
link="hollow@gentoo.org">autorem tekstu</mail> lub zgłosić
problem do <uri link="http://bugs.gentoo.org">Bugzilli</uri>.
</p>

</body>
</section>
</chapter>
</guide>
