<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/openafs.xml,v 1.1 2005/08/07 09:46:54 neysx Exp $ -->

<!-- Orig revision: 1.20  -->
<!-- Translator: Paweł Kwiatkowski <yarel@o2.pl> -->
<!-- Status: Finished -->

<!-- $Id: openafs.xml,v 1.1 2005/08/07 09:46:54 neysx Exp $-->

<guide link="/doc/pl/openafs.xml" lang="pl">
<title>Konfiguracja OpenAFS w Gentoo Linux</title>

<author title="Redaktor">
  <mail link="darks@gentoo.org">Holger Brueckner</mail>
</author>
<author title="Redaktor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Redaktor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Redaktor">
  <mail link="fnjordy@gmail.com">Steven McCoy</mail>
</author>
<author title="Tłumaczenie">
  <mail link="yarel@o2.pl">Paweł Kwiatkowski</mail>
</author>

<abstract>
Przewodnik pokazuje jak zainstalować klienta i serwer openafs w Gentoo Linux
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.9</version>
<date>2005-07-18</date>

<chapter>
<title>Przegląd</title>
<section>
<title>O dokumencie</title>
<body>

<p>
Dokument opisuje wszystkie potrzebne kroki, jakie należy przedsięwziąć by
zainstalować serwer openafs w Gentoo Linux. Niektóre części dokumentu zostały
zaczerpnięte z AFS FAQ oraz przewodnika "IBM Quick Beginnings guide on AFS". Nie
wyważamy otwartych drzwi. :)
</p>

</body>
</section>
<section>
<title>Czym jest AFS?</title>
<body>

<p>
AFS jest rozproszonym systemem plików, który umożliwia współpracującym
komputerom (zarówno klientom jak i serwerom) efektywnie współdzielić zasoby
dyskowe przez sieć lokalną (LAN) jak i rozległą (WAN). Klienci posiadają pamięć
podręczną na często używane obiekty (pliki), by móc szybko się do nich
odwoływać.
</p>

<p>
AFS oparty jest na rozproszonym systemie plików "Andrew File System", nad którym
pracowano w Centrum Technologii Informacyjnej na Uniwersytecie Carnegie-Mellon
(CMU). "Andrew" było nazwą projektu badawczego na CMU, nadaną na cześć
założycieli uniwersytetu. Po założeniu Transarc i tym, gdy AFS stał się
produktem, "Andrew" został zarzucony, by zasygnalizować, że AFS wyszedł poza
ramy projektu badawczego i stał się wspieranym, produkcyjnym systemem plików.
Jednakże istniała znaczna liczba komórek, które swój system plików miały
zakorzeniony jako /afs. W tamtym okresie zmiana punktu zaczepienia systemu
plików była nietrywialnym przedsięwzięciem, więc by uchronić przed zmianami
wczesne ośrodki korzystające AFS, AFS pozostało nazwą i punktem zaczepienia
systemu plików.
</p>

</body>
</section>
<section>
<title>Czym jest komórka AFS?</title>
<body>

<p>
Komórka AFS to zbiór serwerów zgrupowanych administracyjnie i prezentujący się
jako jeden spójny system plików. Zazwyczaj jest to zbiór komputerów
wykorzystujący tę samą domenę internetową (np. gentoo.org). Użytkownicy logują
się na maszyny klienckie AFS, które w ich imieniu żądają informacji i plików z
serwerów należących do komórki. Użytkownicy nie wiedzą, na której maszynie
znajduje się plik do którego próbują się odwołać. Nawet nie zauważą, że serwer
będzie przenoszony w inne miejsce, gdyż każdy wolumin może być replikowany i
przenoszony na inne serwery, bez potrzeby powiadamiania użytkownika. Pliki są
zawsze dostępne. Jest to taki podrasowany NFS :)
</p>

</body>
</section>
<section>
<title>Jakie korzyści płyną z używania AFS?</title>
<body>

<p>
Mocne strony AFS to możliwość cache'owania (po stronie klienta, zazwyczaj od
100M do 1GB), funkcje bezpieczeństwa (bazowany na Kerberos 4, ACL), prostota
adresowania (mamy po prostu jeden system plików), skalowalność (w razie potrzeby
możliwość dodawania kolejnych serwerów do komórki), protokoły komunikacyjne.
</p>

</body>
</section>
<section>
<title>Gdzie można uzyskać więcej informacji?</title>
<body>

<p>
Lektura <uri link="http://www.angelfire.com/hi/plutonic/afs-faq.html">AFS
FAQ</uri>.
</p>

<p>
Strona główna Openafs, <uri link="http://www.openafs.org">www.openafs.org</uri>.
</p>

<p>
AFS był początkowo rozwijany przez Transarc, które obecnie należy do IBM.
Więcej informacji o AFS można znaleźć na stronie <uri
link="http://www.transarc.ibm.com/Product/EFS/AFS/index.html">Transarc</uri>.
</p>

</body>
</section>
<section>
<title>Jak diagnozować problemy?</title>
<body>

<p>
OpenAFS posiada wspaniały mechanizm logowania. Jednakże zgodnie z domyślnymi
ustawieniami, logi wędrują do odrębnych lokalizacji zamiast do mechanizmów
logowania systemowego, które mamy w naszym systemie. Jeśli chcemy, by serwery
korzystały z systemowych mechanizmów logowania, to używamy opcji <c>-syslog</c>
dla wszystkich komend <c>bos</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Dokumentacja</title>
<section>
<title>Pobieranie dokumentacji AFS</title>
<body>

<p>
Istnieje możliwość uzyskania oryginalnej dokumentacji IBM AFS. Jest bardzo
dobrze napisana i naprawdę należy się z nią zapoznać, jeśli myślimy o
administrowania serwerem AFS.
</p>

<pre caption="Instalacja afsdoc">
# <i>emerge app-doc/afsdoc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Instalacja klienta</title>
<section>
<title>Prace wstępne</title>
<body>

<note>
Wszystkie komendy należy wpisać w jednej linii! W tym dokumencie są one czasem
podzielone na dwie linie, by ułatwić czytanie.
</note>

<note>
Niestety klient AFS do prawidłowego działania potrzebuje partycji ext2 na swoją
pamięć podręczną, to ze względu na problemy z blokowaniem na reiserfs. Należy
utworzyć partycję ext2 o rozmiarze ok. 200MB (więcej nie zaszkodzi) i zamontować ją
jako <path>/usr/vice/cache</path>
</note>

<p>
Przed zbudowaniem klienta afs należy dostosować dwa pliki: CellServDB i
ThisCell. (Pliki te znajdują się w
<path>/usr/portage/net-fs/openafs/files</path>.)
</p>

<pre caption="Dostosowanie CellServDB i ThisCell">
CellServDB:
>netlabs        #nazwa komórki
10.0.0.1        #składowanie

ThisCell:
netlabs
</pre>

<warn>
Przy edycji <path>CelLServDB</path> nie należy używać znaków tabulacji (zamiast
nich, spacje), gdyż klient prawdopodobnie nie zadziała poprawnie.
</warn>

<p>
CellServDB mówi klientowi, z którymi serwerami należy kontaktować się w
przypadku określonej komórki. Znaczenie ThisCell powinno być oczywiste.
Zazwyczaj używamy nazwy, która jest unikalna w obrębie organizacji. Nasza
(oficjalna) nazwa domeny może być dobrym wyborem.
</p>

</body>
</section>
<section>
<title>Budowanie klienta</title>
<body>

<pre caption="Instalacja  openafs">
# <i>emerge net-fs/openafs</i>
</pre>

<p>
Po zakończonej sukcesem kompilacji, możemy kontynuować.
</p>

</body>
</section>
<section>
<title>Uruchamianie afs podczas rozruchu systemu</title>
<body>

<p>
Następujące komendy utworzą odpowiednie dowiązania, tak by klient afs uruchamiał
się podczas rozruchu systemu.
</p>

<warn>
Jeśli próbujemy uruchamiać klienta afs, to powinniśmy posiadać w domenie
działający serwer afs. W przeciwnym razie, system nie uruchomi się przed upływem
limitu czasu odpowiedzi od serwera afs. (zazwyczaj jest to całkiem długi
czas...)
</warn>

<pre caption="Dodawanie afs do domyślnego poziomu uruchamiania">
# <i>rc-update add afs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Instalacja serwera</title>
<section>
<title>Budowanie serwera</title>
<body>

<p>
Następujące komendy zainstalują binaria niezbędne do uruchomienia serwera
<e>i</e> klienta AFS.
</p>

<pre caption="Instalacja openafs">
# <i>emerge net-fs/openafs</i>
</pre>

</body>
</section>
<section>
<title>Uruchamianie serwera AFS</title>
<body>

<p>
Najpierw usuwamy przykładowe pliki CellServDB i ThisCell.
</p>

<pre caption="Usuwanie przykładowych plików">
# <i>rm /usr/vice/etc/ThisCell</i>
# <i>rm /usr/vice/etc/CellServDB</i>
</pre>

<p>
Następnie wydajemy komendę <b>bosserver</b>, by uruchomić serwer Basic OverSeer
(BOS), który monitoruje i kontroluje inne procesy serwera AFS na maszynie z
serwerem. Możemy myśleć o tym jak o rozruchu systemu. Dodajemy flagę
<b>-noauth</b> by wyłączyć autoryzację, gdyż jeszcze nie dodaliśmy użytkownika z
prawami administratora.
</p>

<warn>
Wyłączenie autoryzacji likwiduje bezpieczeństwo komórki. Wszystkie kolejne kroki
muszą być wykonane w nieprzerwanym ciągu i nie można zostawić maszyny bez
nadzoru, do czasu restartu serwera BOS z włączoną autoryzacją. Przynajmniej tyle
mówi dokumentacja AFS :)
</warn>

<pre caption="Inicjalizacja serwera Basic OverSeer">
# <i>/usr/afs/bin/bosserver -noauth &amp;</i>
</pre>

<p>
Sprawdzamy, czy serwer BOS utworzył pliki <path>/usr/vice/etc/CellServDB</path>
i <path>/usr/vice/etc/ThisCell</path>.
</p>

<pre caption="Check if CellServDB and ThisCell are created">
# <i>ls -al /usr/vice/etc/</i>
-rw-r--r--    1 root     root           41 Jun  4 22:21 CellServDB
-rw-r--r--    1 root     root            7 Jun  4 22:21 ThisCell
</pre>

</body>
</section>
<section>
<title>Definiowanie nazwy komórki i przynależności dla procesu serwera</title>
<body>

<p>
Przypisujemy komórce nazwę.
</p>

<impo>
Istnieją pewne ograniczenia co do formatu nazwy. Dwa z najważniejszych
ograniczeń to to, że nazwa nie może mieć więcej niż 64 znaki, ani zawierać
wielkich liter. Należy pamiętać, że nazwa komórki pojawi się w katalogu
<path>/afs</path>, więc możemy chcieć wybrać krótsze nazwy.
</impo>

<note>
W poniższej i każdej kolejnej instrukcji w tym podręczniku, wpis &lt;server
name&gt; należy zastąpić pełną złożoną nazwą komputera (np.
<b>afs.gentoo.org</b>) na którym instalujemy, zaś zmienną &lt;cell name&gt;
zastępujemy przez pełną nazwę komórki (np. <b>gentoo</b>).
</note>

<p>
Nazwę komórki ustawiamy wydając polecenie <b>bos setcellname</b>:
</p>

<pre caption="Ustawienie nazwy komórki">
# <i>/usr/afs/bin/bos setcellname &lt;server name&gt; &lt;cell name&gt; -noauth</i>
</pre>

</body>
</section>
<section>
<title>Uruchamianie procesu serwera bazy danych</title>
<body>

<p>
Następnie używamy komendy <b>bos create</b> do utworzenie wpisów w pliku
<path>/usr/afs/local/BosConfig</path>, dla czterech procesów serwerów baz
danych. Te cztery procesy działają tylko na maszynach serwerowych.
</p>

<table>
<tr>
  <ti>kaserver</ti>
  <ti>
    Authentication Server zarządza bazą danych uwierzytelniania. Może zostać
    zastąpiony przez demona Kerberos 5. Jeśli koś zechce wypróbować takie
    rozwiązanie to proszony jest o zaktualizowanie tego dokumentu :)
  </ti>
</tr>
<tr>
  <ti>buserver</ti>
  <ti>Backup Server zarządza bazą kopii zapasowych (Backup Database)</ti>
</tr>
<tr>
  <ti>ptserver</ti>
  <ti>Protection Server zarządza bazą bezpieczeństwa (Protection Database)</ti>
</tr>
<tr>
  <ti>vlserver</ti>
  <ti>
    Volume Location Server zarządza bazą z informacjami o woluminach  (VLDB -
    Volume Location Database).
    Bardzo ważny :)
  </ti>
</tr>
</table>

<pre caption="Tworzenie wpisów dla procesów bazodanowych">
# <i>/usr/afs/bin/bos create &lt;server name&gt; kaserver simple /usr/afs/bin/kaserver -cell &lt;cell name&gt; -noauth</i>
# <i>/usr/afs/bin/bos create &lt;server name&gt; buserver simple /usr/afs/bin/buserver -cell &lt;cell name&gt; -noauth</i>
# <i>/usr/afs/bin/bos create &lt;server name&gt; ptserver simple /usr/afs/bin/ptserver -cell &lt;cell name&gt; -noauth</i>
# <i>/usr/afs/bin/bos create &lt;server name&gt; vlserver simple /usr/afs/bin/vlserver -cell &lt;cell name&gt; -noauth</i>
</pre>

<p>
Działanie wszystkich serwerów możemy zweryfikować wydając polecenie <b>bos status</b>:
</p>

<pre caption="Sprawdzanie działania wszystkich serwerów">
# <i>/usr/afs/bin/bos status &lt;server name&gt; -noauth</i>
Instance kaserver, currently running normally.
Instance buserver, currently running normally.
Instance ptserver, currently running normally.
Instance vlserver, currently running normally.
</pre>

</body>
</section>
<section>
<title>Inicjalizowanie bezpieczeństwa komórki</title>
<body>

<p>
Teraz zajmiemy się inicjalizowaniem mechanizmów bezpieczeństwa komórki.
Zaczniemy od utworzenia następujących dwóch wpisów w bazie zawierającej dane
autentykujące (Authentication Database): główne konto administracyjne, nazwane
zgodnie z konwencją <b>admin</b> oraz wpis dla procesów serwera AFS, zwany
<b>afs</b>. Żaden użytkownik nie legitymuje się tożsamością <b>afs</b>, za
wyjątkiem usługi TGS serwera autentykującego (Ticket Granting Service -
usługa przydzielania biletów), która wykorzystuje to konto do szyfrowania
biletów serwera, przyznawanych klientom AFS. Przypomina to bardzo Kerberosa :)
</p>

<p>
Uruchamianie tryby interaktywnego <b>kas</b>
</p>

<pre caption="Uruchamianie trbu interaktywnego">
# <i>/usr/afs/bin/kas -cell &lt;cell name&gt; -noauth</i>
ka&gt; <i>create afs</i>
initial_password:
Verifying, please re-enter initial_password:
ka&gt; <i>create admin</i>
initial_password:
Verifying, please re-enter initial_password:
ka&gt; <i>examine afs</i>

User data for afs
key (0) cksum is 2651715259, last cpw: Mon Jun  4 20:49:30 2001
password will never expire.
An unlimited number of unsuccessful authentications is permitted.
entry never expires.  Max ticket lifetime 100.00 hours.
last mod on Mon Jun  4 20:49:30 2001 by $lt;none&gt;
permit password reuse
ka&gt; <i>setfields admin -flags admin</i>
ka&gt; <i>examine admin</i>

User data for admin (ADMIN)
key (0) cksum is 2651715259, last cpw: Mon Jun  4 20:49:59 2001
password will never expire.
An unlimited number of unsuccessful authentications is permitted.
entry never expires.  Max ticket lifetime 25.00 hours.
last mod on Mon Jun  4 20:51:10 2001 by $lt;none&gt;
permit password reuse
ka&gt;
</pre>

<p>
Użytkownika <b>admin</b> dodajemy do <path>/usr/afs/etc/UserList</path> przez
wydanie komendy <b>bos adduser</b>.
</p>

<pre caption="Dodawanie użytkownika admin do UserList">
# <i>/usr/afs/bin/bos adduser &lt;server name&gt; admin -cell &lt;cell name&gt; -noauth</i>
</pre>

<p>
Klucz szyfrujący <path>/usr/afs/etc/KeyFile</path> dla serwera AFS definiujemy
wywołując komendę <b>bos addkey</b>.
</p>

<note>
Na pytanie o podanie klucza podajemy hasło, które wprowadziliśmy przy tworzeniu
konta afs przy użyciu <b>kas</b>.
</note>

<pre caption="Wprowadzanie hasła">
# <i>/usr/afs/bin/bos addkey  &lt;server name&gt; -kvno 0 -cell &lt;cell name&gt; -noauth</i>
input key:
Retype input key:
</pre>

<p>
Wydajemy polecenie <b>pts createuser</b>, by dla użytkownika admin utworzyć wpis
w bazie bezpieczeństwa (Protection Database).
</p>

<note>
Serwer ochrony (Protection Server) standardowo przypisuje użytkownikowi
<b>admin</b> AFS UID 1, gdyż jest to pierwszy użytkownik jakiego tworzymy. Jeśli
lokalny plik haseł (/etc/passwd lub analogiczny) już zawiera wpis <b>admin</b>,
który posiada inny UID, to używamy opcji <b>-id</b> do utworzenia
odpowiadającego UIDa.
</note>

<pre caption="Tworzenie wpisu dla użytkownika bazodanowego w bazie
bezpieczeństwa (Protection Database)">
# <i>/usr/afs/bin/pts createuser -name admin -cell &lt;cell name&gt; [-id &lt;AFS UID&gt;] -noauth</i>
</pre>

<p>
Wydajemy komendę <b>pts adduser</b>, by dodać użytkownika <b>admin</b> do grupy
system:administrators, zaś polecenia <b>pts membership</b>, by zweryfikować
przynależność.
</p>

<pre caption="Przypisanie użytkownika admin do grupy administrators i
weryfikacja">
# <i>/usr/afs/bin/pts adduser admin system:administrators -cell &lt;cell name&gt; -noauth</i>
# <i>/usr/afs/bin/pts membership admin -cell &lt;cell name&gt; -noauth</i>
Groups admin (id: 1) is a member of:
system:administrators
</pre>

<p>
Ponownie uruchamiamy wszystkie procesy serwera AFS.
</p>

<pre caption="Ponowne uruchamianie wszystkich procesów serwera AFS">
# <i>/usr/afs/bin/bos restart &lt;server name&gt; -all -cell &lt;cell name&gt; -noauth</i>
</pre>

</body>
</section>
<section>
<title>Uruchamianie serwera plików, woluminów i serwera Salvager</title>
<body>

<p>
Uruchamiamy proces <b>fs</b>, który składa się z serwera plików, serwera
woluminów i serwera Salvager (procesy fileserver, volserver i salvager).
</p>

<pre caption="Uruchamianie procesu fs">
# <i>/usr/afs/bin/bos create &lt;server name&gt; fs fs /usr/afs/bin/fileserver /usr/afs/bin/volserver /usr/afs/bin/salvager -cell &lt;cell name&gt; -noauth</i>
</pre>

<p>
Sprawdzamy czy wszystkie procesy działają.
</p>

<pre caption="Sprawdzanie działania wszystkich procesów">
# <i>/usr/afs/bin/bos status &lt;server name&gt; -long -noauth</i>
Instance kaserver, (type is simple) currently running normally.
Process last started at Mon Jun  4 21:07:17 2001 (2 proc starts)
Last exit at Mon Jun  4 21:07:17 2001
Command 1 is '/usr/afs/bin/kaserver'

Instance buserver, (type is simple) currently running normally.
Process last started at Mon Jun  4 21:07:17 2001 (2 proc starts)
Last exit at Mon Jun  4 21:07:17 2001
Command 1 is '/usr/afs/bin/buserver'

Instance ptserver, (type is simple) currently running normally.
Process last started at Mon Jun  4 21:07:17 2001 (2 proc starts)
Last exit at Mon Jun  4 21:07:17 2001
Command 1 is '/usr/afs/bin/ptserver'

Instance vlserver, (type is simple) currently running normally.
Process last started at Mon Jun  4 21:07:17 2001 (2 proc starts)
Last exit at Mon Jun  4 21:07:17 2001
Command 1 is '/usr/afs/bin/vlserver'

Instance fs, (type is fs) currently running normally.
Auxiliary status is: file server running.
Process last started at Mon Jun  4 21:09:30 2001 (2 proc starts)
Command 1 is '/usr/afs/bin/fileserver'
Command 2 is '/usr/afs/bin/volserver'
Command 3 is '/usr/afs/bin/salvager'
</pre>

<p>
Następne kroki zależą od tego czy kiedykolwiek uruchamialiśmy w obrębie komórki
serwer plików AFS:
</p>

<p>
Jeśli instalujemy po raz pierwszy serwer AFS w komórce, to tworzymy pierwszy
wolumin AFS, <b>root.afs</b>.
</p>

<note>
Zamiast "partition name" wstawiamy nazwę jednej z partycji serwera AFS na danej
maszynie. Zgodnie z konwencją, partycje nazywane są <path>vicepx</path>, gdzie x
należy do zakresu a-z.
</note>

<pre caption="Tworzenie woluminu root.afs">
# <i>/usr/afs/bin/vos create &lt;server name&gt; &lt;partition name&gt; root.afs -cell &lt;cell name&gt; -noauth</i>
</pre>

<p>
Jeśli istnieją maszyny z serwerem plików AFS oraz woluminy w komórce, to
wydajemy polecenia <b>vos sncvldb</b> oraz <b>vos syncserv</b>, by
zsynchronizować VLDB (baza danych woluminów) ze stanem woluminów na lokalnej
maszynie. W efekcie wszystkie niezbędne dane zostaną skopiowane na nowy serwer.
</p>

<p>
Jeśli polecenia zakończy się komunikatem "partition /vicepa does not exist on
the server", to musimy się upewnić, że partycja jest montowana przed
uruchomieniem serwerów OpenAFS lub monujemy katalog i ponownie uruchamiamy
procesy używając <c>/usr/afs/bin/bos restart &lt;server name&gt; -all -cell &lt;cell
name&gt; -noauth</c>.
</p>

<pre caption="Synchronizacja VLDB">
# <i>/usr/afs/bin/vos syncvldb &lt;server name&gt; -cell &lt;cell name&gt; -verbose -noauth</i>
# <i>/usr/afs/bin/vos syncserv &lt;server name&gt; -cell &lt;cell name&gt; -verbose -noauth</i>
</pre>

</body>
</section>
<section>
<title>Uruchamianie fragmentów serwera update</title>
<body>

<pre caption="Uruchamianie serwera update">
# <i>/usr/afs/bin/bos create &lt;server name&gt;
upserver simple "/usr/afs/bin/upserver
-crypt /usr/afs/etc -clear /usr/afs/bin"
-cell &lt;cell name&gt; -noauth</i>
</pre>

</body>
</section>
<section>
<title>Konfigurowanie najwyższego poziomu w systemie plików AFS</title>
<body>

<p>
Na początek musimy ustawić kilka ACLi, tak by użytkownik mógł przeglądać
<path>/afs</path>.
</p>

<pre caption="Ustawianie list kontroli dostępu">
# <i>/usr/afs/bin/fs setacl /afs system:anyuser rl</i>
</pre>

<p>
Następnie tworzymy główny wolumin, montujemy go jako
<path>/afs/&lt;cell name&gt;</path> w trybie tylko do odczytu i jako <path>/afs/.&lt;cell
name&gt;</path> w trybie do odczytu i zapisu.
</p>

<pre caption="Przygotowanie głównego woluminu">
# <i>/usr/afs/bin/vos create &lt;server name&gt;&lt;partition name&gt; root.cell</i>
# <i>/usr/afs/bin/fs mkmount /afs/&lt;cell name&gt; root.cell </i>
# <i>/usr/afs/bin/fs setacl /afs/&lt;cell name&gt; system:anyuser rl</i>
# <i>/usr/afs/bin/fs mkmount /afs/.&lt;cell name&gt; root.cell -rw</i>
</pre>

<p>
Nareszcie skończyliśmy! Powinniśmy posiadać działający serwer plików AFS w
naszej sieci lokalnej. Czas na duży kubek kawy i drukowanie dokumentacji AFS!
</p>

<note>
Do prawidłowego funkcjonowania serwera AFS wymagane jest, by zegary wszystkich
systemów były zsynchronizowane. Można to osiągnąć instalując na jednej z maszyn
(np. serwerze AFS) serwer ntp i synchronizować zegary klientów za pomocą klienta
ntp. Może być to także robione przez klienta afs.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Podstawy administracji</title>
<section>
<title>Ostrzeżenie</title>
<body>

<p>
OpenAFS jest rozległą technologią. Prosimy o przeczytanie dokumentacji AFS w
celu uzyskania większej ilości informacji. W tym rozdziale wymieniamy tylko
kilka administracyjnych zadań.
</p>

</body>
</section>
<section>
<title>Konfiguracja PAM do uzyskiwania tokena AFS przy logowaniu</title>
<body>

<p>
By korzystać z AFS musimy się zautentykować w serwerze KA, jeśli korzystamy z
implementacji AFS i Kerberos 4 lub w Kerberos 5 KDC, jeśli korzystamy z MIT,
Heimdal lub ShiShi Kerberos5. Jednakże, by zalogować się na maszynę,
potrzebujemy konta użytkownika. Może to być konto lokalne w /etc/passwd, NIS,
LDAP (OpenLDAP) lub bazie Hesiod. W Gentoo PAM pozwala na powiązanie
autentykacji AFS z logowaniem na konto użytkownika.
</p>

<p>
Musimy zaktualizować /etc/pam.d/system-auth, które jest używane przez inne
konfiguracje. "use_first_pass" sygnalizuje, że najpierw sprawdzany jest login
użytkownika, zaś "ignore_root" sprawia, że super użytkownik jest ignorowany
(podobnie jak każdy użytkownik z UID 0) w przypadku, gdy zawiedzie AFS lub sieć.
</p>

<pre caption="/etc/pam.d/system-auth">
auth       required     /lib/security/pam_env.so
auth       sufficient   /lib/security/pam_unix.so likeauth nullok
auth       sufficient   /usr/afsws/lib/pam_afs.so.1 use_first_pass ignore_root
auth       required     /lib/security/pam_deny.so

account    required     /lib/security/pam_unix.so

password   required     /lib/security/pam_cracklib.so retry=3
password   sufficient   /lib/security/pam_unix.so nullok md5 shadow use_authtok
password   required     /lib/security/pam_deny.so

session    required     /lib/security/pam_limits.so
session    required     /lib/security/pam_unix.so
</pre>

<p>
By zapobiec uzyskaniu dostępu AFS przez lokalnych użytkowników i by sudo
zachowywało token rzeczywistego użytkownika, zmieniamy /etc/pam.d/su
i następujący sposób:
</p>

<pre caption="/etc/pam.d/su">
<comment># W tym przykładzie, użytkownicy z uid &gt; 100 są traktowani jako
należący do AFS, zaś użytkownicy z
# uid &lt;= 100 są ignorowani przez pam_afs.</comment>
auth       sufficient   /usr/afsws/lib/pam_afs.so.1 ignore_uid 100

auth       sufficient   /lib/security/pam_rootok.so

<comment>#Jeśli chcemy ograniczyć listę użytkowników, którzy mogą wykonywać
# polecenie su, to worzymy plik /etc/security/suauth.allow zapisywalny jedynie
# przez roota i dodajemy w nim listę uprawnionych użytkowników. Każdy w osobnej
# linii.
#auth       required     /lib/security/pam_listfile.so item=ruser \
#       sense=allow onerr=fail file=/etc/security/suauth.allow

# Następującą linię należy odkomentować, by pozwolic użytkownikom z grupy
# 'wheel' na wykonywanie komendy su bez wprowadzania hasła.
#auth       sufficient   /lib/security/pam_wheel.so use_uid trust

# Alternatywę dla powyższego stanowi lista użytkowników, którzy nie muszą
# wprowadzać hasła przy wykonywaniu komendy su.
#auth       sufficient   /lib/security/pam_listfile.so item=ruser \
#       sense=allow onerr=fail file=/etc/security/suauth.nopass

# Poniższa linię należy zakomentować, by pozwolić dowolnemu użytownikowi, nawet
# takiemu nie należącemu do grupy 'wheel', na wykonywanie komendy su.</comment>
auth       required     /lib/security/pam_wheel.so use_uid

auth       required     /lib/security/pam_stack.so service=system-auth

account    required     /lib/security/pam_stack.so service=system-auth

password   required     /lib/security/pam_stack.so service=system-auth

session    required     /lib/security/pam_stack.so service=system-auth
session    optional     /lib/security/pam_xauth.so

<comment># W tym miejscu zapobiegamy zrzuceniu tokena rzeczywistego id
przez użytkownika</comment>
session    optional     /usr/afsws/lib/pam_afs.so.1 no_unlog
</pre>

</body>
</section>
</chapter>

</guide>
