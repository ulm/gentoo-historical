<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/openrc-migration.xml,v 1.1 2008/04/13 18:10:01 rane Exp $ -->

<guide link="/doc/pl/openrc-migration.xml" lang="pl">
<title>Migracja na Baselayout-2 i OpenRC</title>

<author title="Autor">
  <mail link="cardoe"/>
</author>
<author title="Autor">
  <mail link="nightmorph"/>
</author>
<author title="Ofiarodawca">
  <mail link="uberlord"/>
</author>
<author title="Tłumacz">
  <mail link="shpaq@puszkin.org">Michał Laszuk</mail>
</author>

<abstract>
Opis migracji z baselayout-1 na baselayout-2 i OpenRC.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2008-04-11</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Czym jest baselayout?</title>
<body>

<p>
Baselayout dostarcza podstawowy zestaw plików koniecznych do prawidłowej pracy
dla wszystkich systemów, jak <path>/etc/hosts</path>. Dostarcza również
podstawowego układu systemu plików używanych przez Gentoo (na przykład katalogi
<path>/etc</path>, <path>/var</path>, <path>/usr</path>, <path>/home</path>).
</p>

</body>
</section>
<section>
<title>Czym jest OpenRC?</title>
<body>

<p>
OpenRC jest systemem uruchomieniowym bazującym na zależnościach, który może
działać z dowolnym init dostarczanym przez system, zazwyczaj
<path>/sbin/init</path>. Nie jest on jednak zastępstwem dla
<path>/sbin/init</path>. Standardowy init używany w Gentoo Linux to
<c>sys-apps/sysvinit</c>, natomiast Gentoo/FreeBSD korzysta z init FreeBSD
zawartego w pakiecie <c>sys-freebsd/freebsd-sbin</c>.
</p>

</body>
</section>
<section>
<title>Po co więc migracja?</title>
<body>

<p>
Pierwotnie system uruchomieniowy Gentoo był wbudowany w baselayout-1 i w całości
napisany w bashu. Prowadziło to do wielu ograniczeń. Na przykład pewne wywołania
systemowe muszą być dostępne podczas uruchamiania systemu, a to wymaga dodania
wywołań opartych na języku C. Wywołania te były statycznie dowiązane i stale
zmuszały system uruchomieniowy do nadawania wspomnianego dostępu.
</p>

<p>
Gdy Gentoo rozszerzyło się na inne platformy, takie jak Gentoo/FreeBSD czy
Gentoo Embedded, stało się niemożliwym, by wymagać systemu uruchomieniowego
bazującego na bashu. Doprowadziło to do powstania baselayout 2, który napisany
został w C i wymaga jedynie powłoki zgodnej z POSIX. Podczas rozwoju baselayout
2 zostało ustalone, że najlepiej będzie, jeśli baselayout po prostu dostarczy
podstawowych plików i układu systemu plików dla Gentoo, a system uruchomieniowy
zostanie przeniesiony do osobnego pakietu. Tak powstał OpenRC.
</p>

<p>
OpenRC jest rozwijane głównie przez <uri link="http://roy.marples.name/openrc">
Roya Marplesa</uri> i wspiera wszystkie istniejące wariacje Gentoo (na przykład
Gentoo Linux, Gentoo/FreeBSD, Gentoo Embedded i Gentoo Vserver) oraz inne
platformy takie jak FreeBSD i NetBSD.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Migracja na OpenRC</title>
<section>
<body>

<p>
Migracja do OpenRC jest całkiem prosta; będzie ona umieszczona jako część
zwyczajowych aktualizacji systemu dokonywanych za pomocą menadżera pakietów.
Właściwie najważniejszy krok ma miejsce już po zainstalowaniu nowych pakietów
<c>>=sys-apps/baselayout-2</c> i <c>sys-apps/openrc</c>. <e>Krytycznym</e>
krokiem jest uruchomienie <c>dispatch-conf</c> i upewnienie się, że pliki w
<path>/etc</path> zostały zaktualizowane przed ponownym uruchomieniem komputera.
<brite>Pominięcie tego może doprowadzić do nieuruchamiającego się systemu
</brite> i będzie wymagać użycia Gentoo LiveCD, aby przeprowadzić poniższe kroki
mające na celu naprawę niedziałającego systemu.
</p>

<p>
Gdy już wszystkie pliki konfiguracyjne zostaną zaktualizowane, zostanie jeszcze
kilka rzeczy, które należy sprawdzić przed ponownym uruchomieniem komputera.
</p>

</body>
</section>
<section id="rc_conf">
<title>/etc/conf.d/rc</title>
<body>

<p>
Plik <path>/etc/conf.d/rc</path> jest przestarzały i wszystkie ustawienia w nim
zapisane muszą zostać przeniesione do odpowiadających ustawień w
<path>/etc/rc.conf</path>. Należy przeczytać oba pliki <path>/etc/rc.conf</path>
i <path>/etc/conf.d/rc</path>, a następnie przenieść ustawienia. Po wykonaniu
migracji należy skasować plik <path>/etc/conf.d/rc</path>.
</p>

</body>
</section>
<section id="modules">
<title>Moduły jądra</title>
<body>

<p>
Zazwyczaj gdy istniała potrzeba załadowania pewnych modułów automatycznie
podczas uruchamiania systemu, były one umieszczone w
<path>/etc/modules.autoload.d/kernel-2.6</path> razem z wybranymi parametrami. W
baselayout-2 plik ten nie jest już używany. Zamiast niego wszystkie dodatkowe
moduły ładowane podczas startu i ich parametry, niezależnie od wersji jądra,
zostały umieszczone w pliku <path>/etc/conf.d/modules</path>.
</p>

<p>
Przykładem starego stylu konfiguracji będzie:
</p>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
ivtv
cx88_dvb video_br=2
</pre>

<p>
Konwersja powyższego skutkować będzie poniższym:
</p>

<pre caption="/etc/conf.d/modules">
<comment># Moduły ładowane automatycznie podczas uruchamiania</comment>
modules_2_6="ivtv cx88_dvb"
<comment># Parametry modułów</comment>
module_cx88_dvb_args_2_6="video_br=2"
</pre>

<p>
W powyższych przykładach moduły i ich parametry będą działać jedynie na jądrach
z serii 2.6. Nowy sposób konfiguracji pozwala na łatwą kontrolę nad modułami i
ich parametrami bazującą na wersji jądra.
</p>

<p>
Bardziej szczegółowy przykład:
</p>

<pre caption="Szczegółowy przykład /etc/conf.d/modules">
<comment># Always load ochi1394 and ieee1394, no matter the kernel version</comment>
modules="ohci1394 ieee1394"
<comment># Only load tun and usbserial for 2.6.x series kernels</comment>
modules_2_6="tun usbserial"
<comment># Only load cx88_dvb for 2.6.23 kernels</comment>
modules_2_6_23="cx88_dvb"
<comment># Only load ivtv for 2.6.23-gentoo-r5</comment>
modules_2_6_23_gentoo_r5="ivtv"

<comment># For 2.6.23-gentoo-r5, pass video_br=2 to cx88_dvb</comment>
module_cx88_dvb_args_2_6_23_gentoo_r5="video_br=2"
<comment># For 2.6.x series kernels, always pass vendor and product</comment>
module_usbserial_args_2_6="vendor=0x1410 product=0x2110"
<comment># Always pass debug to ieee1394</comment>
module_ieee1394_args="debug"
</pre>

<note>
Należy zwrócić uwagę na różnicę pomiędzy <b>module_</b> a <b>modules_</b>.
</note>

</body>
</section>
<section id="volume">
<title>Zarządzanie woluminami</title>
<body>

<p>
Usługi zarządzające woluminami urządzeń blokowych powinny automatycznie
zostać przemigrowane podczas zmiany na OpenRC i baselayout-2. W przypadku, gdy
nie zostaną, konieczne będzie wypełnienie poniższych instrukcji.
</p>

<p>
Usługi zarządzające woluminami urządzeń blokowych nie są teraz uruchamiane
standardowo. Oznacza to, że usługi takie jak: lvm, raid, swap, device-mapper
(dm), dm-crypt, evms i podobne nie będą uruchamiane automatycznie. W przypadku
korzystania z powyższych dodatków, konieczne będzie dodanie odpowiedniego
skryptu init do poziomu uruchomieniowego <c>boot</c>. W przeciwnym wypadku,
możliwym jest, że system nie będzie w stanie się uruchomić. W przypadku
instalacji różnych usług zarządzających woluminami, odpowiednie skrypty init
zostaną umieszczone w <path>/etc/init.d</path>. Należy się upewnić, że
odpowiednie skrypty init są umieszczone w poziomie uruchomieniowym <c>boot</c>.
</p>

<p>
Podczas gdy ebuild OpenRC będzie usiłował dokonać migracji ustawień
automatycznie, konieczne będzie sprawdzenie czy wszystko przebiegło prawidłowo.
</p>

<pre caption="Sprawdzenie wszystkich usług poziomu uruchomieniowego boot">
# <i>ls -l /etc/runlevels/boot/</i>
</pre>

<p>
W przypadku gdy użytkownik korzysta z mdraid, lvm bądź swap, a na powyższej
liście ich nie ma, konieczne będzie wykonanie poniższych poleceń, by dodać te
usługi do poziomu uruchomieniowego <c>boot</c>
</p>

<pre caption="Dodawanie brakujących usług zarządzania woluminami do poziomu
uruchomieniowego boot">
# <i>rc-update add raid boot</i>
# <i>rc-update add lvm boot</i>
# <i>rc-update add swap boot</i>
</pre>

</body>
</section>
<section>
<title>Zegar</title>
<body>

<p>
Ustawienia zegara zmieniły nazwę z <path>/etc/conf.d/clock</path> na natywne
narzędzie systemowe regulujące zegar. Oznacza to, że w Linuksie będzie to
<path>/etc/conf.d/hwclock</path>, natomiast we FreeBSD będzie to
<path>/etc/conf.d/adjkerntz</path>.
</p>

<p>
Dodatkowo, zmienna <c>TIMEZONE</c> nie jest już obecna w wymienionym pliku. Jej
wartość można teraz znaleźć w pliku <path>/etc/timezone</path>. Należy więc
jeszcze raz przyjrzeć się tym plikom aby być pewnym ich poprawności.
</p>

</body>
</section>
<section>
<title>XSESSION</title>
<body>

<p>
Zmienna XSESSION nie jest już obecna w <path>/etc/rc.conf</path>. Pakiet
<c>x11-apps/xinit</c> dostarcza teraz plik <path>/etc/env.d/90xsession</path>,
który może zostać użyty do ustawienia zmiennej XSESSION.
</p>

<p>
Zmienna ta <b>NIE</b> zostanie przemigrowana automatycznie, konieczne więc
będzie edytowanie pliku <path>/etc/env.d/90xsession</path>.
</p>

<impo>
Po utworzeniu pliku w <path>/etc/env.d</path>, koniecznym jest, aby wykonać
<c>env-update</c>. Aby nowe ustawienia odniosły skutek należy wylogować się i
zalogować ponownie.
</impo>

</body>
</section>
<section>
<title>EDITOR</title>
<body>

<p>
Zmienna EDITOR nie jest już obecna w <path>/etc/rc.conf</path> i na chwilę
obecną nie jest dostarczana przez jakikolwiek pakiet. Namawia się użytkowników
do ustawienia jej samodzielnie wedle potrzeb w pliku <path>~/.bashrc</path> bądź
utworzenie pliku <path>/etc/env.d/99editor</path> i ustawienie w nim tej
zmiennej.
</p>

<impo>
Po utworzeniu pliku w <path>/etc/env.d</path>, koniecznym jest, aby wykonać
<c>env-update</c>. Aby nowe ustawienia odniosły skutek należy wylogować się i
zalogować ponownie. W przypadku gdy zmienna została ustawiona w
<path>~/.bashrc</path>, można wczytać nowe ustawienia wykonując <c>source
~/.bashrc</c>.
</impo>

</body>
</section>
<section>
<title>Kończenie</title>
<body>

<p>
W momencie gdy wszystkie pliki konfiguracyjne i skrypty rozruchowe zostaną
zaktualizowane, ostatnią rzeczą którą należy zrobić jest ponowne uruchomienie
komputera. Jest to konieczne, ponieważ informacje o stanie systemu nie są
zachowywane podczas aktualizacji. Należy więc dostarczyć ich poprzez ponowne
uruchomienie.
</p>

</body>
</section>
</chapter>
</guide>
