<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/power-management-guide.xml,v 1.1 2005/08/19 15:49:58 rane Exp $ -->
<guide link="/doc/pl/power-management-guide.xml" lang="pl">
<title>Zarządzanie zasilaniem</title>

<author title="Autor">
  <mail link="fragfred@gmx.de">Dennis Nienhüser</mail>
</author>
<author title="Tłumaczenie">
  <mail link="edi15ta@gazeta.pl">Mateusz Kotyrba</mail>
</author>

<abstract>
Zarządzanie zasilaniem jest kluczem do przedłużenia żywotności baterii w
komputerach przenośnych takich jak laptopy. Ten przewodnik pomaga je
skonfigurować.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.24</version>
<date>2005-06-10</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Dlaczego zarządzanie zasilaniem?</title>
<body>

<p>
Pojemność i żywotność baterii w laptopach w ostatnich latach znacznie się
poprawiła. Niemniej jednak nowoczesne procesory pożerają znacznie więcej
energii niż te starsze, zaś każde pokolenie laptopów wprowadza coraz więcej
urządzeń głodnych energii. To dlatego zarządzanie zasilaniem jest teraz
bardziej istotne niż kiedykolwiek wcześniej. Zwiększanie żywotności baterii
niekoniecznie jest równoznaczne z kupnem nowych. Wiele można osiągnąć stosując
intelignetną politykę zarządzania zasilaniem.
</p>

</body>
</section>
<section>
<title>Szybki przegląd</title>
<body>

<p>
Ten przewodnik opisuje zarządzanie zasilaniem dla <e>laptopów</e>. Chociaż
niektóre części mogą się przydać również <e>serwerom</e>, posiadacze innych
komputerów <e>nie powinni</e> kierować się tym przewodnikiem, gdyż niektóre
polecenia w nim zawarte mogą wyrządzić szkody. Proszę nie stosować niczego z
tego przewodnika do serwera, jeśli nie jest się pewnym, że jest to nieszkodliwe
działanie.
</p>

<p>
Ponieważ przewodnik ten stał się nieco długi, poniżej znajduje się krótki
przegląd jego zawartości, który pomoże się w nim szybko zorientować.
</p>

<p>
Rozdział <e>Warunki wstępne</e> mówi o pewnych wymaganiach, które muszą być
spełnione, aby dowolne z poniższych urządzeń działało. Są nimi ustawienia
BIOS-u, konfiguracja jądra oraz pewne ułatwienia w środowisku użytkownika.
Następne 3 rozdziały skupiają się na urządzeniach, które zwykle pożerają
najwięcej energii - procesor, ekran oraz dysk twardy. Każde z nich może być
oddzielnie skonfigurowane. <e>Zarządzanie zasilaniem procesora</e> pokazuje
jak ustawić częstotliwość procesora, aby zachować maksymalnie dużo energii
bez straty wydajności. Kilka różnych sztuczek zapobiega działaniu dysku
twardego, kiedy nie jest to konieczne w <e>Zarządzaniu zasilaniem dla dysku
twardego</e> (zmniejszanie poziomu hałasu jako miły skutek uboczny). Parę
uwag o kartach sieci bezprzewodowych oraz USB kończą część o urządzeniach w
<e>Zarządzaniu zasilaniem dla innych urządzeń</e> podczas, gdy inny rodział
jest poświęcony (raczej eksperymentalnie) <e>stanom uśpienia</e>(ang. sleep
states). Ostatni rozdział, <e>Rozwiązywanie problemów</e>, pokazuje najczęstsze
pułapki.
</p>

</body>
</section>
<section>
<title>Budżet energii dla każdego składnika</title>
<body>

<figure link="/images/energy-budget.png" short="Który składnik ile pożera energii?" caption="Budżet energii dla każdego składnika"/>

<p>
Niemal każda część może działać w różnych stanach - chociażby wyłączonym,
uśpionym, bezczynnym, czynnym - pochłaniając różne ilości energii. Najwięcej
pożerają ekran LCD, procesor, chipset i dyski twarde. Często możemy uaktywnić
niezależne od systemu operacyjnego zarządzanie zasilaniem w BIOS-ie, jednak
poprzez inteligentne ustawienie tego w systemie operacyjnym, dostosowujące się
do różnych, sytuacji możemy osiągnąć znacznie więcej.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Warunki wstępne</title>
<section>
<title>Co musi być najpierw zrobione</title>
<body>

<p>
Przed wejściem w szczegóły zarządzania zasilaniem poszczególnych urządzeń należy
się upewnić, że spełnione są pewne wymagania. Po sprawdzeniu ustawień w BIOS-ie,
niektóre opcje w jądrze mogą być uaktywnione - w skrócie są nimi ACPI, stany
uśpienia oraz skalowanie częstotliwości procesora. Ponieważ oszczędzanie
energii wiąże się ze stratą wydajności lub zwiększonym opóźnieniem, więc powinno
to być załączone tylko podczas pracy na bateriach. Tu przychodzi z pomocą nowy
poziom uruchamiania o nazwie <e>battery</e>.
</p>

</body>
</section>
<section>
<title>BIOS</title>
<body>

<p>
Najpierw przypatrzmy się ustawieniom zarządzania zasilania w BIOS-ie.
Najlepszym rozwiązaniem jest, aby połączyć polityki BIOS-u oraz systemu
operacyjengo, lecz na dzień dzisiejszy lepiej wyłączyć większość ustawień w
BIOS-ie. To zapewnia, że BIOS nie będzie wtrącał do naszej polityki zasilania.
Nie należy zapomnieć, aby ponownie sprawdzić ustawienia BIOS-u po
skonfigurowaniu czegokolwiek.
</p>

</body>
</section>
<section>
<title>Konfiguracja jądra</title>
<body>

<p>
ACPI (Advanced Configuration and Power Interface - dosłownie zaawansowana
konfiguracja i interfejs zasilania) wsparcie w jądrze jest nadal w fazie
rozwoju. Używanie świeżych jąder będzie zapewniało najnowszą stabilną wersję.
</p>

<p>
W jądrze włączamy co najmniej 3 opcje:
</p>

<pre caption="Minimalne ustawienia jądra dla zarządzania zasilaniem (jądro 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [*]   zasilacz sieciowy Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Samemu należy zdecydować czy chcemy włączyć Software Suspend, Suspend-to-Disk i
Sleep States (patrz poniżej). Jeśli posiadamy laptop firmy ASUS, Medion lub
Toshiba, włączamy odpowiednią opcję.
</p>

<p>
Jądro musi wiedzieć w jaki sposób ma włączyć skalowanie częstotliwości
procesora. Ponieważ każdy typ procesora ma różny interfejs, więc musimy wybrać
odpowiedni sterownik dla naszego procesora. Należy tu uważać - włączenie
<e>Intel Pentium 4 clock modulation</e> w systemie z Pentium M prowadzi do
dziwnych rezultatów. Należy zapoznać się z dokumentacją jądra, jeśli nie
jesteśmy pewni którą opcję wybrać.
</p>

<p>
Kompilujemy jądro i upewniamy się, że podczas startu systemu ładują się
odpowiednie moduły i uruchamiają jądro z włączonym ACPI. Następnie wykonujemy
<c>emerge sys-power/acpid</c>, aby uzyskać demon acpi. Informuje on o
zdarzeniach takich jak przełączanie z zasilacza sieciowego do baterii lub
zamykaniu ekranu. Należy się upewnić, że moduły zostały załadowane, jeśli nie
wkompilowaliśmy ich w jądro, po czym uruchamiamy acpid za pomocą polecenia
<c>/etc/init.d/acpid start</c>. Wykonujemy <c>rc-update add acpid default</c>,
aby ładować ten moduł podczas startu systemu. Wkrótce nauczymy się go używać.
</p>

<pre caption="Instalowanie acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Tworzenie poziomu uruchamiania o nazwie "battery"</title>
<body>

<p>
Domyślna polityka włączy zarządzanie zasilaniem tylko kiedy to będzie
potrzebne - podczas pracy na bateriach. Aby wykonać przełączenie pomiędzy
zasilaczem sieciowym a wygodną baterią, stworzymy poziom uruchamiania o nazwie
<e>battery</e>, który będzie zawierał wszystkie skrypty uruchamiające i
wyłączające zarządzanie zasilaniem.
</p>

<note>
Możemy bezpiecznie ominąć tę część, jeśli nie chcemy mieć dodatkowego poziomu
uruchamiania Jednakże, ominięcie tego kroku spowoduje, że ustawiając resztę
trzeba będzie się posłużyć kilkoma sztuczkami, gdyż następne części
przewodnika zakładają, że poziom uruchamiania o nazwie <e>battery</e>
istnieje.
</note>

<pre caption="Tworzenie poziomu uruchamiania o nazwie 'battery'">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
Skończone. Nowy poziom uruchamiania o nazwie <e>battery</e> zawiera wszystko
co poziom <e>default</e>, ale nie mamy jeszcze automatycznego przełącznika
pomiędzy nimi dwoma. Czas, aby to zmienić.
</p>

</body>
</section>
<section>
<title>Reagowanie na zdarzenia ACPI</title>
<body>

<p>
Typowymi zdarzeniami ACPI są zamykanie ekranu, zmiana źródła zasilania lub
wciśnięcie przycisku uśpienia. Ważnym zdarzeniem jest zmiana źródła zasilania,
który powinien spowodować przełączenie poziomów uruchamiania. Tworzymy
następujące pliki w celu, aby przełączyć się pomiędzy poziomem uruchamiania
<e>default</e> a <e>battery</e> zależnie od źródła zasilania:
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># POCZĄTEK konfiguracji</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># KONIEC konfiguracji</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># poniżej zastępujemy "ac_adapter" zdarzeniem stworzonym przez
laptop</comment>
<comment># należy sprawdzić /var/log/acpid</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># poniżej zastępujemy "battery" zdarzeniem stworzonym przez
laptop</comment>
<comment># należy sprawdzić /var/log/acpid</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Dodatkowo potrzebujemy pakietu sys-power/powermgmt-base, który zawiera
narzędzie <c>on_ac_power</c>. Plik <path>pmg_switch_runlevel.sh</path> musi
być wykonywalny.
</p>

<pre caption="Kończenie przełączania poziomów uruchamiania z acpid">
# <i>emerge powermgmt-base</i>
# <i>chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</i>
# <i>/etc/init.d/acpid restart</i>
</pre>

<p>
Próbujemy: wkładamy i wyciągamy wtyczkę zasilacza sieciowego i obserwujemy
syslog w poszukiwaniu komunikatów "Switching to AC mode" lub "Switching to
battery mode". Należy spojrzeć do części "Rozwiązywanie problemów", jeśli skrypt
nie będzie w stanie wykryć poprawnie źródła.
</p>

<p>
Dzięki naturze mechanizmu zdarzeń, nasz laptop załaduje się w poziom
uruchamiania <e>default</e> bez względu na to czy pobieramy energię z zasilacza
sieciowego czy z baterii. Możemy dodać dodatkowy wpis do bootloadera
<c>softlevel=battery</c>, ale możemy zapomnieć go wybrać, gdy będziemy pracowali
na baterii. Lepszym rozwiązaniem jest sfałszować zdarzenie ACPI pod koniec
procesu uruchamiania systemu i niech skrypt <path>/etc/acpi/default.sh</path>
zdecyduje czy zmiana poziomu uruchamiania jest konieczna. Otwieramy
<path>/etc/conf.d/local.start</path> w ulubionym edytorze i dodajemy następujące
linie:
</p>

<pre caption="Przełączenie poziomów uruchamiania podczas ładowania systemu, poprzez edycję local.start">
<comment># Fałszywe zdarzenie acpi, aby przełączyć poziom uruchamiania, jeśli pracujemy na bateriach</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
W ten sposób przygotowani, możemy włączyć polityki zarządzania zasilaniem dla
konkretnych urządzeń.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Zarządzanie zasilaniem dla procesora</title>
<section>
<title>Pewne terminy techniczne</title>
<body>

<p>
Podczas skalowania częstotliwości procesora możemy natknąć się na pewne
nieznane nam terminy techniczne. Poniżej znajduje się krótki wstęp.
</p>

<p>
Po pierwsze jądro musi być w stanie zmienić częstotliwość procesora.
<e>Sterownik procesora CPUFreq</e> zna te polecenia. Stąd jest ważne, aby wybrać
właściwy procesor w jądrze. Powinniśmy już to mieć za sobą. Kiedy jądro wie jak
zmieniać częstotliwości, powinno również wiedzieć jaką częstotliwość obecnie
ustawić. To jest wykonywane według <e>polityki</e>, która składa się z
<e>polityki CPUFreq</e> oraz <e>regulatora</e>. Polityką CPUfreq są tylko 2
liczby, które definiują zakres częstotliwości - minimalną i maksymalną
częstotliwość. Regulator teraz decyduje, którą z dostępnych częstotliwości użyć.
Na przykład, <e>regulator powersave</e> zawsze wybiera najniższą dostępną
częstotliwość, <e>regulator performance</e> najwyższą. <e>Regulator
userspace</e> nie podejmuje żadnej decyzji, ale wybiera to co chce użytkownik
(lub program w przestrzeni użytkownika) chce - co oznacza, że czyta on
częstotliwość z
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Nie brzmi to jak dynamiczne skalowanie częstotliwości i wcale tym nie jest.
Jednakże dynamika może być osiągnięta, za pomocą różnych podejść. Na przykład,
<e>regulator ondemand</e> wykonuje swoje decyzje zależnie od obciążenia
procesora. To samo jest wykonane za pomocą narzędzi takich jak <c>cpudyn</c>,
<c>cpufreqd</c>, <c>powernowd</c> i wielu innych. Zdarzenia ACPI mogą również
być użyte do włączenia lub wyłączenia dynamicznych zmian częstotliwości zależnie
od źródła zasilania.
</p>

</body>
</section>
<section>
<title>Ręczne ustawianie częstotliwości</title>
<body>

<p>
Obniżanie prędkości oraz napięcia CPU ma dwie zalety: z jednej strony mniej
energii jest zużywane, z drugiej zmniejsza się ilość wydzielanego ciepła, gdyż
system nie działa na pełnych obrotach. Główną wadą tego rozwiązania jest
oczywiście utrata wydajności. Zmniejszając prędkość procesora jest wyborem
pomiędzy utratą wydajności, a zaoszczędzeniem energii.
</p>

<note>
Nie każdy laptop wspiera skalowanie częstotliwości. Jeśli nie jesteśmy pewni,
powinniśmy spojrzeć na listę wspieranych procesorów w części <e>Rozwiązywanie
problemów</e>, aby sprawdzić czy nasz procesor jest na tej liście.
</note>

<p>
Nadszedł czas, aby sprawdzić czy zmienianie częstotliwości CPU działa.
Zainstalujmy dodatkowe narzędzie, które jest bardzo użyteczne w celach
diagnostycznych: <c>sys-power/cpufrequtils</c>.
</p>

<pre caption="Sprawdzanie częstotliwości procesora">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Poniżej znajduje się przykładowe wyjście:
</p>

<pre caption="Przykładowe wyjście cpufreq-info">
cpufrequtils 0.2: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz (asserted by call to hardware).
</pre>

<p>
Następnie należy  pobawić się <c>cpufreq-set</c>, aby się upewnić, że
przełączanie częstotliwości działa. Na przykład uruchamiamy <c>cpufreq-set -g
ondemand</c>, aby uruchomić regulatora ondemand i sprawdzić zmianę za pomocą
<c>cpufreq-info</c>. Jeśli nie zadziała jak oczekiwaliśmy, wtedy możemy znaleźć
pomoc w części "Rozwiązywanie problemów" na końcu tego przewodnika.
</p>

</body>
</section>
<section>
<title>Zautomatyzowana zmiana częstotliwości</title>
<body>

<p>
Powyższe rozwiązanie jest dosyć dobre, ale nie do codziennego użytku. Lepiej,
aby system ustawił automatycznie odpowiednią częstotliwość. W tym celu istnieją
różne podejścia. Poniższa tabela pokazuje szybki przegląd wszystkich możliwości,
aby pomóc wybrać jeden z nich. Jest ona z grubsza podzielona na 3 kategorie
<e>jądro</e> dla podejść, które wymagają tylko wsparcia jądra, <e>demon</e> dla
programów, które są uruchomione w tle oraz <e>graficzne</e> dla programów, które
dostarczają graficzny interfejs użytkownika dla łatwej konfiguracji i zmian.
</p>

<table>
<tr>
  <th>Nazwa</th>
  <th>Kategoria</th>
  <th>Decyzja o przełączeniu</th>
  <th>Regulatory jądra</th>
  <th>Dalsze regulatory</th>
  <th>Komentarze</th>
</tr>
<tr>
  <ti>Regulator "ondemand"</ti>
  <ti>Jądro</ti>
  <ti>Obciążenie procesora</ti>
  <ti>Niedostępne</ti>
  <ti>Niedostępne</ti>
  <ti>
    Dalsze dostrajanie poprzez pliki
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Ciągle wymaga
    narzędzi użytkownika (programów, skryptów), jeśli przełączanie regulatora
    lub coś podobnego jest naszym celem.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Demon</ti>
  <ti>Obciążenie procesora</ti>
  <ti>performance, powersave</ti>
  <ti>Dynamic</ti>
  <ti>
    Również wspiera stan oczekiwania dysku - jednakże należy zauważyć, że
    <e>laptop-mode</e> w większości przypadków, wykona lepszą robotę.
  </ti>
</tr>
<tr>
  <ti><uri
link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Demon</ti>
  <ti>Stan baterii, obciążenie procesora, uruchomione programy</ti>
  <ti>Wszystko dostępne</ti>
  <ti>Żaden</ti>
  <ti>
    Wyszukane (ale skomplikowane) ustawienie.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Demon</ti>
  <ti>Obciążenie procesora</ti>
  <ti>Żaden</ti>
  <ti>Passive, sine, aggresive</ti>
  <ti>
    Wspiera SMP.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Demon</ti>
  <ti>Obciążenie procesora</ti>
  <ti>Żaden</ti>
  <ti>Dynamic, powersave, performance, fixed speed</ti>
  <ti>
    Mały, ale o dużych możliwościach z użytecznym interfejsem klient-serwer.
    Wymaga jądra 2.6. Wygląda na to, że jego rozwój został porzucony, w
    niedalekiej przyszłości zostanie wyrzucony z Portage.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Graficzny</ti>
  <ti>Żaden</ti>
  <ti>Żaden</ti>
  <ti>Żaden</ti>
  <ti>
    Aplikacja Gnome, narzędzie graficzne, do ręcznego ustawiania częstotliwości
    procesora. Nie oferuje żadnej automatyzacji.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Graficzny</ti>
  <ti>Stan baterii</ti>
  <ti>Wszystko dostępne</ti>
  <ti>Żaden</ti>
  <ti>
    Tylko KDE, regulator 'ondemand' wymagany dla dynamicznego skalowania
    częstotliwości.
  </ti>
</tr>
</table>

<p>
Dopasowywanie częstotliwości do obecnego obciążenia procesora jest z pozoru
łatwym zadaniem, ale nie jest to takie trywialne. Zły algorytm może spowodować
ciągłe przełączanie pomiędzy 2 częstotliwościami lub marnowanie energii poprzez
ustawienie częstotliwości nieodpowiedniej do obciążenia procesora.
</p>

<p>
Który wybrać? Jeśli nie wiemy, to wybieramy <c>cpufreqd</c>:
</p>

<pre caption="Instalowanie cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> może być skonfigurowany poprzez edycję
<path>/etc/cpufreqd.conf</path>. Domyślna konfiguracja może wyglądać trochę
nieładnie. Ja polecam zastąpienie jej konfiguracją napisaną przez jednego z
deweloperów Gentoo - Henrika Brixa Andersena (znajduje się poniżej).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=ondemand

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=performance
</pre>

<p>
Nie możemy użyć wartości procentowych jak wyżej dla min_freq i max_freq, jeśli
używamy jądra 2.6 z interfejsem sysfs. Zastępujemy je najwyższą i najniższą
częstotliwością, które możemy uzyskać z <c>cpufreq-info --hwlimits</c>. Na
przykład, na moim Pentium M 1.4 GHz wpisałem
</p>

<pre caption="Przykładowe wartości minfreq i maxfreq">
minfreq=600000
maxfreq=1400000
</pre>

<p>
Uruchamiamy demon.
</p>

<pre caption="Uruchamianie cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<warn>
Nie należy załączać więcej niż jednego z powyższych programów równocześnie.
Może to spowodować nieład, typu ciągłe przełączanie pomiędzy dwoma
częstotliwościami.
</warn>

</body>
</section>

<section>
<title>Weryfikowanie rezultatu</title>
<body>

<p>
Ostatnią rzeczą jest sprawdzenie czy nasza polityka wykonuje dobrą robotę.
Łatwym sposobem, aby to sprawdzić jest monitorowanie CPU:
</p>

<pre caption="Monitorowanie prędkości procesora">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Jeśli <path>/proc/cpuinfo</path> nie jest aktualizowane (patrz "Rozwiązywanie
problemów"), to monitorujemy częstotliwość za pomocą:
</p>

<pre caption="Alternatywne monitorowanie prędkości procesora">
# <i>watch x86info -mhz</i>
</pre>

<p>
Zależnie od ustawień, prędkość CPU powinna wzrastać pod dużym obciążeniem, maleć
podczas bezczynności lub pozostać na tym samym poziomie. Używając cpufreqd,
jeśli mamy ustawioną rozwlekłość (ang. verbosity) na 5 lub więcej w
<path>cpufreqd.conf</path> otrzymamy dodatkowe informacje o tym co się dzieje,
za pomocą programu logującego.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Zarządzanie zasilaniem dla ekranu LCD</title>
<section>
<title>Pożeracz energii nr 1</title>
<body>

<p>
Jak możemy zauważyć na <uri link="#doc_chap1_fig1">rysunku 1.1</uri>, ekran LCD
pożera największą część energii (nie dotyczy to komputerów stacjonarnych).  Stąd
jest to dosyć ważne nie tylko, aby wyłączać ekran kiedy nie jest używany, ale
również aby zmniejszyć podświetlenie matrycy jeśli to będzie możliwe.  Większość
laptopów oferuje kontrolowanie przyciemniania ekranu.
</p>

<p>
Po pierwsze należy sprawdzić czasy oczekiwania, zawieszenia i wyłączenia ekranu.
Ponieważ to zależy silnie od naszego menedżera okien. Wystarczy sprawdzić 2
popularne miejsca: zaczernienie terminala może być ustawione za pomocą
<c>setterm -blank &lt;liczba_minutM&gt;</c>, <c>setterm -powersave on</c> oraz
<c>setterm -powerdown &lt;liczba_minutM&gt;</c>. Dla Xorg, modyfikujemy
<path>/etc/X11/xorg.conf</path> w następujący sposób:
</p>

<pre caption="Ustawienia zawieszenia dla LCD w Xorg i XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Zaczernienie obrazu po 5 minutach
(udawane)</comment>
  Option  "StandbyTime"  "10"  <comment># Wyłączenie obrazu po 10 minutach
(DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># Całkowite zawieszenie po 20
minutach</comment>
  Option  "OffTime"  "30"  <comment># Wyłączenie po pół godzinie</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
To samo tyczy się XFree86 i <path>/etc/X11/XF86Config</path>.
</p>

<p>
Prawdopodobnie bardziej istotną sprawą jest zmniejszenie podświetlenia. Jeśli
mamy dostęp do ustawień przyciemniania poprzez jakieś narzędzie, napiszemy mały
skrypt, który będzie zmniejszał podświetlenie w trybie pracy na baterii oraz
osadzimy go w poziomie uruchamiania o nazwie <e>battery</e>. Następujący skrypt
powinien działać na większości Thinkpadach IBM-a. Wymaga on pakietu
<c>app-laptop/ibm-acpi</c> lub załączenia odpowiedniej opcji w jądrze.
</p>

<warn>
Wsparcie ustawiania jasności w ibm-acpi jest oznaczone jako eksperymentalne.
Posiada ono bezpośredni dostęp do sprzętu i może spowodować uszkodzenie
komputera. Proszę przeczytać uwagi na <uri
link="http://ibm-acpi.sourceforge.net/">stronie domowej ibm-acpi</uri>
</warn>

<p>
Aby móc ustawić poziom jasności, moduł ibm_acpi musi być załadowany z parametrem
eksperymentalnym.
</p>

<pre caption="Automatyczne ładowanie modułu ibm_acpi">
<comment>(Przed przystąpieniem, proszę przeczytać powyższe ostrzeżenia!)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
To powinno działać bez komunikatów o błędach, plik
<path>/proc/acpi/ibm/brightness</path> powinien być stworzony po załadowaniu
modułu. Skrypt startowy zajmie się wybieraniem jasności w zależności od źródła
zasilania.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Należy zajrzeć do /proc/acpi/ibm/brightness, aby uzyskać dostępne wartości</comment>
<comment># Proszę przeczytać /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># poziom jasności w trybie ac. Domyślnie 7.</comment>
BRIGHTNESS_AC=7

<comment># poziom jasności w trybie battery. Domyślnie 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "Check that ibm_acpi is loaded into the kernel"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Kiedy skończymy, należy się upewnić, że jasność jest dobierana automatycznie
poprzez dodanie tego skryptu do poziomu uruchamiania o nazwie "battery".
</p>

<pre caption="Włączanie automatycznego sterowania jasnością">
# <i>chmod +x /etc/init.d/lcd-brightness</i>
# <i>rc-update add lcd-brightness battery</i>
# <i>rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Zarządzanie zasilaniem dla dysku twardego</title>
<section>
<title>Uśpienie podczas bezczynności</title>
<body>

<p>
Uśpijmy dyski twarde tak szybko jak to możliwe, gdy ich nie potrzebujemy.
Pokażę dwie możliwości, aby to wykonać. Pierwsza, <c>cpudyn</c> wspiera
zarządzanie zasilaniem dla dysków twardych. W tym celu należy odkomentować
poniższe linie w części "Disk Options" w pliku
<path>/etc/conf.d/cpudyn</path>. Aby uśpić twardy dysk po 60 sekundach
bezczynności, wpisujemy:
</p>

<pre caption="Używanie cpudyn do przejścia w stan oczekiwania dysku">
<comment>################################################
# DISK OPTIONS
# (domyślnie wyłączone)
################################################

#
# Czas oczekiwania, aby dysk przeszedł w tryb oczekiwania, jeśli nie było
# żadnego wejścia lub wyjścia w tym czasie (w sekundach).
#
</comment>
TIMEOUT=60
<comment>
#
# Określamy dyski, które mają zwolnić (przecinek oddziela urządzenia)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
Druga, użycie małego skryptu wraz z hdparmem. Tworzymy plik
<path>/etc/init.d/pm.hda</path>, wpisując:
</p>

<pre caption="Używanie hdparm do przejścia stan oczekiwania dysku">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Aby dowiedzieć się o dostępnych opcjach należy spojrzeć do <c>man hdparm</c>.
Jeśli nasz skrypt jest gotowy, należy dodać go do poziomu uruchamiania o
nazwie "battery".
</p>

<pre caption="Zautomatyzowanie ustawień stanu oczekiwania dysku">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Należy być ostrożnym z ustawieniami uśpienia lub zmniejszenia obrotów dysków
twardych. Ustawienie tych opcji na zbyt małe wartości może zniszczyć dysk twardy
co spowoduje utratę gwarancji.
</impo>

</body>
</section>
<section>
<title>Zwiększanie czasu bezczynności - laptop-mode</title>
<body>

<p>
Ostatnie jądra (2.6.6 i nowsze, ostatnie 2.4 i inne z łatkami) zawierają tak
zwany <e>laptop-mode</e>. Kiedy go aktywujemy, brudne bufory (ang. dirty
buffers) będą zapisywane na dysk co 10 lub więcej minut (zamiast 30 sekund).  To
minimalizuje ilość razy kiedy dysk twardy musi się rozkręcać.
</p>

<pre caption="Automatyczne uruchomienie laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
Pakiet <c>laptop-mode-tools</c> posiada plik konfiguracyjny w
<path>/etc/laptop-mode/laptop-mode.conf</path>. Dopasowujemy go do własnych
potrzeb, jest on dobrze opisany. I wykonujemy polecenie <c>rc-update add
laptop_mode battery</c>, aby uruchamiał się on automatycznie.
</p>

</body>
</section>
<section>
<title>Inne sztuczki</title>
<body>

<p>
Poza tym usypianie dysku tak wcześnie jak to możliwe, jest dobrym pomysłem, aby
zminimalizować ilość dostępów do dysku. Spójrzmy na procesy, które często
zapisują dane na dysk - syslogd jest dobrym kandydatem. Prawdopodobnie nie
chcemy zamykać go całkowicie, ale jest możliwe, aby tak zmodyfikować plik
konfiguracyjny, żeby "niepotrzebne" rzeczy nie były logowane, stąd aby nie
tworzyły niepotrzebnego ruchu na dysku. CUPS zapisuje okresowo pewne rzeczy na
dysku, więc należy rozważyć zamknięcie go i w razie potrzeby uruchamiać go tylko
ręcznie.
</p>

<pre caption="Wyłączanie CUPS podczas pracy na bateriach">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Inną możliwością jest wyłączenie swapa podczas pracy na bateriach. Przed
napisaniem przełącznika swapa, należy się upewnić, że mamy dostatecznie dużo
pamięci RAM i swap nie jest używany zbyt często, w przeciwnym wypadku możemy
mieć duże problemy.
</p>

<p>
Jeśli nie chcemy używać laptop-mode, nadal możemy zmniejszyć dostęp do dysku
poprzez zamontowanie pewnych katalogów jako <e>tmpfs</e> - próby zapisu nie są
zachowywane na dysku, ale w głównej pamięci i zostają utracone przy
odmontowywaniu. Często jest użyteczne, aby zamontować w ten sposób
<path>/tmp</path> - nie musimy zwracać szczególnej uwagi, ponieważ zostaje on
skasowany po każdym ponownym uruchomieniu komputera niezależnie czy zamonutjemy
go na dysku czy do RAM-u. Należy się jedynie upewnić, że mamy wystarczającą
ilość pamięci oraz, że żaden program (jak klient ściągający lub narzędzie
pakujące) nie potrzebuje dodatkowej przestrzeni w <path>/tmp</path>. Aby to
włączyć, włączamy wsparcie dla tmpfs w jądrze i dodajemy następującą linię do
<path>/etc/fstab</path>:
</p>

<pre caption="Edytowanie /etc/fstab, aby uczynić /tmp nawet bardziej lotnym">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Należy zwrócić uwagę na parametr i zmienić go tak, aby pasował do naszego
systemu. Jeśli nie jesteśmy pewni, wtedy należy w ogóle się za to nie brać, gdyż
może to łatwo stać się wąskim gardłem w wydajności naszego systemu. W przypadku
jeśli chcemy zamontować w ten sposób <path>/var/log</path>, należy się upewnić,
że pliki dziennika są na dysku przed odmontowaniem. Są one niezbędne. Nie należy
montować /var/tmp w ten sposób, gdyż Portage używa tego katalogu do
kompilacji...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Zarządzanie zasilaniem dla innych urządzeń</title>
<section>
<title>Zarządzanie zasilaniem dla kart sieci bezprzewodowych</title>
<body>

<p>
Karty sieci bezprzewodowych również pochłaniają sporo energii. Należy dodać je
do trybu zarządzania zasilaniem w analogii do skryptu pm.hda.
</p>

<pre caption="Zautomatyzowane zarządzanie zasilaniem dla WLAN">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Uruchomienie tego skryptu spowoduje dodanie wlan0 do trybu zarządzania
zasilaniem, po 3 sekundach bezczynności to urządzenie przejdzie w stan
uśpienia. Zachowujemy ten skrypt jako <path>/etc/init.d/pm.wlan0</path> i
dodajemy go do poziomu uruchamiania o nazwie "battery" tak jak powyżej. Po
więcej szczegółów i opcji należy spojrzeć do <c>man iwconfig</c>. Jeśli nasz
sterownik oraz punkt dostępu wspierają zmienianie czasu sygnału nawigacyjnego,
wtedy to jest dobrym punktem wyjścia do zachowania nawet większej ilości
energii.
</p>

<pre caption="Zarządzanie zasilaniem dla WLAN">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>Zarządzanie zasilaniem dla USB</title>
<body>

<p>
Istnieją dwa główne problemy z urządzeniami USB odnoszące się do pochłaniania
energii: pierwszy, urządzenia jak mysz USB, aparat cyfrowy lub USB sticks
pożerają energię, gdy są podpięte. Nie możemy tego ominąć (nie mniej jednak
należy je odłączyć jeśli nie są potrzebne). Po drugie, kiedy urządzenia USB są
podpięte, wtedy sterownik hosta USB okresowo uzyskuje dostęp do magistrali,
która po kolei zapobiega, aby procesor nie przeszedł stan uśpienia C3 lub C4.
Odpowiedzią systemu operacyjnego na ten problem jest tzw. "USB selective
suspend", które jeszcze nie zostało wdrożone w jądro. "USB selective suspend"
zezwala tylko na dostęp do magistrali w przypadku użycia urządzenia. Brutalnym
obejściem tego jest: kompilacja wsparcia dla USB oraz urządzeń jako modułów
oraz usuwanie ich poprzez skrypt, jeśli nie są używane (np. po zamknięciu
ekranu).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Stany uśpienia: uśpienie, oczekiwanie, suspend to disk</title>
<section>
<title>Przegląd</title>
<body>

<p>
ACPI definiuje różne stany uśpienia. Najważniejszymi są
</p>

<ul>
  <li>S1 alias Oczekiwanie,</li>
  <li>S3 alias Zawieszenie do RAM-u alias Uśpienie,</li>
  <li>S4 alias Zawieszenie na dysk twardy (ang. Suspend-to-Disk) alias
Hibernacja.</li>
</ul>

<p>
Mogą one być wezwane kiedykolwiek system jest bezczynny, ale zamknięcie systemu
nie jest wskazane z powodu długiego czasu ładowania systemu.
</p>

</body>
</section>
<section>
<title>Uśpienie, stan oczekiwania i hibernacja</title>
<body>

<p>
Wsparcie ACPI dla tych stanów uśpienia jest oznaczone jako eksperymentalne z
prostego powodu. Stany uśpienia APM są bardziej stabilne, jednakże nie możemy
używać APM i ACPI jednocześnie.
</p>

<warn>
Pomimo, że wsparcie dla stanu uśpienia ciągle ulega polepszeniom, jest ono
nadal eksperymentalne. W końcu udało mi się uruchomić swsusp2 i zawieszenie do
RAM-u, ale należy uważać: jest bardzo prawdopodobne, że te funkcje nie
zadziałają prawidłowo czego wynikiem może być zniszczenie danych lub systemu.
</warn>

<p>
Obecnie istnieją trzy implementacje dla S4. Oryginalnym jest swsusp, potem
jest swsusp2, który ma najładniejszy interfejs (zwierając wsparcie dla
bootsplasha), ale wymaga ręcznego łatania jądra. Ostatnią jest zawieszenie na
dysk, który jest rozwidleniem swsusp.
</p>

<p>
Nie należy się jednak martwić, spójrzmy na <uri
link="http://softwaresuspend.berlios.de/features.html#compare"> porównanie
cech</uri>. Jeśli nadal nie wiemy co użyć, najpierw wypróbujmy swsusp2, wygląda
najbardziej obiecująco.
</p>

<p>
Jądro należy ustawić następująco:
</p>

<pre caption="Konfiguracja jądra dla różnych typów zawieszeń">
Power Management Options ---&gt;

  <comment>(uśpienie i oczekiwanie)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernacja z swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)

  <comment>(hibernacja z swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"nasz-swap")    Domyślna nazwa urządzenia wznowienia

  <comment>(hibernacja z Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"nasz-swap") Domyślna partycja wznowienia
</pre>

<p>
Kompilujemy jądro z odpowiednimi załączonymi opcjami i wpisujemy <c>cat
/proc/acpi/sleep</c> dla jąder serii 2.4, odpowiednio <c>cat
/sys/power/state</c> dla jąder 2.6, aby zobaczyć co jest wspierane. To ostanie
polecenie u mnie wyświetla <c>standby mem disk</c>. Dla swsusp, parametr jądra
<c>resume=/dev/"nasz-swap"</c> musi być dodany. Jeśli uruchomienie systemu nie
jest możliwe z powodu zepsutego obrazu, to używamy <c>noresume</c> dla swsusp,
<c>pmdisk=off</c> dla zawieszenia na dysk twardy i <c>noresume2</c> dla swsusp2.
</p>

<p>
Aby system przeszedł w jeden z stanów uśpienia, używamy
</p>

<pre caption="Załączanie stanów uśpienia">
<comment>(jądra serii 2.4)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>         <comment>(oczekiwanie)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(uśpienie)</comment>

<comment>(jądra serii 2.6)</comment>
# <i>echo -n standby &gt; /sys/power/state</i>
<comment>(oczekiwanie)</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(uśpienie)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(hibernacja)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(hibernacja)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                   <comment>(hibernacja, patrz
poniżej)</comment>
</pre>

<warn>
Należy zrobić kopię zapasową danych przed wykonaniem tych poleceń. Wykonujemy
<c>sync</c> przed uruchomieniem jednego z poleceń, aby dane zostały zapisane na
dysku. Najpierw próbujemy tego na zewnątrz środowiska X, dopiero potem wewnątrz
X, ale jako niezalogowani.
</warn>

<p>
Jeśli wyświetli nam się komunikat o spanikowaniu jądra z powodu uhci lub
czegoś podobnego, wtedy należy skompilować wsparcie dla USB jako moduł i
usunąć go z pamięci przed uśpieniem laptopa.
</p>

<p>
Powyższe polecenia powinny wystarczyć, aby swsusp i zawieszenie na dysk
twardy uruchomiły się (nie powiedziałem zadziałały), swsusp2 wymaga specjalnej
troski. Po pierwsze należy połatać jądro za pomocą łatek znajdujących się na
<uri link="http://softwaresuspend.berlios.de/">
http://softwaresuspend.berlios.de/</uri>. Dodatkowo musimy zemergować pakiet
<c>hibernate-script</c>. Po zainstalowaniu konfigurujemy go w
<path>/etc/hibernate/hibernate.conf</path> i sprawdzamy czy działa:
</p>

<pre caption="Konfiguracja hibernacji">
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Ostatnia szansa na zrobienie kopii zapasowych danych)</comment>
<i># hibernate</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Rozwiązywanie problemów</title>
<section>
<title>Jeśli coś pójdzie nie tak...</title>
<body>

<p>
<e>P:</e>Próbując zmienić częstotliwość CPU, wyświetlany jest komunikat, że
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_regulator</path> nie
istnieje.
</p>

<p>
<e>O:</e> Należy się upewnić, że nasz procesor wspiera skalowanie częstotliwości
oraz, że wybraliśmy odpowiedni sterownik CPUFreq dla naszego procesora. Poniżej
znajduje się lista procesorów wspieranych przez CPUFreq (jądro 2.6.7): ARM
Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+,
AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon
64, Cyrix Media GXm, Intel mobile PIII i Intel mobile PIII-M na pewnych
chipsetach, Intel Pentium 4, Intel Xeon, Intel Pentium M (Centrino), National
Semiconductors Geode GX, Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III,
SuperH SH-3, SH-4, kilka "PowerBook" i "iBook2" oraz różne procesory zgodne z
systemami ACPI 2.0 (tylko jeśli "ACPI Processor Performance States" są dostępne
w interfejsie ACPI/BIOS).
</p>

<p>
<e>P:</e> Laptop wspiera skalowanie częstotliwości, ale
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> jest pusty.
</p>

<p>
<e>O:</e> Należy poszukać komunikatów o błędach ACPI za pomocą <c>dmesg | grep
ACPI</c>. Należy uaktualnić BIOS, szczególnie jeśli jest raporowany zepsuty
DSDT. Możemy również naprawić to samemu (co wykracza poza ten przewodnik).
</p>

<p>
<e>P:</e> Laptop wspiera skalowanie częstotliwości, ale według /proc/cpuinfo
prędkość nigdy się nie zmienia.
</p>

<p>
<e>O:</e> Prawdopodobnie włączyliśmy wsparcie dla symmetric multiprocessing
support (CONFIG_SMP) w jądrze. Należy to wyłączyć i wszystko powinno działać.
Niektóre starsze jądra posiadały powodujący to błąd. W takim przypadku
wykonujemy <c>emerge x86info</c>, aktualizujemy jądro gdy zostaniemy o to
zapytani i sprawdzamy częstotliwość za pomocą <c>x86info -mhz</c>.
</p>

<p>
<e>P:</e> Częstotliwość CPU może być zmieniana, ale jej zakres nie jest tak
szeroki jak w innym systemie operacyjnym.
</p>

<p>
<e>O:</e> Możemy połączyć skalowanie częstotliwości z przepustnicą ACPI, aby
otrzymać niższą minimalną częstotliwość. Zauważmy, że przepustnica nie
zachowuje wiele energii i głównie jest używana do zarządzania temperaturą
(utrzymując laptop cichym i chłodnym). Możemy uzyskać obecny stan przepustnicy
za pomocą <c>cat /proc/acpi/processor/CPU/throttling</c> i zmienić go
wykonując <c>echo -n "0:x" > /proc/acpi/processor/CPU/limit</c>, gdzie x jest
jednym ze stanów Tx wyszczególnionych w
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>P:</e> Konfigurując jądro regulatory powersave, performance i userspace
pojawiają się, ale brakuje ondemand. Gdzie go można znaleźć?
</p>

<p>
<e>O:</e> Regulator ondemand jest tylko dołączony do ostatnich źródeł jąder.
Należy uaktualnić jądro.
</p>

<p>
<e>P:</e> Żywotność baterii się pogorszyła.
</p>

<p>
<e>O:</e> Sprawdzamy ustawienia w BIOS-ie. Może zapomnieliśmy, ponownie
włączyć niektóre opcje.
</p>

<p>
<e>P:</e> Bateria jest w pełni naładowana, ale KDE wyświetla, że pozostało 0%
i natychmiastowo zamyka system.
</p>

<p>
<e>O:</e> Sprawdzamy wsparcie baterii wkompilowane w jądro. Jeśli używamy go
jako modułu, należy się upewnić, że jest on załadowany.
</p>

<p>
<e>P:</e> Posiadacze laptopów Dell Inspiron 51XX. Nie występują zdarzenia
ACPI.
</p>

<p>
<e>O:</e> Wygląda na błąd w jądrze. Przeczytajmy o tym <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">tutaj</uri>.
</p>

<p>
<e>P:</e> Nowo zakupiona bateria starcza ledwo na kilka minut! Co jest nie
tak?
</p>

<p>
<e>O:</e> Najpierw należy podążyć za wskazówkami producenta o tym jak
poprawnie naładować baterię.
</p>

<p>
<e>P:</e> Powyższe nie pomogło. Co wtedy?
</p>

<p>
<e>O:</e> Niektóre baterie sprzedawane jako "nowe" są w rzeczywistości stare.
Proszę spróbować:
</p>

<pre caption="Zapytanie o stan baterii">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Jeśli "last full capacity" różni się znacznie od "design capacity", wtedy
bateria prawdopodobnie jest zepsuta. Proszę spróbować wymiany gwarancyjnej.
</p>

<p>
<e>P:</e> Naszego problemu nie ma powyżej. Co dalej?
</p>

<p>
<e>O:</e> Nie należy się bać kontaktować bezpośrednio ze mną, <mail
link="fragfred@gmx.de">Dennis Nienhüser</mail>.
</p>

</body>
</section>
</chapter>

</guide>
