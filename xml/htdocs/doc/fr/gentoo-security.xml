<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/gentoo-security.xml,v 1.6 2003/10/21 21:42:00 neysx Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link = "/doc/fr/gentoo-security.xml">
<title>Guide de sécurité Gentoo Linux</title>
<author title="Author"><mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>

<author title="Correcteur"><mail link="zhen@gentoo.org">John P. Davis</mail>
</author>

<author title="Correcteur"><mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>

<author title="Correcteur"><mail link="carl@gentoo.org">Carl Anderson</mail>
</author>

<author title="Correcteur"><mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>

<author title="Correcteur"><mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>

<author title="Correcteur"><mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>

<author title="Correcteur"><mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>

<author title="Correcteur"><mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>

<author title="Correcteur"><mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>

<author title="Traducteur"><mail link="frlinux@frlinux.net">FRLinux</mail>
</author>

<author title="Traducteur"><mail link="mat@frheaven.com">Matthieu Montaudouin</mail>
</author>

<license/>

<abstract>
Ce manuel vous guide pas à pas pour vous aider à sécuriser votre
Gentoo Linux.
</abstract>

<version>0.4.7</version>
<date>12 octobre 2003</date>

-- Introduction start --

<chapter>
<title>Introduction</title>
<section>
<body>

<p>
Ce guide est destiné aux personnes utilisant Gentoo Linux dans un environnement serveur ou sentant le besoin d'une sécurité accrue.
</p>

<note>
Après avoir lu ce guide, si vous voulez en apprendre d'avantage sur la sécurité
et Gentoo, veuillez consulter le projet
<uri link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo</uri>.
</note>

</body>
</section>

<!-- 
<section>
<title>Ce que vous pouvez attendre de la prochaine version de ce document: </title>
<body>

<p>
Dans la version 0.6 (Sauvegardes)
</p>
<ul>
<li>Sauvegarde intégrale de votre système à l'aide de Systemimager</li>
<li>Sauvegardes partielles à l'aide de tar</li>
<li>Sauvegardes à l'aide de postgres</li>
</ul>


<p>
Dans la version 0.8 (Tests de pénétration)
</p>
<ul>
<li>Audits à distance</li>
<li>Audits réseau</li>
<li>Audits de votre hôte</li>
<li>Audits logiciels</li>
</ul>

<p>
Dans la version 1.0 (Après accord)
</p>
<ul>
<li>Comment reporter un incident</li>
<li>Analyse de Forensics</li>
<li>Créer une image de votre système sans effacer les preuves (à l'aide de dd)</li>
<li>Trap et trace (en utilisant tcpdump)</li>
<li>.. Plus à venir ..</li>
<li>Restaurer un système</li>
</ul>

<note>
Comme vous pouvez le constater, chaque version aborde un sujet unique à chaque fois. Ceci 
dans le but de maintenir la meilleure qualité possible.
</note>

</body>
</section>
-->
</chapter>

-- Fin de l'introduction --

-- Considérations avant l'installation --

<chapter>
<title>Considérations avant l'installation</title>
<section>
<title>Sécurité physique</title>
<body>

<p>
Quel que soit le nombre de protections que vous mettez en place, elles seront toutes 
contournées si l'attaquant peut accéder à la machine physiquement. Assurez-vous que 
votre serveur ne soit pas facilement accessible en le mettant, par exemple, dans un 
placard verrouillé. Fermer les boîtiers à clé est également une bonne idée. Pour un 
niveau maximum de sécurité, configurez le BIOS pour qu'il ne démarre que sur le disque
dur de la machine et rien d'autre (désactivez le démarrage à partir du lecteur de 
disquettes et du lecteur de CD-ROM). Pour les paranoïaques, mettre un mot de passe 
sur le BIOS est également une bonne idée. Un tel mot de passe est aussi une bonne idée pour les utilisateurs de 
portables.
</p>

</body>
</section>

<section>
<title>Établir la liste des services à démarrer</title>
<body>

<p>
Établissez une liste des services que la machine doit démarrer ou est supposée démarrer. Cela devrait vous aider à 
établir quel type de partitionnement vous devez appliquer. Cela rendra également
votre stratégie de détection d'intrusion plus facile.

Cette liste est facultative, si vous avez peu d'ordinateurs et que vous êtes le seul à les utiliser, par exemple si l'ordinateur est destiné à servir de pare-feu, il ne devrait démarrer <e>aucun</e> service excepté, peut-être, sshd.
</p>

<p>
Notez-le en précisant la version de SSH. Cela vous aidera à garder une trace des
systèmes que vous devrez mettre à jour dans le cas d'une faille de sécurité dans sshd.
Cela vous permettra de déterminer qui peut avoir accès à ce système.
</p>

</body>
</section>

<section>
<title>Schémas de partitions</title>
<body>

<p>
Règles d'or :
</p>

<ul>

<li>
Tout répertoire dans lequel un utilisateur peut écrire (<path>/home</path>, <path>/tmp</path> et <path>/var</path>) doit se trouver sur une partition séparée et utiliser les quotas de disques. Portage utilise <path>/var/tmp</path> pour compiler des fichiers, cette partition doit donc être volumineuse. Cela
réduit les risques que des utilisateurs ne remplissent la racine <path>/</path> de votre système.
</li>

<li>
Tout répertoire dans lequel vous installez des logiciels qui ne sont pas spécifiques à
votre distribution doit se trouver sur une partition séparée. Si on en croit le
<uri link="http://www.pathname.com/fhs/">standard de hiérarchie de fichiers</uri>.
Cela concerne notamment <path>/opt</path> ou <path>/usr/local</path>. Si ces points de montage sont sur des partitions
séparées, elles ne seront pas effacées si vous devez réinstaller votre système.
</li>

<li>
Essayez de migrer tout type de données statiques sur une partition unique et montez
cette partition en lecture seule. Si vous êtes vraiment paranoïaque, vous pouvez même
envisager de stocker ce type de données sur un média non réinscriptible comme un CDROM.
</li>

</ul>
</body>
</section>

<section>
<title>Le super-utilisateur 'root'</title>
<body>
<p>
Le super-utilisateur 'root' est l'utilisateur le plus important sur un système et ne
devrait pas être utilisé hormis en cas de nécessité absolue. Si un attaquant réussit à
corrompre votre système et obtient les droits root, vous ne pouvez
plus le considérer comme sûr, vous devez donc le réinstaller.
</p>

<p>
Règles d'or concernant 'root' :
</p>

<ul>

<li>
Essayez autant que possible de créer un utilisateur pour l'utilisation quotidienne, et utilisez-le si vous avez besoin de passer en 'root'. Ajoutez cet utilisateur
au groupe 'wheel', cela lui donnera la possibilité de faire un su vers le compte root.
</li>

<li>
N'utilisez jamais X ou toute autre application utilisateur en tant que 'root'.
</li>

<li>
Utilisez toujours des chemins absolus lorsque vous utilisez le compte 'root'. Il est
en effet possible de tromper 'root' en démarrant une application différente de celle
qu'il pense utiliser. Par exemple, si un utilisateur normal utilise 'su' sans préciser
<c>su -</c>, le PATH de l'utilisateur sera alors utilisé.
</li>

<li>
Si un utilisateur n'a besoin que de quelques commandes au lieu de toutes celles disponibles
pour root, vous devriez alors envisager l'utilisation de <c>sudo</c>, mais soyez prudent !
</li>

<li>
Ne laissez jamais un terminal ouvert lorsque vous êtes loggué en tant que root.
</li>

</ul>

<p>
Gentoo dispose d'une protection générale contre les utilisateurs normaux qui tentent
d'utiliser <c>su</c>. Le comportement par défaut de PAM impose à l'utilisateur d'appartenir au
groupe wheel pour pouvoir faire un su.
</p>

</body>
</section>

<section>
<title>Politique de sécurité</title>
<body>

<p>Plusieurs raisons justifient une politique de sécurité.</p>

<ul>

<li>
Vous ne pouvez pas garantir la sécurité de votre réseau sans avoir une définition
précise de ce que vous pensez avoir sécurisé.
</li>

<li>
Il est quasiment impossible d'attraper des attaquants potentiels, résoudre des problèmes
réseau ou faire des audits sans espionner le réseau ou bien encore sans consulter
les dossiers personnels des utilisateurs, tout en sachant que le fait d'espionner sans l'accord préalable des utilisateurs
est illégal dans la plupart des pays. Mais il faut aussi savoir que 60% des attaques proviennent de l'intérieur
de la société, il est donc important de rester vigilant.
</li>

<li>
Vous ne pouvez pas attendre de vos utilisateurs qu'ils pensent à la sécurité si vous ne leur en avez jamais expliqué l'importance ni comment se protéger eux-mêmes et aider leurs collègues.
</li>

<li>
Des règles précises et une documentation sur le réseau sont toujours payantes, quoi qu'il advienne.
</li>

<li>
La police ou les forces de l'ordre ne peuvent pas vous aider à attraper les attaquants s'ils ne connaissent pas le type de réseau que vous avez ou les services que 
vous fournissez.
</li>

<li>
Que faire si vous venez de subir une attaque ? Vous devez définir ce que vous allez faire 
et ce que vous pourrez dévoiler. Allez-vous juste appeler la police ou l'équipe CERT 
(NdT : équipe de sécurité) à chaque fois ? Ils risquent rapidement de ne plus vous
prendre au sérieux.
</li>

</ul>

<p>
Cela devrait clairement définir pourquoi il est important de mettre en place une politique de sécurité sur des 
systèmes qui ont plus d'un utilisateur et pourquoi il est important de former les utilisateurs.
</p>

<p>
Une charte est constituée d'un ou plusieurs documents qui permettent de répondre à des questions comme qui, où, pourquoi et quoi.
Chaque utilisateur de votre réseau/système devrait les lire, les comprendre et les signer. Il est important que vous preniez le temps 
de faire comprendre le règlement aux utilisateurs et pourquoi il est nécessaire de le leur faire signer ainsi que les conséquences en cas de non respect de la 
charte (le règlement devrait normalement le mentionner noir sur blanc). Cela devrait 
être reproduit tous les ans vu que le règlement peut évoluer mais aussi pour rappeler 
aux utilisateurs que la charte existe.
</p>

<note>Créez une charte qui soit facile à comprendre et précise dans tous les sujets abordés.</note>

<p>
La plupart des règles peuvent être mises en place directement sur le système
d'exploitation ou par le biais de pare-feu alors que c'est impossible à faire pour d'autres.
</p>

<p>
Une charte de sécurité doit contenir au moins les points suivants:
</p>

<ul>

<li>Utilisation correcte</li>
<ul>
  <li>Economiseurs d'écran</li>
  <li>Gestion des mots de passe</li>
  <li>Téléchargement et installation de logiciels</li>
  <li>Informer les utilisateurs s'ils sont surveillés</li>
  <li>Utilisation de programmes anti-virus</li>
</ul>

<li>Gestion des informations sensibles (sous forme écrite, papier ou numérique)</li>
<ul>
  <li>Rangement du bureau et mise sous clé des informations sensibles</li>
  <li>Extinction du PC avant de partir</li>
  <li>Utilisation du cryptage</li>
  <li>Gestion des clés avec les collègues de confiance</li>
  <li>Manipulation du matériel sensible en cas de voyage.</li>
</ul>

<li>Manipulation de l'équipement informatique pendant un voyage</li>
<ul>
    <li>Manipulation des portables pendant les voyages et durant les séjours en hôtel</li>
</ul>

</ul>

<p>
Les procédures pour le personnel informaticien seront sans doute
différentes de celles qui concernent l'utilisateur normal.
</p>

<p>
Une politique de sécurité peut devenir très volumineuse et des informations vitales peuvent être facilement oubliées.
La politique pour les informaticiens devrait contenir des informations non disponibles aux utilisateurs normaux, il est donc intelligent de la découper en chartes plus petites, c'est-à-dire Charte de bon usage, Politique de mots de passe, Politique de mails et Politique d'accès distant.
</p>

<p>
Des exemples de politiques se trouvent sur le site du
<uri link="http://www.sans.org/newlook/resources/policies/policies.htm">
projet de sécurité SANS</uri>. Si vous avez un petit réseau et si vous pensez que 
ces procédures sont trop lourdes, vous devriez consulter le guide de sécurité
<uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">RFC2196</uri>.
</p>

</body>
</section>
</chapter>

-- Considérations avant l'installation : fin --

-- Maintenir et améliorer la sécurité après/pendant l'installation --

<chapter>
<title>Améliorer la sécurité pendant/après l'installation</title>
<section>
<title>Options USE</title>
<body>

<p>
Le fichier <path>make.conf</path> contient les options de la variable USE définies par l'utilisateur et <path>/etc/make.profile/make.defaults</path> contient les options USE utilisées par défaut dans Gentoo Linux.
Dans ce guide, nous allons nous intéresser aux options <c>pam</c> (Pluggable Authentication Modules), <c>tcpd</c> (couche TCP) et <c>ssl</c> (Secure Socket Layer). Elles sont toutes dans les options USE par défaut.
</p>

</body>
</section>

<section>
<title>Mot de passe GRUB</title>
<body>

<p>
Grub permet d'ajouter une sécurisation par mot de passe à son fichier de configuration
(<path>/boot/grub/grub.conf</path>) de deux manières différentes. La première avec un mot de passe en clair et la 
seconde en faisant un cryptage md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changez_moi
</pre>

<p>
Cela ajoutera un mot de passe <c>changez_moi</c>. Si aucun mot de passe n'est entré, les paramètres de démarrage par défaut seront alors utilisés.
</p>

<p>
Lorsque vous ajoutez un mot de passe md5,  vous devez le convertir en format crypté
(<c>man crypt</c>)  qui est du même format que le fichier <path>/etc/shadow</path>. Le mot de passe <e>changez_moi</e> peut par exemple ressembler à ça: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</p>

<p>
Ou bien vous pouvez le convertir directement dans le shell de Grub:
</p>

<pre caption="Cryptage md5 dans le shell grub">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>***********</i>
<codenote>Tapez changez_moi</codenote>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Ensuite copiez/collez votre mot de passe dans <path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Le temps limite de 5 secondes devient très pratique si votre système est controlé à 
distance et doit pouvoir redémarrer sans utiliser le clavier. Vous pouvez obtenir plus 
d'informations sur grub et les mots de passe en tapant <c>info grub</c>.
</p>

</body>
</section>

<section>
<title>Mot de passe LILO</title>
<body>

<p>
LILO supporte deux méthodes pour manipuler les mots de passe : globale et par image. 
Les deux contiennent des mots de passe en clair.
</p>

<p>
La première méthode globale se place en haut du fichier de configuration comme ceci :
</p>

<pre caption="/etc/lilo.conf">
password=changez_moi
restricted
delay=3
</pre>

<p>
La seconde se place directement dans la section de l'image comme suit :
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changez_moi
      restricted
</pre>

<p>
Si l'option <c>restricted</c> n'est pas spécifiée, l'ordinateur vous demandera un 
mot de passe à chaque fois.
</p>

<p>
Vous devez exécuter <c>/sbin/lilo</c> pour enregistrer les informations que vous avez 
entrées dans votre fichier <path>lilo.conf</path>.
</p>

</body>
</section>

<section>
<title>Restrictions concernant l'utilisation de la console</title>
<body>
<p>
Le fichier <path>/etc/securetty</path> vous permet de spécifier quels sont les périphériques <c>tty</c> (terminaux) utilisables par le root pour se connecter.
</p>

<p>
Nous vous conseillons de commenter toutes les lignes à part <c>vc/1</c>. Cela vous permettra 
d'être sûr que root n'a le droit de se connecter qu'une seule fois et sur un seul terminal.
</p>
<note>
Les utilisateurs du groupe wheel peuvent toujours utiliser <c>su -</c> pour devenir root sur d'autres TTY.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Plus de logs</title>
<section>
<body>

<p>
Vous devriez ajouter des logs pour obtenir plus d'avertissements ou d'erreurs qui 
peuvent indiquer une attaque en cours ou bien une attaque déjà déployée. Les 
attaquants sondent généralement le réseau avant de commencer une attaque.
</p>

<p>
Il est également important que les fichiers de logs soient lisibles et facilement exploitables.
Gentoo Linux vous permet de choisir entre 3 types de systèmes de gestion de logs
au moment de l'installation.
</p>

<section>
<title>Syslogd</title>
<body>

<p>
Syslogd est le système de log le plus répandu sous Linux et Unix en général. Il n'inclut aucun système 
de rotation pour les logs. Cette partie est gérée par <path>/usr/sbin/logrotate</path> dans 
les tâches de <path>cron</path> et configurée dans <path>/etc/logrotate.conf</path>.
La fréquence de rotation des logs dépend de la charge du système.
</p>

<p>
Ci-dessous il y a le <path>syslog.conf</path> standard avec quelques fonctionnalités supplémentaires.
Nous avons décommenté les lignes <c>cron</c> et <c>tty</c> et ajouté un serveur de log distant.
Pour encore plus de sécurité, vous pouvez ajouter les logs dans deux emplacements.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Fichier de configuration pour syslogd.
#
#                       Pour plus d'informations, voir la page man syslog.conf(5).
#                       Cela provient de la Debian, nous l'utilisons actuellement
#                       Daniel Robbins, 5/15/99

#
# Tout d'abord quelques fichiers de log standards.  Log par fonction.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Log pour le système de mail. Séparez-le afin
# qu'il soit facile d'écrire des scripts pour analyser ces fichiers.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Log pour le système de news INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Quelques fichiers de logs "attrape-tout".
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Les urgences et alertes sont envoyées à toutes les personnes loguées.
#
*.emerg                         *
*.=alert                        *

#
# J'aime avoir des messages affichés sur la console, mais seulement
# sur une console virtuelle que je n'utilise pas.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# Installation d'un serveur de logs distant
*.*                        @logserver

# Le tube nommé /dev/xconsole est pour l'utilitaire `xconsole'.  Pour l'utiliser
# vous devez invoquer `xconsole' avec l'option `-file':
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: ajustez la liste ci-dessous ou vous allez devenir fou si vous avez
#      un site plutôt actif...
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
L'attaquant essaiera généralement d'effacer ses traces en éditant ou en effaçant les 
fichiers de logs. Vous pouvez rendre sa tâche plus complexe en envoyant les logs sur une 
ou plusieurs autres machines.
Vous pouvez trouver plus d'info sur syslogd en consultant la page du manuel
(<c>man syslog</c>).
</p>

</body>
</section>

<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri>, écrit par Frank Dennis, n'est pour 
sa part pas capable de logger sur des serveurs à distance, mais il a bien d'autres 
avantages concernant ses performances et la flexibilité de logging.
Il peut logguer par nom de programme, importance ou fonction (comme syslogd) et permet aussi
l'analyse des logs avec les expressions rationnelles permettant de déclencher 
l'exécution de commandes. Cela s'avère très pratique dans les situations qui demandent une réaction.
</p>

<p>
La configuration de base est généralement suffisante. Si vous voulez être averti par mail quand une erreur de mot de passe est commise, utilisez l'un des scripts suivants.
</p>

<p>
Pour postfix:
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh pour postfix">
#! /bin/sh
echo "$3" | mail -s "Attention (programme : $2)" root
</pre>

<p>
Pour qmail:
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh pour qmail">
#!/bin/sh
echo "To: root
Subject:Echec (Attention: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
N'oubliez pas de rendre ces scripts exécutables en faisant <c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c>
</p>

<p>
Ensuite, décommentez les lignes de commande sous Password failures dans <path>/etc/metalog/metalog.conf</path> comme ceci:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>

<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng propose les mêmes fonctionnalités que syslog et metalog avec quelques petites différences.
Il peut notamment filtrer les messages en se basant sur un niveau d'exécution 
et un contenu (tout comme metalog), gérer des logs distants comme syslogd, exploiter des logs venant 
de syslogd (même de flux venant de Solaris), écrire sur une console TTY, exécuter des 
programmes et être paramétré comme serveur de logs. Il représente actuellement le 
meilleur système combinant le meilleur des deux autres programmes cités ci-dessus en ajoutant 
des options de configuration avancées.
</p>

<p>
Un fichier de configuration classique légèrement modifié :
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#endroit où lire le log
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#définir les destinations
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination mailprog { program("/usr/bin/email.sh"); };
destination xconsole { pipe("/dev/xconsole"); };

#créer les filtres
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#connectez les filtres et les destinations
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#envoyer par mail les logs ratés
log { source(src); filter(f_failed); filter(f_denied); destination(mailprog); };

#log par défaut
log { source(src); destination(console_all); };
</pre>

<p>
Il est très simple à configurer, mais il est aussi très facile d'oublier quelque chose dans le fichier de configuration tellement il est volumineux.
L'auteur
nous promet d'autres améliorations comme le cryptage, l'authentification, la
compression et le contrôle par adresse MAC (Mandatory Access Control). Avec ces
options, il deviendra un système de log réseau parfait étant donné que l'attaquant
ne pourra plus espionner le log.
</p>

<p>
Syslog-ng a bien d'autres avantages et il n'a pas besoin de tourner en tant que root !
</p>

</body>
</section>
</body>
</section>
</chapter>

<chapter>
<title>Montage des partitions</title>
<section>
<body>

<p>
Lorsque vous montez des partitions <c>ext2</c>, <c>ext3</c> ou <c>reiserfs</c>, il y a
plusieurs options que vous pouvez appliquer au fichier <path>/etc/fstab</path>.
En voici le descriptif :
</p>

<ul>

<li>
<c>nosuid</c> - Ignore l'option SUID et considère chaque fichier comme un fichier ordinaire
</li>

<li>
<c>noexec</c> - Interdit l'exécution de tout programme à partir de cette partition
</li>

<li>
<c>nodev</c> - Ne tient pas compte des devices
</li>
</ul>

<p>
Ces paramètres peuvent malheureusement être assez facilement contournés en utilisant
un chemin indirect. Vous pourrez néanmoins arrêter 99% des script kiddies en plaçant
l'option noexec sur <path>/tmp</path> car leurs exploits sont généralement programmés pour être exécutés
à partir de ce répertoire.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>Mettre <path>/tmp</path> en mode <c>noexec</c> peut empêcher le fonctionnement de certains scripts.</warn>
<note>Pour les quotas de disque, cf. la <uri link="#doc_chap6_sect3">section des quotas</uri>.</note>

<note>
Notez que je ne mets pas le répertoire <path>/var</path> en mode <c>noexec</c> ou <c>nosuid</c>
même si les fichiers ne sont jamais exécutés depuis ce point de montage. La raison
principale tient au fait que qmail est installé dans <path>/var/qmail</path> et doit
être autorisé à exécuter et à manipuler un fichier SUID. Je paramètre
<path>/usr</path> en mode lecture seule (read-only) étant donné que je n'y
écris jamais sauf pour mettre à jour Gentoo. Je remonte alors le système de fichiers
en mode lecture-écriture (read-write), je procède à la mise à jour et je remonte le
système en lecture seule.
</note>

<note>Même si vous n'utilisez pas qmail, Gentoo a besoin que <path>/var/tmp</path> soit exécutable, étant donné que les ebuilds sont construits dans ce
répertoire. Mais vous pouvez néanmoins paramétrer un chemin différent si vous tenez
absolument à mettre <path>/var</path> en mode <c>noexec</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Limitations pour utilisateurs et groupes</title>

<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
La limitation des ressources peut se révéler très utile pour éviter une 
attaque de type déni de sevice local ou bien pour limiter le nombre total de logins pour un groupe 
ou un utilisateur.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Si vous vous rendez compte que vous mettez <c>nproc</c> ou <c>maxlogins</c> à 0, il serait certainement plus simple de supprimer l'utilisateur.
L'exemple ci-dessus paramètre le groupe <c>dev</c> pour le nombre
de processus, les fichiers core et <c>maxlogins</c>. Le reste est laissé à la valeur par défaut.
</p>
<note><path>/etc/security/limits.conf</path> fait partie du paquet PAM et ne sera utilisé 
que par les paquets dépendant de PAM.</note>

</body>
</section>

<section>
<title>/etc/limits</title>
<body>
<p>
Le fichier <path>/etc/limits</path> est très similaire au fichier <path>/etc/security/limits.conf</path>. Les seules différences se situent dans le format et 
 le fait qu'il ne fonctionne que sur des utilisateurs ou des expressions rationnelles 
(pas sur les groupes). Regardons un exemple de configuration de plus près :
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Nous réglons ici les paramètres par défaut, mais également une valeur particulière pour 
l'utilisateur kn. Les limites font partie du paquet sys-apps/shadow. Il n'est pas nécessaire de mettre des limites dans ce fichier si vous avez désactivé <c>pam</c> dans votre <path>make.conf</path> ou si vous n'avez pas configuré PAM correctement.
</p>

</body>
</section>
<section>

<title>Quotas</title>
<body>

<warn>
Assurez-vous que le système de fichiers avec lequel vous travaillez supporte les quotas. ReiserFS par exemple ne les gére pas !
</warn>

<p>
Placer des quotas sur un système de fichiers évite que les utilisateurs ne remplissent 
complètement le disque ou même qu'ils y écrivent. Les quotas sont 
activés dans le noyau et ajoutés par la suite sur un point de montage. L'option du noyau
qui active ce paramètre se trouve dans la section <c>File systems->Quota support</c>. Appliquez 
l'option, recompilez votre noyau et redémarrez en utilisant votre nouveau noyau.
</p>

<p>
Commencez par installer les quotas avec <c>emerge quota</c>. Modifiez ensuite votre fichier <path>/etc/fstab</path> et ajoutez les paramètres <c>usrquota</c> et <c>grpquota</c>  aux partitions sur lesquelles vous souhaitez restreindre l'utilisation disque comme le montre l'exemple ci-dessous.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Vous devez ensuite créer les fichiers de quotas (<path>quota.user</path> et <path>quota.group</path>) pour chaque
partition où vous avez activé les quotas et les placer à la racine de ces partitions.
</p>

<pre caption="création des fichiers de quota">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Cette étape est nécessaire pour chaque partition où les quotas sont actifs. Après avoir 
ajouté et configuré les fichiers de quotas, vous devez ajouter un script au démarrage qui 
mettra en route les quotas à chaque boot. Copiez/collez le script suivant dans le fichier 
<path>/etc/init.d/quotas</path>. Créez le fichier s'il n'existe pas encore et rendez-le 
exécutable.
</p>

<pre caption="/etc/init.d/quotas">
#!/sbin/runscript

depend() {
	need localmount
}

start() {
        if [ -x /sbin/quotacheck ]
        then
               ebegin "Vérification des quotas. Veuillez patienter ..."
               /sbin/quotacheck -avug
               eend $?
        fi
        if [ -x /sbin/quotaon ]
        then
               ebegin "Activation des quotas."
               /sbin/quotaon -avug
               eend $?
        fi
}

stop() {
        if [ -x /sbin/quotaon ]
        then
	       ebegin "Désactivation des quotas."
               /sbin/quotaoff
	       eend $?
        fi
}
</pre>

<p>
Rendez-le exécutable avec la commande <c>chmod +x /etc/init.d/quotas</c> et ajoutez-le au démarrage avec <c>rc-update add quotas default</c>. Vérifiez les quotas toutes les semaines en ajoutant la ligne suivante dans <path>/etc/crontab</path>.
</p>

<pre caption="Ajouter la vérification des quotas au crontab">
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
Après avoir redémarré la machine, il est temps de configurer les quotas pour les utilisateurs 
et les groupes. La commande <c>edquota -u kn</c>  démarrera l'éditeur défini dans 
$EDITOR (nano par défaut) qui vous permettra d'éditer les quotas de votre 
utilisateur kn. <c>edquota -g</c> vous permet de faire la même chose pour les groupes.
</p>

<pre caption="Mettre en place des quotas pour l'utilisateur kn">
Quotas pour l'utilisateur kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Pour plus d'informations sur les quotas, consultez les pages de manuel à l'aide de
<c>man edquota</c> ou bien <uri link="http://www.linuxdoc.org/HOWTO/mini/Quota.html">le mini-howto des quotas</uri>.
</p>

</body>
</section>

<section>
<title>/etc/login.defs</title>
<body>

<p>
Si la charte spécifie que les utilisateurs doivent changer leur mot de passe toutes les 
deux semaines, mettez la valeur de <c>PASS_MAX_DAYS</c> à 14 et celle de <c>PASS_WARN_AGE</c> à 7. 
Il est également conseillé d'utiliser l'ancienneté des mots de passe car les attaques par force brute trouveront n'importe quel mot de passe, ce n'est qu'une question de temps. Nous recommandons également de mettre la variable <c>LOG_OK_LOGINS</c> à yes.
</p>

</body>
</section>

<section>
<title>/etc/login.access</title>
<body>
<p>
Le fichier <path>login.access</path> fait également partie du paquet sys-apps/shadow qui vous donne alors
accès à une table de contrôle des logins. Cette table est utilisée pour décider
qui a le droit ou pas d'ouvrir une session en fonction du nom d'utilisateur, du nom de groupe ou du nom d'hôte. 
Par défaut, tous les utilisateurs du système ont le droit d'ouvrir une session, le fichier n'est donc constitué que d'exemples et de commentaires.
Que vous sécurisiez une station
de travail ou un serveur, nous vous recommandons de configurer ce fichier de telle sorte
que vous (l'administrateur) soyez le seul autorisé à accéder à la console.
</p>
<note>Ces paramètres ne sont pas applicables à root.</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Faites attention lorsque vous entrez ces options, car une erreur vous laissera sans accès à la machine si vous n'avez pas d'accès root.
</impo>

<note>
Ces paramètres n'affectent pas SSH car il n'utilise pas <c>/bin/login</c> par défaut. Vous pouvez
activer cette option en mettant <c>UseLogin yes</c> dans le fichier
<path>/etc/ssh/sshd_config</path>. SSH utilisera alors le login et votre configuration
sera utilisée.
</note>

<p>
Cela paramétrera l'accès d'ouverture de session pour que les membres du groupe
wheel puissent ouvrir une session sur la console locale ou depuis le domaine gentoo.org. Cela peut paraître très paranoïaque, mais il vaut mieux être sécurisé
que désolé.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Permissions de fichiers</title>
<section>
<body>

<section>
<title>Lecture pour tous</title>
<body>

<p>
Les utilisateurs normaux ne devraient pas avoir accès aux fichiers de configuration ou
de mots de passe. Un attaquant pourrait dérober les mots de passe d'une base de
données ou d'un site Internet et les utiliser pour modifier, voire effacer des données. C'est pourquoi
il est important que les permissions soient correctes. Si vous êtes certain qu'un fichier
n'est utilisé que par root, assignez-lui les permissions <c>0600</c> et assignez au fichier l'utilisateur correct avec <c>chown</c>.
</p>

</body>
</section>

<section>
<title>Ecriture pour tous les utilisateurs et tous les groupes</title>
<body>

<pre caption="Trouver des fichiers et répertoires accessibles en écriture pour tous">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Cela créera un long fichier contenant la liste des fichiers qui ont
un droit d'écriture pour tout le monde ou pour le groupe. Vérifiez les permissions et
éliminez les droits sur les fichiers qui sont accessibles en écriture par tout le monde en exécutant la commande <path>/bin/chmod o-w</path> sur ces fichiers.
</p>

</body>
</section>

<section>
<title>Les fichiers SUID/SGID</title>
<body>

<p>
Les fichiers avec le bit SUID ou SGID positionné peuvent être exécutés avec les privilèges de l'utilisateur ou du groupe <e>possédant</e> ce fichier, et non ceux de l'utilisateur qui exécute le fichier.
Normalement, ces bits sont utilisés sur des fichiers qui doivent fonctionner en root pour faire ce qu'ils ont à faire.
Ces fichiers peuvent mener à une exploitation locale de votre système avec les droits
root s'ils contiennent des failles de sécurité. Ceci est dangereux et les fichiers avec des bits SUID ou SGID doivent être évités à tout prix. 
Si vous n'utilisez pas ces fichiers, faites
un <c>chmod 0</c> dessus ou bien désinstallez les paquets qui ont généré ces fichiers
(vérifiez à quel paquet ils appartiennent avec la commande <c>qpkg -f</c>, si vous ne l'avez pas déjà installé, faites
<c>emerge gentoolkit</c>). Sinon modifiez juste le bit SUID en faisant <c>chmod -s</c>.
</p>

<pre caption="Trouver des fichiers setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Cette commande crée un fichier contenant la liste de tous les fichiers SUID/SGID.
</p>

<pre caption="Liste des binaires setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Gentoo Linux ne contient pas beaucoup de fichiers SUID par défaut (cela dépend de ce que
vous avez installé), vous pouvez néanmoins obtenir une liste similaire à celle ci-dessus. La plupart de ces commandes ne devraient pas être utilisées par des utilisateurs
normaux et donc restreintes à root. Désactivez le mode suid sur <c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> et <c>traceroute</c> en faisant <c>chmod -s</c> sur chacun
de ces fichiers. N'enlevez pas ce mode sur les fichiers <c>su</c>, <c>qmail-queue</c> ou <c>unix_chkpwd</c>.
En effet, cela vous empêcherait de pouvoir faire des su ou bien de recevoir des mails.
En modifiant ce bit, vous enlevez la possibilité à un utilisateur normal (ou un attaquant) d'obtenir un accès root grâce à ces fichiers.
</p>

<p>
Les seuls fichiers en mode SUID que j'ai sur mon système sont <c>su</c>, <c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> et <c>pwdb_chkpwd</c>. Mais vous en aurez sans doute d'autres si
vous désirez avoir X sur votre machine.
</p>

</body>
</section>


</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM est un ensemble de bibliothèques partagées qui proposent une méthode alternative pour effectuer des authentifications dans les programmes. 
L'option <c>pam</c> est activée par défaut dans la variable USE.
Les paramètres de configuration de PAM dans Gentoo Linux sont relativement
bons, mais on peut toujours faire mieux.
Tout d'abord installez cracklib.
</p>

<pre caption="Installer cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_pwdb.so shadow nullok
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authok
password required pam_pwdb.so md5
session	 required pam_pwdb.so
</pre>

<p>
Ceci ajoutera cracklib qui contrôlera que les utilisateurs entrent un mot de passe
d'un minimum de 8 lettres et qui contient au moins 2 chiffres, 2 symboles et qu'au
moins 3 caractères sont différents du dernier mot de passe. Cela force l'utilisateur à choisir un bon mot de passe. Consultez la documentation
<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>
pour de plus amples informations.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_pwdb.so nullok
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authok
password required pam_pwdb.so shadow md5
session	 required pam_pwdb.so
session	 required pam_limits.so
</pre>

<p>
Tout service non configuré par un fichier PAM dans <path>/etc/pam.d</path>
utilisera alors les règles contenues dans <path>/etc/pam.d/other</path>. Les valeurs par défaut sont mises à <c>deny</c> comme il se doit. Mais aimant avoir beaucoup de logs, j'ai ajouté <c>pam_warn.so</c>. La
dernière configuration est <c>pam_limits</c> qui est controlée par
<path>/etc/security/limits.conf</path>. Consultez la <uri link="#doc_chap6_sect1">section /etc/security/limits.conf</uri> pour plus d'informations sur ces paramètres.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Les wrappers TCP</title>
<section>
<body>

<p>
Ils permettent de contrôler l'accès aux services normalement démarrés par inetd
(que Gentoo n'utilise pas) mais peuvent également être utilisés par xinetd et d'autres
services.
</p>
<note>Le service doit mentionner tcpd dans ses arguments de démarrage (dans xinetd). Consultez le
chapitre sur xinetd pour de plus amples informations.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Comme vous pouvez le constater, ce format est similaire à celui de
<path>/etc/login.access</path>. Tcpd supporte un service spécifique et il ne travaille
pas dans le même genre de sécurité. Ces paramètres ne sont applicables qu'aux
services qui utilisent les wrappers tcpd.
</p>

<p>
Il est également possible d'exécuter des commandes lorsqu'un service est sollicité
(par exemple lorsque vous utilisez la possibilité de numérotation d'un modem pour
les utilisateurs) bien que cela ne soit pas recommandé car les personnes ont tendance
à créer plus de problèmes qu'ils n'en résolvent. Un exemple serait de créer
un script que qui envoie un email à chaque fois que quelqu'un se voit refuser un accès
à cause d'une règle d'interdiction. Une personne malveillante pourrait alors faire
une attaque de type de déni de service en provoquant continuellement l'exécution de ce script de notification.  Cela génèrerait
alors beaucoup d'entrées/sorties et de mails, donc ne le faites pas ! Lisez également
le <c>man 5 hosts_access</c> pour plus d'informations.
</p>

</body>
</section>
</chapter>

-- Renforcer la sécurité après/pendant l'installation : fin --

-- Sécurité du kernel début --

<chapter>
<title>Sécurité du noyau</title>

<section>
<title>Retirer des fonctionnalités</title>
<body>

<p>
La règle de base lorsque vous configurez le noyau est de retirer tout ce dont vous
n'avez pas besoin. Cela créera non seulement un noyau de petite taille mais retirera
également toute vulnérabilité qui pourrait être contenue dans un pilote ou dans
d'autres modules.
</p>

<p>
Vous pouvez également penser à désactiver le support de chargement des modules.
Même s'il est possible de charger des modules (root kits) sans cette option, cela
compliquera l'installation d'un root kit par un attaquant par le biais des modules du noyau.
</p>

</body>
</section>

<section>
<title>/proc (options du noyau)</title>
<body>

<p>
De nombreux paramètres peuvent être modifiés par le biais de <path>/proc</path> ou en utilisant
<c>sysctl</c>.
</p>

<p>
Vous devez avoir défini <c>CONFIG_SYSCTL</c> dans votre noyau afin de pouvoir modifier des
paramètres et variables du noyau dynamiquement. Le noyau 2.4 le contient par défaut.
</p>

<pre caption="Ignorer les paquets ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Cette commande indiquera au noyau d'ignorer les messages de ping (paquets icmp de type 0).
La raison pour cela est qu'un paquet IP transportant un message ICMP peut contenir beaucoup plus d'informations que vous ne le pensez.
Les administrateurs utilisent ping comme un outil de diagnostic et se plaindront souvent s'ils ne peuvent l'utiliser. Il n'y a aucune raison que quelqu'un de l'extérieur puisse faire un ping, mais quelquefois cela peut être pratique pour les utilisateurs locaux. Ce problème peut être résolu en désactivant les messages icmp de type 0 sur le pare-feu.
</p>

<pre caption="Ignorer les pings broadcast">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Ceci désactive les réponses aux broadcasts ICMP et préviendra des attaques smurf. 
Les attaques smurf fonctionnent en envoyant un message ICMP de type 0 (ping) à l'adresse broadcast du réseau. Typiquement, l'attaquant utilisera une adresse source fausse. Tous les ordinateurs du réseau répondront alors au message ping et l'hôte qui possède vraiment l'adresse source utilisée sera surchargé de messages.
</p>

<pre caption="Désactive le routage de paquets d'origine interne">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
N'acceptez pas les paquets apparemment d'origine interne. Un attaquant peut en effet générer du
trafic vers votre réseau en prétendant faire partie du réseau interne.
Accepter de tels paquets lui permettrait alors de compromettre votre réseau. Le
routage de paquets d'origine interne est rarement utilisé à des fins légitimes donc désactivez-le.
</p>

<pre caption="Désactiver l'autorisation de redirection">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Désactivez  l'autorisation des redirections ICMP. Elles sont souvent utilisées pour
altérer vos tables de routage et parfois de façon malicieuse.
</p>

<pre caption="Protection contre les mauvais messages d'erreur">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Activez la protection contre les faux messages d'erreurs.
</p>

<pre caption="Active le filtrage de chemin inverse">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>
Si vous activez l'IP forwarding, vous aurez le même résultat.
</note>

<p>
Activez le filtrage de chemin inverse. Cela vous permet de vous assurer que les paquets
utilisent des adresses sources légitimes en rejettant automatiquement les paquets
entrants si l'entrée de leur adresse source dans la table de routage ne correspond
pas à la carte réseau par laquelle ils entrent. Un des avantages est de pouvoir
empêcher l'usurpation d'IP (spoofing).
</p>

<warn>
Par contre, cela peut poser des
problèmes si vous utilisez un routage asymétrique (les paquets qui vont
de votre machine vers une autre prennent un chemin différent de celui pris par les
paquets revenant de cette machine vers la vôtre) ou bien si vous utilisez un hôte non routant qui a plusieurs adresses IP sur différentes cartes.
</warn>

<pre caption="Logger tous les paquets falsifiés, routés par la source et redirigés">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Enregistre dans le log les paquets falsifiés, les paquets routés par la sources et ceux qui sont redirigés.
</p>

<pre caption="Désactive l'IP forwarding">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Assurez-vous d'avoir désactivé l'IP forwarding. Il n'est utile que pour une machine
avec plusieurs connexions.
</p>

<p>Tous ces paramètres seront effacés lors de votre prochain redémarrage. Je vous conseille
donc d'ajouter le script suivant au runlevel par défaut (<c>rc-update add procparam default</c>) et de le rendre exécutable (<c>chmod +x /etc/init.d/procparam</c>).
</p>

<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 use checkroot
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>

</body>
</section>

<section>
<title>Grsecurity</title>
<body>

<p>
Le patch disponible sur <uri link="http://grsecurity.net">Grsecurity</uri> est inclus
dans les sources du noyau Gentoo mais désactivé par défaut. Voici comment l'activer :
</p>

<p>
Configurez votre noyau comme vous le faites normalement et configurez ensuite l'option
Grsecurity (sélectionnez l'option custom) en activant les options suivantes :
</p>

<ul>
<li>Buffer Overflow Protection</li>
<ul>
  <li>Openwall non-executable stack</li>
  <li>GCC trampoline support</li>
</ul>

<li>Filesystem Protections</li>
<ul>
  <li>Proc restrictions</li>
  <li>Linking restrictions</li>
  <li>Secure file descriptors</li>
  <li>Chroot jail restrictions (activez toutes les options dépendantes de celle-ci)</li>
</ul>

<li>Kernel Auditing</li>
<ul>
  <li>Log execs within chroot</li>
  <li>(Un)Mount logging</li>
  <li>Signal logging</li>
  <li>Fork failure logging</li>
  <li>Log set*ids to root</li>
  <li>Time change logging</li>
</ul>

<li>Executable Protections</li>
<ul>
  <li>Dmesg restriction</li>
  <li>Randomized PIDs</li>
  <li>Altered default IPC permissions (peut empêcher le fonctionnement normal de certains programmes)</li>
  <li>Restricted ptrace</li>
</ul>

<li>Network Protections</li>
<ul>
  <li>Randomized IP IDs</li>
  <li>Randomized TCP source ports</li>
  <li>Altered Ping IDs</li>
  <li>Randomized TTL</li>
</ul>
<li>Miscellaneous Features</li>
<ul>
  <li>BSD-style coredumps (va créer des core dumps du style <path>core.named</path>)</li>
</ul>

</ul>

<p>
Compilez et installez à présent votre nouveau noyau sécurisé.
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> est un patch qui ajoute des fonctions
de cryptage à votre noyau. En patchant votre noyau, vous obtiendrez de nouvelles
options comme : le chiffrement cryptographique, des algorithmes de validation et des filtres
de boucles cryptographiques.
</p>
<warn>Le patch kerneli n'est actuellement pas stable pour les derniers noyaux, vous prenez
donc des risques en l'utilisant.</warn>

</body>
</section>

<section>
<title>Autres patchs du noyau</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">Le projet OpenWall </uri> (pas pour les noyaux 2.4).</li>
  <li><uri link="http://www.lids.org">Système de détection d'intrusion pour Linux</uri>.</li>
  <li><uri link="http://www.rsbac.org">Contrôle d'accès par règles</uri>.</li>
  <li><uri link="http://www.nsa.gov/selinux">Le noyau sécurisé de la NSA</uri>.</li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri>.</li>
</ul>

<p>
Et il en existe probablement beaucoup d'autres.
</p>

</body>
</section>
</chapter>

-- fin de la sécurité du Kernel --

-- début de la sécurisation des services --

<chapter>
<title>Sécurisation des services</title>

<section>
<title>Utiliser xinetd</title>
<body>
<p>
xinetd remplace inetd (que Gentoo ne propose pas), le démon pour les services
Internet. Il supporte les contrôles d'accès basés sur l'adresse de la machine distante
et sur l'heure de l'accès. Il fournit également des fonctionnalités avancées de log, incluant
l'heure de démarrage du serveur, l'adresse de la machine distante, le nom de l'utilisateur distant,
la durée de fonctionnement du serveur ainsi que les actions demandées.
</p>

<p>
Tout comme pour les autres services, il est important d'avoir une bonne configuration par défaut.
Mais étant donné que <c>xinetd</c> fonctionne en tant que root et supporte des protocoles dont
vous pourriez ignorer le fonctionnement, nous vous recommandons de ne pas l'utiliser.
Mais, si vous désirez l'utiliser quand même, voici comment le sécuriser quelque peu :
</p>

<pre caption="Installation de xinetd">
# <i>emerge xinetd tcpd</i>
</pre>

<p>
Puis éditez le fichier de configuration :
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Cela créera un pserver (cvs) via xinetd avec les paramètres suivants :
# max 10 instances (10 connexions simultanées)
# limite le pserver en mode tcp uniquement
# utilise l'utilisateur cvs pour démarrer le service
# lie les interfaces à une seule IP
# autorise l'accès uniquement depuis 10.0.0.*
# limite l'accès des développeurs au serveur entre 8h et 17h
# utilise les wrappers tpcd (contrôlés par liste d'accès dans
# <path>/etc/hosts.allow</path> et <path>/etc/hosts.deny</path>)
# le max_load sur la machine est de 1.0
# L'option de désactivation est normalement inutilisée mais j'aime l'avoir
# si jamais elle doit être utilisée pour désactiver le service
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Pour plus d'informations, consultez <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>ssh</title>
<body>

<p>
La seule option de sécurité que vous devez activer sur OpenSSH concerne l'authentification
basée sur le cryptage à clé publique. Beaucoup trop de sites (comme <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> et
<uri>http://www.apache.org</uri>) ont souffert d'intrusions non autorisées sur leurs
systèmes à cause de mots de passe mal cryptés ou mauvais.
</p>

<pre caption="/etc/ssh/sshd_config">
# Autorise uniquement la version 2
Protocol 2

# Pas d'accès direct en tant que root
PermitRootLogin no

# Active l'authentification de la clé RSA
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# Désactive les fichiers .rhosts et l'authentification normale
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

# Personne d'autre que les membres des groupes wheel ou admin ne doit avoir accès
AllowGroups wheel admin

# Et 2 utilisateurs
AllowUsers kn bs

# Ajoute le niveau de log
SyslogFacility AUTH
LogLevel INFO

# Écoute sur l'interface locale
ListenAddress 127.0.0.1
</pre>

<p>
La seule chose que doivent maintenant faire vos utilisateurs est de créer une clé (sur la machine depuis laquelle ils veulent se connecter) avec la commande suivante: 
</p>

<pre caption="Créer une paire de clés RSA">
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>

<p>
Rentrez une phrase de passe.
</p>

<pre caption="Sortie générée par ssh-keygen">
Generating public/private rsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_rsa):<c>[Tapez Entrée]</c>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <c>[Entrez votre phrase de passe]</c>
Enter same passphrase again: <c>[Entrez votre phrase à nouveau]</c>
Your identification has been saved in /home/kn/.ssh/id_rsa.
Your public key has been saved in /home/kn/.ssh/id_rsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Cela va ajouter deux fichiers dans votre répertoire <path>~/.ssh/</path> nommés <path>id_rsa</path> et <path>id_rsa.pub</path>. Le premier fichier,<path>id_rsa</path>, est votre clé privée et devrait être
gardée précieusement pour vous-même et personne d'autre. L'autre fichier, <path>id_rsa.pub</path>, est
à distribuer à tous les serveurs auxquels vous avez accès. Ajoutez alors la clé dans le répertoire home de l'utilisateur dans <path>~/.ssh/authorized_keys</path> et l'utilisateur devrait
alors être capable de se logger.
</p>

<p>
Vos utilisateurs devraient conserver leur clé privée précieusement. Il est préconisé de
la placer sur un support qu'ils ont toujours sur eux ou alors sur leur station
de travail (inclure cette options dans le règlement sur les <uri link="#doc_chap2_sect5">
mots de passe</uri>).
</p>

<p>Vous pourrez trouver plus d'informations sur le site officiel
<uri link="http://www.openssh.org">OpenSSH</uri>.</p>

</body>
</section>

<section>
<title>X</title>
<body>

<p>
XFree est configuré par défaut pour agir comme un serveur X. Cela peut être dangeureux
étant donné que X utilise des connexions tcp qui ne sont pas cryptées et reste à l'écoute
de clients X. 
</p>

<impo>
Si vous n'avez pas besoin de ce service, désactivez-le !
</impo>

<p>
Attention, si vous
utilisez votre station comme serveur X, utilisez la commande
<path>/usr/X11R6/bin/xhost</path> avec précaution. Cette commande permet aux clients de
se connecter depuis d'autres machines et d'utiliser votre affichage. Cela peut être utile
si vous avez besoin de démarrer une application X depuis une autre machine et que la seule
façon de le faire est depuis le réseau. La syntaxe est
<c>/usr/X11R6/bin/xhost +hostname</c>.
</p>

<warn>N'utilisez jamais la fonctionnalité <c>xhost +</c> ! Elle permet à n'importe quel client de se
connecter et de prendre le contrôle de votre session X. Si un attaquant peut contrôler
votre X, il peut alors espionner vos entrées clavier et contrôler votre bureau.
Si vous devez l'utiliser, souvenez-vous toujours de bien spécifier un hôte.
</warn>

<p>
Une solution plus sécurisée est de désactiver cette fonctionnalité complètement en
démarrant votre X avec l'option <c>startx -- -nolisten tcp</c> ou bien en désactivant
complètement cette option dans le fichier de configuration :
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Pour vous assurer que <path>startx</path> ne soit pas écrasé lorsque vous émergez une nouvelle version de XFree, vous devez le protéger.
Ajoutez la ligne suivante au fichier <path>/etc/make.conf</path> :
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Si vous utilisez un login graphique, vous devez utiliser une approche différente.
</p>

<p>Pour <c>gdm</c> (Gnome Display Manager) :</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>Pour <c>xdm</c> (X Display Manager) et <c>kdm</c> (Kde Display Manager) :</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>

</body>
</section>

<commment>
<section>
<title>Lpd</title>
<body>
<p>
À FAIRE
</p>
</body>
</section>

<section>
<title>Pdq</title>
<body>

<p>http://pdq.sourceforge.net/</p>

<p>
À FAIRE
</p>

</body>
</section>
</commment>


<section>
<title>FTP</title>
<body>
<p>
Le FTP (File Transfer Protocol) est en général une mauvaise idée. Ce service n'utilise aucun cryptage
pour les données, écoute sur 2 ports (en théorie 20 et 21), supporte des utilisateurs
anonymes et est généralement très recherché par les attaquants (afin d'échanger des fichiers
illégaux). Si vous pouvez vous en passer, utilisez plutôt <c>sftpd</c> ou HTTP étant donné que
le protocole FTP comporte un certain nombre de problèmes de sécurité. Sinon, sécurisez
vos services du mieux possible et préparez-vous.
</p>

<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd est une branche venant du projet nommé trollftpd. Modifié pour des raisons
évidentes de sécurité et de fonctionnalité par Frank Dennis.
</p>

<p>
Utilisez des utilisateurs virtuels (jamais de comptes système) en activant l'option
<c>AUTH</c>. Donnez-lui la valeur <c>-lpuredb:/etc/pureftpd.pdb</c> et créez vos utilisateurs en utilisant
<c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
## Nombre de connexions simultanées au total et par IP ##
MAX_CONN="-c 30"
MAX_CONN_IP="-C 10"

## Interdire les uploads si la partition est plus remplie que la valeur suivante ##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## Autres options ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Et configurez votre paramètre <c>MISC_OTHER</c> pour ne pas autoriser les utilisateurs anonymes
(<c>-E</c>), le chroot pour tout le monde (<c>-A</c>), les utilisateurs ne peuvent pas lire ou écrire
des fichiers commençant par un . (point) (<c>-X</c>), temps maximum d'inactivité (<c>-I</c>), limite la récursion (<c>-L</c>) et un <c>umask</c> raisonnable. 
</p>

<warn>
N'utilisez en <e>aucun</e> cas l'option <c>-w</c> ou <c>-W</c> !
Si vous voulez héberger du warez, arrêtez de lire ce document !
</warn>

<p>
Pour en savoir plus, consultez <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>

<section>
<title>Proftpd</title>
<body>

<p>
Proftpd est connu pour avoir eu de nombreux problèmes de sécurité, mais la plupart semblent avoir disparu. Il est quand même important d'appliquer les changements suivants :
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Mon démon FTP"
# Ne donnez pas l'identité du serveur
ServerIdent on "Dégage"

# Permet de créer des utilisateurs virtuels plus facilement.
RequireValidShell off

# Utilise des fichiers de groupe et de mots de passe alternatifs (mais cryptés)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissions
Umask 077

# Temps maximum et limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# Tout le monde en Chroot
DefaultRoot ~

# Ne pas démarrer le service en tant que root
User  nobody
Group nogroup

# Logger tout transfert
TransferLog /var/log/transferlog

# Problèmes avec le globbing
DenyFilter \*.*/
</pre>

<p>
Vous pourrez trouver plus de documentation sur <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>

<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (qui signifie ftp très sécurisé) est un petit démon ftp qui tourne avec un fichier
de configuration par défaut plutôt correct. Il est très simple et ne possède pas
beaucoup de fonctionnalités (comme celle des utilisateurs virtuels) contrairement à
pureftp et proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#lecture seule
write_enable=NO

# Active le logging des transferts
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Comme vous pouvez le constater, ce service ne contient pas de permissions individuelles et
pas d'action chroot de base. Mais en ce qui concerne la configuration pour les utilisateurs anonymes, il est plutôt bon. Il peut parfois être utile d'avoir un serveur FTP anonyme (afin de partager des sources par exemple) et ce serveur est vraiment parfait
pour cela.
</p>

</body>
</section>

</body>
</section>

<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) est livré avec un fichier de configuration relativement bon, mais encore
une fois, nous devons optimiser quelques petites choses comme le faire écouter sur une adresse ou
l'empêcher de donner trop d'informations. Voici les options que vous devriez envisager de placer
dans le fichier de configuration :
</p>

<p>
Si vous n'avez pas supprimé <c>ssl</c> de votre <path>/etc/make.conf</path> avant d'installer apache, vous
devriez être en possession d'un serveur avec SSL activé. Ajoutez simplement ce qui suit
pour l'activer :
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
# Faites-le écouter sur votre IP
Listen 127.0.0.1
BindAddress 127.0.0.1
# Ce n'est pas une bonne idée d'utiliser nobody ou nogroup -
# préférez l'utilisateur apache avec le même groupe (ajoutez-les)
User apache
Group apache
# Empêchera Apache de dévoiler sa version
ServerSignature Off
ServerTokens min
</pre>

<p>
Apache est compilé avec les options <c>--enable-shared=max</c> et <c>--enable-module=all</c>.
Cela autorise tous les modules par défaut, vous devez donc commenter les modules dont
vous n'avez pas besoin dans la section <c>LoadModule</c> (<c>LoadModule</c> et <c>AddModule</c>). Redémarrez
ensuite le service en faisant : <c>/etc/init.d/apache restart</c>.
</p>

<p>
Pour plus d'informations consultez <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<comment>
<section>
<title>Postfix</title>
<body>
À FAIRE !
</body>
</section>
</comment>

<section>
<title>Qmail</title>
<body>
<p>
Qmail est considéré comme le serveur de mail le plus sécurisé. Il a été totalement
écrit en misant sur la sécurité (et la paranoïa). Il n'autorise pas le relais des mails
par défaut et n'a eu aucun trou de sécurité depuis 1996. Faites tout simplement
<c>emerge qmail</c> et configurez-le !
</p>
</body>
</section>

<section>
<title>Bind</title>
<body>

<impo>
Bind est connu pour sa sécurité défaillante et ne doit pas être pris à la
légère. Comme tout autre service, il ne devrait <e>jamais</e> être exécuté en tant que root,
ne changez donc pas la configuration par défaut pour ce service. 
</impo>

<p>
Consultez le reste de la documentation en ligne sur
 <uri link="http://www.isc.org/products/BIND/bind9.html">
Internet Software Consortium</uri>, le manuel de référence de l'administrateur de BIND 9 se trouve aussi dans <path>doc/arm</path>.
</p>

<!--
<p>
Gentoo ne configure
aucun fichier de configuration, vous aurez donc à ajouter vos propres zones dns dans le
fichier <path>/etc/bind/named.conf</path>. Etant donné que la sécurité ne concerne pas
seulement le serveur de domaine mais aussi le protocole, assurez-vous de le configurer
correctement.
</p>

<p>
Beaucoup de personnes demandent, pourquoi ne pas utiliser djbdns (un dns très sécurisé
écrit par D.J. Bernstein) et la réponse est simple : Bind offre des fonctionnalités
que djbdns ne supporte pas, comme le support pour IPv6 (pas sans patch dans tous les
cas).
</p>

<pre caption="/etc/bind/named.conf">
#setup access control
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
#allow "mynet" to make queries
  allow-query { "mynet"; };
#don't allow zone transfers
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
#Only provide recursive service to "mynet"
  recursion no;
  allow-recursion { mynet; };
# Bind to an interface
  listen-on { 10.0.0.1; };
# Don't show the version
  version "Go away";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

#allow only control from localhost and with a key
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>

<p>
Cet exemple est une configuration par défaut. Notez que Bind version 9 contient une
fonctionnalité spéciale chroot que vous devriez utiliser. Voici comment créer un bind
en chroot :
</p>

<pre>
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>

<p>
Cela devrait créer un environnement en chroot dans le répertoire <path>/chroot</path>.
Il ne nous reste plus qu'à modifier le script init pour supporter correctement le nouvel
environnement. Editez <path>/etc/init.d/named</path> et ajoutez <c>-t /chroot/dns</c>
à la fonction start (démarrage).
Changez également la fonction stop afin de pointer vers le fichier correct de processus
pid dans <path>/chroot/var/run/named/named.pid</path>. Redémarrez votre serveur DNS.
</p>
<note>
Un attaquant peut s'échapper d'une prison en chroot, s'il est suffisamment bon (voyez
comment éviter ce problème dans la section de patch du kernel).
</note>
-->

</body>
</section>

<section>
<title>Djbdns</title>
<body>

<p>
Il n'y a pas grand chose à dire sur djbdns à part que son auteur est prêt à parier
de <uri link="http://cr.yp.to/djbdns/guarantee.html">l'argent</uri> pour prouver
qu'il est sécurisé. N'hésitez donc plus et essayez-le sur <uri>http://www.djbdns.org/</uri>.
Il est très différent de Bind v.9 dans sa façon de travailler, mais vous devriez le maîtriser rapidement.
</p>

</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
Samba est un protocole qui permet de partager des fichiers avec des réseaux Microsoft/Novell
et <e>ne devrait pas</e> être utilisé sur Internet. Mais il faut néanmoins le sécuriser.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  # se lier à une interface
  interfaces = eth0 10.0.0.1/32

  # Asurez-vous d'utiliser des mots de passe cryptés
  encrypt passwords = yes
  directory security mask = 0700

  # autoriser le trafic de 10.0.0.*
  hosts allow = 10.0.0.

  # Permet l'authentification d'utilisateur
  #(n'utilisez pas le mode partagé)
  security = user

  # Interdit les comptes privilégiés
  invalid users = root @wheel

  # Ajoute une taille maximum d'utilisation en kilo-octets
  max disk size = 102400

  # Définit la politique de mots de passe
  min password length = 8
  null passwords = no

  # Utilise PAM (si supporté)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Assurez-vous que les permissions sont placées correctement sur chaque partage
et lisez la <uri link="http://www.samba.org">documentation</uri>.
</p>

<p>
Redémarrez à présent le serveur et ajoutez les utilisateurs qui devraient avoir accès
à ce service. Vous pouvez le faire grâce à <path>/usr/bin/smbpasswd</path> avec le paramètre -a.
</p>

</body>
</section>

<section>
<title>Chroot ou serveurs virtuels</title>
<body>
<p>
Chrooter un service est une façon de limiter l'environnement d'un service (ou d'un utilisateur)
afin qu'il n'accède qu'à l'essentiel sans qu'il puisse obtenir un accès (ou des informations) qui pourraient mener
aux privilèges root. En démarrant un service
par le biais d'un autre utilisateur que root (nobody, apache, named), un attaquant ne peut
accéder qu'aux fichiers avec les permissions de cet utilisateur. Cela veut dire qu'un
attaquant ne peut obtenir un accès root même si les services ont une faille de sécurité.
</p>

<p>
Certains services comme pure-ftpd et bind ont des fonctionnalités permettant d'utiliser
chroot, mais pas tous. Si le service le supporte, utilisez-le, sinon il vous
faudra trouver un moyen de créer le vôtre. Voyons à présent comment créer un environnement
chroot, pour apprendre nous allons le tester avec <c>bash</c> (plus facile).
</p>

<p>
Créez le répertoire <path>/chroot</path> (<c>mkdir /chroot</c>) et cherchez quelles sont les bibliothèques dynamiques avec lesquelles <c>bash</c> est compilé (si la compilation a été faite avec le mode <c>-static</c>, ce n'est pas nécessaire) :
</p>

<p>
La commande suivante va créer une liste des bibliothèques utilisées par bash.
</p>

<pre caption="Obtenir la liste des bibliothèques utilisées">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Créons à présent un environnement pour bash.
</p>

<pre caption="Création d'un environnement chroot pour bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Copiez ensuite les fichiers utilisés par bash (<path>/lib</path>) dans le répertoire
chroot /lib et copiez la commande bash dans le répertoire bin de l'environnement chroot.
Cela devrait suffire pour recréer l'environnement, mais avec moins de fonctionnalités.
Il ne vous reste qu'à l'essayer : <c>chroot /chroot/bash</c>. Si vous obtenez un prompt
vous donnant <path>/</path> c'est gagné ! Dans le cas contraire, il devrait vous dire quels
sont les fichiers manquants. Il se peut également que certaines bibliothèques partagées aient
besoin d'autres bibliothèques.
</p>

<p>
Vous remarquerez assez vite que dans le chroot, rien ne marche à part <c>echo</c>. C'est parce
que nous n'avons aucune autre commande dans notre environnement que bash et qu'<c>echo</c> est une fonction intégrée.
</p>

<p>
La méthode est la même pour créer un service en chroot. La seule différence est que
les services se basent parfois sur des périphériques (devices) et des fichiers de configuration
dans <path>/etc</path>. Copiez-les tout simplement (des devices peuvent être copiés avec <c>cp -a</c>) vers l'environnement chrooté,
éditez le script de démarrage (init) pour qu'il utilise le chroot avant de s'exécuter.
Il peut être difficile de trouver quels périphériques et fichiers de configuration sont
nécessaires. C'est ici que la commande <c>strace</c> devient utile. Démarrez le service
avec <c>/usr/bin/strace</c> et notez les fonctions suivantes : open, read, stat et
sans doute connect. Cela devrait vous donner une bonne idée des fichiers à copier. Dans
la plupart des cas, copiez juste le fichier passwd (retirez tous les utilisateurs qui
n'ont aucun rapport avec le service), <path>/dev/zero</path>, <path>/dev/log</path> et
<path>/dev/random</path>.
</p>

<p>
Une autre façon de créer un environnement plus sécurisé est d'utiliser un environnement de
serveur virtuel. Cela créera une copie de votre Linux existant et le démarrera en mode
virtuel. Cela signifie que si le serveur est compromis, ce sera seulement le serveur virtuel
et pas la véritable installation.
</p>

<p>
Voici quelques exemples de serveurs virtuels :
</p>

<ul>

<li>
<uri link="http://user-mode-linux.sourceforge.net">User-Mode Linux</uri> et un howto sur
<uri link="http://www.gentoo.org/doc/uml.html">Linux en mode utilisateur</uri>.
</li>

</ul>

</body>
</section>
</chapter>

-- fin sécurisation des services --

-- pare-feu --

<chapter>
<title>Pare-feu</title>

<section>
<title>Un pare-feu</title>
<body>

<p>
La plupart des gens pensent qu'un pare-feu est la réponse ultime aux problèmes de sécurité. Ils ont tort.
Dans la majorité des cas, avoir un pare-feu mal configuré présente plus de dangers de sécurité
que de ne pas en avoir du tout. Un pare-feu est un logiciel et doit donc être traité
comme tout autre service, tout simplement car il est susceptible d'avoir des bogues.
</p>

<p>
Réfléchissez donc bien avant d'en mettre un en place ! En avez-vous vraiment besoin ? Si vous le
pensez, écrivez un guide sur son utilité, son type et la personne qui doit s'en occuper.
Mais tout d'abord, lisez ce guide.
</p>

<p>
Les pare-feu sont utilisés dans deux situations :
</p>

<ul>
<li>Pour garder des utilisateurs (vers/attaquants) dehors.</li>
<li>Pour garder des utilisateurs (employés/enfants) dedans.</li>
</ul>

<p>
Il existe globalement 3 types de pare-feu :
</p>

<ul>
<li>Filtrage de paquets.</li>
<li>Relais de circuit.</li>
<li>Passerelle d'application.</li>
</ul>

<p>
Un pare-feu devrait être une machine dédiée sans aucun service (ou uniquement <c>sshd</c>) et
sécurisée de la façon qui est recommandée dans ce guide.
</p>

</body>
</section>

<section>
<title>Filtrage de paquets</title>
<body>

<p>
Tout le trafic réseau se fait sous forme de paquets. Une grande partie du trafic est découpée en petits paquets pour une gestion plus simple. Ils sont ensuite réassemblés une fois arrivés à leur destination. L'en-tête de chaque paquet contient des
informations sur comment et où il devrait être délivré. Ces informations sont très
exactement ce qu'un pare-feu filtrant les paquets utilise. Le filtrage se base sur :
</p>

<ul>

<li>Autorisation ou interdiction des paquets en se basant sur l'adresse IP source/destination.</li>
<li>Autorisation ou interdiction des paquets en se basant sur un port source/destination.</li>
<li>Autorisation ou interdiction des paquets selon le protocole.</li>
<li>Autorisation ou interdiction des paquets selon les options établies à l'intérieur d'un protocole.</li>

</ul>

<p>
Globalement, le filtrage se fait sur les données contenues dans l'en-tête d'un paquet
et pas sur le contenu du paquet.
</p>

<p>
Faiblesses :
</p>

<ul>
<li>L'adresse d'un paquet peut être contrefaite ou comme le veut le terme
dédié <e>spoofée</e> par son envoyeur.</li>
<li>Les données ou requêtes contenues dans le paquet peuvent contenir des données indésirables
que l'attaquant peut utiliser pour exploiter des bogues connus dans les services qui sont sur ou
derrière le pare-feu.</li>
<li>Généralement le seul point faible.</li>
</ul>

<p>
Avantages :
</p>

<ul>
<li>Simple et facile à implémenter.</li>
<li>Peut donner des avertissements sur une attaque possible avant qu'elle n'arrive (en
détectant le scan de ports).</li>
<li>Bonne méthode pour arrêter les attaques de type SYN.</li>
</ul>

<p>
Voici quelques exemples de filtreurs de paquets gratuits sous Linux :
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri>.</li>
<li><uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>.</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri>.</li>
</ul>

</body>
</section>

<section>
<title>Relais de circuit</title>
<body>

<p>
Aussi appelé passerelle de niveau circuit, ce type de pare-feu valide les connexions avant d'autoriser l'échange de données. Cela signifie
qu'il n'autorise pas les paquets en fonction de leur en-tête mais détermine si une connexion entre
les deux parties est valide en consultant un ensemble de règles configurables, avant d'autoriser l'ouverture d'une session de transfert de données. Le filtrage est basé sur :
</p>

<ul>
<li>Adresse de destination/source.</li>
<li>Port de destination/source.</li>
<li>Un certain laps de temps.</li>
<li>Protocole.</li>
<li>Utilisateur.</li>
<li>Mot de passe.</li>
</ul>

<p>
Tout le trafic est validé, surveillé et celui ne correspondant pas aux règles est bloqué.
</p>

<p>
Faiblesse :
</p>

<ul>
<li>
Opère sur la couche de transport et peut nécessiter des modifications substantielles concernant la programmation
de la méthode fournissant normalement les fonctions de transport.
</li>
</ul>

</body>
</section>

<section>
<title>Passerelle d'applications</title>
<body>

<p>
La passerelle d'applications est un proxy pour les applications,
échangeant des données pour ses clients avec un système distant. Elle est généralement
gardée à l'abri du public derrière une DMZ (zone démilitarisée, la portion de réseau privé visible à travers le pare-feu) ou
un pare-feu sans connexion vers l'extérieur. Le filtrage est basé sur :
</p>

<ul>
<li>L'autorisation ou l'interdiction en se basant sur les adresses IP source/destination.</li>
<li>En se basant sur le contenu des paquets.</li>
<li>Limitation de l'accès aux fichiers en fonction du type ou de l'extension.</li>
</ul>

<p>
Avantages :
</p>

<ul>
<li>Peut mettre des fichiers en cache, améliorant ainsi les performances réseau.</li>
<li>Log complet et détaillé de toutes les connexions.</li>
<li>S'adapte parfaitement (certains serveurs de proximité peuvent "partager" les données
en cache).</li>
<li>Aucun accès direct depuis l'extérieur.</li>
<li>Peut même modifier le contenu des paquets en temps réel.</li>
</ul>

<p>
Faiblesses :
</p>

<ul>
<li>Sa configuration est compliquée.</li>
</ul>

<p>
Les passerelles d'applications sont considérées comme les solutions les plus sécurisées
étant donné qu'elles ne doivent pas fonctionner sous root et ne sont pas accessibles depuis Internet.
</p>

<p>
Un exemple de passerelle d'applications est
<uri link="http://www.squid-cache.org/">Squid</uri>.
</p>

</body>
</section>

<section>
<title>Iptables</title>
<body>

<p>
Vous devez activer iptables dans le noyau pour qu'il fonctionne correctement.
Je l'ai ajouté en tant que modules (la commande <c>iptables</c> les chargera
lorsqu'elle en a besoin), puis j'ai recompilé mon noyau. 
Pour plus d'informations sur la configuration du noyau pour iptables allez voir le <uri link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables Tutorial Chapter 2: Preparations</uri>.
Après avoir compilé votre nouveau noyau (ou pendant sa compilation), vous devez installer la commande <c>iptables</c>. Il suffit simplement de faire <c>emerge iptables</c> et cela devrait fonctionner.
</p>

<p>
Testez à présent que tout fonctionne avec <c>iptables -L</c>. Si cela ne fonctionne pas,
vérifiez votre configuration encore une fois.
</p>

<p>
Iptables est le nouveau et largement amélioré filtreur de paquets du noyau Linux 2.4.x.
Il est le successeur du précédent filtreur de paquets du noyau Linux 2.2.x, ipchains.
Une des principales améliorations est le filtrage de paquets par états.
Avec ceci, il est possible de garder une trace de chaque connexion TCP établie.
</p>

<p>
Une connexion TCP est composée d'une série de paquets contenant des
informations sur les adresses IP destination/source et une séquence permettant de
réassembler les paquets par la suite sans perte de données.
TCP est un protocole qui établit une connexion contrairement à UDP.
</p>

<p>
En examinant les en-têtes de paquets, un filtre de paquets par état peut déterminer si un paquet TCP reçu fait partie d'une connexion établie ou non, et ainsi accepter ou rejeter le paquet.
</p>

<p>
Avec un filtre de paquets sans état, il est possible de leurrer le filtre en lui faisant accepter des paquets qui devraient être rejetés en manipulant les en-têtes des paquets TCP.
Cela peut être réalisé en manipulant le drapeau SYN ou d'autres drapeaux de l'en-tête TCP.
Avec un filtrage à états il est possible de rejeter de tels paquets, étant donné qu'ils ne font pas partie d'une connexion déja établie.
Cela empêchera aussi les "scans invisibles" puisque de tels paquets ne feront pas partie d'une connexion déja établie.
</p>

<p>
Iptables propose beaucoup d'autres fonctionnalités comme le NAT (Network Address Translation - Traduction d'adresses réseau) et la limitation de flux.
La limitation de flux est très utile quand on essaie de prévenir quelques attaques de déni de service (DoS) comme les SYN floods.
</p>

<p>
Une connexion TCP est établie en trois temps (Ndt: three-way handshake en anglais).
Quand on établit une connexion TCP, le client envoie un paquet au serveur avec le drapeau SYN levé.
Quand le serveur reçoit le paquet SYN, il répond en envoyant un paquet SYN+ACK au client.
Quand le paquet SYN+ACK est reçu par le client, il répond avec un troisième paquet ACK qui a pour effet d'établir la connexion.
</p>

<p>
Un attaque SYN flood est effectuée en envoyant le paquet SYN mais en ne répondant pas au paquet SYN+ACK.
Le client peut créer un paquet avec une adresse IP source falsifiée car il n'a pas besoin de réponse.
Le serveur ajoute une entrée dans la queue de connexions semi-ouvertes quand il reçoit le paquet SYN et attend ensuite le paquet ACK final avant de supprimer cette entrée de la queue.
La queue a un nombre de cases limité et, si toutes les cases sont pleines, le serveur ne peut plus ouvrir de connexions.
Si le paquet ACK n'est pas reçu avant un délai spécifié, l'entrée va être automatiquement supprimée de la queue.
Le délai varie mais est typiquement de 30-60 secondes, même plus.
Le client initie l'attaque en créant plein de paquets SYN avec des adresses IP sources différentes et les envoie vers l'IP cible avec le plus haut débit possible. Cela a pour effet de remplir la queue des connexions semi-ouvertes et empêche les autres clients d'établir des connexions légitimes avec le serveur.
</p>

<p>
C'est là que la limitation de flux devient utile.
Il est possible de limiter le flux de paquets SYN acceptés en utilisant <c>-m limit --limit 1/s</c>.
Cela limitera le nombre de paquets SYN acceptés à un par seconde et réduira donc l'efficacité du SYN flood.
</p>

<p>
Maintenant un peu de pratique !
</p>

<p>
Lorsque iptables est chargé dans le noyau, il contient 5 sections dans lesquelles vous
pouvez placer vos règles : <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>, <c>PREROUTING</c> et <c>POSTROUTING</c>. Ces sections
sont appelées chaînes car elles consistent en une liste de règles.
Chaque régle indique ce qu'il faut faire en fonction de l'en-tête du paquet.
Si une régle ne se vérifie pas sur le paquet, la prochaine régle est consultée.
</p>

<p>
Vous pouvez ajouter des règles directement dans une des 5 listes ou créer des chaînes
de règles et les ajouter aux chaînes existantes. 
Iptables supporte les options suivantes:
</p>

<table border="0">
  <tr>
    <th>Option:</th><th>Description:</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>Append (ajoute)</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>Delete (efface)</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>Insert (insère)</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>Replace (remplace)</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>List (liste)</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>Efface toutes les règles dans la ou les chaînes</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>Remet les compteurs à zéro dans une ou plusieurs chaînes</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>Teste ce paquet sur une chaîne</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>Crée une chaîne définie par l'utilisateur</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>Efface une chaîne définie par l'utilisateur</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>Change le comportement d'une chaîne sur une cible</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>Change le nom d'une chaîne</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>Protocole</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>Adresse/masque de source</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>Adresse/masque de destination</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>Nom d'entrée (nom ethernet)</ti>
  <tr>
  </tr>
    <ti>-o</ti><ti>Nom de sortie (nom ethernet)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>Saute (cible de règle)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>Correspondance étendue (peut utiliser des extensions)</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>Sortie numérique de ports et d'adresses</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>Table à manipuler</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>Mode bavard</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>Vérifications étendues (affiche les valeurs exactes)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>Prends uniquement en compte le second fragment ou ceux d'après</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>Version du paquet</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>Affiche les numéros de ligne</ti>
  </tr>
</table>

<p>
Nous allons d'abord essayer de bloquer tous les paquets ICMP sur notre machine, juste
dans le but de se familiariser avec les commandes.
</p>

<pre caption="Blocage de tous les paquets ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
On spécifie tout d'abord la chaîne à laquelle cela devrait appartenir, ensuite le protocole et enfin l'action. L'action peut être le nom d'une chaîne spécifiée par l'utilisateur ou une des actions spéciales <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c>, <c>MASQUERADE</c>. 
Dans cet exemple, nous
utilisons <c>DROP</c> qui va ignorer le paquet sans répondre au client.
</p>

<p>
Essayez à présent de faire <c>ping localhost</c>. Il ne pourra pas le faire car iptables ignore tous les messages ICMP. Vous ne pourrez pas non plus faire de ping vers d'autres machines car les paquets de retour ICMP seront ignorés. Maintenant, pour vider la chaîne et pouvoir à nouveau faire des ping :
</p>

<pre caption="Supprimer toutes les règles">
# <i>iptables -F</i>
</pre>

<p>
Regardons maintenant le filtrage par état dans iptables. Si nous désirons inspecter les paquets entrants sur eth0 avec les états, voici comment le faire :
</p>

<pre caption="Accepter les paquets qui proviennent d'une connexion déjà établie">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Cela acceptera tous les paquets provenant d'une connexion établie ou ayant un rapport avec la
chaîne INPUT. Vous pouvez ignorer tous les paquets qui ne sont pas dans la table des états
en faisant <c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> juste avant.
Cela active la partie concernant les états dans iptables en chargeant l'extension des
états. Si vous voulez qu'une machine de l'extérieur puisse se connecter à votre machine,
vous pouvez utiliser <c>--state NEW</c>. Iptables contient des modules pour différentes utilisations. En voici certains :
</p>

<table border="0">
  <tr>
    <th>Module</th><th>Description</th><th>Options étendues</th>
  </tr>
  <tr>
    <ti>mac</ti><ti>Vérifie que l'extension correspond pour les paquets entrants sur
	une adresse mac.</ti><ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti><ti>Active l'inspection des états </ti><ti>--state (les états sont  ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti><ti>Définit une limite sur le flux</ti><ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti><ti>Essaie de trouver des correspondances dans le créateur du paquet </ti><ti>--uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner sessionid</ti>
  </tr>
  <tr>
    <ti>unclean</ti><ti>Plusieurs tests de vérification aléatoires du bon état des paquets </ti><ti/>
  </tr>
</table>

<p>
Essayons à présent de créer une chaîne définie par l'utilisateur et de l'appliquer sur
une chaîne existante :
</p>

<pre caption="Création d'une chaîne définie par l'utilisateur">
<codenote>Crée une nouvelle chaîne avec une seule règle</codenote>
# <i>iptables -X machaine</i>
# <i>iptables -N machaine</i>
# <i>iptables -A machaine -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>La politique par défaut est d'accepter tout le trafic sortant. Tout le
trafic entrant est ignoré.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>Et on ajoute cela à la chaîne INPUT</codenote>
# <i>iptables -A INPUT -j machaine</i>
</pre>

<p>
En ajoutant cette règle on obtient que tout paquet sortant est autorisé et le
trafic entrant est ignoré.
</p>

<p>
Pour plus d'informations, consultez <uri link="http://www.iptables.org/documentation/index.html#HOWTO">la documentation sur iptables</uri>.
</p>

<p>
Voyons à présent un exemple complet. Dans ce cas précis, il s'agit de mes règles de
pare-feu/passerelle :
</p>

<ul>
  <li>Connexions au pare-feu uniquement autorisées via SSH (port 22).</li>
  <li>Le réseau local doit avoir accès à HTTP, HTTPS et SSH (DNS est également autorisé).</li>
  <li>Le trafic ICMP peut être nocif et devrait être interdit. Évidemment, nous devons autoriser un peu de trafic ICMP.</li>
  <li>Les scans de ports doivent être détectés et loggés.</li>
  <li>Les attaques SYN doivent être évitées.</li>
  <li>Tout autre trafic doit être ignoré et loggé.</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#interne
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#externe
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Paramétrer les règles internes"

  einfo "On ignore tout par défaut"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # règles par default
  einfo "Créer les chaînes d'état"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  # Trafic ICMP
  einfo "Créer la chaîne icmp"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # Trafic entrant
  einfo "Créer la chaîne de trafic ssh entrant"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  # Protection anti Flood
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -p tcp --dport ssh -j ACCEPT

  # Trafic sortant
  einfo "Créer la chaîne de trafic SSH sortant"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Créer la chaîne de trafic DNS sortant"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \
     -j ACCEPT

  einfo "Créer la chaîne de trafic http/https sortant"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # Détecter les scans ports
  einfo "Créer la chaîne de détection de portscan"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Applique et ajoute les chaînes invalides
  einfo "Appliquer les chaînes a INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Appliquer les chaînes au FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Appliquer les chaînes à l'OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # Autoriser les clients à router via le NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE
  eend $?
}

start() {
  ebegin "Démarrage du pare-feu"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} n'existe pas. Utilisation des règles par defaut."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Arrêt du pare-feu"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Statut"
  $IPTABLES -L -n -v --line-numbers
  einfo "Statut NAT"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Mise en place des règles de panique"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Enregistrer les règles de pare-feu"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Rétablir les règles précédentes"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      réapplique les règles si on démarre, sinon on les force"
  echo "stop)       efface toutes les règles et autorise tout accès"
  echo "rules)      force la mise en place des nouvelles règles"
  echo "save)       sauve les paramètres dans ${FIREWALL}"
  echo "restore)    récupère les paramètres depuis ${FIREWALL}"
  echo "showstatus) affiche les statuts"
}
</pre>

<p>
Quelques conseils utiles lorsque vous créez un pare-feu :
</p>

<ol>
  <li>Créez les règles de votre pare-feu avant de l'écrire.</li>
  <li>Faites quelque chose de simple.</li>
  <li>Connaissez le fonctionnement des protocoles (lisez les <uri link="http://www.ietf.org/">RFC, Request For Comments</uri>).</li>
  <li>Gardez bien en tête que votre pare-feu n'est qu'un logiciel qui fonctionne sous root.</li>
  <li>Testez votre pare-feu.</li>
</ol>

<p>
Si vous pensez que iptables est difficile à comprendre ou vous prendra trop de temps à
configurer, vous pouvez utiliser <uri link="http://www.shorewall.net">Shorewall</uri>.
Il utilise iptables pour générer des règles de pare-feu, mais se concentre sur les règles
et pas les protocoles spécifiques.
</p>

</body>
</section>

<section>
<title>Squid</title>
<body>

<p>
Squid est un serveur proxy très puissant, il peut filtrer le trafic en fonction de l'heure, d'une expression rationnelle sur le chemin/uri, d'une adresse IP
source/destination, du domaine, du navigateur, de l'utilisateur, d'un type MIME ou bien d'un
numéro de port (protocole). J'en ai sans doute oubliés d'autres, mais il serait difficile
de les énoncer dans leur ensemble ici.
</p>

<p>
Dans l'exemple suivant, j'ai ajouté un filtre de bannières plutôt qu'un filtre basé sur
du contenu pornographique. La raison pour cela est que Gentoo.org ne devrait <c>pas</c> être listé comme
site à caractère pornographique. Et je ne veux pas perdre mon temps à essayer de vous
trouver des bonnes adresses de sites.
</p>

<p>
Dans cet exemple précis, mes règles sont les suivantes :
</p>

<ul>
  <li>Le surf (HTTP/HTTPS) est autorisé pendant les heures de bureau (du lundi au vendredi 8h-17h et le
  samedi 8h-13h), s'ils restent plus tard, c'est pour travailler et pas pour surfer.</li>
  <li>Le téléchargement est interdit (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg, etc.).</li>
  <li>N'aimant pas les bannières publicitaires, elles sont filtrées et remplacées par un gif
  transparent (c'est ici que vous devenez créatif).</li>
  <li>Toute autre connexion venant d'Internet ou vers Internet est interdite.</li>
</ul>

<p>
Cela se fait en 4 étapes <e>simples</e>:
</p>

<pre caption="/etc/squid/squid.conf">
# Liaison à une adresse IP et un port
http_port 10.0.2.1:3128

# Configuration standard
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Contrôle d'accès standard
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Machines autorisées à accéder à ce serveur
acl localnet src 10.0.0.0/255.255.0.0

# Et les ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Liste d'accès basée sur les expressions rationnelles
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Liste d'accès basée sur les horaires
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Autorise le manager à se connecter depuis la machine locale
http_access allow manager localhost
http_access deny manager

# Nettoyage de cache autorisé uniquement en local
http_access allow purge localhost
http_access deny purge

# Refuse les requêtes vers des ports inconnus
http_access deny !Safe_ports

# Refuse les connexions en dehors du port SSL
http_access deny CONNECT !SSL_ports

# Mes règles

# Affiche une page quand un bandeau est supprime
deny_info NOTE_ADS_FILTERED url_ads

# Puis les refuse
http_access deny url_ads

# Refuse toutes les archives
http_access deny archives

# Restreint l'accès aux heures de bureau
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Refuse le reste
http_access deny all
</pre>

<p>
Indiquez ensuite les fichiers dont vous ne voulez pas autoriser le téléchargement. J'ai
ajouté : zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz et z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
Notez le [] avec la majuscule et minuscule de chaque lettre. Cela permet de ne pas pouvoir tromper squid en téléchargeant un fichier AvI au lieu de avi.
</note>

<p>
On ajoute ensuite les expressions rationnelles pour identifier les bannières. Vous serez
sans doute plus créatif que moi :
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Et enfin, on veut afficher un fichier lorsque l'on retire une bannière. Il s'agit ici d'un
demi fichier html contenant une image gif transparente de taille 4x4.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>Erreur, l'URL que vous avez demandée est indisponible&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Publicité filtrée !&lt;/H1&gt;
</pre>

<note>
Ne fermez pas les balises &lt;HTML&gt; &lt;BODY&gt;. Squid s'en chargera pour vous.
</note>

<p>
Comme vous pouvez le constater squid a beaucoup de possibilités et est très efficace dans
le filtrage de contenu ainsi qu'en tant que proxy. Vous pouvez même
utiliser plusieurs serveurs squid dans des configurations réseau de grande taille. Le type
de configuration que j'ai listé ici devrait convenir à un réseau de petite taille (entre 1 et 20 utilisateurs).
</p>

<p>
Cependant, combiner le filtrage de paquets (iptables) et un serveur d'applications
(squid) est probablement la meilleure solution, même si squid est situé dans un endroit
sécurisé non accessible de l'extérieur. Gardez en tête que les attaques peuvent aussi
venir de l'intérieur.
</p>

<p>
Vous devez maintenant configurer les navigateurs de vos clients pour qu'ils utilisent le serveur proxy.
La passerelle empêchera les utilisateurs d'avoir un contact avec l'extérieur, à moins qu'ils n'utilisent le proxy.
</p>
<note>
Dans Mozilla, vous pouvez le modifier dans Edit->Preferences->Advanced->Proxies.
</note>

<p>
Vous pouvez aussi le faire de façon transparente en utilisant iptables pour renvoyer
tout le trafic vers le proxy squid. Il suffit pour cela d'ajouter des règles
de pré-routage/forward sur la passerelle :
</p>

<pre caption="Autoriser le forwarding de port vers notre serveur proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>

<section>
<title>Qu'avons-nous appris ?</title>

<body>

<p>
Nous avons appris que :
</p>

<ol>
  <li>Un pare-feu peut représenter un risque s'il est mal configuré et qu'il vaut mieux
  dans ce cas n'en avoir aucun.</li>
  <li>Comment paramétrer un serveur proxy transparent et une passerelle de base.</li>
  <li>La clé d'un bon pare-feu est de connaître le protocole que
  vous voulez autoriser.</li>
  <li>Que le trafic IP ne contient pas que des données légitimes, des
  paquets ICMP peuvent contenir des informations importantes sur le réseau.</li>
  <li>Comment éviter des attaques SYN.</li>
  <li>Filtrer le trafic HTTP en retirant le chargement d'images ou de virus.</li>
  <li>Le fait de combiner un pare-feu et un serveur proxy donne un meilleur contrôle.</li>
</ol>

<p>
Si vous en avez <b>vraiment</b> besoin, vous pouvez à présent créer un pare-feu qui
répond à vos besoins.
</p>

</body>
</section>

</chapter>

-- debut de la detection d'intrus --

<chapter>
<title>Détection d'intrusion</title>

<section>
<title>AIDE (Advanced Intrusion Detection Environment)</title>
<body>

<p>
AIDE est un système de détection d'intrusion installé sur la machine à protéger (une alternative gratuite
à Tripwire). Si vous connaissez déjà Tripwire, vous n'aurez aucune difficulté à configurer AIDE.
</p>

<p>
Le fichier de configuration est basé sur des expressions rationnelles, des macros et des
règles concernant les fichiers et répertoires. Nous avons les macros suivantes :
</p>

<table borlder="0">
  <tr>
    <th>Macro</th><th>Description</th><th>Syntaxe</th>
  </tr>
  <tr>
    <ti>ifdef</ti><ti>Si défini</ti><ti>@@ifdef "nom"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti><ti>Si non défini</ti><ti>@@ifndef "nom"</ti>
  </tr>
  <tr>
    <ti>define</ti><ti>Définit une variable </ti><ti>@@define "nom" "valeur"</ti>
  </tr>
  <tr>
    <ti>undef</ti><ti>Enlève la définition d'une variable</ti><ti>@@undef "nom"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti><ti>si "nom d'hôte"</ti><ti>@@ifhost "nom hôte"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti><ti>si non "nom d'hôte"</ti><ti>@@ifnhost "nom hôte"</ti>
  </tr>
  <tr>
    <ti>endif</ti><ti>Endif doit être utilisé après chacune des macros ci-dessus à part define et undef</ti><ti>@@endif</ti>
  </tr>
</table>

<p>
Ces macros deviennent très pratiques si vous avez plus d'une machine Gentoo et désirez
utiliser AIDE sur chacune d'entre elles. Bien que toutes les machines n'aient pas les
mêmes utilisateurs ou services.
</p>

<p>
Nous devons ensuite vérifier les indicateurs sur les fichiers ou les répertoires.
Ils sont formés d'une combinaison de permissions, de propriétés de fichiers et de checksums.
</p>

<table border="0">
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>p</ti><ti>permissions</ti>
  </tr>
  <tr>
    <ti>i</ti><ti>inode</ti>
  </tr>
  <tr>
    <ti>n</ti><ti>nombre de liens</ti>
  </tr>
  <tr>
    <ti>u</ti><ti>utilisateur</ti>
  </tr>
  <tr>
    <ti>g</ti><ti>groupe</ti>
  </tr>
  <tr>
    <ti>s</ti><ti>taille</ti>
  </tr>
  <tr>
    <ti>b</ti><ti>nombre de blocs</ti>
  </tr>
  <tr>
    <ti>m</ti><ti>mtime</ti>
  </tr>
  <tr>
    <ti>a</ti><ti>atime</ti>
  </tr>
  <tr>
    <ti>c</ti><ti>ctime</ti>
  </tr>
  <tr>
    <ti>S</ti><ti>vérifie si la taille augmente</ti>
  </tr>
  <tr>
    <ti>md5</ti><ti>md5 checksum</ti>
  </tr>
  <tr>
    <ti>sha1</ti><ti>sha1 checksum</ti>
  </tr>
  <tr>
    <ti>rmd160</ti><ti>rmd160 checksum</ti>
  </tr>
  <tr>
    <ti>tiger</ti><ti>tiger checksum</ti>
  </tr>
  <tr>
    <ti>R</ti><ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
    <ti>L</ti><ti>p+i+n+u+g</ti>
  </tr>
  <tr>
    <ti>E</ti><ti>groupe vide</ti>
  </tr>
  <tr>
    <ti>&gt;</ti><ti>Taille du fichier de log en augmentation p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
Et si Aide est compilé avec le support mhash, vous disposerez également de :
</p>

<table border="0">
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>haval</ti><ti>haval checksum</ti>
  </tr>
  <tr>
    <ti>gost</ti><ti>gost checksum</ti>
  </tr>
  <tr>
    <ti>crc32</ti><ti>crc32 checksum</ti>
  </tr>
</table>

<p>
Vous pouvez à présent créer vos propres règles en combinant les indicateurs comme ceci :
</p>

<pre caption="Créer un ensemble de règles pour AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
La dernière chose que nous devons voir pour créer notre propre fichier de configuration est l'ajout de règles aux fichiers ou répertoires. Il vous suffit
de taper le nom d'un fichier ou répertoire suivi d'une règle. AIDE ajoutera les
fichiers récursivement à moins que vous ne précisiez autre chose.
</p>

<table border="0">
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>!</ti><ti>Ne pas ajouter ce fichier ou répertoire.</ti>
  </tr>
  <tr>
    <ti>=</ti><ti>Ajouter ce répertoire mais sans récursion.</ti>
  </tr>
</table>

<p>
Regardons à présent l'exemple complet :
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# L'endroit où lire la base de données.
database=file:@@{AIDEDIR}/aide.db

# L'endroit où inscrire la base de données.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Définition des règles
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
Dans l'exemple ci-dessus, nous spécifions en quelques macros l'emplacement des répertoires principaux ainsi que du répertoire AIDE. AIDE
consulte alors <path>/etc/aide/aide.db</path> pour savoir si le fichier a été modifié.
Mais lorsqu'il met à jour ou crée un nouveau fichier, il l'inscrit dans  <path>/etc/aide/aide.db.new</path>. Cela permet d'éviter qu'il n'écrase automatiquement le
fichier de base de données précédent. L'option <c>report_URL</c> n'est pas encore implémentée, mais les
auteurs comptent bien l'utiliser pour envoyer un email ou bien exécuter un script.
</p>

<p>
Après avoir fini la configuration, vous pouvez créer le fichier de base de 
données en exécutant <c>aide -i</c>, puis copiez le fichier 
<path>/etc/aide/aide.db.new</path> vers <path>/etc/aide/aide.db</path> et 
ajoutez la vérification dans le cron en faisant <c>crontab -e</c> en root.
</p>

<note>
En fonction des indicateurs que vous avez mis, de la puissance de votre processeur et de la rapidité d'accès à votre disque
dur, cela peut prendre un certain temps à s'exécuter.
</note>

<pre caption="Programmer AIDE en tâche cron">
0 3   * * * /usr/bin/aide -u
</pre>
<note>Rappelez-vous bien de paramétrer l'accès au mail pour root. Sinon il y a des
chances que vous ne receviez jamais ce qu'aide vous envoie.</note>

<p>
Dans cet exemple, il démarre tout seul à 3h. Cela évite de déranger les
utilisateurs lorsqu'ils travaillent. Notez également que j'utilise l'option <c>-u</c>
(mise à jour) au lieu de <c>-C</c> (vérification). Étant donné que <c>-u</c> vérifie aussi le fichier et
n'écrase pas la base de données originale, cela devrait accélerer la procédure car
vous n'avez plus qu'à copier le fichier lorsqu'un changement est détecté. Avant de copier, vérifiez les
changements pour vous assurer que c'est bien vous qui les avez faits et pas un
attaquant !
</p>

<p>
Il peut y avoir quelques problèmes concernant la base de données car si un attaquant sait
qu'aide est installé, il essaiera de corrompre la base ou de modifier <path>/usr/bin/aide</path>. Vous devriez donc créer un CD ou n'importe quel autre média
et y copier le fichier .db ainsi que les binaires d'aide.
</p>

<p>
Pour plus d'informations, consultez la page du projet <uri link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>

<section>
<title>Snort</title>
<body>

<p>
Snort est un système de détection d'intrusion sur le réseau. Pour l'installer et le configurer, utilisez les exemples suivants.
</p>

<pre caption="Ajouter un utilisateur snort au système">
# user add snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CO NF=/etc/snort/snort.Cong
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>Étape 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Étape 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 -unicode -cginull
preprocessor unidecode: 80 8080 -unicode -cginull
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode
preprocessor portscan: $HOME_NET 4 3 portscan.log
preprocessor portscan-ignorehosts: $DNS_SERVERS

<codenote>Étape 3</codenote>
include classification.config

<codenote>Étape 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NOUVELLES CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Pour plus d'informations, consultez le site de <uri link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>

</chapter>

-- fin detection d'intrus --

<chapter>
<title>Modifications depuis la dernière version</title>
<section>
<title>Modifications</title>
<body>

<p>
Version 0.1 -> 0.2
</p>
<ul>
  <li>Correction de nombreuses fautes de frappe (beaucoup découvertes par Bjarke Sørensen).</li>
  <li>Modifications pour intégrer apache.conf (ServerTokens min).</li>
  <li>Correction du problème des balises &lt;pre&gt; plus longues que 80 caractères.</li>
  <li>Ajout d'un chapitre sur les pare-feu.</li>
</ul>

<p>
Version 0.2 -> 0.4
</p>
<ul>
  <li>Ajout d'un chapitre sur la détection d'intrus.</li>
  <li>Correction d'un bogue concernant le script du pare-feu.</li>
</ul>

</body>
</section>
</chapter>

</guide>

