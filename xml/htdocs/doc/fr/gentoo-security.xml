<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/gentoo-security.xml,v 1.26 2004/10/06 12:16:54 neysx Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link = "/doc/fr/gentoo-security.xml" lang="fr">
<title>Guide de sécurité Gentoo Linux</title>

<author title="Auteur">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>

<author title="Correcteur"><!-- zhen@gentoo.org -->John P. Davis
</author>

<author title="Correcteur">
 <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>

<author title="Correcteur">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>

<author title="Correcteur"> <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>

<author title="Correcteur">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>

<author title="Correcteur">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>

<author title="Correcteur">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>

<author title="Correcteur">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>

<author title="Correcteur">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>

<author title="Correcteur">
   <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
</author>

<author title="Traducteur">
  <mail link="frlinux@frlinux.net">FRLinux</mail>
</author>

<author title="Traducteur">
  <mail link="mat@frheaven.com">Matthieu Montaudouin</mail>
</author>

<author title="Traducteur">
  <mail link="ribosome@gentoo.org">Olivier Fisette</mail>
</author>

<abstract>
Ce manuel vous guide pas à pas pour vous aider à sécuriser
Gentoo Linux.
</abstract>

<license/>

<version>0.4.33</version>
<date>2 octobre 2004</date>

<chapter>
<title>Introduction</title>
<section>
<body>

<p>
Ce guide est destiné aux personnes utilisant Gentoo Linux dans un environnement
serveur ou sentant le besoin d'une sécurité accrue.
</p>

<note>
Après avoir lu ce guide, si vous voulez en apprendre d'avantage sur la sécurité
et Gentoo, veuillez consulter le projet <uri
link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo</uri>.
</note>

</body>
</section>

<!--
<section>
<title>Ce que vous pouvez attendre de la prochaine version de ce document: </title>
<body>

<p>
Dans la version 0.6 (Sauvegardes)
</p>
<ul>
<li>Sauvegarde intégrale de votre système à l'aide de Systemimager</li>
<li>Sauvegardes partielles à l'aide de tar</li>
<li>Sauvegardes à l'aide de postgres</li>
</ul>


<p>
Dans la version 0.8 (Tests de pénétration)
</p>
<ul>
<li>Audits à distance</li>
<li>Audits réseau</li>
<li>Audits de votre hôte</li>
<li>Audits logiciels</li>
</ul>

<p>
Dans la version 1.0 (Après accord)
</p>
<ul>
<li>Comment reporter un incident</li>
<li>Analyse de Forensics</li>
<li>Créer une image de votre système sans effacer les preuves (à l'aide de dd)</li>
<li>Trap et trace (en utilisant tcpdump)</li>
<li>.. Plus à venir ..</li>
<li>Restaurer un système</li>
</ul>

<note>
Comme vous pouvez le constater, chaque version aborde un sujet unique à chaque fois. Ceci
dans le but de maintenir la meilleure qualité possible.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Considérations avant l'installation</title>
<section>
<title>Sécurité physique</title>
<body>

<p>
Quel que soit le nombre de protections que vous mettez en place, elles seront
toutes aisément contournées par un attaquant disposant d'un accès physique à
votre système. Malgré cela, certaines mesures peuvent être prises afin
d'améliorer la sécurité face à un attaquant pouvant accéder physiquement à
votre système. Gardez votre matériel dans un local verrouillé afin d'éviter
qu'un attaquant puisse simplement le débrancher et l'emporter. Fermer à clé les
boîtiers des ordinateur est également une bonne idée, et permet d'éviter que
quelqu'un ne parte avec votre disque dur. Pour éviter qu'un attaquant n'amorce
le système à partir d'un autre disque, ce qui lui permettrait de contourner
facilement les restrictions relatives aux permissions et à l'ouverture de
sessions, faites de votre disque dur le premier périphérique de démarrage dans
votre BIOS, et protégez le BIOS par un mot de passe. Il est également important
de définir un mot de passe de démarrage pour LILO ou GRUB, afin d'éviter qu'un
utilisateur malicieux ne démarre en mode «&nbsp;single-user&nbsp;» et n'obtienne
un accès complet à votre système. Ce sujet est couvert en détail dans le
chapitre 3, dans les rubriques <uri link="#passwording_GRUB">Protéger GRUB
par un mot de passe</uri> et <uri link="#passwording_LILO">Protéger LILO
par un mot de passe</uri>.
</p>

</body>
</section>

<section>
<title>Planification des services</title>
<body>

<p>
Établissez dès le départ une liste des services que le système devrait
exécuter. Cela vous aidera à établir un schéma de partition optimal pour votre
système, et permettra aussi une meilleure planification des mesures de sécurité
nécessaires. Bien sûr, cette n'étape n'est pas nécessaire si le système n'a
qu'un rôle simple, tel qu'un ordinateur de bureau ou un pare-feu dédié. Dans
un tel cas, vous ne devriez exécuter <e>aucun</e> service, hormis, peut-être,
sshd.
</p>

<p>
Cette liste peut aussi être utile pour l'administration du système. En
conservant une liste à jour des versions des programmes utilisés, il vous sera
plus facile de maintenir le tout à jour si une vulnérabilité est découverte dans un de vos
démons.
</p>

</body>
</section>

<section>
<title>Schémas de partitions</title>
<body>

<p>
Règles de partitionnement&nbsp;:
</p>

<ul>

<li>
  Tout répertoire dans lequel un utilisateur peut écrire (tel que
  <path>/home</path> et <path>/tmp</path>) devrait se trouver sur une partition
  séparée et utiliser les quotas de disques. Cela réduit le risque qu'un
  utilisateur ne remplisse entièrement votre système de fichiers. Portage
  utilise <path>/var/tmp</path> pour compiler des fichiers&nbsp;; cette
  partition doit donc être volumineuse.
</li>

<li>
  Tout répertoire dans lequel vous souhaitez installer des logiciels qui ne
  sont pas spécifiques à votre distribution doit se trouver sur une partition
  séparée. D'après le <uri link="http://www.pathname.com/fhs/">Standard de
  hiérarchie des fichiers</uri>, cela concerne <path>/opt</path> ou
  <path>/usr/local</path>. Si ces points de montage sont sur des partitions
  séparées, ces dernières ne seront pas effacées si vous devez réinstaller
  votre système.
</li>

<li>
  Pour davantage de sécurité, les données statiques devraient être conservées
  sur une partition séparée montée en lecture seulement. Si vous êtes vraiment
  paranoïaque, vous pouvez même envisager de stocker ce type de données sur un
  média non inscriptible comme un CD-ROM.
</li>

</ul>
</body>
</section>

<section>
<title>Le super-utilisateur root</title>
<body>

<p>
Le super-utilisateur root est l'utilisateur le plus important sur un système et
ne devrait être utilisé qu'en cas de nécessité absolue. Si un attaquant obtient
les droits root, vous ne pourrez plus jamais considérer votre système comme
sécurisé tant que vous n'aurez pas procédé à une réinstallation.
</p>

<p>
Règles d'or concernant root&nbsp;:
</p>

<ul>
<li>
  Créez toujours un utilisateur pour l'utilisation quotidienne. Ajoutez-le au
  groupe «&nbsp;wheel&nbsp;»&nbsp;; cela lui donnera la possibilité d'exécuter
  «&nbsp;su&nbsp;» pour obtenir l'accès root.
</li>
<li>
  N'utilisez jamais X ou toute autre application utilisateur en tant que
  root. root ne devrait être utilisé qu'en cas de nécessité absolue&nbsp;; si
  une vulnérabilité existe dans une application exécutée avec les droits d'un
  utilisateur ordinaire, un attaquant peut obtenir un accès utilisateur. Mais,
  si cette même application est exécutée avec les droits de l'utilisateur root,
  l'attaquant obtiendra l'accès root.
</li>
<li>
  Utilisez toujours des chemins absolus lorsque vous utilisez le compte root.
  (Alternativement, vous pourriez vous assurer de toujours utiliser <c>su
  -</c>, qui remplace les variables d'environnement de l'utilisateur par celles
  de root, et vous assurer que la variable <c>PATH</c> de root ne contient que
  des répertoires protégés tels que <path>/bin</path> et <path>/sbin</path>.) Il
  est possible de tromper root en démarrant une application différente de celle
  qu'il pense utiliser. Si le <c>PATH</c> de root est protégé ou si root
  n'utilise que des chemins absolus, vous êtes assuré que cela ne se produira
pas.
</li>
<li>
  Si un utilisateur n'a besoin que de quelques commandes au lieu de toutes
  celles disponibles pour root, vous devriez alors envisager l'utilisation de
  <c>sudo</c>. Faites toutefois attention à qui vous accordez ce
  privilège&nbsp;!
</li>
<li>
  Ne laissez jamais un terminal ouvert lorsque vous êtes connecté en tant que
  root.
</li>
</ul>

<p>
Gentoo dispose d'une protection générale contre les utilisateurs normaux qui
tentent d'utiliser <c>su</c> pour accéder au compte root. Le comportement par
défaut de PAM impose à l'utilisateur d'appartenir au groupe «&nbsp;wheel&nbsp;»
pour utiliser <c>su</c>.
</p>

</body>
</section>

<section id = "security_policies">
<title>Politique de sécurité</title>
<body>

<p>
Plusieurs raisons justifient l'écriture d'une politique de sécurité pour vos
système et votre réseau.
</p>

<ul>
<li>
  Une bonne politique de sécurité vous permet de définir la sécurité en tant
  que «&nbsp;système&nbsp;», plutôt que comme un ensemble de fonctionnalités
  pêle-mêle. Par exemple, sans politique de sécurité, un administrateur
  pourrait décider de désactiver telnet sous prétexte qu'il transmet des mots
  de passe non cryptés, mais pourrait aussi laisser actif l'accès FTP, alors
  que ce dernier souffre de la même faiblesse. Une bonne politique de sécurité
  vous permet d'identifier les mesures qui valent la peine d'être implémentées
  et celles qui n'en valent pas la peine.
</li>
<li>
  Afin de diagnostiquer des problèmes, réaliser des audits ou traquer des
  intrus, il peut être nécessaire d'intercepter le trafic réseau, d'inspecter
  les ouvertures de sessions et l'historique des commandes des utilisateurs,
  ainsi que de consulter le contenu des répertoires personnels. Si cela n'est
  pas clarifié par écrit et si vos utilisateurs n'en sont pas conscients, de
  telles actions peuvent être illégales et <e>vous</e> causer des problèmes
  légaux.
</li>
<li>
  Le détournement de comptes utilisateurs est une des menaces les plus communes
  à la sécurité d'un système. Si vous n'expliquez pas aux utilisateurs pourquoi
  la sécurité est importante et quelles sont les bonnes pratiques en matière de
  sécurité (comme ne pas noter les mots de passe sur des bouts de papier
  traînant sur les bureaux), il y a peu de chances que vos comptes
  utilisateurs soient bien protégés.
</li>
<li>
  Des schémas détaillés de votre système et de votre réseau vous aideront et
  aideront aussi les inspecteurs des forces policières si besoin est, à
  retracer les intrusions et à identifier les faiblesses après coup. Un message
  d'accueil relatif à la politique de sécurité, tel qu'un rappel que le système
  fait partie d'un réseau privé dont l'utilisation non-autorisée est prohibée,
  aidera à vous assurer que vous pouvez poursuivre en justice les intrus que
  vous aurez attrapés.
</li>
</ul>

<p>
À la lumière de ce qui précède, la nécessité d'une bonne politique de sécurité
devrait être évidente.
</p>

<p>
La politique en tant que telle est un document, ou un ensemble de documents,
décrivant le réseau et les fonctionnalités du système (tel que l'ensemble des
services offerts), les utilisations acceptables et celles qui ne le sont pas,
les «&nbsp;bonnes pratiques&nbsp;» de sécurité, etc. Tous les utilisateurs
devraient être informés de l'existence de la politique, ainsi que de tout
changement que vous y apportez pour la mettre à jour. Il est important de
prendre le temps d'aider les utilisateurs à comprendre la politique et de
leur expliquer pourquoi ils doivent signer cette dernière et quelles sont les
conséquences s'ils violent la politique (la politique devrait inclure des
informations à ce sujet). Cette pratique devrait être répétée une fois par an,
puisque la politique peut changer (mais aussi pour faire un rappel à
l'utilisateur).
</p>

<note>
Créez une charte qui soit précise et facile à comprendre dans tous les sujets
abordés.
</note>

<p>
Une politique de sécurité doit contenir au moins les points suivants&nbsp;:
</p>

<ul>
<li>Utilisation correcte</li>
<li>
 <ul>
  <li>Économiseurs d'écran</li>
  <li>Gestion des mots de passe</li>
  <li>Téléchargement et installation de logiciels</li>
  <li>Informer les utilisateurs s'ils sont surveillés</li>
  <li>Utilisation de programmes anti-virus</li>
 </ul>
</li>
<li>Gestion des informations sensibles (sous n'importe quelle forme écrite
ou numérique)</li>
<li>
<ul>
  <li>Rangement du bureau et mise sous clé des informations sensibles</li>
  <li>Extinction du PC avant de partir</li>
  <li>Utilisation du cryptage</li>
  <li>Gestion des clés avec les collègues de confiance</li>
  <li>Manipulation du matériel sensible en cas de voyage</li>
</ul>
</li>
<li>Manipulation de l'équipement informatique pendant un voyage</li>
<li>
<ul>
  <li>
    Manipulation des portables pendant les voyages et durant les séjours en
    hôtel
  </li>
</ul>
</li>
</ul>

<p>
Des utilisateurs différents auront peut-être besoin de niveaux ou de types
d'accès variés. Votre politique peut varier afin d'accommoder tous les
utilisateurs.
</p>

<p>
Une politique de sécurité peut devenir très volumineuse et des informations
vitales peuvent être facilement oubliées. La politique pour les informaticiens
devrait contenir des informations non disponibles pour les autres utilisateurs
&nbsp;; il est donc intelligent de la découper en chartes plus petites,
c'est-à-dire Charte de bon usage, Politique de mots de passe, Politique de
courrier électronique et Politique d'accès distant.
</p>

<p>
Des exemples de politiques se trouvent sur le site du <uri
link="http://www.sans.org/newlook/resources/policies/policies.htm">projet de
sécurité SANS</uri>. Si vous avez un petit réseau et si vous pensez que ces
procédures sont trop lourdes, vous devriez consulter le <uri
link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">Site
Security Handbook</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Améliorer la sécurité pendant et après l'installation</title>
<section>
<title>Options USE</title>
<body>

<p>
Le fichier <path>make.conf</path> contient les options de la variable USE
définies par l'utilisateur et <path>/etc/make.profile/make.defaults</path>
contient les options USE utilisées par défaut dans Gentoo Linux.  Dans ce
guide, nous allons nous intéresser aux options <c>pam</c> (Pluggable
Authentication Modules), <c>tcpd</c> (couche TCP) et <c>ssl</c> (Secure Socket
Layer). Elles sont toutes dans les options USE par défaut.
</p>

</body>
</section>

<section id = "passwording_GRUB">
<title>Protéger GRUB par un mot de passe</title>
<body>

<p>
GRUB permet d'ajouter une sécurisation par mot de passe à votre chargeur de
démarrage de deux manières différentes. La première utilise un mot de passe en
clair et la seconde fait appel à un cryptage md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changez_moi
</pre>

<p>
Cela ajoutera le mot de passe <c>changez_moi</c>. Si aucun mot de passe n'est
entré lors du démarrage, les paramètres de démarrage par défaut seront utilisés.
</p>

<p>
Lorsque vous ajoutez un mot de passe md5, vous devez le convertir en format
crypt, qui est le même format que celui utilisé dans le fichier
<path>/etc/shadow</path>. Pour plus d'information, lisez <c>man crypt</c>. Le
mot de passe crypté <e>changez_moi</e> peut, par exemple, ressembler à&nbsp;:
$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</p>

<p>
Vous pouvez convertir votre mot de passe directement dans le shell de
GRUB&nbsp;:
</p>

<pre caption="Cryptage md5 dans le shell GRUB">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB lists
     possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>***********</i>
<codenote>Tapez changez_moi à l'invite de commande</codenote>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Ensuite, copiez/collez votre mot de passe dans
<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Le temps limite de 5 secondes devient très pratique si votre système est
controlé à distance et doit pouvoir redémarrer sans utiliser le clavier. Vous
pouvez obtenir plus d'informations sur GRUB et les mots de passe en exécutant
<c>info grub</c>.
</p>

</body>
</section>

<section id = "passwording_LILO">
<title>Protéger LILO par un mot de passe</title>
<body>

<p>
LILO supporte deux méthodes pour manipuler les mots de passe&nbsp;: globale et
par image. Les deux contiennent des mots de passe en clair.
</p>

<p>
Le mot de passe global se place en haut du fichier de configuration et
s'applique à toutes les images de démarrage&nbsp;:
</p>

<pre caption="/etc/lilo.conf">
password=changez_moi
restricted
delay=3
</pre>

<p>
Le mot de passe par image est défini comme suit&nbsp;:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changez_moi
      restricted
</pre>

<p>
Si l'option <c>restricted</c> n'est pas spécifiée, l'ordinateur vous demandera
un mot de passe à chaque fois.
</p>

<p>
Vous devez exécuter <c>/sbin/lilo</c> pour enregistrer les informations que
vous avez entrées dans votre fichier <path>lilo.conf</path>.
</p>

</body>
</section>
<section>
<title>Restrictions concernant l'utilisation de la console</title>
<body>

<p>
Le fichier <path>/etc/securetty</path> vous permet de spécifier quels sont les
périphériques <c>tty</c> (terminaux) utilisables par root pour se connecter.
</p>

<p>
Nous vous conseillons de commenter toutes les lignes à part <c>vc/1</c>. Cela
vous permettra d'être sûr que root n'a le droit de se connecter qu'une seule
fois et sur un seul terminal.
</p>

<note>
Les utilisateurs du groupe «&nbsp;wheel&nbsp;» peuvent toujours utiliser <c>su
-</c> pour devenir root sur d'autres TTY.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Plus de journalisation</title>
<section>
<body>

<p>
Vous devriez augmenter le niveau de journalisation des événements pour obtenir
plus d'avertissements ou de messages d'erreurs pouvant indiquer une attaque en
cours ou ayant déjà porté fruits. Les attaquants scannent ou sondent
généralement avant de commencer une attaque.
</p>

<p>
Il est également vital que les fichiers des journaux soient lisibles et
facilement exploitables.  Gentoo Linux vous permet de choisir entre 3 types de
systèmes de journalisation au moment de l'installation.
</p>

</body>
</section>
<section>
<title>Syslogd</title>
<body>

<p>
Syslogd est le système de journalisation le plus répandu sous Linux et UNIX en
général. Il n'inclut aucun système de rotation pour les journaux. Cette
fonctionnalité est gérée par <path>/usr/sbin/logrotate</path> dans les tâches de
<path>cron</path> (logrotate est configuré dans
<path>/etc/logrotate.conf</path>). La fréquence de rotation des journaux que
vous devriez paramétrer dépend de la charge de votre système.
</p>

<p>
Ci-dessous, vous trouverez le <path>syslog.conf</path> standard avec quelques
fonctionnalités supplémentaires.  Nous avons décommenté les lignes <c>cron</c>
et <c>tty</c> et ajouté un serveur de journalisation distant.  Pour encore
plus de sécurité, vous pouvez ajouter les journaux dans deux emplacements.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Fichier de configuration pour syslogd.
#
#                       Pour plus d'informations, voir la page man syslog.conf(5).
#                       Cela provient de Debian, nous l'utilisons actuellement.
#                       Daniel Robbins, 5/15/99

#
# Tout d'abord quelques fichiers de journaux standards. Journal par fonction.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Journaux pour le système de courrier. Séparez-le afin
# qu'il soit facile d'écrire des scripts pour analyser ces fichiers.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Journaux pour le système de « news » INN.
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Quelques fichiers de journaux «&nbsp;attrape-tout&nbsp;».
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Les urgences et alertes sont envoyées à toutes les personnes connectées.
#
*.emerg                         *
*.=alert                        *

#
# J'aime avoir des messages affichés sur la console, mais seulement
# sur une console virtuelle que je n'utilise pas.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# Installation d'un serveur de journaux distant.
*.*                        @logserver

# Le tube nommé /dev/xconsole est pour l'utilitaire `xconsole'.  Pour l'utiliser,
# vous devez invoquer `xconsole' avec l'option `-file' :
#
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE : ajustez la liste ci-dessous ou vous allez devenir fou si vous avez
#        un site plutôt actif...
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                --/var/log/ppp.log
</pre>

<p>
L'attaquant essaiera généralement d'effacer ses traces en éditant ou en
effaçant les fichiers de journaux. Vous pouvez rendre sa tâche plus complexe en
envoyant les journaux sur un ou plusieurs serveurs de journalisation situés sur
des machines distantes. Vous trouverez plus d'informations sur syslogd en
consultant sa page man (<c>man syslog</c>).
</p>

</body>
</section>

<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri>, écrit par Frank
Dennis, n'est pour sa part pas capable de journaliser sur des serveurs à
distance, mais il a bien d'autres avantages concernant les performances et la
flexibilité de journalisation. Il peut journaliser par nom de programme,
importance ou fonction (comme syslogd) et permet aussi l'analyse des journaux
avec des expressions rationnelles permettant de déclencher l'exécution de
commandes. Cela s'avère très pratique dans les situations qui demandent une
réaction.
</p>

<p>
La configuration de base est généralement suffisante. Si vous voulez être
averti par courrier quand une erreur de mot de passe est commise, utilisez
l'un des scripts suivants.
</p>

<p>
Pour postfix&nbsp;:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh pour postfix">
#! /bin/sh
echo "$3" | mail -s "Attention (programme : $2)" root
</pre>

<p>
Pour qmail&nbsp;:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh pour qmail">
#!/bin/sh
echo "To: root
Subject:Echec (Attention: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
N'oubliez pas de rendre ces scripts exécutables en faisant <c>/bin/chmod +x
/usr/local/sbin/mail_pwd_failures.sh</c>
</p>

<p>
Ensuite, décommentez les lignes de commande sous «&nbsp;Password failures&nbsp;»
dans <path>/etc/metalog/metalog.conf</path> comme ceci&nbsp;:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>

<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng propose les mêmes fonctionnalités que syslog et metalog avec quelques
petites différences.  Il peut notamment filtrer les messages en se basant sur
un niveau d'exécution et un contenu (tout comme metalog), gérer des journaux
distants comme syslogd, exploiter des journaux venant de syslogd (même de flux
venant de Solaris), écrire sur une console TTY, exécuter des programmes et être
paramétré comme serveur de journaux. Il représente actuellement le meilleur
système, combinant les qualités des deux autres programmes cités ci-dessus en
ajoutant des options de configuration avancées.
</p>

<p>
Voici un fichier de configuration classique légèrement modifié&nbsp;:
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

# Endroit où lire le journal
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

# Définir les destinations.
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination mailprog { program("/usr/bin/email.sh"); };
destination xconsole { pipe("/dev/xconsole"); };

# Créer les filtres.
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

# Connecter les filtres et les destinations.
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

# Envoyer par courrier les journaux ratés.
log { source(src); filter(f_failed); filter(f_denied); destination(mailprog); };

# Journal par défaut
log { source(src); destination(console_all); };
</pre>

<p>
Syslog-ng est très simple à configurer, mais il est aussi très facile d'oublier
quelque chose dans le fichier de configuration tellement il est volumineux.
L'auteur nous promet d'autres améliorations comme le cryptage,
l'authentification, la compression et le contrôle par adresse MAC (Mandatory
Access Control). Avec ces options, il deviendra un système de journalisation
réseau parfait étant donné que l'attaquant ne pourra plus espionner le journal.
</p>

<p>
Syslog-ng a un autre avantage&nbsp;: il n'a pas besoin d'être exécuté en tant
que root&nbsp;!
</p>

</body>
</section>
<section>
<title>Analyse des journaux avec Logcheck</title>
<body>

<p>
Bien sûr, journaliser les événements n'est que la moitié de la bataille. Une
application telle que Logcheck peut faciliter grandement l'analyse régulière
des journaux. Logcheck est un script accompagné d'un programme binaire nommé
<c>logtail</c>, qui est exécuté à partir du démon cron et qui compare vos
journaux à un ensemble de règles pour repérer une éventuelle activité suspecte.
Il envoie ensuite le résultat par courrier à l'utilisateur root.
</p>
<p>
Logcheck utilise quatre fichiers pour filtrer les journaux et départager les
entrées importantes de celles qui ne le sont pas. Ces fichiers sont
<path>logcheck.hacking</path>, qui contient des messages connus relatifs au
«&nbsp;hacking&nbsp;», <path>logcheck.violations</path>, qui contient des
motifs relatifs aux violations de sécurité,
<path>logcheck.violations.ignore</path>, qui contient des mots-clés sensibles
d'être présents dans le fichier des violations, ce qui permet d'ignorer les
entrées ordinaires, et <path>logcheck.ignore</path>, qui correspond aux entrées
à ignorer.
</p>

<warn>
Ne laissez pas <path>logcheck.violations.ignore</path> vide. Logcheck utilise
<c>grep</c> pour l'analyse lexicale des journaux. Or, certaines versions de
<c>grep</c> considèrent un fichier vide comme un joker. Toutes les violations
seraient alors ignorées.
</warn>
<!-- FIXME: Might want to add more details on logcheck here...I have to install
it on Gentoo to figure out how it's configured! -->

</body>
</section>
</chapter>
<chapter>
<title>Montage des partitions</title>
<section>
<body>

<p>
Lorsque vous montez des partitions <c>ext2</c>, <c>ext3</c> ou <c>reiserfs</c>,
vous pouvez appliquer plusieurs options au fichier <path>/etc/fstab</path>.
Voici leurs descriptions&nbsp;:
</p>

<ul>

<li>
  <c>nosuid</c>&nbsp;- Ignore l'option SUID et considère chaque fichier comme
  un fichier ordinaire.
</li>

<li>
  <c>noexec</c>&nbsp;- Interdit l'exécution de tout fichier à partir de cette
  partition.
</li>

<li>
  <c>nodev</c>&nbsp;- Ne tient pas compte des «&nbsp;devices&nbsp;».
</li>
</ul>

<p>
Ces paramètres peuvent malheureusement être facilement contournés en utilisant
un chemin indirect. Vous pourrez néanmoins, en activant l'option noexec pour
<path>/tmp</path>, arrêter la plupart des «&nbsp;exploits&nbsp;» conçus pour
être exécutés à partir de <path>/tmp</path> .
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var ext3 noatime,nodev 0 0
/dev/sda6 /home ext3 noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Mettre <path>/tmp</path> en mode <c>noexec</c> peut empêcher le fonctionnement
de certains scripts.
</warn>

<note>
Pour les quotas de disque, voir la <uri link="#doc_chap6_sect3">section sur les
quotas</uri>.
</note>

<note>
Notez que je ne mets pas le répertoire <path>/var</path> en mode <c>noexec</c>
ou <c>nosuid</c>, même si les fichiers ne sont jamais exécutés depuis ce point
de montage. La raison principale tient au fait que qmail est installé dans
<path>/var/qmail</path> et doit être autorisé à exécuter et à manipuler un
fichier SUID. Je paramètre <path>/usr</path> en mode lecture seulement
(«&nbsp;read-only&nbsp;») étant donné que je n'y écris jamais sauf pour mettre à
jour Gentoo. Je remonte alors le système de fichiers en mode lecture-écriture
(«&nbsp;read-write&nbsp;»), je procède à la mise à jour et je remonte le système
en lecture seulement.
</note>

<note>
Même si vous n'utilisez pas qmail, Gentoo a besoin que <path>/var/tmp</path>
soit exécutable, étant donné que les ebuilds sont construits dans ce
répertoire. Vous pouvez toutefois paramétrer un chemin différent si vous tenez
absolument à mettre <path>/var</path> en mode <c>noexec</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Limitations pour les utilisateurs et les groupes</title>

<section id = "limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
Contrôler l'utilisation des ressources peut se révéler très utile pour éviter
une attaque de type déni de sevice local ou bien pour limiter le nombre total
d'ouvertures de sessions pour un groupe ou un utilisateur.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Si vous vous rendez compte que vous mettez <c>nproc</c> ou <c>maxlogins</c> à
0, il serait certainement plus simple de supprimer l'utilisateur.  L'exemple
ci-dessus paramètre le groupe <c>dev</c> pour le nombre de processus, les
fichiers core et <c>maxlogins</c>. Le reste est laissé à la valeur par défaut.
</p>

<note>
Le fichier <path>/etc/security/limits.conf</path> fait partie du paquet PAM et
ne sera utilisé que par les paquets dépendant de PAM.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
Le fichier <path>/etc/limits</path> est très similaire au fichier
<path>/etc/security/limits.conf</path>. Les seules différences sont dans
le format et dans le fait qu'il ne fonctionne qu'avec des utilisateurs ou des
expressions rationnelles (et non pas avec des groupes). Regardons un exemple de
configuration de plus près&nbsp;:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Nous réglons ici les paramètres par défaut, mais également une valeur
particulière pour l'utilisateur kn. Les limites font partie du paquet
sys-apps/shadow. Il n'est pas nécessaire de mettre des limites dans ce fichier
si vous avez désactivé <c>pam</c> dans votre <path>make.conf</path> ou si vous
n'avez pas configuré PAM correctement.
</p>

</body>
</section>
<section>
<title>Quotas</title>
<body>

<warn>
Assurez-vous que le système de fichiers avec lequel vous travaillez supporte
les quotas. Pour utiliser les quotas avec ReiserFS, vous devez appliquer à votre
noyau le correctif disponible sur le site de <uri
link="ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">
Namesys</uri>. Les outils de l'utilisateur sont disponibles sur le site du <uri
link="http://www.sf.net/projects/linuxquota/">Linux DiskQuota project</uri>.
Bien que les quotas fonctionnent avec ReiserFS, vous éprouverez peut-être
des problèmes lorsque vous essayerez de les utiliser&nbsp;; vous voilà donc
averti&nbsp;!
</warn>

<p>
Placer des quotas sur un système de fichiers restreint l'utilisation du disque
sur la base de l'identité de l'utilisateur et de son groupe. Les quotas sont
activés dans le noyau et ajoutés par la suite sur un point de montage dans
<path>/etc/fstab</path>. L'option du noyau qui active ce paramètre se trouve
dans la section <c>File systems->Quota support</c>. Appliquez l'option,
recompilez votre noyau et redémarrez en utilisant votre nouveau noyau.
</p>

<p>
Commencez par installer les quotas avec <c>emerge quota</c>. Modifiez ensuite
votre fichier <path>/etc/fstab</path> et ajoutez les paramètres <c>usrquota</c>
et <c>grpquota</c>  aux partitions sur lesquelles vous souhaitez restreindre
l'utilisation du disque, comme le montre l'exemple ci-dessous.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Vous devez ensuite créer les fichiers de quotas (<path>quota.user</path> et
<path>quota.group</path>) pour chaque partition sur lesquelles vous avez
activé les quotas, puis placer ces fichiers à la racine de ces partitions.
</p>

<pre caption="Création des fichiers de quota">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Cette étape est nécessaire pour chaque partition où les quotas sont actifs.
Après avoir ajouté et configuré les fichiers de quotas, vous devez ajouter le
script <c>quota</c> aux scripts d'initialisation pour appliquer les quotas
après chaque démarrage.
</p>

<pre caption="Lancer le script quota à chaque démarrage">
# <i>rc-update add quota boot</i>
</pre>

<p>
Configurez le système afin de vérifier les quotas une fois par semaine en
ajoutant la ligne suivante dans <path>/etc/crontab</path>&nbsp;:
</p>

<pre caption="Ajouter la vérification des quotas au crontab">
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
Après avoir redémarré la machine, il est temps de configurer les quotas pour
les utilisateurs et les groupes. La commande <c>edquota -u kn</c>  démarrera
l'éditeur défini dans $EDITOR (nano par défaut) qui vous permettra d'éditer les
quotas de l'utilisateur kn. <c>edquota -g</c> vous permet de faire la même
chose pour les groupes.
</p>

<pre caption="Mettre en place des quotas pour l'utilisateur kn">
Quotas pour l'utilisateur kn :
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Pour plus d'informations sur les quotas, consultez les pages man à l'aide
de <c>man edquota</c> ou bien <uri
link="http://www.linuxdoc.org/HOWTO/mini/Quota.html">le mini-howto des
quotas</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
Si votre politique de sécurité spécifie que les utilisateurs doivent changer
leur mot de passe toutes les deux semaines, mettez la valeur de
<c>PASS_MAX_DAYS</c> à 14 et celle de <c>PASS_WARN_AGE</c> à 7.  Il est
également conseillé d'utiliser l'ancienneté des mots de passe car les attaques
par force brute peuvent trouver n'importe quel mot de passe&nbsp;; ce n'est
qu'une question de temps. Nous recommandons également de définir la variable
<c>LOG_OK_LOGINS</c> à yes.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Le fichier <path>login.access</path> fait également partie du paquet
sys-apps/shadow, qui vous donne accès à une table de contrôle des
ouvertures de sessions. Cette table est utilisée pour décider qui a le droit ou
pas d'ouvrir une session en fonction du nom d'utilisateur, du nom de groupe ou
du nom d'hôte. Par défaut, tous les utilisateurs du système ont le droit
d'ouvrir une session. Le fichier n'est donc constitué que d'exemples et de
commentaires.  Que vous sécurisiez une station de travail ou un serveur, nous
vous recommandons de configurer ce fichier de telle sorte que vous
(l'administrateur) soyez le seul autorisé à accéder à la console.
</p>

<note>
Ces paramètres ne s'appliquent pas à root.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Faites attention lorsque vous entrez ces options, car une erreur vous laissera
sans accès à la machine si vous n'avez pas d'accès root.
</impo>

<note>
Ces paramètres n'affectent pas SSH car il n'utilise pas <c>/bin/login</c> par
défaut. Vous pouvez changer ce comportement en mettant <c>UseLogin yes</c> dans
le fichier <path>/etc/ssh/sshd_config</path>.
</note>

<p>
Cela paramétrera l'accès d'ouverture de session pour que les membres du groupe
wheel puissent ouvrir une session localement ou depuis le domaine gentoo.org.
Cela peut paraître paranoïaque, mais il vaut mieux être sécurisé que désolé.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Permissions de fichiers</title>
<section>
<title>Lecture pour tous</title>
<body>

<p>
Les utilisateurs normaux ne devraient pas avoir accès aux fichiers de
configuration ou de mots de passe. Un attaquant pourrait dérober les mots de
passe d'une base de données ou d'un site Internet et les utiliser pour
modifier, voire effacer des données. C'est pourquoi il est important que les
permissions des fichiers soient correctes. Si vous êtes certain qu'un fichier
n'est utilisé que par root, assignez-lui les permissions <c>0600</c> et assignez
au fichier l'utilisateur approprié avec <c>chown</c>.
</p>

</body>
</section>
<section>
<title>Écriture pour tous les utilisateurs et tous les groupes</title>
<body>

<pre caption="Trouver des fichiers et répertoires accessibles en écriture pour tous">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Cela créera un long fichier contenant la liste des fichiers qui ont un droit
d'écriture pour tout le monde ou pour le groupe. Vérifiez les permissions et
éliminez les droits sur les fichiers qui sont accessibles en écriture par tout
le monde en exécutant la commande <path>/bin/chmod o-w</path> sur ces fichiers.
</p>

</body>
</section>
<section>
<title>Les fichiers SUID/SGID</title>
<body>

<p>
Les fichiers dont le bit SUID ou SGID est activé sont exécutés avec les
privilèges de l'utilisateur ou du groupe <e>possédant</e> ce fichier, et non
avec ceux de l'utilisateur qui exécute le fichier. Normalement, ces bits sont
utilisés sur des fichiers qui doivent fonctionner en tant que root pour
accomplir leur travail. Ces fichiers peuvent mener à une exploitation locale de
votre système avec les droits root s'ils contiennent des failles de sécurité.
Ceci est dangereux, et les fichiers avec des bits SUID ou SGID doivent être
évités à tout prix. Si vous n'utilisez pas ces fichiers, faites un <c>chmod
0</c> dessus ou bien désinstallez les paquets qui ont généré ces fichiers.
(Vérifiez à quel paquet ils appartiennent avec la commande <c>qpkg -f</c>. Si
elle n'est pas déjà installée, faites <c>emerge gentoolkit</c>). Pour les
fichiers que vous utilisez, modifiez juste le bit SUID en faisant <c>chmod
-s</c>.
</p>

<pre caption="Trouver des fichiers setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Cette commande crée un fichier contenant la liste de tous les fichiers
SUID/SGID.
</p>

<pre caption="Liste des binaires setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Gentoo Linux ne contient pas beaucoup de fichiers SUID par défaut (cela dépend
de ce que vous avez installé). Vous pouvez néanmoins obtenir une liste
similaire à celle ci-dessus. La plupart de ces commandes ne devraient pas être
utilisées par des utilisateurs normaux et devraient donc être restreintes à
root. Désactivez le mode suid sur <c>ping</c>, <c>mount</c>, <c>umount</c>,
<c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> et
<c>traceroute</c> en faisant <c>chmod -s</c> sur chacun de ces fichiers.
N'enlevez pas ce mode sur les fichiers <c>su</c>, <c>qmail-queue</c> ou
<c>unix_chkpwd</c>.  Cela vous empêcherait de pouvoir faire des su ou
bien de recevoir des courriers.  En modifiant ce bit (lorsque c'est
sécuritaire), vous enlevez la possibilité à un utilisateur normal (ou à un
attaquant) d'obtenir un accès root grâce à ces fichiers.
</p>

<p>
Les seuls fichiers en mode SUID que j'ai sur mon système sont <c>su</c>,
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> et
<c>pwdb_chkpwd</c>. Mais, si vous utilisez X, vous en aurez sans doute
davantage, puisque X requiet l'accès privilégié qui lui est conféré par SUID.
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM est un ensemble de bibliothèques partagées qui proposent une méthode
alternative pour effectuer des authentifications dans les programmes. L'option
<c>pam</c> est activée par défaut dans la variable USE. Les paramètres de
configuration de PAM dans Gentoo Linux sont relativement bons, mais on peut
toujours faire mieux. Tout d'abord, installez cracklib.
</p>

<pre caption="Installer cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Ceci ajoutera cracklib, qui contrôlera que les utilisateurs entrent un mot de
passe d'un minimum de 8 caractères, qui contient au moins 2 chiffres, 2
symboles, et pour lequel au moins 3 caractères sont différents de ceux du
dernier mot de passe. Cela force l'utilisateur à choisir un bon mot de passe.
Consultez la documentation <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">
PAM</uri> pour de plus amples informations.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Tout service non configuré par un fichier PAM dans <path>/etc/pam.d</path>
utilisera les règles contenues dans <path>/etc/pam.d/other</path>. Les
valeurs par défaut sont mises à <c>deny</c> comme il se doit. Mais aimant avoir
beaucoup de journaux, j'ai ajouté <c>pam_warn.so</c>. La dernière configuration est
<c>pam_limits</c> qui est controlée par <path>/etc/security/limits.conf</path>.
Consultez la section <uri link ="#limits_conf">/etc/security/limits.conf</uri>
pour plus d'informations sur ces paramètres.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Les «&nbsp;wrappers&nbsp;» TCP</title>
<section>
<body>

<p>
Ils servent à contrôler l'accès aux services normalement démarrés par inetd
(que Gentoo n'utilise pas) et peuvent aussi être utilisés par xinetd et d'autres
services.
</p>

<note>
Le service doit mentionner tcpd dans ses arguments de démarrage (dans xinetd).
Consultez le chapitre sur xinetd pour de plus amples informations.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Comme vous pouvez le constater, ce format est similaire à celui de
<path>/etc/login.access</path>. Toutefois, tcpd supporte un service spécifique
et ne recoupe donc pas les fonctionnalités de <path>/etc/login.access</path>. Ces
paramètres ne sont applicables qu'aux services qui utilisent les
«&nbsp;wrappers&nbsp;» tcpd.
</p>

<p>
Il est également possible d'exécuter des commandes lorsqu'un service est
sollicité (par exemple lorsque vous utilisez la possibilité de numérotation
d'un modem pour les utilisateurs) bien que cela ne soit pas recommandé, car
cela a tendance à créer plus de problèmes que cela n'en résoud. Un bon exemple
est la création d'un script qui envoie un courriel à chaque fois que quelqu'un
se voit refuser un accès à cause d'une règle d'interdiction. Une personne
malveillante pourrait faire une attaque de type déni de service en provoquant
continuellement l'exécution de ce script de notification.  Cela génèrerait alors
beaucoup d'entrées/sorties et de courriels. Ne le faites donc pas&nbsp;! Lisez
<c>man 5 hosts_access</c> pour plus d'informations.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sécurité du noyau</title>

<section>
<title>Retirer des fonctionnalités</title>
<body>

<p>
La règle de base lorsque vous configurez le noyau est de retirer tout ce dont
vous n'avez pas besoin. Cela créera non seulement un noyau de petite taille
mais retirera également toute vulnérabilité qui pourrait être contenue dans un
pilote ou dans d'autres modules.
</p>

<p>
Vous pouvez également penser à désactiver le support du chargement des modules.
Même s'il est possible de charger des «&nbsp;root kits&nbsp;» sans cette option,
cela compliquera l'installation d'un «&nbsp;root kit&nbsp;» par le biais des
modules du noyau, du moins pour les attaquants conventionnels.
</p>

</body>
</section>

<section>
<title>Le système de fichiers /proc</title>
<body>

<p>
De nombreux paramètres peuvent être modifiés par le biais de <path>/proc</path>
ou en utilisant <c>sysctl</c>.
</p>

<p>
Vous devez avoir défini <c>CONFIG_SYSCTL</c> dans votre noyau afin de pouvoir
modifier des paramètres et variables du noyau dynamiquement. Le noyau 2.4
contient cette option par défaut.
</p>

<pre caption="Ignorer les paquets ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Cette commande indiquera au noyau d'ignorer les messages de ping (messages icmp
de type 0).  La raison pour cela est qu'un paquet IP transportant un message
ICMP peut contenir beaucoup plus d'informations que vous ne le pensez.  Les
administrateurs utilisent ping comme un outil de diagnostic et se plaindront
souvent s'ils ne peuvent l'utiliser. Il n'y a aucune raison que quelqu'un de
l'extérieur puisse faire un ping, mais quelquefois cela peut être pratique pour
les utilisateurs locaux. Ce problème peut être résolu en désactivant les
messages icmp de type 0 sur le pare-feu.
</p>

<pre caption="Ignorer les pings de diffusion (« broadcast »)">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Ceci désactive les réponses aux diffusions ICMP et préviendra des attaques
«&nbsp;smurf&nbsp;». Les attaques «&nbsp;smurf&nbsp;» fonctionnent en envoyant
un message  ICMP de type 0 (ping) à l'adresse de diffusion du réseau.
Typiquement, l'attaquant utilisera une adresse source fausse. Tous les
ordinateurs du réseau répondront alors au message ping et l'hôte qui possède
vraiment l'adresse source utilisée sera surchargé de messages.
</p>

<pre caption="Désactiver le routage de paquets d'origine interne">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
N'acceptez pas les paquets apparemment d'origine interne. Un attaquant peut en
effet générer du trafic vers votre réseau en prétendant faire partie du réseau
interne.  Accepter de tels paquets lui permettrait alors de compromettre votre
réseau. Le routage de paquets d'origine interne est rarement utilisé à des fins
légitimes&nbsp;; désactivez-le donc.
</p>

<pre caption="Désactiver l'autorisation de redirection">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Désactivez l'autorisation des redirections ICMP. Elles sont souvent utilisées
pour altérer vos tables de routage, parfois de façon malicieuse.
</p>

<pre caption="Protection contre les mauvais messages d'erreurs">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Activez la protection contre les faux messages d'erreurs.
</p>

<pre caption="Activer le filtrage de chemin inverse">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<note>
Si vous activez l'«&nbsp;IP forwarding&nbsp;», vous aurez le même résultat.
</note>

<p>
Activez le filtrage de chemin inverse. Cela vous permet de vous assurer que les
paquets utilisent des adresses sources légitimes en rejettant automatiquement
les paquets entrants si l'entrée de leur adresse source dans la table de
routage ne correspond pas à la carte réseau par laquelle ils entrent. Un des
avantages est de pouvoir empêcher l'usurpation d'IP («&nbsp;spoofing&nbsp;»).
</p>

<warn>
Par contre, cela peut poser des problèmes si vous utilisez un routage
asymétrique (les paquets qui vont de votre machine vers une autre prennent un
chemin différent de celui pris par les paquets revenant de cette machine vers
la vôtre) ou bien si vous utilisez un hôte non routant qui a plusieurs adresses
IP sur différentes cartes.
</warn>

<pre caption="Consigner tous les paquets falsifiés, routés par la source et redirigés">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Enregistre dans le journal les paquets falsifiés, les paquets routés par la
source et ceux qui sont redirigés.
</p>

<pre caption="Désactiver l'« IP forwarding »">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Assurez-vous d'avoir désactivé l'«&nbsp;IP forwarding&nbsp;». Cela n'est utile
que pour une machine avec plusieurs cartes réseau.
</p>

<p>
Tous ces paramètres seront effacés lors de votre prochain redémarrage. Je vous
conseille donc de les ajouter au fichier de configuration
<path>/etc/sysctl.conf</path> qui est utilisé par le script d'initialisation
<path>/etc/init.d/bootmisc</path>.
</p>

<p>
La syntaxe à utiliser dans le fichier <path>/etc/sysctl.conf</path> est simple.
Vous devez utiliser la même syntaxe que ci-dessus en enlevant la partie
<path>/proc/sys/</path> des chemins mentionnés ci-dessus et en remplaçant les
<path>/</path> par des <path>.</path>&nbsp;:
</p>

<pre caption="Configurer sysctl.conf">
<comment>(La commande manuelle) :</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Initialisation automatique via sysctl.conf) :</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>

<section>
<title>Grsecurity</title>
<body>

<p>
Le correctif disponible sur <uri link="http://grsecurity.net">Grsecurity</uri>
est inclus dans les sources du noyau Gentoo, mais il est désactivé par défaut.
Configurez votre noyau comme vous le faites normalement et configurez ensuite
l'option Grsecurity (sélectionnez l'option «&nbsp;custom&nbsp;»). Des
explications détaillées sont disponibles sur la page du projet
<uri link="/proj/en/hardened">Gentoo Hardened</uri>.
</p>

<p>
Les sources <c>grsec-sources</c> récentes contiennent la version 2.* de
Grsecurity. Pour de plus amples informations, veuillez consulter la
documentation disponible sur la <uri link="http://www.grsecurity.net/">page
d'accueil de Grsecurity</uri>.
</p>
</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> est un correctif qui ajoute des
fonctions de cryptage à votre noyau. En corrigeant votre noyau, vous obtiendrez
de nouvelles options comme&nbsp;: le chiffrement cryptographique, des algorithmes de
validation et des filtres de boucles cryptographiques.
</p>

<warn>
Le correctif kerneli n'est actuellement pas stable pour les derniers noyaux.
Vous prenez donc des risques en l'utilisant.
</warn>

</body>
</section>

<section>
<title>Autres correctifs du noyau</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">Le projet OpenWall</uri></li>
  <li>
    <uri link="http://www.lids.org">Système de détection d'intrusion pour
    Linux</uri>
  </li>
  <li><uri link="http://www.rsbac.org">Contrôle d'accès par règles</uri></li>
  <li>
    <uri link="http://www.nsa.gov/selinux">Le noyau sécurisé de la NSA</uri>
  </li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
Il en existe probablement beaucoup d'autres.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sécurisation des services</title>

<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) est livré avec un fichier de configuration relativement bon,
mais, encore une fois, nous devons optimiser quelques petites choses, comme
lier l'écoute d'Apache à une adresse et l'empêcher de donner trop d'information.
Vous trouverez ci-dessous les options que vous devriez utiliser dans le fichier
de configuration&nbsp;:
</p>

<p>
Si vous n'avez pas désactivé <c>ssl</c> dans <path>/etc/make.conf</path> avant
d'installer apache, vous devriez être en possession d'un serveur avec SSL
activé. Ajoutez simplement ce qui suit pour l'activer&nbsp;:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
# Faites-le écouter sur votre adresse IP.
Listen 127.0.0.1
BindAddress 127.0.0.1
# Ce n'est pas une bonne idée d'utiliser nobody ou nogroup
# pour les services qui ne sont pas exécutés en tant que root ;
# préférez l'utilisateur et le groupe apache (ajoutez-les).
User apache
Group apache
# Empêchera Apache de dévoiler sa version.
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache est compilé avec les options <c>--enable-shared=max</c> et
<c>--enable-module=all</c>.  Cela autorise tous les modules par défaut. Vous
devez donc commenter les modules dont vous n'avez pas besoin dans la section
<c>LoadModule</c> (<c>LoadModule</c> et <c>AddModule</c>). Redémarrez ensuite
le service en faisant&nbsp;: <c>/etc/init.d/apache restart</c>.
</p>

<p>
Pour plus d'informations, consultez <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
Consultez la documentation en ligne sur <uri
link="http://www.isc.org/products/BIND/bind9.html"> Internet Software
Consortium</uri>. Le manuel de référence de l'administrateur de BIND 9 se
trouve aussi dans <path>doc/arm</path>.
</p>

<p>
Les ebuilds récents pour le logiciel BIND supportent le chroot sans effort de
votre part. Après avoir exécuté <c>emerge bind</c>, suivez ces
instructions&nbsp;:
</p>

<pre caption="Utiliser un chroot avec BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<codenote>Avant d'exécuter la commande précédente, vous souhaiterez peut-être
changer le répertoire du chroot dans /etc/conf.d/named. Par défaut,
/chroot/dns sera utilisé.</codenote>
<codenote>Vous devrez peut-être substituer la version du paquet dans la
commande ci-dessus par celle du paquet que vous utilisez.</codenote>
</pre>

</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns est une autres implémentation d'un serveur DNS. Son auteur est prêt à
parier de <uri link="http://cr.yp.to/djbdns/guarantee.html">l'argent</uri> pour
prouver qu'il est sécurisé. Son mode de fonctionnement est très différent de
celui de Bind v.9, mais il vaut la peine d'être testé. Vous trouverez plus
d'informations sur <uri>http://www.djbdns.org/</uri>.
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Utiliser FTP (File Transfer Protocol) est en général une mauvaise idée. Ce
service n'utilise aucun cryptage pour les données (les mots de passe sont
échangés sous forme de texte clair), écoute sur 2 ports (habituellement 20 et
21) et supporte des utilisateurs anonymes, cette dernière caractéristique étant
très attrayante pour les attaquants (qui l'utilisent afin d'échanger des
fichiers illégaux («&nbsp;warez&nbsp;»)). Puisque le protocole FTP comporte de
nombreux problèmes de sécurité, vous devriez plutôt utiliser <c>sftp</c> ou
HTTP. Si vous devez utiliser FTP, sécurisez vos services du mieux que vous le
pouvez, et préparez-vous...
</p>

</body>
</section>

<section>
<title>Mysql</title>
<body>

<p>
Si seules les applications locales ont besoin d'accéder à la base de données
<c>mysql</c>, décommentez la ligne suivante dans
<path>/etc/mysql/my.cnf</path>&nbsp;:
</p>

<pre caption="Désactiver l'accès au réseau">
skip-networking
</pre>

<p>
Nous désactivons ensuite l'utilisation de la commande LOAD DATA LOCAL
INFILE. Cela sert à prévenir une lecture non autorisée à partir des fichiers
locaux. Cela devient pertinent lorsque de nouvelles vulnérabilités d'injection
SQL sont découvertes dans des applications PHP.
</p>

<pre caption="Désactiver LOAD DATA LOCAL INFILE dans la section [mysqld]">
set-variable=local-infile=0
</pre>

<p>
Ensuite, nous devons supprimer la base de donnée fournie comme exemple (test)
ainsi que tous les comptes d'utilisateurs à l'exception du compte <c>root</c>
local.
</p>

<pre caption="Supprimer la base de donnée fournie en exemple et les
utilisateurs non nécessaires">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Faites attention avec les commandes ci-dessus si vous avez déjà configuré des
comptes utilisateurs.
</warn>

<note>
Si vous changez des mots de passe à partir de l'invite MySQL, vous devriez
toujours nettoyer <path>~/.mysql_history</path> et
<path>/var/log/mysql/mysql.log</path> puisqu'ils conservent les commandes SQL
exécutées avec les mots de passe en texte clair.
</note>

</body>
</section>

<section>
<title>Proftpd</title>
<body>

<p>
Proftpd est connu pour avoir eu de nombreux problèmes de sécurité, mais la
plupart semblent avoir été réglés. Il est quand même important d'appliquer les
améliorations suivantes&nbsp;:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Mon démon FTP"
# Ne donnez pas l'identité du serveur.
ServerIdent on "Va voir ailleurs si j'y suis"

# Permet de créer des utilisateurs virtuels plus facilement.
RequireValidShell off

# Utilise des fichiers de groupes et de mots de passe alternatifs
# (passwd utilise un format crypté).
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissions
Umask 077

# Délais maximum et limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# Tout le monde en chroot
DefaultRoot ~

# Ne pas démarrer le service en tant que root.
User  nobody
Group nogroup

# Consigner tout transfert.
TransferLog /var/log/transferlog

# Problèmes avec le « globbing »
DenyFilter \*.*/
</pre>

<p>
Vous trouverez plus de documentation sur <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>

<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd est une branche provenant du projet trollftpd, modifié par Frank
Dennis pour des raisons de sécurité et pour améliorer ses fonctionnalité.
</p>

<p>
Utilisez des utilisateurs virtuels (jamais de comptes système) en activant
l'option <c>AUTH</c>. Donnez-lui la valeur <c>-lpuredb:/etc/pureftpd.pdb</c> et
créez vos utilisateurs en utilisant <c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
## Interdire les téléchargements si la partition est plus remplie que la valeur
suivante. ##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## Autres options ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Configurez aussi votre paramètre <c>MISC_OTHER</c> pour ne pas autoriser les
utilisateurs anonymes (<c>-E</c>), pour utiliser le chroot pour tout le monde
(<c>-A</c>), pour que les utilisateurs ne puissent pas lire ou écrire des
fichiers commençant par un . (point) (<c>-X</c>), pour imposer un temps maximum
d'inactivité (<c>-I</c>), pour limiter la récursion (<c>-L</c>) et spécifier un
<c>umask</c> raisonnable.
</p>

<warn>
N'utilisez en <e>aucun</e> cas l'option <c>-w</c> ou <c>-W</c>&nbsp;!  Si vous
voulez héberger du warez, arrêtez de lire ce document&nbsp;!
</warn>

<p>
Pour en savoir plus, consultez <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>

<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (qui signifie&nbsp;: FTP très sécurisé («&nbsp;very secure FTP&nbsp;»))
est un petit démon FTP qui tourne avec un fichier de configuration par défaut plutôt
correct. Il est très simple et ne possède pas beaucoup de fonctionnalités (comme
celle des utilisateurs virtuels), contrairement à pureftp et proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

# Lecture seulement
write_enable=NO

# Active la journalisation des transferts.
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Comme vous pouvez le constater, ce service ne contient pas de permissions
individuelles et pas d'action chroot de base. Mais en ce qui concerne la
configuration pour les utilisateurs anonymes, il est plutôt bon. Il peut
parfois être utile d'avoir un serveur FTP anonyme (afin de partager des sources
par exemple) et vsftpd est vraiment parfait pour cela.
</p>

</body>
</section>

<section>
<title>Qmail</title>
<body>

<p>
Le serveur de courrier Qmail est fréquemment qualifié de très sécuritaire. Il a
été écrit en misant sur la sécurité (et la paranoïa). Il n'autorise pas le
relais des courriels par défaut et n'a eu aucun trou de sécurité depuis 1996.
Faites tout simplement <c>emerge qmail</c> et configurez-le&nbsp;!
</p>

</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
Samba est un protocole qui permet de partager des fichiers avec des réseaux
Microsoft/Novell et qui <e>ne devrait pas</e> être utilisé sur Internet. Il
faut néanmoins le sécuriser.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  # Lier à une interface.
  interfaces = eth0 10.0.0.1/32

  # Asurez-vous d'utiliser des mots de passe cryptés.
  encrypt passwords = yes
  directory security mask = 0700

  # Autoriser le trafic de 10.0.0.*.
  hosts allow = 10.0.0.

  # Permet l'authentification d'utilisateur.
  #(N'utilisez pas le mode partagé.)
  security = user

  # Interdit les comptes privilégiés.
  invalid users = root @wheel

  # Définit la taille maximum, en kilo-octets, affichée pour un élément partagé
  # (ce n'est pas une limite).
  max disk size = 102400

  # Définit la politique de mots de passe.
  min password length = 8
  null passwords = no

  # Utilise PAM (si ce dernier est supporté).
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Assurez-vous que les permissions sont placées correctement sur chaque partage
et lisez la <uri link="http://www.samba.org">documentation</uri>.
</p>

<p>
Redémarrez à présent le serveur et ajoutez les utilisateurs qui devraient avoir
accès à ce service. Vous pouvez le faire grâce à la commande
<path>/usr/bin/smbpasswd</path> avec le paramètre&nbsp;-a.
</p>

</body>
</section>

<section>
<title>ssh</title>
<body>

<p>
La seule option de sécurité que vous devez activer sur OpenSSH concerne
l'authentification basée sur le cryptage à clé publique. Beaucoup trop de sites
(comme <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> et
<uri>http://www.apache.org</uri>) ont souffert d'intrusions non autorisées sur
leurs systèmes à cause de mauvais mots de passe ou de mots de passe divulgués
par erreur.
</p>

<pre caption="/etc/ssh/sshd_config">
# Autorise uniquement la version 2.
Protocol 2

# Pas d'accès en tant que root. (Les utilisateurs devront utiliser su.)
PermitRootLogin no

# Active l'authentification par clé publique.
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# Désactive les fichiers .rhosts et l'authentification normale.
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

# Seuls les membres des groupes wheel ou admin ont accès.
AllowGroups wheel admin

# Parmi les membres de ces groupes, seuls kn et bs ont accès.
AllowUsers kn bs

# Règle le niveau de journalisation.
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
La seule chose que doivent maintenant faire vos utilisateurs est de créer une
clé (sur la machine depuis laquelle ils veulent se connecter) avec la commande
suivante&nbsp;:
</p>

<pre caption="Créer une paire de clés DSA">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Entrez une phrase de passe.
</p>

<pre caption="Sortie générée par ssh-keygen">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Tapez Entrée.]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Entrez votre phrase de passe.]</i>
Enter same passphrase again: <i>[Entrez votre phrase à nouveau.]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Cela va ajouter deux fichiers dans votre répertoire <path>~/.ssh/</path>, nommés
<path>id_dsa</path> et <path>id_dsa.pub</path>. Le premier
fichier, <path>id_dsa</path>, est votre clé privée et devrait être gardée
précieusement pour vous-même et personne d'autre. L'autre fichier,
<path>id_dsa.pub</path>, est à distribuer à tous les serveurs auxquels vous
avez accès. Ajoutez la clé dans le répertoire personnel de l'utilisateur
dans <path>~/.ssh/authorized_keys</path>, puis l'utilisateur devrait être
capable de se connecter.
</p>

<p>
Vos utilisateurs devraient conserver leur clé privée précieusement. Il est
préconisé de la placer sur un support qu'ils ont toujours sur eux ou alors sur
leur station de travail (inclure cette options dans le règlement sur les <uri
link="#security_policies"> mots de passe</uri>).
</p>

<p>
Vous trouverez plus d'informations sur le site officiel <uri
link="http://www.openssh.org">OpenSSH</uri>.
</p>

</body>
</section>

<section>
<title>Utiliser xinetd</title>
<body>

<p>
xinetd remplace <c>inetd</c> (que Gentoo ne propose pas), le démon pour les
services Internet. Il supporte les contrôles d'accès basés sur l'adresse de la
machine distante et sur l'heure de l'accès. Il fournit également des
fonctionnalités avancées de journalisation, incluant l'heure de démarrage du
serveur, l'adresse de la machine distante, le nom de l'utilisateur distant, la
durée de fonctionnement du serveur ainsi que les actions demandées.
</p>

<p>
Tout comme pour les autres services, il est important d'avoir une bonne
configuration par défaut.  Mais étant donné que <c>xinetd</c> fonctionne en
tant que root et supporte des protocoles dont vous pourriez ignorer le
fonctionnement, nous vous recommandons de ne pas l'utiliser.  Mais, si vous
désirez l'utiliser quand même, voici comment le sécuriser quelque peu&nbsp;:
</p>

<pre caption="Installation de xinetd">
# <i>emerge xinetd tcpd</i>
</pre>

<p>
Puis, éditez le fichier de configuration&nbsp;:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Cela créera un pserver (cvs) via xinetd avec les paramètres suivants :
# Maximum de 10 instances (10 connexions simultanées).
# Limite le pserver en mode tcp uniquement.
# Utilise l'utilisateur cvs pour démarrer le service.
# Lie les interfaces à une seule IP.
# Autorise l'accès uniquement depuis 10.0.0.*.
# Limite l'accès des développeurs au serveur entre 8h et 17h.
# Utilise les « wrappers » tpcd (contrôlés par liste d'accès dans
# <i>/etc/hosts.allow</i> et <i>/etc/hosts.deny</i>).
# Le max_load sur la machine est de 1.0.
# L'option de désactivation est normalement inutilisée mais j'aime l'avoir
# si jamais elle doit être utilisée pour désactiver le service.
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Pour plus d'informations, consultez <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>X</title>
<body>

<p>
XFree est configuré par défaut pour agir comme un serveur X. Cela peut être
dangeureux étant donné que X utilise des connexions tcp qui ne sont pas
cryptées et reste à l'écoute de clients X.
</p>

<impo>
Si vous n'avez pas besoin de ce service, désactivez-le&nbsp;!
</impo>

<p>
Si vous utilisez votre station comme serveur X, utilisez la commande
<path>/usr/X11R6/bin/xhost</path> avec précaution. Cette commande permet aux
clients de se connecter depuis d'autres machines et d'utiliser votre affichage.
Cela peut être utile si vous avez besoin de démarrer une application X depuis
une autre machine et que la seule façon de le faire est depuis le réseau, mais
cela peut aussi être exploité par un attaquant. La syntaxe de cette commande est
<c>/usr/X11R6/bin/xhost +hostname</c>.
</p>

<warn>
N'utilisez jamais la fonctionnalité <c>xhost +</c>&nbsp;! Elle permet à
n'importe quel client de se connecter et de prendre le contrôle de votre
session X. Si un attaquant peut contrôler votre X, il peut alors espionner vos
entrées clavier et contrôler votre bureau.  Si vous devez l'utiliser,
souvenez-vous de toujours spécifier un hôte.
</warn>

<p>
Une solution plus sécurisée est de désactiver cette fonctionnalité complètement
en démarrant votre X avec l'option <c>startx -- -nolisten tcp</c> ou bien en
désactivant complètement cette option dans le fichier de configuration&nbsp;:
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Pour vous assurer que <path>startx</path> ne soit pas écrasé lorsque vous
installez une nouvelle version de XFree, vous devez le protéger.  Ajoutez la
ligne suivante au fichier <path>/etc/make.conf</path>&nbsp;:
</p>

<pre caption="/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Si vous utilisez une invite de connexion graphique, vous devez utiliser une
approche différente.
</p>

<p>Pour <c>gdm</c> (GNOME Display Manager)&nbsp;:</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Pour <c>xdm</c> (X Display Manager) et <c>kdm</c> (KDE Display Manager)&nbsp;:
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Les environnements chroot et les serveurs virtuels</title>

<section>
<title>Utiliser un environnement chroot</title>
<body>

<p>
«&nbsp;Chrooter&nbsp;» un service (ou un utilisateur) est une façon de limiter
son environnement afin qu'il n'accède qu'à l'essentiel sans pouvoir
obtenir un accès (ou des informations) qui pourraient mener aux privilèges
root. En démarrant un service par le biais d'un autre utilisateur que root
(nobody, apache, named), un attaquant ne peut accéder aux fichiers qu'avec les
permissions de cet utilisateur. Cela veut dire qu'un attaquant ne peut obtenir
un accès root même si les services ont une faille de sécurité.
</p>

<p>
Certains services comme pure-ftpd et bind ont des fonctionnalités permettant
d'utiliser chroot, mais pas tous. Si le service le supporte, profitez-en.
Sinon, il vous faudra trouver un moyen de créer le vôtre. Voyons à présent
comment créer un environnement chroot. Pour comprendre les bases, nous allons
expérimenter avec <c>bash</c>. (Ce qui est une façon aisée d'apprendre à
utiliser chroot.)
</p>

<p>
Créez le répertoire <path>/chroot</path> (<c>mkdir /chroot</c>) et cherchez
quelles sont les bibliothèques dynamiques avec lesquelles <c>bash</c> est
compilé (si la compilation a été faite avec le mode <c>-static</c>, ce n'est
pas nécessaire)&nbsp;:
</p>

<p>
La commande suivante va créer une liste des bibliothèques utilisées par
<c>bash</c>.
</p>

<pre caption="Obtenir la liste des bibliothèques utilisées">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Créons à présent un environnement pour <c>bash</c>.
</p>

<pre caption="Création d'un environnement chroot pour bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Copiez ensuite les fichiers utilisés par <c>bash</c> (<path>/lib</path>) dans
le répertoire <path>lib</path> de l'environnement chroot et copiez la commande
bash dans le répertoire <path>bin</path> du chroot. Cela devrait suffire pour
recréer l'environnement, mais avec moins de fonctionnalités. Il ne vous reste
qu'à l'essayer&nbsp;: <c>chroot /chroot/bash /bin/bash</c>. Si vous obtenez une
invite vous donnant <path>/</path>, c'est gagné&nbsp;! Dans le cas contraire, il
devrait vous dire quel est le fichier manquant. Il se peut également que
certaines bibliothèques partagées dépendent d'autres bibliothèques.
</p>

<p>
Vous remarquerez assez vite que, dans le chroot, rien ne marche à part
<c>echo</c>. C'est parce que nous n'avons aucune autre commande dans notre
environnement que bash et qu'<c>echo</c> est une fonction intégrée.
</p>

<p>
La méthode est la même pour créer un service en chroot. La seule différence est
que les services se basent parfois sur des périphériques («&nbsp;devices&nbsp;»)
et des fichiers de configuration dans <path>/etc</path>. Copiez-les tout
simplement (des périphériques peuvent être copiés avec <c>cp -a</c>) vers
l'environnement chroot, éditez le script d'initialisation (init) pour qu'il
utilise chroot avant de s'exécuter.  Il peut être difficile de trouver quels
périphériques et fichiers de configuration sont nécessaires. C'est ici que la
commande <c>strace</c> devient utile. Démarrez le service avec
<c>/usr/bin/strace</c> et notez les fonctions suivantes&nbsp;: open, read, stat
et peut-être connect. Cela devrait vous donner une bonne idée des fichiers à
copier. Dans la plupart des cas, copiez juste le fichier passwd (retirez tous
les utilisateurs qui n'ont aucun rapport avec le service),
<path>/dev/zero</path>, <path>/dev/log</path> et <path>/dev/random</path>.
</p>

</body>
</section>
<section>
<title>Le mode utilisateur Linux («&nbsp;User Mode Linux&nbsp;»)</title>
<body>

<p>
Une autre façon de créer un environnement plus sécurisé est de faire fonctionner
une machine virtuelle. Une telle machine est, comme son nom l'indique, un
processus exécuté par votre véritable système d'exploitation, et qui fournit un
environnement matériel et un système d'exploitation qui donnent l'impression
d'être une machine en soit. Le bénéfice, en ce qui a trait à la sécurité, est
que si le serveur exécuté par la machine virtuelle est compromis, seul le
serveur virtuel est affecté, et non pas l'installation mère.
</p>

<p>
Pour plus d'informations au sujet de l'installation du mode utilisateur Linux,
consultez le <uri link="http://www.gentoo.org/doc/en/uml.xml">User Mode Linux
Guide</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Pare-feu</title>
<section>
<title>Un pare-feu</title>
<body>

<p>
La plupart des gens pensent qu'un pare-feu est la réponse ultime aux problèmes
de sécurité. Ils ont tort. Dans la majorité des cas, avoir un pare-feu mal
configuré présente plus de dangers de sécurité que de ne pas en avoir du tout.
Un pare-feu est un logiciel et doit donc être traité comme tout autre service,
tout simplement car il est susceptible d'avoir des bogues, au même titre que
les autres programmes.
</p>

<p>
Réfléchissez donc bien avant de mettre en placce un pare-feu&nbsp;! En avez-vous
vraiment besoin&nbsp;? Si vous le pensez, écrivez une politique sur son utilité,
son type et qui doit s'en occuper. Mais tout d'abord, lisez ce guide.
</p>

<p>
Les pare-feu sont utilisés dans deux situations&nbsp;:
</p>

<ul>
<li>Pour garder des utilisateurs (vers/attaquants) à l'extérieur.</li>
<li>Pour garder des utilisateurs (employés/enfants) à l'intérieur.</li>
</ul>

<p>
Il existe globalement 3 types de pare-feu&nbsp;:
</p>

<ul>
<li>Filtrage de paquets</li>
<li>Relais de circuit</li>
<li>Passerelle d'application</li>
</ul>

<p>
Un pare-feu devrait être une machine dédiée sans aucun service (ou uniquement
<c>sshd</c>) et sécurisée de la façon qui est recommandée dans ce guide.
</p>

</body>
</section>

<section>
<title>Filtrage de paquets</title>
<body>

<p>
Tout le trafic réseau se fait sous forme de paquets. Une grande partie du
trafic est découpée en petits paquets pour une gestion plus simple. Ils sont
ensuite réassemblés une fois arrivés à leur destination. L'en-tête de chaque
paquet contient des informations sur comment et où il devrait être délivré. Ces
informations sont très exactement ce qu'un pare-feu filtrant les paquets
utilise. Le filtrage se base sur&nbsp;:
</p>

<ul>
<li>
  Autorisation ou interdiction des paquets en se basant sur l'adresse IP
  source/destination.
</li>
<li>
  Autorisation ou interdiction des paquets en se basant sur un port
  source/destination.
</li>
<li>
  Autorisation ou interdiction des paquets selon le protocole.
</li>
<li>
  Autorisation ou interdiction des paquets selon les options établies à
  l'intérieur d'un protocole.
</li>
</ul>

<p>
En d'autres mots, le filtrage se fait sur les données contenues dans l'en-tête
d'un paquet et non pas sur son contenu.
</p>

<p>
Faiblesses&nbsp;:
</p>

<ul>
<li>
  L'adresse IP d'un paquet peut être contrefaite ou, comme le veut le terme
  dédié, <e>spoofée</e> par son envoyeur.
</li>
<li>
  Les données ou requêtes contenues dans le paquet peuvent contenir des données
  indésirables que l'attaquant peut utiliser pour exploiter des bogues connus
  dans les services qui sont sur ou derrière le pare-feu.
</li>
<li>Est généralement un point faible pouvant causer une panne globale.</li>
</ul>

<p>
Avantages&nbsp;:
</p>

<ul>
<li>Simple et facile à implémenter.</li>
<li>
  Peut donner des avertissements sur une attaque possible avant qu'elle
  n'arrive (en détectant les scanneurs de ports).
</li>
<li>Bonne méthode pour arrêter les attaques de type SYN.</li>
</ul>

<p>
Voici quelques exemples de filtreurs de paquets gratuits sous Linux&nbsp;:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri>.</li>
<li><uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>.</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri>.</li>
</ul>

<!--FIXME: should SmoothWall really be included, since it uses iptables?-->

<note>
Nous recommandons d'utiliser iptables. ipchains est obsolète.
</note>

</body>
</section>

<section>
<title>Relais de circuit</title>
<body>

<p>
Aussi appelé passerelle de niveau circuit, ce type de pare-feu valide les
connexions avant d'autoriser l'échange de données. Cela signifie qu'il
n'autorise et ne refuse pas les paquets en fonction de leur en-tête mais
détermine plutôt si une connexion entre les deux parties est valide, en
consultant un ensemble de règles configurables, avant d'autoriser l'ouverture
d'une session de transfert de données. Le filtrage est basé sur&nbsp;:
</p>

<ul>
<li>Adresse de destination/source</li>
<li>Port de destination/source</li>
<li>Un certain laps de temps</li>
<li>Protocole</li>
<li>Utilisateur</li>
<li>Mot de passe</li>
</ul>

<p>
Tout le trafic est validé et surveillé, et peut être bloqué lorsqu'il ne
correspond pas aux règles.
</p>

<p>
Faiblesse&nbsp;:
</p>

<ul>
<li>
  Opère sur la couche de transport et peut nécessiter des modifications
  substantielles des programmes fournissant habituellement les fonctions de
  transport.
</li>
</ul>

</body>
</section>

<section>
<title>Passerelle d'applications</title>
<body>

<p>
La passerelle de niveau application est un mandataire pour les applications,
échangeant des données avec un système distant selon les demandes de ses
clients. Elle est gardée à l'abri du public, en sécurité derrière une DMZ (zone
démilitarisée, la portion de réseau privé visible à travers le pare-feu) ou un
pare-feu sans connexion vers l'extérieur. Le filtrage est basé sur&nbsp;:
</p>

<ul>
<li>
  L'autorisation ou l'interdiction selon les adresses IP source/destination.
</li>
<li>Le contenu des paquets.</li>
<li>
  Limitation de l'accès aux fichiers en fonction du type ou de l'extension.
</li>
</ul>

<p>
Avantages&nbsp;:
</p>

<ul>
<li>
  Peut mettre des fichiers en cache, améliorant ainsi les performances réseau.
</li>
<li>Journal complet et détaillé de toutes les connexions.</li>
<li>
  S'adapte bien aux changements d'échelle (certains serveurs mandataires
  peuvent «&nbsp;partager&nbsp;» les données en cache).
</li>
<li>Aucun accès direct depuis l'extérieur.</li>
<li>Peut même modifier le contenu des paquets en temps réel.</li>
</ul>

<p>
Faiblesses&nbsp;:
</p>

<ul>
<li>Sa configuration est compliquée.</li>
</ul>

<p>
Les passerelles d'applications sont considérées comme les solutions les plus
sécurisées étant donné qu'elles ne doivent pas fonctionner sous root et que
leurs hôtes ne sont pas accessibles depuis Internet.
</p>

<p>
Un exemple de passerelle d'applications est <uri
link="http://www.squid-cache.org/">Squid</uri>.
</p>

</body>
</section>

<section>
<title>Iptables</title>
<body>

<p>
Vous devez activer iptables dans le noyau pour pouvoir l'utiliser.
Je l'ai ajouté en tant que modules (la commande <c>iptables</c> les chargera
lorsqu'elle en a besoin), puis j'ai recompilé mon noyau. (Toutefois, si vous
souhaitez désactiver l'option Loadable Kernel Modules tel que discuté plus tôt,
vous devrez ajouter iptables directement dans le noyau.) Pour plus
d'informations sur la configuration du noyau pour iptables, consultez le <uri
link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables
Tutorial Chapter 2: Preparations</uri>. Après la compilation de votre nouveau
noyau (ou pendant sa compilation), vous devez installer la commande
<c>iptables</c>. Il suffit d'exécuter <c>emerge iptables</c>, et cela
devrait fonctionner.
</p>

<p>
Testez à présent si tout fonctionne avec la commande <c>iptables -L</c>. Si
cette dernière échoue, c'est que quelque chose ne va pas&nbsp;; vérifiez à
nouveau votre configuration.
</p>

<p>
Iptables est le nouveau filtreur de paquets du noyau Linux 2.4.x. Il a été
considérablement amélioré par rapport à son prédécesseur, ipchains, le filtreur
de paquets du noyau Linux 2.2.x. Une des principales améliorations est le
filtrage de paquets par état. Grâce à cette fonction, il est possible de garder
une trace de chaque connexion TCP établie.
</p>

<p>
Une connexion TCP est composée d'une série de paquets contenant des
informations sur les adresses IP et les ports de la source et du destinataire,
ainsi qu'une séquence permettant de réassembler les paquets par la suite, sans
perte de données. TCP est un protocole qui établit une connexion, contrairement
à UDP.
</p>

<p>
En examinant les en-têtes des paquets, un filtre de paquets par état peut
déterminer si un paquet TCP reçu fait partie d'une connexion établie ou non, et
ainsi accepter ou rejeter le paquet.
</p>

<p>
Avec un filtre de paquets sans état, il est possible de leurrer le filtre en
lui faisant accepter des paquets qui devraient être rejetés. Cela se fait en
manipulant les en-têtes des paquets TCP. En modifiant le drapeau SYN (ou
d'autres drapeaux) de l'en-tête TCP, on peut déguiser un paquet mal intentionné
pour qu'il semble faire partie d'une connexion déjà établie (car le filtre de
paquets ne garde pas de trace des connexions). Avec un filtrage par état, il est
possible de rejeter de tels paquets, étant donné qu'ils ne font pas partie d'une
connexion déja établie. Cela empêchera aussi les «&nbsp;scans
invisibles&nbsp;», un type de scanneur de ports qui envoie des paquets dont les
drapeaux sont moins susceptibles d'être consignés par un pare-feu que ceux des
paquets SYN standards.
</p>

<p>
Iptables propose beaucoup d'autres fonctionnalités comme le NAT (Network
Address Translation - traduction d'adresses réseau) et la limitation de flux.
La limitation de flux est très utile quand on essaie de prévenir certaines
attaques de type déni de service (DoS) comme les «&nbsp;SYN floods&nbsp;».
</p>

<p>
Une connexion TCP est établie en trois temps (N.D.T.&nbsp;: «&nbsp;three-way
handshake&nbsp;» en anglais). Quand on établit une connexion TCP, le client
envoie un paquet au serveur avec le drapeau SYN levé.  Quand le serveur reçoit
le paquet SYN, il répond en envoyant un paquet SYN+ACK au client.  Quand le
paquet SYN+ACK est reçu par le client, il répond avec un troisième paquet ACK
qui a pour effet d'établir la connexion.
</p>

<p>
Un attaque «&nbsp;SYN floods&nbsp;» est effectuée en envoyant le paquet SYN mais
en ne répondant pas au paquet SYN+ACK.  Le client peut créer un paquet avec une
adresse IP source falsifiée car il n'a pas besoin de réponse.  Le serveur
ajoute une entrée dans la queue de connexions semi-ouvertes quand il reçoit le
paquet SYN et attend ensuite le paquet ACK final avant de supprimer cette
entrée de la queue. La queue a un nombre de places limité et, si toutes les
places sont occupées, le serveur ne peut plus ouvrir de connexions.  Si le
paquet ACK n'est pas reçu avant un délai spécifié, l'entrée va être
automatiquement supprimée de la queue. Le délai varie, mais se situe typiquement
entre 30 et 60 secondes, voire plus.  Le client initie l'attaque en créant une
énorme quantité de paquets SYN avec des adresses IP sources différentes et les
envoie vers l'IP cible avec le plus haut débit possible. Cela a pour effet de
remplir la queue des connexions semi-ouvertes et empêche les autres clients
d'établir des connexions légitimes avec le serveur.
</p>

<p>
C'est là que la limitation de flux devient utile.  Il est possible de limiter
le flux de paquets SYN acceptés en utilisant <c>-m limit --limit 1/s</c>.  Cela
limitera le nombre de paquets SYN acceptés à un par seconde et réduira donc
l'efficacité du «&nbsp;SYN floods&nbsp;».
</p>

<note>
Les <uri link="http://cr.yp.to/syncookies.html">cookies SYN</uri> sont une autre
option permettant de prévenir les «&nbsp;SYN floods&nbsp;». Ils permettent à
votre ordinateur de répondre aux paquets SYN sans remplir l'espace dans la
queue de connexion. Les cookies SYN peuvent être activés dans la configuration
de noyau Linux, mais ils sont encore, pour l'instant, considérés comme une
fonctionnalité expérimentale.
</note>

<p>
Maintenant un peu de pratique&nbsp;!
</p>

<p>
Lorsque iptables est chargé dans le noyau, il contient 5 sections dans
lesquelles vous pouvez placer vos règles&nbsp;: <c>INPUT</c>, <c>OUTPUT</c>,
<c>FORWARD</c>, <c>PREROUTING</c> et <c>POSTROUTING</c>. Ces sections sont
appelées chaînes car elles consistent en une liste de règles.  Chaque règle
indique ce qu'il faut faire en fonction de l'en-tête du paquet.  Si une règle
ne correspond pas à un paquet, la règle suivante est consultée.
</p>

<p>
Vous pouvez ajouter des règles directement dans une des 5 chaînes ou créer des
chaînes de règles et les ajouter aux chaînes existantes.  Iptables supporte les
options suivantes&nbsp;:
</p>

<table>
  <tr>
    <th>Option&nbsp;:</th><th>Description&nbsp;:</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>Append (ajoute)</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>Delete (efface)</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>Insert (insère)</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>Replace (remplace)</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>List (liste)</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>Efface toutes les règles dans la ou les chaînes</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>Remet les compteurs à zéro dans une ou plusieurs chaînes</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>Teste ce paquet sur une chaîne</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>Crée une chaîne définie par l'utilisateur</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>Efface une chaîne définie par l'utilisateur</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>Change le comportement d'une chaîne sur une cible</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>Change le nom d'une chaîne</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>Protocole</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>Adresse/masque de source</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>Adresse/masque de destination</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>Nom d'entrée (nom ethernet)</ti>
  </tr>
  <tr>
    <ti>-o</ti><ti>Nom de sortie (nom ethernet)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>Saute (cible de règle)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>Correspondance étendue (peut utiliser des extensions)</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>Sortie numérique de ports et d'adresses</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>Table à manipuler</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>Mode bavard</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>Vérifications étendues (affiche les valeurs exactes)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>Prends uniquement en compte le second fragment ou ceux d'après</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>Version du paquet</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>Affiche les numéros de ligne</ti>
  </tr>
</table>

<p>
Nous allons d'abord essayer de bloquer tous les paquets ICMP sur notre machine,
juste dans le but de se familiariser avec les commandes.
</p>

<pre caption="Blocage de tous les paquets ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
On spécifie tout d'abord la chaîne à laquelle notre règle devrait appartenir,
ensuite le protocole des paquets qui nous intéressent, et, enfin, la cible. La
cible peut être le nom d'une chaîne spécifiée par l'utilisateur ou une des
cibles spéciales <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>,
<c>QUEUE</c>, <c>MASQUERADE</c>. Dans cet exemple, nous utilisons <c>DROP</c>,
qui va ignorer le paquet sans répondre au client.
</p>

<note>
La cible <c>LOG</c> est qualifiée de «&nbsp;non-terminatrice&nbsp;»&nbsp;: si
un paquet correspond à une règle utilisant la cible <c>LOG</c>, l'évaluation
des règles n'est pas interrompue&nbsp;; elle se poursuit plutôt avec la règle
suivante. Cela permet de consigner certains paquets sans influer sur leur
gestion.
</note>

<p>
Essayez à présent de faire <c>ping localhost</c>. Vous n'obtiendrez aucune
réponse car iptables ignorera tous les messages ICMP entrants. Vous ne pourrez
pas non plus utiliser ping vers d'autres machines, car les paquets de réponse
ICMP seront également ignorés. Maintenant, vidons la chaîne pour donner à
nouveau libre cours au trafic ICMP.
</p>

<pre caption="Supprimer toutes les règles">
# <i>iptables -F</i>
</pre>

<p>
Regardons maintenant le filtrage par état dans iptables. Si nous désirons
activer l'inspection des paquets entrants sur eth0, la commande à utiliser
est la suivante&nbsp;:
</p>

<pre caption="Accepter les paquets qui proviennent d'une connexion déjà établie">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Cela acceptera tous les paquets provenant d'une connexion déjà établie ou ayant
un rapport avec la chaîne INPUT. Vous pourriez ignorer tous les paquets qui ne
sont pas dans la table des états en faisant <c>iptables -A INPUT -i eth0 -m
state --state INVALID -j DROP</c> juste avant la commande précédente.  Cela
active le filtrage par état dans iptables en chargeant l'extension nommée
«&nbsp;state&nbsp;». Si vous voulez qu'une machine de l'extérieur puisse se
connecter à votre machine, vous pouvez utiliser <c>--state NEW</c>. Iptables
contient des modules correspondant à différentes fonctions. En voici
quelques-uns&nbsp;:
</p>

<table>
  <tr>
    <th>Module</th>
    <th>Description</th>
    <th>Options étendues</th>
  </tr>
  <tr>
    <ti>mac</ti>
    <ti>
      Vérifie que l'extension correspond pour les paquets entrants sur une
      adresse mac.
  </ti>
  <ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti>
    <ti>Active l'inspection des états </ti>
    <ti>--state (les états sont  ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti>
    <ti>Définit une limite sur le flux</ti>
    <ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti>
    <ti>Essaie de trouver des correspondances dans le créateur du paquet </ti>
    <ti>--uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner sessionid</ti>
  </tr>
  <tr>
    <ti>unclean</ti>
    <ti>Plusieurs tests de vérification aléatoires du bon état des paquets</ti>
    <ti />
  </tr>
</table>

<p>
Essayons à présent de créer une chaîne définie par l'utilisateur et de
l'appliquer sur une chaîne existante&nbsp;:
</p>

<pre caption="Création d'une chaîne définie par l'utilisateur">
<codenote>Crée une nouvelle chaîne avec une seule règle.</codenote>
# <i>iptables -X machaine</i>
# <i>iptables -N machaine</i>
# <i>iptables -A machaine -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>La politique par défaut est d'accepter tout le trafic sortant. Tout le
trafic entrant est ignoré.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>Et on ajoute cela à la chaîne INPUT.</codenote>
# <i>iptables -A INPUT -j machaine</i>
</pre>

<p>
En ajoutant cette règle, tout paquet sortant est autorisé et le trafic entrant
est ignoré.
</p>

<p>
Pour plus d'informations, consultez <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">la documentation
sur iptables</uri>.
</p>

<p>
Voyons à présent un exemple complet. Dans ce cas précis, il s'agit de mes
règles de pare-feu/passerelle&nbsp;:
</p>

<ul>
  <li>Connexions au pare-feu uniquement autorisées via SSH (port 22).</li>
  <li>
    Le réseau local doit avoir accès à HTTP, HTTPS et SSH (DNS est également
    autorisé).
  </li>
  <li>
    Le trafic ICMP peut être nocif et devrait être interdit. Évidemment, nous
    devons autoriser un peu de trafic ICMP.
  </li>
  <li>
    Les scanneurs de ports doivent être détectés et leur actions consignées.
  </li>
  <li>Les attaques SYN doivent être évitées.</li>
  <li>Tout autre trafic doit être ignoré et consigné.</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#interne
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#externe
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Paramétrer les règles internes"

  einfo "On ignore tout par défaut"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # Règles par default
  einfo "Créer les chaînes d'état"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  # Trafic ICMP
  einfo "Créer la chaîne icmp"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # Trafic entrant
  einfo "Créer la chaîne de trafic ssh entrant"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  # Protection anti Flood
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -p tcp --dport ssh -j ACCEPT

  # Trafic sortant
  einfo "Créer la chaîne de trafic SSH sortant"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Créer la chaîne de trafic DNS sortant"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \
     -j ACCEPT

  einfo "Créer la chaîne de trafic HTTP/HTTPS sortant"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # Détecter les scanneurs de ports.
  einfo "Créer la chaîne de détection de portscan"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Applique et ajoute les chaînes invalides.
  einfo "Appliquer les chaînes a INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Appliquer les chaînes au FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Appliquer les chaînes à l'OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # Autoriser les clients à router via le NAT (« Network Address Translation »).
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE
  eend $?
}

start() {
  ebegin "Démarrage du pare-feu"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} n'existe pas. Utilisation des règles par defaut."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Arrêt du pare-feu"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Statut"
  $IPTABLES -L -n -v --line-numbers
  einfo "Statut NAT"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Mise en place des règles de panique"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Enregistrement des règles de pare-feu"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Rétablissement des règles précédentes"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      Restaure les paramètres s'ils existent, sinon force les règles."
  echo "stop)       Efface toutes les règles et autorise tout accès."
  echo "rules)      Force les paramètres des nouvelles règles."
  echo "save)       Sauve les paramètres dans ${FIREWALL}."
  echo "restore)    Récupère les paramètres depuis ${FIREWALL}."
  echo "showstatus) Affiche le statut."
}
</pre>

<p>
Quelques conseils pour la création d'un pare-feu&nbsp;:
</p>

<ol>
  <li>Créez la politique de votre pare-feu avant de l'implémenter.</li>
  <li>Faites quelque chose de simple.</li>
  <li>
    Connaissez le fonctionnement de chaque protocole. (Lisez le <uri
    link="http://www.ietf.org/">RFC (Request For Comments)</uri> approprié.)
  </li>
  <li>
    Gardez en tête que votre pare-feu n'est qu'un logiciel qui fonctionne
    sous root.
  </li>
  <li>Testez votre pare-feu.</li>
</ol>

<p>
Si vous pensez que iptables est difficile à comprendre ou vous prendra trop de
temps à configurer, vous pouvez utiliser <uri
link="http://www.shorewall.net">Shorewall</uri>.  Il utilise iptables pour
générer des règles de pare-feu, mais se concentre sur les règles et pas les
protocoles spécifiques.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid est un serveur mandataire très puissant. Il peut filtrer le trafic en
fonction de l'heure, d'une expression rationnelle sur le chemin/URI, d'une
adresse IP source/destination, du domaine, du navigateur, de l'utilisateur,
d'un type MIME ou bien d'un numéro de port (protocole). J'en ai sans doute
oublié d'autres, mais il serait difficile de les énoncer dans leur ensemble
ici.
</p>

<p>
Dans l'exemple suivant, j'ai ajouté un filtre de bannières plutôt qu'un filtre
basé sur du contenu pornographique. La raison pour cela est que Gentoo.org ne
devrait <c>pas</c> être listé comme site à caractère pornographique, et je ne
veux pas perdre mon temps à essayer de vous trouver de bonnes adresses de
sites.
</p>

<p>
Dans cet exemple précis, mes règles sont les suivantes&nbsp;:
</p>

<ul>
  <li>
    Le surf (HTTP/HTTPS) est autorisé pendant les heures de bureau (du lundi au
    vendredi de 8 à 17 heures, et le samedi de 8 à 13 heures), mais si les
    employés restent plus tard, c'est pour travailler et pas pour surfer.
  </li>
  <li>
    Le téléchargement de fichiers est interdit (.exe, .com, .arj, .zip, .asf,
    .avi, .mpg, .mpeg, etc.).
  </li>
  <li>
    N'aimant pas les bannières publicitaires, nous les filtrons et les
    remplaçons par un gif transparent. (C'est ici que vous devenez
    créatif&nbsp;!)
  </li>
  <li>
    Toute autre connexion venant d'Internet ou vers Internet est interdite.
  </li>
</ul>

<p>
Cela se fait en 4 étapes <e>simples</e>&nbsp;:
</p>

<pre caption="/etc/squid/squid.conf">
# Liaison à une adresse IP et un port
http_port 10.0.2.1:3128

# Configuration standard
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Contrôle d'accès standard
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Machines autorisées à accéder à ce serveur
acl localnet src 10.0.0.0/255.255.0.0

# Et les ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Liste d'accès basée sur les expressions rationnelles
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Liste d'accès basée sur les horaires
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Autorise l'administrateur à se connecter depuis la machine locale.
http_access allow manager localhost
http_access deny manager

# Nettoyage de cache autorisé uniquement localement.
http_access allow purge localhost
http_access deny purge

# Refuse les requêtes vers des ports inconnus.
http_access deny !Safe_ports

# Refuse les connexions en dehors du port SSL.
http_access deny CONNECT !SSL_ports

# Mes règles

# Affiche une page quand un bandeau est supprimé.
deny_info NOTE_ADS_FILTERED url_ads

# Puis les refuse.
http_access deny url_ads

# Refuse toutes les archives.
http_access deny archives

# Restreint l'accès aux heures de bureau.
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Refuse le reste.
http_access deny all
</pre>

<p>
Indiquez ensuite les fichiers dont vous ne voulez pas autoriser le
téléchargement. J'ai ajouté&nbsp;: zip, viv, exe, mp3, rar, ace, avi, mov, mpg,
mpeg, au, ra, arj, tar, gz et z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Notez les [] avec une majuscule et une minuscule pour chaque lettre. Cela permet
de ne pas pouvoir tromper notre filtre en téléchargeant un fichier dont
l'extension est AvI plutôt que avi.
</note>

<p>
On ajoute ensuite les expressions rationnelles pour identifier les bannières.
Vous serez sans doute plus créatif que moi&nbsp;:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Et, enfin, on veut afficher un fichier lorsque l'on retire une bannière. Il
s'agit ici d'un fichier html partiel contenant une image gif transparente de
taille 4x4.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>Erreur, l'URL que vous avez demandée est indisponible&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Publicité filtrée !&lt;/H1&gt;
</pre>

<note>
Ne fermez pas les balises &lt;HTML&gt; &lt;BODY&gt;. Squid s'en chargera pour
vous.
</note>

<p>
Comme vous pouvez le constater, Squid a beaucoup de possibilités et est très
efficace dans le filtrage de contenu ainsi qu'en tant que mandataire. Vous
pouvez même utiliser plusieurs serveurs Squid dans des configurations réseau de
grande taille. Le type de configuration que j'ai listé ici devrait convenir à
un réseau de petite taille (entre 1 et 20 utilisateurs).
</p>

<p>
Cependant, combiner le filtrage de paquets (iptables) et un serveur
d'applications (Squid) est probablement la meilleure solution, même si Squid
est situé dans un endroit sécurisé non accessible de l'extérieur. Gardez en
tête que les attaques peuvent aussi venir de l'intérieur.
</p>

<p>
Vous devez maintenant configurer les navigateurs de vos clients pour qu'ils
utilisent le serveur mandataire. La passerelle empêchera les utilisateurs
d'avoir un contact avec l'extérieur, à moins qu'ils n'utilisent le mandataire.
</p>

<note>
Dans Mozilla, vous pouvez modifier le mandataire dans
Edit->Preferences->Advanced->Proxies.
</note>

<p>
Vous pouvez aussi le faire de façon transparente en utilisant iptables pour
renvoyer tout le trafic vers le mandataire Squid. Il suffit pour cela
d'ajouter des règles de pré-routage/«&nbsp;forward&nbsp;» sur la
passerelle&nbsp;:
</p>

<pre caption="Autoriser le « forwarding » de ports vers notre serveur mandataire">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Si le mandataire fonctionne sur l'hôte s'occupant du filtrage des paquets (Bien
que ce ne soit pas recommandé, cela peut être nécessaire si vous ne disposez
pas d'assez de machines pour faire autrement.), utilisez la cible
<c>REDIRECT</c> plutôt que <c>DNAT</c> (<c>REDIRECT</c> dirige les paquets vers
l'hôte local).
</note>

</body>
</section>
<section>
<title>Conclusion de cette leçon</title>

<body>

<p>
Nous avons appris ce qui suit&nbsp;:
</p>

<ol>
  <li>
    Qu'un pare-feu peut représenter un risque s'il est mal configuré et qu'il
    vaut mieux, dans ce cas, n'en avoir aucun.
  </li>
  <li>
    Comment paramétrer un serveur mandataire transparent et une passerelle de
    base.
  </li>
  <li>
    Que la clé d'un bon pare-feu est de connaître le protocole que vous voulez
    autoriser.
  </li>
  <li>
    Que le trafic IP ne contient pas que des données anodines. Des paquets ICMP
    peuvent révéler des informations importantes sur le réseau.
  </li>
  <li>Comment éviter des attaques SYN.</li>
  <li>
    Comment filtrer le trafic HTTP en retirant le chargement d'images ou de
    virus.
  </li>
  <li>
    Que la combinaison pare-feu/serveur mandataire donne le meilleur contrôle.
  </li>
</ol>

<p>
Si vous en avez <b>vraiment</b> besoin, vous pouvez à présent créer un pare-feu
qui répondra à vos besoins.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Détection d'intrusion</title>

<section>
<title>AIDE (Advanced Intrusion Detection Environment)</title>
<body>

<p>
AIDE est un système de détection d'intrusion («&nbsp;Host-Based Intrusion
Detection System&nbsp;» (HIDS)) qui s'installe sur la machine à protéger. C'est
une alternative gratuite à Tripwire. (Si vous connaissez déjà Tripwire, vous
n'aurez aucune difficulté à configurer AIDE.) Les HIDS sont utilisés pour
détecter des changements dans les fichiers importants du système (programmes
binaires et fichiers de configuration), habituellement par calcul d'une somme de
vérification cryptographique unique pour chaque fichier. Les sommes de
vérification sont conservées dans un endroit sûr. Sur une base réguilière (par
exemple une fois par jour), les sommes que l'on considère fiables sont comparées
à celles générés à partir des fichiers présents à ce moment sur le système. On
peut alors déterminer si des fichiers ont été modifiés. Les HIDS sont une
excellente méthode de détection des changements non autorisés qui peuvent avoir
lieu sur votre système. Leur mise en œuvre et leur utilisation nécessite
toutefois quelques efforts.
</p>

<p>
Le fichier de configuration est basé sur des expressions rationnelles, des
macros et des règles concernant les fichiers et répertoires. Nous avons les
macros suivantes&nbsp;:
</p>

<table>
  <tr>
    <th>Macro</th><th>Description</th><th>Syntaxe</th>
  </tr>
  <tr>
    <ti>ifdef</ti><ti>Si défini</ti><ti>@@ifdef "nom"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti><ti>Si non défini</ti><ti>@@ifndef "nom"</ti>
  </tr>
  <tr>
    <ti>define</ti>
    <ti>Définit une variable </ti>
    <ti>@@define "nom" "valeur"</ti>
  </tr>
  <tr>
    <ti>undef</ti>
    <ti>Enlève la définition d'une variable</ti>
    <ti>@@undef "nom"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti><ti>si "nom d'hôte"</ti><ti>@@ifhost "nom hôte"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti><ti>si non "nom d'hôte"</ti><ti>@@ifnhost "nom hôte"</ti>
  </tr>
  <tr>
    <ti>endif</ti>
    <ti>Endif doit être utilisé après chacune des macros ci-dessus à part define et undef</ti>
    <ti>@@endif</ti>
  </tr>
</table>

<p>
Ces macros deviennent très pratiques si vous avez plus d'une machine Gentoo et
désirez utiliser AIDE sur chacune d'entre elles, bien que toutes les machines
n'aient pas les mêmes utilisateurs ou services.
</p>

<p>
Nous devons ensuite vérifier les indicateurs sur les fichiers ou les
répertoires.  Ils sont formés d'une combinaison de permissions, de propriétés
de fichiers et de sommes de vérification.
</p>

<table>
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>p</ti><ti>Permissions</ti>
  </tr>
  <tr>
    <ti>i</ti><ti>inode</ti>
  </tr>
  <tr>
    <ti>n</ti><ti>Nombre de liens</ti>
  </tr>
  <tr>
    <ti>u</ti><ti>Utilisateur</ti>
  </tr>
  <tr>
    <ti>g</ti><ti>Groupe</ti>
  </tr>
  <tr>
    <ti>s</ti><ti>Taille</ti>
  </tr>
  <tr>
    <ti>b</ti><ti>Nombre de blocs</ti>
  </tr>
  <tr>
    <ti>m</ti><ti>mtime</ti>
  </tr>
  <tr>
    <ti>a</ti><ti>atime</ti>
  </tr>
  <tr>
    <ti>c</ti><ti>ctime</ti>
  </tr>
  <tr>
    <ti>S</ti><ti>Vérifie si la taille augmente</ti>
  </tr>
  <tr>
    <ti>md5</ti><ti>Somme de vérification md5</ti>
  </tr>
  <tr>
    <ti>sha1</ti><ti>Somme de vérification sha1</ti>
  </tr>
  <tr>
    <ti>rmd160</ti><ti>Somme de vérification rmd160</ti>
  </tr>
  <tr>
    <ti>tiger</ti><ti>Somme de vérification tiger</ti>
  </tr>
  <tr>
    <ti>R</ti><ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
    <ti>L</ti><ti>p+i+n+u+g</ti>
  </tr>
  <tr>
    <ti>E</ti><ti>Groupe vide</ti>
  </tr>
  <tr>
    <ti>&gt;</ti><ti>Taille du fichier journal en augmentation p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
Et, si AIDE est compilé avec le support mhash, vous disposerez également
de&nbsp;:
</p>

<table>
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>haval</ti><ti>Somme de vérification haval</ti>
  </tr>
  <tr>
    <ti>gost</ti><ti>Somme de vérification gost</ti>
  </tr>
  <tr>
    <ti>crc32</ti><ti>Somme de vérification crc32</ti>
  </tr>
</table>

<p>
Vous pouvez à présent créer vos propres règles en combinant les indicateurs
de cette façon&nbsp;:
</p>

<pre caption="Créer un ensemble de règles pour AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
La dernière chose dont nous avons besoin pour créer notre propre fichier de
configuration est de comprendre comment ajouter une règle à un fichiers ou un
répertoire. Pour ce faire, combinez le nom du fichier ou du répertoire et celui
de la règle. AIDE ajoutera les fichiers récursivement à moins que vous ne
précisiez une règle différente.
</p>

<table>
  <tr>
    <th>Indicateur</th><th>Description</th>
  </tr>
  <tr>
    <ti>!</ti><ti>Ne pas ajouter ce fichier ou répertoire.</ti>
  </tr>
  <tr>
    <ti>=</ti><ti>Ajouter ce répertoire mais sans récursion.</ti>
  </tr>
</table>

<p>
Regardons à présent l'exemple complet&nbsp;:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# L'endroit où lire la base de données.
database=file:@@{AIDEDIR}/aide.db

# L'endroit où inscrire la base de données.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Définition des règles
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
Dans l'exemple ci-dessus, nous spécifions avec quelques macros l'emplacement des
répertoires racines et du répertoire de AIDE. AIDE consulte
<path>/etc/aide/aide.db</path> lorsqu'il vérifie l'intégrité d'un fichier.
Toutefois, lors de la mise à jour ou de la création d'un fichier, l'information
est conservée dans <path>/etc/aide/aide.db.new</path>. Cela permet d'éviter
d'écraser automatiquement le fichier de la base de données précédente. L'option
<c>report_URL</c> n'est pas encore implémentée, mais l'intention de l'auteur
était de permettre l'envoi d'un courriel ou l'exécution de scripts.
</p>

<p>
Après avoir fini la configuration, vous pouvez créer le fichier de base de
données en exécutant <c>aide -i</c>. Puis, copiez le fichier
<path>/etc/aide/aide.db.new</path> vers <path>/etc/aide/aide.db</path> et
ajoutez la vérification dans cron en faisant <c>crontab -e</c> en tant que root.
</p>

<note>
En fonction des indicateurs que vous avez mis, de la puissance de votre
processeur et de la rapidité d'accès à votre disque dur, cela peut prendre un
certain temps d'exécution.
</note>

<pre caption="Programmer AIDE en tâche cron">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
Rappelez-vous de paramétrer un alias pour le courrier électronique de root.
Sinon, il y a des chances que vous ne receviez jamais ce qu'AIDE vous envoie.
</note>

<p>
Dans cet exemple, il démarre tout seul à 3 heures. Cela évite de déranger les
utilisateurs lorsqu'ils travaillent. Notez également que j'utilise l'option
<c>-u</c> (mise à jour) au lieu de <c>-C</c> (vérification). Étant donné que
<c>-u</c> vérifie aussi le fichier et n'écrase pas la base de données
originale, cela devrait accélerer la procédure car vous n'avez plus qu'à copier
le fichier lorsqu'un changement est détecté. Avant de copier, vérifiez les
changements pour vous assurer que c'est bien vous qui les avez faits et pas un
attaquant&nbsp;!
</p>

<p>
Il existe des risques inhérents à l'utilisation d'une base de données locale.
Si un attaquant sait qu'AIDE est installé, il essaiera de corrompre la base ou
de modifier <path>/usr/bin/aide</path>. Vous devriez donc utiliser un CD (ou
un autre média) pour y copier le fichier .db ainsi que les fichiers binaires
d'AIDE.
</p>

<p>
Pour plus d'informations, consultez la page du projet <uri
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort est un système de détection d'intrusion sur le réseau. Pour l'installer
et le configurer, utilisez les exemples suivants.
</p>

<pre caption="Ajouter un utilisateur snort au système">
# user add snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CO NF=/etc/snort/snort.Cong
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>Étape 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Étape 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>Étape 3</codenote>
include classification.config

<codenote>Étape 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NOUVELLES CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Pour plus d'informations, consultez le site de <uri
link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>
<section>
<title>Détecter les logiciels malfaisants avec chkrootkit</title>

<body>

<p>
Les HIDS tels que AIDE sont d'excellents outils pour détecter les changements
apportés à votre système, mais disposer d'une ligne de défense supplémentaire
ne peut pas vous nuire. <c>chkrootkit</c> est un utilitaire servant à scanner
les fichiers système classiques pour y repérer des «&nbsp;rootkits&nbsp;»
(des logiciels conçus pour dissimuler les actions d'un intrus et lui
permettre de conserver son accès). <c>chkrootkit</c> scanne aussi votre système
pour y repérer des logiciels malfaisants, par exemple des programmes servant à
espionner vos entrées clavier. Bien que <c>chkrootkit</c> et ses alternatives
(tel que <c>rkhunter</c>) soient des outils précieux à la fois pour la
maintenance d'un système et pour le repérage des intrus après une attaque, ils
ne peuvent garantir la sécurité de votre système.
</p>

<p>
La meilleure façon d'utiliser <c>chkrootkit</c> pour détecter une intrusion est
de l'exécuter régulièrement à partir de <c>cron</c>. Tout d'abord, exécutez
<c>emerge app-admin/chkrootkit</c>. <c>chkrootkit</c> peut être exécuté en
tapant la commande du même nom, ou à partir de <c>cron</c> grâce à une entrée
comme celle qui suit&nbsp;:
</p>

<pre caption="Planifier l'exécution de chkrootkit en tant que tâche cron">
0 3 * * * /usr/sbin/chkrootkit
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Rester à jour</title>
<section>
<body>

<p>
Une fois votre système installé, configuré et protégé, votre tâche est loin
d'être terminée. Sécuriser un système est un travail constant&nbsp;; la vaste
majorité des intrusions résultent de l'exploitation de failles connues
présentes dans des systèmes où les correctifs appropriés n'ont pas été
appliqués. Garder votre système à jour est ce qu'il y a de plus important pour
assurer un niveau de sécurité élevé.
</p>

<p>
Avec une version récente de Portage, vous pouvez synchroniser votre arbre
Portage avec la commande <c>emerge --sync</c> et ensuite lancer <c>glsa-check
--list</c> pour vérifier si votre système est à jour en ce qui concerne la
sécurité.
</p>

<pre caption="Exemple d'affichage de glsa-check -l">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.

[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
L'outil <c>glsa-check</c> est encore en test. Si la sécurité est un point
critique de votre installation, veuillez vérifier la liste avec une autre
source.
</warn>

<p>
Les lignes qui commencent par <c>[A]</c> ou <c>[U]</c> peuvent être ignorées
sans risque, car le système n'est pas concerné par ces failles.
</p>

<p>
Comme certains utilisateurs préfèrent encore utiliser la commande <c>emerge
le_paquet</c> au lieu de <c>glsa-check -f</c>, toutes les alertes GLSA sont
affichées avec un <c>[N]</c>.
</p>

<p>
Si vous désirez recevoir un courriel à chaque annonce GLSA, inscrivez-vous à
la liste de diffusion <c>gentoo-announce</c>. Les instructions pour vous y
inscrire se trouvent sur notre <uri link="/main/en/lists.xml">page
des listes de diffusion</uri> (en anglais). Vous y trouverez aussi d'autres
listes très intéressantes.
</p>

<p>
Une autre source d'informations précieuses sur la sécurité est la <uri
link="http://www.securityfocus.com/archive/1">liste de diffusion Bugtraq</uri>
(en anglais).
</p>

</body>
</section>
</chapter>
</guide>

