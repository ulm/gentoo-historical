<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/power-management-guide.xml,v 1.1 2004/10/14 17:10:43 neysx Exp $ -->
<guide link="/doc/fr/power-management-guide.xml" lang="fr">
<title>Guide de la gestion de l'alimentation</title>

<author title="Auteur">
  <mail link="fragfred@gmx.de">Dennis Nienh&#252;ser</mail>
</author>
<author title="Traducteur">
  <mail link="ribosome@gentoo.org">Olivier Fisette</mail>
</author>

<abstract>
La gestion de l'alimentation est la clé pour améliorer la durée de vie de la
batterie équipant les systèmes mobiles tels les portables. Ce guide vous
aidera à paramétrer la gestion de l'alimentation sur votre portable.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.17</version>
<date>10 octobre 2004</date>

<chapter>
<title>Introduction</title>

<section>
<title>Pourquoi une gestion de l'alimentation&nbsp;?</title>
<body>

<p>
La capacité et la durée de vie des batteries des portables se sont améliorées
considérablement pendant les dernières années. Toutefois, les processeurs
d'aujourd'hui consomment bien plus d'énergie que leurs prédécesseurs et chaque
génération de portables introduit de nouveaux composants énergivores. C'est
pourquoi la gestion de l'alimentation est plus importante que jamais. Améliorer
l'autonomie ne signifie pas nécessairement acheter une deuxième batterie&nbsp;;
l'utilisation de politiques logicielles intelligentes a un impact
considérable.
</p>

</body>
</section>
<section>
<title>Vue d'ensemble</title>
<body>

<p>
Veuillez noter que ce guide s'intéresse à la gestion de l'alimentation pour les
<e>portables</e>. Même si certaines sections peuvent peut-être s'appliquer aux
<e>serveurs</e>, d'autres ne s'y appliquent pas et peuvent même être nuisibles.
N'essayez pas de mettre en pratique les conseils de ce guide avec un serveur, à
moins que vous ne sachiez vraiment ce que vous faites.
</p>

<p>
Dans sa version actuelle, ce guide est plutôt long. Le paragraphe suivant
résume son contenu afin de vous aider à y trouver ce que vous chercher.
</p>

<p>
Le chapitre sur les <e>prérequis</e> vous informe des actions qui doivent être
entreprises avant de pouvoir utiliser les conseils relatifs à des composants
particuliers présentés dans les autres sections. Cela inclut la configuration
du BIOS et du noyau ainsi que des idées pour simplifier la gestion du côté
utilisateur. Les trois chapitres suivants se concentrent sur les composants
qui, typiquement, consomment le plus d'énergie&nbsp;: le processeur, l'écran et
le disque dur. Chacun d'eux peut être paramétré indépendamment. Le chapitre
<e>Gestion de l'alimentation pour l'unité centrale</e> décrit comment ajuster
la fréquence du processeur afin de maximiser l'économie d'énergie sans
sacrifier les performances. Vous apprendrez comment éviter que votre disque dur
ne consomme de l'énergie pour un travail inutile dans le chapitre <e>Gestion de
l'alimentation pour le disque dur</e> (un effet secondaire agréable est la
réduction du niveau de bruit de votre machine). Quelques notes sur les cartes
réseau sans fil et les périphériques USB (dans le chapitre <e>Gestion de
l'alimentation pour les autres composants</e>) terminent la section dédiée à
des composants spécifiques. Le chapitre qui suit s'intéresse aux <e>états de
veille</e> (mais leur support est expérimental). Pour conclure, le chapitre
<e>Résolution des problèmes</e> dresse une liste des pièges à éviter.
</p>

</body>
</section>
<section>
<title>Budget énergétique des composants</title>
<body>

<figure link="/images/energy-budget.png" short="Quel composant consomme le plus d'énergie" caption="Budget énergétique des composants"/>

<p>
Presque tous les composants peuvent opérer dans différents états (hors
tension, en veille, inactif, etc.)&nbsp;; leur consommation d'énergie variera
selon cet état. Les composants les plus gourmands sont l'écran à cristaux
liquides, l'unité centrale, le jeu de composants de la carte-mère et le disque
dur. Il est parfois possible, grâce au BIOS, d'activer une politique de gestion
de l'alimentation indépendante du système d'exploitation. Toutefois, une
gestion intelligente de l'alimentation par le système d'exploitation est
beaucoup plus efficace et s'adapte plus aisément à une variété de situations.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prérequis</title>
<section>
<title>Les premières étapes</title>
<body>

<p>
Avant de s'intéresser à la gestion de l'alimentation pour des composants
particuliers, vous devez vous assurer que votre système remplisse certaines
conditions. Après la configuration du BIOS, quelques options du noyau devront
être activées (en bref, ce sont l'ACPI, les états de veille et l'échelonnage de
la fréquence de l'unité centrale (en anglais «&nbsp;CPU frequency
scaling&nbsp;»)). Puisque les économies d'énergie sont habituellement
accompagnées de baisses de performances, il faut s'assurer de n'activer cette
gestion que lorsque le portable utilise la batterie. C'est ici qu'un nouveau
niveau d'exécution nommé <e>battery</e> se révélera fort utile.
</p>

</body>
</section>
<section>
<title>Préparer le BIOS</title>
<body>

<p>
Jetez d'abord un coup d'œil aux paramètres de gestion de l'alimentation de votre
BIOS. L'idéal serait de combiner les capacités du BIOS et du système
d'exploitation, mais, pour l'instant, il est préférable de désactiver la gestion
de l'alimentation par le BIOS. Cela nous assure que les politiques de ce dernier
n'interfèreront pas avec celles du système d'exploitation. N'oubliez pas de
vérifier à nouveau les paramètres du BIOS une fois que vous aurez configuré
tout le reste.
</p>

</body>
</section>
<section>
<title>Configurer le noyau</title>
<body>

<p>
Le support pour l'ACPI (sigle anglais pour «&nbsp;Advanced Configuration and
Power Interface&nbsp;») dans le noyau Linux est actuellement en cours de
développement. Utiliser un noyau récent vous assurera le meilleur support
possible.
</p>

<p>
Dans l'utilitaire de configuration du noyau, activez ces options&nbsp;:
</p>

<pre caption="Configuration minimale du noyau pour la gestion de l'alimentation (noyau 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    &lt;M&gt;   AC Adapter
    &lt;M&gt;   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>Pilote CPUFreq approprié pour votre processeur</i>
</pre>

<p>
Décidez vous-même si vous souhaitez activer les options «&nbsp;Software
Suspend&nbsp;», «&nbsp;Suspend-to-Disk&nbsp;» et «&nbsp;Sleep States&nbsp;»
(voyez ci-dessous). Si vous possédez un portable de marque ASUS, Medion ou
Toshiba, activez l'option appropriée.
</p>

<p>
Compilez votre noyau, assurez-vous que les modules appropriés seront chargés
lors du démarrage et amorcez votre nouveau noyau avec support ACPI. Ensuite,
exécutez <c>emerge sys-apps/acpid</c> pour installer le démon acpi. Ce dernier
vous informe des événements tels que le changement de la source du courant
lorsque l'adaptateur est branché ou débranché, ou encore la fermeture du
boîtier du portable. Assurez-vous que le module <e>button</e> est chargé (si
vous ne l'avez pas compilé dans le noyau) et lancez acpid avec la commande
<c>/etc/init.d/acpid start</c>. Exécutez <c>rc-update add acpid default</c>
pour qu'il soit lancé lors du démarrage. Vous verrez bientôt comment l'utiliser.
</p>

<pre caption="Installer acpid">
# <i>emerge sys-apps/acpid</i>
# <i>modprobe button</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Créer le niveau d'exécution battery</title>
<body>

<p>
La politique par défaut est d'activer la gestion de l'alimentation seulement
lorsque cela est nécessaire&nbsp;: lorsque vous utilisez la batterie. Pour
simplifier la gestion du changement entre l'adaptateur et la batterie, créez un
niveau d'exécution nommé <e>battery</e> qui contiendra des références à tous les
scripts servant à démarrer et arrêter la gestion de l'alimentation.
</p>

<note>
Vous pouvez ignorer cette section en toute sécurité si vous n'aimez pas l'idée
de créer un autre niveau d'exécution. Toutefois, les étapes subséquentes
deviendront plus complexes, car les sections qui suivent supposent qu'il
existe un niveau d'exécution <e>battery</e>.
</note>

<pre caption="Créer le niveau d'exécution battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
C'est terminé. Votre nouveau niveau d'exécution <e>battery</e> contient tout ce
que <e>default</e> contient, mais il n'existe pas encore de mécanisme pour
passer de l'un à l'autre. Nous allons maintenant remédier à cela.
</p>

</body>
</section>
<section>
<title>Réagir aux événements ACPI</title>
<body>

<p>
Des événements ACPI typiques sont la fermeture du boîtier, le branchement ou le
débranchement de l'adaptateur et la pression du bouton de mise en veille.
Chaque événement ACPI est reconnu par le noyau puis passé à acpid qui exécute
<path>/etc/acpi/default.sh</path>. Voici une simple modification à apporter à
ce fichier, et qui permet de changer le niveau d'exécution.
</p>

<pre caption="Changement du niveau d'exécution en réaction à un événement ACPI avec acpid">
#!/bin/sh

set $*

group=${1/\/*/}
action=${1/*\//}

<comment># Niveau d'exécution lorsque l'adaptateur est branché.</comment>
RLVL_AC="default"
<comment># Niveau d'exécution lorsque la batterie est utilisée.</comment>
RLVL_BATTERY="battery"

<comment># Fichier indiquant l'état de l'adaptateur. Vérifiez ce nom de fichier avant de procéder.</comment>
AC_STATE="/proc/acpi/ac_adapter/AC/state"
<comment># Chaîne de caractère qui indique que l'adaptateur est utilisé.</comment>
AC_ON="on-line"
<comment># Chaîne de caractère qui indique que la batterie est utilisée.</comment>
AC_OFF="off-line"

function SwitchRunlevel() {
  if [[ "$(grep ${AC_OFF} ${AC_STATE})" != "" &amp;&amp; "$(cat /var/lib/init.d/softlevel)" != "${RLVL_BATTERY}" ]]
  then
    logger "Switching to ${RLVL_BATTERY} runlevel"
    /sbin/rc ${RLVL_BATTERY}
  elif [[ "$(grep ${AC_ON} ${AC_STATE})" != "" &amp;&amp; "$(cat /var/lib/init.d/softlevel)" != "${RLVL_AC}" ]]
  then
    logger "Switching to ${RLVL_AC} runlevel"
    /sbin/rc ${RLVL_AC}
  fi
}


case "$group" in
  battery)
    case "$action" in
      battery)
        SwitchRunlevel
        ;;
      *)
        logger "ACPI group battery / action $action is not defined"
        ;;
    esac
    ;;

  ac_adapter)
    case "$action" in
      ac_adapter)
        SwitchRunlevel
        ;;
      *)
        logger "ACPI group ac_adapter / action $action is not defined"
        ;;
    esac
    ;;
  *)
    logger "ACPI group $group / action $action is not defined"
    ;;
esac
</pre>

<p>
Faites un essai&nbsp;: branchez et débranchez l'adaptateur et consultez les
messages de syslog. Vous devriez y voir «&nbsp;Switching to AC mode&nbsp;» et
«&nbsp;Switching to battery mode&nbsp;».
</p>

<p>
À cause de la nature du mécanisme de gestion des événements, votre portable
démarrera toujours avec le niveau <e>default</e> sans égard à l'état réel de
l'adaptateur. Vous pourriez ajouter à votre chargeur de démarrage une nouvelle
entrée contenant <c>softlevel=boot</c>, mais il y a une meilleure façon de
faire&nbsp;: il est possible de simuler un événement acpi à la fin du processus
de démarrage et de laisser le script <path>/etc/acpi/default.sh</path> décider
si un changement de niveau d'exécution est nécessaire. Ouvrez
<path>/etc/conf.d/local.start</path> dans votre éditeur favori et ajoutez ces
lignes&nbsp;:
</p>

<pre caption="Éditer local.start pour implémenter le changement de niveau d'exécution lors du démarrage">
<comment># Simule un événement ACPI pour changer de niveau d'exécution
# si le portable fonctionne avec la batterie.</comment>
/etc/acpi/default.sh "battery/battery"
</pre>

<p>
Vous êtes maintenant prêt à activer les politiques individuelles de gestion de
l'alimentation pour chaque composant.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour l'unité centrale</title>
<section>
<title>Ajuster la fréquence manuellement</title>
<body>

<p>
Diminuer la vitesse et le voltage du processeur réduit à la fois la
consommation d'énergie et le dégagement de chaleur (votre portable ne deviendra
donc pas aussi chaud que lorsque vous l'utilisez à pleine puissance).  Le
principal désavantage est évidemment une diminution des performances.  Réduire
la vitesse du processeur revient à tronquer les performances contre des gains
énergétiques.
</p>

<note>
Tous les portables ne supportent pas l'échelonnage de la fréquence. Pour être
sûr, consultez la liste des processeurs supportés dans la section <e>Résolution
des problèmes</e>.
</note>

<p>
Il est temps de vérifier si l'échelonnage de la fréquence fonctionne. Afin de
vous familiariser avec l'interface du noyau, apportez d'abord quelques
modifications manuelles à la vitesse du processeur. Pour définir une nouvelle
fréquence, faites&nbsp;:
</p>

<pre caption="Modifications manuelles de la vitesse du processeur">
<comment>(Consultez la fréquence actuelle.)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>

<comment>(Obtenez une liste des fréquences supportées. Cela peut ne pas marcher.)</comment>
# <i>cd /sys/devices/system/cpu/cpu0/cpufreq/</i>
# <i>cat scaling_available_frequencies</i>

<comment>(Changez la fréquence à 1 GHz (1000000 KHz).
Remplacez ce nombre par une fréquence disponible pour votre processeur.)</comment>
# <i>echo -n userspace > scaling_governor</i>
# <i>echo -n 1000000 > scaling_setspeed</i>

<comment>(Vérifiez que le changement a bel et bien eu lieu.)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
Si vous obtenez des messages d'erreurs, référez-vous à la section <e>Résolution
des problèmes</e> (à la fin de ce guide).
</p>

<p>
Vous pouvez aussi écrire dans <path>scaling_max_freq</path> et
<path>scaling_min_freq</path> afin de définir des balises qui limiteront la
fréquence à une plage donnée.
</p>

<note>
Certains noyaux semblent bogués en ce qui concerne la mise à jour de
<path>/proc/cpuinfo</path>. Si vous ne voyez pas de changement à cet endroit,
cela n'implique pas que la fréquence n'a pas changé. Si cela vous arrive,
exécutez <c>emerge x86info</c>, mettez à jour votre noyau et vérifiez la
fréquence avec la commande <c>x86info -mhz</c>.
</note>

</body>
</section>
<section>
<title>Adaptation automatique de la fréquence</title>
<body>

<p>
Ce qui précède est amusant, mais peu pratique dans la vie de tous les jours.
Mieux vaut laisser à votre système le soin de gérer automatiquement la
fréquence. Il existe plusieurs programmes utilisateur permettant de le faire.
Le tableau suivant résume les fonctionnalités de chacun pour faciliter votre
choix.
</p>

<table>
<tr>
  <th>Nom</th>
  <th>Points forts</th>
  <th>Points faibles</th>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Supporte aussi l'arrêt des disques durs.</ti>
  <ti></ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreq</uri></ti>
  <ti>Peut être paramétré de façon très sophistiquée.</ti>
  <ti>Sa mise en place est compliquée.</ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>
    Petit mais puissant<br />
    Interface client/serveur utile
  </ti>
  <ti>Ne fonctionne qu'avec les noyaux 2.6.</ti>
</tr>
<tr>
  <ti><uri link="http://www.deater.net/john/powernowd.html">powernowd</uri></ti>
  <ti>Supporte SMP.</ti>
  <ti></ti>
</tr>
</table>

<p>
Bien qu'ajuster la fréquence semble simple à première vue, ce n'est pas une
tâche triviale. Un mauvais algorithme peut changer constamment la fréquence ou
gaspiller de l'énergie en choisissant une fréquence trop élevée.
</p>

<p>
Lequel choisir&nbsp;? Si vous êtes embêté, essayez d'abord
<c>speedfreq</c>&nbsp;:
</p>

<pre caption="Installer speedfreq">
# <i>emerge speedfreq</i>
# <i>rc-update add speedfreq battery</i>
</pre>

<p>
La configuration de <c>speedfreq</c> se fait avec le fichier
<path>/etc/conf.d/speedfreq</path>. Par exemple, si vous voulez que les
utilisateurs puissent modifier la politique, changez <c>SPEEDFREQ_OPTS=""</c>
pour <c>SPEEDFREQ_OPTS="-u"</c>. Une fois vos changements apportés, démarrez le
démon.
</p>

<pre caption="Démarrer speedfreq">
# <i>/etc/init.d/speedfreq start</i>
</pre>

<p>
Configurer cpufreq est un peu plus complexe.
</p>

<warn>
N'exécutez pas plus d'un de ces programmes à la fois. Autrement, votre système
pourrait avoir un comportement erratique dû notamment à des changements
inutiles et répétés entre deux fréquences. Si vous avez installé speedfreq,
ignorez les directives relatives à cpufreq.
</warn>

<pre caption="Installer cpufreqd">
# <i>emerge cpufreqd</i>
# <i>rc-update add cpufreqd battery</i>
</pre>

<p>
<c>cpufreqd</c> est accompagné du fichier de configuration
<path>/etc/cpufreqd.conf</path>.
Modifiez ce fichier en fonction de vos besoins. L'exemple suivant est plus
économe en matière d'énergie que la configuration par défaut, au détriment des
performances, bien sûr.
</p>

<pre caption="Exemple de configuration pour cpufreqd">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
<comment># Décommentez ce qui suit pour activer le contournement de l'ACPI. (Voir cpufreqd.conf(5).)
# acpi_workaround=1</comment>
verbosity=4 <comment>#(Si vous souhaitez une journalisation minimale, utilisez 5.)</comment>

<comment># Meilleures performances</comment>
[Profile]
name=ac
minfreq=600000
maxfreq=1400000
policy=performance

<comment># Économie d'énergie maximale</comment>
[Profile]
name=battery
minfreq=600000
maxfreq=900000
policy=powersave

<comment># Fréquence constante</comment>
[Profile]
name=dvd
minfreq=900000
maxfreq=1100000
policy=powersave

<comment># Meilleures performances lorsque l'adaptateur est branché.</comment>
[Rule]
name=ac_on
ac=on
profile=ac

<comment># Compilation rapide lorsque l'état de la batterie le permet.</comment>
[Rule]
name=compiling
ac=off
battery_interval=30-100
programs=emerge,make,gcc,cpp
cpu_interval=0-100
profile=ac

<comment># La qualité peut être inacceptable lors de la lecture de DVD si la fréquence
# du processeur est faible. Cela peut s'appliquer aussi aux jeux et à d'autres programmes.</comment>
[Rule]
name=dvd_watching
ac=off
battery_interval=15-100
programs=xine,mplayer,avidemux,kaffeine,kmplayer
cpu_interval=0-100
profile=dvd

<comment># Si les règles précédentes ne s'appliquent pas, maximiser l'économie d'énergie.</comment>
[Rule]
name=battery_on
ac=off
battery_interval=0-100
cpu_interval=0-100
profile=battery
</pre>

<p>
<c>cpudyn</c> et <c>powernowd</c> s'installent de la même façon que
<c>speedfreq</c>.
</p>

<p>
La dernière chose à faire est de vérifier si vos politiques fonctionnent
correctement. Vous pouvez le faire en surveillant la vitesse de l'unité
centrale pendant que vous travaillez avec votre portable.
</p>

<pre caption="Surveiller la vitesse du processeur">
# <i>watch -n 1 grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
Si <path>/proc/cpuinfo</path> n'est pas mis à jour (tel que mentionné
précédemment), surveillez votre processeur avec&nbsp;:
</p>

<pre caption="Méthode alternative pour surveiller la vitesse du processeur">
# <i>watch -n 1 x86info -mhz</i>
</pre>

<p>
Selon votre configuration, la vitesse de votre processeur devrait augmenter
lorsque la charge est élevée et diminuer (ou rester constante) lorsqu'il n'y a
pas d'activité.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour l'écran à cristaux liquides</title>
<section>
<title>Le consommateur d'énergie numéro 1</title>
<body>

<p>
Comme vous pouvez le voir à la <uri link="#doc_chap1_fig1">figure 1.1</uri>,
l'écran à cristaux liquides est le composant le plus énergivore. (Soulignons
que ce n'est pas nécessairement le cas pour les portables équipés de
processeurs qui ne sont pas de type mobile.) Il n'est donc pas seulement
important de fermer l'écran lorsque l'on ne s'en sert pas, mais il faut aussi
réduire la luminosité lorsque possible. La plupart des portables permettent de
contrôler la luminosité.
</p>

<p>
La première chose à faire est de vérifier les délais de pause, de suspension et
de mise hors tension. Puisque cela dépend essentiellement de votre gestionnaire
de fenêtres, ce sera à vous de découvrir comment vous y prendre. Voici deux
façons de faire classiques. D'abord, les commandes
<c>setterm -blank &lt;nombre-de-minutesM&gt;</c>, <c>setterm -powersave on</c>
et <c>setterm -powerdown &lt;nombre-de-minutesM&gt;</c> permettent de gérer
l'extinction de l'écran. Ensuite, si vous utilisez Xorg, vous pouvez modifier
le fichier <path>/etc/X11/xorg.conf</path> pour y incorporer ce qui suit&nbsp;:
</p>

<pre caption="Extinction de l'écran avec Xorg et XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># L'écran devient noir après 5 minutes. (Mais il n'est pas vraiment arrêté.)</comment>
  Option  "StandbyTime"  "10"  <comment># Met l'écran en pause après 10 minutes (utilise DPMS).</comment>
  Option  "SuspendTime"  "20"  <comment># Suspend l'écran après 20 minutes.</comment>
  Option  "OffTime"  "30"  <comment># Extinction complète après 30 minutes.</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
La même procédure s'applique à XFree86 et <path>/etc/X11/XF86Config</path>.
</p>

<p>
Le réglage de la luminosité est probablement plus important encore. Si vous
pouvez modifier ce paramètre avec un outil logiciel, écrivez un script qui
réduit la luminosité lorsque la batterie est utilisée et ajoutez-le à votre
niveau d'exécution <e>battery</e>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour le disque dur</title>
<section>
<title>Mettre en veille lorsqu'il n'y a pas d'activité</title>
<body>

<p>
Essayons de mettre en veille le disque dur aussi vite que possible dès qu'il
n'est pas nécessaire d'y accéder. Voici deux méthodes. La première emploie
l'outil <c>cpudyn</c> qui peut gérer l'économie d'énergie pour les disques
durs. Décommentez les lignes de la section «&nbsp;Disk Options&nbsp;» dans
<path>/etc/conf.d/cpudyn</path>. Pour mettre en veille votre premier disque dur
après 60 secondes d'inactivité, procédez comme suit&nbsp;:
</p>

<pre caption="Utiliser cpudyn pour l'interruption des disques">
<comment>################################################
# DISK OPTIONS
# (disabled by default)
################################################

#
# Timeout to put the disk in standby mode if there was no
# io during that period (in seconds)
#
</comment>
TIMEOUT=60
<comment>
#
# Specified disks to spindown (comma separated devices)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
La deuxième méthode utilise un petit script et le programme hdparm. Créez le
fichier <path>/etc/init.d/pm.hda</path> et copiez-y ce qui suit&nbsp;:
</p>

<pre caption="Utiliser hdparm pour la mise en veille des disques">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Consultez <c>man hdparm</c> pour en connaître les options. Lorsque votre script
est prêt, ajoutez-le au niveau d'exécution battery.
</p>

<pre caption="Automatiser la mise en veille des disques">
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Soyez précautionneux lorsque vous décidez des délais pour l'arrêt de votre
disque dur. Utiliser des temps très courts pourrait user votre disque et
invalider votre garantie.
</impo>

</body>
</section>
<section>
<title>Augmenter le temps d'inaction avec laptop-mode</title>
<body>

<p>
Les noyaux récents (2.6.6 et ultérieurs, les derniers de la série 2.4 et
d'autres grâce à des correctifs) supportent ce que l'on appelle
<e>laptop-mode</e>. Lorsque ce mode est activé, le contenu des tampons n'est
écrit sur le disque qu'après 10 minutes (plutôt que 30 secondes) ou sur
demande. Cela minimise le temps pendant lequel le disque dur doit être actif.
</p>

<p>
<!-- FIXME: bug #45593 -->
Pour démarrer et arrêter laptop-mode, créez le script /etc/init.d/laptop-mode.
Vous pouvez copier celui qui est inclus dans
<path>/usr/src/linux/Documentation/laptop-mode.txt</path>. Lorsque ce script
est prêt, assurez-vous qu'il soit exécuté&nbsp;:
</p>

<pre caption="Démarrage automatique de laptop-mode">
# <i>rc-update add laptop-mode battery</i>
</pre>

<warn>
Encore une fois, faites attention aux délais utilisés pour l'arrêt de votre
disque dur. De trop faibles valeurs useront votre matériel et invalideront
votre garantie. Assurez-vous de lire la documentation contenue dans
laptop-mode.txt. Assurez-vous d'arrêter laptop-mode avant que votre batterie
n'épuise ses réserves&nbsp;; autrement, vous perdrez au minimum les 10
dernières minutes de votre travail.
</warn>

</body>
</section>
<section>
<title>Quelques trucs</title>
<body>

<p>
En plus d'arrêter votre disque aussitôt que possible, vous pouvez minimiser
le nombre d'accès au disque. Vérifiez quels processus écrivent fréquemment sur
le disque&nbsp;; syslogd est un bon candidat. Vous ne souhaiterez sans doute pas
désactiver ce dernier complètement, mais pouvez modifier sa configuration pour
ne pas journaliser d'événements superflus, ce qui diminuera le trafic vers
votre disque dur.
</p>

<pre caption="Désactiver cups en mode batterie">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Une autre possibilité est de désactiver la mémoire virtuelle en mode batterie.
Avant d'écrire un script pour exécuter swapon/swapoff, assurez-vous d'avoir
assez de mémoire vive et que vous n'utilisez pas une grande quantité de mémoire
virtuelle. Autrement, vous allez à l'encontre de graves problèmes.
</p>

<p>
Si vous ne voulez pas utiliser laptop-mode, vous pouvez tout de même limiter
l'accès au disque en montant <e>tempfs</e> sur certains répertoires. (Les
données écrites sont alors conservées dans la mémoire principale plutôt que sur
le disque et le contenu est perdu lors du démontage.) Il peut être pratique de
monter ce système sur <path>/tmp</path>. Après tout, le contenu de ce
répertoire importe peu puisqu'il est de toute façon supprimé à chaque
redémarrage. Que ce contenu ait été conservé sur le disque ou en mémoire ne
change rien. Assurez-vous toutefois d'avoir assez de mémoire vive et qu'aucun
programme (par exemple un client de téléchargement ou un utilitaire de
compression) n'a besoin d'un espace disque phénoménal dans <path>/tmp</path>.
Pour activer cette fonction, ajoutez le support pour tempfs à votre noyau et la
ligne suivante au fichier <path>/etc/fstab</path>&nbsp;:
</p>

<pre caption="Éditer /etc/fstab pour rendre /tmp encore plus volatil">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Faites attention au paramètre «&nbsp;size&nbsp;». Modifiez-le pour l'adapter à
votre système. Si vous n'êtes pas sûr de vous, mieux vaut ne pas essayer. Cette
configuration peut limiter vos performances par un effet d'entonnoir. Si vous
voulez un système de fichier tempfs sur <path>/var/log</path>, assurez-vous de
fusionner les fichiers au disque avant de le démontage. Ils sont essentiels.
N'essayez pas de monter un tempfs sur /var/tmp. Portage utilise ce répertoire
pour compiler...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour les autres composants</title>
<section>
<title>Gestion de l'alimentation pour les cartes réseau sans fil</title>
<body>

<p>
Les cartes réseau sans fil consomment une quantité non négligeable d'énergie.
Cette consommation peut être gérée de façon analogue à ce qui a été décrit pour
le disque dur avec le script pm.hda.
</p>

<pre caption="Gestion automatique de l'alimentation pour les cartes réseau sans fil">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
L'exécution de ce script active la gestion de l'alimentation pour wlan0. La
mise en veille se fera dès que trois secondes sans trafic se seront écoulées.
Sauvegardez ce script sous le nom <path>/etc/init.d/pm.wlan0</path> et
ajoutez-le au niveau d'exécution battery (comme vous avez fait pour le script
pour le disque dur). Consultez <c>man iwconfig</c> pour connaître les
différentes options. Si votre pilote et votre point d'accès permettent de
changer le délai de reconnaissance de l'émission de la balise (en anglais
«&nbsp;beacon time&nbsp;»), cela peut vous servir de point de départ pour
économiser encore davantage d'énergie.
</p>

</body>
</section>
<section>
<title>Gestion de l'alimentation pour les périphériques USB</title>
<body>

<p>
Il existe deux problèmes liés à la consommation d'énergie par les périphériques
USB. Premièrement, les périphériques tels que les souris, caméras numériques et
clés USB consomment de l'énergie lorsqu'ils sont branchés. Vous n'y pouvez
rien, si ce n'est les débrancher lorsqu'ils ne servent pas. Deuxièmement,
lorsque des périphériques USB sont branchés, le contrôleur USB hôte accède
périodiquement au bus, ce qui empêche le processeur d'entrer dans les états de
veille C3/4. La réponse du système d'exploitation à ce problème se nomme
suspension USB sélective et n'a pas encore été intégrée au noyau. La suspension
USB sélective ne permet l'accès au bus que pour les périphériques en cours
d'utilisation. En attendant que cette fonctionnalité soit implémentée, il
existe une alternative (qui manque de raffinement)&nbsp;: compiler le support
USB et les périphériques en tant que modules du noyau et déchargez-les à l'aide
d'un script lorsqu'ils ne sont pas en cours d'utilisation (par exemple lorsque
le boîtier est fermé).
</p>

</body>
</section>
</chapter>

<chapter>
<title>États de veille&nbsp;: suspension, mise en veille et hibernation</title>
<section>
<title>Vue d'ensemble</title>
<body>

<p>
L'ACPI définit plusieurs états de veille. Les principaux sont&nbsp;:
</p>

<ul>
  <li>S1 ou pause («&nbsp;standby&nbsp;»)</li>
  <li>S3 ou suspension en mémoire vive ou encore mise en veille («&nbsp;sleep&nbsp;»)</li>
  <li>S4 ou suspension sur le disque ou encore hibernation («&nbsp;hibernate&nbsp;»)</li>
</ul>

<p>
Ces états peuvent être utilisés dès que vous ne travaillez pas sur votre
portable mais que vous ne voulez pas l'éteindre afin d'éviter le long délai
nécessaire au démarrage.
</p>

</body>
</section>
<section>
<title>Pause, veille et hibernation</title>
<body>

<p>
Le support pour les états de veille ACPI est considéré expérimental pour de
bonnes raisons. Les états de veille APM semblent plus stables, mais vous ne
pouvez pas utiliser à la fois ACPI et APM.
</p>

<warn>
Bien que le support des états de veille se soit beaucoup amélioré, il est
toujours expérimental. J'ai enfin réussi à faire fonctionner swsusp2 et la
suspension en mémoire vive, mais ne vous faites pas d'illusion&nbsp;: cela ne
marchera probablement pas pour vous et endommagera peut-être votre système.
</warn>

<p>
Il existe actuellement trois implémentations pour S4. L'originale est swsusp.
swsusp2 a l'interface la plus agréable (qui inclut le support de
«&nbsp;bootsplash&nbsp;»), mais requiert l'application de correctifs au noyau.
Le dernier (mais non le moindre) est Suspend-to-Disk, dérivé de swsusp.
</p>

<p>
Si vous vous sentez perdu, jetez un coup d'œil à ce <uri
link="http://softwaresuspend.berlios.de/features.html#compare">comparatif des
fonctionnalités</uri> de ces programmes (en anglais). Si vous ne savez toujours
pas lequel choisir, essayez d'abord swsusp2 puisqu'il semble être le plus
prometteur des trois.
</p>

<p>
La configuration du noyau se fait comme suit&nbsp;:
</p>

<pre caption="Configuration pour différents types d'états de veille">
Power Management Options ---&gt;

  <comment>(Pause et mise en veille)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(Hibernation avec swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)

  <comment>(Hibernation avec swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"your-swap-here")    Default resume device name

  <comment>(Hibernation avec Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"your-swap-here") Default resume partition
</pre>

<p>
Compilez votre noyau après avoir activé les options appropriées et exécutez
respectivement <c>cat /proc/acpi/sleep</c> pour les noyaux de la série 2.4 et
<c>cat /sys/power/state</c> pour les noyaux de la série 2.6 pour savoir quels
états sont supportés. Cette dernière commande donne (sur mon portable)&nbsp;:
<c>standby mem disk</c>. Pour swsusp, le paramètre du noyau
<c>resume=/dev/votre-mémoire-virtuelle</c> doit être ajouté. Si le démarrage
n'est pas possible à cause d'une image corrompue, utilisez <c>noresume</c>
(pour swsusp), <c>pmdisk=off</c> (pour Suspend-to-Disk) et <c>noresume2</c>
(pour swsusp2).
</p>

<p>
Pour placer votre système dans un des états de veille, utilisez&nbsp;:
</p>

<pre caption="Activer les états de veille">
<comment>(Noyaux de la série 2.4)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>Pause</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>Mise en veille</comment>

<comment>(Noyaux de la série 2.6)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>Pause</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>Mise en veille</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>Hibernation</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>Hibernation</comment>

<comment>(swsusp2)</comment>
# <i>echo &gt; /proc/swsusp/activate</i>
</pre>

<warn>
Sauvegardez vos données avant de tenter ceci. Exécutez <c>sync</c> avant
d'exécuter ces commandes afin que les données du cache soient écrites sur le
disque. Essayez d'abord hors de l'environnement X, puis dans cet environnement
mais sans session ouverte.
</warn>

<p>
Si vous rencontrez des erreurs du type «&nbsp;kernel panic&nbsp;» à cause de
uhci ou d'une fonctionnalité similaire, essayez de compiler le support USB
comme un module et déchargez les modules avant d'entrer dans un état de veille.
</p>

<p>
Si ce qui précède est suffisant pour pouvoir exécuter swsusp et Suspend-to-Disk
(notez que je parle d'exécution, pas d'un fonctionnement correct), swsusp2
nécessite une attention particulière. La première chose à faire est de corriger
le noyau grâce aux correctifs que vous trouverez à l'adresse <uri
link="http://softwaresuspend.berlios.de/">
http://softwaresuspend.berlios.de/</uri>. Une fois cela fait, installez le
script d'hibernation que vous trouverez sur cette même page.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Résolution des problèmes</title>
<section>
<title>Lorsque ça va mal...</title>
<body>

<p>
<e>Q:</e> J'essaie de changer la fréquence de l'unité centrale, mais
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> n'existe pas.
</p>

<p>
<e>A:</e> Assurez-vous que votre processeur supporte l'échelonnage de la
fréquence et que vous avez choisi le pilote CPUFreq correspondant à votre
processeur. Voici une liste des processeurs supportés par cpufreq (avec le
noyau 2.6.7)&nbsp;: ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400,
SC410, AMD K6-2+ mobile, AMD K6-3+ mobile, AMD Duron mobile, AMD Athlon mobile,
AMD Opteron, AMD Athlon 64, Cyrix Media GXm, Intel PIII mobile et Intel PIII-M
mobile (avec certains jeux de composants), Intel Pentium 4, Intel Xeon, Intel
Pentium M (Centrino), National Semiconductors Geode GX, Transmeta Crusoe, VIA
Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, plusieurs PowerBook et iBook2
et divers processeurs utilisés sur des systèmes compatibles avec ACPI 2.0
(seulement si l'option «&nbsp;ACPI Processor Performance States&nbsp;» est
disponible dans l'interface BIOS/ACPI).
</p>

<p>
<e>Q:</e> Mon processeur supporte l'échelonnage de la fréquence, mais
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> est vide.
</p>

<p>
<e>A:</e> Cherchez des messages d'erreurs ACPI avec <c>dmesg | grep ACPI</c>.
Essayez de mettre votre BIOS à jour, particulièrement si un mauvais
fonctionnement de DSDT est rapporté. Vous pouvez également essayer de corriger
la situation vous-même (ce qui dépasse le cadre de ce guide).
</p>

<p>
<e>Q:</e> Mon portable supporte l'échelonnage de la fréquence, mais selon
/proc/cpuinfo, la vitesse ne change pas.
</p>

<p>
<e>A:</e> Cela semble être un bogue dans le noyau. Exécutez <c>emerge
x86info</c>, mettez votre noyau à jour et vérifiez la vitesse actuelle du
processeur avec <c>x86info -mhz</c>.
</p>

<p>
<e>Q:</e> Je peux changer la fréquence du processeur, mais la plage disponible
est plus restreinte qu'elle ne l'est dans un autre système d'exploitation.
</p>

<p>
<e>A:</e> Vous pouvez combiner l'échelonnage de la fréquence avec la régulation
du temps processeur ACPI («&nbsp;ACPI CPU throttling&nbsp;») pour obtenir une
fréquence minimale plus basse. Notez que la régulation du temps processeur ne
sauve pas beaucoup d'énergie et sert plutôt à la gestion de la dissipation de
la chaleur (afin de garder votre portable froid et silencieux). Vous pouvez
consulter l'état de régulation du temps processeur avec <c>cat
/proc/acpi/processor/CPU/throttling</c> et le changer avec <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, où x est un des états Tx listés dans
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>Q:</e> La durée de vie de la batterie semble moindre qu'avant.
</p>

<p>
<e>A:</e> Vérifiez les paramètres du BIOS. Peut-être avez-vous oublié de
réactiver certaines options.
</p>

<p>
<e>Q:</e> Ma batterie est chargée, mais KDE rapporte un niveau de charge de 0 %
et éteint le système aussitôt.
</p>

<p>
<e>A:</e> Vérifiez que le support pour la batterie est compilé dans le noyau.
Si vous l'utilisez comme module, assurez-vous que celui-ci est chargé.
</p>

<p>
<e>Q:</e> J'ai un portable Dell Inspiron 51XX et je n'obtiens aucun événement
ACPI.
</p>

<p>
<e>A:</e> Cela semble être un bogue dans le noyau. Consultez <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">cette page</uri>.
</p>

<p>
<e>Q:</e> Je viens d'acheter une batterie, mais elle ne dure que quelques
minutes&nbsp;! Où est mon erreur&nbsp;?
</p>

<p>
<e>A:</e> Suivez d'abord les instructions du constructeur expliquant comment
charger la batterie correctement.
</p>

<p>
<e>Q:</e> Ce qui précède ne m'a pas aidé. Que devrais-je faire&nbsp;?
</p>

<p>
<e>A:</e> Certaines batteries prétendument neuves sont en fait usagées.
Essayez ce qui suit&nbsp;:
</p>

<pre caption="Vérifier l'état de la batterie">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Si la valeur de «&nbsp;last full capacity&nbsp;» diffère
significativement de celle de «&nbsp;design capacity&nbsp;», votre batterie est
probablement défaillante. Essayez de faire jouer votre garantie.
</p>

</body>
</section>
</chapter>
</guide>
