<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/power-management-guide.xml,v 1.11 2006/03/12 17:36:38 cam Exp $ -->
<guide link="/doc/fr/power-management-guide.xml" lang="fr">
<title>Guide de la gestion de l'alimentation</title>

<author title="Auteur">
  <mail link="earthwings@gentoo.org">Dennis Nienhüser</mail>
</author>
<author title="Traducteur">
  <mail link="ribosome@gentoo.org">Olivier Fisette</mail>
</author>
<author title="Traducteur">
  <mail link="cam@gentoo.org">Camille Huot</mail>
</author>

<abstract>
La gestion de l'alimentation est la clé pour améliorer la durée de vie de la
batterie équipant les systèmes mobiles tels les portables. Ce guide vous
aidera à paramétrer la gestion de l'alimentation sur votre portable.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.27</version>
<date>2006-02-16</date>

<chapter>
<title>Introduction</title>
<section>
<body>

<p>
La capacité et la durée de vie des batteries des portables se sont améliorées
considérablement pendant les dernières années. Toutefois, les processeurs
d'aujourd'hui consomment bien plus d'énergie que leurs prédécesseurs et chaque
génération de portables introduit de nouveaux composants énergivores. C'est
pourquoi la gestion de l'alimentation est plus importante que jamais. Améliorer
l'autonomie ne signifie pas nécessairement acheter une deuxième batterie&nbsp;;
l'utilisation de politiques logicielles intelligentes a un impact
considérable.
</p>

</body>
</section>
<section>
<title>Vue d'ensemble</title>
<body>

<p>
Veuillez noter que ce guide s'intéresse à la gestion de l'alimentation pour les
<e>portables</e>. Même si certaines sections peuvent peut-être s'appliquer aux
<e>serveurs</e>, d'autres ne s'y appliquent pas et peuvent même être nuisibles.
N'essayez pas de mettre en pratique les conseils de ce guide avec un serveur, à
moins que vous ne sachiez vraiment ce que vous faites.
</p>

<p>
Dans sa version actuelle, ce guide est plutôt long. Le paragraphe suivant
résume son contenu afin de vous aider à y trouver ce que vous chercher.
</p>

<p>
Le chapitre sur les <e>prérequis</e> vous informe des actions qui doivent être
entreprises avant de pouvoir utiliser les conseils relatifs à des composants
particuliers présentés dans les autres sections. Cela inclut la configuration
du BIOS et du noyau ainsi que des idées pour simplifier la gestion du côté
utilisateur. Les trois chapitres suivants se concentrent sur les composants
qui, typiquement, consomment le plus d'énergie&nbsp;: le processeur, l'écran et
le disque dur. Chacun d'eux peut être paramétré indépendamment. Le chapitre
<e>Gestion de l'alimentation pour l'unité centrale</e> décrit comment ajuster
la fréquence du processeur afin de maximiser l'économie d'énergie sans
sacrifier les performances. Vous apprendrez comment éviter que votre disque dur
ne consomme de l'énergie pour un travail inutile dans le chapitre <e>Gestion de
l'alimentation pour le disque dur</e> (un effet secondaire agréable est la
réduction du niveau de bruit de votre machine). Quelques notes sur les cartes
réseau sans fil et les périphériques USB (dans le chapitre <e>Gestion de
l'alimentation pour les autres composants</e>) terminent la section dédiée à
des composants spécifiques. Le chapitre qui suit s'intéresse aux <e>états de
veille</e> (mais leur support est expérimental). Pour conclure, le chapitre
<e>Résolution des problèmes</e> dresse une liste des pièges à éviter.
</p>

</body>
</section>
<section>
<title>Budget énergétique des composants</title>
<body>

<figure link="/images/energy-budget.png" short="Quel composant consomme le plus d'énergie" caption="Budget énergétique des composants"/>

<p>
Presque tous les composants peuvent opérer dans différents états (hors
tension, en veille, inactif, etc.)&nbsp;; leur consommation d'énergie variera
selon cet état. Les composants les plus gourmands sont l'écran à cristaux
liquides, l'unité centrale, le jeu de composants de la carte-mère et le disque
dur. Il est parfois possible, grâce au BIOS, d'activer une politique de gestion
de l'alimentation indépendante du système d'exploitation. Toutefois, une
gestion intelligente de l'alimentation par le système d'exploitation est
beaucoup plus efficace et s'adapte plus aisément à une variété de situations.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Prérequis</title>
<section>
<body>

<p>
Avant de s'intéresser à la gestion de l'alimentation pour des composants
particuliers, vous devez vous assurer que votre système remplisse certaines
conditions. Après la configuration du BIOS, quelques options du noyau devront
être activées (en bref, ce sont l'ACPI, les états de veille et l'échelonnage de
la fréquence de l'unité centrale (en anglais «&nbsp;CPU frequency
scaling&nbsp;»)). Puisque les économies d'énergie sont habituellement
accompagnées de baisses de performances, il faut s'assurer de n'activer cette
gestion que lorsque le portable utilise la batterie. C'est ici qu'un nouveau
niveau d'exécution nommé <e>battery</e> se révélera fort utile.
</p>

</body>
</section>
<section>
<title>Préparer le BIOS</title>
<body>

<p>
Jetez d'abord un coup d'œil aux paramètres de gestion de l'alimentation de votre
BIOS. L'idéal serait de combiner les capacités du BIOS et du système
d'exploitation, mais, pour l'instant, il est préférable de désactiver la gestion
de l'alimentation par le BIOS. Cela nous assure que les politiques de ce dernier
n'interfèreront pas avec celles du système d'exploitation. N'oubliez pas de
vérifier à nouveau les paramètres du BIOS une fois que vous aurez configuré
tout le reste.
</p>

</body>
</section>
<section>
<title>Régler les paramètres USE</title>
<body>

<p>
Veuillez vérifier que le paramètre USE <c>acpi</c> soit bien activé dans
<path>/etc/make.conf</path>. Les paramètres <c>apm</c>, <c>lm_sensors</c>,
<c>nforce2</c>, <c>nvidia</c> et <c>pmu</c> peuvent également être intéressants
pour votre système. Consultez <path>/usr/portage/profiles/use*.desc</path> pour
plus d'informations. Si vous oubliez d'activer un de ces paramètres, vous
pourrez recompiler les paquets qui l'utilisent grâce à l'option <c>--newuse</c>
de la commande <c>emerge</c> (voir <c>man 1 emerge</c>).
</p>

</body>
</section>
<section>
<title>Configurer le noyau</title>
<body>

<p>
Le support pour l'ACPI (sigle anglais pour «&nbsp;Advanced Configuration and
Power Interface&nbsp;») dans le noyau Linux est actuellement en cours de
développement. Utiliser un noyau récent vous assurera le meilleur support
possible.
</p>

<p>
Parmi les différentes sources du noyau Linux proposées par Portage, je vous
conseillerais d'utiliser les <c>gentoo-sources</c> ou les
<c>suspend2-sources</c>. Ce dernier paquet contient les correctifs pour le
Software Suspend 2 (voyez le chapitre qui parle des états de veille pour en
savoir plus). Lorsque vous configurerez votre noyau, activez au moins ces
options&nbsp;:
</p>

<pre caption="Configuration minimale du noyau pour la gestion de l'alimentation (noyau 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)

  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservative' cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>Pilote CPUFreq approprié pour votre processeur</i>
</pre>

<p>
Décidez vous-même si vous souhaitez activer les options «&nbsp;Software
Suspend&nbsp;» et «&nbsp;Sleep States&nbsp;» (voyez ci-dessous). Si vous
possédez un portable de marque ASUS, Medion, IBM Thinkpad ou Toshiba, activez
l'option appropriée.
</p>

<p>
Vous devez indiquer au noyau comment activer l'échelonnage de la fréquence
pour votre unité centrale. Puisque chaque type de processeur a une interface
différente, il importe de choisir le pilote approprié pour votre processeur.
Assurez-vous de ne pas vous tromper&nbsp;! Activer l'option <e>Intel Pentium 4
clock modulation</e> sur un système équipé d'un Pentium M, par exemple, cause
des comportements étranges. Consultez la documentation du noyau si vous êtes
dans le doute.
</p>

<p>
Compilez votre noyau, assurez-vous que les modules appropriés seront chargés
lors du démarrage et amorcez votre nouveau noyau avec support ACPI. Ensuite,
exécutez <c>emerge sys-power/acpid</c> pour installer le démon acpi. Ce dernier
vous informe des événements tels que le changement de la source du courant
lorsque l'adaptateur est branché ou débranché, ou encore la fermeture du
boîtier du portable. Assurez-vous que les modules soient chargés (si vous ne les
avez pas compilé dans le noyau) et lancez acpid avec la commande
<c>/etc/init.d/acpid start</c>. Exécutez <c>rc-update add acpid default</c>
pour qu'il soit lancé lors du démarrage. Vous verrez bientôt comment
l'utiliser.
</p>

<pre caption="Installer acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Créer le niveau d'exécution battery</title>
<body>

<p>
La politique par défaut est d'activer la gestion de l'alimentation seulement
lorsque cela est nécessaire&nbsp;: lorsque vous utilisez la batterie. Pour
simplifier la gestion du changement entre l'adaptateur et la batterie, créez un
niveau d'exécution nommé <e>battery</e> qui contiendra des références à tous les
scripts servant à démarrer et arrêter la gestion de l'alimentation.
</p>

<note>
Vous pouvez ignorer cette section en toute sécurité si vous n'aimez pas l'idée
de créer un autre niveau d'exécution. Toutefois, les étapes subséquentes
deviendront plus complexes, car les sections qui suivent supposent qu'il
existe un niveau d'exécution <e>battery</e>.
</note>

<pre caption="Créer le niveau d'exécution battery">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
C'est terminé. Votre nouveau niveau d'exécution <e>battery</e> contient tout ce
que <e>default</e> contient, mais il n'existe pas encore de mécanisme pour
passer de l'un à l'autre. Nous allons maintenant remédier à cela.
</p>

</body>
</section>
<section>
<title>Réagir aux événements ACPI</title>
<body>

<p>
Des événements ACPI typiques sont la fermeture du boîtier, le branchement ou le
débranchement de l'adaptateur et la pression du bouton de mise en veille. Les
changements de la source de l'alimentation sont des événements
particulièrement importants et le système devrait y réagir en changeant le
niveau d'exécution. Un petit script se chargera de cela.
</p>

<p>
Vous devez donc d'abord obtenir ce script qui passera du niveau d'exécution
<c>default</c> à <c>battery</c> selon l'état de votre source d'alimentation. Le
script utilise la commande <c>on_ac_power</c> du paquet
<c>sys-power/powermgmt-base</c>. Ce paquet doit être installé sur votre système.
</p>

<pre caption="Installer powermgmt-base">
<i># emerge powermgmt-base</i>
</pre>

<p>
Vous pouvez maintenant connaître votre source d'alimentation en tapant
<c>on_ac_power &amp;&amp; echo "Alimentation externe" || echo "Batteries"</c>
dans un shell. Le script ci-dessous se chargera de changer de niveau
d'exécution. Sauvez-le sous le nom
<path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>.
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># DÉBUT de la configuration</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="battery"
<comment># FIN de la configuration</comment>

if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
    logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
    exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
    logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
    exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
    then
        logger "Switching to ${RUNLEVEL_AC} runlevel"
        /sbin/rc ${RUNLEVEL_AC}
    fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
    logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
    /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
N'oubliez pas de faire un <c>chmod +x
/etc/acpi/actions/pmg_switch_runlevel.sh</c> pour que le script soit exécutable.
La dernière chose qu'il reste à faire est de lancer le script lorsque la source
d'alimentation change. Ceci est accompli par l'interception des événements ACPI
grâce à <c>acpid</c>. Vous devez d'abord savoir quels événements sont générés
lorsque la source d'alimentation change. Les événements sont appelés
<e>ac_adapter</e> et <e>battery</e> sur la plupart des ordinateurs portables,
mais cela peut-être différent sur le vôtre.
</p>

<pre caption="Trouver les événements ACPI envoyés lors du changement de source
d'alimentation">
# <i>tail -f /var/log/acpid | grep "received event"</i>
</pre>

<p>
Lancez la commande ci-dessus et enlever le câble d'alimentation. Vous devriez
voir quelque chose comme ceci&nbsp;:
</p>

<pre caption="Exemple d'affichage pour le changement d'alimentation">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
La partie intéressante est celle entre guillemets, après <e>received event</e>.
Elle sera mise en correspondance avec la ligne «&nbsp;event&nbsp;» dans le
fichier que l'on créera plus bas. Ne vous inquiétez pas si votre système génère
des événements multiples ou toujours les mêmes événements. Du moment qu'un
événement est généré, le changement de niveau d'exécution fonctionnera.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># Remplacez « ac_adapter » par le nom de l'évènement généré par votre portable.</comment>
<comment># Par exemple, ac_adapter.* acceptera ac_adapter AC 00000080 00000000.</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch/runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># Remplacez « battery » par le nom de l'évènement généré par votre portable.</comment>
<comment># Par exemple, battery.* acceptera battery BAT0 00000080 00000001.</comment>
event=battery.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
Enfin, acpid doit être redémarré pour prendre en compte les modifications de
configuration.
</p>

<pre caption="Terminer la configuration des niveaux d'exécution avec acpid">
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Faites un essai&nbsp;: branchez et débranchez l'adaptateur et consultez les
messages de syslog. Vous devriez y voir «&nbsp;Switching to AC mode&nbsp;» et
«&nbsp;Switching to battery mode&nbsp;». Consultez la section
«&nbsp;Résolution des problèmes&nbsp;» si le script n'arrive pas à détecter
correctement la source d'alimentation.
</p>

<p>
À cause de la nature du mécanisme de gestion des événements, votre portable
démarrera toujours avec le niveau <e>default</e> quel que soit l'état réel de
l'adaptateur. Cela ne pose pas de problème si nous utilisons l'alimentation
secteur, mais nous voudrions démarrer en niveau d'exécution <e>battery</e> de
temps en temps. Une solution serait d'ajouter à votre chargeur de démarrage une
nouvelle entrée contenant <c>softlevel=battery</c>, mais il y a une meilleure
façon de faire&nbsp;: il est possible de simuler un événement acpi à la fin du
processus de démarrage et de laisser le script <path>/etc/acpi/default.sh</path>
décider si un changement de niveau d'exécution est nécessaire. Ouvrez
<path>/etc/conf.d/local.start</path> dans votre éditeur favori et ajoutez ces
lignes&nbsp;:
</p>

<pre caption="Éditer local.start pour implémenter le changement de niveau d'exécution lors du démarrage">
<comment># Simule un événement ACPI pour changer de niveau d'exécution
# si le portable fonctionne avec la batterie.</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery"
</pre>

<p>
Vous êtes maintenant prêt à activer les politiques individuelles de gestion de
l'alimentation pour chaque composant.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour l'unité centrale</title>
<section>
<body>

<p>
Les processeurs dits «&nbsp;mobiles&nbsp;» peuvent opérer à différentes
fréquences d'horloge. Certains permettent même la modification de la tension
d'alimentation. La plupart du temps, votre processeur n'a pas besoin de tourner
à la vitesse maximale, on peut ainsi ralentir la cadence et largement réduire la
puissance consommée, ceci sans perte de performance.
</p>

</body>
</section>
<section>
<title>Quelques termes techniques</title>
<body>

<p>
Discuter de l'échelonnage de la fréquence des processeurs implique l'emploi de
certains termes techniques avec lesquels vous n'êtes peut-être pas familier.
Voici une brève explication.
</p>

<p>
D'abord, le noyau doit pouvoir changer la fréquence du microprocesseur. Un
<e>pilote CPUfreq pour le processeur</e> (en anglais «&nbsp;CPUfreq processor
driver&nbsp;») connaît la commande qui permet de faire ce changement avec un
processeur particulier. Il est donc important que vous choisissiez le pilote
approprié, c'est-à-dire celui qui correspond à votre processeur. Vous devriez
déjà avoir fait ce choix un peu plus tôt. Une fois que le noyau sait comment
changer la fréquence, il doit savoir à quelle fréquence il doit régler le
processeur. Cela se fait d'après les règles d'une <e>politique</e> à deux
composants&nbsp;: la <e>politique CPUfreq</e> («&nbsp;CPUfreq policy&nbsp;»)
et le gouverneur («&nbsp;governor&nbsp;»). La politique CPUfreq n'est en fait
que deux nombres qui définissent un intervalle à l'intérieur duquel la
fréquence doit rester&nbsp;; il y a une fréquence maximale et une fréquence
minimale. Le gouverneur, lui, décide laquelle des fréquences disponibles entre
les fréquences minimale et maximale doit être choisie. Par exemple, le
gouverneur <e>powersave</e> choisit toujours la fréquence disponible la plus
basse, alors que le gouverneur <e>performance</e> choisit la plus élevée. Le
gouverneur <e>userspace</e>, enfin, ne prend aucune décision. Il laisse plutôt
l'utilisateur (ou un programme utilisateur) décider de la fréquence à
utiliser et se contente de mettre en œuvre cette décision. Ce gouverneur lit
la fréquence choisie à partir du fichier
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Vous trouvez peut-être que cela ne ressemble toujours pas à des changements
dynamiques de la fréquence, et vous avez raison. Ces changements dynamiques
peuvent être implémentés de différentes façons. Par exemple, le gouverneur
<e>ondemand</e> prend ses décisions en fonction de la charge actuelle du
processeur. La même chose peut être réalisée avec des outils utilisateurs tels
que <c>cpudyn</c>, <c>cpufreqd</c>, <c>powernowd</c> et plusieurs autres. Les
événements ACPI peuvent être utilisés pour activer ou désactiver les
changements dynamiques de la fréquence en fonction de la source de
l'alimentation.
</p>

</body>
</section>
<section>
<title>Ajuster la fréquence manuellement</title>
<body>

<p>
Diminuer la vitesse et le voltage du processeur réduit à la fois la
consommation d'énergie et le dégagement de chaleur (votre portable ne deviendra
donc pas aussi chaud que lorsque vous l'utilisez à pleine puissance).  Le
principal désavantage est évidemment une diminution des performances.  Réduire
la vitesse du processeur revient à tronquer les performances contre des gains
énergétiques.
</p>

<note>
Tous les portables ne supportent pas l'échelonnage de la fréquence. Pour être
sûr, consultez la liste des processeurs supportés dans la section <e>Résolution
des problèmes</e>.
</note>

<p>
Il est temps de vérifier si l'échelonnage de la fréquence fonctionne. Installons
un autre outil très utile pour le débogage&nbsp;: <c>sys-power/cpufrequtils</c>.
</p>

<pre caption="Vérifier la fréquence du processeur">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Voici un exemple&nbsp;:
</p>

<pre caption="Exemple de ce que peut renvoyer cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: conservative, ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz.
</pre>

<p>
Maintenant, testez <c>cpufreq-set</c> pour être sûr que le changement de
fréquence fonctionne. Par exemple, lancez <c>cpufreq-set -g ondemand</c> pour
activer le gouverneur ondemand et vérifiez le changement avec
<c>cpufreq-info</c>. Si cela ne marche pas comme prévu, vous pouvez chercher de
l'aide dans la section «&nbsp;<uri link="#troubles">Résolution des
problèmes</uri>&nbsp;».
</p>

</body>
</section>
<section>
<title>Adaptation automatique de la fréquence</title>
<body>

<p>
Ce qui précède est amusant, mais peu pratique dans la vie de tous les jours.
Mieux vaut laisser à votre système le soin de gérer automatiquement la
fréquence. Cela peut se faire de différentes manières. Le tableau suivant
donne un aperçu de la variété des différentes approches disponibles et vous
aidera à en choisir une. Le tableau est divisé en trois catégories&nbsp;:
<e>Noyau</e>, pour les approches qui n'ont besoin que d'un support au niveau
du noyau&nbsp;; <e>Démon</e>, pour les programmes qui sont exécutés en
arrière-plan&nbsp;; et <e>Graphique</e>, pour les programmes qui offrent une
interface utilisateur graphique pour simplifier la configuration et les
changements.
</p>

<table>
<tr>
  <th>Nom</th>
  <th>Catégorie</th>
  <th>Commutateur des décisions</th>
  <th>Gouverneurs du noyau</th>
  <th>Autres gouverneurs</th>
  <th>Commentaires</th>
</tr>
<tr>
  <ti>Gouverneur «&nbsp;ondemand&nbsp;»</ti>
  <ti>Noyau</ti>
  <ti>Charge de l'unité centrale</ti>
  <ti>Ne s'applique pas</ti>
  <ti>Ne s'applique pas</ti>
  <ti>
    Choisit une fréquence CPU maximale lorsque le système est chargé et la
    redescend progressivement lorsque le système est inactif. Peut être
    paramétré grâce aux options contenues dans&nbsp;:
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Requiert tout
    de même des outils utilisateurs (programmes et scripts) si l'on souhaite
    utiliser le changement de gouverneur ou des fonctionnalités similaires.
  </ti>
</tr>
<tr>
  <ti>Gouverneur «&nbsp;conservative&nbsp;»</ti>
  <ti>Noyau</ti>
  <ti>Charge de l'unité centrale</ti>
  <ti>Ne s'applique pas</ti>
  <ti>Ne s'applique pas</ti>
  <ti>
    À la différence du gouverneur <e>ondemand</e>, le <e>conservative</e> ne
    saute pas directement à la fréquence maximale lorsque le système est en
    pleine charge, mais augmente celle-ci progressivement. On peut également le
    paramétrer grâce aux fichiers situés dans
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Il requiert
    tout de même des outils (programmes, scripts) si vous désirez changer
    automatiquement de gouverneur.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Démon</ti>
  <ti>Charge de l'unité centrale</ti>
  <ti>performance, powersave</ti>
  <ti>Dynamique</ti>
  <ti>
    Supporte également la mise en veille des disques. Toutefois, <e>laptop
    mode</e> est plus efficace dans la plupart des cas.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Démon</ti>
  <ti>
    État de la batterie, charge de l'unité centrale, température, programmes
    exécutés et plus...
  </ti>
  <ti>Tous disponibles</ti>
  <ti>Aucun</ti>
  <ti>
    Configuration sophistiquée (mais compliquée). Extensible grâce à des plugins
    tels que la supervision de la température (lm_sensors) ou la coordination de
    la mémoire et du cœur des cartes graphiques nVidia. Cpufreqd gère les
    systèmes multiprocesseurs et peut éventuellement être contrôlé manuellement.
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Démon</ti>
  <ti>Charge de l'unité centrale</ti>
  <ti>Aucun</ti>
  <ti>«&nbsp;passive&nbsp;», «&nbsp;sine&nbsp;», «&nbsp;aggressive&nbsp;»</ti>
  <ti>
    Supporte SMP.
  </ti>
</tr>
<tr>
  <ti>
    <uri
    link="http://fatcat.ftj.agh.edu.pl/~nelchael/index.php?cat=projs&amp;subcat=ncpufreqd&amp;language=en">ncpufreqd</uri>
  </ti>
  <ti>Démon</ti>
  <ti>Température</ti>
  <ti>Aucun</ti>
  <ti>«&nbsp;powersave&nbsp;», «&nbsp;performance&nbsp;»</ti>
  <ti>
    Bascule le gouverneur utilisé de <e>performance</e> à <e>powersave</e> selon
    la température du système. Très utile sur les portables qui chauffent
    beaucoup.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Démon</ti>
  <ti>Charge de l'unité centrale</ti>
  <ti>Aucun</ti>
  <ti>
    «&nbsp;dynamic&nbsp;», «&nbsp;powersave&nbsp;», «&nbsp;performance&nbsp;»,
    «&nbsp;fixed speed&nbsp;»
  </ti>
  <ti>
    Interface client/serveur pratique. Requiert un noyau de la
    série 2.6. Non maintenu, dysfonctionnel et donc retiré de Portage. Veuillez
    plutôt utiliser cpufreqd.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Graphique</ti>
  <ti>Aucun</ti>
  <ti>Aucun</ti>
  <ti>Aucun</ti>
  <ti>
    Un outil graphique GNOME permettant de régler manuellement la fréquence du
    processeur. Il n'offre aucune possibilité d'automatisation.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Graphique</ti>
  <ti>État de la batterie</ti>
  <ti>Tous disponibles</ti>
  <ti>Aucun</ti>
  <ti>
    KDE seulement. Le gouverneur «&nbsp;ondemand&nbsp;» est requis pour
    l'échelonnage dynamique de la fréquence.
  </ti>
</tr>
</table>

<p>
Bien qu'ajuster la fréquence semble simple à première vue, ce n'est pas une
tâche triviale. Un mauvais algorithme peut changer constamment la fréquence ou
gaspiller de l'énergie en choisissant une fréquence trop élevée.
</p>

<p>
Lequel choisir&nbsp;? Si vous êtes embêté, essayez d'abord
<c>cpufreqd</c>&nbsp;:
</p>

<pre caption="Installer cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> se configure en éditant le fichier
<path>/etc/cpufreqd.conf</path>. Le fichier inclu par défaut dans le paquet peut
vous sembler déroutant. Je vous recommande de le remplacer par celui du
développeur Gentoo Hendrik Brix Andersen (voir ci-dessous). Veuillez notez qu'il
vous faut cpufreqd-2.0.0 ou supérieur car les versions précédentes n'ont pas la
même syntaxe de configuration.
</p>

<pre caption="/etc/cpufreqd.conf (pour cpufreqd-2.0.0 et supérieur)">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=3
enable_plugins=acpi_ac,acpi_battery
enable_remote=1
remote_group=wheel
verbosity=5
[/General]

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand
[/Profile]

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative
[/Profile]

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave
[/Profile]

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance
[/Profile]

[Rule]
name=battery
ac=off
profile=conservative
[/Rule]

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave
[/Rule]

[Rule]
name=ac
ac=on
profile=ondemand
[/Rule]
</pre>

<p>
Vous pouvez maintenant démarrer le démon cpufreqd. Ajoutez-le également aux
niveaux d'exécution <e>default</e> et <e>battery</e>.
</p>

<pre caption="Démarrer cpufreqd">
# <i>rc-update add cpufreqd default battery</i>
# <i>rc</i>
</pre>

<p>
Quelques fois, il est préférable de choisir une politique différente de celle
qu'a choisie le démon. Par exemple lorsque la batterie est faible mais que vous
savez que l'alimentation secteur sera bientôt disponible. Dans ce cas, vous
pouvez activer le mode manuel de cpufreqd avec la commande <c>cpufreqd-set
manual</c> et sélectionner la politique désirée (parmi celles listées par
<c>cpufreqd-get</c>). Vous pouvez quitter le mode manuel en tapant
<c>cpufreqd-set dynamic</c>.
</p>

<warn>
Ne lancez pas plus d'un de ces programmes simultanément. Votre ordinateur risque
de ne plus s'arrêter de changer de fréquence...
</warn>

</body>
</section>
<section>
<title>Vérifier les résultats</title>
<body>

<p>
La dernière chose à faire est de vérifier si vos politiques fonctionnent
correctement. Vous pouvez le faire en surveillant la vitesse de l'unité
centrale pendant que vous travaillez avec votre portable.
</p>

<pre caption="Surveiller la vitesse du processeur">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Si <path>/proc/cpuinfo</path> n'est pas mis à jour (voir la «&nbsp;<uri
link="#troubles">Résolution des problèmes</uri>&nbsp;»), surveillez votre
processeur avec&nbsp;:
</p>

<pre caption="Méthode alternative pour surveiller la vitesse du processeur">
# <i>watch x86info -mhz</i>
</pre>

<p>
Selon votre configuration, la vitesse de votre processeur devrait augmenter
lorsque la charge est élevée et diminuer (ou rester constante) lorsqu'il n'y a
pas d'activité.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour l'écran à cristaux liquides</title>
<section>
<body>

<p>
Comme vous pouvez le voir à la <uri link="#doc_chap1_fig1">figure 1.1</uri>,
l'écran à cristaux liquides est le composant le plus énergivore. (Soulignons
que ce n'est pas nécessairement le cas pour les portables équipés de
processeurs qui ne sont pas de type mobile.) Il n'est donc pas seulement
important de fermer l'écran lorsque l'on ne s'en sert pas, mais il faut aussi
réduire la luminosité lorsque possible. La plupart des portables permettent de
contrôler la luminosité.
</p>

</body>
</section>
<section>
<title>Réglage de la pause (standby)</title>
<body>

<p>
La première chose à faire est de vérifier les délais de pause, de suspension et
de mise hors tension. Puisque cela dépend essentiellement de votre gestionnaire
de fenêtres, ce sera à vous de découvrir comment vous y prendre. Voici deux
façons de faire classiques. D'abord, les commandes
<c>setterm -blank &lt;nombre-de-minutesM&gt;</c>, <c>setterm -powersave on</c>
et <c>setterm -powerdown &lt;nombre-de-minutesM&gt;</c> permettent de gérer
l'extinction de l'écran. Ensuite, si vous utilisez Xorg, vous pouvez modifier
le fichier <path>/etc/X11/xorg.conf</path> pour y incorporer ce qui suit&nbsp;:
</p>

<pre caption="Extinction de l'écran avec Xorg et XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># L'écran devient noir après 5 minutes. (Mais il n'est pas vraiment arrêté.)</comment>
  Option  "StandbyTime"  "10"  <comment># Met l'écran en pause après 10 minutes (utilise DPMS).</comment>
  Option  "SuspendTime"  "20"  <comment># Suspend l'écran après 20 minutes.</comment>
  Option  "OffTime"  "30"  <comment># Extinction complète après 30 minutes.</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
La même procédure s'applique à XFree86 et <path>/etc/X11/XF86Config</path>.
</p>

</body>
</section>
<section>
<title>Réglage de la luminosité</title>
<body>

<p>
Le réglage de la luminosité est probablement plus important encore. Si vous
pouvez modifier ce paramètre avec un outil logiciel, écrivez un script qui
réduit la luminosité lorsque la batterie est utilisée et ajoutez-le à votre
niveau d'exécution <e>battery</e>. Le script suivant devrait fonctionner sur la
plupart des portables IBM Thinkpad et Toshiba. Vous devrez activer l'option
appropriée dans votre noyau (pour les IBM Thinkpad) ou installer le paquet
<c>app-laptop/acpitool</c> pour les Toshiba (dans ce cas, sautez la partie
configuration d'ibm_acpi décrite plus bas).
</p>

<warn>
Le réglage de la luminosité est marqué comme expérimental dans ibm-acpi. Il
accède au matériel directement et peut causer de sérieux dommages à votre
système. Veuillez lire le <uri link="http://ibm-acpi.sourceforge.net/">site
d'ibm-acpi</uri>.
</warn>

<p>
Pour pouvoir régler la luminosité, le module ibm_acpi doit avoir été chargé avec
le paramètre experimental.
</p>

<pre caption="Charger automatiquement le module ibm_acpi">
<comment>(Veuillez lire les avertissements avant de faire ceci !)</comment>
# <i>echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
# <i>/sbin/modules-update</i>
# <i>echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
# <i>modprobe ibm_acpi</i>
</pre>

<p>
Cela devrait marcher sans message d'erreur et un fichier
<path>/proc/acpi/ibm/brightness</path> a dû être créé lors du chargement du
module. Un script d'initialisation s'occupera de choisir la bonne luminosité en
fonction de la source d'alimentation.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Voir /proc/acpi/ibm/brightness pour les valeurs disponibles.</comment>
<comment># Veuillez lire /usr/src/Documentation/ibm-acpi.txt</comment>

<comment># Niveau de luminosité en mode ac. 7 par défaut.</comment>
BRIGHTNESS_AC=7

<comment># Niveau de luminosité en mode battery. 4 par défaut.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    elif [[ -e /usr/bin/acpitool &amp;&amp; -n $(acpitool -T | grep "LCD brightness") ]]
    then
        ebegin "Setting LCD brightness"
        acpitool -l $LEVEL >/dev/null || ewarn "Unable to set lcd brightness"
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "For IBM Thinkpads, check that ibm_acpi is loaded into the kernel"
        ewarn "For Toshiba laptops, you've got to install app-laptop/acpitool"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Ensuite, activez l'ajustement automatique de la luminosité en ajoutant ce script
au niveau d'exécution «&nbsp;battery&nbsp;».
</p>

<pre caption="Activer le réglage automatique de la luminosité">
# <i>chmod +x /etc/init.d/lcd-brightness</i>
# <i>rc-update add lcd-brightness battery</i>
# <i>rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour le disque dur</title>
<section>
<body>

<p>
Les disques durs consomment moins d'énergie en mode sommeil. Il est donc logique
d'activer la fonctionnalité d'économie d'énergie lorsque le disque dur n'est pas
utilisé depuis un certain temps. Je vous montrerai deux possibilités
alternatives pour cela. Tout d'abord, le laptop-mode économisera la plupart de
l'énergie grâce à plusieurs mesures qui empêchent ou retardent l'écriture sur le
disque. L'inconvénient de cette technique est que, en cas de coupure électrique
ou de crash du noyau, des données seront perdues car non encore écrites sur le
disque. Si cela ne vous convient pas, assurez-vous qu'aucun processus n'écrit
fréquemment sur le disque. La deuxième alternative est la possibilité d'activer
l'économie d'énergie de votre disque dur via hdparm.
</p>

</body>
</section>
<section>
<title>Augmenter le temps d'inactivité avec laptop-mode</title>
<body>

<p>
Les noyaux récents (2.6.6 et ultérieurs, les derniers de la série 2.4 et
d'autres grâce à des correctifs) supportent ce que l'on appelle
<e>laptop-mode</e>. Lorsque ce mode est activé, le contenu des tampons n'est
écrit sur le disque qu'après 10 minutes (plutôt que 30 secondes) ou sur
demande (lors des demandes de lecture sur le disque). Cela minimise le temps
pendant lequel le disque dur doit être actif.
</p>

<pre caption="Démarrage automatique du laptop-mode">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
Le fichier <path>/etc/laptop-mode/laptop-mode.conf</path> permet de configurer
<c>laptop-mode-tools</c>. Ajustez les options en suivant les instructions
incluses dans le fichier. Lancez <c>rc-update add laptop_mode battery</c>
pour qu'il démarre automatiquement.
</p>

<p>
Les versions récentes (à partir de 1.11) de laptop-mode-tools incluent un nouvel
outil <c>lm-profiler</c>. Il supervisera l'utilisation du disque et les services
réseaux de votre système puis vous suggèrera de désactiver ceux qui ne sont pas
utilisés. Vous pourrez alors les désactiver via le support intégré des niveaux
d'exécution de laptop-mode-tools ou en utilisant vos niveaux
<e>default</e> et <e>battery</e> (recommandé).
</p>

<pre caption="Exemple d'exécution de lm-profiler">
# lm-profiler
Profiling session started.
Time remaining: 600 seconds
[4296896.602000] amarokapp
Time remaining: 599 seconds
[4296897.714000] sort
[4296897.970000] mv
Time remaining: 598 seconds
Time remaining: 597 seconds
[4296900.482000] reiserfs/0
</pre>

<p>
Au bout de six minutes, lm-profiler aura établi un profil de votre système qui
lui permettra de vous lister les services qui ont causé des accès disques
pendant cette période.
</p>

<pre caption="lm-profiler suggère la désactivation de services">
Program:     "atd"
Reason:      standard recommendation (program may not be running)
Init script: /etc/init.d/atd (GUESSED)
Do you want to disable this service in battery mode? [y/N]: n
</pre>

<p>
Pour désactiver atd, comme suggéré dans l'exemple ci-dessus, lancez <c>rc-update
del atd battery</c>. Faites attention à ne pas désactiver des services
nécessaires au fonctionnement de votre système&nbsp;; il est probable que
lm-profiler vous renverra des faux-positifs. Ne désactivez pas un service si
vous ne savez pas à quoi il sert.
</p>

</body>
</section>
<section>
<title>Limiter les accès en écriture</title>
<body>

<p>
Si vous ne voulez pas utiliser le laptop-mode, vous devez prendre soin de
désactiver tous les services qui écrivent régulièrement sur le disque&nbsp;:
<c>syslog</c> est un bon candidat par exemple. Vous ne voudrez peut-être pas le
couper complètement mais vous pouvez modifier sa configuration pour ne pas
journaliser d'événements superflus, ce qui diminuera le trafic vers votre disque
dur. Cups aussi écrit sur le disque régulièrement, nous vous recommandons de le
désactiver et de ne l'activer manuellement que lorsque vous en avez besoin.
</p>

<pre caption="Désactiver cups en mode battery">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
Vous pouvez aussi utiliser <c>lm-profiler</c> contenu dans le paquet
laptop-mode-tools (voir plus haut) pour trouver les services à désactiver. Une
fois que vous les aurez tous éliminés, continuez avec la configuration de
hdparm.
</p>

</body>
</section>
<section>
<title>hdparm</title>
<body>

<p>
La deuxième méthode utilise un petit script et le programme hdparm. Créez le
fichier <path>/etc/init.d/pm.hda</path> et copiez-y ce qui suit&nbsp;:
</p>

<pre caption="Utiliser hdparm pour la mise en veille des disques">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Consultez <c>man hdparm</c> pour en connaître les options. Lorsque votre script
est prêt, ajoutez-le au niveau d'exécution battery.
</p>

<pre caption="Automatiser la mise en veille des disques">
# <i>chmod +x /etc/init.d/pmg_hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pmg_hda battery</i>
</pre>

<impo>
Soyez précautionneux lorsque vous décidez des délais pour l'arrêt de votre
disque dur. Utiliser des temps très courts pourrait user votre disque et
invalider votre garantie.
</impo>

</body>
</section>
<section>
<title>Quelques trucs</title>
<body>

<p>
Une autre possibilité est de désactiver la mémoire virtuelle en mode batterie.
Avant d'écrire un script pour exécuter swapon/swapoff, assurez-vous d'avoir
assez de mémoire vive et que vous n'utilisez pas une grande quantité de mémoire
virtuelle. Autrement, vous allez à l'encontre de graves problèmes.
</p>

<p>
Si vous ne voulez pas utiliser laptop-mode, vous pouvez tout de même limiter
l'accès au disque en montant <e>tempfs</e> sur certains répertoires. (Les
données écrites sont alors conservées dans la mémoire principale plutôt que sur
le disque et le contenu est perdu lors du démontage.) Il peut être pratique de
monter ce système sur <path>/tmp</path>. Après tout, le contenu de ce
répertoire importe peu puisqu'il est de toute façon supprimé à chaque
redémarrage. Que ce contenu ait été conservé sur le disque ou en mémoire ne
change rien. Assurez-vous toutefois d'avoir assez de mémoire vive et qu'aucun
programme (par exemple un client de téléchargement ou un utilitaire de
compression) n'a besoin d'un espace disque phénoménal dans <path>/tmp</path>.
Pour activer cette fonction, ajoutez le support pour tempfs à votre noyau et la
ligne suivante au fichier <path>/etc/fstab</path>&nbsp;:
</p>

<pre caption="Éditer /etc/fstab pour rendre /tmp encore plus volatil">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Faites attention au paramètre «&nbsp;size&nbsp;». Modifiez-le pour l'adapter à
votre système. Si vous n'êtes pas sûr de vous, mieux vaut ne pas essayer. Cette
configuration peut limiter vos performances par un effet d'entonnoir. Si vous
voulez un système de fichier tempfs sur <path>/var/log</path>, assurez-vous de
fusionner les fichiers au disque avant de le démontage. Ils sont essentiels.
N'essayez pas de monter un tempfs sur /var/tmp. Portage utilise ce répertoire
pour compiler...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Gestion de l'alimentation pour les autres composants</title>
<section>
<title>Les cartes graphiques</title>
<body>

<p>
Dans le cas où vous posséderiez une carte graphique ATI qui supporte le
PowerPlay (technique d'ajustement dynamique de l'horloge du processeur
graphique), vous pouvez activer cette fonctionnalité dans Xorg. Ouvrez le
fichier <path>/etc/X11/xorg.conf</path> et ajoutez (ou activez) l'option
<c>DynamicClocks</c> dans la section <e>Device</e>. Veuillez noter que cette
option pourrait faire planter votre système.
</p>

<pre caption="Activer le support ATI PowerPlay dans Xorg">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>

</body>
</section>
<section>
<title>Gestion de l'alimentation pour les cartes réseau sans fil</title>
<body>

<p>
Les cartes réseau sans fil consomment une quantité non négligeable d'énergie.
Cette consommation peut être gérée de façon analogue à ce qui a été décrit pour
le disque dur avec le script pmg_hda.
</p>

<note>
Ce script suppose que votre interface sans fil se nomme <c>wlan0</c>&nbsp;;
faites les corrections appropriées.
</note>

<pre caption="Gestion automatique de l'alimentation pour les cartes réseau sans fil">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
L'exécution de ce script active la gestion de l'alimentation pour wlan0.
Sauvegardez ce script sous le nom <path>/etc/init.d/pmg_wlan0</path> et
ajoutez-le au niveau d'exécution battery (comme vous avez fait pour le script
pour le disque dur). Consultez <c>man iwconfig</c> pour connaître les
différentes options telles que les durées avant la mise en veille de
l'interface.  Si votre pilote et votre point d'accès permettent de changer le
délai de reconnaissance de l'émission de la balise (en anglais «&nbsp;beacon
time&nbsp;»), cela peut vous servir de point de départ pour économiser encore
davantage d'énergie.
</p>

<pre caption="Gestion de l'alimentation pour les cartes réseau sans fil">
# <i>chmod +x /etc/init.d/pmg_wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pmg_wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>Gestion de l'alimentation pour les périphériques USB</title>
<body>

<p>
Il existe deux problèmes liés à la consommation d'énergie par les périphériques
USB. Premièrement, les périphériques tels que les souris, caméras numériques et
clés USB consomment de l'énergie lorsqu'ils sont branchés. Vous n'y pouvez
rien, si ce n'est les débrancher lorsqu'ils ne servent pas. Deuxièmement,
lorsque des périphériques USB sont branchés, le contrôleur USB hôte accède
périodiquement au bus, ce qui empêche le processeur d'entrer dans un état de
veille. Le noyau offre une fonctionnalité expérimentale pour activer la
suspension des périphériques USB au moyen d'appels au pilote ou à un des
fichiers <path>power/state</path> dans <path>/sys/</path>.
</p>

<pre caption="Activer le support de la mise en veille de l'USB dans le noyau Linux">
Device Drivers
  USB support
    [*]   Support for Host-side USB
      [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>États de veille&nbsp;: suspension, mise en veille et hibernation</title>
<section>
<body>

<p>
L'ACPI définit plusieurs états de veille. Les principaux sont&nbsp;:
</p>

<ul>
  <li>S1 ou pause («&nbsp;standby&nbsp;»)&nbsp;;</li>
  <li>
    S3 ou suspension en mémoire vive ou encore mise en veille
    («&nbsp;sleep&nbsp;»)&nbsp;;
  </li>
  <li>
    S4 ou suspension sur le disque ou encore hibernation
    («&nbsp;hibernate&nbsp;»).
  </li>
</ul>

<p>
Ces états peuvent être utilisés dès que vous ne travaillez pas sur votre
portable mais que vous ne voulez pas l'éteindre afin d'éviter le long délai
nécessaire au démarrage.
</p>

</body>
</section>
<section>
<title>Pause (S3)</title>
<body>

<p>
Le support pour les états de veille ACPI est considéré expérimental pour de
bonnes raisons. Les états de veille APM semblent plus stables, mais vous ne
pouvez pas utiliser à la fois ACPI et APM.
</p>

<pre caption="Configuration du noyau pour divers types de mises en veille">
  Power Management Options ---&gt;
    [*]  Power Management support
      ACPI (Advanced Configuration and Power Interface) Support ---&gt;
        [*]  ACPI Support
          [*]   Sleep States
</pre>

<p>
Une fois que le noyau est correctement configuré, vous pouvez utiliser
<c>hibernate-script</c> pour activer la mise en veille. Installons d'abord ce
script.
</p>

<pre caption="Installer hibernate-script">
# <i>emerge hibernate-script</i>
</pre>

<p>
Ce programme se configure dans le fichier <path>/etc/hibernate</path>. Le paquet
fournit par défaut les deux fichiers <path>hibernate.conf</path> et
<path>ram.conf</path>. <c>UseSysfsPowerState mem</c> est déjà configuré
correctement, mais vous devez passer en revue le reste de la configuration pour
l'adapter à votre système. Les commentaires et le nom des options devraient vous
guider. Si vous utilisez des partages nfs ou samba sur votre réseau,
assurez-vous d'appeler les bons scripts d'initialisation pour les couper
proprement.
</p>

<p>
Vous êtes prêt&nbsp;? C'est votre dernière chance de sauvegarder vos données
avant d'exécuter la prochaine commande. Notez que vous devrez probablement taper
une touche particulière comme <e>Fn</e> pour revenir de la mise en veille.
</p>

<pre caption="Passer en veille">
# <i>hibernate-ram</i>
</pre>

<p>
Vous pouvez aussi lancer la pause (Standby ou S1) d'une manière similaire en
copiant <path>ram.conf</path> vers <path>standby.conf</path> et en créant un
lien symbolique <path>/usr/sbin/hibernate-standby</path> pointant vers
<path>/usr/sbin/hibernate</path>. Les modes S3 et S4 sont les plus intéressants
à cause de leurs meilleures capacités d'économie d'énergie.
</p>

</body>
</section>
<section>
<title>Hibernation (S4)</title>
<body>

<p>
Cette section introduit l'hibernation, qui consiste en une capture du système
écrite sur disque juste avant d'éteindre l'ordinateur. Lors de la reprise, la
capture est restaurée et vous pouvez reprendre votre travail exactement au point
où vous l'avez laissé.
</p>

<warn>
N'installez pas du matériel non installable à chaud pendant l'hibernation.
N'essayez pas de charger la capture avec un noyau différent que celui qui a
servi à la créer. Coupez tous les clients NFS ou Samba avant de passer en
hibernation.
</warn>

<p>
Il existe deux implémentations différentes pour S4. L'originale est swsusp.
swsusp2, plus récent, a une interface plus agréable (qui inclut le support de
«&nbsp;fbsplash&nbsp;»). Un <uri
link="http://suspend2.net/features.html#compare">comparatif de
fonctionnalités</uri> est disponible sur le <uri link="http://suspend2.net">site
de suspend2</uri>. Fût un temps, il y eu Suspend-to-Disk (pmdisk), dérivé de
swsusp, mais les modifications ont été ramenées.
</p>

<p>
Suspend2 est pas encore inclus dans Linux. Vous devez donc soit appliquer les
correctifs fournis par <uri link="http://suspend2.net">suspend2.net</uri> sur
les sources du noyau, soit utiliser <c>sys-kernel/suspend2-sources</c>.
</p>

<p>
Voici la configuration du noyau pour swusp et suspend2&nbsp;:
</p>

<pre caption="Configuration pour différents types d'états de veille">
Power Management Options ---&gt;
  <comment>(Hibernation avec swsusp)</comment>
  [*] Software Suspend

  <comment>(Hibernation avec suspend2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]     File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(Remplacez /dev/SWAP par votre partition de swap)</comment>
    (swap:/dev/SWAP)    Default resume device name
    [ ]     Allow Keep Image Mode
</pre>

<p>
La configuration de swusp est plutôt facile. Si vous n'avez pas indiqué le nom
de votre partition de swap dans la configuration du noyau, vous pouvez lui
indiquer lors du démarrage grâce à la directive <c>resume=/dev/SWAP</c>. Si le
démarrage est impossible à cause d'une image défectueuse, utilisez le paramètre
<c>noresume</c>. Le script d'initialisation <c>hibernate-cleanup</c> se chargera
de libérer les images inutilisées lors de la procédure de démarrage du système.
</p>

<pre caption="Invalider les images swusp lors du démarrage">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Pour permettre à swusp de gérer l'hibernation, utilisez le script hibernate et
mettez <c>UseSysfsPowerState disk</c> dans le fichier
<path>/etc/hibernate/hibernate.conf</path>.
</p>

<warn>
Sauvegardez vos données avant de tenter ceci. Exécutez <c>sync</c> avant
d'exécuter ces commandes afin que les données du cache soient écrites sur le
disque. Essayez d'abord hors de l'environnement X, puis dans cet environnement
mais sans session ouverte.
</warn>

<p>
Si vous rencontrez des erreurs du type «&nbsp;kernel panic&nbsp;» à cause de
uhci ou d'une fonctionnalité similaire, essayez de compiler le support USB
comme un module et déchargez les modules avant d'entrer dans un état de veille.
Des options sont disponibles à cet effet dans le fichier
<path>hibernate.conf</path>.
</p>

<pre caption="L'hibernation avec swusp">
# <i>nano -w /etc/hibernate.conf</i>
<comment>(Assurez-vous d'avoir sauvé vos fichiers.)</comment>
# <i>hibernate</i>
</pre>

<p>
La suite de cette section décrit l'installation de suspend2 avec le support
fbsplash pour avoir une barre de défilement graphique pendant la mise en veille
et le réveil.
</p>

<p>
La première partie de la configuration est similaire à celle swusp. Au cas où
vous n'auriez pas indiqué le nom de votre partition de swap au noyau pendant la
configuration de celui-ci, vous devez lui indiquer grâce au paramètre de
démarrage <c>resume2=swap:/dev/SWAP</c>. Si le démarrage est impossible à cause
d'une image défectueuse, ajoutez le paramètre <c>noresume2</c>. De plus, le
script d'initialisation <c>hibernate-cleanup</c> se chargera de libérer les
images suspend2 inutilisées lors de la procédure de démarrage du système.
</p>

<pre caption="Invalider les images suspend2 lors du démarrage">
# <i>rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Éditez maintenant le fichier <path>/etc/hibernate/hibernate.conf</path>, activez
la section <e>suspend2</e> et commentez tout dans les sections
<e>sysfs_power_state</e> et <e>acpi_sleep</e>. N'activez pas la partie fbsplash
dans les options globales pour le moment.
</p>

<pre caption="Hiberner avec suspend2">
# <i>nano -w /etc/hibernate.conf</i>
<comment>(Assurez-vous d'avoir sauvé vos fichiers ouverts.)</comment>
# <i>hibernate</i>
</pre>

<p>
Nous pouvons maintenant passer à la configuration de fbsplash. Le paquet
<c>sys-apps/suspend2-userui</c> est nécessaire pour l'activer pendant
l'hibernation. De plus, vous devez activer l'option USE <e>fbsplash</e>.
</p>

<pre caption="Installer suspend2-userui">
# <i>mkdir -p /etc/portage</i>
# <i>echo sys-apps/suspend2-userui fbsplash >> /etc/portage/package.use</i>
# <i>emerge suspend2-userui</i>
</pre>

<p>
L'ebuild vous indique de créer un lien symbolique vers le thème que vous voulez
utiliser. Par exemple, pour le thème <c>livecd-2005.1</c>, lancez la commande
suivante&nbsp;:
</p>

<pre caption="Utiliser le thème livecd-2005.1 pendant l'hibernation">
# <i>ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
Si vous ne voulez pas un écran noir dans la première partie du réveil, vous
devez ajouter l'outil <c>suspend2ui_fbsplash</c> à votre image initrd. En
supposant que vous ayez créé cette image avec <c>splash_geninitramfs</c> et que
vous l'ayez nommée <path>/boot/fbsplash-emergence-1024x768</path>, voici comment
procéder.
</p>

<pre caption="Ajouter suspend2ui_fbsplash à une image initrd">
# <i>mount /boot</i>
# <i>mkdir ~/initrd.d</i>
# <i>cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
# <i>cd ~/initrd.d</i>
# <i>gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
# <i>rm fbsplash-emergence-1024x768</i>
# <i>cp /usr/sbin/suspend2ui_fbsplash sbin/</i>
# <i>find . | cpio --quiet --dereference -o -H newc | gzip -9 > /boot/fbsplash-suspend2-emergence-1024x768</i>
</pre>

<p>
Ensuite, ajustez votre <path>grub.conf</path> (ou <path>lilo.conf</path>) pour
que votre noyau suspend2 utilise
<path>/boot/fbsplash-suspend2-emergence-1024x768</path> comme image initrd. Vous
pouvez maintenant tester si tout fonctionne correctement.
</p>

<pre caption="Test de l'hibernation avec fbsplash">
# <i>suspend2ui_fbsplash -t</i>
</pre>

<p>
Enfin, ouvrez le fichier <path>/etc/hibernate/hibernate.conf</path> une nouvelle
fois et activez l'option fbsplash. Exécutez <c>hibernate</c> et appréciez.
</p>

</body>
</section>
</chapter>

<chapter id="troubles">
<title>Résolution des problèmes</title>
<section>
<body>

<p>
<e>Q:</e> J'essaie de changer la fréquence de l'unité centrale, mais
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> n'existe pas.
</p>

<p>
<e>R:</e> Assurez-vous que votre processeur supporte l'échelonnage de la
fréquence et que vous avez choisi le pilote CPUFreq correspondant à votre
processeur. Voici une liste des processeurs supportés par cpufreq (avec le
noyau 2.6.7)&nbsp;: ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400,
SC410, AMD K6-2+ mobile, AMD K6-3+ mobile, AMD Duron mobile, AMD Athlon mobile,
AMD Opteron, AMD Athlon 64, Cyrix Media GXm, Intel PIII mobile et Intel PIII-M
mobile (avec certains jeux de composants), Intel Pentium 4, Intel Xeon, Intel
Pentium M (Centrino), National Semiconductors Geode GX, Transmeta Crusoe, VIA
Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, plusieurs PowerBook et iBook2
et divers processeurs utilisés sur des systèmes compatibles avec ACPI 2.0
(seulement si l'option «&nbsp;ACPI Processor Performance States&nbsp;» est
disponible dans l'interface BIOS/ACPI).
</p>

<p>
<e>Q:</e> Mon processeur supporte l'échelonnage de la fréquence, mais
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> est vide.
</p>

<p>
<e>R:</e> Cherchez des messages d'erreurs ACPI avec <c>dmesg | grep ACPI</c>.
Essayez de mettre votre BIOS à jour, particulièrement si un mauvais
fonctionnement de DSDT est rapporté. Vous pouvez également essayer de corriger
la situation vous-même (ce qui dépasse le cadre de ce guide).
</p>

<p>
<e>Q:</e> Mon portable supporte l'échelonnage de la fréquence, mais selon
/proc/cpuinfo, la vitesse ne change pas.
</p>

<p>
<e>R:</e> Vous avez probablement activé le support multiprocesseurs symétrique
(CONFIG_SMP) dans votre noyau. Désactivez cette option et le problème devrait
disparaître. Il y avait un bogue dans certains vieux noyaux causant ce
problème. Si c'est votre cas, exécutez <c>emerge x86info</c>, mettez votre
noyau à jour et vérifiez la vitesse actuelle du processeur avec <c>x86info
-mhz</c>.
</p>

<p>
<e>Q:</e> Je peux changer la fréquence du processeur, mais la plage disponible
est plus restreinte qu'elle ne l'est dans un autre système d'exploitation.
</p>

<p>
<e>R:</e> Vous pouvez combiner l'échelonnage de la fréquence avec la régulation
du temps processeur ACPI («&nbsp;ACPI CPU throttling&nbsp;») pour obtenir une
fréquence minimale plus basse. Notez que la régulation du temps processeur ne
sauve pas beaucoup d'énergie et sert plutôt à la gestion de la dissipation de
la chaleur (afin de garder votre portable froid et silencieux). Vous pouvez
consulter l'état de régulation du temps processeur avec <c>cat
/proc/acpi/processor/CPU/throttling</c> et le changer avec <c>echo -n "0:x" >
/proc/acpi/processor/CPU/limit</c>, où x est un des états Tx listés dans
<path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>Q:</e> Lorsque je configure le noyau, les gouverneurs
«&nbsp;powersave&nbsp;», «&nbsp;performance&nbsp;» et «&nbsp;userspace&nbsp;»
sont disponibles, mais pas «&nbsp;ondemand&nbsp;». Comment puis-je
l'activer&nbsp;?
</p>

<p>
<e>R:</e> Le gouverneur «&nbsp;ondemand&nbsp;» n'est disponible que dans les
noyaux récents. Essayez de mettre le votre à jour.
</p>

<p>
<e>Q:</e> La durée de vie de la batterie semble moindre qu'avant.
</p>

<p>
<e>R:</e> Vérifiez les paramètres du BIOS. Peut-être avez-vous oublié de
réactiver certaines options.
</p>

<p>
<e>Q:</e> Ma batterie est chargée, mais KDE rapporte un niveau de charge de 0 %
et éteint le système aussitôt.
</p>

<p>
<e>R:</e> Vérifiez que le support pour la batterie est compilé dans le noyau.
Si vous l'utilisez comme module, assurez-vous que celui-ci est chargé.
</p>

<p>
<e>Q:</e> Mon système de journalisation reporte quelque chose comme
«&nbsp;logger: ACPI group battery / action battery is not defined&nbsp;».
</p>

<p>
<e>R:</e> Ce message est généré par le script <path>/etc/acpi/default.sh</path>
livré avec acpid, vous pouvez tranquillement l'ignorer. Si vous voulez supprimer
ce message, commentez la ligne appropriée dans le script&nbsp;:
</p>

<pre caption="Désactiver les avertissements à propos d'événements ACPI inconnus">
        *)      # logger "ACPI action $action is not defined"
</pre>

<p>
<e>Q:</e> J'ai un portable Dell Inspiron 51XX et je n'obtiens aucun événement
ACPI.
</p>

<p>
<e>R:</e> Cela semble être un bogue dans le noyau. Consultez <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">cette page</uri>.
</p>

<p>
<e>Q:</e> J'ai activé l'option DynamicClocks dans <path>xorg.conf</path> et
maintenant Xorg plante / l'écran reste noir / mon portable ne s'éteint plus
correctement.
</p>

<p>
<e>R:</e> Cela arrive sur certains systèmes. Vous devez désactiver
DynamicClocks.
</p>

<p>
<e>Q:</e> Je veux utilisez suspend2 mais il me dit que ma partition d'échange
est trop petite. Je ne peux pas l'agrandir.
</p>

<p>
<e>R:</e> Si vous disposez d'assez d'espace sur votre système, vous pouvez
enregistrer la capture dans un fichier plutôt que dans la swap.
<c>hibernate-script</c> sait le faire. Vous trouverez plus d'information à ce
sujet dans le fichier
<path>/usr/src/linux/Documentation/power/suspend2.txt</path>.
</p>

<p>
<e>Q:</e> Je viens d'acheter une batterie, mais elle ne dure que quelques
minutes&nbsp;! Où est mon erreur&nbsp;?
</p>

<p>
<e>R:</e> Suivez d'abord les instructions du constructeur expliquant comment
charger la batterie correctement.
</p>

<p>
<e>Q:</e> Ce qui précède ne m'a pas aidé. Que devrais-je faire&nbsp;?
</p>

<p>
<e>R:</e> Certaines batteries prétendument neuves sont en fait usagées.
Essayez ce qui suit&nbsp;:
</p>

<pre caption="Vérifier l'état de la batterie">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Si la valeur de «&nbsp;last full capacity&nbsp;» diffère
significativement de celle de «&nbsp;design capacity&nbsp;», votre batterie est
probablement défaillante. Essayez de faire jouer votre garantie.
</p>

<p>
<e>Q:</e> Mon problème n'est pas mentionné ci-dessus. Que puis-je faire&nbsp;?
</p>

<p>
N'hésitez pas à me contacter (<mail link="earthwings@gentoo.org">Dennis
Nienhüser</mail>) directement. Les <uri link="http://forums.gentoo.org">Forums
Gentoo</uri> sont également un bon endroit pour trouver de l'aide. Si vous
préférez IRC, essayez le canal <e>#gentoo-laptop</e> sur
<e>irc.freenode.net</e>.
</p>

</body>
</section>
</chapter>
</guide>
