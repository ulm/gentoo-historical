<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/cvs-tutorial-fr.html">
<title>Tutoriel CVS de Gentoo Linux</title>
<author title="Chief Architect" email="drobbins@gentoo.org">Daniel Robbins</author>
<author title="Traducteur" email="pierre.habouzit@m4x.org">Pierre Habouzit</author>

<version>1.1</version>
<date>10 Aug 2001</date>

<abstract>
    Ce tutoriel va présenter aux lecteurs le système CVS (Concurrent Versions System),
    utilisé par beaucoup de développeurs de par le monde pour développer des logiciels
    en collaboration, dans un environnement souple. Destiné aux utilisateurs débutants de CVS,
    ce tutoriel va permettre à la fois aux utilisateurs occasionnels et aux nouveaux développeurs
    de travailler beaucoup plus efficacement. Que vous désiriez utiliser CVS pour faire un
    "check out" des dernières sources d'un logiciel donné, ou que vous l'utilisiez en tant
    que développeur expérimenté, ce tutoriel est fait pour vous.
</abstract>

<chapter>
<title>Introduction</title>

<section>
<title>Organisation du Tutoriel</title>
<body>
    <p>
	Ce tutoriel a deux parties. La première explique comment utiliser CVS
    lorsqu'on n'est
	pas développeur, c'est à dire comment récupérer des sources par CVS et les garder à jour.
	La seconde partie vous présente comment utiliser CVS pour développer, en vous montrant
	comment modifier, ajouter, retirer des fichiers sur CVS, ainsi que comment réaliser pleins
	d'autres tâches concernant les développeurs.
	Si vous ne connaissez rien à CVS, il est recommandé de commencer par lire la première partie,
	puis la seconde ; si vous avez une petite expérience de CVS, mais que vous allez l'utiliser
	en tant que véritable développeur pour la première fois, vous trouverez votre bohneur
	dans la seconde partie (mais vous pouvez aussi avoir envie de parcourir rapidement
	la première partie).
    </p>
</body>
</section>

<section>
<title>Qu'est ce que CVS, et qu'est ce que ca fait ?</title>
<body>
    <p>
	CVS est un système client/serveur qui permet aux développeurs de conserver
	leurs projets sur un serveur central, appelé repository. En utilisant les
	clients cvs et les outils associés, les développeurs peuvent faire des modifications
	du contenu de la repository. En fait, la repository cvs conserve chaque changement
	fait sur chaque fichier, créant ainsi un historique complet de toute l'évolution
	du développement du projet. Les développeurs peuvent demander des versions antérieures
	d'un fichier particulier, regarder un log des modifications, et réaliser au besoin
	plusieurs autres actions utiles.
    </p>
</body>
</section>

<section>
<title>Le rôle de CVS</title>
<body>
    <p>
	Un nombre conséquent de projets ont leurs propres serveurs CVS, qui sont utilisés
	par les développeurs du projet de repository centrale pour tous leurs travaux.
	Les développeurs font quotidiennement des améliorations aux sources dans la repository CVS;
	et souvent, ces développeurs sont dispersés dans le monde entier, ainsi CVS leur fournit
	les mécanismes nécessaires pour unifier leur projet dans une structure centralisée 
	et cohérente. CVS crée le "liant organisationnel" qui permet à ces développeurs
	d'améliorer leur code sans se marcher sur les pieds, en perdant des données importantes
	ou en étant bloqué par l'impossiblité de mettre à jour certains fichiers crititques.
    </p>
</body>
</section>

<section>
<title>CVS -- les dernières sources du programmeur</title>
<body>
    <p>
	Quand les programmeurs sont prêts, ils vont empaqueter leur travail actuel
	sur CVS dans un fichier tar.gz et le publier comme une nouvelle version
	de leur logiciel. Pourtant, parfois, la dernière version officielle n'est
	pas très assez récente pour vous, pour diverses raisons. Dans la première partie
	de ce tutoriel, je vais vous montrer comment utiliser CVS dans ce but : récupérer
	la varsion de développement la plus récente et la plus complète des sources
	pour votre usage personnel.
    </p>
</body>
</section>

<section>
<title>CVS -- l'avez vous ?</title>
<body>
    <p>
	Avant que vous puissiez utiliser CVS, vous devez l'installer sur votre système.
	Le moyen le plus simple de vérifier si cvs est installé chez vous, et de taper :
    </p>
<pre>
# <i>cvs</i>
</pre>
    <p>
	Si la commande cvs est trouvée, alors c'est bon. Sinon, vous devez soit récupérer
	un paquet de binaires pour votre distribution, ou l'installer depuis les sources.
	Installer CVS depuis les sources est plutôt simple, et je vous montre comment le
	faire un peu plus loin.
    </p>
</body>
</section>


<section>
<title>Installer CVS depuis les sources</title>
<body>
    <p>
	Installer CVS depuis les sources est facile. Tout d'abord, récupérez le tarball
	cvs-1.11.tar.gz depuis <uri>ftp://ftp.cvshome.org/pub/cvs-1.11/cvs-1.11.tar.gz</uri>
	(si il y a une version plus récente répertoriée <uri link="ftp://ftp.cvshome.org/pub/">ici</uri>,
	vous pouvez aussi bien récupérer la nouvelle à la place). Ensuite, procédez comme suit (la sortie
	standard a été omise) :
    </p>
<pre>
# <i>tar xzvf cvs-1.11.tar.gz</i>
# <i>cd cvs-1.11</i>
# <i>./configure</i>
# <i>make</i>
# <i>make install</i>
</pre>
    <p>
	maintenant, vous êtes prêts à travailler.
    </p>
</body>
</section>

<section>
<title>Le CVSROOT</title>
<body>
    <p>
	Avant de commencer, il y a quelques fondamentaux à connaitre. Le premier est que
	pour se connecter sur une repository CVS, vous devez tout d'abord renseigner un chemin
	appelé le CVSROOT (la racine CVS). CVSROOT est une chaîne de caractères, un peu comme
	une URL, qui dit à la commande cvs ou se trouve la repository distante, et comment
	on aimerait s'y connecter. Juste pour rendre les choses plus intéressantes, CVS supporte
	de nombreux formats pour CVSROOT, dépendant du fait que la repository soit locale ou
	distante, et dépendant de la méthode utilisée pour s'y connecter. Voici quelques
	exemples de CVSROOT avec des explications ...
    </p>
</body>
</section>

<section>
<title>Une racine CVS locale</title>
<body>
    <pre>CVSROOT=/home/cvsroot</pre>
    <p>
	C'est un exemple de chemin pour une racine CVS locale; vous devriez utiliser
	une telle variable si vous voulez vous connecter à une repository locale
	située en /home/cvsroot; ou bien, vous pouvez aussi avoir une repository locale
	montée via NFS en /home/cvsroot.
    </p>
</body>
</section>

<section>
<title>une racine CVS pour un pserver distant (remote password server)</title>
<body>
    <pre>CVSROOT=:pserver:cvs@foo.bar.com:/home/cvsroot</pre>
    <p>
	C'est un exemple de CVSROOT pour une repository existant sur l'hôte
	foo.bar.com et qui réside dans le /home/cvsroot de cette machine.
	La partie ":pserver:" indique à notre client qu'il doit se connecter
	à cette machine distante en utilisant le protocole pserver, un
	protocole incorporé à CVS. Typiquement, les repository CVS publiques
	utilisent des pserver pour autoriser l'accès à des utilisateurs anonymes.
    </p>
</body>
</section>

<section>
<title>Une racine CVS avec accès distant par rsh/ssh</title>
<body>
    <pre>CVSROOT=drobbins@foo.bar.com:/data/cvs</pre>
    <p>
	C'est un exemple de CVSROOT pour utiliser le protocole RSH ou SSH ;
	dans cet exemple, le serveur CVS va accéder à la repository sur
	foo.bar.com via le compte drobbins. Si la variable d'environnement
	est positionnée à "ssh", le client cvs va utiliser ssh pour se connecter;
	sinon, rsh est utilisé par défaut. L'accès par ssh est plus populaire chez
	ceux qui aiment la sécurité; mais ni rsh, ni ssh ne permettent 	des accès 
	anonymes aux sources. Pour utiliser cette méthode, il faut absolument
	avoir un compte sur foo.bar.com.
    </p>
</body>
</section>

<section>
<title>Quelques précisions...</title>
<body>
    <p>
	En plus de la racine CVS, vous allez avoir besoin du nom du module
	(groupe de sources) que vous voudriez récupérer, ainsi que le mot de passe
	anonyme que vous devrez utiliser pour vous logguer au serveur CVS.
	à l'inverse des ftp anonymes, il n'y a pas de format "standard"
	pour les mots de passe anonymes, il faudra donc récupérer les mot de passe
	spécifiques publiés sur le site web du développeur, ou le demander aux développeurs
	eux-mêmes. Avec ces informations, vous êtes prêt à commencer.
    </p>
</body>
</section>

<section>
<title>Utiliser CVS, Partie 1</title>
<body>
    <p>
	Récupérer des sources se fait en deux temps. Tout d'abord, il faut se logguer
	au pserver. Ensuite, on récupère les sources avec la commande <c>checkout</c>.
	Voisi un exemple des commandes que l'on peut lancer pour fair un "checkout"
	des dernières sources de Samba :
    </p>
<pre>
# <i>export CVSROOT=:pserver:cvs@pserver.samba.org:/cvsroot</i>
</pre>
    <p>
	Cette première commande positionne la variable d'environnement CVSROOT.
	Si vous ne le faites pas, il faudra faire suivre, à chaque fois,  la commande <c>cvs</c>
	par l'option suivante : <c>-d :pserver:cvs@pserver.samba.org:/cvsroot</c>.
	Exporter la variable CVSROOT permet d'économiser un peu d'écriture.
    </p>
</body>
</section>

<section>
<title>Uiliser CVS, partie 2</title>
<body>
    <p>
	Voici les commandes utiles pour récupérer une copie à jour des sources
	de développement. Vous pouvez sauter le panneau suivant pour lire l'explication
	de ces commandes, et revenir ensuite :
    </p>
<pre>
# <i>cvs login</i>
(Logging in to cvs@pserver.samba.org)
CVS password: <comment>(taper le mot de passe ici)</comment>

# <i>cvs -z5 co samba</i>
U samba/COPYING
U samba/Manifest
U samba/README
U samba/Read-Manifest-Now
U samba/Roadmap
U samba/WHATSNEW.txt
<comment>(c'est juste une partie de la sortie complète de la commande cvs co output)</comment>
</pre>

</body>
</section>

<section>
<title>Utiliser CVS -- l'explication</title>
<body>
    <p>
	La première commande cvs (ci dessus) nous loggue sur le pserver, et la seconde
	demande à notre client de faire un checkout ("co") du module samba, en utilisant
	une compression de type gzip de niveau 5 ("-z5") pour accélérer la transmission
	sur une connexion lente. Pour chaque nouveau fichier créé localement, cvs affiche
	"U [fichier]", ce qui indique que ce fichier a bien été mis à jour sur le disque
	(Updated).
    </p>
</body>
</section>

<section>
<title>Fin du checkout</title>
<body>
    <p>
	Une fois le checkout terminé, vous aurez un répertoire "samba" dans votre
	répertoire courrant. Remarquez d'ailleurs que chaque répertoire contient
	un nouveau répertoire "CVS" -- CVS y stocke plusieurs informations qui
	peuvent être ignorées sans problèmes à ce niveau. A partir de maintenant,
	nous n'avons plus à nous inquiéter que la variable CVSROOT soit positionnée
	ou non, parce que les informations sur la repository sont stockées dans
	ces fameux répertoires "CVS" supplémentaires. A savoir : CVSROOT n'est à
	définir que pour la première connexion et le premier "checkout".
    </p>
</body>
</section>

<section>
<title>Mettre les sources à jour</title>
<body>
    <p>
	Quand vous en êtes là, vos sources sont récentes. Vous pouvez continuer,
	les compiler et les installer, les parcourir, et en faire tout ce que vous voulez.
    </p>
    <p>
	De temps en temps, vous pouvez avoir envie de synchroniser vos sources déjà récupérées
	avec la version actuelle sur CVS. Pour ce faire, vous n'avez pas besoin de vous connecter
	à nouveau au pserver; vos informations d'autentifications sont mises en cache par cvs
	dans les répertoires "CVS" dont j'ai parlé. Il suffit d'entrer dans le répertoire
	principal des sources (dans notre cas "samba"), et de taper :
    </p>
<pre>
# <i>cvs update -dP</i>
</pre>
</body>
</section>

<section>
<title>"cvs update", courtes explications, partie 1</title>
<body>
    <p>
	Si il y a de quelconques nouveaux fichiers, cvs va imprimer une ligne "U [fichier]"
	à l'écran, pour chaque fichier, lorsqu'il les met à jour. Si vous avez compilé les
	sources une fois déjà, vous allez sans doute voir apparaître beaucoup de lignes
	"? [fichier]" ; ce sont des fichiers dont cvs signale qu'ils ne sont pas sur la
	repository distante.
    </p>
</body>
</section>

<section>
<title>"cvs update", courtes explications, partie 2</title>
<body>
    <p>
	Remarquez d'ailleurs les deux options utilisées pour faire un "cvs update".
	"-d" demande à cvs de créer chez vous les nouveaux répertoires qui ont pu être
	ajoutés à la repository (ce qui n'est pas le comportement par défaut), et "-P"
	sert à supprimer tous les répertoires vides de votre copie locale des sources.
	"-P" est une bonne idée puisque cvs a tendance à récupérer un bon nombre
	de répertoires vides (utilisés à une époque, puis abandonnés).
    </p>
    <p>
	Lorsqu'il s'agit juste de récupérer les sources les plus récentes, c'est à peu près
	tout ce qu'il suffit de savoir sur cvs. La suite concerne plutot les développeurs.
    </p>
</body>
</section>
</chapter>
<chapter>
<title>CVS pour les developpeurs</title>

<section>
<title>Modifier des fichiers</title>
<body>
    <p>
	En tant que développeur, vous aurez à modifier des fichiers sur la CVS. Pour ceci,
	commencez par faire les changements désirés sur votre copie de la repository.
	Ces changements ne sont bien entendu pas répercutés sur la repository distante tant
	que vous n'avez pas explicitement demandé à la cvs de faire un "commit" de vos
	modifications. Lorsque vous avez suffisamment testé toutes vos modifications,
	que vous êtes sûr que tout fonctionne parfaitement, alors vous êtes prêt
	à envoyer vos améliorations sur la repository distante. Suivez alors bien les deux
	étapes. En premier lieu, mettez vos sources à jour, par la commande suivante :
    </p>
<pre>
# <i>cvs update -dP</i>
</pre>
</body>
</section>

<section>
<title>CVS fusionne les modifications des autres</title>
<body>
    <p>
	Comme on l'a vu plus tôt, "cvs update" va synchroniser vos sources avec
	celles de la repository distante. Mais que va-t-il se passer pour vos
	modifications ? Rassurez vous, elles ne seront pas perdues ! Si un autre
	développeur a modifié un fichier que vous n'avez pas modifié, votre fichier
	local sera mis à jour, et ainsi, tous les fichiers que vous n'aurez
	pas touchés, seront synchrones des fichiers de la repository CVS.
    </p>
    <p>
	De plus, si vous avez modifié les lignes 1 à 10 d'un fichier en local, et qu'un autre
	développeur a supprimé les lignes 40 à 50, ajouté 12 lignes à la fin de ce fichier,
	puis réalisé un "commit" avant vous, alors cvs va réaliser une fusion intelligente
	des modifications réalisées par l'autre développeur sur votre à vous, et ainsi,
	aucun travail n'est perdu. Cela permet à deux développeurs de travailler sur
	des parties distinctes d'un même fichier, et ce en même temps.
    </p>
</body>
</section>

<section>
<title>La fusion n'est pas parfaite</title>
<body>
    <p>
	Pourtant, si deux ou plus de développeurs on fait des modifications
	sur la <i>même partie du même fichier</i>, alors les choses se compliquent
	un tout petit peu. Si cela arrive, alors cvs va vous prévenir qu'il y a un
	conflit. Aucun travail n'est perdu, mais une intervention de votre part va
	être requise. En effet, cvs a besoin que vous lui indiquiez comment
	fusionner les changements.
    </p>
</body>
</section>



<section>
<title>Le "commit"</title>
<body>
    <p>
	Nous allons nous intéresser à comment résoudre les conflits un peu plus loin.
	Mias pour l'instant, supposons qu'il n'y a pas eu de conflits à la sortie de
	la commande "cvs update -dP" (ce qui est souvent le cas). Dans ce cas, vos
	sources locales sont à jour (up-to-date) et vous êtes alors prêts à réaliser 
	le "commit" de vos sources. Il suffit de taper la commande suivante, dans le 
	répertoire principal de vos sources :
    </p>
<pre>
# <i>cvs commit</i>
</pre>


</body>
</section>

<section>
<title>Ce que fait le "commit"</title>
<body>
    <p>
	"cvs commit" ne fait <i>pas qu'appliquer</i> vos modifications sur la repository 
	distante. Avant de vraiment envoyer vos sources, cvs va ouvrir votre éditeur par
	défaut, pour que vous puissiez écrire une courte description des changements réalisés.
	Une fois ce commentaire saisi, enregistrez le fichier, et quittez l'éditeur, vos
	changements (et les commentaires associés) vont être appliqués à la repository distante,
	et vont être disponnibles pour les autres développeurs de l'équipe.
    </p>
</body>
</section>

<section>
<title>Consulter les logs</title>
<body>
    <p>
	Il est vraiment très facile de consulter l'hitorique complet d'un fichier
	donné, avec tous les commentaires que les développeurs (dont vous) ont pu
	faire lorsqu'ils ont fait des "commit". Pour accéder à ces informations, faites :
    </p>
<pre>
# <i>cvs log myfile.c</i>
</pre>
    <p>
	"cvs log" est une commande récursive, donc pour consulter le log complet de toute
	une arborescence d'un répertoire, allez dans le répertoire en question, et tapez :
    </p>
<pre>
# <i>cvs log | less</i>
</pre>

</body>
</section>

<section>
<title>Les options du "commit"</title>
<body>
    <p>
	Vous pourriez avoir envie d'utiliser un autre éditeur que celui que cvs utilise par défaut
	lorsque vous faites un "cvs commit". Si c'est le cas, positionnez la variable d'environnement
	EDITOR sur le nom de votre éditeur favori. Mettre une telle ligne dans votre ~/.bashrc peut
	être une bonne idée :
    </p>
<pre>
export EDITOR=jpico
</pre>
    <p>
	Vous pouvez aussi spécifier le commentaire dans la ligne de commande, de sorte que
	cvs n'ait pas à ouvrir un éditeur de texte :
    </p>
<pre>
# <i>cvs commit -m 'I fixed a few silly bugs in portage.py'</i>
</pre>
</body>
</section>

<section>
<title>Le fichier .cvsrc</title>
<body>
    <p>
	Avant de continuer de découvrir d'autres commandes cvs, je vous recommande de créer
	un fichier ~/.cvsrc. En le créant dans votre "home directory", vous pouvez dire à cvs
	d'utiliser des options par défaut pour chaque commande cvs, et ainsi, vous n'avez pas
	à vous rappeler de les taper à chaque fois. Voici un exemple de fichier .cvsrc :
    </p>
<pre>
cvs -q
diff -u -b -B
checkout -P
update -d -P
</pre>
</body>
</section>

<section>
<title>Le fichier .cvsrc, suite</title>
<body>
    <p>
	En plus de pouvoir spécifier pleins d'options utiles pour une un grand nombre de
	commandes cvs, la première ligne du .cvsrc force le mode silencieux de cvs, ce qui
	a comme premire conséquence de rendre la sortie de "cvs update" beaucoup plus 
	concise et lisible. Une fois ce fichier en place, il vous suffit de taper
	"cvs update" au lieu de "cvs update -dP" (par exemple).
    </p>
</body>
</section>

<section>
<title>Ajouter un fichier à la repository</title>
<body>
    <p>
	Il est vraiment facile d'ajouter un fichier de sources à la CVS. En premier,
	vous devez créer le fichier en question, puis taper la commande suivante :
    </p>
<pre>
# <i>cvs add myfile.c</i>
cvs server: use 'cvs commit' to add this file permanently
</pre>
    <p>
	Ceci va dire à cvs d'ajouter ce fichier à la repository la prochaine fois
	que vous ferez un "cvs commit". Jusqu'à ce moment, les autres développeurs
	ne pourront pas le voir.
    </p>
</body>
</section>

<section>
<title>Ajouter un répertoire à la repository</title>
<body>
    <p>
	Pour ajouter un répertoire, la procédure est similaire :
    </p>
<pre>
# <i>mkdir foo</i>
# <i>cvs add foo</i>
Directory /home/cvsroot/mycode/foo added to the repository   
</pre>
    <p>
	A la différence d'un ajout de fichier, lorsque vous ajoutez un répertoire,
	il apparait immédiatement sur la repository, le "commit" n'est pas requis.
	Une fois le répertoire local ajouté à la repository, vous allez remarquer
	qu'un répertoire "CVS" y est créé pour y stocker les informations CVS
    . Ainsi, vous pouvez facilement savoir si un répertoire a été
	ajouté à la cvs en regardant si il contient un répertoire "CVS" à l'intérieur.
    </p>
</body>
</section>

<section>
<title>Remarques sur "cvs add"</title>
<body>
    <p>
	Comme vous pouvez le deviner, avant d'ajouter un fichier ou un répertoire
	à la répository, vous devez bien vérifier que son répertoire parent
	a bien déjà été ajouté à la repository. Sinon, vous allez avoir l'erreur suivante :
    </p>
<pre>
# <i>cvs add myfile.c</i>
cvs add: cannot open CVS/Entries for reading: No such file or directory
cvs [add aborted]: no repository  
</pre>
</body>
</section>

<section>
<title>Se familiariser avec "cvs update", partie 1</title>
<body>
    <p>
	Avant de s'occuper de comment résoudre les conflits, familiarisons nous avec
	les sorties de la commande "cvs update". Si vous créez un fichier ~/.cvsrc
	qui contient la ligne "cvs -q", vous allez trouver les sorties de "cvs update"
	beaucoup plus faciles à lire. "cvs update" vous informe de ce qu'il fait,
	représentant ses actions par un caractère, un espace et un nom de fichier;
	par exemple :
</p><pre>
# <i>cvs update -dP</i>
? distfiles
? packages
? profiles 
</pre>
</body>
</section>

<section>
<title>Se familiariser avec "cvs update", partie 2</title>
<body>
    <p>
	"cvs update" utilise le caractère "?" pour vous signifier qu'il ne sait rien
	sur ce fichier là, fichier qu'il trouve dans votre copie locale, mais pas
	sur la repository. Ces fichiers ne font pas partie de la repository distante,
	et n'ont pas non plus été prévus pour être ajoutés à la repository.
	Voici une liste de tous les messages possibles que CVS utilise :
    </p>
<pre>
U [path]
</pre>
    <p>
	Utilisé lorsqu'un fichier est créé dans votre copie locale, ou si un fichier
	que vous n'avez pas touché est mis à jour.
    </p>
<pre>
A [path]
</pre>
    <p>
	L'ajout de ce fichier à la repository a été programmée et sera officiellement ajouté
	à la repository quand vous ferez un "cvs commit".
    </p>
</body>
</section>


<section>
<title>Se familiariser avec "cvs update", partie 3</title>
<body>
<pre>
R [path]
</pre>
    <p>
	A l'image de "A", "R" vous indique que la suppression de ce fichier à été prévue.
	Ce fichier sera effectivement retiré dès que vous aurez fait un "cvs commit".
    </p>
<pre>
M [path]
</pre>
    <p>
	Cela signifie que ce fichier a été modifié par vous; de plus, il est possible
	que des modifications aient été fusionnées dans ce fichier sans conflits.
    </p>
<pre>
C [path]
</pre>
    <p>
	Le caractère "C" indique que ce fichier a des conflits et nécessite une
    intervention
	manuelle avant de réaliser votre "commit".
    </p>
</body>
</section>

<section>
<title>Résoudre les conflits, introduction</title>
<body>
    <p>
	Désormais, occupons nous de résoudre ces conflits. Je suis assez impliqué dans
	le projet Gentoo-Linux, et nous avons notre propre serveur cvs configuré
	sur cvs.gentoo.org. Nous autres, développeurs, passons la majorité de notre
	temps à hacker les sources du module "gentoo-x86", et nous avons ajouté un fichier
	appelé "ChangeLog" qui contient (vous l'aurez deviné) les modifications majeurs
	que nous avons fait sur la repository.
    </p>
</body>
</section>

<section>
<title>Une exemple  de conflit</title>
<body>
    <p>
	Puisque que ce ficher est modifié à peu près à chaque fois qu'un changement majeur
	est réalisé sur CVS, c'est notre plus grande source de conflits. En voici un
	exemple. Imaginons, que j'ai ajouté les lignes suivantes au début du fichier
	de ChangeLog :
    </p>
<pre>
date 25 Feb 2001
 
This is the thing I added myself
</pre>
    <p>
	Imaginons, qu'avant que je fasse un "commit" de ces trois nouvelles lignes,
	un développeur a déja ajouté les lignes suivantes au début du Changelog, et
	a envoyé ses modifications :
    </p>
<pre>
date 25 Feb 2001
 
This is the part added by another developer
</pre> 
</body>
</section>

<section>
<title>Une exemple de conflit, suite</title>
<body>
    <p>
	Maintenant, lorsque je fais un "cvs update -dP" (comme il faut le faire avant
	chaque commit), cvs n'est pas capable de fusionner ces modifications sur ma
	copie locale du ChangeLog, parce que nous avons tous les deux ajouté des lignes
	dans la même partie du fichier. Cvs ne sait alors pas quelle partie utiliser.
	Et ainsi, j'ai l'erreur suivante :
    </p>
<pre>
RCS file: /home/cvsroot/gentoo-x86/ChangeLog,v
retrieving revision 1.362
retrieving revision 1.363
Merging differences between 1.362 and 1.363 into ChangeLog
rcsmerge: warning: conflicts during merge
cvs server: conflicts found in ChangeLog
C ChangeLog
</pre>
</body>
</section>

<section>
<title>Résolution de conflit, partie 1</title>
<body>
    <p>
	Ahhh, un conflit ! Heureusement, résoudre un conflit est facile. Si je lance
	mon éditeur favori, je vois le texte suivant au début du fichier "ChangeLog" :
    </p>
<pre>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ChangeLog
date 25 Feb 2001
 
This is the thing I added myself
 
=======
date 25 Feb 2001
 
This is the part added by another developer
 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.363
</pre>
</body>
</section>


<section>
<title>Résolution de conflit, partie 2</title>
<body>
    <p>
	Au lieu de choisir une version ou l'autre, cvs ajoute les deux versions
	au fichier ChangeLog, et les entoure de caractères spéciaux pour marquer 
	clairement les régions qui posent problème. Maintenant, c'est à moi de
	remplacer ces régions par les texte qui <i>devrait</i> apparaitre dans
	le ChangeLog; dans ce cas, le texte de remplacement n'est ni l'une, 
	ni l'autre des versions, mais une combinaison des deux :
    </p>
<pre>
date 25 Feb 2001

This is the thing I added myself

This is the part added by another developer
</pre>
    <p>
	Maintenant que j'ai remplacé les régions conflictuelles du fichier avec le texte
	approprié (et supprimé les "=======" et autres marqueurs), je peux alors faire
	un "commit" sans aucun problème.
    </p>
</body>
</section>

<section>
<title>Astuces pour résoudre les conflits</title>
<body>
    <p>
	A chaque fois que vous avez besoin d'éditer un fichier pour régler
	des conflits, vérifiez bien que vous avez bien parcouru tout le fichier,
	de telle manière que vous n'ayez rien oublié. Sinon, cvs n'autorisera
	pas votre "commit" et ce jusqu'à ce que le conflit soit résolu.
	Il est donc très important d'enlever les marqueurs spéciaux que
	cvs a ajouté aux fichiers conflictueux. Autre astuce : si vous avez
	fait une erreur en essayant de résoudre un conflit, et que accidentellement
	vous avez enregistré vos modifications, vous pouvez retrouver la copie
	originale du fichier dans le fichier ".#nom_du_fichier.version".
    </p>
</body>
</section>

<section>
<title>Supprimer un fichier</title>
<body>
    <p>
	Maintenant, il est temps de découvrir notre dernière commande cvs : supprimer un
	fichier de la repository. Supprimer un fichier se fait en deux étapes. Il
	faut commencer par supprimer le fichier de votre copie des sources, puis
	exécuter la commande "cvs remove" sur ce fichier :
    </p>
<pre>
# <i>rm myoldfile.c</i>
# <i>cvs remove myoldfile.c</i>
</pre>
</body>
</section>

<section>
<title>Supprimer un fichier, suite</title>
<body>
    <p>
	La suppression du fichier est alors prévue par cvs, et sera effective
	pour votre prochain "commit". Une fois le "commit" réalisé, le fichier
	sera officiellement supprimé de la repository distante. Pourtant, cvs
	ne va pas faire diparaitre ce fichier, et va en garder un enregistrement
	complet de son contenu et de son historique, au cas où vous en auriez
	besoin dans le futur. C'est juste un des nombreux moyens qui permet à cvs
	de protéger votre code.
    </p>
    <p>
	"cvs remove" est récursif, ce qui signifie, que vous pouvez supprimer
	un paquet de fichiers, et lancer la commande "cvs remove" sans autres arguments
	depuis un répertoire parent. Ceci va marquer tous les fichiers supprimés
	comme "à supprimer" pour le prochain "commit".
    </p>
</body>
</section>

<section>
<title>Supprimer un répertoire</title>
<body>
    <p>
	Si vous voulez supprimer un répertoire complet, je vous recommande la méthode
	suivante. Tout d'abord supprimez chaque fichier du répertoire, et faites un
	"cvs remove" :
    </p>
<pre>
# <i>rm *.c</i>
# <i>cvs remove</i>
</pre>
</body>
</section>

<section>
<title>Supprimer un répertoire, suite</title>
<body>
    <p>
	Ensuite, faites un "commit" :
    </p>
<pre>
# cvs commit
</pre>
    <p>
	Et là, astuce : exécutez les commandes suivantes pour supprimer le répertoire :
    </p>
<pre>
# <i>cd ..</i>
# <i>cvs remove mydir</i>
# <i>rm -rf mydir</i>
</pre>
    <p>
	Remarquez que supprimer un répertoire ne nécessite pas un autre "commit". L'ajout
	et la suppression de répertoires sur la repository distante se font en temps réel.
    </p>
</body>
</section>

<section>
<title>C'est terminé !</title>
<body>
    <p>
	Votre introdution à CVS est terminée. J'espère que ce tutoriel vous a été utile.
	Il y a bien d'autres choses à savoir sur CVS, que je n'ai pu couvrir dans ce tutoriel
	introductif, mais heureusement, il y a pleins de documentations sur CVS qui vous aidera
	à développer votre connaissance de CVS :
    </p>
    <p>
	<ul>
	    <li><uri>http://www.cvshome.org</uri> page principale du développement de CVS,
		et offre une foule de documentation sur CVS, en particulier la
		<uri link="http://www.cvshome.org/docs/manual/cvs.html">documentation officielle de CVS "online"</uri>.
	    </li>
	    <li>Le site <uri link="http://www.durak.org/cvswebsites/">"CVS Version Control for Web Site Projects"</uri>
		propose de bonnes informations sur comment utiliser CVS pour développer des sites Web.
	    </li>
	    <li>Karl Fogel a écrit un livre intitulé <uri link="http://cvsbook.red-bean.com/">Open Source Development with CVS</uri>.
		Nombre de chapitres de ce livre sont disponnibles sur le site.
	    </li>
	    <li><uri link="http://stud.fh-heilbronn.de/~zeller/cgi/cvsweb.cgi/">cvsweb</uri> est un script
		CGI merveilleux qui fournit une interface web à votre répository. Excellent pour le parcours rapide.
	    </li>
	    <li>Le site <uri link="http://www.loria.fr/~molli/cvs-index.html">CVS Bubbles</uri> 
		propose aussi de nombreuses informations, dont "CVS FAQ-o-matic".
	    </li>
	</ul>
    </p>
</body>
</section>

<section>
<body>
    <note>
	Ce tutoriel a tout d'abord été publié dans <uri link="http://www.ibm.com/developerworks/linux">IBM developerWorks Linux Zone</uri>,
	sous le titre <uri
    link="http://www-105.ibm.com/developerworks/education.nsf/linux-onlinecourse-bytitle/A5C4A0AF4296C66886256A0E005DE112?OpenDocument">CVS
    for the developer or amateur</uri>.  Cet article appartient à Tenco Media Corporation.
</note>
</body>
</section>

</chapter>
</guide>
	
