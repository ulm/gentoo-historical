<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/fr/gentoo-x86-install.xml">
  <title>Guide d'installation de la Gentoo Linux 1.4_rc4</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">
    <mail link="">Jerry Alexandratos</mail>
  </author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>
  <author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
  </author>
  <author title="Editor">
    <mail link="">Colin Morey</mail>
  </author>
  <author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Traducteur">
    <mail link="frlinux@frlinux.net">FRLinux</mail>
  </author>
  <abstract>
	Ces instructions ont pour but de vous aider à installer Gentoo Linux 1.4_rc4.
	Le processus d'installation supporte plusieurs approches, selon vos besoins et
	selon le niveau de customisation que vous désirez.
	</abstract>
<version>2.6.1</version>
 <date>13 May 2003</date>
  <chapter>
    <title>A propos de l'installation</title>
    <section>
      <body>
        <p>
		Ce nouveau CD d'installation devrait démarrer depuis presque n'importe quel type
de lecteur CDROM, qu'il soit IDE ou SCSI, en considérant que vous avez bien sûr le support
BIOS pour démarrer depuis un CDROM. Ce CDROM inclut tout le support nécessaire sous Linux
pour IDE (ainsi que IDE PCI) (mis en dur dans le noyau) ainsi que pour tous les périphériques SCSI (en tant que modules). Nous fournissons également un support quasiment
complet pour n'importe quel type de carte réseau supportée par Linux, ainsi que plusieurs
outils pour configurer votre réseau et établir une connexion externe sécurisée (<c>ssh</c>) afin
de pouvoir télécharger des fichiers.</p>
        <p>Pour installer Gentoo Linux à partir du CD, vous aurez besoin au minimum d'un
processeur 486+ avec 64MO de RAM. (Gentoo Linux a été compilée avec succès sur une machine
possédant 64MO de RAM + 64MO de swap (fichier d'échange), bien que la compilation soit
horriblement longue dans ces conditions).</p>
        <p>Vous pouvez installer Gentoo Linux en utilisant une des trois archives. Vous
devez en choisir un en fonction du degré de compilation que vous désirez sur votre
système. L'archive stage1 sert à mettre en place le système et le compiler entièrement
de zéro. L'archive stage2 sert à compiler le système une fois que la base a été installée.
L'archive stage3 contient une installation de base de Gentoo Linux.</p>
        <p><b>Dois-je choisir le stage1, stage2, ou le stage3 ?</b>
		Démarrer à partir du stage1 vous permet d'avoir un contrôle total sur les
optimisations et les fonctionnalités de compilation propres à votre système. Le stage1
convient parfaitement aux utilisateurs expérimentés désirant contrôler chaque étape du
processus. Les installations à partir du stage2 vous permettent d'éviter le processus de
bootstrap, et ne devrait pas vous poser de problème si vous êtes satisfait des optimisations que nous avons faîtes sur le tarball. Choisir le stage3 vous permet
d'installer Gentoo Linux beaucoup plus rapidement, au détriment d'une optimisation
spécifique étant donné que nous avons avons choisies pour vous. Vu que la plupart
des sorties majeures de Gentoo Linux sont accompagnées de tarballs stage3 spéficiquement
optimisés pour la majorité des processeurs, cela devrait vous convenir. <b>Si vous
installez Gentoo Linux pour la première fois, utilisez de préférence une archive stage3.</b></p>

		<p>Comment se déroule le début de l'installation ? Vous devez dabord choisir le
type d'image ISO du liveCD qui vous convient en la téléchargeant ici :
<uri>http://www.ibiblio.org/gentoo/releases/1.4_rc4/x86/</uri> . N'oubliez pas que nous
possédons de nombreux miroirs qu'il vaut mieux utiliser afin d'alléger la charge des
serveurs principaux. La liste des serveurs se trouve là :
<uri>http://www.gentoo.org/main/en/mirrors.xml</uri>.
</p>
        <p>Les liveCDs sont des images CD entières qui peuvent êtres gravées sur des
CDR ou CD-RW en utilisant un logiciel de gravure. Nous avons actuellement deux types
de liveCDs. Le premier s'appellant &quot;gentoo-basic&quot; , fait approximativement
40MO en taille, et contient seulement le tarball stage1 et se trouve dans le répertoire
<path>x86/livecd/</path>. Ce liveCD de taille minimale vous permet un téléchargement
rapide et contient le tarball stage1 qui se trouve dans <path>/mnt/cdrom/gentoo/</path>  après avoir démarré depuis le CD-ROM.</p>
        <p>Le second liveCD s'appelle &quot;gentoo-3stages.&quot; et se trouve également
dans <path>x86/livecd</path>. Il contient les 3 tarballs : stage 1, 2 et 3. Il est
possible d'installer un système Gentoo Linux complet assez rapidement gràce à ce
CD.</p>
<p><b>Qu'est-il arrivé aux stages i686, pentium3, athlon, athlon-mp , LiveCDs et GRP (Gentoo Reference Platform)?</b>
La Gentoo 1.4_rc4 est supposée être une release candidate mineure. 1.4_final
sera celle contenant toutes les architectures x86 et GRP. Si vous désirez installer des
stages optimisés pour ces autres architectures x86 ou GRP, utilisez la documentation
disponible pour la version 1.4_rc2, qui se trouve là :
<uri>http://www.gentoo.org/doc/en/gentoo-x86-1.4_rc2-install.xml</uri>
</p>
        <impo>Si vous recontrez quelque problème que ce soir durant l'installation
et désirez le reporter comme un bug, utilisez <uri>http://bugs.gentoo.org</uri>. Si le bug
doit être transmis aux développeurs responsables du logiciel (par exemple l'équipe de KDE),
<e>les développeurs de Gentoo</e> s'en chargeront pour vous.
</impo>
        <p>Récapitulons à présent le processus d'installation. Vous devez d'abord
télécharger, graver et démarrer depuis un liveCD. Après avoir obtenu l'invite, vous devez
créer des partitions, les formater puis extraire l'archive contenant le stage désiré. Quelque soit le
stage utilisé, nous éxaminerons les étapes nécessaires pour arriver au stage3. Une fois
que le système a atteint le stage3, nous pouvons le configurer (personnaliser les fichiers
de configuration, installer un gestionnaire de démarrage, etc) et le redémarrer pour obtenir
un système Gentoo Linux complètement fonctionnel. Voici les étapes nécessaires selon le
type d'installation que vous entamez :</p>
        <table>
          <tr>
            <th>stage tarball</th>
            <th>requirements for installation</th>
          </tr>
          <tr>
            <ti>1</ti>
            <ti>configuration partition/système de fichiers, emerge sync, bootstrap, emerge system, emerge kernel sources, configuration finale</ti>
          </tr>
          <tr>
            <ti>2</ti>
            <ti>configuration partition/système de fichiers, emerge sync, emerge system, emerge kernel sources, configuration finale</ti>
          </tr>
          <tr>
            <ti>3</ti>
            <ti>configuration partition/système de fichiers, emerge sync, configuration finale</ti>
          </tr>
        </table>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Démarrage</title>
    <section>
      <body>
        <p>Commencez par démarrer depuis un liveCD. Vous devriez voir apparaître un bel
écran de démarrage avec le logo Gentoo Linux. Vous pouvez alors tapper [Entrée]
pour débuter le processus de démarrage, ou alors spécifier un kernel ainsi que des options
de démarrage si nécessaire. Vous pouvez par exemple utiliser <c>gentoo nousb nohotplug</c>.
Consultez la table ci-dessous afin de savoir à quoi correspondent les options de démarrage
ou bien faîtes F2 pour voir l'écran d'aide.</p>

	<table>
	<tr>
		<th>Kernels disponibles.</th>
		<th>Description</th>
	</tr>

	<tr><ti>gentoo</ti><ti>kernel Gentoo (defaut)</ti></tr>
	<tr><ti>800</ti><ti>mode framebuffer 800x600</ti></tr>
	<tr><ti>1024</ti><ti>mode framebuffer 1024x768 (default)</ti></tr>
	<tr><ti>1280</ti><ti>mode framebuffer 1280x1024</ti></tr>
	<tr><ti>nofb</ti><ti>mode framebuffer désactivé</ti></tr>
	<tr><ti>smp</ti><ti>charge un kernel smp sans framebuffer</ti></tr>
	<tr><ti>acpi</ti><ti>active acpi=on et charge les modules acpi pendant l'init</ti></tr>
	<tr><ti>memtest</ti><ti>démarre le programme de test de la mémoire</ti></tr>

	</table>

	<p>
	<table>
	<tr>
		<th>Options de démarrage disponibles.</th>
		<th>description</th>
	</tr>

	<tr><ti>doataraid</ti>
	<ti>Charge les modules raid IDE dans l'initrd</ti></tr>

	<tr><ti>dofirewire</ti>
	<ti>Charge les modules firewire dans l'initrd (pour les CDROMs firewire, etc)</ti></tr>

	<tr><ti>dokeymap</ti>
	<ti>Active la sélection des mappings pour les claviers non US</ti></tr>

	<tr><ti>dopcmcia</ti>
	<ti>Démarre le service PCMCIA</ti></tr>

	<tr><ti>doscsi</ti>
	<ti>Recherche les périphériques SCSI (peut faire un conflit avec certaines cartes réseau)</ti></tr>

	<tr><ti>noapm</ti>
	<ti>Désactive le chargement du module APM</ti></tr>

	<tr><ti>nodetect</ti>
	<ti>Désactive le démarrage de hwsetup/kudzu et hotplug</ti></tr>

	<tr><ti>nodhcp</ti>
	<ti>Désactive le chargement de DHCP si une carte réseau est trouvée</ti></tr>

	<tr><ti>nohotplug</ti>
	<ti>Désactive le service hotplug</ti></tr>

	<tr><ti>noraid</ti>
	<ti>Désactive le chargement des modules evms</ti></tr>

	<tr><ti>nousb</ti>
	<ti>Désactive les modules usb du chargement initrd et hotplug</ti></tr>

	<tr><ti>ide=nodma</ti>
	<ti>Force la désactivation du dma pour les périphériques IDE défectueux</ti></tr>

	<tr><ti>cdcache</ti>
	<ti>Cache la portion entière du CD dans la ram, ce qui utilise 40MO, mais vous
permet alors de démonter le CD de démarrage et d'en monter un autre.</ti></tr>

	</table></p>

	<p>Après avoir appuyé sur entrée, vous serez accueilli par les messages
standards du démarrage du kernel et d'initrd, suivi du démarrage normal de Gentoo
Linux. Vous serez alors automatiquement loggué en tant que &quot;<c>root</c>&quot; et
un mot de passe root sera créé aléatoirement pour des raisons de sécurité. Vous
devriez donc voir le prompt (&quot;<c>#</c>&quot;) root sur la console, et pouvez alors
passer d'une console à une autre en pressant Alt-F2, Alt-F3 et Alt-F4. Revenez à celle
de démarrage en faisant Alt-F1. Il est conseillé de changer le mot de passe root à ce
moment en tapant <c>passwd</c> et en suivant les indications à l'écran.
			</p>
        <p>Vous aurez probablement remarqué qu'au dessus du prompt <c>#</c> se trouve
une quantité substancielle de texte qui vous aide à configurer votre réseau et vous
indique où se trouvent les tarballs de stage sur le CD.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Chargement des modules du kernel</title>
    <section>
      <body>
        <p>Si la détection PCI n'a pas reconnu une partie de votre matériel,
		vous pouvez toujours charger manuellement les modules nécessaire
		. Pour voir une liste complète des modules de cartes réseau
		disponibles, tapez <c>ls /lib/modules/*/kernel/drivers/net/*</c>. Pour charger
		une module particulier, tapez :</p>
<pre caption="Configuration des modules PCI">
# <c>modprobe pcnet32</c>
<comment>(remplacez pcnet32 par le module de votre carte réseau)</comment>
</pre>
        <p>De même, si vous avez besoin d'accéder à du matériel SCSI non
		détecté, il vous suffit de charger les bons modules depuis /lib/modules, en
		utilisant <c>modprobe</c>:
			</p>
<pre caption="Charger les modules SCSI">
# <c>modprobe aic7xxx</c>
<comment>(remplacez aic7xxx avec le module de votre carte SCSI)</comment>
# <c>modprobe sd_mod</c>
<comment>(sd_mod est le module supportant les disques durs SCSI)</comment>
</pre>
			<note>
			Le support des CDROMs SCSI et des disques est intégré au kernel.
			</note>
        <p>Si vous utilisez des périphériques RAID, il vous faudra charger les modules
			ATA-RAID pour votre controlleur RAID.
			</p>
<pre caption="Charger les modules RAID">
# <c>modprobe ataraid</c>
# <c>modprobe pdcraid</c>
<comment>(Controlleur Raid Promise)</comment>
# <c>modprobe hptraid</c>
<comment>(Controlleur Raid Highpoint)</comment>
</pre>
        <p>Le liveCD Gentoo devrait activer de lui-même le DMA sur vos disques, mais
		s'il ne l'a pas fait, vous pouvez utiliser <c>hdparm</c>.</p>
<pre caption="Activer le DMA">
<comment>Remplacez hdX avec vos disques.</comment>
# hdparm -d 1 /dev/hdX <comment>Active le DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(Active le DMA ainsi que d'autres options)</comment>
# hdparm -X66 /dev/hdX
<comment>(Active l'Ultra-DMA -- dangereux -- peut causer des erreurs)</comment>
</pre>
      </body>
    </section>
  </chapter>
<!-- THIS SECTION SHOULD BE DEPRECATED WITH HOTPLUG ENABLED IN 1.4_rc3 (drobbins)
  <chapter>
    <title>Loading PCMCIA Kernel Modules</title>
    <section>
      <body>
        <p>If you have a PCMCIA network card, you will need to perform a few extra steps.
			</p>
        <warn>To avoid problems with <c>cardmgr</c>, you <e>must</e> run it <e>before</e> you enter the chroot
			portion of the install. </warn>
<pre caption="Loading PCMCIA Modules">
# <i>modprobe pcmcia_core</i>
# <i>modprobe i82365</i>
# <i>modprobe ds</i>
# <i>cardmgr -f</i>
</pre>
        <p>As <c>cardmgr</c> detects which hardware is present, your speaker should emit a
			few reassuring beeps, and your PCMCIA network card should be active. You can
			of course insert the PCMCIA card after loading <c>cardmgr</c> too, if that is
			preferable. (Technically, you need not run
			<c>cardmgr</c> if you know exactly which module your PCMCIA card requires.
			But if you don't, loading all PCMCIA modules and see which sticks won't work,
			as all PCMCIA modules load obligingly and hang around for a PCMCIA card to
			drop by. <c>cardmgr</c> will also unload the module(s) for any card when you
			remove it). </p>
      </body>
    </section>
  </chapter>
-->
  <chapter>
    <title>Configuration du réseau</title>
	<section>
      <title>Votre réseau est-il déjà fonctionnel ?</title>
      <body>
		<p>Si vous utilisez le liveCD 1.4_rc3 ou plus récent, il y a de grandes chances
		que le réseau soit déjà paramétré. Si tel est le cas, vous devriez pouvoir vous
		servir des commandes réseau telles que <c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> et <c>lynx</c>, ce qui constitue une liste non exhaustive.</p>

        <p>Si le réseau est correctement paramétré, la commande <c>/sbin/ifconfig</c> devrait
		lister les interfaces réseau disponibles à coté de <c>lo</c>, telle que <c>eth0</c>:
		</p>
<pre caption="/sbin/ifconfig d'une carté réseau correctement paramétrée">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
        <p>Vous devriez également éssayer de faire un ping du serveur DNS de votre
		fournisseur d'accès (se trouvant dans votre <path>/etc/resolv.conf</path>),
		ainsi qu'un serveur internet de votre choix, juste pour vous assurer que vos
		paquets atteignent l'internet et que la résolution des noms fonctionne correctement.
		</p>
<pre caption="Test de réseau avancé">
# <c>ping -c 3 www.yahoo.fr </c>
</pre>
		<p>Pouvez vous utiliser correctement votre réseau ? Si oui, vous pouvez passer
		à la section suivante.</p>
      </body>
    </section>
    <section>
      <title> Configuration de PPPoE</title>
      <body>
        <p>Si vous avez besoin de PPPoE (ADSL) pour accéder à internet, le liveCD (quelque
		soit sa version) devrait vous faciliter la tâche car il inclus <c>rp-pppoe</c>. Il
		vous suffit alors d'utiliser le script <c>adsl-setup</c> inclut pour configurer
		votre connexion. Il vous demandera alors quelle carte ethernet se connecte à votre
		modem ADSL, votre nom d'utilisateur et votre mot de passe, les adresses IP de
		vos serveurs DNS, et si vous désirez un pare-feu de base.</p>
<pre caption="Configuration de PPPoE">
# <c> adsl-setup </c>
# <c> adsl-start </c>
</pre>
        <p>Si quelque chose se passe mal, vérifiez que vous avez correctement entré votre
		utilisateur et votre mot de passe en regardant <path>/etc/ppp/pap-secrets</path> ou
		bien <path>/etc/ppp/chap-secrets</path>, et assurez vous également que vous
		utilisez le bon périphérique éthernet.</p>
      </body>
    </section>
    <section>
      <title> Configuration automatique du réseau </title>
      <body>
       <p>La méthode la plus simple pour paramétrer le réseau s'il n'a pas été automatiquement pris en compte est de démarrer le script <c>net-setup</c>.</p>
<pre caption="Le scripte net-setup">
# <c>net-setup eth0</c>
</pre>
        <p>Vous pouvez bien évidemment paramétrer votre réseau manuellement si vous
		le préférez comme le montre la section suivante.</p>
      </body>
    </section>
    <section>
      <title>Configuration DHCP manuelle</title>
      <body>
        <p>La configuration réseau est simple grâce à DHCP ; Si votre fournisseur d'accès
		n'utilise pas DHCP, passez à la configuration statique détaillée plus bas.</p>
<pre caption="Configuration réseau avec DHCP">
# <c>dhcpcd eth0</c>
</pre>
        <note>
		Certains fournisseurs d'accès demandent un nom de machine. Pour se faire,
		ajoutez l'option : <c>-h myhostname</c> à la ligne dhcpcd plus haut.
		</note>
        <p>Si vous voyez des messages <i>dhcpConfig</i>, ne vous inquiétez pas ;
		les erreurs sont purements informatives. Vous pouvez passer au test du réseau
		plus bas.</p>
      </body>
    </section>
    <section>
      <title>Configuration manuelle statique</title>
      <body>
        <p>
		Nous avons besoin de paramétrer les bases du réseau afin de pouvoir télécharger
		les fichiers sources pour construire votre système, ainsi que l'interface
		utilisateur. Tapez les commandes suivantes, en remplacant $IFACE avec votre
		interface réseau (généralement <c>eth0</c>), $IPNUM par votre adresse IP,
		$BCAST avec votre adresse d'émission, et $NMASK par votre masque de réseau.
		Pour la commande <c>route</c> remplacez $GTWAY par votre l'adresse IP de votre passerelle par défaut.
		</p>
<pre caption="Configuration d'IP statique">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</c>
</pre>
        <p>Il faut maintenant créer le fichier <path>/etc/resolv.conf</path>
		afin que la résolution de noms de domaines (permettant de trouver des sites Web/FTP par leur
		nom, plutôt que par leur adresse IP) fonctionne.</p>
        <p>Voici un exemple pour créer votre fichier /etc/resolv.conf : </p>
<pre caption="exemple /etc/resolv.conf">
domain modomaine.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
        <p>Remplacez <c>10.0.0.1</c> et <c>10.0.0.2</c> avec les adresses IP de
		vos DNS primaires et secondaires respectivement.</p>
      </body>
    </section>
    <section>
      <title>Configuration d'un serveur de proximité</title>
      <body>
        <p>Si vous vous trouvez derrière un serveur de proximité, vous devez le
		déclarer sur votre machine avant de continuer. Les lignes suivantes exporteront
		les valeurs de votre serveur de proximité :
		</p>
<pre caption="Configurer un serveur de proximité">
# <c>export http_proxy=&quot;machine.company.com:1234&quot; </c>
# <c>export ftp_proxy=&quot;$http_proxy&quot; </c>
# <c>export RSYNC_PROXY=&quot;$http_proxy&quot; </c>
</pre>
      </body>
    </section>
        <section>
      <title>Le réseau est prêt !</title>
      <body>
        <p>Le réseau devrait à présent être correctement paramétré et utilisable. Vous
		devriez donc pouvoir utiliser les commandes <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> et <c>wget</c> pour vous connecter à d'autres machines sur votre réseau
		ou internet.</p>
      </body>
    </section>
    <section>
    	<title>Je n'ai pas de réseau !</title>
	<body>Si vous n'avez toujours pas de réseau, vous pourrez sans doute trouver de l'aide
	dans les <uri link="http://forums.gentoo.org/">forums Gentoo</uri>. Quelques
	liens utiles peuvent être trouvés ici : 				<uri>http://forums.gentoo.org/viewtopic.php?t=43025</uri>.
	</body>
  </section>
  </chapter>
  <chapter>
    <title>Paramétrer la date et l'heure de votre système</title>
    <section>
      <body>
        <p>Vous devez à présent paramétrer la date et l'heure de votre système. Vous pouvez le faire
		manuellement en invoquant la commande <c>date</c>.</p>
<pre caption="Paramétrer votre date système">
# <c>date</c>
Jeu Fev 27 09:04:42 CST 2003
<comment>(Si votre date est incorrecte, utilisez la commande suivante pour la corriger)</comment>
# <c>date 022709042003</c>
<comment>(date MMJJhhmmAAAA)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Systèmes de fichiers, partitions et les périphériques de stockage</title>
    <section>
		<title>Introduction aux périphériques de stockage</title>
      <body>
<p>
Dans cette section, nous allons voir de façon approfondie les aspects disques qui
concernent Gentoo Linux et Linux en général, ce qui concerne les systèmes de fichiers,
les partitions et les périphériques de stockage. Lorsque vous vous serez bien familiarisé avec les
disques et les systèmes de fichiers, vous serez guidés pour paramétrer vos partitions et
les systèmes de fichiers concernant l'installation de votre Gentoo Linux.
</p>
<p>
Nous allons, pour commencer, aborder la notion de périphériques de stockage. Le plus
important périphérique de stockage est sans aucun doute celui qui représente le premier
disque dur IDE dans un système Linux :
</p>
<pre caption="/dev/hda, est le périphérique représentant votre premier disque dur dans
votre machine">
/dev/hda
</pre>

<p>
Si votre système utilise des disques SCSI, votre premier disque dur sera alors :
</p>

<pre caption="/dev/sda, le périphérique de stockage représentant le premier disque logique  SCSI dans votre système">
/dev/sda
</pre>

<p>Les périphériques de stockage ci-dessus représentent une interface <i>abstraite</i>.
Les programmes peuvent utiliser ces périphériques de bloc pour interragir avec le
système sans avoir à s'inquiéter si vos pilotes sont IDE, SCSI ou bien autre. Le
programme peut simplement inscrire les données sur le disque en utilisant des blocs
continus, accessibles a aléatoirement, d'une taille de 512 octets chacun.</p>
</body>
</section>
<section>
<title>Partitions et fdisk</title>
<body>
<p> Sous Linux, nous créons un système de fichier en utilisant une commande spéciale
nommée <c>mkfs</c> (ou <c>mke2fs</c>, <c>mkreiserfs</c>, etc,) qui spécifie un système
de fichier particulier en argument de ligne de commande.</p>

<p>Bien qu'il soit théoriquement possible d'utiliser le périphérique de bloc du
"disque entier" (celui qui réprésente le disque <i>entier</i>) comme <c>/dev/hda</c> ou
<c>/dev/sda</c> pour y abriter un système de fichiers entier, ce n'est jamais utilisé
en temps normal. On préfère découper la contenance globale du disque en tronçons
plus petits, donc plus faciles à maîtriser que l'on appelle "partitions". Les partitions
sont créees en faisant appel à un utilitaire nommé <c>fdisk</c>, utilisé pour
créer et éditer la table de partitions qui est inscrite sur chacun des disques. Cette
table décrit exactement comment découper la totalité du disque.
 </p>

<p>Nous pouvons examiner une table de partitions en utilisant <c>fdisk</c>,
et en spécifiant le périphérique qui représente le disque dans son ensemble : </p>

<note>Il existe des alternatives pour consulter les tables de partitions telles que  <c>cfdisk</c>, <c>parted</c> et <c>partimage</c></note>

<pre caption="Démarrage de fdisk">
# fdisk /dev/hda
</pre>
<p>
or
</p>
<pre caption="Démarrage de fdisk sur un disque dur SCSI : /dev/sda">
# fdisk /dev/sda
</pre>

<impo>
<b>Vous ne devriez <i>pas</i> faire de modifications sur une table de partitions d'un
disque contenant des données en utilisation ou importantes. Cela entraîne généralement
la perte des données.</b>
</impo>

<p>
Lorsque vous êtes dans fdisk, vous devriez voir un prompt de ce type :
</p>

<pre caption="Le prompt fdisk">
Command (m for help):
</pre>


<p>
Appuyez sur <c>p</c> pour afficher la table de partitions : </p>

<pre caption="Un exemple de table de partitions :">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p> Ce disque est paramétré pour contenir 7 systèmes de fichiers Linux
(chacun correspondant à une partition listée comme "Linux") ainsi qu'une
partition d'échange (listée comme "Linux swap").  </p>

<p>
Notez le nom des blocs de partitions dans la colonne de gauche, commencant avec
<c>/dev/hda1</c> et finissant par <c>/dev/hda9</c>. Au début de l'ère des PCs,
les logiciels de partitionnement n'autorisaient que 4 partitions (appelées
"partitions principales"). Cela a vite limité les possibilités, on a donc trouvé
une solution pour avoir des <i>partitions étendues</i>). Une partition étendue est
très similaire à une partition primaire, et fait partie d'une des 4 partitions
principales. La différence se situe dans le fait qu'elle peut contenir des
<i>partitions étendues</i>, permettant ainsi de contourner le problème de limite
des 4 partitions.</p>

<p>
Toutes les partitions au dessus de <c>hda4</c> sont des partitions logiques. Les chiffres
1 à 4 sont réservés pour des partitions primaires ou étendues.</p>

<p>Dans notre exemple, <c>hda1</c> à <c>hda3</c> sont des partitions primaires.
<c>hda4</c> est une partition étendue qui contient des partitions logiques numérotées de
<c>hda5</c> à <c>hda9</c>. Vous <i>n'utiliserez</i> donc jamais <c>/dev/hda4</c> pour
stocker des systèmes de fichiers directement -- elle sert juste d'enveloppe pour les
partitions de <c>hda5</c> à <c>hda9</c>.  </p>

<p>Notez également que chaque partition contient une "Id", que l'on appelle aussi
"type de partition". Lorsque vous en créez une nouvelle, assurez-vous bien de placer
correctement le type. '83' est le type correct pour une partition de système de fichiers
Linux et '82' concerne la partition d'échange (swap). Vous pouvez utiliser la lettre <c>t</c>
dans <c>fdisk</c> pour les paramétrer. Le noyau de linux utilise les types de partitions
afin de détecter automatiquement les systèmes de fichiers et les fichiers d'échange sur le
disque à chaque démarrage.
</p>
</body>
</section>
<section>
<title>Utilisation de fdisk pour paramétrer des partitions</title>
<body>

<p>Maintenant que vous avez vu la méthode pour créer des partitions sous Linux, il
est temps de voir comment créer vos partitions sous Gentoo Linux. Une fois que nous
aurons terminé, votres configuration de partitions devrait ressembler à çà :</p>

<pre caption="La configuration des partitions une fois finie">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>Dans notre configuration de partitions pour "nouveau venu", nous avons trois
partitions. La première (<c>/dev/hda1</c>) qui est au début du disque et de petite
taille est appellée partition d'amorçage (boot). Cette partition a pour but de
contenir toutes les données importantes au démarrage -- comme par exemple les informations
de GRUB (ou bien LILO selon ce que vous utilisez) ainsi que vos noyaux Linux. La
partition de démarrage vous donne une place sécurisée pour contenir tout ce qui
concerne le démarrage de Linux. Lors d'une utilisation journalière et régulière
de votre Gentoo Linux, votre partition de d'amorçage (boot) devrait rester
<e>démontée</e> pour plus de sécurité. Si vous avez un système qui utilise des disques
SCSI, votre partition d'amorçage devrait sans doute être <c>/dev/sda1</c>.</p>

<p>Il est recommandé d'avoir des partitions de démarrage (contenant tout le nécessaire
pour permettre au gestionnaire de démarrage de fonctionner) au début du disque dur.
Bien que cela ne soit plus vraiment le cas, c'est une tradition utile qui remonte au
temps où LILO ne pouvait pas charger des kernels qui étaient contenus au dessus des
1024 cylindres d'un disque.</p>

<p>La seconde partition (<c>/dev/hda2</c>) est utilisée comme partition d'échange (swap).
Le noyau utilise un fichier d'échange lorsqu'il n'a plus assez de RAM disponible. Cette
partition n'est généralement pas très grande, aux alentours de 512 MO. Si vous utilisez
un système à base de SCSI, cette même partition s'appelera sans doute <c>/dev/sda2</c>.  </p>

<p>La troisième partition (<c>/dev/hda3</c>) est relativement conséquente et prend le
reste du disque dur. Cette partition, appelée partition "racine" (root) est utilisée pour
stocker votre distribution Gentoo dans son ensemble. Sur un système SCSI, cette partition
s'appelera <c>/dev/sda3</c>.</p>


<p>Avant que nous ne faisions le partitionnement du disque dur, voici une revue rapide
des partitions et systèmes de fichiers conseillés lorsque vous installez Gentoo Linux :</p>

<table>
	<tr>
	<th>Partition</th>
	<th>Taille</th>
	<th>Type</th>
	<th>Exemple</th>
	</tr>
	<tr>
	<ti>partition boot, contenant les informations relatives au kernel</ti>
	<ti>100 MO</ti>
	<ti>ext2/3 de préférence (plus facile); si vous utilisez ReiserFS, à monter avec
	 <c>-o notail</c></ti>
	<ti>/dev/hda1</ti>
	</tr>
	<tr>
	<ti>partition swap (limitation de 2GB contrairement à 128MO précédemment)</ti>
	<ti>Entre une et deux fois la taille actuelle de la RAM</ti>
	<ti>Linux swap</ti>
	<ti>/dev/hda2</ti>
	</tr>
	<tr>
	<ti>partition root, contenant le système principal (/usr, /home, etc)</ti>
	<ti>&gt;=1.5 Go</ti>
	<ti>ReiserFS ou ext3 recommendés; ext2 ok</ti>
	<ti>/dev/hda3</ti>
	</tr>
</table>

<p>OK, il nous faut à présent créer les partitions selon les exemples donnés ci-dessus
. Tout d'abord, démarrez fdisk en faisant <c>fdisk /dev/hda</c> ou <c>fdisk /dev/sda</c>,
selon que vous utilisiez un disque IDE ou SCSI. Tapez ensuite, <c>p</c> afin de voir la configuration
actuelle des partitions. Y a-t'il une quelconque information sur ce disque que vous
devez conserver ? Si oui, <b>arrêtez de suite</b>. Si vous continuez, <b>toutes les données
existentes de votre disque dur seront effacées.</b></p>

<impo>L'application de ces instructions résultera dans <b>l'effacement complet</b> des
données de votre disque dur. Si votre disque contient quelques données que ce soit,
assurez vous que ce ne soit pas quelque chose d'important. Assurez vous également
d'avoir <b>sélectionné le bon disque dur</b> afin de ne pas effacer les données du
mauvais disque dur.</impo>

<p>Effaçons à présent les données des partitions existentes. Pour se faire, appuyez
sur <c>d</c> et entrée. Vous devrez alors spécifier la partition que vous désirez
effacer. Pour effacer par exemple <c>/dev/hda1</c>, tapez :</p>

<pre caption="Effacer une partition">
Command (m for help): d
Partition number (1-4): 1
</pre>

<p>Cette partition est donc programmée pour être effacée. Il ne sera plus visible
si vous tapez sur <c>p</c>, mais ne sera pas effacée avant que vous ne sauvegardiez
vos changements. Si vous faîtes une erreur, vous pouvez annuler sans sauver vos
modifications en tapant sur <c>q</c> et entrée. Rien de ce que vous n'avez fait ne
sera enregistré sur le disque.</p>
<!-- NOTE: THis is not sufficient documentation to cover ATA Raid and I just
find it confusing, so I'm commenting it out (drobbins)
<note>If you are using RAID your partitions will be a little different.  You
will have the partitions like this: <path>/dev/ataraid/discX/partY</path> X are
the arrays you have made, so if you only have made 1 array, then it will be
disc0.Y is the partition number as in <path>/dev/hdaY</path> </note>
-->
<p>Si vous désirez effacer toutes les partitions de votre disque dur, appuyez plusieurs
fois sur <c>p</c> pour afficher la liste des partitions puis appuyez sur <c>d</c> suivi
du numéro de la partition à effacer. Vous vous retrouverez alors
avec une table de partitions vide : </p>

<pre caption="Une table de partitions vide">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>Maintenant que la table de partitions en mémoire vive est vide (rappellez vous qu'aucune
modification n'est encore sauvée sur le disque dur), vous devez créer une partition
de démarrage (boot). Pour se faire, appuyez sur <c>n</c> pour créer une nouvelle
partition puis appuyez <c>p</c> pour lui indiquer que vous désirez créer une partition
primaire. Tapez ensuite <c>1</c> (car il s'agit de la première partition que nous
créons sur le disque dur). Lorsque vous verrez apparaître la demande du cylindre
de démarrage, appuyez sur entrée. Pour le dernier cylindre, tapez <c>+100M</c>
(ndt : je trouve 100Mo un peu beaucoup pour une partition de démarrage sachant que 20Mo
sont généralement largement suffisants). Voici le résultat : </p>

<pre caption="Etapres pour créer notre partition de démarrage (boot)">
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +100M
</pre>

<p>Si vous tapez <c>p</c>, vous devriez donc à présent voir apparaître :</p>

<pre caption="Notre première parition a été créée">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

<p>Créons ensuite la partition d'échange (swap). Pour se faire, appuyez sur
<c>n</c> pour créer une nouvelle partition puis <c>p</c> pour dire à fdisk que cela
sera la seconde partition primaire. Appuyez ensuite sur <c>2</c> ce qui correspondra à
<c>/dev/hda2</c> dans notre cas.
Pour le premier cylindre, appuyez sur entrée. Pour le dernier cylindre, tapez sur
<c>+512M</c> pour créer une partition de 512MO en taille. Lorsque vous avez terminé,
appuyez sur <c>t</c> pour changer le type de partition, et appuyez ensuite sur <c>82</c>
pour changer le type de partition en "Linux Swap". Lorsque vous aurez terminé, <c>p</c>
devrait vous afficher une table de partitions ressemblant à ceci : </p>

<pre caption="Notre partition d'échange (swap) a été créée">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

<p>Créons enfin la partition racine (root). Pour se faire, appuyez une fois de
plus sur <c>n</c> pour créer une nouvelle partition et <c>p</c> pour indiquer que vous
voulez une partition primaire. Ensuite sur <c>3</c> pour créer une troisième partition
primaire qui sera donc <c>/dev/hda3</c> dans notre cas. Appuyez sur entrée pour le
premier cylindre puis à nouveau pour le cylindre de fin pour prendre tout l'espace
disponible restant sur votre disque dur. Après avoir effectué ces étapes, le résultat
de la commande <c>p</c> devrait ressembler à ca : </p>

<pre caption="Notre partition root a été créée">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>

<p>
Il faut à présent placer l'option "amorçable" (bootable) sur la partition de démarrage
et inscrire les changements sur le disque. Pour rendre <c>/dev/hda1</c> amorçable, tappez
<c>a</c> puis <c>1</c> pour indiquer la partition. Si vous tapez <c>p</c> à présent,
vous devriez voir que <c>/dev/hda1</c> affichr un <c>*</c> dans la section "Boot".
Pour inscrire les changements sur le disque dur, appuyez sur <c>w</c> puis entrée. Les
partitions sont à présent prêtes pour une installation de Gentoo Linux.</p>

<note>Si vous avez un avertissement avec <c>fdisk</c> ou <c>cfdisk</c> à propos d'un
rédémarrage pour prendre en compte les changements de partitions, faîtes le.</note>
</body>
</section>
<section>
<title>Créer des systèmes de fichiers</title>
<body>
<p>Maintenant que nous avons créé les partitions, il faut les formater avec un
système de fichier pour pouvoir les monter et les utiliser pour stocker des données.
Nous allons également configurer la partition d'échange comme fichier de stockage de
swap.
</p>

<p>Gentoo Linux supporte une variété de types de systèmes de fichiers ; chacun possédant
ses points forts et ses faiblesses ainsi que des performances différentes. Nous supportons
actuellement la création de systèmes de fichiers tels que : ext2, ext3, XFS, JFS et
ReiserFS.</p>

<p>ext2 est de loin le système de fichiers le plus éprouvé et celui correspondant à
Linux depuis longtemps mais ne contient pas la journalisation des meta-données ce qui
veut dire que la vérification de routine de systèmes de fichiers ext2 au démarrage peuvent
prendre un certain temps. Vous pouvez donc opter pour un système de fichier de type
<i>journalisé</i> qui vérifie les inconsistences rapidement. Les systèmes de
fichiers journalisés permettent d'accélerer les délais de démarrage si vous
avez des erreurs sur ces systèmes de fichiers.</p>

<p>ext3 est la version journalisée d'ext2, fournissant donc le support pour la
journalisation de méta-données améliorant la réparation rapide ainsi que des options
avancées de modes de journalisation tels que la journalisation de données complètes
et données ordonnées. ext3 est très bon et fiable. Il offre des performances décentes
selon les conditions. Etant donné qu'il n'utilise pas de façon extensive l'emploi des
"hiérarchies" dans son design interne, il n'est pas très recommandé pour des systèmes
de fichiers de grande taille car il aura du mal à s'adapter (ce qui est le cas si vous
avez aussi beaucoup de données de grande taille au sein d'un seul répertoire). En dehors
de ce cas, c'est un excellent système de fichiers.</p>

<p>ReiserFS est un système de fichiers basé sur les B*-tree qui permet une performance
générale de bonne qualité et dépasse de loin les performances d'ext2 et ext3 sur la
manipulation de fichiers de petite taille (taille inférieure à 4k), en offrant un gain
de performance de près de 10x-15x. ReiserFS s'adapte parfaitement et possède également
des fonctions de journalisation. Depuis le kernel 2.4.18+, ReiserFS est à présent un
système de fichiers considéré comme robuste et de facto recommandé pour des systèmes
de fichiers standards ou des systèmes de fichiers extrêmes tels que : grande taille,
l'utilisation de beaucoup de fichiers, fichiers très larges et de répertoires contenant
des dizaines de milliers de fichiers. Nous recommandons ReiserFS pour toutes les
partitions qui ne sont pas boot.</p>

<p>XFS est un système de fichiers avec des capacités de journalisation de méta-données
et qui est complètement supporté par le kernel <path>xfs-sources</path> de Gentoo Linux.
Il est livré avec beaucoup de fonctionnalités et est optimisé pour la scalabilité. Nous
le recommandons sur des systèmes ayant des controlleurs SCSI de haut niveau ou des
stockages en fibre optique et en alimentation continue. Du fait que XFS met en cache de façon aggressive les données en transit dans la RAM, les programmes qui ne sont pas
écrit correctement (ceux qui ne prennent pas la précaution d'écrire des fichiers vers le
disque, et il en existe quelques uns) peuvent perdre une bonne quantité de données si le
système s'arrête de façon inattendue.</p>

<p>JFS est le système haute performance de journalisation de fichiers d'IBM. Il a été
récemment déclaré comme valide à l'utilisation en production, ce qui fait qu'il est
difficile de savoir s'il est stable car il manque d'ancienneté pour en savoir plus.</p>

<p>Si vous cherchez le système de fichiers le plus robuste et éprouvé, utilisez ext3.
Si vous voulez utiliser un système de fichiers de haute performance avec support de
journalisation, optez pour ReiserFS ; ext3 comme ReiserFS sont matures, évolués et
recommandés pour une utilisation de tous les jours.</p>

<!-- Corner case, confusing
		<p>But before creating filesystems, you may want to initialize the
			beginning of your partition using <c>dd</c> if you are using a pre-existing partition that has been used before.
			This is particularly helpful when you're going to create a new XFS filesystem on a partition that previously contained
			a ReiserFS filesystem. Doing this will ensure that your new filesystem
			will not be mis-identified by Linux's filesystem auto-detection code.
			This can be done as follows:
			</p>
<pre caption="Initializing first 1024 bytes of your partition">
# <c>dd if=/dev/zero of=/dev/hda3 bs=1k count=1</c>
<comment>(Replace /dev/hda3 with the partition you wish to &quot;clean.&quot;)</comment>
</pre>
	<warn>The command above will destroy all data from <path>/dev/hda3</path>.
	Be careful and check twice which partition you specify for zeroing.
	If you make a mistake it might result in a loss of data.
	</warn>
-->

<p>En se basant sur notre exemple ci-dessus, nous allons utiliser des commandes
pour initialiser toutes les partitions : </p>

<pre caption="Initialisation des partitions (exemple)">
# mke2fs -j /dev/hda1
# mkswap /dev/hda2
# mkreiserfs /dev/hda3
</pre>

<p>Nous avons choisi ext3 pour la partition de boot <c>/dev/hda1</c> car c'est un
système de fichier journalisé robuste qui supporte tous les chargeurs de démarrage
(bootloaders). Nous avons alors utilisé <c>mkswap</c> pour <c>/dev/hda2 </c> qui est
une partition d'échange de données (swap) -- le choix est relativement évident. Enfin
pour notre partition principale (root) <c>/dev/hda3</c> nous avons opté pour ReiserFS,
étant donné qu'il représente un système de fichier journalisé solide qui offre d'excellentes performances. Il est a présent temps d'initialiser vos partitions.</p>

<p>Pour référence, voici les commandes disponibles <c>mkfs</c> lors de
l'installation :</p>

	<p><c>mkswap</c> initialise une partition d'échange:</p>
<pre caption="Initialise le Swap">
# <c>mkswap /dev/hda2</c>
</pre>
<p>Vous pouvez utiliser la commande <c>mke2fs</c> pour créer des systèmes de fichiers
ext2 :</p>
<pre caption="Créer un système de fichiers ext2">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>Pour utiliser ext3, vous pouvez créer des systèmes de fichiers ext3 par la commande :
	<c>mke2fs -j</c>:</p>
<pre caption="Créer un système de fichiers ext3">
# <c>mke2fs -j /dev/hda3</c>
</pre>
        <note>Pour en savoir plus à propos d'ext3 sous Linux 2.4, consultez
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.</note>
        <p>Pour créer un système de fichiers ReiserFS, utilisez la commande <c>mkreiserfs</c> :</p>
<pre caption="Créer un système de fichiers ReiserFS">
# <c>mkreiserfs /dev/hda3</c>
</pre>
        <p>Pour créer un système de fichiers XFS, utilisez la commande <c>mkfs.xfs</c> :</p>
<pre caption="Créer un système de fichiers XFS">
# <c>mkfs.xfs /dev/hda3</c>
</pre>
        <note>Il se peut que vous vouliez ajouter quelques options à la commande
	<c>mkfs.xfs</c> : <c>-d agcount=3 -l size=32m</c>.
	L'option <c>-d agcount=3</c> permet de réduire le nombre de groupes d'allocation.
	XFS insistera pour utiliser au moins un group d'allocation par 4 GO disponible sur
	votre partition, donc par exemple, si vous avez 20 GO de disponible, vous aurez besoin
	d'un mininum de 5 agcount. L'option <c>-l size=32m</c> augmente la taille du journal
	à 32 MO, améliorant ainsi ses performances.</note>

	<p>Pour créer un système de fichiers JFS, utilisez la commande <c>mkfs.jfs</c> :</p>
<pre caption="Créer un système de fichiers JFS">
# <c>mkfs.jfs /dev/hda3</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Montage des partitions</title>
    <section>
      <body>
        <p>Nous allons à présent activer notre nouveau volume de swap, étant donné que
		nous aurons sans doute besoin de cet apport de mémoire virtuelle plus tard :
			</p>
<pre caption="Activatiion du Swap">
# <c>swapon /dev/hda2</c>
</pre>

        <p>Nous créons ensuite les points de montage <path>/mnt/gentoo</path> et <path>/mnt/gentoo/boot</path> et allons monter nos systèmes de fichiers sur ces points.
		Une fois que nos systèmes de fichiers boot et root seront montés, tous les fichiers
		que nous allons copier ou créer dans <path>/mnt/gentoo</path> seront mis sur
		ce système de fichiers. Il va de soi que si vous avez créé des partitions
		supplémentaires telles que <path>/usr</path> ou <path>/var</path>, vous devez
		les monter sous <path>/mnt/gentoo/usr</path> et <path>/mnt/gentoo/var</path>. 			</p>

			 <impo>Si votre partition de <e>boot</e> est en ReiserFS, prenez soin de
			 la monter avec l'option <c>-o notail</c> afin que GRUB puisse s'installer
			correctement. Assurez vous que <c>notail</c> soit présent à la fin de votre 				<path>/etc/fstab</path>sur la ligne de votre partition de boot.
			Nous en reparlerons un peu plus tard dans cette page. Si vous comptez utiliser
			LILO avec ReiserFS, vous n'avez alors pas besoin de <c>-o notail</c>. Il est
			néanmoins conseillé de préciser cette option si vous nous savez pas ce que
			vous devez mettre pour ReiserFS.
			</impo>

<pre caption="Création des points de montage">
# <c>mkdir /mnt/gentoo</c>
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
</pre>

                      <impo>Si vous rencontrez des problèmes au montage de votre partition
					  boot en ext2, essayez ceci :
		   	<c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c> </impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Les des différentes étapes et le chroot</title>
    <section>
		<title>Choisir la bonne étape</title>
      <body>

<p>
Vous devez à présent décider quel tarball vous voulez utiliser comme base de votre
installation.</p>

<p>Si vous désirez faire une installation &quot;à partir de zéro en compilant tout&quot;,
vous devez utiliser l'image <path>stage1-x86-1.4_rc4.tar.bz2</path>. Si vous utilisez
l'un des plus gros CDs tel que l'ISO "3stages", vous aurez également le choix avec
stage2 et stage3. Ces images vous permettront d'économiser du temps mais en perdant
des options de configuration (nous avons déjà défini des optimisations de compilation
ainsi que les variables USE pour vous). Les étapes se trouvent à l'endroit suivant
sur le CD : <path>/mnt/cdrom/gentoo</path>, et vous pouvez taper <c>ls /mnt/cdrom/gentoo</c>
pour voir ce qui s'y trouve.</p>

<p>Si vous désirez faire une installation avec l'archive d'une étape qui ne se trouve <i>pas</i>
sur le CD, c'est possible, mais vous devrez le télécharger séparément et suivre les
instructions qui s'y rapportent. Si vous avez déjà l'archive de l'étape que vous voulez
utiliser (ce qui est le cas de nombreux utilisateurs), passez à la section "Extraction
de l'archive sélectionnée".</p>

<pre caption="Téléchargement des stages nécessaires">
# <c>cd /mnt/gentoo</c>
<comment>Utilisez lynx pour obtenir une URL pour votre tarball:</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc4/x86/</c>
<comment>Utilisez flèche <c>haut</c> et <c>bas</c> (ou bien la touche <c>TAB</c>) afin
d'aller dans le bon répertoire puis mettez en surbrillance le stage que vous voulez
télécharger. Appuyez sur <c>d</c> afin de commencer le téléchargement puis sauvez le
fichier et quittez le navigateur.

<b>OU</b> utilisez directement wget depuis la ligne de commande :</comment>
# <c>wget <comment>insérez ici l'URL complète vers le tarball.</comment></c>
</pre>
      </body>
    </section>
    <section>
		<title>Extraction de l'archive sélectionnée</title>
      <body>

<p>Il est temps d'extraire l'archive compressée du stage qui vous convient vers
<path>/mnt/gentoo/</path>. Souvenez vous de n'en extraire qu'un <b>seul</b> (soit
le stage1, stage2 ou stage3). Si vous désirez donc n'utiliser que le stage3, procédez
comme ceci : </p>

<impo>Utilisez bien l'option <c>p</c> avec <c>tar</c>.  Si vous ne le faîtes pas,
certains fichiers auront des permissions incorrectes.</impo>

<pre caption="Décompresser les stages">
# <c>cd /mnt/gentoo</c>
<comment>Changez "stage3" à "stage2" ou "stage1" selon celui que vous avez choisit.
</comment>
<comment>Si vous avez téléchargé une archive, changez le chemin ci-dessous pour le
changez avec "/mnt/gentoo/" au lieu de "/mnt/cdrom/gentoo/".</comment>
# <c>tar -xvjpf /mnt/cdrom/gentoo/stage3-*.tar.bz2</c>
</pre>

<p>Si vous avez téléchargé une archive dans <path>/mnt/gentoo</path>, vous pouvez à présent
l'éffacer avec la commande <c>rm /mnt/gentoo/stage*.tar.bz2</c>.</p>
</body>
</section>
<section>
<title>Entrer dans le chroot</title>
<body>
<p>
Nous allons à présent faire un <c>chroot</c> vers l'installation de Gentoo Linux
afin de se placer &quot;dedans&quot;.
</p>

<pre caption="Préparer et entrer en chroot">
# <c>mount -t proc proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
<comment>(Les commandes ci-dessus mettent à jour votre environnement et vers des binaires plus à jour.)</comment>
</pre>
        <p>Après avoir exécuté ces commandes, vous serez à &quot;l'intérieur&quot; de
		votre environnement Gentoo Linux dans <path>/mnt/gentoo</path>. Nous allons
		continuer l'installation dans ce chroot.
		</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Obtenir la dernière version de portage par le biais de sync</title>
    <section>
      <body>

<p>Vous devez à présent faire un <c>emerge sync</c>. Cette commande demande à portage
de télécharger la version la plus à jour de la hiérarchie portage de Gentoo Linux.
Portage contient tous les scripts (appelés ebuilds) utilisés pour construire tous
les paquets sous Gentoo Linux. Nous avons actuellement des scripts ebuilds pour
près de 4000 paquets. Une fois que vous avez terminé l'<c>emerge sync</c>, vous
aurez une hiérarchie portage complète se trouvant dans <path>/usr/portage</path>.</p>

<pre caption="Mettre à jour en utilisant sync">
# <c>emerge sync</c>
</pre>

      </body>
    </section>
  </chapter>
  <chapter>
    <title>Placer les optimisations Gentoo (make.conf)</title>
    <section>
      <body>

<p>Maintenant que vous possédez une bonne version de portage, vous pouvez
passer à l'optimisation des paramètres de compilation sur votre système
Gentoo Linux. Portage utilisera ces paramètres lorsqu'il aura à compiler
n'importe quel programme que ce soit. Pour se faire, éditez le fichier
<path>/etc/make.conf</path>.  C'est ici que vous pouvez placer des options
pour <c>USE</c>, qui définit toutes les fonctionnalités que vous désirez
avoir lors de la compilation pour toutes les sources ; vous pouvez bien entendu
le laisser par défaut (soit <e>vide</e> ou désactiver la variable <c>USE</c>) ce
qui ne devrait pas poser de problème. Pour plus d'informations sur <c>USE</c> et
son utilisation, consultez <uri link="http://www.gentoo.org/doc/fr/use-howto.xml">cette page</uri>. Une liste complète des options de USE est également disponible
<uri link="http://www.gentoo.org/dyn/use-index.xml">ici</uri>.  </p>

<p>Vous devriez aussi renseigner <c>CHOST</c>, <c>CFLAGS</c> et
<c>CXXFLAGS</c> de l'architecture du système que vous avez (des exemples commentés se
trouvent plus loin dans le fichier). Ces paramètres serviront aux compilateurs C et C++ pour savoir
comment optimiser le code qui est généré sur votre machine. Les utilisateurs de
processeurs Athlon XP spécifient généralement "-march=athlon-xp" dans leurs CFLAGS et
CXXFLAGS afin que toutes les sources compilées soient optimisées pour leur type de
processeur. Le fichier <path>/etc/make.conf</path> contient un guide général incluant les
paramètres pour CFLAGS et CXXFLAGS.</p>

<p>Si vous êtes derrière un serveur de proximité, c'est également ici que vous le renseignez. Utilisez
la commande suivante pour éditer <path>/etc/make.conf</path> avec <c>nano</c>,
qui est un simple éditeur de texte.
</p>
<pre caption="Paramétrer les options du make.conf">
# <c>nano -w /etc/make.conf</c>
<comment>(Editez CHOST, CFLAGS, CXXFLAGS ainsi que les options du USE ou pour votre proxy)</comment>
</pre>
        <note>
		Pour les personnes désirant personnaliser quelques peu le processus de
		compilation, consultez <path>/etc/make.globals</path>. Il intègre les options
		par défaut de Gentoo Linux et ne devrait pas être touché. Si ces options ne
		suffisent pas, vous devriez modifier <path>/etc/make.conf</path>, qui est pris
		en compte en premier en <comment>outrepassant</comment> les valeurs de
		<path>make.globals</path>. Si vous désirez customiser les paramètres USE,
		consultez <path>/etc/make.profile/make.defaults</path>. Si vous voulez être
		sur que le USE n'utilisera pas une des options, il vous suffit d'ajouter un
  		<c>USE=&quot;-foo&quot;</c> dans votre <path>/etc/make.conf</path> afin de
		désactiver une <c>option</c> qui pourrait être activée par défaut dans votre
		<path>/etc/make.globals</path> ou <path>/etc/make.profile/make.defaults</path>.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Démarrage à partir de la première étape (stage 1)</title>
    <section>
      <body>
	  	<note>Si vous ne commencez pas à partir de la première étape (stage1), passez à la section suivante.</note>
        <p>
		L'archive stage1 sert à complètement optimiser votre système. Si c'est celle
		que vous avez séléctionné, vous devriez alors posséder un système hyper-optimisé
		et très à jour. Amusez vous bien car l'optimisation est ce qui fait tout le
		charme de Gentoo Linux ! Ce type d'installation prend néanmoins très longtemps,
		mais le résultat est à la hauteur en vous fournissant un système optimisé dès le départ.
		</p>
        <p>Nous allons commencer par le &quot;bootstrap&quot;. Ce processus peut prendre
		près de 2 heures sur un AMD Athlon 1200. Pendant ce temps, la librairie C de GNU,
		la suite de compilation ainsi que d'autres programmes clé du système seront
		construits. Pour commencer le bootstrap, faîtes ce qui suit :</p>
<pre caption="Faire le bootstrap">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
</pre>
        <p>Le &quot;bootstrap&quot; va alors démarrer.
			</p>
        <note>
			Portage utilise <c>/var/tmp</c> par défaut pendant ses compilations, utilisant
			pour cela plusieurs centaines de méga-octets d'espace temporaire. Si vous
			voulez changer l'endroit où portage mettra ses fichiers temporaires,
			renseignez un nouveau PORTAGE_TMPDIR <e>avant</e> de commencer le processus de
			bootstrap, comme ceci :
			</note>
<pre caption="Changer le chemin d'utilisation de Portage">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
</pre>
        <p><c>bootstrap.sh</c> va compiler <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,
			et <c>glibc</c>, en recompilant <c>binutils</c>, <c>gcc</c>, et <c>gettext</c>
			après <c>glibc</c>. Nul besoin de dire que cela prends du temps.
			Une fois que ce processus est achevé, votre système sera l'équivalent d'un
			&quot;stage2&quot;, ce qui signifie que vous êtes prêt à passer à la deuxième étape (stage 2).
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Commencer à la deuxième étape et continuer la première</title>
    <section>
      <body>

		<note>
		Cette section concerne ceux continuant le stage1 ou bien commencant au stage2.
		Si cela ne vous concerne pas (ex: vous utilisez le stage3), passez à la section
		suivante.
        </note>
		<p>La seconde archive (stage 2) contient déjà le bootstrap complet pour vous éviter la peine
		de le compiler vous même. Il ne vous reste alors plus qu'à installer le reste du système.
			</p>
		<note>
		Si vous démarrez depuis un stage2 pré-compilé et voulez vous assurer que vous
		avez un set d'outils de compilation complètement à jour, ajoutez <c>-u</c>
		aux commandes qui suivent. Si vous ne voyez pas l'intérêt (ne comprenez pas
		ce qui suit), vous pouvez passer cette suggestion.
		</note>

<pre caption="Installer le reste du système">
# <c>emerge -p system</c>
<comment>(liste les paquets qui restent à installer)</comment>
# <c>emerge system</c>
</pre>
               <p>
				Ce processus va bien sûr prendre du temps vu qu'il installe la base
				entière du système. Votre récompense se mesurera dans l'optimisation de
				votre système. Le problème est qu'il va falloir trouver comment vous
				occupper. L'auteur suggère &quot;StarWars - Super Bombad Racing&quot; pour 					PS2.
			</p>
			<p>
			La compilation est désormais terminée. Vous pouvez continuer et passez à la
			section "Configuration de votre fuseau horaire".
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Démarrage à partir de la troisième étape (stage 3)</title>
    <section>
      <body>
  		<note>
		Cette section est pour ceux <b>commençant</b> avec le stage3, et pas pour
		ceux ayant commencé avec un stage1 ou stage2 qui devraient passer leur chemin
		</note>

	 <p>
	Le tarball stage3 fournit un système Gentoo de base complètement fonctionnel, afin
	que vous n'ayez pas besoin de le construire. Ce au détriment de sa fraîcheur et des
	optimisations spécifiques à votre machine. Si cela vous pose problème, vous pouvez le
	mettre à jour en faisant les commandes décrites plus bas. Notez que cela peut prendre
	un certain temps si le stage3 que vous avez est ancien. Dans le cas contraire, la mise
	à jour devrait être rapide. Vous pouvez bien sûr passer cette section si vous n'en
	voyez pas l'intérêt.
	</p>

<pre caption="Mettre à jour">
# <c>export CONFIG_PROTECT="-*"</c>
# <c>emerge -up system</c>
<comment>(liste les paquets qui doivent être installés)</comment>
# <c>emerge -u system</c>
<comment>(fais le merge des paquets)</comment>
# <c>unset CONFIG_PROTECT</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configuration de votre fuseau horaire</title>
    <section>
      <body>
        <p>Il est maintenant temps de configurer votre fuseau horaire.</p>
        <p>Regardez quelle est votre fuseau horaire (ou GMT)
	   dans <path>/usr/share/zoneinfo</path>. Et créez  ensuite un lien symbolique vers
	   /etc/localtime  en tapant:</p>
<pre caption="Créer un lien symbolique pour votre fuseau horaire">
# <c>ln -sf /usr/share/zoneinfo/chemin/vers/fichiertimezone /etc/localtime</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Installer le kernel et système de logs</title>
    <section>
      <body>
        <note>
		Si vous ne l'avez pas déjà fait, veillez à éditer <path>/etc/make.conf</path>
		pour l'adapter à vos besoins.
			</note>
        <p>Vous devez à présent émerger un kernel parmis ceux que nous offrons :
			</p>
        <table>
          <tr>
            <th>ebuild</th>
            <th>description</th>
          </tr>
          <tr>
            <ti>
              <path>gentoo-sources</path>
            </ti>
            <ti>Notre propre kernel contenant des patches pour la performances et de meilleurs
	    fonctionalités kernel. Attention, il ne comprends pas le patch XFS.
	  </ti>
          </tr>
          <tr>
            <ti>
              <path>xfs-sources</path>
            </ti>
            <ti>Kernel avec support XFS.</ti>
          </tr>
          <tr>
            <ti>
              <path>openmosix-sources</path>
            </ti>
            <ti>Un kernel Linux de base avec support pour le projet GPL <uri link="http://www.openmosix.com">openMosix</uri> qui ajoute la technologie de  load-balancing/clustering.</ti>
          </tr>
          <tr>
            <ti>
              <path>usermode-sources</path>
            </ti>
            <ti>Un kernel Linux de base patché avec User-Mode Linux.  (technologie &quot;Linux inside Linux&quot;)</ti>
          </tr>
          <tr>
            <ti>
              <path>vanilla-sources</path>
            </ti>
            <ti>Le kernel de base Linux venant directement de kernel.org</ti>
          </tr>
        </table>
        <warn>
	Si vous configurez votre propre kernel, faites attention à l'option <i>grsecurity</i>
	. Selon les paramètres mis dans cette section, certains programmes (tels que X) ne
	pourrons pas fonctionner correctement. Si vous avez un doute, ne l'activez pas.
	</warn>
        <p>Choisissez un kernel puis mergez le de cette façon :</p>
<pre caption="Emerger les kernel gentoo-sources">
# <c>emerge sys-kernel/gentoo-sources</c>
</pre>
        <p>Une fois qu'il est disponible, il ne vous reste plus qu'à le configuer et le
	compiler.
	</p>
		<p>Notez que <path>/usr/src/linux</path> est un lien symbolique vers votre
		nouveau kernel, et est automatiquement géré par portage. Si vous avez plusieurs
		kernels sur votre machine, il est important de vérifier que le lien symbolique
		vers <path>/usr/src/linux</path> est le bon.
		</p>
<pre caption="Compiler le kernel Linux">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
        <warn>Si vous voulez que votre kernel fonctionne correctement, il y a quelques
	options que vous devez obligatoirement intégrer -- c'est à dire placées en dur dans
	le kernel et pas en <i>modules</i>. Assurez vous également d'avoir activé
	&quot;ReiserFS&quot; si vous avez opté pour des partitions de ce type, le meme conseil
	s'applique si vous avez installé &quot;Ext3&quot;.  Si vous utilisez XFS, activez cette
	ligne : &quot;SGI XFS filesystem support&quot;. C'est toujours une bonne idée de laisser
	ext2 activé que vous l'utilisiez ou non. Voici quelques options que vous allez avoir
	besoin d'activer :
	</warn>
<pre caption="options make menuconfig">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(Les options ci-dessous demandent celle-ci.)</comment>
     ...

File systems ---&gt;
  &lt;*&gt; Reiserfs support
<comment>(Pour les utilisateurs de partitions reiserfs.)</comment>
       ...
  &lt;*&gt; Ext3 journalling file system support
<comment>(Si vous avez des partitions ext3.)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Nécessaire pour Gentoo Linux.)</comment>
       ...
  &lt;*&gt; JFS filesystem support
<comment>(Pour les utilisateurs de JFS.)</comment>
       ...
  [*] /proc file system support
<comment>(Nécessaire pour Gentoo Linux.)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
<comment>(Required for Gentoo Linux.)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(Désactivez cette option, vous n'en avez PAS besoin.)</comment>
       ...
  &lt;*&gt; Second extended fs support
<comment>(Utile pour ceux utilisant ext2.)</comment>
       ...
  &lt;*&gt; XFS filesystem support
<comment>(Pour les utilisateurs de XFS.)</comment>
</pre>
        <p>Les utilisateurs de RAID matériel devront activer quelques options supplémentaires
		dans le kernel :
			Pour les controleurs de type HighPoint RAID, sélectionnez
			 hpt366 chipset support, support for IDE RAID controlers et Highpoint
			370 software RAID. Pour les controleurs de type Promise RAID sélectionnez
			PROMISE PDC202{46|62|65|67|68|69|70} support,
			support for IDE RAID
			controllers et Support Promise software RAID (Fasttrak(tm))
			</p>
        <p>Si vous utilisez PPPoE pour vous connecter à internet, vous aurez également
		besoin des options suivantes (de préférence en dur dans le kernel ou en modules) :
			&quot;PPP (point-to-point protocol) support&quot;, &quot;PPP support for async
			serial ports&quot;,
			&quot;PPP support for sync tty ports&quot;.
			Le fait de définir les deux compressions ne devrait pas poser de problèmes bien
			que non nécessaire, et il en va de meme pour l'option
			&quot;PPP over Ethernet&quot;, qui peut n'etre utilisée que par <i>rp-pppoe</i>
			lorsque vous le configurez pour faire du mode kernel PPPoE.
			</p>
        <p>Les possesseurs de graveur IDE auront besoin d'activer l'émulation SCSI dans le
		kernel. Activez donc &quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA et
			ATAPI Block
			devices&quot; ---&gt; &quot;SCSI emulation support&quot; (de préférence en
			module selon ce que vous préférez), puis sous &quot;SCSI support&quot; activez
			&quot;SCSI support&quot;, &quot;SCSI CD-ROM
			 support&quot; et &quot;SCSI generic support&quot; (ici encore, je préfère les
			 modules). Si vous avez choisis les modules, faites ceci
			<c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot;	&gt;&gt; /etc/modules.autoload</c>
			pour que ce soit pris en compte au chargement de votre kernel.
			</p>
        <note>
			Pour les aventureux, il est également possible d'utiliser un kernel 2.2, mais
			avec des conséquences : vous allez perdre beaucoup des nouvelles fonctionnalités
			présentes dans les 2.4 (support XFS, tmpfs, iptables et plus encore),  encore
			que vous pouvez patcher un 2.2 avec le support ReiserFS et devfs.
			Le script de démarrage de Gentoo Linux a besoin de tmpfs ou bien d'un support
			de ramdisk en dur (pas en module). Cette option est <comment>vitale</comment>,
			ajoutez <e>gentoo=notmpfs</e> à la ligne du kernel dans
			<path>/boot/grub/grub.conf</path> ou bien dans <path>/etc/lilo.conf</path>
			pour les kernels 2.2 afin qu'un ramdisk soit monté pour les scripts de démarrage
			à la place de tmpfs. Si vous n'utilisez pas devfs, vous devriez placer l'option
			suivante : <e>gentoo=notmpfs,nodevfs</e>.
			</note>
        <p>Votre kernel optimisé (et ses modules) sont à présent installés. Vous devez à
		présent choisir un système de logs. Nous vous offrons la possibilité de choisir
		entre sysklogd, qui est celui généralement présent dans les autres distributions.
		Nous avons également inclus la possibilité d'utiliser msyslog et syslog-ng
		ainsi que metalog. Les utilisateurs expérimentés semblent s'éloigner de sysklogd
		(à cause de ses performances médiocres) pour se tourner vers les nouvelles alernatives.
		En cas de doute, nous vous conseillons metalog, étant donné qu'il est très populaire.
		Pour merger le système de logs de votre choix, tapez <e>une</e> de ces quatres lignes
		:
			</p>
<pre caption="Emerger votre système de logs">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>ou</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>ou</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>ou</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
</pre>
        <impo>
			Metalog inscrit les résultats en blocs sur le disque, ce qui fait que les messages
			ne sont pas directement inscrits dans le fichier de logs. Si vous voulez utiliser
			l'inscription en direct des logs, vous pouvez envoyer à metalog un signal USR1
			afin de désactiver temporairement son inscription retardée (afin que
			<i>tail -f <path>/var/log/everything/current</path></i> inscrive en temps réel
			comme vous l'espérez), et un signal USR2 afin de revenir en mode buffer. Si vous
			voulez complètement le désactiver, vous pouvez changer cette option :
			 METALOG_OPTS="-B" to METALOG_OPTS="-B -s" dans le fichier
			 <path>/etc/conf.d/metalog</path>.
			</impo>
        <p>Vous devez à présent choisir un planificateur de tâches pour votre système. Nous vous
		 offrons actuellement le choix entre dcron, fcron et vcron. Si vous ne savez pas lequel
		 choisir vous pouvez vous tourner vers vcron. Voici comment les installer :
			</p>
<pre caption="Choisir un démon CRON">
# <c>emerge sys-apps/dcron</c>
# <c>rc-update add dcron default</c>
# <c>crontab /etc/crontab</c>
<comment>ou</comment>
# <c>emerge sys-apps/fcron</c>
# <c>rc-update add fcron default</c>
# <c>crontab /etc/crontab</c>
<comment>ou</comment>
# <c>emerge sys-apps/vcron</c>
# <c>rc-update add vcron default</c>
<comment>Nul besoin de mettre à jour <c>crontab /etc/crontab</c> si vous avez choisit
vcron.</comment>
</pre>
			 <p>Pour en savoir plus sur le démarrage des programmes et démons ,
			 consultez le <uri link="/doc/fr/rc-scripts.xml">guide rc-script</uri>.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Installation de paquets divers nécessaires</title>
    <section>
      <body>
        <p>Les utilisateurs de rp-pppoe doivent installer ce paquet car il n'a pas
		encore été mis en place sur votre machine.</p>
<pre caption="Installer rp-pppoe">
# <c>USE="-X" emerge rp-pppoe</c>
</pre>

		<note>L'option <i>USE="-X"</i> évite à pppoe d'installer ces options pour X, ce qui
		est une bonne chose, étant donné que X devrait alors etre installé et nous ne l'avons
		pas encore fait. Vous pouvez toujours recompiler <i>rp-pppoe</i> afin d'ajouter le
		support pour X plus tard.
		</note>
        <note>Notez également que rp-pppoe est installé mais pas configuré, il vous faut en effet
		taper <c>adsl-setup</c> lors du premier redémarrage.
			</note>
        <p>Selon le système de fichiers utilisé, vous aurez sans doute besoin de quelques
		packages supplémentaires tels que XFS, ReiserFS ou LVM. Si vous utilisez XFS, vous
		devriez émerger le paquet <c>xfsprogs</c> :
			</p>
<pre caption="Emerger les outils pour systèmes de fichiers">
# <c>emerge sys-apps/xfsprogs</c>
<comment>Si vous utilisez ReiserFS, vous devriez émerger les outils ReiserFS : </comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>Si vous utilisez JFS, il vous faudra les outils JFS : </comment>
# <c>emerge jfsutils</c>
<comment>Si vous utilisez LVM, vous devriez émerger <c>lvm-user</c> : </comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>
        <p>Les utilisateurs de portables qui veulent utiliser leurs ports PCMCIA après le
		premier démarrage devraient émerger le paquet <i>pcmcia-cs</i>.
			</p>
<pre caption="Emerger PCMCIA-cs">
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
        <warn>Vous devrez réémerger <i>pcmcia-cs</i> après installation afin de faire
		marcher correctement PCMCIA.
			</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Modifier /etc/fstab pour votre machine</title>
    <section>
      <body>
        <p>Votre système Gentoo Linux est quasimment pret à fonctionner. Il ne vous reste plus
		qu'à configurer quelques fichiers système importants et installer le gestionnaire de
		démarrage. Le premier fichier que vous aurez besoin de moficier est
		<path>/etc/fstab</path>.  Rappellez vous bien d'utiliser l'option <c>notail</c>
		pour votre partition de démarrage si vous utilisez ReiserFS. Notez également que
		vous devez vous rappeller de spécifier <c>ext2</c>, <c>ext3</c> ou <c>reiserfs</c>
		selon le type de système de fichiers que vous utilisez.
			</p>
        <p>Vous pouvez vous inspirer de l'exemple de <path>/etc/fstab</path> ci-dessous, en
		vous assurant de remplacer &quot;BOOT&quot;, &quot;ROOT&quot; et &quot;SWAP&quot;
		avec vos propres partitions (telle que <c>hda1</c>, etc.)</p>
<pre caption="Editer fstab">
<comment># /etc/fstab: information des systèmes de fichiers statiques.
#
# noatime désactive atimes afin d'en améliorer les performances (atimes n'est généralement
# pas nécessaire ; notail améliore les performances de ReiserFS (mais répercute ce gain
# sur l'efficacité de stockage).  Vous pouvez supprimer l'option noatime si vous voulez
# utiliser notail et tail sans contraintes.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: Si votre partition BOOT est en ReiserFS, ajoutez l'option notail à opts.
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>
        <warn>Notez que <i>/boot</i> n'est pas monté au démarrage, ceci afin de protéger
		les données s'y trouvant contre une éventuelle corruption. Si vous avez besoin de
		l'accéder, montez la.
			</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Paramétrage d'un mot de passe pour le super-utilisateur root</title>
    <section>
      <body>
        <p>Avant que vous ne l'oubliiez, tapez un mot de passe pour le super-utilisateur
		root en faisant : </p>
<pre caption="Paramétrage du mot de passe pour le super-utilisateur root">
# <c>passwd</c>
</pre>

	<p>Vous pouvez également à ce moment ajouter vos utilisateurs, consultez pour se faire
	la <uri link="http://www.gentoo.org/doc/fr/faq.xml">FAQ Gentoo</uri>.
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Paramétrage du nom de machine</title>
    <section>
      <body>
        <p>Editez le fichier <path>/etc/hostname</path> pour qu'il contienne votre nom complet
		de domaine sur une ligne, ex. <c>mamachine.mondomaine.com</c>.
			</p>
<pre caption="Configurer votre nom de machine">
# <c>echo mamachine.mondomaine.com &gt; /etc/hostname</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Modification de votre /etc/hosts</title>
    <section>
      <body>
        <p>Ce fichier contient une liste d'adresses IP associées à leurs noms de machines.
		Très utile pour les machines qui ne peuvent résoudre les machines qui ne sont pas
		dans les DNS. Voici un template pour se faire :
			</p>
<pre caption="Template pour les hotese">
127.0.0.1      localhost
<comment># la ligne suivante devrait contenir votre adresse IP et son nom associé</comment>
192.168.1.1    mamachine.mondomaine.com	mamachine
</pre>
        <note>Si vous utilisez DHCP, n'oubliez pas de paramétrer <i>localhost</i> avec le
		nom de votre machine. Cela aidera Gnome ainsi que d'autres programmes à faire une
		résolution de noms qui soit correcte.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configuration finale des modules</title>
    <section>
      <body>
        <p>Ajoutez les noms de tous les modules qui sont nécessaires au bon fonctionnement de
		votre système dans le fichier <path>/etc/modules.autoload</path> (vous pouvez bien
		évidemment spécifier les options nécessaires sur la même ligne). Dans la liste de
		vos modules devrait se trouver celui de votre carte réseau, si vous l'avez compilé
		en tant que module :
			</p>
<pre caption="/etc/modules.autoload"><comment>Les possesseurs de carte 3com peuvent faire :
Vérifiez <path>/lib/modules/`uname -r`/kernel/drivers/net</path> pour trouver le module
de votre carte. </comment>
3c59x
</pre>
        <p>Editez le fichier <path>/etc/conf.d/net</path> pour configurer correctement votre
		carte au premier démarrage : </p>
<pre caption="Configuration de réseau au démarrage">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
</pre>
        <p>Si vous avez plusieurs cartes réseau, créez des scripts du type
		<path>net.eth<comment>x</comment></path> pour chacune d'entre elles.
		(<comment>x</comment> = 1, 2, ...): </p>
<pre caption="Cartes réseau multiples">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
</pre>
        <p>Si vous avez des cartes PCMCIA installées, regardez rapidement
		<path>/etc/init.d/pcmcia</path> pour vérifier qu'il correspond à votre configuration,
			et ajoutez ensuite la ligne suivante dans <path>/etc/init.d/net.ethx</path>:
			</p>
<pre caption="PCMCIA depend dans /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
</pre>
        <p>Chargera PCMCIA avant la configuration réseau.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Etapes finales : Edition de la configuration de base (paramétrage du clavier)</title>
    <section>
      <body>
<pre caption="Configuration de base">
# <c>nano -w /etc/rc.conf</c>
</pre>
        <p>Suivez les indications dans le fichier pour savoir comment les paramétrer. Tous
		les utisateurs devraient s'assurer que <c>CLOCK</c> est correctement paramétré.
		Les utilisateurs de claviers internationaux doivent modifier la variable
		<c>KEYMAP</c> (parcourez <path>/usr/share/keymaps</path> pour voir les options
		disponibles).
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configuration d'un gestionnaire de démarrage</title>
	<section>
	<title>Notes</title>
	<body>
	<p>
	Totalement dans l'esprit de Gentoo, vous pouvez choisir ici parmis plusieurs gestionnaires
	de démarrage. Choisissez donc entre GRUB ou LILO.
	</p>
	<p>Il est bien entendu inutile d'installer les deux gestionnaires sur le meme système,
	vous devriez donc choisir celui que vous allez utiliser.
	</p>
	<impo>Si vous installez Gentoo Linux sur un système qui contient une NVIDIA nForce ou
	nForce2 utilisant la carte graphique intégrée de type GeForce, vous devriez utiliser
	LILO et éviter GRUB. Le fait d'utiliser la carte graphique intégrée utilise la mémoire
	basse de votre RAM. Etant donné que GRUB en prends également, vous pourriez expérimenter
	une erreur de type "out of memory" (plus de mémoire). Donc les possesseurs de cartes
	vidéo intégrées devraient se tourner vers LILO.</impo>

	</body>
	</section>
    <section>
	<title>Configuration de GRUB</title>
      <body>
        <p>La partie la plus importante dans GRUB est de le comprendre afin de se sentir en confiance
		pour effectuer son installation sur votre disque dur. Votre partition Linux 							<path>/dev/hda1</path> s'appelle <path>(hd0,0)</path> sous GRUB. Notez bien les parenthèses
		autour du hd0,0 qui sont nécessaires. Les disques durs commencent à 0 plutôt qu'à &quot;a&quot;, 		et les partitions également à 0 plutôt qu'à un. Notez également que seuls les disques durs sont
		pris en compte et pas les périphériques atapi IDE de type lecteurs CDROM, graveurs, ce qui est
		également le cas pour les disques SCSI. (On leur assigne généralement des chiffres plus élevés
		que ceux des disques durs IDE sauf lorsque le BIOS est paramétré pour démarrer depuis des
		périphériques SCSI). En considérant que vous avez un disque dur sur /dev/hda, un lecteur CDROM
		sur /dev/hdb, un graveur sur /dev/hdc, un second disque dur sur /dev/hdd et aucun lecteur SCSI,
		<path>/dev/hdd7</path> devient alors <path>(hd1,6)</path>.

		Cela peut sembler complexe, ce qui est le cas, mais comme vous le verrez plus tard, GRUB offre
		un mécanisme de démarrage qui est extrêmement utile dans le cas de ceux possédant plusieurs
		disques durs et encore plus de partitions et qui se perdent quelques peu dans la méthode de
		numérotation. Vous êtes à présent prêt à installer GRUB.
			</p>
        <p>La façon la plus simple pour installer GRUB est de taper <c>grub</c> dans votre shell
		en chroot : </p>
<pre caption="Installation de GRUB">
# <c>emerge grub</c>
# <c>grub</c>
</pre>
        <impo>Si vous utilisez du RAID matériel, cette partie ne marchera pas à ce moment,
		passez à la section pour créer votre <path>grub.conf</path>. Après cela, nous nous occuperons
		du paramétrage de grub pour le controleurs RAID.
			</impo>
        <p>Vous devriez alors vous retrouver en face du prompt <c>grub&gt;</c>. Il vous faut maintenant
		tapper les bonnes commandes pour installer le secteur de démarrage de GRUB. Dans notre exemple
		de configuration, nous voulons installer GRUB sur le MBR (premier secteur du disque dur), afin
		que cela soit la première chose que l'ordinateur détecte au démarrage. Dans ce cas, les
		commandes à taper sont :
			</p>

<pre caption="GRUB sur le MBR">
grub&gt; <c>root (hd0,0)</c> <codenote>Votre partition boot</codenote>
grub&gt; <c>setup (hd0)</c> <codenote>Indique où installer le boot record, ici, dans le MBR</codenote>
</pre>

<pre caption="GRUB en dehors du MBR">
<comment>Si vous voulez installer GRUB ailleurs que sur le MBR</comment>
grub&gt; <c>root (hd0,0)</c> <codenote>Votre partition boot</codenote>
grub&gt; <c>setup (hd0,4)</c> <codenote>Indique où installer le boot record, ici sur /dev/hda5</codenote>
grub&gt; <c>quit</c>
</pre>

	<p>Voici comment fonctionnent ces deux commandes. La première commande <c>root ( )</c>
	indique à GRUB l'endroit où se trouve la partition de boot (dans notre exemple
	<path>/dev/hda1</path> ou <path>(hd0,0)</path> en terminologie GRUB. La seconde commande
	<c>setup ( )</c> indique à GRUB où installer le secteur de démarrage - qui sera alors configuré
	pour chercher ses fichiers de démarrage dans la location <c>root ( )</c> que vous avez
	spécifié. Dans mon cas, je veux le secteurde démarrage sur le MBR du disque dur, il me suffit donc
	d'indiquer <path>/dev/hda</path> (également appellé <path>(hd0)</path>).
	Si j'utilise un autre gestionnaire de démarrage et veux installer GRUB en tant que gestionnaire de
	démarrage secondaire, je peux installer GRUB sur le secteur de démarrage d'une partition. Dans ce
	cas, je spécifie une partition donnée plutôt que le disque dur entier. Une fois que le secteur de
	démarrage de GRUB est installé, il ne reste qu'à taper <c>quit</c> pour sortir de GRUB.
			</p>

			<note> La complétion automatique de GRUB peut être utilisée à l'intérieur même de
			GRUB si vous l'avez paramétré en inscrivant <c> root (</c>. Le fait d'appuyer sur TAB
			devrait vous donner une liste des périphériques disponibles (et pas seulement les disques
			durs). Si vous appuyez sur TAB après avoir inscrit <c> root (hd</c>, grub vous listera
			alors les partitions accessibles sur le premier disque dur. Cette fonctionnalité devrait
			vous aider à faire les bons choix sous GRUB et paramétrer la bonne partition.
			</note>

			<p>
			Gentoo Linux est à présent installée, mais nous devons avant tout créer un fichier
			<path>/boot/grub/grub.conf</path> sinon GRUB n'aura aucun fichier à consulter lors
			du prochain démarrage.</p>
        <impo>Afin d'assurer une compatibilité avec les versions précédentes de GRUB, créez un lien
		de <i>grub.conf</i> vers <i>menu.lst</i>. Vous pouvez le faire grâce à la commande
			<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>. </impo>
        <p>Créez à présent le fichier grub.conf (<c>nano -w /boot/grub/grub.conf</c>), et ajoutez
		ce qui suit :
			</p>
<pre caption="Grub.conf pour GRUB">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Mon exemple de Gentoo Linux
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/hda3

<comment># Configuration pour RAID matériel</comment>
title=Ma Gentoo Linux sur RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment># Pour ceux possédant un dual-boot</comment>
title=Windows XP
root (hd0,5)
chainloader (hd0,5)+1
</pre>
        <note>
			(hd0,0) s'écrit sans aucun espace entre les parenthèses.
			</note>
        <impo>
			Si vous paramétrer une émulation SCSI pour votre graveur IDE, vous devez ajouter l'option
			&quot;hdx=ide-scsi&quot; sur la ligne de kernel de grub.conf (où &quot;hdx&quot;
			représente le périphérique servant à graver).
			</impo>
        <p>Après avoir sauvé ce fichier votre installation Gentoo Linux est vraiment complète.
		En redémarrant, la selection de la première option devrait amorcer votre Gentoo sans soucis.
		La seconde partie du fichier grub.conf est optionnelle et montre comment ajouter une ligne
		pour démarrer un système dual-boot avec Windows.
			</p>
        <note>Dans l'exemple ci-dessus, <path>(hd0,0)</path> devrait pointer vers votre partition
		&quot;boot&quot; (<path>/dev/hda1</path> dans notre exemple) et <path>/dev/hda3</path>
		devrait pointer vers la partition root. <path>(hd0,5)</path> contient le secteur de démarrage
		de NT.</note>
        <note>
			Le chemin vers l'image du kernel est relatif à la partition de démarrage. Si dans votre
			cas vous avez séparé la partition de démarrage boot <path>(hd0,0)</path> et la partition
			root <path>(hd0,1)</path>, tous les chemins dans le fichier grub.conf pointerons vers
			<path>/bzImage</path>.
			</note>
        <p>Si vous avez besoin d'ajouter quelque option que ce soit à votre kernel, ajoutez les
		simplement à la fin de la commande <c>kernel</c>. Nous avons déjà ajouté une option
			(<c>root=/dev/hda3</c>), mais vous pouvez en rajouter autant que vous voulez.
			Si vous désirez en particulier désactiver devfs (pas recommandé à moins de savoir ce que
			vous faites) ajoutez alors <c>gentoo=nodevfs</c> à la fin de la ligne <c>kernel</c>.
			</p>
        <note>Vous n'avez plus besoin d'ajouter l'option <c>devfs=mount</c> (comme c'était le cas
		dans les versions précédentes de Gentoo) à la fin de votre ligne de <c>kernel</c>. Depuis la
		rc3, c'est fait automatiquement.
			</note>
      </body>
    </section>
	<section>
    <title>Configuration de LILO</title>
      <body>
        <p>Bien que GRUB représente l'alternative pour la plupart des personnes, ce n'est pas toujours
		la meilleure solution. LILO était utilisé bien avant GRUB et peut régler certains problèmes.
		Voici comment installer LILO :
	</p>
        <p>La première étape est d'émerger LILO:
	</p>
<pre caption="Emerger LILO">
# <c>emerge lilo</c>
</pre>
        <p>Ensuite, on le configure. Voici un fichier d'exemple de configuration
		<path>/etc/lilo.conf</path>
	</p>
<pre caption="Exemple de lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	read-only
	root=/dev/hda3

# Pour systèmes utilisant le dual boot
other=/dev/hda1
	label=dos
</pre>
	<ul>
        <li><i>boot=/dev/hda</i> indique à LILO de s'enregistrer sur le premier secteur d'amorçage
		IDE. </li>
        <li><i>map=/boot/map</i> indique où trouver le fichier map. Il n'est généralement pas nécessaire
		de le modifier.</li>
        <li><i>install=/boot/boot.b</i> indique à LILO d'installer ce fichier comme secteur de démarrage 		</li>
        <li>Le paramètre <i>prompt</i> indique à LILO d'afficher <i>lilo:</i> au démarrage.
		Il n'est pas recommandé de le laisser, vous pouvez d'ailleurs l'obtenir en appuyant sur
  		[Shift] quand votre machine démarre. </li>
        <li><i>timeout=50</i> indique au bout de combien de temps LILO sélectionne l'image par
		défaut. Cette valeur s'exprime en 10ème de secondes, 50 étant la valeur par défaut.</li>
        <li><i>lba32</i> indique la géométrie du disque à LILO. L'autre étant linear. Ne la changez
		pas à moins de savoir ce que vous faîtes. Cela pourrait rendre votre système inamorçable.</li>
        <li><i>default=linux</i> indique le label qui sera utilisé par défaut.</li>
        <li><i>image=/boot/vmlinuz-2.4.20</i> indique l'image utilisée par le boot.</li>
        <li><i>label=linux</i> nomme le système d'exploitation sur l'écran lilo. Dans cet exemple
		précis, c'est également le nom de la ligne par défaut.</li>
        <li><i>read-only</i> indique que la partition root (voir la ligne root en dessous) est
		en lecture seule et ne devrait en aucun cas être modifiée durant le démarrage.</li>
        <li><i>root=/dev/hda5</i> indique à LILO quelle est la partition root (racine). </li>
	</ul>
        <p>Après avoir édité le fichier <i>lilo.conf</i>, il ne vous reste plus qu'à inscrire les
		informations de LILO sur le MBR :
	</p>
<pre caption="Exécuter LILO">
# <c>/sbin/lilo</c>
</pre>
        <p>LILO est à présent configuré, et votre système Gentoo Linux est prêt !
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Création de disquettes de démarrage</title>
    <section>
      <title>GRUB Bootdisks</title>
      <body>
        <p>C'est toujours une bonne idée de créer des disquettes la première fois que vous installez
		une distribution Linux. C'est généralement une bonne chose à faire. Si vous utilisez du RAID
		matériel, vous devriez faire une disquette de démarrage pour GRUB. Avec ces types de RAID
		matériel, l'installation de GRUB en chroot peut échouer. Vous devez alors créer une disquette
		de démarrage avec GRUB pour redémarrer dessus et réinscrire le MBR.
			</p>
<pre caption="Création de la disquette de démarrage de GRUB">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>
# <c>umount /mnt/floppy</c>
# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
</pre>
        <p>Redémarrez à présent sur la disquette. Lors du prompt <c>grub&gt;</c>, vous pourrez
		alors éxecuter <c>root</c> et <c>setup</c>.</p>
      </body>
    </section>
    <section>
      <title>Disquettes de démarrage de LILO</title>
      <body>
        <p>Si vous utilisez LILO, vous devriez aussi faire une disquette de démarrage :
		</p>
<pre caption="Making a LILO Bootdisk">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>Ne marchera que si votre kernel fait moins que 1.4MB</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Installation Complète !</title>
    <section>
      <body>
        <p>Gentoo Linux est à présent installé. La dernière étape est de ... mettre à jour les
		fichiers de configuration et de sortir du shell chroot, démonter les partitions et redémarrer
		le système.
			</p>
<pre caption="Redémarrage du système">
# <c>etc-update</c>
# <c>exit</c>
<comment>(Sort du shell chroot; marche aussi avec <c>^D</c>)</comment>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
        <note>
			Après avoir redémarré, il est conseillé de faire un <c>update-modules</c> pour créer le
			fichier <path>/etc/modules.conf</path>.  Pensez à modifier les fichiers se trouvant dans
			<path>/etc/modules.d</path> plutôt que de toucher modules.conf.
			</note>
        <impo>Si vous utilisez du RAID matériel, vous devez utiliser une disquette de démarrage lors
		du premier démarrage pour installer GRUB correctement. C'est désormais fini -- félicitations !
		</impo>
        <p>Si vous avez des questions ou que vous désirez être actif dans le développement de Gentoo
		Linux, vous pouvez vous inscrire aux listes gentoo-user et gentoo-dev (pour plus d'informations,
		consultez cette <uri link="http://www.gentoo.org/main/en/lists.xml">page</uri>). Nous avons
		également rédigé un <uri link="http://www.gentoo.org/doc/en/desktop.xml">Guide de
		configuration du bureau</uri> qui devrait vous aider à paufiner votre nouvelle distribution
		Gentoo Linux, ainsi qu'un <uri link="http://www.gentoo.org/doc/en/portage-user.xml">Guide
		utilisateur de portage</uri> afin de vous aider à vous familiariser avec les bases de portage.
		 Vous pouvez trouver le reste de la documentation
		 <uri link="http://www.gentoo.org/main/en/docs.xml">ici</uri>. Si vous avez d'autres questions,
		 pensez à consulter la <uri link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri>. Amusez
		 vous bien et bienvenue sous Gentoo Linux !
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentoo-Stats</title>
    <section>
      <body>
        <p>Ce programme permet de donner aux développeurs une idée des statistiques d'utilisation
		de Gentoo. Il collecte des informations sur Gentoo Linux afin de nous aider à placer des
		priorités dans le développement. Son installation est complètement optionnelle mais nous
		apprécions le geste si vous décidez de l'utiliser. Les statistiques sont consultables sur
		<uri>http://stats.gentoo.org/</uri>.
		</p>
        <p>Le serveur gentoo-stats vous attribuera alors un numéro ID unique. Cette ID sera utilisée
		pour assurer que chaque système n'est référencé qu'une seule fois. Elle ne sera en aucun cas
		utilisée pour identifier individuellement votre système ou recenser une adresse IP ou toute
		autre information personnelle. Voici ce que nous récupérons comme informations : </p>
        <ul>
          <li>Paquets installés et versions</li>
          <li>Informations processeur : vitesse (MHz), revendeur , type, options (tel &quot;mmx&quot;
		  ou &quot;3dnow&quot;)</li>
          <li>Informations Mémoire (total disponible de RAM et de swap)</li>
          <li>Cartes PCI et cartes réseau</li>
          <li>Le profil Gentoo utilisé par votre machine (l'endroit où pointe votre
		  /etc/make.profile).</li>
        </ul>
        <p>Nous sommes sensible au fait que ces informations sont importantes et ne doivent être divulguées
		(ce qui reflète la pensée des développeurs).
		</p>
        <ul>
          <li>A moins que vous ne modifiez le programme gentoo-stats, il ne transmettra jamais
		  d'informations sensibles telles que vos mots de passe, vos données, votre taille de
		  chaussures ...</li>
          <li>La transmission de votre adresse email est optionnelle et désactivée par défaut.</li>
          <li>Votre adresse IP ne sera jamais divulguée de façon à vous identifier. Nous n'enregistrons
		  pas de corrélation entre &quot;Adresse IP/ID système&quot;.</li>
        </ul>
        <p>L'installation est simple, comme suit :
		</p>
<pre caption="Installation de gentoo-stats">
# <c>emerge gentoo-stats</c>   <codenote>Installe gentoo-stats</codenote>
# <c>gentoo-stats --new</c>    <codenote>Obtient une nouvelle ID système</codenote>
</pre>
        <p>La seconde commande demande une ID qu'elle place ensuite dans
		<path>/etc/gentoo-stats/gentoo-stats.conf</path> automatiquement. Vous pouvez ensuite
		éditer ce fichier pour consulter les autres options disponibles.
		</p>
        <p>Configurez ensuite ce programme pour tourner à intervalle régulière (sans
		avoir besoin d'être root) en éditant votre <path>crontab</path>:
		</p>
<pre caption="Mettre à jour gentoo-stats avec cron">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
</pre>
        <p>Le programme <c>gentoo-stats</c> est un simple script perl qui peut être édité avec
		votre programme favori en ouvrant : <path>/usr/sbin/gentoo-stats</path>.	</p>
      </body>
    </section>
  </chapter>
</guide>
