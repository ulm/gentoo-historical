<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/diskless-howto.xml,v 1.24 2006/10/25 13:29:16 cam Exp $ -->

<guide link="/doc/fr/diskless-howto.xml" lang="fr">

<title>Gentoo sur des machines sans disque</title>

<author title="Auteur">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Correcteur">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Relecteur">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Relecteur, traducteur">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Traducteur">
    <mail link="ribosome@gentoo.org">Olivier Fisette</mail>
</author>

<abstract>
Ce guide vous explique comment installer des stations sans disque avec Gentoo.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.22</version>
<date>2006-10-22</date>

<chapter>
<title>Introduction</title>

<section>
<title>À propos de ce guide</title>
<body>

<p>
Ce guide va vous montrer comment installer des stations <e>diskless</e> (sans
disque). Il est basé sur la distribution Gentoo. Nous avons essayé de rendre
ce guide aussi accessible que possible en pensant au débutant que nous avons
tous été. Bien qu'un utilisateur plus expérimenté puisse réussir à assimiler
les différents guides sur les stations sans disque et les réseaux, nous
espérons que ce guide vous épargnera bien des écueils.
</p>

</body>
</section>

<section>
<title>Qu'est-ce qu'une machine diskless ?</title>
<body>

<p>
Une machine diskless est un PC dépourvu des périphériques de démarrage
habituels, c'est-à-dire sans disque dur ni lecteur de CD-ROM ou de disquette.
Un PC diskless démarre sur le réseau et a besoin d'un serveur qui va lui
fournir de l'espace disque comme un disque dur local. Nous appellerons le
serveur le <e>maître</e> et les machines sans disque des <e>esclaves</e>. Un
esclave a besoin d'une carte réseau qui supporte le démarrage via PXE ou
Etherboot&nbsp;; consultez <uri
link="http://www.etherboot.org">Etherboot.org</uri> pour des listes des matériels
supportés. La plupart des cartes modernes, ainsi que plusieurs adaptateurs
intégrés aux cartes-mères, supportent PXE.
</p>

</body>

</section>

<section>
<title>Avant de commencer</title>
<body>

<p>
Gentoo devrait être installé sur votre maître et celui-ci devrait
disposer de suffisamment d'espace disque pour stocker les systèmes de
fichiers des nœuds esclaves. Assurez-vous aussi d'avoir une interface Internet
séparée de la connexion au réseau local.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configuration des nœuds maître et esclaves</title>

<section>
<title>À propos du noyau</title>
<body>

<note>
Si vous avez l'intention de construire un cluster openMosix, vous devez
utiliser le noyau adapté pour openMosix. Il se trouve dans Portage sous
<path>sys-kernel/openmosix-sources</path>. Vous devriez lire notre <uri
link="openmosix-howto.xml">Guide openMosix</uri> pour savoir quelles options
sélectionner dans un noyau openMosix.
</note>

<p>
Le noyau est le logiciel qui sert d'interface entre votre matériel et
l'ensemble des logiciels installés sur votre machine. Il est le cœur
de tout système construit autour d'un noyau. Quand votre PC démarre, le BIOS
exécute les instructions qu'il trouve dans le secteur de démarrage de votre
disque dur («&nbsp;boot sector&nbsp;» en anglais). Ces instructions sont
communément appelées le chargeur de démarrage (en anglais «&nbsp;boot
loader&nbsp;»). Celui-ci charge le noyau en mémoire et lui passe la main.
</p>

<p>
Pour plus d'informations relatives au noyau et à sa configuation,
vous pouvez consulter le <uri
link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">kernel howto</uri>.
</p>

</body>
</section>

<section>
<title>Configuration du noyau du nœud maître</title>
<body>

<p>
Peu importe la taille et le niveau de paramétrage du noyau maître,
certaines options sont indispensables. Voici comment configurer votre noyau&nbsp;:
</p>

<pre caption="Modifier la configuration du noyau du nœud maître">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Une interface devrait apparaître et vous permettre de
configurer votre noyau plus facilement qu'en modifiant manuellement le
fichier <path>/usr/src/linux/.config</path>. Si votre noyau actuel
fonctionne, vous voulez peut-être garder une copie de sa configuration.
Quittez l'écran de configuration et tapez&nbsp;:
</p>

<pre caption="Sauvegarder une copie de la configuration du noyau maître">
# <i>cp .config .config_working</i>
</pre>

<p>
Vérifiez que les options listées ci-dessous sont bien sélectionnées pour
être compilées en dur et <e>PAS</e> comme modules. Les options affichées
ci-dessous proviennent du noyau 2.6.10. Si vous utilisez une autre version, il
se peut que le texte ou l'ordre diffère quelque peu.
</p>

<pre caption="Les options du noyau maître">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers


Device Drivers ---&gt;
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)


File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support

<comment>
Si vous voulez accéder à Internet par le nœud maître et/ou utiliser un pare-feu
sécurisé, assurez-vous d'ajouter le support pour iptables.
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Si vous voulez utiliser le filtrage des paquets, vous pouvez ajouter le reste
des modules plus tard. Assurez-vous de lire le <uri
link="/doc/fr/security/security-handbook.xml?part=1&amp;chap=12">chapitre sur
les pare-feu</uri> du manuel de sécurité Gentoo pour savoir comment configurer
le filtrage de manière appropriée.
</p>

<note>
Ces options de configuration du noyau s'ajoutent aux options spécifiques
à votre matériel, elles ne les remplacent pas.
</note>

<p>
Après avoir configuré le noyau maître, vous devez le compiler.
Tapez ceci&nbsp;:
</p>

<pre caption="Recompiler le noyau maître et ses modules">
# <i>make &amp;&amp; make modules_install</i>
<comment>(Vérifiez que /boot est monté avant d'y copier le noyau)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
</pre>

<p>
Maintenant que le nouveau fichier bzImage a été copié dans votre répertoire
<path>/boot</path>, il ne vous reste plus qu'à vous assurer que votre
chargeur de démarrage («&nbsp;bootloader&nbsp;») l'utilise.
Modifiez <path>lilo.conf</path> ou <path>grub.conf</path> selon le
chargeur de démarrage que vous utilisez. Ensuite, vous pouvez redémarrer votre
machine pour activer ces nouvelles options.
</p>

</body>
</section>

<section>
<title>À propos du noyau esclave</title>
<body>

<p>
Il est recommandé de compiler le noyau esclave sans modules, c'est-à-dire avec
les options compilées en dur parce qu'il est difficile et inutile de charger des
modules lors d'un démarrage via le réseau et parce que ce noyau doit être aussi
compact que possible pour démarrer plus rapidement. Nous allons compiler le
noyau esclave au même endroit que le noyau maître.
</p>

<p>
Pour éviter toute confusion et toute perte de temps, il vaut mieux garder une
copie de la configuration du noyau maître comme ceci&nbsp;:
</p>

<pre caption="Sauvegarder une copie de la configuration du noyau maître">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Nous devons maintenant configurer le noyau des nœuds esclaves de la même
façon que pour le noyau maître. Si vous préférez repartir d'une
configuration vierge, vous pouvez réinitialiser
<path>/usr/src/linux/.config</path> comme ceci&nbsp;:
</p>

<pre caption="Obtenir une configuration de noyau vierge">
# <i>cd /usr/src/linux</i>
# <i>cp .config_master .config</i>
</pre>

<p>
Ensuite, utilisez l'interface de configuration&nbsp;:
</p>

<pre caption="Modifier la configuration du noyau du nœud esclave">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Assurez-vous que les options suivantes sont sélectionnées pour une compilation
en dur dans le noyau et <e>PAS</e> comme module&nbsp;:
</p>

<pre caption="Options du noyau esclave">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers


Device Drivers ---&gt;
  [*] Networking support
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support (NEW)


File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
Configurer un serveur BOOTP est une alternative au serveur DHCP.
</note>

<impo>
Il est important de compiler votre adaptateur réseau dans le kernel des nœuds
(plutôt que d'en faire un module). En général, toutefois, l'utilisation de modules
pour les nœuds diskless n'est pas un problème.
</impo>

<p>
Compilons le noyau esclave. Vous devez prendre garde à ne pas
écraser les modules que vous avez construits pour le nœud maître.
Faites&nbsp;:
</p>

<pre caption="Compiler le noyau esclave">
# <i>cd /usr/src/linux</i>
# <i>make</i>
</pre>

<p>
Maintenant, créez le répertoire qui va accueillir le système de fichiers des
nœuds esclaves sur le maître et copiez-y le fichier <path>bzImage</path>. Nous
utilisons <path>/diskless</path>, mais vous pouvez utiliser un autre nom.
</p>

<note>
Si vous utilisez plusieurs architectures, vous voudrez peut-être sauvegarder
chaque fichier config sous le nom <path>.config_arch</path>. Faites de même
avec les images&nbsp;: sauvegardez chacune d'elles dans le répertoire
<path>/diskless</path> sous le nom <path>bzImage_arch</path>.
</note>

<pre caption="Copier le noyau esclave">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>

</body>
</section>

<section>
<title>Configuration d'un premier système de fichiers pour les nœuds esclaves</title>
<body>

<p>
Les systèmes de fichiers des nœuds maître et esclaves peuvent subir de
nombreuses adaptations. Concentrons-nous d'abord sur les fichiers de
configuration et les points de montage. Nous avons besoin d'un répertoire sous
<path>/diskless</path> pour le premier nœud esclave. Chaque esclave a besoin de
son propre système de fichiers racine (le «&nbsp;root&nbsp;») parce que
certains fichiers ne peuvent pas être communs à plusieurs machines sans causer
de graves problèmes. Peu importe les noms des sous-répertoires, vous pouvez,
par exemple, les nommer d'après les adresses IP, car elles sont uniques et
explicites. Dans cet exemple, l'adresse IP du premier nœud esclave est
<c>192.168.1.21</c>&nbsp;:
</p>

<pre caption="Créer le répertoire / du premier nœud esclave">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Certains fichiers de configuration de <path>/etc</path> doivent être modifiés
pour les esclaves. Copiez d'abord le répertoire <path>/etc</path> du maître
dans le nouveau répertoire destiné au nœud esclave&nbsp;:
</p>

<pre caption="Créer /etc pour l'esclave">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Le système de fichiers est encore incomplet, il lui manque différents
points de montage&nbsp;:
</p>

<pre caption="Créer les points de montage pour l'esclave">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/sys</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
<comment>(uniquement pour openMosix)</comment>
# <i>mkdir /diskless/192.168.1.21/mfs</i>
</pre>

<p>
La plupart de ces noms devraient vous être familiers. Les points tels que
<path>/dev</path>, <path>/sys</path> ou <path>/proc</path> seront utilisés au
démarrage de l'esclave, les autres seront montés un peu plus tard. Vous devez
également indiquer le nom de machine de l'esclave dans le fichier
<path>/diskless/192.168.1.21/etc/conf.d/hostname</path>. Les programmes,
bibliothèques et autres fichiers seront copiés au bon endroit plus loin dans ce
guide. En fait, ce sera juste avant de démarrer l'esclave.
</p>

<p>
Bien que les fichiers de périphériques de <path>/dev</path> soient créés par
<c>udev</c> plus loin, vous devez créer l'entrée <path>/dev/console</path>. Si
vous ne le faites pas, vous verrez l'erreur «&nbsp;unable to open initial
console&nbsp;»
</p>

<pre caption="Créer console dans /dev">
# <i>mknod /diskless/192.168.1.21/dev/console c 5 1</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configuration du serveur DHCP</title>

<section>
<title>À propos du serveur DHCP</title>
<body>

<p>
DHCP signifie «&nbsp;Dynamic Host Configuration Protocol&nbsp;». Le serveur DHCP
est le premier ordinateur contacté par les nœuds esclaves quand ils démarrent
par le système PXE via le réseau. La principale fonction d'un serveur DHCP est
d'attribuer des adresses IP. Un tel serveur peut attribuer des adresses en se
basant sur les adresses MAC des cartes réseau (N.D.T.&nbsp;: l'adresse MAC est
censée être unique pour chaque carte sur le marché et est attribuée par le
constructeur). Une fois l'adresse attribuée, le serveur DHCP indique au nœud
esclave où il peut obtenir son noyau et son système de fichiers intial.
</p>

</body>
</section>


<section>
<title>Avant de commencer</title>
<body>

<p>
Vous devez vérifier plusieurs choses avant de poursuivre.
D'abord, vérifions si votre connexion réseau fonctionne&nbsp;:
</p>

<pre caption="Vérifier la connexion réseau">
# <i>ifconfig eth0 multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Vous devez vérifier que vous avez un périphérique <e>eth0</e> qui fonctionne.
Vous devriez voir quelque chose comme ceci&nbsp;:
</p>

<pre caption="Un périphérique eth0 activé">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
L'option <e>MULTICAST</e> est essentielle. Si vous ne l'avez pas, vous devez
recompiler votre noyau avec cette option activée dans sa configuration.
</p>

</body>
</section>

<section>
<title>Installation du serveur DHCP</title>
<body>

<p>
Si votre réseau n'a pas encore de serveur DHCP, vous devez en installer un&nbsp;:
</p>

<pre caption="Installer un serveur DHCP">
# <i>emerge dhcp</i>
</pre>

<p>
Si un serveur DHCP est déjà installé sur votre réseau, vous devez modifier
sa configuration pour permettre un démarrage via PXE.
</p>

</body>
</section>

<section>
<title>Configuration du serveur DHCP</title>
<body>

<p>
Le serveur DHCP est configuré grâce au seul fichier
<path>/etc/dhcp/dhcpd.conf</path>. Le répertoire <path>/etc/dhcp</path>
devrait contenir un exemple que vous pouvez utiliser comme point de départ&nbsp;:
</p>

<pre caption="Editer le fichier de configuration du serveur DHCP">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
Le fichier de configuration est organisé et indenté comme ceci&nbsp;:
</p>

<pre caption="Exemple de dhcpd.conf">
<comment># Les options globales vont ici.</comment>

ddns-update-style none;
shared-network LOCAL-NET {

<comment># Les options partagées du réseau vont ici.</comment>

subnet 192.168.1.0 netmask 255.255.255.0 {

    <comment># Les options de sous-réseau vont ici.</comment>

    host slave{
        <comment># Les options spécifiques à l'hôte vont ici.</comment>
    }

    group {
        <comment># Les options spécifiques au groupe vont ici.</comment>
    }
}
}
</pre>

<p>
La mention <c>shared-network</c> est facultative et est réservée pour des
adresses IP que vous voulez attribuer aux nœuds qui font partie de votre réseau.
Vous devez avoir au moins une section <c>subnet</c> et la section facultative
<c>group</c> permet de définir des options communes aux nœuds spécifiés dans la
section <c>subnet</c>. Voici un exemple de <path>dhcpd.conf</path> complet&nbsp;:
</p>

<pre caption="Exemple de dhcpd.conf">
# Fichier de configuration DHCP pour DHCP ISC 3.0

ddns-update-style none;

# Définition des options spécifiques à PXE
# Code 1: Adresse IP à multidiffusion du serveur de fichiers de démarrage
# Code 2: Port UDP que le client devrait observer pour les réponses MTFTP.
# Code 3: Port UPD que les serveurs utilisent pour écouter les requêtes MTFTP.
# Code 4: Nombre de secondes pendant lesquelles un client doit écouter avant
#         d'essayer de débuter un nouveau transfet MTFTP.
# Code 5: Nombre de secondes pendant lesquelles un client doit écouter avant
#         de réinitier un transfert MTFTP.

option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;

subnet 192.168.1.0 netmask 255.255.255.0 {


  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    option vendor-class-identifier "PXEClient";
    vendor-option-space PXE;

    # Au moins une des options PXE spécifiques au vendeur doit être
    # paramétrée afin que les ROM du client de démarrage réalisent que
    # nous utilisons un serveur adhérant à PXE. L'adresse IP MCAST est réglée à
    # 0.0.0.0 afin de dire au ROM de démarrage que la multidiffusion TFTP n'est
    # pas supportée (l'adresse 0.0.0.0 signifie aucune adresse).

    option PXE.mtftp-ip 0.0.0.0;

    # Ceci est le nom du fichier que les ROM de démarrage doivent télécharger.
    filename "pxelinux.0";
    # Ceci est le nom du serveur à partir duquel ils doivent le télécharger.
    <comment># Utilisez l'adresse IP du maître</comment>
    next-server 192.168.1.1;
  }

  <comment># Si vous utilisez etherboot avec une image non spécifique.</comment>
  class "etherboot" {
        if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
        filename "/diskless/vmlinuz";
        }
  }

  pool {
    max-lease-time 86400;
    default-lease-time 86400;
    <comment># Ceci évite l'attribution d'une adresse à un client non listé.</comment>
    deny unknown-clients;
  }

  host slave21 {
       <comment># Utilisez l'adresse MAC de votre esclave.</comment>
       hardware ethernet                00:40:63:C2:CA:C9;
       <comment># Donnez à votre esclave une adresse IP fixe.</comment>
       fixed-address                    192.168.1.21;
       server-name                      "master";
       <comment># Si nécessaire, utilisez votre passerelle.</comment>
       option routers                   192.168.1.1;
       <comment># Si nécessaire, utilisez votre IP DNS.</comment>
       option domain-name-servers       192.168.1.1;
       option domain-name               "mydomain.com";
       <comment># Utilisez le nom d'hôte de l'esclave.</comment>
       option host-name                 "slave21";


       <comment># Etherboot et pxe démarrent avec une image mac spécifique.</comment>
       option root-path                 "/diskless/192.168.1.21";

       if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
                        filename "/vmlinuz_arch";
        } else if substring (option vendor-class-identifier, 0,9) ="PXEClient" {
                        filename "/pxelinux.0";
        }

  }
}
</pre>

<note>
Rien n'empêche d'utiliser PXE boot et Etherboot ensemble. L'exemple ci-dessus
est un <e>exemple</e>&nbsp; en cas de problème, veuillez consulter la
documentation de DHCPd.
</note>

<p>
L'option <c>next-server</c> indique l'adresse IP de la machine à laquelle le
nœud esclave doit demander le fichier <c>filename</c> après avoir reçu son
adresse IP. Cette adresse est l'adresse du serveur TFTP, généralement la même
que celle du nœud maître. Le nom du fichier spécifié dans l'option
<c>filename</c> est relatif au répertoire <path>/diskless</path> si votre
serveur tftp est configuré comme indiqué plus loin dans ce guide. La section
<c>host</c> contient l'adresse matérielle (la «&nbsp;MAC address&nbsp;») de
votre carte réseau et l'option <c>fixed-address</c> permet d'y associer
l'adresse IP spécifiée. Il est judicieux d'indiquer le nom du nœud dans
l'option <c>host-name</c>. L'ensemble des options du fichier
<path>dhcpd.conf</path> n'ont pas leur place dans ce guide, mais sont
évidemment disponibles dans les pages man.
</p>

<pre caption="Consulter la page man de dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>

<section>
<title>Activer le serveur DHCP</title>
<body>

<p>
Avant de lancer le script d'initialisation de DHCP, vous devez
modifier le fichier <path>/etc/conf.d/dhcp</path> pour
qu'il ressemble à ceci&nbsp;:
</p>

<pre caption="Exemple de /etc/conf.d/dhcp">
IFACE="eth0"
<comment># insert any other options needed</comment>
</pre>

<p>
La variable <c>IFACE</c> indique le péripherique réseau sur lequel
sont connectés les nœuds esclaves. Dans notre cas, c'est <c>eth0</c>.
Il peut être intéressant d'ajouter des valeurs à <c>IFACE</c> si le serveur
est équipé de plusieurs cartes réseau. Pour démarrer le serveur DHCP, faites&nbsp;:
</p>

<pre caption="Démarrage du serveur DHCP sur le nœud maître">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Pour faire démarrer le serveur DHCP automatiquement par votre machine, faites&nbsp;:
</p>

<pre caption="Ajout du serveur DHCP dans la procédure de démarrage de la machine">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>

<section>
<title>Problèmes avec le serveur DHCP</title>
<body>

<p>
Quand un nœud esclave démarre, vous devriez voir des messages semblables dans
le fichier <path>/var/log/messages</path> sur le maître&nbsp;:
</p>

<pre caption="Exemple de messages de DHCP">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
Ce fichier peut aussi vous aider à trouver les adresses MAC des nœuds esclaves.
</note>

<p>
Si vous voyez le message ci-dessous, cela indique que le serveur DHCP
émet bien sur le réseau, mais qu'il y a une erreur dans le fichier
de configuration.
</p>

<pre caption="Exemple d'erreur DHCP">
no free leases on subnet LOCAL-NET
</pre>

<p>
Chaque fois que vous modifiez le fichier de configuration,
vous devez relancer le server DHCP comme ceci&nbsp;:
</p>

<pre caption="Relancer le serveur DHCP sur le maître">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configuration du serveur TFTP et du démarrage via PXE et/ou de Etherboot</title>
<section>
<title>À propos du serveur TFTP</title>
<body>

<p>
TFTP signifie «&nbsp;Trivial File Transfer Protocol&nbsp;». Le serveur TFTP va
fournir un noyau et un système de fichiers aux nœuds esclaves. Tous les noyaux
des esclaves et leur système de fichiers seront stockés sur le serveur TFTP.
Il est donc recommandé de l'installer sur le nœud maître.
</p>

</body>
</section>
<section>
<title>Installation du serveur TFTP</title>
<body>

<p>
Un serveur tftp reconnu est celui compris dans le paquet tftp-hpa.
Il se trouve qu'il a été écrit par le même auteur que SYSLINUX et ils
fonctionnent très bien ensemble. Faites&nbsp;:
</p>

<pre caption="Installer le serveur tfp">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>

<section>
<title>Configuration du serveur TFTP</title>
<body>

<p>
Modifiez le fichier <path>/etc/conf.d/in.tftpd</path>.
Vous devez y indiquer le répertoire principal servi par le serveur
TFTP dans l'option <c>INTFTPD_PATH</c>. Les éventuelles options de la ligne
de commande utilisée pour lancer le serveur viennent après <c>INTFTPD_OPTS</c>.
Votre fichier devrait ressembler à ceci&nbsp;:
</p>

<pre caption="Exemple de /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
L'option -l indique que le serveur doit écouter lui-même sur le réseau, ce qui
vous évite d'utiliser inetd. L'option -v demande au serveur de fournir plus de
messages dans son journal. L'option -s spécifie le répertoire racine du
serveur.
</p>

</body>
</section>

<section>
<title>Activer le serveur TFTP</title>
<body>

<p>
Pour lancer le serveur TFTP, faites&nbsp;:
</p>

<pre caption="Lancer le serveur ttfp sur le maître">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Ce script va lancer le serveur tftp avec les options spécifiées dans
le fichier <path>/etc/conf.d/in.tftpd</path>. Si voulez que le serveur TFTP
soit lancé au démarrage de votre machine, faites&nbsp;:
</p>

<pre caption="Lancer le serveur tftp au démarrage du nœud maître">
# <i>rc-update add in.tftpd default</i>
</pre>

</body>
</section>
<section>
<title>À propos de PXELINUX</title>
<body>

<p>
Cette partie ne vous intéresse pas si vous utilisez Etherboot. PXELINUX est
l'équivalent réseau de LILO ou de GRUB, il est envoyé par le serveur TFTP. Il
s'agit en fait d'un petit bout de code qui indique au client où trouver son
noyau et son système de fichiers initial et qui permet de passer quelques
options au noyau.
</p>

</body>
</section>

<section>
<title>Avant de commencer</title>
<body>

<p>
Vous avez besoin du fichier <path>pxelinux.0</path> fourni avec le paquet
SYSLINUX de H. Peter Anvin. Vous pouvez l'installer comme ceci&nbsp;:
</p>

<pre caption="Installer syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>

<section>
<title>Configuration de PXELINUX</title>
<body>

<note>
Ceci n'est pas nécessaire si vous utilisez Etherboot.
</note>

<p>
Avant de démarrer votre serveur TFTP, vous devez installer pxelinux.
Copiez le binaire de pxelinux dans <path>/diskless</path> comme ceci&nbsp;:
</p>

<pre caption="Installer le démarreur à distance">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Cela va créer un fichier de configuration par défaut pour syslinux. Le binaire
<path>pxelinux.0</path> cherche son fichier de configuration dans le répertoire
<path>pxelinux.cfg</path>. Il commence par chercher un fichier dont le nom est
l'adresse IP attribuée au nœud écrite en hexadécimal. Si un tel fichier
n'existe pas, <path>pxelinux.0</path> enlève successivement le chiffre le plus
à droite et regarde si un fichier correspondant existe jusqu'à ce qu'il trouve
un fichier ou qu'il n'y ait plus de chiffre. Les version 2.05 et ultérieures de
syslinux recherchent d'abord un fichier nommé d'après l'adresse MAC. Si ce
fichier n'existe pas, la routine de recherche présentée ci-haut est effectuée.
En dernier recours, le fichier <path>default</path> est utilisé.
</p>

<pre caption="Recherche du fichier de configuration dans pxelinux.cfg/">
<comment>Le préfixe 01 indique le type ethernet. Les bits suivants correspondent à l'adresse MAC du nœud.</comment>
01-00-40-63-c2-ca-c9

<comment>(Adresse IP assignée, en hexadécimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C

default
</pre>

<note>
Tous les fichiers utilisent seulement des lettres minuscules.
</note>

<p>
Utilisons simplement un fichier <path>default</path>&nbsp;:
</p>

<pre caption="Exemple de pxelinux.cfg/default">
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
L'option <c>DEFAULT</c> indique le chemin vers le noyau.
L'option <c>APPEND</c> fournit les paramètres à passer au noyau. Puisque nous
avons compilé le noyau avec l'option <c>NFS_ROOT_SUPPORT</c>, nous indiquons ici
le chemin vers notre système de fichiers racine (le «&nbsp;root&nbsp;» via NFS).
La première adresse IP est l'adresse du nœud maître et la seconde est le
nom du répertoire que nous avons créé dans <path>/diskless</path> et qui contient
le système de fichiers de l'esclave.
</p>

</body>
</section>
<section>
<title>À propos de Etherboot</title>
<body>

<note>
Ceci ne vous intéresse pas si vous utilisez le démarrage via PXE.
</note>

<p>
Le système Etherboot permet de démarrer à partir d'images stockées sur un
serveur TFTP. Comme PXE, ceci est similaire à LILO ou GRUB. L'utilitaire
<c>mknbi</c> permet de créer différentes images avec des options différentes.
</p>

</body>
</section>
<section>
<title>Avant de commencer</title>
<body>

<p>
Vous devez d'abord installer l'utilitaire <c>mknbi</c> qui permet de marquer
des images de noyaux qui seront démarrés via le système Etherboot. Cet outil
créera une image de votre noyau orinal et la configurera comme décrit
ci-dessous.
</p>

<pre caption="Installer mknbi">
# <i>emerge mknbi</i>
</pre>

</body>
</section>
<section>
<title>Configurer Etherboot</title>
<body>

<p>
Voyons comment configurer une simple image qui permet de démarrer via
Etherboot. Comme le serveur DHCP définit la racine utilisée par les clients
dans l'option «&nbsp;option root-path&nbsp;» dans le fichier
<path>dhcp.conf</path>, il n'est pas nécessaire de la spécifier ici. Veuillez
consulter la page man de mknbi pour plus d'informations.
</p>

<pre caption="Afficher la page man de mknbi">
# <i>man mknbi</i>
</pre>

<p>
Pour créer une image ELF démarrable qui sait passer les paramètres DHCP et la
racine à utiliser au noyau tout en forçant le noyau à demander une adresse IP
via DHCP, faites&nbsp;:
</p>

<pre caption="Créer une image Etherboot">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Pour une architecture spécifique, utilisez <c>bzImage_arch</c> et
<c>vmlinuz_arch</c>.
</note>

</body>
</section>
<section>
<title>Problèmes lors du démarrage via le réseau</title>
<body>

<p>
Il y a plusieurs façons de résoudre les problèmes de démarrage via le réseau.
Un outil fréquemment utilisé est <c>tcpdump</c>.
Pour l'installer, faites&nbsp;:
</p>

<pre caption="Installer tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Maintenant, vous pouvez surveiller le trafic réseau et vous assurer que votre
serveur et les clients se parlent. En cas de problèmes, vous devriez d'abord
vérifier que vos machines sont physiquement connectées et que les câbles ne
sont pas endommagés. Vous devriez aussi vous assurer que le trafic n'est pas
bloqué par un pare-feu. Pour visualiser le dialogue entre deux ordinateurs,
faites&nbsp;:
</p>

<pre caption="Visualiser le dialogue entre deux ordinateurs avec tcpdump">
# <i>tcpdump host </i><comment>ip_client</comment><i> and </i><comment>ip_server</comment>
</pre>

<p>
Vous pouvez aussi surveiller un port particulier, celui du serveur tftp par exemple&nbsp;:
</p>

<pre caption="Surveiller le port du serveur tftp">
# <i>tcpdump port 69</i>
</pre>

<p>
Une erreur fréquente est «&nbsp;PXE-E32: TFTP open time-out&nbsp;».
Elle est généralement causée par un pare-feu.
Si vous utilisez <c>TCPwrappers</c>, vous devriez aussi vérifier que
les fichiers <path>/etc/hosts.allow</path> et <path>etc/hosts.deny</path>
sont correctement configurés. Les nœuds esclaves doivent avoir accès
au maître.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configuration du serveur NFS</title>
<section>
<title>À propos du serveur NFS</title>
<body>

<p>
NFS signifie «&nbsp;Network File System&nbsp;». Un serveur NFS fournit un
système de fichiers via le réseau. Cette partie peut être reconfigurée plus
tard, mais nous voulons d'abord un système de base permettant au nœud esclave de
démarrer.
</p>

</body>
</section>
<section>
<title>À propos de portmap</title>
<body>

<p>
Certains services ne sont pas toujours liés au même port, mais utilisent le
système d'appel de fonction à distance (les RPC en anglais pour «&nbsp;Remote
Procedure Call&nbsp;»). Dans ce cas, lorsqu'un service démarre, il écoute sur
un port disponible choisi au hasard et il s'inscrit dans la liste de tels
services tenue par le programme portmap. NFS utilise ce mécanisme et a besoin
que le programme portmap soit actif avant de démarrer.
</p>

</body>
</section>

<section>
<title>Avant de commencer</title>
<body>

<p>
Pour pouvoir activer le serveur NFS, vous devez avoir compilé le noyau avec
les options adéquates. Pour vérifier que cela a bien été fait, tapez&nbsp;:
</p>

<pre caption="Afficher les options NFS dans la configuration du noyau">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
L'affichage devrait ressembler à ceci&nbsp;:
</p>

<pre caption="Configuration NFS correcte du noyau maître">
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>

</body>
</section>

<section>
<title>Installation du serveur NFS</title>
<body>

<p>
Le paquet NFS est installé via Portage comme ceci&nbsp;:
</p>

<pre caption="Installer nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Ce paquet comprend le programme portmap, le serveur nfs et les utilitaires
pour les clients NFS. Les dépendances lors de l'initialisation sont correctement
résolues.
</p>

</body>
</section>

<section>
<title>Configuration du serveur NFS</title>
<body>

<p>
Il y a trois fichiers principaux à modifier&nbsp;:
</p>

<pre caption="Les fichiers de configuration relatifs à NFS">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
Le fichier <path>/etc/exports</path> indique comment, à qui et quels
répertoires sont disponibles pour les clients NFS.
Le fichier <path>/etc/fstab</path> des nœuds esclaves sera modifié
pour monter les répertoires exportés par le maître.
</p>

<p>
Le fichier <path>/etc/exports</path> du maître devrait ressembler à ceci&nbsp;:
</p>

<pre caption="Exemple de /etc/exports sur le maître">
<comment># Une ligne comme celle-ci par esclave.</comment>
/diskless/192.168.1.21   192.168.1.21(rw,no_root_squash,no_all_squash)
<comment># Valable pour tous les esclaves.</comment>
/opt   192.168.1.0/24(ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(rw,no_root_squash,no_all_squash)
<comment># Si vous voulez un journal commun à tous les nœuds.</comment>
/var/log   192.168.1.21(rw,no_root_squash,no_all_squash)
</pre>

<p>
Le premier champ indique le nom du répertoire à exporter et le suivant
spécifie qui peut l'utiliser et comment.
Le «&nbsp;qui&nbsp;» indique quel nœud peut monter ce répertoire via le réseau
et le «&nbsp;comment&nbsp;» liste ce que le nœud peut faire.
L'option <c>ro</c> interdit l'écriture (=read-only) et <c>rw</c>
l'autorise. Les options <c>no_root_squash</c> et <c>no_all_squash</c>
sont importantes dans le cas de machines sans disque&nbsp;: elles permettent
de préserver les identifiants (uid/gid) des clients.
</p>
<p>
Le fichier fstab <path>/diskless/192.168.1.21/etc/fstab</path> du nœud
esclave devrait ressembler à ceci&nbsp;:
</p>

<pre caption="Exemple de /etc/fstab du nœud esclave">
<comment># Ces lignes sont essentielles.</comment>
master:/diskless/192.168.1.21  /         nfs   sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                    /opt      nfs   sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                    /usr      nfs   sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                   /home     nfs   sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                           /proc     proc  defaults                                          0 0
<comment># Utile, mais facultatif.</comment>
master:/var/log                /var/log  nfs   sync,hard,intr,rw                                 0 0
<comment>(Uniquement pour des clusters openMosix.)</comment>
none                           /mfs      mfs   dfsa=1                                            0 0
</pre>

<p>
Dans cet exemple, <e>master</e> est le nom du nœud maître, mais il pourrait
être remplacé par son adresse IP. Le premier champ indique l'endroit du
répertoire à monter et le deuxième spécifie le point de montage sur le nœud
esclave. Le troisième champ indique le type de système de fichiers (NFS dans
notre cas). Le quatrième champ donne des indications au processus de montage
des répertoires (voir mount(1) pour plus d'infos). Certains ont rencontré des
problèmes avec l'option soft et nous avons donc opté pour des points montés
avec l'option hard. vous devriez consulter la documentation relative aux
options de <path>/etc/fstab</path>.
</p>

<p>
Le dernier fichier à modifier est <path>/etc/conf.d/nfs</path>.
Il décrit les options de démarrage du serveur NFS. Il devrait
ressembler à ceci&nbsp;:
</p>

<pre caption="Exemple de /etc/init.d/nfs sur le maître">
# Config file for /etc/init.d/nfs

# Number of servers to be started up by default
RPCNFSDCOUNT=8

# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Vous devriez indiquer le nombre de machines sans disque de votre réseau
sur l'option <c>RPCNFSDCOUNT</c>.
</p>

</body>
</section>
<section>
<title>Activer le serveur NFS</title>
<body>

<p>
Vous pouvez lancer le serveur NFS grâce au script situé dans <path>/etc/init.d</path>
comme ceci&nbsp;:
</p>

<pre caption="Lancer le serveur NFS sur le maître">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Si vous voulez ajouter ce script au processus de démarrage du maître,
faites&nbsp;:
</p>

<pre caption="Lancer le serveur NFS au démarrage du nœud maître">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Finaliser le système de fichiers du nœud esclave</title>
<section>
<title>Copier les fichiers nécessaires</title>
<body>

<p>
Vous devez copier des fichiers du nœud maître dans le système de fichiers du
nœud esclave. Faites ceci&nbsp;:
</p>

<pre caption="Créer le système de fichiers esclave">
# <i>rsync -avz /bin  /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib  /diskless/192.168.1.21</i>
</pre>

<note>
L'utilisation de rsync -avz permet de copier les liens symboliques et les
permissions de fichiers.
</note>

</body>
</section>
<section>
<title>Scripts d'initialisation</title>
<body>

<p>
Les scripts d'initialisation exécutent <e>checkroot</e>, ce qui n'a aucun sens
sur une machine diskless. La solution difficile est de modifier le script
<path>/diskless/192.168.1.21/sbin/rc</path>, mais cela est risqué et pourrait
vous poser des problèmes si vous faites une mise à jour des fichiers de votre
nœud esclave et que vous oubliez de ne pas toucher à ce fichier. L'astuce
consiste à créer un fichier <path>/fastboot</path> au démarrage. Ce fichier
indique à <e>checkroot</e> de ne pas lancer la vérification du système de
fichiers. Cependant, le fichier <path>/fastboot</path> est supprimé
automatiquement par les scripts d'initialisation. C'est pourquoi il faut
recréer ce fichier à la fin du processus de démarrage.
</p>

<pre caption="Empêcher les scripts d'init de vérifier le système de fichiers">
<comment>(Créer le fichier /fastboot pour le prochain démarrage)</comment>
# <i>touch /diskless/192.168.1.21/fastboot</i>
<comment>(Créer le fichier /fastboot à chaque démarrage)</comment>
# <i>echo "touch /fastboot" &gt;&gt; /diskless/192.168.1.21/etc/conf.d/local.start</i>
</pre>

<p>
Puisque les systèmes de fichiers montés via le réseau doivent être démontés le
plus tard possible, vous devez éditer le script
<path>/etc/init.d/netmount</path> comme ceci&nbsp;:
</p>

<pre caption="Modifier /etc/init.d/netmount">
depend() {
    <i>before *</i>
</pre>

<note>
Cela n'est plus nécessaire à partir des versions 1.11.* de baselayout.
</note>

<p>
Si vous faites ces modifications sur un système en cours d'utilisation,
n'oubliez pas de lancer la commande <c>depscan.sh</c> pour redéfinir les
dépendances entre les services. Vous pouvez ignorer l'avertissement à propos du
conflit avec <path>/etc/init.d/checkroot</path> puisque vous avez désactivé ce
dernier avec le fichier <path>/fastboot</path>.
</p>

<p>
Vous pouvez avoir autant de scripts liés dans le sous-répertoire
<path>/diskless/192.168.1.21/etc/runlevels</path> que de services à lancer sur
votre nœud esclave. Cela ne dépend que de ce que vous voulez que vos esclaves
fassent.
</p>

<warn>
N'utilisez pas <c>rc-update</c> pour ajouter ou enlever des scripts
d'initialisation sur vos esclaves en étant connecté sur le maître, car cela
modifierait les niveaux d'exécution du maître. Vous devez créer les liens
symboliques manuellement ou vous connecter au nœud esclave via ssh ou un
clavier et un écran attachés à l'esclave.
</warn>

<pre caption="Exemple de niveaux d'exécution d'un esclave">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single

/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom

/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron

/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local

/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
C'est le moment de démarrer votre nœud esclave et de croiser les doigts.
Ça marche&nbsp;?
Bravo, vous disposez maintenant d'un PC sans disque fonctionnel.
</p>


</body>
</section>
</chapter>

</guide>
