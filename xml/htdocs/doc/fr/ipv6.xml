<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "../../dtd/guide.dtd">

<!-- The contents of this document are licensed under the
     Creative Commons - Attribution / Share Alike license.

     Please see http://creativecommons.org/licenses/by-sa/1.0
     for details.
-->

<guide link="/doc/fr/ipv6.xml">
<title>Guide Gentoo du routeur IPv6</title>
<author title="Développeur">
    <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Correcteur">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Correcteur, relecteur">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Traducteur">
    <mail link="cam@cameuh.net">Camille Huot</mail>
</author>
<license/>
<abstract>
Ce guide explique comment installer IPv6 sur un système Gentoo. Nous verrons 
notamment comment établir une liaison avec une passerelle IPv6 externe, paramétrer un DNS simple et
configurer les clients pour accéder au réseau IPv6.
</abstract>

<version>1.0.1</version>
<date>30 septembre 2003</date>

<chapter>

<title>Configuration du noyau</title>

<section>
<title>Configuration proprement dite</title>
<body>
<p>
N'importe quel noyau de la série 2.4 fourni dans Gentoo supportera IPv6 sans
problème. Cependant, <c>sys-kernel/gentoo-sources</c> et 
<c>sys-kernel/pfeifer-sources</c> disposent des patchs USAGI. Cet ensemble 
de patchs USAGI ne sont pas obligatoires, mais ils complètent largement
la couche IPv6 du noyau de base. Pour utiliser les patchs USAGI, mettez juste
le mot-clé 'usagi' dans la variable USE avant d'emerger l'un de ces deux 
paquets. La branche 2.5.x de développement du noyau a également un excellent
support d'IPv6 et intègre un bon nombre du code USAGI.
</p>

<pre caption="Emerger un noyau">
# <i>USE="usagi" emerge gentoo-sources</i>
<comment>ou bien</comment>
# <i>USE="usagi" emerge pfeifer-sources</i>
</pre>

<p>
Nous pouvons à présent nous placer dans le répertoire des sources du noyau
et commencer notre configuration du noyau.
</p>

<pre caption="Configurer le noyau Linux">
# <i>cd /usr/src/linux/</i>
# <i>make menuconfig</i>
</pre>

<note>
Vérifiez bien que le lien symbolique <path>/usr/src/linux</path> pointe vers
le répertoire contenant les sources que vous allez utiliser.
</note>

<note>
Pour activer la configuration IPv6, vous devez activer <path>Prompt for 
development and/or incomplete code/drivers</path> au début de la 
configuration du noyau.
</note>

<pre caption="Les options à activer">
Networking options ---&gt;
   &lt;*&gt; IP: tunneling
   ...
   &lt;*&gt; The IPv6 protocol (EXPERIMENTAL) ---&gt;

<codenote>Les options dans le sous-menu IPv6 peuvent être utiles pour certaines applications,</codenote>
<codenote>mais ne sont pas requises pour une configuration de base</codenote>

Network device support ---&gt;
   &lt;*&gt; Universal TUN/TAP device driver support
<codenote>Cette option est seulement requise si vous utilisez ptrtd pour connecter</codenote>
<codenote>votre réseau IPv6 à un réseau externe IPv4</codenote>
</pre>

</body>
</section>

<section>
<title>Test du support IPv6</title>
<body>

<p>
Après avoir activé les options requises, recompilez les sources et redémarrez
le système avec votre nouveau noyau IPv6. Si tout est correct, vous devriez déjà voir une 
adresse IPv6 pour l'adresse de loopback.
</p>

<pre caption="Vérification de l'interface loopback">
# <i>ifconfig lo</i>
lo    Link encap:Local Loopback 
      inet addr:127.0.0.1  Mask:255.0.0.0 
      inet6 addr: ::1/128 Scope:Host
      <codenote>Cette ligne montre que ça marche correctement</codenote>
      UP LOOPBACK RUNNING  MTU:16436  Metric:1
      RX packets:6 errors:0 dropped:0 overruns:0 frame:0
      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
      collisions:0 txqueuelen:0
      RX bytes:456 (456.0 b)  TX bytes:456 (456.0 b)
</pre>
<p>
Avant de continuer, soyez sûr d'avoir ajouté "ipv6" à votre liste de 
variables USE dans le make.conf, afin que les prochains paquets puissent
bénéficier du support IPv6 à l'avenir.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Configuration du tunnel</title>

<section>
<title>Configuration de base</title>
<body>

<p>
La majeure partie des fournisseurs d'accès à Internet ne proposent pas
encore de connexion IPv6 native (Ndt: à ma connaissance seul 
<uri link="http://www.nerim.fr/">Nerim</uri>
propose ce service en France). Pour outrepasser cette limitation, 
plusieurs passerelles IPv6 (Ndt: communément appelées "tunnel broker")
ont vu le jour et proposent des connexions gratuites au réseau IPv6
via un tunnel. Cela vous permettra d'encapsuler toutes vos connexions
IPv6 dans une connexion IPv4 classique vers la passerelle.
</p>

<table>
<tr><th>Passerelle IPv6</th><th>Location</th></tr>
<tr><ti><uri link="http://tunnelbroker.net">Hurricane Electric</uri></ti><ti>US/Canada</ti></tr>
<tr><ti><uri link="http://www.freenet6.net">Freenet6</uri></ti><ti>US</ti></tr>
<tr><ti><uri link="http://ipng.org.uk">IPnG</uri></ti><ti>UK</ti></tr>
<tr><ti><uri link="http://tb.ipv6.btexact.com">BTExact</uri></ti><ti>Europe</ti></tr>
</table>

<p>
Voici deux exemples de configurations pour mettre en place un tunnel 
avec deux fournisseurs populaires nord-américains, Hurricane Electric
et Freenet6.
</p>
</body>
</section>

<section>
<title>Hurricane Electric</title>
<body>

<p>
Hurricane Electric (HE pour abréger) offre gratuitement des tunnels
vers IPv6 et vous alloue un bloc d'adresses /64 dédiées. Il vous
permet également de configurer vos reverse DNS. Pour obtenir un tunnel
chez HE, il vous suffit d'aller sur <uri>http://www.tunnelbroker.net</uri>
et de remplir un formulaire d'une page.
</p>

<note>
L'inscription au service vous demandera des informations telles que votre
adresse et numéro de téléphone.
</note>

<warn>
Afin de limiter les abus, HE a volontairement
instauré un délai de 24 heures avant d'activer le tunnel.
</warn>

<p>
Une fois votre demande de tunnel acceptée et votre bloc /64 alloué, vous
pouvez passer à la configuration de votre Gentoo. HE fournit des exemples
de configurations basées sur les outils <c>ifconfig</c> et <c>iproute</c>. Les exemples
suivants supposent que vous utilisiez la configuration suivante:
</p>

<table>
<tr><ti>Adresse IPv4 locale</ti><ti>68.36.91.195</ti></tr>
<tr><ti>Adresse IPv4 de HE</ti><ti>64.71.128.82</ti></tr>
<tr><ti>Adresse IPv6 locale du tunnel</ti><ti>2001:470:1F00:FFFF::189</ti></tr>
<tr><ti>Bloc IPv6 alloué par HE</ti><ti>2001:470:1F00:296::/64</ti></tr>
</table>

<p>
En utilisant les net-tools et <c>ifconfig</c>:
</p>

<pre caption="Configuration avec ifconfig">
# <i>ifconfig sit0 up</i>
# <i>ifconfig sit0 inet6 tunnel ::64.71.128.82 </i>
<codenote>Ajoute un tunnel vers l'adresse IPv4 de HE</codenote>
# <i>ifconfig sit1 up</i>
# <i>ifconfig sit1 inet6 add 2001:470:1F00:FFFF::189/127</i>
# <i>route -A inet6 add ::/0 dev sit1</i>
<codenote>Route tout le trafic IPv6 vers l'interface 'sit1'</codenote>
</pre>

<p>
En utilisant le paquet iproute et la commande <c>ip</c>:
</p>

<pre caption="Configuration avec ip">
# <i>ip tunnel add sixbone mode sit remote 64.71.128.82 local 68.36.91.195 ttl 255</i>
<codenote>Crée un tunnel entre l'adresse IPv4 locale et l'adresse distante IPv4 de HE</codenote>
# <i>ip link set sixbone up</i>
# <i>ip addr add 2001:470:1F00:FFFF::189/127 dev sixbone</i>
<codenote>Active le tunnel et lui assigne son adresse IPv6</codenote>
# <i>ip route add ::/0 dev sixbone</i>
<codenote>Route tout le trafic IPv6 vers notre interface 'sixbone'</codenote>
</pre>

</body>
</section>

<section>
<title>Freenet6</title>
<body>

<p>
<uri link="www.freenet6.net">Freenet6</uri> est un autre fournisseur 
gratuit à l'IPv6. L'enregistrement ne demande qu'un nom 
d'utilisateur et une adresse email valide. Ils ont choisi de confier
la configuration du tunnel à une application client/serveur et ont créé
le client <c>tscp</c>. Le client est disponible dans Portage, pour 
l'installer :
</p>

<pre>
# <i>emerge freenet6</i>
</pre>

<p>
Vous devez maintenant configurer freenet6 en éditant 
<path>/etc/freenet6/tspc.conf</path> et en modifiant les champs 
<path>userid</path> et <path>passwd</path>. Voici un exemple:
</p>

<pre caption="Exemple de tscp.conf">
tsp_version=1.0.1
tsp_dir=/etc/freenet6
auth_method=any
client_v4=auto
<i>userid=anonymous</i>
<i>passwd=foobar</i>
template=gentoo
server=tsps1.freenet6.net
retry_delay=0
if_tunnel=sit3
</pre>

</body>
</section>

<section>
<title>Testons la connexion</title>
<body>

<p>
Maintenant que le tunnel est configuré, vous pouvez tester votre 
connexion. La méthode la plus simple et rapide est d'utiliser l'utilitaire
<c>ping6</c> et d'essayer d'atteindre un hôte IPv6.
</p>

<pre caption="Test de la connexion">
# <i>emerge iputils</i>
# <i>ping6 www.kame.net</i>
PING www.kame.net(orange.kame.net) 56 data bytes
64 bytes from orange.kame.net: icmp_seq=1 ttl=52 time=290 ms
64 bytes from orange.kame.net: icmp_seq=2 ttl=52 time=277 ms
64 bytes from orange.kame.net: icmp_seq=3 ttl=52 time=280 ms
64 bytes from orange.kame.net: icmp_seq=4 ttl=52 time=279 ms
64 bytes from orange.kame.net: icmp_seq=5 ttl=52 time=277 ms

--- www.kame.net ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4038ms
rtt min/avg/max/mdev = 277.040/281.041/290.046/4.699 ms
</pre>

<p>
L'équipe Gentoo travaille dur pour améliorer le support IPv6 dans
les scripts d'initialisation du réseau. Si vous êtes intéressé ou bien 
voulez participer, envoyez un mail à 
<mail link="latexer@gentoo.org">latexer@gentoo.org</mail> (Ndt: 
en anglais!).
</p>

</body>
</section>

</chapter>
<chapter>

<title>IPv6 dans les applications</title>

<section>
<title>Re-emerger les paquets</title>
<body>

<p>
À moins que vous ayez déjà USE="ipv6" dans votre 
<path>/etc/make.conf</path>, vous devrez probablement re-emerger pas mal
de paquets pour leur faire activer le support IPv6. Pour avoir une liste
des paquets installés qui pourraient utiliser ce mot-clé, faites:
</p>

<pre caption="Les candidats à la ré-installation">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | cut -d' ' -f1</i>
</pre>

<p>
Pour facilement re-emerger uniquement les paquets désirés, faites-en la
liste:
</p>

<pre caption="Les candidats à la ré-installation">
# <i>emerge -epv world | grep ipv6 | sed "s:^.*\] ::; s:-[0-9]\+.*::" | \</i>
&gt; <i>cut -d' ' -f1 > packages</i>
</pre>

<p>
Puis editez le fichier <path>packages</path> pour enlever les paquets
que vous ne souhaitez pas recompiler de suite.
</p>

<p>
Enfin, lancez simplement:
</p>

<pre>
# <i>emerge `cat packages`</i>
</pre>

</body>
</section>

<section>
<title>Paquets spécifiques à IPv6</title>
<body>

<p>
Il y a quelques paquets dédiés spécifiquement à l'IPv6, la plupart se
trouvent dans <path>/usr/portage/net-misc</path>.
</p>

<table>
<tr><th>Paquet</th><th>Description</th></tr>
<tr><ti>net-misc/ipv6calc</ti><ti>Transforme une adresse IPv6 au format compressé</ti></tr>
<tr><ti>net-misc/nc6</ti><ti>Version de netcat qui supporte IPv6 et IPv4</ti></tr>
<tr><ti>dev-perl/Socket6</ti><ti>Partie IPv6 du fichier C socket.h contenant les définitions et les structures</ti></tr>
</table>
</body>
</section>

</chapter>
<chapter>

<title>Mise en place du DNS</title>

<section>
<title>IPv6 et DNS</title>
<body>

<p>
Vous savez peut-être que le DNS utilise un enregistrement de type
A pour IPv4. Et bien sachez qu'il utilise un enregistrement de type
AAAA pour IPv6. (C'est parce qu'une
adresse IPv4 utilise un mot de 32 bits d'espace alors qu'une adresse IPv6
utilise 4 mots de 32 bits, soit 128 bits.) Pour le reverse DNS, le 
standard INT est le plus supporté. ARPA est le format standard actuel
mais il n'est pas aussi répandu que INT. Ce guide décrira le format INT.
</p>

</body>
</section>

<section>
<title>Configuration de BIND</title>
<body>

<p>
Les versions récentes de BIND incluent un excellent support d'IPv6.
Cette section suppose que vous ayez un minimum de connaissances de la 
configuration et de l'utilisation de BIND. Nous supposerons également
que vous ne fassiez pas tourner BIND dans un environnement chrooté. Si
c'est le cas, ajoutez le préfixe du chroot à la plupart des chemins de
cette section.
</p>

<p>
Premièrement, vous devez ajouter des entrées pour les zones directes et
inverses (Ndt: "forward and reverse DNS") dans le fichier 
<path>/etc/bind/named.conf</path>.
</p>

<pre caption="Entrées à ajouter dans named.conf">
zone "ipv6-rules.com" IN {
	type master;
	file "pri/ipv6-rules.com";
};
<codenote>Déclare le domaine 'ipv6-rules.com' dans le DNS</codenote>

zone "6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int" {
	type master;
	file "pri/rev-ipv6-rules.com.int";
};
<codenote>Déclare le préfixe 2001:470:1f00:296/64 dans le DNS,</codenote>
<codenote>on obtient ce nom de zone en prenant chaque chiffre du</codenote>
<codenote>préfixe dans l'ordre inverse, en les séparant par un point</codenote>
</pre>

<p>
Maintenant, créons les fichiers de zones spécifiés, et ajoutons des entrées
pour nos machines:
</p>

<pre caption="pri/ipv6-rules.com">
$TTL    2h
@       IN      SOA     ipv6-rules.com. webmaster.ipv6-rules.com.  (
                                2003052501 ; Serial
				28800      ; Refresh
				14400      ; Retry
				3600000    ; Expire
				86400 )    ; Minimum
			NS      ns1.ipv6-rules.com

	IN	AAAA	2001:470:1f00:296::1 ; adresse de ipv6-rules.com
host1	IN	AAAA	2001:470:1f00:296::2 ; adresse de host1.ipv6-rules.com
host2	IN	AAAA	2001:470:1f00:296::3:3 ; adresse de host2.ipv6-rules.com
</pre>

<pre caption="pri/rev-ipv6-rules.com.int">
$TTL 3d ; Le TTL par défaut (obligatoire pour bind 8, bind 9 l'ignore)
@       IN SOA ipv6-rules.com. webmaster.ipv6-rules.com. (
                        2003052501      ; Serial number (YYYYMMdd)
			24h             ; Refresh time
			30m             ; Retry time
			2d              ; Expire time
			3d )            ; Default TTL
	IN      NS     ns1.ipv6-rules.com.
; IPv6 PTR entries
$ORIGIN 6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int.

1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     ipv6-rules.com.
2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host1.ipv6-rules.com.
3.0.0.0.3.0.0.0.0.0.0.0.0.0.0.0 IN      PTR     host2.ipv6-rules.com.
</pre>

</body>
</section>

<section>
<title>Configuration de DJBDNS</title>
<body>

<p>
Il y a actuellement des patchs pour DJBDNS disponibles sur 
<uri link="http://www.fefe.de/dns/">http://www.fefe.de/dns/</uri> qui 
le rendent compatible avec IPv6. DJBDNS peut être installé avec ces patchs
si vous l'emergez avec "ipv6" dans votre variable USE.
</p>

<warn>
Certains types d'enregistrements ne sont pas encore supportés avec ces
patchs. C'est le cas notamment des types NS et MX.
</warn>

<pre>
# <i>USE="ipv6" emerge djbdns</i>
</pre>

<p>
Après l'installation de DJBDNS, vous pouvez le configurer en lançant
<c>tinydns-setup</c> et en répondant aux quelques questions posées pour 
savoir quelle adresse utiliser, où installer tinydns, etc.
</p>

<pre caption="Installer tinydns">
# <i>tinydns-setup</i>
</pre>

<p>
Supposons que vous ayez installé <c>tinydns</c> dans <path>/var/tinydns/</path>,
vous pouvez maintenant éditer <path>/var/tinydns/root/data</path>. Ce
fichier contiendra toutes les données nécessaires pour que tinydns puisse
s'occuper de votre délégation IPv6.
</p>

<pre caption="Exemple de fichier data">
.ipv6-rules.com:192.168.0.1:a:259200
<codenote>*.ipv6-rules.com est géré par 192.168.0.1</codenote>
.6.9.2.0.0.0.f.1.0.7.4.0.1.0.0.2.ip6.int:192.168.0.1:a
<codenote>Reverse DNS pour 2001:470:1f00:296::/64</codenote>
6host1.ipv6-rules.com:200104701f0002960000000000000001:86400
6host2.ipv6-rules.com:200104701f0002960000000000000002:86400
<codenote>Spécifie les IPs pour host1 et host2</codenote>
3www.ipv6-rules.com:200104701f0002960000000000000002:86400
<codenote>Pointe vers host1</codenote>
</pre>

<p>
Les lignes préfixées par un <c>6</c> auront deux enregistrements de types
AAAA et PTR créés. Celles préfixées par un <c>3</c> auront seulement un
enregistrement de type AAAA. Au lieu d'éditer manuellement le fichier
<path>data</path>, vous pouvez utiliser les scripts <c>add-host6</c> et
<c>add-alias6</c> pour ajouter de nouvelles entrées. Après avoir modifié
le fichier <path>data</path>, vous n'avez qu'à lancer <c>make</c> dans le
répertoire <path>/var/tinydns/root</path> pour mettre à jour la 
configuration. Cela va créer <path>/var/tinydns/root/data.cfb</path> que
tinydns utilise pour servir les requêtes DNS.
</p>

</body>
</section>

</chapter>
<chapter>

<title>Paramétrer un routeur IPv6</title>

<section>
<title>Configurer le routage</title>
<body>

<p>
Quelques modifications restent à faire si vous voulez utiliser votre
système en tant que routeur pour des clients qui voudraient se 
connecter au réseau IPv6. Nous devons activer le routage des paquets
IPv6. Il y a deux façons de faire.
</p>

<pre caption="Activer le routage sur votre système">
# <i>echo 1 > /proc/sys/net/ipv6/conf/all/forwarding</i>
ou bien
# <i>sysctl -w net.ipv6.conf.all.forwarding=1</i>
</pre>

<warn>
Les scripts d'initialisation de radvd activent le routage des paquets.
Si vous utilisez radvd vous pouvez sauter la prochaine étape.
</warn>

<p>
Pour activer le routage au démarrage du système, éditez le fichier
<path>/etc/sysctl.conf</path> et ajoutez la ligne suivante:
</p>

<pre caption="Ajout dans sysctl.conf">
net.ipv6.conf.default.forwarding=1
</pre>

<p>
Tout le trafic envoyé à votre système devrait maintenant être redirigé
vers la passerelle IPv6 que nous avons précédemment paramétrée à l'aide
d'un tunnel.
</p>

<p>
Pour assigner automatiquement des adresses IPv6 à vos clients,
il existe deux moyens prévus par les spécifications IPv6. La méthode
la plus en vogue s'appelle "Router Advertisement" et permet à un client
d'obtenir une adresse et une route de la part du routeur, permettant
la connexion au réseau
IPv6 simplement en activant l'interface. C'est le client qui 
détermine son adresse en fonction du préfixe donné par le routeur. La deuxième
méthode est "DHCPv6". Tel DHCP sous IPv4, c'est le serveur qui 
assigne l'adresse et la route au client en fonction de son 
identificateur réseau. DHCPv6 permet de garder une trace des 
assignations d'IPs, au contraire de RADV.
</p>

</body>
</section>

<section>
<title>Installation d'un routeur RADV</title>
<body>

<p>
L'installation d'un routeur RADV est enfantine en utilisant le Router
Advertisement Daemon: radvd.
</p>

<pre caption="Installer radvd">
# <i>emerge radvd</i>
</pre>

<p>
Après avoir installé radvd, nous devons créer le fichier
<path>/etc/radvd/radvd.conf</path> qui contient les informations
du routeur à transmettre aux clients, à savoir le bloc d'IPs 
allouées. Voici un exemple de <path>radvd.conf</path> en utilisant
le préfixe que nous avons déjà utilisé pour notre passerelle IPv6.
</p>

<pre caption="Exemple de radvd.conf">
interface eth0
{
        AdvSendAdvert on;
        <codenote>Envoie régulièrement des annonces aux autres machines</codenote>
        AdvLinkMTU 1280;
        MaxRtrAdvInterval 300;
        prefix 2001:470:1F00:296::/64
        <codenote>Le bloc d'IPs que nous avons obtenues</codenote>
        {
                AdvOnLink on;
                AdvAutonomous on;
        };
};
</pre>

<p>
Pour plus d'informations, consulter <c>man radvd.conf</c>. Nous 
pouvons à présent lancer radvd et le faire démarrer au boot.
</p>

<pre caption="Activer radvd">
# <i>/etc/init.d/radvd start</i>
# <i>rc-update add radvd default</i>
</pre>

</body>
</section>

<section>
<title>Installation d'un routeur DHCPv6</title>
<body>

<p>
Pour installer DHCPv6 sur votre routeur, vous devez bien évidemment
installer et configurer le démon dhcpv6.
</p>

<pre caption="Installation de dhcpv6">
# <i>emerge dhcpv6</i>
</pre>

<p>
Nous devons à présent configurer le serveur DHCPv6 en éditant
<path>/etc/dhcp6s.conf</path>.
</p>

<pre caption="Exemple de dhcp6s.conf">
prefer-life-time 10000;
valid-life-time 20000;
renew-time 5000;
rebind-time 8000;
interface eth1 {
	link AAA {
		allow unicast;
		send unicast;
		allow rapid-commit;
		send server-preference 5;
		renew-time 1000;
		rebind-time 2400;
		prefer-life-time 2000;
		valid-life-time 3000;
                pool{
                        range 2001:470:1f00:296::10 to 2001:470:1f00:296::110/64;
                        prefix 2001:470:1f00:296::/64;
                };
	};
};
</pre>

<p>
Nous pouvons enfin lancer dhcp6s et le faire démarrer lors du boot.
</p>

<pre caption="Démarrer dhcpv6s">
# <i>/etc/init.d/dhcp6s start</i>
# <i>rc-update add dhcp6s default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Les clients IPv6</title>
<section>
<title>En utilisant radvd</title>
<body>

<p>
Les clients derrière ce routeur devraient maintenant pouvoir accéder
au réseau IPv6. En utilisant radvd, aucune configuration particulière
n'est nécessaire et il vous suffit d'activer votre interface réseau.
C'est probablement déjà fait par votre script d'initialisation 
net.ethX.
</p>

<pre caption="Se connecter à IPv6">
# <i>ifconfig eth0 up</i>
# <i>ifconfig eth0</i>
eth0      Link encap:Ethernet  HWaddr 00:09:6B:06:B7:B4
          inet6 addr: fe80::209:6bff:fe06:b7b4/64 Scope:Link
          inet6 addr: 2001:470:1f00:296:209:6bff:fe06:b7b4 Scope:Global
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:100
          RX bytes:0 (0.0 b)  TX bytes:828 (828.0 b)
          Interrupt:11 Base address:0x8400 Memory:d0204000-d0204038
</pre>

</body>
</section>

<section>
<title>En utilisant DHCPv6</title>
<body>

<p>
Si votre routeur est configuré pour utiliser DHCPv6, vos clients
doivent alors également avoir le paquet dhcpv6 d'installé. Ensuite, 
vous devez configurer vos clients en éditant le fichier
<path>/etc/dhcp6c.conf</path>.
</p>

<pre caption="Exemple de dhcp6c.conf">
interface eth0 {
	send rapid-commit;
	request prefix-delegation;
	request domain-name-servers;
	request temp-address;
	iaid 11111;
	renew-time 11000;
	rebind-time 21000;
};
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Utiliser la conversion 6to4</title>
<section>
<title>Principes de base</title>
<body>

<p>
La conversion 6to4 permet à des machines IPv6 de communiquer avec 
des machines IPv4. Cela vous permet d'avoir un réseau entièrement
en IPv6 et de continuer à vous connecter aux serveurs IPv4 habituels,
votre routeur (IPv6 et IPv4) s'occupera du reste.
</p>

</body>
</section>

<section>
<title>Configuration DNS</title>
<body>

<p>
Pour faire fonctionner correctement les conversions 6to4, vous devez
installer un proxy DNS, <c>totd</c> qui vous renverra un
enregistrement DNS de type AAAA pour les hôtes qui n'ont
qu'un enregistrement de type A. Ces enregistrements de type AAAA
pointeront vers des adresses IPv6 qui n'existent pas réellement,
mais qui seront reconnues par le proxy 6to4 qui routera les
paquets vers la bonne machine. Actuellement <c>totd</c> est encore
masqué en <c>~x86</c> en attendant des tests plus approfondis.
</p>

<pre caption="Installation de totd">
# <i>ACCEPT_KEYWORDS="~x86" emerge totd</i>
</pre>

<p>
Ensuite, vous devez paramétrer le fichier <path>/etc/totd.conf</path>:
</p>

<pre caption="Exemple de totd.conf">
forwarder 192.168.0.2 port 53
<codenote>L'adresse d'un vrai serveur DNS</codenote>
prefix 3ffe:abcd:1234:9876::
<codenote>Le préfixe à ajouter aux faux enregistrements AAAA</codenote>
port 5005
<codenote>Le port où totd écoutera</codenote>
pidfile /var/run/totd.pid
<codenote>Nom de fichier PID à utiliser</codenote>
stf
<codenote>Active le 6to4</codenote>
</pre>

<note>
<c>totd</c> doit etre configuré sur un port différent de 53 dans le
cas où un serveur DNS tournerait déjà sur votre serveur.
</note>

</body>
</section>

<section>
<title>Le proxy 6to4</title>
<body>

<p>
Nous allons utiliser <c>ptrtd</c> comme proxy 6to4, ce qui permettra
les connexions entre l'IPv6 et l'IPv4.
</p>

<pre caption="Installation de ptrtd">
# <i>ACCEPT_KEYWORDS="~x86" emerge ptrtd</i>
</pre>

<p>
Vous devez à présent configurer <c>ptrtd</c> en lui indiquant le 
faux préfixe que vous avez donné à totd afin qu'il puisse 
reconnaître les paquets à transformer. Éditez le fichier 
<path>/etc/conf.d/ptrtd</path> et réglez <c>IPV6_PREFIX</c>. Cela 
doit impérativement être le même préfixe que celui donné à 
<c>totd</c>.
</p>

<pre caption="Exemple de ptrtd.conf">
IPV6_PREFIX="3ffe:abcd:1234:9876::"
</pre>

<p>
Vous pouvez maintenant lancer totd.
</p>

<pre caption="Démarrage de totd">
# <i>/etc/init.d/totd start</i>
# <i>rc-update add totd default</i>
</pre>

</body>
</section>

<section>
<title>Configuration et test des clients</title>
<body>

<p>
Les clients peuvent maintenant être configurés pour pouvoir se 
connecter aussi bien aux machines IPv6 qu'IPv4, avec seulement
une interface IPv6. Supposons que les clients aient déjà reçu une
adresse IP de radvd, nous n'avons plus qu'à configurer le serveur 
DNS à utiliser et à ajouter une route par défaut spéciale pour 
les "fausses adresses". Premièrement, ajoutons une entrée au début
du fichier <path>/etc/resolv.conf</path> pointant vers la machine
où <c>totd</c> tourne.
</p>

<pre caption="Exemple de resolv.conf">
nameserver 2001:470:1f00:296::1
<codenote>L'adresse du serveur où totd tourne</codenote>
</pre>

<p>
Pour tester la résolution de nom, faites une requête de type AAAA
sur un nom qui n'a que des adresses IPv4.
</p>

<pre caption="Test de la résolution de nom">
# <i>host -t aaaa google.com</i>
google.com has AAAA address 3ffe:abcd:1234:9876::d8ef:3364
google.com has AAAA address 3ffe:abcd:1234:9876::d8ef:3564
</pre>

<p>
Nous allons maintenant ajouter une route par défaut spéciale pour
toutes les adresses qui commenceront par notre préfixe choisi.
</p>

<pre caption="En utilisant route">
# <i>route -A inet6 add 3ffe:abcd:1234:9876::/64 gw 2001:470:1f00:296::1</i>
</pre>

<pre caption="En utilisant iproute">
# <i>ip route add 3ffe:abcd:1234:9876::/64 via 2001:470:1f00:296::1 dev eth0</i>
</pre>

<p>
Enfin, utilisez <c>ping6</c> pour pinguer google.com avec sa fausse 
adresse IPv6.
</p>

<pre caption="Test du 6to4">
# <i>ping6 -c 2 google.com</i>
PING 3ffe:abcd:1234:9876::d8ef:3364(3ffe:abcd:1234:9876::d8ef:3364) 56 data bytes
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=1 ttl=255 time=0.106 ms
64 bytes from 3ffe:abcd:1234:9876::d8ef:3364: icmp_seq=2 ttl=255 time=0.090 ms

--- 3ffe:abcd:1234:9876::d8ef:3364 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.090/0.098/0.106/0.008 ms
</pre>

<note>
En fait c'est le routeur avec <c>ptrtd</c> qui répond, mais cela
nous montre au moins que ça marche.
</note>

</body>
</section>

</chapter>

<chapter>
<title>Autres ressources</title>
<body>

<p>
Il existe de nombreuses excellentes ressources en ligne concernant
IPv6.
</p>

<table>
<tr><th>Sites</th><th>Ressources</th></tr>
<tr><ti><uri link="http://www.ipv6.org/">www.ipv6.org</uri></ti><ti>Informations générales sur IPv6</ti></tr>
<tr><ti><uri link="http://www.linux-ipv6.org/">www.linux-ipv6.org/</uri></ti><ti>Le projet USAGI</ti></tr>
<tr><ti><uri link="http://www.deepspace6.net/">www.deepspace6.net</uri></ti><ti>Un site sur Linux et IPv6</ti></tr>
<tr><ti><uri link="http://www.hs247.com/">www.hs247.com</uri></ti><ti>De nombreuses choses autour d'IPv6</ti></tr>
<tr><ti><uri link="http://www.ipv6-net.org/">www.ipv6-net.org</uri></ti><ti>Un site allemand sur IPv6</ti></tr>
<tr><ti><uri link="http://www.kame.net/">www.kame.net</uri></ti><ti>La fameuse implémentation pour *BSD</ti></tr>
</table>

<p>
Ndt: Et voici quelques sites en français.
</p>

<table>
<tr><th>Sites</th><th>Ressources</th></tr>
<tr><ti><uri link="http://www.g6.asso.fr/">www.g6.asso.fr</uri></ti><ti>L'association G6</ti></tr>
<tr><ti><uri link="http://www.fr.ipv6tf.org/">www.fr.ipv6tf.org</uri></ti><ti>IPv6 Task Force France</ti></tr>
</table>

<p>
Sur IRC, vous pouvez essayer <c>#gentoo-ipv6</c> ou <c>#ipv6</c> sur 
<uri link="http://www.freenode.net">Freenode</uri>. Vous pouvez vous connecter
aux serveurs Freenode en IPv6 en vous connectant à <b>irc.ipv6.freenode.net</b>.
</p>

</body>
</chapter>


</guide>
