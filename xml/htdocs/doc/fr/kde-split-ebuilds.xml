<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/kde-split-ebuilds.xml,v 1.1 2005/03/02 20:48:10 cam Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/fr/kde-split-ebuilds.xml" lang="fr">

<title>Guide sur les ebuilds séparés de KDE</title>

<author title="Auteur">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Traducteur">
  <mail link="clement@varaldi.org">Clément Varaldi</mail>
</author>


<abstract>
Avec KDE 3.4, la notion d'ebuilds séparés a été introduite dans Portage. Ce
guide présente les raisons de cette transition et les fonctionnalités qui ont
été mises à disposition.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.1</version>
<date>2005-02-19</date>

<chapter>
<title>Les ebuilds séparés de KDE</title>
<section>
<title>Ce qu'ils sont</title>
<body>

<p>
Jusqu'à janvier 2005, les seuls ebuilds de KDE dans Portage étaient des ebuilds
monolithiques. Il n'y avait qu'une quinzaine d'ebuilds et chacun installait de
nombreuses applications qui, en réalité, ne dépendait pas les unes des autres.
Ce n'était vraiment une situation ni idéale, ni très conforme à l'esprit Gentoo,
mais cela a été toléré pendant longtemps.
</p>

<p>
Les nouveaux ebuilds «&nbsp;séparés&nbsp;» corrigent ce problème en proposant
des ebuilds distincts pour toutes les applications de KDE. Cela donne un total
d'environ 330 nouveaux ebuilds dans la catégorie kde-base.
</p>

<p>
Nous continuons cependant à proposer les ebuilds monolithiques pour KDE 3.4 et
ils sont utilisables en conjonction avec les versions séparées. Cependant, les
ebuilds séparés sont désormais la version par défaut et, pour KDE 4.0, la
version monolithique disparaîtra.
</p>

<p>
Enfin, il faut remarquer qu'il existe également des ebuilds séparés pour Koffice
qui proposent kword, kugar, etc. comme des paquets distincts.
</p>

</body>
</section>
<section>
<title>Comment les utiliser</title>
<body>

<p>
À l'heure où ces lignes sont écrites, la dernière version de test pour KDE 3.4.0
est la 3.4.0_beta1. Les ebuilds séparés et monolithiques pour cette version sont
disponibles en paquets masqués dans Portage.
</p>

<ul>
  <li>
    Pour installer un paquet particulier comme, par exemple, kmail, il suffit de
    faire un <c>emerge kmail</c>.
  </li>
  <li>
    Pour installer l'environnement KDE de base, qui vous permettra de vous
    connecter à une simple session KDE, il faudra faire un <c>emerge
    kdebase-startkde</c>.
  </li>
  <li>
    Enfin, pour disposer de l'équivalent exact de l'un des paquets monolithiques
    (par exemple, pour disposer de toutes les applications incluses dans
    <c>kdebase</c> en utilisant les ebuilds séparés), vous pouvez faire un
    <c>emerge kdebase-meta</c> (ou kdepim-meta, etc.). Pour disposer
    d'absolument tous les paquets KDE, installez kde-meta avec <c>emerge
    kde-meta</c>.
  </li>
</ul>

</body>
</section>
<section>
<title>Avantages des ebuilds séparés</title>
<body>

<p>
Voici une liste rapide de ce que vous gagnerez à passer aux ebuilds
séparés&nbsp;:
</p>

<ul>
  <li>
    La plupart des paquets KDE ne changent pas du tout entre deux sorties
    mineures de KDE. Par exemple, le passage de la version 3.3.1 à la 3.3.2
    modifiera moins de 100 paquets sur 320. Les paquets séparés nous permettent
    de ne créer un nouvel ebuild uniquement lorsque l'application a
    effectivement subi des modifications, ce qui fait économiser (dans notre
    exemple) plus de deux tiers du temps de compilation lors de la mise à jour.
  </li>
  <li>
    Les correctifs n'affectent en général qu'un paquet bien précis. Avec les
    ebuilds séparés, ils peuvent être testés, approuvés et soumis plus
    rapidement et les développeurs ont moins de travail. Enfin, l'utilisateur
    final passera moins de temps à faire sa mise à jour. C'est important surtout
    pour les mises à jour de sécurité.
  </li>
  <li>
    Les utilisateurs d'autres bureaux ou gestionnaires de fenêtres peuvent
    installer les quelques applications KDE qui leur plaisent sans devoir passer
    par l'installation d'un gros paquet d'applications qu'ils n'utiliseront pas.
    Par exemple, kdebase ou kdepim.
  </li>
  <li>
    Les utilisateurs peuvent personnaliser au mieux les paquets qu'ils
    installent. Pourquoi&nbsp;?

    <ul>
      <li>
        Vous vous préoccupez du temps de compilation. <c>emerge kdebase kdepim
        kdenetwork</c> prend bien trop de temps à compiler, surtout si vous ne
        souhaitiez que konqueror, kmail et kopete.
      </li>
      <li>
        Vous vous préoccupez de l'espace disque. Chaque paquet non utilisé
        représente de l'espace disque bloqué et inutilisable sur votre disque.
        Un disque avec plus d'espace disque est préférable.
      </li>
      <li>
        Vous vous préoccupez de la sécurité du système. Tous les logiciels
        installés sont des sources potentielles de vulnérabilité et il n'y a
        aucune excuse pour permettre de laisser des programmes inusités traîner
        sur votre système.
      </li>
      <li>
        Vous adhérez complètement à la
        <uri link="http://www.gentoo.org/main/en/philosophy.xml">philosophie
        Gentoo</uri> et vous ne supportez pas d'avoir des applications
        regroupées par paquets qui obligent les utilisateurs à installer le
        tout.
      </li>
    </ul>
  </li>
  <li>
    Enfin, les ebuilds séparés permettent plus de flexibilité, en ce qui
    concerne notamment les temps de compilation, grâce aux paramètres USE.
  </li>
</ul>

</body>
</section>
<section>
<title>Utilisation conjointe des ebuilds monolithiques et séparés</title>
<body>

<p>
Les ebuilds monolithiques et séparés peuvent être librement mélangés. La seule
restriction est qu'il ne faut pas installer un ebuild monolithique en même temps
qu'un ebuild séparés qui en dérive. Des dépendances bloquantes empêchent de
faire cela, donc vous pouvez faire tout ce qu'emerge vous permet de faire.
</p>

<p>
Cela dit, il n'y a normalement aucune raison pour que vous utilisiez une
configuration mixte. En fait, mis à part certains cas comme la compilation sur
des machines lentes, vous devriez plutôt utiliser les ebuilds séparés pour tout
ce que vous souhaitez utiliser.
</p>

<p>
Les ebuilds séparés sont les ebuilds par défaut. Cela signifie que quand
d'autres ebuilds dépendent d'une application KDE, ils essayeront d'installer
l'ebuild séparé. Cela dit, l'ebuild monolithique correspondant devra également
satisfaire cette dépendance, donc vous pouvez installer l'ebuild monolithique
à la main, puis installer l'ebuild qui en dépend.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problèmes de performance</title>
<section>
<title>Pourquoi les ebuilds séparés sont lents ?</title>
<body>

<p>
Il a été remarqué dans
<uri link="http://bugs.gentoo.org/show_bug.cgi?id=11123">ce rapport de
bogue</uri> que les ebuilds séparés sont plus longs à installer que leur version
monolithique, à cause du fait qu'il faille désarchiver et lancer le script de
configuration pour chaque paquet, au lieu d'un seul. Une installation complète
avec <c>emerge kde-meta</c> devrait prendre entre 20 et 30% plus de temps qu'une
installation classique de <c>emerge kde</c>, ce qui est difficilement acceptable
pour une compilation qui prend déjà suffisamment de temps.
</p>

<p>
Pour couronner le tout, pour le moment, les ebuilds séparés lancent toujours un
<c>make -f admin/Makefile.cvs</c> (ce qui signifie exécuter autoconf, automake,
etc. et divers scripts spécifiques à KDE). Cela ajoute une dose de lenteur à la
compilation, qui est du même ordre que l'exécution du script de configuration.
</p>

<p>
L'analyse semble très pessimiste, mais certains éléments permettent de réduire
cette lenteur, que nous détaillerons dans les prochaines sections.
</p>

<p>
Il est bon de rappeler ici que grâce aux ebuilds séparés, une mise à jour de KDE
aura un temps de compilation bien inférieur à cette même mise à jour en
utilisant les ebuilds monolithiques. Ces bénéfices masquent souvent les
désagréments constatés lors de l'installation initiale.
</p>

<p>
Finalement, installer tout KDE n'a de sens que si vous voulez explorer et
tester l'ensemble des paquets disponibles ou si vous voulez mettre en place un
environnement multi-utilisateurs. Cela dit, la plupart des utilisateurs
n'utilisent qu'une poignée des plus de 300 applications KDE disponibles. Ceux
qui se préoccupent sérieusement du temps de compilation, comme les propriétaires
de vieilles machines, peuvent gagner plus de temps à choisir minutieusement les
paquets à installer qu'à installer les ebuilds monolithiques.
</p>

</body>
</section>
<section>
<title>Comment va-t-on faire pour accélérer tout ça ?</title>
<body>

<p>
L'amélioration la plus évidente serait de distribuer des archives séparées pour
les ebuilds séparés, au lieu de désarchiver des morceaux des archives
monolithiques (kdebase, etc.). Cela supprimerait deux des trois facteurs de
ralentissement à l'installation&nbsp;: extraction répétée d'une grosse archive
et régénération du Makefile (l'étape <c>make -f admin/Makefile.cvs</c>
mentionnée précédemment).
</p>

<p>
Il nous reste le problème du lancement répété du script de configuration. Une
solution correcte est donnée par confcache&nbsp;: un cache de configuration
partagé entre les exécutions d'emerge. Une implémentation existe déjà dans la
branche développement de Portage (l'outil, pas l'arbre de Portage). Une sortie
stable avec confcache est prévue d'ici environ six mois.
</p>

</body>
</section>
<section>
<title>Autres facteurs qui peuvent accélérer la compilation des ebuilds
séparés</title>
<body>

<p>
Dans la section précédente, nous avons vu des méthodes pour améliorer les
performances des ebuilds séparés uniquement. Nous allons maintenant citer
quelques améliorations à venir qui seront valables tant pour les ebuilds séparés
que pour les monolithiques. De telles améliorations permettront d'obtenir des
ebuilds séparés suffisamment rapides, sans comparaison avec des solutions moins
intéressantes telles que les ebuilds monolithiques.
</p>

<ul>
  <li>
    KDE 4.0 devrait pouvoir utiliser
    <uri link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri>
    à la place de automake, ce qui accélère la compilation dans certains cas.
    Nos ebuilds pour KDE 3.4 pourraient également utiliser unsermake à leur
    avantage.
  </li>
  <li>
    Les ebuilds séparés supportent le paramètre USE kdexdeltas, qui permet de
    télécharger des mises à jour de binaires entre deux archives de versions
    différentes pour économiser de la bande passante.
  </li>
  <li>
    Tous les autres outils impliqués dans le processus de construction du
    binaire gagnent également en rapidité ou permettent des améliorations liées
    à la compilation de KDE. Les fonctionnalités visibility=hidden (GCC 3.4)
    et les en-têtes précompilées (GCC 4.0) sont deux exemples récents. Ils ne
    sont pas la conséquence directe du passage aux ebuilds séparés, mais cela
    permet tout simplement d'exploiter au mieux le processeur pour la
    compilation.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>FAQ sur les ebuilds séparés</title>
<section>
<title>Est-ce qu'on ne peut pas déjà faire ceci avec
DO_NOT_COMPILE&nbsp;?</title>
<body>

<p>
DO_NOT_COMPILE est une variable d'environnement interne utilisée lors de la
compilation de KDE. Elle permet de supprimer de la compilation certains
sous-répertoires choisis à l'avance. Certains utilisateurs s'en servent pour ne
compiler qu'une partie d'un ebuild KDE monolithique. Par exemple, exécuter
<c>DO_NOT_COMPILE=konqueror emerge kdebase</c> devrait installer la base de KDE
sans installer l'application konqueror.
</p>

<p>
Cependant, DO_NOT_COMPILE n'a jamais eu pour but de permettre d'intervenir dans
les opérations de compilation du gestionnaire de paquet. Cela ne fonctionne pas
correctement, peut casser votre système et n'a jamais été supporté. Nous
demandons donc de ne surtout pas l'utiliser.
</p>

<p>
Voici quelques-uns des problèmes de DO_NOT_COMPILE&nbsp;:
</p>

<ul>
  <li>
    Il casse complètement le système de recherche de dépendances de Portage.
    Portage ne connaît pas DO_NOT_COMPILE et pense que l'ensemble du paquet
    monolithique a été installé et peut satisfaire les dépendances d'autres
    paquets. Cela peut amener ces autres paquets à ne pas pouvoir s'installer
    ou ne pas pouvoir s'exécuter.
  </li>
  <li>
    Il oblige l'utilisateur à connaître le nom et le sens de tous les différents
    sous répertoires des modules KDE. Peu d'utilisateurs en connaissent le sens,
    à moins d'être développeur KDE, vous avez peu de chances d'en faire partie.
    Il y a peu de chances pour que vous utilisiez alors DO_NOT_COMPILE
    correctement.
  </li>
  <li>
    Les sous-répertoires de modules KDE peuvent avoir des dépendances entre
    eux, nécessitent parfois un ordre précis de compilation, nécessitent la
    présence d'un autre répertoire même s'il n'a pas besoin d'être installé,
    etc. Nous avons passé beaucoup de temps sur les ebuilds séparés pour qu'ils
    puissent fonctionner correctement dans ce sens. DO_NOT_COMPILE n'est pas un
    outil assez fin pour obtenir des résultats aussi bons que les ebuilds
    séparés, même si l'utilisateur a une connaissance suffisante pour pouvoir
    le manipuler. La seule chose que cette variable vous permette de faire est
    d'enlever de la compilation quelques applications. Il est pratiquement
    impossible de l'utiliser pour installer deux ou trois applications à partir
    de modules comme kdebase ou kdepim.
  </li>
  <li>
    Si j'ai installé kmail hier et que je veux ajouter korn aujourd'hui, en
    utilisant DO_NOT_COMPILE, il faudra recompiler kmail également. Cela
    signifie que DO_NOT_COMPILE sera toujours plus lent que les ebuilds séparés.
  </li>
  <li>
    DO_NOT_COMPILE ne peut pas être utilisé pour créer des paquets précompilés
    (comme par exemple les GRP) contenant des applications individuelles de KDE.
  </li>
</ul>

</body>
</section>
<section>
<title>Est-ce que vous n'en demanderiez pas un peu trop aux mainteneurs KDE de
Gentoo&nbsp;?</title>
<body>

<p>
Curieusement, cette question est souvent revenue. Je suis content de voir que
les utilisateurs sont aussi prévenants à l'égard des mainteneurs. Laissez-moi
vous dire, pour l'occasion, que nous avons nous-même choisi la voie des ebuilds
séparés. Nous croyons que nous seront capables de maintenir les paquets avec la
même qualité qu'actuellement. Rien ne nous empêchera de faire les ebuilds
séparés.
</p>

<p>
Pour être plus juste, je devrais ajouter que des mainteneurs d'autres
architectures se sont effectivement plaints de l'augmentation de charge de
travail, de tests et de gestion des mots-clefs sur autant d'ebuilds séparés.
Nous travaillons actuellement pour résoudre ce problème et c'est la raison
essentielle qui fait que les ebuilds monolithiques seront en fait toujours
disponibles pour KDE 3.4.
</p>

</body>
</section>
<section>
<title>Allez-vous supprimer les ebuilds monolithiques ?</title>
<body>

<p>
Nous essayerons de le faire. Cela dit, pour toutes les versions de KDE 3.4, nous
aurons à la fois des ebuilds monolithiques et séparés.
</p>

<p>
Si vous préférez les ebuilds monolithiques aux séparés, merci de nous faire part
de <uri link="http://bugs.gentoo.org">vos raisons</uri>.
</p>

</body>
</section>
<section>
<title>Il y a trop d'ebuilds&nbsp;! Comment faire pour trouver celui dont j'ai
besoin&nbsp;?</title>
<body>

<p>
Tout d'abord, si vous savez que le paquet que vous recherchez vient avec kdebase
vous pouvez toujours faire un <c>emerge kdebase-meta</c>, qui vous permettra
de faire un peu la même chose que si vous installiez la version monolithique de
<c>kdebase</c>.
</p>

<p>
Évidemment, vous pouvez utiliser tous les moyens habituels de recherche de
paquet. Trouveriez-vous votre ebuild si c'était une application Gnome&nbsp;? Le
minimum est d'avoir le nom de l'application que vous recherchez.
</p>

<p>
La situation pourrait peut-être être améliorée en ajoutant certains ebuilds de
type -meta. Ils sont à considérer comme des listes de dépendances, donc ça ne
nous coûte rien d'en créer. Mais nous n'avons pas encore décidé si nous le
ferons ou pas. De même, il serait bien que Portage puisse supporter certaines
fonctionnalités liées aux ebuilds -meta avant de se mettre à les utiliser de
manière excessive.
</p>

</body>
</section>
<section>
<title>Comment puis-je désinstaller une ancienne version de KDE ?</title>
<body>

<p>
Supposons que KDE 4.0 sorte et que vous vouliez désinstaller les ebuilds
séparés de KDE 3.4. Parce qu'ils appartiennent à deux SLOT différents, emerge
ne le fera pas pour vous, il faudra donc utiliser une méthode adaptée.
</p>

<p>
Une bonne solution à ce problème nécessite des modifications dans Portage. On
peut trouver une telle solution dans la
<uri link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>.
Cependant, d'ici à son implémentation, il faudra utiliser des scripts comme
celui proposé ci-dessous.
</p>

<p>
Tous les ebuilds KDE appartiennent au répertoire kde-base (et tous les ebuilds
dans la catégorie kde-base viennent de kde.org). Partant de ce constant, vous
pouvez utiliser le code suivant&nbsp;:
</p>

<pre>
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
Ce code peut apparaître comme un vilain hack, mais ce n'en est en réalité pas
un, parce que tout ce que nous avons à faire est d'établir la liste des ebuilds
dans kde-base. C'est une tâche très simple et il y aura donc toujours un moyen
simple pour le faire.
</p>

</body>
</section>
<section>
<title>Comment puis-je lister/désinstaller tous les ebuilds séparés qui dérivent
d'un paquet donné&nbsp;?</title>
<body>

<p>
L'objectif ici est d'obtenir une liste de tous les ebuilds séparés de KDE
dérivant de, mettons, l'ebuild monolithique kdebase. Encore une fois, une
implémentation correcte (comme proposé dans la
<uri link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>)
pourrait rendre cette opération triviale. Mais, pour le moment, vous devrez
jouer avec des détails qui concernent l'implémentation des eclass KDE. Donc si
vous les utilisez pour un script qui n'est pas à usage privé, merci de nous le
signaler.
</p>

<p>
kde-functions.eclass définit des fonctions nommées get-parent-package() et
get-child-packages() qui font la traduction pour vous. Ces deux fonctions sont
un bon moyen d'obtenir la liste demandée à partir d'un ebuild ou d'un script
bash externe. Voici un exemple&nbsp;:
</p>

<pre>
$ <i>function die() { echo $@; }</i>
<comment>(Appelée pour récupérer les erreurs.)</comment>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror</i>
Package konqueror not found in KDE_DERIVATION_MAP, please report bug
<comment>(Ne fonctionne pas, vous devez spécifier le nom complet.)</comment>
$ <i>get-parent-package kde-base/konqueror</i>
kde-base/kdebase
$ <i>get-child-packages kde-base/kdebase</i>
<comment>(Une longue liste de paquet est retournée ici.)</comment>
</pre>

<p>
Si votre script n'est pas en bash, vous pouvez récupérer dans
kde-functions.eclass la définition (sur plusieurs lignes) de la variable
KDE_DERIVATION_MAP que les fonctions citées plus haut utilisent. Cette variable
contient une liste de mots séparés par des espaces et chaque paire de mots
consécutifs permet de faire la correspondance entre un paquet parent et un
ebuild séparé qui hérite de celui-ci.
</p>

</body>
</section>
</chapter>
</guide>
