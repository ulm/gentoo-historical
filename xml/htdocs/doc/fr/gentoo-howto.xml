<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/Attic/gentoo-howto.xml,v 1.4 2004/01/19 22:30:36 neysx Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/fr/gentoo-howto.xml">
<title>HOWTO pour les développeurs Gentoo Linux</title>
<author title="Auteur">
  <mail link="woodchip@gentoo.org">Donny Davies</mail>
</author>
<author title="Auteur">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Auteur">
  <mail link="pete@gentoo.org">Peter Gavin</mail>
</author>
<author title="Auteur">
  <mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail>
</author>
<author title="Auteur"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Auteur">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Correcteur">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Correcteur">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Correcteur">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Correcteur">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Correcteur">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Traducteur">
  <mail link="pierre.habouzit@m4x.org">Pierre Habouzit</mail>
</author>
<author title="Traducteur">
  <mail link="vincent.strubel@m4x.org">Vincent Strubel</mail>
</author>

<abstract>
Ce document décrit le système Portage de Gentoo-Linux, comment créer de
nouveaux paquets pour Gentoo, et essaie de définir une sorte de standard pour
les développeurs Gentoo.  C'est un travail en cours qui est constamment mis à
jour et modifié. Il est donc par nature incomplet.  Vous devriez
<e>toujours</e>  l'utiliser en conjonction avec les pages de manuel de Portage
(en particulier ebuild(5)) et la <uri
link="http://www.gentoo.org/doc/en/policy.xml"> politique de développement
Gentoo Linux</uri>.
</abstract>

<version>1.4.6</version>
<date>7 janvier 2004</date>

<chapter>
<title>L'arbre de Portage</title>
<section>
<title>Introduction</title>
<body>

<p>
L'arbre de Portage se trouve typiquement dans <path>/usr/portage</path> et est
organisé suivant une structure hiérarchique composée de répertoires par
catégorie, puis de répertoires spécifiques aux paquets. Par exemple, vous
pouvez trouver le fichier <path>util-linux-2.11y.ebuild</path> dans le
répertoire <path>/usr/portage/sys-apps/util-linux</path>. Il peut y avoir
plusieurs autres versions d'ebuilds pour <c>util-linux</c> dans le même
répertoire.  En effet, <e>tous les ebuilds pour un paquet donné (indépendamment
de la version)</e> partagent le même répertoire <path>catégorie/paquet</path>
dans <path>/usr/portage</path>. 
</p>

</body>
</section>

<section>
<title>Récupérer l'arbre de Portage par CVS</title>
<body>

<p>
Si vous n'êtes pas familier avec le système CVS, veuillez lire le 
<uri link="http://www.gentoo.org/doc/en/cvs-tutorial.xml">tutoriel CVS</uri>
pour plus d'information.
</p>

<p>
L'arbre de Portage peut être trouvé dans le module <c>gentoo-x86</c>
de l'arborescence Gentoo Linux. Pour récupérer le module (350 méga-octets 
environ), vous devez en premier lieu configurer CVS comme indiqué dans le guide 
ci-dessus, puis récupérer le module <c>gentoo-x86</c>.
</p>

</body>
</section>

<section>
<title>Que mettre (et ne pas mettre) dans l'arbre de Portage</title>
<body>

<p>
Avant d'écrire un ebuild, vérifiez sur <uri link="http://bugs.gentoo.org/">
bugs.gentoo.org</uri> qu'il n'existe pas d'ebuild correspondant à celui que
vous voulez écrire et qu'il ne soit pas encore intégré à l'arbre de Portage.
Allez sur <uri link="http://bugs.gentoo.org/">bugs.gentoo.org</uri>, choisissez
<e>query</e>, comme produit (<e>product</e>), choisisez <e>Gentoo Linux</e>, et
comme composant (<e>component</e>) <e>ebuilds</e>. Mettez le nom de l'ebuild
dans le champ de recherche et choisissez NEW, ASSIGNED, REOPENED, et RESOLVED
(RESOLVED est important) comme statut (<e>status</e>), puis soumettez la
demande. Pour les paresseux, cliquez <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">ici</uri>.
</p>

<p>
De manière générale, l'arbre de Portage ne devrait être utilisé que pour
entreposer des fichiers <path>.ebuild</path> ainsi que des fichiers
d'accompagnement de taille limitée comme des patchs ou des exemples de fichiers
de configuration. Les fichiers de ce type devraient être placés dans le
répertoire <path>/usr/portage/catégorie/paquet/files</path> afin de limiter
l'encombrement du répertoire principal <path>catégorie/paquet</path>. Les
exceptions à cette règle concernent les plus gros patchs qui devraient être mis
sur les miroirs Gentoo pour éviter aux utilisateurs de gaspiller trop de bande
passante ou d'espace disque.  Par ailleurs, ce n'est en général pas une bonne
idée pour les développeurs d'ajouter des fichiers binaires (non-ASCII) au CVS.
Cependant, si cela s'avère nécessaire (par exemple si vous avez besoin
d'ajouter une petite image PNG pour une raison quelconque), faites bien
attention à l'ajouter au CVS avec l'option <c>-kb</c>, comme ceci&nbsp;:
</p>

<pre caption="Ajouter des fichiers binaires au CVS">
# <i>cvs add -kb maphoto.png</i>
</pre>

<p>
L'option <c>-kb</c> indique à CVS que <path>maphoto.png</path> est un 
fichier binaire qui doit être traité de manière spécifique. Par exemple, 
la fusion des différences entre deux version de ce fichier ne devrait 
jamais être effectuée pour des raisons évidentes. Par ailleurs, toujours 
à propos de la fusion de différences, les patchs que vous ajoutez à 
Portage ne doivent en général <e>pas</e> être compressés. Cela permet à 
CVS de fusionner les modifications et d'informer correctement les 
développeurs de conflits éventuels.
</p>

<p>
N'oubliez pas, les paquets que vous soumettez doivent être <e>prêts</e> à 
fonctionner sans effort supplémentaire de la part de l'utilisateur final
lorsque vous les fournissez comme stables. Assurez-vous d'avoir une bonne 
configuration par défaut qui convienne à la majorité des systèmes et des 
utilisateurs qui se serviront de votre paquet. Si votre paquet est 
cassé et que vous n'êtes pas sûr qu'il fonctionne, renseignez-vous auprès 
d'autres distributions qui offrent leur version du paquet. Vous pouvez 
consulter <uri link="http://cvs.mandrakesoft.com/cgi-bin/cvsweb.cgi/SPECS/">
Mandrake</uri> ou <uri link="http://www.debian.org/distrib/packages">Debian</uri> 
pour des exemples.
</p>

<p>
Pour envoyer leurs ebuilds au CVS, tous les développeurs doivent utiliser 
<c>repoman commit</c> plutôt que <c>cvs commit</c>. Avant tout commit,
exécutez <c>repoman full</c> pour vous assurer de n'avoir rien oublié.
</p>

</body>
</section>

<section>
<title>Politique de commit CVS</title>
<body>

<ul>
<li>Exécutez systématiquement <c>repoman scan</c> avant tout commit.</li>
<li>Exécutez systématiquement <c>repoman full</c> avant tout commit.</li>
<li>Vérifiez toujours que <path>package.mask</path> est correct en faisant 
<c>emerge --pretend mypkg</c> avant le commit, et assurez qu'il n'y a aucun 
conflit.</li>
<li>Mettez toujours le <path>ChangeLog</path> à jour avant le commit.</li>
<li>Effectuez toujours un commit du <path>package.mask</path> mis à jour 
avant celui du paquet mis à jour, au cas où des conflits se produiraient 
lorsque vous envoyez <path>package.mask</path>.</li>
<li>Faites toujours des commits atomiques. Si vous devez envoyer un paquet
avec une nouvelle licence, envoyez d'abord le <path>package.mask</path> corrigé, 
puis envoyez l'ebuild, le <path>ChangeLog</path> et la licence en un seul coup, 
à moins que vous ne teniez à détruire les installations des utilisateurs.</li>
</ul>

</body>
</section>

<section>
<title>Le sous-répertoire files</title>
<body>

<p>
Comme mentionné un peu plus haut, dans le répertoire de chaque paquet se trouve
un sous-répertoire <path>files</path>.  Tout patch, tout fichier de
configuration ou tout autre fichier auxiliaire utile pour le paquet doit être
ajouté dans ce sous-répertoire. Il est préférable de nommer ces patchs avec un
numéro de version spécifique comme <path>mypkg-1.0-gentoo.diff</path> ou, plus
simplement, <path>1.0-gentoo.diff</path>.  Notez que l'extension
<path>gentoo</path> signale que ce paquet a été créé par nous, les développeurs
de Gentoo Linux et non récupéré sur une liste de diffusion ou ailleurs. De
nouveau, ne compressez jamais ces correctifs, car cvs ne gère pas très bien les
fichiers compressés.
</p>

<p>
Pensez à ajouter un suffixe ou un préfixe comme <path>mypkg-1.0</path> au nom
de chaque fichier que vous mettez dans le répertoire <path>files</path> de
sorte que les fichiers utilisés pour des versions spécifiques de votre script
ebuild soient distinguables les uns des autres et que les modifications d'une
version à l'autre soient visibles. C'est en général plutôt une bonne idée. :)
Vous pouvez bien sûr utiliser un suffixe différent si une précision plus grande
est requise.
</p>

<p>
Si de nombreux fichiers doivent aller dans le répertoire <path>files/</path>, 
pensez à créer des sous-répertoires appelés <path>files/1.0/</path> et à 
mettre les fichiers concernés dans le sous-répertoire ad hoc. Si vous utilisez 
cette méthode, vous n'avez pas besoin d'ajouter d'information sur le numéro de 
version dans les noms des fichiers, ce qui est souvent plus pratique.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Les scripts d'ebuild</title>
<section>
<title>Introduction</title>
<body>

<p>
Les scripts d'ebuild sont la base de tout le système Portage. Ils contiennent
toute l'information requise pour télécharger, décompresser, compiler et
installer un ensemble de sources ainsi que pour réaliser toutes les éventuelles
opérations pré/post (dés-)installatoires ou encore les fonctions de
configuration.  Même si la plus grande partie de Portage est écrite en Python,
les ebuilds eux-mêmes sont écrits en bash puisque utiliser bash permet
d'appeler des commandes comme nous le ferions depuis la ligne de commande.  Un
des principes fondamentaux des scripts ebuild est que les commandes qui y sont
incluses soient analogues à celles utilisées en ligne de commande lors d'une
installation manuelle. Dans cette optique, l'utilisation de la syntaxe bash est
une très bonne chose.
</p>

<p>
Les scripts ebuild sont interprétés par les commandes <c>ebuild</c> et 
<c>emerge</c>. Imaginez la commande <c>ebuild</c> comme un outil de 
compilation de bas niveau. Il peut construire et installer un ebuild 
unique, mais rien de plus. Il va vérifier si les dépendances sont 
satisfaites, mais il ne va pas les résoudre lui-même. D'un autre côté, 
<c>emerge</c> est une interface de haut niveau pour <c>ebuild</c> 
qui a la capacité d'installer automatiquement les dépendances si c'est 
nécessaire, de réaliser des <e>pseudo</e> installations pour indiquer 
à l'utilisateur quels ebuilds pourraient être installés, et bien plus 
encore. Dans l'ensemble, <c>emerge</c> fait mieux que <c>ebuild</c>, 
sauf sur un point. Avec <c>ebuild</c>, vous pouvez réaliser une 
installation de paquet pas à pas (récupération des sources, 
décompression, compilation, installation, fusion). 
Pour les développeurs, c'est un outil de débogage inestimable, car 
il permet d'isoler les problèmes d'un ebuild aux portions spécifiques à 
chaque étape de la procédure d'installation.
</p>

</body>
</section>
<section>
<title>Nommer les fichiers ebuild</title>
<body>

<p>
Les noms d'ebuilds se décomposent en quatre parties&nbsp;:
</p>

<p>
La première est le nom du paquet qui ne doit contenir que des minuscules, les
chiffres 0-9 et un nombre indéfini de tirets ou de caractères de soulignement.
Quelques exemples&nbsp;: <c>util-linux</c>, <c>sysklogd</c>, <c>mod_php</c> et
<c>glibc</c>.
</p>

<p>
La deuxième partie est la version du paquet qui devrait normalement être la
version de la principale archive de sources. La version est normalement
composée de deux ou trois nombres séparés par des points comme <c>1.2</c> ou
<c>4.5.2</c> (mais toute séquence de nombres séparés par des points <e>est</e>
supportée) qui peuvent se terminer par un caractère simple comme <c>1.4b</c> or
<c>2.6h</c>. La version du paquet est ajoutée à la fin du nom du paquet avec
un tiret&nbsp;; par exemple&nbsp;: <c>foo-1.0</c>, <c>bar-2.4.6</c>, etc.
</p>

<impo>
Si vous voulez utiliser la lettre suivant votre numéro de version, notez bien
qu'elle ne doit <e>pas</e> être utilisée pour signifier le statut alpha ou bêta
du paquet puisque les alphas et les bêtas sont des <e>pré-versions</e> alors
que les version avec une lettre sont de <e>nouvelles versions</e>. Ceci peut
être vraiment important puisque Portage utilise le numéro de version d'un
ebuild pour déterminer s'il est plus récent ou plus ancien que les autres
paquets qui ont la même catégorie et le même nom. Il est vraiment important que
les numéros de version des paquets représentent exactement la version du paquet
pour que Portage puisse vérifier les informations de dépendances correctement.
</impo>

<p>
La troisième partie (optionnelle) contient un suffixe spécial parmi les
suivants&nbsp;: <c>_alpha</c>, <c>_beta</c>, <c>_pre</c> (pré-version),
<c>_rc</c> (version candidate) ou <c>_p</c> (patch). Chacun de ces suffixes
doit être immédiatement suivi d'un nombre, par exemple
<c>linux-2.4.0_pre10</c>&nbsp;; pour deux versions identiques, un paquet en
<c>_alpha</c> est plus vieux qu'un autre en <c>_beta</c>, lui même plus vieux
qu'un <c>_pre</c> qui est à son tour plus vieux qu'un <c>_rc</c>, ce dernier
étant pour finir plus vieux qu'un <c>_p</c>. Cette section ne s'applique que
pour les versions en amont d'une version stable.
</p>

<note>
Un paquet en <c>_rc</c> est plus ancien qu'un autre sans suffixe souligné
(comme <c>linux-2.4.0</c>) et <c>linux-2.4.0</c> est plus vieux qu'un paquet
dont la version se termine par un caractère simple, comme <c>linux-2.4.0b</c>.
Et comme vous pouvez vous y attendre, <c>linux-2.4.0b</c> est considéré comme
plus vieux que <c>linux-2.4.0c</c>. Encore une fois, les informations de
version sont primordiales, puisque Portage les utilise pour déterminer si
l'ebuild d'un paquet ou un autre est plus ancien ou plus récent qu'un autre
pour la même catégorie et le même nom.
</note>

<p>
La quatrième partie (elle aussi optionnelle) du nom de paquet est spécifique à
Gentoo-Linux et indique le numéro de <e>révision</e> qui est spécifié par le
suffixe <c>-r#</c>, où <c>#</c> est un entier, par exemple
<c>package-4.5.3-r3</c>.  Ce numéro de révision est indépendant de la version
des sources du paquet et est utilisé pour informer les utilisateurs qu'une
version améliorée des scripts Gentoo Linux est disponible pour un paquet donné.
</p>

<p>
Si vous faites des modifications non triviales à un fichier ebuild existant, il
est préférable de copier cet ebuild dans un nouveau fichier et d'incrémenter le
numéro de révision de 1. Les versions originales n'ont habituellement pas de
numéro de révision, par exemple <path>package-4.5.3</path> et Portage considère
que leur numéro de révision est nul. Ce qui signifie que l'ordre de décompte
est le suivant&nbsp;: <c>1.0</c> (version initiale), <c>1.0-r1</c>,
<c>1.0-r2</c>, etc. N'oubliez <e>jamais</e> de décrire vos changements dans le
<path>ChangeLog</path>. Vous aurez des ennuis sérieux si vous ne le faites pas,
votre accès au CVS pourrait être révoqué.
</p>

<p>
... et je suppose qu'il y a une <e>cinquième</e> section dans le nom de l'ebuild 
-- l'extension <c>.ebuild</c> elle-même.
</p>

</body>
</section>
<section>
<title>Contenu d'un fichier <e>ebuild</e></title>
<body>

<note>
Cette section est une introduction aux ebuilds. Pour une liste exhaustive de
tout ce qu'il est possible de faire dans un ebuild, il existe une page de man
décrivant le format interne, les variables et les fonctions utilisés dans un
script d'ebuild&nbsp;: <c>man 5 ebuild</c>.
</note>

<p><b>Variables</b></p>

<p>
La première partie d'un fichier ebuild comporte un certain nombre
d'initialisations de variables. Elles se répartissent en trois catégories (et
sont désignées par la suite avec les noms correspondants)&nbsp;:
</p>

<ul>
<li>READ: variables que vous pouvez utiliser mais <e>jamais modifier</e></li>
<li>MUST: variables que vous <e>devez toujours initialiser</e></li>
<li>OPT: variables que vous pouvez modifier</li>
</ul>

<table>
<tr>
  <th>Variable</th>
  <th>Utilisation</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Le nom et la version du paquet.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Le nom du paquet.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>La version du paquet.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>Contient le numéro de révision ou <c>r0</c> s'il n'existe pas de numéro de version.</ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Contient le numéro de version et de révision.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Contient le nom complet du paquet <c>${PN}-${PV}-${PR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Liste des noms des fichiers inclus dans <c>SRC_URI</c> délimités par des espaces.
    Cela n'inclut pas les chemins URL, juste les noms de fichiers.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Racine du répertoire de construction pour cet ebuild. Rien ne doit être construit 
    en dehors de ce répertoire.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Contient le chemin vers le sous-répertoire <path>files</path> dans
    l'emplacement spécifique du paquet dans l'arbre de portage. Ne modifiez pas
    cette variable.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Le répertoire des sources de votre paquet&nbsp;; généralement <c>${WORKDIR}/${P}</c>.
    Portage utilisera cette valeur par défaut, donc vous n'aurez probablement pas à
    la modifier.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Le répertoire temporaire pour votre paquet. Il est utilisé comme un répertoire 
    <path>/tmp</path> virtuel pendant le traitement de l'ebuild.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Le répertoire racine dans lequel le paquet est installé, considérez-le
    comme un <path>/</path> virtuel.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage gère plusieurs versions d'un même programme installé. Pour avoir,
    par exemple, GCC 2.95 et GCC 3.2 installés en même temps, vous devrez
    spécifier le <c>SLOT</c> dans chaque ebuild. Dans ce cas, le <c>SLOT</c> 
    de GCC 2.95 serait <c>2</c> et celui de GCC 3.2 serait <c>3</c>.
    <note>
    Utiliser la valeur <c>0</c> pour le <c>SLOT</c> signifie que votre paquet
    n'a qu'un <c>SLOT</c> (en d'autres termes, ce paquet n'est pas
    «&nbsp;SLOTable&nbsp;»).
    </note>
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Cette variable spécifie la licence qui couvre le programme, par ex. GPL-2, 
    BSD, etc. Ce champ doit contenir une licence valide (c-à-d. une de celles 
    trouvées dans <path>/usr/portage/license/</path>). Si la licence ne figure pas 
    encore dans ce dernier fichier, elle doit y être ajoutée avant que l'ebuild 
    ne puisse être ajouté à l'arbre de portage. 
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Cette variable joue plusieurs rôles. Tout d'abord, elle spécifie à quelle
    architecture l'ebuild est destiné. Ces mots-clés comprennent&nbsp;: <e>x86,
    ppc, sparc, mips, alpha, arm, hppa, amd64, ia64</e>. Évidemment, vous
    devrez la définir en fonction des architectures visées. Portage ne
    permettra pas de construire autre chose que des ebuilds x86, selon ce qui
    est spécifié par la variable <c>KEYWORDS</c>, sur une machine x86. Les
    paquets qui ne supportent pas l'architecture native sont automatiquement
    masqués par Portage.  Si un paramètre de <c>KEYWORDS</c> est précédé d'un
    <e>~</e>, cela signifie que cet ebuild fonctionne, mais a besoin d'être
    testé dans différents environnements avant d'être marqué comme stable avec
    le mot-clé correspondant. Si un paramètre de <c>KEYWORDS</c> est précédé
    d'un <e>-</e>, alors l'ebuild ne fonctionne pas sur l'architecture
    correspondante.  Si rien ne précède un mot-clé de <c>KEYWORDS</c>, alors le
    paquet est considéré comme stable. Vous pouvez autoriser l'installation de
    ces différents types de paquets par la variable <c>ACCEPT_KEYWORDS</c> dans
    <path>make.conf</path>.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti>Une <e>courte</e> description en une ligne de votre paquet.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    Les URLs de tous les fichiers sources de votre paquet, séparées par des espaces.
    Normalement, la première ligne est quelque chose comme&nbsp;:
    «&nbsp;ftp://ftp.company.com/pub/somepackage/${P}.tar.bz2&nbsp;»
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    La page principale du paquet. Si vous n'en trouvez pas d'officielle, essayez 
    de fournir un lien sur <uri link="http://freshmeat.net/">freshmeat.net</uri> ou un
    autre site de suivi de paquets.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Décrit tous les paramètres <c>USE</c> que votre paquet utilise.  N'oubliez
    pas que les paramètres <c>KEYWORDS</c> ne doivent pas être listés
    ici&nbsp;!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Les dépendances à la construction du paquet sont listées ici.
    Voir la section <uri link="#doc_chap5">Dépendances des paquets</uri> pour
    plus de détails sur la syntaxe correcte.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Les dépendances à l'exécution du paquet sont listées ici. Encore une fois,
    voir la section <uri link="#doc_chap5">Dépendances des paquets</uri> pour
    plus de détails.
  </ti>
</tr>
</table>

<p><b>Fonctions</b></p>

<p>
Dans les fichiers ebuild, vous pouvez définir un certain nombre de fonctions
qui contrôlent la procédure de construction et d'installation de votre paquet.
</p>

<table>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Utilisez cette fonction pour effectuer diverses tâches pré-requises. Cela peut 
    comprendre l'ajout de comptes utilisateurs sur le système ou la recherche d'un
    fichier de configuration existant.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    Informe l'utilisateur d'actions nécessaires si, pour une raison quelconque
    (comme des problèmes de licence), les sources ne peuvent pas être
    téléchargées automatiquement par Portage. Utilisez ceci en conjonction avec
    <c>RESTRICT=&quot;fetch&quot;</c>.  Vous devez seulement afficher des
    messages avec cette fonction et ne jamais appeler <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Utilisez cette fonction pour désarchiver vos sources, appliquer des patchs
    et exécuter des programmes auxiliaires commes ceux des autotools. Par
    défaut, cette fonction désarchive les archives listées dans <c>A</c>. Le
    répertoire de travail initial est défini par <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Utilisez cette fonction pour configurer et construire le paquet. Le
    répertoire de travail initial est <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Utilisez cette fonction pour installer le paquet dans une image contenue
    dans <c>D</c>.  Si votre paquet utilise automake, vous pouvez faire cela
    simplement avec <c>make DESTDIR=${D} install</c>. <e>Verifiez que le paquet
    installe tous ses fichiers avec <c>D</c> comme racine&nbsp;!</e>  Le
    répertoire de travail initial est <c>S</c>. 
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Les commandes de cette fonction sont exécutées juste <e>avant de
    fusionner</e> le paquet avec le système de fichiers.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Les commandes de cette fonction sont exécutées juste <e>après avoir
    fusionné</e> le paquet avec le système de fichiers.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Les commandes de cette fonction sont exécutées juste <e>avant la
    suppression</e> du paquet du système de fichiers.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Les commandes de cette fonction sont exécutées juste <e>après la
    suppression</e> du paquet du système de fichiers.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Utilisez cette fonction pour mettre en place une configuration initiale
    pour le paquet après son installation. Tous les chemins doivent être
    préfixés avec <c>ROOT</c>.  Cette fonction n'est exécutée <e>que</e> quand
    l'utilisateur exécute&nbsp;:<c>ebuild
    /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>.
  </ti>
</tr>
</table>

<p><b>Fonctions utilitaires</b></p>

<p>
Vous pouvez aussi utiliser les fonctions suivantes dans vos ebuilds, pour plus
de convenance.
</p>

<table>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Vérifie si une ou plusieurs options USE sont définies. Si c'est le cas, la
    fonction renvoie les options qui sont définies dans <c>USE</c>. Pour
    vérifier l'existence d'une option USE, vous pouvez utiliser <c>[ `use
    foobar` ]</c>.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Retourne 1 si le système dispose de la version demandée d'un certain paquet.
    Par exemple <c>has_version >=glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Retourne la version <path>category/package-version</path> du paquet 
    <path>category/package</path> demandé. Par exemple <c>best_version 
    x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Cette fonction vérifie si une option USE a été définie et retourne 
    &quot;--with-foobar&quot; ou &quot;--without-foobar&quot; en fonction du 
    résultat.  Si vous ne donnez qu'un seul argument, celui-ci est à la fois
    l'option USE et &quot;chaîne&quot; dans &quot;with(out)-chaîne&quot;. Par exemple, 
    <c>use_with truetype freetype</c> retournera &quot;--with-freetype&quot; 
    si &quot;truetype&quot; est dans <c>USE</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Similaire à <c>use_with</c>, mais retourne &quot;--enable-foobar&quot; ou 
    &quot;--disable-foobar&quot; en fonction du résultat.
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Vérifie que Portage connaît la version du noyau. Dans le cas contraire, 
    affiche une erreur et appelle &quot;die&quot;. Si vous avez besoin de la version 
    du noyau dans votre script, utilisez la variable <c>KV</c> qui est 
    automatiquement définie par Portage. Sur un système utilisant 
    gentoo-sources-2.4.20-r6, <c>KV</c> aura la valeur &quot;2.4.20&quot;.
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Crée (si nécessaire), un fichier <path>.keep</path> dans le répertoire 
    concerné pour qu'il ne soit pas nettoyé automatiquement. Ne créez <e>jamais</e> 
    un fichier <path>.keep</path> vous-même. Si le fonctionnement de <c>keepdir</c> 
    change dans Portage, le fait de créer ce fichier vous-même rendra le paquet 
    non-fonctionnel.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Lance <c>./configure</c> avec les changements de chemin nécessaires
    (prefix, host, mandir, infodir, sysconfdir, localstatedir).  Vous pouvez le
    cas échéant passer des arguments supplémentaires à <c>./configure</c> en
    les spécifiant lorsque vous appelez <c>econf</c> ou en les définissant dans
    la variable locale <c>EXTRA_CONF</c>. La priorité des options passées à
    <c>configure</c> suit l'ordre inverse de celui dans lequel elles ont été
    données. En d'autres termes, le dernier argument qui lui est passé a
    toujours la priorité sur le premier.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Lance <c>make install</c> avec les changements de chemin nécessaires
    (prefix, host, mandir, infodir, sysconfdir, localstatedir).  Ici encore,
    vous pouvez passer des arguments supplémentaires à la commande <c>make</c>
    en les spécifiant lorsque vous appelez <c>einstall</c>. Notez que la
    manière préférée d'installer un paquet consiste à appeler <c>make install
    DESTDIR=${D}</c> plutôt que <c>einstall</c>. Cette commande n'est qu'une
    solution de remplacement dans le cas de fichiers make non convenables.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Arrête le processus en cours. L'utilisateur sera informé de la raison 
    par l'affichage des arguments. N'omettez pas d'écrire un message dans 
    les arguments de <c>die</c>, si vous l'appelez en plusieurs points dans 
    le corps d'une même fonction. Il est plus difficile de comprendre une 
    erreur si vous ne savez pas <c>à quel endroit</c> le paquet à échoué.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Informe l'utilisateur de quelque chose d'important. L'argument donné à 
    <c>einfo</c> est le message que l'utilisateur verra. N'utilisez pas 
    <c>einfo</c> pour afficher des bannières telles que
    &quot;*************************************&quot;.  Le fait que vous 
    utilisiez <c>einfo</c> est suffisant pour attirer l'attention de l'utilisateur.
  </ti>
</tr>
</table>

</body>
</section>
<section>
<title>Règles pour écrire des fichiers ebuild</title>
<body>

<p>
Comme les fichiers ebuild ne sont en fait que des scripts shell, vous devriez
utiliser le mode script shell de votre éditeur pour les éditer. Vous devriez
utiliser une indentation correcte avec seulement des caractères de tabulation
(<e>pas d'espaces</e>).  Configurez votre éditeur pour qu'il arrête les
tabulations à 4 espaces. Mettez toujours des accolades autour des variables
d'environnement, par ex. <c>${P}</c> plutôt que simplement <c>$P</c>. 
</p>

<p>
Les lignes trop longues sont scindées en utilisant le caractère '\', comme
suit&nbsp;:   
</p>

<pre caption="Scinder les lignes dans les ebuilds">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Pour plus de détails, voir <path>skel.ebuild</path> qui se trouve 
généralement dans <path>/usr/portage</path>.
</p>

<p>
Si vous utilisez Vim, vous pouvez placer les lignes suivantes à la 
fin de votre .vimrc pour faire en sorte d'utiliser la bonne configuration 
lorsque vous éditez des fichiers Gentoo.
</p>

<pre caption="Configuration de vimrc pour éditer des ebuilds">
if (getcwd() =~ 'gentoo-x86\|gentoo-src\|portage')
  set tabstop=4 shiftwidth=4 noexpandtab
endif
</pre>

<p>
Si vous utilisez Emacs, vous pouvez placer les lignes suivantes à la fin 
de votre fichier .emacsrc (pour GNU Emacs) ou init.el (pour XEmacs) pour faire 
en sorte d'utiliser la bonne configuration lorsque vous éditez des fichiers Gentoo.
</p>

<pre caption="Configuration de emacsrc pour éditer des ebuilds">
(defun ebuild-mode ()
  (shell-script-mode)
  (sh-set-shell "bash")
  (make-local-variable 'tab-width)
  (setq tab-width 4))
(setq auto-mode-alist (cons '("\\.ebuild\\'" . ebuild-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.eclass\\'" . ebuild-mode) auto-mode-alist))
</pre>

<p>
Si vous utilisez nano, vous êtes chanceux&nbsp;! Editez simplement
<path>/etc/nanorc</path> et décommentez la section concernant les ebuilds. 
</p>

</body>
</section>
<section>
<title>Variables <c>USE</c></title>
<body>

<p>
Le but des variables USE est de vous permettre de configurer Portage pour
activer ou désactiver globalement et automatiquement certaines <e>options de
compilation</e>. Un exemple&nbsp;: imaginons que vous êtes un fan de GNOME et
que vous souhaitez que toutes les applications soient compilées avec le support
GNOME. Dans ce cas, il suffit d'ajouter <c>gnome</c> à votre variable
<c>USE</c> dans <path>/etc/make.conf</path> et Portage va automatiquement
ajouter les fonctionnalités GNOME optionnelles aux nouveaux paquets si c'est
possible.  De même, si la compatibilité GNOME ne vous intéresse pas et que vous
désirez que les ebuilds ne l'utilisent pas, il suffit d'éditer
<path>/etc/make.conf</path> et de faire en sorte que <c>gnome</c> ne soit
<e>pas</e> activé dans la variable <c>USE</c>. Gentoo Linux comprend un nombre
impressionnant d'options pour <c>USE</c> qui vous permettent de configurer
votre machine exactement comme vous l'entendez.
</p>

<note>
Si vous désactivez une variable USE (par exemple, enlever <c>gnome</c> de
<c>USE</c>), cela va dire à Portage de désactiver le support GNOME
<e>optionnel</e> à la compilation.  Mais si vous lancez un emerge sur une
application qui <e>nécessite</e> GNOME, le paquet va évidemment inclure le
support GNOME, comme on peut s'y attendre. Cela signifie en particulier que
GNOME sera installé automatiquement (en tant que dépendance) s'il ne l'était
pas déjà.  C'est pour ça que c'est une bonne idée de faire un <c>emerge
--pretend</c> avant de faire le «&nbsp;vrai&nbsp;» <c>emerge</c>&nbsp;; de
cette manière, vous saurez toujours ce que vous installez.
</note>

<p>
Dans vos propres ebuilds, vous pouvez vérifier si une variable est incluse ou non en 
utilisant la commande <c>use &lt;variable&gt;</c>. La commande <c>use</c> affiche le 
nom de chaque variable présente à la fois dans <c>USE</c> et sa ligne de commande. 
Cette commande s'utilise normalement comme suit&nbsp;:
</p>

<pre caption="Détecter si une option USE est activée">
if [ `use X` ] ; then
  commandes spécifiques à X
fi
</pre>

<p>
Les variables USE peuvent aussi être utilisées pour définir les dépendances.
Par exemple, vous pouvez dépendre d'un paquet si et seulement si une certaine
variable USE est activée. Ce qui se gère avec la commande <c>variable? (
mycat/mypackage-1.0-r1 )</c> dans la variable DEPEND de votre ebuild. Dans cet
exemple, <c>mycat/mypackage-1.0-r1</c> ne sera requis que si <c>variable</c>
est présent dans <c>USE</c>. Il est de plus possible de spécifier quelle
dépendance doit être utilisée si un paramètre USE est défini, et quelle
dépendance utiliser s'il ne l'est <e>pas</e>&nbsp;: <c>variable? (
mycat/mypackage) : ( othercat/otherpackage )</c>. Dans ce cas, si
<c>variable</c> n'est pas définie, <c>othercat/otherpackage</c> est utilisé au
lieu de <c>mycat/mypackage</c>.  Enfin, vous pouvez aussi spécifier une
dépendance dans le cas où une certaine variable n'est <e>pas</e> définie.
Préfixez simplement la variable avec &quot;!&quot;, comme ceci&nbsp;:
<c>!variable? ( mycat/mypackage )</c>. Utilisez cette syntaxe et non les
&quot;if&quot; de Bash. Les structures conditionnelles de Bash interfèrent avec
la mise en cache des dépendances par Portage, et leur utilisation rendrait
votre ebuild inutilisable.
</p>

<p>
Il y a une astuce importante à connaître sur <c>USE</c>. La plupart du temps,
un paquet utilise un script <c>./configure</c> pour réaliser sa configuration.
En général, si votre ebuild utilise <c>./configure</c>, toute fonctionnalité
est activée ou désactivée en passant les arguments appropriés à la commande
<c>./configure</c>. Voici le meilleur moyen de le faire&nbsp;: 
</p>

<pre caption="Options en fonction des paramètres USE">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 ) : ( =net-www/apache-1.* )"

src_compile() {
  econf \
    `use_enable X x11` \
    `use_enable mysql` \
    || die "configure failed"
  emake || die "emake failed";
}
</pre>

<p>
Cette approche a un résultat très satisfaisant. Nous n'avons pas à nous 
préoccuper de la configuration par défaut pour mysql ou X (activé ou non),
nous disons explicitement à <c>econf</c> que nous voulons qu'il fasse les 
choses en fonction de la variable <c>USE</c>. Qui plus est, c'est très lisible :)
</p>

<p>
Pour consulter un tableau continuellement mis à jour des variables USE, lisez 
<uri link="http://www.gentoo.org/dyn/use-index.xml">ceci</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Organisation du système de fichiers</title>
<section>
<title>Introduction au FHS</title>
<body>

<p>
Les principes d'organisation du système de fichiers utilisés dans Gentoo Linux
suivent rigoureusement le FHS (<e>Filesystem Hierarchy Standard</e> ou
«&nbsp;standard de système de fichiers hiérarchique&nbsp;»). Une description
simplifiée de ce standard est donné ici, pour plus de détails, allez sur
<uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
La hiérarchie de <path>/opt</path> est traitée dans la section 3.12 du FHS.
La section 4.4 concerne le répertoire <path>/usr/X11R6</path>. KDE et GNOME ne 
sont pas spécifiquement traités et ne sont en fait même pas mentionnés dans 
la version actuelle du FHS.
</note>

</body>
</section>
<section>
<title>Comment insérer des paquets dans le système de fichiers</title>
<body>

<p>
Habituellement, si le paquet utilise autoconf/automake, la destination
d'installation par défaut est souvent correcte avec quelques exceptions&nbsp;: 
</p>

<ul>
<li>
Si vous installez un programme dans <path>/bin</path>, <path>/sbin</path>,
<path>/usr/bin</path> ou <path>/usr/sbin</path>, alors les pages de manuel
correspondantes doivent êtres installées dans <path>/usr/share/man</path>.
Ceci peut très souvent être obtenu en spécifiant <c>./configure
--mandir=/usr/share/man</c> dans l'ebuild.
</li>
<li>
Les fichiers d'info GNU doivent toujours être installés dans
<path>/usr/share/info</path>, <e>même pour les fichiers relatifs à X11, GNOME
ou des applications spécifiques à KDE</e>. Notez bien que
<path>/usr/share/info</path> est le <e>seul</e> emplacement officiel pour
installer des fichiers info GNU.  Comme beaucoup de scripts <c>./configure</c>
installent les fichiers d'info dans <c>/usr/info</c> par défaut, il est souvent
nécessaire d'appeler <c>./configure</c> avec l'argument
<c>--infodir=/usr/share/info</c>.
</li>
<li>
Les fichiers de documentation sont installés dans <path>/usr/share/doc</path>
dans un sous-répertoire contenant le nom, la version et la révision du
programme concerné. Ceci s'applique à tous les types programmes&nbsp;: GNOME,
KDE, X11 ou console. En revanche, les programmes peuvent installer leur
documentation dans un sous répertoire de <path>/usr/share</path> avec leur
propre hiérarchie.
</li>
<li>
Les programmes et les bibliothèques spécifiques à X11 sont toujours installés
dans <path>/usr</path> et non directement dans <path>/usr/X11R6</path>.  Nous
conservons l'arborescence de <path>/usr/X11R6</path> pour le système de
fenêtres X, Version 11 Release 6 <e>lui-même</e>. C'est peut-être une
interprétation plus rigoureuse de la FHS que celle de certaines distributions.
</li>
<li>
Les applications GNOME et KDE doivent, de manière similaire, toujours être
installées dans <path>/usr</path>.
</li>
</ul>

<impo>
Certaines distributions choisissent d'installer GNOME et KDE dans <path>/opt</path>. 
Il n'y a pas de standard pour ces environnements de travail, du moins en ce qui 
concerne le lieu d'installation de leurs fichiers. Dans un but de simplicité et 
de logique, nous avons choisi d'installer les paquets GNOME et KDE dans l'arborescence 
<path>/usr</path>.
</impo>

<p>
En général, les ebuilds installent leurs fichiers dans <path>/usr</path> directement. 
<e>Certains</e> programmes sont compilés et liés avec ou sans les bibliothèques GNOME,
KDE ou X11, ce qui peut créer du désordre. Notre solution est de tout installer dans 
<path>/usr</path>, ce qui évite des ambiguïtés et une complexité inutile pour les auteurs 
d'ebuilds.  L'endroit où installer les fichiers d'un programme ne doit <e>pas</e> dépendre
de la présence ou de l'absence de certaines variables spécifiques de <c>USE</c>. C'est 
pourquoi les ebuilds de l'arbre Portage installent <e>le plus souvent</e> les 
fichiers exclusivement dans <path>/usr</path>.
</p>

<note>
Le répertoire <path>/opt</path>, dans Gentoo Linux, est réservé aux paquets
binaires.  Par exemple&nbsp;: mozilla-bin, acroread, netscape et realplayer.
Ces paquets nécessitent en général un fichier <path>/etc/env.d/foo</path> dans
le but d'inclure les chemins et les variables additionnelles dans
l'environnement. Pour plus d'informations sur <path>/etc/env.d</path>,
consultez <uri link="http://www.gentoo.org/doc/fr/env.d-howto.xml"> ce
document</uri>.
</note>

</body>
</section>
</chapter>
<chapter>
<title>Les scripts et utilitaires de Portage</title>
<section>
<title>Les scripts publics</title>
<body>

<p>
Ce sont des scripts utilisés par l'administrateur système pour installer ou 
retirer des paquets et maintenir la base de donnés des paquets.
</p>

<p>
<c>ebuild</c> est l'outil principal du système Portage&nbsp;; il réalise toutes
les tâches majeures telles que décompresser, compiler, installer, fusionner et
enlever des paquets. Il est appellé par la commande <c>ebuild
chemin/vers/package.ebuild commande</c>. Les commandes disponibles sont&nbsp;:
</p>

<table>
<tr>
  <th>Commande</th>
  <th>Description</th>
  <th>Fonction appelée dans le fichier <c>ebuild</c></th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Exécute toute commande préparatoire nécessaire avant de lancer l'ebuild
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>
    Affiche les dépendances nécessaires à la construction de l'ebuild
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Décompresse, compile, installe et fusionne le paquet dans le système de fichiers
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Fusionne le paquet dans le système de fichiers en supposant que la décompression, 
    la compilation et l'installation ont déjà été réalisées
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Décompresse l'archive des sources dans le répertoire de travail
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Compile le paquet</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Crée un rpm depuis le paquet</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Crée un paquet Gentoo (<c>tbz2</c>)</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Réalise la phase préparatoire à la suppression du paquet</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Réalise la phase post-suppression de la désinstallation d'un paquet</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Réalise la phase pré-installatoire du paquet</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Réalise la phase post-installatoire du paquet</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Génère une configuration par défaut, une fois que le paquet est fusionné</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Met à jour le mtimes pour chaque archive de sources du paquet</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Nettoie le répertoire de travail pour le paquet</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Récupère les sources du paquet</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Crée un fichier digest avec les sommes de contrôle pour le paquet</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Installe le paquet dans le répertoire image</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Désinstalle le paquet du système de fichiers</ti>
  <ti>N/A</ti>
</tr>
</table>

<note>
Les commandes avec un astérisque (*) sont normalement utilisées uniquement 
par les développeurs.
</note>

<p>
<c>emerge</c> fusionne récursivement les paquets et toutes leurs dépendances 
dans le système de fichiers. Cette commande supporte de nombreuses options 
dont la liste est accessible par un <c>emerge --help</c>.
</p>

<p>
<c>env-update</c> met à jour les fichiers de configuration (en particulier,
mais pas uniquement, <path>/etc/ld.so.conf</path> et
<path>/etc/profile.env</path>) pour prendre en compte les modifications faites
par l'installation des paquets.
</p>

</body>
</section>
<section>
<title>Scripts et commandes privées</title>
<body>

<p>
Ce sont des scripts que vous pouvez utiliser dans vos ebuilds pour
réaliser des tâches courantes.
</p>

<p>
Si vous êtes pressé et/ou acharné, vous pouvez consulter les scripts 
eux-mêmes dans <path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Commande</th>
  <th>Valeur par défaut</th>
  <th>Description</th>
  <th>Exemple</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Définit les options utilisées à l'exécution de <c>dodir</c></ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>N/A</ti>
  <ti>Installe les binaires spécifiés dans <path>DESTTREE/bin</path></ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Définit le sous-répertoire relatif (<e>DOCDESTTREE</e>) utilisé par <c>dodoc</c> 
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>N/A</ti>
  <ti>Crée un répertoire en utilisant ${D} de manière transparente</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers spécifiés dans le répertoire de documentation du paquet 
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (voir <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers spécifiés avec le mode <e>EXEOPTIONS</e> (voir 
    <c>exeopts</c>) dans <path>EXEDESTTREE</path> (voir <c>exeinto</c>)
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>N/A</ti>
  <ti>Crée un lien dur en utilisant ${D} de manière transparente</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers et répertoires spécifiés dans
    <path>/usr/share/doc/${PF}/html</path> 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers spécifiés dans <path>/usr/share/info</path> 
    et les compresse ensuite avec gzip
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers spécifiés avec le mode <c>INSOPTIONS</c> (voir 
    <c>insopts</c>) dans <path>INSDESTTREE</path> (voir <c>insinto</c>)
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les bibliothèques spécifiées dans <path>DESTTREE/lib</path> avec 
    le mode 0644 
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les bibliothèques spécifiées dans <path>DESTTREE/lib</path> 
    avec le mode 0644
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les bibliothèques spécifiées dans <path>DESTTREE/lib</path> 
    avec le mode 0755
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe les fichiers spécifiés dans <path>/usr/share/man/manX</path>, 
    avec le suffixe X adapté (fichier.1 va dans <path>man1</path>)
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installe des binaires dans <path>DESTTREE/sbin</path> et les 
    rend exécutables
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>N/A</ti>
  <ti>Crée un lien symbolique en utilisant ${D} de manière transparente</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>N/A</ti>
  <ti>
    Lance make avec les options <c>MAKEOPTS</c>. Certains paquets ne peuvent 
    pas être compilés en parallèle, utilisez alors <c>emake -j1</c>
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>
    Définit la racine de l'arborescence (<e>EXEDESTTREE</e>) pour la commande
    <c>doexe</c></ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Définit les options utilisées lors de l'appel à <c>doexe</c></ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>N/A</ti>
  <ti>
    Applique la propriété spécifiée (premier argument) au fichier spécifié 
    (second argument) via la commande chown, gère ${D} de manière transparente
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>N/A</ti>
  <ti>
    Applique les permissions spécifiées (premier argument) aux fichiers 
    spécifiés (second argument) via la commande chmod, gère ${D} de 
    manière transparente
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Définit la racine de l'arborescence (<e>INSDESTTREE</e>) pour la commande
    <c>doins</c></ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Définit les options utilisées lors de l'appel à <c>doins</c></ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Définit le répertoire cible (<path>DESTTREE</path>) pour toutes les commandes
    'do' (comme <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, 
    <c>domo</c>, <c>dosbin</c>)
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Définit les options utilisées lors de l'appel à <c>dolib</c></ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>dobin</c> et installe le binaire spécifié (premier argument)
    dans <path>DESTTREE/bin</path> en le renommant en le second argument
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>dodoc</c> et installe le fichier spécifié (premier argument)
    de manière transparente en le renommant en le second argument
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>doexe</c> et installe le fichier spécifié (premier argument)
    de manière transparente en le renommant en le second argument
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>doins</c> et installe le fichier spécifié (premier argument)
    de manière transparente en le renommant en le second argument
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>doman</c> et installe le fichier spécifié (premier argument)
    de manière transparente en le renommant en le second argument
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Encapsule <c>dosbin</c> et installe le fichier spécifié (premier argument)
    de manière transparente en le renommant en le second argument
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>N/A</ti>
  <ti>
    Exécute <c>prepallman</c>, <c>prepallinfo</c> et <c>prepallstrip</c>.
    Vérifie que toutes les bibliothèques dans <path>/opt/*/lib</path>,
    <path>/lib</path>, <path>/usr/lib</path> et <path>/usr/X11R6/lib</path>
    sont exécutables.  Déplace enfin toutes les macros aclocal dans
    <path>/usr/share/aclocal</path>
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>N/A</ti>
  <ti>
    Compresse récursivement avec gzip tous les fichiers de documentation
    dans <path>/usr/share/doc</path> en gérant les liens symboliques de 
    manière transparente.
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Compresse récursivement avec gzip tous les fichiers info dans 
    <path>/usr/share/info</path>
  </ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>N/A</ti>
  <ti>
    Compresse récursivement avec gzip toutes les pages de man dans 
    <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>, 
    <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path> 
    en gérant les liens symboliques de manière transparente
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</section>
</chapter>
<chapter>
<title>Les dépendances de paquets</title>
<section>
<title>Pourquoi les dépendances sont importantes</title>
<body>

<p>
Portage est un peu plus qu'un script pratique qui vous offre une méthode 
unifiée pour construire n'importe quel projet (programme, bibliothèque) à partir
des sources. Il permet aussi de récupérer et d'installer toutes les dépendances 
nécessaires pour peu que vous fassiez bien attention à les spécifier dans l'ebuild.
</p>

<p>
Dans les ebuilds officiels, les dépendances ont déjà été spécifiées, ainsi, si 
vous faites un <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage va s'assurer 
que les bibliothèques nécessaires à la compilation et à l'exécution de mozilla 
sont bien installées avant que Mozilla ne soit lui-même construit.
</p>

<p>
Portage distingue même les dépendances à la construction des dépendances
à l'exécution. Remarquez que, pour le moment, Portage installe toutes les 
dépendances et laisse les choses en l'état. Dans un futur proche, il sera 
possible de désinstaller les dépendances de compilation pure et de 
n'installer que les dépendances à l'exécution.
</p>

</body>
</section>
<section>
<title>Comment spécifier des dépendances dans votre fichier ebuild</title>
<body>

<p>
La variable <c>DEPEND</c> dans votre ebuild <path>foo-x.y.z.ebuild</path> 
spécifie à Portage quels paquets sont requis pour construire 
<path>foo</path>. La variable <c>RDEPEND</c> spécifie quels paquets sont 
nécessaires pour que le paquet spécifié puisse s'exécuter.
</p>

<pre caption="Exemple de dépendances">
DEPEND="virtual/glibc
        sys-libs/zlib"
RDEPEND="virtual/glibc"
</pre>

<p>
Cela spécifie à Portage que pour construire <path>foo-x.y.z</path>, les paquets 
<path>virtual/glibc</path> et <path>sys-libs/zlib</path> sont requis.  Cela ne dit 
rien sur les versions de la glibc ou de zlib qui sont requises et signifie donc que
n'importe lesquelles conviennent.
</p>

<p>
Ce «&nbsp;n'importe lesquelles conviennent&nbsp;» est un peu effrayant et ne
fonctionne pas, en général.  Mais pour des bibliothèques importantes comme la
glibc qui est particulièrement étudiée pour être toujours 100% compatible, cela
fonctionne. Pour d'autres bibliothèques, on peut bien sûr spécifier la version
dans la dépendance. 
</p>

<pre caption="Exemple avec un numéro de version">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= et = font ce à quoi on peut s'attendre&nbsp; sys-apps/bar version 1.2 ou
plus récent est bon (ce qui signifie que sys-apps/bar-2.0 est accepté), alors
que la version 1.0 de sys-apps/baz est la seule acceptée. Pour plus
d'information sur le schéma de version des paquets, voir la section <uri
link="doc_chap2_sect2"> nommer les fichiers ebuild</uri> plus haut.
</p>

<p>
Voici les autres méthodes pour spécifier les dépendances&nbsp;:
</p>

<pre caption="Spécifier les dépendances de version">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 va sélectionner la révision la plus récente de qux-1.0
</p>

<p>
=sys-apps/foo-1.2* va sélectionner le membre le plus récent de la branche 
1.2, mais va ignorer les branches 1.3 et suivantes ou précédentes. 
C'est-à-dire que foo-1.2.3 et foo-1.2.0 sont tous les deux valides, mais 
que foo-1.3.3, foo-1.3.0 et foo-1.1.0 ne le sont pas.
</p>

<p>
!sys-libs/gdbm empêchera ce paquet d'être installé si gdbm est déjà installé.
</p>

<note>
Pour les derniers détails sur les symboles utilsés par DEPEND, veuillez
consulter la page de man de la section 5 sur les ebuilds. <c>man 5 ebuilds</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Tests et déploiement</title>
<section>
<title>ChangeLog</title>
<body>

<p>
Chaque fois que vous mettez à jour un ebuild (ou en écrivez un nouveau), vous 
devez aussi mettre à jour (ou écrire) le fichier ChangeLog en y rapportant 
les changements effectués. Le fichier <path>skel.ChangeLog</path> contient 
un exemple de ChangeLog que vous pouvez utiliser comme point de départ.
</p>

<p>
Le but du ChangeLog est de documenter <e>ce qui</e> est fait, <e>pourquoi</e>
cela est fait et par <e>qui</e>. Cela permet aussi bien aux développeurs 
qu'aux utilisateurs de suivre aisément les changements.
</p>

<p>
Le ChangeLog étant principalement écrit pour les utilisateurs, restez concis 
et clairs, et évitez de trop vous étendre sur les détails techniques internes. 
</p>

</body>
</section>

<section>
<title>Stocker vos propres ebuilds localement</title>
<body>

<p>
Afin d'être en mesure de tester vos ebuilds et de les faire reconnaître par
Portage, vous devez les placer dans un répertoire connu. Portage utilisera la
variable <c>PORTDIR_OVERLAY</c> que vous pouvez définir dans
<path>/etc/make.conf</path>. Définissez cette variable en fonction de votre
répertoire de travail (par ex. <path>/usr/local/portage</path>).
</p>

<p>
Dans ce répertoire, vous devez utiliser la même structure (et les mêmes catégories)
que dans <path>/usr/portage</path>. 
</p>

<p>
Grâce à ce <c>PORTDIR_OVERLAY</c>, vos ebuilds resteront sur votre système, même 
après un <c>emerge sync</c>, et resteront connus de Portage.
</p>

</body>
</section>

<section>
<title>Outils de test</title>
<body>

<p>
Nous disposons de quelques outils utiles pour vous aider à écrire et à
maintenir vos ebuilds.
</p>

<warn>
<c>lintool</c> ne fonctionne pas. Utilisez repoman à la place. 
</warn>

<table>
<tr>
  <th>Outil</th>
  <th>Paquet</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Outil uniquement conçu pour les développeurs, afin de les assister dans 
    la procédure de &quot;checkin&quot; CVS. Il réalise un grand nombre de 
    tests communs et essaie de vérifier que les fichiers ajoutés au CVS ne 
    vont pas abimer l'arbre de Portage.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Outil qui conserve les fichiers pré-traités de telle sorte que la 
    recompilation se déroule <e>beaucoup</e> plus rapidement. N'oubliez 
    pas d'ajouter <c>ccache</c> à la variable <c>FEATURES</c> dans 
    <path>/etc/make.conf</path>&nbsp;!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Lance un shell qui crée un environnement bac à sable. Utile pour se placer 
    dans le même environnement que celui dans lequel Portage construit ses 
    paquets et pour régler les problèmes à la main.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>
    Permet de créer un nouveau ChangeLog ou d'ajouter une entrée dans un
    ChangeLog existant.
  </ti>
</tr>
<tr>
  <ti><c>gentool-bump-revision</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>
    Outil conçu uniquement pour les développeurs qui permet d'incrémenter le 
    numéro de révision, d'ajouter la nouvelle révision au CVS, d'enlever 
    l'ancienne, et de mettre à jour le ChangeLog en conséquence.
  </ti>
</tr>
<tr>
  <ti><c>qpkg</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>Un outil pour rassembler diverses informations sur les paquets installés.</ti>
</tr>
</table>

</body>
</section>
</chapter>
</guide>
