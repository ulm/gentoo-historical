<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/nvidia_tsg-fr.html">
<title>Guide d'utilisation des drivers nVidia pour Linux</title>
<author><mail link="phoenix@minion.de">Christian Zander</mail></author>
<author><mail link="mthome@bbn.com">Michael Thome</mail></author>
<author><mail link="nohar@altern.org">Tradution: Arnaud Cornet</mail></author>

<abstract>
Ce document est un guide pour aider a la mise en fonction des drivers X nVidia sous Linux. Il n'est pas spécifique à Gentoo.
</abstract>

<version>1.0.0</version>
<date>Feb 13 2001</date>

<chapter>
	<title>Introduction</title>

	<section>
		<title>Kézako?</title>
		<body>
		<p>Vous venez d'installer les drivers nVidia pour linux et espérez
        pouvoir commencer a profiter réellement de votre distribution toute
        chaude. Malheureusement, pour une raison qui vous est inconnue, les
        choses ne sont pas exactement comme vous les auriez souhaitées.
Vous vous retrouvez donc devant un ecran noir, ou, pour les plus chanceux
d'entre vous, devant une console. Bien qu'il soit vrai qu'on ne peut nier
l'extrême beauté de la console en 80x25, ce n'est pas avec ca qu'on va fragger un monstre venu d'ailleurs...
</p>
		<p>Heureusement, la plupart des problèmes auxquels vous
pouvez être confronté ont déja été vécus par d'autres. Et
même mieux, il existe des moyens de contourner ces
problemes. Comment chercher et trouver des réponses?
Ce document est ce que vous cherchez.
	</p>
<p>Avant d'aller plus loin la plupart des informations
trouvées dans ce document proviennent de <c>#nvidia</c>
(<uri link="http://openprojects.nte">irc.openprojects.net</uri>) et de
l'expérience de l'auteur. Il a aussi pris la liberté de prendre des
informations du driver lui même et de sa documentation. Le channel IRC
mentionné est un bon endroit pour chercher de l'aide ou des fichiers ou
patches.</p>
<p>Il pourra être utile de vérifier son système avec le script
<c>nv_check.sh</c>, qui peut être téléchargé (ainsi que tous les patches
référencés) à partir de <c>iCE-DCC</c>, un bot à offre DCC dans le channel
IRC sus-cité.</p>
		</body>
	</section>

	<section>
		<title>Remarques</title>
		<body>
		<p>Les suggestions, questions, remarques vont en anglais à
<mail link="phoenix@minion.de">Christian Zander</mail></p>
		</body>
	</section>
</chapter>

<chapter>
	<title>AGP/KERNEL</title>
	<section>
		<title>Vue d'ensemble</title>
		<body>
		<p>Comme vous l'avez peut etre remarqué, le driver nVidia,
a besoin de ressources au niveau du noyau pour fonctionner. Ce travail est
accompli par le module noyau NVdriver. Parmi ces responstabilités on
trouve : les contrôle d'accès au périphérique, la localisation et
l'initialisation de certains aspects du matériel, contrôle du driver AGP, du
DMA, pour en citer certains.</p>
		</body>
	</section>

	<section>
		<title>AGPGART contre NVAGP</title>
		<body>
		<p>Du point de vue de linux, votre port AGP n'est rien d'autre qu'un
        autre slot PCI, et il est détecté comme tel. Comme vous voulez profiter
        de ce que le bus AGP apporte, vous avez besoin d'un driver adéquat. Avec
        les drivers nVidia pour linux, vous avez le choix entre le driver AGP
        d'nVidia qui a été porté d'NT (NVAGP) et AGPGART, développé par Jeff
        Hartmann et quelques contributeurs. AGPGART fais partie du noyau officiel (2.2.18+, 2.3.??+) et il est supporté par défaut par bon nombre de distributions. Le choix du driver dépend (1) de votre chipset AGP, (2) de vos préférences.
		</p>
		<p>Si tout a fonctionné pour vous quelque soit le driver choisi, vous n'avez pas a vous en faire. Il y a par contre de bonnes chances pour que les choses ne soient pas pour le mieux (sinon vous ne liriez pas ça).
		</p>
		<p>
		Une façon de savoir si votre configuration AGP est responsable de vos
        problèmes (et parfois la seule choses à faire pour avoir un système qui marche) c'est d'enlever complètement le support AGP dans le driver. Pour cela, metre dans votre fichier <path>XF86Config</path> :</p>
		<pre>Option "<i>NvAgp</i>" "<i>0</i>"</pre>
		<p>Certaines combinaisons de drivers et de chipset AGP peuvent rendre
        votre système très instable, voire inutilisable, alors soyez prudent.
        Ces combinaisons devraient marcher (très incomplet, dites nous si vous
        connaissez d'autres configs)
		</p>
		<!--<p>Intel:</p>-->
		<table>
		<tr>
			<th>Chipset</th>
			<th>Driver</th>
		</tr>
		<tr>
			<ti>Intel</ti>
			<ti><pre>440BX   NVAGP   / AGPGART <comment># Ne marche pas chez certains</comment>
810     NVAGP   / AGPGART
815(e)  NVAGP   / AGPGART <comment># avec le patch 815</comment></pre></ti>
                 </tr>
		<tr>
			<ti>VIA</ti>
			<ti><!--<p>VIA:</p>--><pre>Apollo  AGPGART / NVAGP
MVP3    AGPGART
MVP4    AGPGART
KX133   NVAGP
KT133   NVAGP</pre></ti>
		</tr>
		<tr>
			<ti>Ali</ti>
			<ti><!--<p>Ali:</p>--><pre>...     AGPGART <comment># 2.4.0+,  2.2.18 avec le patch ALi</comment></pre>
		</ti></tr>
		<tr>
			<ti>SiS</ti>
			<ti><!--<p>SiS:</p>--><pre>...     AGPGART <comment># ?</comment></pre></ti>
		</tr>
		</table>
		<p>Si vous vous demandez quel est le chipset AGP de votre carte mère, consultez la documentation de votre carte mère, ou essayez de récupèrer l'information dans <path>/proc/pci</path></p>
		
		<pre>$ <i>grep AGP /proc/pci</i></pre>
		<p>Maintenant que vous savez quel driver utiliser, nous allons voir comment configurer le système pour utiliser le driver choisi</p>
        	<table>
		<tr>
			<th>Drapeau</th>
			<th>Effet</th>
		</tr>
		<tr>
			<ti>NVAGP</ti>
			<ti><!--
		<p>Compiler le driver NVdriver avec:</p>
		<pre>$ <i>make clean</i>
$ <i>make NVdriver BUILD_PARAMS=NOAGPGART</i>
# <i>make install</i></pre>--><p>Enable NVAGP support</p></ti>
		</tr>
		<tr>
			<ti>AGPGART</ti>
			<ti>Sélectionner le support de l'AGPGART dans le noyau
Il y a rien d'autre a faire, le driver va automagiqument être compilé avec le support pour celui ci. Je recommande fortement que vous utilisiez au moins un noyau 2.2.18 ou un noyau de développement récent avec AGPGART.</ti>
		</tr>
		</table>
		<p>Si vous utilisez NVAGP, compiler le driver NVdriver ainsi : </p>
		<pre>$ <i>make clean</i>
$ <i>make NVdriver BUILD_PARAMS=NOAGPGART</i>
# <i>make install</i></pre>
		<impo><p>Changements à partir de 0.9-6:</p>
		<p>
		A partir de cette version, le driver chargera le driver AGP dynamiquement quand X démarre, la sélection du driver à charger est contrôlée à l'aide de l'option suivante dans la section Screen de votre fichier <path>XF86Config</path></p></impo>
		<pre>Option "<i>NvAgp</i>" "<i>0</i>"  <comment># Pas du support AGP</comment>
Option "<i>NvAgp</i>" "<i>1</i>"  <comment># support NVAGP</comment>
Option "<i>NvAgp</i>" "<i>2</i>"  <comment># support AGPGART</comment></pre>
		<p>
		Soyez sûrs de ne pas avoir 'l'autre' driver AGP chargé quand vous dites à X de charger par exemple NVAGP. Certaines distributions chargent AGPGART par défaut. X le remarquera mais ne sera pas capable de changer de driver AGP à la volée.
</p>
		<p>
Hardez a l'esprit que changer de driver AGP ou les désactiver nécessite souvent
un redémarrage avant que les changements prennent effet. Charger un driver AGP
différent sans redémarrer peut causer des plantages ou une instabilité générale du système.
</p>
		</body>
	</section>

	<section>
		<title>AGP Aperture</title>
		<body>
		<p>C'est la taille de la mémoire physique dont on autorise l'accès a la
        carte vidéo par l'interface AGP (pour les textures etc). Alors que c'est
        a vous de décider la valeur de ce paramètre, il est généralement désirable de ne pas utiliser plus de la moitié de votre mémoire vive. 32M-64M semblent être raisonnables. Ne mettez pas de valeur suppérieure ou égale à la taille de votre RAM, en effet AGPGART vas planter votre machine si vous faites ceci.
(à régler dans le BIOS)
		</p>
		</body>
	</section>

	<section>
		<title>AGP Fast Writes</title>
		<body>
		<p>Dans le but d'améliorer les performances, ce paramètre plante les
        machines en général. Dans tous les cas, les gains potentiels de
        performance ne valent pas le risque encourru. (à régler dans le
        BIOS)</p>
		<p>(autrement, passer l'argument <c>NVreg_EnableAGPFW=0</c> au driver NVdriver)</p>
		</body>
	</section>

	<section>
		<title>Vitesses AGP (1x, 2x, 4x)</title>
		<body>
		<p>
		Cela contrôle la bande passante à laquelle le bus AGP opère.
Alors que la plupart des chipsets actuels supportent des transferts 4x, cela peut causer un plantage du système ou un comportement étrange dans certains cas.
Le driver connait pas mal de bugs de ce genre et les contourne. Les chipsets VIA sont mis en 2x par défaut.
</p>
		<p>
La vitesse AGP se règle en passant une option au driver :
</p>
           <pre># <i>modprobe NVdriver NVreg_ReqAGPRate=0x2</i> <codenote>0x1 | 0x2 | 0x4</codenote></pre>
		<p>
La même chose mais dans <path>modules.conf</path> :
		</p>
           <pre>alias char-major-195 NVdriver
           options NVdriver NVreg_ReqAGPRate=<i>0x2</i></pre>
		<p>
       (si vous voulez du 4x avec un chipset Via, utiliser <c>NVreg_EnableVia4x=1</c>)
		</p>
		</body>
	</section>

	<section>
		<title>Contournement de bug AGP &amp;&amp; AGPGART</title>
		<body>
		<p>
	Comme mentionné precédemment, le driver se débrouille pour contourner des
    bugs de certains chipsets AGP. A partir de la version 0.9-5 du driver, ces
    bidouilles sont appliquées à NVAGP et AGPGART. Si vous ne voulez pas les
    utiliser avec AGPGART (pour une quelconque raison) vous pouvez désactiver ce comportement par défaut a l'aide de l'argument <c>NVreg_UpdateKernelAGP=0</c> en option de NVdriver.
		</p>
		</body>
	</section>

	<section>
		<title>
      IRQ / Assigner une interruption au contrôleur VGA
		</title>
		<body>
		<p>
Le driver nVidia a besoin d'une interruption assignée à la carte graphique pour
fonctionner correctement. Assurez vous que vous ayez sélectionné l'option du
BIOS '<c>assign IRQ to vga</c>' (Le BIOS peut l'appeller d'une autre façon).
		</p>
		</body>
	</section>

	<section>
		<title>
Compiler NVdriver
</title>
		<body><p>
On peut difficilement faire plus simple dans la plupart des cas :
		</p>
<pre>$ make clean
$ <i>make NVdriver <codenote>si besoin: BUILD_PARAMS=NOAGPGART, voir ci-dessus</codenote></i>
# <i>make install</i></pre>
<p>
Dans certaines situations, cela ne marche pas. J'ai déjà dit qu'il faut choisir entre AGPGART et NVAGP.
</p>
<p>
Le driver suppose que les entêtes du noyeau sont installées dans :
<path>/usr/src/linux/include</path>. Si ce n'est pas le cas changez l'option <c>SYSINCLUDE</c>:
</p>
<pre>$ <i>make clean</i>
$ <i>make NVdriver SYSINCLUDE=/la/ou/sont/vos/entetes</i>
# <i>make install</i></pre>
		</body>
	</section>
	<section>
		<title>
Fichiers Spéciaux en mode caractères
		</title>
		<body><p>
Le modules XFree86 communique avec le driver NVdriver a travers, plusieurs charactères spéciaux situées dans le répertoire <path>/dev</path>
Si ils ont mal été crés ou s'il n'ont pas les bonnes premissions X ne fonctionnera pas.
		</p>
<pre>crw-rw----    1 root     video    195,   0 Jan  4 23:19 /dev/nvidia0
crw-rw----    1 root     video    195,   1 Jan  4 23:19 /dev/nvidia1
crw-rw----    1 root     video    195,   2 Jan  4 23:19 /dev/nvidia2
crw-rw----    1 root     video    195,   3 Jan  4 23:19 /dev/nvidia3
crw-rw----    1 root     video    195, 255 Jan  4 23:19 /dev/nvidiactl</pre>
		<p>
Comme vous le voyez, j'ai choisi de rendre les fichiers accessibles à root
uniquement, ainsi qu'aux membres du groupe <c>video</c>. 
Vos choix pourront etre différents. Dans tous les cas, assurez vous que
l'utilisateur qui veut démarrer X a accès aux fichiers cités en lecture et en écriture.
		</p>
		</body>
	</section>

	<section>
		<title>devFS</title>
		<body><p>
A partir de la version 2.3.XX le noyau linux offre une méthode alternative: <c>devFS</c>.
Expliquer les mécanismes de devFS sont totalement hors sujet ici.
Mais je souligne qu'il existe un patch pour le driver nVidia qui le rend adapté
à devfs.
		</p></body>
	</section>

	<section>
		<title>procFS</title>
		<body><p>
	A partir des versions 0.9-6, le driver nvidia, fourni les
	informations nécessaires sur votre système dans
	<path>/proc/nv/card[0-3]</path>. Il y a un patch pour avoir cette
	fonctionnalité dans le driver 0.9-5.
		</p>
		</body>
	</section>

	<section>
		<title>BIOS Repost</title>
		<body><p>
	Le driver tente de reposter le bios de la carte quand X commence à assurer
    que la carte est dans un état connu par le driver. Malheureusement, cela
    cause des problemes avec certaines cartes. On peut empêcher ce comportement
    avec une autre option de NVdriver.</p>
		<pre>
           modprobe NVdriver NVreg_SkipBiosPost=<i>1</i>
		</pre>
		</body>
	</section>

	<section>
		<title>TNT SGRAM vs. SDRAM</title>
		<body><p>
Le driver détecte le type de mémoire utilisée par les TNT en lisant son bios. Malheureusement, certaines cartes ont été flashées avec des bios incorrects.
Si vous pensez que c'est le cas avec votre configuration, essayez
l'option <c>NVreg_VideoMemoryTypeOverride</c>
(<c>SDRAM = 1, SGRAM = 2</c>). Ca ne marche pas tout le temps, 
voir <path>os-registry.c</path> pour les détails.
		</p>
		</body>
	</section>

	<section>
		<title>Kernel 2.4.0</title>
		<body><p>
	Pas mal de changements depuis les 2.2.x et pas mal concernant le driver nvidia.
       Obtenez les patchs pour cette série sur <c>#nvidia</c>.
		</p>
		</body>
	</section>

	<section>
		<title>	
       "Ignoring changed section attributes for .modinfo"
		</title>
		<body><p>
Si ce message vous emm^H^Hnnuie, commentez la ligne dans
<path>/usr/src/linux/include/linux/modules.h</path>. Ne vous inquiétez pas ,
vous ne risquez rien.
		</p></body>
	</section>
</chapter>

<chapter>
	<title>XFree86 / OpenGL</title>
	<section>
		<title>Introduction</title>
		<body><p>
    Avant de démarrer la description de la plupart des problèmes les plus
    souvent rencontrés avec cette partie du driver, je veux expliquer
    certaines choses qui sont souvent incomprises et qui troublent pas mal
    de personnes :
		</p>
		</body>
	</section>

	<section>
		<title>L'architecture du Driver nVidia contre DRI et DRM</title>
		<body><p>
       Le driver nVidia n'utilise pas l'architecture DRI (Direct Rendering
       Interface) qui est apparue pour la première fois dans XFree86 4.0.0.
       Au lieu de ça, nVidia a choisi d'implémenter un mécanisme propre.
       Les architectures sont pourtant similaires :  les deux utilisent un
       driver niveau noyau (NVdriver contre DRM) et tous deux mettent en
       place un mécanisme pour fournir une haute performance OpenGL en
       permettant un accès direct au matériel plutôt que de passer par GLX,
       quand le tout est fait localement.
		</p></body>
	</section>

	<section>
		<title>OpenGL: l'implémentation nVidia contre Mesa</title>
		<body><p>
       Le driver nVidia vient avec sa propre implémentation de OpenGL et
       n'utilise pas Mesa, qui est fourni avec XFree. Les bibliothèques
       OpenGL d'nVidia sont basées sur l'implémentation d'OpenGL 1.2 de SGI
       et fournit un bon nombre d'extensions qui permettent l'utilisation
       de capacités telles que l'utilisation de textures compressées S3TC.
		</p></body>
	</section>

	<section>
		<title>Le module nVidia contre ceux d'XFree86
		</title>
		<body><p>
       Le module <c>nv</c> fourni avec XFree86 n'a rien à voir avec le
       module 'nvidia' fourni avec le driver nVidia. Ce dernier ne repose
       pas sur un driver niveau noyau pour fonctionner et ne nécessite pas
       d'interruption et ne supporte 'que' les opérations en 2D. A partir
       de la version 4.0.2, ce driver fonctionne avec toutes les versions
       des adaptateurs graphiques nVidia, y compris les cartes à GeForce 2.
       Si vous avez ce driver d'installé, c'est une bonne idée tester votre
       installation de X en essayant de démarrer X avec le driver
       <c>nv</c>.
		</p>
    		<p>
    Je vais maintenant lister la liste de quelques problèmes courants que
    les gens rencontrent avec les drivers nVidia. Parmi toutes les
    problèmes décrits ici, beaucoup sont résolus dans la documentation
    officielle inclue dans le paquet du driver, mais puisque personne n'a
    l'air de les lire, je les explique quand même.
		</p>
		</body>
	</section>

	<section>
		<title>libglx.a / libGLcore.a / libGL.so.1.2.303... (Mesa)</title>
		<body><p>
       Mes préférées... Comme mentionné ci-dessus, le driver nVidia
       n'utilise pas la bibliothèque Mesa fournie avec XFree86 qui en fait,
       fait des conflits avec l'implémentation de nVidia.
		</p>
       <warn>C'est <e>la</e> principale source d'erreurs.</warn>
		<p>
       Si votre distribution a installé et configuré X pour vous, vous avez
       de fortes chances d'avoir dans votre <path>XF86Config</path> une
       section Module qui ressemble à cela :
		</p>
<pre>Section "<i>Module</i>"
	...
	Load  "<i>glx</i>"
	Load  "<i>GLcore</i>"
	...
EndSection</pre>
	<p>
       Votre attention doit se focaliser sur ces deux dernières lignes.
	</p>
		</body>
	</section>

	<section>
		<title>Load "glx"</title>
		<body><p>
	Ceci dit à X de charger le module d'extension GLX. Avec
	l'intallation par défaut de XFree86, cela se traduit en
	<path>libglx.a</path>. Le driver nVidia fourni sa propre extension
	GLX, <path>libglx.so</path>. C'est ici que la fête commence : si
	vous n'avez pas enlevé <path>libglx.a</path>, X va continuer a
	charger <path>libglx.a</path>, qui ne fonctionne pas avec les
	drivers nVidia.
	
		</p>
          <impo>
	  Effacez ou renommez <path>libglx.a</path> (<path>/usr/X11R6/lib/modules/extensions</path>)
	  </impo>
	  
	</body></section>

	<section>
		<title>Load "GLcore"</title>
		<body><p>
	  Pas grand chose à dire à part que vous ne voulez pas de cette
	  ligne dans votre section Module. Le libGLcore.so fourni par
	  nVidia est chargé dynamiquement - ne le chargez pas en tant
	  qu'extension X. Cela ne fonctionnera pas.
		</p>
		<p>
	  On peut facilement déterminer si on charge <path>libglx.a</path>
	  et/ou libGLcore.a en regardant dans
	  <path>/var/log/XFree86.0.log</path> :
		</p>
<pre>...
(II) LoadModule: "glx"
(II) Loading /usr/X11R6/lib/modules/extensions/libglx.a
(II) Module glx: vendor="The XFree86 Project"
	compiled for 4.0.1, module version = 1.0.0
	ABI class: XFree86 Server Extension, version 0.1
(II) Loading extension GLX
(II) Loading sub module "GLcore"
(II) LoadModule: "GLcore"
(II) Reloading /usr/X11R6/lib/modules/extensions/libGLcore.a
...</pre>
		<p>
	  Ce que vous devez voir ressemble à ça:
		</p>
<pre>...
(II) LoadModule: "glx"
(II) Loading /usr/X11R6.4/lib/modules/extensions/libglx.so
(II) Module glx: vendor="NVIDIA Corporation"
	compiled for 4.0.1, module version = 1.0.5
	Module class: XFree86 Server Extension
	ABI class: XFree86 Server Extension, version 0.1
(II) Loading extension GLX
...</pre>
    		<p>
    La dernière partie de Mesa qui peut causer des problèmes est la
    bibliothèque OpenGL elle-même, souvent appelée
    <path>libGL.so.1.2.303</path>... ou quelque chose qui y ressemble, selon
    l'endroit où elle est installée, elle va tôt ou tard entrer en conflit avec
    la bibliothèque OpenGL d'nVidia. Souvent, les jeux vidéos chargent
    libGL.so la première fois, et Mesa la fois d'après.
		</p>
		<p>
    Les symptômes d'un conflit avec Mesa (bibliothèque ou extension) sont
    des crash avec des erreurs de segmentations (Segmentation Faults
    (Signal 11)) - aussi bien tout de suite après le démarrage de X qu'au
    démarrage d'un application OpenGL. Un autre symptome peut être de très
    faibles performances (1-5 images par secondes), ce que vous obtenez
    quand Mesa effectue son calcul d'image logiciel.
		</p>
		</body>
	</section>

	<section>
		<title>nv_drv.o vs. nvidia_drv.o</title>
		<body><p>
       Un autre problème courant - après une installation par défaut le
       driver <c>nv</c> d'XFree86 va être chargé. Assurez vous que votre
       section Device dans <path>XF86Config</path> ressemble à ceci:
		</p>
<pre>Section "<i>Device</i>"
	Identifier  "<i>nVidia GeForce 256 DDR</i>"
	Driver      "<i>nvidia</i>"
EndSection</pre>
		</body>
	</section>

	<section>
		<title>
        X plante instantanément avec un signal 11
    		</title>
		<body><p>
       Cherchez dans <path>/var/log/XFree86.0.log</path> les messages
       d'erreurs suivants :
		</p>
		<pre>
       (WW) module ABI minor version (2) is newer than the server's version (1)
		</pre>
		<p>
        Cela arrive couramment quand vous essayez d'utiliser les drivers 0.9-5
        ou plus récent avec XFree86 4.0.0 ou les drivers 0.9-4 ou plus vieux
        avec XFree86 4.0.1 ou plus récent. Je recommande de mettre à jour X à la
        version 4.0.2 quelque soit le dernier driver au moment de la lecture de
        ce document.
        </p>
		</body>
	</section>

	<section>
		<title>
    X se plante en se plaignant de la DMA
		</title>
		<body><p>       
       Certainement un noyau bogué - utilisez 2.2.18+ ou 2.4.0+.
		</p>
	</body></section>

	<section>
		<title>
    L'écran n'est plus synchronisé quand X démarre
		</title>
		<body><p>
	Cela peut avoir plusieurs causes.
       <ul>
		<li><p>
	  De mauvaises "modelines" sont spécifiées. Effacez les modelines
	  explicites dans votre section Moniteur, ou corrigez les.
	  </p>
</li>
		<li>
       <p>Les modelines sont correctes, mais le driver n'a pas l'air de les
	  aimer - essayez ces options dans votre section Screen:
	  </p>
<pre>Option      "<i>IgnoreEdid</i>"       "<i>1</i>"
Option      "<i>GenerateRTList</i>"   "<i>0</i>"</pre>
		</li>
	</ul>
	</p>	</body>
	</section>

	<section>
		<title>X &amp;&amp; MTRRs</title>
		<body><p>
       Si vous voulez avoir le support des MTRRs (vous le voulez), vous
       allez devoir sélectionner leur support dans le noyau lui-même avant
       que le driver soit capable de les utiliser. Les MTRRs influencent
       grandement les performances de votre système.
		</p>
		</body>
	</section>

	<section>
		<title>X efface le mode désiré avec le message : (hsync out of range)</title>
		<body><p>
       X a décidé que votre écran n'est pas capable d'afficher de façon
       sûre le mode désiré. Assurez vous que les valeurs spécifiées des
       options HorizSync et VertRefresh sont bien celles de votre moniteur
       (trouvez les dans le manuel de votre écran). Si aucune valeur n'est
       spécifiée, X utilisera des valeurs "sûres".
		</p>
		</body>
	</section>

	<section>
		<title> X se plaint (Warning) d'option de polarité</title>
		<body><p>
       Il arrive souvent en passant en mode console - d'habitude sans
       dommage ; si vous ne savez pas de quoi parle X et voulez vous
       débarasser des messages, utilisez ceci dans votre section Screen:
		</p>
           <pre>Option      "<i>OverridePolarity</i>" "<i>1</i>"</pre>
		<p>
       Cele peut aussi accélérer le passage en mode console.
		</p>
		</body>
	</section>

	<section>
		<title>DDC</title>
		<body><p>
       Oui, XFree86 4.0.x supporte DDC - vous pouvez en activer le support
       en chargeant le modules approprié :
		</p>
           <pre>Load "<i>ddc</i>"</pre>
		<p>
       Ceci ne fonctionnera que si votre carte graphique et votre moniteur
       supportent DDC. N'utilisez pas de modlines explicites avec cette
       option.
		</p>
		</body>
	</section>

	<section>
		<title>
    Le jeu XY ne se met pas en plein écran
		</title>
		<body><p>
       C'est un problème de configuration. Il y a deux choses à s'assurer
       avant qu'un jeu ne puisse changer la résolution avec l'extension
       Vidmode d'X:
		</p>
		<p>

       Il vous faut cette ligne dans la section Module d'XF86Config:
		</p>
           <pre>Load "<i>extmod</i>"    <comment># ou, sinon, SubSection
	   <e>extmod</e></comment></pre>
		<p>
       Vous devez avoir une sous-section Affichage (<c>Display
       SubSection</c>) dans votre section <c>Screen</c> correcte. Elle doit
       définir le mode dont le jeu a besoin dans la section correspondant au
       nombre de couleurs que vous utilisez, soit:
		</p>
<pre>Subsection "<i>Display</i>"
	Depth  <i>24</i>
	Modes  "<i>1152x864</i>" "<i>1024x768</i>" "<i>800x600</i>" "<i>640x480</i>"
EndSubsection</pre>
		</body>
	</section>

	<section>
	<title>
     X fonctionne en 16bpp, vous en voulez 32, mais cela ne marche pas
	</title>
		<body><p>
       24/32bpp est appellée 24 dans X 4.x. Cela se contrôle avec deux
       option dans la section Screen:
		</p><pre>
           DefaultDepth <i>24</i>
           DefaultFbBpp <i>32</i>
		</pre>
		<p>       
       Assurez vous encore une fois d'avoir une sous-section affichage
       (Display Subsection) correcte.
		</p></body>
	</section>

	<section>
		<title>La souris a molette ne marche pas</title>
		<body><p>
       Cela n'a rien à voir avec nVidia, mais cette une question
       récurrente. Vous devez choisir le protocole IMPS/2 et mapper le
       4ième et le 5ième boutton à l'axe Z. Voilà à quoi ma configuration
       ressemble:
		</p><pre>
           Section "<i>InputDevice</i>"
             Identifier  "<i>Mouse</i>"
             Driver      "<i>mouse</i>"
             Option      "<i>Device</i>"  "<i>/dev/mouse</i>"
             Option      "<i>Protocol</i>"    "<i>IMPS/2</i>"
             Option      "<i>ZAxisMapping</i>"   "<i>4 5</i>"
           EndSection
		</pre><p>
       J'utilise une souris USB, <path>/dev/mouse</path> est un lien
       symbolique vers <path>/dev/input/mice</path> dans mon cas.
       </p>
		</body>
	</section>

	<section>
		<title> La souris rame dans les jeux (QuakeIII, mauvais
		rafraîchissement)</title>
		<body><p>
       De nombreux jeux utilisent la méthode DGA pour gérer la souris dans
       les jeux, la méthode est similaire au directinput de windows. Toutes
       les versions de XFree86 avant 4.0.2 ont une gestion de la souris
       avec DGA 1 incorrecte. Si vous voulez de meilleurs performances
       mettez a jour à 4.0.2.
</p>
		<p>
	En plus de ca, vous aurez à charger l'extension DGA. De nombreux
	outils de configuration le désactivent par défaut, utiliser:
</p>
           <pre>Load "<i>extmod</i>"</pre>
		<p>
       Au lieu d'une Subsection si vous voulez être sûr que DGA est
       chargé. Après cela, vous aurez à activer la gestion de la souris par
       DGA vous même.Pour Quake 3 cela devient :
		</p>
           <pre>seta in_dgamouse "<i>1</i>"</pre>
		<p>
       Dans le fichier de configuration de Quake III (<path>~/.q3a/baseq3/q3config.cfg</path>).
		</p>
		<note>
       XFree86 4.0.2 introduit DGA 2, qui est connu pour marcher encore
       mieux. Bien que Quake III ne le supporte pas encore, vous pouvez
       faire fonctionner la plupart des jeux Loki avec, en compilant le
       support SDL pour DGA 2.
		</note>
		</body>
	</section>

	<section>
		<title>L'application XY ne trouve pas GLUT ou GLU</title>
		<body>
       <p>GLUT est un système de fenétrage qui fourni aux programmeurs une
       façon simple de gérer des fenêtres avec des contextes OpenGL et qui
       a une gestion primaire d'évènements (qu'OpenGL ne gère pas du tout).
       Cela ne fait pas non plus partie du driver nVidia.
	</p>
	<p>
       GLUT et GLU peuvent tous deux être obtenus à partir du site du
       projet Mesa et ont de grandes chances d'être disponibles sous forme
       de paquet pour votre distribution linux.
	</p>
	<p>La section suivante sont des ajouts de <mail link="mthome@bbn.com">Michael Thome</mail></p>
	<ul><li>
      <p>N'utilisez pas le driver du noyeau FBdev pour nvidia. Il crée des
       conflits avec les drivers propriétaires d'nVidia et peuvent causer
       toute sorte d'effets déplaisants. (crash, problèmes d'affichage, etc).
       </p>
	</li>
	<li>
      <p>Les drivers closed source de Vortex d'Auréal ne semblent pas
       s'entendre avec les drivers binaires d'nVidia sur certaines
       configurations, certainement des conflits d'IRQ.
       </p>
	<warn>
	  Le partage d'IRQ semble être un problème avec le driver nVidia.
	  J'ai été incapable de faire marcher un carte fast ethernet
	  (RTL8139) avec le driver dans des circonstances similaires. Si
	  vous avez des problèmes liés au matériel qui fonctionne mal ou
	  pas du tout, vous pouvez re-vérifier qu'il ne partage pas
	  d'interruption avec votre adaptateur graphique.
	</warn>
	</li>
	</ul>
	</body></section>
<section><title>le mode 100dpi
</title><body><p>
       Contrairement au driver d'XFree86, le module nVidia n'utilise pas
       DDC pour déterminer la résolution de l'écran. J'ai du ajouter ce
       qui suit à la section moniteur pour avoir un mode 100dpi:
</p>

<pre>Section "<i>Monitor</i>"
	Identifier   "<i>Monitor0</i>"
	VendorName   "<i>Dell</i>"
	ModelName    "<i>Monitor Model</i>"
	HorizSync    <i>30.0-107.0</i>
	VertRefresh  <i>48.0-160.0</i>

	<comment># pour 100dpi</comment>
	DisplaySize  <i>406 304</i>
EndSection</pre>
<p>
       Les paramètres sont les hauteurs et largeurs affichables en mm. J'ai
       choisi ces valeurs pour avoir du 100x100dpi en 1600x1200.
</p>
</body></section></chapter>

<chapter>
	<title>Resources</title>
	<section>
		<title>
    Mon <path>/etc/X11/XF86Config</path> [0.9-6] pour ceux que cela
    intéresse :
</title><body>
<pre>    Section "<i>Module</i>"
      Load  "<i>bitmap</i>"
      Load  "<i>dbe</i>"
      Load  "<i>extmod</i>"
      Load  "<i>freetype</i>"
      Load  "<i>glx</i>"
      Load  "<i>type1</i>"
      Load  "<i>v4l</i>"
    EndSection

    Section "<i>Files</i>"
      RgbPath   "<i>/usr/X11R6.4/lib/X11/rgb</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/misc/</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/75dpi/:unscaled</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/100dpi/:unscaled</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/75dpi/</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/100dpi/</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/TrueType/</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/local/</i>"
      FontPath  "<i>/usr/X11R6.4/lib/X11/fonts/Type1/</i>"
    EndSection

    Section "<i>ServerFlags</i>"
      Option  "<i>SuspendTime</i>"  "<i>0</i>"
      Option  "<i>StandbyTime</i>"  "<i>0</i>"
      Option  "<i>BlankTime</i>"    "<i>0</i>"
      Option  "<i>OffTime</i>"      "<i>0</i>"
    EndSection

    Section "<i>InputDevice</i>"
      Identifier  "<i>Keyboard</i>"
      Driver      "<i>Keyboard</i>"
      Option      "<i>XkbRules</i>"  "<i>xfree86</i>"
      Option      "<i>XkbModel</i>"    "<i>pc102</i>"
      Option      "<i>XkbLayout</i>"      "<i>us</i>"
    EndSection

    Section "<i>InputDevice</i>"
      Identifier  "<i>Mouse</i>"
      Driver      "<i>mouse</i>"
      Option      "<i>Device</i>"  "<i>/dev/mouse</i>"
      Option      "<i>Protocol</i>"    "<i>IMPS/2</i>"
      Option      "<i>ZAxisMapping</i>"   "<i>4 5</i>"
      Option      "<i>Buttons</i>"          "<i>5</i>"
    EndSection

    Section "<i>Monitor</i>"
      Identifier  "<i>Vision Master Pro 17</i>"

      HorizSync    <i>27.0-92.0</i>
      VertRefresh  <i>50-160</i>

      Mode "<i>1152x864</i>"
        DotClock <i>137.65</i>
        HTimings <i>1152 1184 1312 1536</i>
        VTimings  <i>864  866  882  902</i>
        Flags    "<i>-HSync</i>" "<i>-VSync</i>"
      EndMode

      Mode "<i>1024x768</i>"
        DotClock <i>115.50</i>
        HTimings <i>1024 1056 1248 1440</i>
        VTimings  <i>768  771  781  802</i>
        Flags    "<i>-HSync</i>" "<i>-VSync</i>"
      EndMode

      Mode "<i>800x600</i>"
        DotClock <i>69.65</i>
        HTimings <i>800 864 928 1088</i>
        VTimings <i>600 604 610  640</i>
        Flags    "<i>-HSync</i>" "<i>-VSync</i>"
      EndMode

      Mode "<i>640x480</i>"
        DotClock <i>45.80</i>
        HTimings <i>640 672 768 864</i>
        VTimings <i>480 488 494 530</i>
        Flags    "<i>-HSync</i>" "<i>-VSync</i>"
      EndMode
    EndSection

    Section "<i>Device</i>"
      Identifier  "<i>nVidia GeForce 256 DDR</i>"
      Driver      "<i>nvidia</i>"
    EndSection

    Section "<i>Screen</i>"
      Identifier  "<i>Screen</i>"
      Device      "<i>nVidia GeForce 256 DDR</i>"
      Monitor     "<i>Vision Master Pro 17</i>"
      Option      "<i>NvAgp</i>" "<i>2</i>"

      DefaultDepth <i>24</i>
      DefaultFbBpp <i>32</i>

      Subsection "<i>Display</i>"
        Depth  <i>16</i>
        Modes  "<i>1152x864</i>" "<i>1024x768</i>" "<i>800x600</i>" "<i>640x480</i>"
      EndSubsection

      Subsection "<i>Display</i>"
        Depth  <i>24</i>
        Modes  "<i>1152x864</i>" "<i>1024x768</i>" "<i>800x600</i>" "<i>640x480</i>"
      EndSubsection
    EndSection

    Section "<i>ServerLayout</i>"
      Identifier   "<i>Chronos</i>"
      Screen       "<i>Screen</i>"
      InputDevice  "<i>Keyboard</i>" "<i>CoreKeyboard</i>"
      InputDevice  "<i>Mouse</i>"  "<i>CorePointer</i>"
    EndSection</pre>
</body>
</section>

<section>

<title>Mon host.def</title>
<body><p>
    Pour ceux qui compilent X eux-mêmes, voici mon <path>host.def</path>
    qui se débarasse de certaines choses dont vous n'avez pas l'utilité
    quoi qu'il arrive (copier vers <path>xc/config/cf</path>):
</p>
<pre>    #define DefaultCCOptions     <i>-O3 -march=i686 -Wall -ansi -pedantic</i>
    #define DefaultGcc2i386Opt   <i>-O3 -march=i686 -fno-strength-reduce</i>
    #define LibraryCDebugFlags   <i>-O3 -march=i686 -fno-strength-reduce</i>
    #define DefaultCDebugFlags   <i>-O3 -march=i686 -fno-strength-reduce</i>
    #define OptimizedCDebugFlags <i>-O3 -march=i686 -fno-strength-reduce</i>

    #define Freetype2Dir      <i>/usr/local</i>
    #define ProjectRoot     <i>/usr/X11R6.4</i>

    #define XF86CardDrivers       <i>nv v4l</i>
    #define XInputDrivers          <i>mouse</i>

    #define BuildServersOnly          <i>NO</i>
    #define BuildXF86DRI              <i>NO</i>
    #define XnestServer               <i>NO</i>
    #define XprtServer                <i>NO</i>
    #define XVirtualFramebufferServer <i>NO</i>
    #define BuildFontServer           <i>NO</i>
    #define BuildXinerama             <i>NO</i>
    #define BuildXF86RushExt          <i>NO</i>
    #define BuildPexExt               <i>NO</i>
    #define BuildGlxExt               <i>NO</i>
    #define LinuxFBDevSupport         <i>NO</i>
    #define XF1Bpp                    <i>NO</i>
    #define XF4Bpp                    <i>NO</i>
    #define BuildXTrueType            <i>NO</i>

    #define BuildSpeedo               <i>NO</i>
    #define BuildCID                  <i>NO</i>

    #define BuildCyrillicFonts        <i>NO</i>
    #define BuildSpeedoFonts          <i>NO</i>
    #define BuildCIDFonts             <i>NO</i>
    #define MakeLocalFontDir          <i>NO</i></pre>
</body>
</section>
</chapter></guide>
