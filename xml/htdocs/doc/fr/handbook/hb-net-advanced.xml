<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Le contenu de ce document est sous licence CC-BY-SA. -->
<!-- Voir http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/handbook/hb-net-advanced.xml,v 1.3 2005/06/14 19:47:08 cam Exp $ -->

<sections>

<version>1.2</version>
<date>2005-06-14</date>

<section>
<title>Configuration avancée</title>
<body>

<p>
La variable config_eth0 est le cœur de la configuration d'une interface. Sa
valeur est une liste d'instructions de haut niveau pour configurer une interface
(eth0 dans notre cas). Chaque commande de la liste d'instructions est exécutée
séquentiellement. L'interface est considérée active si au moins une commande
marche.
</p>

<p>
Voici une liste des instructions intégrées&nbsp;:
</p>

<table>
<tr>
  <th>Commande</th>
  <th>Description</th>
</tr>
<tr>
  <ti>null</ti>
  <ti>Ne fait rien.</ti>
</tr>
<tr>
  <ti>noop</ti>
  <ti>
    Si l'interface est active et possède une adresse, alors annule sa
    configuration en renvoyant un code de succès.
  </ti>
</tr>
<tr>
  <ti>Une adresse IPv4 ou IPv6</ti>
  <ti>Ajoute l'adresse à l'interface.</ti>
</tr>
<tr>
  <ti>
    dhcp, adsl ou apipa<br/>
    (ou bien une commande personnalisée venant d'une module tiers)
  </ti>
  <ti>
    Exécute le module qui fournit la commande. Par exemple, «&nbsp;dhcp&nbsp;»
    exécutera un module qui fournit le DHCP, ce qui peut être dhcpd, udhcpc ou
    pump.
  </ti>
</tr>
</table>

<p>
Si une commande échoue, vous pouvez spécifier une commande de secours. Celle-ci
doit correspondre exactement à la structure de configuration.
</p>

<p>
Vous pouvez enchaîner ces commandes ensemble. Voici quelques <e>vrais</e>
exemples&nbsp;:
</p>

<pre caption="Exemples de configuration">
<comment># Ajout de trois adresses IPv4 :</comment>
config_eth0=(
    "192.168.0.2/24"
    "192.168.0.3/24"
    "192.168.0.4/24"
)

<comment># Ajout d'une adresse IPv4 et deux adresses IPv6</comment>
config_eth0=(
    "192.168.0.2/24"
    "4321:0:1:2:3:4:567:89ab"
    "4321:0:1:2:3:4:567:89ac"
)

<comment># On garde l'adresse déjà assignée par le noyau, sauf si l'interface
# tombe. Dans ce cas, on en assigne une autre grâce à DHCP. Si DHCP ne marche
# pas, alors on ajoute une adresse statique déterminée par APIPA.</comment>
config_eth0=(
    "noop"
    "dhcp"
)
fallback_eth0=(
    "null"
    "apipa"
)
</pre>

<note>
Lorsque vous utilisez le module ifconfig pour ajouter plusieurs adresses, un
alias d'interface est alors créé pour chaque adresse supplémentaire. Donc,
avec les deux exemples précédents, vous obtiendrez eth0, eth0:1 et eth0:2. Vous
ne pouvez rien faire de particulier avec ces interfaces car le noyau et les
applications considèreront eth0:1 et eth0:2 comme n'étant juste qu'eth0.
</note>

<impo>
L'ordre des commandes de secours est très important&nbsp;! En effet, si nous
n'avions pas spécifié la commande «&nbsp;null&nbsp;», alors la commande
«&nbsp;apipa&nbsp;» aurait été lancée si seule la commande
«&nbsp;noop&nbsp;» avait échouée.
</impo>

<note>
<uri link="?part=4&amp;chap=3#apipa">APIPA</uri> et
<uri link="?part=4&amp;chap=3#dhcp">DHCP</uri> seront expliqués plus tard.
</note>

</body>
</section>

<section>
<title>Dépendance du réseau</title>
<body>

<p>
Les scripts de démarrage du répertoire <path>/etc/init.d/</path> peuvent
dépendre d'une interface réseau particulière ou simplement de «&nbsp;net&nbsp;».
Ce que signifie réellement net est configurable grâce à la variable
<c>RC_NET_STRICT_CHECKING</c> dans le fichier <path>/etc/conf.d/rc</path>.
</p>

<table>
<tr>
  <th>Valeur</th>
  <th>Description</th>
</tr>
<tr>
  <ti>none</ti>
  <ti>Le service net est toujours considéré comme actif.</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>
    Cela signifie qu'au moins un service net.*, excepté net.lo, doit
    être actif. Cela peut être utile pour les utilisateurs de portables qui ont
    une interface wifi et une statique car une seule interface active à la fois
    suffit.
  </ti>
</tr>
<tr>
  <ti>lo</ti>
  <ti>
    C'est la même chose que l'option «&nbsp;no&nbsp;», mis à part que net.lo
    compte. C'est utile pour les gens qui se fichent d'avoir forcément une
    interface activée au démarrage du système.
  </ti>
</tr>
<tr>
  <ti>yes</ti>
  <ti>
    Ici, <b>toutes</b> les interfaces réseaux <b>doivent</b> être actives pour
    que le service «&nbsp;net&nbsp;» soit considéré comme démarré.
  </ti>
</tr>
</table>

<p>
Mais comment fait-on si net.br0 dépend de net.eth0 et de net.eth1&nbsp;?
net.eth1 peut être une interface wifi ou bien une connexion ppp qui nécessite
une configuration avant de pouvoir être ajouté au pont réseau. Nous ne pouvons
régler ce problème dans <path>/etc/init.d/net.br0</path> puisque c'est un lien
symbolique vers net.lo.
</p>

<p>
La réponse est que vous pouvez fabriquer votre propre fonction depend() dans
<path>/etc/conf.d/net</path>.
</p>

<pre caption="Les dépendances de net.br0 dans /etc/conf.d/net">
<comment># Vous pouvez utiliser n'importe quel type de dépendance (use, after,
# before) tels qu'on les trouve dans les scripts.</comment>
depend_br0() {
    need net.eth0 net.eth1
}
</pre>

<p>
Pour une explication plus détaillée des dépendances, veuillez consulter la
section «&nbsp;<uri link="?part=2&amp;chap=4#doc_chap4">Écrire un script
d'initialisation</uri>&nbsp;» du Manuel Gentoo.
</p>

</body>
</section>

<section id="variable_name">
<title>Noms et valeurs des variables</title>
<body>

<p>
Le nom des variables est dynamique. En principe, il suit le schéma
<c>variable_${interface|mac|essid|apmac}</c>. Par exemple, la variable
<c>dhcpcd_eth0</c> contient la valeur des options dhcpcd pour eth0 et
<c>dhcpcd_essid</c> contient la valeur des options dhcpcd pour quand une
interface se connecte à l'ESSID «&nbsp;essid&nbsp;».
</p>

<p>
Cependant, il n'y a pas de règle pure et simple stipulant que les noms
d'interface doivent être de la forme ethX. En fait, de nombreuses interfaces
sans fil ont des noms tels que wlanX, raX ou encore ethX. Aussi, les interfaces
définies par l'utilisateur, telles que les ponts réseaux, peuvent avoir
n'importe quel nom, «&nbsp;foo&nbsp;» par exemple. Pour rendre la vie encore
plus intéressante, les bornes d'accès wifi peuvent avoir des noms qui
contiennent des caractères non alphanumériques (c'est important car vous pouvez
configurer les paramètres réseaux en fonction de l'ESSID)...
</p>

<p>
Le problème, dans tout ceci, c'est que Gentoo utilise des variables Bash pour
gérer le réseau... et Bash ne peut rien utiliser d'autre que les alphanumériques
anglais. Pour contourner cette limitation, nous transformons tout caractère qui
n'est pas un alphanumérique anglais en souligné «&nbsp;_&nbsp;».
</p>

<p>
Un autre problème de Bash est le contenu des variables&nbsp;: certains
caractères doivent être échappés. La parade est d'ajouter un antislash
«&nbsp;\&nbsp;» devant chacun de ces caractères. Les caractères qui doivent
être échappés sont <c>"</c>, <c>'</c> et <c>\</c>.
</p>

<p>
Dans cet exemple, nous utilisons un ESSID wifi car ils peuvent contenir un
ensemble plus large de caractères. Disons que nous devons utiliser l'ESSID
<c>Mon "\ rézo</c>&nbsp;:
</p>

<pre caption="Exemple de nom de variable">
<comment># Cela marche, mais le domaine est invalide.</comment>
dns_domain_Mon____r_zo="Mon \"\\ rézo"

<comment># La ligne ci-dessus configure le domaine DNS à « Mon "\ rézo »
# lorsqu'une carte sans fil se connecte à un point d'accès
# dont l'ESSID est « Mon "\ rézo ».</comment>
</pre>

</body>
</section>

</sections>
