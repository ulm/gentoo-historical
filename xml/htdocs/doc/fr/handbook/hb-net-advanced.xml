<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Le contenu de ce document est sous licence CC-BY-SA. -->
<!-- Voir http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/handbook/hb-net-advanced.xml,v 1.6 2006/10/24 15:12:43 cam Exp $ -->

<sections>

<version>7.0</version>
<date>2006-08-30</date>

<section>
<title>Configuration avancée</title>
<body>

<p>
La variable <c>config_eth0</c> est le cœur de la configuration d'une interface.
Sa valeur est une liste d'instructions de haut niveau pour configurer une
interface (<c>eth0</c> dans notre cas). Chaque commande de la liste
d'instructions est exécutée séquentiellement. L'interface est considérée active
si au moins une commande marche.
</p>

<p>
Voici une liste des instructions intégrées&nbsp;:
</p>

<table>
<tr>
  <th>Commande</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>null</c></ti>
  <ti>Ne fait rien.</ti>
</tr>
<tr>
  <ti><c>noop</c></ti>
  <ti>
    Si l'interface est active et possède une adresse, alors annule sa
    configuration en renvoyant un code de succès.
  </ti>
</tr>
<tr>
  <ti>Une adresse IPv4 ou IPv6</ti>
  <ti>Ajoute l'adresse à l'interface.</ti>
</tr>
<tr>
  <ti>
    <c>dhcp</c>, <c>adsl</c> ou <c>apipa</c><br/>
    (ou bien une commande personnalisée venant d'une module tiers)
  </ti>
  <ti>
    Exécute le module qui fournit la commande. Par exemple, <c>dhcp</c>
    exécutera un module qui fournit le DHCP, ce qui peut être <c>dhcpd</c>,
    <c>udhcpc</c> ou <c>pump</c>.
  </ti>
</tr>
</table>

<p>
Si une commande échoue, vous pouvez spécifier une commande de secours. Celle-ci
doit correspondre exactement à la structure de configuration.
</p>

<p>
Vous pouvez enchaîner ces commandes ensemble. Voici quelques <e>vrais</e>
exemples&nbsp;:
</p>

<pre caption="Exemples de configuration">
<comment># Ajout de trois adresses IPv4 :</comment>
config_eth0=(
    "192.168.0.2/24"
    "192.168.0.3/24"
    "192.168.0.4/24"
)

<comment># Ajout d'une adresse IPv4 et deux adresses IPv6</comment>
config_eth0=(
    "192.168.0.2/24"
    "4321:0:1:2:3:4:567:89ab"
    "4321:0:1:2:3:4:567:89ac"
)

<comment># On garde l'adresse déjà assignée par le noyau, sauf si l'interface
# tombe. Dans ce cas, on en assigne une autre grâce à DHCP. Si DHCP ne marche
# pas, alors on ajoute une adresse statique déterminée par APIPA.</comment>
config_eth0=(
    "noop"
    "dhcp"
)
fallback_eth0=(
    "null"
    "apipa"
)
</pre>

<note>
Lorsque vous utilisez le module <c>ifconfig</c> pour ajouter plusieurs
adresses, un alias d'interface est alors créé pour chaque adresse
supplémentaire. Donc, avec les deux exemples précédents, vous obtiendrez
<c>eth0</c>, <c>eth0:1</c> et <c>eth0:2</c>. Vous ne pouvez rien faire de
particulier avec ces interfaces car le noyau et les applications considèreront
<c>eth0:1</c> et <c>eth0:2</c> comme n'étant juste qu'<c>eth0</c>.
</note>

<impo>
L'ordre des commandes de secours est très important&nbsp;! En effet, si nous
n'avions pas spécifié la commande <c>null</c>, alors la commande <c>apipa</c>
aurait été lancée si seule la commande <c>noop</c> avait échoué.
</impo>

<note>
<uri link="?part=4&amp;chap=3#apipa">APIPA</uri> et
<uri link="?part=4&amp;chap=3#dhcp">DHCP</uri> seront expliqués plus tard.
</note>

</body>
</section>

<section>
<title>Dépendance du réseau</title>
<body>

<p>
Les scripts de démarrage du répertoire <path>/etc/init.d/</path> peuvent
dépendre d'une interface réseau particulière ou simplement de <c>net</c>.
Ce que signifie réellement net est configurable grâce à la variable
<c>RC_NET_STRICT_CHECKING</c> dans le fichier <path>/etc/conf.d/rc</path>.
</p>

<table>
<tr>
  <th>Valeur</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>none</c></ti>
  <ti>Le service <path>net</path> est toujours considéré comme actif.</ti>
</tr>
<tr>
  <ti><c>no</c></ti>
  <ti>
    Cela signifie qu'au moins un service <path>net.*</path>, excepté
    <path>net.lo</path>, doit être actif. Cela peut être utile pour les
    utilisateurs de portables qui ont une interface wifi et une statique car
    une seule interface active à la fois suffit.
  </ti>
</tr>
<tr>
  <ti><c>lo</c></ti>
  <ti>
    C'est la même chose que l'option <c>no</c>, mis à part que <path>net.lo</path>
    compte. C'est utile pour les gens qui se fichent d'avoir forcément une
    interface activée au démarrage du système.
  </ti>
</tr>
<tr>
  <ti><c>yes</c></ti>
  <ti>
    Ici, <b>toutes</b> les interfaces réseaux <b>doivent</b> être actives pour
    que le service <path>net</path> soit considéré comme démarré.
  </ti>
</tr>
</table>

<p>
Mais comment fait-on si <path>net.br0</path> dépend de <path>net.eth0</path> et
de <path>net.eth1</path>&nbsp;?  <path>net.eth1</path> peut être une interface
wifi ou bien une connexion ppp qui nécessite une configuration avant de pouvoir
être ajouté au pont réseau. Nous ne pouvons régler ce problème dans
<path>/etc/init.d/net.br0</path> puisque c'est un lien symbolique vers
<path>net.lo</path>.
</p>

<p>
La réponse est que vous pouvez fabriquer votre propre fonction depend() dans
<path>/etc/conf.d/net</path>.
</p>

<pre caption="Les dépendances de net.br0 dans /etc/conf.d/net">
<comment># Vous pouvez utiliser n'importe quel type de dépendance (use, after,
# before) tels qu'on les trouve dans les scripts.</comment>
depend_br0() {
    need net.eth0 net.eth1
}
</pre>

<p>
Pour une explication plus détaillée des dépendances, veuillez consulter la
section «&nbsp;<uri link="?part=2&amp;chap=4#doc_chap4">Écrire un script
d'initialisation</uri>&nbsp;» du Manuel Gentoo.
</p>

</body>
</section>

<section id="variable_name">
<title>Noms et valeurs des variables</title>
<body>

<p>
Le nom des variables est dynamique. En principe, il suit le schéma
<c>variable_${interface|mac|essid|apmac}</c>. Par exemple, la variable
<c>dhcpcd_eth0</c> contient la valeur des options dhcpcd pour eth0 et
<c>dhcpcd_essid</c> contient la valeur des options dhcpcd pour quand une
interface se connecte à l'ESSID «&nbsp;essid&nbsp;».
</p>

<p>
Cependant, il n'y a pas de règle pure et simple stipulant que les noms
d'interface doivent être de la forme ethX. En fait, de nombreuses interfaces
sans fil ont des noms tels que wlanX, raX ou encore ethX. Aussi, les interfaces
définies par l'utilisateur, telles que les ponts réseaux, peuvent avoir
n'importe quel nom, «&nbsp;foo&nbsp;» par exemple. Pour rendre la vie encore
plus intéressante, les bornes d'accès wifi peuvent avoir des noms qui
contiennent des caractères non alphanumériques (c'est important car vous pouvez
configurer les paramètres réseaux en fonction de l'ESSID)...
</p>

<p>
Le problème, dans tout ceci, c'est que Gentoo utilise des variables Bash pour
gérer le réseau... et Bash ne peut rien utiliser d'autre que les alphanumériques
anglais. Pour contourner cette limitation, nous transformons tout caractère qui
n'est pas un alphanumérique anglais en un souligné <c>_</c>.
</p>

<p>
Un autre problème de Bash est le contenu des variables&nbsp;: certains
caractères doivent être échappés. La parade est d'ajouter un antislash
<c>\</c> devant chacun de ces caractères. Les caractères qui doivent
être échappés sont <c>"</c>, <c>'</c> et <c>\</c>.
</p>

<p>
Dans cet exemple, nous utilisons un ESSID wifi car ils peuvent contenir un
ensemble plus large de caractères. Disons que nous devons utiliser l'ESSID
<c>Mon "\ rézo</c>&nbsp;:
</p>

<pre caption="Exemple de nom de variable">
<comment># Cela marche, mais le domaine est invalide.</comment>
dns_domain_Mon____r_zo="Mon \"\\ rézo"

<comment># La ligne ci-dessus configure le domaine DNS à « Mon "\ rézo »
# lorsqu'une carte sans fil se connecte à un point d'accès
# dont l'ESSID est « Mon "\ rézo ».</comment>
</pre>

</body>
</section>

</sections>
