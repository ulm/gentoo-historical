<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/handbook/hb-install-config.xml,v 1.45 2007/03/30 20:38:26 cam Exp $ -->

<sections>

<abstract>
Vous devrez modifier certains fichiers de configuration. Ce chapitre vous donne
un aperçu de ces fichiers et décrit comment procéder.
</abstract>

<version>7.7</version>
<date>2007-03-11</date>

<section>
<title>Information sur le système de fichiers</title>
<subsection>
<title>Qu'est-ce que fstab&nbsp;?</title>
<body>

<p>
Sous Linux, toutes les partitions utilisées par le système doivent être listées
dans <path>/etc/fstab</path>. Ce fichier contient l'information relative aux
points de montage de ces partitions (où elles se situent dans le système de
fichiers de Linux), la façon dont elles sont montées (décrite par des options
spéciales) et les circonstances de leur montage (qui peut être
automatique ou non, sous le contrôle des utilisateurs ou non, etc.).
(N.D.T.&nbsp;: Bien que l'on emploie fréquemment l'expression «&nbsp;monter une
partition&nbsp;», il serait plus exact de dire que l'on monte le système de
fichiers présent sur la partition et non pas la partition elle-même.)
</p>

</body>
</subsection>
<subsection>
<title>Créer /etc/fstab</title>
<body>

<p>
<path>/etc/fstab</path> emploie une syntaxe particulière. Chaque ligne contient
six champs séparés par des blancs (une ou plusieurs espaces ou tabulations ou
encore un mélange d'espaces et de tabulations). Chaque champ a une signification
particulière&nbsp;:
</p>

<ul>
<li>
  Le premier champ indique la <b>partition</b> (il s'agit du chemin d'accès vers
  le fichier matériel).
</li>
<li>
  Le second champ indique le <b>point de montage</b> où la partition sera
  montée.
</li>
<li>
  Le troisième champ indique le <b>type de système de fichiers</b> présent
  sur la partition.
</li>
<li>
  Le quatrième champ indique les <b>options de montage</b> utilisées par
  <c>mount</c> lorsque cette commande tente de monter la partition. Puisque
  chaque type de système de fichiers a ses propres options de montage, vous êtes
  encouragé à lire la page man de la commande mount (<c>man mount</c>) pour
  obtenir une liste complète de ces options. Des options de montage multiples
  doivent être séparées par des virgules.
</li>
<li>
  Le cinquième champ est utilisé par <c>dump</c> pour déterminer si la partition
  doit être «&nbsp;<c>dump</c>ée&nbsp;» ou non. Vous pouvez généralement
  laisser cette valeur à <c>0</c> (zéro).
</li>
<li>
  Le sixième champ est utilisé par <c>fsck</c> afin de déterminer l'ordre dans
  lequel les systèmes de fichiers doivent être vérifiés si le système n'a pas
  été mis hors tension de façon appropriée. Pour le système de fichiers racine,
  la valeur devrait être <c>1</c>. Pour les autres systèmes de fichiers, la
  valeur devrait être <c>2</c> (ou <c>0</c> s'il n'est pas nécessaire de
  vérifier le système de fichiers).
</li>
</ul>

<impo>
Vous devez modifier le fichier <path>/etc/fstab</path> qui a été installé par
Gentoo, car celui-ci n'est qu'un exemple et votre système ne démarrera pas si
vous le laissez tel quel. Ouvrez <c>nano</c> (ou votre éditeur favori) pour
créer votre <path>/etc/fstab</path>&nbsp;:
</impo>

<pre caption="Ouvrir /etc/fstab">
# <i>nano -w /etc/fstab</i>
</pre>

</body>
<body test="func:keyval('/boot')">

<p>
Jetons un coup d'œil à la façon d'écrire l'entrée correspondant à la partition
<path>/boot</path>. Il ne s'agit que d'un exemple, aussi ne le copiez pas si
votre n'avez pas ou ne pouvez pas créer de partition <path>/boot</path>.
</p>

<p test="contains(func:keyval('/boot'), '/dev/hd')">
Dans notre exemple de stratégie de partitionnement par défaut pour les systèmes
<keyval id="arch"/>, <path>/boot</path> est sur la partition 
<path><keyval id="/boot"/></path>(ou <path>/dev/sda*</path> si vous utilisez un
disque SCSI ou SATA) dans un système de fichiers <c>ext2</c>. Il doit être
vérifié au démarrage.  Nous écrivons donc&nbsp;:
</p>

<p test="contains(func:keyval('/boot'), '/dev/sd')">
Dans notre exemple de stratégie de partitionnement par défaut pour les systèmes
<keyval id="arch"/>, <path>/boot</path> est sur la partition 
<path><keyval id="/boot"/></path>, dans un système de fichiers <c>ext2</c>.
Il doit être vérifié au démarrage.  Nous écrivons donc&nbsp;:
</p>

<pre caption="Exemple d'une ligne pour /boot dans /etc/fstab">
<keyval id="/boot"/>   /boot     ext2    defaults        1 2
</pre>

<p>
Certains utilisateurs ne désirent pas que leur partition <path>/boot</path>
soit montée automatiquement au démarrage pour des raisons de sécurité. Dans ce
cas, il convient de remplacer <c>defaults</c> par <c>noauto</c>. Ceci signifie
que la partition <path>/boot</path> devra être montée manuellement avant chaque
usage, par exemple pour installer un nouveau noyau et configurer grub.
</p>

</body>
<body>

<p test="not(func:keyval('arch')='SPARC')">
Ajoutez les règles qui correspondent à votre schéma de partitions ainsi que
les règles pour <path>/proc</path>, <c>tmpfs</c>, vos lecteurs de CD-ROM,
et, si vous en avez, pour vos disques et partitions supplémentaires.
</p>

<p test="func:keyval('arch')='SPARC'">
Ajoutez les règles qui correspondent à votre schéma de partitions ainsi que 
les règles pour <path>/proc/openprom</path>, <path>/proc</path>, <c>tmpfs</c>,
vos lecteurs de CD-ROM et, si vous en avez, pour vos disques et partitions
supplémentaires.
</p>

<p>
Maintenant, servez-vous de l'<e>exemple</e> ci-dessous pour créer votre
<path>/etc/fstab</path>&nbsp;:
</p>

<pre caption="Un exemple complet de fichier /etc/fstab" test="func:keyval('arch')='AMD64' or func:keyval('arch')='x86'">
<keyval id="/boot"/>   /boot        ext2    defaults,noatime     1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1

proc        /proc        proc    defaults             0 0
shm         /dev/shm     tmpfs   nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre>

<pre caption="Un exemple complet de fichier /etc/fstab" test="func:keyval('arch')='HPPA'">
<keyval id="/boot"/>   /boot        ext2    defaults,noatime     1 2
/dev/sda3   none         swap    sw                   0 0
/dev/sda4   /            ext3    noatime              0 1

proc        /proc        proc    defaults             0 0
shm         /dev/shm     tmpfs   nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre>

<pre caption="Un exemple complet de fichier /etc/fstab" test="func:keyval('arch')='Alpha' or func:keyval('arch')='MIPS'">
<keyval id="/boot"/>   /boot        ext2    defaults,noatime     1 2
/dev/sda2   none         swap    sw                   0 0
/dev/sda3   /            ext3    noatime              0 1

proc        /proc        proc    defaults             0 0
shm         /dev/shm     tmpfs   nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre>

<pre caption="Un exemple complet /etc/fstab example" test="func:keyval('arch')='SPARC'">
/dev/sda1   /               ext3        noatime              0 1
/dev/sda2   none            swap        sw                   0 0
/dev/sda4   /usr            ext3        noatime              0 2
/dev/sda5   /var            ext3        noatime              0 2
/dev/sda6   /home           ext3        noatime              0 2

openprom    /proc/openprom  openpromfs  defaults             0 0
proc        /proc           proc        defaults             0 0
shm         /dev/shm        tmpfs       nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom      auto        noauto,user          0 0
</pre>

<note test="func:keyval('arch')='PPC'">
Il y a d'importantes modifications à faire selon le type de machine PPC.
Faites attention à bien adapter l'exemple qui suit à votre configuration.
</note>

<pre caption="Un exemple complet de fichier /etc/fstab" test="func:keyval('arch')='PPC'">
/dev/hda4   /            ext3    noatime              0 1
/dev/hda3   none         swap    sw                   0 0

proc        /proc        proc    defaults             0 0
shm         /dev/shm     tmpfs   nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre>

<pre caption="A full /etc/fstab example" test="func:keyval('arch')='PPC64'">
/dev/sda4   /            ext3    noatime              0 1
/dev/sda3   none         swap    sw                   0 0

proc        /proc        proc    defaults             0 0
shm         /dev/shm     tmpfs   nodev,nosuid,noexec  0 0

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre>																											       	

<p>
L'option <c>auto</c> indique à <c>mount</c> de tenter de deviner le type du
système de fichiers (ce qui est recommandé pour les périphériques amovibles
puisqu'ils peuvent contenir différents types de systèmes de fichiers). L'option
<c>user</c> permet aux utilisateurs (autres que root) de monter le système de 
fichiers (en l'occurence celui présent sur le CD-ROM).
</p>

<p>
Afin d'améliorer les performances, la plupart des utilisateurs devraient
ajouter l'option <c>noatime</c> au champ options de montage, ce qui donnera un
système plus rapide puisque les temps d'accès ne seront pas consignés. De
toute façon, vous n'en avez généralement pas besoin.
</p>


<p>
Relisez votre <path>/etc/fstab</path>, sauvegardez, puis quittez l'éditeur.
</p>

</body>
</subsection>
</section>
<section>
<title>Information réseau</title>
<subsection>
<title>Nom d'hôte, nom de domaine, etc.</title>
<body>

<p>
Une des choses que chaque utilisateur doit faire est nommer son PC. Cela
peut sembler aisé, mais de <e>nombreux</e> utilisateurs ont bien du mal à
trouver un nom approprié pour leur PC Linux. Afin d'accélérer les choses,
dites-vous que le nom que vous choisissez maintenant pourra être changé plus
tard. Si vous êtes embêté, nommez temporairement votre système <c>tux</c> et
choisissez <c>homenetwork</c> comme nom de domaine.
</p>

<pre caption="Définir le nom d'hôte">
# <i>nano -w /etc/conf.d/hostname</i>
<comment>(Attribuez le nom de votre machine à la variable HOSTNAME.)</comment>
HOSTNAME="<i>tux</i>"
</pre>

<p>
Ensuite, <e>si</e> vous avez <e>besoin</e> d'un nom de domaine, définissez-le
dans <path>/etc/conf.d/net</path>. Vous avez besoin d'un nom de domaine
uniquement si votre fournisseur d'accès ou si votre administrateur vous
l'indiquent ou si vous utilisez un serveur DNS sans utiliser de serveur DHCP.
Vous n'avez pas à vous occuper du DNS ou du nom de domaine si votre réseau est
configuré via DHCP.
</p>

<pre caption="Définir le nom de domaine">
# <i>nano -w /etc/conf.d/net</i>
<comment>(Attribuez le nom de votre domaine à la variable dns_domain.)</comment>
dns_domain_lo="<i>mondomaine</i>"
</pre>

<note>
Si vous choisissez de ne pas spécifier de nom de domaine, vous devriez éditer
le fichier <path>/etc/issue</path> en y supprimant la chaine <c>.\O</c> afin de
ne pas avoir ce genre de message de bienvenue au login&nbsp;: «&nbsp;This is
hostname.(none)&nbsp;».
</note>

<p>
Si vous avez un domaine NIS, vous devez également le définir&nbsp;: (Si vous
ne savez pas ce qu'est un domaine NIS, vous n'en avez certainement pas.)
</p>

<pre caption="Définir le domaine NIS">
# <i>nano -w /etc/conf.d/net</i>
<comment>(Attribuez le nom de votre domaine à la variable nis_domain.)</comment>
nis_domain_lo="<i>mondomaineNIS</i>"
</pre>

<note>
Pour plus d'information sur la configuration du DNS et du NIS, lisez l'exemple
fourni dans le fichier <path>/etc/conf.d/net.example</path>. En plus, vous
pourriez être intéressé par l'installation du paquet <c>resolvconf-gentoo</c>
pour vous aider à gérer votre configuration DNS/NIS.
</note>

</body>
</subsection>
<subsection>
<title>Configurer le réseau</title>
<body>

<p>
Si vous éprouvez une sensation de déjà-vu, souvenez-vous que les paramètres
réseau que vous avez définis au début de l'installation ne concernaient que
l'installation elle-même. Vous devez maintenant vous attarder à la configuration
permanente du réseau pour votre système Gentoo.
</p>

<note>
Ce manuel détaille la <uri link="?part=4">configuration réseau</uri>, y compris
les ponts, le couplage d'interface, les réseaux 802.1Q et sans fil, plus loin.
</note>

<p>
Toute l'information réseau est rassemblée dans <path>/etc/conf.d/net</path>. Ce
fichier utilise une syntaxe simple mais pas nécessairement intuitive si vous ne
savez pas comment paramétrer manuellement un réseau. Pas d'inquiétude, tout
vous sera expliqué. Un exemple commenté complet se trouve dans le fichier
<path>/etc/conf.d/net.example</path>.
</p>

<p>
DHCP est utilisé par défaut.  Pour que le DHCP fonctionne, vous devez installer
un client DHCP.  La procédure à suivre est décrite dans <uri link="?part=1&amp;chap=9#networking-tools">
installation des outils systèmes</uri>. N'oubliez pas d'installer un
client DHCP.
</p>

<p>
Si vous devez configurer votre réseau soit pour spécifier des options
particulières pour DHCP, soit parce que vous n'utilisez pas DHCP, ouvrez le
fichier <path>/etc/conf.d/net</path> avec votre éditeur favori&nbsp;:
</p>

<pre caption="Ouvrir /etc/conf.d/net">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
Vous devriez voir le fichier suivant&nbsp;:
</p>

<pre caption="Fichier /etc/conf.d/net par défaut">
# This blank configuration will automatically use DHCP for any net.*
# scripts in /etc/init.d.  To create a more complete configuration,
# please review /etc/conf.d/net.example and save your configuration
# in /etc/conf.d/net (this file :]!).
</pre>

<p>
Pour entrer une adresse fixe, un masque de réseau et une adresse de passerelle,
vous devez définir <c>config_eth0</c> et <c>routes_eth0</c>&nbsp;:
</p>

<pre caption="Définir une adresse statique pour eth0">
config_eth0=( "192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255" )
routes_eth0=( "default gw 192.168.0.1" )
</pre>

<p>
Pour utiliser DHCP et lui passer des options, définissez les variables
<c>config_eth0</c> et <c>dhcp_eth0</c>&nbsp;:
</p>

<pre caption="Obtenir une adresse IP automatiquement avec DHCP">
config_eth0=( "dhcp" )
dhcp_eth0="nodns nontp nonis"
</pre>

<p>
Le fichier <path>/etc/conf.d/net.example</path> contient une série d'exemples
commentés pour vous aider à configurer votre réseau.
</p>

<p>
Si vous avez plusieurs interfaces réseau, répétez ces étapes avec
<c>config_eth1</c>, <c>config_eth2</c>, etc.
</p>

<p>
Sauvegardez votre configuration, puis quittez l'éditeur afin de poursuivre.
</p>

</body>
</subsection>
<subsection>
<title>Activer les connexions réseau automatiquement au démarrage</title>
<body>

<p>
Pour que vos interfaces réseau soient activées automatiquement lors du
démarrage, vous devez les ajouter au niveau d'exécution «&nbsp;default&nbsp;».
Si vous avez des interfaces PCMCIA, vous devriez ignorer cette section puisque
les interfaces PCMCIA sont activées par le script PCMCIA.
</p>

<pre caption="Ajouter net.eth0 au niveau d'exécution « default »">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
Si vous avez plusieurs interfaces réseau, vous devez créer les scripts
appropriés (<path>net.eth1</path>, <path>net.eth2</path> etc.). Pour ce faire,
utilisez <c>ln</c>&nbsp;:
</p>

<pre caption="Créer des scripts d'initialisation supplémentaires">
# <i>cd /etc/init.d</i>
# <i>ln -s net.lo net.eth1</i>
# <i>rc-update add net.eth1 default</i>
</pre>

</body>
</subsection>
<subsection>
<title>Noter l'information relative au réseau</title>
<body>

<p>
Vous devez maintenant fournir à Linux l'information relative à votre réseau.
Cela est défini dans <path>/etc/hosts</path> et permet de faire le lien entre
les noms d'hôtes et les adresses IP pour les hôtes qui ne sont pas gérés par le
serveur de noms. Vous devez y faire figurer votre propre machine. Vous pouvez
également y mettre d'autres machines de votre réseau si vous ne voulez pas
configurer un serveur DNS interne.
</p>

<pre caption="Ouvrir /etc/hosts">
# <i>nano -w /etc/hosts</i>
</pre>

<pre caption="Inscrire les informations réseau">
<comment>(Ceci sert à définir votre propre machine)</comment>
127.0.0.1     tux.homenetwork tux localhost

<comment>(Définit des machines supplémentaires sur le réseau. Ces machines
doivent avoir une IP statique pour que celà fonctionne.)</comment>
192.168.0.5   jenny.homenetwork jenny
192.168.0.6   benny.homenetwork benny
</pre>

<p>
Sauvegardez et quittez l'éditeur afin de poursuivre.
</p>

<p test="func:keyval('arch')='AMD64' or func:keyval('arch')='x86' or substring(func:keyval('arch'),1,3)='PPC'">
Si vous n'avez pas de PCMCIA, vous pouvez maintenant poursuivre avec <uri
link="#sysinfo">Information système</uri>. Les utilisateurs de PCMCIA
devraient lire ce qui suit&nbsp;:
</p>

</body>
</subsection>
<subsection test="func:keyval('arch')='AMD64' or func:keyval('arch')='x86' or substring(func:keyval('arch'),1,3)='PPC'">
<title>Facultatif&nbsp;: Activer PCMCIA</title>
<body>

<p>
Les utilisateurs de PCMCIA devraient d'abord installer le paquet
<c>pcmcia-cs</c>.  Les utilisateurs de noyaux 2.6.x doivent aussi installer ce
paquet même si les pilotes installés par ce paquet ne seront pas utilisés.
L'ajout de <c>USE="-X"</c> est nécessaire pour éviter d'installer xorg-x11 en
même temps&nbsp;:
</p>

<pre caption="Installer pcmcia-cs">
# <i>USE="-X" emerge pcmcia-cs</i>
</pre>

<p>
Lorsque <c>pcmcia-cs</c> est installé, ajoutez <c>pcmcia</c> au
niveau d'exécution «&nbsp;default&nbsp;».
</p>

<pre caption="Ajouter pcmcia au niveau d'exécution « default »">
# <i>rc-update add pcmcia default</i>
</pre>

</body>
</subsection>
</section>
<section id="sysinfo">
<title>Information système</title>
<subsection>
<title>Mot de passe root</title>
<body>

<p>
Pour commencer, définissons le mot de passe root en tapant&nbsp;:
</p>

<pre caption="Définition du mot de passe root">
# <i>passwd</i>
</pre>

<p>
Si vous voulez pouvoir vous identifier en tant que root en passant par la console
série, ajoutez <c>tts/0</c> à <path>/etc/securetty</path>&nbsp;:
</p>

<pre caption="Ajout de tts/0 à /etc/securetty">
# <i>echo "tts/0" &gt;&gt; /etc/securetty</i>
</pre>

</body>
</subsection>
<subsection>
<title>Informations sur le système</title>
<body>

<p>
Gentoo utilise <path>/etc/rc.conf</path> pour la configuration générale qui
s'applique à l'ensemble du système. Ouvrez <path>/etc/rc.conf</path> et
appréciez les commentaires qui s'y trouvent&nbsp;:)
</p>

<pre caption="Ouvrir /etc/rc.conf">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
Ensuite, sauvez votre fichier et quittez votre éditeur.
</p>

<p>
Comme vous pouvez le voir, ce fichier est généreusement commenté afin de vous
aider à paramétrer les différentes variables relatives à la configuration.
Vous pouvez configurer votre système pour qu'il utilise Unicode. Vous pouvez
aussi définir votre éditeur par défaut et votre gestionnaire d'affichage
préféré (gdm ou kdm).
</p>

<p>
Le fichier <path>/etc/conf.d/keymaps</path> permet de spécifier le type de
clavier que vous utilisez.
</p>


<pre caption="Ouvrir /etc/conf.d/keymaps">
# <i>nano -w /etc/conf.d/keymaps</i>
</pre>

<p>
La valeur que vous attribuez à la variable <c>KEYMAP</c> détermine la
disposition des touches de votre clavier. Si vous choisissez une valeur
incorrecte, vous serez surpris quand vous taperez sur votre clavier.
</p>

<note test="func:keyval('arch')='SPARC'">
Si vous utilisez un système <b>SPARC</b> avec USB ou un clone de <b>SPARC</b>,
vous devrez peut-être sélectionner une disposition clavier «&nbsp;i386&nbsp;»
(par exemple «&nbsp;us&nbsp;») au lieu de «&nbsp;sunkeymap&nbsp;».
</note>
<note test="substring(func:keyval('arch'),1,3)='PPC'">
La plupart des systèmes <b>PPC</b> utilisent des définitions de clavier x86. Si
vous voulez utiliser une disposition ADB, vous devez l'activer quand vous
compilez votre noyau et ensuite définir une disposition mac/ppc dans
<path>/etc/conf.d/keymaps</path>.
</note>


<p>
Quand vous en avez terminé avec le fichier <path>/etc/conf.d/keymaps</path>,
sauvez et quittez.
</p>

<p>
Ensuite, éditez le fichier <path>/etc/conf.d/clock</path> pour configurer les
options relatives à l'horloge&nbsp;:
</p>

<pre caption="Ouvrir /etc/conf.d/clock">
# <i>nano -w /etc/conf.d/clock</i>
</pre>

<p>
Si l'horloge de votre PC n'utilise pas l'heure UTC, vous devez ajouter
<c>CLOCK="local"</c> à ce fichier sans quoi votre horloge fera des «&nbsp;saut
d'heures&nbsp;».
</p>

<p>
Lorsque vous aurez fini de configurer <path>/etc/conf.d/clock</path>,
sauvegardez puis quittez l'éditeur.
</p>

<p test="not(func:keyval('arch')='PPC64')">
Poursuivez votre lecture avec l'<uri link="?part=1&amp;chap=9">installation des 
outils systèmes</uri>.
</p>

</body>
</subsection>
<subsection test="func:keyval('arch')='PPC64'">
<title>Configurer la console</title>
<body>

<p>
Vous devez décommenter la ligne appropriée hvc dans le fichier <path>/etc/inittab</path>
pour obtenir une invite sur la console virtuelle.
</p>

<pre caption="Activer hvc ou hvsi dans /etc/inittab">
hvc0:12345:respawn:/sbin/agetty -L 9600 hvc0
hvsi:12345:respawn:/sbin/agetty -L 19200 hvsi0
</pre>

<p>
Veuillez vérifier que la console que vous venez d'activer se trouve dans le
fichier <path>/etc/securetty</path>.
</p>

<p>
Poursuivez votre lecture avec l'<uri link="?part=1&amp;chap=9">installation des
outils systèmes</uri>.
</p>

</body>
</subsection>
</section>
</sections>
