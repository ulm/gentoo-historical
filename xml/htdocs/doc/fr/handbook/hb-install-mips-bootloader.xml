<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/handbook/hb-install-mips-bootloader.xml,v 1.9 2005/03/30 09:04:00 neysx Exp $ -->

<sections>

<version>1.7</version>
<date>2005-03-30</date>

<section id="sgi">
<title>Configuration de arcboot pour les machines Silicon Graphics</title>
<subsection>
<title>Installer arcboot</title>
<body>

<p>
Jusqu'à présent, ce guide présentait comment construire son noyau, le copier
dans l'en-tête du volume SGI avec <c>dvhtool</c>. Cette méthode présentait deux
problèmes importants&nbsp;:
</p>

<ul>
  <li>Elle n'est pas supportée sur tous les systèmes SGI&nbsp;:</li>
  <li>Elle requiert un en-tête du volume SGI relativement importante.</li>
</ul>

<p>
Afin de pouvoir démarrer sur votre machine, un chargeur de démarrage a été
développé. <c>Arcboot</c> vous permet de laisser votre noyau sur
<path>/boot</path> (qui doit être une partition EXT2/3) au lieu de le mettre
directement dans l'en-tête du volume SGI. Il suffit d'indiquer à <c>arcboot</c>
(qui est placé dans l'en-tête du volume SGI à la place du noyau) où se situe
celui-ci. Nous allons donc dans un premier temps installer un certain nombre
d'outils qui seront utilisés plus tard.
</p>

<pre caption="Installation des outils nécessaires">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Cela devrait vous avoir installé deux outils&nbsp;: <c>arcboot</c>, qui sera mis
dans l'en-tête du volume SGI et chargera le noyau pour nous, et <c>dvhtool</c>,
qui permettra de placer <c>arcboot</c> dans ledit en-tête.
</p>

<p>
Le binaire que nous recherchons se cache dans <path>/usr/lib/arcboot</path>. Sur
les systèmes IP22 (Indy, Indigo 2, Challenge S), il se nomme en fait
<path>arcboot.ip22</path>. Les autres systèmes devraient être similaires. Nous
allons tout d'abord copier ce fichier dans l'en-tête du volume SGI.
</p>

<pre caption="Installer arcboot dans l'en-tête du volume SGI">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Ensuite, vérifiez que le fichier est bien dans l'en-tête du volume SGI.
</p>

<pre caption="Vérification de la bonne installation de arcboot">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Vous remarquerez que, dans mon cas, j'ai déjà deux anciens noyaux là-dedans,
<path>linux</path> et <path>newlinux</path>. Ils viennent de l'installation que
j'avais faite avant de commencer à utiliser <c>arcboot</c>. Leur présence n'est
pas dérangeante, tant que <c>arcboot</c> est là tout va bien.
</note>

</body>
</subsection>

<subsection>
<title>Configurer arcboot</title>
<body>

<p>
Si vous avez déjà mis en place le logiciel Linux Loader (<c>lilo</c>) auparavant
vous remarquerez que <c>arcboot</c> utilise une syntaxe similaire pour son
fichier de configuration. Souvenez-vous cependant bien que <c>arcboot</c>
s'attend à trouver son fichier de configuration sur une partition de type EXT2/3
et qu'il doit se nommer <path>/etc/arcboot.conf</path>. Le meilleur moyen de
s'en assurer est d'avoir <path>/boot</path> sur une partition EXT2/3 et de
placer le fichier <path>arcboot.conf</path> dans le répertoire
<path>/boot/etc</path>. Vous trouverez un exemple de fichier de configuration
dans <path>/etc/arcboot.conf.sample</path>.
</p>

<pre caption="Placer arcboot.conf au bon endroit">
<comment>(Création du répertoire /boot/etc)</comment>
# <i>mkdir /boot/etc</i>

<comment>(Mettre notre configuration dans ce répertoire)</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(Créer un lien symbolique dans /etc)</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(... et un lien symbolique de /boot sur lui-même)</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Vous pouvez maintenant éditer le fichier <path>/etc/arcboot.conf</path> à votre
convenance. Personnellement j'aime disposer de deux images de noyau&nbsp;:
<path>new</path> qui est une image récemment construire, qui n'est pas sûre de
fonctionner et <path>working</path> qui est une image dont je suis sûr qu'elle
marche. Mon fichier <path>arcboot.conf</path> ressemble plus ou moins à ceci.
</p>

<pre caption="Exemple de configuration pour arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"
<comment># Version de sauvegarde</comment>

label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Une fois que tout est bien configuré, il vous reste quelques petites
modifications à apporter sur la PROM SGI pour que tout fonctionne. Vous pouvez
passer directement au chapitre <uri link="#reboot">Redémarrer votre
système</uri>.<br/>
Le chapitre suivant traite de la configuration des serveurs Cobalt.
</p>

</body>
</subsection>
</section>

<section id="cobalt">
<title>Configuration de CoLo pour les serveurs Cobalt</title>
<subsection>
<title>Installer CoLo</title>
<body>

<p>
Les capacités du firmware installé sur les cartes des serveurs Cobalt sont bien
plus limitées. Le BOOTROM de Cobalt est primitif en comparaison à la PROM SGI et
a un certain nombre de limitations critiques.
</p>

<ul>
  <li>
    Les noyaux sont limités à 675&nbsp;Ko. La taille actuelle de Linux 2.4 fait
    que c'est presque mission impossible pour arriver à un noyau de cette
    taille. Pour les noyaux 2.6, ce n'est même pas la peine d'y penser.
  </li>
  <li>
    Les noyaux 64-bits ne sont pas supportés par le firmware d'origine (en tout
    cas c'est au stade plus qu'expérimental sur les machines Cobalt
    actuellement).
  </li>
  <li>
    Le shell est franchement limité.
  </li>
</ul>

<p>
Pour s'affranchir de toutes ces limitations, un firmware alternatif nommé
<uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> (Cobalt
Loader) a été développé. C'est une image BOOTROM qui peut au choix être
incorporée directement dans la carte du serveur Cobalt ou être chargée par le
firmware actuel.
</p>

<note>
Ce guide va vous indiquer comment installer CoLo afin qu'il soit chargé par le
firmware d'origine. C'est la seule méthode sûre et recommandée d'installer CoLo.
</note>

<warn>
Si vous le souhaitez, vous pouvez tout aussi bien le «&nbsp;flasher&nbsp;» dans
votre serveur et remplacer le firmware originel. Cela dit, vous prenez vos
propres risques en faisant cela. Si quelque chose ne va pas, il vous faudra
supprimer physiquement le BOOTROM et le reprogrammer vous-même avec le firmware
d'origine. Si vous n'êtes pas sur de la méthode, alors <e>NE TOUCHEZ À RIEN</e>.
Nous ne sommes pas responsable de ce que vous ferez si vous ignorez cet
avertissement.
</warn>

<p>
Bon, cela étant dit, nous pouvons procéder à l'installation de CoLo. Tout
d'abord commencez par installer le paquet.
</p>

<pre caption="Installation de colo">
# <i>emerge colo</i>
</pre>

<p>
Maintenant que c'est installé (j'espère que vous avez lu les messages) vous
devriez jeter un coup d'œil au répertoire <path>/usr/lib/colo</path> qui
contient deux fichiers&nbsp;: <path>colo-chain.elf</path>, qui est le
«&nbsp;noyau&nbsp;» à charger par le firmware d'origine, et
<path>colo-rom-image.bin</path>, qui est une image ROM pour remplacer son
BOOTROM. Commençons par monter <path>/boot</path> et y mettre une copie
compressée de <path>colo-chain.elf</path> là où le système s'attend à la
trouver.
</p>

<pre caption="Mettre CoLo à sa place">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configurer CoLo</title>
<body>

<p>
Maintenant, quand le système démarre pour la première fois, il chargera CoLo.
Celui-ci va afficher un menu sur votre LCD à l'arrière de la machine. La
première option (celle par défaut qui sera validée après 5 secondes) est de
démarrer sur le disque dur. Le système propose alors de monter la première
partition Linux qu'il trouvera et d'exécuter le script
<path>default.colo</path>. La syntaxe de ce fichier est très bien documentée
dans la documentation de CoLo (jetez un coup d'œil au fichier
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path> - où X.YY est la version
de CoLo installée) et est très simple.
</p>

<note>
Astuce : gardez toujours deux noyaux, un <path>kernel.gz.working</path> dont
vous savez qu'il fonctionne et <path>kernel.gz.new</path>, celui que vous venez
de compiler. Ensuite, utilisez un lien symbolique vers l'un ou l'autre, ou
faites une copie de l'un d'eux.
</note>

<pre caption="Un fichier default.colo de base">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo refusera de charger un script qui ne commence pas par la ligne
<c>#:CoLo:#</c>. Prenez-le comme une sorte d'équivalent à la ligne
<c>#!/bin/sh</c> dans un script shell.
</note>

<p>
Il est également possible de proposer un menu, comme par exemple quel noyau
et configuration vous souhaitez charger. Le menu aura un délai de réponse par
défaut. Voici la configuration que j'utilise sur mon serveur Cobalt&nbsp;:
</p>

<impo>
Veuillez noter que l'exemple suivant ne fonctionne pas avec <c>menu</c> de la
version 1.11 de Colo. Il fonctionne avec les versions 1.12 et 1.13. 
</impo>

<impo>
La commande <c>menu</c> a été remplacée par <c>select</c> dans la version 1.14
de CoLo. Si avez installé la dernière version, voyez le fichier
<path>menu.colo</path> dans le répertoire <path>examples</path> de CoLo.
</impo>

<pre caption="Configuration avec menu">
<comment>#:CoLo:#</comment>

lcd "Monter hda1"
mount hda1
menu "Quel noyau ?" 50 Working working New new
lcd "Chargement de Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Démarrage..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Ce script demande à l'utilisateur sur quel noyau il veut démarrer (New ou
Working) puis chargera <path>vmlinux.gz.new</path> ou
<path>vmlinux.gz.working</path> selon ce qui aura été choisi. Si aucun choix n'a
été fait dans les 5 secondes (50 dixièmes de secondes) il démarrera sur la
première option.
</p>

</body>

</subsection>
</section>

<section>
<title>Mise en place pour une console en série</title>

<subsection>
<body>

<p>
Bon, l'installation de Linux devrait désormais démarrer correctement, mais
suppose que vous allez vous connecter dessus depuis un terminal physique. Sur
les machines Cobalt, c'est particulièrement ennuyeux dans la mesure où les
terminaux physiques... n'existent pas.
</p>

<note>
Ceux qui ont le luxe de pouvoir utiliser le framebuffer peuvent sauter ce
chapitre s'ils le souhaitent.
</note>

<p>
Tout d'abord, ouvrez un éditeur et allez cherchez le fichier
<path>/etc/inittab</path>.  Dans celui-ci, vous devriez voir les lignes
suivantes&nbsp;:
</p>

<pre caption="Configuration de inittab">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Commencez par enlever le commentaire de la ligne <c>c0</c>. Par défaut il est
configuré pour utiliser un terminal ayant un taux de transfert de 9600bps. Sur
les serveurs Cobalt, vous pouvez changer la valeur à 115200 pour que cela
corresponde au taux de transfert décidé par le BOOTROM. Voici à quoi ressemble
cette section après avoir commenté les lignes pour les terminaux locaux
(<c>c1</c> à <c>c6</c>) dans la mesure où ceux-ci posent problème quand ils ne
peuvent pas ouvrir <path>/dev/ttyX</path>.
</p>

<pre caption="Extrait de la configuration de inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- These are useless on a headless qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Finalement, nous devons indiquer au système que le port série local peut être
considéré comme un terminal sûr. Le fichier qu'il vous faudra modifier est
<path>/etc/securetty</path>. Il contient une liste de terminaux que le système
peut utiliser. Il nous suffit d'ajouter deux lignes pour permettre au port série
d'être utilisé pour se connecter en tant que <c>root</c>.
</p>

<pre caption="Permettre la connexion de root sur la console en série">
<comment>(/dev/ttyS0 -- le nom traditionnel du premier port série)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Ensuite, Linux appelle également cela /dev/tts/0, donc nous
l'ajoutons aussi)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="#reboot">
<title>Redémarrage du système</title>
<subsection>
<body>

<p>
Sortez de l'environnement «&nbsp;chroot&nbsp;» et démontez toutes les partitions
montées. Ensuite, tapez la commande magique tant attendue&nbsp;: <c>reboot</c>.
</p>

<pre caption="Sortie du chroot, démontage des partitions et redémarrage">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Pour les utilisateurs de Cobalt&nbsp;:</e> la suite de ce chapitre concerne
la configuration de la PROM SGI afin qu'elle puisse démarrer <c>arcboot</c>
et charger Linux. Ce n'est pas applicable à la configuration des serveurs
Cobalt. En fait, vous avez fini votre travail de configuration et pouvez
désormais démarrer sur votre système. Passez directement au chapitre&nbsp;:
<uri link="?part=1&amp;chap=11">Finaliser votre installation de Gentoo</uri>.
</note>

</body>
</subsection>
</section>
<section>
<title>Peaufiner la PROM SGI</title>
<subsection>
<body>

<p>
Lorsque vous avez redémarré, allez dans le menu <e>System Maintenance Menu</e>
et sélectionnez <e>Enter Command Monitor</e> (<c>5</c>). Si vous voulez tester
votre nouvelle installation Gentoo, vous n'avez qu'à lancer <c>boot -f &lt;nom
du noyau&gt;</c>. Pour que votre système démarre automatiquement l'installation
Gentoo, vous devez régler quelques variables dans la PROM SGI&nbsp;:
</p>

<pre caption="Configuration de la PROM pour démarrer Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

 <comment>(&lt;périphérique racine&gt; = la partition racine (root) Gentoo, /dev/sda3 par exemple</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;périphérique racine&gt;</i>

<comment>(Pour obtenir la liste des noyaux disponibles, tapez « ls ».)</comment>
&gt;&gt; <i>setenv OSLoader &lt;nom du noyau&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;nom du noyau&gt;</i>

<comment>(Déclarez les paramètres du noyau à passer en argument.)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;paramètres du noyau&gt;</i>

<comment>(Donnez la localisation de l'entête de volume (« Volume Header »).)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Démarrez automatiquement Gentoo.)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Réglez le fuseau horaire.)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Utilisation de la console série - Les utilisateurs de cartes graphiques</comment>
<comment>doivent mettre « g » au lieu de « d1 » (D un).)</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>

<p>
Vous êtes maintenant fin prêt pour apprécier Gentoo&nbsp;! Démarrer votre
installation et concluez avec la <uri link="?part=1&amp;chap=11">finalisation
de l'installation</uri>.
</p>

</body>
</subsection>
</section>
</sections>
