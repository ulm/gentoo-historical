<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/home-router-howto.xml,v 1.3 2004/09/29 14:53:27 neysx Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/fr/home-router-howto.xml" lang="fr">

<title>Guide du routeur personnel</title>

<author title="Auteur">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Traducteur">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>

<abstract>
Ce document montre comment transformer une vieille machine Gentoo en un routeur
destiné à connecter votre réseau personnel à Internet.
</abstract>

<version>1.2</version>
<date>22 septembre 2004</date>

<chapter>
<title>Introduction</title>
<section>
<body>

<p>
Mettre votre propre routeur sur pieds à partir de vieilles pièces détachées
présente quelques avantages par rapport aux routeurs vendus dans le commerce
tels que des Linksys ou autres.  L'avantage majeur est le contrôle que vous
avez sur la connexion&nbsp;;les autres avantages dépendent de votre imagination
et de ce que vous allez décider de faire avec votre routeur.
</p>

<p>
Ce guide va vous montrer comment utiliser NAT («&nbsp;Network Address
Translation&nbsp;») qui permet à plusieurs machines d'accéder à Internet à
partir d'une seule adresse IP, vous expliquer comment installer et utiliser des
services courants tels que DNS (avec dnsmasq), DHCP (avec dhcpd), ADSL (avec
rp-pppoe) et enfin vous présenter quelques exemples sympas d'utilisation de
votre routeur tels que la redirection de ports<!--, la gestion du trafic, les
serveurs mandataires (proxies), etc-->.
</p>

<p>
Avant de poursuivre, veuillez vérifier que vous disposez des éléments requis.
Vous avez besoin d'un ordinateur équipé d'au moins deux cartes réseau. Vous
devez aussi avoir les informations relatives à votre connexion Internet sous la
main (adresses IP, serveurs DNS, passerelle, nom d'utilisateur et mot de
passe). Vous aurez aussi besoin d'un peu de temps et de considération pour
Gentoo.
</p>

<p>
Ce guide utilise les conventions suivantes&nbsp;:
</p>

<ul>
 <li>eth0 - carte réseau connectée à votre réseau local.</li>
 <li>eth1 - carte réseau connectée à internet.</li>
 <li>Le réseau local utilise des adresses IP 192.168.0.xxx</li>
 <li>L'adresse du routeur est fixée à 192.168.0.1</li>
 <li>Le routeur utilise Linux 2.4 ou 2.6&nbsp;; débrouillez-vous tout seul avec 2.0/2.2</li>
</ul>

<impo>
Pour des raisons de sécurité, vous devriez désactiver tous les services qui ne
sont pas indispensables sur votre routeur jusqu'à ce que le pare-feu soit
configuré et activé. Pour afficher les services actifs, lancez
<c>rc-status</c>.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Configuration du noyau</title>
<section>
<body>

<p>
Les pilotes de vos cartes réseau doivent avoir été activés. Pour vérifier si
vos cartes sont activées, utilisez <c>ifconfig</c>. L'affichage sera sans doute
un peu différent, mais l'important est que les deux cartes apparaissent.
</p>

<pre caption="Vérifier les cartes réseau">
# <i>ifconfig -a</i>
eth0      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B8
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x9800 

eth1      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B9
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:10 Base address:0x9400 
</pre>

<p>
Si vos cartes réseau ne sont pas affichées et que vous ignorez quel type de
carte vous avez, utilisez <c>lspci</c>. Cet outil est installé avec <c>emerge
pciutils</c>. Cherchez le texte «&nbsp;Ethernet controller&nbsp;» dans
l'affichage de <c>lspci</c>. Une fois le type de carte déterminé, configurez
votre noyau pour ajouter les pilotes ad hoc.
</p>

<p>
Vous devez aussi ajouter le support de iptables et du NAT (et la gestion du
trafic si vous le désirez). Les options du noyau requises ci-dessous utilisent
la convention suivante&nbsp;:(*) nécessaire, (x) conseillée, (s) gestion du
trafic. Peu importe si vous compilez les options en dur ou en module pour
autant que les modules soient chargés au moment où la fonctionnalité est
utilisée. Le chargement des modules est laissé à la discrétion du lecteur.
</p>

<pre caption="Options réseau du noyau">
<i>Networking options  ---&gt;</i>
<i>   [*] TCP/IP networking</i>
<i>      [*] IP: advanced router</i>
<i>   [*] Network packet filtering (replaces ipchains)</i>
<comment>Avec un noyau 2.4.x, vous devez activer l'option suivante pour DHCP :</comment>
<i>   [*] Socket Filtering</i>

<i>   IP: Netfilter Configuration  ---&gt;</i>
<i>      [*] Connection tracking (required for masq/NAT)</i>
<i>         [x] FTP protocol support</i>
<i>         [x] IRC protocol support</i>
<i>      [*] IP tables support (required for filtering/masq/NAT)</i>
<i>         [*] IP range match support</i>
<i>         [x] MAC address match support</i>
<i>         [*] Multiple port match support</i>
<i>         [*] Packet filtering</i>
<i>            [*] REJECT target support</i>
<i>            [x] REDIRECT target support</i>
<i>         [*] Full NAT</i>
<i>            [*] MASQUERADE target support</i>
<i>         [s] Packet mangling</i>
<i>            [s] MARK target support</i>
<i>         [x] LOG target support</i>

<i>   QoS and/or fair queueing  ---&gt;</i>
<i>      [s] QoS and/or fair queueing</i>
<i>         [s] HTB packet scheduler</i>
<i>         [s] Ingress Qdisc</i>
</pre>

<note>
Certaines options ou leur position peuvent être un peu différentes d'une
version du noyau à une autre, mais vous devriez pourvoir les retrouver.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Connectez-vous à Internet</title>
<section>
<title>Introduction</title>
<body>

<p>
Il y a de nombreuses façons de vous connecter à Internet. L'auteur a
sélectionné les méthodes qui lui sont familières, c'est-à-dire l'ADSL (PPPoE)
et un modem-câble (adresse statique ou dynamique). Si vous voulez ajouter une
méthode, veuillez adresser un courriel à <mail
link="vapier@gentoo.org">l'auteur</mail> (en anglais). Lisez uniquement la
partie relative à votre type de connexion. Ce chapitre est seulement consacré à
la connexion de votre routeur à Internet via eth1.
</p>

</body>
</section>
<section>
<title>ADSL et PPPoE</title>
<body>

<p>
Les logiciels requis pour une connexion ADSL via PPPoE ont été rassemblés dans
un paquet nommé <uri link="http://www.roaringpenguin.com/">Roaring
Penguin</uri> (N.d.t. le manchot rugissant). Il vous suffit de lancer <c>emerge
rp-pppoe</c>. Ensuite, ouvrez le fichier <path>/etc/ppp/pppoe.conf</path> dans
votre éditeur préféré et définissez le nom d'utilisateur et le mot de passe à
utiliser pour la connexion ADSL.
</p>

<note>
Pour que le script net.eth1 fonctionne, vous devez utiliser baselayout-1.10.1
ou une version plus récente.
</note>

<pre caption="Configurer eth1">
<comment>(Remplacez 'vla9h924' par le nom de l'utilisateur et</comment>
<comment>'password' par le mot de passe à utiliser.)</comment>

# <i>nano /etc/ppp/pppoe.conf</i>
<comment># Carte Ethernet connectée au modem ADSL via eth1
ETH=eth1
# Nom d'utilisateur ADSL.
USER=vla9h924</comment>
# <i>nano /etc/ppp/pap-secrets</i>
<comment># client    server  secret
"vla9h924" * "password"</comment>
# <i>nano /etc/conf.d/net</i>
<comment>(Ajoutez une entrée ifconfig_eth1 et attribuez-lui la valeur adsl.)</comment>
ifconfig_eth1=( "adsl" )
# <i>ln -s net.eth0 /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<warn>
Quand votre interface ADSL sera activée, elle créera ppp0. Bien que votre carte
réseau s'appelle eth1, l'adresse IP sera liée à ppp0. À partir de maintenant,
vous devrez remplacer <c>eth1</c> par <c>ppp0</c> dans tous les exemples
proposés.
</warn>

</body>
</section>
<section>
<title>Modem câble avec une adresse IP statique ou dynamique</title>
<body>

<p>
Si votre FAI vous a attribué une adresse statique, vous avez besoin de plus
d'informations que pour une adresse dynamique, c'est-à-dire votre adresse IP et
celles de votre passerelle et des serveurs DNS de votre FAI.
</p>

<pre caption="Configurer eth1">
<comment>Adresse dynamique :</comment>
# <i>emerge dhcpcd</i>
# <i>nano /etc/conf.d/net</i>
<comment>Ajoutez une entrée telle que :</comment>
ifconfig_eth1=( "dhcp" )

<comment>Adresse statique :</comment>
# <i>nano /etc/conf.d/net</i>
<comment>Ajoutez une entrée telle que :</comment>
ifconfig_eth1=( "66.92.78.102 broadcast 66.92.78.255 netmask 255.255.255.0" )
routes_eth1=( "default gw 66.92.78.1" )
# <i>nano /etc/resolv.conf</i>
<comment>Ajoutez une ligne par serveur DNS de votre FAI :</comment>
nameserver 123.123.123.123

<comment>Configuration commune :</comment>
# <i>ln -s net.eth0 /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<p>
Cela devrait suffire.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Connectez votre réseau local</title>
<section>
<body>

<p>
Cette étape est du gâteau par rapport à la précédente.
</p>

<pre caption="Configurer eth0">
# <i>nano /etc/conf.d/net</i>
<comment>Ajoutez cette entrée :</comment>
ifconfig_eth0=( "192.168.0.1 broadcast 192.168.0.255 netmask 255.255.255.0" )
# <i>rc-update add net.eth0 default</i>
# <i>/etc/init.d/net.eth0 start</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Services réseau à activer</title>
<section>
<title>Serveur DHCP</title>
<body>

<p>
Ce serait sympa si tous vos ordinateurs pouvaient se connecter à votre réseau
sans rien devoir reconfigurer ni sans devoir mémoriser des adresses IP.
Installons un serveur DHCP pour allouer des adresses IP automatiquement.
</p>

<p>
Un serveur DHCP, comme son nom l'indique en anglais («&nbsp;Dynamic Host
Configuration Protocol&nbsp;»), permet de configurer les machines qui se
connectent à votre réseau au moment où elles se connectent.  Vous devez
installer Le programme dhcp sur le serveur et le configurer en fonction de
votre réseau (adresses IP valides, serveurs DNS, passerelle, etc.) Ensuite,
quand une machine se connecte, elle exécute un programme client qui reçoit une
configuration du serveur et qui l'utilise automatiquement pour définir vos
paramètres réseau. Vous trouverez un article complet à propos de DHCP sur <uri
link="http://fr.wikipedia.org/wiki/DHCP">Wikipedia</uri>.
</p>

<pre caption="Configurer dhcpd">
# <i>emerge dhcp</i>
# <i>nano /etc/dhcp/dhcpd.conf</i>
<comment>Voici un exemple type de configuration :</comment>
authoritative;
ddns-update-style ad-hoc;
subnet 192.168.0.0 netmask 255.255.255.0 {
	range 192.168.0.100 192.168.0.250;
	default-lease-time 259200;
	max-lease-time 518400;
	option subnet-mask 255.255.255.0;
	option broadcast-address 192.168.0.255;
	option routers 192.168.0.1;
	option domain-name-servers 192.168.0.1;
}
# <i>nano /etc/conf.d/dhcp</i>
<comment>Ajoutez ou décommentez :</comment>
IFACE="eth0"
# <i>rc-update add dhcp default</i>
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Votre routeur est maintenant un serveur DHCP. Connectez d'autres machines sur
votre réseau et observez. Sur un système Windows, vous devez allez dans les
propriétés TCP/IP et sélectionner «&nbsp;Obtain DNS server address
automatically&nbsp;» et «&nbsp;Obtain DNS server address automatically&nbsp;».
Parfois, les changements ne sont pas pris en compte immédiatement. Dans ce cas,
lancez les commandes <c>ipconfig /release</c> et <c>ipconfig 
/renew</c> dans un terminal.
</p>

</body>
</section>
<section>
<title>Serveur DNS</title>
<body>

<p>
Quand vous visitez un site Internet, vous utilisez un nom de site, car c'est
bien plus facile à retenir qu'une adresse IP (vous préférez ebay.com ou
66.135.192.87&nbsp;?) Cela implique l'utilisation d'un serveur DNS qui va
rechercher l'adresse IP d'un serveur à partir du nom du site que vous tapez.
Vous trouverez plus d'informations à propos des serveurs DNS sur <uri
link="http://fr.wikipedia.org/wiki/DNS">Wikipedia</uri>.
</p>

<p>
Vous avez sans doute remarqué que la configuration de notre serveur DHCP
mentionne un serveur DNS à l'adresse 192.168.0.1. et que c'est justement
l'adresse de notre routeur. Puisque nous n'avons pas encore installé de serveur
DNS, il est temps de le faire&nbsp;!
</p>

<pre caption="Configurer dnsmasq">
# <i>emerge dnsmasq</i>
# <i>nano /etc/conf.d/dnsmasq</i>
<comment>Ajoutez l'option "-i eth0" sur la ligne suivante :</comment>
DNSMASQ_OPTS="-i eth0"
# <i>rc-update add dnsmasq default</i>
# <i>/etc/init.d/dnsmasq start</i>
</pre>

<p>
C'était rapide, n'est-ce pas&nbsp;? Vous êtes libre de choisir un autre serveur
DNS, mais dnsmasq fait exactement ce dont nous avons besoin. Il tient un cache
des requêtes DNS émises depuis votre réseau local et transfère les requêtes
pour lesquelles il n'a pas la réponse aux serveurs DNS de votre FAI. Le but
n'est pas de fournir un serveur DNS pour notre domaine, mais simplement de
fournir un serveur DNS à toutes vos machines.
</p>

</body>
</section>
<section>
<title>NAT (ou IP-masquerading ou translation d'adresses)</title>
<body>

<p>
Désormais, vos utilisateurs peuvent se parler sur votre réseau et ils peuvent
envoyer des requêtes DNS, mais ils ne peuvent pas encore accéder à Internet.
Cela vous laisse plus de bande passante, mais cela n'est sans doute pas votre
but.
</p>

<p>
Pour pouvoir connecter plusieurs ordinateurs depuis une seule adresse IP (celle
que votre FAI vous a attribuée), nous avons besoin de NAT pour effectuer des
translations d'adresses IP. En effet, lorsqu'une requête est émise par un de
vos ordinateurs, le monde extérieur (Internet) ne voit que votre adresse
publique. Lorsqu'une réponse arrive sur votre routeur, il doit pouvoir
déterminer quelle machine interne attend la réponse. Vous en apprendrez plus à
propose de NAT sur <uri
link="http://en.wikipedia.org/wiki/NAT">Wikipedia</uri>.
</p>

<note>
Commencez par vérifier que iptables est installé sur votre routeur. Il devrait
avoir été installé automatiquement, mais mieux vaut vérifier. S'il n'est pas
installé, lancez simplement <c>emerge iptables</c>.
</note>

<pre caption="Configurer iptables">
<comment>Effacez les règles en cours :</comment>
# <i>iptables -F</i>
# <i>iptables -t nat -F</i>

<comment>Rendez les services accessibles uniquement à nos machines locales :</comment>
# <i>iptables -I INPUT 1 -i eth0 -j ACCEPT</i>
# <i>iptables -I INPUT 1 -i lo -j ACCEPT</i>
# <i>iptables -A INPUT -p UDP --dport bootps -i ! eth0 -j REJECT</i>
# <i>iptables -A INPUT -p UDP --dport domain -i ! eth0 -j REJECT</i>

<comment>(Facultatif) Autoriser l'accès au serveur ssh depuis l'extérieur :</comment>
# <i>iptables -A INPUT -p TCP --dport ssh -i eth1 -j ACCEPT</i>

<comment>Éliminez les paquets destinés aux ports privilégiés :</comment>
# <i>iptables -A INPUT -p TCP -i ! eth0 -d 0/0 --dport 0:1023 -j DROP</i>
# <i>iptables -A INPUT -p UDP -i ! eth0 -d 0/0 --dport 0:1023 -j DROP</i>

<comment>Ajoutez les règles pour le NAT :</comment>
# <i>iptables -I FORWARD -i eth0 -d 192.168.0.0/255.255.0.0 -j DROP</i>
# <i>iptables -A FORWARD -i eth0 -s 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -A FORWARD -i eth1 -d 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE</i>

<comment>Indiquez au noyau d'effectuer le transfert IP :</comment>
# <i>echo 1 > /proc/sys/net/ipv4/ip_forward</i>
# <i>for f in /proc/sys/net/ipv4/conf/*/rp_filter ; do echo 1 > $f ; done</i>

<comment>Enregistrez les règles ci-dessus pour le prochain démarrage :</comment>
# <i>/etc/init.d/iptables save</i>
# <i>rc-update add iptables default</i>
# <i>nano /etc/sysctl.conf</i>

<comment>Ajouter ou décommentez les lignes ci-dessous :</comment>
net.ipv4.ip_forward = 1
net.ipv4.conf.default.rp_filter = 1
</pre>

<p>
Une fois toutes ces commandes effectuées, les autres machines de votre réseau
devraient pouvoir accéder à Internet comme si elles étaient connectées
directement.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Options sympas (pour un jour de pluie)</title>
<section>
<title>Introduction</title>
<body>

<p>
Croyez-le ou pas, vous avez terminé&nbsp;! La suite de ce guide concerne des
sujets qui peuvent vous intéresser, mais tout ce qui suit est facultatif.
</p>

</body>
</section>
<section>
<title>Transfert de port</title>
<body>

<p>
Dans certains cas, vous voudrez permettre un accès depuis Internet à des
services qui tournent sur des machines de votre réseau local au lieu de votre
routeur, par exemple un serveur FTP, HTTP, SSH ou encore VNC. Le transfert de
port permet cela avec la seule restriction qu'un port ne peut être redirigé que
vers une seule machine. Par exemple, pour un serveur FTP, vous ne pourriez pas
rediriger le port 21 en entrée sur votre routeur vers différentes machines. Si
vous voulez permettre l'accès à trois serveurs FTP différents sur votre réseau,
vous devez choisir d'autres ports. Vous pouvez utilisez le port standard 21
pour un serveur, mais vous devez choisir, par exemple, 123 et 567 pour les deux
autres serveurs.
</p>

<p>
Toutes les règles de transfert de port sont sous la forme <c>iptables -t nat -A
PREROUTING [-p protocole] --dport [port externe sur le routeur] -i eth1 -j DNAT
--to [adresse ip et port vers lesquel rediriger]</c>.  L'outil iptables
n'accepte pas des noms de machine dans les règles de redirection.  Si vous
redirigez vers le même port que le port d'entrée sur votre routeur, vous n'êtes
pas obligé de la répéter dans la règle. Utilisez <c>man 8 iptables</c> pour
plus d'informations.
</p>

<pre caption="Quelques exemples">
<comment>Rediriger le port 2 vers ssh sur un PC interne :</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 2 -i eth1 -j DNAT --to 192.168.0.2:22</i>

<comment>Transfert des requêtes FTP vers un serveur FTP interne :</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 21 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>Transfert des requêtes HTTP vers un serveur Web interne :</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>Transfert des requêtes VNC vers un serveur interne :</comment>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5900 -i eth1 -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5901 -i eth1 -j DNAT --to 192.168.0.3:5900</i>
<comment>Pour vous connecter au VNC de 192.168.0.3, ajoutez ':1' au nom de votre routeur</comment>

<comment>Redirection pour bittorrent :</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 6881:6889 -i eth1 -j DNAT --to 192.168.0.2</i>

<comment>Support du « Game Cube Warp Pipe » :</comment>
# <i>iptables -t nat -A PREROUTING -p udp --dport 4000 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>Support de « Playstation2 Online » :</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 10070:10080 -i eth1 -j DNAT --to 192.168.0.11</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 10070:10080 -i eth1 -j DNAT --to 192.168.0.11</i>
</pre>

<note>
Si vous avez d'autres exemples courants ou intéressants, vous pouvez les
proposer à l'<mail link="vapier@gentoo.org">auteur</mail> (en anglais).
</note>

</body>
</section>
<section>
<title>Identd (pour IRC)</title>
<body>

<p>
IRC utilise beaucoup le service ident. Maintenant que vos utilisateurs de IRC
sont derrière votre routeur, vous devriez utiliser un service ident pour le
routeur et les ordinateurs. Ce service est fourni par le paquet <c>midentd</c>.
</p>

<pre caption="Configurer ident">
# <i>emerge midentd</i>
# <i>rc-update add midentd default</i>
# <i>/etc/init.d/midentd start</i>
</pre>

<p>
D'autres serveurs ident sont disponibles dans Portage. Selon vos besoins,
l'auteur vous recommande <c>oidentd</c> et <c>fakeidentd</c>.
</p>

</body>
</section>

<!--
<section>
<title>Gestion du trafic</title>
<body>

<p>
Ce chapitre tente de simplifier l'article sur la <uri
link="http://www.tldp.org/HOWTO/ADSL-Bandwidth-Management-HOWTO/">gestion de la
bande passante</uri> publié sur TLDP et de l'adapter à Gentoo. N'hésitez pas à
consulter l'original pour plus de détails.
</p>

<p>
Nous allons installer ce que certains appellent «&nbsp;Packet Shaper&nbsp;»,
«&nbsp;<uri link="http://en.wikipedia.org/wiki/Traffic_shaping">Traffic
Shaping</uri>&nbsp;» ou «&nbsp;<uri
link="http://en.wikipedia.org/wiki/QoS">Quality of Service</uri>&nbsp;». En
d'autres mots, nous voulons définir des règles sur notre routeur pour ralentir
certains types de connexions tels que l'envoi de courriels volumineux ou le
téléchargement depuis des réseaux P2P au profit d'autres activités telles que
la navigation sur Internet ou le jeu en ligne.  Une différence de 30 secondes
pendant un jeu en ligne est plus dérangeante que la même différence pendant le
téléchargement d'un fichier.
</p>

<p>
Commencez par vérifier que les options nécessaires ont été sélectionnée dans
votre noyau. Le chapitre sur la <uri link="#doc_chap2">Configuration du
noyau</uri> ci-dessus décrit les options en question. Ensuite, veuillez lancez
la commande <c>emerge iptables iputils</c>, car vous aurez besoin des commande
<c>iptables</c>, <c>ip</c> et <c>tc</c>.
</p>

<p>
Avant de poursuivre, quelques explications théoriques s'imposent. Le système
que nous allons installer est basé sur la classification de flux sur le réseau
et sur l'attribution des priorités à ceux-ci. L'outil <c>itables</c> permet de
classer les flux, <c>iputils</c> permet de définir les priorités entre ces flux
et le noyau se charge du reste.  Notez que vous pouvez exercer un contrôle
strict sur le trafic originaire de votre réseau local, mais que vous très peu
de contrôle sur le trafic entrant. N'oubliez pas que ces exemples sont destinés
à vous mettre en appétit. Si vous voulez allez plus en profondeur, vous devriez
consulter les documentations existantes sur le sujet. Dans cet exemple, nous
utilisons un algorithme d'ordonnancement de paquets nommé «&nbsp;<uri
link="http://luxik.cdi.cz/~devik/qos/htb/">Hierarchical Token Buckets
(HTB)</uri>&nbsp;». Toujours là&nbsp;? Poursuivons.
</p>

<pre caption="Configuration">
DEV=eth1 <comment>Carte réseau connectée à Internet</comment>
RATE_OUT=100 <comment>Bande passante disponible en sortie (en kilo-octets).</comment>
RATE_IN=1400 <comment>Bande passante disponible en entrée (en kilo-octets).</comment>

<comment>Initialisons le système de priorités.</comment>
<comment>La valeur 45 définit le niveau de classification moyen.</comment>
ip link set dev ${DEV} qlen 30
tc qdisc add dev ${DEV} root handle 1: htb default 45
tc class add dev ${DEV} parent 1: classid 1:1 htb rate ${RATE_OUT}kbit
</pre>

<p>
Nous avons ainsi initialisé le système qui permet de gérer les priorités entre
nos flux. Nous avons créé une queue, indiqué au système d'applique l'algorithme
HTB et défini la priorité moyenne à 45. Cette valeur est arbitraire tout comme
les priorités que nous allons définir ci-dessous. Le système compare les
valeurs pour déterminer les priorités. Par exemple, un flux avec une priorité
de 10 passera avant un flux avec une priorité de 45.
</p>

<pre caption="Définition des niveaux de priorité">
tc class add dev $DEV parent 1:1 classid 1:10 htb rate $rkbit ceil $tkbit prio $p
tc qdisc add dev $DEV parent 1:10 handle 10: sfq
</pre>
</body>
</section>
-->

<section>
<title>Serveur de temps</title>
<body>

<p>
Maintenir un ordinateur à l'heure est important pour garantir la bonne santé
d'un système. Une des méthodes les plus courantes est d'utiliser NTP
(«&nbsp;Network Time Protocol&nbsp;»). Le paquet ntp contient un client et un
serveur.
</p>

<p>
Beaucoup d'utilisateurs ont installé ntp sur leur ordinateur. Évidemment, plus
il y a de clients, plus les serveurs sont chargés. Dans un réseau local, on
peut alléger la charge des serveurs publics tout en gardant tous les
ordinateurs à l'heure. De plus, toutes les mises à l'heure sur les machines
locales seront plus rapides. Nous avons juste besoin d'un serveur local sur
notre routeur qui se met à l'heure avec un serveur public sur Internet et qui
est utilisé par toutes les autres machines locales. Commencez par faire
<c>emerge ntp</c> sur votre routeur.
</p>

<pre caption="Configurer un serveur NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Ajustez les paramètres si nécessaire, mais les valeurs par défaut devraient suffire :</comment>
# <i>rc-update add ntp-client default</i>

# <i>nano /etc/ntp.conf</i>
<comment>Ajoutez les lignes suivantes :</comment>
restrict default ignore
restrict 192.168.0.0 mask 255.255.255.0 notrust nomodify notrap
<comment>Ces lignes donnent accès au serveur NTP uniquement aux clients avec une adresse IP 192.168.0.xxx :</comment>
# <i>nano /etc/conf.d/ntpd</i>
<comment>Ajustez les paramètres si nécessaire, mais les valeurs par défaut devraient suffire :</comment>
# <i>rc-update add ntpd default</i>

# <i>/etc/init.d/ntp-client start</i>
# <i>/etc/init.d/ntpd start</i>
</pre>

<p>
Ensuite, exécutez <c>emerge ntp</c> sur les autres machines aussi, mais nous
n'utiliserons que la partie client, ce qui est plus simple.
</p>

<pre caption="Configurer un client NTP">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Remplacez le nom de serveur 'pool.ntp.org' par '192.168.0.1' dans la variable NTPCLIENT_OPTS :</comment>
# <i>rc-update add ntp-client default</i>
# <i>/etc/init.d/ntp-client start</i>
</pre>

</body>
</section>
<section>
<title>Serveur de courrier</title>
<body>

<p>
Plusieurs raisons peuvent vous pousser à utiliser votre propre serveur de
courrier (SMTP) sur votre routeur. L'auteur le fait pour que ses utilisateurs
aient l'impression que leurs courriels sont envoyés immédiatement alors que
l'envoi réel et les multiples tentatives éventuelles sont effectués par le
routeur. Notez que certains FAI (comme Verizon) bloquent le relai de courriels
qui ne sont pas destinés à leurs propres abonnés. De plus, vous pouvez aussi
réduire la bande passante utilisée pour l'envoi de courriels de sorte que
l'émission de grosses pièces jointes ne bloquent pas votre accès à Internet
pendant leur envoi.
</p>

<pre caption="Configurer un serveur SMTP">
# <i>emerge qmail</i>
<comment>Vérifiez que l'affichage de la commande `hostname` est correct.</comment>
# <i>ebuild /var/db/pkg/*-*/qmail-1.03-r*/*.ebuild config</i>
# <i>iptables -I INPUT -p tcp --dport smtp -i ! eth0 -j REJECT</i>
# <i>ln -s /var/qmail/supervise/qmail-send /service/qmail-send</i>
# <i>ln -s /var/qmail/supervise/qmail-smtpd /service/qmail-smtpd</i>
<!--
# <i>cd /etc/tcprules.d</i>
# <i>nano tcp.qmail-smtp</i>
-->
# <i>cd /etc</i>
# <i>nano tcp.smtp</i>
<comment>Ajoutez une entrée comme celle-ci dans la section « allow » :</comment>
192.168.0.:allow,RELAYCLIENT=""
<!--
# <i>tcprules tcp.qmail-qmtp.cdb rules.tmp &lt; tcp.qmail-smtp</i>
-->
# <i>tcprules tcp.smtp.cdb rules.tmp &lt; tcp.smtp</i>
# <i>rc-update add svscan default</i>
# <i>/etc/init.d/svscan start</i>
</pre>

<p>
L'auteur est un inconditionnel de qmail, mais vous êtes libre d'utiliser un
autre MTA. Quand vous configurez vos ordinateurs, définissez 192.168.0.1 comme
serveur SMTP et tout devrait fonctionner tout seul.  Vous trouverez plus
d'informations sur la <uri link="http://qmail.org/">page d'accueil de
qmail</uri>.
</p>

</body>
</section>
<!--
<section>
<title>Détection de virus dans les courriels</title>
<body>

<p>
Si vous désirez activer la détection de virus dans les courriels reçus par vos
utilisateurs, mais que vous ne voulez pas installer un anti-virus sur chaque
poste, vous devriez penser à utiliser <c>pop3vscan</c>, un détecteur de virus
dans les boîtes POP.
</p>

<pre caption="Configurer pop3vscan">
À FAIRE
</pre>

</body>
</section>
-->
</chapter>

<chapter>
<title>Notes finales</title>
<section>
<body>

<p>
L'auteur n'a pas grand chose à ajouter. Toutefois, si vous avez rencontré des
problèmes avec ce guide, veuillez envoyer un courriel à l'<mail
link="vapier@gentoo.org">auteur</mail> (en anglais) ou soumettre un bug dans
notre <uri link="http://bugs.gentoo.org/">système de gestion de bogues</uri>.
De plus, si vous avez de bonnes idées pour améliorer ce guide, n'hésitez pas à
en faire part à l'auteur.
</p>

</body>
</section>
</chapter>
</guide>
