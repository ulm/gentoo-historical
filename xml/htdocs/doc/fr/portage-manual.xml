<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/Attic/portage-manual.xml,v 1.4 2003/10/21 21:54:57 neysx Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/fr/portage-manual.xml">
<title>Manuel Portage</title>
<author title="Auteur"><mail link="blocke@shivan.org">Bruce A.Locke</mail></author>
<author title="Correcteur"><mail link="carl@gentoo.org">Carl Anderson</mail></author>
<author title="Correcteur"><mail link="swift@gentoo.org">Sven Vermeulen</mail></author>
<author title="Correcteur"><mail link="peesh@gentoo.org">Jorge Paulo</mail></author>
<author title="Traducteur"><mail link="nohar@altern.org">Arnaud Cornet</mail></author>
<author title="Traducteur"><mail link="vincent.rubiolo@free.fr">Vincent Rubiolo</mail></author>

<abstract>
Ce manuel fournit une vue générale de Portage, des informations détaillées
de configuration et un guide pour l'installation et la maintenance de
paquets en utilisant le système Portage.
</abstract>

<licence/>

<version>0.9.8</version>
<date>15 september 2003</date>

<chapter>
<title>Portage: Une vue d'ensemble</title>

<section>
  <title>Vue d'ensemble</title>
  <body>
	<p>
	Portage est un système de gestion de paquets très avancé et
	puissant. Sa flexibilité et sa capacité à servir aussi bien de
	moteur de compilation que de former le coeur d'une distribution à 
	la pointe de la technologie lui confèrent le titre de Moteur de
	Méta-Distribution. La distribution Gentoo Linux est conçue autour
	de Portage.
	</p>
	<p>
	Gentoo Linux elle-même est souvent qualifiée de méta-distribution.
	Elle consiste en Portage et plus de 4000 recettes de 
	paquets appelés <i>ebuilds</i>. Ces <i>ebuilds</i> donnent les
	informations nécessaires à Portage pour compiler et installer un
	paquet logiciel. En utilisant des <i>profils</i> et l'utilitaire
	de ligne de commande <i>emerge</i>, les utilisateurs et les
	developpeurs peuvent utiliser Portage pour installer et maintenir
	les paquets qui forment le système d'exploitation et les applications
	d'une machine.
	</p>
	<p>
	Un système Gentoo Linux est "compilé à la volée". Installer Gentoo
	Linux implique la mise en place d'au moins un compilateur et d'un
	environnement de compilation à l'aide duquel Portage peut
	télécharger un code source à partir d'Internet et compiler le reste du
	coeur du système ainsi que n'importe quelle application désirée. 
	Bien que Portage permette l'utilisation de paquets précompilés, ils 
	forment un compromis et ne sont utilisés que pour l'installation sur des
	machines lentes par des developpeurs qui auraient besoin de
	restaurer un paquet rapidement, ou pour permettre à d'autres
	machines plus rapides de compiler pour une machine plus lente.
	</p>
	<p>
	A cause de ces caractéristiques et du fait que Portage soit très 
	configurable dans sa façon de compiler et d'installer les paquets, 
	très peu d'installations Gentoo sont identiques. En bref, quand un
	utilisateur installe Gentoo Linux, le système Portage compile une
	distribution Linux personnalisée selon les options spécifiées dans
	la configuration de Portage et dans les ebuilds.
	</p>	
	<p>
	Au premier abord, l'idée de Portage peut sembler
	similaire au traditionnel système de ports BSD. Tous deux compilent
	des paquets à partir de la source et permettent aux utilisateurs
	d'installer et de désinstaller de façon sûre les logiciels d'un
	système, et tous deux gèrent les dépendances automatiquement. Beaucoup
	d'idées de Portage viennent du système de ports de BSD mais Portage n'est 
	en aucune façon un enième dérivé du système de ports BSD.
	</p>
	<p>
	Le système Portage est le résultat de l'association d'un coeur 
	en Python et d'<i>Ebuilds</i> qui sont des scripts bash. Au lieu de
	gérer des makefiles à l'aide de la commande <i>make</i>, Portage
	associe la puissance de Python et la simplicité d'utilisation des
	scripts bash avec quelques caractéristiques orientées objet afin
	d'obtenir un système unique et puissant que nous pensons supérieur à
	tous les autres systèmes de ports.
	</p>

	<p>
	Certaines  caractéristiques avancées de Portage :
	plusieurs versions/révisions d'un même paquet dans l'arbre,
	dépendances conditionnelles, une gestion fine des paquets, une
	installation sûre, la protection des fichiers de configuration et plus
	encore. Beaucoup de ces particularités sont détaillées plus loin
	dans ce manuel.
	</p>
  </body>
</section>

<section>
<title>Résolution des dépendances conditionnelles et support de caractéristiques spéciales </title>
<body>
	<p>
	Le système Portage est unique de par la flexibilité offerte aux utilisateurs.
	Les systèmes de ports BSD ont tendance à ne supporter qu'une révision de
	paquet à la fois dans l'arbre. Portage ne souffre pas de cette limitation. 
	Plusieurs versions du même paquet peuvent être disponibles et prêtes à être 
	installées. Les dépendances -- les paquets nécessaires pour pouvoir compiler 
	ou utiliser un autre paquet -- peuvent être spécifiées à la version
	près ou grâce à un intervalle de versions. Cela rend
	sûr le fait d'avoir plusieurs versions différentes du même
	paquet dans l'arbre.
	</p>
	<p>
	Le système de dépendances supporte aussi les dépendances
	conditionnelles. Portage utilise le concept puissant de réglage de
	la variable <i>USE</i>. En changeant la valeur de cette variable
	dans un fichier de configuration de Portage, vous pouvez désactiver
	des capacités optionnelles (et donc vous débarrasser des dépendances) 
	de certaines bibliothèques pour tous les paquets à la compilation. 
	Ce système très puissant est décrit plus en détail dans le chapitre
	suivant.
	</p>
	<p>
	De plus, Portage connaît le concept de <i>SLOTS</i>. Au cours
	du développement de Gentoo Linux, les développeurs ont souvent éprouvé le
	besoin d'avoir plusieurs versions de certains paquets (des
	bibliothèques par exemple) installées de façon à satisfaire la
	demande d'autres paquets. L'approche traditionnelle pour résoudre
	ce type de probleme est de traiter les différentes versions du même
	paquet comme des paquets séparés avec des noms légèrement différents.
	</p>
	<p>
	Au lieu que les développeurs aient à apprendre à traiter certaines
	versions comme des paquets séparés, les développeurs ont appris à
	Portage comment gérer et maintenir plusieurs versions du même
	paquet au travers de l'utilisation de <i>SLOTS</i>. Un exemple serait
	de considérer la bibliothèque freetype dont les branches 1.x et 2.x ne 
	sont pas compatibles. Les deux sont cependant nécessaires pour satisfaire 
	les dépendances des logiciels d'un système. La plupart des distributions 
	et des systèmes de ports appellent "freetype" le paquet contenant freetype 
	1.x et "freetype2" le paquet contenant freetype 2.x. Nous considérons cette 
	approche comme le signe d'un système de paquets fondamentalement mal conçu. 
	Nous avons simplement assigné le <i>SLOT</i> numéro 1 à la première version et le 
	<i>SLOT</i> numéro 2 à la deuxième. Grâce à cette information, Portage peut 
	gérer les deux branches simultanément et les mettre à jour indépendamment en 
	fonction des changements apportés à chacune.
	</p>
</body>
</section>

<section>
<title>Profils</title>
<body>

	<p>
	Portage utilise le concept de <i>profils</i>. Un profil
	contient une liste de noms de paquets et de versions ainsi qu'un ensemble
	d'options de configuration utilisées par Portage. Un profil indique à Portage
	quels paquets autoriser, interdire ou considérer comme indispensables.
	Les utilisateurs peuvent changer de profil en changeant un simple lien
	symbolique (<path>/etc/make.profile</path>). Cela peut paraître simple
	mais cela permet à Portage de répondre aux besoins d'une
	distribution et de servir de système de compilation professionnel.
	</p>
	<p>
	L'effort de production de Gentoo Linux a résulté en une collection
	de fichiers <i>ebuild</i> que Portage utilise et d'un profil.
	Ce profil définit quel paquets sont considèrés comme essentiels,
	vitaux au bon fonctionnement du système. Le profil permet aussi
	aux développeurs de bloquer et de débloquer un paquet spécifique
	pour désactiver temporairement un paquet bogué, etc. Les fichiers
	<i>ebuild</i> disent simplement à Portage comment compiler et
	installer le paquet que le profil demande ou autorise.
	</p>
	
</body>
</section>
</chapter>


<chapter>
<title>Configurer Portage</title>

<section>
<title>Vue d'ensemble</title>
<body>
	<p>
	Les chapitres suivants couvrent les différents aspects de la
	configuration de Portage utiles à la fois aux utilisateurs et aux
	développeurs. Portage est un système très flexible et vous allez
	avoir besoin de comprendre comment configurer Portage afin de
	maîtriser votre système et de l'optimiser selon vos besoins.
	</p>
	<p>
	Notez bien que le terme "utilisateur" se réfère dans ce document à
	une personne ayant les droits d'administrateurs sur la machine.
	Vous devez être super-utilisateur (root) pour accéder et changer la 
	configuration de Portage et pour installer ("merger") et désinstaller 
	("unmerger") des paquets.
	</p>
</body>
</section>

<section>
<title>Les Fichiers de configuration de Portage</title>
<body>
	<p>
	Pratiquement toutes les options de configuration dont on parle
	ci-dessous se trouvent dans les fichiers <path>/etc/make.conf</path>,
	<path>/etc/make.profile/make.defaults</path> et
	<path>/etc/make.globals</path>. <path>/etc/make.conf</path> contient 
	différentes variables utilisées par Portage.
	</p>
	<p>	
	En ce qui concerne un réglage du système, Portage vérifiera d'abord les variables
	d'environnement définies puis, si rien n'est trouvé, le fichier 
	<path>/etc/make.conf</path>. Si rien n'est défini dans celui-ci, Portage regarde 
	<path>/etc/make.profile/make.defaults</path>. Enfin, si rien n'existe là non plus, 
	Portage se rabattra sur <path>/etc/make.globals</path>.<br/>
	Veuillez noter que <i>tous</i> les réglages utilisateurs devraient être faits
	par les variables d'environnement ou dans <path>/etc/make.conf</path> qui est 
	destiné à être adapté par l'utilisateur.
	Il est également important de noter que tout réglage fait par l'intermédiaire de 
	<path>/etc/make.conf</path> prendra quasi systématiquement le pas sur celui fait
	dans <path>/etc/make.globals</path>.
	Tous les réglages faits dans <path>/etc/make.conf</path> et <path>/etc/make.globals</path> 
	sont considérés comme généraux et affectent tout le système, 
	du point de vue de Portage.
	</p>
	<p>
	Quand vous vérifiez si une option est déjà définie, il est
	recommandé de vérifier d'abord /etc/make.conf et ensuite
	<path>/etc/make.globals</path>. A moins que le contraire soit 
	spécifié, les options dans <path>/etc/make.conf</path> sont 
	prioritaires par rapport à celles de <path>/etc/make.globals</path>.
	</p>
</body>
</section>

<section>
  <title>Le paramètre USE</title>
  <body>
  	<p>
	Le paramètre USE fournit un moyen flexible de sélectionner ou
	déselectionner des options à la compilation de paquets, ce à un
	niveau global, et pour des paquets individuels. Cela permet à
	l'administrateur de contrôler comment les paquets seront compilés
	en fonction de ce que le paquet propose comme options de
	compilation. Par exemple, les paquets qui proposent l'option GNOME
	pourront être compilés sans le support GNOME en désactivant l'option
	USE "<i>gnome</i>". Sélectionner l'option <i>gnome</i> permettrait
	de compiler le support de GNOME pour chacun de ces mêmes paquets.
	</p>
	<p>
	L'effet d'une option USE sur les paquets dépend du logiciel
	lui-même et du fait que l'ebuild supporte l'option en tant que
	fonctionnalité optionnelle. Si le logiciel n'a pas de capacité à utiliser
	le composant logiciel cité dans l'option USE, alors l'option n'a
	évidemment pas d'effet. De plus, beaucoup de dépendances de paquets 
	ne sont pas considérées comme optionnelles par les logiciels et les options
	de la variable USE n'auront pas d'effet sur ces dépendances.
	Une liste de mot-clefs USE utilisés par un paquet particulier peuvent être
	trouvés en regardant les variables <i>DEPEND</i> et <i>RDEPEND</i>
	dans n'importe quel fichier ebuild.
	</p>

	<p>
	Une liste des paramètres USE utilisés par Gentoo Linux est
	accessible dans <path>/usr/portage/profiles/use.desc</path>. On y trouve
	un paramètre par ligne suivi d'une brève description de ce que le
	paramètre active.
	</p>

	<p>
	Portage détermine si le paramètre USE est sélectionné ou
	désélectionné en vérifiant jusqu'à quatre emplacements différents.
	Ces emplacements changent les paramètres USE en s'"empilant".
	Portage regarde chaque emplacement et se souvient de la valeur
	qu'avait le paramètre à l'emplacement précédent. Les sélections
	ou désélections sont cumulées par Portage.
	</p>
	<p>
	Les emplacements visités par le processus de parcours de la variable USE 
	ainsi que leur ordre sont déterminés par la variable <i>USE_ORDER</i> dans 
	<path>/etc/make.globals</path>. Pour retirer un emplacement, il suffit 
	d'enlever celui-ci de la variable <i>USE_ORDER</i>.
	</p>
	<p>
	Ce qui suit est une description des emplacements, dans l'ordre dans lequel 
	ils sont définis par la variable <i>USE_ORDER</i> de la configuration par 
	défaut de Portage.
	</p>
	
	
	<p><b>Défauts</b></p>
	<p>
	Les "profils" Portage peuvent définir un ensemble de mot-clés USE.
	Ceci est défini dans make.defaults de chaque profil Portage. Comme
	<path>/etc/make.profile</path> est un lien vers le profil actuellement 
	utilisé par Portage, <path>/etc/make.profile/make.defaults</path> 
	contient les défauts utilisés. Il est recommandé de ne pas modifier 
	ce fichier car il sera écrasé à chaque mise a jour de Portage.
	</p>
	<p><b>Auto</b></p>
	<p>
	Auto est défini dans le fichier use.defaults dans le profil de
	Portage (<path>/etc/make.profile/use.defaults</path>). Chaque entrée 
	consiste en un paramètre USE et son paquet correspondant. Si le paquet 
	listé pour un mot-clef USE est actuellement installé, alors le mot
	clef USE est considéré comme sélectionné. Donc, par exemple, si
	vous avez installé <i>x11-base/xfree</i> et n'avez pas
	explicitement désélectionné le paramètre USE X, alors ce paramétre
	est considéré comme sélectionné. Il est recommandé de ne pas
	modifier ce fichier car il sera écrasé à chaque mise à jour de
	Portage.
	</p>

	<p><b>Conf</b></p>
	<p>
	Si des options <i>USE</i> sont définies dans <path>/etc/make.conf</path> 
	alors elles sont utilisées; sinon <path>/etc/make.globals</path> est vérifié. 
	Cette entrée peut ressembler à ceci :</p>

	<pre caption = "Un exemple de variable USE">
USE="slang readline gpm berkdb gdbm tcpd pam libwww ssl gb tk
     lm_sensors lvm ldap tex bonobo sdl gtk xfs evo pda ldap
     mmx mitshm perl python guile ruby postgres dvd 3dnow tcl
     lcms gif sdl vorbis ogg oss libg++ directfb decss snmp
     gnome X opengl mozilla pdflib gpg -nls gd xface jpilot
     -kde -qt -esd -motif -alsa oggvorbis"
	</pre>

	<p>
	Un paramètre USE est séléctionné simplement en faisant apparaître
	son nom dans la liste, il est désélectionné en plaçant devant son
	nom un <i>-</i>. Par exemble <i>gnome</i> sélectionne GNOME et
	<i>-motif</i> désélectionne motif.
	</p>
	<p>
	La variable <i>USE</i> dans <path>/etc/make.conf</path> est celle 
	qu'il est recommandé de modifier pour sélectionner ou désélectionner
	explicitement un mot-clef. Ce fichier ne sera pas écrasé par une
	mise à jour de Portage. Il est recommandé de spécifier ici les
	paramètres USE dont on ne veut pas qu'ils soient modifiés
	dans les deux emplacements précédents.
	</p>
	
	<p><b>Env</b></p>
	<p>
	USE peut être modifié manuellement en utilisant la variable
	d'environnement USE.
	</p>

	<pre caption = "Comment redéfinir la variable USE">
# <i>export USE="-gnome"</i>
# <i>emerge net-im/gaim</i>
	</pre>

	<p>
	Ceci permet d'utiliser une variable USE particulière lors de
	l'installation d'un paquet spécifique. Un appel à emerge après le
	positionnement de la variable USE utilisera la nouvelle variable
	USE du moment que vous appelliez emerge du shell où la variable a
	été positionnée et que cette variable n'ait pas été manuellement
	effacée.
	</p>
	
	<note>
	Bien que Portage enregistre le paramètre USE utilisé lors de
	l'installation d'un paquet, ce paramètre n'est pas persistant. Si
	le paquet est re-emergé ou mis à jour dans le futur, il utilisera
	la variable USE en effet au moment de l'appel à emerge et non pas
	la variable USE utilisée quand il a été installé pour la première
	fois.
	</note>
	
  </body>
</section>

<section>
<title>Options du compilateur</title>
<body>
	<p>
	Les options du compilateur utilisé par Portage pour compiler les
	paquets peuvent être configurées dans <path>/etc/make.conf</path> en éditant les
	variables <i>CHOST</i>, <i>CFLAGS</i> et <i>CXXFLAGS</i>.
	<i>CHOST</i> spécifie la plate-forme pour laquelle vous compilez,
	<i>CFLAGS</i> et <i>CXXFLAGS</i> spécifient les drapeaux (flags) à passer
	aux compilateurs C et C++ respectivement.
	</p>
	<p>
	Plusieurs exemples de variables sont fournies avec des commentaires
	explicant pour quelles plate-formes ils sont adaptés. Ces défauts
	sont testés et considérés comme stables. Les changer peut conduire
	à des erreurs de compilation ou à des bogues à la compilation et à
	l'exécution du programme compilé. S'il vous plaît, soyez précautionneux si 
	vous décidez de configurer un paramètre par défaut car cela peut conduire 
	à un système inutilisable.
	</p>
	<p>
	Les utilisateurs possédant des systèmes multi-processeurs peuvent
	utiliser la variable <i>MAKEOPTS</i> de <path>/etc/make.globals</path>. 
	Cette option est passée à <i>make</i> pendant la compilation d'un paquet
	pour lancer plusieurs compilateurs en même temps.
	</p>
	
</body>
</section>

<section>
<title>Les emplacements des répertoires</title>
<body>
	<p>
	Portage vous permet de configurer les répertoires qu'il utilise
	pour compiler des paquets et là où il enregistre certains fichiers.
	La plupart des utilisateurs n'auront pas besoin de modifier ces
	emplacements. Les variables suivantes peuvent être positionnées :
	</p>

	<ul>
	<li><i>PORTDIR</i> - Emplacement de l'arbre de Portage</li>
	<li><i>DISTDIR</i> - Cache local des archives téléchargées</li>
	<li><i>PKGDIR</i> - Emplacement des paquets tbz2 générés localement</li>
	<li><i>RPMDIR</i> - Emplacement des paquets RPM générés localement</li>
	<li><i>PORTAGE_TMPDIR</i> - Espace temporaire utilisé pour la
	compilation de paquets</li>
	<li><i>BUILD_PREFIX</i> - Associé à PORTAGE_TMPDIR</li>
	<li><i>PKG_TMPDIR</i> - Associé à PKGDIR</li>
	</ul>
</body>
</section>
	

<section>
<title>La protection des fichiers de configuration</title>
<body>
	<p>
	Portage permet la protection de tous les fichiers de répertoires
	spécifiés. Portage n'écrasera pas les fichiers d'un répertoire
	protégé. Si un paquet essaie d'écraser un fichier protégé, il
	sera renommé en quelque chose de la forme <path>._cfg0000_nom</path>, ceci
	afin de permettre à l'utilisateur de fusionner son ancienne
	configuration avec la nouvelle manuellement.
	</p>
	<p>
	Les répertoires protégés sont spécifiés à l'aide de
	<i>CONFIG_PROTECT</i> dans <path>/etc/make.conf</path> ou 
	<path>/etc/make.globals</path>. Des fichiers spécifiques ainsi que des 
	sous-répertoires d'un répertoire protégé sont déprotégés 
	à l'aide de la variable <i>CONFIG_PROTECT_MASK</i>.
	</p>
	<p>
	Ceci est un exemple et ne doit pas être bêtement recopié :
	</p>

<pre caption = "Comment protéger certains répertoires ou fichiers">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/2/share/config"
CONFIG_PROTECT_MASK="/etc/gconf /etc/init.d /etc/pam.d"
</pre>

	<p>Les utilisateurs peuvent obtenir plus d'informations sur la façon dont
	fonctionne la protection des fichiers en appelant la commande suivante 
	depuis un shell :
	</p>

<pre caption = "Obtenir davantage d'informations sur la protection des fichiers">
# <i>emerge --help config</i>
</pre>

</body>
</section>

<section>
<title>CARACTÉRISTIQUES</title>
<body>
	<p>
	Portage offre bon nombre d'options qui facilitent la vie des
	développeurs et qui gouvernent le comportement de Portage et la
	façon dont il nettoie après lui les nombreuses étapes de
	l'installation d'un paquet. Ces options ont un intérêt seulement pour les
	développeurs et peuvent causer des problèmes pour les utilisateurs.
	</p>
	<p>
	La liste des caractéristiques est positionnée à
	l'aide de la variable <i>FEATURES</i> dans <path>/etc/make.conf</path> ou
	<path>/etc/make.globals</path>. Voici la liste des options disponibles:
	</p>
	<p>
	<ul>
	<li><i>digest</i> : Automatiquement créer un digest pour les
	nouveaux ebuilds.</li>
	<li><i>cvs</i> : Automatiquement enregistrer les nouveaux digests
	par cvs.</li>
	<li><i>sandbox</i> : Sélectionne le bac à sable (sandbox) pour la
	protection des préfixes de chemin.</li>
	<li><i>noclean</i> : Portage ne nettoie rien après lui.</li>
	<li><i>noauto</i> : N'exécute pas les étapes précédentes
	à l'installation d'un paquet automatiquement. </li>
     	<li><i>distcc</i> : Activer la compilation distribuée offerte 
	par distcc.</li>
  	<li><i>ccache</i> : Conserver les fichiers objets pour gagner du 
	temps à la recompilation.</li>
  	<li><i>buildpkg</i> : Créer un paquet binaire lors de l'installation 
	de chaque ebuild.</li>
  	<li><i>userpriv</i> : Abandonner les privilèges super-utilisateur lors 
	de la compilation.</li>
  	<li><i>usersandbox</i> : Utiliser le bac à sable (sandboxing) lorsque 
	<i>userpriv</i> est activé.</li>
  	<li><i>keeptemp</i> : Ne pas effacer les fichiers temporaires (${T}) 
	après une installation.</li>
  	</ul>
  	Certaines de ces caractéristiques peuvent être ajustées plus finement à 
	l'aide des variables suivantes :
  	<ul>
  	<li><i>CCACHE_SIZE</i> : Définit combien de mémoire <c>ccache</c> peut 
	être utilisée. Le réglage par défaut est de 2 Go.</li>
  	<li><i>DISTCC_HOSTS</i> : Définit quelles sont les machines qui vont 
	participer à la compilation distribuée grâce à <c>distcc</c>. Chacune 
	d'elle doit exécuter le démon <c>distccd</c>.</li>
	</ul>
	</p>
</body>
</section>

<section>
<title>Les réglages SYNC de Portage</title>
<body>
	<p>
	Portage a la capacité de mettre à jour l'arbre de Portage à travers rsync. 
	Si vous trouvez un autre moyen de mettre à jour l'arbre Portage, vous pouvez 
	définir quelle méthode utiliser dans la variable <i>SYNC</i> de 
	<path>/etc/make.conf</path>.
	</p>

	<p><b>RSYNC</b></p>

	<p>
	rsync est la méthode la plus classique pour tenir un arbre Portage à jour. Elle
	est activée dans <path>/etc/make.conf</path></p>

<pre caption = "Réglage de la variable SYNC">
SYNC="rsync://cvs.gentoo.org/gentoo-x86-portage"
</pre>

	<note>
	Cette méthode écrase bêtement les changements que vous avez pu
	effectuer à votre arbre Portage local. Si vous avez besoin de
	les conserver , utilisez
	PORTDIR_OVERLAY=/endroit/ou/vous/voulez/sauver-votre-arbre-original
	pour protéger vos changements.
	</note>
        <note>
	<path>/etc/make.conf</path> contient des informations sur le réglage 
	de la variable <i>SYNC</i> pour se connecter automatiquement au serveur
	rsync géographiquement plus proche de chez vous. Cela donne généralement 
	des taux de transferts plus élevés et permet de répartir la charge sur 
	l'ensemble des serveurs.
	</note>

	<p><b>Accès CVS pour développeur</b></p>

	<p>
	Les développeurs ayant un acces complet à l'arbre CVS peuvent également 
	utiliser <i>emerge</i> pour qu'il synchronise l'arborescence locale avec 
	un repository CVS auquel ils accèdent par ssh.
	</p>
	<p>
	Rapatriez simplement une copie de l'arbre CVS en utilisant votre compte 
	("checkout"), déplacez-le vers <path>/usr/portage</path>, 
	et utilisez cette option de <i>SYNC :</i>
	</p>
	
<pre caption = "Utilisation de CVS avec votre arborescence locale">
SYNC="cvs://votrecompte@cvs.gentoo.org:/home/cvsroot"
</pre>

</body>
</section>

<section>
<title>Miroirs</title>
<body>
	<p>
	Le projet Gentoo maintient un miroir local de toutes les archives
	référencées dans les ebuilds de l'arbre Portage. Souvent, les
	sources sont conservées sur des serveurs lents qui peuvent être
	régulièrement indisponibles. Les développeurs effacent également les
	anciennes versions de leurs sources quand ils en mettent une nouvelle à disposition.
	Pour simplifier la vie des utilisateurs de la 
	distribution Gentoo (et pour réduire l'utilisation de la bande passante 
	du site conservant les sources) nous gardons une copie de ces fichiers. 
	Cela permet un téléchargement plus rapide et plus fiable depuis l'un des 
	miroirs localisés près de votre emplacement géographique.
	</p>
	<p>
	Quand vous tentez d'installer un paquet, Portage essaie d'abord de
	vérifier si notre miroir possède cette archive. Si le miroir ne la
	possède pas, alors Portage essaie de télécharger les sources depuis le
	serveur HTTP ou FTP spécifié dans l'ebuild du paquet.
	</p>
	<p>
	Le miroir que Portage utilise peut être spécifié à l'aide de
	la variable <i>GENTOO_MIRRORS</i> dans <path>/etc/make.conf</path>. 
	Voici la configuration courante par défaut :
	</p>
<pre caption = "Spécifier un miroir">
GENTOO_MIRRORS="http://www.ibiblio.org/gentoo"
</pre>
	<p>
	Pour trouver un miroir Gentoo plus près de chez vois, visitez le
	site de Gentoo ou demandez à la liste de diffusion locale. Vous pouvez
	également installer <c>mirrorselect</c> qui déterminera automatiquement
	le miroir le plus près de chez vous. Veuillez vous référer au guide 
	d'installation pour plus d'informations sur l'utilisation de 
	<c>mirrorselect</c>.
	</p>
</body>
</section>

<section>
<title>Programme de téléchargement.</title>
<body>
	<p>Le programme que Portage utilise pour télécharger les archives peut
	être spécifié grâce aux variables <i>FETCHCOMMAND</i> et
	<i>RESUMECOMMAND</i>. Plusieurs exemples sont indiqués dans
	<path>/etc/make.conf</path> et <path>/etc/make.globals</path>. 
	Portage utilise <i>wget</i> par défaut, ce qui devrait satisfaire 
	la plupart des utilisateurs.
	</p>

	<note>Portage passe les informations relatives aux proxys HTTP et FTP au
	programme de téléchargement à l'aide des variables d'environnement
	HTTP_PROXY et FTP_PROXY.</note>
</body>
</section>

<section>
<title>Proxies</title>
<body>
	<p>
	On peut dire à Portage d'utiliser des proxies HTTP et FTP pour
	télécharger des fichiers. Les proxies peuvent être spécifiés par
	<i>HTTP_PROXY</i> et <i>FTP_PROXY</i> soit dans 
	<path>/etc/make.conf</path>, soit dans <path>/etc/make.globals</path>. 
	Si le même proxy sert de proxy http et ftp, alors vous pouvez utiliser 
	la variable <i>PROXY</i> à la place.
	</p>
	
	<p>Voila un exemple :</p>

<pre caption ="Réglage des proxies">
HTTP_PROXY="http://192.168.1.1:8080"
FTP_PROXY="http://192.168.1.1:8080"
<comment>
ou
</comment>
PROXY="http://192.168.1.1:8080"
</pre>

  	<p>
	Il est également possible de spécifier un proxy http pour 
	l'utilisation de RSYNC. Le proxy RSYNC peut être spécifié en utilisant 
	la variable RSYNC_PROXY dans <path>/etc/make.conf</path> ou comme variable 
	d'environnement.
	</p>
	<p>
	En voici un example :
	</p>

<pre caption = "Spécification d'un proxy RSYNC">
RSYNC_PROXY="192.168.1.1:8080"
</pre>

	<note>
	Si vous êtes derrière un pare-feu et que rsync ne semble pas pouvoir utiliser votre
	proxy http, vous pouvez quand même mettre à jour votre arbre Portage en utilisant 
	une archive tar ("tarball"). Référez-vous à la 
	<uri link="http://www.gentoo.org/doc/en/faq.xml#doc_chap4_sect10">FAQ</uri> pour 
	plus d'informations [NDT : vous pouvez aussi utilisez emerge-webrsync]</note>

</body>
</section>

<section>
<title>Options diverses</title>
<body>
	<p>Voici quelques options qui pourront être utiles à certains
	utilisateurs :</p>

	<ul>
	<li><i>NOCOLOR</i> : Permet aux utilisateurs d'empêcher
	l'utilisation de couleurs dans la sortie de l'outil emerge. </li>
	<li><i>CLEAN_DELAY</i> : Portage ne désinstalle un paquet qu'après un
	certain nombre de secondes pour permettre à l'utilisateur d'annuler
	l'opération. Cette option spécifie le nombre de secondes à
	attendre. Mettre à "0" pour désactiver.</li>
	</ul>

</body>
</section>

</chapter>

<chapter>
<title>Gestion de paquets</title>

<section>
<title>Mise à jour de l'arbre Portage</title>
<body>
	<p>
	L'arbre Portage, situé dans /usr/portage, contient la bibliothèque
	d'instructions pour de nombreux paquets (appelés <i>ebuilds</i>). 
	L'arbre contient également les informations profil et package.mask vitales 
	pour avoir un arbre Portage à jour. Il est important de garder 
	l'arbre synchronisé avec l'arbre officiel pour avoir les versions 
	des paquets et les correctifs de bogues les plus récents. 
	Vous pouvez mettre a jour l'arbre Portage à l'aide de la commande 
	suivante :
	</p>
<pre caption = "Mise à jour de l'arbre Portage">
# <i>emerge sync</i>
</pre>
	<p>
	La méthode de mise à jour d'emerge peut être changée. Voir
	<i>l'option SYNC</i> dans le chapitre <i>Les fichiers de
	configuration de Portage</i> pour de plus amples informations.
	</p>
</body>
</section>

<section>
<title>Installation de paquets</title>
<body>
	<p>
	Le fait de compiler un paquet à l'aide de Portage est appelé
	"<i>merger</i>". Portage compile les paquets et les installe
	temporairement dans un répertoire "image" où il enregistre les
	fichiers qui vont être installés. Ces fichiers sont alors déplacés
	du répertoire image et installés dans le vrai système de fichier /.
	</p>
	<p>
	La commande <i>emerge</i> est une façade au système Portage.
	L'installation et la désinstalltion de paquets est faite à l'aide de
	cette commande et de ses nombreux arguments.
	</p>
	<p>
	Pour installer la version la plus récente d'un paquet qui ne soit pas masquée,
	spécifier simplement son nom comme ceci :
	</p>

<pre caption = "Installation d'un paquet">
# <i>emerge galeon</i>
</pre>
	<p>
	La commande va compiler et installer toutes les dépendances
	nécessaires (en prenant en compte la variable USE), elle va 
	ensuite compiler et installer la version non-masquée la plus récente 
	de galeon. Galeon aurait pu être référencé à l'aide de son nom et de
	sa catégorie : <i>net-www/galeon</i>.
	</p>
	<p>
  La commande <i>emerge</i> accepte aussi en argument le chemin du fichier
  ebuild lui-même. Ceci permet aux utilisateurs d'installer d'anciennes
  versions de paquets mais aussi des paquets n'étant pas inclus dans l'arbre
  Portage. Notez que cette méthode ne tient pas compte du masquage éventuel du
  paquet ni du paramètre <i>ACCEPT_KEYWORDS</i>. Voici un exemple d'utilisation
  de cette fonctionnalité :
	</p>

<pre caption = "Installer un ebuild spécifique">
# <i>emerge /usr/portage/net-www/galeon/galeon-1.2.0-r3.ebuild</i>
</pre>
	<p>
	En plus de spécifier le nom du paquet ou l'ebuild à installer,
	<i>emerge</i> connaît plusieurs arguments de ligne de commande 
	très utiles. Un de ces arguments, <i>--pretend</i>, est peut-être 
	le plus intéressant. Quand il est utilisé, l'action demandée n'est 
	pas effectuée. Au lieu de cela, Portage affiche une liste de paquets 
	qui seraient installés ou mis à jour si l'action était effectuée. Le 
	listing suivant est un exemple de ce qui serait installé pour la dernière 
	version du paquet kdevelop :
	</p>

<pre caption = "Vérifier ce que emerge va faire">
# <i>emerge --pretend kdevelop</i>

These are the packages that I would merge, in order.

Calculating dependencies ...done!
[ebuild  N   ] kde-base/kdelibs-2.2.2-r4 to /
[ebuild  N   ] dev-util/kdbg-1.2.2 to /
[ebuild   U  ] app-text/psutils-1.17 to /
[ebuild   U  ] app-text/a2ps-4.13b-r3 to /
[ebuild   U  ] app-text/jadetex-2.20 to /
[ebuild  N   ] app-text/sgmltools-lite-3.0.3-r2 to /
[ebuild  N   ] kde-base/kdoc-2.2.2-r1 to /
[ebuild  N   ] net-www/htdig-3.1.5-r2 to /
[ebuild  N   ] app-text/enscript-1.6.3-r1 to /
[ebuild  N   ] kde-base/kdebase-2.2.2-r2 to /
[ebuild  N   ] app-doc/qt-docs-2.3.1 to /
[ebuild  N   ] dev-util/kdevelop-2.0.2 to /
</pre>
	<p>
	Dans le listing ci-dessus, les paquets marqués d'un <i>N</i> (new) sont
	les paquets qui n'ont pas été installés et qui seraient installés
	avec cette commande. Les paquets marqués d'un <i>U</i> (upgrade) sont ceux
	dont une version plus ancienne a déjà été installée, et qui
	seraient mis à jour par cette commande.
	</p>
	<p>
	Les autres arguments disponibles sont:
	</p>
	<p>
	<i>--fetchonly</i> : Télécharge seulement l'archive nécessaire à la
	compilation du paquet et les dépendances.
	</p>
	<p>
	<i>--emptytree</i> : Cette option dit à Portage de supposer
	qu'aucune des dépendances de ce paquet ou des paquets dont il
	dépend sont déjà installées.  Ceci est utile avec <i>--pretend</i>
	pour afficher l'arbre complet des dépendances d'un paquet
	particulier. Toutes les dépendances sauf la bibliothèque glibc sont
	affichées.
	</p>
	<p>
	<i>--nodeps</i> : Portage tente d'installer uniquement le paquet
	spécifié et ignore les dépendances. Si les dépendances ne sont pas
	déjà installées, la compilation peut échouer.
	</p>
	<p>
	<i>--onlydeps</i> : Seules les dépendances du paquet sont
	installées. Le paquet spécifié n'est <i>pas</i> installé.
        </p>
	<p>
	<i>--noreplace</i> : Passe l'installation d'un paquet s'il est
	déjà installé.  
	</p>
	<p>
	<i>--usepkg</i> : Au lieu de compiler le paquet particulier,
	Portage tente de trouver un paquet précompilé de format tbz2 à l'emplacement
	spécifié par la variable de shell <i>PKGDIR</i>.
	</p>
	<p>
	<i>--debug</i> : Dit à l'environnement ebuild d'être plus bavard.
	C'est utile pour les développeurs qui essaient de trouver des
	erreurs dans les ebuilds.
	</p>
	<p>
	<i>--autoclean</i> : Force <i>emerge</i> à nettoyer les fichiers
	temporaires des répertoires de compilation avant de démarrer la
	compilation d'un paquet. Portage le fait par défaut, cette option
	n'est utile qu'aux développeurs qui ont désactivé ce comportement.
	</p>
	<p>
	<i>--verbose</i> : Dit à <i>emerge</i> de fonctionner en mode
	bavard. Utilisé de concert avec <i>--pretend</i>, il affiche la 
	valeur de la variable USE pour un paquet spécifié.
	</p>
</body>
</section>

<section>
<title>Désinstallation de paquets</title>
<body>
	<p>
	Le fait d' "unmerger" est le fait d'enlever les fichiers associés à
	un paquet du système de fichiers. Le logiciel est retiré du système
	et ne peut donc plus être utilisé jusqu'à ce qu'il soit réinstallé.
	</p>
    	<p>
	La désinstallation de paquets est réalisée grâce à la commande
	<i>emerge</i> suivie de l'argument <i>unmerge</i> suivi du nom du
	paquet à enlever. L'exemple suivant désinstallerait toutes les
	versions du paquet <i>ltrace</i> :
	</p>

<pre caption = "Désinstallation d'un paquet">
# <i>emerge unmerge ltrace</i>
<comment>
ou
</comment>
# <i>emerge unmerge dev-util/ltrace</i>
</pre>
	<p>
	Portage permet aussi de spécifier des versions particulières de paquets à
	désinstaller. Les intervalles sont spécifiés à l'aide de <i>=</i>
	(version exacte), <i>&lt;</i> (inférieure), <i>&gt;</i>
	(supérieure), et <i>&gt;=</i> (supérieure ou égale). L'exemple
	suivant désinstallerait toutes les versions du paquet ltrace 
	égales à 0.3.15 ou plus anciennes :
	</p>

<pre caption = "Désinstallation une version spécifique d'un paquet">
# <i>emerge unmerge \&lt;=dev-utils/ltrace-0.3.15</i>
</pre>

	<p>
	Quand vous spécifiez un intervalle, il est important de mettre un
	\ devant <i>&gt;</i> et <i>&lt;</i> dans la ligne de commande du
	shell pour que le shell n'interprète pas ces caractères
	particuliers. Aussi, il vous faudra spécifier la catégorie du
	paquet comme dans l'exemple. Pour un autre exemple de la façon dont
	fonctionne la spécification d'intervalle référez-vous à la commande 
	<i>emerge --help</i>
	</p>

	<warn>
	Désinstaller un paquet peut être dangereux. Si vous enlevez un
	paquet essentiel, le système pourra s'arrêter de fonctionner et
	l'effacement de nombreuses bibliothèques peuvent causer le mauvais
	fonctionnement de logiciels. <b>Portage ne vous préviendra pas si 
	vous effacez un paquet essentiel au système ou une dépendance d'un 
	autre paquet.</b>
	</warn>

	<p>
	Si le paquet à enlever est installé, le programme emerge va
	afficher le paquet exact qui va être retiré et va attendre un
	nombre de secondes donné pour donner à l'utilisateur l'opportunité
	d'appuyer sur Control-C pour annuler l'action.
	</p>
	<p>
	Une fois que l'opération commence, vous verrez une longue liste de
	noms de fichiers appartenant au paquet affiché. Certains de ces noms
	de fichier seront accompagnés d'un drapeau (flag) sur leur gauche. Les
	drapeaux <i>!mtime</i>, <i>!empty</i>, et <i>cfgpro</i> spécifient la
	raison pour laquelle certains fichiers ne sont pas enlevés lors de
	l'effacement du paquet du système. Les fichiers listés sans ces
	drapeaux sont effacés du système.
	</p>
	<p>
	<i>!mtime</i> signifie que le fichier a été modifié après
	l'installation de la version du paquet spécifiée. Cela signifie que
	quelqu'un a édité ce fichier après l'installation du paquet, ou
	qu'un autre paquet a écrasé ce fichier après lui. Cela permet aux
	paquets d'être mis à jour en s'assurant que la désintallation
	d'une version plus ancienne n'efface pas de fichiers essentiels.
	</p>
	<p>
	<i>!empty</i> indique un répertoire que Portage refuse d'effacer
	parce qu'il n'est pas vide (plusieurs paquets prétendent souvent posséder un 
	même répertoire). La protection de fichier entre en jeu quand vous 
	voyez le drapeau (flag) <i>cfgpro</i>. Cela signifie qu'un paquet plus récent 
	prétend posséder ce fichier de configuration et Portage refuse de l'effacer.
	</p>
	<warn>
	Les fichiers sont considérés comme possédés par le dernier paquet
	installé. Cela dépend donc de l'ordre d'installation des paquets et
	non pas des numéros de version des paquets. Effacer la version la
	plus récemment installée qui prétend posséder un certain fichier
	effacera toujours le fichier même si un paquet plus vieux a
	installé ce fichier auparavant (en supposant que l'utilisateur
	n'ait pas modifié le fichier).
	</warn>
	
</body>
</section>

<section>
<title>Mises à jour du système</title>
<body>
	<p>
	Portage est capable de mettre automatiquement à jour les paquets installés
	à l'aide d'une seule commande. La capacité de mise
	à jour du système permet aux utilisateurs de mettre à jour les
	paquets "centraux" à des versions recommandées par les développeurs
	du système Gentoo Linux. Une mise à jour système ne met pas
	les paquets non essentiels à jour, mais seulement les paquets définis par le
	profil Portage comme essentiels au bon fonctionnement et à la
	maintenance du système.
	</p>
	<p>
	Pour effectuer une mise à jour du système lancer la commande :
	</p>
<pre caption = "Mettre votre système à jour">
# <i>emerge --update system</i>
</pre>
	<p>
	Portage va alors compiler et installer les mises à jour en fonction
	des versions, des paquets que vous avez installés sur votre
	système et en fonction de ce qui est recommandé par le profil
	Portage courant. Les utilisateurs peuvent utiliser <i>--pretend</i>
	avec l'exemple précédent pour avoir la liste de ce qui serait
	installé ou modifié avec cette action.
	</p>
	<note>
	Vous remarquerez dans les intructions d'installation qu'une des
	étapes est d'exécuter <i>emerge system</i> pour installer tous les
	paquets de base (ou "centraux"). <i>emerge --update system</i> met
	à jour ces paquets à la dernière version recommandée.
	</note>
</body>
</section>

<section>
<title>Mise à jour "world"</title>
<body>
	<p>
	Portage permet aussi de mettre à jour automatiquement les paquets
	non-essentiels avec une seule commande. Le système Portage a été
	conçu avec une certaine forme d'intelligence pour permettre la mise
	à jour sûre d'un système où plusieurs versions de paquets
	conflictuels peuvent être disponibles.
	</p>

	<p>
	La capacité de mise à jour "world" vérifie le profil système, la
	liste de paquet bloqués (<path>package.mask</path>), le profil "world"
	et les dépendances (avec les intervalles de versions) de paquets
	listés dans le profil "world" pour déterminer quels paquets ont
	besoin d'être mis à jour. Un paquet n'est mis à jour que si une
	nouvelle version existe et que le paquet est listé dans le profil
	"world", ou si il est une dépendance d'un paquet dans le profil
	"world". En plus, le paquet ou la version spécifique du paquet ne
	doit pas être bloqué par le profil système ou dans
	<i>package.mask</i>.
	</p>

	<p>
	Quand il détermine les paquets à mettre à jour, Portage essaie de
	mettre à jour tous les paquets mentionnés dans le profil "world" à
	la version la plus récente qui ne soit pas bloquée. Portage
	considère également les dépendances de chaque paquet mentionné
	dans le profil "world" et va essayer de mettre à jour les
	dépendances à une version plus récente s'il y en a de disponibles,
	qu'elles correspondent à l'intervalle de version spécifié et 
	qu'elles ne soient pas bloquées dans le profil système ou dans 
	<path>package.mask</path>. Il prend également en considération des 
	<i>SLOTS</i> comme mentionné dans un chapitre précédent.
	</p>

	<p>
	Les utilisateurs qui connaissent d'autres distributions et d'autres
	méthodes de paquetage en plus de Portage, peuvent trouver étrange
	que Portage ne mette pas bêtement à jour en fonction des numéros de
	version (ce que faisait Gentoo 1.0). Plusieurs paquets inclus dans
	l'arbre de Portage ont plusieurs versions disponibles. Une version
	plus ancienne ou plus récente d'un paquet peut être incompatible avec 
	un logiciel qui dépend de lui. Mettre bêtement à jour les bibliothèques 
	et les outils sans prendre en compte le besoin d'autres paquets peut
	rapidement causer des dommages importants. Pour éviter ceci,
	Portage essaie de le prendre en compte quand il met à jour des
	paquets et considère les besoins de chaque paquet mis à jour en
	fonctions des informations trouvées dans chaque ebuild.
	</p>
	
	<p>
	Le coeur de la mise à jour "world" de Portage est le profil
    	"world". Au contraire du profil système qui est habituellement
	défini par les développeurs et jamais modifié par les utilisateurs,
	le profil "world" est généré indirectement au cours du temps en
	fonction des actions de l'utilisateur.
	Le profil "world" est plus ou moins une liste de "favoris".
	Les paquets installés manuellement par l'utilisateur au travers de 
	l'utilisation de la commande <i>emerge</i> sont enregistrés dans le
	fichier <i>world</i> situé dans <path>/var/cache/edb/world</path>.
	Portage suppose que comme vous avez fait l'effort de lui dire 
	d'installer ce paquet vous avez certainement un intérêt à ce qu'il soit 
	maintenu à jour.
	</p>
	<p>
	Le fichier <i>world</i> consiste en une liste de noms de paquets avec
	leur catégorie, un par ligne, et peut ressembler à ceci :
	</p>
<pre caption = "Un exemple du contenu de /var/cache/edb/world">
net-im/gaim
net-www/skipstone
net-www/galeon
app-editors/vim
app-text/ispell
net-mail/evolution
dev-util/ltrace
sys-apps/xfsprogs
=net-www/mozilla-0.9.8-r3
sys-apps/attr
sys-apps/dmapi
sys-kernel/linux-sources
sys-apps/acl
app-office/gnucash
app-cdr/xcdroast
</pre>
	<p>
	La plupart des entrées de ce fichier d'exemple ont été ajoutées
	automatiquement par Portage quand l'utilisateur a installé
	manuellement les paquets spécifiés. Ces paquets seront mis à jour
	si une nouvelle version est disponible.
	</p>
	
	<note>
	Pour vous économiser du temps et vous assurer que vos paquets
	préférés sont mis à jour, vous pouvez éditer manuellement le fichier
	<i>world</i> et ajouter les entrées pour ces paquets. Les
	utilisateurs qui mettent à jour une vieille version de Portage
	pouront avoir besoin d'ajouter des choses dans ce fichier. Les
	installations plus récentes de Gentoo et Portage s'occupent de le
	remplir à l'installation.</note>
	
	<p>
	Il est intéressant de s'attarder sur l'entrée pour le paquet mozilla
	(<i>=net-www/mozilla-0.9.8-r3</i>). Cette entrée fut ajoutée
	manuellement par un utilisateur pour "épingler" une version
	spécifique. Les intervalles de paquets (vus dans la section
	<i>Désinstallation de paquets</i> de ce manuel) peuvent être utilisés
	pour forcer Portage à ne considérer que certaines versions lors de
	mises à jour. Cette entrée force Portage à considérer que
	mozilla-0.9.8-r3 est la seule version disponible; il ne va donc
	jamais mettre à jour ce paquet pendant une mise à jour de type
	"world" et ce, quelle qu'en soit la raison.
	</p>
	
	<p>
	Une mise à jour de type "world" s'effectue de la façon suivante :
	</p>
<pre caption = "Mettre tout à jour">
# <i>emerge --update world</i>
</pre>
	<p>
	Portage va alors essayer de mettre à jour tous les paquets
	mentionnés dans le fichier <i>world</i> et va mettre à jour toutes
	les dépendances si besoin est. Les dépendances sont mises à jour à
	la version la plus récente disponible qui satisfasse les besoins du
	paquet à mettre à jour. Les paquets qui ne sont pas listés dans
	<i>world</i> et qui ne sont pas des dépendances des paquets cités 
	ci-dessus ne sont pas mis à jour.
	</p>

	<warn>
	Portage n'écrasera pas les fichiers se trouvant dans les
	répertoires protégés par la protection de fichiers de
	configuration. Vous devrez adapter manuellement votre configuration 
	actuelle à la nouvelle version que Portage sauvegarde pour vous. Si 
	vous ne mettez pas à jour vos fichier de configuration, vos logiciels 
	installés peuvent s'arrêter de fonctionner. Référez-vous à <i>Protection 
	des fichiers de fonfiguration</i> dans le chapitre <i>Configurer Portage</i> 
	ou utilisez la commande <i>emerge --help config</i> pour plus
	d'informations.
	</warn> 

	<p>Pour connaître la liste de ce qui serait mis à jour ou installé
	pendant une mise à jour "world", utilisez l'option <i>--pretend</i>
	comme mentionné dans les sections précédentes de ce chapitre.
	</p>

	<note>
	Une mise à jour "world" effectue automatiquement une mise à jour
	système. Les paquets centraux ne peuvent pas être épinglés à l'aide
	du fichier <i>world</i> comme décrit précédemment parce que le
	profil Portage courant à la priorité sur le fichier world.
	</note>

	<p>
	Un effet secondaire intéressant est la façon dont la mise à jour
	"world" peut être exploitée par les utilisateurs souhaitant
	recompiler tous les logiciels installés sur le système. Comme la
	mise à jour world va essayer de mettre à jour tous les paquets
	mentionnés dans le fichier <i>world</i> et leur dépendances,
	l'utilisation de l'argument <i>--emptytree</i> est une façon de
	forcer la recompilation de ces paquets ainsi que de chaque
	dépendance à part la glibc. Ceci peut être utile pour les
	utilisateurs souhaitant changer les options du compilateur ou un
	mot-clef USE et qui veulent que ces modifications soient utilisées
	par tous les logiciels qu'ils utilisent sans re-emerger
	manuellement tous les paquets. Il suffit de remplir le fichier
	<i>world</i> avec toutes vos applications utilisées régulièrement
	et de lancer la commande suivante :
	</p>
<pre caption = "Recompiler également toutes les dépendances">
# <i>emerge --update world --emptytree</i>
</pre>
	<p>
	Vous pouvez ajouter l'argument <i>--pretend</i> à cette commande
	pour avoir la liste des paquets qui seraient recompilés par cette
	commande.
	</p>
	
</body>
</section>

<section>
<title>Nettoyage du système</title>
<body>
	<p>
	Portage permet l'installation de plusieurs versions du même paquet les
	unes sur les autres. Il y a quelques paquets dans l'arbre de Portage
	de Gentoo qui utilisent cette fonctionnalité (pour la compatibilité
	descendante puisque de vieux logiciels peuvent être incompatibles avec
	une version plus récente d'un autre paquet).
	</p>
	<p>
	Dans la plupart des cas, quand une version plus récente d'un paquet
	est installé, la plupart des fichiers de l'ancien paquet sont écrasés et il
	ne reste que quelques fichiers de documentation et autres
	fichiers sans importance quant au fonctionnement du système. Au fil
	du temps ces résidus peuvent s'accumuler et gâcher un espace disque
	précieux.
	</p>
	<p>
	Pour éviter ceci, Portage propose une façon simple d'effacer les
	traces des anciennes versions d'un système. Cette fonctionnalité
	est appelée à l'aide de l'option <i>clean</i> et peut être lancée
	avec la commande suivante :
	</p>
<pre caption = "Retirer les vieilles version des paquets" >
# <i>emerge clean</i>
</pre>
	<p>
	<i>emerge</i> va alors afficher une liste de révisions et de
	versions à effacer ainsi que les versions qui seront conservées, et
	permettre à l'utilisateur d'annuler en appuyant sur Contrôle-C.
	Sur un système typique très actif, une longue liste de fichiers
	ayant été gardés ou enlevés sera affichée.
	</p>

	<p>
	Sauf mention contraire, Portage suppose que l'option clean est
	appliquée pour "<i>world</i>" (les paquets installés). Vous pouvez
	limiter le champ d'action de clean en utilisant des options comme
	<i>world</i>,  <i>system</i>, une liste de nom de paquets ou des
	intervalles de paquets comme vu dans les chapitres précédents.
	</p>

	<p>
	Quand il détermine quelles versions des paquets doivent être
	désinstallées, le système Portage exploite les profils, les
	besoins d'autres paquets installés et les SLOTs de paquets. En
	supposant que les dépendances sont définies correctement pour tous
	les paquets, l'action clean va enlever de façon sûre les paquets
	les plus anciens et ne devrait pas enlever quelque fonctionnalité
	que ce soit ou empêcher le système de fonctionner.
	</p>	
</body>
</section>

<section>
<title>"Pruner" un paquet</title>
<body>
	<p>
	Portage permet l'action <i>prune</i> sur un paquet. L'action
	"prune" est la forme non-sûre de clean. Elle efface toutes les
	versions de tous les paquets sauf les dernières versions
	installées. Elle n'effectue aucune des vérifications que fait
	l'action <i>clean</i> et peut très bien effacer un paquet
	essentiel au fonctionnement de votre système. Les utilisateurs de
	cette action peuvent facilement empêcher leur système de
	fonctionner ; son utilisation n'est pas recommandée à part dans des
	circonstances très particulières.
	</p>

	<p>
	L'action <i>prune</i> accepte les mêmes arguments que <i>clean</i>
	et peut être utilisée ainsi :
	</p>
<pre caption = "Pruner le système">
# <i>emerge prune</i>
</pre>
</body>
</section>


<section>
<title>Chercher dans l'arbre Portage</title>
<body>
	<p>
	L'arbre Portage comme celui qui forme le coeur de la distribution
	Gentoo peut devenir très grand. <i>emerge</i> permet d'effectuer
	des recherches à l'aide d'une chaîne de caractères sous la forme
	d'une expression rationnelle entre guillements. Les expressions
	rationnelles sont des créatures très compliquées et il est donc 
	recommandé de trouver un bon livre sur le sujet si vous êtes 
	intéressés et souhaitez les maîtriser pleinement.
	</p>
	<p>
	La plupart des recherches simples peuvent cependant être effectuées sans
	savoir comment écrire une expression rationnelle. Voici un exemple de
	recherche simple de paquet dont la chaine "gcc" apparaît dans le
	nom :
	</p>
<pre caption = "Recherche à partir d'une expression rationnelle">
# <i>emerge search gcc</i>
</pre>
	<p>
	Pour chaque chaîne de caractères qui correspond, emerge affiche 
	le nom du paquet, la version la plus récente disponible, la version 
	la plus récente installée, la page Web du paquet et la description 
	du logiciel contenu dans le paquet.
	</p>
</body>
</section>

<section>
<title>Obtenir de l'aide</title>
<body>
	<p>
	Davantage d'informations sur les nombreuses options d'<i>emerge</i>
	peuvent être trouvées à l'aide de la commande :
	</p>
<pre caption = "Obtenir de l'aide">
# <i>emerge --help</i>
</pre>
</body>
</section>
	
		

<section>
<title>Outils utiles</title>
<body>
	<p>
	Plusieurs outils qui simplifient la vie ont été mis a disposition
	par des utilisateurs de Gentoo. Ces outils sont disponibles dans le
	paquet <i>app-admin/gentoolkit</i> dans l'arbre Portage de
	Gentoo.
	</p>
	<p>
	<ul>
	<li><i>etc-update</i> : script shell utilisant vim pour permettre
	de fusionner les changements des fichiers de configuration de /etc 
	(peut être dangereux si mal utilisé).</li>
	<li><i>qpkg</i> : outil pour extraire des informations de la base
	de données de paquets</li>
	<li><i>epm</i> : un autre outil similaire a qpkg mais avec une
	syntaxe proche de celle de RPM</li>
	<li><i>etcat</i> : affiche et décrit le contenu de la variable USE 
	d'un paquet</li>
	</ul>
	</p>
</body>
</section>
</chapter>

 
<chapter>
<title>Que sont les paquets masqués ?</title>
<section>
<body>
	<p>
	Les gens se demandent pourquoi un paquet nouvellement mis à disposition 
	n'est pas pris en compte lorsqu'ils appellent la commande 
	<c>emerge -u world</c>.
	Un bon exemple en est xfree-4.3.0 (version au moment de l'écriture de 
	ce manuel). Si vous avez effectué un <c>emerge sync</c> suivi d'un 
	<c>emerge -u world</c>, vous ne voyez pas xfree comme candidat à la 
	mise à jour. Pourquoi ?
	</p>
	<p>
	La raison est que certains paquets sont marqués comme "masqués" -- c'est-à-dire
	que le paquet ne sera pas automatiquement mis à jour ou désinstallé
	sans action spécifique de votre part. Veuillez vous référer à la <uri
	link="http://forums.gentoo.org/viewtopic.php?t=33534">FAQ des paquets
	masqués</uri> dans les <uri link="http://forums.gentoo.org/">Forums Gentoo </uri>
	pour savoir comment autoriser l'installation des paquets masqués.
	</p>

</body>
</section>
</chapter>

</guide>

