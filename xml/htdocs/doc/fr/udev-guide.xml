<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/udev-guide.xml,v 1.21 2007/03/13 11:17:21 cam Exp $ -->

<guide link="/doc/fr/udev-guide.xml" lang="fr">
<title>Guide udev pour Gentoo</title>

<author title="Auteur">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributeur">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Traducteur">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>

<abstract>
Ce document explique ce qu'est udev et comment l'utiliser.
</abstract>

<license/>

<version>0.28</version>
<date>2007-03-12</date>

<chapter>
<title>Qu'est udev&nbsp;?</title>
<section>
<title>Le répertoire /dev</title>
<body>

<p>
Les personnes qui ne connaissent pas du tout Linux seraient certainement
étonnées d'entendre des Linuxiens dire «&nbsp;slash dev slash bidule&nbsp;»
pour désigner un périphérique. Par contre, pour des Linuxiens comme nous,
<path>/dev/hda1</path> représente simplement la première partition du disque
maître connecté sur l'interface IDE primaire.
</p>

<p>
Nous savons ce qu'est un fichier de périphérique, certains savent même que les
fichiers de périphériques ont des numéros que l'on peut voir en faisant <c>ls
-l</c> dans <path>/dev</path>. Cependant, nous considérons que
<path>/dev/hda</path> correspondra toujours au premier disque IDE. Cela vous
étonnera sans doute, mais c'est une erreur de conception.
</p>

<p>
Pensez aux périphériques qui peuvent être connectés à chaud (c-à-d. quand la
machine est déjà allumée) comme les périphériques USB, IEEE1394 (Firewire) ou
certaines cartes PCI. Quel est le premier périphérique dans ce cas&nbsp;? Les
autres périphériques doivent-ils être renommés quand un périphérique est
déconnecté&nbsp;? Quel sera l'impact sur les processus en cours&nbsp;?
Imaginez que votre document envoyé à votre nouvelle imprimante laser arrive sur
votre vieille imprimante matricielle parce vous avez oublié de l'allumer.
</p>

<p>
Voilà pourquoi <e>udev</e> a été créé. Les objectifs du projet udev sont
intéressants et surtout nécessaires&nbsp;:
</p>

<ul>
  <li>
    Il doit tourner dans l'espace utilisateur (c-à-d. pas dans le noyau).
  </li>
  <li>
    Les fichiers de périphériques doivent être ajoutés et enlevés
    dynamiquement.
  </li>
  <li>Les règles de nommage doivent être cohérentes.</li>
  <li>
    Une interface de programmation (une «&nbsp;API&nbsp;») doit exister.
  </li>
</ul>

<p>
Pour atteindre ces objectifs, udev a été développé en trois sous-projets&nbsp;:
<e>namedev</e>, <e>libsysfs</e> et, bien sûr, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev permet de nommer les périphériques indépendamment de udev. Ceci permet
d'utiliser des règles de nommage souples définies par des entités différentes.
Ce sous-système de nommage fournit une interface standard utilisée par udev.
</p>

<p>
Actuellement, le seul sous-système de nommage est fournit par LANANA et est
utilisé par la plupart des systèmes Linux actuels. La majorité des utilisateurs
de Linux l'utiliseront.
</p>

<p>
Namedev utilise une procédure à cinq étapes pour attribuer un nom à un
périphérique. Dès qu'un nom peut être attribué, la procédure s'arrête et le nom
est attribué. Ces étapes sont&nbsp;:
</p>

<ul>
  <li>un «&nbsp;label&nbsp;» ou un numéro de série</li>
  <li>numéro du bus</li>
  <li>topologie du bus</li>
  <li>attribution d'un nom statique</li>
  <li>nom attribué par le noyau</li>
</ul>

<p>
La première étape consiste à détecter un «&nbsp;label&nbsp;» ou un numéro de
série qui pourrait identifier le périphérique. Par exemple, un appareil USB
possède un numéro de série unique&nbsp;; un périphérique SCSI a un code UUID
unique. Si namedev trouve une correspondance entre un tel identifiant et un
fichier de configuration, le nom indiqué dans ce fichier sera utilisé.
</p>

<p>
Ensuite, namedev essaie d'identifier le périphérique en fonction du numéro du
bus sur lequel il est branché. Dans le cas de périphériques qui ne sont jamais
déconnectés, ceci suffit généralement. Par exemple, le numéro de bus d'une
carte PCI change très rarement. Si namedev trouve un fichier de configuration
qui correspond à ce numéro de bus, le nom indiqué dans ce fichier sera utilisé.
</p>

<p>
De façon similaire, l'attribution d'un nom selon la topologie du bus permet une
définition statique des périphériques pour autant que l'utilisateur ne permute
pas les périphériques. Quand la position d'un appareil sur le bus sur lequel il
est connecté correspond à un fichier de configuration défini par l'utilisateur,
le nom qui y est indiqué est utilisé.
</p>

<p>
La quatrième étape consiste à attribuer un nom de façon statique en fonction
d'une chaîne de caractères. Si le nom par défaut du périphérique tel qu'il est
connu par le noyau correspond à une chaîne de caractères donnée, le nom associé
à celle-ci est utilisé.
</p>

<p>
Finalement, c'est le nom attribué par le noyau qui sera utilisé par défaut.
Dans la majorité des cas, ceci permet de conserver les noms utilisés
actuellement.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
Le dialogue entre udev et le noyau passe par le pseudo-système de fichiers
sysfs. Le projet libsysfs offre une interface de programmation standard et
générique avec le système de fichiers sysfs. Ceci permet d'interroger toutes
sortes de périphériques sans devoir en connaître le type.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Chaque fois que le noyau détecte un changement quant aux périphériques, comme
un nouvel appareil que l'utilisateur connecte, il appelle le programme
<path>/sbin/hotplug</path>. Ce dernier lance l'application correspondant au
périphérique via un lien symbolique dans le sous-répertoire
<path>/etc/hotplug.d/default</path> où se trouve également un lien vers
l'application udev. Le programme hotplug relaie l'information reçue du noyau
vers l'application udev qui réalise les opérations nécessaires dans la structure
/dev comme la création ou la suppression de fichiers de périphériques.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Utiliser udev avec Gentoo</title>
<section>
<title>Prérequis</title>
<body>

<p>
Pour utiliser udev, vous devez installer un noyau 2.6.x comme
<c>gentoo-sources</c> avec un profil 2005.0. Vous devez aussi utiliser une
version récente de <c>sys-apps/baselayout</c>.
</p>

<pre caption="Installer udev">
# <i>emerge udev</i>
</pre>

<p>
Le paquet <c>hotplug-base</c> sera installé, car il est défini comme une
dépendance de udev.  Il n'est pas nécessaire d'installer le paquet
<c>hotplug</c> sauf si vous voulez que vos modules soient chargés
automatiquement quand vous branchez des périphériques. Le paquet <c>hotplug</c>
se charge aussi d'activer les interfaces réseau et de télécharger des
firmwares.
</p>

<pre caption="Installer les scripts hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
À propos du noyau, veuillez vérifier que les options suivantes ont été
sélectionnées&nbsp;:
</p>

<pre caption="Options du noyau nécessaires">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Vous pouvez laisser l'option <c>/dev file system support (OBSOLETE)</c>
sélectionnée si vous voulez, mais l'option <c>Automatically mount at boot</c>
<e>ne doit pas</e> être sélectionnée&nbsp;:
</p>

<pre caption="Ne pas monter devfsd automatiquement">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Si vous utilisez <c>genkernel</c>, n'oubliez pas l'option <c>--udev</c>. Cette
option suffit pour sélectionner toutes les options du noyau requises pour udev.
</p>

</body>
</section>
<section>
<title>Configuration</title>
<body>

<p>
Si vous voulez utiliser les fignolages apportés par les développeurs Gentoo
pour vous faciliter la vie, n'allez pas plus loin. Gentoo utilisera udev mais
gardera un <path>/dev</path> statique afin qu'il ne vous manque pas de
périphérique. Les scripts d'initialisation de Gentoo ne lanceront pas le démon
devfsd et désactiveront devfs au démarrage.
</p>

<p>
Cependant, si vous êtes un acharné qui veut un système 100% udev tel qu'il a
été voulu par ses développeurs, y compris avec les difficultés causées par les
périphériques absents par faute de support, alors lisez ce qui suit&nbsp;:)
</p>

<p>
Commençons par désactiver le système de sauvegarde des définitions des fichiers
de périphériques. Initialisez la variable <c>RC_DEVICE_TARBALL</c> à <c>no</c>
dans le fichier <path>/etc/conf.d/rc</path>&nbsp;:
</p>

<pre caption="Fichier /etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Si le support de devfs a été compilé dans votre noyau, vous pouvez le
désactiver dans la configuration de votre chargeur de démarrage en passant
l'option <c>gentoo=nodevfs</c> au noyau. Si vous voulez utiliser devfs et
désactiver udev, passez l'option <c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problèmes actuels</title>
<section>
<title>Fichiers de périphériques absents</title>
<body>

<p>
Si votre système ne démarre pas correctement parce que <path>/dev/null</path>
n'existe pas ou que la console n'est pas définie, le problème est que des
fichiers de périphériques devraient exister dans <path>/dev</path> <e>avant</e>
que udev ne monte <path>/dev</path>. Ce problème est fréquent sur des anciennes
installations de Gentoo.
</p>

<p>
Si vous utiliser <c>sys-apps/baselayout-1.8.12</c> ou une version plus récente,
votre système démarrera, mais affichera des messages d'avertissement. Pour les
faire disparaître, il suffit de créer les fichiers de périphériques qui
manquent.
</p>

<p>
Pour voir quels fichiers de périphériques existent dans <path>/dev</path> avant
que le système de fichiers dev ne soit monté, utilisez les commandes
suivantes&nbsp;:
</p>

<pre caption="Afficher les fichiers de périphériques de /dev">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Les fichiers de périphériques nécessaires lors du démarrage sont
<path>/dev/null</path> et <path>/dev/console</path>. Si le test effectué
ci-dessus révèle qu'ils manquent, vous devez les ajouter. Exécutez les
commandes ci-dessous dans le répertoire <path>test/dev/</path>&nbsp;:
</p>

<pre caption="Créer les fichiers de périphériques nécessaires">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
N'oubliez pas ensuite de démonter le répertoire <path>test/</path>.
</p>

<pre caption="Démonter le répertoire test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev et nVidia</title>
<body>

<p>
Si vous utilisez les pilotes propriétaires de nVidia et que le serveur X ne
démarre pas sur un système qui n'utilise que udev, veuillez vérifier les
éléments suivants&nbsp;:
</p>

<ul>
  <li>
    le module <c>nvidia</c> devrait être mentionné dans
    <path>/etc/modules.autoload.d/kernel-2.6</path>&nbsp;;
  </li>
  <li>
    la version du pilote <c>nvidia-kernel</c> doit être
    <c>media-video/nvidia-kernel-1.0.5336-r2</c> ou plus récente&nbsp;;
  </li>
  <li>
    la version de baselayout doit être <c>sys-apps/baselayout-1.8.12</c> ou
    plus récente.
  </li>
</ul>

<p>
Si <c>xorg-x11</c> ne démarre pas, il se peut que le fichier de périphérique
<path>/dev/nvidia</path> manque. Dans ce cas, exécutez
<path>/sbin/NVmakedevices.sh</path> pour le (re)créer.
</p>

</body>
</section>
<section>
<title>Les noms reliés à LVM2 disparaissent</title>
<body>

<p>
Si vous utilisez <c>udev</c> et LVM2 en même temps, vous remarquerez peut-être
que les groupes de volumes et les volumes logiques que vous avez créés ont
disparu. Enfin, ils n'ont pas vraiment disparu, mais ils sont malheureusement
renommés en <path>/dev/dm-#</path> (où # est 0, 1...)
</p>

<p>
Pour remédier à ce problème, éditez
<path>/etc/udev/rules.d/50-udev.rules</path> et décommentez la ligne
suivante &nbsp;:
</p>

<pre caption="Décommentez cette ligne de /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
Ensuite, installez le paquet <c>sys-fs/multipath-tools</c> qui fournit l'outil
<c>devmap_name</c>.
</p>


<pre caption="Installing multipath-tools">
<comment>(Au moment d'écrire ces lignes, multipath-tools est encore dans la branche de test :)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>Les noms des périphériques sont différents entre DevFS et udev</title>
<body>

<p>
Bien que nous nous efforcions de conserver des noms de périphériques identiques
entre DevFS et udev, des différences sont parfois inévitables.
</p>

<p>
Un exemple connu est la carte RAID Smart Array 5i de HP, plus précisément, le
module <c>cciss</c>. Avec udev, les périphériques sont nommés
<path>/dev/cciss/cXdYpZ</path> où X, Y et Z sont des nombres. Avec DevFS, ils
s'appellent <path>/dev/hostX/targetY/partZ</path> ou sont liés depuis
<path>/dev/cciss/cXdY</path>.
</p>

<p>
Si vous êtes confrontés à un tel cas, n'oubliez pas de mettre à jour votre
fichier <path>/etc/fstab</path> et la configuration de votre chargeur de
démarrage.
</p>

<p>
Des problèmes similaires peuvent se produire à cause des liens symboliques qui
existaient dans <path>/dev</path> (<path>/dev/mouse</path> par exemple) et que
udev ne crée pas. Veuillez vérifier que votre configuration de X utilise un
périphérique défini.
</p>

<p>
Un autre problème possible est dû aux noms attribués aux terminaux. Ceux créés
par devfs sont nommés <c>tty</c>, mais udev les nomme <c>vc</c> et <c>tty</c>.
Cela peut causer un problème si vous restreignez l'accès à root sur les
consoles en utilisant le fichier <path>/etc/securetty</path>. Vous devez
vérifier que <c>tty1</c> et <c>vc/1</c> figurent dans ce fichier pour permettre
à root de se connecter via la console.
</p>

</body>
</section>
<section>
<title>Autres problèmes</title>
<body>

<p>
Si un fichier de périphérique n'est pas créé quand un module est chargé via
<path>/etc/modules.autoload.d/kernel-2.6</path>, mais qu'il est bien créé quand
vous chargez le module avec modprobe, vous devez installer
<c>sys-apps/baselayout-1.8.12</c> ou une version plus récente.
</p>

<p>
Le support du framebuffer (fichiers de périphériques <path>/dev/fb/*</path>) est
disponible à partir de la version 2.6.6-rc2 du noyau.
</p>

<p>
Avec des noyaux avant la version 2.6.4, vous devez inclure explicitement le
support du système de fichiers <path>/dev/pts</path>.
</p>

<pre caption="Inclure le système de fichiers /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ressources &amp; remerciements</title>
<section>
<body>

<p>
L'exposé de Greg Kroah-Hartman (IBM Corporation) au Linux Symposium (Ottawa,
Ontario Canada - 2003) a permis une bonne compréhension du système udev.
</p>

<p>
L'<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">article
de Decibel</uri> (en anglais) traite en profondeur de udev sur systèmes Gentoo.
</p>

<p>
L'<uri link="http://www.reactivated.net/udevrules.php">article de Daniel
Drake</uri> (en anglais) est un excellent document sur la configuration de
udev.
</p>

</body>
</section>
</chapter>

</guide>
