<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/udev-guide.xml,v 1.30 2008/12/05 21:58:43 titefleur Exp $ -->

<guide link="/doc/fr/udev-guide.xml" lang="fr">
<title>Guide udev pour Gentoo</title>

<author title="Auteur">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributeur">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Correcteur">
  <mail link="nightmorph"/>
</author>
<author title="Traducteur">
  <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>

<abstract>
Ce document explique ce qu'est udev et comment l'utiliser.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<license/>

<version>3</version>
<date>2008-09-06</date>

<chapter>
<title>Qu'est udev&nbsp;?</title>
<section>
<title>Le répertoire /dev</title>
<body>

<p>
Les personnes qui ne connaissent pas du tout Linux seraient certainement
étonnées d'entendre des Linuxiens dire «&nbsp;slash dev slash bidule&nbsp;»
pour désigner un périphérique. Par contre, pour des Linuxiens comme nous,
<path>/dev/hda1</path> représente simplement la première partition du disque
maître connecté sur l'interface IDE primaire.
</p>

<p>
Nous savons ce qu'est un fichier de périphérique, certains savent même que les
fichiers de périphériques ont des numéros que l'on peut voir en faisant <c>ls
-l</c> dans <path>/dev</path>. Cependant, nous considérons que
<path>/dev/hda</path> correspondra toujours au premier disque IDE. Cela vous
étonnera sans doute, mais c'est une erreur de conception.
</p>

<p>
Pensez aux périphériques qui peuvent être connectés à chaud (c-à-d. quand la
machine est déjà allumée) comme les périphériques USB, IEEE1394 (Firewire) ou
certaines cartes PCI. Quel est le premier périphérique dans ce cas&nbsp;? Les
autres périphériques doivent-ils être renommés quand un périphérique est
déconnecté&nbsp;? Quel sera l'impact sur les processus en cours&nbsp;?
Imaginez que votre document envoyé à votre nouvelle imprimante laser arrive sur
votre vieille imprimante matricielle parce vous avez oublié de l'allumer.
</p>

<p>
Voilà pourquoi <e>udev</e> a été créé. Les objectifs du projet udev sont
intéressants et surtout nécessaires&nbsp;:
</p>

<ul>
  <li>
    Il doit tourner dans l'espace utilisateur (c-à-d. pas dans le noyau).
  </li>
  <li>
    Les fichiers de périphériques doivent être ajoutés et enlevés
    dynamiquement.
  </li>
  <li>Les règles de nommage doivent être cohérentes.</li>
  <li>
    Une interface de programmation (une «&nbsp;API&nbsp;») doit exister.
  </li>
</ul>

<p>
Pour atteindre ces objectifs, udev a été développé en trois sous-projets&nbsp;:
<e>namedev</e>, <e>libsysfs</e> et, bien sûr, <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev permet de nommer les périphériques indépendamment de udev. Ceci permet
d'utiliser des règles de nommage souples définies par des entités différentes.
Ce sous-système de nommage fournit une interface standard utilisée par udev.
</p>

<p>
Actuellement, le seul sous-système de nommage est fournit par LANANA et est
utilisé par la plupart des systèmes Linux actuels. La majorité des utilisateurs
de Linux l'utiliseront.
</p>

<p>
Namedev utilise une procédure à cinq étapes pour attribuer un nom à un
périphérique. Dès qu'un nom peut être attribué, la procédure s'arrête et le nom
est attribué. Ces étapes sont&nbsp;:
</p>

<ul>
  <li>un «&nbsp;label&nbsp;» ou un numéro de série</li>
  <li>numéro du bus</li>
  <li>topologie du bus</li>
  <li>attribution d'un nom statique</li>
  <li>nom attribué par le noyau</li>
</ul>

<p>
La première étape consiste à détecter un «&nbsp;label&nbsp;» ou un numéro de
série qui pourrait identifier le périphérique. Par exemple, un appareil USB
possède un numéro de série unique&nbsp;; un périphérique SCSI a un code UUID
unique. Si namedev trouve une correspondance entre un tel identifiant et un
fichier de configuration, le nom indiqué dans ce fichier sera utilisé.
</p>

<p>
Ensuite, namedev essaie d'identifier le périphérique en fonction du numéro du
bus sur lequel il est branché. Dans le cas de périphériques qui ne sont jamais
déconnectés, ceci suffit généralement. Par exemple, le numéro de bus d'une
carte PCI change très rarement. Si namedev trouve un fichier de configuration
qui correspond à ce numéro de bus, le nom indiqué dans ce fichier sera utilisé.
</p>

<p>
De façon similaire, l'attribution d'un nom selon la topologie du bus permet une
définition statique des périphériques pour autant que l'utilisateur ne permute
pas les périphériques. Quand la position d'un appareil sur le bus sur lequel il
est connecté correspond à un fichier de configuration défini par l'utilisateur,
le nom qui y est indiqué est utilisé.
</p>

<p>
La quatrième étape consiste à attribuer un nom de façon statique en fonction
d'une chaîne de caractères. Si le nom par défaut du périphérique tel qu'il est
connu par le noyau correspond à une chaîne de caractères donnée, le nom associé
à celle-ci est utilisé.
</p>

<p>
Finalement, c'est le nom attribué par le noyau qui sera utilisé par défaut.
Dans la majorité des cas, ceci permet de conserver les noms utilisés
actuellement.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
Le dialogue entre udev et le noyau passe par le pseudo-système de fichiers
sysfs. Le projet libsysfs offre une interface de programmation standard et
générique avec le système de fichiers sysfs. Ceci permet d'interroger toutes
sortes de périphériques sans devoir en connaître le type.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Chaque fois que le noyau reçoit un évènement relatif aux périphériques, comme
un nouvel appareil que l'utilisateur connecte, il demande à udev de s'en
occuper. udev suit les règles qui se trouvent dans le répertoire
<path>/etc/udev/rules.d/</path> en conjonction avec les informations apportées
par le noyau pour déterminer quelles actions doivent être exécutées sur la
structure de fichiers <path>/dev</path> (créer ou supprimer des fichiers de
périphériques).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Utiliser udev avec Gentoo</title>
<section>
<title>Prérequis</title>
<body>

<p>
Pour utiliser udev, vous devez installer un noyau 2.6.x comme
<c>gentoo-sources</c> avec un profil 2007.0. Vous devez aussi utiliser une
version récente de <c>sys-apps/baselayout</c>.
</p>

<pre caption="Installer udev">
# <i>emerge udev</i>
</pre>

<p>
À propos du noyau, veuillez vérifier que les options suivantes ont été
sélectionnées&nbsp;:
</p>

<pre caption="Options du noyau nécessaires">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Si vous utilisez <c>genkernel</c>, vous n'avez besoin de rien faire de spécial.
Genkernel paramètre udev par défaut.
</p>

</body>
</section>
<section>
<title>Configuration</title>
<body>

<p>
Si vous voulez utiliser les paramètres d'udev apportés par les développeurs
Gentoo pour vous faciliter la vie, n'allez pas plus loin. Gentoo utilisera udev
mais gardera un <path>/dev</path> statique afin qu'il ne vous manque pas de
périphérique. Les scripts d'initialisation de Gentoo ne lanceront pas le démon
devfsd et désactiveront devfs au démarrage.
</p>

<p>
Cependant, si vous êtes un acharné qui veut un système 100% udev non modifié
tel qu'il a été voulu par ses développeurs, y compris avec les difficultés
causées par les périphériques absents par faute de support, alors lisez ce qui
suit&nbsp;:)
</p>

<p>
Commençons par désactiver le système de sauvegarde des définitions des fichiers
de périphériques. Initialisez la variable <c>RC_DEVICE_TARBALL</c> à <c>no</c>
dans le fichier <path>/etc/conf.d/rc</path>&nbsp;:
</p>

<pre caption="Fichier /etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Si le support de devfs a été compilé dans votre noyau, vous pouvez le
désactiver dans la configuration de votre chargeur de démarrage en passant
l'option <c>gentoo=nodevfs</c> au noyau. Si vous voulez utiliser devfs et
désactiver udev, passez l'option <c>gentoo=noudev</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Problèmes actuels</title>
<section>
<title>Fichiers de périphériques absents</title>
<body>

<p>
Si votre système ne démarre pas correctement parce que <path>/dev/null</path>
n'existe pas ou que la console n'est pas définie, le problème est que des
fichiers de périphériques devraient exister dans <path>/dev</path> <e>avant</e>
que udev ne monte <path>/dev</path>. Ce problème est fréquent sur des anciennes
installations de Gentoo.
</p>

<p>
Si vous utiliser <c>sys-apps/baselayout-1.8.12</c> ou une version plus récente,
votre système démarrera, mais affichera des messages d'avertissement. Pour les
faire disparaître, il suffit de créer les fichiers de périphériques qui
manquent.
</p>

<p>
Pour voir quels fichiers de périphériques existent dans <path>/dev</path> avant
que le système de fichiers dev ne soit monté, utilisez les commandes
suivantes&nbsp;:
</p>

<pre caption="Afficher les fichiers de périphériques de /dev">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Les fichiers de périphériques nécessaires lors du démarrage sont
<path>/dev/null</path> et <path>/dev/console</path>. Si le test effectué
ci-dessus révèle qu'ils manquent, vous devez les ajouter. Exécutez les
commandes ci-dessous dans le répertoire <path>test/dev/</path>&nbsp;:
</p>

<pre caption="Créer les fichiers de périphériques nécessaires">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
N'oubliez pas ensuite de démonter le répertoire <path>test/</path>.
</p>

<pre caption="Démonter le répertoire test/">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev et nVidia</title>
<body>

<p>
Si vous utilisez les pilotes propriétaires de nVidia et que le serveur X ne
démarre pas sur un système qui n'utilise que udev, veuillez vérifier les
éléments suivants&nbsp;:
</p>

<ul>
  <li>
    le module <c>nvidia</c> devrait être mentionné dans
    <path>/etc/modules.autoload.d/kernel-2.6</path>&nbsp;;
  </li>
  <li>
    la version de baselayout doit être <c>sys-apps/baselayout-1.8.12</c> ou
    plus récente.
  </li>
</ul>

</body>
</section>
<section>
<title>Les noms des périphériques sont différents entre DevFS et udev</title>
<body>

<p>
Bien que nous nous efforcions de conserver des noms de périphériques identiques
entre DevFS et udev, des différences sont parfois inévitables.
</p>

<p>
Un exemple connu est la carte RAID Smart Array 5i de HP, plus précisément, le
module <c>cciss</c>. Avec udev, les périphériques sont nommés
<path>/dev/cciss/cXdYpZ</path> où X, Y et Z sont des nombres. Avec DevFS, ils
s'appellent <path>/dev/hostX/targetY/partZ</path> ou sont liés depuis
<path>/dev/cciss/cXdY</path>.
</p>

<p>
Si vous êtes confrontés à un tel cas, n'oubliez pas de mettre à jour votre
fichier <path>/etc/fstab</path> et la configuration de votre chargeur de
démarrage.
</p>

<p>
Des problèmes similaires peuvent se produire à cause des liens symboliques qui
existaient dans <path>/dev</path> (<path>/dev/mouse</path> par exemple) et que
udev ne crée pas. Veuillez vérifier que votre configuration de X utilise un
périphérique défini.
</p>

<p>
Un autre problème possible est dû aux noms attribués aux terminaux. Ceux créés
par devfs sont nommés <c>tty</c>, mais udev les nomme <c>vc</c> et <c>tty</c>.
Cela peut causer un problème si vous restreignez l'accès à root sur les
consoles en utilisant le fichier <path>/etc/securetty</path>. Vous devez
vérifier que <c>tty1</c> et <c>vc/1</c> figurent dans ce fichier pour permettre
à root de se connecter via la console.
</p>

</body>
</section>
<section>
<title>Renommer un périphérique</title>
<body>

<p>
Les versions récentes d'udev (104 et supérieures) avec les nouvelles versions
du noyau (2.6.19 et supérieures) permettent de renommer vos périphériques,
grâce à un changement dans l'implémentation de la bibliothèque libata du noyau.
Un périphérique CD-RW en <path>/dev/hdc</path> peut être changé en
<path>/dev/sr0</path>. Si ce n'est normalement pas un souci, cela peut causer
des problèmes à certaines applications codées en dur pour chercher les
périphériques aux autres emplacements. Par exemple, <c>media-sound/rip</c>
s'attend à trouver les disques dans <path>/dev/cdrom</path>, ce qui devient un
problème si vous utilisez un nouveau noyau et que udev renomme votre
périphérique en <path>/dev/cdrom1</path>.
</p>

<p>
Pour contourner ces problèmes, vous devez éditer le fichier
<path>/etc/udev/rules.d/70-persistent-cd.rules</path> et assigner au
périphérique le nom correct.
</p>

<p>
Pour plus d'informations sur l'écriture des règles udev, reportez-vous au
<uri link="http://www.reactivated.net/udevrules.php">guide</uri> de Daniel Drake.
</p>

</body>
</section>
<section>
<title>udev charge les modules dans un ordre aléatoire</title>
<body>

<p>
Il arrive qu'udev charge les modules dans un ordre indésiré, imprévisible ou qui
semble aléatoire. Cela apparaît surtout sur les systèmes qui possèdent
plusieurs périphériques de même type, tels que les périphériques multimédia.
Cela peut affecter les numéros assignés aux périphériques&nbsp;; par exemple,
les cartes son échangent parfois leur numéro.
</p>

<p>
Il existe plusieurs solutions pour fixer les numéros de périphériques et/ou
l'ordre de chargement des modules. Dans le meilleur des cas, vous pouvez
simplement utiliser les paramètres du module pour spécifier le numéro désiré au
périphérique. Certains modules, tels qu'ALSA, incluent le paramètre
«&nbsp;index&nbsp;». Les modules qui utilisent ce paramètre peuvent être
ajustés comme indiqué. Cet exemple concerne un système avec deux cartes son.
La carte avec l'indice 0 est désignée comme la première carte. Une fois que les
paramètres sont changés, les fichiers de configuration des modules doivent être
mis à jour.
</p>

<pre caption="Spécification des paramètres des modules">
# <i>echo "option snd-ice1724 index=0" >> /etc/modules.d/alsa</i>
# <i>echo "option snd-ymfpci index=1" >> /etc/modules.d/alsa</i>
# <i>update-modules</i>
</pre>

<p>
La solution dans l'exemple ci-dessus est celle qui est préférée mais tous les
modules ne possèdent pas un paramètre tel que l'indice. Pour ceux-là, vous
devrez forcer l'ordre correct de chargement des modules. Tout d'abord, vous
devez empêcher udev de charger automatiquement les modules en les mettant sur la
liste noire. Assurez-vous d'utiliser le nom exact du module qui est chargé. Pour
les périphériques PCI, vous devrez utiliser les noms des modules obtenus sur la
sortie de la commande <c>pcimodules</c>, disponible dans le paquet
<c>pciutils</c>. L'exemple suivant illustre le cas des modules DVB.
</p>

<pre caption="Mettre les modules sur la liste noire">
# <i>echo "blacklist b2c2-flexcop-pci" >> /etc/modprobe.d/dvb</i>
# <i>echo "blacklist budget" >> /etc/modprobe.d/dvb</i>
# <i>update-modules</i>
</pre>

<p>
Ensuite, chargez les modules dans l'ordre correct. Ajoutez-les au fichier
<path>/etc/modules.autoload.d/kernel-2.6</path> <e>dans l'ordre exact où vous
voulez qu'ils soient chargés</e>.
</p>

<pre caption="Chargement des modules dans l'ordre correct">
# <i>echo "budget" >> /etc/modules.autoload.d/kernel-2.6</i>
# <i>echo "b2c2-flexcop-pci" >> /etc/modules.autoload.d/kernel-2.6</i>
</pre>

</body>
</section>
<section>
<title>Autres problèmes</title>
<body>

<p>
Si un fichier de périphérique n'est pas créé quand un module est chargé via
<path>/etc/modules.autoload.d/kernel-2.6</path>, mais qu'il est bien créé quand
vous chargez le module avec modprobe, vous devez installer
<c>sys-apps/baselayout-1.8.12</c> ou une version plus récente.
</p>

<p>
Le support du framebuffer (fichiers de périphériques <path>/dev/fb/*</path>) est
disponible à partir de la version 2.6.6-rc2 du noyau.
</p>

<p>
Avec des noyaux avant la version 2.6.4, vous devez inclure explicitement le
support du système de fichiers <path>/dev/pts</path>.
</p>

<pre caption="Inclure le système de fichiers /dev/pts">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ressources &amp; remerciements</title>
<section>
<body>

<p>
L'exposé de Greg Kroah-Hartman (IBM Corporation) au Linux Symposium (Ottawa,
Ontario Canada - 2003) a permis une bonne compréhension du système udev.
</p>

<p>
L'<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">article
de Decibel</uri> (en anglais) traite en profondeur de udev sur systèmes Gentoo.
</p>

<p>
L'<uri link="http://www.reactivated.net/udevrules.php">article de Daniel
Drake</uri> (en anglais) est un excellent document sur la configuration de
udev.
</p>

</body>
</section>
</chapter>
</guide>
