<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/bugzilla-howto.xml,v 1.7 2010/05/05 15:34:52 titefleur Exp $ -->

<guide lang="fr">
<title>Guide de rapport de bogue de Gentoo</title>

<author title="Auteur">
  <mail link="chriswhite"/>
</author>
<author title="Correcteur">
  <mail link="fox2mike"/>
</author>
<author title="Traducteur">
  <mail link="titefleur"/>
</author>
<author title="Traducteur">
  <mail link="geekounet@gmail.com">Pierre Guinoiseau</mail>
</author>

<abstract>
Ce document montre de quelle manière se fait le rapport de bogues avec le
Bugzilla.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.15</version>
<date>2010-02-27</date>

<chapter>
<title>Introduction</title>
<section>
<title>Préface</title>
<body>

<p>
L'un des facteurs qui fait qu'un bogue tarde à être corrigé réside dans la
manière dont il est rapporté. En créant ce guide, nous espérons aider à
améliorer la communication entre les développeurs et les utilisateurs en ce qui
concerne la résolution de bogues. La correction de bogues constitue une part
importante sinon cruciale de l'assurance de qualité quelque soit le projet alors
espérons que ce guide aidera à y contribuer.
</p>

</body>
</section>
<section>
<title>Bogues&nbsp;!!!!</title>
<body>

<p>
Vous êtes en train d'installer un paquet ou de travailler avec un programme
quand soudainement, le pire arrive&nbsp;: vous trouvez un bogue. Les bogues
surviennent de différentes manières, il y a par exemple les erreurs qui se
produisent lors de la commande <c>emerge</c> ou les erreurs de segmentation.
Quelqu'en soit la cause, le fait est qu'un tel bogue doit être corrigé. Voici
quelques exemples de ce genre de bogues.
</p>

<pre caption="Une erreur d'exécution">
$ <i>./bad_code `perl -e 'print "A"x100'`</i>
Segmentation fault
</pre>

<pre caption="Un échec de la part d'emerge">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Ces erreurs peuvent être très gênantes. Toutefois, une fois que vous les avez
décelées, que devez-vous faire&nbsp;? Les sections suivantes vont présenter deux
outils importants dans la gestion des erreurs d'exécution. Après cela, nous
jetterons un œil aux erreurs de compilation et à la manière de les traiter.
Commençons dès à présent avec le premier outil de débogage pour les erreurs
d'exécution, <c>GDB</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Débogage grâce à GDB</title>
<section>
<title>Introduction</title>
<body>

<p>
GDB, pour le (G)NU (D)e(B)ugger, est un programme utilisé pour trouver les
erreurs d'exécution qui impliquent généralement une corruption de la mémoire.
Tout d'abord, jetons un œil à ce qui permet le débogage. L'une des principales
choses que vous devez faire afin de déboguer un programme est d'installer le
programme avec <c>FEATURES="nostrip"</c>. Cela évite la suppression des symboles
de débogage. Pourquoi les programmes sont-ils privés de ceux-ci par
défaut&nbsp;? La raison est la même que celle pour laquelle les pages du manuel
sont compressées avec gzip&nbsp;: l'économie de place. Voici la façon dont varie
la taille d'un programme avec et sans la suppression des symboles de débogage.
</p>

<pre caption="Comparaison de la taille des fichiers">
<comment>(symboles de débogage supprimés)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 bad_code
<comment>(symboles de débogage intacts)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 bad_code
</pre>

<p>
Juste pour indication, <e>bad_code</e> est le programme que nous allons
déboguer avec <c>GDB</c> plus tard. Comme vous pouvez le voir, le programme
privé des symboles de débogage ne pèse que 3140 octets, tandis que le même
programme avec ces symboles en pèse 6374, soit près du double&nbsp;! Deux
autres choses peuvent être faites pour aider au débogage. La première est
d'ajouter <c>ggdb</c> dans votre CFLAGS et dans votre CXXFLAGS. Cette variable
ajoute plus d'informations de débogage que la normale. Nous verrons ce que cela
signifie plus tard. Voici ce à quoi <e>pourrait</e> ressembler votre fichier
<path>/etc/make.conf</path> après l'ajout de ces nouvelles variables.
</p>

<pre caption="Paramètres du make.conf">
CFLAGS="-O1 -pipe -ggdb"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Enfin, vous pouvez ajouter l'option debug de la variable USE à vos paquets, par
l'intermédiaire du fichier <path>package.use</path>.
</p>

<pre caption="Ajout de l'option debug de la variable USE dans le fichier
package.use">
# <i>echo "catégorie/paquet debug" >> /etc/portage/package.use</i>
</pre>

<note>
Le répertoire <path>/etc/portage</path> n'existe pas par défaut, vous devrez le
créer, si vous ne l'avez pas déjà fait. Si le paquet possède déjà des variables
USE indiquées dans le fichier <path>package.use</path>, vous devrez les modifier
manuellement à l'aide de l'éditeur de votre choix.
</note>

<p>
Ensuite, nous allons réinstaller le paquet avec les modifications faites plus
haut comme montré ci-dessous.
</p>

<pre caption="Réinstallation d'un paquet avec le débogage">
# <i>FEATURES="nostrip" emerge paquet</i>
</pre>

<p>
Maintenant que les symboles de débogage sont mis, nous pouvons continuer avec le
débogage du programme.
</p>

</body>
</section>
<section>
<title>Exécution du programme avec GDB</title>
<body>

<p>
Disons que nous avons un programme appelé ici «&nbsp;bad_code&nbsp;». Quelqu'un
a affirmé que le programme plantait et a fourni un exemple. Vous allez tester sa
sortie.
</p>

<pre caption="Corruption du programme">
$ <i>./bad_code `perl -e 'print "A"x100'`</i>
Segmentation fault
</pre>

<p>
Il semble que cette personne avait raison. Puisque le programme est
effectivement corrompu, nous avons un bogue sous la main. À présent, il est
temps d'utiliser <c>GDB</c> pour nous aider à résoudre ce problème. Tout
d'abord nous lançons <c>GDB</c> avec <c>--args</c> suivi du programme complet
avec ses arguments comme voici&nbsp;:
</p>

<pre caption="Exécution de notre programme dans GDB">
$ <i>gdb --args ./bad_code `perl -e 'print "A"x100'`</i>
GNU gdb 6.3
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu"...Using host libthread_db library "/lib/libthread_db.so.1".
</pre>

<note>
On peut également déboguer avec des sauvegardes d'images mémoires (NdT&nbsp;:
«&nbsp;core dumps&nbsp;»). Ces fichiers du noyau contiennent les mêmes
informations que ce que le programme produirait en l'exécutant avec GDB. Pour
déboguer notre programme bad_code avec un tel fichier, vous devez exécuter
<c>gdb ./bad_code core</c> où «&nbsp;core&nbsp;» est le nom du fichier de
sauvegarde.
</note>

<p>
Vous devriez voir une invite de commande indiquant «&nbsp;(gdb)&nbsp;» et
attendant une saisie clavier. D'abord, nous devons exécuter le programme. En
écrivant <c>run</c> sur la ligne de commande nous obtenons une information telle
que celle-ci&nbsp;:
</p>

<pre caption="Exécution du programme dans GDB">
(gdb) <i>run</i>
Starting program: /home/chris/bad_code

Program received signal SIGSEGV, Segmentation fault.
0xb7ec6dc0 in strcpy () from /lib/libc.so.6
</pre>

<p>
Ici nous pouvons voir le programme démarrer ainsi qu'une notification de
SIGSEGV, c'est-à-dire une erreur de segmentation. C'est GDB qui nous dit que
notre programme a planté. Il nous donne également la dernière fonction exécutée
qu'il a pu remonter quand le programme a planté. Toutefois, ceci n'est pas très
utile puisqu'il peut y avoir de nombreux «&nbsp;strcpy&nbsp;» dans le programme,
rendant difficile pour les développeurs de déceler celui qui cause ce problème.
Afin de les aider, nous allons faire ce qu'on appelle un traçage (NdT&nbsp;:
«&nbsp;backtrace&nbsp;»). Un traçage exécute à l'envers toutes les fonctions qui
existent dès l'exécution du programme jusqu'à la fonction qui produit la faute.
Les fonctions qui retournent quelque chose (sans causer de plantage) ne seront
pas montrées dans le traçage. Pour obtenir un traçage, sur l'invite de commande
(gdb), écrivez <c>bt</c>. Vous obtiendrez quelque chose comme ceci&nbsp;:
</p>

<pre caption="Traçage du programme">
(gdb) <i>bt</i>
#0  0xb7ec6dc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it ()
#2  0x080483ba in main ()
</pre>

<p>
Vous pouvez remarquer clairement la trace du patron. La fonction main() est
appelée en premier, suivie de la fonction run_it(), et quelque part dans
run_it() se trouve le strcpy() qui commet la faute. De telles informations
aident les développeurs à réduire les problèmes. Il y a des cas où vous
n'obtiendrez pas cette sortie. Le premier se produit si vous oubliez d'activer
les symboles de débogage avec <c>FEATURES="nostrip"</c>. Si les symboles sont
supprimés, la sortie ressemblera plutôt à quelque chose comme cela&nbsp;:
</p>

<pre caption="Traçage du programme sans les symboles de débogage">
(gdb) <i>bt</i>
#0  0xb7e2cdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in ?? ()
#2  0xbfd19510 in ?? ()
#3  0x00000000 in ?? ()
#4  0x00000000 in ?? ()
#5  0xb7eef148 in libgcc_s_personality () from /lib/libc.so.6
#6  0x080482ed in ?? ()
#7  0x080495b0 in ?? ()
#8  0xbfd19528 in ?? ()
#9  0xb7dd73b8 in __guard_setup () from /lib/libc.so.6
#10 0xb7dd742d in __guard_setup () from /lib/libc.so.6
#11 0x00000006 in ?? ()
#12 0xbfd19548 in ?? ()
#13 0x080483ba in ?? ()
#14 0x00000000 in ?? ()
#15 0x00000000 in ?? ()
#16 0xb7deebcc in __new_exitfn () from /lib/libc.so.6
#17 0x00000000 in ?? ()
#18 0xbfd19560 in ?? ()
#19 0xb7ef017c in nullserv () from /lib/libc.so.6
#20 0xb7dd6f37 in __libc_start_main () from /lib/libc.so.6
#21 0x00000001 in ?? ()
#22 0xbfd195d4 in ?? ()
#23 0xbfd195dc in ?? ()
#24 0x08048201 in ?? ()
</pre>

<p>
Ce traçage contient un grand nombre de marques «&nbsp;??&nbsp;». Cela est dû au
fait que <c>GDB</c> ne connaît pas la façon dont le programme a été exécuté
puisqu'il n'y a pas de symboles de débogage. Il est donc crucial de ne
<e>pas</e> supprimer ces symboles. À présent, rappelez-vous qu'au-dessus nous
avions mentionné l'existence d'une option -ggdb. Voyons à quoi ressemble la
sortie si celle-ci est active&nbsp;:
</p>

<pre caption="Traçage du programme avec -ggdb">
(gdb) <i>bt</i>
#0  0xb7e4bdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it (input=0x0) at bad_code.c:7
#2  0x080483ba in main (argc=1, argv=0xbfd3a434) at bad_code.c:12
</pre>

<p>
Nous pouvons voir que beaucoup plus d'informations sont disponibles pour les
développeurs. Non seulement le nom de la fonction est affiché, mais il y a
également les numéros de lignes exacts dans la source des fichiers. Cette
méthode est celle qui est préférée si vous pouvez libérer un peu d'espace
supplémentaire. Voici comment varie la taille des fichiers avec la présence des
symboles de débogage, sans ces symboles, et avec l'activation de l'option -ggdb.
</p>

<pre caption="Différences avec l'option -ggdb">
<comment>(symboles de débogage supprimés)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 bad_code
<comment>(symboles de débogage intacts)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 bad_code
<comment>(variable -ggdb active)</comment>
-rwxr-xr-x  1 chris users 19552  6/28 13:11 bad_code
</pre>

<p>
Comme vous pouvez le remarquer, -ggdb ajoute environ <e>13178</e> octets de plus
à la taille du fichier par rapport à celui qui contient les symboles de
débogage. Toutefois, comme nous l'avons vu, ce poids supplémentaire peut valoir
le coup pour présenter les informations de débogage aux développeurs. Le traçage
peut être sauvegardé dans un fichier en copiant et collant depuis le terminal.
(Si c'est un terminal qui n'utilise pas le serveur X, vous pouvez utiliser GPM.
Afin de garder cette documentation simple, je vous recommande de lire la
<uri link="/doc/fr/gpm.xml#doc_chap4">documentation pour GPM</uri> pour voir
comment copier et coller avec.) Maintenant que nous avons fait ce que nous
devions avec <c>GDB</c>, nous pouvons en sortir.
</p>

<pre caption="Quitter GDB">
(gdb) <i>quit</i>
The program is running. Exit anyway? (y or n) <i>y</i>
$
</pre>

<p>
Ceci clôt la découverte de <c>GDB</c>. En utilisant <c>GDB</c>, nous espérons
que vous serez en mesure de l'utiliser pour créer de meilleurs rapports de
bogue. Toutefois, il y a d'autres types d'erreurs qui peuvent causer
l'interruption d'un programme durant son exécution. L'un des autres cas peut
être une erreur d'accès à un fichier. Nous pouvons les retrouver en utilisant un
petit outil bien chouette du nom de <c>strace</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Utiliser strace pour chercher les erreurs d'accès aux fichiers</title>
<section>
<title>Introduction</title>
<body>

<p>
Les programmes utilisent souvent des fichiers pour récupérer des informations de
configuration, accéder au matériel ou écrire des journaux. Parfois, un programme
tente d'accéder à de tels fichiers de manière incorrecte. Un outil nommé
<c>strace</c> a été créé afin de faciliter leur détection. <c>strace</c> trace
les appels systèmes (d'où le nom), ce qui implique les appels qui utilisent la
mémoire et les fichiers. Pour notre exemple, nous allons prendre un programme
nommé foobar2, qui est une version mise à jour de foobar. Cependant, durant la
transition vers foobar2, vous vous apercevez que tous les fichiers de
configuration sont manquants&nbsp;! Vous aviez configuré la première version de
foobar pour qu'elle affiche «&nbsp;foo&nbsp;», mais maintenant elle affiche la
valeur par défaut «&nbsp;bar&nbsp;».
</p>

<pre caption="Foobar2 avec une configuration invalide">
$ <i>./foobar2</i>
La configuration dit: bar
</pre>

<p>
Notre configuration précédente était spécialement définie à «&nbsp;foo&nbsp;»,
utilisons donc <c>strace</c> pour savoir ce qui se passe.
</p>

</body>
</section>
<section>
<title>Utiliser strace pour chercher le problème</title>
<body>

<p>
Nous utilisons <c>strace</c> pour enregistrer les résultats des appels systèmes.
Pour cela, nous lançons <c>strace</c> avec l'argument -o[fichier]. Utilisons-le
sur foobar2 comme suit&nbsp;:
</p>

<pre caption="Lancer foobar2 avec strace">
# <i>strace -ostrace.log ./foobar2</i>
</pre>

<p>
Cela crée un fichier nommé <path>strace.log</path> dans le répertoire courant.
Nous vérifions le fichier, et en voici ci-dessous la partie intéressante&nbsp;:
</p>

<pre caption="Un coup d'œil au journal de strace">
open(".foobar2/config", O_RDONLY)       = 3
read(3, "bar", 3)                       = 3
</pre>

<p>
Aha! Voilà donc le problème. Quelqu'un a changé l'emplacement du répertoire de
configuration vers <path>.foobar2</path> au lieu de <path>.foobar</path>. Nous
voyons également que le programme lit «&nbsp;bar&nbsp;» comme prévu. Dans ce
cas-ci, nous recommandons au mainteneur de l'ebuild d'ajouter un avertissement à
ce propos. Pour le moment toutefois, nous pouvons remplacer le fichier de
configuration avec celui du répertoire <path>.foobar</path> et le modifier afin
d'obtenir le résultat correct.
</p>

</body>
</section>
<section>
<title>Conclusion</title>
<body>

<p>
Nous nous sommes donc occupés de rechercher les bogues d'exécution du programme.
Ces bogues sont souvent problématiques lorsque vous essayez et lancez vos
programmes. Cependant, ces erreurs d'exécution s'avèrent sans grande importance
lorsque votre programme ne compile pas du tout. Intéressons-nous donc à la
manière d'aborder les erreurs de compilation d'<c>emerge</c>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gérer les erreurs d'emerge</title>
<section>
<title>Introduction</title>
<body>

<p>
Les erreurs d'<c>emerge</c>, comme celle affichée précédemment, peuvent être une
cause majeure de frustration pour les utilisateurs. Leur signalisation est donc
considérée commme cruciale pour garantir la santé de Gentoo. Prenons pour
exemple un ebuild, foobar2, qui contient des erreurs de compilation.
</p>

</body>
</section>
<section id="emerge_error">
<title>Évaluer les erreurs d'emerge</title>
<body>

<p>
Intéressons-nous à cette très simple erreur d'<c>emerge</c>&nbsp;:
</p>

<pre caption="Erreur d'emerge (les lignes trop longues ont été coupées volontairement pour s'adapter à la fenêtre)">
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2.o foobar2.c
foobar2.c:1:17: ogg.h: Aucun fichier ou répertoire de ce type
make: *** [foobar2.o] Error 1

!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
La compilation du programme se déroule très bien jusqu'à ce qu'elle s'arrête et
affiche un message d'erreur. Cette erreur particulière peut se décomposer en
trois parties&nbsp;: les messages de compilation, l'erreur de construction et le
message d'erreur d'<c>emerge</c> comme montré ci-dessous.
</p>

<pre caption="Parties de l'erreur  (les lignes trop longues ont été coupées volontairement pour s'adapter à la fenêtre)">
<comment>(Les messages de compilation)</comment>
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
-c -o foobar2.o foobar2.c

<comment>(L'erreur de construction)</comment>
foobar2.c:1:17: ogg.h: Aucun fichier ou répertoire de ce type
make: *** [foobar2.o] Error 1

<comment>(L'erreur d'emerge)</comment>
!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
Ce sont les messages de compilation qui amènent à l'erreur. Le plus souvent, il
est préférable d'inclure au moins dix lignes d'informations de compilation afin
que le développeur sache où la compilation en était quand l'erreur est arrivée.
</p>

<p>
Veuillez vous assurer de toujours inclure les messages d'erreur en anglais,
même si votre langage système est réglé sur autre chose. Vous pouvez
temporairement basculer votre système en anglais en préfixant la commande
emerge avec <c>LC_ALL=C</c> comme ceci&nbsp;:
</p>

<pre caption="Changement temporaire de locale">
# <i>LC_ALL=C emerge sys-apps/foobar2</i>
</pre>

<note>
Il s'agit du seul moment où vous devez utiliser la variable d'environnement
<c>LC_ALL</c> pour spécifier les paramètres de locale. Si vous cherchez un
moyen de changer le langage de votre système, merci de plutôt consulter notre
<uri link="guide-localization.xml">Guide de localisation</uri>.
</note>

<p>
Les erreurs de <c>make</c> sont de véritables erreurs et fournissent les
informations dont le développeur a besoin. Quand vous voyez «&nbsp;make:
***&nbsp;», il s'agit souvent de l'endroit où l'erreur est arrivée.
Normalement, vous pouvez copier et coller les dix lignes précédentes et le
développeur sera capable d'identifier le problème. Cependant, il se peut que ça
ne fonctionne pas et nous allons voir une alternative peu après.
</p>

<p>
L'erreur d'<c>emerge</c> est ce que la commande renvoie comme une erreur.
Parfois, elle peut contenir aussi des informations importantes. Souvent, les
gens font l'erreur de ne poster que l'erreur d'<c>emerge</c> et rien d'autre.
Elle est inutile toute seule, mais avec l'erreur de <c>make</c> et les
informations de compilation, un développeur peut savoir quelle application et
quelle version du paquet a ce problème. Petite parenthèse, <c>make</c> est
communément utilisé pour le processus de compilation des programmes (<b>mais pas
toujours</b>). Si vous ne trouvez d'erreur «&nbsp;make: ***&nbsp;» nulle part,
alors copiez et collez simplement les vingt lignes précédant l'erreur
d'<c>emerge</c>. Cela devrait couvrir la majorité des messages d'erreurs du
système de compilation. Disons maintenant que l'erreur paraît très grande. Dix
lignes ne suffiront pas pour tout comprendre. C'est là qu'entre en jeu
PORT_LOGDIR.
</p>

</body>
</section>
<section>
<title>La commande emerge et PORT_LOGDIR</title>
<body>

<p>
PORT_LOGDIR est une variable de Portage qui définit un répertoire pour séparer
les journaux d'<c>emerge</c>. Intéressons-nous-y et voyons ce que cela requiert.
Tout d'abord, lancez <c>emerge</c> en définissant PORT_LOGDIR à votre
emplacement préféré. Disons que nous avons un répertoire
<path>/var/log/portage</path>. Nous allons l'utiliser pour notre répertoire de
journaux&nbsp;:
</p>

<note>
Dans la configuration par défaut, <path>/var/log/portage</path> n'existe pas, et
vous allez devoir le créer. Si vous ne le faites pas, Portage n'arrivera pas à
écrire les journaux.
</note>

<pre caption="Utiliser emerge avec PORT_LOGDIR">
# <i>PORT_LOGDIR=/var/log/portage emerge cate-gorie/foobar2</i>
</pre>

<p>
Maintenant, <c>emerge</c> va encore échouer. Cependant, nous avons cette fois-ci
un journal avec lequel nous pouvons travailler, et que l'on pourra joindre au
bogue plus tard. Jetons un œil à notre fichier journal.
</p>

<pre caption="Contenu de PORT_LOGDIR">
# <i>ls -la /var/log/portage</i>
total 16
drwxrws---   2 root root 4096 Jun 30 10:08 .
drwxr-xr-x  15 root root 4096 Jun 30 10:08 ..
-rw-r--r--   1 root root 7390 Jun 30 10:09 cate-gorie:foobar2-1.0:20090110-213217.log
</pre>

<p>
Les fichiers de journaux ont le format [categorie]:[nom du
paquet]-[version]:[date].log. Un coup d'œil rapide au journal montre le
processus entier d'<c>emerge</c>. Il pourra être joint plus tard comme nous le
verrons dans la section de rapport de bogues. Maintenant que nous avons
correctement obtenu nos informations nécessaires pour rapporter le bogue, nous
pouvons continuer. Cependant, avant d'aborder ce point, nous devons nous
assurer que personne n'a déjà rapporté le problème. Intéressons-nous donc à la
recherche de bogues.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Recherche avec Bugzilla</title>
<section>
<title>Introduction</title>
<body>

<p>
<uri link="http://www.bugzilla.org">Bugzilla</uri> est ce que nous utilisons
chez Gentoo pour gérer les bogues. Le Bugzilla de Gentoo est joignable en HTTPS
et en HTTP. La version HTTPS est disponible pour ceux qui sont sur des réseaux
non sécurisés ou simplement pour les paranoïaques&nbsp;:). Pour respecter une
certaine uniformité, nous utiliserons la version HTTPS dans les exemples qui
suivent. Rendez-vous sur <uri link="https://bugs.gentoo.org">Gentoo Bugs</uri>
pour voir à quoi cela ressemble.
</p>

<p>
L'une des choses les plus frustrantes pour les développeurs et les mainteneurs
de bogues est de trouver des rapports de bogues dupliqués. Cela leur coûte un
temps non négligeable qu'ils pourraient plutôt utiliser pour travailler sur des
bogues plus importants. Généralement, ceci pourrait être évité avec quelques
méthodes simples de recherche. Nous allons ainsi voir comment rechercher des
bogues et détecter si vous en avez un similaire. Dans cet exemple, nous allons
utiliser l'erreur décelée tout à l'heure avec l'installation de xclass.
</p>

<pre caption="Erreur lors de l'emerge de xclass">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Pour commencer la recherche, rendons-nous sur la <uri
link="https://bugs.gentoo.org/">page d'accueil du Bugzilla</uri>.
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Page d'accueil du
Bugzilla"/>

<p>
Cliquons sur «&nbsp;Query Existing bug reports&nbsp;» (NdT&nbsp;: 
«&nbsp;Recherche de rapports de bogues existants&nbsp;»). Nous choisissons cette
recherche plutôt que la recherche classique car la recherche classique a
tendance à donner des résultats vagues et empêche souvent les utilisateurs de
trouver leur bogue à cause d'un grand nombre de résultats de recherche. Une fois
que nous avons cliqué sur ce lien, nous obtenons la page suivante&nbsp;:
</p>

<figure link="/images/docs/bugzie-search.png" caption="Page de recherche du
Bugzilla"/>

<note>
Si vous avez déjà utilisé la recherche avancée auparavant, vous aurez plus de
chances de voir cet écran à la place.
</note>

<p>
Cliquez sur le lien «&nbsp;Advanced search&nbsp;» (NdT&nbsp;: «&nbsp;Recherche
avancée&nbsp;») pour atteindre la page de recherche avancée.
</p>

<figure link="/images/docs/bugzie-adv-search.png" caption="Page de recherche
avancée"/>

<p>
Voici comment la page de recherche avancée se présente. Bien que cela puisse
s'avérer bouleversant au premier abord, nous allons voir que quelques simples
renseignements permettent de réduire quelque peu les résultats vagues que le
Bugzilla retourne.
</p>

<figure link="/images/docs/bugzie-content.png" caption="Contenu"/>

<p>
Le premier champ est le résumé du bogue. Ici nous allons simplement mettre le
nom du paquet qui a planté. Si Bugzilla ne retourne aucun résultat, essayez de
retirer le nom du paquet, juste au cas où quelqu'un ne l'aurez pas mis dans le
résumé (hautement déconseillé, mais nous avons déjà vu un certain nombre de
rapports de bogues étranges).
</p>

<p>
Les champs «&nbsp;Product &nbsp;» (NdT&nbsp;: «&nbsp;produit&nbsp;»),
«&nbsp;Component&nbsp;» (NdT&nbsp;: «&nbsp;pour la partie&nbsp;») et
«&nbsp;Version &nbsp;» vont tous être laissés par défaut. Cela nous évite
d'être trop précis et de manquer tous les bogues.
</p>

<p>
La partie «&nbsp;Comment&nbsp;» (NdT&nbsp;: «&nbsp;commentaire&nbsp;») est la
plus importante. Utilisez ce champ pour lister ce qui semble être un cas
caractéristique de l'erreur. En gros, n'utilisez pas quelque chose comme le
début de l'erreur de compilation, mais trouvez une ligne avant faisant état
d'une vraie erreur. Aussi vous pouvez filtrer la ponctuation pour éviter que
Bugzilla n'interprète les résultats des commentaires de la mauvaise façon. Voici
l'exemple de notre erreur de xclass&nbsp;:
</p>

<pre caption="Contenu de la ligne Comment">
menudef.h:78: error: brace-enclosed initializer used to initialize `OXPopupMenu'
<comment>(Enlevez la ponctuation ` ' :.)</comment>
menudef.h 78 error brace-enclosed initializer used to initialize OXPopupMenu
</pre>

<p>
L'exemple ci-dessus est assez caractéristique de l'endroit où nous trouverions
le bogue sans patauger avec d'autres résultats candidats pour cette erreur de
compilation de xclass.
</p>

<p>
«&nbsp;URI&nbsp;», «&nbsp;Whiteboard&nbsp;» (NdT&nbsp;: «&nbsp;tableau
blanc&nbsp;»), et «&nbsp;Keywords&nbsp;» (NdT&nbsp;: «&nbsp;mots clefs&nbsp;»)
peuvent être laissés vides. Ce que nous avons mis avant devrait suffir à trouver
notre bogue. Jetons un œil à ce que nous avons renseigné.
</p>

<figure link="/images/docs/bugzie-comp-search.png" caption="Formulaire de
recherche complété"/>

<p>
À présent, cliquons sur le bouton «&nbsp;Search&nbsp;» (NdT&nbsp;:
«&nbsp;Rechercher&nbsp;») et voici les résultats...
</p>

<figure link="/images/docs/bugzie-search-result.png" caption="Résultats de
recherche"/>

<p>
Seulement deux bogues&nbsp;! C'est ainsi beaucoup plus facile de s'en occuper.
Cliquons sur le premier pour vérifier et être suffisamment sûr que c'est celui
que nous cherchons.
</p>

<figure link="/images/docs/bugzie-located.png" caption="Bogue localisé"/>

<p>
Non seulement c'est celui que nous voulons, mais en plus il a déjà été résolu.
En vérifiant le dernier commentaire, nous trouvons la solution et savons ce
qu'il faut faire pour le résoudre. Maintenant, voyons ce qu'il se serait passé
si nous n'avions pas utilisé la recherche avancée.
</p>

<figure link="/images/docs/bugzie-basic-search-result.png" caption="Résultats de
recherche classique"/>

<p>
Quatre bogues à inspecter&nbsp;! Cela aurait été bien pire avec de plus gros
paquets. Néanmoins, avec ces simples outils, nous sommes capables de réduire de
manière significative le temps de recherche pour essayer de localiser un bogue
spécifique.
</p>

</body>
</section>
<section>
<title>Conclusion</title>
<body>

<p>
Disons que vous avez cherché et cherché mais que vous n'avez toujours pas trouvé
un bogue correspondant sur le Bugzilla. Alors vous avez trouvé vous-même un
nouveau bogue. Nous allons voir le processus de rapport de bogue pour soumettre
votre nouveau bogue.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Le rapport de bogues</title>
<section>
<title>Introduction</title>
<body>

<p>
Dans ce chapitre, nous allons voir comment utiliser Bugzilla pour répertorier
un nouveau bogue de façon claire. Rendez-vous pour cela sur la page de <uri
link="https://bugs.gentoo.org">Gentoo Bugs</uri>...
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Page d'accueil de
Bugzilla"/>

<p>
Cliquez sur «&nbsp;Report a Bug - Using the guided format&nbsp;» (NdT&nbsp;:
«&nbsp;Rapporter un bogue, utilisation du format guidé&nbsp;»).
</p>

<figure link="/images/docs/bugzie-prod-select.png" caption="Sélection du
produit"/>

<p>
Comme vous pouvez le voir, l'accent <b>majeur</b> a été mis sur le fait de
placer votre bogue au bon endroit. «&nbsp;Gentoo Linux&nbsp;» est l'endroit où
la grande majorité des bogues vont trouver leur place.
</p>

<p>
En dépit de ceci, certaines personnes posteront les bogues d'ebuild dans la
partie du développement de Portage (pensant que l'équipe de Portage gère l'arbre
de Portage) ou dans «&nbsp;infra&nbsp;» (pensant que l'équipe a accès aux
miroirs pouvant ainsi synchroniser et régler le problème directement). Ce n'est
simplement pas comme ça que les choses fonctionnent.
</p>

<p>
Une autre idée reçue et qui est fausse concerne nos bogues de documentation.
Par exemple, un utilisateur trouve un bogue avec la
<uri link="/proj/en/releng/catalyst/">documentation de Catalyst</uri>. La
tendance générale est de répertorier un bogue dans «&nbsp;Docs-user&nbsp;», qui
est en fait assigné à l'équipe du <uri link="http://gdp.gentoo.org">GDP</uri>,
alors qu'il devrait être envoyé à un membre de l'équipe du projet <uri
link="/proj/en/releng/">Release Engineering</uri>. En général, seule la
documentation se trouvant dans <path>http://www.gentoo.org/doc/*</path>
appartient à la GDP. Toute documentation se trouvant dans
<path>http://www.gentoo.org/proj/*</path> appartient aux équipes respectives.
</p>

<note>
Nous préférons voir un bogue dont le produit n'est pas censé être «&nbsp;Gentoo
Linux&nbsp;» mais qui a été classé dans cette catégorie plutôt que de voir un
bogue qui appartient au produit «&nbsp;Gentoo Linux&nbsp;» et rangé autre part.
Même si aucun des deux n'est privilégié, le premier est plus recevable et
compréhensible (à l'exception des bogues du site... nous pourrions avoir un
problème avec cela...).
</note>

<p>
Notre bogue va dans «&nbsp;Gentoo Linux&nbsp;» car c'est un bogue d'ebuild. Nous
nous rendons là-bas et nous nous trouvons face au processus multi-étapes de
rapport de bogue. Passons donc à présent à l'étape 1...
</p>

<figure link="/images/docs/bugzie-guide-step1.png" caption="Format guidé de
l'étape 1"/>

<p>
Cette première étape est vraiment très importante (comme vous le montre le texte
rouge). C'est l'endroit où vous cherchez pour voir si quelqu'un d'autre n'a pas
déjà relevé le même bogue que vous. Si vous zappez cette étape et qu'un bogue
comme le vôtre existe, il sera marqué en DUPLICATE gaspillant de ce fait un
grand effort de la part des QA. Pour vous donner une idée, les numéros de bogues
qui sont barrés ci-dessus concernent des bogues dupliqués. Vient maintenant
l'étape 2, où nous renseignons l'information.
</p>

</body>
</section>
<section>
<title>Information requise</title>
<body>

<figure link="/images/docs/bugzie-basic.png" caption="Informations de base"/>

<p>
Jetons un petit coup d'œil à qui est quoi.
</p>

<ul>
  <li>
    En premier, c'est le produit, «&nbsp;Product&nbsp;». Le produit va réduire
    le bogue à un domaine spécifique de Gentoo comme le Bugzilla (pour les
    bogues en relation avec bugs.gentoo.org), Docs-user (pour la documentation
    utilisateur) ou Gentoo Linux (pour les ebuilds et semblables).
  </li>
  <li>
    La partie («&nbsp;Component&nbsp;») est où exactement le problème est
    apparu, plus précisément dans quelle partie du produit sélectionné le bogue
    est arrivé. Cela rend la classification plus facile.
  </li>
  <li>
    La plate-forme matérielle («&nbsp;Hardware Platform&nbsp;») est
    l'architecture que vous utilisez. Si vous utilisez SPARC, vous devrez mettre
    SPARC.
  </li>
  <li>
    «&nbsp;Operating System&nbsp;», pour système d'exploitation, correspond au
    système que vous utilisez. Gentoo étant considérée comme une
    "méta-distribution", elle peut également fonctionner sur des systèmes
    d'exploitation autres que Linux.
  </li>
</ul>

<p>
Donc, pour notre exemple de bogue, nous avons&nbsp;:
</p>

<ul>
  <li>Product - Gentoo Linux (puisque c'est un problème d'ebuild)</li>
  <li>
    Component - Application (c'est une erreur provenant d'une application,
    foobar2)
  </li>
  <li>
    Hardware Platform - All (cette erreur pourrait apparaître sur toutes les
    architectures)
  </li>
  <li>
    Operating System - All (cela pourrait se produire sur tous les types de
    systèmes)
  </li>
</ul>

<figure link="/images/docs/bugzie-basic-comp.png" caption="Informations de base
complétées"/>

<ul>
  <li>
    La marque de construction («&nbsp;Build Identifier&nbsp;») est simplement
    le nom du navigateur (l'«&nbsp;User Agent&nbsp;») utilisé pour rapporter le
    bogue (à des fins de journalisation). Vous pouvez laisser comme tel.
  </li>
  <li>
    L'URL est optionnelle et sert à pointer l'information appropriée sur un
    autre site (un bogue parent sur le Bugzilla, les notes de publications sur
    la page d'accueil du paquet, etc.). Vous ne devriez jamais utiliser une URL
    qui mène sur un pastebin pour les messages d'erreurs, les logs, la sortie de
    <c>emerge --info</c>, les captures d'écran ou les informations similaires.
    Celles-ci doivent toujours être attachées au bogue.
  </li>
  <li>
    Dans le résumé, «&nbsp;Summary&nbsp;», vous devriez mettre la catégorie du
    paquet, son nom, et son numéro.
  </li>
</ul>

<p>
Ne pas inclure la catégorie dans le résumé n'est pas vraiment une catastrophe,
mais c'est recommandé. Si vous ne mettez pas le nom du paquet, en revanche,
nous ne saurons pas sur quoi vous remplissez un rapport de bogue, et nous serons
obligés de vous le demander plus tard. Le numéro de version est important pour
les personnes cherchant les bogues. Si vingt personnes remplissent des bogues et
qu'aucun d'entre eux ne met de numéro de version, comment vont faire les gens
qui cherchent si un bogue similaire au leur existe déjà&nbsp;? Ils vont devoir
inspecter chaque bogue individuellement, ce qui n'est pas trop difficile, mais
s'il y a, disons, 200 bogues... ce n'est pas aussi facile. Après toutes les
informations concernant le paquet, vous devrez écrire une petite description du
problème. Ici par exemple&nbsp;:
</p>

<figure link="/images/docs/bugzie-summary.png" caption="Résumé"/>

<p>
Ces quelques règles simples peuvent simplifier grandement la gestion des bogues.
Ensuite viennent les détails. Ici nous renseignons les informations concernant
le bogue. Nous allons voir cela avec un exemple&nbsp;:
</p>

<figure link="/images/docs/bugzie-details.png" caption="Détails"/>

<p>
À présent, les développeurs savent pourquoi nous avons rapporté ce bogue. Ils
peuvent alors essayer de le reproduire. Le champ «&nbsp;Reproducibility&nbsp;»
(NdT&nbsp;: «&nbsp;Reproduction&nbsp;») nous dit à quelle fréquence on a pu
reproduire le problème. Dans cet exemple, nous pouvons le reproduire chaque fois
simplement en exécutant foobar2. Renseignons cette information.
</p>

<figure link="/images/docs/bugzie-reprod.png" caption="Reproduction"/>

<p>
Nous avons expliqué comment nous avons trouvé le bogue. La prochaine étape
consiste à expliquer quels ont été les résultats que nous avons obtenus et ce
que nous pensons qu'ils auraient dû être en réalité.
</p>

<figure link="/images/docs/bugzie-results.png" caption="Résultats"/>

<p>
Nous pourrions alors fournir des informations supplémentaires. Cela peut être
des choses telles que les traces de pile, des <b>morceaux</b> (puisque le
journal complet est généralement lourd et pas très utile) des journaux de
strace, mais plus important, notre sortie de <c>emerge --info</c>. Voici un
exemple.
</p>

<figure link="/images/docs/bugzie-addl-info.png" caption="Informations
supplémentaires"/>

<p>
Enfin nous désignons la sévérité du bogue. Veuillez passer en revue ceci
attentivement. Dans la plupart des cas, il est bon de laisser le choix par
défaut et quelqu'un augmentera ou baissera le niveau de criticité pour vous.
Toutefois, si vous relevez le niveau de sévérité du bogue, assurez-vous de le
renseigner très soigneusement et assurez-vous que vous ne faites pas une erreur.
Un aperçu des différents niveaux de criticité est donné ci-dessous.
</p>

<ul>
  <li>
    Blocker (NdT&nbsp;: «&nbsp;Bloquant&nbsp;») - Le programme ne veut tout
    simplement pas s'installer ou représente une entrave majeure au système. Par
    exemple, un problème de <c>baselayout</c> qui empêche le système de démarrer
    pourrait être un candidat à cet estampillage.
  </li>
  <li>
    Critical (N.D.T: pour «&nbsp;Critique&nbsp;») - Le programme connaît des
    pertes de données ou de graves fuites de mémoire durant son exécution. De
    nouveau, un programme important tel que <c>net-tools</c> échouant durant sa
    compilation pourrait être étiqueté comme critique. Il ne va pas empêcher le
    système de démarrer, mais est assez essentiel dans l'utilisation de tous les
    jours.
  </li>
  <li>
    Major (N.D.T: pour «&nbsp;Majeur&nbsp;») - Le programme plante, mais rien ne
    cause des dommages sévères à votre système ou ne crée des pertes
    d'informations.
  </li>
  <li>
    Minor (N.D.T: pour «&nbsp;Mineur&nbsp;») - Votre programme plante ici et là
    avec des fonctions claires.
  </li>
  <li>
    Normal - Le choix par défaut. Si vous n'êtes pas sûr, laissez ceci comme tel
    à moins que ce soit une nouvelle version, ou un changement d'apparence, dans
    ce cas regardez ci-dessous pour plus d'informations.
  </li>
  <li>
    Trivial - Des choses telles qu'un mot oublié ou pour enlever un espace
    blanc.
  </li>
  <li>
    Enhancement (N.D.T: pour «&nbsp;Amélioration&nbsp;» - Une requête pour
    activer une nouvelle fonctionnalité dans un programme, ou plus
    particulièrement des <e>nouveaux ebuilds</e>.
  </li>
</ul>

<figure link="/images/docs/bugzie-sev.png" caption="Sévérité"/>

<p>
Ici, nous mettons le bogue au niveau Normal.
</p>

<p>
À présent, nous pouvons soumettre notre rapport de bogue en cliquant sur la
boîte «&nbsp;Submit Bug Report&nbsp;» (NdT&nbsp;: «&nbsp;Soumettre un rapport de
bogue&nbsp;»). Vous pouvez dès à présent voir votre nouveau bogue. Regardez le
<uri link="https://bugs.gentoo.org/show_bug.cgi?id=97265">Bogue 97561</uri> pour
voir à quoi cela ressemble. Nous avons rapporté notre bogue&nbsp;! Voyons
comment cela est traité.
</p>

</body>
</section>
<section>
<title>Les requêtes d'estampillage de 0-jour</title>
<body>

<p>
Plus haut, nous avons vu comment rapporter un bogue. Maintenant nous allons voir
ce qu'il ne faut <e>pas</e> faire.
</p>

<p>
Supposons que vous avez ardemment suivi la planification d'un projet ascendant,
et quand vous vérifiez sa page d'accueil, que voyez-vous&nbsp;? Ils viennent
juste de sortir une nouvelle version quelques minutes avant&nbsp;! La plupart
des utilisateurs se précipiteraient immédiatement sur le Bugzilla de Gentoo pour
dire que la nouvelle version est disponible&nbsp;: veuillez estampiller la
version existante et l'ajouter à Portage, etc. Toutefois, c'est exactement ce
que vous ne devez <b>pas</b> faire. Les requêtes de ce genre sont appelées des
requêtes d'estampillage de zéro jour (ou des 0-jour), car elles sont faites
le même jour que la sortie de la nouvelle version.
</p>

<impo>
<b>Veuillez patienter <e>au moins</e> 48 heures avant de rapporter une nouvelle
version sur notre Bugzilla.</b> Aussi, vous <e>devez</e> vérifier Bugzilla
avant de poster une demande afin de vous assurer que personne ne l'a déjà
rapporté, ou que les mainteneurs de Gentoo ne sont pas déjà en train de traiter
la nouvelle version.
</impo>

<p>
Pourquoi devez-vous attendre&nbsp;? Premièrement, c'est assez impoli d'exiger
des développeurs de Gentoo d'abandonner quelque chose qu'ils sont en train de
faire juste pour ajouter une nouvelle version qui est sortie quinze minutes
avant. Votre demande pourrait être marquée comme INVALID ou LATER, car les
développeurs ont plein de problèmes urgents qui les gardent occupés.
Deuxièmement, les développeurs sont généralement au courant des sorties de
nouvelles versions bien avant les utilisateurs, puisqu'ils doivent suivre la
version en amont d'assez près. Ils savent déjà qu'une nouvelle version est en
cours. Dans bien des cas, ils ont déjà ouvert un bogue, ou peut-être même l'ont
déjà ajouté à Portage comme paquet masqué.
</p>

<p>
Soyez judicieux quand vous testez et demandez des nouvelles versions de paquets.
Cherchez dans Bugzilla avant de poster votre requête d'estampillage&nbsp;: n'y
a-t-il pas déjà un bogue ouvert&nbsp;? Avez-vous synchronisé il y a
longtemps&nbsp;; n'est-ce pas déjà dans Portage&nbsp;? Le paquet a-t-il bien
été libéré par l'équipe en amont&nbsp;? Un peu de bon sens fera bon chemin, et
vous fera apprécier des développeurs qui ont déjà beaucoup à faire. Si cela
fait quelques jours que la version est sortie et que vous êtes sûr qu'il n'y a
pas d'autres demandes pour celle-ci (et qu'elle n'est pas non plus dans
Portage), alors vous pouvez ouvrir un nouveau bogue. Assurez-vous de mentionner
qu'il compile et fonctionne bien sur votre architecture. Toute autre
information pouvant aider et que vous fournirez sera la bienvenue.
</p>

<p>
Vous voulez voir la nouvelle version de votre logiciel favori dans
Portage&nbsp;? Répertoriez des bogues intelligents.
</p>

</body>
</section>
</chapter>

<chapter>
<title>S'occuper de votre bogue</title>
<section>
<body>

<p>
En regardant le bogue, nous voyons les informations que nous avons fournies
précédemment. Vous noterez que le bogue a été assigné à
bug-wranglers@gentoo.org. C'est l'attribution par défaut pour les bogues de la
composante Application.
</p>

<figure link="/images/docs/bugzie-new-basic.png" caption="Informations de base
d'un nouveau bogue"/>

<p>
Les détails que nous avons entrés à propos du bogue sont également disponibles.
</p>

<figure link="/images/docs/bugzie-new-details.png" caption="Détails du nouveau
bogue"/>

<p>
Cependant, les mainteneurs de bogues ne vont (généralement) pas corriger nos
bogues, donc nous allons les réassigner à quelqu'un qui peut le faire (vous
pouvez aussi laisser les mainteneurs de bogues le réassigner pour vous). Pour
cela, nous utilisons le fichier metadata.xml du paquet. Vous pouvez normalement
le trouver dans <path>/usr/portage/categorie/paquet/metadata.xml</path>. Voici
celui que j'ai créé pour foobar2.
</p>

<note>
Vous devez être le rapporteur du bogue ou un membre de certains groupes du
Bugzilla de Gentoo (comme celui des Développeurs Gentoo) pour pouvoir réassigner
les bogues.
</note>

<pre caption="metadata.xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd"&gt;
&lt;pkgmetadata&gt;
&lt;herd&gt;chriswhite&lt;/herd&gt;
&lt;maintainer&gt;
&lt;email&gt;chriswhite@gentoo.org&lt;/email&gt;
&lt;name&gt;Chris White&lt;/name&gt;
&lt;/maintainer&gt;
&lt;longdescription lang="en"&gt;
Foobar2 is a package that uses a configuration file to display a word.
&lt;/longdescription&gt;
&lt;/pkgmetadata&gt;
</pre>

<p>
Notez la section «&nbsp;maintainer&nbsp;» (NdT&nbsp;: «&nbsp;mainteneur&nbsp;»).
Elle renseigne sur le mainteneur du paquet, qui est moi-même, Chris White, dans
ce cas-ci. L'adresse électronique listée est chriswhite@gentoo.org. Nous allons
l'utiliser afin de réassigner le bogue à la bonne personne. Pour se faire,
cliquez sur la bulle à côté de «&nbsp;Reassign bug to&nbsp;» (NdT&nbsp;:
«&nbsp;Réassigner le bogue à&nbsp;»), puis renseignez l'adresse électronique.
</p>

<note>
Pour un paquet qui n'a pas de fichier metadata.xml, le bogue doit être réassigné
à maintainer-needed@gentoo.org et un paquet qui a besoin d'un développeur Gentoo
pour être maintenu doit être assigné à maintainer-wanted@gentoo.org.
</note>

<figure link="/images/docs/bugzie-reassign.png" caption="Réassignement d'un
bogue"/>

<p>
Puis cliquez sur le bouton «&nbsp;Commit&nbsp;» (NdT&nbsp;:
«&nbsp;Envoyer&nbsp;») pour appliquer les changements. Le bogue m'a été
réassigné. Peu après, vous remarquerez (par email habituellement) que j'ai
répondu à votre bogue. J'ai indiqué que j'aimerais voir un journal de strace
afin de voir comment le programme essaie d'atteindre son fichier de
configuration. Suivez les instructions précédentes sur l'utilisation de strace
pour obtenir un journal. Maintenant vous devez le joindre au bogue. Pour ce
faire, cliquez sur «&nbsp;Create A New Attachment&nbsp;» (NdT&nbsp;: 
«&nbsp;Créer une nouvelle pièce jointe&nbsp;»).
</p>

<figure link="/images/docs/bugzie-new-attach.png" caption="Nouvelle pièce
jointe"/>

<p>
Maintenant, nous devons joindre le journal. Allons-y à grands pas.
</p>

<ul>
  <li>
    File (NdT&nbsp;: Fichier) - C'est l'emplacement du fichier sur votre
    machine. Dans cet exemple, l'emplacement de <path>strace.log</path>. Vous
    pouvez utiliser le bouton «&nbsp;Browse...&nbsp;» (NdT&nbsp;: Parcourir ...)
    pour sélectionner le fichier, ou entrer le chemin directement dans le champ
    de texte.
  </li>
  <li>
    Description - Une courte ligne, ou quelques mots décrivant la pièce jointe.
    Nous allons juste entrer «&nbsp;strace.log&nbsp;» ici, puisque c'est
    suffisamment explicite.
  </li>
  <li>
    Content Type (NdT&nbsp;: Type de Contenu) - C'est le type du fichier que
    nous joignons au bogue.
  </li>
  <li>
    Obsoletes (NdT&nbsp;: Obsolètes) -  S'il y avait des pièces jointes
    attachées au bogue avant l'actuel, vous avez une option pour les déclarer
    obsolètes par les vôtres. Puisque nous n'avons pas de pièces jointes
    précédemment attachées à ce bogue, nous n'avons pas à nous en occuper.
  </li>
  <li>
    Comment (NdT&nbsp;: Commentaire) - Entrez des commentaires qui seront
    visibles avec cette pièce jointe. Vous pouvez donner des précisions sur
    celle-ci, si besoin.
  </li>
</ul>

<p>
Pour le respect du type de contenu, voici quelques détails supplémentaires. Vous
pouvez cocher la case «&nbsp;patch&nbsp;» si vous joignez un correctif.
Autrement, vous pouvez demander à Bugzilla d'auto-détecter le type de fichier
(non recommandé). Les autres options sont dans «&nbsp;select from list&nbsp;»
(NdT&nbsp;: sélectionner depuis une liste), qui est le plus fréquemment utilisé.
Utiliser le texte simple (text/plain) pour la plupart des pièces jointes sauf
pour les fichiers binaires comme les images (qui peuvent utiliser image/gif,
image/jpeg ou image/png selon leur type) ou les fichiers compressés comme
.tar.bz2 qui utiliseraient application/octet-stream comme type de fichier.
</p>

<figure link="/images/docs/bugzie-new-attach-comp.png" caption="Nouvelle pièce
jointe complétée"/>

<p>
Nous envoyons <path>strace.log</path> qui va être appliqué au rapport de bogue.
</p>

<figure link="/images/docs/bugzie-strace.png" caption="strace log attaché"/>

<p>
Nous avons mentionné auparavant que les ebuilds vont parfois nécessiter que vous
joignez un fichier avec l'erreur d'<c>emerge</c>. Voici un exemple ci-dessous.
</p>

<pre caption="Exemple de demande de fichier joint">
configure: error: PNG support requires ZLIB. Use --with-zlib-dir=&lt;DIR&gt;

!!! Please attach the config.log to your bug report:
!!! /var/tmp/portage/php-5.0.3-r1/work/php-5.0.3/config.log

!!! ERROR: dev-php/php-5.0.3-r1 failed.
!!! Function econf, Line 485, Exitcode 0
!!! econf failed
!!! If you need support, post the topmost build error, NOT this status message.
</pre>

<p>
Veuillez s'il-vous-plaît joindre tout fichier demandé comme ceci à votre rapport
de bogue.
</p>

<p>
Parfois un développeur peut vous demander de joindre un fichier diff ou un
correctif pour un fichier. Les fichiers diff standards peuvent être obtenus de
la façon suivante&nbsp;:
</p>

<pre caption="Création d'un fichier diff standard">
$ <i>cp fichier fichier.old</i>
$ <i>nano fichier</i>
$ <i>diff -u fichier.old fichier</i>
</pre>

<p>
Pour les fichiers source C/C++, l'option <b>-p</b> est ajoutée pour montrer à
quels appels de fonction s'applique le fichier diff&nbsp;:
</p>

<pre caption="Fichier diff d'un fichier source C/C++">
$ <i>cp fichier.c fichier.c.old</i>
$ <i>nano fichier.c</i>
$ <i>diff -up fichier.c.old fichier.c</i>
</pre>

<p>
L'équipe de documentation demandera la combinaison d'options <b>-Nt</b> ainsi
que <b>-u</b>. C'est surtout en rapport avec les espaces des tabulations. Vous
pouvez créer un tel fichier diff avec&nbsp;:
</p>

<pre caption="Fichier diff pour la documentation">
$<i> cp fichier.xml fichier.xml.old</i>
$<i> nano fichier.xml</i>
$<i> diff -Nut fichier.xml.old fichier.xml</i>
</pre>

<p>
Votre fichier diff est ainsi créé. Pendant que nous faisons tout ça, supposez
qu'une autre personne trouve votre bogue en cherchant sur le Bugzilla et est
curieuse de garder sa trace, elle peut le faire en ajoutant son adresse email au
champ CC du bogue comme montré ci-dessous. Vous pouvez également suivre la trace
d'autres bogues de la même façon.
</p>

<figure link="/images/docs/bugzie-add-email.png" caption="Ajouter un email au
CC"/>

<note>
Les adresses électroniques doivent être enregistrées avec le Bugzilla Gentoo.
Afin d'ajouter plusieurs adresses email, séparez-les simplement avec des
virgules ou des espaces.
</note>

<p>
Après tout ce travail, le bogue peut passer par divers états. C'est généralement
fait par les développeurs Gentoo et parfois par le rapporteur. Les valeurs
suivantes sont les divers états possibles qu'un bogue peut avoir durant sa vie.
</p>

<ul>
  <li>
    UNCONFIRMED (NdT&nbsp;: Non confirmé) - Vous ne le rencontrerez généralement
    pas souvent. Cela signifie qu'un rapporteur de bogue en a ouvert un en
    utilisant la méthode avancée et n'est pas certain que c'en est vraiment un.
  </li>
  <li>
    NEW (NdT&nbsp;: Nouveau) - Les bogues ouverts pour la première fois sont
    considérés comme nouveaux.
  </li>
  <li>
    ASSIGNED (NdT&nbsp;: Assigné) - Quand la personne à qui vous avez assigné
    votre bogue le valide, il va généralement recevoir le statut ASSIGNED le
    temps que les développeurs trouvent le problème. Ceci vous permet de savoir
    que votre bogue a été accepté comme un vrai bogue.
  </li>
  <li>
    REOPENED (NdT&nbsp;: Ré-ouvert) - Quelqu'un a résolu le bogue et vous pensez
    que la solution n'est pas faisable ou que le problème persiste. À ce
    moment-là, vous pouvez ré-ouvrir le bogue. <b>N'en abusez pas</b>
    s'il-vous-plaît. Si un développeur ferme un bogue une seconde ou troisième
    fois, il y a de grandes chances pour que votre bogue soit fermé.
  </li>
  <li>
    RESOLVED (NdT&nbsp;:  Résolu) - Une décision a été prise au sujet du bogue.
    Ceci aboutit généralement au statut FIXED (NdT&nbsp;: corrigé) pour indiquer
    que le bogue est résolu et que le sujet est clos même si d'autres
    résolutions sont possibles. Nous allons y regarder en détail peu après.
  </li>
  <li>
    VERIFIED (NdT&nbsp;: Vérifié) - Les étapes de travail du bogue sont
    correctes. C'est généralement une histoire d'assurance qualité.
  </li>
  <li>
    CLOSED (NdT&nbsp;: Fermé) - Signifie simplement la fermeture du bogue qui
    est enterré sous le flux sans fin des nouveaux bogues.
  </li>
</ul>

<p>
Maintenant ci-dessous, nous trouvons l'erreur dans le journal de strace,
corrigeons le bogue, le marquons comme RESOLVED FIXED, mentionnons qu'il y a eu
un changement de l'emplacement des fichiers de configuration, et mettons à jour
l'ebuild avec un avertissement à ce propos. Le bogue est alors résolu, et il
vous est affiché ceci&nbsp;:
</p>

<figure link="/images/docs/bugzie-reso.png" caption="Bogue résolu"/>

<p>
Un peu en dessous, vous allez voir ceci&nbsp;:
</p>

<figure link="/images/docs/bugzie-options.png" caption="Options du bogue"/>

<p>
Cela vous donne la possibilité de ré-ouvrir le bogue si vous le souhaitez (par
exemple le développeur pense que c'est résolu mais ce n'est vraiment pas selon
vos standards). Maintenant notre bogue est corrigé&nbsp;! Cependant, différentes
résolutions peuvent arriver. En voici une courte liste&nbsp;:
</p>

<ul>
  <li>
    FIXED (NdT&nbsp;: Corrigé) - Le bogue est corrigé, suivez les instructions
    pour résoudre le problème.
  </li>
  <li>
    INVALID (NdT&nbsp;: Invalide) - Vous n'avez pas fait quelque chose de
    spécialement documenté, causant le bogue.
  </li>
  <li>
    DUPLICATE (NdT&nbsp;: Dupliqué) - Vous n'avez pas utilisé ce guide et avez
    rapporté un bogue dupliqué.
  </li>
  <li>
    WORKSFORME (NdT&nbsp;: Fonctionne pour moi) - Le développeur ou la personne
    assigné au bogue ne peut pas reproduire votre erreur.
  </li>
  <li>
    CANTFIX (NdT&nbsp;: Non corrigeable) - Le bogue ne peut pas être résolu à
    cause de certaines circonstances. Celles-ci seront notées par la personne
    prenant en charge le bogue.
  </li>
  <li>
    WONTFIX (NdT&nbsp;: Ne sera pas corrigé) - C'est souvent appliqué aux
    nouveaux ebuilds ou aux demandes de nouvelles fonctionnalités. Le
    développeur ne veut simplement pas ajouter une certaine fonctionnalité parce
    que ce n'est pas nécessaire, qu'une meilleure alternative existe, ou que ça
    ne fonctionne pas. Il vous sera parfois donné une solution pour considérer
    le problème résolu.
  </li>
  <li>
    UPSTREAM (NdT&nbsp;: En amont) - Le bogue ne peut pas être corrigé par
    l'équipe de développement de Gentoo, et ils vous demandent de signaler le
    problème en amont (les personnes ayant fait le programme) pour une révision.
    Ils ont quelques moyens pour la gestion des bogues. Ceux-ci inclus les
    listes de mails, les canaux IRC, et aussi des systèmes de rapport de bogue.
    Si vous n'êtes pas sûr de la manière de les contacter, demandez dans le
    bogue et quelqu'un vous donnera la direction à suivre.
  </li>
</ul>

<p>
Parfois, avant qu'un bogue soit résolu, un développeur peut vous demander de
tester un ebuild mis à jour. Dans le chapitre suivant, nous allons voir comment
faire cela.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Test des ebuilds</title>
<section>
<title>Récupérer les fichiers</title>
<body>

<p>
Disons que vous avez rapporté un bogue pour la correction de l'erreur de
compilation de foobar2 obtenue auparavant. À présent, les développeurs peuvent
chercher quel est le problème et peuvent avoir besoin que vous testiez l'ebuild
pour eux afin d'être sûr que celui-ci fonctionne également pour vous&nbsp;:
</p>

<figure link="/images/docs/bugzie-ebuild-request.png" caption="Demande de test
d'ebuild"/>

<p>
Plusieurs termes de vocabulaire plutôt confus sont utilisés ici. Tout d'abord,
voyons ce qu'est un «&nbsp;overlay&nbsp;» (NdT : ici, «&nbsp;surcouche&nbsp;»).
Une surcouche est un répertoire spécial, comme <path>/usr/portage</path>, à la
différence près que quand vous faites un <c>emerge sync</c>, les fichiers
contenus à l'intérieur de celui-ci ne sont pas effacés. Heureusement, un
répertoire spécial <path>/usr/local/portage</path> est créé dans ce but. Nous
allons donc indiquer notre surcouche de Portage dans le fichier
<path>/etc/make.conf</path>. Pour cela, ouvrez le fichier avec votre éditeur
favori et ajoutez ceci vers la fin.
</p>

<pre caption="Renseignement de la variable PORTDIR_OVERLAY">
PORTDIR_OVERLAY="/usr/local/portage"
</pre>

<p>
Maintenant nous pouvons créer les répertoires appropriés pour mettre les
fichiers de notre ebuild à tester. Dans le cas présent, nous sommes supposés
les mettre dans le répertoire sys-apps/foobar2. Vous remarquerez que le second
commentaire recommande un répertoire <path>files</path> pour le correctif. Le
répertoire <path>files</path> contient les fichiers requis qui ne sont pas
inclus dans l'archive standard des sources (correctifs, scripts init.d...). Il
s'agit d'un sous-répertoire dans le répertoire du paquet, qui est appelé
«&nbsp;files&nbsp;». Nous allons donc créer ces répertoires.
</p>

<pre caption="Création des répertoires de la catégorie et du paquet">
# <i>mkdir -p /usr/local/portage/sys-apps/foobar2/files</i>
</pre>

<note>
L'option -p dans la commande mkdir permet de créer également les répertoires
parents du répertoire que vous désirez s'ils n'existent pas (sys-apps et
foobar2 dans ce cas).
</note>

<p>
Ok à présent, nous allons pouvoir récupérer les fichiers. D'abord,
téléchargez l'ebuild dans <path>/usr/local/portage/sys-apps/foobar2</path>, et
ajoutez alors le correctif (NdT&nbsp;: «&nbsp;patch&nbsp;») dans
<path>/usr/local/portage/sys-apps/foobar2/files</path>. Maintenant que vous
avons les fichiers, nous pouvons commencer à tester l'ebuild.
</p>

</body>
</section>
<section>
<title>Test de l'ebuild</title>
<body>

<p>
Le processus pour créer un ebuild qui peut être utilisé par emerge est assez
simple. Vous devez créer un fichier Manifest pour l'ebuild, grâce à la commande
<c>ebuild</c>. Exécutez cette commande comme ceci&nbsp;:
</p>

<pre caption="Création des fichiers Manifest">
# <i>ebuild foobar2-1.0.ebuild manifest</i>
&gt;&gt;&gt; Creating Manifest for /usr/local/portage/sys-apps/foobar2
</pre>

<p>
À présent, essayons de voir si cela marche comme prévu.
</p>

<pre caption="Test avec emerge -pv">
# <i>emerge -pv foobar2</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] sys-apps/foobar2-1.0  0 kB [1]

Total size of downloads: 0 kB
Portage overlays:
 [1] /usr/local/portage
</pre>

<p>
Cela semble avoir fonctionné&nbsp;! Vous pourrez remarquer le [1] à côté de la
ligne [ebuild]. Cela pointe vers <path>/usr/local/portage</path>, qui est la
surcouche que vous avons créée auparavant. Maintenant allons-y et installons le
paquet.
</p>

<pre caption="Résultat de la commande emerge">
# <i>emerge foobar2</i>
 Calculating dependencies ...done!
<comment>(Informations de compilation coupées)</comment>
>>> Unpacking foobar2-1.0.tar.bz2 to /var/tmp/portage/foobar2-1.0/work
 * Applying foobar2-1.0-Makefile.patch ...                                    [ ok ]
<comment>(Informations de compilation coupées)</comment>
>>> Merging sys-apps/foobar2-1.0 to /
>>> chris +sandbox(preinst)
--- /usr/
--- /usr/bin/
>>> /usr/bin/foobar2
</pre>

<p>
Dans la première section nous voyons que la commande emerge a commencé comme il
fallait. La seconde section montre que notre correctif a été appliqué avec
succès grâce au message de statut [ ok ] sur la droite. La dernière section
nous informe que la compilation du programme est réussie. Le correctif
fonctionne&nbsp;! Nous pouvons donc prévenir les développeurs que leur correctif
fonctionne correctement, et qu'ils peuvent l'envoyer dans l'arbre Portage.
</p>

</body>
</section>
<section>
<title>Conclusion</title>
<body>

<p>
Ceci conclut la documentation sur le fonctionnement du Bugzilla. J'espère que
vous l'aurez trouvée utile. Si vous avez des questions, des commentaires ou des
idées à propos de ce document, veuillez me les envoyer à
<mail>chriswhite@gentoo.org</mail>. Remerciements particuliers à moreon pour ses
notes au sujet des options -g et des erreurs de compilations, aux personnes de
#gentoo-bugs pour leur aide sur les querelles de bogues, à Griffon26 pour ses
notes sur les indispensables mainteneurs, à robbat2 pour les suggestions d'ordre
général et à fox2mike pour la correction de ce document et l'ajout des choses
nécessaires.
</p>

</body>
</section>
</chapter>
</guide>
