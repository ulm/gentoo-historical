<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/fr/Attic/2.6-koutput.xml,v 1.1 2004/04/30 10:49:25 neysx Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/fr/2.6-koutput.xml" lang="fr">

<title>Les fichiers de sortie des noyaux 2.6</title>

<author title="Développeur">
  <mail link="latexer@gentoo.org">Peter Johanson</mail>
</author>
<author title="Correcteur">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Traducteur">
  <mail link="olivier.fisette@sympatico.ca">Olivier Fisette</mail>
</author>

<abstract>
Ce guide est destiné aux développeurs et couvre en détails les récents
changements relatifs aux fichiers de sortie des noyaux dans Gentoo.
</abstract>

<license/>

<version>1.2</version>
<date>26 mars 2004</date>

<chapter>
<title>Préface</title>
<section>
<title>Le nouveau système</title>
<body>

<p>
Parmi la myriade d'améliorations apportées au noyau Linux dans la série 2.6,
une nouvelle infrastructure nommée «&nbsp;kbuild&nbsp;» a été développée afin
de fournir un système de compilation hautement configurable et versatile. La
portée de ce changement ne sera pas étudiée dans le présent document&nbsp;;
nous nous intéresserons plutôt à la nouvelle méthode recommandée pour la
compilation de modules externes avec un arbre des sources d'un noyau 2.6.
Voici une traduction libre d'un extrait de
<path>Documentation/kbuild/modules.txt</path>&nbsp;:
</p>

<pre caption="Documentation/kbuild/modules.txt">
Compiler des modules hors du noyau officiel
-------------------------------------------
Des modules sont fréquemment développés hors du noyau officiel. Afin d'être à
jour par rapport aux changements apportés au système de compilation, la manière
la plus transposable d'un système à un autre pour compiler un module hors du
noyau est d'utiliser la commande suivante&nbsp;:

make -C chemin/vers/noyau/src SUBDIRS=$PWD modules
</pre>

<p>
En redéfinissant la variable SUBDIRS, l'architecture kbuild la plus récente
permet de compiler aisément des modules externes. En soit, il s'agit d'une
amélioration <e>énorme</e>, mais les choses deviennent problématiques lorsque
l'on examine détails du procédé.
</p>

</body>
</section>
<section>
<title>Le problème</title>
<body>

<p>
Ayant configuré et compilé un noyau de la série 2.6 dont les sources résident
dans <path>/usr/src/linux</path>, il n'est pas déraisonnable de supposer que je
veuille ensuite compiler quelques modules externes avec l'arbre de ce noyau.
De plus, on peut raisonnablement s'attendre à ce que cela puisse être fait par
un utilisateur non-privilégié. Pourtant, ceux qui ont essayé savent que ce
<e>n'est pas</e> le cas. Une telle tentative se solde par un échec car
<c>make</c> tente de mettre à jour des fichiers dans
<path>/usr/src/linux</path> alors que les utilisateurs non-privilégiés n'ont
pas accès à cet emplacement en mode écriture.
</p>

<p>
Les modules compilés par le système Portage ont exactement le même
problème&nbsp;: lorsqu'une mise à jour est lancée, elle échoue à cause de
violations de l'environnement bac à sable. Le système kbuild a complexifié la
compilation de modules de telle manière qu'il est difficile d'utiliser le
principe sécuritaire des privilèges minima. 
</p>

<p>
Une recherche sur le système Bugzilla de Gentoo montre que beaucoup de bogues
causés par ce problème ont été rapportés. Aussi, beaucoup d'articles présentant
la désactivation du bac à sable comme seule solution ont été postés dans les
forums. Considérant l'état des choses à ce moment, il semblait en effet
inévitable d'avoir à écrire ou à mettre à jour des fichiers dans
<path>/usr/src/linux</path> lors de la compilation de modules des noyaux 2.6.
</p>

</body>
</section>
<section>
<title>Lutter contre le système</title>
<body>

<p>
Plusieurs façons de «&nbsp;hacker&nbsp;» le système kbuild afin de le
contourner ont été proposées, dont une suggérant de lier symboliquement les
éléments de <path>/usr/src/linux</path> dans un répertoire temporaire.
Ultimement, toutes les solutions menaient à des problèmes de sécurité, car
<path>/usr/src/linux</path> devait être touché d'une façon ou d'une autre.
Toutefois, priver les utilisateurs d'un chemin permettant une mise à jour
relativement facile n'est pas une option acceptable. C'est pourquoi le nouveau
kmod.eclass peut conférer à Portage l'accès en mode écriture à
<path>/usr/src/linux</path> pour les noyaux 2.6 plus anciens. 
</p>

<p>
Comme il s'agit d'un risque de sécurité majeur, les utilisateurs sont forcés
d'accepter cette option lors de sa première utilisation, par le biais d'un
nouvel outil&nbsp;: <b>config-kernel</b>. Les utilisateurs peuvent exécuter
config-kernel une fois pour accepter l'option, puis ils ne recevront qu'un
avertissement chaque fois que Portage compilera un module du noyau en utilisant
cette fonctionnalité.
</p>

<pre caption="Exécuter config-kernel">
# <i>config-kernel --allow-writable yes</i>
</pre>

</body>
</section>
<section>
<title>Accepter le changement</title>
<body>

<p>
Une solution plus appropriée a vu le jour lorsqu'il est devenu évident que
lutter contre les nouvelles fonctionnalités de kbuild ne causerait que des
problèmes de plus en plus nombreux dans le futur. En fait, la solution réside
dans la nouvelle capacité de kbuild d'envoyer tous ses fichiers de sortie dans
un répertoire séparé. Garder l'arbre des sources complètement propre et 
permettre aux modules externes de compiler avec des sources propres tout en
envoyant leurs fichiers de sortie dans un répertoire temporaire est la clé.
</p>

<p>
Les détails des interactions de tous ces éléments sont plutôt complexes. La
section suivante essaie de faciliter l'assimilation de ces concepts en les
décomposant en morceaux plus simples.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Les fichiers de sortie du noyau</title>
<section>
<title>Les variables KBUILD_OUTPUT et O</title>
<body>

<p>
kbuild fournit deux variables qui indiquent où le noyau doit placer ses
fichiers de sortie.
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Utilisation</th>
</tr>
<tr>
  <ti>KBUILD_OUTPUT</ti>
  <ti>
    Cette variable peut être définie dans le <path>Makefile</path> de plus haut
    niveau du noyau si vous voulez spécifier un répertoire de sortie par défaut
    différent de l'arbre des sources lui-même.
  </ti>
</tr>
<tr>
  <ti>O</ti>
  <ti>
    Cette variable devrait être utilisée sur la ligne de commande pour écraser
    tout autre paramètre et indiquer où les fichiers de sortie produits par la
    commande actuelle devraient être placés.
  </ti>
</tr>
</table>

<p>
La combinaison de ces deux variables est la clé pour une utilisation adéquate
de kbuild et Portage pour installer des modules du noyau.
</p>

</body>
</section>
<section>
<title>Changements relatifs à l'installation des noyaux</title>
<body>

<p>
Pour utiliser les fonctionnalités de redirection de la sortie du noyau, le
nouveau <path>kernel-2.eclass</path>, écrit par <mail
link="johnm@gentoo.org">John Mylchreest</mail> a été corrigé pour ajouter un
chemin par défaut <c>KBUILD_OUTPUT</c> dans le makefile de plus haut niveau du
noyau (<path>/usr/src/linux/Makefile</path>). Par défaut, ce chemin a la valeur
<path>/var/tmp/kernel-output/${KV}</path> puisque <path>/var/tmp</path> est un
emplacement approprié pour les fichiers temporaires qui doivent être préservés
lors des redémarrages. 
</p>

<p>
Une fois que cette variable est paramétrée, toutes les commandes make exécutées
dans l'arbre des sources du noyau envoient leurs fichiers de sortie dans ce
nouveau répertoire. Rien de plus n'est nécessaire de la part de l'utilisateur
et le changement est essentiellement (voyez la section suivante pour les
exceptions) transparent. Une fois un noyau installé, l'utilisateur n'a qu'à
faire&nbsp;:
</p>

<pre caption="Configurer le noyau">
# <i>make menuconfig</i>
</pre>

<p>
et ils pourront configurer leur noyau puis le compiler.
</p>

</body>
</section>
<section>
<title>Changements importants concernant les emplacements des fichiers</title>
<body>

<p>
Comme tous les fichiers générés sont maintenant placés dans un répertoire
séparé, quelques fichiers clés aboutiront dans un endroit inattendu pour
l'usager. Plus particulièrement, les <path>.config</path> et
<path>bzImage</path> de l'utilisateur ne seront plus dans
<path>/usr/src/linux</path> comme ils l'étaient auparavant. <mail
link="latexer@gentoo.org">Peter Johanson</mail> a écrit un nouveau guide du
noyau 2.6 disponible <uri link="2.6-koutput-user.xml">ici</uri> et destiné aux
utilisateurs. Il souligne les changements apportés à kbuild et, en particulier,
les nouveaux emplacements de ces fichiers.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Ebuilds pour les modules externes</title>
<section>
<title>Approche générale</title>
<body>

<p>
Maintenant que les noyaux génèrent leurs fichiers dans un emplacement
différent, écrire des ebuilds adhérant à ce nouveau système est l'étape
suivante. Il convient de mettre à jour les ebuilds pour qu'ils vérifient la
présence de certains fichiers et en-têtes dans l'emplacement approprié et pour
qu'ils utilisent la magie <path>Makefile</path> appropriée.
</p>

<p>
L'idée générale est de corriger les <path>Makefiles</path> des paquets pour
qu'ils utilisent, lors de la compilation avec des noyaux 2.6, la variable O
afin de générer leurs fichiers dans un répertoire temporaire à l'intérieur de
l'environnement bac à sable. Il ne reste qu'à ajouter quelques pièces pour
faire fonctionner le tout et obtenir un nouveau paquet pour un module externe
qui s'intégrera avec succès.
</p>

<note>
L'obtention d'un module utilisable et fonctionnel après la compilation et
l'installation n'est <e>pas</e> abordée dans ce document. Il s'agit d'un
problème totalement différent que les auteurs du module devraient gérer en
amont.
</note>

<p>
Des changements ont été apportés à <path>kmod.eclass</path> pour inclure
quelques variables et outils que les auteurs d'ebuilds peuvent utiliser pour
implémenter plus aisément les changements requis dans les ebuilds.
</p>

</body>
</section>
<section>
<title>Critères à remplir pour les Makefiles</title>
<body>

<p>
L'utilisation de koutput oblige les <path>Makefile</path> des paquets de
modules du noyau à remplir certains critères. Plus particulièrement, ils
devront utiliser la variable kbuild <c>O</c> afin de générer leurs fichiers
dans un sous-répertoire donné de <c>WORKDIR</c>. Souvent, cela sera quelque
chose de semblable à <path>${S}/tmp</path>. Lorsque ce système est utilisé, le
répertoire de sortie doit compter le <path>.config</path> du noyau parmi ses
fichiers. La copie de ce fichier peut être faite à partir du makefile ou de
l'ebuild, mais l'intégrer au makefile de façon appropriée pourrait mener à une
correction en amont qui déchargerait les développeurs Gentoo de ce travail.
</p>

</body>
</section>
<section>
<title>Fonctionnalités de kmod.eclass</title>
<body>

<p>
Tous les ebuilds de modules du noyau devraient désormais utiliser
<path>kmod.eclass</path>. Voici un aperçu de son utilisation. La fonction
kmod_src_unpack() s'occupe du désarchivage, ainsi que de la définition de
plusieurs variables extrêmement utiles qui pourront être utilisées par la
suite. Deux variables peuvent être paramétrées par l'ebuild afin de contrôler
les fonctionnalités de kmod_src-unpack().
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Utilisation</th>
</tr>
<tr>
  <ti>KMOD_SOURCES</ti>
  <ti>
    Si cette variable est définie, ces fichiers (habituellement des archives
    tar) seront désarchivés dans WORKDIR. Autrement, ${A} sera désarchivé.
    Alternativement, la variable peut être définie à «&nbsp;none&nbsp;» si un
    ebuild doit prendre en charge lui-même le désarchivage et autres processus.
  </ti>
</tr>
<tr>
  <ti>KMOD_KOUTPUT_PATCH</ti>
  <ti>
    Si la variable KV_OUTPUT a une valeur différente de
    <path>/usr/src/linux</path> et qu'elle est définie, le correctif spécifié
    sera appliqué en utilisant epatch dans <path>${S}</path>. Bien que cela
    puisse être fait manuellement, cette variable peut être utile pour ne pas
    devoir définir src_unpack() dans un ebuild.
  </ti>
</tr>
</table>

<p>
La fonction kmod_src_unpack() s'applique à déterminer comment le pilote à
compiler doit être géré. Elle supporte d'ailleurs très bien les deux méthodes
de compilation pour versions 2.6. Si la nouvelle méthode employant koutput est
détectée, la fonction appliquera le correctif spécifié par KMOD_KOUTPUT_PATCH
si celui-ci existe. Après que kmod_src_unpack() ait été appelée, une pléthore
de variables deviennent disponibles et peuvent être utilisées par après dans
l'ebuild.
</p>

<table>
<tr>
  <th>Variable</th>
  <th>Signification</th>
</tr>
<tr>
  <ti>KV_OUTPUT</ti>
  <ti>
    Le chemin d'accès absolu utilisé par le noyau pour ses fichiers de sortie.
    Pour les noyaux 2.4, cela sera toujours <path>/usr/src/linux</path>. Pour
    les 2.6, cela devrait être un répertoire différent (sinon la compilation du
    module échouera).
  </ti>
</tr>
<tr>
  <ti>KV_OJB</ti>
  <ti>
    L'extension pour les modules du noyau pour cette version du noyau. Cela
    sera soit «&nbsp;ko&nbsp;», soit «&nbsp;o&nbsp;» selon la version du noyau.
  </ti>
</tr>
<tr>
  <ti>KV_VERSION_FULL</ti>
  <ti>La version complète du noyau.</ti>
</tr>
<tr>
  <ti>KV_MAJOR</ti>
  <ti>Le numéro de version majeur du noyau.</ti>
</tr>
<tr>
  <ti>KV_MINOR</ti>
  <ti>Le numéro de version mineur du noyau.</ti>
</tr>
<tr>
  <ti>KV_PATCH</ti>
  <ti>Le numéro de correction du noyau.</ti>
</tr>
<tr>
  <ti>KV_TYPE</ti>
  <ti>
    Le type du noyau (par exemple&nbsp;: "-gentoo-r1" pour "2.4.23-gentoo-r1")
  </ti>
</tr>
</table>

<p>
La valeur de KV_OUTPUT est le résultat du processus qui détermine quelle
configuration de noyau a été détectée et quelle méthode de compilation sera
utilisée. Voici un tableau montrant les trois différentes configurations du
noyau possibles et la valeur assignée à la variable après l'appel de la
fonction kmod_src_unpack().
</p>

<table>
<tr>
  <ti></ti>
  <th>KV_OUTPUT</th>
  <th>Approche pour compiler les modules</th>
</tr>
<tr>
  <th>Noyau 2.4</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Flexible. Certains makefiles utiliseront des instructions manuelles, d'autres
  emploieront <b>make -C $(KV_BUILD)</b>. Les deux techniques sont faciles à
  utiliser avec les noyaux 2.4.
  </ti>
</tr>
<tr>
  <th>Noyau 2.6, sortie normale</th>
  <ti>/usr/src/linux</ti>
  <ti>
  Il s'agit de la méthode traditionnelle. kmod.eclass gère cette situation en
  utilisant config-kernel pour vérifier si la permission d'écrire dans
  <path>/usr/src/linux</path> a été accordée, puis procède à l'écriture si
  demandé. Cette méthode sera employée tant que la nouvelle méthode de
  compilation ne sera pas adoptée par tous.
  </ti>
</tr>
<tr>
  <th>Noyau 2.6, sortie alternative</th>
  <ti>/un/autre/chemin</ti>
  <ti>
  La compilation avec cette configuration nécessite l'utilisation de la méthode
  «&nbsp;koutput&nbsp;». Habituellement, des corrections sont requises pour les
  makefiles, et les variables «&nbsp;sources&nbsp;» et «&nbsp;output&nbsp;»
  seront alors définies. Les modules sont alors compilés en utilisant les
  makefiles du noyau, mais leurs fichiers de sortie sont placés dans un
  sous-répertoire local.
  </ti>
</tr>
</table>

<p>
Une fonction d'aide est fournie par kmod.eclass pour déterminer facilement
quelle configuration est utilisée. <b>is_koutput()</b> permet à ebuild de
déterminer comment procéder à la compilation. Un ebuild typique pourrait
utiliser le test suivant&nbsp;:
</p>

<pre>
	if is_koutput
	then
		# Utiliser sed pour corriger certaines choses pour l'utilisation de koutput.
		sed -i "s:foo:bar:" Makefile
	fi
</pre>

<p>
La plupart des ebuilds nécessiteront un correctif pour les makefiles pour
activer la sortie vers un répertoire différent, puis l'utilisation de sed si
is_koutput() retourne la valeur «&nbsp;true&nbsp;». L'ebuild donné comme
exemple ci-dessous montre comment cela est géré. Pour les ebuilds nécessitant
plus de travail (nvidia-kernel est l'un d'eux), il y a quelques fonctions qui
peuvent être appelées pour exercer un contrôle plus fin.
</p>

<table>
<tr>
  <th>Fonction</th>
  <th>Utilisation</th>
</tr>
<tr>
  <ti>kmod_make_linux_writable()</ti>
  <ti>
    Cette fonction sert à permettre l'écriture dans
    <path>/usr/src/linux</path>. Elle devrait être appelée préférentiellement à
    l'utilisation directe de addwrite, car elle réalisera les vérifications
    nécessaires afin d'être sûr que cela est nécessaire et que l'utilisateur
    l'a explicitement permis avec <b>config-kernel</b>.
  </ti>
</tr>
<tr>
  <ti>kmod_do_buildpatches()</ti>
  <ti>
    Cette fonction peut être appelée pour appliquer le correctif de
    KMOD_KOUTPUT_PATCH lorsque c'est nécessaire. Habituellement, elle ne sera
    utilisée que si un ebuild est forcé de désarchiver les sources du module
    manuellement.
  </ti>
</tr>
<tr>
  <ti>is_kernel()</ti>
  <ti>
    Cette fonction requiert deux arguments, un numéro de version majeur du
    noyau, et un numéro de version mineur. C'est la façon recommandée de
    vérifier si l'on utilise une certaine version du noyau.
  </ti>
</tr>
</table>

<p>
En plus de ces fonctions spéciales, kmod.eclass exporte src_unpack, src_compile,
etc., qui peuvent être référencées par kmod_src_unpack, kmod_src_compile, etc.
</p>

</body>
</section>
<section>
<title>Exemple de modification d'un ebuild et d'un Makefile</title>
<body>

<p>
Ce qui suit est un exemple pratique détaillant comment le paquet hostap-driver
a été modifié pour créer un ebuild tout à fait fonctionnel et compatible avec
les noyaux des séries 2.4 et 2.6. Il utilise un correctif (assez général pour
être utilisé en amont et permettre la simplification des futurs ebuilds) pour
le <path>Makefile</path> de plus haut niveau, ainsi que quelques changements de
l'ebuild pour prendre en compte les différences dans les emplacements de
certains fichiers.
</p>

<p>
Vous trouverez ci-dessous des extraits du <path>Makefile</path> original, du
<path>Makefile</path> modifié et des sections modifiées qui permettent une
compilation correcte. D'abord, une ligne doit être corrigée car elle suppose que
<path>.config</path> sera dans le même répertoire que les sources du noyau.
</p>

<note>
La variable KERNEL_OUTPUT_PATH est ajoutée plus tôt dans le ebuild pour
complémenter la variable KERNEL_PATH dans l'original.
</note>

<pre caption="Ligne originale utilisant include">
include $(KERNEL_PATH)/.config
</pre>

<p>
La version corrigée ci-dessous permet à la variable KERNEL_OUTPUT_PATH d'être
définie si elle ne l'est pas déjà (pour la compatibilité descendante avec 2.4)
et cherche le fichier <path>.config</path> dans cet emplacement.
</p>

<pre caption="Ligne corrigée utilisant include">
ifndef KERNEL_OUTPUT_PATH
KERNEL_OUTPUT_PATH=$(KERNEL_PATH)
endif

include $(KERNEL_OUTPUT_PATH)/.config
</pre>

<p>
Comme nous avons maintenant la variable KERNEL_OUTPUT_PATH à notre disposition,
corriger la déclaration de variable suivante impliquant le
<path>version.h</path> généré est simple. L'original&nbsp;:
</p>

<pre caption="VERFILE original">
VERFILE := $(KERNEL_PATH)/include/linux/version.h
</pre>

<p>
Et la version éditée et corrigée&nbsp;:
</p>

<pre caption="VERFILE édité">
VERFILE := $(KERNEL_OUTPUT_PATH)/include/linux/version.h
</pre>

<p>
Finalement, notre correctif remplace la ligne qui invoque le système kbuild 2.6
afin d'incorporer l'utilisation de la variable O, paramétrant le système pour
produire les fichiers dans le sous-répertoire <path>tmp/</path> du répertoire
courant.
</p>

<warn>
kbuild s'attend à trouver un fichier <path>.config</path> valide dans le
répertoire de sortie spécifié par <c>O=foo</c>. L'ebuild ou le makefile
devrait être édité pour copier <path>.config</path> dans ${KV_OUTPUT}
(variable paramétrée par kmod.eclass).
</warn>

<p>
Voici l'original&nbsp;:
</p>

<pre caption="Répertoire de sortie original">
$(MAKE) -C $(KERNEL_PATH) SUBDIRS=$(PWD)/driver/modules \
	MODVERDIR=$(PWD)/driver/modules modules
</pre>

<p>
Et voici la version modifiée&nbsp;:
</p>

<pre caption="Répertoire de sortie édité">
mkdir -p $(PWD)/tmp
-cp $(KERNEL_OUTPUT_PATH)/.config $(PWD)/tmp
$(MAKE) -C $(KERNEL_PATH) O=$(PWD)/tmp \
	SUBDIRS=$(PWD)/driver/modules \
	MODVERDIR=$(PWD)/driver/modules  modules
</pre>

<p>
Les changements apportés à l'ebuild sont relativement simples. L'eclass kmod
rend d'ailleurs les choses très faciles. Voici quelques extraits de src_unpack
et quelques variables paramétrées dans le ebuild&nbsp;:
</p>

<pre caption="La fonction src_unpack()">
KMOD_SOURCES="${P}.tar.gz"
KMOD_KOUTPUT_PATCH="${PN}-koutput.diff.gz"

src_unpack() {
    # Désarchive et paramètre quelques variables.
    kmod_src_unpack
	
    ## Désarchive les sources pcmcia-cs si nécessaire.
    pcmcia_src_unpack

    epatch "${FILESDIR}/${P}.firmware.diff.bz2"
    
    # Si koutput est utilisé, employer sed pour ajouter le chemin approprié.
    if is_koutput
    then
        sed -i -e \
	    "s:^# KERNEL_OUTPUT_PATH=.*:KERNEL_OUTPUT_PATH=${KV_OUTPUT}:" \
	    ${S}/Makefile
    fi
}
</pre>

<p>
Remarquez l'utilisation des deux variables <c>KMOD_SOURCES</c> et
<c>KMOD_KOUTPUT_PATCH</c>. Ces dernières peuvent être définies selon les besoins
pour spécifier quelles sources doivent être désarchivées par
kmod_src_unpack() et quel fichier de correctif employer si koutput est utilisé.
<c>KMOD_KOUTPUT_PATCH</c> ne sera <b>pas</b> appliqué si le processus détecte
que le noyau 2.6 est paramétré pour utiliser <path>/usr/src/linux</path> comme
répertoire de sortie. Voici une version écourtée de la fonction
src_compile()&nbsp;:
</p>

<pre caption="Fonction src_compile()">
src_compile() {
    # Configurer les sources pcmcia-cs tel que nécessaire.
    pcmcia_configure

    einfo "Building hostap-driver for kernel version: ${KV}"
    case ${KV_MINOR} in
        [34])
            local mydrivers

            use pcmcia &amp;&amp; mydrivers="${mydrivers} pccard"
            use hostap-nopci || mydrivers="${mydrivers} pci"
            use hostap-noplx || mydrivers="${mydrivers} plx"

            einfo "Building the following drivers: ${mydrivers}"
            emake ${mydrivers} || die "make failed"
            ;;
        [56])
            unset ARCH
            emake all || die "make failed"
            ;;
        *)
            eerror "Unsupported kernel version: ${KV}"
	    die
	    ;;
    esac
}
</pre>

<warn>
Pour les noyaux 2.6, la variable <c>ARCH</c> doit ne pas être définie. Les
makefiles du nouveau noyau utilisent <c>ARCH</c> pour déterminer ce qui est à
compiler et utilisent une syntaxe différente pour i386, etc.
</warn>

<p>
La fonction src_install() de cet ebuild ne sera pas montrée ici, car elle ne
fait essentiellement qu'installer tous les modules dans
<path>/lib/modules/${KV}/</path>. Notez que les changements d'extension de
<path>.o</path> à <path>.ko</path> pour les noyaux 2.6 sont pris en charge.
kmod.eclass définit la variable <c>KV_OBJ</c> soit à <path>o</path>, soit à
<path>ko</path>, tel qu'approprié, afin de vous simplifier les choses.
</p>

</body>
</section>
</chapter>
</guide>
