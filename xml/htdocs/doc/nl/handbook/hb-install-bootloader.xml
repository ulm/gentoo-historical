<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/nl/handbook/Attic/hb-install-bootloader.xml,v 1.1 2004/01/15 07:03:12 blubber Exp $ -->

<sections>
<section>
<!--<title>Making your Choice</title>-->
<title>Een keuze maken</title>
<subsection>
<!--<title>Introduction</title>-->
<title>Introductie</title>
<body>

<p>
<!--
Now that your kernel is configured and compiled and the necessary system
configuration files are filled in correctly, it is time to install a
program that will fire up your kernel when you start the system. Such a
program is called a <e>bootloader</e>. But before you start, consider
your options...
-->
Nu je kernel is geconfigureerd en gecompiled en de benodigde systeem
configuratie bestanden correct zijn ingevuld, is het tijd om het programma te
installeren dat de kernel aanslingerd wanneer je je systeem start. Zo een
programma noemen we een <e>bootloader</e>. Maar voor we beginnen nemen we eerst
de opties door...
</p>

<p>
<!--
Several bootloaders exist for Linux. However, these bootloaders only
function on a small set of architectures. Therefore you must choose between the
bootloaders that support your architecture.
-->
Er bestaan verschillende bootloaders voor linux. Echter, deze bootloaders werken
op slechts een deel van de architecturen. Daarom moet je kiezen tussen de
bootloaders die jouw architectuur ondersteunen.
</p>

<p>
<!--
The next table lists the architectures and the supported bootloaders.
Pick a bootloader based on your architecture. For instance, if you have
a Pentium IV, then your architecture is <e>x86</e>. You have the choice
between GRUB (recommended) and LILO.
-->
De volgende tabel geeft een lijst van alle architecturen en ondersteunde
bootloaders. Kies een bootloader op basis van je architectuur. Bijvoorbeeld, als
je een Pentium IV bezit, dan is je architectuur <e>x86</e>. Je hebt de keuze
tussen GRUB (aangeraden) en LILO.
</p>

<table>
<tr>
  <th>Architectuur</th>
  <th>Aangeraden</th>
  <th>Alternatieven</th>
</tr>
<tr>
  <th>x86</th>
  <ti><uri link="#doc_chap2">GRUB</uri></ti>
  <ti><uri link="#doc_chap3">LILO</uri></ti>
</tr>
<tr>
  <th>alpha</th>
  <ti><uri link="#doc_chap4">aBoot</uri></ti>
  <ti><uri link="#doc_chap5">MILO</uri></ti>
</tr>
<tr>
  <th>sparc</th>
  <ti><uri link="#doc_chap6">SILO</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>ppc</th>
  <ti>
    <uri link="#doc_chap8">yaBoot</uri> (NewWorld), 
    <uri link="#doc_chap9">BootX</uri> (OldWorld)
  </ti>
  <ti></ti>
</tr>
<tr>
  <th>hppa</th>
  <ti><uri link="#doc_chap7">PALO</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>mips</th>
  <ti><uri link="#doc_chap10">MIPS PROM</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>amd64</th>
  <ti><uri link="#doc_chap2">GRUB</uri></ti>
  <ti></ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<!--<title>Optional: Framebuffer</title>-->
<title>Optioneel: Frambuffer</title>
<body>

<note>
<!--
This section only applies to x86, AMD64 and PPC users who have configured 
framebuffer support in their kernel. This includes <c>genkernel</c> users.
-->
Deze sectie is alleen toepasselijk op x86, AMD64 en PPC gebruikers die
framebuffer ondersteuning in hun kernel hebben gedaan. Hieronder vallen de
<c>genkernel</c> gebruikers.
</note>

<p>
<!--
<e>If</e> you have configured your kernel with framebuffer support, you
have to add a <c>vga</c>-statement to your bootloader configuration
file if you require framebuffer. The next table lists the available 
<c>vga</c>-values you can use. In the example configuration files we use 
<e>800x600 @ 16bpp</e>, thus <e>788</e>.
-->
<e>Als</e> je je kernel met framebuffer ondersteuning hebt geconfigureerd, kan
je een <c>vga</c>-statement aan je bootloader configuratie toevoegen, als je een
framebuffer wilt. De volgende tabel geeft een lijst weer van alle beschikbare
<c>vga</c>-waarden die je kunt gebruiken. In de voorbeeld configuratie bestanden
gebruiken met <e>800x600 @ 16bpp</e>, dus <e>788</e>.
</p>

<table>
<tr>
  <ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th>
</tr>
<tr>
  <th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti>
</tr>
<tr>
  <th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti>
</tr>
<tr>
  <th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti>
</tr>
</table>

<p>
<!--
Remember (or write down) your value; you will need it shortly hereafter.
-->
Onthoud het nummer (of schrijf het op); je hebt het zo direct nodig.
</p>

<p>
<!--
Now select the bootloader of your choice from the table above.
-->
Selecteer vervolgens een bootloader naar keuze uit de bovenstaande lijst.
</p>

</body>
</subsection>
</section>
<section>
<!--<title>Default: Using GRUB</title>-->
<title>Standaard: GRUB gebruiken</title>
<subsection>
<!--<title>Understanding GRUB's terminology</title>-->
<title>GRUB's terminalogie begrijpen</title>
<body>

<impo>
<!--GRUB can only be used with x86- and AMD64-based systems!-->
GRUB kan alleen gebruimt worden op x86- en AMD64-gebaseerde systemen!
</impo>

<p>
<!--
The most critical part of understanding GRUB is getting comfortable with
how GRUB refers to hard drives and partitions. Your Linux partition
<path>/dev/hda1</path> is called <path>(hd0,0)</path> under GRUB. Notice the 
parenthesis around the <path>hd0,0</path> - they are required.
-->
Het meest kritieke punt aan het begrijpen van GRUB is het wennen aan de manier
waarop GRUB refereert naar harde schijven en partities. Je Linux partitie
<path>/dev/hda1</path> heet in GRUB <path>(hd0,0)</path>. Let op de haakjes
rondom <path>hd0,0</path> - deze zijn verplicht.
</p>

<p>
<!--
Hard drives count from zero rather than "a" and partitions start at zero 
rather than one. Be aware too that with the hd devices, only hard drives are 
counted, not atapi-ide devices such as cdrom players and burners.  Also, the 
same construct is used with scsi drives. (Normally they get higher numbers 
than ide drives except when the bios is configured to boot from scsi devices.)]
-->
Harde schijven worden geteld vanaf nul in plaats van "a" en partities beginnen
bij nul in plaats van een. Wees je ervan bewust dat enkel de harde schijven
worden geteld, dus niet de atapi-ide apparaten zoals cd-rom spelers en
branders. Dezelfde constructie wordt ook gebruikt voor scsi schijven. (Deze
krijgen meestal een hoger nummer dan ide schijven, tenzij de bios is
geconfigureerd om op te starten van scsi apparaten.)
</p>

<p>
<!--
Assuming you have a hard drive on <path>/dev/hda</path>, a cdrom player on 
<path>/dev/hdb</path>, a burner on <path>/dev/hdc</path>, a second hard drive 
on <path>/dev/hdd</path> and no SCSI hard drive, <path>/dev/hdd7</path> gets 
translated to <path>(hd1,6)</path>. It might sound tricky and tricky it is 
indeed, but as we will see, GRUB offers a tab completion mechanism
that comes handy for those of you having a lot of hard drives and
partitions and who are a little lost in the GRUB numbering scheme.
-->
Aangemomen dat je een harde schijf hebt op <path>/dev/hda</path>, een cdrom
speler op <path>/dev/hdb</path>, een brander op <path>/dev/hdc</path>, een
tweede harde schijf op <path>/dev/hdd</path> en geen SCSI harde schijf,
<path>/dev/hdd7</path> vertaald dan naar <path>(hd1,6)</path>. Het lijkt
misschien lastig, en dat is het ook, maar zoals we straks zullen zien biedt GRUB
een tab completion mechanisme aan dat heel handig is voor mensen met veel harde
schijven en partities, en voor mensen die de weg kwijt raden in GRUBs numerings
schema.
</p>

<p>
<!--aving gotten the feel for that, it is time to install GRUB.-->
Nu we hieraan gewend zijn geraakt is het tijd om GRUB te installeren.
</p>

</body>
</subsection>
<subsection>
<title>GRUB Installeren</title>
<body>

<p>
<!--
To install GRUB, let's first emerge it. Users of the x86 architecture have to
install <c>grub</c>, AMD64 users will need to emerge <c>grub-static</c>:
-->
Om GRUB te installeren moeten we het eerst emergen. Gebruikres van de x86
architectuur dienen <c>grub</c> te installeren, AMD64 gebruikers diene
<c>grub-static</c> te installeren:
</p>

<pre caption = "GRUB Installeren">
<comment>(Voor de x86 architectuur:)</comment>
# <i>emerge --usepkg grub</i>

<comment>(Voor de AMD64 architectuur:)</comment>
# <i>emerge --usepkg grub-static</i>
# <i>cp -Rpv /usr/share/grub/i386-pc/* /boot/grub</i>
</pre>

<p>
<!--
To start configuring GRUB, you type in <c>grub</c>. You'll be presented
with the <path>grub&gt;</path> grub command-line prompt. Now, you need to type 
in the right commands to install the GRUB boot record onto your hard drive.
-->
Om te beginnen met de configuratie van GRUB type je <c>grub</c> in. Je krijgt de
<path>grub&gt;</path> grub commando prompt te zien. Je dient nu de juiste
commandos in te typen om GRUB te installeren op je harde schijf.
</p>

<pre caption = "De GRUB shell starten">
# <i>grub</i>
</pre>

<p>
<!--
In the example configuration we want to install GRUB so that it reads its 
information from the boot-partition <path>/dev/hda1</path>, and installs the 
GRUB boot record on the hard drive's MBR (master boot record) so that the first
thing we see when we turn on the computer is the GRUB prompt. Of course, if you
haven't followed the example configuration during the installation,
change the commands accordingly.
-->
In de voorbeeld configuratie willen we GRUB zo installeren dat het de benodigde
informatie van de boot partitie haalt <path>/dev/hda1</path>, en de GRUB boot
record in de MBR (master boot record) van de harde schijf installeert. Zodat het
eerste dat we zien na het inschakelen van de computer de GRUB prompt is.
Uiteraard, als je de voorbeeld configuratie niet gevolgt hebt, pas dan de
commandos aan je eigen situatie aan.
</p>

<p>
<!--
The tab completion mechanism of GRUB can be used from within GRUB.
For instance, if you type in "<c>root (</c>" followed by a TAB, you will
be presented with a list of devices (such as <path>hd0</path>). If you
type in "<c>root (hd0,</c>" followed by a TAB, you will receive a list
of available partitions to choose from (such as <path>hd0,0</path>).
-->
Het tab completion mechanisme van GRUB kan binnen GRUB gebruikt worden.
Bijvoorbeeld, als je "<c>root(</c>" intypt gevolgd door een TAB, dan krijg je
een lijst te zien van alle apparaten (zoals <path>hd0</path>). Als je typt
"<c>root (hd0,</c>" gevolgd door een TAB, dan krijg je een lijst te zien van
alle beschikbare partitions (zoals <path>hd0,0</path>).
</p>

<p>
<!--
By using the tab completion, setting up GRUB should be not that hard.
Now go on, configure GRUB, shall we? :-)
-->
Door tab completion te gebruiken wordt het installeren van GRUB een stuk
makkelijker. Mu, laten we GRUB eens gaan installeren :)
</p>

<pre caption = "GRUB installeren in de MBR">
grub&gt; <i>root (hd0,0)</i>          <comment>(Gebruik informatie op de boot
partitie)</comment>
grub&gt; <i>setup (hd0)</i>           <comment>(Installeer GRUB in de MBR)</comment>
grub&gt; <i>quit</i>                  <comment>(Verlaat de GRUB shell)</comment>
</pre>

<note>
<!--
If you want to install GRUB in a certain partition instead of the MBR,
you have to alter the <c>setup</c> command so it points to the right
partition. For instance, if you want GRUB installed in
<path>/dev/hda3</path>, then the command becomes <c>setup (hd0,2)</c>.
Few users however want to do this.
-->
Als je GRUB wilt installeren op een partitie in plaats van de MBR, dan dien je
het <c>setup</c> commando aan te passen, zodat het verwijst naar de juiste
partitie. Bijvoorbeeld, als je GRUB wilt installeren op <path>/dev/hda3</path>,
dan wordt het commando <c>setup (hd0, 2)</c>. Echter slechts een enkeling wilt
dit.
</note>

<p>
<!--
Although GRUB is now installed, we still need to write up a
configuration file for it, so that GRUB automatically boots your newly
created kernel. Create <path>/boot/grub/grub.conf</path> with
<c>nano</c> (or, if applicable, another editor):
-->
Hoewel GRUB geinstalleerd is, moeten we nog steeds een configuratie bestand
schrijven, zodat GRUB automatisch je nieuw geinstalleerde kernel gebruikt.
Creeer <path>/boot/grub/grub.conf</path> met <c>nano</c> (of een andere editor
naar keus):
</p>

<pre caption = "/boot/grub/grub.conf aanmaken">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
<!--
Now we are going to write up a <path>grub.conf</path>. Beneath you'll
find a <path>grub.conf</path> for the partitioning example we use in
this guide, with kernel image <path>kernel-2.4.22</path>.
-->
Nu gaan we <path>grub.conf</path> schrijven. Hieronder vind je een
<path>grub.conf</path> voor het voorbeeld dat wij gebruiken in deze handleiding,
met een kernel image <path>kernel-2.4.22</path>.
</p>

<pre caption = "grub.conf inhoud">
<comment># Welk optie eerst gestart moet worden, 0 is de eerste 1 de tweede enz..</comment>
default 0
<comment># Hoeveel seconden er gewacht moet worden alvorens de standaard gestart wordt.</comment>
timeout 30
<comment># Moeie, vette splash image om het scherm te sieren :)</comment>
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux
<comment># Partitie waar het kernel image (of os) gevonden kan worden</comment>
root (hd0,0)
kernel (hd0,0)/kernel-2.4.22 root=/dev/hda3
<comment># Alleen als je genkernel gebruikt hebt. Verwijder deze regel anders</comment>
initrd (hd0,0)/initrd-2.4.22-gentoo-r2

<comment># De volgende drie regels zijn alleen van toepassing als je dual-boot met een Windows OS.</comment>
<comment># In dit geval staat Windows op /dev/hda6.</comment>
title=Windows XP
root (hd0,5)
chainloader +1
</pre>

<note>
<!--
If you use a different partitioning scheme and/or kernel image, adjust 
accordingly. However, make sure that anything that follows a GRUB-device 
(such as <path>(hd0,0)</path>) is relative to the mountpoint, not the root. In 
other words, <path>(hd0,0)/grub/splash.xpm.gz</path> is in reality 
<path>/boot/grub/splash.xpm.gz</path> since <path>(hd0,0)</path> is 
<path>/boot</path>.
-->
Als je een andere partities gebruikt en/of een andere kernel image, pas de
instellingen dan aan. Echter zorg ervoor dat alles dat na een GRUB-apparaat komt
(zoals <path>(hd0,0)</path>) relatief is aan het mount punt, en niet aan de
root. Met andere woorden <path>(hd0,0)/grub/splash.xmp.gz</path> is in de
realiteit <path>/boot/grub/splash.xpm.gz</path> omdat <path>(hd0,0)</path>
<path>/boot</path> is.
</note>

<p>
<!--
If you need to pass any additional options to the kernel, simply add
them to the end of the kernel command. We're already passing one option
(<c>root=/dev/hda3</c>), but you can pass others as well. As an example
we use the <c>vga</c> statement for framebuffer we discussed previously:
-->
Als je meer options aan de kernel mee wilt geven, voeg ze dan toe achter het
kernel commando. We geven al een optie mee (<c>root=/dev/hda3</c>), maar je kan
er ook nog andere opties aan toe voegen. Bijvoorbeeld <c>vga</c> om de
framebuffer aan te zetten, zoals eerder besproken:
</p>

<pre caption = "Het vga-statement toevoegen als kernel argument">
title=Gentoo Linux
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.22 root=/dev/hda3 vga=788
</pre>

<p>
<!--
<c>genkernel</c> users should know that their kernels use the same boot options
as is used for the LiveCD. For instance, if you have SCSI devices, you should
add <c>doscsi</c> as kernel option.
-->
<c>genkernel</c> gebruikers moeten weten dat hun kernel dezelfde opstart opties
gebruikt als de LiveCD. Bijvoorbeeld, als je een SCSI apparaat hebt, dan dien je
<c>doscsi</c> als kernel optie toe te voegen.
</p>

<p>
<!--
Now save the <path>grub.conf</path> file and exit. As of now, GRUB is
fully configured, and you can continue with <uri
link="?part=1&amp;chap=10">Installing Necessary System Tools</uri>.
-->
Sla nu <path>grub.conf</path> op, en verlaat de editor. Vanaf nu is GRUB
succesvol geconfigureerd, en kan je doorgaan met <uri
link="?part=1&amp;chap=10">Benodigde Systeem tools installeren</uri>.
</p>

</body>
</subsection>
</section>
<section>
<!--<title>Alternative: Using LILO</title>-->
<title>Alternatief: LILO gebruiken</title>
<subsection>
<!--<title>Installing LILO</title>-->
<title>LILO Installeren</title>
<body>

<impo>
<!--ILO can only be used with x86-based systems!-->
LILO kan enkel gebruikt worden met x86 systemen!
</impo>

<p>
<!--
LILO, the LInuxLOader, is the tried and true workhorse of Linux
bootloaders. However, it lacks some features that GRUB has (which is
also the reason why GRUB is currently gaining popularity). The reason
why LILO is still used is that, on some systems, GRUB doesn't work and
LILO does. Of course, it is also used because some people know LILO and
want to stick with it. Either way, Gentoo supports both, and apparently
you have chosen to use LILO.
-->
LILO, de LInuxLOader, is de bewezen oplossing wat betreft bootloader. Echter,
het mist een aantal mogelijkheden die GRUB wel heeft (wat ook de reden is dat
GRUB momenteel meer gebruikt wordt). Dat LILO nog gebruikt wordt komt doordat
GRUB op sommige system niet werkt, en LILO wel. Uiteraard wordt het ook gebruikt
omdat sommige mensen LILO kennen, en het gewoon willen blijven gebruiken. Hoe je
het ook wentelt of keert, Gentoo ondersteund beide, en klaarblijkelijk hebt je
voor LILO gekozen.
</p>

<p>
<!--
Installing LILO is a breeze; just use <c>emerge</c>.
-->
LILO installeren is een eitje; gebruik gewoon <c>emerge</c>.
</p>

<pre caption = "LILO Installeren">
# <i>emerge --usepkg lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>LILO Configureren</title>
<body>

<p>
<!--
To configure LILO, you must create <path>/etc/lilo.conf</path>. Fire up
your favorite editor (in this handbook we use <c>nano</c> for
consistency) and create the file.
-->
Om LILO te configureren dien je eerst <path>/etc/lilo.conf</path> aan te maken.
Start je favoriete editor (in dit handboek gebruiken we <c>nano</c> voor
consistentie) en maak het bestand aan.
</p>

<pre caption = "/etc/lilo.conf aanmaken">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
<!--
Some sections ago we have asked you to remember the kernel-image name
you have created. In the next example <path>lilo.conf</path> we assume
the imagename is <path>kernel-2.4.22</path>. We also use the
example partitioning scheme in this example.
-->
Enige secties terug vroegen we je om de naam te onthouden van het kernel-image
dat je gemaakt hebt. In het volgende <path>lilo.conf</path> voorbeeld nemen we
aan dat het image <path>kernel-2.4.22</path> heet. We maken ook gebruik van de
voorbeeld partitie indeling.
</p>

<pre caption = "Example /etc/lilo.conf">
boot=/dev/hda             <comment># Installeer LILO in de MBR</comment>
prompt                    <comment># Geef de gebruiker een kans om een OS te kiezen</comment>
timeout=50                <comment># Wacht vijf seconden alvorens het standaard OS te starten</comment>
default=gentoo            <comment># Wanneer de timeout voorbij is starten we Gentoo</comment>
<comment># Alleen van toepassing als je een framebuffer gebruikt</comment>
vga=788                   <comment># Framebuffer instelling. Aanpassen aan je eigen wil</comment>

image=/boot/kernel-2.4.22
  label=gentoo            <comment># Naam van dit OS</comment>
  read-only               <comment># Starten met read-only root partitie. Niet aanpassen!</comment>
  root=/dev/hda3          <comment># Locatie van het root bestandssysteem</comment>
  <comment># Alleen voor genkernel gebruikers, anders deze regel verwijderen:</comment>
  initrd=/boot/initrd-2.4.22-gentoo-r2

<comment># De volgende twee regels zijn alleen van toepassing als je dual-boot met een Windows OS.</comment>
<comment># In dit geval staat Windows op /dev/hda6.</comment>
other=/dev/hda6
  label=windows
</pre>

<note>
</note>

<p>
<!--
If you need to pass any additional options to the kernel, add an
<c>append</c> statement to the section. As an example, we add the
<c>acpi=off</c> statement to disable ACPI support:
-->
Als je meer opties aan de kernel wilt doorgeven, voeg dat een <c>append</c>
regel toe voor het betreffende OS. Bijvoorbeeld, we voegen <c>acpi=off</c> toe
om ACPI ondersteuning uit te schakelen.
</p>

<pre caption = "append gebruiken om kernel opties te geven">
image=/boot/kernel-2.4.22
  label=gentoo
  read-only
  root=/dev/hda3
  <i>append="acpi=off"</i>
</pre>

<p>
<!--
<c>genkernel</c> users should know that their kernels use the same boot options
as is used for the LiveCD. For instance, if you have SCSI devices, you should
add <c>doscsi</c> as kernel option.
-->
<c>genkernel</c> gebruikers moeten weten dat hun kernel dezelfde opstart opties
gebruikt als de LiveCD. Bijvoorbeeld, als je een SCSI apparaat hebt, dan dien je
<c>doscsi</c> als kernel optie toe te voegen.
</p>


<p>
<!--
Now save the file and exit. To finish up, you have to run
<c>/sbin/lilo</c> so LILO can apply the <path>/etc/lilo.conf</path> to
your system (i.e. install itself on the disk).
-->
Sla het bestand op, en verlaat de editor. Om de installatie af te maken hoef je
enkel nog <c>/sbin/lilo</c> te draaien, zodat de configuratie in
<path>/etc/lilo.conf</path> in het system wordt gezet.
</p>

<pre caption = "De LILO installatie afmaken">
# <i>/sbin/lilo</i>
</pre>

<p>
<!--
Now continue with <uri link="?part=1&amp;chap=10">Installing Necessary System
Tools</uri>.
-->
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</subsection>
</section>
<section>
<!--<title>Alternative: Using aboot</title>-->
<title>Alternatief: aboot gebruiken</title>
<body>

<impo>
<!--
aboot can only be used with alpha-based systems!
-->
aboot kan alleen gebruikt worden op alpha systemen!
</impo>

<p>
<!--
We first install aboot on our system. Of course we use <c>emerge</c> to
do so:
-->
Eerst moeten we aboot installeren. Uiteraard doen we dat met behulp van
<c>emerge</c>:
</p>

<pre caption = "aboot installeren">
# <i>emerge --usepkg aboot</i>
</pre>

<p>
<!--
The next step is to make our bootdisk bootable. This will start
<c>aboot</c> when you boot your system. We make our bootdisk bootable by
writing the <c>aboot</c> bootloader to the start of the disk.
-->
De volgende stap maakt onze bootdisk bootable. Dit zorgt ervoor dat <c>aboot</c>
wordt gestart tijdens het starten het je systeem. We maken on bootdisk bootable
door de <c>aboot</c> bootloader naar het begin van de schijf te schrijven.
</p>

<pre caption = "Je bootdisk bootable maken">
# <i>swriteboot -f3 /dev/sda /boot/bootlx</i> 
# <i>abootconf /dev/sda 2</i>
</pre>

<note>
<!--
If you use a different partitioning scheme than the one we use
throughout this chapter, you have to change the commands accordingly.
Please read the appropriate manual pages (<c>man 8 swriteboot</c> and
<c>man 8 abootconf</c>).
-->
Als je een andere partitie indeling gebruikt dan wij gebruiken in dit voorbeeld,
dan moet je alle commando's daarop aanpassen. De volgende man pagina's zijn
hierop van toepassing <c>man 8 swriteboot</c> en <c>man 8 abootconf</c>.
</note>

<p>
<!--
Additionally, you can make Gentoo boot more easily by setting up the
aboot configuration file and SRM boot_osflags variable. You will need to
make sure that the bootdef_dev is also properly set (easier to do at the
console than from Linux).
-->
Om het opstarten van Gentoo makkelijker te maken, maken we een aboot
configuratie bestand, en zetten we de SRM boot_osflags variabele. You moet je
ervan vergewissen dat de bootdef_dev goed staat (makkelijker vanuit de console
dan vanuit Linux).
</p>

<pre caption = "Gentoo opstarten vergemakkelijken">
# <i>echo '0:2/boot/vmlinux.gz root=/dev/sda2' &gt; /etc/aboot.conf</i>
# <i>echo -n 0 &gt; /proc/srm_environment/named_variables/boot_osflags</i>
# <i>echo -n '' &gt; /proc/srm_environment/named_variables/boot_file</i>
</pre>

<p>
<!--
If you're installing using a serial console, don't forget to include
the serial console boot flag in <path>aboot.conf</path>. See 
<path>/etc/aboot.conf.example</path> for some further information. 
Additionally, you need to allow login on the serial port:
-->
Als je installeerd vanaf een seriele console, vergeet dan niet de seriele
console boot vlag toe te voegen aan <path>aboot.conf</path>. Zie
<path>/etc/aboot.conf.example</path> voor meer informatie. Tevens dien je het
inloggen vanaf de seriele poort toe te staan:
</p>

<pre caption = "Login vanaf de seriele poort toestaan">
# <i>echo tts/0 &gt;&gt; /etc/securetty</i>
# <i>echo 's0:12345:respawn:/sbin/agetty 9600 tts/0 vt100' &gt;&gt; /etc/inittab</i>
</pre>

<p>
<!--
Aboot is now configured and ready to use. Continue with <uri
link="?part=1&amp;chap=10">Installing Necessary System Tools</uri>.
-->
Aboot is nu geconfigureerd en klaar voor gebruik. Je kan nu verder gaan met 
<uri link="?part=1&amp;chap=10">Benodigde Systeem tools installeren</uri>.
</p>

</body>
</section>
<section>
<!--<title>Alternative: Using MILO</title>-->
<title>Alternatief: MILO gebruiken</title>
<body>

<impo>
<!--MILO can only be used with alpha-based systems!-->
MILO kan enkel gebruikt worden op alpha systemen!
</impo>

<p>
<!--
Before continuing, you should decide on how to use MILO. In this
section, we will assume that you want to make a MILO boot floppy. If you
are going to boot from an MS-DOS partition on your hard disk, you should
amend the commands appropriately.
-->
Voor we verder gaan, moet je beslissen hoe je MILO gaat gebruiken. We gaan er
hier vanuit dat je een MILO boot floppy wilt maken. Als je wilt gaan opstarten
vanaf een MS-DOS partitie op je harde schijf, pas dan de commando's aan.
</p>

<p>
<!--To install MILO, we use <c>emerge</c>.-->
Om MILO te installeren gebruiken we <c>emerge</c>
</p>

<pre caption = "MILO Installeren">
# <i>emerge --usepkg milo</i>
</pre>

<p>
<!--
After MILO has been installed, the MILO images should be in
<path>/opt/milo</path>. The commands below make a bootfloppy for use
with MILO. Remember to use the correct image for your Alpha-system.
-->
Nadat MILO geinstalleerd is, behoren de MILO images in <path>/opt/milo</path> te
staan. De commando's hieronder maken een bootfloppy voor gebruik met MILO. Zorg
ervoor dat je het correcte image gebruikt voor jouw alpha systeem.
</p>

<pre caption = "MILO op een floppy installeren">
<comment>(Stop een lege floppy in de computer)</comment>
# <i>fdformat /dev/fd0</i>
# <i>mformat a:</i>
# <i>mcopy /opt/milo/milo-2.2-18-gentoo-ruffian a:\milo</i>
# <i>mcopy /opt/milo/linload.exe a:\lilnload.exe</i>
<comment>(Alleen voor mensen met een Ruffian:</comment>     
  # <i>mcopy /opt/milo/ldmilo.exe a:\ldmilo.exe</i>
<comment>)</comment>
# <i>echo -ne '\125\252' | dd of=/dev/fd0 bs=1 seek=510 count=2</i>
</pre>

<p>
<!--
Your MILO boot floppy is now ready to boot Gentoo Linux. You may need to
set environment variables in your ARCS Firmware to get MILO to start;
this is all explained in the <uri
link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri> with some examples 
on common systems, and examples of the commands to use in interactive mode.
-->
Je MILO boot floppy is nu klaar om Gentoo Linux te starten. Het kan zijn dat je
enkele omgevings variabelen in je ARCS Firware moet aanpassen om MILO werkend te
krijgen. Dit staat allemaal uitgelegd in de <uri
link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri> met enkele voorbeelde
voor veel gebruikte systemen, en voorbeelden van commando's in interactieve
modus.
</p>

<p>
<!--
Not reading the <uri link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri> 
is a <e>bad</e> idea.
-->
De <uri link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri> niet lezen is
een <e>slecht</e> idee.
</p>

<p>
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</section>
<section>
<!--<title>Alternative: Using SILO</title>-->
<title>Alternatief: SILO gebruiken</title>
<body>

<p>
<!--
It is now time to install and configure <uri
link="http://www.sparc-boot.org">SILO</uri>, the Sparc Improved boot
LOader.
-->
Het is nu tijd om <uri link="http://www.sparc-boot.org">SILO</uri>, de Sparc
Improved boot LOader te installeren en configureren.
</p>

<pre caption = "SILO Installeren">
# <i>emerge --usepkg silo</i>
</pre>

<p>
<!--
Now open up your favorite editor (we use <c>nano</c> as an example) and
create <path>/etc/silo.conf</path>.
-->
Open je favoriete editer (wij gebruiken <c>nano</c> als voorbeeld) en maak
<path>/etc/silo.conf</path> aan.
</p>

<pre caption = "/etc/silo.conf aanmaken">
# <i>nano -w /etc/silo.conf</i>
</pre>

<p>
<!--
Beneath you find an example <path>silo.conf</path> file. It uses the
partitioning scheme we use throughout this book and
<path>kernel-2.4.22</path> as kernelimage.
-->
Hieronder vind je een voorbeeld <path>silo.conf</path> bestand. Het maakt
gebruik van de partitie indeling die we door het gehele boek gebruiken, en
<path>kernel-2.4.22</path> als kernel image.
</p>

<pre caption = "Voorbeeld /etc/silo.conf">
partition = 1         <comment># Boot partitie</comment>
root = /dev/hda4      <comment># Root partitie</comment>
timeout = 15          <comment># Wacht 15 seconden voor het default OS gestart wordt</comment>

image = /boot/kernel-2.4.22
  label = linux
</pre>

<p>
<!--
If you use the example <path>silo.conf</path> delivered by Portage, be
sure to comment out <e>all</e> lines that you do not need.
-->
Als je de voorbeeld <path>silo.conf</path> gebruikt, die door Portage wordt
geinstalleerd, vergewis je er van van dat je <e>alle</e> regels die je niet
nodig hebt van commentaar voorziet.
</p>

<p>
<!--
If you have a separate <path>/boot</path> partition, copy over the
configuration file to <path>/boot</path> and run <c>/sbin/silo</c>:
-->
Als je een aparte <path>/boot</path> partitie hebt, kopieer dan het
configuratie bestand naar <path>/boot</path> en draai <c>/sbin/silo</c>:
</p>

<pre caption = "Enkel als je /boot op een andere partitie hebt">
# <i>cp /etc/silo.conf /boot</i>
# <i>/sbin/silo -C /boot/silo.conf</i>
/boot/silo.conf appears to be valid
</pre>

<p>
<!--
If your <path>/boot</path> directory resides on your root partition,
just run <c>/sbin/silo</c>:
-->
Als je <path>/boot</path> directorie zich op de root partitie bevind, draai dan
enkel <c>/sbin/silo</c>:
</p>

<pre caption = "Run silo">
# <i>/sbin/silo</i>
/etc/silo.conf appears to be valid
</pre>

<p>
<!--
Now continue with <uri link="?part=1&amp;chap=10">Installing Necessary System
Tools</uri>.
-->
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</section>
<section>
<title>Alternatief: PALO gebruiken</title>
<body>

<impo>
PALO kan enkel gebruikt worden op HPPA systemen!
</impo>

<p>
<!--
On the PA-RISC platform, the boot loader is called palo. You can find
the configuration file in <path>/etc/palo.conf</path>. Here is a sample 
configuration:
-->
Op het PA-RISC platform heet de bootloader palo. Je kan het configuratie bestand
vinden in <path>/etc/palo.conf</path>. Hier is een voorbeeld configuratie.
</p>

<pre caption = "/etc/palo.conf voorbeeld">
--commandline=2/vmlinux root=/dev/sdb2 HOME=/
--recoverykernel=/vmlinux.old
--init-partitioned=/dev/sdb
</pre>

<p>
<!--
The first line tells palo the location of the kernel and which boot
parameters it must use. <c>2/vmlinux</c> means the kernel named <c>/vmlinux</c>
resides on the second partition. Beware, the path to the kernel is
relative to the partition, not to the root of your filesystem.
-->
De eerste regel verteld palo de locatie van de kernel en de kernel opties.
<c>2/vmlinux</c> betekend de kernel genaamd <c>/vmlinux</c> die op de tweede
partitie staat. Pas op, het pad naar de kernel is relatief aan de partitie, en
niet aan het root bestandssysteem.
</p>

<p>
<!--
The second line indicates which recovery kernel to use. If it is your
first install and you do not have a recovery kernel, please comment this
out. The third line indicates on which disk palo will reside. 
-->
De tweede regel geeft aan welke nood kernel je wilt gebruiken. Als dit je eerste
installatie is, en je hebt nog geen nood kernel, voorzie deze regel dan van
commentaar. De derde regel geeft aan op welke schijf palo is geinstalleerd.
</p>

<p>
<!--
When configuration is done, just run <c>palo</c>.
-->
Wanneer de configuratie klaar is kan je gewoon <c>palo</c> draaien.
</p>

<pre caption = "Applying the PALO configuration">
# <i>palo</i>
</pre>

<p>
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</section>
<section>
<title>Alternatief: yaBoot gebruiken</title>
<subsection>
<title>Introductie</title>
<body>

<impo>
<!--
yaBoot can only be used on NewWorld PPC-based systems!
-->
yaBoot kan ankel op NewWorld PPC systemen worden gebruikt!
</impo>

<p>
<!--
There are two ways to configure yaBoot for your system. You can use the
new and improved <c>yabootconfig</c> included with
<path>yaboot-1.3.8-r1</path> and later to automatically setup yaboot. If
for some reason you do not want to run <c>yabootconfig</c> to
automatically setup <path>/etc/yaboot.conf</path>, you can just edit the
sample file already installed on your system.
-->
Er zijn twee verschillende manieren om yaBoot te configureren. Je kan de nieuwe
verbeterde <c>yabootconfig</c> gebruiken, deze zit standaard bij
<path>yaboot-1.3.8-r1</path>, om automatisch yaBoot te installeren. Als je om
welke reden dan ook <c>yabootconfig</c> niet wilt gebruiken om automatisch
<path>/etc/yaboot.conf</path> te maken, dan kan je gewoon het voorbeeld bestand
dat al op je systeem aanwezig is aanpassen.
</p>

<ul>
  <li><uri link="#doc_chap8_sect2">Standaard: yabootconfig gebruiken</uri></li>
  <li>
    <uri link="#doc_chap8_sect3">Alternatief: handmatige yaBoot 
    configurate</uri>
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Standaard: yabootconfig gebruiken</title>
<body>

<p>
<!--
<c>yabootconfig</c> will auto-detect the partitions on your machine and will
setup dual and triple boot combinations with Linux, Mac OS, and Mac OS
X.
-->
<c>yabootconfig</c> detecteerd automatisch de partities op je systeem, en zal
dual en triple boot combinaties met Linux, Mac OS en Mac OS X configureren.
</p>

<p>
<!--
To use <c>yabootconfig</c>, your drive must have a bootstrap partition, and
<path>/etc/fstab</path> must be configured with your Linux partitions. Both of 
these should have been done already in the steps above. To start, ensure that
you have the latest version of yaboot installed by running <c>emerge - -update
yaboot</c>. This is necessary as the latest version will be available via
Portage, but it may not have made it into the stage files.
-->
Om <c>yabootconfig</c> te gebruiken, moet je schijf een bootstrap partitie
hebben, en <path>/etc/fstab</path> moet juist configureerd zijn voor je Linux
partities. Beide behoren gedaan te zijn in eerdere stappen. Maak je er zeker van
dat je, voor je begint, de laatste versie van yaBoot geinstalleerd hebt door
<c>emerge --update yaboot</c> te draaien. Dit is nodig omdat een nieuwe versie
misschien wel in Portage staat, maar nog niet in de stage bestanden zat.
</p>

<pre caption = "yaBoot installeren">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
<!--
Now run <c>yabootconfig</c>. The program will run and it will confirm
the location of the bootstrap partition. Type <c>Y</c> if it is correct. If
not, double check <path>/etc/fstab</path>. yabootconfig will then scan your
system setup, create <path>/etc/yaboot.conf</path> and run <c>mkofboot</c> for
you. <c>mkofboot</c> is used to format the bootstrap partition, and install 
the yaboot configuration file into it.
-->
Draai nu <c>yabootconfig</c>. Het programma zal de locatie van de bootstrap
partitie bevestigen. Type <c>Y</c> als deze locatie correct is. Zoniet,
controleer <path>/etc/fstab</path> nogmaals. yabootconfig zal dan je systeem
setup scannen, een <path>/etc/yaboot.conf</path> aanmaken en <c>mkofboot</c>
draaien. <c>mkofboot</c> wordt gebruikt om de boostrap partitie te formatteren
en het yaBoot configuratie bestanden erin te plaatsen.
</p>

<p>
<!--
You might want to verify the contents of <path>/etc/yaboot.conf</path>. If 
you make changes to <path>/etc/yaboot.conf</path> (like setting the 
default/boot OS), make sure to rerun <c>ybin -v</c> to apply changes to the 
bootstrap partition.
-->
Je wilt wellicht de inhoud van <path>/etc/yaboot.conf</path> controleren. Als je
veranderingen aanbrengt in <path>/etc/yaboot.conf</path>, zorg er dan voor dat
je <c>ybin -v</c> draait om te veranderingen toe te passen op de bootstrap
partitie.
</p>

<p>
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Alternatief: Handmatige yaBoot Configuratie</title>
<body>

<p>
<!--
First make sure you have the latest <c>yaboot</c> installed on your
system:
-->
Zorg er allereerst voor dat je de laatste <c>yaboot</c> geinstalleerd hebt:
</p>

<pre caption = "yaboot installeren">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
<!--
Below you find a completed <path>yaboot.conf</path> file. Alter it at
will:
-->
Hieronder vind je een compleet <path>yaboot.conf</path> bestand, pas het aan
naar eigen wil.
</p>

<pre caption = "/etc/yaboot.conf">
<comment>## /etc/yaboot.conf
##
## run: "man yaboot.conf" for details. Do not make changes until you have!!
## see also: /usr/share/doc/yaboot/examples for example configurations.
##
## For a dual-boot menu, add one or more of:
## bsd=/dev/hdaX, macos=/dev/hdaY, macosx=/dev/hdaZ

## our bootstrap partition:</comment>

boot=/dev/hda9

<comment>##hd: is open firmware praat voor hda</comment>
device=hd:
partition=11

root=/dev/hda11
delay=5
defaultos=macosx
timeout=30
install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot

<comment>#################
## Deze sectie kan gekopieerd worden als je meer dan een kernel of boot opties
## wilt gebruiken
#################</comment>
image=/boot/vmlinux
  label=Linux
  sysmap=/boot/System.map
  read-only
<comment>##################</comment>

macos=/dev/hda13
macosx=/dev/hda12
enablecdboot
enableofboot
</pre>

<p>
<!--
Once <path>yaboot.conf</path> is set up the way you want it, you run 
<c>mkofboot -v</c> to install the settings in the bootstrap partition. <e>Don't 
forget this!</e> If all goes well, and you have the same options as the sample 
above, your next reboot will give you a simple, five-entry boot menu. If you 
update your yaboot config later on, you'll just need to run <c>ybin -v</c> to 
update the bootstrap partition - <c>mkofboot</c> is for initial setup only.
-->
Als <path>yaboot.conf</path> eenmaal klaar is, kan je <c>mkofboot -v</c> draaien
om de instellingen in de bootstrap partitie op te slaan. <e>Vergeet dit
niet!</e> Als alles goed gaat, en je hebt dezelfde opties als het voorbeeld
bestand, zal de volgende herstart resulteren in een simpel, vijf-keuzen opstart
menu. Als je je yaboot configuratie later aanpast, dien je <c>ybin -v</c> te
draiien, om de bootstrap partitie opnieuw te configureren - <c>mkofboot</c> is
alleen voor de eerste keer nodig.
</p>

<p>
Voor meer informatie over yaBoot kan je een kijkje nemen bij het <uri
link="http://penguinppc.org/projects/yaboot">yaboot project</uri>. Nu kun je 
verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem tools 
installeren</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternatief: BootX</title>
<body>

<impo>
BootX kan enkel worden gebruikt op OldWorld PPC systemen!
</impo>

<p>
<!--
If you want to use BootX, then you don't have to do anything at this
stage. However, after rebooting, you will have to some configuration in
the BootX control panel (inside MacOS). We discuss this later in the
installation.
-->
Als je BootX wilt gebruiken, dan hoef je niets te doen op dit moment. Echter, na
het herstarten, dien je enige configuratie te verrichten in het BootX control
panel (inside MacOS). We hebben het hier verderop in de installatie nog over.
</p>

<p>
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</section>
<section>
<title>Alternatief: MIPS PROM</title>
<subsection>
<body>

<p>
<!--
MIPS doesn't require that you install a bootloader. The MIPS PROM handles the
booting, but you need to install your kernel as a viable option. 
-->
Bij MIPS is het niet noodzakelijk dat je een bootloader installeert. De MIPS
PROM handelt het opstarten af, je hoeft alleen maar je kernel als geldige optie
te installeren.
</p>

<p>
<!--
First, install <c>dvhtool</c>, needed to copy the kernel to the SGI Volume
Header.
-->
Eerst installeer je <c>dvhtool</c>, nodig om de kernel naar het SGI Volume
Header te kopieren.
</p>

<pre caption="dvhtool installeren">
# <i>emerge dvhtool</i>
</pre>

<p>
<!--
Now copy over the kernel to the SGI Volume Header. By default <c>dvhtool</c>
assumes that the SGI Volume Header is on <path>/dev/sda</path>. If this is not
the case (for instance when IRIX is installed on <path>/dev/sda</path> and
Gentoo/MIPS on <path>/dev/sdb</path>) you need to inform <c>dvhtool</c> about it
using <c>-d &lt;device&gt;</c>.
-->
Kopieer nu de kernel naar het SGI Volume Header. Standaard neemt <c>dvhtool</c>
aan dat het SGI Volume Header zich op <path>/dev/sda</path> bevindt. ALs dit
niet het geval is (bijvoorbeeld wanneer IRIX is geinstalleerd op
<path>/dev/sda</path> en Gentoo/MIPS op <path>/dev/sdb</path>) dan moet je
<c>dvhtool</c> hierover inlichten met <c>-d &lt;device&gt;</c>
</p>

<pre caption="Een kernel naar het SGI Volume Header kopieeren">
# <i>dvhtool --unix-to-vh &lt;kernel name in /boot&gt; &lt;naam die je wilt geven in de volume header&gt;</i>
</pre>

<p>
<!--
If you want to see all available entries in the volume, use
<c>- -print-volume-directory</c>:
-->
Als je alle beschikbare opties in het volume wilt zien gebruik je
<c>--print-volume-directory</c>:
</p>

<pre caption="Alle beschikbare opties in het volume bekijken">
# <i>dvhtool --print-volume-directory</i>
</pre>

<p>
<!--
To setup your system to boot Gentoo/MIPS you need to go tweak some settings in
the MIPS PROM. We will describe this later on when the Gentoo installation has
finished.
-->
Om je systeem te configureren om Gentoo/MIPS te starten dien je de instellingen
in het MIPS PROM nog een beetje aan te passen. We beschrijven later hoe dit
gedaan wordt, als de Gentoo installatie klaar is.
</p>

<p>
Nu kun je verder gaan met <uri link="?part=1&amp;chap=10">Benodigde Systeem
tools installeren</uri>.
</p>

</body>
</subsection>
</section>
</sections>
