<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Id: gentoo-security.xml,v 1.16 2012/06/30 18:42:54 swift Exp $ -->

<!-- 
	Rev: 1.13
-->

<guide disclaimer="obsolete" link = "/doc/nl/gentoo-security.xml">
<title>Gentoo Linux Security Handleiding</title>
<author title="Author">
   <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>

<author title="Editor">
   <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>

<author title="Editor">
   <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>

<author title="Editor">
    <mail link="swift@gentoo.org">Jorge Paulo</mail>
</author>

<author title="Translator">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>

<abstract>
Deze handleiding is een stap-voor-stap handleiding over het beveiligen van
Gentoo Linux.
</abstract>

<license/>

<version>0.4</version>
<date>21 July 2003</date>


<!-- Introductie start -->

<chapter>
<title>Inleiding</title>
<section>
<title>Wie zou deze handleiding moeten lezen?</title>
<body>

<p>
Mensen die Gentoo Linux in een serveromgeving gebruiken en/of de nood hebben
aan meer, of zelfs paranoide veiligheid.
</p>

</body>
</section>

<section>
<title>Credits</title>
<body>

<p>
Kim Nielsen
</p>

</body>
</section>

<section>
<title>Speciale dankbetuigingen aan</title>
<body>

<p>
Een speciale dankbetuiging gaat uit naar de volgende personen die verschillende
inhoud-, spellings- en grammatica-fouten opspoorden en verbeterden.
</p>

<p>
Bjarke Sørensen, Justin Lambert, Andreas Waschbuesch, Duncan Lissett, Sherman
Boyd, Sami Dalouche en Väinö Järvelä.
</p>

</body>
</section>

<section>
<title>Toevoegingen geplanned voor volgende versies:</title>
<body>

<p>
In versie 0.6 (Backups)
</p>
<ul>
<li>Arpwatch</li>
<li>Volledige systeembackups dmv Systemimager</li>
<li>Partiele backups dmv tar</li>
<li>Backup nemen van postgres database</li>
</ul>


<p>
In versie 0.8 (Intrusion Testing -- Inbraakpogingen testen)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In versie 1.0 (After a compromise -- Na een inbraak)
</p>
<ul>
<li>Hoe een inbraak rapporteren</li>
<li>Sporen onderzoek</li>
<li>Een snapshot van je systeem maken zonder bewijsmateriaal te vernietigen
(dmv dd)</li>
<li>Trap en trace (dmv tcpdump)</li>
<li>.. Nog enkele zaken ..</li>
<li>Systeem terugzetten</li>
</ul>

<note>
Merk op dat elke versie op zich zich concentreert op 1 onderwerp per keer. Dit
is om kwaliteitsredenen.
</note>

</body>
</section>

</chapter>

<!-- Introductie einde -->

<!-- Overwegingen alvorens installatie start-->

<chapter>
<title>Pre-installatie bedenkingen</title>
<section>
<title>Fysische veiligheid</title>
<body>

<p>
Hoeveel veiligheidsmaatregelen je ook treft, ze kunnen allemaal omzeild worden
indien de aanvaller fysische toegang heeft tot je pc. Zorg er dus voor dat je
hardware niet gewoonweg bereikbaar is voor jan en alleman. Bijvoorbeeld kan je
je pc in een gesloten serverkast plaatsen. Het sluiten van je pc-kast is ook
een goed idee. Om de hoogste veiligheid te verkrijgen is het het best dat je je
BIOS instelt om enkel van HD te kunnen booten. Maw schakel booten van floppy en
CD-ROM uit. Voor de paranoide mensen is het instellen van een BIOS- en 
bootpaswoord ook aangeraden. BIOS paswoorden zijn vooral aangeraden bij 
laptopgebruikers.
</p>

</body>
</section>

<section>
<title>Daemon/Service Planning</title>
<body>

<p>
Documenteer welke services er op de pc moeten of zullen draaien. Dit zal je 
helpen in het opstellen van een goed partitioneerschema voor je systeem. Het 
zal tevens je ID strategy (Intrusion Detection - Inbraakpoging detectie) 
vereenvoudigen.
</p>

<p>
Natuurlijk is het bijhouden van de gedocumenteerde informatie niet 
noodzakelijk indien je maar 1 of enkele pc's hebt en je de enige bent die er 
gebruik van maakt.
</p>

<p>
Bijvoorbeeld:
</p>

<p>
Vraag: De computer moet als firewall dienen. Welke services zou het moeten 
draaien?
</p>

<p>
Antwoord: <e>geeneen</e>, behalve misschien ssh.
</p>

<p>
Documenteer dit en noteer tevens de huidige versie van SSH - dat zal je helpen
met het onderhoud van je systeem indien iemand een veiligheidsprobleem vindt in
sshd. Dit zal je tevens helpen met het beoordelen van wie wel en niet toegang
moet krijgen tot dat systeem.
</p>

</body>
</section>

<section>
<title>Partitioneringsschema's</title>
<body>

<p>
Gouden regels:
</p>

<ul>

<li>
Elke directorie waarnaartoe een gebruiker kan schrijven (/home, /tmp en /var in
de meeste gevallen) dienen op een aparte partitie te komen waarop disk
quota's ingesteld worden. Portage maakt gebruik van /var/tmp om broncode te
compileren dus deze partitie moet groot genoeg zijn. Dit vermindert het risico
dat een gebruiker je &quot;/&quot; mountpoint opvult.
</li>

<li>
Elke directoriestructuur waar je niet-distibutie software in wil installeren 
moet op een aparte partitie komen. Volgens de <uri
link="http://www.pathname.com/fhs">File Hierarchy Standard</uri> (Engels,
Standaard voor bestandsstructuur) zijn deze directories <path>/opt</path> of
<path>/usr/local</path>. Indien deze aparte partities zijn zullen zij dus niet
verwijderd worden indien je het systeem opnieuw installeert, wat de kans op 
extra downtime van je systeem vermindert.
</li>

<li>
Probeer statische data op zijn eigen partitie te plaatsen, en mount deze
partitie read-only (alleen-lezen). Indien je echt paranoide bent kan je deze
data proberen te branden op alleen-lezen-media zoals CD-ROMs.
</li>

</ul>
</body>
</section>

<section>
<title>De root gebruiker</title>
<body>

<p>
De rootgebruiker is de meest belangrijke maar tevens kwetsbare gebruiker van je
systeem en dient niet gebruikt te worden tenzij dit absoluut noodzakelijk is.
Indien een aanvaller root-toegang tot je systeem verkregen heeft kan je niets
meer van je systeem vertrouwen, en moet je deze dus herinstalleren. Compleet.
Inclusief de voordien vermelde niet-distributie software, ook al staat deze op
een aparte partitie.
</p>

<p>
De gouden regels aangaande de root-gebruiker:
</p>

<ul>

<li>
Maak altijd een gebruiker aan voor algemeen gebruik van je systeem. Indien
nodig voeg je deze gebruiker toe aan de wheel-groep zodat deze kan su'en naar
root. 
</li>

<li>
Draai nooit X of andere gewone gebruikersapplicaties als root.
</li>

<li>
Gebruik altijd volledige padnamen indien je werkt als root. Het is immers
mogelijk om root andere applicaties te doen draaien dan dat hij wenst.
Bijvoorbeeld indien iemand met jouw gebruiker's PATH-variabele geknoeid heeft,
en je gebruiker gaat naar root dmv <c>su</c> ipv <c>su -</c>, dan maakt de root
gebruik van die gebruiker zijn PATH en niet die van de root-gebruiker zelf.
</li>

<li>
Indien een gebruiker enkel een klein scala aan commando's dient uit te voeren
als root, overweeg dan het gebruik van sudo, maar wees voorzichtig bij het
configureren!
</li>

<li>
Laat nooit een root-terminal open staan.
</li>

</ul>

<p>
Gentoo heeft een algemene veiligheidsmaatregel tegen gebruikers die proberen
te su'en. De default instellingen van PAM laten immers niet toe dat gebruikers
die geen lid zijn van de wheel-groep kunnen su'en.
</p>

</body>
</section>

<section>
<title>Beleidsverklaringen (Policies)</title>
<body>

<p>
Er zijn verschillende redenen waarom beleidsverklaringen nodig zijn.
</p> 

<ul>

<li>
Je kan niet verklaren dat je netwerk veilig is zonder een definitie te geven
van &quot;veilig&quot;.
</li>

<li>
Het is bijna onmogelijk om potentiele aanvallers vast te grijpen,
netwerkproblemen op te lossen of audit's uit te voeren zonder dat je je
netwerktraffic bekijkt of in private homedirectories van gebruikers neust. En
aangezien dergelijke controles illegaal zijn zonder dat de gebruiker dit
goedgekeurd heeft, en ongeveer 60% van alle aanvallen van binnenin de
organisatie komen, is het belangrijk dat je een wakend oog hebt en een beleid
opstelt.
</li>

<li>
Je kan niet verwachten van je gebruikers dat ze aan veiligheid denken, indien
je hen nooit uitlegt waarom en hoe ze zich moeten beschermen tegen zichzelf of 
andere collega's.
</li>

<li>
Goede regels en netwerkdocumentatie zijn altijd positief, onafhankelijk van de
situatie.
</li>

<li>
De politie of het federaal rechtssysteem kan je niet helpen met het vatten van
de aanvaller indien ze niet weten hoe je netwerk in elkaar zit of welke
services je aanbiedt.
</li>

<li>
Wat zal je doen als er een aanval succesvol uitgevoerd werd? Je moet
definieren wat je dan zal doen en wie je ervan op de hoogte houdt. Ga je de
politie of een CERT team bij elke mogelijke poging al contacteren? Ze zullen je
niet serieus nemen...
</li>

</ul>

<p>
Deze zaken zouden je duidelijk moeten gemaakt hebben waarom beleidsverklaringen
belangrijk zijn bij systemen met meer dan 1 gebruiker en waarom je je
gebruikers moet informeren.
</p>

<p>
Een beleidsverklaring is een document (of meerdere documenten) met antwoorden
op vragen zoals wie, waar, waarom en wat.
Elke gebruiker op je systeem/netwerk zou dat document moeten lezen, begrijpen
en ondertekenen. Het is belangrijk dat je de tijd neemt om de gebruikers te
helpen met het interpreteren van je beleidsverklaring en met het waarom van het
ondertekenen, alsook met de repercussies indien ze tegen het beleid in gaan
(dit moet tevens in de beleidsverklaring staan). Dit moet minstens 1 keer per
jaar herhaald worden, niet enkel omdat het beleid kan veranderen, maar tevens 
als herinnering voor de gebruikers.
</p>

<note>
Maak beleidsverklaringen aan die gemakkelijk lezen en duidelijk maar specifiek
elk mogelijk onderwerp aankaarten.
</note>

<p>
De meeste onderdelen van een beleidsverklaring kunnen direct op het
besturingssysteem toegepast worden of via firewalls, maar andere kunnen dan
weer niet geautomatiseerd worden.
</p>

</body>
</section>

<section>
<title>Veiligheidsbeleid</title>
<body>

<p>
Een veiligheidsbeleid is eigenlijk een verzameling van regels die voor de
veiligheid van je netwerk of systeem instaan. Het is een document die
informatie bevat aangaande de computers, het netwerk, de paswoorden, de 
e-mail-regels, hoe je gebruikers zich al dan niet moeten gedragen, 
wat er moet gedaan worden indien er een al-dan-niet succesvolle aanval is 
geweest, hoe computers geinstalleerd worden, hoe het infrastructuur eruit moet 
zien etc...
</p>

<p>
Een veiligheidsbeleid moet op zijn minst de volgende onderwerpen aansnijden:
</p>

<ul>

<li>Aanvaardbaar gebruik.</li>
<li>
<ul>
  <li>Schermbeveiligingen</li>
  <li>Paswoordonderhoud</li>
  <li>Downloaden van software</li>
  <li>Kennisgeving van &quot;spionering&quot;</li>
  <li>Gebruik van anti-virus software</li>
  <li>etc.</li>
</ul>
</li>

<li>
Gebruik van belangrijke, gevoelige informatie (eender welke vorm: telefoon,
fax, papier, digitaal, ...).
</li>
<li>
<ul>
  <li>Overzichtelijk bureau en documenten achter slot en grendel</li>
  <li>Afsluiten van pc's alvorens de zaal/kamer te verlaten</li>
  <li>Gebruik van encryptie</li>
  <li>Gebruik van sleutels en uitwisseling met vertrouwde collega's</li>
  <li>Gebruik van gevoelige informatie tijdens transport of reis</li>
</ul>
</li>

<li>
Gebruik van computermateriaal tijdens transport of reis</li>
<li>
<ul>
  <li>Gebruik van laptop in hotels, conferenties, ...</li>
</ul>
</li>

</ul>

<p>
Het beleid voor IT-mensen kan verschillen van die van gewone gebruikers.
</p>

<p>
Het veiligheidsbeleid kan zeer groot worden, en belangrijke informatie kan
gemakkelijk vergeten worden. De IT-mensen hun beleid kan informatie bevatten
die geheim is voor de gewone gebruiker, dus is het belangrijk om je
beleidsverklaringen te splitsen in kleinere documenten; bijvoorbeeld
&quot;Aanvaardbaar gebruik&quot;, &quot;Paswoord gebruik&quot;, &quot;E-mail
beleid&quot;, &quot;Werken vanuit andere locaties&quot;, ...
</p>

<p>
Voorbeelden van beleidsverklaringen kan je vinden op <uri
link="http://www.sans.org/resources/policies/">De SANS
Policy Project</uri> (Engels). Indien je een klein netwerk hebt en je denkt dat
deze beleidsverklaringen iets te uitgebreid zijn kan je misschien eens kijken
naar <uri
link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">RFC2196</uri> wat
een website's beveiligingsgids is.
</p>

</body>
</section>
</chapter>

<!-- Overwegingen voor de installatie einde -->

<!-- Verbeteren van de veiligheid na/gedurende de installatie -->

<chapter>
<title>De veiligheid verbeteren tijdens en na de installatie</title>
<section>
<title>/etc/make.conf</title>
<body>

<p>
Het make.conf bestand bevat alle opties en vermeld de extra bibliotheken die je
wil gebruiken wanneer je je ebuilds compileert. In dit bestand moet je
minstens ebuild-ondersteuning meegeven voor veiligheidsbibliotheken zoals PAM
(Pluggable Authentication Modules), tcp wrappers of SSL (Secure Socket Layer).
Je USE-variabele moet dus minstens pam, tcpd en ssl bevatten.
</p>

<p>
Voeg dus het volgende toe:
</p>

<pre caption="USE aanpassingen">
USE="tcpd pam ssl"
</pre>

</body>
</section>

<section>
<title>GRUB paswoord</title>
<body>

<p>
Grub ondersteunt 2 methodes van paswoordrestrictie in zijn configuratiebestand
(<path>/boot/grub/grub.conf</path>). De ene is met een gewoon paswoord, de
andere is met md5+salt encryptie.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
Dit zal het paswoord <e>changeme</e> gebruiken en als er geen paswoord
opgegeven wordt zal het de default instellingen opstarten.
</p>

<p>
Indien je een md5 paswoord wil invullen moet je het paswoord in crypt-formaat
(man crypt) converteren wat hetzelfde formaat is als dat het shadow
paswoordbestand gebruikt. Bijvoorbeeld zal het geencrypteerde paswoord
<e>changeme</e> er als volgt uitzien: <e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>
</p>

<p>
Dit wordt weergegeven in de volgende configuratieinstellingen:
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<warn>
Wanneer je dit wil testen, vergeet dan niet de timeout in te stellen. Anders
zal je niet de mogelijkheid krijgen om je systeem te booten indien je paswoord
verkeerd is.
</warn>

<p>
De 5-seconden timeout is zeer handig indien het systeem op een andere locatie
staat en de pc moet kunnen booten zonder keyboard-interactie. Meer informatie 
over Grub paswoorden kan je vinden in <path>info grub</path>.
</p>

</body>
</section>

<section>
<title>LILO paswoord</title>
<body>

<p>
LILO ondersteunt ook 2 methodes van paswoorden: een globale en een per-image
gebaseerde; beide zijn gewone (niet-geencrypteerde) paswoorden.
</p>


<p>
Het globale paswoord zet je bovenaan je configuratiebestand:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
In het andere geval voeg je het gewoon toe aan een image.
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
Indien de <e>restricted</e> optie niet meegegeven wordt zal LILO altijd achter
een paswoord vragen, indien de optie wel meegegeven wordt zal LILO enkel achter
een paswoord vragen indien je iets anders dan de default instellingen wil 
gebruiken.
</p>

<p>
Om de nieuw aangebrachte aanpassingen door te voeren moet je <c>/sbin/lilo</c>
opnieuw uitvoeren.
</p>

</body>
</section>

<section>
<title>Consolegebruik beperken</title>
<body>
<p>
<path>/etc/securetty</path> bevat de terminals waarop je als root mag inloggen.
</p>

<p>
We raden aan dat je alles behalve vc/1 verwijdert. Hierdoor zorg je ervoor dat
root maar op 1 terminal tegelijkertijd kan inloggen (<c>su -</c> wordt niet
meegerekend).
</p>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>

<section>
<title>Meer loggen</title>
<body>

<p>
Extra loggen wordt best toegepast om fouten, waarschuwingen en dergelijke meer
op te vangen. Deze kunnen immers een lopende aanval (of succesvol uitgevoerde
aanval) aantonen. Aanvallers maken zeer frequent gebruik van scanning of
probing alvorens ze een systeem aanvallen.
</p>

<p>
Het is tevens van vitaal belang dat de logbestanden gemakkelijk leesbaar en
onderhoudbaar zijn.
</p>

<p>
Gentoo Linux laat je toe om tussen 3 verschillende loggers te kiezen tijdens de
installatie.
</p>
</body>
</section>

<section>
<title>Syslogd</title>
<body>

<p>
Syslogd is de meest gebruikte logger voor Linux en Unix algemeen. Het heeft
geen logrotatie mogelijkheid. Deze mogelijkheid kan je toch implementeren door
middel van <path>/usr/sbin/logrotate</path> in een cronjob te steken en
<path>/etc/logrotate.conf</path> goed te configureren. De hoeveelheid van
logrotaties zijn afhankelijk van het gebruik van je systeem.
</p>

<p>
Hier is een voorbeeld van hoe je syslog kan configureren:
</p>

<pre caption="/etc/syslog.conf">
*.=debug                   /var/log/debug
*.err                      /var/log/syslog

#Gebruikers van wie je wil zien wanneer ze ingelogd zijn
*.=alert                   root,<i>je gebruikers hier</i>
*.=emerg                   root,<i>je gebruikers hier</i>

mail.info,mail.notice      /var/log/maillog
kern.*                     /var/log/kern.log
daemon.info;daemon.notice  /var/log/daemon.log
cron.*                     /var/log/cron.log
mail.*                     /var/log/mail.log
user.*                     /var/log/user.log
uucp.*                     /var/log/uucp.log
*.*;auth,authpriv.none     /var/log/syslog

#Plaats de logbestanden in 2 verschillende locaties
authpriv.*;auth.*          /admin/auth.log
authpriv.*;auth.*          /var/log/secure

#Schrijf alles tevens neer in een terminal
*.*                        /dev/tty12

#Stel een andere server in als logserver
*.*                        @logserver
</pre>

<p>
De aanvaller zal waarschijnlijk proberen om zijn voetsporen te wissen door
logbestanden aan te passen of te verwijderen. Je kan het hem moeilijk maken
door de logs naar een of meer logservers op verschillende machines te sturen.
</p>

<p>
Meer informatie over syslogd kan je vinden in de manpage (<path>man
syslog</path>).
</p>

</body>
</section>

<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> door Frank Dennis
heeft niet de mogelijkheid om naar een andere server te loggen, maar heeft wel
voordelen op gebied van performantie en logflexibiliteit.
</p>

<p>
Het kan per proces loggen of per faciliteit (zoals syslogd werkt) en komt met
een eigen expressietaal en uitvoering van commandos. Zeer goed om akties te
ondernemen indien nodig.
</p> 

<pre caption="/etc/metalog.conf">
maxsize  = 1000000
maxtime  = 86400
maxfiles = 7
minimum  = 7

Kernel messages :

  facility = "kern"
  logdir   = "/var/log/kernel"

Auth messages :
  facility = "auth"
  logdir   = "/var/log/auth"

Emergencies :
  facility = "emerg"
  command  = "/usr/local/sbin/pwdfail.sh"  

Crond :

  program  = "crond"
  logdir   = "/var/log/crond"
  
Password failures :

  regex    = "(password|login|authentication)\s+(fail|invalid)"
  regex    = "(failed|invalid)\s+(password|login|authentication)"
  regex    = "ILLEGAL ROOT LOGIN"
  logdir   = "/var/log/pwdfail"
  command  = "/usr/local/sbin/pwdfail.sh"

SSH Server :

  program  = "sshd"
  logdir   = "/var/log/sshd"

Mail :

  facility = "mail"
  logdir   = "/var/log/mail"

Snort:
  program   = "snort"
  command  = "/usr/local/sbin/pwdfail.sh"

Everything important :

  facility = "*"
  logdir   = "/var/log/everything"

Everything very important :

  facility = "*"
  logdir   = "/var/log/critical"

</pre>

<p>
Dit is een default configuratie met enkele aanpassingen, zoals een minimum
logniveau van 7, wat wil zeggen dat alles gelogged zal worden.
</p>

<p>
pwdfail.sh voor postfix:
</p>

<pre caption = "pwdfail.sh voor Postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
pwdfail.sh voor qmail:
</p>

<pre caption = "pwdfail.sh voor qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Meer informatie kan je vinden op de <uri
link="http://metalog.sourceforge.net">metalog</uri> website.
</p>

</body>
</section>
<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng levert sommige features van syslog en metalog met enkele kleine
verschillen. Het kan berichten filteren op niveau en inhoud (net zoals
metalog), ondersteunt logservers zoals syslog, kan syslogd logs aan (zelfs deze
van Solaris), kan naar een TTY schrijven en programmas uitvoeren en zelf als
logserver fungeren. Dit is dus eigenlijk het beste van beide andere loggers met
extra mogelijkheden.
</p>

<p>
Een klassiek configuratiebestand mits wat kleine aanpassingen.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#bron van waar de log ingelezen dient te worden
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#doelen definieren
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#filters aanmaken
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#filter en doel linken
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#default log
log { source(src); destination(console_all); };
</pre>

<p>
Het is gemakkelijk om te configureren maar tevens zeer gemakkelijk om fouten te
maken aangezien het configuratiebestand groot is. De auteur heeft belooft om
nog extra mogelijkheden zoals encryptie, identiteits verificatie, compressie 
en MAC (Mandatory Access Control) in te bouwen. Met deze opties zal dit de 
perfecte logger worden, aangezien de aanvaller de logs dan niet meer kan 
bekijken en aanpassen.
</p>

<p>
En syslog-ng heeft nog een andere mogelijkheid: het moet niet als root werken!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Mounten van partitions</title>
<section>
<body>

<p>
Wanneer we een ext2, ext3 of een reiserfs partitie mounten kan je verschillende
opties meegeven in <path>/etc/fstab</path>. Deze zijn:
</p>

<ul>

<li>
nosuid - Pas de SUID bit niet toe en maak van het programma een ordinair
programma.
</li>

<li>
noexec - Zorgt ervoor dat geen bestanden van deze partitie uitgevoerd kunnen
worden.
</li>

<li>
nodev - Negeer apparaatbestanden op deze partitie.
</li>
</ul>

<p>
Jammergenoeg kunnen deze instellingen gemakkelijk omzeild worden door een
niet-direct pad mee te geven. Het instellen van noexec op /tmp zal toch 99% van
de scriptkiddies tegenhouden aangezien hun exploits gemaakt zijn om uitgevoerd
te voeren vanuit /tmp.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
<path>/tmp</path> met noexec mounten kan verhinderen dat sommige scripts
correct uitgevoerd worden!
</warn>

<note>
Disk quotas worden in een ander hoofdstuk besproken
</note>

<p>
Merk op dat we <path>/var</path> niet met noexec of nosuid mounten, ook al zijn
bestanden daarin normaal gezien niet uitvoerbaar. De reden hievoor is dat qmail
geinstalleerd wordt in <path>/var/qmail</path> en de mogelijkheid moet hebben 
om 1 suid file aan te passen en uit te voeren.
We maken van <path>/usr</path> wel een read-only partitie aangezien daar nooit
naartoe moet geschreven worden, tenzij om Gentoo up te daten. Dan mounten we
<path>/usr</path> eventjes in lees-schrijf mode, updaten en hermounten we ze 
opnieuw in alleen-lezen.
</p>

<note>
Zelfs indien je qmail niet gebruikt, vereist Gentoo nog steeds de executable
bit op <path>/var/tmp</path> aangezien ebuilds daarin gecompileerd worden. Een
alternatief pad kan ingegeven worden indien je werkelijk <path>/var</path> met
noexec wil mounten.
</note>

</body>
</section>
</chapter>

<chapter>
<title>User/group limitaties</title>
<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
Het controleren en beperken van resource-gebruik kan zeer efficient zijn om 
lokale DoS te voorkomen, of om het maximaal aantal logins van een gebruiker of
groep gebruikers te beperken.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Indien je overweegt om nproc of maxlogins voor een bepaald gebruiker op 0 te
plaatsen, misschien dat je dan beter de gebruiker verwijdert. Het voorbeeld
hierboven stelt de instellingen in voor de groep &quot;dev&quot; voor
processen, core bestanden en maxlogins. De rest krijgt de default instellingen.
</p>

<note>
<path>/etc/security/limits.conf</path> is een deel van de PAM package en zal
enkel werken bij programma's die PAM gebruiken.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
Limieten zijn gelijkaardig aan het limitbestand
<path>/etc/security/limits.conf</path>. Het enige verschil is het formaat en
het feit dat deze enkel werkt op gebruikers (niet op groepen). Laten we eens
kijken naar een degelijke configuratie:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Hier stellen we de default instellingen in alsook een specifieke setting voor
de gebruiker <e>kn</e>. Limieten zijn onderdeel van de shadow package en gelden
enkel voor het shadow login programma. Het is niet noodzakelijk om hierin
instellingen te veranderen indien je de PAM setting in je make.conf aangezet
hebt en PAM correct geconfigureerd is.
</p>

</body>
</section>
<section>
<title>Quotas</title>
<body>

<p>
Het plaatsen van quota's op een bestandssysteem verhindert dat gebruikers die
partitie vullen met (al dan niet nutteloze) bestanden, of zelfs dat de
gebruikers erop schrijven. Quota-ondersteuning moet in de kernel zitten en moet
als optie meegegeven zijn tijdens het mounten van een partitie. De kerneloptie
kan je vinden onder <c>File systems -&gt; Quota support</c>. 
</p>

<pre caption="Installeren van quota">
# <i>emerge quota</i>
</pre>

<p>
Pas je <path>/etc/fstab</path> aan en voeg usrquota en grpquota toe aan de
partities waarvan je het gebruik wil beperken zoals aangegeven in het
voorbeeld.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Op elke partitie die gebruik moet maken van de quota-ondersteuning moet je de
quota-bestanden aanmaken (quota.user en quota.group) en deze in de root van
elke partitie plaatsen.
</p>

<pre caption = "Aanmaken van quota-bestanden op /tmp">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Deze stap moet uitgevoerd worden op elke partitie waar je quota's wil
gebruiken. Nadat je de quota-bestanden aangemaakt hebt en geconfigureerd, moet
je een script als rc-script aanmaken zodat de quota's automatisch geactiveerd
worden tijdens het booten. Kopieer en plak het volgende script in een bestand
genaamd <path>/etc/init.d/quotas</path>. Maak gewoon dat bestand aan (het
bestaat nog niet) en maak het uitvoerbaar.
</p>

<pre caption="/etc/init.d/quotas">
#!/sbin/runscript

depend() {
	need localmount
}

start() {
        if [ -x /sbin/quotacheck ] 
        then 
               ebegin "Checking quotas. This may take some time." 
               /sbin/quotacheck -avug 
               eend $?
        fi 
        if [ -x /sbin/quotaon ] 
        then 
               ebegin "Turning on quota." 
               /sbin/quotaon -avug 
               eend $?
        fi
}

stop() {
        if [ -x /sbin/quotaon ] 
        then 
	       ebegin "Turning off quota."
               /sbin/quotaoff
	       eend $?
        fi
}
</pre>

<p>
Voeg deze dan toe aan de default runlevel met <c>rc-update add quotas
default</c> en voeg een quota-controle toe als cronjob (crontab -e) om
periodisch elke week de quota's te scannen: <c>0 3 * * 0 /sbin/quotacheck
-avug</c>.
</p>

<p>
Nadat je je systeem gereboot hebt (nieuwe kernel, herinner je nog?) is het tijd
om de quota's van de gebruikers en de groepen in te stellen. <c>edquota -u
kn</c> zal de gedefinieerde editor ($EDITOR, default is nano) opstarten en zal
de quota's voor de gebruiken kn weergeven zodat je deze dan kan aanpassen. 
<c>-g</c> zal hetzelfde laten doen voor een gegeven groep.
</p>

<pre caption="Instellen van de quota's van gebruiker kn">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Voor meer details, lees <e>man edquota</e> of <uri
link="http://www.tldp.org/HOWTO/mini/Quota.html">The quota mini HOWTO</uri> 
(Engels).
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
Indien het beleid verklaart dat de gebruikers hun paswoord elke week moeten
aanpassen, moet je de variabele PASS_MAX_DAYS op bijvoorbeeld 14 zetten, en de
variabele PASS_WARN_AGE op 7. Het is tevens aangeraden dat je
paswoordveroudering gebruikt om brute krachtmethoden tegen te gaan: geef ze
genoeg tijd en een brute krachtmethode kan elk paswoord kraken.
We raden tevens aan om LOG_OK_LOGINS op yes te plaatsen.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Het login.access bestand is ook deel van de shadow package en bevat een
toegangscontroletabel. De tabel wordt gebruikt om te bepalen wie wel en niet
kan inloggen gebaseerd op gebruikersnaam, groepnaam of hostnaam. Per default
mogen alle gebruikers inloggen dus is dit bestand in het begin enkel gevuld met
commentaar en voorbeelden. Als je dus je pc aan het beveiligen bent raden we
aan om iedereen uit te schakelen (zodat ze niet kunnen inloggen) behalve de
personen die mogen inloggen (en dat is meestal enkel jezelf bij de meeste
servers).
</p>

<note>
De settings in dit bestand zijn niet geldig voor de root-gebruiker.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<warn>
Wees voorzichtig wanneer je deze opties configureert, aangezien fouten ervoor
kunnen zorgen dat je zelf geen toegang meer hebt tot de machine!
</warn>

<note>
Deze aanpassingen zijn niet geldig voor SSH aangezien SSH niet gebruik maakt
van /bin/login per default. Je kan daar echter wel voor zorgen door
&quot;UseLogin yes&quot; te plaatsen in <path>/etc/ssh/sshd_config</path>.
</note>

<p>
Dit voorbeeld zal ervoor zorgen dat leden van de wheel-groep wel kunnen
inloggen op de console, alsook gebruikers van het gentoo.org-domein. Misschien
te paranoide, maar beter dat dan je systeem te zien vallen in handen van
hackers.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Bestandspermissies</title>
<section>
<title>Wereldleesbaar (world readable)</title>
<body>

<p>
Gewone gebruikers zouden geen toegang moeten hebben tot configuratiebestanden
of paswoorden. Een hacker kan paswoorden stelen van een database of website en
deze defacen of, nog erger, verwijderen. Dit is waarom het belangrijk is dat de
permissies correct zijn. Indien je er zeker van bent dat een bestand enkel door
root gebruikt moet worden, geef deze dan 0600 permissies en verander de
eigenaar via chown.
</p>

</body>
</section>

<section>
<title>Wereld/Groep schrijfbaar</title>
<body>

<pre caption="Zoeken naar wereldschrijfbare bestanden en directories">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Dit zal een groot bestand aanmaken met de permissies van alle bestanden die
ofwel schrijfbaar zijn voor de groep of voor iedereen. Bekijk deze permissies
en elimineer bestanden die door iedereen schrijfbaar zijn, dit door
<path>/bin/chmod o-w</path> uit te voeren op die bestanden.
</p>

</body>
</section>

<section>
<title>SUID/SGID files</title>
<body>

<p>
SUID/SGID bestanden (bestanden met de superuser bit geplaatst) zijn vaak 
uitvoerbare bestanden waardoor de gebruiker zaken kan uitvoeren met 
rootpermissies. Deze bestanden kunnen leiden tot een lokale root-escalatie 
(indien de bestanden/programmas fouten bevatten). Dergelijke bestanden zijn 
gevaarlijk en moeten vermeden worden.
Indien je de bestanden niet nodig hebt, doe dan <c>chmod 0</c> op deze
bestanden, of unmerge de pakketten die deze bestanden levert (dat kan je
controleren met qpkg -f dat door <c>gentoolkit</c> geleverd wordt).
Anders kan je de SUID bit verwijderen met <c>chmod -s</c>.
</p>

<pre caption="Zoeken van suid-bestanden">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Dit zal een bestand aanmaken dat alle SUID/SGID bestanden vermeldt.
</p>

<pre caption="suid-bestanden op een default Gentoo Linux systeem">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Per default heeft Gentoo niet veel SUID bestanden (dit hangt natuurlijk af van
wat je geinstalleerd hebt), maar je lijst zal er ongeveer zo uitzien. De meeste
commando's moeten niet gebruikt worden door gewone gebruikers, maar enkel door
root. Schakel de SUID bit uit van ping, mount, umount, chfn, chsh, newgrp,
suidperl, pt_chown en traceroute dmv <c>chmod -s</c> op elk van die bestanden.
Verwijder niet de bit van su, qmail-queue of unix_chkpwd. Als je dat zou doen
zou je niet meer kunnen su'en en mail ontvangen. Maar het is natuurlijk een
extra veiligheid (wat betreft su) indien er niemand hoeft te su'en.
</p>

<p>
De enige SUID bestanden die ik op mijn systeem staan heb zijn su, passwd,
gpasswd, qmail-queue, unix_chkpwd en pwdb_checkpwd. Maar indien je X gebruikt
zal je er waarschijnlijk nog enkele hebben, aangezien sommige X-tools de 
SUID-bit vereisen.
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM is een set van gedeelde bibliotheekbestanden die een alternatief bieden op
gebied van identiteits verificatie in programma's. De PAM instellingen van 
Gentoo Linux zijn goed, maar er is altijd ruimte voor verbetering :)
</p>

<note>
Dit hoofdstuk heeft geen effect op je systeem indien je PAM niet in je
USE opties hebt meegegeven in <path>/etc/make.conf</path>
</note>

<p>
Installeer cracklib:
</p>

<pre caption = "Installeren van cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_pwdb.so shadow nullok
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2
password required pam_pwdb.so md5 use_authok
session	 required pam_pwdb.so
</pre>

<p>
Dit zal de cracklib bibliotheek toevoegen zodat gebruikers een paswoord van
minimum 8 karakters moeten ingeven, waarbij er minstens 2 cijfers zijn, 2
niet-letters en minstens 3 karakters verschillend van het vorige paswoord. 
Dit forceert de gebruikers om een goed paswoord te gebruiken (paswoord beleid).
Zie <uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">
PAM</uri> (Engels) documentatie voor meer mogelijkheden.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_pwdb.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_pwdb.so shadow md5
session	 required pam_pwdb.so
session	 required pam_limits.so
</pre>

<p>
Elke service die niet door een PAM bestand in <path>/etc/pam.d</path>
geconfigureerd wordt wordt door de &quot;other&quot; regels ingesteld. De
default instellingen zijn om alles te weigeren, zoals het moet zijn dus. Maar
aangezien we graag veel logs van vanalles hebben, voegen we pam_warn.so toe. De
laatste configuratie is pam_limits die geconfigureerd wordt door
<path>/etc/security/limits.conf</path>. Zie ook het desbetreffende hoofdstuk.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
TCP Wrappers is een manier om toegang tot services die door inetd (die Gentoo
niet default installeert) of xinetd en anderen gecontroleerd worden te beheren.
</p>

<note>
De USE variabele in make.conf moet tcpd bevatten en de service in kwestie
dient tcpd te gebruiken als serverargument (in xinetd). Zie ook het hoofdstuk
aangaande xinetd voor meer informatie.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Zoals je kan zien is het formaat gelijkaardig aan deze van
<path>/etc/login.access</path>. Tcpd ondersteunt specifieke services en
beide werken in verschillende plaatsen wat betreft veiligheid. Deze
instellingen zijn enkel geldig voor services die gebruik maken van tcp
wrappers.
</p>

<p>
Het is tevens mogelijk om commando's uit te voeren als een service gebruikt
wordt (bijvoorbeeld om relaying te activeren voor gebruikers die inbellen) maar
het wordt niet aangeraden aangezien mensen zich zo meer problemen op de hals
jagen dan dat ze er oplossen. Een voorbeeld van gebruik kan zijn dat je een
script gebruikt die uitgevoerd wordt telkens iemand een deny-regel van de tcp
wrappers activeert, maar zo kan een hacker dan weer een DoS uitvoeren door
constant te proberen. Dit zou dus veeeeeel I/O en mails genereren, dus
<e>niet</e> doen is de boodschap. Lees <c>man 5 host_access</c> voor meer
informatie.
</p>

</body>
</section>
</chapter>

<!-- De veiligheid verbeteren tijdens / na de installatie einde -->

<!-- Kernelveiligheid start -->

<chapter>
<title>Kernel security</title>

<section>
<title>Verwijderen van overbodige functionaliteit</title>
<body>

<p>
De basisregel van kernelconfiguratie is om alles te verwijderen wat je niet
nodig hebt. Dit zorgt ervoor dat je een kleine kernel hebt met de minste kans
op fouten (die zich bevinden in drivers e.d.).
</p>

<p>
Overweeg tevens om module-ondersteuning uit te schakelen. Alhoewel het mogelijk
is om rootkit modules te gebruiken zonder deze feature maakt het het toch
moeilijker voor gewone hackers om dit te proberen.
</p>

</body>
</section>

<section>
<title>/proc (kernel flags)</title>
<body>

<p>
Veel kernelparameters kunnen aangepast worden via het /proc bestandssysteem of
door gebruik te maken van sysctl.
</p>

<p>
Om dynamisch kernelparameters aan te passen moet CONFIG_SYSCTL aan staan in je
kernel. Dit is default in een 2.4-kernel.
</p>

<pre caption="Negeren van ping-pakketten">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Dit zal ICMP type 0 (gekend als ping) pakketten uitschakelen. De reden hiertoe
is dat ICMP meer informatie bevat dan dat je denkt. Sommige beheerders zullen 
misschien klagen dat ze niet kunnen pingen ter controle van het netwerk. 
Er is echter geen reden voor outsiders om te kunnen pingen. Maar soms kan het 
wel interessant zijn voor insiders om te kunnen pingen. Om dit toe te laten 
sluit je ICMP type 0 enkel uit op de publieke interface via je firewall.
</p>

<pre caption="Negeren van broadcast-pings">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Dit schakelt broadcast-antwoorden uit.
</p>

<p>
Je wil zeker geen smurf versterker worden. Smurf versterkers of X-mass trees
zijn methoden die een hacker gebruikt om een explosief grote hoeveelheid 
traffic te genereren naar een bepaald doel.
</p>

<pre caption="Weigeren van source-routed pakketten">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Dit schakelt source-gerouteerde pakketten uit.
</p>

<p>
Aanvaard geen source-gerouteerde pakketten. Hackers gebruiken soms
sourcerouting om traffic te genereren die lijkt alsof ze vanuit je eigen
netwerk komen, maar die teruggerouteerd worden langs het pad dat ze kwamen,
zodat hackers je netwerk kunnen misleiden. Source routing wordt amper gebruikt
voor meer vriendelijke doeleinden, dus mag je die gerust uitschakelen.
</p>

<pre caption="Negeren van redirect-pakketten">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Schakelt ICMP redirect uit. ICMP redirects kunnen gebruikt worden
om je routingtabellen aan te passen, mogelijk met kwade bedoelingen.
</p>

<pre caption="Bescherm tegen slechte errorberichten">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Schakel bescherming in tegen slechte errormessages.
</p>

<pre caption="Activeren van reverse path filtering">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter;
done</i>
</pre>

<note>
Indien je IP forwarding aanschakelt, wordt dit al vanzelf gedaan.
</note>

<p>
Schakel reverse path filteren in. Dit verzekert je dat de pakketten legitieme
bronadressen gebruiken, en dit door automatisch binnenkomende pakketten te
weigeren wiens bronadres niet overeenkomt met de netwerkinterface waar ze op
toekomen. Dit heeft als voordeel dat IP spoofing niet mogelijk wordt, <c>echter
kan het problemen opleveren bij assymetrische routering</c> (pakketten die van
jouw host naar een andere host gaan nemen een andere weg dan deze die 
van de andere host naar jouw host gaan) alsook indien je een non-routing host 
gebruikt die verschillende IP adressen heeft op verschillende interfaces.
</p>

<pre caption="Loggen van alle voordien uitgeschakelde pakketten">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Log gespoofede pakketten, source gerouteerde pakketten en redirect pakketten.
</p>

<pre caption="IP forwarding uitschakelen">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Verzeker jezelf ervan dat IP forwarding af staat. Je wenst dit enkel voor
speciale doeleinden.
</p>

<p>
Al deze instellingen worden gereset nadat je gereboot hebt. Het is dus
aangeraden om het volgende script aan een runlevel toe te voegen en deze
uitvoerbaar te maken:
</p>

<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 before *
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>

<p>
Voeg het nu toe aan de default runlevel door <c>rc-update add procparam
default</c> uit te voeren.
</p>

</body>
</section>

<section>
<title>Grsecurity</title>
<body>

<p>
De patch van <uri link="http://grsecurity.net">Grsecurity</uri> zit in
de Gentoo kernel maar is default uitgeschakeld. Hier staat hoe je het
activeert:
</p>

<p>
Configureer je kernel zoals je normaal gezien doet, en configureer dan de
Grsecurity optie: kies &quot;customized&quot; en activeer de volgende opties:
</p>

<ul>
<li>Buffer Overflow Protection</li>
<li>
<ul>
  <li>Openwall non-executable stack</li>
  <li>Gcc trampoline support</li>
</ul>
</li>

<li>Filesystem Protections</li>
<li>
<ul>
  <li>Proc restrictions</li>
  <li>Linking restrictions</li>
  <li>Secure file descriptors</li>
  <li>Chroot jail restrictions (Activeer alle andere opties hieronder)</li>
</ul>
</li>

<li>Kernel Auditing</li>
<li>
<ul>
  <li>Log execs within chroot</li>
  <li>(Un)Mount logging</li>
  <li>Signal logging</li>
  <li>Fork failure logging</li>
  <li>Log set*ids to root</li>
  <li>Time change logging</li>
</ul>
</li>

<li>Executable Protections</li>
<li>
<ul>
  <li>Dmesg restriction</li>
  <li>Randomized PIDs</li>
  <li>Altered default IPC permissions (kan resulteren in slecht functionerende
  programmas)</li>
  <li>Restricted ptrace</li>
</ul>
</li>

<li>Network Protections</li>
<li>
<ul>
  <li>Randomized IP IDs</li>
  <li>Randomized TCP source ports</li>
  <li>Altered Ping IDs</li>
  <li>Randomized TTL</li>
</ul>
</li>
<li>Miscellaneous Features</li>
<li>
<ul>
  <li>BSD-style coredumps (zal coredumps zoals core.named creeren)</li>
</ul>
</li>

</ul>

<p>
Compileer en installeer nu je veiligheids-uitgebreidde kernel.
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.kerneli.org">Kerneli</uri> is een patch die encryptie
toevoegt aan de huidige kernels. Door je kernel te patchen krijg je nieuwe
opties zoals Cryptografische sleutels, Digest algoritmen en Cryptografische
loopfilters.
</p>

<warn>
De kerneli patch is op dit moment niet beschikbaar in een stabiele versie
voor de laatste stabiele kernel, dus wees op je hoede als je die gebruikt.
</warn>

</body>
</section>

<section>
<title>Andere kernel patches</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri> (niet voor
2.4 kernels)</li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
En er zijn er waarschijnlijk nog een ganse boel meer...
</p>

</body>
</section>

</chapter>

<!-- Kernel security einde -->

<!-- Beveiligen van de services start -->

<chapter>
<title>Services beveiligen</title>

<section>
<title>Gebruik maken van xinetd</title>
<body>
<p>
xinetd is een substituut voor inetd (die Gentoo niet levert), de internet
services daemon. Deze ondersteunt toegangscontrole gebaseerd op het adres van
de host en het tijdstip van toegang. Het laat tevens verschillende
logging-mogelijkheden toe, inclusief server starttijd, host adres,
gebruikersnaam, server runtijd, alsook acties om te ondernemen bij bepaalde events.
</p>

<p>
Zoals met alle andere services is het hier ook belangrijk om een goede
configuratie te hebben. Maar aangezien xinetd als root werkt en protocols
ondersteunt die je misschien niet kent raden we af om deze te gebruiken. Maar
als je het wil gebruiken, dan volgen hier enkele tips over hoe je deze kan
beveiligen:
</p>

<pre caption="Installeren van xinetd">
# <i>emerge xinetd tcpd</i>
</pre>

<p>
Pas het configuratiebestand aan:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Dit zal pserver (cvs) opstellen via xinetd met de volgende instellingen:
# - maximum 10 connecties
# - limiteer pserver tot tcp
# - gebruik de cvs gebruiker om deze service uit te voeren
# - bind deze service aan 1 ip
# - laat enkel toegang vanuit 10.0.0.* toe
# - limiteer de tijd van developers van 8am tot 5pm
# - gebruik tcpd wrappers
# - de maximum load van de machine mag 1.0 niet overschrijden
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Voor meer informatie lees <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>ssh</title>
<body>

<p>
Het enige wat OpenSSH van beveiliging nodig heeft is een sterkere
identificatie gebaseerd op publieke sleutel-encryptie. Veel te veel sites
(zoals <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> en
 <uri>http://www.apache.org</uri>) hadden problemen met hun systemen wegens
paswoordlekken of slechte paswoorden.
</p>

<pre caption="/etc/ssh/sshd_config">
#Laat enkel versie 2 toe
Protocol 2

#Geen directe rootlogins toelaten
PermitRootLogin no

#Schakel RSA sleutelidentificatie aan
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# Schakel .rhosts en gewone paswoordbeveiliging uit (dus enkel sleutels
# toelaten)
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Niemand behalve mensen in de groepen wheel of admin mogen toegang hebben...
AllowGroups wheel admin

#... op 2 gebruikers na ;)
AllowUsers kn bs

#Activeer logging
SyslogFacility AUTH
LogLevel INFO

#bind
ListenAddress 127.0.0.1
</pre>

<p>
Wat al je gebruikers nu nog hoeven te doen is een publieke sleutel aanmaken
(op hun machine van waaruit ze willen inloggen) met het volgende commando:
</p>

<pre caption="Aanmaken van een RSA sleutelpaar">
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>

<p>
Type een paswoordzin in:
</p>

<pre caption="Uitvoer van ssh-keygen">
Generating public/private rsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_rsa):<i>[Druk op enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Type je paswoord/paszin in]</i>
Enter same passphrase again: <i>[Type je paswoord/paszin nogmaals in]</i>
Your identification has been saved in /home/kn/.ssh/id_rsa.
Your public key has been saved in /home/kn/.ssh/id_rsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Dit zal 2 bestanden in je <path>~/.ssh</path> aanmaken genaamd id_rsa en
id_rsa.pub. Het bestand id_rsa is je privesleutel en mag niet publiek gemaakt
worden. Het andere bestand is id_rsa.pub en dient gedistribueerd te worden naar
elke server waar je toegang tot hebt. Voeg de sleutel toe aan de gebruikers'
homedirectorie in <path>~/.ssh/authorized_keys</path>. De gebruiker zou normaal
gezien nu moeten kunnen inloggen.
</p>

<p>
Nu moeten je gebruikers hun eigen private sleutel goed bewaren. Laat ze hun
sleutels op een medium plaatsen die ze altijd bij hebben of sla ze op op hun
werkstation (hint: paswoord beleid).
</p>

<p>
Meer informatie vind je op <uri link="http://www.openssh.org">OpenSSH</uri>'s 
website.
</p>

</body>
</section>

<section>
<title>X beveiligen</title>
<body>

<p>
Per default is XFree geconfigureerd om als Xserver te fungeren. Dit kan
gevaarlijk zijn aangezien X ongeencrypteerde tcp connecties gebruikt en
luistert naar xclients. Indien je dit niet nodig hebt, schakel deze functie dan
uit! Maar indien je wenst dat je werkstation een Xserver is, maak dan
voorzichtig gebruik van <path>/usr/X11R6/bin/xhost</path>. Dit commando stelt
in welke clients (andere machines) er mogen connecteren naar je pc en je
display gebruiken. Dit kan handig zijn indien je een X-applicatie van een
andere machine wil gebruiken. De syntax is <path>/usr/X11R6/bin/xhost
+hostname</path>.
</p>

<warn>
Gebruik <e>nooit</e> <c>xhost +</c>! Dit laat toe dat eender welke client kan
connecteren naar je X en er gebruik van kan maken. Indien een hacker van je X 
kan gebruik maken kan hij je keyboardgebruik loggen en je desktop controleren.
</warn>

<p>
Een veiligere oplossing is om deze functionaliteit uit te schakelen door X op
te starten met <c>startx -- -nolisten tcp</c> of door dit permanent uit te
schakelen in het configuratiebestand:
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs=""
</pre>

<p> 
aan te passen naar 
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Indien je een grafische login manager gebruikt moet je een andere manier
toepassen.
</p>

<p>
Voor: gdm (Gnome Display Manager)
</p>

<p>
Verander:
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X
</pre>

<p>
naar
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Voor: xdm (X Display Manager) en kdm (Kde Display Manager)
</p>

<p>
Verander
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X 
</pre>

<p>
naar
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>

<section>
<title>FTP</title>
<body>
<p>
FTP (File Transfer Protocol) is algemeen een slecht idee. Het maakt gebruik van
ongeencrypteerde data, luistert naar 2 poorten, ondersteunt anonieme gebruikers
en is eigenlijk juist de service waar hackers naar zoeken (om bv warez uit te
wisselen). Indien mogelijk, probeer dan gebruik te maken van sftpd of http in
plaats van het ftp protocol aangezien het ftp protocol verschillende
veiligheidsproblemen bevat. Indien dit niet mogelijk is, probeer je dan zo
veilig mogelijk te maken en wees op je hoede!
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd is een spin-off van trollftpd. Ze is aangepast met veiligheid
en grotere functionaliteit in gedachten door Frank Dennis.
</p>

<p>
Maak gebruik van virtuele gebruikers (dus nooit echte systeemaccounts) door de
AUTH optie te activeren. Zet deze op <c>-lpuredb:/etc/pureftpd.pdb</c> en maak
je gebruikers aan met <path>/usr/bin/pure-pw</path>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
## Aantal simultane connecties, per ip gerekend ##
MAX_CONN="-c 30"
MAX_CONN_IP="-C 10"

## Laat geen uploads toe indien de partitie voller is dan deze variabele ##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Andere... ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Configureer je MISC_OTHER instellingen zodat anonieme toegang geweigerd wordt
(-E), chroot toegepast wordt op alle gebruikers (-A), geweigerd wordt dat 
gebruikers  bestanden lezen of schrijven die beginnen met een . (dot) (-X), 
een maximale idletijd ingesteld staat (-I), recursie gelimiteerd wordt (-L) en 
geef een voldoende veilige umask in. En gebruik <e>zeker niet</e> de optie -w 
of -W! En indien je een warez-site wil aanmaken: stop met dit document te 
lezen!
</p>

<p>
Meer informatie kan je vinden op <uri>http://www.pureftpd.org</uri>
</p>


</body>
</section>

<section>
<title>Proftpd</title>
<body>

<p>
Proftpd heeft verschillende veiligheidsproblemen gehad, maar deze zijn allemaal
opgelost. Er zijn echter nog steeds enkele aanpassingen aangeraden:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Mijn ftp daemon"
#Toon de identificatie van de server niet
ServerIdent on "Heeeeeere's Jhonny!"

#Maak het gemakkelijker om virtuele gebruikers aan te maken
RequireValidShell off

#Gebruik een alternatief password en group bestand
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissies
Umask 077

# Timeouts en limitaties
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Iedereen chrooten
DefaultRoot ~

#Niet als root draaien
User  nobody
Group nogroup

#Alles loggen
TransferLog /var/log/transferlog

#Globbingproblemen elimineren
DenyFilter \*.*/
</pre>

<p>
De rest hangt van jezelf en je eigen mogelijkheid tot lezen af
(<uri>http://www.proftpd.org</uri>).
</p>

</body>
</section>

<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (staat voor &quot;Very Secure FTP&quot;: zeer veilige ftp) is een snelle
ftp-daemon met een voldoend veilige default configuratie. Ze is simpel en heeft
niet veel features (zoals virtuele gebruikers) die pureftp en proftp wel
hebben.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#Enkel lezen
write_enable=NO

#Transfers loggen
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Zoals je ziet is er geen manier voor deze service om individuele permissies en
default chrootacties te ondernemen. Maar wanneer het neerkomt op anonieme
instellingen is ze zeer goed. Soms kan het handig zijn om een anonieme
ftp-server te hebben (om bv open source bestanden te delen) en deze server is
daar ideaal voor.
</p>

</body>
</section>

<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) komt met een leuk en goed configuratiebestand, maar toch zijn
er enkele aanpassingen nodig, zoals het binden aan 1 enkel adres en
informatielekken tegenhouden. Dit zijn de opties die je in het
configuratiebestand zou moeten toepassen:
</p>

<p>
Indien je ssl aan je <path>/etc/make.conf</path> hebt toegevoegd alvorens je
apache geinstalleerd hebt is er toegang tot een ssl webserver. Voeg gewoon de
volgende regel toe om deze te activeren:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Laat het naar jouw localhost luisteren
Listen 127.0.0.1
BindAddress 127.0.0.1
#Het is geen goed idee om nobody of nogroup te gebruiken voor elke service die
#niet als root draait. Maak gewoon een user/group apache aan voor apache.
User apache
Group apache
#Zeg niet welke versie je hebt
ServerSignature Off
ServerTokens min
</pre>

<p>
Apache is gecompileerd met --enable-shared=max en --enable-module=all. Dit zal
per default alle modules activeren dus moet je de modules in de LoadModule
sectie (LoadModule en AddModule) wegcommentarieren indien je ze niet wil
gebruiken. Herstart de service door <c>/etc/init.d/apache restart</c> uit te
voeren.
</p>

<p>
Meer documentatie kan je vinden op <uri>http://www.apache.org</uri>
</p>

</body>
</section>

<section>
<title>Qmail</title>
<body>
<p>
Qmail wordt verondersteld de meest veilige mailserver te zijn die er bestaat.
Ze is geschreven met veiligheid (en paranoia) in gedachten. Ze laat geen
relaying toe per default en heeft geen enkele veiligheidslek gehad sinds
1996. Voer gewoonweg <c>emerge qmail</c> uit en begin met configureren.
</p>
</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
Bind is gekend voor zijn (on)veiligheidsgeschiedenis en dat moet je niet 
lichtjes opvatten. Zoals met elke andere service mag het <e>nooit</e> als root 
draaien, dus verander aub niet de default configuratie van deze service op dat 
vlak. Per default stelt Gentoo geen configuratie in voor deze service dus zal 
je je eigen dns zones in <path>/etc/bind/named.conf</path> moeten installeren. 
Maar de veiligheid hangt niet enkel af van de dns-server, maar tevens van het 
protocol dat gebruikt wordt moet goed geconfigureerd zijn.
</p>

<p>
Mensen vragen vaak &quot;Waarom niet djbdns&quot; gebruiken (zeer veilige dns
van D.J. Bernstein) en het antwoord is: Bind heeft features die djbdns niet
heeft, zoals ondersteuning voor IPv6 (of toch niet zonder patches).
</p>

<pre caption="/etc/bind/named.conf">
#Stel ACLs in
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
#Laat toe dat "mynet" queries uitvoert.
  allow-query { "mynet"; };
#Laat geen zonetransfers toe.
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
#Laat enkel recursie toe aan "mynet"
  recursion no;
  allow-recursion { mynet; };
#Bind aan een interface
  listen-on { 10.0.0.1; };
#Toon de versie niet
  version "Heeeeeeeres Jhonny!";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

#Laat enkel beheer toe van localhost en met een sleutel
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>

<p>
Dit is een default goede configuratie. Echter heeft Bind versie 9 speciale
chrootfunctionaliteit dat je best gebruikt. Hier leg ik uit hoe je je gechroote
bind aanmaakt:
</p>

<pre caption="Aanmaken van chrootomgeving">
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>

<p>
Dit zal een chrootomgeving aanmaken in <path>/chroot</path>. Al wat we nu nog
moeten doen is de initscript aanpassen om de nieuwe chrootomgeving te
gebruiken. Editeer <path>/etc/init.d/named</path> en voeg <c>-t /chroot/dns</c>
toe aan de startfunctie. Je zou tevens beter de stop-functie ook aanpassen om
naar het correcte PID-bestand te wijzen
(<path>/chroot/var/run/named/named.pid</path>). Herstart je DNS-server.
</p>

<note>
Een hacker kan uit een chrootjail ontsnappen indien hij goed genoeg is (zie hoe
je dat voorkomt in de kernelpatch sectie van dit document).
</note>

<p>
Documentatie kan gevonden worden op het <uri
link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri> (Engels).
</p>

</body>
</section>

<section>
<title>Djbdns</title>
<body>

<p>
Er is niet echt veel te vertellen over djbdns behalve dat de auteur <uri
link="http://cr.yp.to/djbdns/guarantee.html">geld</uri> wil verwedden op het 
feit dat zijn software veilig is. Dus ga en probeer het eens:
<uri>http://www.djbdns.org</uri>. Het is verschillend van Bind v9 wat betreft
configuratie e.d. maar echt moeilijk is het nie.
</p>

</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
Samba is een netwerk file/printer-sharing protocol tussen Microsoft/Novell 
netwerken en zou <e>niet</e> mogen gebruikt worden over het internet. Maar 
ongeacht dat heeft het nog steeds veiligheid nodig.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Aan een interface binden
  interfaces = eth0 10.0.0.1/32

  #Geencrypteerde paswoorden gebruiken
  encrypt passwords = yes
  directory security mask = 0700

  #Enkel toegang verlenen aan het 1.0.0.* netwerk
  hosts allow = 10.0.0.

  #Gebruikersidentificatie gebruiken
  #(dus geen share-mode)
  security = user
  
  #Alle gepriviligeerde accounts weigeren
  invalid users = root @wheel

  #Maximaal gebruik (in kilobytes)
  max disk size = 102400

  #Paswoordbeleid forceren
  min password length = 8
  null passwords = no

  #PAM gebruiken (indien ondersteund)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Zorg ervoor dat de permissies correct zijn op elke share en herinner je eraan
om de <uri link="http://www.samba.org">documentatie</uri> (Engels) te lezen.
</p>

<p>
Herstart nu je server en voeg de gebruikers toe die toegang moeten hebben tot
deze service. Dit kan je doen door <path>/usr/bin/smbpasswd</path> te gebruiken
met de <c>-a</c> optie.
</p>

</body>
</section>

<section>
<title>Chroot of virtuele servers.</title>
<body>

<p>
Chrooten is een manier om je service (of gebruiker) te limiteren naar een 
beperkte omgeving zodat het/hij geen toegang heeft tot andere informatie van je
systeem, wat zou kunnen leiden tot veiligheidsproblemen. Door de service als
een andere gebruiker dan root te draaien (nobody, apache, named) kan een hacker
enkel de permissies van die gebruiker verkrijgen en dus enkel bestanden van die
gebruiker aanpassen. Dit wil zeggen dat een hacker geen rootaccess kan
verkrijgen ook al bevat de service veiligheidsfouten.
</p>

<p>
Sommige services zoals pure-ftpd en bind hebben features voor chrooting,
terwijl anderen dat dan weer niet hebben. Indien de service het ondersteunt,
gebruik het dan. Anders moet je zelf een chrootomgeving opstellen voor die
service. Laten we eens bekijken hoe je een eigen chroot omgeving opstelt. Om
het gedrag van een chrootomgeving te verkennen zullen we deze testen met bash.
</p>

<p>
Maak een directorie aan in <path>/</path> genaamd chroot (<c>mkdir chroot</c>).
Probeer erachter te komen welke dynamische bibliotheekbestanden bash gebruikt
(indien deze statisch gecompileerd is is dit niet nodig):
</p>

<p>
Het volgende commando zal een lijst aanmaken van bibliotheekbestanden die bash
gebruikt.
</p>

<pre caption="Tonen van de gebruikte bibliotheekbestanden">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Laten we nu een omgeving aanmaken voor bash.
</p>

<pre caption="Aanmaken van chroot-omgeving">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Vervolgens kopieren we de bestanden die door bash gebruikt worden
(<path>/lib</path>) naar de gechrootte omgeving en kopieren we bash zelf naar
de gechroote bin-directorie. Dit zal eenzelfde omgeving voor bash aanmaken,
maar met heel wat minder mogelijkheden. Na het kopieren proberen we het uit:
<c>chroot /chroot/bash</c>. Indien je een prompt krijgt die <c>/</c> leest dan
werkt je chrootomgeving. Anders zal het je duidelijk maken welk bestand er
vermist is. Sommige bibliotheekbestanden hangen immers af van nog andere
bibliotheekbestanden...
</p>

<p>
Je zal merken dat in de chrootomgeving niets werkt behalve echo. Dit is omdat
we geen enkel ander commando in de chrootomgeving geplaatst hebben behalve
bash, en echo is ingebouwd in bash.
</p>

<p>
Dit is ongeveer hoe je een gechroote service aanmaakt. Het enige verschil is
dat de services afhangen van configuratiebestanden en devicefiles in
<path>/etc</path> en <path>/dev</path>. Kopieer deze gewoon over (devices
kopieer je het best met cp -a) naar de gechrootte omgeving, en pas het
initscript aan zodat deze chroot gebruikt voordat deze de service uitvoert. Het
kan moeilijk zijn om te weten te komen welke devices en configuratiebestanden
een service nodig heeft. Om hierachter te komen is <c>strace</c> een zeer
handig commando. Start de service met <path>/usr/bin/strace</path> en zoek voor
open, read, stat en misschien connect. Dit zal je een idee geven van welke
bestanden je moet kopieren. In de meeste gevallen moet je
<path>/etc/passwd</path> (na aanpassen zodat enkel de nodige gebruikers erin
staan), <path>/dev/zero</path>, <path>/dev/log</path> en
<path>/dev/random</path>. 
</p>

<p>
Een andere manier van een veilige chrootomgeving op te stellen is door een
virtuele server te creeren. Dit zal een kopie maken van de huidige
Linuxomgeving en booten in een virtuele machine. Dat wil zeggen dat, indien een
hacker de service kan kraken, enkel de virtuele server gehackt is en niet de
werkelijke installatie.
</p>

<p>
Een voorbeeld van virtuele servers:
</p>

<ul>

<li>
<uri link="http://user-mode-linux.sourceforge.net">Usermode Linux</uri> met een
howto op <uri link="http://www.gentoo.org/doc/en/uml.xml">UML on Gentoo</uri>
(beide Engels).
</li>

<li>
<uri link="http://www.solucorp.qc.ca/miscprj/s_context.hc">Virtuele private
servers</uri> (Engels).
</li>

</ul>

</body>
</section>

</chapter>

<!-- Securing Services einde -->

<!-- Firewalls -->

<chapter>
<title>Firewalls</title>

<section>
<title>Een firewall</title>
<body>

<p>
Mensen denken vaak dat een firewall de ultieme veiligheid is, maar ze zijn
verkeerd. In de meeste gevallen is een slecht geconfigureerde firewall zelfs de
slechtste veiligheid die je je kan wensen, zelfs slechter dan geen firewall te
hebben. Een firewall is een deel software en moet gezien worden als elke andere
service, aangezien ze even vatbaar is voor fouten (veiligheidsfouten).
</p>

<p>
Dus denk alvorens je een firewall implementeert. Heb je er werkelijk een nodig?
Indien je denkt dat je er een nodig hebt, schrijf dan een beleidsdocument over
hoe het moet werken, welk soort firewall je wenst en wie deze moet beheren.
</p>

<p>
Firewalls worden voor 2 redenen gebruikt:
</p>

<ul>
<li>Om gebruikers (wormen of hackers) buiten te houden</li>
<li>Om gebruikers (werknemers of kinderen) binnen te houden</li>
</ul>

<p>
Er zijn ongeveer 3 types van firewalls:
</p>

<ul>
<li>Packet filtering</li>
<li>Circuit relay</li>
<li>Application gateway</li>
</ul>

<p>
Een firewall is idealiter een aparte machine die geen andere services draait
(behalve misschien ssh) en beveiligd is zoals deze handleiding je uitlegt.
</p>

</body>
</section>

<section>
<title>Packet filtering</title>
<body>

<p>
Alle netwerktraffiek is in vorm van pakketten. Grote traffiek wordt opgesplitst
in kleinere pakketten voor gemakkelijke routing en worden weer samengevoegd
wanneer ze toegekomen zijn aan hun bestemming. Elk pakket bevat informatie
over hoe en waar deze moet toekomen. En deze informatie is juist datgene wat de
packet filtering firewall gebruikt. Het filteren is gebaseerd op:
</p>

<ul>

<li>Toelaten of verhinderen van pakketten gebaseerd op bron/bestemming IP
adres</li>
<li>Toelaten of verhinderen van pakketten gebaseerd op bron/bestemming
poort</li>
<li>Toelaten of verhinderen van pakketten afhankelijk van het gebruikte
protocol</li>
<li>Toelaten of verhinderen van pakketten afhankelijk van de vlaggen in het
gebruikte protocol</li>
</ul>

<p>
Normaal gezien gebeurt filteren dus altijd op de data in de header van een
pakket en niet in de inhoud van het pakket.
</p>

<p>
Problemen:
</p>

<ul>
<li>Adresinformatie in een pakket kan een potentieel foutief adres zijn (of,
zoals dat heet, een <e>spoofed</e> IP-adres)</li>
<li>Data of aanvragen van data in een toegelaten pakket kan ongewenste data 
bevatten die de hacker kan gebruiken om bekende fouten in services te 
exploiteren of een firewall te omzeilen.</li>
<li>Er is normaal gezien een enkelvoudig foutpunt (1 fout en alles is naar de
knoppen).</li>
</ul>

<p>
Voordelen:
</p>

<ul>
<li>Simpel en eenvoudig te implementeren</li>
<li>Kan waarschuwingen geven aangaande een mogelijke hackpoging alvorens de
hackpoging succesvol uitgevoerd is (door bv portscans te detecteren).</li>
<li>Gemakkelijk om SYN aanvallen tegen te gaan</li>
</ul>

<p>
Voorbeelden van vrije packet filters onder Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li><uri link="http://www.tldp.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri></li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

</body>
</section>

<section>
<title>Circuit relay</title>
<body>

<p>
Circuit relays, ook genaamd circuit level gateways, zijn firewalls die 
connecties valideren alvorens data mag uitgewisseld worden. Dit wil zeggen dat 
het simpelweg pakketten aanvaard of weigert gebaseerd op het feit of de 
connectie tussen beide hosts opgemaakt is volgens de configuratieregels van de 
firewall. Enkel indien die connectie correct is aangemaakt wordt er een sessie 
gestart waardoor data kan uitgewisseld worden. Het filteren is gebaseerd op:
</p>

<ul>
<li>Doel/bron adres</li>
<li>Doel/bron poort</li>
<li>Een tijdsperiode</li>
<li>Protocol</li>
<li>Gebruiker</li>
<li>Paswoord</li>
</ul>

<p>
Alle traffiek wordt gevalideerd en gecontroleerd; traffiek waar dat niet gedaan
kan worden wordt geweigerd.
</p>

<p>
Zwaktes:
</p>

<ul>
<li>
Opereert op de transportlaag en vereist mogelijk grote aanpassingen van de
programmacode die normaal gezien de transportlaagfuncties aanbiedt.
</li>
</ul>

</body>
</section>

<section>
<title>Application gateway</title>
<body>

<p>
De application level gateway is een proxy voor applicaties die data uitwisselen
met een ander systeem op client-niveau. Ze wordt weggehouden van het publiek 
door ze achter de DMZ of firewall te plaatsen waar er geen connectie is 
vanbuitenuit. Filteren is gebaseerd op:
</p>

<ul>
<li>Toelaten of weigeren van pakketten gebaseerd op bron/doel</li>
<li>Gebaseerd op de inhoud van het pakket</li>
<li>Kan zelf de pakketten aanpassen</li>
<li>Limiteer toegang tot bestanden gebaseerd op bestandstype of extensie</li>
</ul>

<p>
Voordelen:
</p>

<ul>
<li>Kan bestanden in een cache plaatsen, waardoor de netwerkperformantie
verbetert.</li>
<li>Gedetailleerde logging van alle connecties</li>
<li>Zeer flexibel; sommige proxies kunnen gecachede data uitwisselen</li>
<li>Geen toegang van buitenuit</li>
</ul>

<p>
Zwakheden:
</p>

<ul>
<li>Zeer complexe configuratie</li>
</ul>

<p>
Application gateways worden aanzien als de meest veilige oplossing aangezien ze
niet als root moeten draaien en niet vanuit het internet bereikbaar zijn.
</p>

<p>
Voorbeeld van een vrije application gateway:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>

<section>
<title>Iptables</title>
<body>

<p>
Om iptables werkende te krijgen moet deze geactiveerd zijn in de kernel. Ik
persoonlijk heb deze als modules gecompileerd (het iptables commando zal die
zelf laden indien nodig) en daarna mn kernel gehercompileerd. Hierna is het
nodig om iptables te installeren (<c>emerge iptables</c>), waarna het zou
moeten werken.
</p>

<p>
Test iptables door <c>iptables -L</c> uit te voeren. Indien er ergens een fout
optreedt moet je je configuratie in je kernel nog eens goed bekijken.
</p>

<p>
Iptables is een stateful packet filter wat wil zeggen dat ze meer controle en
veiligheid biedt dan ipchains (Linux versie 2.2) die niet stateful is. Nu vraag
je je waarschijnlijk af wat stateful wil zeggen? En wat het verschil is?
</p>

<p>
We weten allemaal dat TCP uitgemaakt is als een serie pakketten. Elke pakket
bevat informatie over bronadres, doeladres en een sequentienummer opdat de
pakketten weer samengebracht kunnen worden. We weten tevens dat TCP
connectie-georienteeerd is en UDP connectieloos. Dat zijn de &quot;states&quot;
die gebruikt worden. Nu vraag je je waarschijnlijk af &quot;En dan?&quot; Wel,
daar kom ik nu aan toe...
</p>

<p>
Stel je nu voor dat je een stateless firewall hebt (ipchains) en je wil niet
dat externe pc's een connectie naar je interne services aanmaken; maar hoe kan
je nu weten of een pakket nu behoort tot een connectie naar of een connectie
van? Een stateless firewall kan geen onderscheidt tussen beide maken door te
kijken naar de SYN vlag.
</p>

<p>
Veronderstel dat een hacker een bende zelfgemaakte pakketten verstuurt waarin 
hij de SYN vlag of andere vlaggen aangepast heeft. Dit is iets wat hackers 
vaak doen.
Ze zenden zo pakketten langs de firewall om en passen routingtables aan of
exploiteren services die op de firewall draaien maar zogezegd veilig moeten
zijn. Een stateful firewall zal bijhouden welke connecties er zijn en kan
gemakkelijk verifieren of een pakket tot een bestaande connectie behoort of
niet. Wanneer een connectie, die zegt dat hij een deel is van een bestaande
connectie, ontmaskert wordt als vals, dan kan deze aangeduid worden als
&quot;ongeldig&quot; en kan men de bijhorende pakket weigeren. Op die manier 
is het dus mogelijk om &quot;Stealth Scans&quot; tegen te houden, aangezien 
deze gebruik maken van valse connecties.
</p>

<p>
Er zijn nog tientallen andere redenen waarom, maar ik denk wel dat je
bovenstaande uitleg begrijpt. Eenvoudige regels maken een kleinere
firewallconfiguratie mogelijk waardoor ze dus ook gemakkelijker is om te
beheren.
</p>

<p>
Iptables biedt verschillende andere mogelijkheden, zoals rate limitaties. Deze
feature is zeer handig indien je bepaalde DoS aanvallen zoals SYN aanvallen wil
tegengaan. Maar wat is nu een SYN aanval?
</p>

<p>
Wel, wanneer een TCP connectie opgemaakt wordt wordt er gebruik gemaakt van een
3-wegs handdruk:
</p>

<fig link="http://www.ibiblio.org/pub/Linux/distributions/gentoo/images/synack.jpg" short="Three-way handshake"/>

<p>
Een SYN aanval is wanneer de vijand maar 1 SYN pakket verstuurt maar niet het 
andere pakket waardoor de connectie niet wordt opgemaakt. Een SYN pakket
moet geen geldig zender-IP-adres bevatten omdat ze geen antwoord vereist van de
hacker. Dus blijft de half-open connectie hangen totdat deze timeout. Indien de
hacker dus veel SYN pakketyrn verzendt met een valse zender-IP dan zal de doelpc
blijven wachten op een antwoord die nooit komt. Afhankelijk van de timeout
instellingen van je systeem zal de connectie gedurende 30 tot 60 seconden open
blijven. Wanneer de connectielimiettabel volledig in gebruik is kan je pc geen
andere connecties meer aangaan, en is je server dus onbereikbaar via het
internet.  
</p>

<p>
Dit is waar rate limit in het spel komt. Het is mogelijk om het aantal SYN
pakketten van een bepaald bronadres te limiteren dmv <c>-m limit --limit
1/s</c>. Dit zal het aantal SYN pakketten per bronadres restricteren en dus de
SYN floods tegengaan.
</p>

<p>
Nu wat praktische zaken...
</p>

<p>
Wanneer iptables in de kernel geladen is heeft het 5 plaatsen waarin je je
regels kan plaatsen. Ze noemen INPUT, OUTPUT, FORWARD, PREROUTING en
POSTROUTING. Deze lijsten worden ketens (chains) genaamd omdat ze werken als
een ketting: deel per deel wordt ingegeven, elk pakket doorloopt alle regels.
Indien 1 regel nyet zegt, wordt het pakket geweigerd.
</p>

<p>
Je kan je regels direct in 1 van de 5 hoofdketens plaatsen, ofwel zelf ketens
maken en deze toevoegen als regel aan een bestaande keten. Laten we eens kijken
hoe je dat doet:
</p>

<table>
  <tr>
    <th>Optie:</th><th>Uitleg:</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>Append (Toevoegen)</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>Delete (Verwijderen)</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>Insert (Invoegen)</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>Replace (Vervangen)</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>List (Toon)</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>Verwijder alle regels in een of alle ketens</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>Zet de tellers van een of alle ketens op nul</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>Test dit pakket op de keten(s)</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>Maak een eigen keten</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>Verwijder een zelfgemaakte keten</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>Verander het beleid van een keten</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>Verander de naam van de keten</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>Protocol</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>Bronadres of -mask</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>Doeladres of -mask</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>Invoer naam (netwerkinterface)</ti>
  </tr>
  <tr>
    <ti>-o</ti><ti>Uitvoer naam (netwerkinterface)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>Spring (commando voor in een keten)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>Uitgebreide herkenning</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>Numerieke uitvoer van IP-adressen</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>Tabel om aan te passen</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>Veel uitleg geven (Verbose)</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>Nummers uitbreiden (volledige nummers tonen)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>Enkel 2e of verdere delen onderzoeken</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>Pakket versie</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>Geef regelnummering</ti>
  </tr>
</table>

<p>
Allereerst proberen we alle ICMP pakketten te blokkeren (dit als voorbeeld van
het gebruik van iptables):
</p>

<pre caption="Weigeren van ping-pakketten">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Eerst definieren we de keten waar dit aan moet toegevoegd worden. Daarna
specifieren we het protocol en dan de regel die moet toegevoegd worden. De
regel kan ACCEPT, DROP, REJECT, LOG, QUEUE, MASQUERADE, een geladen module of
een zelfgedefinieerde keten zijn. In dit geval gebruiken we DROP die alle
pakketten die aan de regel voldoen zullen wegsmijten zonder dit mede te delen 
aan de bronpc die het pakket verstuurt heeft.
</p>

<p>
Probeer nu <c>ping localhost</c> uit te voeren. Je zal zien dat je geen
antwoord zal verkrijgen aangezien de firewall alle ICMP-pakketten weigert die
toekomen op de pc. Je zal tevens geen andere pc's kunnen pingen aangezien de
ICMP antwoorden ook geweigerd worden. Laten we nu alle regels verwijderen om
ICMP weer toe te laten:
</p>

<pre caption="Flushen van iptables-rules">
# <i>iptables -F</i>
</pre>

<p>
Laten we nu eens kijken naar het stateful deel in iptables. Indien we een
stateful inspectie van de pakketten wensen die toekomen op eth0 kunnen we dit
als volgt uitvoeren:
</p>

<pre caption="Toelaten van pakketten die al tot een bestaande connectie
behoren">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Dit zal alle pakketten, die tot een al bestaande connectie behoren, of die
voldoen aan de INPUT keten, doorlaten. Je kan alle pakketten die niet in de
state tabel zitten weigeren door <c>iptables -A INPUT -i eth0 -n state --state
INVALID -j DROP</c> uit te voeren juist voor bovenstaande regel. Dit zal ervoor
zorgen dat de stateful deel in iptables geactiveerd wordt door de extension
state te laden. Indien je een connectie van buitenuit wil toelaten tot je pc
kan je <c>--state NEW</c> gebruiken. Iptables bevat nog enkele andere modules
voor verschillende doeleinden. Onder deze modules zijn:
</p>

<table>
  <tr>
    <th>Module/Regel</th><th>Uitleg</th><th>Uitgebreide opties</th>
  </tr>
  <tr>
    <ti>mac</ti><ti>
	Afhankelijk van het MAC adres van de binnenkomende pakketten regels
	opstellen.</ti><ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti><ti>Stateful inspectie activeren</ti><ti>--state (states zijn ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti><ti>Rate matching limiteren</ti><ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti><ti>Probeert om verschillende eigenschappen van de
	pakketmaker te herkennen</ti><ti>--uid-owner userid --gid-owner groupip
	--pid-owner processid --sid-owner sessoinid</ti>
  </tr>
  <tr>
    <ti>unclean</ti><ti>Verschillende random controles op pakketten.</ti><ti/>
  </tr>
</table>

<p>
Laten we een zelfgedefinieerde keten maken en deze toepassen op een
van de bestaande ketens:
</p>

<pre caption="Aanmaken van een gebruiker-gedefinieerde keten">
<comment>(Maak een nieuwe keten met 1 regel)</comment>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(Het default beleid is dat alle uitgaande traffiek toegelaten wordt.
Inkomende wordt echter geweigerd.)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(Voeg ze toe aan de INPUT keten)</comment>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
Door de regel toe te passen op de INPUT keten krijgen we het volgende beleid:
alles wordt toegelaten wat uitgaand is, en enkel inkomende pakketten die tot
een bestaande connectie behoren worden toegelaten. Dit is eigenlijk algemeen
gezien een slecht idee. Een beleid zou eigenlijk alles moeten weigeren en dan 
expliciet enkele zaken toelaten, maar dit is gewoon een voorbeeld.
</p>

<p>
Indien je meer informatie wenst, kijk dan naar <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">iptables
documentatie</uri> (Engels).
</p>

<p>
Laten we een volledig voorbeeld bekijken. Dit voorbeeld zijn mijn
firewall/gateway instellingen:
</p>

<ul>
  <li>Connecties naar de firewall zijn enkel toegelaten via SSH (poort 22)</li>
  <li>Het lokale netwerk heeft toegang tot HTTP, HTTPS en SSH (en DNS
natuurlijk ook)</li>
  <li>ICMP traffiek kan teveel informatie bevatten en wordt dus niet
  toegelaten. Natuurlijk moet er wel een beetje ICMP-traffiek mogelijk
  zijn.</li>
  <li>Portscans moeten gedetecteerd en gelogged worden</li>
  <li>SYN aanvallen dienen vermeden te worden</li>
  <li>Alle andere traffiek dient geweigerd en gelogged te worden</li>
</ul>
  

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#binnenin
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#buiten
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default regel
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffiek
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Inkomende traffiek
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood beveiliging
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -p tcp --dport ssh -j ACCEPT

  #Uitgaande traffiek
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Portscanners tegenhouden
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Pas toe en voeg ongeldige states toe aan de ketens
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # Laat clients toe om via NAT te werken
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<note>
Ik gebruik \ in sommige regels voor betere leesbaarheid. Het is misschien een
goed idee om de regels samen te voegen in de werkelijke configuratie. 
</note>

<p>
Gratis advies voor het aanmaken van firewalls:
</p>

<ol>
  <li>Maak je firewallsbeleid alvorens je die implementeert.</li>
  <li>Hou het simpel</li>
  <li>Weet hoe het protocol werkt (lees de <uri link="http://www.ietf.org">RFCs</uri>)</li>
  <li>Hou in gedachten dat een firewall gewoon een stuk software is dat als
  root draait.</li>
  <li>Test je firewall</li>
</ol>

<p>
Indien je denkt dat iptables moeilijk te verstaan is, of veel tijd inneemt om
op te stellen, maak dan gebruik van <uri
link="http://www.shorewall.net">Shorewall</uri>. Dit is een front-end van
iptables.
</p>

</body>
</section>

<section>
<title>Squid</title>
<body>

<p>
Squid is een zeer sterke proxyserver en kan traffiek filteren en weigeren 
gebaseerd op: tijd, reguliere expressies van paden/uri's, bron en doeladressen,
domeinen, browser, geidentificeerde gebruiker, mime-type, poort (protocol).
En waarschijnlijk heb ik nog enkele features vergeten, maar squid is dan ook
enorm uitgebreid.
</p> 

<p>
In het volgende voorbeeld heb ik een bannerfilter geplaatst in plaats van een
filter die gebaseerd is op pornosites. De reden hiertoe is dat Gentoo.org
<c>niet</c> als pornosite mag gezien worden. En ik wil tevens mijn tijd niet
verdoen om enkele goede pornosites voor jou op te zoeken :)
</p>

<p>
In bovenstaand geval:
</p>

<ul>
  <li>Surfen (HTTP/HTTPS) wordt toegelaten tijdens werkuren (maandag tot
vrijdag van 08 tot 17, en zaterdag van 08 tot 13 uur). Als ze hier extra lang
blijven moeten ze werken. Niet surfen.</li>
  <li>Downloaden is niet toegestaan (.exe, .com, .arj, .zip, .asf, .avi, .mpg,
.mpeg etc...)</li>
  <li>We haten banners dus filteren we die uit en vervangen we ze met een
  transparante gif (hier kan je nog wel leukere zaken bedenken :)</li>
  <li>Elke andere connectie van en naar het internet wordt niet toegestaan</li>
</ul>

<p>
Dit wordt in 4 gemakkelijke stappen geimplementeerd:
</p>

<pre caption="/etc/squid/squid.conf">
# Binden aan een ip en poort
http_port 10.0.2.1:3128

# Default configuratie
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# ACLs toevoegen
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Wie deze proxyserver kan gebruiken
acl localnet src 10.0.0.0/255.255.0.0

# Welke poorten er toegelaten zijn
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# ACL gebaseerd op regexps
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# ACL gebaseerd op tijden/datums
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#Beheer enkel via localhost
http_access allow manager localhost
http_access deny manager

#Purge aanvragen enkel via localhost
http_access allow purge localhost
http_access deny purge

# Onbekende poorten weigeren
http_access deny !Safe_ports

# Alle poorten behalve SSL moeten niet naartoe geconnecteerd worden
http_access deny CONNECT !SSL_ports

# En nog wat enkele persoonlijke regels...

# Pagina bij banner 
deny_info NOTE_ADS_FILTERED url_ads

# En die bannerurl's dan verwijderen
http_access deny url_ads

# Alle archieven weigeren
http_access deny archives

# Enkel toegang tijdens werkuren
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Al de rest weigeren
http_access deny all
</pre>

<p>
Vul nu de bestandsextensies in waarvan je niet wenst dat de gebruikers die
kunnen downloaden.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
Merk op dat tussen [] er telkens een hoofdletter en een kleine letter voorkomt.
Dit is omdat men anders wel .AVI bestanden kan downloaden maar geen .avi...
</note>

<p>
Hierna voegen we enkele reguliere expressies toe om banners te identificeren.
Je bent zelf waarschijnlijk iets creatiever dan ik hier:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
En het laatste deel. We willen dat dit bestand getoond wordt wanneer er een
banner verwijderd is. Het is niet meer dan een stukje HTML-code die een
transparante 4x4 gif toont.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
Sluit de &lt;HTML&gt; en &lt;BODY&gt; tags niet. Dit wordt vanzelf gedaan door
squid.
</note>

<p>
Zoals je kan zien heeft squid veel mogelijkheden en is ze zeer efficient in
zowel het filteren als het proxy'en. Ze kan tevens alternatieve squid proxies
aanspreken om op grote netwerken flexibel te werken. De configuratie die ik
hier getoond heb is meer gemaakt voor kleine netwerken met 1 tot 20 gebruikers.
</p>

<p>
Het combineren van een packet filter (iptables) met een application gateway
(squid) is waarschijnlijk de beste oplossing, zelfs wanneer squid ergens veilig
geplaatst is waar niemand er toegang tot heeft van buitenaf. We moeten immers
steeds behoed zijn tegen aanvallen van binnenuit!
</p>

<p>
Stel je browsers in om de proxyserver te gebruiken. De gateway zal ervoor
zorgen dat gebruikers enkel toegang hebben tot de buitenwereld via de proxy. Ze
kunnen dus niet naar buiten als ze de proxy niet instellen op hun browser.
</p>

<note>
In Mozilla doe je dit via Edit-&gt;Preferences-&gt;Advanced-&gt;Proxies
</note>

<p>
Het kan tevens goed zijn om alles transparant te laten gebeuren door iptables
alle traffiek te laten forwarden naar een squid proxyserver. Dit kan
gemakkelijk gebeuren door de volgende regels op de gateway te implementeren:
</p>

<pre caption="Portforwarding van de pakketten naar je proxyserver">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>

<section>
<title>Wat hebben we geleerd?</title>

<body>

<p>
We hebben geleerd dat:
</p>

<ol>
  <li>Een firewall een risico op zich is. Een slecht geconfigureerde firewall
  is slechter dan geen firewall.</li>
  <li>Hoe moeten we een gateway en transparante proxy configureren</li>
  <li>De sleutel tot een goede firewall is het kennen van het protocol dat je
  wil toelaten</li>
  <li>IP traffiek bevat niet altijd correcte informatie. Als voorbeeld denk je
  maar aan ICMP pakketten.</li>
  <li>Hoe houden we SYN aanvallen tegen</li>
  <li>Filteren van HTTP traffiek door aanstootnemende fotos en downloaden van
  virussen te elimineren</li>
  <li>Combineren van packet filters en application gateways geven betere
  controle over het netwerkgebruik</li>
</ol>

<p>
Dus, als je <b>werkelijk</b> een firewall nodig hebt, begin er dan maar aan.
</p>

</body>
</section>

</chapter>

<!-- Intrusion detection start -->

<chapter>
<title>Intrusion detection</title>

<section>
<title>Aide (Advanced Intrusion Detection Environment)</title>
<body>

<p>
Aide is een hostgebaseerde IDS (vrij alternatief voor Tripwire). Indien je
Tripwire kent dan zou je geen moeilijkheden mogen hebben met de configuratie
van Aide.
</p>

<p>
Het configuratiebestand is gebaseerd op reguliere expressies, macros en regels
voor bestanden en directories. We hebben de volgende macro's:
</p>

<table>
  <tr>
    <th>Macro</th><th>Uitleg</th><th>Syntax</th>
  </tr>
  <tr>
    <ti>ifdef</ti><ti>Indien gedefinieerd</ti><ti>@@ifdef "name"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti><ti>Indien niet gedefinieerd</ti><ti>@@ifndef "name"</ti>
  </tr>
  <tr>
    <ti>define</ti><ti>Definieer een variabele</ti><ti>@@define "name" "value"</ti>
  </tr>
  <tr>
    <ti>undef</ti><ti>Undefinieer een variabele</ti><ti>@@undef "name"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti><ti>Indien &quot;hostname&quot;</ti><ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti><ti>Indien niet &quot;hostname&quot;</ti><ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
    <ti>endif</ti><ti>Endif moet gebruikt worden na alle macro's behalve define
	en undef</ti><ti>@@endif</ti>
  </tr>
</table>

<p>
Deze macro's zijn zeer handig indien je meer dan 1 Gentoo pc hebt en je wil
Aide op alle pc's gebruiken. Niet alle machines bevatten immers dezelfde
services of dezelfde gebruikers.
</p>

<p>
Vervolgens hebben we een verzameling van eigenschappen van bestanden of
directories waarop we controleren. Dit zijn een combinatie van permissies,
bestandseigenschappen en cryptografische hashes of checksums.
</p>

<table>
  <tr>
    <th>Flag</th><th>Uitleg</th>
  </tr>
  <tr>
    <ti>p</ti><ti>permissies</ti>
  </tr>
  <tr>
    <ti>i</ti><ti>inode</ti>
  </tr>
  <tr>
    <ti>n</ti><ti>aantal links</ti>
  </tr>
  <tr>
    <ti>u</ti><ti>gebruiker</ti>
  </tr>
  <tr>
    <ti>g</ti><ti>groep</ti>
  </tr>
  <tr>
    <ti>s</ti><ti>grootte</ti>
  </tr>
  <tr>
    <ti>b</ti><ti>hoeveelheid blokken</ti>
  </tr>
  <tr>
    <ti>m</ti><ti>mtime</ti>
  </tr>
  <tr>
    <ti>a</ti><ti>atime</ti>
  </tr>
  <tr>
    <ti>c</ti><ti>ctime</ti>
  </tr>
  <tr>
    <ti>S</ti><ti>controleer op groeiende grootte</ti>
  </tr>
  <tr>
    <ti>md5</ti><ti>md5 checksum</ti>
  </tr>
  <tr>
    <ti>sha1</ti><ti>sha1 checksum</ti>
  </tr>
  <tr>
    <ti>rmd160</ti><ti>rmd160 checksum</ti>
  </tr>
  <tr>
    <ti>tiger</ti><ti>tiger checksum</ti>
  </tr>
  <tr>
    <ti>R</ti><ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
    <ti>L</ti><ti>p+i+n+u+g</ti>
  </tr>
  <tr>
    <ti>E</ti><ti>Lege groep</ti>
  </tr>
  <tr>
    <ti>&gt;</ti><ti>Groeiende logbestand p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
En indien Aide gecompileerd is met mhash ondersteuning heeft het nog enkele
andere mogelijkheden:
</p>

<table>
  <tr>
    <th>Flag</th><th>Uitleg</th>
  </tr>
  <tr>
    <ti>haval</ti><ti>haval checksum</ti>
  </tr>
  <tr>
    <ti>gost</ti><ti>gost checksum</ti>
  </tr>
  <tr>
    <ti>crc32</ti><ti>crc32 checksum</ti>
  </tr>
</table>

<p>
Nu kan je je eigen regels aanmaken gebaseerd op bovenstaande vlaggen door deze
als volgt te combineren:
</p>

<pre caption="Instellen van AIDE-regel">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Het laatste wat we nu moeten doen is kijken hoe je regels toevoegt voor een
bestand of directorie. Eenvoudig gezegd geef je gewoon de bestandsnaam of
directorie naam in en dan de regel. Aide zal dan alle bestanden recursief
toevoegen tenzij je iets anders specifieert:
</p>

<table>
  <tr>
    <th>Flag</th><th>Uitleg</th>
  </tr>
  <tr>
    <ti>!</ti><ti>Voeg dit bestand of directorie niet toe</ti>
  </tr>
  <tr>
    <ti>=</ti><ti>Voeg deze directorie toe, maar niet recursief</ti>
  </tr>
</table>

<p>
Laten we eens een volledig voorbeeld beschouwen:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# De locatie van de database waarvan gelezen moet worden
database=file:@@{AIDEDIR}/aide.db

# De locatie van de database waarnaartoe geschreven moet worden
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Regel definities
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
In bovenstaand voorbeeld specifieren we enkele macro's alsook waar de
hoofddirectorie is en waar de aide-directorie is. Aide controleert
<path>/etc/aide/aide.db</path> voor de bestandsintegriteit. Maar wanneer er
geupdate moet worden of wanneer een nieuw bestand aangemaakt wordt wordt deze
opgeslagen in <path>/etc/aide/aide.db.new</path>. Dit is omdat het eerste
db-bestand niet zou overschreven worden. De optionele report_URL is een
&quot;nog te implementeren&quot; feature dat nu nog geen resultaat geeft, maar
de bedoeling is dat er in de toekomst de URL komt van een e-mailadres of van
een script waarnaartoe gemaild kan worden of welke uitgevoerd kan worden.
</p>

<p>
Na de configuratie moet je je eigen db-bestand aanmaken door <c>aide -i</c> uit
te voeren, en dan het bestand <path>/etc/aide/aide.db.new</path> naar
<path>/etc/aide/aide.db</path> te kopieren. Daarna voeg je de controle toe aan
cron door <c>crontab -e</c> als root uit te voeren.
</p>

<note>
Afhankelijk van je CPU en de vlaggen die gebruikt hebt kan de controle 
een tijdje duren.
</note>

<pre caption="aide -u als een cronjob instellen">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
Herinner je eraan om je mailserver te configureren zodat je de root's
mail krijgt. Anders zal je nooit Aides rapporten ontvangen.
</note>

<p>
In bovenstaand geval wordt aide om 3am uitgevoerd. Dit is omdat ik niet de
gebruikers wil lastig vallen wanneer deze werken. Ik gebruik tevens de
<c>-u</c> (Update) optie in plaats van de <c>-C</c> (Check). De reden daartoe
is dat <c>-u</c> de bestanden controleert en niet de originele database
overschrijft waardoor je tijd wint aangezien het enige wat je moet doen 
wanneer een bestand veranderd is is het aidebestand kopieren. Controleer 
gewoon de aanpassingen om te zien of jij het wel bent die de verandering heeft
doorgevoerd in plaats van een hacker alvorens je aide aanpast aan de nieuwe
situatie.
</p>

<p>
Nu is er een probleem met het opslaan van de database op je bestandssysteem
aangezien de hacker (als hij weet dat aide geinstalleerd is) waarschijnlijk zal
proberen om de db-bestanden aan te passen of te verwijderen. Dus is het
belangrijk dat deze bestanden op een CD of een ander medium staan (origineel of
als kopie) alsook de aide binaire bestanden (want die kan een hacker ook
aanpassen). Dus maak je best een CD of een ander medium en maak je het best een
kopie van de .db bestanden en de aide binaire bestanden.
</p>

<p>
Meer informatie vind je op <uri
link="http://www.cs.tut.fi/~rammer/aide.html">aide's</uri> projectpagina
(Engels).

</p>

</body>
</section>

<section>
<title>Snort</title>
<body>

<pre caption="Aanmaken van de gebruiker snort">
# user add snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CO NF=/etc/snort/snort.Cong
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>(Stap 1)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(Stap 2)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace 
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(Stap 3)</comment>
include classification.config

<comment>(Stap 4)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# Nieuwe classificaties
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Meer informatie kan je vinden op <uri link="http://www.snort.org">Snorts</uri>
website (Engels).

</p>

</body>
</section>

</chapter>

<!-- Intrusion detection einde -->

<chapter>
<title>Changelog</title>
<section>
<title>Aanpassingen</title>
<body>

<p>
Versie 0.1 -> 0.2
</p>
<ul>
  <li>Verschillende typefouten</li>
  <li>Aanpassingen aan apache.conf</li>
  <li>Problemen met pre-tags van meer dan 80 karakters oplossen</li>
  <li>Firewall hoofdstuk toegevoegd</li>
</ul>

<p>
Versie 0.2 -> 0.4
</p>
<ul>
  <li>IDS toegevoegd</li>
  <li>Fout in firewallscript opgelost</li>
</ul>

</body>
</section>
</chapter>



<chapter>
<title>FAQ</title>

<section>
<title>Vragen en antwoorden</title>
<body>

<table>
  <tr>
    <th>Vraag</th><th>Antwoord</th>
  </tr>
  <tr>
    <ti>
	Waar kan ik de laatste versie vinden van dit document?</ti>
	<ti>De laatste versie is beschikbaar op <uri>http://www.gentoo.org</uri>.
	De laatste kladversie is op <uri>http://gentoo.insecurity.dk</uri></ti>
  </tr>
</table>

</body>
</section>
</chapter>


</guide>
