<?xml version='1.0' encoding="UTF-8"?>

<!-- 
    Rev 1.3
-->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/nl/rc-scripts.xml">
<title>Gentoo Linux 1.0 Init Systeem</title>
<author title="Author">
   <mail link="azarah@gentoo.org">Martin Schlemmer</mail>
</author>
<author title="Proof-reader">
   <mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Translator">
   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>

<abstract>
Deze handleiding is een introductie tot Gentoo Linux' Init systeem,
en beschrijft tevens enkele zaken ivm met schrijven van rc-scripts.
</abstract>

<version>1.0.2</version>
<date>13 Maart 2003</date>

<chapter>
<title>Inleiding</title>
<section>
<body>

<p>
Gentoo Linux gebruikt een initsysteem dat vooral gecontroleerd wordt door
afhankelijkheden (<e>dependencies</e>). Ze is eenvoudig in onderhoud, maar 
toch krachtig en flexibel genoeg voor eender welke opstelling.
Deze handleiding mag niet beschouwd worden als een introductie tot de interne
werking van het systeem; eerder is deze een snelle handleiding over hoe je het
Gentoo's initsysteem klaar en draaiende krijgt.
Voor diegenen die geinteresseerd zijn in de interne werking: lees de broncode
:)
</p>

</body>
</section>
</chapter>

<chapter>
<title>Runlevels</title>
<section>
<body>

<p>
In tegenstelling tot andere initsystemen maakt Gentoo's initsysteem geen
gebruik van vreemde namen of nummers, maar eerder van eigengedefinieerde namen
die vertaald worden naar de standaard runlevelnummers van init.
</p>

<note>
Per default zijn er 3 runlevels, namelijk <e>&quot;boot&quot;</e>,
<e>&quot;default&quot;</e> en <e>&quot;nonetwork&quot;</e>.
</note>

<p>
De <e>&quot;boot&quot;</e> runlevel is default bij de meeste configuraties, en 
zoals de naam al laat vermoeden is het deze runlevel die uitgevoerd wordt 
tijdens het booten. De volgende is <e>&quot;default&quot;</e> die, zoals de 
naam al laat vermoeden, uitgevoerd wordt na de boot-runlevel. De laatste is
<e>&quot;nonetwork&quot;</e> die eigenlijk puur een voorbeeldrol speelt.
</p>

<p>
De runlevels bevinden zich in <path>/etc/runlevels</path>, in een submap
genoemd naar de runlevel; deze submap is gevuld met symlinks naar services die
door de runlevel opgestart worden.
</p>

<note>
De aangeraden manier om services toe te voegen of te verwijderen staat in de
sectie &quot;Utilities / help-scripts&quot;.
</note>

<p>
Zoals al eerder werd vermeld kan de naam van de runlevel aangepast worden naar
eender welke term de gebruiker wenst, maar men mag niet vergeten
<path>/etc/inittab</path> mee te wijzigen om de aanpassing door te voeren.
</p>

<warn>
Een uitzondering is de <e>&quot;boot&quot;</e> runlevel die NOOIT mag hernoemd
worden, aangezien dat leidt tot defecte werking van je systeem.
</warn>

<p>
De <path>/sbin/rc</path> script leidt al dit in goede banen, en kan uitgevoerd 
worden om direct tussen verschillende virtuele runlevels te switchen.
</p>

</body>
</section>

<section>
<title>Virtuele runlevels</title>
<body>

<p>
Aangezien de runlevels niet statisch gemapped worden aan deze van init kan je
meer runlevels aanmaken dan dat er nummers bij init voorhanden zijn.
Hierdoor kan de gebruiker profielen of virtuele runlevels aanmaken afhankelijk
van de situatie.
</p>

<p>
Bijvoorbeeld, een laptop gebruiker kan 2 default runlevels hebben, genaamd
&quot;online&quot; en &quot;offline&quot;. Hierdoor kan men een actieve
runlevel hebben voor wanneer de PCMCIA netwerkkaart ingeplugged is, en een 
voor wanneer deze netwerkkaart niet ingeplugged is. De PCMCIA-scripts kunnen 
geconfigureerd worden om, afhankelijk van de situatie, 
<c>&quot;/sbin/rc online&quot;</c> respectievelijk 
<c>&quot;/sbin/rc offline&quot;</c> uit te voeren, dit om de correcte services
te laden afhankelijk van de aanwezigheid van de netwerkkaart.
</p>

</body>
</section>

<section>
<title>Runlevels en XFree86</title>
<body>

<p>
Gentoo heeft geen aparte runlevel expliciet voor het grafisch opstarten, maar 
enkel een rc-script (initscript) die dat toelaat. Deze heet, zoals bij de 
meeste andere distributies, &quot;xdm&quot; en kan aan eender welke runlevel 
toegevoegd worden indien de gebruiker dat wenst.
</p>

<warn>
&quot;xdm&quot; toevoegen aan de boot runlevel kan resulteren in
ongewenste werking van het systeem!
</warn>

<p>
Per default, als je xdm, gdm of kdm wilt uitvoeren alvorens de gettys gestart
worden, zal X starten op de eerste vrije console. Bij tragere machines is dit
geen probleem indien de Desktop Manager service pas op het einde van de
bootsequentie opgestart wordt. De gettys zullen starten voordat X start
en deze laatste zal zich dus binden aan console 7 zoals gewenst.
Bij snellere machines is dit echter niet het geval. X zal starten alvorens de
gettys gestart zijn (gewoonlijk op console 2). Wanneer de gettys starten, nemen
deze de controle over van het keyboard en verliest de Desktop Manager
keyboardondersteuning.
</p>

<p>
Dit kan opgelost worden door de Desktop Managers' opstartscript in een 
extra runlevel te plaatsen, namelijk 'a'. Aangezien 'a' geen echte runlevel
is dient onze &quot;xdm&quot; script enkel <c>&quot;telinit a&quot;</c> op te
starten. Hierdoor zullen alle services in runlevel 'a' uitgevoerd worden
<i>nadat</i> de services in de huidige runlevel uitgevoerd zijn, dus wanneer
alle gettys opgestart zijn.
</p>

<note>
Meer informatie over runlevel 'a' krijg je door init's manpage te
lezen.
</note>

</body>
</section>
</chapter>

<chapter>
<title>RC-Scripts</title>
<section>
<body>

<p>
rc-scripts zijn scripts die de basis-functies van elke service definieren,
inclusief afhankelijkheden voor opstarten en afsluiten. Ze bevinden zich in
<path>/etc/init.d</path>
</p>

</body>
</section>

<section>
<title>Basis layout van een rc-script</title>
   
<body>
<pre caption="rc-script layout">
#!/sbin/runscript
 
depend() {
    need bar
}
 
start() {
    ebegin &quot;Starting foo&quot;
    /sbin/foo
    eend $? &quot;Failed to start foo&quot;
}
 
stop() {
    ebegin &quot;Stopping foo&quot;
    kill $(cat /var/run/foo.pid)
    eend $? &quot;Failed to stop foo&quot;
}
</pre>

<note>
De interpreter is &quot;/sbin/runscript&quot;. De &quot;depend&quot;
functie is optioneel. Alle rc-scripts moeten minstens de &quot;start&quot;
functie hebben.
</note>

</body>
</section>

<section>
<title>Opstarten controleren</title>
<body>

<p>
De algemene opstartvolgorde van de services in een runlevel is alfabetisch. Dit
komt wegens de output van <path>/bin/ls</path>.
</p>

<p>
De eerste methode om van de default opstartvolgorde af te wijken zijn
afhankelijkheden. Indien er geen relatie is tussen services kan het order-type
gebruikt worden.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Dependency types</title>
<section>
<body>

<p>
De meeste services zijn gerelateerd of hangen af van een andere service.
</p>

<p>
Postfix bijvoorbeeld vereist een draaiende &quot;network&quot;, alsook een 
system logger.
</p>

<p>
Samba aan de andere hand vereist dat &quot;network&quot; draaiende is, maar
indien CUPS gebruikt wordt voor het printen moet deze opgestart worden voordat
samba gestart wordt. Merk echter op dat cups niet expliciet noodzakelijk is
voor het opstarten van samba.
</p>

<p>
We hebben dus 2 manieren om afhankelijkheidsrelaties (<e>dependencies</e>)
tussen verschillende services uit te drukken. Deze afhankelijkheden zijn altijd
geldig, ook al is de runlevel compleet aangepast of een service manueel 
gestart/gestopt na het booten.
</p>

</body>
</section>

<section>
<title>De NEED afhankelijkheid (dependency)</title>
<body>

<p>
Deze wordt gebruikt indien een service noodzakelijk is voor het opstarten van
de huidige service.
</p>

<pre caption="Toevoegen van logger en net als een NEED afhankelijkheid">
depend() {
    need net logger
}
</pre>

<note>De service vermeld na <e>NEED</e> is noodzakelijk voor het opstarten van
de service. Deze service zal dus niet opstarten indien een van zijn
NEED-afhankelijkheden niet opstart.
</note>

<impo>
Indien een service aan een <e>NEED</e>-regel is toegevoegd zal deze opgestart
worden, onafhankelijk van het feit of deze service in de huidige runlevel (of
in de &quot;boot&quot; runlevel) gedefinieerd is of niet.
</impo>

<p>
<e>NEED</e> is dus een &quot;dominante&quot; afhankelijkheid.
</p>

</body>
</section>

<section>
<title>De USE afhankelijkheid</title>
<body>

<p>
De service die door de use-afhankelijkheid vermeld wordt is niet noodzakelijk 
voor het opstarten van de huidige service, maar indien ze opgestart wordt moet 
dat voordien gebeuren.
</p>

<pre caption="Toevoegen van portmap als een USE afhankelijkheid aan netmount">
depend() {
    use portmap
}
</pre>

<p>
Netmount kan per default gebruik maken van NFS mounts, maar zal enkel afhangen
van portmap indien deze toegevoegd is aan de huidige runlevel (of de
&quot;boot&quot;-runlevel). Indien je dus wenst dat NFS-mounts ondersteund
worden moet je dus portmap toevoegen aan de default runlevel, zodat netmount
portmap ziet als een afhankelijkheid en deze dus eerder laat opstarten.
</p>

<impo>
Een service in de <e>USE</e> regel <e>moet</e> toegevoegd worden aan de
huidige runlevel (of de boot runlevel) opdat deze als een geldige
afhankelijkheid gezien wordt.
</impo>

<p>
<e>USE</e> is dus een &quot;voorbehouden&quot; afhankelijkheid.
</p>

<note>
Indien een service in een <e>USE</e> regel niet foutloos start, zal de huidige
service toch starten, aangezien de service in de <e>USE</e> regel niet
noodzakelijk is.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Zonder afhankelijkheden toch de volgorde controleren</title>
<section>
<body>

<p>
Indien geen afhankelijkheidsrelatie bestaat tussen 2 services, maar het gewenst
is dat de ene voor de andere opstart, dan kan men gebruik maken van de
<e>AFTER</e> en de <e>BEFORE</e> afhankelijkheden.
</p>

<note>
Deze 2 types zijn enkel geldig tussen verschillende runlevels.
</note>

<p>
Optioneel kan men gebruik maken van de &quot;*&quot; glob voor het aanduiden
van alle andere services:
</p>

<pre caption="Een glob example voor AFTER in de local-initscript">
depend() {
    after *
}
</pre>

<p>
Dit zorgt ervoor dat local gestart wordt <e>na</e> alle andere services.
</p>

</body>
</section>

<section>
<title>De BEFORE volgorde-variabele</title>
<body>

<p>
De huidige service moet gestart worden <e>voor</e> de services vermeld in de 
<e>BEFORE</e> regel.
</p>

<pre caption="Zorgt ervoor dat foo start voor bar (in foo-initscript)">
depend() {
   before bar
}
</pre>

</body>
</section>

<section>
<title>De AFTER volgorde-variabele</title>
<body>

<p>
De huidige service moet gestart worden <e>na</e> de services vermeld in de 
<e>AFTER</e> regel.
</p>

<pre caption="Zorgt ervoor dat bar start na foo (in bar-initscript)">
depend() {
    after foo
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Virtuele services</title>
<section>
<body>

<p>
Services, zoals de meeste andere zaken in de Unix-wereld van vandaag, komen in
verschillende smaken en kleuren. Het is meestal de keuze van de
systeembeheerder die beslist welke servicetool er gebruikt wordt.
</p>

<p>
System loggers zijn een van die voorbeelden. Op het moment van schrijven bevat
Gentoo Linux een 4-tal verschillende system loggers waaruit de gebruikers
kunnen kiezen. Alle services die een system logger vereisen voordat ze zelf
opstarten kunnen onmogelijk alle 4 de loggers in de <e>NEED</e> steken. Maar
<e>USE</e> is te zwak aangezien een werkende system logger noodzakelijk is.
</p>

<p>
Dit is waar virtuele services en de <e>PROVIDE</e> types hun intrede doen.
</p>

</body>
</section>

<section>
<title>Het PROVIDE type</title>
<body>

<p>
Het <e>PROVIDE</e> type definieert een virtuele service die andere services
kunnen <e>NEED</e>'en of <e>USE</e>'en.
</p>

<pre caption="sysklogd die logger PROVIDEs">
depend() {
    provide logger
}
</pre>

</body>
</section>

<section>
<title>De LOGGER virtuele service</title>
<body>

<p>
<e>LOGGER</e> is een voorgedefinieerde virtuele service die door alle system
loggers gecreeerd wordt. Ze kan gebruikt worden met <e>NEED</e> of <e>USE</e>
afhankelijkheidstypes.
</p>

</body>
</section>

<section>
<title>De NET virtuele service</title>
<body>

<p>
De <e>NET</e> service is een andere virtuele service, maar in tegenstelling tot
<e>LOGGER</e> omvat het niet 1 expliciete service.
</p>

<impo>
Om de <e>NET</e> virtuele service te voorzien (PROVIDE) moet:
<ul>
<li>de service toegevoegd worden aan de huidige of de boot runlevel.</li>
<li>zijn naam beginnen met &quot;net.&quot;.</li>
<li>zijn naam eindigen met de naam van een bestaande netwerk-interface
(bijvoorbeeld net.eth0 of net.ppp1).</li>
</ul>
</impo>

<p>
Voor elke net.* service zal $IFACE gedefinieerd zijn met de naam van
de netwerkinterface (bijvoorbeeld &quot;eth0&quot; voor net.eth0).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Default commandoregelopties</title>
<section>
<body>

<p>
Elke service kan opgeroepen worden met een van de default opties. Alle vermelde
opties zijn automatisch beschikbaar, behalve <e>START</e> en <e>STOP</e> die de
gebruiker zelf moet definieren in zijn rc-script.
</p>

<impo>
De <e>start()</e> functie <e>moet</e> gedefinieerd zijn.
</impo>

<note>
De <e>stop()</e> functie is minder belangrijk en kan worden
weggelaten.
</note>


<note>
In het algemeen zal de gebruiker enkel <e>start()</e>, <e>stop()</e> en
<e>restart()</e> definieren. De rest is intern en dient met rust gelaten te
worden.
</note>

<pre caption="start de httpd service">
# <c>/etc/init.d/httpd start</c>
</pre>

<note>Commandoregelopties kunnen gemengd voorkomen.</note>

<pre caption="pause/start net.eth0">
# <c>/etc/init.d/net.eth0 pause start</c>
</pre>

</body>
</section>

<section>
<title>De START/STOP opties</title>
<body>

<p>
<e>START</e> de service inclusief de services waarvan deze afhangt.
</p>

<p>
<e>STOP</e> de service inclusief de services die ervan afhangen.
</p>

</body>
</section>

<section>
<title>De RESTART optie</title>
<body>

<p>
De service moet gestart zijn alvorens dat <e>RESTART</e> zal werken. Het zal de
service herstarten alsook alle services die ervan afhangen.
</p>

<note>
Indien een eigen <e>restart()</e> functie gedefinieerd is moet de
gebruiker <e>&quot;svc_start()&quot;</e> en <e>&quot;svc_stop()&quot;</e>
gebruiken om de service te starten respectievelijk te stoppen. Dit is
noodzakelijk om de afhankelijkheden correct te doen verlopen.
</note>

</body>
</section>

<section>
<title>De PAUSE optie</title>
<body>

<p>
Deze zal de service stoppen, maar in tegenstelling tot <e>STOP</e> zullen de
services die ervan afhangen met rust gelaten worden.
</p>

</body>
</section>

<section>
<title>De ZAP optie</title>
<body>

<p>
Deze zet de status van de service naar &quot;gestopped&quot;.
</p>

<note>
Merk op dat geen enkel van de commando's in de <e>stop()</e> functie
uitgevoerd worden. De gebruiker zal er dus zelf voor moeten zorgen dat de
service-daemons etc... gestopt zijn (bijvoorbeeld dmv killall).
</note>

</body>
</section>

<section>
<title>De INEED/NEEDSME opties</title>
<body>

<p>
<e>INEED</e> geeft de services weer die deze service in zijn <e>NEED</e> regel 
staan heeft.
</p>

<p>
<e>NEEDSME</e> geeft de services weer die deze service in hun <e>NEED</e> regel
staan hebben.
</p>

</body>
</section>

<section>
<title>De IUSE/USESME opties</title>
<body>

<p>
<e>IUSE</e> geeft de services weer die deze service in zijn <e>USE</e> regel 
staan heeft.
</p>

<p>
<e>USESME</e> geeft de services weer die deze service in hun <e>USE</e> regel 
staan hebben.
</p>

</body>
</section>

<section>
<title>De BROKEN optie</title>
<body>

<p>
Deze toont de services die vermist zijn (indien van toepassing) en die wel
in de <e>NEED</e> regel staan vermeld.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Eigen commandoregelopties toevoegen</title>
<section>
<body>

<p>
Het is relatief gemakkelijk om eigen commandoregelopties toe te voegen. Een
functie met als naam de gewenste commandoregeloptie dient te worden
gedefinieerd in de rc-script, en moet toegevoegd worden aan de <e>$opts</e> 
variabele, zoals in het onderstaande voorbeeld:
</p>

<pre caption="foo als een eigen optie">
opts=&quot;${opts} foo&quot;
 
foo() {
    ............
}
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configuratie</title>
<section>
<body>

<p>
Configuratie van rc-scripts dient algemeen te gebeuren via
omgevingsvariabelen. Deze mogen echter niet in de rc-script gedefinieerd
worden, maar in een van de 3 mogelijke configuratiebestanden.
</p>

<p>
De eerste is specifiek aan het rc-script, de andere zijn 2
globale configuratiebestanden.
</p>

<pre caption="configuratiebestanden voor rc-scripts">
<path>/etc/conf.d/&lt;naam van rc-script&gt;</path>
<path>/etc/conf.d/basic</path>
<path>/etc/rc.conf</path>
</pre>

<note>
Deze 3 configuratiebestanden worden automatisch ingelezen in diezelfde
volgorde.
</note>

<impo>
De <e>NET</e> services lezen tevens <path>/etc/conf.d/net</path>
in.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Utilities / help-scripts</title>

<section>
<title>Het rc-update tool</title>
<body>

<p>
rc-update is de primaire tool om services toe te voegen aan en te verwijderen 
uit een runlevel. Deze zal tevens &quot;depscan.sh&quot; uitvoeren om de
afhankelijkheidsinformatie te vernieuwen.
</p>

<pre caption="Voeg metalog toe aan de default runlevel">
# <c>rc-update add metalog default</c>
</pre>

<pre caption="Verwijder metalog uit de default runlevel">
# <c>rc-update del metalog default</c>
</pre>

<note>
Indien je rc-update zonder argumenten uitvoert krijg je meer informatie.
</note>

</body>
</section>

<section>
<title>Het depscan.sh-script</title>
<body>

<p>
Voor de volledigheid vermelden we hier depscan.sh. Deze wordt gebruikt om een
afhankelijkheidlijst op te stellen die bestaat uit de afhankelijkheden die door
de services vermeld worden.
</p>

<p>
depscan.sh moet uitgevoerd worden telkens er een nieuwe rc-script toegevoegd
wordt aan <path>/etc/init.d</path>, maar aangezien rc-update dat zelf al doet
moeten de meeste gebruikers zich hier niets van aantrekken.
</p>

</body>
</section>
</chapter>
</guide>

