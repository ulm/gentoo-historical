<?xml version='1.0' encoding="utf-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/da/diskless-howto.xml,v 1.6 2004/08/30 20:44:29 broeman Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/da/diskless-howto.xml" lang="da">

<title>Diskfrie noder med Gentoo</title>

<author title="Researcher">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Redaktør">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Reviewer">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Oversætter">
    <mail link="broeman@gentoo.org">Jesper Brodersen</mail>
</author>
<author title="Korrektur">
    <mail link="aaby@gentoo.org">Arne Mejlholm</mail>
</author>
<author title="Korrektur">
    <mail link="broeman@gentoo.org">Jesper Brodersen</mail>
</author>

<abstract>
Denne HOWTO vil hjælpe dig med at opsætte diskfrie noder med Gentoo Linux.
</abstract>

<license/>

<version>1.4</version>
<date>9. Maj, 2003</date>

<chapter>
<title>Introduktion</title>

<section>
<title>Om denne HOWTO</title>
<body>

<p>
Denne HOWTO vil hjælpe dig med sætte <e>diskfrie</e> arbejdsstationer
op, baseret på Gentoo Linux distributionen. Vi prøver at lave det så
brugervenligt som muligt, og sørger for Linux-newbien, fordi alle var
én på et specifikt tidspunkt :) Da en erfaren bruger sagtens kan samle
de mange HOWTOer, som er tilgængelige omkring diskfrie noder og
netværk sammenlagt, håber vi at denne vejledning kan lette
installationen for alle interesserede brugere, nørd eller ej.
</p>

</body>
</section>
<section>
<title>Hvad er en diskfri maskine?</title>
<body>

<p>
En diskfri maskine er en PC, uden nogen af de normale opstartsenheder,
som harddiske, floppydrev eller CDROM-drev. Den diskfrie node starter
via et netværk og skal bruge en server, som kan levere det med
lagerplads, som en lokal harddisk ville gøre. Fra nu af, kalder vi
serveren <e>master</e>, imens vi kalder den diskfrie maskine for
<e>slave</e> (det ligger i navnet :). Slave-noden kræver en
netværksadapter, som understøtter PXE-opstarti eller Etherboot; tjek <uri link="http://www.etherboot.org">Etherboot.org</uri> for understøttede lister. De fleste kort
understøtter PXE og mange indebygget adaptere på bundkorte vil også
virke.
</p>

</body>
</section>
<section>
<title>Før du starter</title>
<body>

<p>
Du bør have Gentoo installeret på din master-node, og nok plads på 
master til at gemme filsystemer til slave-noderne. Vær også sikker på
at du har en grænseflade til Internet separeret fra din lokale/interne
forbindelse (LAN).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Opsætning af master og slave</title>
<section>
<title>Om kerner</title>
<body>

<note>
Hvis du vil lave en cluster af dine noder til en
openMosix-cluster, vær sikker på at du bruger den patchede kerne til
openMosix. Den kan findes i portage under
<path>sys-kernel/openmosix-sources</path>. Du burde læse vores <uri
link="openmosix-howto.xml">openMosix HOWTO</uri> for at lære om,
hvordan du kompilerer din kerne til openMosix.  
</note>

<p>
Kernen er det software, som sidder imellem dit hardware og alt andet 
software, som du har hentet på din maskine, er essensen af et kerne 
baseret operativsystem.  Når din computer er startet, vil BIOS udføre 
instruktioner, som er fundet på et reserveret opstartsplads på din harddisk. Disse 
instruktioner er typisk en boot-loader, som henter din kerne. Efter at din 
kerne er blevet hentet, er alle processer håndteret af kernen.  
</p>

<p>
Flere informationer om kerner og kerneopsætning kan du finde ved at
kigge på <uri link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">kernel
HOWTO</uri> (engelsk, dansk version på vej).
</p>

</body>
</section>
<section>
<title>Opsætning af masters kerne</title>
<body>

<p>
Masterens kerne kan være så stor og skræddersyet, som du ville ønske det, men
der er få krævede kerne-valgmuligheder, som du skal vælge. Gå ind i din 
kerne-opsætningsmenu ved at taste:
</p>

<pre caption="Redigering af masters kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Du burde få et grå og blåt grafisk grænseflade (GUI), som leverer et sikkert alternativ til manuelt
redigering af <path>/usr/src/linux/.config</path> filen.  Hvis din kerne er 
funktionsdygtig, så er det måske en god idé at gemme den nuværende opsætningsfil 
ved at afslutte GUIen og taste:
</p>

<pre caption="Backup af masters kerneopsætning">
# <i>cp .config .config_working</i>
</pre>

<p>
Gå ind i følgende under-menuer og være sikker på at de viste ting er afkrydset
som 'built-in' (og <e>IKKE</e> som moduler).  Indstillingerne, som er vist forneden er taget fra 
2.4.22 kerneversionen. Hvis du bruger en anden version, så kan teksten eller opstillingen
være anderledes. Vær sikker på at du vælger mindst dem vist forneden.
</p>

<pre caption="masters kerneindstillinger">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers


Networking options ---&gt;
  &lt;*&gt; Packet socket
  [ ]   Packet socket: mmapped IO
  &lt; &gt; Netlink device emulation
  [ ] Network packet filtering (replaces ipchains)
  [ ] Socket Filtering
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting

  
File systems ---&gt;
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot    
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support

<comment>
Hvis du vil have adgang til Internet igennem din masters node og/eller har en sikker firewall, vær sikker på at tilføje understøttelse til iptables
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Hvis du ønsker at bruge pakke-filter (packet filtering), kan du tilføje resten af modulerne senere. Vær sikker på at læse <uri link="http://www.gentoo.org/doc/en/gentoo-security#doc_chap12">Gentoo sikkerhedsvejledning, kapitel 12 Firewall</uri> (engelsk) for at sætte dette ordentligt op.
</p>

<note>
Disse kerneopsætningsindstillinger skulle kun blive tilføjet dine systemspecifikke 
opsætningsindstillinger og er ikke ment til at erstarte din egen kernes
indstillinger fuldstændigt.
</note>

<p>
Efter at du har genindstillet masters kerne, vil du få brug for at genbygge den: 
</p>

<pre caption="Genkompilering af masters kerne og moduler">
# <i>make dep</i>
# <i>make clean bzImage modules modules_install</i>
<comment>(Vær sikker på at /boot er mountet, før du kopierer til den)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
# <i>cp System.map /boot/System.map-master</i>
</pre>

<p>
Tilføj så et punkt for den nye kerne i <path>lilo.conf</path> eller
<path>grub.conf</path>, afhængigt af hvilken boot-loader du bruger og lav
den nye kerne, valgt som standard. Nu da den nye bzImage er blevet kopieret til dit
boot-bibliotek, er alt hvad du skal gøre er, at genstarte systemet for at hente
disse nye indstillinger.
</p>

</body>
</section>
<section>
<title>Om slaves kerne</title>
<body>

<p>
Det er anbefalet, at du kompilerer slaves kerne uden nogen moduler, idet at
hente og indstille dem via en fjern-kontroleret opstart er svært og en unødvendig
process.  I tilføjelse af dette, burde slaves kerne være så lille og kompakt som
muligt, for at kunne opstarte effektivt fra netværket. Vi skal til at kompilere
slaves kerne i det samme sted, som master var opsat.
</p>

<p>
For at undgå misforståelser og spild af tid, er det sikkert en god idé at lave en backup af 
masters opsætningsfil ved at taste:
</p>

<pre caption="Backup af masters kerneopsætning">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Nu skal vi til at opsætte slaves kerne på den samme måde, som vi
opsatte masters kerne.  Hvis du vil starte med en ren
opsætningsfil, kan du altid genskabe standard
<path>/usr/src/linux/.config</path>-filen ved at taste:
</p>

<pre caption="Genskabelse af en ren kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make mrproper</i>
</pre>

<p>
Gå nu ind i opsætningsGUIen ved at taste:
</p>

<pre caption="Redigering af slaves kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Du vil nok være sikker på at du har valgt de følgende indstillinger som indbygget
og <e>IKKE</e> som kerne-moduler:
</p>

<pre caption="slaves kerneindstillinger">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Networking options ---&gt;
  &lt;*&gt; Packet socket
  [ ]   Packet socket: mmapped IO
  &lt; &gt; Netlink device emulation
  [ ] Network packet filtering (replaces ipchains)
  [ ] Socket Filtering
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
  [*]   IP: kernel level autoconfiguration
  [*]     IP: DHCP support (NEW)


File systems ---&gt;
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  Network File Systems  ---&gt;
    &lt;*&gt; file system support 
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
Et alternativ til en DHCP-server er at opsætte en BOOTP-server.
</note>

<impo>
Det er vigtigt at du tilføjer dit netværksadapter ind i kernen (og ikke som et modul) på noderne. Brug af moduler er dog generelt ikke et problem for diskfrie noder.
</impo>

<p>
Nu mangler slaves kerne at blive kompileret.  Du skal være omhyggelig her,
idet du ikke ønsker at ødelægge modulerne (hvis nogen) som du har bygget til 
master:
</p>

<note>
Hvis du bruger forskellige arkitekturer, bør du nok gemme hver opsætning til <path>.config_arch</path>. Gør det samme med billedfiler: gem dem i <path>/diskless</path> som <path>bzImage_arch</path>.
</note>

<pre caption="Kompilering af slaves kerne">
# <i>cd /usr/src/linux</i>
# <i>make clean dep bzImage</i>
</pre>

<p>
Lav nu et bibliotek på master, som du vil bruge til at indeholde slaves filer
og krævede systemfiler. Vi bruger <path>/diskless</path>, men du kan vælge
den placering, som du ønsker.  Kopiér nu slaves bzImage ind i
<path>/diskless</path> biblioteket:
</p>

<note>
Hvis du bruger forskellige arkitekturer, bør du gemme hver opsætning som
<path>.config_arch</path>. Gør det samme med billed-filerne: gem dem i
<path>/diskless</path> som <path>bzImage_arch</path>.
</note>

<pre caption="Kopiering af slaves kerne">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>

</body>
</section>
<section>
<title>Opsætning af en slaves indledende filsystem</title>
<body>

<p>
Masters og slaves filsystemer kan blive fin-indstillet og ændret en del.  Lige nu
er vi kun interesseret i at få lavet et indledende filsystem med passende
opsætningsfiler og mount-punkter. Først skal vi lave et bibliotek
inde i <path>/diskless</path> til den første slave.  Enhver slave kræver dens eget
overordnede filsystem, fordi at dele specifikke systemfiler, kan skabe problemer med
rettigheder og at det hele går ned.  Du kan kalde de biblioteker alt hvad du ønsker,
men vi foreslår at bruge slavernes IP-adresser, idet de er unikke og ikke
misledende.  Den statiske IP på vores første slave vil være, f.eks.
<c>192.168.1.21</c>:
</p>

<pre caption="Oprettelse af et fjernstyret rodbibliotek">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Forskellige opsætningsfiler i <path>/etc</path> skal modificeres for at virke på
slaven. Kopiér masters <path>/etc</path>-bibliotek ind i din nye
slaves rod ved at taste:
</p>

<pre caption="Oprettelse af /etc til slaves filsystem">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Stadigvæk er filsystemet ikke klart, fordi at den kræver flere mount-punkter og
biblioteker. For at oprette dem, tast:
</p>

<pre caption="Oprettelse af mount-punkter og biblioteker til slaves filsystem">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
<comment>(Kun for openMosix)</comment>
# <i>mkdir /diskless/192.168.1.21/mfs</i>
</pre>

<p>
De fleste af disse "stumper" skulle være forståeligt for dig; Stumper som
<path>/dev</path> eller <path>/proc</path> vil være befolket, når slaven starter,
de andre vil blive mountet senere. Du skulle også ændre
<path>/diskless/192.168.1.21/etc/hostname</path>-filen til at vise værtnavnet til
slave. Binære filer, underprogrammer (libs) og andre filer vil blive befolket senere i
denne HOWTO lige før du vil prøve at starte slave.
</p>

</body>
</section>
</chapter>


<chapter>
<title>Opsætning af DHCP-server</title>
<section>
<title>Om DHCP-serveren</title>
<body>

<p>
DHCP står for 'Dynamic Host Configuration Protocol'.  DHCP-serveren er den
første computer, som slaverne kommunikerer med, når de starter via PXE.  Den
primære hensigt af DHCP-serveren er at tildele IP-adresser.  DHCP-serveren
kan tildele IP-adresser, baseret på værtens MAC-adresse.  Når en slave
har en IP-adresse, vil DHCP-serveren fortælle slaven, hvor den skal få fat
i det indledende filsystem og kerne.
</p>

</body>
</section>
<section>
<title>Før du starter</title>
<body>

<p>
Der er flere forskellige ting, som du burde vær sikker på at virker, før du
begynder. Tjek først din netværksforbindelse:
</p>

<pre caption="Tjek af netværksindstillinger">
# <i>ifconfig eth0 enable multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Du burde også være sikker på at have en <e>eth0</e>-enhed kørende.  Den
burde se ud som dette her:
</p>

<pre caption="En passende eth0-enhed, som virker">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
Det er vigtigt, at den siger <e>MULTICAST</e>, og hvis den ikke gør dette, så bliver du nødt til at
gen-kompilere din kerne til at inkludere multicast-understøttelse.
</p>

</body>
</section>
<section>
<title>Installation af DHCP-serveren</title>
<body>

<p>
Hvis dit netværk ikke allerede har en DHCP-server installeret, så vil du få brug for
at installere én:
</p>

<pre caption="Installation af dhcp-server">
# <i>emerge dhcp</i>
</pre>

<p>
Hvis dit netværk allerede har en DHCP-server installeret, så skal du redigere
opsætningsfilen for at få PXE-opstart til at virke korrekt.
</p>

</body>
</section>
<section>
<title>Opsætning af DHCP-serveren</title>
<body>

<p>
Der er kun én opsætningsfil, som du skal redigere før du starter
DHCP-serveren: <path>/etc/dhcp/dhcpd.conf</path>.  Kopiér og redigér den leverede
smagsprøve-fil:
</p>

<pre caption="Redigering af dhcp-serverens opsætningsfil">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
Det generelle layout af filen er indstillet med hensigt og ser
ud som følgende:
</p>

<pre caption="Smagsprøve af dhcpd.conf layout">
<comment># globale muligheder her</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># delte netværksmuligheder her</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # undernetværksmuligheder her</comment>
    host slave{
<comment>        # muligheder specifikt for vært her</comment>
    }
    group {
<comment>        # muligheder specifikt for gruppe her</comment>
    }
}
}
</pre>

<p>
<c>shared-network</c>-blokken er valgfri og skulle blive brugt til IPer, som du ønsker
at være tildelt, for at tilhøre de samme netværkssteder.  Mindst én af <c>subnet</c>
skal være erklæret og den valgfrie <c>group</c>-blok tillader dig at gruppere opsætninger
imellem punkter. Et godt eksempel på <path>dhcpd.conf</path> ser ud som følgende:
</p>

<pre caption="Smagsprøve af dhcpd.conf">
# DHCP configuration file for DHCP ISC 3.0
 
ddns-update-style none;
 
# Definition af PXE-specifikke indstillinger
# Code 1: Multicast IP-adresse af boot-filserveren
# Code 2: UDP-port, som en klient burde overvåge til MTFTP-responser
# Code 3: UDP-port, som MTFTP-servere bruger til at lytte for MTFTP-requests
# Code 4: Sekunder, som en klient skal lytte til en aktivitet, før den prøver
#         at starte en ny MTFTP-overførsel
# Code 5: Sekunder, som en klient skal lytte til, før den prøver at genstarte
#         en MTFTP-overførsel
 
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
 
subnet 192.168.1.0 netmask 255.255.255.0 {


  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    option vendor-class-identifier "PXEClient";
    vendor-option-space PXE;
 
    # Mindst én af de salg-specifikke PXE-indstillinger skal være indstillet
    # for at klients opstartsROM kan forstå at vi har en PXE-understøttet
    # server. Vi kan indstille MCAST IP-adressen til 0.0.0.0 for at fortælle
    # opstartsROM at vi ikke kan levere multicast-TFTP (adressen 0.0.0.0 betyder
    # ingen adresse).
 
    option PXE.mtftp-ip 0.0.0.0;
 
    # Dette er navnet på filen, som opstartsROM burde hente.
    filename "pxelinux.0";
    # Dette er navnet på den server, som vi skal få det fra.
    <comment># Brug masters IP</comment>
    next-server 192.168.1.1;
  }

<comment># Hvis du bruger etherboot med en ikke-specifik billedfil</comment>
class "etherboot" {
    if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
    filename "/diskless/vmlinuz";
    }
}

  pool {
    max-lease-time 86400;
    default-lease-time 86400;
    <comment># Dette forhinder at ulistede maskiner kan få en IP</comment>
    deny unknown clients;
  }
 
  host slave21 {
       <comment># Brug slaves MAC-adresse</comment>
       hardware ethernet                00:40:63:C2:CA:C9;
       <comment># Giv slave en statisk IP</comment>
       fixed-address                    192.168.1.21;
       server-name                      "master";
       <comment># Brug din gateways IP, hvis krævet</comment>
       option routers                   192.168.1.1;
       <comment># Brug din DNSs IP, hvis krævet</comment>
       option domain-name-servers       192.168.1.1;
       option domain-name               "mydomain.com";
       <comment># Brut slaves værtsnavn</comment>
       option host-name                 "slave21";


       <comment># Etherboot og pxe-boot med en mac-specifik billedfil</comment>
       option root-path                 "/diskless/192.168.1.21";

       if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
       			filename "/vmlinuz_arch";
	} else if substring (option vendor-class-identifier, 0, 9) = "PXEClient" {
			filename "/pxelinux.0";
	}

  }
}
</pre>

<note>
Der er ikke noget der forhindrer brugen af både PXE-boot og Etherboot samtidigt.
</note>

<p>
IP-adressen efter <c>next-server</c> vil blive spurgt efter et specificeret
<c>filename</c> (filnavn). Denne IP-adresse skal være IPen på TFTP-serveren, som normalt er
den samme, som masters IP-adresse.  <c>filename</c> er relativ til
<path>/diskless</path>-biblioteket (dette er til TFTP-serverens specifikke
indstillinger, som vil blive dækket senere).  Inde i <c>host</c>-blokken specificerer 
<c>hardware ethernet</c>-indstillingen en MAC-adresse, og 
<c>fixed-address</c> tildeler en fast IP-adresse til en specifik MAC-adresse.
<c>host-name</c>-indstillingen er sikkert en god idé at inkludere og er bare
værtsnavnet på en specifik slave.  Der er en pæn god man-page om 
<path>dhcpd.conf</path> med instillinger udover omfanget af denne HOWTO.
Du kan læse den, ved at taste:
</p>

<pre caption="Læsning af man-pages for dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>
<section>
<title>Start af DHCP-serveren</title>
<body>

<p>
Før du starter DHCPs initialiseringsscript, så redigér
<path>/etc/conf.d/dhcp</path>-filen, så at den ser ud som dette
her:
</p>

<pre caption="Smagsprøve af /etc/conf.d/dhcp">
IFACE="eth0"
<comment># indsæt de andre indstillinger, som er nødvendige</comment>
</pre>

<p>
<c>IFACE</c>-variablen er enheden, som
du ønsker at køre din DHCP-server på, i dette tilfælde <c>eth0</c>. Tilføjelser af flere
punkter til <c>IFACE</c>-variablen kan være brugbart til et komplekse netværkssteder,
med flere netværkskorte. For at starte DHCP-serveren, tast:  
</p>

<pre caption="Start af DHCP-server på master">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
For at tilføje DHCP-serveren til dit opstartsscript, tast:
</p>

<pre caption="Tilføjelse af DHCP-server til masters standard runlevel">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>
<section>
<title>Fejlfinding af DHCP-server</title>
<body>

<p>
For at se at noden starter, kan du tage et kig på
<path>/var/log/syslog.log</path>.  Hvis denne node starter med
succes, vil <path>syslog.log</path>-filen have nogle linjer i bunden, som ser ud som dette:
</p>

<pre caption="Smagsprøve af logfil-punkter oprettet af DHCP">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
Denne logfil vil også hjælpe dig med at finde slavernes MAC-adresser.
</note>

<p>
Hvis du får følgende besked, er det sikkert fordi at der er noget galt
med opsætningsfilen, men også at DHCP-serveren stadigvæk sender korrekt.
</p>

<pre caption="Smagsprøve af en DHCP-serverfejl">
no free leases on subnet LOCAL-NET
</pre>

<p>
Hver gang at du ændrer opsætningsfilen, skal du genstarte DHCP-serveren.
For at genstarte serveren, tast:
</p>

<pre caption="Genstart af DHCP-server på master">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Opsætning af TFTP-server og PXE Linux boot-loader og/eller Etherboot</title>
<section>
<title>Om TFTP-serveren</title>
<body>

<p>
TFTP står for 'Trivial File Transfer Protocol'.  TFTP-serveren vil
levere slave med en kerne, og et indledende filsystem.  Alle 
slave-kerner og filsystemer vil blive gemt på TFTP-serveren, så det er
sikkert en god idé at lave master til TFTP-serveren.
</p>

</body>
</section>
<section>
<title>Installation af TFTP-server</title>
<body>

<p>
En virkelig anbefalet tftp-server er klar som tftp-hpa pakken. Denne tftp-server er skrevet af SYSLINUX-forfatteren og den virker meget godt sammen med pxelinux. For at installere, bare tast:
</p>

<pre caption="Installation af tftp-serveren">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>
<section>
<title>Opsætning af TFTP-server</title>
<body>

<p>
Rediger <path>/etc/conf.d/in.tftpd</path>. Du bør specficere tftproot-folderen med <c>INTFTPD_PATH</c> og hvilketsomhelst kommandolinie-valgmulighed med <c>INTFTPD_OPTS</c>. Det bør se ud som noget lignende dette:
</p>

<pre caption="Smagsprøve af /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
<c>-l</c>-optionen indikerer at serveren lytter i 'stand alone mode', så den ikke skal køre inetd. <c>-v</c> indikerer at log-/fejl-beskeder skal være verdslige. <c>-s /diskless</c> specificerer roden af din tftp-server.
</p>

</body>
</section>
<section>
<title>Start af TFTP-server</title>
<body>

<p>
For at starte tftp-serveren tast:
</p>

<pre caption="Start af master's tftp-server">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Dette bør starte tftp-serveren med de valgmuligheder, som du specficerede i <path>/etc/conf.d/in.tftpd</path>. Hvis du vil have at denne server bliver automatisk startet ved opstart, tast:
</p>

<pre caption="Tilføjelse af tftp-server til masters default run-level">
# <i>rc-update add in-tftpd default</i>
</pre>

</body>
</section>
<section>
<title>Om PXELINUX</title>
<body>

<p>
Denne sektion er ikke krævet, hvis du kun bruger Etherboot. PXELINUX er en netværksboot-loader, som kan sammenlignes med LILO eller GRUB, og vil være behandlet via TFTP.  Det er essentielt et lille sæt af instruktioner, som fortæller klienten, hvor den skal finde sin kerne og indledende filsystem og tillader forskellige kerneopsætninger.
</p>

</body>
</section>
<section>
<title>Før vi starter</title>
<body>

<p>
Du vil få brug for pxelinux.0 filen, som kommer med SYSLINUX-pakken
af H. Peter Anvin.  Du kan installere denne pakke ved at taste:
</p>

<pre caption="Installation af syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>
<section>
<title>Opsætning af PXELINUX</title>
<body>

<note>
Dette er ikke nødvendigt til Etherboot.
</note>

<p>
Før du starter din TFTP-server, skal du indstille pxelinux.  Du skal først kopiere 
pxelinux-binærfilen ind i dit <path>/diskless</path>-bibliotek:
</p>

<pre caption="Indstilling af en fjernstyret boot-loader">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Dette vil oprette en standard boot-loader opsætningsfil. Den binære
<path>pxelinux.0</path> vil kigge i
<path>pxelinux.cfg</path>-biblioteket efter en fil, hvis navn er
klientens IP-adresse i hexadecimal. Hvis den ikke finder denne fil,
vil den slette det højre ciffer fra samme filnavn og prøve igen,
indtil den ikke har flere cifre at bruge. Version 2.05 og senere af
syslinux vil lave en ekstra søgning for en fil, som er navngivet efter
MAC-adressen. Hvis ingen fil er fundet, vil den bruge
<path>default</path>-filen.
</p>

<pre caption="Filer som PXE kigger efter i pxelinux.cfg/ i rækkefølge">
<comment>(Tildelt IP i hexadecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
<comment>(Er første ciffer 01, betyder det Ethernet, de efterfølgende bytes passer til vores slaves MAC-adresse)</comment>
01-00-40-63-c2-ca-c9
default
</pre>

<note>
Disse er alle med små bogstaver.
</note>

<p>
Lad os starte med <path>default</path>-filen:
</p>

<pre caption="Smagsprøve af pxelinux.cfg/default">
DEFAULT /diskless/bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
<c>DEFAULT</c>-taggen dirigerer pxelinux til kernens bzImage, som vi har kompileret
tidligere.  <c>APPEND</c>-taggen tildeler kernens intialiseringsopsætning. Siden vi har
kompileret slaves kerne med <c>NFS_ROOT_SUPPORT</c> vil vi specificere
nfsroot her.  Den første IP er masters IP, og det andet IP er
biblioteket, som var oprettet i <path>/diskless</path> til at gemme slaves
indledende filsystem. 
</p>

</body>
</section>

<section>
<title>Om Etherboot</title>
<body>

<note>
Dette er ikke krævet, hvis du bruger PXE-boot.
</note>

<p>
Etherboot opstarter netværks-opstartsbilledfiler fra en TFTP-server. Som PXEen, er dette sammenlignelig med LILO eller GRUB. <c>mknbi</c>-værktøjet sørger for at du kan oprette forskellige billedfiler, som bruger forskellige valgmuligheder.
</p>

</body>
</section>
<section>
<title>Før du starter</title>
<body>

<p>
Du vil få brug for <c>mknbi</c>-pakken (værktøj til at lave tagged kerne-billedfiler, som er brugbart til netopstart) for at oprette dine Etherboot-billedfiler. Dette værktøj vil oprette en præ-opsat kerne-billedfil fra din originale kerne. Denne indeholder opstarts-valgmulighederne, som er vist længere nede.
</p>

<pre caption="Installation af mknbi">
# <i>emerge mknbi</i>
</pre>

</body>
</section>
<section>
<title>Opsætning af Etherboot</title>
<body>

<p>
I denne sektion vil vi oprette en simpel etherboot-billedfil. Idet DHCP-serveren uddeler klientens rod-sti i "option root-path" dhcp.conf, skal vi ikke tilføje den her. Flere detaljer kan blive fundet i mknbis manual.
</p>

<pre caption="mknbi manual">
# <i>man mknbi</i>
</pre>

<p>
Oprettelse af opstart-billedfiler. Dette vil oprette en ELF opstartbar billedfil, som kan tilføje DHCP og rod-stien til kernen. Den tvinger også kernen til at browse netværket for en DHCP-server.
</p>

<pre caption="Oprettelse af netopstart-billedfiler">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Til arkitektur-specifikke billedfiler, skal du indtaste <c>bzImage_arch</c> og <c>vmlinuz_arch</c>.
</note>

</body>
</section>
<section>
<title>Fejlfinding af netværksopstartsprocessen</title>
<body>

<p>
Der er få ting, som du kan gøre for at kigge på netværksopstartsprocessen.  Primært
kan du bruge et værktøj, kaldet <c>tcpdump</c>.  For at installere <c>tcpdump</c>, tast:
</p>

<pre caption="Installation af tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Du kan nu lytte til forskelligt netværkstrafik og vurdere at din
klient/server-interaktion er funktionelt.  Hvis noget ikke virker, er
der få ting, som du måske skulle kigge efter. Først, vær sikker på at
klient/server er fysisk forbundet ordentligt, og at netværkskabler
ikker er ødelagte.  Hvis din klient/server ikke modtager 'requests' på
en specifik port, vær sikker på at der ikke er nogen
firewall-afbrydelser.  For at lytte til interaktionen imellem to
computere, tast:
</p>

<pre caption="Lytte til klient- og server-interaktion via tcpdump">
# <i>tcpdump host </i><comment>client_ip</comment><i> og </i><comment>server_ip</comment>
</pre>

<p>
Du kan også bruge <c>tcpdump</c> til at lytte til en specifik port, som f.eks. tftp-porten,
ved at taste:
</p>

<pre caption="Lytte til tftp-server">
# <i>tcpdump port 69</i>
</pre>

<p>
EN typisk fejl, som du vil modtage, er: "PXE-E32: TFTP open time-out".
Det er sikkert pga. fireware-problemer.  Hvis du bruger <c>TCPwrappers</c>, 
burde du måske tjekke <path>/etc/hosts.allow</path> og 
<path>etc/hosts.deny</path> og sørge for at de er opsat ordentligt. 
Klienten burde være tilladt til at forbinde til serveren.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Opsætning af NFS-serveren</title>
<section>
<title>Om NFS-serveren</title>
<body>

<p>
NFS står for 'Network File System'.  NFS-serveren vil blive brugt til at behandle
biblioteker til slave. Disse kan blive personlige senere, men
lige nu, er alt hvad vi vil, er at få en indlendende slave-node til at starte diskfrit.
</p>

</body>
</section>
<section>
<title>Om Portmapper</title>
<body>

<p>
Forskellige klient/server-tjenester lytter ikke til en specifik port, men stoler i stedet 
for på RPCer (Remote Procedure Calls).  Når denne tjeneste er startet, vil den
lytte på en hvilkensomhelst port og så registrere denne port med 
Portmapper-værktøjet.  NFS stoler på RPCer og derfor kræver den Portmapper er startet, 
før den er startet.
</p>

</body>
</section>
<section>
<title>Før du starter</title>
<body>

<p>
NFS-serveren kræver kernens level-understøttelse, så hvis du ikke har dette, skulle du
genkompilere din masters kerne.  For at dobbelt-tjekke din masters kerne-opsætning,
tast:
</p>

<pre caption="Tjek af NFS-specifik opsætning">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
Du burde se et output, som ser ud som dette, hvis din kerne er blevet sat 
ordentligt op:
</p>

<pre caption="Ordentlig NFS-specifik opsætning i masters kerneopsætning">
# CONFIG_ROOT_NFS is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_TCP is not set
# CONFIG_NCPFS_NFS_NS is not set
</pre>

</body>
</section>
<section>
<title>Installation af NFS-serveren</title>
<body>

<p>
NFS-pakken kan fåes igennem portage, ved at taste:
</p>

<pre caption="Installation af nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Denne pakke vil emerge en portmapping-værktøj, nfs server og nfs-client 
værktøjer, og vil automatisk ordne initialiseringsafhængigheder.
</p>

</body>
</section>
<section>
<title>Opsætning af NFS-serveren</title>
<body>

<p>
Der er tre store opsætningsfiler, som du skal redigere:
</p>

<pre caption="NFS opsætningsfiler">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
<path>/etc/exports</path>-filen specificerer hvordan, til hvem og hvad at eksportere
igennem NFS.  Slaves fstab vil blive ændret sådan, at den kan mounte NFS-filsystemer,
som master eksporterer.
</p>

<p>
En typisk <path>/etc/exports</path> til master, skulle se ud lige som 
dette:
</p>

<pre caption="Smagsprøve af masters /etc/exports">
<comment># En linie som denne til hver slave</comment>
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
<comment># Fælles for alle slaver</comment>
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
<comment># Hvis du vil have en delt log</comment>
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>

<p>
Det første felt indikerer biblioteket, som bliver eksporteret og det
næste felt indikerer til hvem og hvordan. Dette felt kan blive delt i
to dele: hvem bør have tilladelse til at mounte det specifikke
bibliotek og hvad den mountede klient kan gøre med filsystemet:
<c>ro</c> for 'read only', <c>rw</c> for 'read/write';
<c>no_root_squash</c> og <c>no_all_squash</c> er vigtige til diskfri
klienter, som skriver til disken, så de ikke bliver "smadret", når de
laver 'I/O requests'.  Slaves fstab-fil,
<path>/diskless/192.168.1.21/etc/fstab</path>, bør se ud som dette:
</p>

<pre caption="Smagsprøve af slaves fstab">
<comment># Disse punkter er essentielle</comment>
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># Brugbart, men ikke nødvendigt</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0

<comment>(kun hvis du opsætter en openMosix-cluster)</comment>
none                            /mfs      mfs     dfsa=1                                       0 0
</pre>

<p>
I dette eksempel er <e>master</e> kun værtnavnet for master, men det kunne med
med lethed være IP for master.  Det første felt indikerer biblioteket, som bliver
mountet og det andet felt indikerer hvor.  Det tredje felt beskriver
filsystem og bør være NFS til enhvert NFS-mountet bibliotek. Det fjerde felt
indikerer forskellige indstillinger som kan blive brugt til mount-processen (se
mount(1) for flere mount-indstillinger).  Nogle folk har problemer med 
'soft' mount-punkter, så vi laver dem alle 'hard', men du skulle kigge på forskellige
<path>/etc/fstab</path>-indstillinger for at gøre din cluster mere effektiv. 
</p>

<p>
Den sidste fil, som du skal redigere er <path>/etc/conf.d/nfs</path>, som 
beskriver nogle få indstillinger til NFS, når den er startet, og ser ud som følgende:
</p>

<pre caption="Smagsprøve af masters /etc/conf.d/nfs">
# Config file for /etc/init.d/nfs

# Antal af servere, som skal startes som standard
RPCNFSDCOUNT=8

# Indstillinger til at sende til rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Du bør ændre <c>RPCNFSDCOUNT</c> til det antal af diskfrie noder på
netværket.
</p>

</body>
</section>
<section>
<title>Start af NFS-serveren</title>
<body>

<p>
Du skal starte NFS-serveren med dens init-script, som er placeret i 
<path>/etc/init.d</path>, ved at taste:
</p>

<pre caption="Start af masters NFS-server">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Hvis du vil have at dette script starter ved opstart, tast følgende:
</p>

<pre caption="Tilføjelse af NFS-server til masters standard runlevel">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Afslutning af slaves filsystem</title>
<section>
<title>Kopiering af de manglende filer</title>
<body>

<p>
Vi vil nu sørge for slaves filsystem er ajour med masters og levere
de nødvendige binære filer, imens vi stadigvæk bevarer slaves specifikke filer.
</p>

<pre caption="Oprettelse af slaves filsystem">
# <i>rsync -avz /bin /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib /diskless/192.168.1.21</i>
</pre>

<note>
Begrundelsen for at bruge rsync -avz istedet for cp er for at opretholde symlinks og rettigheder.
</note>

</body>
</section>
<section>
<title>Start-scripts</title>
<body>

<p>
Standard-scripterne vil prøve at køre <e>checkroot</e>, som ikke er
logisk for dine slave-noder. Den svære vej er at manuelt redigere
<path>/diskless/192.168.1.21/sbin/rc</path>-scriptet, men dette er
byrdefuldt, farligt og kunne ødelægge det hele, når du vil ajourføre
din nodes filsystem igen og glemmer at lade denne script være.
Fidusen er at have en <path>/fastboot</path>-fil, når dit system
starter op. Denne fil fortæller <e>checkroot</e> om ikke at køre
nogen tjek af filsystem. Men dette vil også slette filen, når den er
færdig med programstartsprocessen. Derfor skal vi oprette filen igen i
slutningen af programstartsprocessen, som dette:
</p>

<pre caption="At forhindre programstartsscriptre at køre et filsystemstjek">
<comment>(Oprettelse af /fastboot filen til næste genstart)</comment>
# <i>touch /diskless/192.168.1.21/fastboot</i>
<comment>(Oprettelse af /fastboot filen på enhver opstart)</comment>
# <i>echo "touch /fastboot" &gt;&gt; /diskless/192.168.1.21/etc/conf.d/local.start</i>
</pre>

<p>
Du får brug for mange programstartsscripter under
<path>/diskless/192.168.1.21/etc/runlevel</path>, idet du behøver tjenester på dine
diskfrie noder. Det afhænger alt efter du vil have dine slaver til at gøre.
</p>

<warn>
Brug ikke <c>rc-update</c> programmet til at tilføje eller fjerne scripter i
slaves runlevel'er, når du er logget ind på din master. Dette ville ændre din masters
runlevel'er. Du skal oprette henvisninger manuelt eller logge ind til dine slave-noder
ved brug af ssh eller tilslutte en skærm og tastatur til din slave.
</warn>

<pre caption="Typiske slave runlevels">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
 
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 portmap -> /etc/init.d/portmap
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 serial -> /etc/init.d/serial
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
 
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 metalog -> /etc/init.d/metalog
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 ntp-client -> /etc/init.d/ntp-client
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 ntpd -> /etc/init.d/ntpd
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vcron -> /etc/init.d/vcron
 
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
 
/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
Nu er det et godt tidspunkt at starte din slave og krydse dine fingre. Virker det?
Tillykke!, du er nu en stolt ejer af (en) diskfri(e) node(r) :)
</p>

</body>
</section>

<!-- 

<section>
<title>Et alternativ : ClusterNFS</title>
<body>

<warn>
Dette er kun forklaret, fordi at en reviewer af dette dokument brugte
denne løsning. Du skal være klar over at Gentoo <e>ikke</e>
understøtter ClusterNFS. Den er ikke i portage og kræver ændringer til
et baselayout programstartsscript. <b>Brug det på eget ansvar</b>.  
</warn>

<p>
Hvis du ikke gider at have en specifik rod til hver slave, fordi at det kræver noget
vedligeholdse, når du opgraderer filer fra masters biblioteker, kan du dele
den samme rod over alle noderne, master og slaver inkluderet. Dette betyder at alt hvad dine
maskiner kræver er, at være kompatible, idet at du kun har ét sæt af binære filer.
Du skal også være klar over at dette vil måske have sikkerhedsproblemer, idet alle dine
dine masters rodfiler vil blive eksporteret igennem NFS.
</p>

<p>
Hvis du stadigvæk vil prøve dette alternativ, besøg ClusterNFSs <uri
link="http://clusternfs.sourceforge.net/">hjemmeside</uri>, hente
softwaren og læs dokumentationen.
</p>

<p>
For at gøre det kort, er alle filer delt og filerne, som er forskellige fra
master til alle slaverne, er kopieret til <path>file$$CLIENT$$</path>. Når en 
slave kræver en fil: <path>file</path>, vil ClusterNFS notere eksistensen af
<path>file$$CLIENT$$</path> og sende denne i stedet for. Filer, som behøver at være
forskellige på hver node, er kopieret til <path>file$$IP=192.168.1.21$$</path>.
Det samme gælder for biblioteker.
</p>

<p>
Meget kort, er dette er hvad er forskelligt fra installationsproceduren, beskrevet 
foroven:
</p>

<ul>
  <li>Du behøver ikke NFS-server understøttelse i din masters kerne</li>
  <li>Installation af ClusterNFS <e>efter</e> du emerger nfs-utils</li>
  <li>Lav slave-kopier af filer og biblioteker, som beskrevet foroven</li>
  <li>Lav ikke et rodbibliotek for hver node</li>
  <li>Eksporterer kun / i din <path>/etc/exports</path> fil</li>
  <li>
    Mount kun / via NFS i slaves <path>/etc/fstab$$CLIENT$$</path> fil
  </li>
  <li>Redigér <path>/etc/init.d/nfs</path>, som beskrevet forneden</li>
  <li>
    Redigér <path>/etc/conf.d/local.start$$CLIENT$$</path>, som beskrevet forneden
  </li>
</ul>

<pre caption="Filer som skal være forskellig fra master til slave">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Måske tom)</comment>
/etc/crontab$$CLIENT$$<comment> (Måske tom, master tager sig af dette)</comment>
/etc/exports$$CLIENT$$<comment> (Tom, slaver eksporterer ikke NFS-mountpunkter)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Navngiv dine slaver)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Ren adskillelse imellem masters og slaves opstartsscripter)</comment>
/fastboot$$CLIENT$$
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Oprette underbiblioteker som i /var)</comment>
</pre>

<pre caption="Redigering af /etc/init.d/nfs">
        ebegin "Start af NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Tilføj - -translate-names option</comment>
                $nfsd - - - -translate-names
        eend $? "Fejl ved start af NFS daemon"
         # Tjekker om vi understøtter NFSv3
        ebegin "Start af NFS mountd"
<comment># Kommentér de følgende to linier (ClusterNFS kender kun NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Fejl ved start af NFS mountd"
</pre>

<pre caption="Redigering af /etc/conf.d/local.start$$CLIENT$$">
<comment>(Tilføjelse af denne linie)</comment>
touch /fastboot\$\$CLIENT\$\$
</pre>

</body>
</section>
-->
</chapter>

</guide>
