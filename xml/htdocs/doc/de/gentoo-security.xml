<?xml version='1.0' encoding='UTF-8'?>
 <!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/gentoo-security.xml,v 1.21 2005/04/20 04:43:11 dertobi123 Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- English CVS Version: 1.76 -->

<guide link="/doc/de/gentoo-security.xml">
<title>Gentoo Linux Sicherheitsleitfaden</title>

<author title="Bearbeiter">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Bearbeiter"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Bearbeiter">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Bearbeiter">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Bearbeiter">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Bearbeiter">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Bearbeiter">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Bearbeiter">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Bearbeiter">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Bearbeiter">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Editor">
  <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
</author>
<author title="Übersetzer">
  <mail link="jhgz1@ufl.edu">Jan Hendrik Grahl</mail>
</author>
<author title="Übersetzer">
  <mail link="dertobi123@gentoo.org">Tobias Scherbaum</mail>
</author>
<author title="Übersetzung">
  <mail link="vorlon@gentoo.org">Matthias Geerdsen</mail>
</author>
  

<abstract>
Dieser Leitfaden ist eine Schritt-für-Schritt-Anleitung für das Absichern von
Gentoo Linux.
</abstract>

<license/>

<version>0.4.46</version>
<date>2005-04-07</date>

<chapter>
<title>Einleitung</title>
<section>
<body>

<p>
Dieser Leitfaden ist für Leute gedacht, die Gentoo Linux in einer
Server-basierten Umgebung einsetzen, oder das Gefühl haben mehr Sicherheit zu
brauchen.
</p>

<note>
Wenn Sie nach dem Lesen dieses Leitfadens an noch mehr Sicherheit interessiert
sind, sollten Sie einen Blick auf das 
<uri link="http://www.gentoo.org/proj/en/hardened/"> Hardened Gentoo 
Projekt</uri> werfen.
</note>
</body>
</section>

<!--
<section>
<title>Erweiterungen für zukünftige Ausgaben dieses Leitfadens:</title>
<body>

<p>
In Version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Komplettes Systembackup mit Hilfe von Systemimager</li>
<li>Partielles Backup mittels tar</li>
<li>Backups von PostgreSQL erstellen</li>
</ul>


<p>
In Version 0.8 (Penetrations Tests)
</p>
<ul>
<li>Wie meldet man einen Vorfall</li>
<li>Forensische Analyse</li>
<li>Erstellen von Systemimages ohne Beweise zu vernichten (mittels <c>dd</c>)</li>
<li>Fallen stellen und verfolgen (mit tcpdump)</li>
<li>.. Noch einiges mehr ..</li>
<li>System wieder herstellen</li>
</ul>

<note>
Bitte beachten Sie, dass sich jede Version jeweils nur auf ein Thema bezieht. Dies wird aus
Qualitätssicherungsgründen so gehandhabt.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Was vor der Installation beachtet werden sollte</title>
<section>
<title>Physische Sicherheit</title>
<body>

<p>
Egal wie viele Sicherheitsmaßnahmen Sie integrieren, sie können leicht umgangen
werden, wenn der Hacker direkten Zugriff auf Ihre Maschine hat.
Nichtsdestotrotz können zumindest einige Maßnahmen ergriffen werden, um einen
gewissen Grad an Sicherheit auch gegen Angreifer mit direktem Zugang zu
erlangen. Den Computer in einen entsprechenden Schrank zu schließen, verhindert
ein einfaches Steckerabziehen und stehlen. Auch das verschließen des Gehäuses
ist eine gute Idee, damit niemand einfach mit der Festplatte davon laufen kann.
Um das Booten von einem anderen Medium zu untersagen, was einfach alle
Befugnisse und Login Beschränkungen aufheben würde, stellen Sie im BIOS die
Festplatte als erstes Boot Device ein und setzen Sie ein BIOS Passwort. Auch
ist es wichtig ein LILO oder GRUB Passwort festzulegen, um ein Booten in den
Single-User Modus und somit einen kompletten Zugriff auf das System zu
verhindern. Dieses wird detaillierter in Kapitel 3 unter 
<uri link="#passwording_GRUB">GRUB Passwort</uri> und 
<uri link="#passwording_LILO">LILO Passwort</uri> beschrieben.
</p>

</body>
</section>
<section>
<title>Dämon/Dienst Planung</title>
<body>

<p>
Beginnen Sie, indem Sie dokumentieren, welche Dienste auf der Maschine laufen 
sollten. Das wird Ihnen helfen ein besseres Partitionsschema für das System zu 
finden und Ihnen erlauben, Sicherheitsmaßnahmen besser zu planen. Natürlich 
ist dieses nicht nötig wenn die Maschine nur einem einfachen Zweck dienen 
soll, z.B. als Desktop oder dedizierte Firewall. In diesen Fällen sollten 
<e>gar keine</e> Dienste, ausser vielleicht sshd, laufen. 
</p>
<p>
Diese Liste kann auch zur Unterstützung der Systemadministration verwendet 
werden. Indem eine aktuelle Liste mit Versionsinformationen geführt wird, 
werden Sie es viel einfacher haben alles up to date zu halten, falls eine aus 
der Ferne nutzbare Sicherheitslücke in einem der Daemons entdeckt wird.
</p>

</body>
</section>
<section>
<title>Partitions-Schemata</title>
<body>

<p>
Regeln zur Partitionierung:
</p>

<ul>
  <li>
  Jedes Verzeichnis auf das ein Benutzer Schreibrechte haben muss
  (<path>/home</path> und <path>/tmp</path>, <path>/var</path>) sollte auf einer
  separaten Partition liegen und Disk-Quotas benutzen. Dies reduziert das
  Risiko, dass ein Benutzer das gesamte Dateisystem füllt. Portage benutzt
  <path>/var/tmp</path> zum kompilieren, folglich muss diese Partition groß
  sein.
  </li>
  <li>
  Jedes Verzeichnis, in das nicht in der Distribution enthaltene Pakete
  installiert werden sollen, sollten auf einer separaten Partition liegen.  Nach
  dem <uri link="http://www.pathname.com/fhs/">Filesystem Hierarchy
  Standard</uri> ist dies <path>/opt</path> oder <path>/usr/local</path>. Wenn
  diese separate Partitionen sind, bleiben Sie bei einer eventuellen
  Neuinstallation des Systems bestehen.
  </li>
  <li>
  Für zusätzliche Sicherheit können Sie statische Daten in eine eigene Partition
  verschieben und diese Partition nur lesbar einhängen. Wenn Sie wirklich
  übervorsichtig sind, dann könnten Sie statische Daten auch auf einem nur
  lesbaren Medium speichern - zum Beispiel einer CD-ROM.
  </li>
</ul>

</body>
</section>
<section>
<title>Der Benutzer root</title>
<body>

<p>
Der Benutzer 'root' ist der mächtigste Benutzer im System und sollte für nichts
eingesetzt werden, es sei denn, es ist absolut notwendig. Wenn ein Angreifer
root-Zugang erreicht, dann können Sie Ihrem System nicht mehr länger trauen -
Sie haben dann keine andere Wahl, als neu zu installieren.
</p>

<p>
Goldene Regeln bezüglich 'root'
</p>

<ul>
  <li>
  Erstellen Sie immer einen Benutzer für die tägliche Arbeit. Wenn dieser
  Benutzer root-Zugang benötigt, dann fügen Sie diesen Benutzer zur Gruppe
  'wheel' hinzu. Dies erlaubt einem normalen Benutzer per <c>su</c> zu 'root' zu
  wechseln.
  </li>
  <li>
  Lassen Sie X oder irgendeine andere Benutzeranwendung niemals als root laufen.
  Root sollte nur benutzt werden wenn es absolut notwendig ist. Sollte eine
  Sicherheitslücke in einem Programm existieren das als normaler Benutzer läuft,
  so kann ein Angreifer damit lediglich die Rechte des Benutzers erhalten; läuft
  die Anwendung hingegen als root, so erlangt der Angreifer auch root-Zugang.
  </li>
  <li>
  Benutzen Sie immer absolute Pfadangaben, wenn Sie als root angemeldet sind
  (oder verwenden Sie immer <c>su -</c>, was die Umgebungsvariablen des
  Benutzers durch die von root ersetzt, wenn Sie sich sicher sind, dass der
  <c>PATH</c> von root nur geschützte Verzeichnise wie <path>/bin</path> und
  <path>/sbin</path> enthält).  Es ist möglich root auszutricksen und ihn dazu
  zu bringen eine andere Anwendung statt der, die eigentlich ausgeführt werden
  soll, auszuführen. Wenn der <c>PATH</c> von root sicher ist oder der root
  Benutzer nur absolute Pfade verwendet, können wir sicher sein, dass dies nicht
  geschehen wird.
  </li>
  <li>
  Wenn ein Benutzer nur ein paar Kommandos, anstatt von allen, die root benutzen
  kann, dann überlegen Sie, vielleicht auf <c>sudo</c> zurückzugreifen, aber
  seien Sie auch hierbei vorsichtig wem Sie Zugang gewähren.
  </li>
  <li>
  Verlassen Sie nie den Terminal, wenn Sie als root angemeldet sind.
  </li>
</ul>

<p>
Gentoo hat einen Standardschutz gegen normale Benutzer, die versuchen durch
<c>su</c> root zu werden. Die Standardeinstellung von PAM verlangt, dass ein
Benutzer in der Gruppe wheel sein muss, um <c>su</c> benutzen zu dürfen.
</p>

</body>
</section>
<section id="security_policies">
<title>Sicherheitsrichtlinien</title>
<body>

<p>
Es gibt verschiedene Gründe Sicherheitsrichtlinien für Ihr System/Ihre Systeme
und Ihr Netzwerk zu entwerfen.
</p>

<ul>
  <li>
  Gute Sicherheitsrichtlinien erlauben es Ihnen, Sicherheit mehr als ein
  "System" zu behandeln statt als einfaches Durcheinander verschiedener
  Merkmale. Ohne Richtlinie zum Beispiel, könnte ein Administrator entscheiden,
  telnet abzuschalten, da es unverschlüsselte Passwörter überträgt, während er
  andererseits FTP-Zugang gewährt, obwohl es die selbe Schwäche besitzt. Eine
  gute Sicherheitsrichtlinie erlaubt es, lohnenswerte Maßnahmen von nicht
  lohnenswerten zu unterscheiden.
  </li>
  <li>
  Um Probleme zu diagnostizieren, Prüfungen durchzuführen und Eindringlinge zu
  finden, kann es nötig sein Netzwerkverkehr abzufangen, Einblick in Login- und
  Befehls-Logs und Home-Verzeichnise von Benutzern zu nehmen. Ohne dieses
  schriftlich darzulegen und Benutzer davon in Kenntnis zu setzen, können solche
  Dinge illegal sein und <e>Sie</e> in rechtliche Schwierigkeiten bringen.
  </li>
  <li>
  Entführte Benutzerzugänge sind eine der häufigsten Bedrohungen der
  Systemsicherheit. Die Hoffnung auf sicher Benutzerzugänge ist vergebens, wenn
  den Benutzern nicht erklärt wird, warum Sicherheit wichtig ist und wie sie
  sich entsprechend verhalten können (z.B. keine Passwörter auf Haftnotizen auf
  dem Schreibtisch aufbewahren).
  </li>
  <li>
  Ein gut dokumentiertes Netzwerk- und Systemlayout hilft sowohl Ihnen als auch
  ggf. den Untersuchenden der Strafverfolgungsbehörden beim nachspüren eines
  Eindringens und dem Aufspüren von Schwachstellen. Ein entsprechendes "issue"
  Banner, welches besagt, dass es sich bei Ihrem System um ein privates Netzwerk
  handelt und das jeglicher unautorisierter Zugriff untersagt ist, wird auch
  die Sicherstellung einer eventuellen strafrechtlichen Verfolgung des
  Eindringlings verbessern.
</li>
</ul>

<p>
Der Bedarf an einer guten Sicherheitsrichtlinie ist jetzt hoffentlich mehr als
klar.
</p>

<p>
Eine Richtlinie ist ein Dokument (oder mehrere Dokumente), das die Merkmale des
Systems und des Netzwerk (z.B. welche Dienste werden angeboten),
akzeptable/verbotene Benutzung, richtige Verhaltensweisen in Bezug auf
Sicherheit, etc. darstellt.  Alle Benutzer sollten auf diese Richtlinie
aufmerksam gemacht und über Änderungen daran  informiert werden. Weiterhin ist
es wichtig, dass Sie sich die Zeit nehmen den Benutzern beim Verständnis der
Richtlinie zu helfen, Ihnen zu erklären warum diese unterschrieben werden sollte
und was geschieht, wenn Sie sich entgegen der Richtlinie verhalten (auch dieses
sollte in der Sicherheitsrichtlinie enthalten sein). Dieses sollte auch
mindestens einmal im Jahr wiederholt werden. Zum einen, da es Änderungen geben
kann, aber auch um die Benutzer an die Richtlinie zu erinnern.
</p>

<note>
Erstellen Sie Richtlinien, die einfach zu lesen und in jedem Zusammenhang sehr
präzise sind.
</note>

<p>
Eine Sicherheitsrichtlinie sollte mindestens die folgenden Punkte beinhalten:
</p>

<ul>
  <li>Akzeptable Anwendung</li>
  <li>
  <ul>
    <li>Bildschirmschoner</li>
    <li>Behandlung von Kennworten</li>
    <li>Herunterladen von Programmen</li>
    <li>Wissen darüber, ob Benutzer überwacht werden</li>
    <li>Benutzung von Antiviren-Software</li>
  </ul>
  </li>
  <li>Behandlung von sensiblen Daten (jegliche schriftliche Form, Papier oder 
  Digital)</li>
  <li>
  <ul>
    <li>Sauberer Schreibtisch und verschlossene, vertrauliche Informationen</li>
    <li>PC herunterfahren vorm Verlassen</li>
    <li>Benutzung von Verschlüsselung</li>
    <li>Behandlung von Schlüsseln für vertraute Mitarbeiter</li>
    <li>Behandlung von vertraulichem Material auf Reisen</li>
  </ul>
  </li>
  <li>Behandlung der Computerausstattung auf Reisen</li>
  <li>
  <ul>
    <li>Behandlung des Laptops auf Reisen und bei Hotelaufenthalten</li>
  </ul>
  </li>
</ul>

<p>
Verschiedene Benutzer könnten verschiedene Ebenen und Arten von Zugang
benötigen, die Richtlinie kann daher entsprechend variieren.
</p>

<p>
Die Sicherheitsrichtlinie kann riesig werden und wichtige Informationen können
leicht vergessen werden. Die Richtlinie für die IT-Abteilung kann Informationen
enthalten, die gegenüber den normalen Benutzern als vertraulich gelten. Somit
ist es sinnvoll, sie in kleinere Richtlinien aufzuteilen: Richtlinie für
akzeptable Benutzung, Richtlinie für Passwörter, für E-Mail und für Fernzugriff.
</p>

<p>
Beispiele für Richtlinien können beim 
<uri link="http://www.sans.org/newlook/resources/policies/policies.htm">The 
SANS Security Policy Project</uri> gefunden werden. Wenn Sie ein kleines 
Netzwerk haben und diese Richtlinie für zu groß halten, dann sollten Sie einen
Blick auf das <uri link="ftp://ftp.isi.edu/in-notes/rfc2196.txt">
RFC2196</uri> werfen, dass ein Sicherheitshandbuch darstellt.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Die Sicherheit nach/während der Installation anziehen</title>
<section>
<title>USE Flags</title>
<body>

<p>
Die <path>make.conf</path>-Datei enthält die benutzerdefinierten und die
<path>/etc/make.profile/make.defaults</path>-Datei die Standard USE Flags. Die
wichtigen Flags für diesen Leitfaden sind <c>PAM</c> (Pluggable Authentication
Module), <c>tcpd</c> (TCP Wrapper) und <c>SSL</c> (Secure Socket Layer). Diese
sind in den Standard USE Flags enthalten.
</p>

</body>
</section>
<section id="#passwording_GRUB">
<title>GRUB Passwortschutz</title>
<body>

<p>
Grub unterstützt zwei verschiedene Wege zur Passwortkontrolle: 
Zum einen normalen Text und zum anderen md5+salt Verschlüsselung.
</p>

<p>
Fügen Sie ein Passwort in <path>/boot/grub/grub.conf</path> ein.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
Dies wird das Passwort <e>changeme</e> hinzufügen; wenn kein Passwort eingegeben
ist, wird die Standard-Boot-Einstellung genommen.
</p>

<p>
Sollte ein md5-Passwort genommen werden, dann müssen Sie das Passwort ins
Crypt-Format konvertieren, welches auch in <c>/etc/shadow</c> verwendet wird,
für weitere Informationen s. <c>man crypt</c>. Zum Beispiel könnte das
verschlüsselte Passwort <e>changeme</e> so aussehen:
<e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>
</p>

<p>
Sie können das Passwort direkt in der GRUB Shell konvertieren:
</p>

<pre caption="md5crypt in der GRUB Shell">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<comment>Typed changeme</comment>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Dann kopieren Sie das Passwort und fügen es in <path>/boot/grub/grub.conf</path>
ein.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Der Zeitablauf von 5 Sekunden wird sinnvoll, wenn das System fernbedient wird
und bei einem Neustart ohne Tastatureingaben auskommen muss. Mehr Informationen
über Grub-Passwörter können Sie bekommen, wenn Sie <c>info grub</c> ausführen.
</p>

</body>
</section>
<section id="#passwording_LILO">
<title>LILO Passwortschutz</title>
<body>

<p>
LILO unterstützt auch zwei Arten des Behandelns von Passwörtern: 
Global und per Image, beide in Klartext.
</p>

<p>
Das globale Passwort wird am Anfang der Konfigurationsdatei gesetzt und gilt für
jedes Boot Image:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
Im anderen Fall fügen Sie es einfach beim entsprechenden Image hinzu.
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
Wenn die <c>restricted</c>-Option nicht angegeben wurde, dann wird jedes Mal 
nach einem Passwort gefragt.
</p>

<p>
Um die Änderungen an <path>lilo.conf</path> zu übernehmen, müssen Sie
<c>/sbin/lilo</c> ausführen.
</p>

</body>
</section>
<section>
<title>Einschränkung der Konsolenbenutzung.</title>
<body>

<p>
<path>/etc/securetty</path> enthält Terminaltypen die es Ihnen
ermöglichen/erlauben festzulegen, von welchen <c>TTY</c> Geräten aus root sich
einloggen darf.
</p>

<p>
Wir empfehlen, dass Sie alle Zeilen bis auf <c>vc/1</c> auskommentieren. Dies
stellt sicher, dass sich root nur einmal und nur an einem Terminal einloggen
kann.
</p>

<note>
Benutzer in der 'wheel' Gruppe können weiterhin auf anderen Konsolen per <c>su
-</c> root werden.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Mehr Protokolle (Logs)</title>
<section>
<body>

<p>
Zusätzliche Protokollierung sollte hinzugefügt werden, um Warnungen oder Fehler
aufzuspüren, die auf einen momentanen oder bereits durchgeführten Angriff
hinweisen könnten. Angreifer beobachten ein Netzwerk oder durchsuchen dies oft,
bevor sie angreifen.
</p>

<p>
Es ist auch unersetzlich, dass die Protokolldateien einfach zu lesen und zu
verwalten sind. Gentoo Linux gibt ihnen die Möglichkeit bei der Installation
zwischen drei verschiedenen Protokollierungsprogrammen zu wählen.
</p>

</body>
</section>
<section>
<title>Loggen: Syslogd</title>
<body>

<p>
Syslogd ist das gängigste Protokollierungsprogramm für Linux und Unix. Es
beinhaltet keine Protokollrotation. Diese Eigenschaft wird durch das Verwenden
von <path>/usr/sbin/logrotate</path> in einem Cron Job und korrekt
konfigurierten Einstellungen in <path>/etc/logrotate.conf</path> übernommen. Wie
oft die Protokollrotation stattfinden sollte hängt von der Systembelastung ab.
</p>

<p>
Hierunter sehen Sie die Standard Konfiguration <path>/syslog.conf</path> mit
einigen zuästzlichen Features. Wir haben die <c>cron</c> und <c>tty</c> Zeilen
unkommentiert und einen Remote Logging Server hinzugefügt. Um die Sicherheit
weiter zu erhöhen, können Sie Logs an zwei Orten schreiben lassen.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# First some standard logfiles.  Log by facility.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Logging for the mail system. Split it up so that
# it is easy to write scripts to parse these files.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Logging for INN news system
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Some `catch-all' logfiles.
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Emergencies and alerts are sent to everybody logged in.
#
*.emerg                         *
*.=alert                        *

#
# I like to have messages displayed on the console, but only on a virtual
# console I usually leave idle.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

#Setup a remote logging server
*.*                        @logserver

# The named pipe /dev/xconsole is for the `xconsole' utility.  To use it,
# you must invoke `xconsole' with the `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: adjust the list below, or you'll go crazy if you have a reasonably
#      busy site..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                --/var/log/ppp.log
</pre>

<p>
Der Angreifer wird höchstwahrscheinlich versuchen seine Spuren zu verwischen,
indem er Protokolldateien bearbeitet oder löscht. Sie können es für den
Angreifer schwerer machen indem Sie das Protokoll an einen oder mehrere
Protokollserver auf verschiedenen Maschinen schicken. Mehr Informationen über
syslogd finden Sie in der Man Page (<c>man syslog</c>)
</p>

</body>
</section>
<section>
<title>Loggen: Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> von Frank Dennis bietet
nicht die Möglichkeit Protokolle an einen entfernten (remote) Server zu senden,
aber es hat Vorteile im  Bereich der Performance und der
Protokollierungsflexibilität. Es kann nach Programmnamen <!--oder nach
Einrichtung -->protokollieren (wie syslogd) und beinhaltet reguläre
Ausdrucksübereinstimmung und die Möglichkeit Kommandos auszuführen.  Sehr gut um
Handeln zu können, wenn nötig.
</p>

<p>
Die Standard Konfiguration ist meistens ausreichend. Wenn Sie benachrichtigt
werden wollen, wenn z.B. ein Anmeldevorgang fehlschlägt benutzen Sie eines der
folgenden Skripte.
</p>

<p>
Für Postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh für Postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Für Qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh für Qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Denken Sie daran das Skript mit 
<c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c> ausführbar zu machen.
</p>

<p>
Kommentieren Sie dann die Zeile unter "Password failures" in
<path>/etc/metalog/metalog.conf</path> wie folgt aus:
</p>

<pre caption="/etc/metalog/metalog.conf">
command = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Loggen: Syslog-ng</title>
<body>

<p>
Syslog-ng enthält einige derselben Funktionen wie Syslog und Metalog mit einem
kleinen Unterschied. Es ermöglicht die Filterung von Nachrichten basierend auf
Level und Inhalt (wie Metalog), bietet entferntes Protokollieren (wie syslog),
kann Protokolle von syslogd verarbeiten (sogar Streams von Solaris), auf ein TTY
ausgeben, Programme ausführen und auch als Protokollierungsserver dienen.
Grundlegend ist dies das Beste aus beiden Protokollierern kombiniert mit einer
erweiterten Konfiguration.
</p>

<p>
Eine klassische, leicht modifizierte Konfigurationsdatei:
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#Quelle von der das Log gelesen werden soll
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#Ziele festlegen
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#Filter erstellen
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#Filter und Ziele verbinden
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#Standard-Log
log { source(src); destination(console_all); };
</pre>

<p>
Syslog-ng ist sehr einfach zu konfigurieren, aber es ist auch sehr einfach etwas
zu übersehen, da die Konfigurationsdatei riesig ist. Der Autor verspricht zudem
noch einige zusätzliche Funktionen wie Verschlüsselung, Authentifizierung,
Komprimierung und MAC (Mandatory Access Control) Kontrolle. Mit diesen Optionen
wird es perfekt sein für Netzwerkprotokollierung, da der Angreifer die
Protokolle nicht ausspionieren kann.
</p>

<p>
Syslog-ng hat auch noch andere Vorteile - es muss nicht als root laufen!
</p>

</body>
</section>

<section>
<title>Protokollanalyse mit Logcheck</title>
<body>

<p>
Natürlich ist das Erstellen von Protokollen nur die halbe Miete. Ein Programm
wie Logcheck kann die regelmäßige Analyse von Protokollen sehr vereinfachen.
Logcheck ist ein Skript, zusammen mit einem Binary namens <c>logtail</c>,
welches vom Cron aufgerufen wird und die Protokolle regelmäßig mit einer Liste
verdächtiger Aktivitäten vergleicht; dann versendet es die Ausgabe per Mail an
root.
</p>

<p>
Logcheck verwendet vier Dateien um wichtige Einträge von den unwichtigen zu
filtern. Diese Dateien sind <path>logcheck.hacking</path>, welche Nachrichten
bekannter Hackerangriffe enthält, <path>logcheck.violations</path>, mit den
Signaturen von Sicherheitsverletzungen, <path>logcheck.violations.ignore</path>,
welche Schlüsselwörter enthält, die vermutlich durch die violations Datei
erkannt würden, so dass normale Einträge ignoriert werden können und
<path>logcheck.ignore</path>, mit Einträgen, die ingnoriert werden sollen.
</p>

<warn>
Lassen Sie <path>logcheck.violations.ignore</path> nicht leer, da Logcheck
<c>grep</c> zum Durchsuchen der Protokolle einsetzt und einige Versionen hiervon
interpretieren eine leere Datei als Platzhalter, was dazu führen könnte das alle
Einträge in der violations Datei ignoriert werden.
</warn>

</body>
</section>

</chapter>

<chapter>
<title>Partitionen mounten</title>
<section>
<body>

<p>
Mountet man eine <c>ext2</c>, <c>ext3</c> oder eine <c>reiserfs</c> Partition,
so gibt es mehrere Optionen die man in <path>/etc/fstab</path> einfügen kann.
Diese Optionen sind:
</p>

<ul>
  <li>
  <c>nosuid</c> - Ignoriert das SUID bit und behandelt es einfach wie eine
  normale Datei.
  </li>
  <li>
  <c>noexec</c> - Verhindert das Ausführen von Dateien von dieser Partition.
  </li>
  <li>
  <c>nodev</c> - Ignoriert Geräte.
  </li>
</ul>

<p>
Leider können diese Einstellungen leicht umgangen werden, indem man einen
nicht-direkten Pfad ausführt. Jedoch kann das Setzen von <path>/tmp</path> auf
noexec die Mehrzahl von Exploits aufhalten, welche derart gestaltet sind, dass
sie direkt von <path>/tmp</path> ausgeführt werden.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Setzt man <path>/tmp</path> in <c>noexec</c> Modus, kann dies dazu führen, dass
einige Scripts nicht richtig ausgeführt werden.
</warn>

<note>
Plattenquotas werden im Kapitel <uri link="#doc_chap6_sect3">Quotas</uri>
behandelt
</note>

<note>
Beachten Sie dass ich <path>/var</path> weder in <c>noexec</c> noch in
<c>nosuid</c> Modus setze, obwohl Dateien von diesem Mountpoint normalerweise
niemals ausgeführt werden. Der Grund dafür ist, dass qmail in
<path>/var/qmail</path> installiert ist und berechtigt sein muss eine suid-Datei
auszuführen und auf sie zuzugreifen. Ich setze <path>/usr</path> in read-only
Modus, da ich hier nichts verändere solange ich Gentoo nicht aktualisiere. Dann
mounte ich das Dateisystem erneut in read-write Modus, aktualisiere und mounte
dann erneut in read-only.
</note>

<note>
Selbst wenn Sie qmail nicht benutzen, braucht Gentoo trotzdem noch die
Ausführberechtigung in <path>/var/tmp</path>, da dort ebuilds hergestellt
werden. Jedoch kann hierfür ein alternativer Pfad eingerichtet werden, wenn Sie
darauf bestehen <path>/var</path> im <c>noexec</c> Modus zu betreiben.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Einschränkungen für Benutzer/Gruppen </title>
<section id="limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
Die Kontrolle von Ressourcenbegrenzungen kann sehr effektiv sein, wenn es darum
geht eine lokale Denial of Service Attacke zu verhindern oder die maximal
erlaubten Logins für eine Gruppe oder einen Benutzer zu handhaben.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Wenn Sie dabei sind den Wert von <c>nproc</c> oder <c>maxlogins</c> gleich 0 zu
setzen, sollten Sie diesen Benutzer vielleicht lieber löschen. Das Beispiel oben
setzt die Einstellungen für die Gruppe <c>dev</c> für Prozesse, Kerndateien und
<c>maxlogins</c>. Der Rest erhält einen Standardwert.
</p>

<note>
<path>/etc/security/limits.conf</path> ist Teil des PAM Paketes und wird nur auf
Pakete angewendet, die PAM benutzen.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> ist recht ähnlich zur Limit-Datei
<path>/etc/security/limits.conf</path>. Der einzige Unterschied ist das Format
und dass diese nur auf Benutzern oder Wild-Cards (aber keinen Gruppen) beruht.
Werfen wir einen Blick auf die Konfiguration:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Hier setzen wir die Standardeinstellungen und eine spezielle Einstellung für den
Anwender kn. Limits sind ein Teil des Shadow-Paketes und betreffen nur das
Shadow-Login-Programm. Es ist nicht notwendig irgendwelche Beschränkungen in
dieser Datei zu setzen, wenn Sie die PAM-Einstellung in
<path>/etc/make.conf</path> vorgenommen haben und PAM vollständig konfiguriert
haben.
</p>

</body>
</section>
<section>

<title>Quotas</title>
<body>

<warn>
Stellen Sie sicher, dass ihr Dateisystem Quotas unterstützt. Um Quotas auf
ReiserFS zu verwenden, müssen Sie Ihren Kernel mit folgenden Patchen versehen,
die Sie bei 
<uri link="ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">
Namesys</uri> finden. Benutzer Programme sind beim 
<uri link="http://www.sf.net/projects/linuxquota/">the Linux DiskQuota 
project</uri>zu finden. Auch wenn Quotas mit ReiserFS funktionieren, könnten 
Sie auf andere Probleme treffen, wenn Sie sie verwenden -- Sie wurden gewarnt!
</warn>

<p>
Die Anwendung von Quotas auf einem Dateisystem beschränkt die
Datenträgerverwendung je nach Gruppe oder Benutzer. Quotas werden im Kernel
aktiviert und zu einem Mount Point in <path>/etc/fstab</path> hinzugefügt.  Die
Kernel-Option wird bei der Kernelkonfiguration unter <c>File systems-&gt;Quota
support</c> aktiviert. Nehmen Sie die Einstellung vor, kompilieren Sie den
Kernel neu und starten Sie mit diesem Ihren Computer neu.
</p>

<p>
Starten Sie die Installation mit <c>emerge quota</c>. Passen Sie Ihre
<path>/etc/fstab</path> an, indem Sie usrquota und grpquota bei den Partitionen
hinzufügen, für die Sie die Nutzungsbeschränkung festlegen wollen.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Auf jeder Partition auf der Sie Quotas aktiviert haben, erstellen Sie nun die
Quota-Dateien (<path>aquota.user</path> und <path>aquota.group</path>) und
setzen diese in das Wurzelverzeichnis der Partition.
</p>

<pre caption="Erstellen der Quota-Dateien">
# <i>touch /tmp/aquota.user</i>
# <i>touch /tmp/aquota.group</i>
# <i>chmod 600 /tmp/aquota.user</i>
# <i>chmod 600 /tmp/aquota.group</i>
</pre>

<p>
Dieser Schritt muss auf jeder Partition durchgeführt werden, auf der Quotas
aktiviert wurden. Nachdem Sie die Quota-Dateien erstellt und konfiguriert haben,
müssen Sie das <c>quota</c> Initskript dem boot Runlevel hinzufügen.
</p>

<pre caption="Quota zum boot Runlevel hinzufügen">
# <i>rc-update add quota boot</i>
</pre>

<p>
Wir werden das System nun so konfigurieren, dass die Quotas einmal wöchentlich
überprüft werden. Dazu fügen Sie folgende Zeile in <path>/etc/crontab</path>
ein.
</p>


<pre caption="Quota Check in der crontab">
0 3 * * 0 /usr/sbin/quotacheck -avug
</pre>

<p>
Nachdem Sie den Rechner neu gestartet haben, ist es an der Zeit, die Quotas für
die Benutzer und Gruppen festzulegen. <c>edquota -u kn</c> wird den in $EDITOR
festgelegten Editor starten (Standard ist nano), damit Sie die Quotas des
Benutzers kn bearbeiten können. <c>edquota -g</c>  wird genau dasselbe,
allerdings für Gruppen machen.
</p>

<pre caption="Bearbeiten der Quotas für den Benutzer kn">
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Für weitere Informationen lesen Sie bitte <e>man edquota</e> oder 
<uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Das Quota Mini-Howto</uri>
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
Wenn Ihre Sicherheitsrichtlinie besagt, dass die Anwender jede Woche ihr
Passwort ändern müssen, dann setzen Sie die Variable <c>PASS_MAX_DAYS</c> auf 14
und <c>PASS_WARN_AGE</c> auf 7. Es wird ausserdem empfohlen, dass Sie alternde
Passwörter benutzen, da Brute-Force Angriffe jedes Passwort finden können,
solange ihnen genügend Zeit zur Verfügung steht. Wir empfehlen ausserdem, dass
Sie <c>LOG_OK_LOGINS</c> auf yes setzen.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Die <path>login.access</path> Datei ist auch ein Teil des Shadow-Paketes, welche
eine Tabelle zur Login Zugangskontrolle anbietet. Die Tabelle wird benutzt um zu
kontrollieren, wer sich und wer sich nicht einloggen darf, basierend auf dem
Benutzernamen, dem Gruppennamen oder dem Hostnamen von dem der Versuch gestartet
wird. Normalerweise sind alle Anwender des Systems berechtigt sich anzumelden;
aus diesem Grunde ist die Datei nur mit Kommentaren und Beispielen gefüllt.  Je
nachdem wie Sie Ihren Server oder Ihren Arbeitsplatzrechner schützen empfehlen
wir die Datei so anzupassen, das niemand anderes als Sie selbst (also der
Administrator) Zugang zur Konsole bekommt.
</p>

<note>
Diese Einstellungen sind nicht für root anwendbar.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Seien Sie vorsichtig bei der Bearbeitung der Datei. Bei Fehlern könnten Sie sich
aussperren, falls Sie nicht über root-Rechte verfügen.
</impo>

<note>
Diese Einstellungen wirken sich nicht auf SSH aus, da SSH
<path>/bin/login</path> normalerweise nicht ausführt. Dies kann durch die
Benutzung von "UseLogin yes" in <path>/etc/ssh/sshd_config</path> ermöglicht
werden.
</note>

<p>
Dies erstellt Loginzugriff so das Mitglieder von wheel sich an der Konsole
einloggen können oder wenn ihre Quelle die gentoo.org Domäne ist. Vielleicht ein
wenig zu paranoid, aber sicher ist sicher.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Dateiberechtigungen</title>
<section>
<title>Von allen lesbar</title>
<body>

<p>
Normale Benutzer sollten zu Konfigurationsdateien oder Passwörtern keinen Zugang
haben. Ein Angreifer kann Passwörter aus einer Datenbank oder von einer Webseite
stehlen und verunstalten oder noch schlimmer: Daten löschen. Deswegen ist es
notwendig, dass die Berechtigungen korrekt gesetzt sind. Wenn Sie sicher sind,
dass eine Datei nur von root benutzt wird, geben Sie ihr die Berechtigung
<c>0600</c> und ordnen Sie diese mit <c>chown</c> dem richtigen Benutzer zu.
</p>

</body>
</section>
<section>
<title>Welt/Gruppen-Schreibbar.</title>
<body>

<pre caption="Auffinden von Dateien und Verzeichnissen, die von allen schreibar sind">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Dies schafft eine riesige Datei mit Berechtigungen von allen Dateien, die
entweder Schreibberechtigungen für alle oder eine Gruppe haben. Überprüfen Sie
die Berechtigungen und eliminieren Sie die für alle schreibbaren Dateien durch
das Ausführen von <path>/bin/chmod o-w</path> für die Dateien.
</p>

</body>
</section>
<section>
<title>SUID/SGID Dateien</title>
<body>

<p>
Dateien bei denen das SUID oder SGID Bit gesetzt ist, werden mit den Rechten des
Benutzers bzw. der Gruppe ausgeführt, der diese Datei <e>gehört</e>.
Normalerweise werden diese Bits bei Dateien verwendet, die als root ausgeführt
werden müssen um ihren Zweck zu erfüllen. Diese Dateien können zu lokalen root
Einbrüchen führen (falls Sie Sicherheitslücken enthalten).  Dieses ist
gefährlich, daher sollten Dateien mit gesetztem SUID/SGID Bit auf jeden Fall
vermieden werden. Sollten Sie diese Dateien nicht verwenden, dann wenden Sie
<c>chmod 0</c> auf diese an oder unmergen das Paket welches diese Dateien
mitgebracht hat (das zugehörige Paket können Sie mit <c>equery</c> finden;
sollte es noch nicht installiert sein, dann geben Sie einfach <c>emerge
gentoolkit</c> ein). Ansonsten schalten Sie das SUID Bit mit <c>chmod -s</c>
aus.
</p>

<pre caption="Auffinden von setuid Dateien">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Dies erzeugt eine Datei mit einer Liste aller SUID/SGID Dateien.
</p>

<pre caption="Liste der setuid binären Dateien">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Standardmäßig hat Gentoo Linux nicht viele SUID Dateien (allerdings hängt es
davon ab, was Sie installiert haben), aber Sie könnten eine Liste wie die obige
erhalten. Viele dieser Befehle sollten nicht von normalen Benutzern benutzt
werden, sondern nur von root. Schalten Sie das suid bit bei <c>ping</c>,
<c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>,
<c>suidperl</c>, <c>pt_chown</c> und <c>traceroute</c> aus. Sie tun dies mit dem
Befehl <c>chmod -s</c> bei jeder einzelnen Datei. Entfernen Sie das bit nicht
von <c>su</c>, <c>qmail-queue</c> oder <c>unix_chkpwd</c>.  Dies würde dazu
führen, dass Sie nicht mehr <c>su</c> benutzen könnten und keine Mail empfangen
würden. Durch Entfernen des Bits (wenn es sicher ist, dies zu tun) beseitigen
Sie die Möglichkeit, dass ein normaler User (oder Angreifer) root Zugriff durch
eine dieser Dateien erlangen kann.
</p>

<p>
Die einzigen SUID Dateien die ich auf meinem System habe sind <c>su</c>,
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> und
<c>pwdb_chkpwd</c>. Aber wenn Sie X benutzen, könnten Sie einige mehr haben,
denn X benötigt diesen erweiterten Zugriff.
</p>
</body>
</section>

<section>
<title>SUID/SGID binaries und Hardlinks</title>
<body>

<p>
Eine Datei wird nur als gelöscht angesehen, falls keine Links mehr auf sie
zeigen.  Dies mag nach einem merkwürdigen Konzept klingen, aber bedenken Sie,
dass ein Dateiname wie <path>/usr/bin/perl</path> eigentlich nur ein Link auf
einen Inode ist, wo die Daten gespeichert sind. Eine beliebige Zahl von Links
kann auf eine Datei verweisen und solange noch einer existiert, existiert auch
die Datei.
</p>

<p>
Wenn Ihre Benutzer Zugang zu einer Partition haben, die nicht mit <c>nosuid</c>
oder <c>noexec</c> eingebunden sind (z. B. falls <path>/tmp</path>,
<path>/home</path>, oder <path>/var/tmp</path> nicht auf unterschiedlichen
Partitionen liegen), sollten Sie darauf achten, dass Benutzer keine Hardlinks
auf SUID oder SGID Binaries erstellen, so dass Sie nach einem Update durch
Portage immer noch Zugang zu alten Versionen haben.
</p>

<warn>
Wenn Portage eine Warnung über verbliebene Hardlinks ausgegeben hat und Benutzer
Schreibrechte auf einer Partition haben, welche die Ausführung von SUID/SGID
Dateien erlaubt, dann sollten Sie diesen Abschnitt aufmerksam lesen.  Einer der
Benutzer könnte versuchen das Update zu umgehen indem er eine alte Version eines
Programmes behält. Falls Benutzer keine eigenen SUID Dateien erstellen können
oder falls Sie Programme nur über den dynamischen Loader ausführen können
(Partitionen mit <c>noexec</c> eingebunden), dann brauchen Sie sich keine Sorgen
zu machen.
</warn>

<note>
Benutzer brauchen keinen Lesezugriff auf eine Datei um einen Link zu ihr zu
erstellen; es werden lediglich Leserechte für das Verzeichnis benötigt in dem
sie sich befindet.
</note>

<p>
Um herauszufinden wie viele Links eine Datei, kann der <c>stat</c> Befehl
verwendet werden.
</p>

<pre caption="Stat Befehl">
$ stat /bin/su
  File: `/bin/su'
  Size: 29350           Blocks: 64         IO Block: 131072 regular file
Device: 900h/2304d      Inode: 2057419     Links: 1
Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2005-02-07 01:59:35.000000000 +0000 Modify: 2004-11-04 01:46:17.000000000 +0000
Change: 2004-11-04 01:46:17.000000000 +0000
</pre>

<p>
Um SUID und GUID Dateien mit mehreren Links zu finden, kann <c>find</c>
verwendet werden.
</p>

<pre caption="SUID/SGID Dateien mit mehreren Links finden">
$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls
</pre>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM ist eine Sammlung von shared libraries, die eine Alternative für
Authentifizierungen in Programmen darstellen. Das <c>pam</c> USE flag ist
standardmäßig gesetzt. Die PAM Einstellungen von Gentoo Linux sind relativ
vernünftig, aber es gibt immer Platz für Verbesserungen. Zunächst installieren
wir cracklib.
</p>

<pre caption="Installieren von cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth  required pam_unix.so shadow nullok
account required pam_unix.so
password  required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password  required pam_unix.so md5 use_authtok
session required pam_unix.so
</pre>

<p>
Dies fügt die cracklib hinzu, welche sicherstellt, dass der Benutzer eine
minimale Passwortlänge von acht Zeichen benutzt, bestehend aus mindestens zwei
Zahlen und zwei sonstigen Zeichen, weiterhin müssen mindestens drei Zeichen
anders sein als beim letzten Passwort. Dies zwingt den Benutzer ein gutes
Passwort zu wählen (Passwortrichtlinien). In der Dokumentation von 
<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">
PAM</uri> finden Sie weitere Optionen.
</p>

<pre caption="/etc/pam.d/sshd">
auth  required pam_unix.so nullok 
auth  required pam_shells.so
auth  required pam_nologin.so
auth  required pam_env.so
account  required pam_unix.so
password  required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password  required pam_unix.so shadow md5
session  required pam_unix.so
session  required pam_limits.so
</pre>

<p>
Jeder andere Dienst der nicht mit einer PAM Datei in <path>/etc/pam.d</path>
konfiguriert ist wird die Regeln in <path>/etc/pam.d/other</path> benutzen.  Die
Standardeinstellungen sind auf <c>deny</c> gesetzt, so wie es sein sollte.
Jedoch habe ich gerne viele Protokolle und deswegen habe ich <c>pam_warn.so</c>
hinzugefügt. Die letzte Konfiguration ist <c>pam_limits</c> welche von
<path>/etc/security/limits.conf</path> kontrolliert wird. Mehr zu diesen
Einstellungen im <uri link="#limits_conf">Kapitel zu
/etc/security/limits.conf</uri>.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
Dies ist ein Weg um den Zugang zu Diensten kontrollieren, die normalerweise von
inetd ausgeführt werden (welches Gentoo nicht hat), aber es kann auch von inetd
und anderen Diensten benutzt werden.
</p>

<note>
Der Dienst sollte tcpd in seinem Serverargument (in xinetd) aufrufen. Mehr
Informationen gibt das Kapitel zu xinetd.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Wie Sie sehen können ist das Format sehr ähnlich dem in
<path>/etc/login.access</path>. Tcpd unterstützt einen spezifischen Dienst; es
überlappt sich nicht mit <path>/etc/login.access</path>. Diese Einstellungen
gelten nur für Dienste die TCP Wrapper benutzen.
</p>

<p>
Es ist auch möglich Befehle auszuführen wenn auf einen Dienst zugegriffen wird
(kann benutzt werden wenn Weiterleitung für Benutzer die sich einwählen
aktiviert wird) aber es nicht empfohlen, da Menschen dazu neigen mehr Probleme
zu schaffen als Sie versuchen zu beheben. Ein Beispiel könnte sein, dass Sie ein
Script konfigurieren jedes mal eine E-Mail zu senden wenn jemand die deny-Regel
trifft, aber ein Angreifer könnte so eine DoS Attacke ausführen indem er weiter
darauf zugreift. Dies schafft viel I/O und viele E-Mails, deswegen tun Sie es
nicht! Lesen Sie <c>man 5 hosts_access</c> für weitere Informationen.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Kernelsicherheit</title>
<section>
<title>Funktionsentfernung</title>
<body>

<p>
Eine grundlegende Regel ist die Entfernung von allem was Sie nicht brauchen.
Das schafft einen kleinen Kernel und entfernt auch die Verwundbarkeiten die in
Treibern oder anderen Eigenschaften liegen können.
</p>

<p>
Ziehen Sie auch in betracht loadable module support
(=ladbare-Modulunterstützung) auszuschalten. Auch wenn es möglich ist sog. Root
Kits ohne diese Eigenschaft hinzuzufügen, wird es doch schwerer für den normalen
Angreifer Root Kits über Kernelmodule zu installieren.
</p>

</body>
</section>
<section>
<title>Das proc Dateisystem</title>
<body>

<p>
Viele Kernel Parameter können durch das <path>/proc</path> Dateisystem oder
durch die Benutzung von <c>sysct1</c> verändert werden.
</p>

<p>
Um Kernelparameter und -variablen dynamisch zu ändern, muss <c>CONFIG_SYSCTL</c>
in Ihrem Kernel definiert sein. Dies ist voreingestellt im Standard 2.4 Kernel.
</p>

<pre caption="IP Forwarding deaktivieren">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Stellen Sie sicher, dass IP Forwarding deaktiviert ist. Dieses benötigen wir
lediglich bei einem Rechner in mehreren Netzen. Es ist anzuraten, diese
Einstellung vor allen anderen vorzunehmen, da mit ihr auch andere (de)aktiviert
werden.
</p>

<pre caption="Entfernen von ping-Paketen">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Dies veranlasst den Kernel alle ping Pakete (auch bekannt als ICMP Typ 0 Pakete)
zu ignorieren). Der Grund hierfür ist, dass IP Pakete, welche ICMP Nachrichten
beinhalten auch andere Informationen beinhalten können als Sie denken.
Administratoren benutzen ping häufig als Diagnosewerkzeug und beschweren sich,
wenn es deaktiviert ist; es gibt aber für einen Aussenseiter keinen Grund in der
Lage sein zu müssen, pings zu verwenden. Nichtsdestotrotz ist es manchmal
nützlich von innen ping benutzen zu können, dann können Sie ICMP Typ 0 Pakete in
der Firewall deaktivieren (und es dabei lokalen Administratoren erlauben ping zu
verwenden).
</p>

<pre caption="Ignorieren von broadcast-Pings">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Dies deaktiviert das Antworten auf ICMP Broadcasts und verhindern sog.
Smurf-Attacken. Diese verwenden eine ICMP Typ 0 (ping) Nachricht, welche an die
Broadcast-Adresse eines Netzwerks gesendet wird, wobei der Angreifer
typischerweise die Ursprungsadresse verschleiert. Sämtliche Rechner des Netzes
werden nun auf diese Nachricht antworten und dabei den Computer der in
Wirklichkeit die gefälschte Ursprungsadresse besitzt überfluten.
</p>

<pre caption="Sperren von source routed Paketen">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Akzeptieren Sie keine source routed Pakete. Angreifer können Source Routing
benutzen um Datenverkehr zu erzeugen, der vorgibt aus dem Netzwerk zu kommen,
jedoch eigentlich über seinen Ursprungspfad zurück geroutet wird. Source Routing
wird selten für legitime Zwecke eingesetzt, daher ist es sicher dies zu
deaktivieren.
</p>

<pre caption="Sperren von Umleitungsakzeptanz">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Akzeptieren Sie keine ICMP Umleitungspakete. Diese können zur Veränderung der
Routing Tables verwendet werden, möglicherweise zu einem böswilligen Ende.
</p>

<pre caption="Schutz gegen bad error messages">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Schalten Sie den Schutz gegen bad error messages ein.
</p>

<pre caption="Ermöglichen von rückwärtiger Pfadfilterung">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
         /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<p>
Stellen Sie reverse path filtering an. Dies hilft durch automatisches Ablehnen
von Quelladressen, die nicht mit dem Netzwerkinterface übereinstimmen,
sicherzustellen, dass Pakete legitime Quelladressen benutzen.  Dies hat
Sicherheitsvorteile, da es IP Spoofing verhindert. Wir müssen es für alle
<path>net/ipv4/conf/*</path> aktivieren, da sonst die Validierung der Quelle
nicht funktionieren kann.
</p>

<warn>
Die Nutzung von reverse path filtering kann auch ein Problem darstellen, wenn
Sie asymmetrisches Routing benutzen (Pakete von Ihnen zu einem Host nehmen einen
anderen Weg als Pakete vom Host zu Ihnen) oder wenn Sie einen Non-Routing Host
betreiben, der verschiedene IP-Adressen an verschiedenen Interfaces hat.
</warn>

<pre caption="Protokollieren aller spoofed, source routed und umgeleiteten Pakete">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Protokollieren von spoofed, source routed und umgeleiteten Pakete.
</p>

<p>
Alle diese Einstellungen werden zurückgesetzt, wenn die Maschine neu gestartet
wird. Daher schlage ich vor, dass Sie sie in <path>/etc/sysctl.conf</path>
eintragen. Diese Datei wird vom <path>/ect/init.d/bootmisc</path> Skript
ausgelesen.
</p>

<p>
Die Syntax für <path>/etc/sysctl.conf</path> ist recht gradlinig. Entfernen Sie
das <path>/proc/sys/</path> von den eben angesprochenen Pfadnamen und ersetzen
Sie <path>/</path> mit <path>.</path>:
</p>

<pre caption="Übersetzen zu sysctl.conf">
<comment>(Manuell durch echo):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automatisch in sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
Der Patch von <uri link="http://grsecurity.net">Grsecurity</uri> ist Standard im
Gentoo Kernel aber per Voreinstellung deaktiviert.  Konfigurieren Sie Ihren
Kernel wie gewohnt und konfigurieren Sie dann die Grsecurity Optionen. Eine
ausführliche Erläuterung zu den verfügbaren Grsecurity Optionen (Version 1.9)
ist auf der Seite des <uri link="http://www.gentoo.org/proj/en/hardened">Gentoo
Hardened Projekt</uri> verfügbar.
</p>

<p>
Die aktuellen <c>grsec-sources</c> enthalten die 2.* Version von Grsecurity. Für
mehr Informationen zu diesem verbessertem Patch Set konsultieren Sie bitte die
Dokumentation auf der <uri link="http://www.grsecurity.net/">Grsecurity
Homepage</uri>.
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> ist ein Patch der
Verschlüsselung zum existierenden Kernel hinzufügt. Durch patchen des Kernel
erhalten Sie neue Optionen wie: Kryptographische Chiffrierung,
Zusammenfassungsalgorithmen und Kryptographische-Schleifenfilter.
</p>

<warn>
Der Kerneli Patch ist momentan nicht in einer stabilen Version für den neuesten
Kernel verfügbar, also Vorsicht beim Gebrauch.
</warn>

</body>
</section>
<section>
<title>Andere Kernel Patches</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri></li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
Und es gibt wahrscheinlich vieles mehr.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sichern von Diensten</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) kommt mit einer recht gut eingestellten Konfigurationsdatei,
aber auch hier müssen wir einige Dinge verbessern wie z.B. das Verbinden mit
einer Adresse und die Verhinderung von Datenlecks bei der Übertragung.  Folgende
Optionen sollten Sie in der Konfigurationsdatei anpassen:
</p>

<p>
Wenn Sie <c>ssl</c> in Ihrer <path>/etc/make.conf</path> vor der Installation
von Apache nicht entfernt haben, dann sollten Sie Zugang zu einem SSL-fähigen
Server haben. Fügen Sie folgende Zeile ein, um dieses Feature zu aktivieren.
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Lassen Sie ihn auf Ihre IP hören
Listen 127.0.0.1
BindAddress 127.0.0.1
#Es ist keine gute Idee nobody oder nogroup für
#jeden Prozess der nicht als root läuft zu benutzen -
#(erstellen Sie den Benutzer apache mit der Gruppe apache)
User apache
Group apache
#Wir halten Apache davon ab, die Serverversion auszuplaudern
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache wird mit <c>--enable-shared=max</c> und <c>--enable-module=all</c>
kompiliert. Dies wird von Vorneherein alle Module aktivieren, sodass Sie alle
Module in der <c>LoadModule</c>-Sektion (also <c>LoadModule</c> und
<c>AddModule</c>) auskommentieren müssen, die Sie nicht benötigen.  Starten Sie
den Dienst neu, indem Sie <c>/etc/init.d/apache restart</c> ausführen.
</p>

<p>
Die Dokumentation gibt es auf <uri>http://www.apache.org</uri>.
</p>

</body>
</section>
<section>
<title>Bind</title>
<body>

<p>
Dokumentation zu Bind finden Sie beim 
<uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Konsortium</uri>. Das "BIND 9 Administrator Reference Manual" ist auch in
<path>doc/arm</path> verfügbar.
</p>

<p>
Die neueren BIND Ebuilds unterstützen chrooten von vorneherein. Folgen Sie nach
dem emergen von <c>bind</c> diesen simplen Anweisungen:
</p>

<pre caption="Chrooten von BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<comment>Bevor Sie diesen Befehl ausführen, möchten Sie vielleicht das chroot 
Verzeichnis in /etc/conf.d/named ändern. Ansonsten wird /chroot/dns verwendet.
</comment>
<comment>
Sie müssen möglicherweise die Versionsnummer durch die aktuelle 
ersetzen. 
</comment>
</pre>
</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns ist eine DNS Implementierung auf deren Sicherheit der Autor bereit ist
<uri link="http://cr.yp.to/djbdns/guarantee.html">Geld</uri> zu wetten. Sie
unterscheidet sich grundlegend von Bind 9, ist aber einen Versuch wert. Weitere
Informationen finden sich auf <uri>http://www.djbdns.org</uri>.
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Das Benutzen von FTP (File Transfer Protocol) ist im Allgemeinen eine schlechte
Idee. Es benutzt unverschlüsselte Daten (Passwörter werden also als Klartext
gesendet), lauscht auf zwei Ports (normalerweise 20 und 21), und anonyme Logins
sind das, wonach Angreifer gerne suchen (um Warez zu verteilen). Da das
FTP-Protokoll einige Sicherheitslücken enthält, benutzen Sie bitte alternativ
<c>sftpd</c> oder HTTP.  Wenn dies nicht möglich sein sollte, dann sichern Sie
Ihre Dienste so gut wie nur möglich ab und bereiten Sie sich vor.
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
Wenn nur lokale Anwendungen auf die <c>mysql</c> Datenbank zugreifen, dann
entkommentieren Sie die folgende Zeile in <path>/etc/mysql/my.cnf</path>.
</p>

<pre caption="Deaktivieren zu Netzwerkzugriff">
skip-networking
</pre>

<p>
Dann deaktivieren wir die Verwendung des Befehls LOAD DATA LOCAL INFILE, um ein
nicht autorisiertes Lesen von lokalen Dateien zu verhindern. Dies ist relevant
wenn neue SQL Injection Schwachstellen in PHP Applikationen gefunden werden.
</p>

<pre caption="Deaktivieren von LOAD DATA LOCAL INFILE in der [mysqld] Sektion">
set-variable=local-infile=0
</pre>

<p>
Als nächstes müssen wir die Beispielsdatenbank (test) entfernen und alle
Accounts, ausser dem lokalen <c>root</c> Account.
</p>

<pre caption="Entfernen der Beispielsdatenbank und aller unnötigen Benutzer">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Seien Sie vorsichtig mit diesem Befehl, wenn Sie schon Benutzerkonten
konfiguriert haben.
</warn>

<note>
Wenn Sie Passwörter vom MySQL Prompt aus geändert haben, sollten sie immer
<path>~/.mysql_history</path> und <path>/var/log/mysql/mysql.log</path>
bereinigen, da dort die ausgeführten SQL Befehle gespeichert werden, wie auch
die Passwörter als Klartext.
</note>
</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd hat einige Sicherheitsprobleme, aber es hat den Anschein als seien die
meisten repariert worden. Weitere Verbesserungen wären:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Mein ftp Daemon"
#Zeigen Sie nicht den Ident des Servers
ServerIdent on "Hau ab!"

#Vereinfacht es virtuelle Benutzer anzulegen
RequireValidShell off

#Benutzen Sie eine alternative Passwort- und Gruppendatei (passwd benutzt das Crypt-Format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Berechtigungen
Umask 077

# Timeouts und Beschränkungen
MaxInstances 30
MaxClients 10 "Nur 10 Verbindungen erlaubt"
MaxClientsPerHost 1 "Sie sind schon eingeloggt"
MaxClientsPerUser 1 "Sie sind schon eingeloggt"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#jeden "chroot"-en
DefaultRoot ~

#nicht als root laufen lassen
User  nobody
Group nogroup

#Jeden Transfer aufzeichnen
TransferLog /var/log/transferlog

#Probleme mit Zeichenersetzung
DenyFilter \*.*/
</pre>

<p>
Dokumentation findet man auf <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd ist ein Zweig des ursprünglichen trollftpd. Es wurde von Frank Dennis
aus Funktionalitäts- und Sicherheitsgründen modifiziert.
</p>

<p>
Benutzen Sie virtuelle Server (niemals System Accounts) indem Sie die
<c>AUTH</c> Option aktivieren. Setzen Sie diese auf
<c>-lpuredb:/etc/pureftpd.pdb</c> und erstellen Sie Ihre Benutzer mit Hilfe von
<c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Konfigurieren Sie Ihre <c>MISC_OTHER</c> Einstellung um anonymen Zugriff zu
verwehren (<c>-E</c>), chrooten Sie jeden (<c>-A</c>), verhindern Sie, dass User
Dateien lesen/schreiben können, welche mit einem "." (Punkt) beginnen
(<c>-X</c>), maximale Idle Zeit (<c>-I</c>), beschränken Sie Rekursion
(<c>-L</c>) und verwenden Sie eine sinnvolle <c>umask</c>.
</p>

<warn>
Benutzen Sie <e>nicht</e> die <c>-w</c> oder <c>-W</c> Optionen! Wenn Sie eine
Warez-Site wünschen, lesen Sie nicht weiter!
</warn>

<p>
Dokumentation kann auf <uri>http://www.pureftpd.org</uri> gefunden werden.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (kurz für "very secure ftp", also "sehr sicheres FTP") ist ein kleiner
FTP-Dämon der mit einer vernünftigen Standardkonfiguration versehen ist. Er ist
einfach und besitzt nicht so viele Möglichkeiten wie pureftp und proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#read only
write_enable=NO

#enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Wie Sie sehen können, gibt es bei diesem Dienst keine Möglichkeit individuelle
Rechte zu verwenden, wenn es aber um anonyme Einstellungen geht, ist er recht
gut.  Manchmal kann es gut sein einen anonymen FTP Server zu haben (z.B. für
Open Source) und dann leistet vsftpd hervorragende Arbeit.
</p>

</body>
</section>

<section>
<title>Qmail</title>
<body>

<p>
Qmail wird oft als der sicherste Mail-Server angesehen. Er wurde mit Sicherheit
(und Paranoia) im Hinterkopf geschrieben. Er erlaubt von Haus aus kein Relaying
und hatte seit 1996 kein Sicherheitsloch. Starten Sie einfach ein <c>emerge
qmail</c> und konfigurieren Sie es danach.
</p>
</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba ist ein Protokoll um Dateien mit Microsoft/Novell Netzwerken auszutauschen
und sollte <e>nicht</e> über das Internet verwendet werden. Nichtsdestotrotz muss
es gesichert werden.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #An ein Interface binden
  interfaces = eth0 10.0.0.1/32

  #Sicherstellen, dass verschlüsselte Passwörter verwendet werden
  encrypt passwords = yes
  directory security mask = 0700

  #Traffic von 10.0.0.* erlauben
  hosts allow = 10.0.0.

  #Aktiviert Benutzerauthentifizierung
  #(verwenden Sie nicht den share Modus)
  security = user
  
  #Verweigern von privilegierten Accounts
  invalid users = root @wheel

  #Maximalgröße die smb für ein Share anzeigt (ist kein Limit)
  max disk size = 102400

  #Die Passwortrichtlinie aufrecht erhalten
  min password length = 8
  null passwords = no

  #PAM verwenden (Wenn Support hinzugefügt)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Stellen Sie sicher, dass die Berechtigungen korrekt gesetzt sind für jedes Share
und denken Sie daran die <uri link="http://www.samba.org">Dokumentation</uri> zu
lesen.
</p>

<p>
Starten Sie den Server nun neu und fügen Sie den Benutzer hinzu, der Zugriff auf
diesen Service haben sollte. Dies geschieht durch
<path>/usr/bin/smbpasswd</path> mit dem Parameter <c>-a</c>.
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
Das einzige sichern, das OpenSSH benötigt ist aktivieren von stärkerer
Authentifizierung basierend auf der Public-Key Verschlüsselung. Viel zu viele
Seiten (wie <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri>
und <uri>http://www.apache.org</uri>) haben unter unautorisiertem Eindringen in
Ihre Systeme gelitten durch Passwortverlust oder schlechte Passwörter.
</p>

<pre caption="/etc/ssh/sshd_config">
#Nur Version 2 aktivieren
Protocol 2

#Root login deaktivieren, Benutzer müssen su verwenden um root zu erlangen
PermitRootLogin no

#Public key Authentifizierung aktivieren
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Deaktivieren von .rhost und normaler Passwortauthentifizierung
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Nur Benutzern aus der wheel oder admin Gruppe den Zugang erlauben
AllowGroups wheel admin

#In diesen Gruppen nur folgende Benutzer zulassen
#Das @&lt;Domainname&gt; ist optional, aber ersetzt die 
#ältere AllowHosts Direktive
AllowUsers kn@gentoo.org bs@gentoo.org

#Logging 
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
Stellen Sie auch sicher, dass Sie nicht <c>UsePAM yes</c> in Ihrer
Konfigurationsdatei gesetzt haben, da so der Mechanismus zur Authentifizierung
durch öffentliche Schlüssel überschreiben wird.
</p>

<p>
Nun ist alles, was Ihre Benutzer noch tun müssen, mit folgendem Befehl (auf der
Maschine von der Sie sich einloggen wollen) einen Schlüssel zu erstellen:
</p>

<pre caption="Erstellen eines DSA Schlüsselpaars">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Eine Passphrase eintippen.
</p>

<pre caption="Ausgabe von ssh-keygen">
Generierung des öffentlichen/privaten dsa Schlüsselpaares.
Geben Sie den Dateinamen ein unter dem der Schlüssel gespeichert wird (/home/kn/.ssh/id_rsa):<i>[Enter drücken]</i>
Verzeichnis erstellt '/home/kn/.ssh'.
Passsatz eingeben (leer für keinen Passsatz): <i>[Passsatz eingeben]</i>
Denselben Passsatz erneut eingeben: <i>[Erneut Passsatz eingeben]</i>
Ihre Identifikation wurde in /home/kn/.ssh/id_dsa gespeichert.
Ihr öffentlicher Schlüssel wurde in /home/kn/.ssh/id_dsa.pub gespeichert.
Der Fingerabdruck des Schlüssels ist: 
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Dies fügt zwei Dateien zu Ihrem <path>~/.ssh/</path> Verzeichnis mit den Namen
id_dsa und id_dsa.pub hinzu. Die Datei id_dsa ist Ihr privater Schlüssel und
sollte von anderen Leuten außer Ihnen Ferngehalten werden. Die andere Datei
id_dsa.pub soll an jeden Server verteilt werden zu dem Sie Zugriff haben.  Fügen
Sie den Schlüssel in das home Verzeichnis des Benutzers in
<path>~/.ssh/authorized_keys</path> ein, so sollte der Benutzer die Möglichkeit
haben sich einzuloggen.
</p>

<p>
Ihre Benutzer sollten diesen privaten Schlüssel gut verwahren. Packen Sie es auf
ein Medium, dass Sie immer mit sich tragen oder lassen Sie es auf ihrer
Workstation (fügen Sie dies in die <uri link="#security_policies">
Passwortrichtlinien</uri> ein).
</p>

<p>
Mehr über <uri link="http://www.openssh.org">OpenSSH</uri> finden Sie auf der
Webseite.
</p>


</body>
</section>
<section>
<title>Benutzung von xinetd</title>
<body>
<p>
xinetd ist ein Ersatz für <c>inetd</c> (welchen Gentoo nicht hat), den
Internet-Dienst-Daemon. Er unterstützt Zugriffskontrolle basierend auf den
Adressen der entfernten Hosts und dem Zeitpunkt des Zugriffs. Es beinhaltet auch
ausführliche Protokollfähigkeiten, inklusive Serverstartzeit, Adresse des
entfernten Hosts, entfernter Benutzername, Serverlaufzeit und geforderte
Abläufe.
</p>

<p>
Wie bei allen anderen Diensten ist es wichtig eine gute Standardkonfiguration zu
haben. Da <c>xinetd</c> aber von als root ausgeführt wird und Protokolle
unterstützt, deren Funktionsweise Sie möglicherweise nicht verstehen, raten wir
Ihnen, es nicht zu benutzen. Wenn Sie es aber dennoch benutzen wollen, fügen Sie
so mehr Sicherheit hinzu:
</p>

<pre caption="Installieren von xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Ergänzen Sie die Konfigurationsdatei um:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Dies konfiguriert pserver (cvs) durch xinetd mit den folgenden Einstellungen:
# maximal 10 Instanzen (10 Verbindungen gleichzeitig)
# Begrenzung von pserver auf tcp
# benutzen des Benutzer-cvs um diesen Dienst laufen zu lassen
# Anbinden der Schnittstelle an nur 1 IP
# Zulassen von Zugriff von 10.0.0.*
# Begrenzung der Zeit in der Entwickler auf das cvs
# zugreifen können von 08Uhr bis 17Uhr
# Benutzung von tcpd wrappers (Zugriffskontrolle kontrolliert durch 
# <i>/etc/hosts.allow</i> und <i>/etc/hosts.deny</i>)
# max_load ist an der Maschine auf 1.0 gesetzt
# die disable flag (sperren) steht auf nein, aber ich bevorzuge sie zu 
# haben, für den Fall das es gesperrt werden sollte
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Für weitere Information lesen Sie bitte <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (dies steht für "Very Secure ftp") ist ein kleiner FTP-Dämon mit einer 
einfachen Standardkonfiguration. Er ist einfach und hat nicht so viele 
Funktionen (wie z.B. virtuelle Benutzer) wie sie PureFTP und ProFTP anbieten.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#nur lesbar
write_enable=NO

#Aufzeichnen von Übertragungen aktivieren
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Wie Sie sehen können, gibt es keine Möglichkeit für diesen Dienst 
individuelle Rechte und eine standardmäßige chroot-Aktion zu konfigurieren. 
Aber wenn es um die anonymen Einstellungen geht, dann entwickelt sich dies 
zum Vorteil. Manchmal kann es gut sein einen anonymen FTP-Server z.B. zum 
Verteilen von Open-Source zu haben und dieser Server passt hierfür perfekt.
</p>

</body>
</section>
<section>
<title>X</title>
<body>
 
<p>
Standardmäßig ist Xorg konfiguriert als Xserver zu arbeiten. Dies kann
gefährlich sein, denn X verwendet unverschlüsselte TCP Verbindungen und wartet
auf xclients.
</p>

<impo>
Wenn Sie diesen Dienst nicht benötigen, deaktivieren Sie ihn!
</impo>

<p>
Wenn Sie aber Ihre Workstation als Xserver verwenden müssen, dann seien Sie
vorsichtig mit dem <c>/usr/X11R6/bin/xhost</c> Befehl. Dieser Befehl erlaubt es
Clients von anderen Hosts sich zu verbinden und Ihre Display zu benutzen. Dies
kann hilfreich sein, wenn Sie eine X Anwendung von einem anderen Rechner
benötigen und der einzige Weg über das Netzwerk führt, dies kann jedoch auch
durch einen Angreifer ausgenutzt werden. Die Syntax lautet
<c>/usr/X11R6/bin/xhost +hostname</c>
</p>

<warn>
Verwenden Sie das <c>xhost +</c> Feature niemals! Dies erlaubt es jeglichen
Clients eine Verbindung aufzubauen und Kontrolle über Ihr X zu erlangen. Wenn
ein Angreifer Zugang zu Ihrem X erlangt, kann er Ihre Tastenanschläge
protokollieren und Ihren Desktop kontrollieren. Wenn Sie es verwenden müssen,
denken Sie immer daran, einen Host zu spezifizieren.
</warn>


<p>
Eine sichere Lösung ist dieses Feature komplett zu deaktivieren, indem man X mit
<c>startx -- -nolisten tcp</c> startet oder es permanent in der Konfiguration
deaktiviert.
</p>

<pre caption="/usr/X11R6/bin/startx">
 defaultserverargs="-nolisten tcp"
</pre>

<p>
Um sicherzustellen, dass <path>startx</path> nicht überschrieben wird, wenn eine
neue Version von Xorg mit emerge installiert wird, müssen Sie es schützen. Fügen
Sie die folgende Zeile zu <path>/etc/make.conf</path> hinzu:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Wenn Sie einen graphischen Loginmanager verwenden, müssen Sie die Sache anders
angehen.
</p>


<p>
Für <c>gdm</c> (Gnome Display Manager).
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Füt <c>xdm</c> (X Display Manager) und <c>kdm</c> (Kde Display Manager)
</p>

 <pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>

</body>
</section>
<section>
<title>Chrooten</title>
<body>

<p>
Einen Dienst zu chrooten stellt eine Möglichkeit dar einen Dienst (oder
Benutzer) auf für ihn vorgesehene Ressourcen zu beschränken und zu verhindern,
dass er Zugang zu Bereichen (oder Informationen) erlangt, die zu einem
unberechtigten Besitz von root-Rechten führen könnte. Indem man einen Dienst als
ein anderer Benutzer als <c>root</c> laufen lässt (<c>nobody</c>, <c>apache</c>,
<c>named</c>) kann ein Angreifer nur Zugriff auf Dateien nehmen mit den
Berechtigungen des Users. Dies bedeutet, dass ein Angreifer nie <c>root</c>
Zugang erlangen kann, selbst wenn der entsprechende Dienst eine Sicherheitslücke
hätte.
</p>

<p>
Einige Dienste wie zum Beispiel <c>pure-ftpd</c> und <c>bind</c> haben
eingebaute Fähigkeiten für "chrooting" und andere Dienste bieten dies nicht.
Wenn der Dienst es anbietet, dann benutzen Sie es, andernfalls müssen Sie in die
Materie einsteigen und einen eigenen Benutzer erstellen. Lassen Sie es uns nun
versuchen und eine eigene chroot-Umgebung aufbauen. Um einen Einstieg zu finden
und zu sehen wie chroot arbeitet versuchen wir es zuerst mit bash (als einfachen
Einstieg ins Lernen).
</p>

<p>
Erstellen Sie das <path>/chroot</path> Verzeichnis mittels <c>mkdir
/chroot</c>. Nun müssen wir herausfinden, mit welche dynamischen Bibliotheken
<c>bash</c> benötigt (wenn sie mit <c>-static</c> kompiliert wurde, dann ist
dieser Schritt nicht nötig).
</p>

<p>
Das folgende Kommando wird eine Liste der von <c>bash</c> benutzten Bibliotheken
ausgeben.
</p>

<pre caption="Benutzte Bibliotheken auflisten">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Nun erstellen wir die Umgebung für <c>bash</c>.
</p>

<pre caption="chroot-Umgebung für bash erstellen">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Nun kopieren wir die von <c>bash</c> benutzten Dateien (<path>/lib</path>) in
das chrootete <path>lib</path> und kopieren das Kommando bash in das Verzeichnis
<path>/bin</path> im chroot. Dies wird die originale Umgebung herstellen - nur
eben mit weniger Funktionalität. Nachdem das Kopieren abgeschlossen wurde
versuchen Sie ein  <c>chroot /chroot/bash /bin/bash</c>.  Wenn Sie ein Prompt
bekommen, dass als aktuelles Verzeichnis <c>/</c> angibt, dann hat alles
funktioniert. Wenn nicht, dann werden Sie unter Umständen eine Fehlermeldung
bekommen, die die fehlende Datei angibt.  Manche dynamische Bibliotheken bauen
aufeinander auf.
</p>

<p>
Sie werden feststellen, dass innerhalb der chroot-Umgebung nichts anderes als
<c>echo</c> funktioniert. Dies ist deshalb so, weil wir keine anderen Kommandos
in unserer chroot-Umgebung haben und <c>echo</c> ein in bash eingebauter Befehl
ist.
</p>

<p>
Dies ist in etwa der Weg den Sie gehen würden, um einen "ge-chrooteten" Dienst
zu erstellen. Der einzige Unterschied ist, dass Dienste manchmal auf Geräten und
Konfigurationsdateien in <path>/etc</path> basieren.  Kopieren Sie diese einfach
in die chroot-Umgebung (Geräte können mit cp -a kopiert werden) und editieren
Sie das Init-Script sodaß es die chroot-Umgebung vor der Ausführung verwendet.
Es kann schwierig sein herauszufinden, welche Konfigurationsdateien und Geräte
ein Dienst benutzt. Dies ist der Punkt, an dem <c>strace</c> nützlich wird.
Starten Sie den Service mit <path>/usr/bin/strace</path> bash und suchen Sie
nach open, read, stat und vielleicht noch connect. Dies wird Ihnen eine Idee
darüber geben, welche Dateien Sie kopieren müssen. Aber in den meisten Fällen
kopieren Sie einfach die passwd-datei (vorher editieren und die Benutzer
entfernen, die mit dem Dienst nichts zu tun haben), <path>/dev/zero</path>,
<path>/dev/log</path> und <path>/dev/random</path> in die neue Umgebung.
</p>

</body>
</section>
<section>
<title>User Mode Linux</title>
<body>

<p>
Ein weiterer Weg eine sichere Umgebung zu erstellen besteht darin, eine
virtuelle Maschine zu verwenden. Eine virtuelle Maschine ist, wie der Name schon
sagt, ein Prozess der auf dem wirklichen Betriebssystem läuft und eine Hardware-
und Betriebssystemumgebung vorspiegelt, welche eine eigene Maschine zu sein
scheint. Der Sicherheitsgewinn hierbei ist, dass bei einer Kompromittierung der
virtuellen Maschine lediglich diese betroffen ist und nicht die
Elterninstallation.
</p>

<p>
Für weitere Informationen zum Aufsetzen von User Mode Linux können Sie den <uri
link="http://www.gentoo.org/doc/en/uml.xml">User Mode Linux Guide</uri>
(englisch) zu rate ziehen.
<!-- FIXME: UML noch nicht übersetzt -->
</p>

</body>
</section>
</chapter>

<chapter>
<title>Firewalls</title>
<section>
<title>Eine Firewall</title>
<body>

<p>
Oftmals wird eine Firewall als die ultimative Sicherheitsmaßnahme bezeichnet -
was aber falsch ist. In den meisten Fällen kann eine falsch konfigurierte
Firewall ein System sogar noch unsicherer machen, als es ohne eine Firewall
wäre. Eine Firewall ist auch eine Software und sollte genau so wie jeder andere
Dienst behandelt werden, denn auch hier können Bugs vorhanden sein.
</p>

<p>
Also denken Sie nach, bevor Sie eine Firewall in Betrieb nehmen! Brauchen Sie
wirklich eine? Wenn Sie der Meinung sind, dass Sie eine brauchen, dann verfassen
Sie eine Richtlinie wie sie funktionieren sollte, welcher Art sie sein soll und
wer sie betreiben sollte. Aber lesen Sie zuerst diese Anleitung.
</p>

<p>
Firewalls werden für folgende beiden Zwecke verwendet:
</p>

<ul>
<li>Um Benutzer (Würmer/Angreifer) draussen zu halten</li>
<li>Um Benutzer (Angestellte/Kinder) drinnen zu halten</li>
</ul>

<p>
Es gibt im Allgemeinen drei Arten von Firewalls:
</p>

<ul>
<li>Paket-Filter</li>
<li>>>>> S.o please translate >>>> Circuit relay</li>
<li>Applikationsgateway</li>
</ul>

<p>
Eine Firewall sollte auf einer dedizierten Maschine ohne weitere Dienste laufen
(und wenn, dann höchstens noch <c>sshd</c>) und so abgesichert werden, wie
dieser Leitfaden es vorschlägt.
</p>

</body>
</section>
<section>
<title>Paket-Filter</title>
<body>

<p>
Jeglicher Netzwerkverkehr basiert auf Paketen. Große Datenmengen werden in
kleinere Pakete zerlegt (da diese einfacher zu handhaben sind) und bei der
Ankunft am Ziel in der richtigen Reihenfolge wieder zusammengesetzt. Jedes Paket
enthält Informationen darüber wie es wohin transportiert werden soll. Und genau
diese Informationen macht sich eine Firewall mit Paketfilter zu nutze. 
Filtern basiert auf:
</p>

<ul>
<li>Erlauben oder verbieten von Paketen entsprechend der Quell-/Ziel-IP-Adresse</li>
<li>Erlauben oder verbieten von Paketen entsprechend des Quell-/Ziel-Ports</li>
<li>Erlauben oder verbieten von Paketen entsprechend dem verwendeten Protokoll</li>
<li>Erlauben oder verbieten von Paketen entsprechend von bestimmten Einstellungen 
im Protokoll</li>
</ul>

<p>
In anderen Worten, diese Filtrierung auf den Daten im Kopf eines Paketes und
nicht dessen Inhalt.  </p>

<p>
Schwächen:
</p>

<ul>
  <li>
  Adressinformationen in einem Paket könnten vom Sender gefälscht
  (<e>gespoofed</e>) sein </li>
  <li>
  Daten oder Anfragen im erlaubten Paket könnten ungewollte Daten enthalten die
  ein Angreifer zu seinen Zwecken benutzen könnte, um z.B. Schwächen in den
  Diensten oder hinter der Firewall zu auszunutzen.
  </li>
  <li>Normalerweise kann ein Fehler die Firewall unbrauchbar machen</li>
</ul>

<p>
Vorteile:
</p>

<ul>
  <li>Einfach und schnell zu implementieren</li>
  <li>
  Kann Warnungen vor Angriffen verursachen, bevor diese stattfinden (erkennen
  von Portscans)
  </li>
  <li>Geeignet um SYN-Attacken zu beenden</li>
</ul>

<p>
Beispiele für freie Paketfilter für Linux:
</p>

<ul>
  <li><uri link="http://www.iptables.org">Iptables</uri></li>
  <li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
  </li>
  <li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

<note>
Es wird empfohlen iptables zu verwenden, da ipchains obsolet ist.
</note>

</body>
</section>
<section>
<title>Circuit Relay</title>
<body>

<p>
Circuit Level Gateways sind Firewalls, die Verbindungen validieren bevor die
Erlaubnis für den Datenaustausch erteilt wird. Dies bedeutet, dass Pakete nicht
nur aufgrund des Inhaltes des Paketkopfes erlaubt oder verboten werden, sondern
auch geprüft wird, ob die Verbindung an beiden Enden gültig entsprechend
konfigurierbaren Regeln ist, bevor sie geöffnet oder Daten ausgetauscht werden.
Filtern basiert auf:
</p>

<ul>
  <li>Quell-/Zieladresse</li>
  <li>Quell-/Zielport</li>
  <li>Zeitraum</li>
  <li>Protokoll</li>
  <li>Nutzer</li>
  <li>Passwort</li>
</ul>

<p>
Jeglicher Verkehr wird validiert, überwacht und ungewollte Verkehr verboten.
</p>

<p>
Schwächen:
</p>

<ul>
  <li>
  Operiert auf der Transportebene und kann u.U. grundlegende Veränderungen in der
  Programmierung die normalerweise die Transportfunktionen regelt erfordern.
  </li>
</ul>

</body>
</section>
<section>
<title>Applikationsgateway</title>
<body>

<p>
Der Gateway auf der Applikationsebene ist ein Proxy für eine Applikation, die
Daten mit dem Remotesystem unter Verwendung seiner Clients austauscht.  Er wird
vor der Öffentlichkeit hinter einer DMZ (De-Militarzized Zone, demilitarisierte
Zone: der Abschnitt eines privaten Netzwerkes, welches durch die Firewall
sichtbar ist) oder einer Firewall ohne Verbindung zur Aussenwelt gesichert. Der
Filter basiert auf:
</p>

<ul>
  <li>Erlauben oder verbieten basierend auf Herkunft/Ziel</li>
  <li>Entsprechend dem Paketinhalt</li>
  <li>Dateizugriff abhängig von Dateityp oder -Erweiterung beschränken</li>
</ul>

<p>
Vorteile:
</p>

<ul>
  <li>
  Dateien können zwischengespeichert werden - das erhöht die
  Netzwerkleitung
  </li> 
  <li>Detailliertes aufzeichnen von Verbindungen</li>
  <li>
  Skaliert gut (manche Proxy-Server können die zwischengespeicherten Daten
  teilen)
  </li>
  <li>Kein direkter Zugriff von Aussen</li>
  <li>Kann Inhalte "on the fly" modifizieren</li>
</ul>

<p>
Schwächen:
</p>

<ul>
  <li>Die Konfiguration ist Komplex</li>
</ul>

<p>
Applikationsgateways werden als die sicherste Lösung angesehen, da sie nicht als
root laufen müssen und aus dem Internet nicht erreichbar sind.
</p>

<p>
Beispiel eines freien Applikationsgateways:
</p>

<ul>
  <li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Um iptables zu verwenden, muss es im Kernel aktiviert werden. Ich habe sie als
Module eingefügt (das Kommando <c>iptables</c> wird diese wenn benötigt laden)
und den Kernel neu kompiliert (aber Sie möchten iptables eventuell
einkompilieren, wenn Sie ladbare Kernelmodule, wie oben diskutiert, deaktivieren
wollen). Für mehr Informationen zur Konfiguration von iptables lesen Sie 
<uri link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">
Iptables Tutorial Chapter 2: Preparations</uri>. Nachdem Sie den Kernel neu
kompilierthaben (oder noch während der Kernel kompiliert wird) müssen Sie das
<c>iptables</c> Kommando hinzufügen. Führen Sie einfach nur <c>emerge
iptables</c> aus und alles sollte funktionieren.
</p>

<p>
Nun probieren Sie bitte ob alles funktioniert, indem Sie <c>iptables -L</c>
ausführen. Wenn irgendetwas nicht funktioniert, dann sollten Sie die
Konfiguration nochmals überprüfen.
</p>

<p>
Iptables ist der neue und extrem verbesserte Paketfilter in Linux 2.4.x. Es ist
der Nachfolger von ipchains aus dem Linux 2.2.x Kernel. Eine der großen
Verbesserungen ist, dass iptables nun in der Lage ist "stateful" Packet
Filtering durchzuführen. Mit "stateful" Packet filtering ist es möglich die Spur
jeder errichteten TCP Verbindung zu verfolgen.
</p>

<p>
Eine TCP Verbindung besteht aus einer Serie von Paketen die Informationen über
die Quelladresse, die Zieladresse, den Quell- und Zielport enthält, sowie eine
Sequenznummer, welche das richtige Zusammensetzen der Daten ermöglicht. TCP ist
im Gegensatz zu UDP ein verbindungsorientiertes Protokol, UDP ist
verbindungslos.
</p>

<p>
Bei der Prüfung der Header der TCP Pakete kann ein "stateful" Paketfilter
bestimmen, ob ein empfangenes TCP Paket zur einer bestehenden Verbindung gehört
oder nicht und das Paket entweder akzeptieren oder wegwerfen.
</p>

<p>
Mit einem "stateless" Paketfilter is es möglich, dem Paketfilter Pakete durch
das manipulieren des TCP Paket Header unterzuschieben die eigentlich gedroppt
werden sollten. Dies kann durch das manipulieren des SYN Flag oder anderer Flags
im TCP Header erreicht werden. Mit "stateful" Packet Filtering ist es möglich
solche Pakete zu droppen, da Sie keiner bestehenden Verbindung zuzuordnen sind.
Damit wird auch die Möglichkeit von "stealth scans" verhindertn, da solche
Pakete ebenfalls keiner bestehenden Verbindung zuzuordnen sind.
</p>

<p>
Iptables bietet einige weitere Möglichkeiten wie zum Beispiel
Wiederholungsbegrenzung (rate limiting). Diese Fähigkeit ist extrem nützlich,
wenn man bestimmte DoS (Denial of Service)-Angriffe wie auch einen SYN-Angriff
verhindern will.
</p>

<p>
Eine TCP-Verbindung wird durch einen sogenannten Drei-Wege-Handschlag aufgebaut.
Wenn eine TCP Verbindung sendet der Client ein Paket mit einem SYN Flag an den
Server. Wenn die Server-Seite das SYN Paket empfängt reagiert sie, in dem sie
ein SYN+ACK Paket an den client schickt. Wenn der SYN+ACK vom Client empfangen
wird, erkennt dieser wiederum mit einem dritten ACL Paket die Verbindung an.
</p>

<p>
Ein SYN-Angriff geschieht, wenn nur ein SYN-Paket gesendet wird, aber das Senden
des SYN+ACK Paket fehlschlägt. Der Client kann ein Paket mit einer gefälschten
IP-Adresse senden, da es keine Antwort benötigt. Der Server wird beim Empfang
eines SYN Paket einen Eintrag in die Liste halb-geöffneter Verbindungen machen
und dann auf den finalen ACK warten, bis der Eintrag gelöscht wird. Der Queue
hat eine begrenzte Anzahl von Slots, wenn alle Slots belegt sind können keine
neuen Verbindungen aufgebaut werden. Wenn der ACK nicht innerhalb eines
begrenzten Zeitraums beim Server ankommt timed die Verbindung aus, der Eintrag
wird aus der Queue gelöscht.  Die Timeout Einstellungen variieren, liegen aber
typischerweise im Bereich von 30 bis 60 Sekunden oder mehr. Die Clientseite
initiiert die Attacke durch das Aussenden einer größtmöglichen Zahl von SYN
Paketen mit verschiedenen Source IP Adressen. Dadurch wird die Liste
halb-geöffneter Verbindungen schnell gefüllt, so dass andere Clients davon
abgehalten werden eine Verbindung zu diesem Server aufzubauen.
</p>

<p>
Hier wird das Ratenlimit besonders hilfreich. Es ist möglich die Anzahl von
SYN-Pakten von einer bestimmten Quelle zu begrenzen, aber durch Gebrauch von
<c>-m limit --limit 1/s</c> begrenzt dies das Limit der SYN-Pakete für eins pro
Quelle und daher begrenzt die SYN-Flut auf unsere Ressourcen.
</p>

<note>
Eine weitere Möglichkeit SYN-Fluten vorzubeugen sind 
<uri link="http://cr.yp.to/syncookies.html">SYN cookies</uri>, welche es dem 
Computer erlauben auf SYN Pakete zu Antworten ohne die Verbindungs-Queue
aufzufüllen. SYN cookies können in der Linux Kernel Konfiguration aktiviert
werden; z. Z. werden sie aber als experimentell angesehen.
</note>

<p>
Jetzt einiger praktischer Kram!
</p>

<p>
Wenn iptables in den Kernel geladen wird, hat es fünf Aufhänger an die Sie ihre
Regeln hängen können. Sie heissen <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>,
<c>PREROUTING</c> und <c>POSTROUTING</c>. Diese Listen nennt man Ketten, da sie
per zugefügter Regel funktionieren und überprüfen die Regeln eine nach der
anderen in der Reihenfolge wie sie hinzugefügt wurden. Wenn eine Regel auf ein
Paket nicht zutrifft wird es an die nächste Regel weitergeleitet.
</p>

<p>
Sie können Regeln direkt in die fünf Hauptketten setzen oder Ketten erstellen
und diese als Regel zu einer existierenden Kette hinzufügen. Iptables
unterstützt die folgenden Optionen.
</p>

<table>
  <tr>
  <th>Option:</th>
  <th>Beschreibung:</th>
  </tr>
  <tr>
  <ti>-A</ti>
  <ti>Anhängen</ti>
  </tr>
  <tr>
  <ti>-D</ti>
  <ti>Löschen</ti>
  </tr>
  <tr>
  <ti>-I</ti>
  <ti>Einfügen</ti>
  </tr>
  <tr>
  <ti>-R</ti>
  <ti>Ersetzen</ti>
  </tr>
  <tr>
  <ti>-L</ti>
  <ti>Auflisten</ti>
  </tr>
  <tr>
  <ti>-F</ti>
  <ti>Löscht alle Regeln in der Kette oder in allen Ketten</ti>
  </tr>
  <tr>
  <ti>-Z</ti>
  <ti>Keine Counter in der Kette oder in allen Ketten</ti>
  </tr>
  <tr>
  <ti>-C</ti>
  <ti>Teste dieses Paket an der Kette</ti>
  </tr>
  <tr>
  <ti>-N</ti>
  <ti>Erstellen einer neuen benutzerdefinierten Kette</ti>
  </tr>
  <tr>
  <ti>-X</ti>
  <ti>Löschen einer benutzerdefinierten Kette</ti>
  </tr>
  <tr>
  <ti>-P</ti>
  <ti>Richtlinie der Kette bezüglich des Ziels ändern</ti>
  </tr>
  <tr>
  <ti>-E</ti>
  <ti>Ändern des Kettennamens</ti>
  </tr>
  <tr>
  <ti>-p</ti>
  <ti>Protokoll</ti>
  </tr>
  <tr>
  <ti>-s</ti>
  <ti>Quelladresse/maske</ti>
  </tr>
  <tr>
  <ti>-d</ti>
  <ti>Zieladresse/maske</ti>
  </tr>
  <tr>
  <ti>-i</ti>
  <ti>Eingabename (Ethernetname)</ti>
  </tr>
  <tr>
  <ti>-o</ti>
  <ti>Ausgabename (Ethernetname)</ti>
  </tr>
  <tr>
  <ti>-j</ti>
  <ti>Jump (Ziel für Regel)</ti>
  </tr>
  <tr>
  <ti>-m</ti>
  <ti>Erweiterter Treffer (Kann Erweiterung benutzen)</ti>
  </tr>
  <tr>
  <ti>-n</ti>
  <ti>Numerische Ausgabe von Adressen und Ports</ti>
  </tr>
  <tr>
  <ti>-t</ti>
  <ti>Zu ändernde Tabelle</ti>
  </tr>
  <tr>
  <ti>-v</ti>
  <ti>Ausführliche Ausgabe</ti>
  </tr>
  <tr>
  <ti>-x</ti>
  <ti>Zahlen Erweitern (exakte Werte anzeigen)</ti>
  </tr>
  <tr>
  <ti>-f</ti>
  <ti>Nur auf die zweiten oder weitere Pakete achten</ti>
  </tr>
  <tr>
  <ti>-V</ti>
  <ti>Paketversion</ti>
  </tr>
  <tr>
  <ti>--line-numbers</ti>
  <ti>Zeilennummern mit ausgeben</ti>
  </tr>
</table>

<p>
Zuerst werden wir versuchen alle ICMP-Pakete an unsere Maschine zu blocken - nur
um uns mit iptables vertraut zu machen.
</p>

<pre caption="Alle ICMP-Pakete blocken">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Zuerst legen wir die Kette fest, an die es angehängt werden soll, dann das
Protokoll und schließlich das Ziel. Das Ziel kann eine Benutzer spezifierte
Regel oder eines der speziellen Ziele <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>,
<c>LOG</c>, <c>QUEUE</c>, <c>MASQUERADE</c> sein. In diesem Fall benutzen wir
<c>DROP</c>, welches das Paket ohne irgendeine Antwort an den Client fallen
lässt.
</p>

<note>
Das <c>LOG</c> ist "nicht-beendent". Falls eine Regel mit dem Ziel <c>LOG</c>
auf ein Paket zutrifft, wird dieses Paket auch weitere Regeln durchlaufen und
die weitere Verarbeitung wird nicht abgebrochen. Dieses erlaubt das
Protokollieren von Pakete während sie normal verarbeitet werden.
</note>

<p>
Nun versuchen Sie ein <c>ping localhost</c>. Es wird nicht möglich sein, eine
Antwort zu bekommen, da das komplette ICMP-Protokoll eingehend geblockt wird. Es
wird auch nicht möglich sein, andere Maschinen anzupingen, da die Pakete nicht
mehr von den anderen Rechnern in unseren Rechner kommen können. Nun leeren Sie
die Kette um ICMP wieder zum Laufen zu bekommen.
</p>

<pre caption="Alle Regeln leeren (Flush)">
# <i>iptables -F</i>
</pre>

<p>
Nun sehen wir uns die stateful Paketfilterung in iptables an. Wenn wir eine
Prüfung bezüglich des Verbindungszustandes an eth0 haben wollen, könnten wir
dies folgendermaßen aktivieren:
</p>

<pre caption="Pakete die zu einer bereits bestehenden Verbindung gehören akzeptieren">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Dies wird in der INPUT-Kette alle Pakete die zu einer bereits bestehenden oder
einer verwandten Verbindung gehören akzeptieren. Man könnte auch jedes Paket,
dass nicht in der Zustandstabelle abgedeckt wurde fallen lassen, indem man
<c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> direkt davor
aufruft. Dies aktiviert die stateful Paketfilterung in iptables indem es die
Erweiterung "state" lädt. Wenn Sie nun von Aussen mit Ihrer Maschine, dann
könnten Sie <c>--state NEW</c> benutzen. Iptables enthält einige
unterschiedliche Module für unterschiedliche Anwendungszwecke. Einige dieser
Module sind:
</p>

<table>
  <tr>
  <th>Modul/Treffer</th>
  <th>Beschreibung</th>
  <th>Erweiterte Optionen</th>
  </tr>
  <tr>
  <ti>mac</ti>
  <ti>Prüfung auf die Quell-MAC-Adressen der eingehenden Pakete.</ti>
  <ti>--mac-source</ti>
  </tr>
  <tr>
  <ti>state</ti>
  <ti>Prüfung auf Zustand</ti>
  <ti>--state (passende Werte sind ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
  <ti>limit</ti>
  <ti>Trefferrate begrenzen</ti>
  <ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
  <ti>owner</ti>
  <ti>Prüfung auf diverse Fähigkeiten des Paketgenerators</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
  </tr>
  <tr>
  <ti>unclean</ti>
  <ti>Diverse Gültigkeitsprüfungen auf den Paketen</ti><ti></ti>
  </tr>
</table>

<p>
Lassen Sie uns nun eine benutzerdefinierte Kette erstellen und in einer der
existierenden Ketten einbetten:
</p>

<pre caption="Benutzerdefinierte Kette erstellen">
<comment>Neue Kette mit einer Regel erstellen</comment>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>Die Standardrichtlinie sagt, dass jeglicher ausgehender Verkehr erlaubt ist, aber eingehender verboten.</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>And add it to the INPUT chain</comment>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
Indem man die Regel in die INPUT-Kette einpasst bekommt man die Richtlinie:
Alles darf raus, aber alles reinkommende wird verworfen ("gedroppt").
</p>

<p>
Man findet  Dokumentation in der 
<uri link="http://www.iptables.org/documentation/index.html#HOWTO">
Netfilter/iptables Dokumentation</uri>.
</p>

<p>
Schauen wir uns nun ein komplettes Beispiel an. In diesem Falle sagt meine
Firewall-/Gateway-Richtlinie:
</p>

<ul>
  <li>Verbindungen zur Firewall wird nur über SSH erlaubt (Port 22)</li>
  <li>
  Das lokale Netz soll Zugriff auf HTTP, HTTPS und SSH haben (DNS sollte auch
  erlaubt sein)
  </li>
  <li>
  ICMP-Verkehr könnte kritische Daten enthalten und sollte deswegen nicht
  erlaubt sein. Natürlich gibt es einige Ausnahmen
  </li>
  <li>Portscans sollten erkannt und aufgezeichnet werden</li>
  <li>SYN-Angriffe sollten abgewehrt werden</li>
  <li>Jeglicher anderer Verkehr sollte blockiert und aufgezeichnet werden</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#Innen
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#Aussen
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setze interne Regeln"

  einfo "Setze Standardregel auf Fallenlassen"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #Standardregel
  einfo "Erstelle Zustands-Kette"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \
      "Böses Paket von ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP Verkehr
  einfo "Erstelle ICMP-Kette"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Eingehender Verkehr
  einfo "Erstelle Kette für eingehenden SSH-Verkehr"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood-Schutz
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state -state RELATED,ESTABLISHED -p tcp -dport ssh -j ACCEPT

  #Ausgehender Verkehr
  einfo "Erstelle Kette für ausgehenden SSH-Verkehr"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Erstelle Kette für ausgehenden DNS-Verkehr"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Portscanner fangen
  einfo "Erstelle Portscan-Erkennungs-Kette"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Ungültige Zustände in den Ketten einpassen
  einfo "Passe Ketten in INPUT an"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Passe Ketten in FORWARD an"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Passe Ketten in OUTPUT an"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #erlaube den Clients über NAT (Network Address Translation) zu routen
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE
  eend $?
}

start() {
  ebegin "Starte Firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} existiert nicht. Benutze Standardregeln."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Halte Firewall an"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setze Panikregeln"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Sichere Firewallregeln"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Stelle Firewallregeln wieder her"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Benutzung: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      Wird die Standardeinstellung wieder herstellen oder andernfalls zu Regeln zwingen"
  echo "stop)       Alle Regeln löschen und alles akzeptieren"
  echo "rules)      zu Einstellungen der neuen regeln zwingen"
  echo "save)       speichert die Regeln in ${FIREWALL}"
  echo "restore)    stellt die Regeln von ${FIREWALL} wieder her"
  echo "showstatus) Status anzeigen"
}
</pre>

<p>
Einige Ratschläge für das Erstellen einer Firewall:
</p>

<ol>
  <li>Erstellen Sie vor der Implementierung eine Richtlinie für die Firewall</li>
  <li>Halten Sie sie einfach</li>
  <li>
  Erlangen Sie Wissen über die Protokolle (lesen Sie das 
  <uri link="http://www.ietf.org/">RFC (Request For Comments)</uri>)
  </li>
  <li>
  Denken Sie daran, dass eine Firewall ein weiteres Paket ist, dass als root
  läuft
  </li>
  <li>Testen Sie die Firewall</li>
</ol>

<p>
Wenn Sie denken, dass iptables schwer zu verstehen sind oder es zu lange dauert
eine sinnvolle Firewall zu erstellen, dann könnten Sie auch 
<uri link="http://www.shorewall.net">Shorewall</uri> benutzen. Es benutzt im
Grunde genommen iptables um eine Firewall zu erstellen, aber es konzentriert
sich auf Regeln und nicht auf spezielle Protokolle.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid ist ein sehr leistungsstarker Proxy Server. Er kann Datenverkehr basierend
auf Zeitpunkt, regulären Ausdrücken für Pfad/URI, Quell- und Zieladresse (IP),
Domäne, Browser, dem authentifizierten Benutzernamen, MIME-Typ und Port
(Protokoll). Wahrscheinlich habe ich einige Funktionen vergessen, aber es ist
schwer die gesamte Liste abzudecken.
</p>

<p>
Im folgenden Beispiel habe ich einen Banner Filter hinzugefügt anstatt eines
Filters basierend auf pornographischen Seiten. Der Grund dafür ist, dass
Gentoo.org <e>nicht</e> als eine pornographische Seite aufgelistet werden
sollte. Ausserdem will ich meine Zeit nicht damit verbringen einige gute Seiten
für Sie zu finden.
</p>

<p>
In diesem Fall diktiert meine Richtlinie:
</p>

<ul>
  <li>
  Surfen (HTTP/HTTPS) ist während der Arbeitszeiten erlaubt (Mo-Fr 8-16 und Sa
  8-13), wenn Angestellte länger da sind, sollten sie arbeiten und nicht surfen.
  </li>
  <li>
  Das Herunterladen von Dateien ist nicht erlaubt (.exe, .com, .arj, .zip, .asf,
  .avi, .mpg, .mpeg etc.) </li>
  <li>
  Banner sind unerwünscht, daher werden sie herausgefiltert und mit einem
  transparenten GIF ersetzt (hier können Sie kreativ werden!)
  </li>
  <li>
  Jede andere kommende oder gehende Verbindung mit dem Internet ist nicht
  erlaubt.
  </li>
</ul>

<p>
Dies wird in vier <e>einfachen</e> Schritten implementiert .
</p>

<pre caption="/etc/squid/squid.conf">
# Anbinden an eine IP und einen Port
http_port 10.0.2.1:3128

# Standardkonfiguration
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Hinzufügen von grundlegenden Listen der Zugriffskontrolle 
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Hinzufügen wer auf diesen Proxy Server zugreifen kann
acl localnet src 10.0.0.0/255.255.0.0

# Und welche Ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Hinzufügen von Listen zur Zugriffskontrolle basierend 
# auf regelmäßigen Ausdrücken innerhalb von URLs
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Hinzufügen von Listen zur Zugriffskontrolle basierend 
# auf Datum und Uhrzeit
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Erlauben von Managmentzugriff von Localhost
http_access allow manager localhost
http_access deny manager

# Nur Purge Anfragen von Localhost erlauben
http_access allow purge localhost
http_access deny purge

# Verweigern von Anfragen an unbekannte Ports
http_access deny !Safe_ports

# Verweigern von CONNECT an alle ausser SSL Ports
http_access deny CONNECT !SSL_ports

# Meine eigenen Regeln


# Hinzufügen einer Seite zur Darstellung,
# wenn ein Banner entfernt wurde
deny_info NOTE_ADS_FILTERED url_ads

# Dann diese verweigern
http_access deny url_ads

# Verweigern aller Archive
http_access deny archives

# Begrenzung des Zugriffs auf Arbeitszeiten
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Verweigern von allem anderen
http_access deny all
</pre>

<p>
Als nächstes fügen Sie alle Dateitypen ein, von denen Sie nicht wollen, dass
Ihre Benutzer sie herunterladen können. Ich habe zip, viv, exe, mp3, rar, ace,
avi, mov, mpg, mpeg, au, ra, arj, tar, gz und z Dateien gewählt. 
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
 \.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Beachten Sie bitte die [] mit Groß- und Kleinbuchstaben fuer jeden Buchstaben.
Dies dient dazu, dass niemand es umgehen kann indem er eine Datei mit AvI abruft
anstatt avi.
</note>

<p>
Als nächstes fügen wir die regulären Ausdrücke ein um Banner zu identifizieren.
Sie werden wahrscheinlich viel kreativer sein als ich:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Nun der letzte Teil: Wir wollen diese Datei anzeigen, wenn das Banner entfernt
wird. Es ist grundlegend eine halbe HTML Datei mit einem 4x4 transparenten GIF
Bild.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>FEHLER: Die angeforderte URL konnte nicht angezeigt werden&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Anzeige gefiltert!&lt;/H1&gt;
</pre>

<note>
Schließen Sie die &lt;HTML&gt; &lt;BODY&gt; Tags nicht. Dies wird von Squid
erledigt.
</note>

<p>
Wie Sie sehen können hat Squid eine Vielzahl von Möglichkeiten und ist sehr
effektiv zum Filtern und als Proxy. Es kann sogar alternative Squid Proxys
benutzen um an sehr große Netzwerke angepasst zu werden. Die Konfiguration, die
ich hier aufgelistet habe ist hauptsächlich fuer kleine Netzwerke mit 1-20
Benutzern geeignet.
</p>

<p>
Jedoch die Kombination von Paketfilterung (iptables) und dem Anwendungsgateway
(squid) ist wahrscheinlich die beste Lösung, selbst wenn Squid selber an einem
sicheren Ort stationiert ist und niemand von ausserhalb darauf zugreifen kann.
Wir müssen uns weiterhin Gedanken machen um Angriffe von Innen.
</p>

<p>
Nun müssen Sie den Proxy Server in die Einstellungen des Browsers Ihrer
Benutzers einbinden. Das Gateway verhindert, dass die Benutzer jeglichen Kontakt
mit der Aussenwelt haben, solange sie nicht den Proxy benutzen.
</p>

<note>
In Mozilla geschieht dies in Bearbeiten->Einstellungen->Erweitert->Proxies (bzw.
Edit->Preferences->Advanced->Proxies).
</note>

<p>
Es kann auch transparent geschehen, indem man iptables benutzt um den gesamten
ausgehenden Datenverkehr an einen Squid Proxy weiterzuleiten. Dies kann erreicht
werden, indem man eine Weiterleitungs/Prerouting Regel für das Gateway
hinzufügt:
</p>

<pre caption="Ermöglichen von Portweiterleitung an unseren Proxy Server">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Falls der Proxy auf dem Rechner läuft, der auch die Paketfilterung durchführt --
auch wenn dies nicht empfohlen wird, könnte es aufgrund von Mangel an Maschinen
nötig sein -- benutzen Sie ein <c>REDIRECT</c> Ziel an Stelle von <c>DNAT</c>
(<c>REDIRECT</c> leitet Pakete an localhost weiter).
</note>

</body>
</section>
<section>
<title>Gelernte Lektionen</title>
<body>

<p>
Wir lernten, dass:
</p>

<ol>
  <li>
  Eine Firewall selbst ein Risiko sein kann. Eine schlecht konfigurierte
  Firewall ist schlechter als überhaupt keine.
  </li>
  <li>
  Wie man grundsätzlich ein Gateway und einen transparenten Proxy erstellt.
  </li>
  <li>
  Der Schlüssel zu einer guten Firewall ist es, die Protokolle zu kennen, die
  Sie zulassen wollen.
  </li>
  <li>
  Dass IP Traffic nicht immer legitime Daten beinhaltet, z.B. ein ICMP Paket mit
  böswilliger Nutzlast.
  </li>
  <li>Wie man SYN Angriffen vorbeugt</li>
  <li>
  Filtern von HTTP Traffic indem man anstößige Bilder und das Herunterladen von
  Viren verhindert.
  </li>
  <li>
  Kombinieren von Paketfiltern und Anwendungsgateways geben eine bessere
  Kontrolle.
  </li>
</ol>

<p>
Nun, wenn Sie <e>wirklich</e> müssen, schaffen Sie sich eine Firewall an, die
ihre Bedürfnisse deckt.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Auffinden von Eindringlingen</title>
<section>
<title>Aide (Advanced Intrusion Detection Environment)</title>
<body>

<p>
Aide ist ein Host basierendes Eindringlingserkennungssystem (HIDS, Host-Based
Intrusion Detection System), eine kostenlose Alternative zu Tripwire (falls Sie
bereits mit Tripwire vertraut sind, sollten Sie keine Schwierigkeiten haben die
Konfigurationsdateien für Aide zu erlernen). HIDS werden zu Entdeckung von
Änderungen an wichtigen Systemkonfigurationsdateien und Binaries verwenden, in
der Regel indem sie einen kryptographischen Hash-Wert für jede der zu prüfenden
Dateien erstellen und diesen an einem sicheren Ort speichern. In regelmäßigen
Abständen (z.B. täglich) werden die als "gut" bekannten Werte mit denen der
derzeitigen Kopien der Dateien verglichen, um herauszufinden, ob die Datei
geändert wurde. HIDS sind eine gute Methode um unerlaubte Änderungen am System
zu entdecken, aber es braucht ein wenig Arbeit sie ordentlich einzurichten und
gut zu verwenden.
</p>

<p>
Die Konfigurationsdatei basiert auf regelmäßigen Ausdrücken, Makros und Regeln
für Dateien und Verzeichnisse. Wir haben die folgenden Makros:
</p>

<table>
  <tr>
  <th>Makro</th>
  <th>Beschreibung</th>
  <th>Syntax</th>
  </tr>
  <tr>
  <ti>ifdef</ti>
  <ti>wenn definiert</ti>
  <ti>@@ifdef "name"</ti>
  </tr>
  <tr>
  <ti>ifndef</ti>
  <ti>wenn nicht definiert</ti>
  <ti>@@ifndef "name"</ti>
  </tr>
  <tr>
  <ti>define</ti>
  <ti>definiert eine Variable</ti>
  <ti>@@define "name" "value"</ti>
  </tr>
  <tr>
  <ti>undef</ti>
  <ti>undefiniert eine Variable</ti>
  <ti>@@undef "name"</ti>
  </tr>
  <tr>
  <ti>ifhost</ti>
  <ti>wenn "hostname"</ti>
  <ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
  <ti>ifnhost</ti>
  <ti>wenn "hostname" nicht</ti>
  <ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
  <ti>endif</ti>
  <ti>
  Endif muss benutzt werden nach jedem der obigen Makros außer define und
  undef
  </ti>
  <ti>@@endif</ti>
  </tr>
</table>

<p>
Diese Makros sind sehr praktisch, wenn Sie mehr als ein Gentoo System haben und
auf allen Aide benutzen wollen. Aber nicht alle Maschinen haben dieselben
Dienste oder gar Benutzer.
</p>

<p>
Als nächstes haben wir Gruppen von Flags um Überprüfungen an Dateien und Ordnern
durchzuführen. Diese sind eine Kombination aus Berechtigungen,
Dateieigenschaften und kryptographischen Hashes/Prüfsummen.
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>p</ti>
  <ti>Berechtigungen</ti>
  </tr>
  <tr>
  <ti>i</ti>
  <ti>Inode</ti>
  </tr>
  <tr>
  <ti>n</ti>
  <ti>Anzahl der Links</ti>
  </tr>
  <tr>
  <ti>u</ti>
  <ti>Benutzer</ti>
  </tr>
  <tr>
  <ti>g</ti>
  <ti>Gruppe</ti>
  </tr>
  <tr>
  <ti>s</ti>
  <ti>Größe</ti>
  </tr>
  <tr>
  <ti>b</ti>
  <ti>Blockzahl</ti>
  </tr>
  <tr>
  <ti>m</ti>
  <ti>mtime</ti>
  </tr>
  <tr>
  <ti>a</ti>
  <ti>atime</ti>
  </tr>
  <tr>
  <ti>c</ti>
  <ti>ctime</ti>
  </tr>
  <tr>
  <ti>S</ti>
  <ti>Überprüfung ob die Größe wächst</ti>
  </tr>
  <tr>
  <ti>md5</ti>
  <ti>MD5 Checksumme</ti>
  </tr>
  <tr>
  <ti>sha1</ti>
  <ti>SHA1 Checksumme</ti>
  </tr>
  <tr>
  <ti>rmd160</ti>
  <ti>RMD160 Checksumme</ti>
  </tr>
  <tr>
  <ti>tiger</ti>
  <ti>Tiger Checksumme</ti>
  </tr>
  <tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
  </tr>
  <tr>
  <ti>E</ti>
  <ti>Leere Gruppe</ti>
  </tr>
  <tr>
  <ti>&gt;</ti>
  <ti>Wachsende Protokolldatei p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
Und wenn Aide mit mhash Unterstützung kompiliert ist, hat es noch einige weitere
Funktionen:
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>haval</ti>
  <ti>HAVAL Checksumme</ti>
  </tr>
  <tr>
  <ti>gost</ti>
  <ti>GOST Checksumme</ti>
  </tr>
  <tr>
  <ti>crc32</ti>
  <ti>CRC32 Checksumme</ti>
  </tr>
</table>

<p>
Nun können Sie ihre eigenen auf den oben genannten Flags basierenden Regeln
definieren, indem Sie diese folgendermaßen kombinieren:
</p>

<pre caption="Erstellen eines Regelsatzes für AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Das letzte was wir tun müssen um unsere eigene Konfigurationsdatei zu erstellen
ist zu schauen wie man diese Regeln einer Datei oder einem Verzeichnis
hinzufügt. Um eine Regel einzugeben, kombinieren Sie Datei oder Verzeichnis und
die Regel. AIDE wird alle Dateien rekursiv hinzufügen, es sei denn Sie
spezifizieren eine alternative Regel.
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>!</ti>
  <ti>Diese Datei oder dieses Verzeichnis nicht hinzufügen. </ti>
  </tr>
  <tr>
  <ti>=</ti>
  <ti>Dieses Verzeichnis hinzufügen, aber nicht rekursiv.</ti>
  </tr>
</table>

<p>
Lassen Sie uns also ein vollständiges Beispiel betrachten:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# Der Ort der Datenbank die gelesen werden soll.
database=file:@@{AIDEDIR}/aide.db

# Der Ort der Datenbank, die erstellt werden soll.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Regeldefinition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
Im obigen Beispiel definieren wir einige Makros, die angeben wo das topdir
beginnt und wo das AIDE Verzeichnis ist. AIDE überprüft die
<path>/etc/aide/aide.db</path> Datei wenn die Integrität einer Datei überprüft
wird. Jedoch wenn ein Update vorgenommen wird oder eine neue Datei erstellt
wird, speichert es die Informationen in <path>/etc/aide/aide.db.new</path>. Dies
geschieht, damit die ursprünglich Datenbankdatei nicht automatisch überschrieben
wird. Die Option <c>report_URL</c> ist eine noch nicht implementierte Funktion,
die wirklich noch keine Bedeutung hat.Die Absicht des Autoren war es, dass es
möglich wäre eine Email zu senden oder vielleicht sogar ein Script auszuführen.
</p>

<p>
Nach der Konfiguration sollten Sie Ihre Datenbankdatei erstellen indem Sie aide
-i ausführen und dann die Datei <path>/etc/aide/aide.db.new</path> nach
<path>/etc/aide/aide.db</path> kopieren und den Check zu cron hinzufügen durch
crontab -e als root.
</p>

<note>
Abhängig von Ihrer CPU, Festplattenzugriffsgeschwindigkeit und den benutzten
Flags für Dateien, kann dies einige Zeit in Anspruch nehmen.
</note>

<pre caption="Aide als cronjob einrichten">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
Denken Sie daran es so einzustellen, dass Sie die Post für root bekommen.
Ansonsten werden Sie niemals wissen was AIDE berichtet.
</note>

<p>
In diesem Fall läuft es einmal um 3 Uhr. Dies geschieht dann, denn ich will die
Benutzer beim Arbeiten nicht stören. Beachten Sie, dass ich die <c>-u</c>
(Update) Option benutzen statt <c>-C</c> (überprüfen). Denn <c>-u</c> überprüft
auch die Dateien und überschreibt nicht die Originaldatenbankdatei, was Zeit
spart, denn so müssen Sie nur eine Datei kopieren, wenn Veränderungen
festgestellt werden. Überprüfen Sie einfach die Veränderungen, um zu sehen, ob
Sie es selbst waren oder ein Angreifer der die Veränderungen gemacht hat bevor
Sie diese kopieren!
</p>

<p>
Nun gibt es einige Probleme damit die Datenbankdateien lokal zu speichern, denn
der Angreifer wird (wenn er weiss, dass Aide installiert ist)
höchstwahrscheinlich versuchen die Datenbankdatei zu verändern, ein Update der
Datenbankdatei durchzuführen oder <path>/usr/bin/aide</path> zu verändern.
Deswegen sollten Sie eine CD erstellen oder anderes Medium auf das Sie eine
Kopie der Datenbankdatei und der Aide Binärdateien ablegen.
</p>

<p>
Weitere Informationen gibt es auf der 
<uri link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri> Projektseite.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort ist ein "Network Intrusion Detection System (NIDS)". Zur Installation und
Konfiguration benutzen Sie die folgenden Beispiele.
</p>

<pre caption="Dem System einen Anwender hinzufügen">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>Schritt 1</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>Schritt 2</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>Schritt 3</comment>
include classification.config

<comment>Schritt 4</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Weitere Informationen gibt es auf der 
<uri link="http://www.snort.org">Snort</uri> Webseite.
</p>

</body>
</section>

<section>
<title>Detektion böswilliger Software mit chkrootkit</title>

<body>

<p>
HIDS wie AIDE sind sehr gut, um Änderungen am System zu bemerken, aber es
schadet nie, eine weitere Verteidigungslinie zu haben. <c>chkrootkit</c> ist ein
Werkzeug, welches typische Systemdateien auf die Anwesenheit von Rootkits
untersucht -- Programme welche entworfen wurden, um das Vorgehen eines
Eindringlings zu verstecken und seinen Zugriff aufrecht zu erhalten.  Es
durchsucht Ihr System auch nach Spuren von Keyloggern und anderer sog. Malware
(Schadsoftware). Auch wenn <c>chkrootkit</c> (und alternativen wie
<c>rkhunter</c>) sinnvolle Werkzeuge zur Systempflege und zum Aufspüren eines
Eindringlings nach einer Attacke sind, so können sie doch kein sicheres System
garantieren.
</p>

<pre caption="Schedule chkrootkit as a cronjob">
0 3 * * * /usr/sbin/chkrootkit
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Up to Date bleiben</title>
<section>
<body>
<p> 
Wenn Sie Ihr System erfolgreich installiert haben und sichergestellt haben, dass
Sie ein gutes Sicherheitslevel erreicht haben, sind Sie trotzdem noch nicht
fertig. Sicherheit ist ein fortschreitender Prozess. Die weitgehende Mehrheit
von Einbrüchen stammt von bekannten Sicherheitslücken in nicht gepatchten
Systemen. Der wohl wichtigste Schritt zu mehr Sicherheit ist es, dass System
up-to-date zu halten.
</p>

<p>
Wenn Sie eine aktuelle Version von <c>portage</c> installiert haben, dann können
Sie zuerst ihren Portage Baum mit <c>emerge --sync</c> synchronisieren und dann
den Befehl <c>glsa-check --list</c> ausführen, um zu sehen ob Ihr System in
Hinsicht auf Sicherheit aktuell ist. <c>glsa-check</c> ist ein Teil von 
<c>app-portage/gentoolkit</c>.
</p>

<pre caption="Beispielsausgabe von glsa-check -l">
#<i>glsa-check -l</i>
WARNUNG: Dieses Tool ist komplett neu und noch nicht ausgiebig getestet. 
Daher sollte es nicht in Produktionssystem verwendet werden. Es ist 
größtenteils ein Testprogramm für das neue GLSA Release und 
Veröffentlichungssystem. Seine Funktionalität wird zu einem späteren 
Zeitpunkt in emerge und equery eingewoben werden.
Bitte lesen Sie http://www.gentoo.org/proj/en/portage/glsa-integration.xml 
bevor Sie dieses Tool verwenden UND bevor sei ein Bug melden.

[A] means this GLSA was already applied, 
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
Das <c>glsa-check</c> ist momentan noch experimentell, daher sollten Sie, wenn
Sicherheit wirklich Ihr wichtigstes Anliegen ist, dies noch mit anderen
zusätzlichen Quellen überprüfen.
</warn>

<p>
Alle Zeilen mit einem  <c>[A]</c> und einem <c>[U]</c> können mit ziemlicher
Sicherheit ignoriert werden, da das System von diesem GLSA nicht beeinträchtigt
wird.
</p>

<p>
Einige Menschen bevorzugen noch <c>emerge paketname</c> anstatt von
<c>glsa-check -f</c> daher sind alle GLSA als  <c>[N]</c> aufgelistet.
</p>

<p>
Wenn Sie jedes mal eine Email erhalten möchten wenn ein GLSA herausgegeben wird,
dann melden Sie sich für die <c>gentoo-announce</c> Mailingliste an.
Instruktionen zum Anmelden und eine größere Menge anderer Mailinglisten finden
Sie unter der <uri link="/mail/en/list.xml">Gentoo Linux
Mailinglistenübersicht</uri>.
</p>

<p>
Eine andere gute Quelle für Sicherheitsinformationen ist die 
<uri link="http://www.securityfocus.com/archive/1">Bugtraq Mailingliste</uri>.
</p>

</body>
</section>
</chapter>

</guide>
