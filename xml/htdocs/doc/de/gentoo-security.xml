<?xml version='1.0' encoding='UTF-8'?>
 <!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/gentoo-security.xml,v 1.15 2004/08/10 18:13:55 dertobi123 Exp $ -->
<!DOCTYPE guide SYSTEM "http://www.gentoo.org/dtd/guide.dtd">

<!-- English CVS Version: 1.59 -->

<guide link = "/doc/de/gentoo-security.xml">
<title>Gentoo Linux Sicherheitsleitfaden</title>

<author title="Editor">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Übersetzung">
  <mail link="beejay@gentoo.org">Benjamin Judas</mail>
</author>
<author title="Übersetzung">
  <mail link="baka@users.berlios.de">Hendrik Grahl</mail>
</author>
<author title="Übersetzung">
  <mail link="dertobi123@gentoo.org">Tobias Scherbaum</mail>
</author>

<abstract>
Dieser Leitfaden ist eine Schritt-für-Schritt-Anleitung für das Absichern 
von Gentoo Linux
</abstract>

<license/>

<version>0.4.30</version>
<date>30. Juli 2004</date>

<chapter>
<title>Einleitung</title>
<section>
<body>

<p>
Dieser Guide ist für Leute gedacht, die Gentoo Linux in einer Server-Basierten
Umgebung einsetzen, oder das Gefühl haben mehr Sicherheit zu brauchen.
</p>

<note>
Wenn Sie nach dem Lesen dieses Guides an noch mehr Sicherheit
interessiert sind, sollten Sie einen Blick auf das
<uri link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo Projekt</uri>
werfen
</note>

</body>
</section>

<!--
<section>
<title>Erweiterungen für zukünftige Ausgaben dieses Leitfadens:</title>
<body>

<p>
In Version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Komplettes Systembackup mit Hilfe von Systemimager</li>
<li>Partielles Backup mittels tar</li>
<li>Backups von PostgreSQL erstellen</li>
</ul>


<p>
In Version 0.8 (Penetrations Tests)
</p>
<ul>
<li>Wie meldet man einen Vorfall</li>
<li>Forensische Analyse</li>
<li>Erstellen von Systemimages ohne Beweise zu vernichten (mittels <c>dd</c>)</li>
<li>Fallen stellen und verfolgen (mit tcpdump)</li>
<li>.. Noch einiges mehr ..</li>
<li>System wieder herstellen</li>
</ul>

<note>
Bitte beachten Sie, dass sich jede Version jeweils nur auf ein Thema bezieht. Dies wird aus
Qualitätssicherungsgründen so gehandhabt.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Was vor der Installation beachtet werden sollte</title>
<section>
<title>Physische Sicherheit</title>
<body>

<p>
Egal wieviele Sicherheitsmassnahmen Sie integrieren, sie können leicht
umgangen werden, wenn der Hacker direkten Zugriff auf Ihre Maschine hat.
Stellen Sie sicher, dass Ihre Hardware nicht einfach so zugänglich ist.
Zum Beispiel könnten Sie Ihre Maschine in einem speziellen Serverraum
einschliessen. Die Gehäuse zu versiegeln ist auch eine gute Idee. Um das
höchste Niveau an Sicherheit zu erreichen, können Sie Ihr BIOS so einstellen,
dass es nur von der Festplatte bootet. Deaktivieren Sie auch das Booten von
Diskette und von CD-ROM. Für den Übervorsichtigen kann es auch sinnvoll sein,
das BIOS-Passwort zu aktivieren. BIOS-Passwörter sind auch eine gute Idee
für Notebook-Benutzer.
</p>

</body>
</section>
<section>
<title>Dämon/Dienst Planung</title>
<body>

<p>
Dokumentieren Sie, welche Dienste die Maschine anbieten soll oder anbieten darf.
Dies wird Ihnen helfen ein besseres Partitionsschema für das System zu erstellen.
Es kann auch das Aufspüren von Eindringlingen erheblich erleichtern.
Natürlich brauchen Sie das nicht zu dokumentieren, wenn Sie nur einen oder ein
paar Computer benutzen und Sie der einzige Nutzer sind. Zum Beispiel: Wenn die
Maschine als Firewall agieren soll sollten auf der Maschine <e>keine</e> Dienste
ausser vielleicht sshd laufen.
</p>
<p>
Dokumentieren Sie dies und die aktuelle Version von SSH - es wird Ihnen helfen,
das zu aktualisierende System wiederzufinden - für den Fall, dass jemand ein
Sicherheitsloch in sshd findet. Dies wird Ihnen auch dabei helfen festzulegen,
wer Zugriff auf das System haben sollte.
</p>

</body>
</section>
<section>
<title>Partitions-Schemata</title>
<body>

<p>
Goldene Regeln:
</p>

<ul>
<li>
  Jedes Verzeichnis auf das ein Benutzer Schreibrechte haben muss 
  (<path>/home</path> und <path>/tmp</path>, <path>/var</path>) sollte auf 
  einer seperaten Partition liegen und Disk-Quotas benutzen. Portage benutzt
  <path>/var/tmp</path> zum kompilieren, folglich muss diese Partition gross 
  sein. Dies reduziert das Risiko, daß ein Benutzer "/" komplett füllen kann.
</li>
<li>
  Jedes Verzeichnis, in das nicht in der Distribution enthaltene Pakete 
  installiert werden sollen, sollten auf einer seperaten Partition liegen.
  Nach dem <uri link="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</uri>
  ist dies <path>/opt</path> oder <path>/usr/local</path>. Wenn diese seperate 
  Partitionen sind, bleiben Sie bei einer eventuellen Neuinstallation des
  Systems bestehen.
</li>
<li>
  Versuchen sie, statische Daten in eine eigene Partition zu verschieben und
  diese   Partition nur lesbar einzuhängen. Wenn sie wirklich übervorsichtig
  sind, dann könnten Sie statische Daten auch auf einem nur lesbaren Medium
  speichern - zum Beispiel einer CD-ROM.
</li>
</ul>

</body>
</section>

<section>
<title>Der Benutzer root</title>
<body>

<p>
Der Benutzer 'root' ist der mächtigste Benutzer im System und sollte nie für 
irgendetwas Anderes als administrative Aufgaben eingesetzt werden. Wenn ein 
Angreifer root-Zugang erreicht, dann können Sie Ihrem System nicht mehr länger
trauen - Sie haben dann keine andere Wahl, als neu zu installieren.
</p>

<p>
Goldene Regeln bezüglich 'root'
</p>

<ul>
<li>
  Erstellen Sie immer einen Benutzer für die tägliche Arbeit. Wenn dieser 
  Benutzer root-Zugang benötigt, dann fügen Sie diesen Benutzer zur Gruppe wheel 
  hinzu. Dies erlaubt einem normalen benutzer "nach root zu su'en".
</li>
<li>
  Lassen Sie X oder irgendeine andere Benutzeranwendung niemals als root laufen.
</li>
<li>
  Benutzen Sie immer absolute Pfadangaben, wenn Sie als root angemeldet sind. 
  Es ist möglich root auszutricksen und ihn dazu zu bringen eine andere 
  Anwendung statt der, die eigentlich ausgeführt werden soll, auszuführen.
  Wenn zum Beispiel jemand PATH manipuliert hat und root ohne
  <c>su -</c> su verwendet, dann wird root den Pfad des Nutzers benutzen.
</li>
<li>
  Wenn ein Benutzer nur ein paar Kommandos, anstatt von allen, die root benutzen 
  kann, dann überlegen Sie, vielleicht auf sudo zurückzugreifen - aber seien Sie 
  vorsichtig damit.
</li>
<li>
  Verlassen Sie nie den Terminal, wenn root angemeldet ist!
</li>
</ul>

<p>
Gentoo hat einen allgemeinen Schutz gegen normale Benutzer, die versuchen su
einzusetzen. Die Standardeinstellung von PAM besagt, dass ein Benutzer in der 
Gruppe wheel sein muss, um su benutzen zu dürfen.
</p>

</body>
</section>
<section>
<title>Sicherheitsrichtlinien</title>
<body>

<p>
Es gibt verschiedene Gründe, weshalb Sicherheitsrichtlinien benötigt werden.
</p>

<ul>
<li>
  Sie können nicht behaupten ein sicheres Netzwerk zu haben, ohne jemals 
  definiert zu haben, was sicher ist.
</li>
<li>
  Es ist fast unmöglich potientielle Angreifer zu erwischen, Netzwerkprobleme
  zu lösen, oder Prüfungen zu dirigieren ohne den Netzwerkverkehr abzuhören 
  oder in private Home-Verzeichnisse zu sehen. Aber dieses Reinhören ohne 
  Erlaubnis des Nutzers ist in den meisten Ländern illegal. Und da 60% aller 
  Angriffe von innerhalb eines Unternehmens kommen ist es wichtig, dass Sie 
  die Augen offen halten.
</li>
<li>
  Sie können von Ihren Anwendern nicht erwarten, dass sie sich Gedanken über 
  Sicherheit machen, wenn Sie niemals erklärt haben, warum es wichtig ist 
  oder wie sie sich selbst und ihre Kollegen schützen sollten.
</li>
<li>
  Gute Richtlinien und Netzwerkdokumentation zahlen sich immer aus - egal wie.
</li>
<li>
	Die Polizei oder die Staatliche Kriminalbehörde kann Ihnen nicht helfen den 
  Angreifer dingfest zu machen, wenn diese nicht wissen wie Ihre 
  Netzwerkkonfiguration aussieht oder welche Dienste Sie anbieten.
</li>
<li>
	Was werden Sie tun, wenn es einen Angriff gab? Sie müssen definieren, was 
  Sie tun würden und wen Sie informieren würden. Würden Sie bei jeder 
  Gelegenheit die Polizei oder ein CERT-Team anrufen? Die würden Sie nicht 
  ernst nehmen.
</li>
</ul>

<p>
Dies sollte eigentlich darlegen warum es wichtig ist Richtlinien auf Systemen
mit mehr als einem Benutzer festzulegen und warum es wichtig ist die Anwender
zu erziehen.
</p>

<p>
Eine Richtlinie ist ein Dokument (oder mehrere Dokumente) mit Antworten auf
die Fragen "wer", "wo", "warum" und "was". Jeder Anwender in Ihrem
System/Netzwerk sollte es lesen, verstehen und unterschreiben. Es ist wichtig,
daß Sie sich die Zeit nehmen den Anwendern beim Verstehen der Richtlinie zu helfen:
dem Grund, weshalb diese Richtlinie unterschrieben werden muß und was passiert,
wenn sie direkt gegen die Richtlinie verstossen (dies sollte in der Richtlinie
aufgeführt sein). Dies sollte mindestens einmal im Jahr wiederholt werden,
da sich die Richtlinie ändern kann, aber auch um die Anwender immer wieder 
aufs Neue daran zu erinnern.
</p>

<note>
Erstellen Sie Richtlinien, die einfach zu lesen und in jedem Zusammenhang
sehr präzise sind.
</note>

<p>
Eine Sicherheitsrichtlinie sollte mindestens die folgenden Punkte beinhalten:
</p>

<table>
  <tr>
    <th>Akzeptable Anwendung</th>
  </tr>
  <tr>
    <ti>
      Bildschirmschoner
      Behandlung von Kennwörtern
      Herunterladen von Programmen
      Wissen darüber, ob diese überwacht werden
      Benutzung von Antiviren-Software
      etc.
    </ti>
  </tr>
  <tr>
    <th>
      Behandlung von sensitiven Daten (jegliche Schriftliche Form, 
      Papier oder Digital
    </th>
  </tr>
  <tr>
    <ti>
      Sauberer Schreibtisch und verschlossene, vertrauliche Informationen
      PC herunterfahren vorm Verlassen
      Benutzung von Verschlüsselung
      Behandlung von Schlüsseln für vertraute Mitarbeiter
      Behandlung von vertraulichem Material auf Reisen
    </ti>
  </tr>
  <tr>
    <th>Behandlung der Computerausstattung auf Reisen</th>
  </tr>
  <tr>
    <ti>
      Behandlung des Laptops auf Reisen und bei Hotelaufenthalten
    </ti>
  </tr>
</table>

<p>
Die Richtlinie für die IT-Abteilung kann sich von der für die normalen 
Angestellten leicht unterscheiden.
</p>

<p>
Die Sicherheitsrichtlinie kann riesig werden und wichtige Informationen können 
leicht vergessen gehen. Die Richtline für die IT-Abteilung kann Informationen 
enthalten, die gegenüber den normalen Benutzern als vertraulich gelten. Somit 
ist es sinnvoll, sich in kleinen Richtlinien fortzubewegen: Richtlinie für
akzeptable Bedienung, Richtlinie für Passwörter, für E-Mail und für Fernzugriff.
</p>

<p>
Beispiele für Richtlinien können beim
<uri link="http://www.sans.org/newlook/resources/policies/policies.htm">
The SANS Security Policy Project</uri> gefunden werden. Wenn Sie ein kleines
Netzwerk haben und diese Richtlinie für zu gross halten, dann sollten
 sie einen Blick auf das
<uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">RFC2196</uri>
werfen, dass ein Sicherheitshandbuch darstellt
</p>

</body>
</section>
</chapter>

<chapter>
<title>Die Sicherheit nach/während der Installation anziehen</title>
<section>
<title>USE Flags</title>
<body>

<p>
Die <path>/etc/make.conf</path>-Datei enthält die benutzerdefinierten
und die <path>/etc/make.profile/make.defaults</path>-Datei die
Standard USE Flags. Die wichtigen Flags für diesen Guide sind
<c>PAM</c> (Pluggable Authentication Module), <c>tcpd</c> (TCP Wrapper) und
<c>SSL</c> (Secure Socket Layer). Diese sind in den Standard USE Flags
enthalten.
</p>

</body>
</section>
<section>
<title>GRUB Passwort</title>
<body>

<p>
Grub unterstützt 2 verschiedene Wege für Passwortkontrolle in seiner
Konfigurationsdatei(<path>/boot/grub/grub.conf</path>):
Zum einen normalen Text und zum anderen md5+salt Verschlüsselung.
</p>

<p>
Fügen Sie ein Passwort in <path>/boot/grub/grub.conf</path> ein.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
Dies wird das Passwort <e>changeme</e> hinzufügen; wenn kein Passwort 
eingegeben ist, wird die Standard-Boot-Einstellung genommen.
</p>

<p>
Sollte ein md5-Passwort genommen werden, dann müssen Sie das Passwort ins 
Crypt-Format konvertieren (<c>man crypt</c>), daß das selbe Format wie die 
Shadow-Datei hat. Zum Beispiel könnte das verschlüsselte Passwort 
<e>changeme</e> so aussehen: <e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>
</p>

<p>
Oder das Passwort direkt in der GRUB Shell konvertieren:
</p>

<pre caption="md5crypt in der GRUB Shell">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<codenote>Typed changeme</codenote>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Dann kopieren und  fügen Sie das Passwort in <path>/boot/grub/grub.conf</path> ein.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Der Zeitablauf von 5 Sekunden wird sinnvoll, wenn das System fernbedient wird 
und bei einem Neustart ohne Tastatureingaben auskommen muss. Mehr Informationen 
über Grub-Passwörter können Sie bekommen, wenn Sie <c>info grub</c> ausführen.
</p>

</body>
</section>
<section>
<title>LILO Passwort</title>
<body>

<p>
LILO unterstützt auch zwei Arten des Behandelns von Passwörtern : 
Global und Imagerelativ -- beide in Klartext.
</p>

<p>
Das globale wird am Anfang der Konfigurationsdatei gesetzt:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
Im anderen Fall fügen Sie es einfach beim entsprechenden Image hinzu.
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
Wenn die <c>restricted</c>-Option nicht angegeben wurde, dann wird jedes Mal 
nach einem Passwort gefragt.
</p>

<p>
Um die Änderungen an lilo.conf zu übernehmen, müssen Sie 
<c>/sbin/lilo</c> ausführen.
</p>

</body>
</section>
<section>
<title>Einschränkung der Konsolenbenutzung.</title>
<body>

<p>
<path>/etc/securetty</path> enthält Terminaltypen die es Ihnen 
ermöglichen/erlauben festzulegen, von welchen <c>TTY</c> Geräten aus 
root sich einloggen darf.
</p>

<p>
Wir empfehlen, dass sie alle Zeilen bis auf <c>vc/1</c> auskommentieren. 
Dies stellt sicher, dass sich root nur einmal und nur an einem Terminal
einloggen kann.
</p>

<note>
Benutzer in der wheel Gruppe können weiterhin auf anderen Konsolen per
<c>su -</c> root werden.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Mehr Protokolle (Logs)</title>
<section>
<body>

<p>
Zusätzliche Protokolle sollten hinzugefügt werden um Warnungen oder Fehler
aufzuspüren, die vor einem momentanen oder bereits durchgeführten Angriff
warnen könnten. Angreifer beobachten ein Netzwerk oder durchsuchen dies
oft, bevor sie angreifen.
</p>

<p>
Es ist auch unersetzlich, dass die Protokolldateien einfach zu lesen und
zu verwalten sind. Gentoo Linux gibt ihnen die Möglichkeit bei der
Installation zwischen drei verschiedenen Protokollierungsprogrammen zu wählen.
</p>

</body>
</section>
<section>
<title>Loggen: Syslogd</title>
<body>

<p>
Syslogd ist das gängigste Protokollierungsprogramm für Linux und Unix. Es 
beinhaltet keine Protokollrotation. Diese Eigenschaft wird
durch das Verwenden von <path>/usr/sbin/logrotate</path> in einem Cron Job
und korrekt konfigurierten Einstellungen in <path>/etc/logrotate.conf</path> übernommen.
Wie oft die Protokollrotation stattfinden sollte hängt von der 
Systembelastung  ab.
</p>

<p>
Hierunter sehen Sie die Standard Konfiguration <path>/syslog.conf</path>
mit einigen zuästzlichen Features. Wir haben die <c>cron</c> und <c>tty</c>
Zeilen unkommentiert und eine Remote Logging Server hinzugefügt. Um die 
Sicherheit weiter zu erhöhen, können Sie Logs an zwei Orten schreiben lassen.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# First some standard logfiles.  Log by facility.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Logging for the mail system. Split it up so that
# it is easy to write scripts to parse these files.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Logging for INN news system
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Some `catch-all' logfiles.
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Emergencies and alerts are sent to everybody logged in.
#
*.emerg                         *
*.=alert                        *

#
# I like to have messages displayed on the console, but only on a virtual
# console I usually leave idle.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

#Setup a remote logging server
*.*                        @logserver

# The named pipe /dev/xconsole is for the `xconsole' utility.  To use it,
# you must invoke `xconsole' with the `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: adjust the list below, or you'll go crazy if you have a reasonably
#      busy site..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
Der Angreifer wird höchstwahrscheinlich versuchen seine Spuren zu verwischen,
indem er die Protokolldateien bearbeitet oder löscht. Sie können es für den 
Angreifer schwerer machen indem sie das Protokoll an einen oder mehrere 
Protokollserver auf verschiedenen Maschinen schicken. Mehr Informationen über 
syslogd finden sie in der Man Page (<c>man syslog</c>)
</p>

</body>
</section>
<section>
<title>Loggen: Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> von Frank Dennis 
bietet nicht die Möglichkeit Protokolle an einen entfernten (remote) 
Server zu senden, aber es hat Vorteile im  Bereich der Performance und der 
Protokollierungsflexibilität. Es kann nach Programmnamen <!--oder nach 
Einrichtung -->protokollieren (wie syslogd) und beinhaltet reguläre 
Ausdrucksübereinstimmung und die Möglichkeit Kommandos auszuführen.
Sehr gut um Handeln zu können, wenn nötig.
</p>

<p>
Die Standard Konfiguration ist zunächst ausreichend. Wenn Sie benachrichtigt
werden wollen, wenn z.B. ein Anmeldevorgang fehlschlägt benutzen Sie eines
der folgenden Skripte.
</p>

<p>
Für Postfix.
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh für Postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Für Qmail:
</p>

<pre caption = "/usr/local/sbin/mail_pwd_failures.sh für Qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Denken Sie daran das Skript mit 
<c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c> ausführbar
zu machen.
</p>

<p>
Unkommentieren Sie dann die Zeile unter "Password failures" in
<path>/etc/metalog/metalog.conf</path> wie folgt:
</p>

<pre caption="/etc/metalog/metalog.conf">
command = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Loggen: Syslog-ng</title>
<body>

<p>
Syslog-ng enthält einige derselben Funktionen wie Syslog und Metalog mit
einem kleinen Unterschied. Es ermöglicht die Filterung von Nachrichten
basierend auf Level und Inhalt (wie Metalog), bietet entferntes Protokollieren
(wie syslog) und kann Protokolle von syslogd verarbeiten. Sogar Streams von
Solaris, schreiben an ein TTY, Ausführen von Programmen und die Nutzung als
Protokollierungsserver sind möglich. Grundlegend ist dies das Beste aus
beiden Protokollierern kombiniert mit einer erweiterten Konfiguration.
</p>

<p>
Eine klassische, leicht modifizierte Konfigurationsdatei.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#Quelle von der das Log gelesen werden soll
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#Ziele festlegen
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#Filter erstellen
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#Filter und Ziele verbinden
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#Standard-Log
log { source(src); destination(console_all); };
</pre>

<p>
Sehr einfach zu konfigurieren, aber es ist auch sehr einfach etwas zu übersehen,
da die Konfigurationsdatei riesig ist. Der Autor verspricht zudem noch einige
zusätzliche Funktionen wie Verschlüsselung, Authentifizierung, Komprimierung
und MAC (Mandatory Access Control) Kontrolle. Mit diesen Optionen wird es
perfekt sein für Netzwerkprotokollierung, da der Angreifer die Protokolle
nicht ausspionieren kann.
</p>

<p>
Syslog-ng hat auch noch andere Vorteile - es muss nicht als root laufen!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Partitionen mounten</title>
<section>
<body>

<p>
Mountet man eine ext2, ext3 oder eine reiserfs Partition, so gibt es mehrere
Optionen die man in <path>/etc/fstab</path> einfügen kann. Diese Optionen sind:
</p>

<ul>
<li>
  <c>nosuid</c> - Ignoriert das SUID bit und behandelt es einfach wie eine
  normale Datei.
</li>
<li>
  <c>noexec</c> - Verhindert das Ausführen von Dateien von dieser Partition.
</li>

<li>
  <c>nodev</c> - Ignoriert Geräte.
</li>
</ul>

<p>
Leider können diese Einstellungen leicht umgangen werden, indem man einen
nicht-direkten Pfad ausführt. Jedoch wenn man /tmp auf noexec setzt,
stoppt das etwa 99% aller Script-Kiddies, da deren Exploits so
gestaltet sind dass sie direkt von /tmp ausgeführt werden.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Setzt man <path>/tmp</path> in noexec Modus, kann dies dazu führen,
dass einige Scripts nicht richtig ausgeführt werden.
</warn>

<note>
Plattenquotas werden im Kapitel <uri link="#doc_chap6_sect3">Quotas</uri>
behandelt
</note>

<note>
Beachten Sie dass ich <path>/var</path> weder in <c>noexec</c> noch in <c>nosuid</c>
Modus setze, obwohl Dateien von diesem Mountpunkt normalerweise niemals ausgeführt
werden. Der Grund dafür ist, dass qmail in <path>/var/qmail</path>
installiert ist und berechtigt sein muss eine suid-Datei auszuführen und
auf sie zuzugreifen. Ich setze <path>/usr</path> in read-only Modus, da ich
hier nichts verändere solange ich Gentoo nicht aktualisiere. Dann mounte ich
das Dateisystem erneut in read-write Modus, aktualisiere und mounte dann erneut
in read-only.
</note>

<note>
Selbst wenn sie qmail nicht benutzen, braucht Gentoo trotzdem noch die
Ausführberechtigung in <path>/var/tmp</path>, da dort ebuilds hergestellt
werden. Jedoch kann hierfür ein alternativer Pfad eingerichtet werden,
wenn Sie darauf bestehen <path>/var</path> im <c>noexec</c> Modus zu betreiben.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Einschränkungen für Benutzer/Gruppen </title>
<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
Die Kontrolle von Ressourcenbegrenzungen kann sehr effektiv sein, wenn es
darum geht eine lokale DoS Attacke zu verhindern oder die maximal erlaubten
Logins für eine Gruppe oder einen Benutzer zu handhaben.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Wenn Sie dabei sind den Wert von <c>nproc</c> oder <c>maxlogins</c> gleich 0 zu
setzen, sollten sie diesen Benutzer vielleicht lieber löschen. Das Beispiel
oben setzt die Einstellungen für die Gruppe <c>dev</c> für Prozesse,
Kerndateien und <c>maxlogins</c>. Der Rest erhält einen Standardwert.
</p>

<note>
<path>/etc/security/limits.conf</path> ist Teil des PAM Paketes und wird
nur auf Pakete angewendet, die PAM benutzen.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> ist recht ähnlich zur Limit-Datei
<path>/etc/security/limits.conf</path>. Der einzige Unterschied ist das
Format und daß diese nur auf Benutzern oder Wild-Cards (aber keinen Gruppen)
beruht. Werfen wir einen Blick auf die Konfiguration:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Hier setzen wir die Standardeinstellungen und eine spezielle Einstellung für
den Anwender <e>kn</e>. Limits sind ein Teil des Shadow-Paketes und betreffen
nur das Shadow-Login-Programm. Es ist nicht notwendig irgendwelche
Beschränkungen in dieser Datei zu setzen, wenn Sie die PAM-Einstellung in
<path>/etc/make.conf</path> vorgenommen haben und PAM vollständig konfiguriert haben.
</p>

</body>
</section>
<section>

<title>Quotas</title>
<body>

<warn>
Stellen Sie sicher, dass ihr Dateisystem Quotas unterstützt. ReiserFS zum
Beispiel tut es nicht!
</warn>

<p>
Die Anwendung von Quotas auf einem Dateisystem verhindert, daß Anwender den
Datenträger mit Ihren Daten überfüllen oder überhaupt schreiben können.
Die Kernel-Option wird bei der Kernelkonfiguration unter
<c>File systems->Quota support</c> aktiviert. Nehmen Sie die Einstellung vor, 
kompilieren Sie den Kernel neu und starten Sie mit diesem Ihren Computer neu.
</p>

<p>
Starten Sie die Installation mit <c>emerge quota</c>. Passen Sie Ihre
<path>/etc/fstab</path> an, indem Sie usrquota und grpquota bei den
Partitionen hinzufügen, für die Sie die Nutzungsbeschränkung festlegen wollen.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Auf jeder Partition auf der Sie Quotas aktiviert haben, erstellen Sie nun die
Quota-Dateien (quota.user und quota.group) und setzen diese in die Wurzel
der Partition.
</p>

<pre caption="Erstellen der Quota-Dateien">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Dieser Schritt muss auf jeder Partition durchgeführt werden, auf der Quotas
aktiviert wurden. Nachdem Sie die Quota-Dateien erstellt und konfiguriert haben,
müssen Sie das <c>quota</c> Initskript dem boot Runlevel hinzufügen.
</p>

<pre caption="Quota zum boot Runlevel hinzufügen">
# <i>rc-update add quota boot</i>
</pre>

<p>
Wir werden das System nun so konfigurieren, dass die Quotas einmal
wöchentlich gecheckt werden. Dazu fügen Sie folgende Zeile in die
<path>/etc/crontab</path> ein.
</p>


<pre caption="Quota Check in der crontab">
0 3 * * 0 /sbin/quotacheck -avug
</pre>

<p>
Nachdem Sie den Rechner neu gestartet haben, ist es an der Zeit, die Quotas 
für die Benutzer und Gruppen festzulegen. <c>edquota -u kn</c> wird den in 
$EDITOR festgelegten Editor starten (Standard ist nano), damit Sie die Quotas 
des Benutzers kn bearbeiten können. -g wird genau dasselbe, allerdings für 
Gruppen machen.
</p>

<pre caption="Bearbeiten der Quotas für den Benutzer kn">
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Für weitere Informationen lesen Sie bitte <e>man edquota</e> oder 
<uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Das Quota Mini-Howto</uri>
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
Wenn die Richtlinie besagt, dass die Anwender jede Woche ihr Passwort ändern 
müssen, dann setzen Sie die Variable <c>PASS_MAX_DAYS</c> auf 14 und 
<c>PASS_WARN_AGE</c>  auf 7. Es wird ausserdem empfohlen, dass Sie alternde 
Passwörter benutzen, da Brute-Force Angriffe jedes Passwort finden können - 
alles nur eine Frage der Zeit. Wir empfehlen ausserdem, dass Sie 
<c>LOG_OK_LOGINS</c> auf yes setzen.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Die <path>login.access</path> ist auch ein Teil des Shadow-Paketes, dass eine 
Login Zugangs-Kontrolltabelle anbietet. Die Tabelle wird benutzt um zu 
kontrollieren, wer und wer nicht einloggen darf, basierend auf dem Benutzernamen,
dem Gruppennamen oder dem Hostnamen von dem der Versuch gestartet wird. 
Normalerweise sind alle Anwender des Systems berechtigt sich anzumelden; 
aus diesem Grunde ist die Datei nur mit Kommentaren und Beispielen gefüllt. 
Je nachdem wie Sie Ihren Server oder Ihren Arbeitsplatzrechner schützen 
empfehlen wir die Datei so anzupassen, das niemand anderes als Sie selbst 
(also der Administrator) Zugang zur Konsole bekommt.
</p>

<note>
Diese Einstellungen sind nicht für root anwendbar.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Seien Sie vorsichtig bei der Bearbeitung der Datei. Wenn Sie nicht aufpassen, 
dann können Sie sich aussperren wenn Sie nicht über root-Rechte verfügen.
</impo>

<note>
Diese Einstellungen wirken sich nicht auf SSH aus, da SSH <path>/bin/login</path>
normalerweise nicht ausführt. Dies kann durch die Benutzung von "UseLogin yes" 
in <path>/etc/ssh/sshd_config</path> ermöglicht werden. Das führt dazu, dass 
SSH login benutzt und die Einstellungen benutzt werden.
</note>

<p>
Dies erstellt Loginzugriff so das Mitglieder von wheel sich an der Konsole 
einloggen können oder wenn ihre Quelle die gentoo.org Domäne ist. Vielleicht 
ein wenig zu paranoid, aber sicher ist sicher.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Dateiberechtigungen.</title>
<section>
<title>Von allen lesbar</title>
<body>

<p>
Normale Benutzer sollten zu Konfigurationsdateien oder Passwörtern keinen 
Zugang haben. Ein Angreifer kann Passwörter aus einer Datenbank oder von einer 
Webseite stehlen und verunstalten oder noch schlimmer: Daten löschen. Deswegen 
ist es notwendig, dass die Berechtigungen korrekt gesetzt sind. Wenn Sie sicher
sind, dass eine Datei nur von root benutzt wird, geben Sie ihr die Berechtigung
<c>0600</c> und ordnen Sie diese mit <c>chown</c> dem richtigen Benutzer zu.
</p>

</body>
</section>
<section>
<title>Welt/Gruppen-Schreibbar.</title>
<body>

<pre caption="Auffinden von Dateien und Verzeichnissen, die von allen schreibar sind">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Dies schafft eine riesige Datei mit Berechtigungen von allen Dateien, die 
entweder Schreibberechtigungen für alle oder eine Gruppe haben. Überprüfen 
Sie die Berechtigungen und eliminieren Sie die für alle schreibbaren Dateien 
durch das Ausführen von <path>/bin/chmod o-w</path> für die Dateien.
</p>

</body>
</section>
<section>
<title>SUID/SGID Dateien</title>
<body>

<p>
SUID/SGID Dateien (Dateien bei denen das superuser bit gestzt wurde) ist ein 
Weg für normale Benutzer Dinge zu tun die normalerweise nur root darf. Diese 
Dateien können zu lokalen root-Brüchen führen (wenn sie Sicherheitslöcher 
enthalten), da so eine Datei mit root Berechtigungen ausgeführt wird. Diese 
Dateien sind gefährlich und sollten unter allen Umständen vermieden werden. 
Wenn Sie die Dateien nicht benutzen. Führen sie chmod 0 aus oder entfernen 
sie das Paket (unmerge) aus dem sie stammen (überprüfen sie das Paket mit 
<c>qpkg -f</c>. Wenn sie es nicht längst installiert haben, tun Sie dies 
mit <c>emerge gentoolkit</c>). Ansonsten schalten Sie das suid bit einfach 
mit chmod-s ab.
</p>

<pre caption="Auffinden von setuid Dateien">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Dies erzeugt eine Datei mit einer Liste aller SUID/SGID Dateien.
</p>

<pre caption="Liste der setuid binären Dateien">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Standardmäßig hat Gentoo Linux nicht viele SUID Dateien (es hängt davon, 
was Sie installiert haben), aber Sie könnten eine Liste wie die obige 
erhalten. Viele dieser Befehle sollten nicht von normalen Benutzern benutzt 
werden, sondern nur von root. Schalten sie das suid bit bei <c>ping</c>, 
<c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, 
<c>suidperl</c>, <c>pt_chown</c> und <c>traceroute</c> aus. Sie tun 
dies mit dem Befehl <c>chmod -s</c> bei jeder einzelnen Datei. Entfernen Sie 
das bit nicht von <c>su</c>, <c>qmail-queue</c> oder <c>unix_chkpwd</c>. 
Dies würde dazu führen, dass Sie nicht mehr su benutzen und mail empfangen 
könnten. Durch entfernen des bits entfernen Sie die Möglichkeit, dass ein 
normaler User (oder Angreifer) root Zugriff durch eine dieser Dateien erlangen 
kann.
</p>

<p>
Die einzigen SUID Dateien die ich auf meinem System habe sind <c>su</c>, 
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> und 
<c>pwdb_chkpwd</c>. Aber wenn sie X benutzen, könnten sie einige mehr haben, 
denn X benötigt diesen Zugriff.
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM ist eine Sammlung von shared libraries, die eine Alternative für 
Authentifizierungen in Programmen darstellen. Die PAM Einstellungen von 
Gentoo Linux sind relativ vernünftig, aber es gibt immer Platz für 
Verbesserungen. Zunächst installieren wir cracklib.
</p>

<pre caption="Installieren von cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth  required pam_unix.so shadow nullok
account required pam_unix.so
password  required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password  required pam_unix.so md5 use_authtok
session required pam_unix.so
</pre>

<p>
Dies fügt die cracklib hinzu, welche sicherstellt, dass der Benutzer eine 
minimale Passwortlänge von 8 Zeichen benutzt; Bestehend aus mindestens 
2 Zahlen, 2 Unterschiedlichen und es müssen mindestens 3 Zeichen anders sein 
als beim letzten Passwort. Dies zwingt den Benutzer ein gutes Passwort zu 
wählen (Passwortrichtlinien). In der Dokumentation von 
<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>
finden Sie weitere Optionen.
</p>

<pre caption="/etc/pam.d/sshd">
auth  required pam_unix.so nullok 
auth  required pam_shells.so
auth  required pam_nologin.so
auth  required pam_env.so
account  required pam_unix.so
password  required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password  required pam_unix.so shadow md5
session  required pam_unix.so
session  required pam_limits.so
</pre>

<p>
Jeder andere Dienst der nicht mit einer PAM Datei in <path>/etc/pam.d</path> 
konfiguriert ist wird die "andere" Regel benutzen. Die Standardeinstellung 
sind auf <c>deny</c> gesetzt, so wie es sein sollte. Jedoch habe ich gerne viele 
Protokolle und deswegen habe ich <c>pam_warn.so</c> hinzugefügt. Die letzte 
Konfiguration ist <c>pam_limits</c> welche von 
<path>/etc/security/limits.conf</path> kontrolliert wird. Siehe das 
<uri link="#doc_chap6_sect1">passende Kapitel</uri> hierzu.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
Ist ein Weg um Zugang zu kontrollieren für Dienste die normalerweise von 
inetd ausgeführt werden (welches Gentoo nicht hat) aber es kann auch von 
xinetd und anderen Diensten benutzt werden.
</p>

<note>
Der Dienst sollte tcpd in seinem Serverargument (in xinetd) asugeführt werden.
Schauen Sie für mehr Informationen in das xinetd Kapitel.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Wie Sie sehen können ist das Format sehr ähnlich dem in 
<path>/etc/login.access</path>. Tcpd unterstützt einen spezifischen Dienst 
und sie arbeiten nicht im selben Gebiet von Sicherheit. Diese Einstellungen 
gelten nur für Dienste die TCP Wrapper benutzen.
</p>

<p>
Es ist auch möglich Befehle auszuführen wenn auf einen Dienst zugegriffen 
wird (kann benutzt werden wenn Weiterleiten für Benutzer die sich einwählen 
aktiviert wird) aber es nicht empfohlen, da Menschen dazu neigen mehr Probleme 
zu schaffen als sie versuchen zu beheben. Ein Beispiel könnte sein, dass sie 
ein Script konfigurieren um email zu senden jedes mal wenn jemand die 
deny-Regel trifft, aber ein Angreifer könnte so eine DoS Attacke ausführen 
indem er darauf weiter zugreift. Dies schafft viel I/O und viele mails, 
deswegen tun Sie es nicht! Lesen Sie <c>man 5 hosts_access</c> 
für weitere Informationen.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Kernelsicherheit</title>
<section>
<title>Funktionsentfernung</title>
<body>

<p>
Eine grundlegende Regel ist die Entfernung von allem was sie nicht brauchen. 
Das schafft einen kleinen Kernel und entfernt auch die Verwundbarkeiten die 
in Treibern oder anderen Eigenschaften liegen können.
</p>

<p>
Ziehen Sie auch in betracht loadable module support(=ladbare-Modulunterstützung) 
auszuschalten. Auch wenn es möglich ist Module ohne diese Eigenschaft 
hinzuzufügen (root kits), wird es doch schwerer für den normalen Angreifer 
root kits über Kernelmodule zu installieren.
</p>

</body>
</section>
<section>
<title>/proc (kernel flags)</title>
<body>

<p>
Viele Kernel Parameter können durch das /proc Dateisystem verändert werden, 
oder durch die Benutzung von <c>sysct1</c>.
</p>

<p>
Um dynamisch Kernelparameter und -variablen sofort zu ändern benötigen Sie 
<c>CONFIG_SYSCTL</c> in Ihrem Kernel. Die ist voreingestellt im Standard 
2.4 Kernel.
</p>

<pre caption="Entfernen von ping-Paketen">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Dies sperrt icmp Typ 0 (auch bekannt als Ping) Pakete. Der Grund hierfür ist, 
dass icmp Nutzlast mit anderen Informationen beinhalten kann als Sie denken. 
Administratoren benutzen Ping als Diagnoseprogramm und beschweren sich oft 
wenn sie Ping nicht benutzen können. Es gibt keinen Grund für einen 
Außenstehenden die Möglichkeit zu haben Ping zu benutzen, aber ab und zu kann 
es hilfreich für Eingeweihte sein, diese Möglichkeit zu haben. Das Problem 
kann dadurch gelöst werden, indem man icmp type 0 in der Firewall deaktiviert.
</p>

<pre caption="Ignorieren von broadcast-Pings">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Dies sperrt Antworten auf Anfragen, Sie wollen schliesslich nicht ein 
Schlumpfverstärker werden. Schlumpfverstärker oder X-mass trees ist 
eine Methode die es einem Angreifer erlaubt einen moderaten Teil von Traffic 
zu senden und geradezu eine Explosion von Traffic zu verursachen am 
beabsichtigten Ziel.
</p>

<pre caption="Sperren von source routed Paketen">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Akzeptieren sie keine source routed Pakete. Angreifer können source routing benutzen um Traffic zu erzeugen der vorgibt aus dem Netzwerk zu kommen, 
jedoch weitergeleitet wurde den Pfad von dem es ursprünglich kam. Sperren sie Source Routing denn es wird selten für legitime Zwecke genutzt.
</p>

<pre caption="Sperren von Umleitungsakzeptanz">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Sperren Sie ICMP Umleitungsakzeptanz. ICMP Umleitungen können benutzt werden um Ihre routing tables zu verändern, möglicherweise zu einem schlimmen Ende.
</p>

<pre caption="Schutz gegen bad error messages">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Schalten sie den Schutz gegen bad error messages ein.
</p>

<pre caption="Ermöglichen von rückwärtiger Pfadfilterung">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
         /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<note>
Wenn Sie  IP forwarding aktivieren, werden Sie auch dieses Resultat erhalten.
</note>

<p>
Stellen Sie reverse path filtering an. Dies hilft durch automatisches 
Ablehnen von Quelladressen, die nicht mit dem Netzwerkinterface übereinstimmen, 
dabei sicherzustellen, dass Pakete legitime Quelladressen benutzen. 
Dies hat Sicherheitsvorteile, da es IP Spoofing verhindert. 
</p>

<warn>
Die Nutzung von reverse path filtering kann auch ein Problem darstellen, wenn
sie asymetrisches Routing benutzen (Pakete von Ihnen zu einem Host nehmen einen
anderen Weg als Pakete vom host zu Ihnen) oder wenn Sie einen Non-Routing Host
betreiben, der verschiedene IP-Adressen an verschiedenen Interfaces hat.
</warn>

<pre caption="Protokollieren aller spoofed, source routed und umgeleiteten Pakete">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Protokollieren von spoofed, source routed und umgeleiteten Pakete.
</p>

<pre caption="Deaktivieren von IP forwarding">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Stellen Sie sicher, dass IP forwarding ausgeschaltet ist. Wir wollen es nur 
für einen multi-homed Host.
</p>

<p>
Alle diese Einstellungen werden zurückgesetzt, wenn die Maschine neu gestartet 
wird. Daher schlage ich vor, dass Sie sie in <path>/etc/sysctl.conf</path>
eintragen. Diese Datei wird vom <path>/ect/init.d/bootmisc</path> Script
ausgelesen.
</p>

<p>
Die Syntax für <path>/etc/sysctl.conf</path> ist recht gradlinig.
Entfernen Sie das <path>/proc/sys/</path> von den eben angesprochenen Pfadnamen
und ersetzen Sie <path>/</path> mit <path>.</path>:
</p>

<pre caption="Übersetzen zu sysctl.conf">
<comment>(Manuell durch echo):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automatisch in sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
Der Patch von <uri link="http://grsecurity.net">Grsecurity</uri> ist
Standard im Gentoo Kernel aber per Voreinstellung deaktiviert.
Konfigurieren Sie Ihren Kernel wie gewohnt und konfigurieren Sie dann die
Grsecurity Optionen. Eine ausführliche Erläuterung zu die verfügbaren Grsecurity
Optionen ist auf der Seite des <uri
link="http://www.gentoo.org/proj/en/hardened">Gentoo Hardened Projekt</uri>
verfügbar.
</p>

<p>
Die aktuellen <c>grsec-sources</c> enthalten die 2.* Version von Grsecurity. Für
mehr Informationen zu diesem verbessertem Patch Set kosultieren Sie bitte die
Dokumentation auf der <uri link="http://www.grsecurity.net/">Grsecurity
Homepage</uri>.
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> ist ein Patch der 
Verschlüsselung zum existierenden Kernel hinzufügt. Durch patchen des 
Kernel erhalten Sie neue Optionen wie: Kryptrographische Chiffrierung, 
Zusammenfassungsalgorithmen und Kryptrographische-Schleifenfilter.
</p>

<warn>
Der Kerneli Patch ist momentan nicht in einer stabilen Version für den neuesten 
Kernel verfügbar, also Vorsicht beim Gebrauch.
</warn>

</body>
</section>
<section>
<title>Andere Kernel Patches</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri></li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
Und es gibt wahrscheinlich vieles mehr.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sichern von Diensten</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) kommt mit einer recht gut eingestellten Konfigurationsdatei, 
aber auch hier müssen wir einige Dinge verbessern wie z.B. verbinden mit 
einer Adresse und Verhindern des Datenverlustes bei der Übertragung.
Folgende Optionen sollten sie in der Konfigurationsdatei anpassen:
</p>

<p>
Wenn Sie <c>ssl</c> in Ihrer <path>/etc/make.conf</path> vor der Installation 
von Apache gesetzt haben, dann sollten Sie Zugang zu einem SSL-fähigen Server 
haben. Fügen Sie folgende Zeile ein um dieses Feature zu aktivieren.
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Lassen Sie ihn auf Ihre IP hören
Listen 127.0.0.1
BindAddress 127.0.0.1
#Es ist keine gute Idee nobody oder nogroup für
#jeden Prozess der nicht als root läuft zu benutzen -
#(erstellen Sie den Benutzer apache mit der Gruppe apache)
User apache
Group apache
#Wir halten Apache davon ab, die Serverversion auszuplaudern
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache wird mit <c>--enable-shared=max</c> und <c>--enable-module=all</c> 
kompiliert. Dies wird von Vorneherein alle Module aktivieren, sodass Sie 
alle Module in der <c>LoadModule</c>-Sektion (also <c>LoadModule</c> und 
<c>AddModule</c>) auskommentieren müssen, die Sie nicht benötigen. 
Starten Sie den Dienst neu, indem Sie <c>/etc/init.d/apache restart</c>
ausführen.
</p>

<p>
Die Dokumentation gibt es auf <uri>http://www.apache.org</uri>
</p>

</body>
</section>
<section>
<title>Bind</title>
<body>

<p>
Sie finden Dokumentation zu Bind beim <uri
link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Konsortium</uri>. Das "BIND 9 Administrator Reference Manual" ist auch in
<path>doc/arm</path> verfügbar.
</p>

<p>
Die neueren BIND Ebuilds unterstützen chrooten von vorneherein. Folgen Sie nach 
dem emergen von <c>bind</c> diesen simplen Anweisungen:
</p>

<pre caption="Chrooten von BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<codenote>Bevor Sie diesen Befehl ausführen, möchten Sie vielleicht das chroot 
Verzeichnis in /etc/conf.d/named ändern. Ansonsten wird /chroot/dns verwendet.
</codenote>
<codenote>
Sie müssen möglicherweise die Versionsnummer durch die aktuelle 
ersetzen. 
</codenote>
</pre>
</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns ist eine DNS Implementierung auf die der Author bereit ist 
<uri link="http://cr.yp.to/djbdns/guarantee.html">Geld</uri> zu 
wetten, wie sicher es ist. Es unterscheidet sich grundlegend von Bind 9 ist 
aber einen Versuch wert. Weitere Informationen finden sich auf 
<uri>http://www.djbdns.org</uri>.
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
Das Benutzen von FTP (File Transfer Protocol) ist im Allgemeinen eine schlechte
Idee. Es benutzt unverschlüsselte Daten, lauscht auf zwei Ports (normalerweise
20 und 21), und anonyme Logins sind das, wonach Angreifer 
gerne suchen (um Warez zu verteilen). Da das ftp-Protokoll einige 
Sicherheitslücken enthält, benutzen Sie bitte alternativ <c>sftpd</c> oder HTTP.
Wenn dies nicht möglich sein sollte, dann sichern Sie 
Ihre Dienste so gut wie nur möglich ab und bereiten Sie sich vor.
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
Wenn nur lokale Anwendungen auf die <c>mysql</c> Datenbank zugreifen, dann 
entkommentieren Sie die folgende Zeile in <path>/etc/mysql/my.cnf</path>.
</p>

<pre caption="Deaktivieren zu Netzwerkzugriff">
skip-networking
</pre>

<p>
Deaktivieren Sie den Befehl <c>LOAD DATA LOCAL INFILE</c> in derselben Datei.
</p>

<pre caption="Deaktivieren von LOAD DATA LOCAL INFILE in der [mysqld] Sektion">
set-variable=local-infile=0
</pre>

<p>
Die Standard <c>mysql</c> Installation kommt mit einem leeren <c>root</c> 
Passwort.
</p>

<pre caption="Setzen des root Passworts">
<i>/usr/local/mysql/bin/mysql -u root</i> 
mysql> <i>SET PASSWORD FOR root@localhost=PASSWORD('new_password');</i>
</pre>

<note>
Es ist guter Stil das Passwort nicht von der Kommandozeile zu ändern, zum 
Beispiel mit dem <c>mysqladmin password</c> Befehl. Dies it besonders wichtig 
wenn andere Benutzer an dem Server arbeiten. In diesem Fall könnte das 
Passwort leicht entdeckt werden, z.B. mit dem <c>ps aux</c> Befehl oder durch 
die Betrachtung von History Dateien (<path>~/.history</path>, 
<path>~/.bash_history</path> etc), wenn unpassende Zugriffsrechte auf diese 
gesetzt sind.
</note>

<p>
Als nächstes müssen wir die Beispielsdatenbank (test) entfernen und alle 
Accounts, ausser dem lokalen <c>root</c> Account.
</p>

<pre caption="Entfernen der Beispielsdatenbank und aller unnötigen Benutzer">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Seien Sie vorsichtig mit diesem Befehl, wenn Sie schon Benuzterkonten 
konfiguriert haben.
</warn>

</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd hat einige Sicherheitsprobleme, aber es hat den Anschein als seien die 
meisten repariert worden. Weitere Verbesserungen wären:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "Mein ftp Daemon"
#Zeigen Sie nicht den Ident des Servers
ServerIdent on "Hau ab!"

#Vereinfacht es virtuelle Benutzer anzulegen
RequireValidShell off

#Benutzen Sie eine alternative Passwort- und Gruppendatei (passwd benutzt das Crypt-Format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Berechtigungen
Umask 077

# Timeouts und Beschränkungen
MaxInstances 30
MaxClients 10 "Nur 10 Verbindungen erlaubt"
MaxClientsPerHost 1 "Sie sind schon eingeloggt"
MaxClientsPerUser 1 "Sie sind schon eingeloggt"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#jeden "chroot"-en
DefaultRoot ~

#nicht als root laufen lassen
User  nobody
Group nogroup

#Jeden Transfer aufzeichnen
TransferLog /var/log/transferlog

#Probleme mit Zeichenersetzung
DenyFilter \*.*/
</pre>

<p>
Dokumentation findet man auf <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Qmail</title>
<body>

<p>
Qmail wird als der sicherste Mail-Server angesehen. Er wurde mit Sicherheit 
(und Paranoia) im Hinterkopf geschrieben. Es erlaubt von Haus aus kein 
Relaying und hatte seit 1996 kein Sicherheitsloch. Starten Sie einfach ein
<c>emerge qmail</c> und konfigurieren Sie es danach.
</p>
</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samaba ist ein Protkoll um Dateien auszutausche mit Microsoft/Novell 
Netwerken und sollte <e>nicht</e> über das Internet verwendet werden. 
Nichtsdesotrotz muss es gesichert werden.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #An ein Interface binden
  interfaces = eth0 10.0.0.1/32

  #Sicherstellen, dass verschlüsselte Passwörter verwednet werden
  encrypt passwords = yes
  directory security mask = 0700

  #Traffic von 10.0.0.* erlauben
  hosts allow = 10.0.0.

  #Aktiviert Benutzerauthentifizierung
  #(verwenden Sie nicht den share Modus)
  security = user
  
  #Verweigern von priviligierten Accounts
  invalid users = root @wheel

  #Maximalgrösse die smb für ein Share anzeigt (ist kein Limit)
  max disk size = 102400

  #Die Passwortrichtlinie aufrecht erhalten
  min password length = 8
  null passwords = no

  #PAM verwenden (Wenn Support hinzugefügt)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Stellen Sie sicher, dass die Berechtigungen korrekt gesetzt sind für jedes 
Share und denken Sie daran die 
<uri link="http://www.samba.org">Dokumentation</uri> zu lesen.
</p>

<p>
Starten Sie den Server nun neu und fügen Sie den Benutzer hinzu, der Zugriff 
auf diesen Service haben sollte. Dies geschieht durch 
<path>/usr/bin/smbpasswd</path> mit dem Parameter -a.
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
Das einzige sichern, das OpenSSH benötigt ist aktivieren von stärkerer 
Authentifizierung basierend auf der Public-Key Verschlüsselung. Viel zu viele 
Seiten (wie <uri>http://www.sourceforge.net</uri>, 
<uri>http://www.php.net</uri> und <uri>http://www.apache.org</uri>) haben 
unter unauthorisiertem Eindringen in Ihre Systeme gelitten durch 
Passwortverlust oder schlechte Passwörter.
</p>

<pre caption="/etc/ssh/sshd_config">
#Nur Version 2 aktivieren
Protocol 2

#Root login deaktivieren, Benutzer müssen su verwenen um root zu erlangen
PermitRootLogin no

#Public key Authentifizierung aktivieren
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Deaktivieren von .rhost und normaler Passwortauthentifizierung
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Nur Benutzern aus der wheel oder admin Gruppe den Zugang erlauben
AllowGroups wheel admin

#In diesen Gruppen nur folgende Benuzter zulassen
AllowUsers kn bs

#Logging 
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
Nun ist alles, was Ihre Benutzer noch tun müssen einen Schlüssel zu erstellen 
(auf der Maschine von der sie sich einloggen wollen) mit folgendem Befehl
</p>

<pre caption="Erstellen eines DSA Schlüsselpaars">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Eine Passphrase eintippen
</p>

<pre caption="Ausgabe von ssh-keygen">
Generierung des öffentlichen/privaten dsa Schlüsselpaares.
Geben sie den Dateinamen ein unter dem der Schlüssel gespeichert wird (/home/kn/.ssh/id_rsa):<i>[Enter drücken]</i>
Verzeichnis erstellt '/home/kn/.ssh'.
Passsatz eingeben (leer für keinen Passsatz): <i>[Passsatz eingeben]</i>
Denselben Passsatz erneut eingeben: <i>[Erneut Passsatz eingeben]</i>
Ihre Identifikation wurde in /home/kn/.ssh/id_dsa gespeichert.
Ihr öffentlicher Schlüssel wurde in /home/kn/.ssh/id_dsa.pub gespeichert.
Der Fingerabdruck des Schlüssels ist: 
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Dies fügt zwei Dateien zu Ihrem <path>~/.ssh/</path> Verzeichnis mit den 
Namen id_dsa und id_dsa.pub hinzu. Die Datei id_dsa ist Ihr privater Schlüssel 
und sollte von anderen Leuten außer Ihnen Ferngehalten werden. Die andere 
Datei id_dsa.pub soll an jeden Server verteilt werden zu dem Sie Zugriff haben. 
Fügen Sie den Schlüssel in das home Verzeichnis des Benutzers in 
<path>~/.ssh/authorized_keys</path> ein, so sollte der Benutzer die Möglichkeit 
haben sich einzuloggen.
</p>

<p>
Ihre Benutzer sollten diesen privaten Schlüssel gut verwahren. Packen Sie es 
auf ein Medium, dass sie immer mit sich tragen oder lassen Sie es auf ihrer 
Workstation (fügen Sie dies in die 
<uri link="#doc_chap2_sect5">Passwortrichtlinien</uri> ein).
</p>

<p>
Mehr über <uri link="http://www.openssh.org">OpenSSH</uri> finden Sie 
auf der Webseite.
</p>


</body>
</section>
<section>
<title>Benutzung von xinetd</title>
<body>
<p>
xinetd ist ein Ersatz für inetd (welchen Gentoo nicht hat), den 
Internet-Dienst-Daemon. Er unterstützt Zugriffskontrolle basierend auf den 
Adressen der entfernten Hosts und der Zugriffszeit. Es beinhaltet auch 
ausführliche Protokollfähigkeiten, inklusive Serverstartzeit, Adresse des 
entfernten Hosts, entfernter Benutzername, Serverlaufzeit und geforderte 
Abläufe.
</p>

<p>
Wie bei allen anderen Diensten ist es wichtig eine gute Standardkonfiguration 
zu haben. Da aber <c>xinetd</c> von root benutzt wird und Protokolle 
unterstützt, von denen Sie möglicherweise die Funktionsweise nicht verstehen, 
raten wir Ihnen es nicht zu benutzen. Wenn Sie es aber doch benutzen wollen, 
fügen Sie so mehr Sicherheit hinzu:
</p>

<pre caption="Installieren von xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Ergänzen Sie die Konfigurationsdatei um:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Dies konfiguriert pserver (cvs) durch xinetd mit den folgenden Einstellungen:
# maximal 10 Instanzen (10 Verbindungen gleichzeitig)
# Begrenzung von pserver auf tcp
# benutzen des Benutzer-cvs um diesen Dienst laufen zu lassen
# Anbinden der Schnittstelle an nur 1 IP
# Zulassen von Zugriff von 10.0.0.*
# Begrenzung der Zeit in der Entwickler auf das cvs
# zugreifen können von 08Uhr bis 17Uhr
# Benutzung von tcpd wrappers (Zugriffskontrolle kontrolliert durch 
# <i>/etc/hosts.allow</i> und <i>/etc/hosts.deny</i>)
# max_load ist an der Maschine auf 1.0 gesetzt
# die disable flag (sperren) steht auf nein, aber ich bevorzuge sie zu 
# haben, für den Fall das es gesperrt werden sollte
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Für weitere Information lesen Sie bitte <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (dies steht für "Very Secure ftp") ist ein kleiner FTP-Dämon mit einer 
einfachen Standardkonfiguration. Er ist einfach und hat nicht so viele 
Funktionen (wie z.B. virtuelle Benutzer) wie sie PureFTP und ProFTP anbieten.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#nur lesbar
write_enable=NO

#Aufzeichnen von Übertragungen aktivieren
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Wie Sie sehen können, gibt es keine Möglichkeit für diesen Dienst 
individuelle Rechte und eine standardmässige chroot-Aktion zu konfigurieren. 
Aber wenn es um die anonymen Einstellungen geht, dann entwickelt sich dies 
zum Vorteil. Manchmal kann es gut sein einen anonymen FTP-Server z.B. zum 
Verteilen von Open-Source zu haben und dieser Server passt hierfür perfekt.
</p>

</body>
</section>
<section>
<title>X</title>
<body>
 
<p>
Standardmäßig ist XFree konfiguriert als Xserver zu arbeiten. Dies kann 
 gefährlich sein, denn X verwendet unverschlüsselte TCP Verbindungen und 
 wartet auf xclients.
</p>

<impo>
Wenn Sie diesen Dienst nicht benötigen, deaktivieren Sie ihn!
</impo>

<p>
Wenn Sie aber Ihre Workstation als Xserver verwenden müssen, dann seien 
Sie vorsichtig mit dem <c>/usr/X11R6/bin/xhost</c> Befehl. Dieser Befehl 
erlaubt es Clients von anderen Hosts sich zu verbinden und Ihre Display zu 
benutzen. Dies kann hilfreich sein, wenn Sie eine X Anwendung von einem 
anderen Rechner benötigen und der einzige Weg über das Netzwerk führt.
Der Syntax ist <c>/usr/X11R6/bin/xhost +hostname</c>
</p>

<warn>
Verwenden Sie das <c>xhost +</c> Feature niemals! Dies erlaubt es jeglichen 
Clients eine Verbindung aufzubauen und Kontrolle über Ihr X zu erlangen. Wenn 
ein Angreifer Zugang zu Ihrem X erlangt, kann er Ihre Tastenanschläge 
protokollieren und Ihren Desktop kontrollieren. Wenn Sie es verwenden müssen, 
denken Sie immer daran einen Host zu spezifizieren.
</warn>


<p>
Eine sichere Lösung ist dieses Feature komplett zu deaktivieren, indem man X 
 mit <c>startx -- -nolisten tcp</c> startet oder es permanent in der 
Konfiguration deaktiviert.
</p>

<pre caption="/usr/X11R6/bin/startx">
 defaultserverargs="-nolisten tcp"
</pre>

<p>
Um sicherzustellen, dass <path>startx</path> nicht überschrieben wird, wenn 
man eine neue Version von xfree mit emerge installiert, müssen Sie es 
schützen. Fügen Sie die folgende Zeile zu <path>/etc/make.conf</path> hinzu:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Wenn Sie einen graphischen Loginmanager verwenden, müssen 
Sie die Sache anders angehen.
</p>


<p>
Für <c>gdm</c> (Gnome Display Manager).
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Füt <c>xdm</c> (X Display Manager) und <c>kdm</c> (Kde Display Manager)
</p>

 <pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>

</body>
</section>
<section>
<title>Chrooten</title>
<body>

<p>
Einen Dienst zu chrooten stellt eine Möglichkeit dar einen Dienst (oder 
Benutzer) auf für ihn vorgesehene Ressourcen zu beschränken und zu verhindern,
daß er Zugang zu Bereichen (oder Informationen) erlangt, die zu einem 
unberechtigten Besitz von root-Rechten führen könnte. Indem man einen 
Dienst als ein anderer Benutzer als <c>root</c> laufen lässt (<c>nobody</c>, 
<c>apache</c>, <c>named</c>) kann ein Angreifer nur Zugriff auf Dateien 
nehmen mit den Berechtigungen des Users. Dies bedeutet, dass ein Angreifer 
nie <c>root</c> Zugang erlangen kann, selbst wenn der entsprechende Dienst 
eine Sicherheitslücke hätte.
</p>

<p>
Einige Dienste wie zum Beispiel <c>pure-ftpd</c> und <c>bind</c> haben 
eingebaute Fähigkeiten für "chrooting" und andere Dienste bieten dies nicht. 
Wenn der Dienst es anbietet, dann benutzen Sie es, andernfalls müssen Sie in 
die Materie einsteigen und einen eigenen Benutzer erstellen. Lassen Sie es uns 
nun versuchen und eine eigene chroot-Umgebung aufbauen. Um einen Einstieg zu 
finden und zu sehen wie chroot arbeitet versuchen wir es zuerst mit bash 
(als einfachen Einstieg ins Lernen).
</p>

<p>
Erstellen Sie das <path>/chroot</path> Verzeichnis mitttels 
<c>mkdir /chroot</c>. Nun müssen wir herausfinden, mit welche dynamischen 
Bibliotheken <c>bash</c> benötigt (wenn sie mit <c>-static</c> kompiliert 
wurde, dann ist dieser Schritt nicht nötig).
</p>

<p>
Das folgende Kommando wird eine Liste der von <c>bash</c> benutzten 
Bibliotheken ausgeben.
</p>

<pre caption="Benutzte Bibliotheken auflisten">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Nun erstellen wir die Umgebung für <c>bash</c>.
</p>

<pre caption="chroot-Umgebung für bash erstellen">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Nun kopieren wir die von <c>bash</c> benutzten Dateien (<path>/lib</path>) in 
das chrootete <path>lib</path> und kopieren das Kommando bash in das 
Verzeichnis <path>/bin</path> im chroot. Dies wird die originale Umgebung 
herstellen - nur eben mit weniger Funktionalität. Nachdem das Kopieren 
abgeschlossen wurde versuchen Sie ein  <c>chroot /chroot/bash /bin/bash</c>.
Wenn Sie ein Prompt bekommen, dass als aktuelles Verzeichnis <c>/</c> 
angibt, dann hat alles funktioniert. Wenn nicht, dann werden Sie unter 
Umständen eine Fehlermeldung bekommen, die die fehlende Datei angibt. 
Manche dynamische Bibliotheken bauen aufeinander auf.
</p>

<p>
Sie werden feststellen, dass innerhalb der chroot-Umgebung nichts anderes als 
<c>echo</c> funktioniert. Dies ist deshalb so, weil wir keine anderen Kommandos 
in unserer chroot-Umgebung haben und <c>echo</c> ein in bash eingebauter 
Befehl ist.
</p>

<p>
Dies ist in etwa der Weg den Sie gehen würden, um einen "ge-chrooteten" 
Dienst zu erstellen. Der einzige Unterschied ist, dass Dienste manchmal auf 
Geräten und Konfigurationsdateien in <path>/etc</path> basieren.
Kopieren Sie diese einfach in die chroot-Umgebung (Geräte können mit cp -a 
kopiert werden) und editieren Sie das Init-Script sodaß es die chroot-Umgebung
vor der Ausführung verwendet. Es kann schwierig sein herauszufinden, welche
Konfigurationsdateien und Geräte ein Dienst benutzt. Dies ist der Punkt, 
an dem <c>strace</c> nützlich wird. Starten Sie den Service mit 
<path>/usr/bin/strace</path> bash und suchen Sie nach open, read, stat und 
vielleicht noch connect. Dies wird Ihnen eine Idee darüber geben, welche 
Dateien Sie kopieren müssen. Aber in den meisten Fällen kopieren Sie einfach 
die passwd-datei (vorher editieren und die Benutzer entfernen, die mit dem 
Dienst nichts zu tun haben), <path>/dev/zero</path>, <path>/dev/log</path> und 
<path>/dev/random</path> in die neue Umgebung.
</p>
 </body>
 </section>
 <section>
 <title>Virtuelle Server</title>
 <body>
<p>
Ein weiterer Weg eine sichere Umgebung zu erstellen besteht darin, eine 
virtuelle Serverumgebung zu erstellen. Dies wird eine Kopie der 
exisitierenden Linuxinstallation erstellen und es virtuell booten. Dies 
bedeutet, dass wenn der Server angegriffen wird in Wirklichkeit nur der 
virtuelle Server angegriffen wird, nicht die echte Installation.
</p>

<p>
Beispiele von virtuellen Servern:
</p>

<ul>
<li>
  <uri link="http://user-mode-linux.sourceforge.net">Usermode Linux</uri> und 
  ein HowTo über <uri link="http://www.gentoo.org/doc/uml.html">Usermode 
  Linux</uri>.
</li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Firewalls</title>
<section>
<title>Eine Firewall</title>
<body>

<p>
Oftmals wird eine Firewall als die ultimative Sicherheitsmassnahme bezeichnet - 
was aber nur bedingt stimmt. In den meisten Fällen kann eine falsch 
konfigurierte Firewall ein System sogar noch mehr verunsichern. Eine Firewall 
ist auch eine Software und sollte genau so wie jeder andere Dienst behandelt 
werden, denn auch hier können Bugs vorhanden sein (die hier Sicherheitslöcher 
sind).
</p>

<p>
Also denken Sie nach, bevor Sie eine Firewall in Betrieb nehmen! Brauchen Sie 
wirklich eine? Wenn Sie der Meinung sind, daß sie eine brauchen, dann verfassen 
Sie eine Richtlinie wie sie funktionieren sollte, welcher Art sie sein soll und
wer sie betreiben sollte.
</p>

<p>
Firewalls werden für folgende beiden Zwecke verwendet:
</p>

<ul>
<li>Um Benutzer (Würmer/Angreifer) draussen zu halten</li>
<li>Um Benutzer (Angestellte/Kinder) drinnen zu halten</li>
</ul>

<p>
Es gibt im Allgemeinen drei Arten von Firewalls:
</p>

<ul>
<li>Paket-Filter</li>
<li>>>>> S.o please translate >>>> Circuit relay</li>
<li>Applikationsgateway</li>
</ul>

<p>
Eine Firewall sollte auf einer dedizierten Maschine ohne weitere Dienste laufen 
(und wenn, dann höchstens noch ssh) und so abgesichert werden wie dieser 
Leitfaden es vorschlägt.
</p>

</body>
</section>
<section>
<title>Paket-Filter</title>
<body>

<p>
Jeglicher Netzwerkverkehr basiert auf Paketen. Viel Verkehr wird in kleinere 
Pakete transformiert (da diese einfacher zu handhaben sind) und bei der Ankunft 
am Ziel wieder in der richtigen Reihenfolge wieder zusammengesetzt. Jedes Paket 
enthält Informationen darüber wie es wohin transportiert werden soll. Und genau 
diese Informationen macht sich eine Firewall mit Paketfilter zu nutze. 
Filtern basiert auf:
</p>

<ul>
<li>Erlauben oder verbieten von Paketen entsprechend der Quell-/Ziel-IP-Adresse</li>
<li>Erlauben oder verbieten von Paketen entsprechend des Quell-/Ziel-Ports</li>
<li>Erlauben oder verbieten von Paketen entsprechend dem verwendeten Protokoll</li>
<li>Erlauben oder verbieten von Paketen entsprechend von bestimmten Einstellungen 
im Protokoll</li>
</ul>

<p>
Normalerweise wird nur anhand der Daten im Kopf eines Paketes und nicht im 
eigentlichen Inhalt vollzogen.
</p>

<p>
Schwächen:
</p>

<ul>
<li>
  Adressinformationen in einem Paket könnten gefälscht (<e>gespoofed</e>) 
  an den Sender übermittelt werden
</li>
<li>
  Daten oder Anfragen im erlaubten Paket könnten ungewollte Daten enthalten 
  die ein Angreifer zu seinen Zwecken benutzen könnte um z.B. Schwächen in 
  den Diensten oder hinter der Firewall zu benutzen.
</li>
<li>Normalerweise kann ein Fehler die Firewall unbrauchbar machen</li>
</ul>

<p>
Vorteile:
</p>

<ul>
<li>Einfach und schnell zu implementieren</li>
<li>
  Kann Warnungen vor Angriffen verursachen, bevor diese stattfinden 
  (erkennen von Portscans)
</li>
<li>Geeignet um SYN-Attacken zu beenden</li>
</ul>

<p>
Beispiele für freie Paketfilter für Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

</body>
</section>
<section>
<title>Circuit Relay</title>
<body>

<p>
Oder auch Circuit Level Gateways sind Firewalls, die Verbindungen validieren 
bevor die Erlaubnis für den Datenaustausch erteilt wird. Dies bedeutet, dass 
Pakete entsprechend dem Inhalt des Paketkopfes erlaubt oder verboten werden; 
dies aber hängt davon ab, ob die Verbindung an beiden Enden gültig 
entsprechend konfigurierbaren Regeln ist, bevor sie geöffnet oder Daten 
ausgetauscht werden. Filtern basiert auf:
</p>

<ul>
<li>Quell-/Zieladresse</li>
<li>Quell-/Zielport</li>
<li>Zeitraum</li>
<li>Protokoll</li>
<li>Nutzer</li>
<li>Passwort</li>
</ul>

<p>
Jeglicher Verkehr wird validiert, überwacht und Verkehr ohne diese 
Informationen wird verboten.
</p>

<p>
Schwächen:
</p>

<ul>
<li>
Operiert auf der Transportebene und kann u.U. grundlegende Veränderungen in 
der Programmierung die normalerweise die Transportfunktionen regelt erfordern.
</li>
</ul>

</body>
</section>
<section>
<title>Applikationsgateway</title>
<body>

<p>
Der Gateway auf der Applikationsebene ist ein Proxy für eine Applikation, 
die Daten mit dem Remotesystem unter Verwendung seiner Clients austauscht. 
Er wird vor der Öffentlichkeit hinter einer DMZ oder einer Firewall ohne 
Verbindung zur Aussenwelt gesichert. Der Filter basiert auf:
</p>

<ul>
<li>Erlauben oder verbieten basierend auf Herkunft/Ziel</li>
<li>Entsprechend dem Paketinhalt</li>
<li>Dateizugriff abhängig von Dateityp oder -Erweiterung beschränken</li>
</ul>

<p>
Vorteile:
</p>

<ul>
<li>Dateien können zwischengespeichert werden - das erhöht die Netzwerkleitung</li>
<li>Detailliertes aufzeichnen von Verbindungen</li>
<li>Skaliert perfekt (manche Proxy-Server können die zwischengespeicherten 
Daten teilen)</li>
<li>Kein direkter Zugriff von Aussen</li>
<li>Kann Inhalte "on the fly" modifizieren</li>
</ul>

<p>
Schwächen:
</p>

<ul>
<li>Die Konfiguration ist Komplex</li>
</ul>

<p>
Applikationsgateways werden als die sicherste Lösung angesehen, da sie nicht 
als root laufen müssen und Richtung Internet nicht öffentlich sind.
</p>

<p>
Beispiel eines freien Applikationsgateways:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Um iptables ans Laufen zu kriegen, muss es im Kernel aktiviert werden. Ich habe 
sie als Module eingefügt (das Kommando iptables wird diese wenn benötigt laden) 
und den Kernel neu kompiliert. Für mehr Informationen zur Konfiguration von
iptables lesen Sie <uri 
link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables 
Tutorial Chapter 2: Preparations</uri>. Nachdem Sie den Kernel neu kompiliert haben 
(oder noch während der Kernel kompiliert wird) müssen Sie die iptables-Kommandos 
hinzufügen. Führen Sie einfach nur <c>emerge iptables</c> aus und alles sollte 
funktionieren.
</p>

<p>
Nun probieren Sie bitte ob alles funktioniert, indem Sie <c>iptables -L</c> 
ausführen. Wenn irgendetwas nicht funktioniert, dann sollten Sie die 
Konfiguration nochmals überprüfen.
</p>

<p>
Iptables ist der neue und extrem verbesserte Paketefilter in Linux 2.4.x. Es 
ist der Nachfolger von ipchains aus dem Linux 2.2.x Kernel. Eine der großen
Verbesserungen ist, dass iptables nun in der Lage ist "stateful" Packet 
Filtering zu performen. Mit "stateful" Packet filtering is es möglich die Spur
jeder errichteten TCP Verbindung zu verfolgen.
</p>

<p>
Eine TCP Verbindung besteht aus einer Serie von Paketen die Informationen über 
die Quelladresse, die Zieladresse und einem Zähler der das richtige Zusammensetzen 
der Daten ermöglicht. TCP ist im Gegensatz zu UDP ein verbindungsorientiertes 
Protokol, UDP ist verbindungslos.
</p>

<p>
Bei der Prüfung der Header der TCP Pakete kann ein "stateful" Paketfilter 
bestimmen, ob ein empfangenes TCP Paket zur einer bestehenden Verbindung gehört
oder nicht und das Paket entweder akzeptieren oder wegwerfen.
</p>

<p>
Mit einem "stateless" Paketfilter is es möglich, dem Paket Filter Pakete 
durch das manipulieren des TCP Paket Header unterzuschieben die eigentlicht
gedroppt werden sollten. Dies kann durch das manipulieren des SYN Flag oder
anderer Flags im TCP Header erreicht werden. Mit "stateful" Packet Filtering
ist es möglich solche Pakete zu droppen, da Sie keiner bestehenden Verbindung
zuzuordnen sind. Damit wird auch die Möglichkeit von "stealth scans" verhindertn, 
da solche Pakete ebenfalls keiner bestehenden Verbindung zuzuordnen sind.
</p>

<p>
Iptables bietet einige weitere Möglichkeiten wie zum Beispiel 
Wiederholungsbegrenzung (rate limiting). Diese Fähigkeit ist extrem nützlich, 
wenn man einen sicheren DoS (Denial of Service)-Angriff wie auch 
einen SYN-Angriff verhindern will.
</p>

<p>
Eine TCP-Verbindung wird durch einen sogenannten Drei-Wege-Handschlag 
aufgebaut. Wenn eine TCP Verbindung sendet der Client ein Paket mit einem 
SYN Flag an den Server. Wenn die Server-Seite das SYN Paket empfängt reagiert
sie, in dem sie ein SYN+ACK Paket an den client schickt. Wenn der SYN+ACK vom
Client empfangen wird, erkennt dieser wiederum mit einem dritten ACL Paket 
die Verbindung an.
</p>

<p>
Ein SYN-Angriff geschieht, wenn nur ein SYN-Paket gesendet wird, aber das 
Senden des SYN+ACK Paket fehlschlägt. Der Client kann ein Paket mit einer
gefälschten IP-Adresse senden, da es keine Antwort benötigt. Der Server
wird beim Empfang eines SYN Paket einen Eintrag in die Liste 
halb-geöffneter Verbindungen machen und dann auf den finalen ACK warten,
bis der Eintrag gelöscht wird. Der Queue hat eine begrenzte Anzahl von
Slots, wenn alle Slots belegt sind können keine neuen Verbindungen aufgebaut
werden. Wenn der ACK nicht innerhalb eines begrenzten Zeitraums beim Server
ankommt timed die Verbindung aus, der Eintrag wird aus der Queue gelöscht.
Die Timeout Einstellungen variieren, liegen aber typischerweise im Bereich 
von 30 bis 60 Sekunden oder mehr. Die Clientseite initiert die Attacke
durch das Aussenden einer größtmöglichen Zahl von SYN Paketen mit 
verschiedenen Source IP Adressen. Dadurch wird die Liste halb-geöffneter
Verbindungen schnell gefüllt, so dass andere Clients davon abgehalten werden
eine Verbindung zu diesem Server aufzubauen.
</p>

<p>
Hier wird das Ratenlimit besonders hilfreich. Es ist möglich die Anzahl von 
SYN-Pakten von einer bestimmten Quelle zu begrenzen, aber durch Gebrauch 
von <c>-m limit --limit 1/s</c> begrenzt dies das Limit der SYN-Pakete für 
eins pro Quelle und daher begrenzt die SYN-Flut auf unsere Ressourcen.</p>

<p>
Jetzt einiger praktischer Kram!
</p>

<p>
Wenn iptables in den Kernel geladen wird, hat es 5 Aufhänger an die Sie ihre 
Regeln hängen können. Sie heissen <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>,
<c>PREROUTING</c> und <c>POSTROUTING</c>. Diese Listen nennt man Ketten, 
da sie per zugefügter Regel funktionieren und überprüfen die Regeln eine 
nach der anderen in der Reihenfolge wie sie hinzugefügt wurden. Wenn eine 
Regel auf ein Paket nicht zutrifft wird es an die nächste Regel 
weitergeleitet.
</p>

<p>
Sie können Regeln direkt in die 5 Hauptketten setzen oder Ketten erstellen 
und diese als Regel zu einer existierenden Kette hinzufügen. Iptables 
unterstützt die folgenden Optionen.
</p>

<table>
  <tr>
  <th>Option:</th>
  <th>Beschreibung:</th>
  </tr>
  <tr>
  <ti>-A</ti>
  <ti>Anhängen</ti>
  </tr>
  <tr>
  <ti>-D</ti>
  <ti>Löschen</ti>
  </tr>
  <tr>
  <ti>-I</ti>
  <ti>Einfügen</ti>
  </tr>
  <tr>
  <ti>-R</ti>
  <ti>Ersetzen</ti>
  </tr>
  <tr>
  <ti>-L</ti>
  <ti>Auflisten</ti>
  </tr>
  <tr>
  <ti>-F</ti>
  <ti>Löscht alle Regeln in der Kette oder in allen Ketten</ti>
  </tr>
  <tr>
  <ti>-Z</ti>
  <ti>Keine Counter in der Kette oder in allen Ketten</ti>
  </tr>
  <tr>
  <ti>-C</ti>
  <ti>Teste dieses Paket an der Kette</ti>
  </tr>
  <tr>
  <ti>-N</ti>
  <ti>Erstellen einer neuen benutzerdefinierten Kette</ti>
  </tr>
  <tr>
  <ti>-X</ti>
  <ti>Löschen einer benutzerdefinierten Kette</ti>
  </tr>
  <tr>
  <ti>-P</ti>
  <ti>Richtlinie der Kette bezüglich des Ziels ändern</ti>
  </tr>
  <tr>
  <ti>-E</ti>
  <ti>Ändern des Kettennamens</ti>
  </tr>
  <tr>
  <ti>-p</ti>
  <ti>Protokoll</ti>
  </tr>
  <tr>
  <ti>-s</ti>
  <ti>Quelladresse/maske</ti>
  </tr>
  <tr>
  <ti>-d</ti>
  <ti>Zieladresse/maske</ti>
  </tr>
  <tr>
  <ti>-i</ti>
  <ti>Eingabename (Ethernetname)</ti>
  </tr>
  <tr>
  <ti>-o</ti>
  <ti>Ausgabename (Ethernetname)</ti>
  </tr>
  <tr>
  <ti>-j</ti>
  <ti>Jump (Ziel für Regel)</ti>
  </tr>
  <tr>
  <ti>-m</ti>
  <ti>Erweiterter Treffer (Kann erweiterung benutzen)</ti>
  </tr>
  <tr>
  <ti>-n</ti>
  <ti>Numerische Ausgabe von Adressen und Ports</ti>
  </tr>
  <tr>
  <ti>-t</ti>
  <ti>Zu ändernde Tabelle</ti>
  </tr>
  <tr>
  <ti>-v</ti>
  <ti>Ausführliche Ausgabe</ti>
  </tr>
  <tr>
  <ti>-x</ti>
  <ti>Zahlen Erweitern (exakte Werte anzeigen)</ti>
  </tr>
  <tr>
  <ti>-f</ti>
  <ti>Nur auf die zweiten oder weitere Pakete achten</ti>
  </tr>
  <tr>
  <ti>-V</ti>
  <ti>Paketversion</ti>
  </tr>
  <tr>
  <ti>--line-numbers</ti>
  <ti>Zeilennummern mit ausgeben</ti>
  </tr>
</table>

<p>
Zuerst werden wir versuchen alle ICMP-Pakete an unsere Maschine zu blocken - 
nur um uns mit iptables vertraut zu machen.
</p>

<pre caption="Alle ICMP-Pakete blocken">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Zuerst legen wir die Kette fest, an die es angehängt werden soll, dann das 
Protokoll und dann das Ziel. Das Ziel kann eine Benutzer spezifierte Regel oder
eines der speziellen Ziele <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, 
<c>LOG</c>, <c>QUEUE</c>, <c>MASQUERADE</c> sein. In diesem Fall benutzen wir 
<c>DROP</c> daß das Paket ohne irgendeine Antwort an den Client fallen lässt.
</p>

<p>
Nun versuchen Sie ein <c>ping localhost</c>. Es wird nicht möglich sein, 
eine Antwort zu bekommen, da das komplette ICMP-Protokoll eingehend geblockt 
wird. Es wird auch nicht möglich sein, andere Maschinen azupingen, da die 
Pakete nicht mehr von den anderen Rechnern in unseren Rechner kommen können. 
Nun leeren Sie die Kette um ICMP wieder zum Laufen zu bekommen.
</p>

<pre caption="Alle Regeln leeren (Flush)">
# <i>iptables -F</i>
</pre>

<p>
Nun sehen wir uns die Zustandsmaschinerie in iptables an. Wenn wir eine 
Prüfung bezüglich des Verbindungszustandes an eth0 haben wollen, könnten wir 
dies folgendermassen aktivieren:
</p>

<pre caption="Pakete die zu einer bereits bestehenden Verbindung gehören akzeptieren">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Dies wird in der INPUT-Kette alle Pakete die zu einer bereits bestehenden oder 
einer verwandten Verbindung gehören akzeptieren. Man könnte auch jedes Paket, 
dass nicht in der Zustandstabelle abgedeckt wurde fallen lassen, indem man 
<c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> direkt davor 
aufruft. Das aktiviert die Zustandssteuerung in iptables da es die Erweiterung 
state lädt. Wenn Sie nun von Aussen mit Ihrer Maschine, dann könnten Sie 
<c>--state NEW</c> benutzen. Iptables enthält einige unterschiedliche Module 
für unterschiedliche Anwendungszwecke. Einige dieser Module sind:
</p>

<table>
  <tr>
  <th>Modul/Treffer</th>
  <th>Beschreibung</th>
  <th>Erweiterte Optionen</th>
  </tr>
  <tr>
  <ti>mac</ti>
  <ti>Prüfung auf die Quell-MAC-Adressen der eingehenden Pakete.</ti>
  <ti>--mac-source</ti>
  </tr>
  <tr>
  <ti>state</ti>
  <ti>Prüfung auf Zustand</ti>
  <ti>--state (passende Werte sind ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
  <ti>limit</ti>
  <ti>Trefferrate begrenzen</ti>
  <ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
  <ti>owner</ti>
  <ti>Prüfung auf diverse Fähigkeiten des Paketgernators</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
  </tr>
  <tr>
  <ti>unclean</ti>
  <ti>Diverse Gültigkeitsprüfungen auf den Paketen</ti><ti></ti>
  </tr>
</table>

<p>
Lassen Sie uns nun eine benutzerdefinierte Kette erstellen und in einer 
der existierenden Ketten einbetten:
</p>

<pre caption="Benutzerdefinierte Kette erstellen">
<codenote>Neue Kette mit einer Regel erstellen</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>Die Standardrichtlinie sagt, dass jeglicher ausgehender Verkehr erlaubt ist, aber eingehender verboten.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>And add it to the INPUT chain</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
Indem man die Regel in die INPUT-Kette einpasst bekommt man die Richtlinie: 
Alles darf raus, aber alles reinkommende wird verworfen ("gedroppt").
</p>

<p>
Man findet  Dokumentation in der<uri
link="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables
Dokumentation</uri>.
</p>

<p>
Schauen wir uns nun ein komplettes Beispiel an. In diesem Falle sagt meine 
Firewall/Gateway Richtline:
</p>

<ul>
<li>Verbindungen zur Firewall wird nur über SSH erlaubt (Port 22)</li>
<li>
  Das lokale Netz soll Zugriff auf HTTP, HTTPS und SSH haben (DNS sollte auch 
  erlaubt sein)
</li>
<li>ICMP-Verkehr könnte kritische Daten enthalten und sollte deswegen nicht 
erlaubt sein. Natürlich gibt es einige Ausnahmen
</li>
<li>Portscans sollten erkannt und aufgezeichnet werden</li>
<li>SYN-Angriffe sollten abgewehrt werden</li>
<li>Jeglicher anderer Verkehr sollte blockiert und aufgezeichnet werden</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#Innen
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#Aussen
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setze interne Regeln"

  einfo "Setze Standardregel auf Fallenlassen"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #Standardregel
  einfo "Erstelle Zustands-Kette"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \
      "Böses Paket von ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP Verkehr
  einfo "Erstelle ICMP-Kette"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Eingehender Verkehr
  einfo "Erstelle Kette für eingehenden SSH-Verkehr"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood-Schutz
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state -state RELATED,ESTABLISHED -p tcp -dport ssh -j ACCEPT

  #Ausgehender Verkehr
  einfo "Erstelle Kette für ausgehenden SSH-Verkehr"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Erstelle Kette für ausgehenden DNS-Verkehr"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Portscanner fangen
  einfo "Erstelle Portscan-Erkennungs-Kette"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Ungültige Zustände in den Ketten einpassen
  einfo "Passe Ketten in INPUT an"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Passe Ketten in FORWARD an"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Passe Ketten in OUTPUT an"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #erlaube den Clients über NAT (Network Address Translation) zu routen
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE
  eend $?
}

start() {
  ebegin "Starte Firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} existiert nicht. Benutze Standardregeln."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Halte Firewall an"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setze Panikregeln"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Sichere Firewallregeln"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Stelle Firewallregeln wieder her"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Benutzung: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      Wird die Standardeinstellung wieder herstellen oder anderndfalls zu Regeln zwingen"
  echo "stop)       Alle Regeln löschen und alles akzeptieren"
  echo "rules)      zu Einstellungen der neuen regeln zwingen"
  echo "save)       speichert die Regeln in ${FIREWALL}"
  echo "restore)    stellt die Regeln von ${FIREWALL} wieder her"
  echo "showstatus) Status anzeigen"
}
</pre>

<p>
Kostenloser Ratschlag für das Erstellen einer Firewall:
</p>

<ol>
<li>Erstellen Sie vor der Implementierung eine Richtlinie für die Firewall</li>
<li>Halten Sie sie einfach</li>
<li>
  Erlangen Sie Wissen über die Protokolle (lesen Sie das 
  <uri link="http://www.ietf.org/">RFC (Request For Comments)</uri>)
</li>
<li>
  Denken Sie daran, dass eine Firewall ein weiteres Paket ist, dass als 
  root läuft
</li>
<li>Testen Sie die Firewall</li>
</ol>

<p>
Wenn Sie denken, dass iptables schwer zu verstehen sind oder es zu lange 
dauert eine sinnvolle Firewall zu erstellen, dann könnten Sie auch 
<uri link="http://www.shorewall.net">Shorewall</uri> benutzen. Es benutzt im 
Grunde genommen iptables um eine Firewall zu erstellen, aber es konzentriert 
sich auf Regeln und nicht auf spezielle Protokolle.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid ist ein sehr leistungsstarker Proxy Server, er hat eingebaute Filter, 
lehnt Traffic auf Grund folgender Merkmale ab: Zeit, regelmäßiger 
Ausdruckspfad/URI, Quell- und Zieladresse (IP), Domäne, Browser, der 
authentifizierte Benutzername, Mime-Typ und Port (Protokoll). Wahrscheinlich 
habe ich einige Funktionen vergessen, aber es ist schwer jede Funktion der 
gesammten Funktionsliste abzudecken.
</p>

<p>
Im folgenden Beispiel habe ich einen Banner Filter hinzugefügt anstatt eines 
Filters basiernd auf pornographischen Seiten. Der Grund dafür ist, dass 
Gentoo.org <e>nicht</e> als eine pornographische Seite aufgelistet werden 
sollte. Ausserdem will ich meine Zeit nicht damit verbringen einige gute Seiten 
für Sie zu finden.
</p>

<p>
In diesen Fall diktiert meine Richtlinie:
</p>

<ul>
<li>
  Surfen (HTTP/HTTPS) ist während der Arbeitszeiten erlaubt
  (MO-FR 8-16 und SA 8-13), wenn sie länger da sind, sollten sie arbeiten 
  und nicht surfen.
</li>
<li>
  Downloaden ist nicht erlaubt (.exe, .com, .arj, .zip, .asf, .avi, .mpg, 
  .mpeg etc.)
</li>
<li>
  Banner sind unerwünscht, daher werden sie herausgefiltert und mit einem 
  transparenten GIF ersetzt (hier können Sie kreativ werden!)
</li>
<li>
  Jede andere kommende oder gehende Verbidung mit dem Internet ist nicht 
  erlaubt.
</li>
</ul>

<p>
Dies wird in 4 <e>einfachen</e> Schritten implementiert .
</p>

<pre caption="/etc/squid/squid.conf">
# Anbinden an eine IP und einen Port
http_port 10.0.2.1:3128

# Standardkonfiguration
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Hinzufügen von grundlegenden Listen der Zugriffskontrolle 
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Hinzufügen wer auf diesen Proxy Server zugreifen kann
acl localnet src 10.0.0.0/255.255.0.0

# Und welche Ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Hinzufügen von Listen zur Zugriffskontrolle basierend 
# auf regelmäßigen Ausdrücken innerhalb von URLs
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Hinzufügen von Listen zur Zugriffskontrolle basierend 
# auf Datum und Uhrzeit
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# Erlauben von Managmentzugriff von Localhost
http_access allow manager localhost
http_access deny manager

# Nur Purge Anfragen von Localhost erlauben
http_access allow purge localhost
http_access deny purge

# Verweigern von Anfragen an unbekannte Ports
http_access deny !Safe_ports

# Verweigern von CONNECT an alle ausser SSL Ports
http_access deny CONNECT !SSL_ports

# Meine eigenen Regeln


# Hinzufügen einer Seite zur Darstellung,
# wenn ein Banner entfernt wurde
deny_info NOTE_ADS_FILTERED url_ads

# Dann diese verweigern
http_access deny url_ads

# Verweigern aller Archive
http_access deny archives

# Begrenzung des Zugriffs auf Arbeitszeiten
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Verweigern von allem anderen
http_access deny all
</pre>

<p>
Als nächstes fügen Sie alle Dateitypen ein, von denen sie wollen, dass ihre 
Benutzer sie nicht herunterladen können. Ich habe zip, viv, exe, mp3, rar, 
ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz und z Dateien gewählt. 
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
 \.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Beachten Sie bitte die [] mit Gross- und Kleinbuchstaben fuer jeden Buchstaben.
Dies dient dazu, dass niemand es umgehen kann indem er eine Datei mit AvI 
abruft anstatt avi.
</note>

<p>
Als nächstes fügen wir die regelmäßigen Ausdrücke ein um Banner zu 
identifizieren. Sie werden wahrscheinlich viel kreativer sein als ich:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Nun der letzte Teil: Wir wollen diese Datei anzeigen, wenn das Banner 
entfernt wird. Es ist grundlegend eine halbe HTML Datei mit einem 4x4 
transparenten GIF Bild.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>FEHLER: Die angeforderte URL konnte nicht angezeigt werden&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Anzeige gefiltert!&lt;/H1&gt;
</pre>

<note>
Schliessen sie die &lt;HTML&gt; &lt;BODY&gt; Tags nicht. Dies wird von 
Squid erledigt.
</note>

<p>
Wie Sie sehen können hat Squid eine Vielzahl von Möglichkeiten und ist sehr 
effektiv zum Filtern und als Proxy. Es kann sogar alternative Squid Proxys 
benutzen um an sehr grosse Netzwerke angepasst zu werden. Die Konfiguration, 
die ich hier aufgelistet habe ist hauptsächlich fuer kleine Netzwerke mit 
1-20 Benutzern geeignet.
</p>

<p>
Jedoch die Kombinierung von Paketfilterung (iptables) und dem Anwendungsgateway 
(squid) ist wahrscheinlich die beste Lösung, selbst wenn Squid selber an einem 
sicheren Ort stationiert ist und niemand von ausserhalb darauf zugreifen kann. 
Wir müssen uns weiterhin Gedanken machen um Angriffe von Innen.
</p>

<p>
Nun müssen Sie den Proxy Server in die Einstellungen des Browsers Ihrer 
Benutzers einbinden. Das Gateway verhindert, dass die Benutzer jeglichen 
Kontakt mit der Aussenwelt haben, solange sie nicht den Proxy benutzen.
</p>

<note>
In Mozilla geschieht dies in Bearbeiten->Einstellungen->Erweitert->Proxies 
(bzw. Edit->Preferences->Advanced->Proxies).
</note>

<p>
Es kann auch transparent geschehen, indem man iptables benutzt um den gesamten 
Traffic an einen Squid Proxy weiterzuleiten. Dies kann erreicht werden indem 
man eine Weiterleitungs/Prerouting Regel fürs Gateway hinzufügt:
</p>

<pre caption="Ermöglichen von Portweiterleitung an unseren Proxy Server">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>
<section>
<title>Also was haben wir gelernt?</title>
<body>

<p>
Wir lernten, dass:
</p>

<ol>
<li>
  Eine Firewall selbst ein Risiko sein kann. Eine schlecht konfigurierte 
  Firewall ist schlechter als überhaupt keine.
</li>
<li>
  Wie man ein grundlegendes Gateway und einen transparenten Proxy erstellt
</li>
<li>
  Der Schlüssel zu einer guten Firewall ist das Protokoll zu kennen, 
  dass Sie zulassen wollen
</li>
<li>
  Dass IP Traffic nicht immer legitime Daten beinhaltet, z.B. ein ICMP Paket 
  mit zusätzlicher Nutzlast
</li>
<li>Wie man SYN Angriffe vereitelt</li>
<li>
  Filtern von HTTP Traffic indem man anstössige Bilder und Downloaden von 
  Viren entfernt.
</li>
<li>
  Kombinieren von Paketfiltern und Anwendungsgateways geben eine bessere 
  Kontrolle.
</li>
</ol>

<p>
Nun, wenn sie <e>wirklich</e> müssen, schaffen Sie sich eine Firewall an, 
die ihre Bedürfnisse deckt.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Auffinden von Eindringlingen</title>
<section>
<title>Aide (Advanced Intrusion Detection Environment)</title>
<body>

<p>
Aide ist ein Host basierendes Eindringlingserkennungssystem (eine kostenlose 
Alternative zu Tripwire). Und wenn Sie bereits mit Tripwire vertraut sind, 
sollten sie keine Schwierigkeiten haben die Konfigurationsdateien für Aide 
zu erlernen. 
</p>

<p>
Die Konfigurationsdatei basiert auf regelmäßigen Ausdrücken, Makros und 
Regeln für Dateien und Verzeichnisse. Wir haben die folgenden Makros:
</p>

<table>
  <tr>
  <th>Makro</th>
  <th>Beschreibung</th>
  <th>Syntax</th>
  </tr>
  <tr>
  <ti>ifdef</ti>
  <ti>wenn definiert</ti>
  <ti>@@ifdef "name"</ti>
  </tr>
  <tr>
  <ti>ifndef</ti>
  <ti>wenn nicht definiert</ti>
  <ti>@@ifndef "name"</ti>
  </tr>
  <tr>
  <ti>define</ti>
  <ti>definiert eine Variable</ti>
  <ti>@@define "name" "value"</ti>
  </tr>
  <tr>
  <ti>undef</ti>
  <ti>undefiniert eine Variable</ti>
  <ti>@@undef "name"</ti>
  </tr>
  <tr>
  <ti>ifhost</ti>
  <ti>wenn "hostname"</ti>
  <ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
  <ti>ifnhost</ti>
  <ti>wenn "hostname" nicht</ti>
  <ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
  <ti>endif</ti>
  <ti>
    Endif muss benutzt werden nach jedem der obrigen Makros ausser 
    define und undef
  </ti>
  <ti>@@endif</ti>
  </tr>
</table>

<p>
Diese Makros sind sehr praktisch, wenn sie mehr als ein Gentoo System haben 
und auf allen Aide benutzen wollen. Aber nicht alle Maschinen oder vielleicht 
sogar Benutzer benuten denselben Dienst.
</p>

<p>
Als nächstes haben wir Gruppen von Flags um überprüfungen an Dateien und 
Ordnern durchzuführen. Diese sind eine Kombination aus Berechtigungen, 
Dateieigenschaften und kryptographischen Hashes/Checksummen.
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>p</ti>
  <ti>Berechtigungen</ti>
  </tr>
  <tr>
  <ti>i</ti>
  <ti>Inode</ti>
  </tr>
  <tr>
  <ti>n</ti>
  <ti>Anzahl der Links</ti>
  </tr>
  <tr>
  <ti>u</ti>
  <ti>Benutzer</ti>
  </tr>
  <tr>
  <ti>g</ti>
  <ti>Gruppe</ti>
  </tr>
  <tr>
  <ti>s</ti>
  <ti>Grösse</ti>
  </tr>
  <tr>
  <ti>b</ti>
  <ti>Blockzahl</ti>
  </tr>
  <tr>
  <ti>m</ti>
  <ti>mtime</ti>
  </tr>
  <tr>
  <ti>a</ti>
  <ti>atime</ti>
  </tr>
  <tr>
  <ti>c</ti>
  <ti>ctime</ti>
  </tr>
  <tr>
  <ti>S</ti>
  <ti>überprüfung ob die Grösse wächst</ti>
  </tr>
  <tr>
  <ti>md5</ti>
  <ti>MD5 Checksumme</ti>
  </tr>
  <tr>
  <ti>sha1</ti>
  <ti>SHA1 Checksumme</ti>
  </tr>
  <tr>
  <ti>rmd160</ti>
  <ti>RMD160 Checksumme</ti>
  </tr>
  <tr>
  <ti>tiger</ti>
  <ti>Tiger Checksumme</ti>
  </tr>
  <tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
  </tr>
  <tr>
  <ti>E</ti>
  <ti>Leere Gruppe</ti>
  </tr>
  <tr>
  <ti>&gt;</ti>
  <ti>Wachsende Protokolldatei p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
Und wenn Aide mit mhash Unterstützung kompiliert ist, hat es noch einige 
weitere Funktionen:
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>haval</ti>
  <ti>HAVAL Checksumme</ti>
  </tr>
  <tr>
  <ti>gost</ti>
  <ti>GOST Checksumme</ti>
  </tr>
  <tr>
  <ti>crc32</ti>
  <ti>CRC32 Checksumme</ti>
  </tr>
</table>

<p>
Nun können sie ihre eigenen auf den oben genannten Flags basierenden Regeln
definieren, indem Sie diese folgendermassen kombinieren:
</p>

<pre caption="Erstellen eines Regelsatzes für AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Das letzte was wir tun müssen um unsere eigene Konfigurationsdatei zu 
erstellen ist zu schauen wie man diese Regeln einer Datei oder einem 
Verzeichnis hinzufügt. Grundlegend tippen sie einfach den Datei- oder 
Verzeichnisnamen und die Regel ein. Aide wird alle Dateien rekursiv 
hinzufügen, solange Sie nicht etwas anderes angeben.
</p>

<table>
  <tr>
  <th>Flag</th>
  <th>Beschreibung</th>
  </tr>
  <tr>
  <ti>!</ti>
  <ti>Diese Datei oder dieses Veriechnis nicht hinzufügen. </ti>
  </tr>
  <tr>
  <ti>=</ti>
  <ti>Dieses Verzeichnis hinzufügen, aber nicht rekursiv.</ti>
  </tr>
</table>

<p>
Lassen sie uns also ein vollständiges Beispiel betrachten
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# Der Ort der Datenbank die gelesen werden soll.
database=file:@@{AIDEDIR}/aide.db

# Der Ort der Datenbank, die erstellt werden soll.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Regeldefinition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
Im obrigen Beispiel definieren wir einige Makros, die angeben wo das topdir 
startet und wo das Aide Verzeichnis ist. Aide überprüft die 
<path>/etc/aide/aide.db</path> Datei wenn die Intigrität einer Datei 
überprüft wird. Jedoch wenn ein Update vorgenommen wird oder eine neue 
Datei erstellt wird, speichert es die Informationen in 
<path>/etc/aide/aide.db.new</path>. Dies geschieht, damit die ursprünglich 
Datenbankdatei nicht automatisch überschrieben wird. Die Option report_URL 
ist eine "noch kommende" Funktion die wirklich noch keine Bedeutung hat. 
Die Absicht der Autoren war es, dass es möglich wäre eine Email zu senden 
oder vielleicht sogar ein Script auszuführen.
</p>

<p>
Nach der Konfiguration sollten Sie Ihre Datenbankdatei erstellen indem Sie 
aide -i ausführen und dann die Datei <path>/etc/aide/aide.db.new</path> 
nach <path>/etc/aide/aide.db</path> kopieren und den Check zu cron hinzufügen 
durch crontab -e als root.
</p>

<note>
Abhängig von ihren CPU, Festplattenzugriff und den benutzten Flags für 
Dateien, kann dies einige Zeit in Anspruch nehmen
</note>

<pre caption="Aide als cronjob einrichten">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
Denken sie daran es so einzustellen, dass sie die Post für root bekommen. 
Ansonsten werden Sie niemals wissen was Aide berichtet.
</note>

<p>
In diesem Fall läuft es einmal um 03 Uhr. Dies geschieht dann, denn ich will 
die Benutzer beim Arbeiten nicht stören. Beachten Sie, dass ich die 
<c>-u</c> (Update) Option benutzen statt <c>-C</c> (überprüfen). Denn 
<c>-u</c> überprüft auch die Dateien und überschreibt nicht die 
Originaldatenbankdatei, was Zeit spart, denn so müssen sie nur eine Datei 
kopieren, wenn Veränderungen festgestellt werden. überprüfen sie einfach die 
Veränderungen um zu sehen, ob Sie es selbst waren oder ein Angreifer der die 
Veränderungen gemacht hat bevor sie diese kopieren!
</p>

<p>
Nun gibt es einige Probleme damit die Datenbankdateien lokal zu speichern, 
denn der Angreifer wird (Wenn er weiss, dass Aide installiert ist) 
höchstwahrscheinlich versuchen die Datenbankdatei zu verändern, ein Update 
bei der Datenbankdatei durchzuführen oder <path>/usr/bin/aide</path> zu 
verändern. Deswegen sollten sie eine CD erstellen oder anderes Medium auf 
das Sie eine Kopie der Datenbankdatei und der Aide Binärdateien ablegen.
</p>

<p>
Weitere Informationen gibt es auf der <uri 
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri> Projektseite.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort ist ein "Network Intrusion Detection System (NIDS)". Zur Installation
und Konfiguration benutzen Sie die folgenden Beispiele.
</p>

<pre caption="Dem System einen Anwender hinzufügen">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>Schritt 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Schritt 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>Schritt 3</codenote>
include classification.config

<codenote>Schritt 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Weitere Informationen gibt es auf der <uri 
link="http://www.snort.org">Snorts</uri> Webseite.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Up to Date bleiben</title>
<section>
<body>
<p> 
Wenn Sie Ihr System erfolgreich installiert haben und sichgergestellt 
haben, dass Sie ein gutes Sicherheitslevel erreicht haben, sind Sie trotzdem 
noch nicht fertig. Sicherheit ist ein fortschreitender Prozess und Sie
müssen up to date halten mit den neuesten Sicherheitspatches.
</p>

<p>
Wenn Sie eine aktuelle Version von <c>portage</c> installiert haben, dann 
können Sie zuerst ihren Portage Baum mit <c>emerge sync</c> synchronisieren 
und dann den Befehl <c>glsa-check --list</c> ausführen um zu sehen 
ob Ihr System in Hinsicht auf Sicherheit aktuell ist.
</p>

<pre caption="Beispielsausgabe von glsa-check -l">
#<i>glas-check -l</i>
WARNUNG: Dieses Tool ist komplett neu und noch nicht ausgiebig getestet. 
Daher sollte es nicht in Produktionssystem verwendet werden. Es ist 
grösstenteils ein Testprogramm für das neue GLSA Release und 
Veröffentlichungssystem. Seine Funktionalität wird zu einem späteren 
Zeitpunkt in emerge und equery eingewoben werden.
Bitte lesen Sie http://www.gentoo.org/proj/en/portage/glsa-integration.xml 
bevor Sie dieses Tool verwenden UND bevor sei ein Bug melden.

[A] means this GLSA was already applied, 
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
Das <c>glsa-check</c> ist momentan noch experimentell, daher sollten Sie, 
wenn Sicherheit wirklich Ihr wichtigstes Anliegen ist, dies noch mit einer 
anderen zusätzlichen Quelle überprüfen.
</warn>

<p>
Alle Zeilen mit einem  <c>[A]</c> und einem <c>[U]</c> können mit ziemlicher 
Sicherheit ignoriert werden, da das System von diesem GLSA nicht 
beeinträchtigt wird.
</p>

<p>
Einige Menschen bevorzugen noch <c>emerge paketname</c> anstatt von 
<c>glsa-check -f</c> daher sind alle GLSA als  <c>[N]</c> aufgelistet.
</p>

<p>
Wenn Sie eine Email erhalten möchten jedesmal wenn ein GLSA herausgegeben wird, 
dann melden Sie sich für die <c>gentoo-announce</c> Mailingliste an. 
Instruktionen zum Anmelden und eine grössere Menge andere Mailinglisten finden 
Sie unter der <uri link="/mail/en/list.xml">Gentoo Linux 
Mailinglistenübersicht</uri>.
</p>

</body>
</section>
</chapter>

</guide>
