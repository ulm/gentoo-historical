<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/home-router-howto.xml,v 1.3 2005/04/04 19:03:21 dertobi123 Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- English CVS Version: 1.21 -->

<guide link="/doc/de/home-router-howto.xml">
<title>Home Router Guide</title>

<author title="Autor">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Übersetzer">
  <mail link="rk@oppono.de">Robert Körner</mail>
</author>

<abstract>
Dieses Dokument erklärt, wie man eine alte Gentoo-Maschine in einen Router 
verwandelt, um das eigene Heimnetzwerk mit dem Internet zu verbinden.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.2</version>
<date>22. September 2004</date>

<chapter>
<title>Einleitung</title>
<section>
<body>

<p>
Einen eigenen Router aus alten, ungenutzten Teilen zu bauen hat viele Vorteile
gegenüber dem Kauf einer vorgefertigten Lösung von z.B. Linksys. Der weitaus
größte ist die Kontrolle über die Verbindung. Alle anderen bleiben für die
eigene Vorstellungskraft; beinahe alles kann in diesem Scenario getan werden,
es ist nur eine Sache der Notwendigkeit.
</p>

<p>
Diese Anleitung erklärt, wie man auf dem Router NAT (Network Address Translation)
installiert (Kernel und iptables), wie gebräuchliche Dienste hinzugefügt und
konfiguriert werden (Domain Name System (DNS) mit dnsmasq, dhcp mit dhcpcd, 
ADSL durch rp-pppoe) und schließt mit komplizierteren und teilweise lustigeren 
Dingen, die getan werden können (Portweiterleitung, <e>traffic shaping</e>, 
Proxys, usw.).
</p>

<p>
Vor dem Start warten ein paar Anforderungen, die mindestens erfüllt sein müssen.
Zuerst wird ein Computer gebraucht, der min. 2 Netzwerkkarten beinhaltet. Als
nächstes werden die Einwahl- und Konfigurationsdaten für die jeweilige
Internetverbindung benötigt (können Dinge wie IP/DNS/Gateway/Benutzername/Passwort sein).
Abschließend sind ein bisschen Zeit und eine Idee von Gentoo-Nutzung notwendig.
</p>

<p>
Die in dieser Anleitung gebrauchten Standards sind:
</p>
<ul>
  <li>eth0 - NIC (Network Interface Card) verbunden mit dem lokalen Netzwerk (LAN)</li>
  <li>eth1 - NIC verbunden mit dem Internet (WAN)</li>
  <li>Das LAN benutzt das private 192.168.0.xxx Netzwerk</li>
  <li>Der Router ist auf die Standard-IP 192.168.0.1 konfiguriert</li>
  <li>Der Router läuft unter Linux 2.4 oder 2.6; 2.0/2.2 werden nicht eingehender behandelt</li>
</ul>

<impo>
Zur Sicherheit empfehle ich, alle ungenutzten Dienste zu stoppen, bevor die
Firewall konfiguriert ist und läuft. Um die aktuell laufenden Dienste
anzuzeigen, tippe <c>rc-status</c> in ein Konsolenfenster.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Kernel-Konfiguration (kenne dich selbst zuerst)</title>
<section>
<body>

<p>
Der Kernel muss die Treiber für beide NICs kennen und verwenden. Um
festzustellen, ob die Karten bereits fertig Konfiguriert sind, starten Sie 
<c>ifonfig</c>. Ihre Ausgabe mag leicht vom Folgenden abweichen, das ist in
Ordnung. Wichtig ist, dass die Karten alle angezeigt werden.
</p>
<pre caption="Testen der NICs">
# <i>ifconfig -a</i>
eth0      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B8
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x9800 

eth1      Link encap:Ethernet  HWaddr 00:60:F5:07:07:B9
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:10 Base address:0x9400 
</pre>
<p>
Wenn Sie Ihre beiden Karten nicht angezeigt bekommen und Sie nicht sicher 
sind, welche Sie haben, versuchen Sie <c>lspci</c>. Dieses Tool bekommen Sie 
durch <c>emerge pciutils</c>. Suchen Sie nach <e>Ethernet controller</e> in der 
Ausgabe. Wenn Sie die Informationen beisammen haben, überarbeiten Sie noch 
einmal Ihre Kernel-Konfiguration und fügen Sie die Unterstützung für die 
richtigen Treiber hinzu.
</p>

<p>
Als nächstes müssen iptables und NAT (und, wenn gewünscht, traffic shaping) 
unterstützt werden. Die nachfolgende Liste ist geteilt in benötigte (*), 
vorgeschlagene (x) und zum shaping (s) benötigte Fähigkeiten. Es macht keinen
Unterschied, ob die Unterstützungen in den Kernel implementiert oder als Modul
kompiliert werden, solange zur rechten Zeit die notwendigen Module geladen 
werden (Laden von Modulen ist dem Leser jedoch als Spaß-Übung überlassen und
wird nicht weiter behandelt).
</p>
<pre caption="Netzwerkoptionen">
<i>Networking options  ---&gt;</i>
<i>   [*] TCP/IP networking</i>
<i>      [*] IP: advanced router</i>
<i>   [*] Network packet filtering (replaces ipchains)</i>
<comment>Wenn Sie 2.4.x benutzen, müssen Sie folgendes für DHCP aktivieren:
</comment>
<i>   [*] Socket Filtering</i>

<i>   IP: Netfilter Configuration  ---&gt;</i>
<i>      [*] Connection tracking (required for masq/NAT)</i>
<i>         [x] FTP protocol support</i>
<i>         [x] IRC protocol support</i>
<i>      [*] IP tables support (required for filtering/masq/NAT)</i>
<i>         [*] IP range match support</i>
<i>         [x] MAC address match support</i>
<i>         [*] Multiple port match support</i>
<i>         [*] Packet filtering</i>
<i>            [*] REJECT target support</i>
<i>            [x] REDIRECT target support</i>
<i>         [*] Full NAT</i>
<i>            [*] MASQUERADE target support</i>
<i>         [s] Packet mangling</i>
<i>            [s] MARK target support</i>
<i>         [x] LOG target support</i>

<i>   QoS and/or fair queueing  ---&gt;</i>
<i>      [s] QoS and/or fair queueing</i>
<i>         [s] HTB packet scheduler</i>
<i>         [s] Ingress Qdisc</i>
</pre>
<note>
Manches in einem 2.6er Kernel mag sich leicht von einem 2.4er unterscheiden,
allerdings sollte es Ihnen möglich sein, Unterschiede herauszufinden. :)
</note>

</body>
</section>
</chapter>

<chapter>
<title>Das WAN (a.k.a. Internet)</title>

<section>
<title>Intro</title>
<body>

<p>
Es gibt viele Wege, um sich ins Internet zu verbinden. Daher decke ich hier 
lediglich die ab, mit denen ich mich auskenne. Damit bleiben ADSL (PPPoE) und 
Kabelmodems (statisch/dynamisch). Wenn es andere Methoden gibt, fühlen Sie sich 
ermuntert, eine kleine Anleitung zu schreiben und sie mir via E-Mail zukommen
zu lassen (für deutsche E-Mails bitte an rk@oppono.de). Nicht auf Ihre Umgebung 
zutreffende Sektionen in diesem Kapitel können Sie selbstverständlich 
überspringen. Dieses Kapitel behandelt lediglich die Verbindung des Routers mit 
dem Internet durch eth1.
</p>
</body>
</section>

<section>
<title>ADSL und PPPoE</title>
<body>

<p>
Die ganze einfallsreiche PPPoE Software wurde in einem Paket zusammengefasst,
das sich <uri link="http://www.roaringpenguin.com/">Roaring Penguin</uri>
nennt. Ein simples <c>emerge rp-pppoe</c> und alles, was benötigt wird, ist 
installiert. Erinnern Sie sich, wie ich sagte, dass Sie einen Benutzernamen und
ein Passwort brauchen? Nun, ich habe nicht gelogen; also hoffe ich, dass Sie
beides jetzt vorliegen haben! Öffnen Sie <path>/etc/ppp/pppoe.conf</path> in 
Ihrem bevorzugten Editor und konfigurieren Sie es.
</p>

<note>
Damit die folgenden net.eth1-Einstellungen funktionieren, müssen Sie 
baselayout-1.10.1 oder neuer installiert haben.
</note>

<pre caption="Konfiguration von eth1">
<comment>(Ersetzen Sie 'vla9h924' mit Ihrem Benutzernamen und 'password' mit Ihrem Passwort)</comment>

# <i>nano /etc/ppp/pppoe.conf</i>
<comment># NIC, die mit Ihrem ADSL-Modem verbunden ist
ETH=eth1
# ADSL Benutzername
USER=vla9h924</comment>
# <i>nano /etc/ppp/pap-secrets</i>
<comment># client server secret
"vla9h924" * "password"</comment>
# <i>nano /etc/conf.d/net</i>
<comment>Fügen Sie einen Eintrag für ifconfig_eth1 hinzu und stellen Sie ihn auf
adsl
:
ifconfig_eth1=( "adsl" )</comment>
# <i>ln -s net.eth0 /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<warn>
Wenn das DSL-Interface läuft, erstellt es ppp0. Obwohl Ihre NIC eth1 genannt
wird, ist die IP tatsächlich an ppp0 gebunden. Von jetzt an, wenn Sie ein 
Beispiel sehen, das 'eth1' nutzt, ersetzen Sie es mit 'ppp0'.
</warn>

</body>
</section>

<section>
<title>Kabel und/oder dynamische/statische IP</title>
<body>

<p>
Wenn Sie eine statische IP nutzen, brauchen Sie ein paar mehr Details als bei 
einer dynamischen. Für Nutzer von statischen IPs werden sowohl IP als auch 
Gateway und die DNS-Server benötigt.
</p>

<pre caption="Konfiguration von eth1">
<comment>Benutzer dynamischer IPs:</comment>
# <i>emerge dhcpcd</i>
# <i>nano /etc/conf.d/net</i>
<comment>Sie brauchen einen Eintrag wie den folgenden:
ifconfig_eth1=( "dhcp" )</comment>

<comment>Benutzer statischer IPs:</comment>
# <i>nano /etc/conf.d/net</i>
<comment>Sie brauchen Einträge wie die folgenden:
ifconfig_eth1=( "66.92.78.102 broadcast 66.92.78.255 netmask 255.255.255.0" )
routes_eth1=( "default gw 66.92.78.1" )</comment>
# <i>nano /etc/resolv.conf</i>
<comment>Einen DNS-Server pro Zeile:
nameserver 123.123.123.123</comment>

<comment>Für sowohl statische als auch dynamische Setups:</comment>
# <i>ln -s net.eth0 /etc/init.d/net.eth1</i>
# <i>rc-update add net.eth1 default</i>
# <i>/etc/init.d/net.eth1 start</i>
</pre>

<p>
Jetzt sollte alles bereit sein damit Sie sich ins Internet verbinden können.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Das LAN (bringen Sie ein paar Freunde mit)</title>
<section>
<body>

<p>
Dieser Schritt ist ein Kinderspiel, im Vergleich zum vorherigen.
</p>

<pre caption="Konfiguration von eth0">
# <i>nano /etc/conf.d/net</i>
<comment>Fügen Sie eine Zeile wie die folgende hinzu:
ifconfig_eth0=( "192.168.0.1 broadcast 192.168.0.255 netmask 255.255.255.0"</comment>
# <i>rc-update add net.eth0 default</i>
# <i>/etc/init.d/net.eth0 start</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>LAN Dienste (denn wir sind freundliche Menschen)</title>

<section>
<title>DHCP-Server</title>
<body>

<p>
Ich wette es wäre schön, wenn alle anderen in Ihrem Haus lediglich ihre
Computer ins Netzwerk stecken müssten und alles einfach liefe. Nicht nötig,
sie sich komplizierte Details merken zu lassen oder sie vor verwirrende 
Konfigurationsbildschirme zu setzen! Das Leben wäre großartig, hm? Das
<e>Dynamic Host Configuration Protocol</e> (DHCP) und warum Sie es wichtig
finden sollten.
</p>

<p>
DHCP ist genau das, was sein Name impliziert. Es ist ein Protokoll, mit dem
man andere Computer dynamisch und automatisch konfigurieren kann. Sie starten
einen DHCP-Server auf dem Router (dhcpcd), geben ihm alle notwendigen
Informationen über Ihr Netzwerk (erlaubte IPs, DNS-Server, Gateways, usw...)
und wenn andere Computer hochfahren, starten sie einen DHCP-Client, der diese
automatisch Konfiguriert. Kein Brimborium, kein Durcheinander! Um mehr über
DHCP zu erfahren, können Sie immer bei 
<uri link="http://de.wikipedia.org/wiki/DHCP">Wikipedia</uri> vorbeischauen.
</p>

<pre caption="Konfiguration des dhcpd">
# <i>emerge dhcp</i>
# <i>nano /etc/dhcp/dhcpd.conf</i>
<comment>Hier eine Beispielkonfiguration:
authoritative;
ddns-update-style ad-hoc;
subnet 192.168.0.0 netmask 255.255.255.0 {
range 192.168.0.100 192.168.0.250;
default-lease-time 259200;
max-lease-time 518400;
option subnet-mask 255.255.255.0;
option broadcast-address 192.168.0.255;
option routers 192.168.0.1;
option domain-name-servers 192.168.0.1;
}
</comment>
# <i>nano /etc/conf.d/dhcp</i>
<comment>Set IFACE="eth0"</comment>
# <i>rc-update add dhcp default</i>
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Jetzt ist Ihr kleiner Router ein echter DHCP-Server! Fügen Sie die Computer 
Ihrem Netzwerk hinzu und sehen Sie, wie sie arbeiten! Bei Windows-Systemen 
sollten Sie in die Netzwerkeinstellungen für TCP/IP gehen und dort die 
Optionen "IP-Adresse automatisch beziehen" und "DNS-Server-Adresse automatisch 
beziehen" aktivieren. Manchmal werden die Änderungen nicht sofort übernommen. 
Um die Wartezeit zu umgehen, können Sie eine CMD-Box öffnen und <c>ipconfig
/release</c> und <c>ipconfig /renew</c> eingeben. Doch genug von Windows, lassen
uns zurück zu unserem Lieblingspinguin kommen.
</p>
</body>
</section>

<section>
<title>DNS-Server</title>
<body>

<p>
Wenn Leute einen Ort im Internet besuchen wollen, merken sie sich Namen, keine
langen Ketten nutzloser Nummern. Denn was ist einfacher zu merken: ebay.com
oder 66.135.192.87? Hier wird das DNS aktiv. DNS-Server laufen überall im
Internet und wann immer jemand 'ebay.com' besuchen möchte, übersetzen diese
Server 'ebay.com' (was wir verstehen) in '66.135.192.87' (was Computer 
verstehen). Für mehr Informationen über das DNS können Sie jederzeit
<uri link="http://de.wikipedia.org/wiki/DNS">Wikipedia</uri> besuchen.
</p>

<p>
Möglicherweise ist Ihnen zuvor aufgefallen, dass wir den DHCP-Clients gesagt
haben, dass ein DNS-Server unter 192.168.0.1 läuft. Möglicherweise erinnern
Sie sich auch daran, dass 192.168.0.1 unser kleiner Router ist. Jedoch kann
ich mich nicht daran erinnern, einen DNS-Server aufgesetzt zu haben... Also
machen wir das jetzt!
</p>

<pre caption="Konfiguration von dnsmasq">
# <i>emerge dnsmasq</i>
# <i>nano /etc/conf.d/dnsmasq</i>
<comment>Füge "-i eth0" zu DNSMASQ_OPTS hinzu</comment>
# <i>rc-update add dnsmasq default</i>
# <i>/etc/init.d/dnsmasq start</i>
</pre>

<p>
Nun, das ging schnell. Aber was haben wir gemacht? Das Großartige ist, wir
haben nicht viel zu tun! Selbstverständlich können Sie einen anderen DNS-Server
wählen, mit dem Sie besser vertraut sind; dnsmasq ist jedoch sehr gut, da es
genau für das kreiert wurde, was wir wollen und nicht mehr. Es ist ein kleiner
DNS Auffangs-/Weiterleitungsserver für lokale Netzwerke. Wir wollen hier kein
DNS für unsere eigene Domäne offerieren, sondern nur ein einfaches DNS
für alle anderen im LAN.
</p>

</body>
</section>

<section>
<title>NAT (a.k.a. IP-Maskerade)</title>
<body>

<p>
An diesem Punkt angelangt können Leute in Ihrem Netzwerk miteinander sprechen
und über den DNS-Server auch Hostnamen überprüfen. Dennoch ist noch immer keine
Verbindung ins Internet möglich. Wärend Sie möglicherweise glauben, dass das 
großartig ist (mehr Bandbreite für Sie!), wette ich, dass alle anderen nicht
allzu froh darüber sind.
</p>

<p>
Hier tritt NAT auf. NAT ist ein Weg um mehrere Computer in einem privaten LAN
mit dem Internet zu verbinden, wenn nur eine kleinere Nummer an IP-Adressen
zur Verfügung steht. Normalerweise bekommen Sie von deinem ISP (Internet Service
Provider) genau eine IP zugewiesen, dennoch möchten Sie das ganz Haus mit 
Internet versorgen. NAT ist die Zauberei, die dies möglich macht. Für mehr 
Informationen über NAT können Sie immer bei 
<uri link="http://de.wikipedia.org/wiki/NAT">Wikipedia</uri> vorbeischauen.
</p>

<note>
Bevor wir starten überprüfen Sie bitte, ob Sie iptables auf Ihrem System 
installiert haben. Obgleich es normalerweise automatisch auf den meisten 
Systemen installiert wird, könnten Sie es nicht dabei haben. Wenn dem der Fall 
ist, starten Sie einfach <c>emerge iptables</c>.
</note>

<pre caption="Konfiguration von iptables">
<comment>Zuerst leeren wir unsere aktuellen Regeln</comment>
# <i>iptables -F</i>
# <i>iptables -t nat -F</i>

<comment>Dann beschränken wir unsere Dienste, sodass sie nur im LAN arbeiten</comment>
# <i>iptables -I INPUT 1 -i eth0 -j ACCEPT</i>
# <i>iptables -I INPUT 1 -i lo -j ACCEPT</i>
# <i>iptables -A INPUT -p UDP --dport bootps -i ! eth0 -j REJECT</i>
# <i>iptables -A INPUT -p UDP --dport domain -i ! eth0 -j REJECT</i>

<comment>(Optional) Erlauben Sie Zugriff auf unseren SSH-Server aus dem WAN</comment>
# <i>iptables -A INPUT -p TCP --dport ssh -i eth1 -j ACCEPT</i>

<comment>Lassen Sie TCP/UDP-Pakete für bestimmte Ports fallen</comment>
# <i>iptables -A INPUT -p TCP -i ! eth0 -d 0/0 --dport 0:1023 -j DROP</i>
# <i>iptables -A INPUT -p UDP -i ! eth0 -d 0/0 --dport 0:1023 -j DROP</i>

<comment>Schließlich fügen wir NAT-Regeln hinzu</comment>
# <i>iptables -I FORWARD -i eth0 -d 192.168.0.0/255.255.0.0 -j DROP</i>
# <i>iptables -A FORWARD -i eth0 -s 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -A FORWARD -i eth1 -d 192.168.0.0/255.255.0.0 -j ACCEPT</i>
# <i>iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE</i>
<comment>Sagen Sie dem Kernel, dass IP-Forwarding in Ordnung ist</comment>
# <i>echo 1 > /proc/sys/net/ipv4/ip_forward</i>
# <i>for f in /proc/sys/net/ipv4/conf/*/rp_filter ; do echo 1 > $f ; done</i>

<comment>So müssen wir nach dem Booten die Regeln nicht per Hand starten</comment>
# <i>/etc/init.d/iptables save</i>
# <i>rc-update add iptables default</i>
# <i>nano /etc/sysctl.conf</i>
<comment>Fügen Sie hinzu oder unkommentieren Sie folgende Zeilen:
net.ipv4.ip_forward = 1
net.ipv4.conf.default.rp_filter = 1</comment>
</pre>

<p>
Nachdem Sie das alles eingetragen und gestartet haben, sollte der Rest Ihres
Netzwerks in der Lage sein, das Internet zu benutzen, als wenn sie alle selbst
direkt damit verbunden wären.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Spielereien (für einen regnerischen Tag)</title>

<section>
<title>Intro</title>
<body>

<p>
Glauben Sie es oder oder nicht: Sie sind fertig :). Von hier aus bespreche ich
ein paar gebräuchliche Dinge, die Sie interessieren könnten. Alles in diesem
Kapitel ist absolut optional.
</p>
</body>
</section>

<section>
<title>Port Weiterleitung (port forwarding)</title>
<body>

<p>
Manchmal möchten Sie evtl. die Möglichkeit haben, Dienste auf einem Computer
hinter Ihrem Router laufen zu haben oder einfach Ihr Leben im Bereich der
Remoteverwaltung erleichtern. Vielleicht möchten Sie einen FTP, HTTP, SSH oder
VNC-Server auf einer oder mehrerer Maschinen hinter dem Router starten und die
Option haben, sich zu allen zu verbinden. Die einzige Einschränkung ist, dass
Sie lediglich eine Dienst/Maschinen-Kombination pro Port haben. Zum Beispiel 
gibt es keine Möglichkeit, drei FTP-Server hinter Ihrem Router zu starten und 
zu allen via Port 21 zu verbinden; nur einer kann auf Port 21 laufen, wärend 
die anderen auf z.B. Port 123 und Port 567 laufen müssten.
</p>

<p>
Alle Portweiterleitungsregeln sind in der Form <c>iptables -t nat -A PREROUTING
[-p protocol] --dport [externer Port auf dem Router] -i eth1 -j DNAT --to [IP/Port
auf den weitergeleitet wird]</c>. iptables akzeptiert keine Hostnamen bei der 
Portweiterleitung. Wenn Sie den selben externen Port auf einen internen Port
weiterleiten, können Sie den Zielport weglassen. Lesen Sie sich iptables(8) 
durch für mehr Informationen.
</p>

<pre>
<comment>Leiten Sie Port 2 zu einem internen SSH-Host weiter</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 2 -i eth1 -j DNAT --to 192.168.0.2:22</i>

<comment>FTP-Weiterleitung zu einem internen Host</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 21 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>HTTP-Weiterleitung zu einem internen Host</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>VNC-Weiterleitung zu einem internen Host</comment>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5900 -i eth1 -j DNAT --to 192.168.0.2</i>
# <i>iptables -t nat -I PREROUTING -p tcp --dport 5901 -i eth1 -j DNAT --to 192.168.0.3:5900</i>
<comment>Wenn Sie auf den VNC-Server auf 192.168.0.3 verbinden möchten, fügen
Sie ein simples ':1' hinter den Hostnamen des Routers hinzu.</comment>

<comment>Bittorrent-Weiterleitung</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 6881:6889 -i eth1 -j DNAT --to 192.168.0.2</i>

<comment>Game Cube Warp Pipe Unterstützung</comment>
 <i>iptables -t nat -A PREROUTING -p udp --dport 4000 -i eth1 -j DNAT --to 192.168.0.56</i>

<comment>Playstation2 Onlineunterstützung</comment>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 10070:10080 -i eth1 -j DNAT --to 192.168.0.11</i>
# <i>iptables -t nat -A PREROUTING -p udp --dport 10070:10080 -i eth1 -j DNAT --to 192.168.0.11</i>
</pre>

<note>
Wenn Sie andere gebräuchliche / coole Beispiele haben, schreiben Sie mir eine 
<uri link="mailto:vapier@gentoo.org">E-Mail</uri> (auf Englisch, für deutsche
E-Mails bitte an <uri link="mailto:rk@oppono.de">rk</uri>).
</note>
</body>
</section>

<section>
<title>Identd (für's IRC)</title>
<body>

<p>
<e>Internet Relay Chat</e> benutzt den ident-Dienst ziemlich stark. Jetzt, da
die IRC-Clients hinter dem Router sind, brauchen wir einen Weg, um ident sowohl
auf den Clients als auch auf dem Router unterzubringen. Ein solcher Server ist
z.B. <c>midentd</c>.
</p>

<pre caption="Konfiguration von ident">
# <i>emerge midentd</i>
# <i>rc-update add midentd default</i>
# <i>/etc/init.d/midentd start</i>
</pre>

<p>
Es gibt noch ein paar weitere ident-Server in Portage. Abhängig von Ihrem 
Bedarf empfehle ich, <c>oidentd</c> und <c>fakeidentd</c> zu testen.
</p>
</body>
</section>

<!--
<section>
<title>Traffic Shaping</title>
<body>

<p>
Dies ist der Versuch, das <uri link="http://www.tldp.org/HOWTO/ADSL-Bandwidth-Management-HOWTO/">ADSL Bandwidth Management HOWTO</uri>
zu vereinfachen. Du kannst selbstverständlich wann immer du möchtest das
originale Dokument zu Rate ziehen.
</p>

<p>
Hier konfigurieren wir jetzt, was manche Menschen als "Packet Shaper", 
<uri link="http://de.wikipedia.org/wiki/Traffic_shaping">Traffic Shaping"</uri>
oder <uri link="http://de.wikipedia.org/wiki/QoS">"Quality of Service"</uri>
bezeichnen. Simpel gesehen wollen wir Regeln auf unserem Router einrichten,
die bestimmte Aktivitäten verlangsamen (z.B. das Senden von großen E-Mails oder
der Download aus P2P-Netzwerken), wärend andere Aktivitäten (z.B. Surfen im Web
oder Spielen von Online-Games) relativ schnell gehalten werden. Eine
30-Sekunden-Differenz in einem Videospiel ist sehr viel schlimmer als eine beim
Herunterladen großer Dateien :).
</p>

<p>
Zuerst muss man nachschauen, ob der Kernel alle Vorraussetzungen erfüllt. Siehe
<uri link="#doc_chap2">Kernel-Konfiguration</uri> für mehr Informationen. Als
nächstes musst du <c>emerge iptables iputils</c> durchführen, damit du Zugriff
auf <c>iptables</c>-, <c>ip</c>- und <c>tc</c>-Befehle hast.
</p>

<p>
Bevor wir mit den Befehlen anfangen, sollten wir ein bisschen Theorie abdecken.
Dieses ganze System arbeitet dadurch, dass gebräuchliche Netzwerkstreams
klassifiziert werden und dann mit einer Priorität versehen werden. Du nutzt 
iptables zum Klassifizieren von Netzwerkstreams, iputils um die
unterschiedlichen Prioritäten zu definieren und den Kernel um die
Geschwindigkeiten anzupassen. Erinnere dich, dass du den <e>outbound traffic</e>
relativ streng kontrollieren kannst (vom LAN zum WAN) - diese Möglichkeit 
transferiert auf den <e>inbound traffic</e> (vom WAN zum LAN) jedoch relativ
begrenzt ist. Bitte denk' daran, dass die folgenden Beispiele lediglich als
kleine Heranführung an die Bereiche gedacht sind. Solltest du mehr erfahren 
wollen, solltest du mehr über die speziellen Themengebiete lesen. In diesem
Beispiel werden wir den <uri link="http://luxik.cdi.cz/~devik/qos/htb/">Hierarchical Token Buckets (HTB)</uri> 
Paketplanungs-Algorithmus verwenden. Noch immer dabei? Klasse, dann lass uns 
mit dem <e>shaping</e> beginnen :).
</p>

<pre caption="Konfiguration">
DEV=eth1 <comment>NIC verbunden mit dem WAN</comment>
RATE_OUT=100 <comment>Verfügbare Bandbreite ins WAN (in Kilobit [kb])</comment>
RATE_IN=1400 <comment>Verfügbare Bandbreite aus dem WAN ins LAN (in kb)</comment>

<comment>Hier initialisieren wir das Prioritätssystem. Die 45 wird benutzt, um den Standard-Klassifizierungslevel festzulegen.</comment>
ip link set dev ${DEV} qlen 30
tc qdisc add dev ${DEV} root handle 1: htb default 45
tc class add dev ${DEV} parent 1: classid 1:1 htb rate ${RATE_OUT}kbit
</pre>

<p>
Hier initialisieren wir das Systen, dass benutzt werden wird um den gesammten
Netzwerk-Traffic zu priorisieren. Wir kreierten unseren Ablauf (queue), sagten
ihm, den HTB Algorithmus zu benutzen und setzten den Standard-Klassifizierungslevel
auf '45'. Der Standard ist vollkommen frei wählbar, genau wie alle anderen Level
von hier aus. Das Einzige, was wichtig ist, ist wie sich diese Level relativ 
zueinander verhalten; ein Level '10' Paket bekommt den Vorzug vor einem Level 
'45' Paket. Lass uns weitermachen mit dem Erstellen unterschiedlicher Level.
</p>

<pre caption="Erstellen von Levels">
tc class add dev $DEV parent 1:1 classid 1:10 htb rate $rkbit ceil $tkbit prio $p
tc qdisc add dev $DEV parent 1:10 handle 10: sfq
</pre>
</body>
</section>
-->

<section>
<title>Zeitserver</title>
<body>

<p>
Für ein gesundes, funktionierendes System ist es unausweichlich, die Zeit immer
korrekt zu halten. Einer der gebräuchlichsten Wege, dies zu verwirklichen, ist
die Benutzung des <e>Network Time Protocol</e> (NTP) und dem ntp-Paket (das 
sowohl Implementierungen für Server und Client enthält).
</p>

<p>
Viele Menschen haben ntp-Clients auf ihren Computern laufen. Offensichtlich 
müssen die NTP-Server in der Welt mehr Last verarbeiten, je mehr Menschen solche
Clients starten. In Umgebungen wie unserem Heimnetzwerk können wir jedoch
die Last der öffentlichen Server etwas mindern und dennoch allen Geräten in 
unserem Netzwerk die richtige Zeit offerieren. Als Bonus sind unsere privaten
Updates für alle Clients sehr viel schneller! Alles, was wir zu tun haben, ist,
einen NTP-Server auf unserem Router zu starten, der sich selbst mit den 
öffentlichen Servern synchronisiert und gleichzeitig diese Zeit dem Rest der
Rechner im Netzwerk zur Verfügung stellt. Für den Start reicht ein einfaches
<c>emerge ntp</c> auf dem Router.
</p>

<pre caption="Konfiguration des NTP-Servers">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Editieren Sie hier, wenn Sie möchten. Die Standards sollten aber in 
Ordnung sein.</comment>
# <i>rc-update add ntp-client default</i>

# <i>nano /etc/ntp.conf</i>
<comment>Fügen Sie folgende Zeilen hinzu:
restrict default ignore
restrict 192.168.0.0 mask 255.255.255.0 notrust nomodify notrap
Dies erlaubt nur Clients mit einer IP-Adresse aus dem 192.168.0.xxx-Netz die 
Nutzung Ihres NTP-Servers.</comment>
# <i>nano /etc/conf.d/ntpd</i>
<comment>Editieren Sie hier, wenn Sie möchten. Die Standards sollten aber in 
Ordnung sein.</comment>
# <i>rc-update add ntpd default</i>

# <i>/etc/init.d/ntp-client start</i>
# <i>/etc/init.d/ntpd start</i>
</pre>

<p>
Jetzt führen Sie auf Ihren Clients ebenfalls ein <c>emerge ntp</c> durch. Jedoch
werden wir hier lediglich den NTP-Client starten, was die Konfiguration um 
einiges erleichtert.
</p>

<pre caption="Konfiguration eines NTP-Clients">
# <i>nano /etc/conf.d/ntp-client</i>
<comment>Änderen Sie den 'pool.ntp.org'-Server in der NTPCLIENT_OPTS Variable 
in '192.168.0.1'</comment>
# <i>rc-update add ntp-client default</i>
# <i>/etc/init.d/ntp-client start</i>
</pre>
</body>
</section>

<section>
<title>Mail Server</title>
<body>

<p>
Manchmal ist es schön, den eigenen <e>Simple Mail Transfer Protocol</e> (SMTP)
Server auf dem Router laufen zu haben. Sie mögen Ihren eigenen Grund dafür 
haben, aber ich benutze ihn damit die Benutzer den Versand ihrer E-Mails sehen
als wenn sie sofort verschickt werden und die Arbeit des Wiederholens/Routens
dem Mail-Server überlassen ist. Manche ISPs erlauben die Weitergabe für Accounts
die nicht Teil ihres Netzwerks sind, überhaupt nicht (z.B. Verizon). Zudem
können Sie so den Versand von Mails einfach drosseln, sodass große Anhänge
Ihrer Verbindung keinen großen Lag von einer halben Stunde aufzwingen.
</p>

<pre caption="Konfiguration vom SMTP">
# <i>emerge qmail</i>
<comment>Versicheren Sie sich, dass die Ausgabe von 'hostname' richtig ist
</comment>
# <i>ebuild /var/db/pkg/*-*/qmail-1.03-r*/*.ebuild config</i>
# <i>iptables -I INPUT -p tcp --dport smtp -i ! eth0 -j REJECT</i>
# <i>ln -s /var/qmail/supervise/qmail-send /service/qmail-send</i>
# <i>ln -s /var/qmail/supervise/qmail-smtpd /service/qmail-smtpd</i>
<!--
# <i>cd /etc/tcprules.d</i>
# <i>nano tcp.qmail-smtp</i>
-->
# <i>cd /etc</i>
# <i>nano tcp.smtp</i>
<comment>Fügen Sie eine Zeile ähnlich der folgenden zum "allow"-Abschnitt hinzu:
192.168.0.:allow,RELAYCLIENT=""</comment>
<!--
# <i>tcprules tcp.qmail-qmtp.cdb rules.tmp &lt; tcp.qmail-smtp</i>
-->

# <i>tcprules tcp.smtp.cdb rules.tmp &lt; tcp.smtp</i>
# <i>rc-update add svscan default</i>
# <i>/etc/init.d/svscan start</i>
</pre>

<p>
Ich bin ein großer Fan von QMail, aber selbstverständlich können Sie auch
ein anderes Programm nutzen :). Wenn Sie E-Mail auf den Hosts in Ihrem Netzwerk
konfigurierst, sagen Sie ihnen, dass der SMTP-Server 192.168.0.1 ist und alles 
sollte gut laufen. Möglicherweise möchten Sie <uri link="http://qmail.org/">QMail</uri> besuchen, um weitere Dokumentationen zu bekommen.
</p>
</body>
</section>

<!--
<section>
<title>E-Mail Virenscan</title>
<body>

<p>
Wenn du deinen Usern E-Mail Virenscan zur Verfügung stellen willst, jedoch
nicht auf jeder einzelnen Maschine einen Virenscanner installieren willst, 
könnte <c>pop3vscan</c> genau das richtige für dich sein; ein transparenter
<e>Post Office Protocol</e> (POP) Scanner.
</p>

<pre caption="Konfiguration von pop3vscan">
TODO
</pre>

</body>
</section>
-->

</chapter>

<chapter>
<title>Ausklang</title>
<section>
<body>

<p>
Ich habe keine abschließenden Bemerkungen. Wenn Sie jedoch irgendwelche 
Probleme mit diesem Guide haben, können Sie mich per 
<mail link="vapier@gentoo.org">E-Mail</mail> erreichen (bitte auf Englisch, für
deutsche Mails <mail link="rk@oppono.de">hier</mail>
klicken). Eine andere Möglichkeit ist, dass Sie einen Bug melden auf 
<uri link="http://bugs.gentoo.org/">Gentoo's Bugtracking Website</uri>. Wenn Sie
ein paar interessante Dinge haben, von denen Sie annehmen, dass sie diesen Guide
verbessern würden, schicken Sie sie mir bitte zur Einbindung (auch hier bitte: 
Auf Englisch).
</p>

</body>
</section>
</chapter>
</guide>
