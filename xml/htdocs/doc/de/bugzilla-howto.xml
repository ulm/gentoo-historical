<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/bugzilla-howto.xml,v 1.4 2012/04/18 18:30:16 swift Exp $ -->

<guide lang="de">
<title>Gentoo Bug Reporting Leitfaden</title>

<author title="Autor">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Bearbeiter">
  <mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>
<author title="Übersetzer">
  <mail link="micm@micm.eu">Michael Münch</mail>
</author>
<author title="Übersetzer">
  <mail link="keytoaster@gentoo.org">Tobias Heinlein</mail>
</author>

<abstract>
Dieses Dokument zeigt Ihnen, wie Sie Bugs mit Hilfe von Bugzilla richtig melden.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.15</version>
<date>2010-02-27</date>

<chapter>
<title>Einführung</title>
<section>
<title>Vorwort</title>
<body>

<p>
Einer der Faktoren, der die Lösung eines Bugs herauszögert, ist die Art und
Weise wie er berichtet wird. Durch das Erstellen dieses Leitfadens hoffen wir,
die Kommunikation zwischen den Entwicklern und den Benutzern in punkto
Fehlerbereinigung zu verbessern. Fehler zu beseitigen ist ein wichtiger, wenn
nicht gar entscheidender Teil der Qualitätssicherung eines jeden Projektes und
wir hoffen, dass dieser Leitfaden dazu beitragen wird, dies zu einem Erfolg zu
machen.
</p>

</body>
</section>
<section>
<title>Bugs!!!!</title>
<body>

<p>
Sie emergen ein Paket oder arbeiten mit einem Programm und plötzlich passiert
das Schlimmste -- Sie finden einen Bug. Fehler kommen in vielen Formen vor, zum
Beispiel als Fehler beim emergen oder als Speicherzugriffsfehler. Was auch immer
die Ursache ist, Tatsache ist, dass so ein Fehler gelöst werden muss. Hier sind
ein paar Beispiele für solche Fehler.
</p>

<pre caption="Ein Laufzeitfehler">
$ <i>./bad_code `perl -e 'print "A"x100'`</i>
Segmentation fault
</pre>

<pre caption="Ein emerge Fehler">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Diese Fehler können ziemlich lästig sein. Aber wenn Sie einen finden, was
sollten Sie tun? Die folgenden Abschnitte zeigen Ihnen zwei wichtige Werkzeuge
um mit Laufzeitfehlern umzugehen. Danach werden wir einen Blick auf Fehler beim
Kompilieren werfen und wie man mit diesen umgeht. Lassen Sie uns also mit dem
ersten Werkzeug zur Fehlerbehandlung von Laufzeitfehlern anfangen -- <c>gdb</c>.
</p>

</body>
</section>
</chapter>


<chapter>
<title>Fehlersuche mit GDB</title>
<section>
<title>Einführung</title>
<body>

<p>
GDB, oder der (G)NU (D)e(B)ugger, ist ein Programm um Laufzeitfehler zu finden,
die normalerweise Memory Corruption nach sich ziehen. Schauen wir uns als erstes
an, was Debuggen beinhaltet. Eines der wichtigsten Dinge, die Sie tun müssen, um
ein Programm zu debuggen, ist, es mit <c>FEATURES="nostrip"</c> zu
<c>emergen</c>. Das verhindert, dass die Debug-Symbole entfernt werden. Warum
werden diese bei Programmen normalerweise entfernt? Der Grund ist derselbe, aus
dem man gezippte Manpages verwendet -- um Platz zu sparen. Hier ist ein
Vergleich wie sich die Größe eines Programms mit und ohne entfernte
Debug-Symbole verändert.
</p>

<pre caption="Vergleich der Dateigröße">
<comment>(Debug-Symbole entfernt)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 bad_code
<comment>(Debug-Symbole enthalten)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 bad_code
</pre>

<p>
Nur zur Verdeutlichung, <e>bad_code</e> ist das Programm, dass wir mit dem
<c>gdb</c> gleich debuggen werden. Wie Sie sehen können, ist das Programm ohne
Debug-Symbole 3140 Bytes groß, während mit ihnen das Programm 6374 Bytes groß
ist. Das ist fast das Doppelte! Zwei weitere Sachen können Sie zum Debuggen
machen. Das erste ist, <c>ggdb</c> zu Ihren CFLAGS und CXXFLAGS hinzuzufügen.
Dieses Flag fügt weitere Debug-Symbole hinzu. Wir werden später sehen, was das
bedeutet. Dies ist ein Beispiel wie <path>/etc/make.conf</path> mit den neu
hinzugefügten Flags aussehen <e>könnte</e>.
</p>

<pre caption="make.conf Einstellungen">
CFLAGS="-O1 -pipe -ggdb"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Als letztes können Sie noch debug zu den USE-Flags des Paketes hinzufügen. Dies
können Sie mit Hilfe der Datei <path>package.use</path> wie folgt erledigen.
</p>

<pre caption="Benutzung von package.use um das debug USE-Flag hinzuzufügen">
# <i>echo "category/package debug" >> /etc/portage/package.use</i>
</pre>

<note>
Das Verzeichnis <path>/etc/portage</path> ist standardmäßig nicht vorhanden
und Sie müssen es eventuell erst erstellen, wenn Sie es noch nicht gemacht
haben. Wenn das Paket bereits USE-Flags in <path>package.use</path> gesetzt
hat, müssen Sie die Datei manuell in einem Editor Ihrer Wahl bearbeiten.
</note>

<p>
Danach emergen wir das Paket, mit den bereits vorgenommenen Änderungen, erneut.
</p>

<pre caption="Erneutes emergen eines Paketes mit aktiviertem Debugging">
# <i>FEATURES="nostrip" emerge package</i>
</pre>

<p>
Nun, da die Debug-Symbole eingerichtet sind, können wir mit dem Debuggen des
Programms fortfahren.
</p>

</body>
</section>
<section>
<title>Das Programm mit dem GDB ausführen</title>
<body>

<p>
Nehmen wir an, wir haben ein Programm "bad_code". Jemand behauptet, dass das
Programm abstürzt und gibt ein Beispiel. Sie nehmen sich der Sache an und
probieren es aus:
</p>

<pre caption="Das Programm zum Absturz bringen">
$ <i>./bad_code `perl -e 'print "A"x100'`</i>
Segmentation fault
</pre>

<p>
Es sieht so aus, als hätte derjenige Recht. Da das Programm offensichtlich
defekt ist, haben wir einen Bug vor uns. Jetzt ist es an der Zeit <c>gdb</c> zu
benutzen, um das Problem zu lösen. Als erstes starten wir <c>gdb</c> mit
<c>--args</c> und dem vollständigen Programmaufruf inklusive Argumenten, wie
hier gezeigt:
</p>

<pre caption="Unser Programm durch GDB starten">
$ <i>gdb --args ./bad_code `perl -e 'print "A"x100'`</i>
GNU gdb 6.3
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu"...Using host libthread_db library "/lib/libthread_db.so.1".
</pre>

<note>
Man kann auch mit Speicherauszügen debuggen. Diese enthalten die gleichen
Informationen, die das Programm liefern würde, wenn es durch gdb gestartet wird.
Um bad_code mit Hilfe des Speicherauszuges zu debuggen, müssten Sie <c>gdb
./bad_code core</c> ausführen, wobei core der Name des Speicherauszuges ist.
</note>

<p>
Sie sollten eine Eingabeaufforderung der Form "(gdb)" sehen, die auf eine
Eingabe wartet. Als erstes müssen wir das Programm ausführen. Wir geben
<c>run</c> ein und erhalten eine Nachricht ähnlich wie:
</p>

<pre caption="Starten des Programms im GDB">
(gdb) <i>run</i>
Starting program: /home/chris/bad_code

Program received signal SIGSEGV, Segmentation fault.
0xb7ec6dc0 in strcpy () from /lib/libc.so.6
</pre>

<p>
Hier sehen wir, wie das Programm startet, sowie eine Benachrichtigung über
SIGSEV beziehungsweise Speicherzugriffsfehler. Das ist der GDB, der uns
mitteilt, dass unser Programm abgestürzt ist. Er nennt uns außerdem die letzte
ausgeführte Funktion, die er aufspüren konnte, als das Programm abgestürzt ist.
Dies ist allerdings nicht wirklich hilfreich, da es mehrere strcpy in dem
Programm geben könnte, so dass es den Entwicklern schwer fiele, zu erkennen,
welches davon das Problem verursacht. Um ihnen dabei zu helfen, werden wir einen
sogenannten Backtrace durchführen. Ein Backtrace läuft rückwärts durch alle
Funktionen, die während der Programmausführung aufgerufen wurden, bis hin zu der
fehlerhaften Funktion. Funktionen die (ohne einen Absturz zu verursachen) enden,
werden im Backtrace nicht angezeigt. Um das Backtrace zu erhalten geben Sie am
(gdb)-Prompt <c>bt</c> ein. Sie erhalten dann eine Ausgabe ähnlich wie:
</p>

<pre caption="Backtrace des Programms">
(gdb) <i>bt</i>
#0  0xb7ec6dc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it ()
#2  0x080483ba in main ()
</pre>

<p>
Sie können den Ablauf deutlich erkennen. main() wird als erstes aufgerufen,
gefolgt von run_it() und irgendwo in run_it() liegt die fehlerhafte Funktion
strcpy(). Solche Angaben helfen den Entwicklern das Problem einzugrenzen. Es
gibt einige Ausnahmen zu dieser Ausgabe. Als erstes, wenn man vergisst die
Debug-Symbole mit <c>FEATURES="nostrip"</c> zu aktivieren. Mit entfernten
Debug-Symbolen sieht die Ausgabe folgendermaßen aus:
</p>

<pre caption="Backtrace des Programms mit entfernten Debug-Symbolen">
(gdb) <i>bt</i>
#0  0xb7e2cdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in ?? ()
#2  0xbfd19510 in ?? ()
#3  0x00000000 in ?? ()
#4  0x00000000 in ?? ()
#5  0xb7eef148 in libgcc_s_personality () from /lib/libc.so.6
#6  0x080482ed in ?? ()
#7  0x080495b0 in ?? ()
#8  0xbfd19528 in ?? ()
#9  0xb7dd73b8 in __guard_setup () from /lib/libc.so.6
#10 0xb7dd742d in __guard_setup () from /lib/libc.so.6
#11 0x00000006 in ?? ()
#12 0xbfd19548 in ?? ()
#13 0x080483ba in ?? ()
#14 0x00000000 in ?? ()
#15 0x00000000 in ?? ()
#16 0xb7deebcc in __new_exitfn () from /lib/libc.so.6
#17 0x00000000 in ?? ()
#18 0xbfd19560 in ?? ()
#19 0xb7ef017c in nullserv () from /lib/libc.so.6
#20 0xb7dd6f37 in __libc_start_main () from /lib/libc.so.6
#21 0x00000001 in ?? ()
#22 0xbfd195d4 in ?? ()
#23 0xbfd195dc in ?? ()
#24 0x08048201 in ?? ()
</pre>

<p>
Dieser Backtrace enthält eine Vielzahl von Zeilen mit ??. Das kommt daher, da
ohne Debug-Symbole <c>gdb</c> nicht weiß, wie das Programm ausgeführt wurde.
Daher ist es unheimlich wichtig, dass die Debug-Symbole <e>nicht</e> entfernt
werden. Jetzt erinnern Sie sich daran, dass wir vor einiger Zeit das -ggdb
Flag erwähnt haben. Lassen Sie uns mal ausprobieren, wie die Ausgabe mit diesem
Flag aussieht:
</p>

<pre caption="Backtrace des Programms mit -ggdb">
(gdb) <i>bt</i>
#0  0xb7e4bdc0 in strcpy () from /lib/libc.so.6
#1  0x0804838c in run_it (input=0x0) at bad_code.c:7
#2  0x080483ba in main (argc=1, argv=0xbfd3a434) at bad_code.c:12
</pre>

<p>
Hier sehen wir, dass deutlich mehr Informationen für die Entwickler verfügbar
sind. Es werden nicht nur die Informationen zu den aufgerufenen Funktionen
angezeigt, sondern auch die genauen Zeilennummern aus den Quelldateien. Dieses
wird bevorzugt, wenn Sie zusätzlichen Speicherplatz übrig haben. Hier sehen Sie,
wie sehr sich die Dateigröße zwischen Programmen mit debug, strip und -ggdb
unterscheidet.
</p>

<pre caption="Unterschiedliche Dateigrößen mit -ggdb Flag">
<comment>(Debug-Symbole entfernt)</comment>
-rwxr-xr-x  1 chris users 3140  6/28 13:11 bad_code
<comment>(Debug-Symbole aktiviert)</comment>
-rwxr-xr-x  1 chris users 6374  6/28 13:10 bad_code
<comment>(-ggdb Flag aktiviert)</comment>
-rwxr-xr-x  1 chris users 19552  6/28 13:11 bad_code
</pre>

<p>
Wie Sie sehen können, fügt -ggdb etwa <e>13178</e> weitere Bytes zu der
Größe der Datei mit Debug-Symbolen hinzu. Allerdings kann, wie oben gezeigt, der
zusätzliche Speicherplatzbedarf sinnvoll sein, wenn man die Debuginformationen
den Entwicklern präsentiert. Der Backtrace kann durch Kopieren und Einfügen in
eine Datei gespeichert werden (wenn es ein nicht-X-basierendes Terminal ist,
können Sie gpm verwenden. Um diese Anleitung kurz zu halten, empfehle ich Ihnen,
die <uri link="/doc/de/gpm.xml#doc_chap4">Dokumentation zu gpm</uri> zu lesen,
um zu erfahren, wie Sie damit Kopieren und Einfügen können). Jetzt, wo wir mit
<c>gdb</c> fertig sind, können wir ihn beenden.
</p>

<pre caption="Beenden von GDB">
(gdb) <i>quit</i>
The program is running. Exit anyway? (y or n) <i>y</i>
$
</pre>

<p>
Damit endet die Einführung zu <c>gdb</c>. Wir hoffen, dass Sie mit Hilfe von
<c>gdb</c> bessere Bugreports erstellen können. Allerdings gibt es auch andere
Arten von Fehlern, die dazu führen können, dass ein Programm zur Laufzeit
abbricht. Eine der anderen Möglichkeiten ist ein unzulässiger Dateizugriff.
Dieses können wir mit einem raffinierten kleinen Tool namens <c>strace</c>
herausfinden.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Herausfinden von Dateizugriffsfehlern mit Hilfe von strace</title>
<section>
<title>Einführung</title>
<body>

<p>
Programme benutzen oftmals Dateien, um Konfigurationsinformationen zu holen,
auf Hardware zuzugreifen oder Logfiles zu schreiben. Manchmal versucht ein
Programm auf solche Dateien fehlerhaft zuzugreifen. Ein Werkzeug namens
<c>strace</c> wurde erstellt, um damit umgehen zu können. <c>strace</c> spürt
Systemaufrufe auf (daher der Name), unter anderem Aufrufe, die den
Arbeitsspeicher oder Dateien benutzen. Für unser Beispiel nehmen wir das
Programm foobar2. Dieses ist eine neuere Version von foobar. Während des
Wechsels zu foobar2 bemerken Sie allerdings, dass alle Ihre
Konfigurationsdateien fehlen! In foobar Version 1 hatten Sie es auf "foo"
eingestellt, jetzt benutzt es aber den Standard "bar".
</p>

<pre caption="Foobar2 mit einer fehlerhaften Konfiguration">
$ <i>./foobar2</i>
Configuration says: bar
</pre>

<p>
Unsere vorherige Konfiguration hatte es ausdrücklich auf foo gesetzt, daher
benutzen wir jetzt <c>strace</c>, um herauszufinden, was passiert ist.
</p>

</body>
</section>
<section>
<title>Benutzen von strace um den Fehler zu finden</title>
<body>

<p>
Wir lassen <c>strace</c> die Ergebnisse der Systemaufrufe loggen. Um dies zu
erreichen, starten wir <c>strace</c> mit dem Argument -o[file]. Lassen Sie es
uns wie folgt auf foobar2 anwenden.
</p>

<pre caption="Starten von foobar2 durch strace">
# <i>strace -ostrace.log ./foobar2</i>
</pre>

<p>
Damit erstellen wir im aktuellen Verzeichnis eine Datei namens
<path>strace.log</path>. Wir prüfen nun die Datei. Hier sehen Sie einen Auszug
der relevanten Teile dieser Datei.
</p>

<pre caption="Ein Blick auf das strace-Log">
open(".foobar2/config", O_RDONLY)       = 3
read(3, "bar", 3)                       = 3
</pre>

<p>
Aha! Da ist also das Problem. Jemand hat das Konfigurationsverzeichnis auf
<path>.foobar2</path> anstelle von <path>.foobar</path> geändert. Wir können
auch sehen, dass das Programm wie erwartet "bar" einliest. In diesem Fall
können wir dem Ebuild-Maintainer empfehlen einen Warnhinweis einzubauen. Für
den Moment können wir die Konfigurationsdateien von <path>.foobar</path>
herüberkopieren und verändern, um das gewünschte Ergebnis zu erreichen.
</p>

</body>
</section>
<section>
<title>Fazit</title>
<body>

<p>
Bis jetzt haben wir uns darum gekümmert, Fehler zur Laufzeit zu finden. Diese
Fehler sind problematisch, wenn Sie versuchen, Ihr Programm auszuführen.
Allerdings sind Laufzeitfehler das geringste Problem, wenn sich das Programm
erst gar nicht kompilieren lässt. Lassen Sie uns daher einen Blick darauf
werfen, wie man Kompilationsfehlern beim <c>emergen</c> begegnet.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Umgang mit emerge-Fehlern</title>
<section>
<title>Einführung</title>
<body>

<p>
<c>emerge</c>-Fehler, wie der am Anfang gezeigte, können eine Hauptursache für
Frustration bei den Benutzern sein. Das Melden solcher Fehler wird daher als
entscheidend für die Bewahrung von Gentoos Gesundheit erachtet. Lassen Sie uns
als Beispiel einen Blick auf das Ebuild foobar2, das einige Buildfehler
enthält, werfen.
</p>

</body>
</section>
<section id="emerge_error">
<title>Untersuchen von emerge-Fehlern</title>
<body>

<p>
Lassen Sie uns einen Blick auf diesen sehr einfachen <c>emerge</c>-Fehler
werfen:
</p>

<pre caption="emerge-Fehler (lange Zeilen sind manuell umgebrochen, um in das Fenster zu passen)">
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2.o foobar2.c
foobar2.c:1:17: ogg.h: No such file or directory
make: *** [foobar2.o] Error 1


!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
Das Programm kompiliert problemlos, bis es plötzlich stoppt und eine
Fehlermeldung anzeigt. Dieser spezielle Fehler kann in drei verschiedene Teile
aufgeteilt werden, die Kompilierungsnachrichten, den Buildfehler und die
emerge-Fehlermeldung, wie nachfolgend gezeigt:
</p>

<pre caption="Teile des Fehlers (lange Zeilen sind manuell umgebrochen, um in das Fenster zu passen)">
<comment>(Kompilierungsnachrichten)</comment>
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-7.o foobar2-7.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-8.o foobar2-8.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2-9.o foobar2-9.c
gcc -D__TEST__ -D__GNU__ -D__LINUX__ -L/usr/lib -I/usr/include -L/usr/lib/nspr/ -I/usr/include/fmod \
 -c -o foobar2.o foobar2.c

<comment>(Buildfehler)</comment>
foobar2.c:1:17: ogg.h: No such file or directory
make: *** [foobar2.o] Error 1

<comment>(emerge-Fehler)</comment>
!!! ERROR: sys-apps/foobar2-1.0 failed.
!!! Function src_compile, Line 19, Exitcode 2
!!! Make failed!
!!! If you need support, post the topmost build error, NOT this status message
</pre>

<p>
Die Kompilierungsnachrichten weisen auf den Fehler hin. Meistens ist es eine
gute Idee, mindestens die letzten 10 Zeilen beizufügen, so dass die Entwickler
wissen, an welcher Stelle die Kompilierung war, als der Fehler auftrat.
</p>

<p>
Bitte stellen Sie sicher, dass Sie Fehlermeldungen immer auf Englisch einbinden,
auch wenn Ihre Systemsprache auf eine andere gesetzt ist. Sie können temporär
auf eine englische Locale umstellen, indem Sie <c>LC_ALL=C</c> der emerge
Befehlszeile voranstellen.
</p>

<pre caption="Temporär die Locale auf Englisch umstellen">
# <i>LC_ALL=C emerge sys-apps/foobar2</i>
</pre>

<note>
Dies ist auch ungefähr der einzige Zeitpunkt, an dem Sie die Umgebungsvariable
<c>LC_ALL</c> zum Setzen der Locale-Einstellungen verwenden sollten. Wenn Sie
nach einem Weg suchen, die Sprache Ihres Systems umzustellen, dann werfen Sie
stattdessen bitte einen Blick in unseren <uri
link="guide-localization.xml">Leitfaden zur Lokalisierung</uri>.
</note>

<p>
Make-Fehler sind die tatsächlichen Fehler und die Informationen, die der
Entwickler benötigt. Wenn Sie Zeilen der Art "make: ***" sehen, ist dies oft die
Stelle, an der der Fehler auftrat. Normalerweise können Sie 10 Zeilen davor und
danach beifügen und der Entwickler kann den Fehler adressieren. Allerdings mag
das nicht immer funktionieren, daher werden wir uns gleich eine Alternative
ansehen.
</p>

<p>
Der emerge-Fehler ist das, was <c>emerge</c> als einen Fehler auswirft. Manchmal
kann auch das wichtige Informationen beinhalten. Oftmals machen Leute den
Fehler, ausschließlich den emerge-Fehler zu berichten. Das ist für sich alleine
genommen nutzlos, aber mit dem make-Fehler und den Kompilierungsinformationen
zusammen kann ein Entwickler sehen, welches Programm und welche Version des
Pakets fehlschlägt. Als Randbemerkung, make ist als Buildprozess für Programme
weit verbreitet (<b>aber nicht immer</b>). Wenn Sie keinen Fehler der Art
"make: ***" finden können, kopieren Sie einfach die 20 Zeilen vor dem
emerge-Fehler. Das sollte die meisten Fehlermeldungen des Buildsystems
beinhalten. Nehmen wir einmal an, die Fehler scheinen recht umfangreich zu sein.
10 Zeilen werden dann nicht reichen, um alles einzufangen. An dieser Stelle
kommt PORT_LOGDIR ins Spiel.
</p>

</body>
</section>
<section>
<title>emerge und PORT_LOGDIR</title>
<body>

<p>
PORT_LOGDIR ist eine Portage-Variable, die ein Logverzeichnis für einzelne
emerge-Logs aufsetzt. Lassen Sie uns einen Blick darauf werfen, was das zur
Folge hat. Starten Sie zuerst emerge mit PORT_LOGDIR auf Ihr gewähltes
Logverzeichnis gesetzt. Nehmen wir an, Sie haben ein Verzeichnis
<path>/var/log/portage</path>. Wir werden das als unser Logverzeichnis benutzen:
</p>

<note>
In der Standardinstallation existiert <path>/var/log/portage</path> nicht und
Sie müssen das Verzeichnis manuell anlegen. Wenn Sie das nicht machen, wird
Portage bei dem Versuch, das Logfile zu schreiben, fehlschlagen.
</note>

<pre caption="emergen mit PORT_LOGDIR">
# <i>PORT_LOGDIR=/var/log/portage emerge cate-gory/foobar2</i>
</pre>

<p>
Nun wird emerge wieder fehlschlagen. Allerdings haben wir dieses Mal ein
Logfile, mit dem wir arbeiten und das wir dem Bugreport nachher anhängen können.
Lassen Sie uns einen kurzen Blick in unser Logverzeichnis werfen.
</p>

<pre caption="Inhalt von PORT_LOGDIR">
# <i>ls -la /var/log/portage</i>
total 16
drwxrws---   2 root root 4096 Jun 30 10:08 .
drwxr-xr-x  15 root root 4096 Jun 30 10:08 ..
-rw-r--r--   1 root root 7390 Jun 30 10:09 cate-gory:foobar2-1.0:20090110-213217.log
</pre>

<p>
Die Logfiles haben das Format [Kategorie]:[Paketname]-[Version]:[Datum].log.
Ein kurzer Blick über das Logfile zeigt Ihnen den kompletten emerge-Prozess.
Dieses kann dann angehängt werden, wie wir nachher im Kapitel Bugs melden sehen
werden. Jetzt, da wir die Informationen, die wir zum Melden des Bugs benötigen,
gewonnen haben, können wir das auch endlich machen. Bevor wir damit allerdings
anfangen, müssen wir erst einmal sicherstellen, dass noch niemand den Fehler
bereits gemeldet hat. Lassen Sie uns also einen Blick auf das Suchen von Bugs
werfen.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Suchen mit Bugzilla</title>
<section>
<title>Einführung</title>
<body>

<p>
Wir bei Gentoo benutzen <uri link="http://www.bugzilla.org">Bugzilla</uri>, um
Bugs zu verwalten. Gentoos Bugzilla ist per HTTPS und HTTP erreichbar. HTTPS
ist für diejenigen verfügbar, die sich in unsicheren Netzwerken befinden oder
einfach paranoid sind :). Wegen der Konsistenz werden wir in den folgenden
Beispielen die HTTPS-Version benutzen. Gehen Sie auf <uri
link="https://bugs.gentoo.org">Gentoo Bugs</uri>, um sich einen ersten Eindruck
zu verschaffen.
</p>

<p>
Eines der frustrierensten Dinge für Entwickler und Bug-Wrangler ist es,
doppelte Bug Reports zu finden. Diese kosten sie eine Menge wertvoller Zeit, die
sie ansonsten für wichtigere Bugs nutzen könnten. Oft kann dieses durch einige
einfache Suchmethoden verhindert werden. Daher werden wir uns ansehen, wie man
nach Bugs sucht, und herausfinden kann, ob man einen ähnlichen Bug gefunden hat.
Für dieses Beispiel werden wir den xclass Emerge-Fehler benutzen, den wir weiter
oben schon verwendet haben.
</p>

<pre caption="xclass emerge-Fehler">
/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.2/include/g++-v3/backward/backward_warning.h:32:2:
warning: #warning This file includes at least one deprecated or antiquated
header. Please consider using one of the 32 headers found in section 17.4.1.2 of
the C++ standard. Examples include substituting the &lt;X&gt; header for the &lt;X.h&gt;
header for C++ includes, or &lt;sstream&gt; instead of the deprecated header
&lt;strstream.h&gt;. To disable this warning use -Wno-deprecated.
In file included from main.cc:40:
menudef.h:55: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:62: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:70: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
menudef.h:78: error: brace-enclosed initializer used to initialize `
OXPopupMenu*'
main.cc: In member function `void OXMain::DoOpen()':
main.cc:323: warning: unused variable `FILE*fp'
main.cc: In member function `void OXMain::DoSave(char*)':
main.cc:337: warning: unused variable `FILE*fp'
make[1]: *** [main.o] Error 1
make[1]: Leaving directory
`/var/tmp/portage/xclass-0.7.4/work/xclass-0.7.4/example-app'
make: *** [shared] Error 2

!!! ERROR: x11-libs/xclass-0.7.4 failed.
!!! Function src_compile, Line 29, Exitcode 2
!!! 'emake shared' failed
</pre>

<p>
Um unsere Suche zu beginnen, gehen wir zu der <uri
link="https://bugs.gentoo.org/">Bugzilla Homepage</uri>.
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Bugzilla Homepage"/>

<p>
Wir klicken auf "Query Existing bug reports". Der Grund, warum wir diese Suche
der "basic bug search" vorziehen, ist, dass die basic bug search dazu tendiert,
einem nur vage Ergebnisse zu liefern und Benutzer oft daran hindert, die
Ergebnisse durchzusehen und doppelte Bugs zu finden. Nachdem wir auf den Query
Screen geklickt haben, erreichen wir die nächste Seite:
</p>

<figure link="/images/docs/bugzie-search.png" caption="Bugzilla Suchseite"/>

<note>
Wenn Sie die "Advanced Search" schon vorher benutzt haben, werden Sie höchst
wahrscheinlich diesen Bildschirm stattdessen sehen.
</note>

<p>
Fahren Sie durch Klicken des "Advanced Search"-Link fort um die Advanced Search
Seite hervorzubringen.
</p>

<figure link="/images/docs/bugzie-adv-search.png" caption="Seite Advanced Search"/>

<p>
So sieht die Advanced Search Seite aus. Es mag auf den ersten Blick
überwältigend aussehen, aber wir werden ein paar einfache Felder betrachten,
mit deren Hilfe wir die eher vagen Suchergebnisse eingrenzen können.
</p>

<figure link="/images/docs/bugzie-content.png" caption="Inhalt"/>

<p>
Das erste Feld ist die Zusammenfassung des Fehlers. Hier tragen wir einfach
den Namen des Pakets ein, das abstürzt. Wenn Bugzie keine Ergebnisse liefert,
versuchen Sie den Paketnamen zu entfernen, für den Fall, dass jemand den Namen
nicht in das Feld der Zusammenfassung geschrieben hat (eher unwahrscheinlich,
aber wir haben schon eine Menge merkwürdiger Bug Reports gesehen).
</p>

<p>
Product, Component und Version sollten alle auf der Standardeinstellung
gelassen werden. Das verhindert, dass wir zu genau suchen und die richtigen
Bugs ausschließen.
</p>

<p>
Comment ist der wichtigste Teil. Benutzen Sie das Kommentarfeld, um die
Besonderheit dieses Fehlers einzutragen. Grundsätzlich sollten Sie nicht
so etwas wie den Anfang des Buildfehlers nehmen. Suchen Sie stattdessen eine
Zeile die vorher auftritt und einen tatsächlichen Fehler zeigt. Sie sollten
zusätzlich die Zeichensetzung entfernen, um Bugzilla davon abzuhalten, das
Ergebnis falsch zu interpretieren. Ein Beispiel aus dem xclass emerge-Fehler:
</p>

<pre caption="Inhalt der Zeile Comment">
menudef.h:78: error: brace-enclosed initializer used to initialize `OXPopupMenu'
<comment>(Entfernen Sie die Anführungszeichen ' ')</comment>
menudef.h 78 error brace-enclosed initializer used to initialize OXPopupMenu
</pre>

<p>
Diese Meldung ist spefizisch genug, um den gesuchten Bug zu finden, ohne sich
durch Unmengen anderer xclass-Kompilierungsfehler wühlen zu müssen.
</p>

<p>
URI, Whiteboard und Keywords können so gelassen werden. Was wir bis hierhin
eingetragen haben sollte ausreichen, um unseren Bug zu finden. Werfen wir nun
einen Blick darauf, was wir eingetragen haben.
</p>

<figure link="/images/docs/bugzie-comp-search.png" caption="Ausgefüllte Suchmaske"/>

<p>
Wenn wir auf den Search-Button klicken kommt unser Ergebnis...
</p>

<figure link="/images/docs/bugzie-search-result.png" caption="Suchergebnisse"/>

<p>
Nur 2 Bugs! Damit können wir viel einfacher umgehen. Wir klicken den ersten an
und tatsächlich, es ist der gesuchte Bug.
</p>

<figure link="/images/docs/bugzie-located.png" caption="Bug gefunden"/>

<p>
Es ist aber nicht nur der Bug den wir gesucht haben, er ist auch schon gelöst.
Wenn wir uns den letzten Kommentar ansehen, finden wir die Lösung und wissen,
wie wir vorgehen müssen, um den Fehler zu bereinigen. Jetzt sehen wir uns mal
an, was passiert wäre, wenn Sie nicht die Advanced Search genutzt hätten.
</p>

<figure link="/images/docs/bugzie-basic-search-result.png" caption="Einfache Suchergebnisse"/>

<p>
4 zusätzliche Bugs mit denen wir uns beschäftigen müssten! Mit größeren Paketen
wird es sogar noch schlimmer. Mit diesen einfachen Werkzeugen sind wir jedoch in
der Lage die Anzahl der Suchergebnisse deutlich einzuschränken, um zu versuchen,
einen spezifischen Bug zu finden.
</p>

</body>
</section>
<section>
<title>Fazit</title>
<body>

<p>
Nehmen wir mal an, Sie haben gesucht und gesucht, aber finden einfach keinen
Bug. Sie haben also selbst einen bisher unbekannten Bug gefunden. Werfen wir
also einen Blick auf den Prozess, wie man neue Bugs meldet.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Das Melden von Bugs</title>
<section>
<title>Einführung</title>
<body>

<p>
In diesem Kapitel werden wir herausfinden, wie wir Bugzilla benutzen können, um
einen neuen Bug zu melden. Gehen Sie nun auf <uri
link="https://bugs.gentoo.org">Gentoo Bugs</uri> und ...
</p>

<figure link="/images/docs/bugzie-homepage.png" caption="Bugzilla Homepage"/>

<p>
Klicken auf "Report a Bug - Using the guided format".
</p>

<figure link="/images/docs/bugzie-prod-select.png" caption="Produktauswahl"/>

<p>
Wie Sie sehen können, <b>größter</b> Nachdruck wurde darauf gelegt, dass Sie
den Bug an der richtigen Stelle eröffnen. Der Großteil der Bugs geht zu Gentoo
Linux.
</p>

<p>
Trotzdem ordnen manche Leute ebuild-Bugs in Portage-Development (in der
Annahme, dass das Portage-Team sich um den Portagebaum kümmert) oder Infra
(in der Annahme, dass Infra Zugriff auf die Spiegelserver und rsync hat und den
Fehler direkt beheben kann) ein. Das ist aber nicht die Art und Weise wie es
funktioniert.
</p>

<p>
Ein anderes Missverständnis tritt häufig mit unseren Documentation-Bugs auf.
Zum Beispiel, ein Benutzer findet einen Fehler in der <uri
link="/proj/en/releng/catalyst/">Catalyst Dokumentation</uri>. Die allgemeine
Tendenz ist, den Fehler unter Docs-user einzuordnen, so dass er dem <uri
link="http://gdp.gentoo.org">GDP</uri> zugeteilt wird, obwohl er eigentlich zu
einem Mitglied des <uri link="/proj/en/releng/">Release Engineering</uri>-Team
gehen sollte. Als Faustregel gilt: Nur Dokumentation unter
<path>http://www.gentoo.org/doc/*</path> gehört zum GDP. Alles unter
<path>http://www.gentoo.org/proj/*</path> gehört zu den jeweiligen Teams.
</p>

<note>
Wir sehen lieber einen Bug, dessen Produkt nicht Gentoo Linux seien sollte, aber
unter diesem eingetragen wurde, als einen Bug der zu Gentoo Linux gehört und
falsch zugeordnet wurde. Auch wenn keines von beiden gerne gesehen wird, ist
das erste eher verständlich und zu akzeptieren (außer Website-Bugs.. damit
könnten wir Probleme haben...).
</note>

<p>
Unser Bug gehört nach Gentoo Linux, da er ein Ebuild-Fehler ist. Wir fahren
dementsprechend fort und bekommen den mehrstufigen Bug-Reporting-Prozess zu
sehen. Lassen Sie uns jetzt mit Schritt 1 beginnen...
</p>

<figure link="/images/docs/bugzie-guide-step1.png" caption="Guided Format Schritt 1"/>

<p>
Der erste Schritt hierbei ist wirklich wichtig (wie Sie an dem roten Text sehen
können). Das ist der Punkt, an dem Sie durch eine Suche nachsehen, dass noch
niemand den Bug gemeldet hat. Wenn Sie diesen Schritt weglassen und einen schon
existierenden Bug melden, wird er als DUPLICATE markiert werden und damit eine
Menge Arbeitsaufwand der Qualitätssicherung verschwendet. Um Ihnen einen
Eindruck zu vermitteln: Die durchgestrichenen Bugnummern sind duplizierte Bugs.
Jetzt folgt Schritt 2, in dem wir die benötigten Informationen eingeben.
</p>

</body>
</section>
<section>
<title>Benötigte Informationen</title>
<body>

<figure link="/images/docs/bugzie-basic.png" caption="Basisinformationen"/>

<p>
Lassen Sie uns einen näheren Blick darauf werfen, was was ist.
</p>

<ul>
  <li>
    Als erstes gibt es das Produkt. Das Produkt schränkt den Bug auf einen
    bestimmten Bereich von Gentoo, wie zum Beispiel Bugzilla (für Bugs im
    Zusammenhang mit bugs.gentoo.org), Doc-user (für Benutzerdokumentation)
    oder Gentoo Linux (für Ebuilds und ähnliches) ein.
  </li>
  <li>
    Component gibt an, wo der Bug genau aufgetreten ist, insbesonders in welchen
    Bereich des gewählten Produktes er gehört. Das macht die Einteilung
    einfacher.
  </li>
  <li>
    Hardware-Plattform gibt Ihre verwendete Architektur an. Wenn Sie SPARC
    benutzen, setzen Sie es auf SPARC.
  </li>
  <li>
    Operating System gibt das Betriebssystem an, das Sie benutzen. Da Gentoo
    eine "Meta-Distribution" ist, kann es auf anderen Betriebssystemen als
    Linux laufen.
  </li>
</ul>

<p>
So, für unser Beispiel haben wir:
</p>

<ul>
  <li>Product - Gentoo Linux (Da es sich um einen Ebuild-Fehler handelt)</li>
  <li>Component - Application (Es ist ein fehlerhaftes Programm, foobar2)</li>
  <li>
    Hardware Platform - All (Dieser Fehler könnte auf allen Architekturen
    auftreten)
  </li>
  <li>
    Operation System - All (Er könnte auf allen Arten von Betriebssystemen
    auftreten)
  </li>
</ul>

<figure link="/images/docs/bugzie-basic-comp.png" caption="Vervollständigte Basisinformation"/>

<ul>
  <li>
    Build Identifier ist im Wesentlichen der User-Agent des Browsers, der
    benutzt wird um den Bug zu melden (zur Protokollierung). Sie können das
    Feld wie vorgefunden belassen.
  </li>
  <li>
    URL ist optional und wird benutzt, um auf weitere wichtige Informationen auf
    einer anderen Webseite zu verweisen (Upstream Bugzilla, Releasenotes auf der
    Pakethomepage usw.). Sie sollten niemals URL benutzen, um auf ein Pastebin
    für Fehlermeldungen, Logfiles, Ausgabe von <c>emerge --info</c>, Screenshots
    oder ähnliche Informationen zu verweisen. Stattdessen sollten diese
    Informationen immer an den Bug angehängt werden.
  </li>
  <li>
    In Summary sollten Sie die Paketkategorie, den Paketnamen und die
    Versionsnummer angeben.
  </li>
</ul>

<p>
Die Kategorie nicht in der Zusammenfassung anzugeben ist nicht so schlimm, wird
aber empfohlen. Wenn Sie aber den Paketnamen nicht angeben, wissen wir nicht
worauf sich der Bug bezieht und wir müssen nachfragen. Die Versionsnummer ist
wichtig für die Leute, die nach Bugs suchen. Wenn 20 Personen Bugs erstellen und
niemand eine Versionsnummer angibt, wie soll dann jemand, der nach einem
ähnlichen Bug sucht, herausfinden, ob es seiner ist? Er müsste sich jeden
einzelnen ansehen, was nicht so schwierig wäre. Aber stellen Sie sich vor, es
wären 200 Bugs, das wäre schon aufwändiger. Nach all den Paketinformationen
sollten Sie eine kurze Beschreibung des Vorfalls einfügen. Hier ist ein
Beispiel:
</p>

<figure link="/images/docs/bugzie-summary.png" caption="Zusammenfassung"/>

<p>
Diese einfachen Regeln machen das Umgehen mit Bugs deutlicher einfacher. Als
nächstes kommen wir zu den Details. Hier geben wir die Informationen bezüglich
des Bugs an. Wir erklären es Ihnen anhand eines Beispiels:
</p>

<figure link="/images/docs/bugzie-details.png" caption="Details"/>

<p>
Jetzt wissen die Entwickler, warum wir den Bugreport erstellen. Sie können nun
versuchen, den Fehler zu reproduzieren. Reproduzierbarkeit gibt an, wie oft wir
in der Lage waren, das Problem nachzustellen. In diesem Beispiel können wir den
Fehler jederzeit reproduzieren, indem wir foobar2 ausführen. Tragen wir also
diesen Hinweis ein.
</p>

<figure link="/images/docs/bugzie-reprod.png" caption="Reproduzierbarkeit"/>

<p>
Wir haben angegeben, wie wir den Fehler gefunden haben. Der nächste Schritt ist
nun anzugeben, welches Ergebnis wir erhalten haben und was wir glauben, wie es
hätte aussehen sollen.
</p>

<figure link="/images/docs/bugzie-results.png" caption="Ergebnis"/>

<p>
Dann können wir zusätzliche Informationen angeben. Das können zum Beispiel
Sachen wie Stack-Traces, <b>Abschnitte</b> (da das komplette Logfile meistens zu
groß und nicht sonderlich sinnvoll ist) des strace-Logs oder das Wichtigste,
Ihre Ausgabe von <c>emerge --info</c> sein. Hier ist ein Beispiel:
</p>

<figure link="/images/docs/bugzie-addl-info.png" caption="Zusätzliche Informationen"/>

<p>
Schlussendlich wählen wir die Dringlichkeit des Bugs. Schauen Sie sich das noch
einmal ganz genau an. In den meisten Fällen ist es in Ordnung, es so zu lassen
wie es ist, und jemand wird den Wert für Sie erhöhen/verringern. Wenn Sie
allerdings die Dringlichkeit des Bugs erhöhen, lesen Sie alles noch einmal durch
und vergewissern Sie sich, dass Sie keinen Fehler gemacht haben. Eine Übersicht
über die verschiedenen Stufen folgt.
</p>

<ul>
  <li>
    Blocker - Das Programm lässt sich schlichtweg nicht emergen oder ist eine
    wesentliche Behinderung des Systems. Zum Beispiel ein
    <c>baselayout</c>-Problem, welches das System vom Booten abhält, wäre ein
    sicherer Kandidat für die Kategorie Blocker.
  </li>
  <li>
    Critical - Das Programm verursacht Datenverlust oder schwerwiegende
    Speicherlecks während der Laufzeit. Wiederum, wenn ein wichtiges Programm,
    wie zum Beispiel <c>net-tools</c>, nicht kompiliert, könnte es als critical
    gekennzeichnet werden. Zwar wird das System dadurch nicht am Starten
    gehindert, aber es ist ziemlich wichtig für den alltäglichen Gebrauch.
  </li>
  <li>
    Major - Das Programm stürzt ab, aber es ist nichts, was dazu führt, dass das
    System schweren Schaden nimmt oder Daten verloren gehen.
  </li>
  <li>
    Minor - Ihr Programm stürzt sporadisch ab und es gibt offensichtliche
    Notlösungen.
  </li>
  <li>
    Normal - Der Standard. Wenn Sie sich nicht sicher sind, lassen Sie es dabei,
    außer es handelt sich um einen neuen Build oder kosmetische Änderungen. In
    dem Fall lesen Sie bitter weiter unten für weitere Informationen.
  </li>
  <li>
    Trivial - Sachen wie ein falsch geschriebenes Wort oder die Korrektur
    von Leerzeichen.
  </li>
  <li>
    Enhancement - Eine Anfrage bezüglich neuer Features in einem Programm oder
    genauer gesagt ein <e>neues Ebuild</e>.
  </li>
</ul>

<figure link="/images/docs/bugzie-sev.png" caption="Gewichtung"/>

<p>
In unserem Fall setzten wir den Wert auf Normal.
</p>

<p>
Jetzt können wir den neuen Bug Report abschicken, indem wir auf das Feld Submit
Bug Report klicken. Sie sehen dann Ihren neuen Bug erscheinen. Sehen Sie sich
<uri link="https://bugs.gentoo.org/show_bug.cgi?id=97265">Bug 97561</uri> an, um
zu sehen, wie das Ergebnis aussieht. Wir haben damit unseren Bug gemeldet!
Schauen wir uns jetzt an, wie damit weiter umgegangen wird.
</p>

</body>
</section>
<section>
<title>Zero-Day Bump Request</title>
<body>

<p>
Bisher haben wir gezeigt, was man machen muss, um einen Bug zu erstellen. Jetzt
sehen wir uns an, was man <e>nicht</e> machen sollte.
</p>

<p>
Nehmen wir an, Sie haben ungeduldig den Terminplan eines Upstreamprojektes
verfolgt und wenn Sie auf die Homepage gehen, sehen Sie was? Genau, es wurde
gerade vor ein paar Minuten eine neue Version veröffentlicht! Die meisten
Benutzer würden sofort zu Gentoos Bugzilla rennen und melden, dass eine neue
Version verfügbar ist - "Bitte fügt die neue Version Portage hinzu", usw.
Allerdings ist dies genau das, was Sie <b>nicht</b> tun sollten. Diese Art von
Anfragen werden Zero-Day (oder 0-Day) Bump Requests genannt, da sie am selben
Tag getätigt werden, an dem eine neue Version erscheint.
</p>

<impo>
<b>Bitte warten Sie <e>mindestens</e> 48 Stunden bevor Sie eine neue Version auf
Bugzilla melden.</b> Zusätzlich <e>müssen</e> Sie vor dem Eintragen in Bugzilla
nachsehen, um sicher zu stellen, dass nicht schon jemand anderes es gemeldet
hat oder die Gentoo Maintainer sich nicht schon von sich aus mit der neuen
Version beschäftigt haben.
</impo>

<p>
Warum Sie warten sollten? Als erstes ist es ziemlich unhöflich zu erwarten,
dass Gentoo Entwickler alles liegenlassen, woran sie gerade arbeiten, um eine
neue Version, die vor 15 Minuten veröffentlicht wurde, hinzuzufügen. Ihr
Zero-Day Bump Request könnte daher als INVALID oder LATER markiert werden, da
Entwickler eine Menge dringender Aufgaben haben, die sie beschäftigen. Zweitens
sind Entwickler normalerweise weit vor den Benutzern über neue Versionen
informiert, da sie Upstream relativ eng verfolgen müssen. Sie wissen bereits,
dass eine neue Version auf dem Weg ist. In vielen Fällen werden sie bereits
einen Bug erstellt oder sogar die Version in Portage als maskiertes Paket
hinzugefügt haben.
</p>

<p>
Seien Sie clever, wenn Sie neue Versionen von Paketen testen und vorschlagen.
Suchen Sie in Bugzilla, bevor Sie Ihren Bump Request erstellen. Ist bereits ein
Bug offen? Haben Sie kürzlich synchronisiert? Ist es bereits in Portage? Wurde
es wirklich schon von Upstream veröffentlicht? Gesunder Menschenverstand wird
Sie weit bringen und Sie bei den vielbeschäftigten Entwicklern beliebt machen.
Wenn mehrere Tage seit der Veröffentlichung vergangen sind und Sie sich sicher
sind, dass keine offene Anfrage dazu vorliegt (und dass es nicht bereits in
Portage vorhanden ist), dann können Sie einen neuen Bug erstellen. Denken Sie
daran, zu erwähnen, dass sich das Paket auf Ihrer Architektur kompilieren lässt
und gut läuft. Jede weitere hilfreiche Information, die Sie beitragen, ist gerne
gesehen.
</p>

<p>
Sie wollen die neueste Version Ihres Lieblingspakets in Portage sehen? Erstellen
Sie kluge Bugs.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Arbeiten mit Ihrem Bug</title>
<section>
<body>

<p>
Wenn wir uns den Bug ansehen, sehen wir die Informationen, die wir vorhin
eingegeben haben. Sie werden feststellen, dass der Bug bug-wranglers@gentoo.org
zugeordnet wurde. Das ist die Standardzuordnung für Application Component Bugs.
</p>

<figure link="/images/docs/bugzie-new-basic.png" caption="Neue Basisinformationen eines Bug"/>

<p>
Die Details, die wir zu dem Bug eingegeben haben, sind ebenfalls einsehbar.
</p>

<figure link="/images/docs/bugzie-new-details.png" caption="Neue Bugdetails"/>

<p>
Allerdings werden Bug-Wrangler (normalerweise) unseren Bug nicht reparieren,
daher werden wir ihn jemandem zuordnen, der das kann (Sie können die Zuordnung
auch die Bug-Wrangler erledigen lassen). Dafür benutzen wir die metadata.xml des
Paketes. Sie finden sie normalerweise unter
<path>/usr/portage/category/package/metadata.xml</path>. Hier ist die für
foobar2 erstellte.
</p>

<note>
Um Bugs neu zuordnen zu können, müssen Sie entweder Ersteller des Bugs oder
Mitglied einer bestimmten Gentoo Bugzilla-Benutzergruppe (z.B. Gentoo
Developers) sein.
</note>

<pre caption="metadata.xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd"&gt;
&lt;pkgmetadata&gt;
&lt;herd&gt;chriswhite&lt;/herd&gt;
&lt;maintainer&gt;
&lt;email&gt;chriswhite@gentoo.org&lt;/email&gt;
&lt;name&gt;Chris White&lt;/name&gt;
&lt;/maintainer&gt;
&lt;longdescription lang="en"&gt;
Foobar2 is a package that uses a configuration file to display a word.
&lt;/longdescription&gt;
&lt;/pkgmetadata&gt;
</pre>

<p>
Beachten Sie den Abschnitt maintainer. Dieser zählt die Maintainer des Paketes
auf, in unserem Fall mich selber, Chris White. Die eingetragene Email ist
chriswhite@gentoo.org. Wir werden diese Informationen nutzen, um den Bug der
richtigen Person zuzuordnen. Um das zu machen, klicken Sie auf die Markierung
neben Reassign bug to und geben dann die Email-Adresse ein.
</p>

<note>
Ein Bug für ein Paket ohne die Datei metadata.xml sollte
maintainer-needed@gentoo.org zugeordnet werden. Ein Paket, das einen Gentoo
Entwickler zur Pflege benötigt, sollte maintainer-wanted@gentoo.org zugeordnet
werden.
</note>

<figure link="/images/docs/bugzie-reassign.png" caption="Neuzuordnung eines Bug"/>

<p>
Drücken Sie danach den Button Commit, um die Änderungen zu übernehmen. Der Bug
wird mir dann zugeordnet. Kurz danach bemerken Sie (normalerweise per Email),
dass ich auf Ihren Bug geantwortet habe. Ich habe Sie um ein strace-Log
gebeten, um herauszufinden wie das Programm versucht auf die Konfigurationsdatei
zuzugreifen. Sie folgen den anfänglichen Anweisungen bezüglich der Nutzung von
strace und erhalten ein strace-Log. Nun müssen Sie es dem Bug hinzufügen. Um das
zu erreichen, klicken Sie auf "Create A New Attachment".
</p>

<figure link="/images/docs/bugzie-new-attach.png" caption="Neuer Anhang"/>

<p>
Jetzt müssen wir das Logfile hinzufügen. Lassen Sie uns das schrittweise
durchgehen.
</p>

<ul>
  <li>
    File - Das ist der Ort der Datei auf ihrem Rechner. In diesem Beispiel der
    Ort von <path>strace.log</path>. Sie können den "Browse..." Knopf benutzen,
    um die Datei auszuwählen oder den Pfad direkt in das Textfeld eintragen.
  </li>
  <li>
    Description - Ein kurzer Einzeiler oder einige wenige Worte, die den Anhang
    beschreiben. Wir werden hier nur strace.log eintragen, da das ziemlich
    selbsterklärend ist.
  </li>
  <li>
    Content Type - Das ist der Dateityp der Datei, die wir an den Bug anhängen.
  </li>
  <li>
    Obsoletes - Falls schon Anhänge zu diesem Bug hinzugefügt wurden, haben Sie
    die Möglichkeit sie durch Ihren Anhang als hinfällig zu erklären. Da es
    keine existierenden Anhänge zu diesem Bug gibt, brauchen wir uns darum nicht
    zu kümmern.
  </li>
  <li>
    Comment - Fügen Sie Kommentare hinzu, die mit dem Anhang sichtbar werden.
    Sie können hier, falls nötig, näher auf den Anhang eingehen.
  </li>
</ul>

<p>
Im Bezug auf den Content Type, gibt es noch einige weitere Details. Sie können
die "patch"-Checkbox auswählen, wenn Sie einen Patch anhängen. Ansonsten können
Sie Bugzilla bitten, den Dateityp automatisch ("auto-detect") zu ermitteln
(nicht empfehlenswert). Die andere Möglichkeit ist, den Dateityp aus einer Liste
auszuwählen ("select from list"), was oftmals verwendet wird. Benutzen Sie
Klartext (text/plain) für <e>die meisten</e> Anhänge, außer Binärdateien wie
Bilder (je nach Typ image/gif, image/jpeg oder image/png benutzen) oder
komprimierte Dateien wie .tar.bz2, welche vom Dateityp application/octet-stream
sind.
</p>


<figure link="/images/docs/bugzie-new-attach-comp.png" caption="Neuer Anhang hinzugefügt"/>

<p>
Wir übermitteln <path>strace.log</path> und es wird im Bugreport wie folgt
dargestellt.
</p>

<figure link="/images/docs/bugzie-strace.png" caption="Angehängtes Stracelog"/>

<p>
Wir hatten schon erwähnt, dass es manchmal Ebuilds gibt, die Ihnen in der
Emerge-Fehlermeldung mitteilen, eine bestimmte Datei anzuhängen. Ein Beispiel
sehen Sie hier.
</p>

<pre caption="Beispiel einer Aufforderung zum Dateianhang">
configure: error: PNG support requires ZLIB. Use --with-zlib-dir=&lt;DIR&gt;

!!! Please attach the config.log to your bug report:
!!! /var/tmp/portage/php-5.0.3-r1/work/php-5.0.3/config.log

!!! ERROR: dev-php/php-5.0.3-r1 failed.
!!! Function econf, Line 485, Exitcode 0
!!! econf failed
!!! If you need support, post the topmost build error, NOT this status message.
</pre>

<p>
Bitte fügen Sie sämtliche so erwähnte Dateien Ihrem Bugreport hinzu.
</p>

<p>
Manchmal kann es passieren, dass Sie ein Entwickler bittet, ein diff oder einen
Patch für eine Datei hinzuzufügen. Standard diff-Dateien können so erzeugt
werden:
</p>

<pre caption="Erstellung von Standard diff-Dateien">
$ <i>cp file file.old</i>
$ <i>nano file</i>
$ <i>diff -u file.old file</i>
</pre>

<p>
Für C/C++ Quelldateien wird das Flag <b>-p</b> hinzugefügt, um die
Funktionsaufrufe mit anzuzeigen, auf die das Diff sich bezieht:
</p>

<pre caption="Diff von C/C++ Quellcode">
$ <i>cp file.c file.c.old</i>
$ <i>nano file.c</i>
$ <i>diff -up file.c.old file.c</i>
</pre>

<p>
Das Dokumentationsteam benötigt die Flag-Kombination <b>-Nt</b> sowie
<b>-u</b>. Das hat hauptsächlich mit Tabexpansion zu tun. Sie können so einen
Diff folgendermaßen erstellen:
</p>

<pre caption="Diff von Dokumentationen">
$<i> cp file.xml file.xml.old</i>
$<i> nano file.xml</i>
$<i> diff -Nut file.xml.old file.xml</i>
</pre>

<p>
Damit ist Ihr Diff erstellt. Stellen Sie sich vor, während wir all das
erledigen, findet jemand anderes Ihren Bug über die Suchfunktion von Bugzilla
und möchte den Bug weiter verfolgen. Er kann das tun, indem er seine Email in
das Add CC Feld des Bugs einträgt, wie unten gezeigt. Sie können mit dieser
Methode auch andere Bugs verfolgen.
</p>

<figure link="/images/docs/bugzie-add-email.png" caption="Hinzufügen einer Email zu CC:"/>

<note>
Emailadressen müssen bei Gentoo Bugzilla registriert sein. Um mehrere Adressen
dem CC hinzuzufügen, genügt es, sie mit Kommata oder Leerzeichen zu trennen.
</note>

<p>
Während all dieser Arbeit kann der Bug verschiedene Statuskennzeichnungen
durchlaufen. Das wird normalerweise durch die Gentoo Entwickler erledigt, aber
manchmal auch durch den Ersteller. Die folgenden sind die verschiedenen
möglichen Stati, die ein Bug während seiner Existenz durchlaufen kann.
</p>

<ul>
  <li>
    UNCONFIRMED - Sie werden diesen Fall nicht so oft erleben. Das bedeutet,
    dass der Ersteller des Bugs ihn mit Hilfe der fortgeschrittenen Methode
    erstellt hat und sich nicht sicher ist, ob sein Bug tatsächlich auch einer
    ist.
  </li>
  <li>
    NEW - Bugs werden, wenn sie erstellt werden, zuallererst als neu gelistet.
  </li>
  <li>
    ASSIGNED - Wenn die Person, der Sie den Bug zugeteilt haben, ihn validiert,
    wird er oftmals den Status ASSIGNED bekommen, während versucht wird, den Bug
    zu lösen. Das lässt Sie wissen, dass Ihr Bug als tatsächlicher Bug
    angenommen wurde.
  </li>
  <li>
    REOPENED - Jemand hat den Bug gelöst und Sie glauben die Lösung ist nicht
    praktikabel oder das Problem existiert weiterhin. Dann können Sie den Bug
    neu öffnen. Bitte <b>missbrauchen Sie das nicht</b>. Wenn ein Entwickler
    einen Bug das zweite oder dritte Mal schließt, ist es wahrscheinlich, dass
    Ihr Bug wirklich erledigt ist.
  </li>
  <li>
    RESOLVED - Eine bedeutende Entscheidung bezüglich des Bugs wurde getroffen.
    Normalerweise geht sie mit FIXED einher, um anzuzeigen, dass der Bug gelöst
    und der Fall geschlossen ist, auch wenn verschiedene andere Lösungen möglich
    sind. Wir werden uns damit etwas später noch beschäftigen.
  </li>
  <li>
    VERIFIED - Die Maßnahmen um den Bug zu reproduzieren sind korrekt. Betrifft
    normalerweise die QS (QA).
  </li>
  <li>
    CLOSED - Bedeutet im Grunde genommen für den Bug "Ruhe in Frieden" und er
    wird unter der nicht endenden Flut neuer Bugs begraben.
  </li>
</ul>

<p>
Kurz darauf finden wir den Fehler im strace-Log, lösen den Bug, markieren
ihn als RESOLVED FIXED und vermerken, dass es eine Änderung in dem Ort der
Konfigurationsdateien gab und dass ich das Ebuild mit einer Warnung
diesbezüglich updaten werde. Der Bug ist nun gelöst und Sie bekommen folgendes
zu sehen:
</p>

<figure link="/images/docs/bugzie-reso.png" caption="Gelöste Bugs"/>

<p>
Weiter unten sehen Sie dies:
</p>

<figure link="/images/docs/bugzie-options.png" caption="Bug Optionen"/>

<p>
Das gibt Ihnen die Möglichkeit, wenn Sie wollen, den Bug neu zu öffnen (z.B.
weil die Entwickler glauben, er wäre gelöst, aber die Lösung eigentlich nicht
Ihren Erwartungen entspricht). Unser Bug ist jetzt gelöst! Es können jedoch
verschiedene Arten von Lösungen auftreten. Hier ist eine kleine Liste:
</p>

<ul>
  <li>
    FIXED - Der Bug ist gelöst, folgen Sie den Anweisungen, um Ihre Probleme zu
    lösen.
  </li>
  <li>
    INVALID - Sie haben etwas ausdrücklich Dokumentiertes nicht gemacht und
    dadurch den Bug ausgelöst.
  </li>
  <li>
    DUPLICATE - Sie haben sich nicht an diese Anleitung gehalten und einen
    schon vorhandenen Bug noch einmal erstellt.
  </li>
  <li>
    WORKSFORME - Entwickler oder zugeordnete Personen können den Fehler nicht
    reproduzieren.
  </li>
  <li>
    CANTFIX - Der Bug kann aus bestimmten Umständen nicht gelöst werden. Diese
    Umstände werden von der Person, die sich um den Bug kümmert, notiert.
  </li>
  <li>
    WONTFIX - Dies wird normalerweise bei Anfragen nach neuen Ebuilds oder
    Feature-Requests gesetzt. Im Wesentlichen will der Entwickler ein
    bestimmtes Feature nicht hinzufügen, weil es entweder nicht gebraucht wird,
    eine bessere Alternative existiert oder einfach nur kaputt ist. Manchmal
    wird Ihnen eine Lösung mitgeteilt, wie Sie mit der Sache umgehen können.
  </li>
  <li>
    UPSTREAM - Der Bug kann nicht vom Gentoo Entwickler-Team gelöst werden und
    Sie werden gebeten, das Problem Upstream (die Leute die eigentlich das
    Programm erstellt haben) anzusprechen. Upstream hat verschiedene Wege mit
    Bugs umzugehen. Diese enthalten Mailinglisten, IRC-Channels und manchmal
    auch Bugreporting-Systeme. Wenn Sie sich nicht sicher sind, wie Sie Upstream
    erreichen können, fragen Sie im Bugreport nach und jemand wird Sie in die
    richtige Richtung stoßen.
  </li>
</ul>

<p>
Manchmal wird ein Entwickler Sie bitten, ein aktualisiertes Ebuild zu testen,
bevor der Bug als gelöst markiert werden kann. Im nächsten Kapitel werden wir
einen Blick darauf werfen, wie man Ebuilds testet.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Ebuilds testen</title>
<section>
<title>Holen der Dateien</title>
<body>

<p>
Nehmen wir an, Sie haben einen Bug für den foobar2 Compile-Fix von vorhin
gemeldet. Jetzt könnten Entwickler herausfinden, wo das Problem liegt und
brauchen möglicherweise Ihre Hilfe, um zu sicherzustellen, dass das Ebuild auch
für Sie funktioniert:
</p>

<figure link="/images/docs/bugzie-ebuild-request.png" caption="Ebuild Testanfrage"/>

<p>
Einige eher verwirrende Vokabeln werden hier benutzt. Als erstes sehen wir uns
an, was ein Overlay ist. Ein Overlay ist ein besonderes Verzeichnis, wie
<path>/usr/portage</path>, mit dem Unterschied, dass wenn Sie <c>emerge
sync</c> benutzen, Dateien darin nicht gelöscht werden. Glücklicherweise wird
dazu ein spezielles Verzeichnis <path>/usr/local/portage</path> erstellt.
Lassen Sie uns fortfahren und unser Portage Overlay in
<path>/etc/make.conf</path> eintragen. Öffnen Sie make.conf in Ihrem
Lieblingseditor und fügen Sie gegen Ende folgendes ein.
</p>

<pre caption="Einrichten von PORTDIR_OVERLAY">
PORTDIR_OVERLAY="/usr/local/portage"
</pre>

<p>
Jetzt wollen wir die entsprechenden Verzeichnisse erstellen und die Dateien
unseres Test-Ebuilds hinzufügen. In diesem Fall müssen wir die Dateien in das
Verzeichnis sys-apps/foobar2 packen. Sie werden feststellen, dass der zweite
Kommentar nach einem Verzeichnis <path>files</path> für den Patch fragt. Dieses
Verzeichnis enthält andere benötigte Dateien, die nicht im Standardquellarchiv
enthalten sind (Patches, init.d-Skripte, usw). Das ist ein Unterverzeichnis im
Paketverzeichnis mit dem Namen <path>files</path>. Fahren Sie fort und erstellen
Sie dieses Verzeichnis:
</p>

<pre caption="Erstellen des Kategorie- und Paketverzeichnis">
# <i>mkdir -p /usr/local/portage/sys-apps/foobar2/files</i>
</pre>

<note>
Das -p in dem mkdir-Befehl erstellt nicht nur das gewünschte Verzeichnis,
sondern auch alle fehlenden Oberverzeichnisse (in diesem Fall sys-apps und
foobar2).
</note>

<p>
Ok, jetzt können wir fortfahren und die Dateien herunterladen. Als erstes laden
Sie das Ebuild nach <path>/usr/local/portage/sys-apps/foobar2</path> herunter,
und danach den Patch nach
<path>/usr/local/portage/sys-apps/foobar2/files</path>. Jetzt, da wir alle
benötigten Dateien haben, können wir mit dem Testen des Ebuilds anfangen.
</p>

</body>
</section>
<section>
<title>Testen des Ebuilds</title>
<body>

<p>
Der Prozess um ein Ebuild zu erstellen, das durch emerge genutzt werden kann,
ist ziemlich einfach. Sie müssen eine Manifest-Datei für das Ebuild erstellen.
Das kann mit dem ebuild-Befehl gemacht werden. Starten Sie ihn wie hier
gezeigt:
</p>

<pre caption="Erstellen der Manifest-Datei">
# <i>ebuild foobar2-1.0.ebuild manifest</i>
&gt;&gt;&gt; Creating Manifest for /usr/local/portage/sys-apps/foobar2
</pre>

<p>
Jetzt testen wir, ob es wie erwartet funktioniert.
</p>

<pre caption="Testen mit emerge -pv">
# <i>emerge -pv foobar2</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] sys-apps/foobar2-1.0  0 kB [1]

Total size of downloads: 0 kB
Portage overlays:
 [1] /usr/local/portage
</pre>

<p>
Es sieht aus, als hätte es funktioniert! Sie werden die [1] neben der
[ebuild]-Zeile bemerkt haben. Diese zeigt auf <path>/usr/local/portage</path>,
was das vorhin erstellte Overlay ist. Jetzt fahren Sie fort und emergen das
Paket.
</p>

<pre caption="Ergebnis von emerge">
# <i>emerge foobar2</i>
 Calculating dependencies ...done!
<comment>(compile info ausgeschnitten)</comment>
>>> Unpacking foobar2-1.0.tar.bz2 to /var/tmp/portage/foobar2-1.0/work
 * Applying foobar2-1.0-Makefile.patch ...                                    [ ok ]
<comment>(compile info ausgeschnitten)</comment>
>>> Merging sys-apps/foobar2-1.0 to /
>>> chris +sandbox(preinst)
--- /usr/
--- /usr/bin/
>>> /usr/bin/foobar2
</pre>

<p>
Im ersten Abschnitt sehen wir, dass der Emergevorgang wie gewünscht startet.
Der zweite Abschnitt zeigt, durch die Statusmeldung "[ ok ]" am rechten Rand,
dass unser Patch erfolgreich angewandt wurde. Der letzte Abschnitt sagt uns,
dass das Programm fehlerfrei kompiliert wurde. Unser Patch funktioniert! Jetzt
können wir dem Entwickler mitteilen, dass sein Patch funktioniert und er den
Fix in Portage einspielen kann.
</p>

</body>
</section>
<section>
<title>Fazit</title>
<body>

<p>
Das schließt dieses Howto bezüglich der Arbeit mit Bugzilla ab. Ich hoffe, Sie
fanden es hilfreich. Wenn Sie Fragen, Kommentare oder Anregungen zu diesem
Dokument haben, senden Sie diese (auf Englisch) bitte an mich unter
<mail>chriswhite@gentoo.org</mail>. Besonderer Dank geht an moreon für seine
Anmerkungen bezüglich des -g Flags und Kompilierfehler, die Leute in
#gentoo-bugs für Ihre Hilfe mit dem Bug-Wrangling, Griffon26 für seine
Anmerkungen bezüglich maintainer-needed, robbat2 für allgemeine Vorschläge und
fox2mike für die Korrektur des Dokuments und das Hinzufügen von Inhalten.
</p>

</body>
</section>
</chapter>
</guide>
