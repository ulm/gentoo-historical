<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/Attic/portage-manual.xml,v 1.19 2004/10/28 18:16:25 dertobi123 Exp $ -->

<!-- English CVS Version: 1.37 -->

<guide link = "/doc/de/portage-manual.xml">
<title>Portage Leitfaden</title>
<author title="Author and Editor">
  <mail link="blocke@shivan.org">Bruce A. Locke</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Editor">
  <mail link="g.guidi@sns.it">Gregorio Guidi</mail> 
</author>
<author title="Übersetzer">
  <mail link="sebastian@beneke-it.de">Sebastian Beneke</mail>
</author>
<author title="Übersetzer">
  <mail link="jazz_rabbit@berlios.de">Erwin Hengl</mail>
</author>
<author title="Übersetzer">
  <mail link="kontakt@hendrik-brandt.de">Hendrik Brandt</mail>
</author>
<author title="Korrektur">
  <mail link="pylon@gentoo.org">Lars Weiler</mail>
</author>
<author title="Korrektur">
  <mail link="dertobi123@gentoo.org">Tobias Scherbaum</mail>
</author>
<author title="Übersetzer">
  <mail link="hendrik@grahli.net">Jan Hendrik Grahl</mail>
</author>


<abstract>
Dieses Handbuch liefert einen generellen Überblick über Portage,
detaillierte Informationen, sowie eine Anleitung zur Installation und
Pflege von Paketen des Portage Systems.
</abstract>

<license/>

<version>0.12</version>
<date>2. Oktober 2004</date>

<chapter>
<title>Portage: Ein Überblick</title>
<section>
<title>Überblick</title>
<body>
 
<warn>
Der Inhalt dieses Dokuments wurde in das <uri
 link="/doc/de/handbook/handbook-x86.xml?part=2">Gentoo Handbuch</uri> 
 verschoben. Daher ist dieses Dokument nun überholt und nur aus historischen 
 Gründen noch verfügbar. Bitte verwenden Sie stattdessen das 
 <uri link="/doc/de/handbook/handbook-x86.xml?part=2">Gentoo Handbuch</uri>. 
 Wenn Sie der Meinung sind, dass dem <uri
 link="/doc/de/handbook/handbook-x86.xml?part=2">Gentoo Handbuch</uri> 
 entscheidende Informationen fehlen, dann bitten wir Sie einen 
 <uri link="http://bugs.gentoo.org">Bugreport</uri> zu verfassen.
 </warn>
 
<p>
Portage ist ein sehr mächtiges und fortgeschrittenes
Paket-Management-System.  Seine Flexibilität und Fähigkeit als einfaches
Werkzeug zum Kompilieren von Software oder als Herzstück einer
brandaktuellen Linux Distribution zu dienen, ist nahezu einzigartig. Die
Gentoo Linux Distribution wurde um Portage herum entwickelt.
</p>

<p>
Gentoo Linux wird oftmals als "Meta-Distribution" bezeichnet. Gentoo
besteht aus Portage und über 8000 Anleitungen zum Kompilieren von
Paketen, sogenannten <e>ebuilds</e>. Diese <e>ebuilds</e> geben Portage
die Anweisungen wie ein bestimmtes Softwarepaket kompiliert und
installiert werden soll. Durch die Information gespeichert in einem 
<e>Profil</e> und den Direktiven, die an das Kommandozeilen Programm 
<e>emerge</e> übergeben werden können Benutzer und Entwickler
Portage dazu nutzen um die Pakete, aus denen das System besteht, zu 
installieren und zu pflegen - von den Kernkomponenten bis zu den komplexesten 
Anwendungen.
</p>

<p>
Ein Gentoo Linux wird "on-the-fly" kompiliert, d.h. direkt auf den
entsprechenden Rechner angepasst und erstellt. Um Gentoo Linux zu 
instalieren, wird nicht mehr benötigt als ein funktionierender Compiler und
eine passende Erstellungsumgebung, in der Portage Quellcode aus dem Internet 
herunterladen kann und den Rest des Systems erstellen kann. Portage 
unterstützt auch vorgefertigte Binärpakete aber der Hauptzweck dieser ist die 
Installation auf langsamen Maschinen zu verkürzen und nicht um 
Softwareupdates in Umlauf zu bringen: durch den Portage Tree können Entwickler 
auf eine sehr schnelle und einfache Art und Weise neue Software den Benutzern 
zur Verfügung stellen. Binärpakete können auch verwendet werden um die 
Installation einer Anwendung schnell zu replizieren oder Software an einen 
Cluster von Maschinen zu verteilen.
</p>

<p>
Wegen diesen Eigenschaften und der Tatsache, dass Portage extrem 
konfigurierbar ist in Bezug auf die Art wie es Pakete kompiliert und 
installiert, sind nur sehr wenige Gentoo Linux Installationen identisch. Im 
Grunde wird bei der Installation von Gentoo Linux eine angepasste Linux
Distribution erstellt, die sich an den Optionen orientiert die der Benutzer 
spezifiziert hat.
</p>

<p>
Auf den ersten Blick mag die Idee hinter Portage ähnlich dem BSD
Ports System sein.  Beide kompilieren Pakete aus den Sourcen und
erlauben dem Benutzer Software sicher zu installieren bzw. zu
deinstallieren.  Und beide lösen Abhängigkeiten automatisch auf.  Viele
Ideen von Portage wurden beim BSD Ports System ausgeliehen, jedoch
handelt es sich bei Portage definitiv nicht um eine weitere
"Ports-Kopie".
</p>

<p>
Das Portage System ist eine Verbindung aus einem auf Python
basierenden Kern und auf Bash Scripten basierten <e>ebuilds</e>.
Anstatt mit Makefiles und dem <c>make</c> Kommando zu hantieren,
verbindet Portage die Möglichkeiten von Python und das einfach zu
handhabende Shellscripting mit einigen objektbasierten Eigenschaften, um
ein einzigartig mächtiges System zu erstellen. Dieses setzt Portage an
die Spitze aller aktuellen Ports Systeme.
</p>

<p>
Einige der von Portage angebotenen erweiterten Funktionen sind die
Möglichkeit verschiedene Versionen und Überarbeitungen des gleichen
Pakets zu halten, Auflösung der entsprechenden Abhängigkeiten,
feinstrukturiertes Paketmanagement, sichere Installation via Sandbox,
Schutz von bestehenden Konfigurationsdateien, Profile und vieles mehr.
Viele dieser Funktionen werden noch im Laufe dieses Handbuches genauer
erläutert.
</p>

</body>
</section>
<section>
<title>Umgebungsabhängige Auflösung von Abhängigkeiten und Slots</title>
<body>

<p>
Portage, as any other package management system, can resolve dependencies;
but one feature that makes it different is the fact that it also supports
conditional dependencies.  Portage has a powerful concept called the
<e>USE setting</e>.  By changing one variable in a Portage configuration
file you can disable optional support (and thus the need to depend on it)
for particular features or libraries at compile time. This is a very
flexible and powerful system which is further explained in the next chapter.
</p>

<p>
In addition Portage supports the concept of <e>SLOT</e>s.  Working on
Gentoo Linux its developers often found that they needed to have multiple
versions of certain packages (such as libraries) installed to satisfy the
demands of other packages. The traditional approach to this problem has
been to treat different versions of the same package as different packages
with slightly different names.
</p>

<p>
Instead of treating certain versions as separate packages, the developers
taught Portage how to handle and maintain several versions of the same package
through the use of <e>SLOT</e>s.  An example comes from the common library
known as freetype.  The 1.x branch of freetype is incompatible with the 2.x
branch but both versions are needed to satisfy the dependencies of various
packages.  Most distributions and ports systems tend to have a "freetype"
package for freetype 1.x and "freetype2" for 2.x.  We consider this approach
a sign of a fundamentally broken package management system.  We simply assigned
the <c>SLOT</c> number 1 to the first and number 2 to the second.  With 
this information Portage can track both versions and upgrade them if updates
to the respective upstream branches are made.
</p>

<p>
Currently, slots cannot be used to install multiple instances of the same
version of a package.  When it will be possible, one could even install the
same version of gcc multiple times (for instance to build cross-compilers for
different architectures). 
</p>

<p>
There are other areas where the support for slots can improve. At the moment
Portage is not able to automatically work out if different versions of a
package can coexist, it must be explicited in ebuilds.  Sometimes Portage
forces users to upgrade their applications to the most recent version even if
the version they have installed is in a different slot.  Moreover, for those
who write ebuilds it is not possible to express the dependency on a specific
slot of a package.
</p>

</body>
</section>
<section>
<title>Profile</title>
<body>

<p>
Ein Profil enthält eine Liste von Paketnamen und einen Satz von Standard 
Konfigurationsoptionen, die von Portage verwendet werden sollen. Diese 
Dateien sagen Portage welche Pakete und welche spezifischen Versionen 
dieser Pakete erlaubt, verweigert oder wie benötigt behandelt werden müssen. 
Benutzer können Profile wechseln einfach durch die Veränderung eines einzelnen 
symbolischen Links (<path>/etc/make.profile</path>). 
</p>

<p>
Ein Profil definiert welche Pakete "Kern" Pakete sind und notwendig sind 
für die Funktion des Systems. Es erlaubt Entwicklern auch spezifische 
Pakete und Versionen zu blockieren oder zu entblockieren um temporär 
nicht funktionierende Pakete auszuklammern und ähnliches. Mit den 
Informationen im Profil kann Portage wählen, welche Ebuild Dateien tatsächlich 
verwendet werden sollen um die Hauptkomponenten des Systems zu erstellen 
und zu installieren.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Portage konfigurieren</title>
<section>
<title>Überblick</title>
<body>

<p>
Dieses Kapitel soll verschiedene Aspekte der Konfiguration von
Portage abdecken, die für Benutzer wie Entwickler wichtig sind.  Portage
ist ein sehr flexibles System und Sie müssen verstehen, wie man Portage
richtig konfiguriert, um Ihr System genau auf Ihre Bedürfnisse abstimmen
zu können.
</p>

<p>
Bitte beachten Sie, dass in diesem Dokument der Begriff "Benutzer"
Personen mit administrativen Rechten definiert. Um die Portage
Konfiguration zu ändern und neue Pakete zu installieren bzw. zu
entfernen benötigen Sie Root-Rechte.
</p>

</body>
</section>
<section>
<title>Portage Konfigurations Dateien</title>
<body>

<p>
Fast alle Konfigurations-Optionen sind definiert in einfachen Variablen, 
diese finden sich in <path>/etc/make.conf</path>, 
<path>/etc/make.conf.example</path>,<path>/etc/make.profile/make.defaults</path>
 und <path>/etc/make.globals</path>.  Portage wird als erstes die Werte, 
 definiert durch die momentane Umgebungsvariablen, verwenden. Wenn keine 
 Einstellung gefunden wurde wird Portage <path>/etc/make.conf</path> 
 überprüfen. Wenn diese dort nicht gefunden werden. wird Portage
 <path>/etc/make.profile/make.defaults</path> überprüfen. Wenn bis jetzt 
 diese noch nicht definiert sind, dann werden die Standardeinstellungen von 
 <path>/etc/make.globals</path>. verwendet. Beachten Sie bitte, dass alle 
 Benutzereinstellungen in der Umgebung oder <path>/etc/make.conf</path> 
 vorgenommen werden sollten, diese Datei ist zur Anpassung vorgesehen.  
 Es ist wichtig anzumerken, dass jede Einstellung die in 
 <path>/etc/make.conf</path> gesetzt ist, wird so gut wie immer jede 
 Einstellung in <path>/etc/make.globals</path> aufhebt. Soweit es Portage 
 betrifft, kann alles in <path>/etc/make.conf</path> und 
 <path>/etc/make.globals</path> als systemweite globale Einstellung angesehen 
 werden.
</p>

<p>
Das Verhalten von Portage wird auch durch den Inhalt einiger Dateien 
beeinflusst. Diese Dateien sind optional, Portage wird die Existenz dieser 
prüfen und in einigen Fällen sie in Betracht ziehen. Wir werden einige dieser 
Dateien, wie <path>/etc/portage/package.use</path> und
<path>/etc/portage/package.keywords</path>, später in diesem Leitfaden 
behandeln. Für weitere Informationen führen Sie bitte <c>man portage</c> aus: 
Die Portage Anleitungsseite beinhaltet detaillierte Beschreibungen für alle 
diese Dateien.
</p>

</body>
</section>
<section>
<title>USE Einstellungen</title>
<body>

<p>
Das USE-System ist eine flexible Möglichkeit, um sämtliche Features,
direkt beim Kompilierprozess von Gentoo Linux oder später für einzelne
Pakete ein- bzw. auszuschalten.  Dies erlaubt eine Administrierbarkeit,
wie die Pakete in Verbindung mit den angegebenen Features in der
USE-Variable, kompiliert werden.  Zum Beispiel, wenn ein Paket
Unterstützung für GNOME bietet, können Sie diese abschalten, indem Sie
in der USE-Variable <c>-gnome</c> angeben.  Wenn Sie jedoch die
GNOME-Unterstützung für das Paket aktivieren wollen, dann setzen Sie in
der USE-Variable <c>gnome</c> ein.
</p>

<p>
Der Effekt der USE Flags auf Pakete ist abhängig davon, ob die
Software und das ebuild Paket selbst, das jeweils gesetzte USE Flag
unterstützten. Wenn dem nicht so ist, so bewirkt auch das jeweilige USE
Flag nichts an der Software. Auch werden einige Paketabhängigkeiten bei
mancher Software nicht als optional angesehen, dadurch haben gesetzte
USE Flags keine Auswirkung auf diese vorgeschriebenen Abhängigkeiten.
Die Liste der USE Schlüsselwörter, welche die Kompilierung und Installation 
eines Paketes beeinflussen können Betrachtet werden indem man den 
<c>emerge </c> Befehl mit dem <c>--verbose</c> Flag und <c>--pretend</c> 
zusammen ausführt (Siehe <uri link="#doc_chap3_sect2">Einbinden von 
Paketen</uri> in <uri link="#doc_chap3">Paket Management</uri>). Um zu sehen, 
was jedes einzelne Flag im Detail tut können Sie den <c>equery</c> Befehl (in
<c>app-portage/gentoolkit</c>) verwenden.
</p>

<p>
Die komplette Liste von globalen USE Einstellungen, welche von Gentoo Linux 
verwendet werden, finden sich in <path>/usr/portage/profiles/use.desc</path>. 
Von Zeit zu Zeit kann es vorkommen, dass ein Ebuild von USE Einstellungen 
beeinflusst wird, welche spezifisch für das einzelne Paket sind und nicht in 
<path>use.desc</path> vorhanden sind. Diese Einstellungen werden lokale 
USE Flags genannt und sind aufgelistet in 
<path>/usr/portage/profiles/use.local.desc</path>.
</p>

<p>
Portage bestimmt, welche USE Flags ein- bzw. ausgeschaltet sind
aufgrund einer Überprüfung der USE Variable an  vier verschiedenen Stellen, 
sowie unter der Betrachtung der Einträge in 
<path>/etc/portage/package.use</path>, wenn
vorhanden. Diese Stellen bewirken, dass die USE Flags, die
dort definiert sind, "aufgestapelt" werden.  Es durchforstet jede
einzelne Stelle und merkt sich jedes USE Flag der früheren Stellen, ob
sie ein- bzw. ausgeschaltet sind und fügt neu gefundene Features hinzu,
so dass es eine lange USE Variable ergibt.  Wird zum Beispiel ein
Feature an einer früheren Stelle abgeschaltet und an der aktuellen
Stelle, die Portage durchforstet, eingeschaltet, so wird das Feature
trotz Abschaltens an der früheren Stelle wieder eingeschaltet.
</p>

<p>
Die Berechnung der aktivierten Variablen von USE Einstellungen und die 
Reihenfolge in der Portage sie überprüft ist in der Variable <c>USE_ORDER</c> 
in <path>/etc/make.globals</path> angegeben. Um eine Variable
ausschalten entfernen Sie diese einfach in <c>USE_ORDER</c>.
</p>

<p>
Die folgenden Absätze beschreiben jeden Ort, der in <c>USE_ORDER</c>
mit der Portage Standard Konfiguration definiert wurde.
</p>

<p>
<b>Defaults</b>
</p>

<p>
Portage Profile können einen Satz von Standard USE Flags beinhalten.
Diese Standard Features sind bei jedem Profil dabei und werden in der
Datei <path>make.defaults</path> angegeben. Da
<path>/etc/make.profile</path> als eine Verknüpfung zum aktuell
benutzten Portage Profil fungiert, ist der Satz an standard USE Flags
des aktuellen Profils die Datei
<path>/etc/make.profile/make.defaults</path>. Es ist nicht zu empfehlen
Änderungen in dieser Datei vorzunehmen, da zukünftige Profiländerungen
sie wieder überschreiben würden.
</p>

<p>
<b>Auto</b>
</p>

<p>
Diese Pakete sind in der Datei <path>use.defaults</path> im Portage
Profil (<path>/etc/make.profile/use.defaults</path>) definiert. Jeder
Eintrag beinhaltet eine USE Flag Bezeichnung und das dazugehörende
Paket.  Wenn das für ein USE Flag angegebene Paket installiert ist,
wird das Feature als eingeschaltet Betrachtet.  Wenn Sie zum Beispiel
das Paket <c>dev-db/mysql</c> installieren und das <e>mysql</e> USE Flag an 
späterer Stelle nicht explizit abgeschaltet wird, dann wird das <e>mysql</e> 
Schlüsselwort global eingeschaltet, solange das Paket installiert ist.  Es ist 
nicht zu empfehlen, diese Datei zu bearbeiten da zukünftige 
Profiländerungen, diese überschreiben würden.
</p>

<p>
<b>Conf</b>
</p>

<p>
Wenn eine <c>USE</c> Variable in <path>/etc/make.conf</path> definiert ist,
werden die <c>USE</c> Flags, die in jener Variable angegeben wurden, verwendet.
Wenn es keine USE Variable in <path>make.conf</path> gibt, dann wird
<path>/etc/make.globals</path> überprüft. Solch ein Eintrag könnte wie
folgt aussehen:
</p>

<pre caption="Beispielhafte USE Variable">
USE="slang readline gpm berkdb gdbm tcpd pam libwww ssl gb tk
lm_sensors lvm ldap tex bonobo sdl gtk xfs evo pda ldap
mmx mitshm perl python guile ruby postgres dvd 3dnow tcl
lcms gif sdl vorbis ogg oss libg++ directfb decss snmp
gnome X opengl mozilla pdflib gpg -nls gd xface jpilot
-kde -qt -esd -motif -alsa oggvorbis"
</pre>

<p>
USE Flags werden eingeschaltet, indem Sie einfach in der USE Variable
angegeben werden. USE Flags können jedoch auch mittels Negation durch
ein <c>-</c> (Minus) vor dem Feature-Namen deaktiviert werden.  Zum
Beispiel schaltet <c>gnome</c> GNOME Support ein, während <c>-motif</c>
den MOTIF Support abschaltet.
</p>

<p>
Die <c>USE</c> Variable in <path>/etc/make.conf</path> ist der empfohlene
Ort, wo Sie USE Flags ein- bzw. ausschalten. Diese Datei wird nicht
automatisch von Portage überschrieben. Es wird empfohlen, dass Sie hier
die USE Flags eintragen, die nicht von den vorangehenden Stellen ein
bzw. ausgeschaltet werden sollen.
</p>

<p>
<b>Env</b>
</p>

<p>
Die USE Flags kann man von Hand aus mit seiner eigenen Shell
Umgebungsvariable überschreiben.
</p>

<pre caption="USE Flags temporär setzen">
# <i>export USE="-gnome"</i>
# <i>emerge net-im/gaim</i>

<comment>oder</comment>

# <i>USE="-gnome" emerge net-im/gaim</i>
</pre>

<p>
Dies erlaubt die Benutzung von speziellen USE Flags für ein oder
mehrere Pakete.  Diese von Ihnen per Hand definierten USE Flags bleiben
bestehen, solange Sie in jener Shell Umgebung damit arbeiten.  Verlassen
Sie Ihre Umgebung ("exit"), ist auch das von Hand gesetzte USE Flag
weg.
</p>

<note>
Das spezielle Flag <c>-*</c> kann verwenet werden um alle USE Einstellungen 
zu deaktivieren. Zum Beispiel <c>USE="-* ssl"</c> in der 
Kommandozeile oder in <path>/etc/make.conf</path> zu setzen hat den 
Effekt, das jede USE Einstellung bis auf <c>ssl</c> ausgeschaltet wird.
</note>

<p>
Beachten Sie, dass wen das Paket erneut mit emerge in der Zukunft installiert 
wird, dann wird es die dann momentan aktuellen USE Einstellungen verwenden und 
nicht die, welche definiert wurden, als es das erste mal mit emerge installiert 
wurde. Um eine USE Einstellung relativ zu einem spezifischen Paket konsequent 
zu spezifzieren, können Sie einen Eintrag, wie im unten gezeigten Biespiel, in 
<path>/etc/portage/package.use</path> vornehmen. Dieser Eintrag wird 
sicherstellen, dass jedes Mal wenn <c>net-im/gaim</c> erstellt wird, die 
<c>gnome</c> Einstellung deaktiviert ist.
</p>

<pre caption = "Verwendung von /etc/portage/package.use">
<comment>Fügen Sie diese Zeile  /etc/portage/package.use hinzu:</comment>
net-im/gaim -gnome
</pre>

</body>
</section>
<section>
<title>Compiler Optionen</title>
<body>

<p>
Die Compiler Optionen, welche von Portage zum kompilieren von Paketen
genutzt werden, können in <path>/etc/make.conf</path> gesetzt werden
indem <c>CHOST</c>, <c>CFLAGS</c> und <c>CXXFLAGS</c> editiert werden.
Die <c>CHOST</c> Einstellung gibt an, auf welcher Plattform Sie
kompilieren.  <c>CFLAGS</c> und <c>CXXFLAGS</c> geben Compiler
Einstellungen für C bzw. C++ an.
</p>

<p>
Es werden Ihnen einige kommentierte Standard Einstellungen für
unterschiedliche Plattformen angeboten. Diese Einstellungen können als
getestet und stabil angesehen werden. Diese zu ändern, könnte zu Fehlern
in der Software und dem Compiler führen. Bitte seien Sie beim Ändern der
Standard Einstellung vorsichtig, da sie zu einem unbenutzbaren bzw.
beschädigten System führen können.
</p>

<p>
Benutzer eines Multiprozessor Systems können einige Vorteile
erhalten, indem sie in <path>/etc/make.globals</path> die Option
<c>MAKEOPTS</c> editieren. Diese Option wird während des
Kompilierungsvorganges an <c>make</c> übergeben um mehrere <c>gcc</c>
Instanzen zu aktivieren.</p>

</body>
</section>
<section>
<title>Lage der Verzeichnisse</title>
<body>

<p>
Portage erlaubt es Ihnen zu bestimmen in welchen Verzeichnissen
Pakete kompiliert und verschiedene Dateien gespeichert werden sollen.
Die meisten Benutzer werden diese Optionen nicht benötigen. Folgende
Optionen können genutzt werden:
</p>

<ul>
  <li>
    <c>PORTDIR</c> - Position des Portage Trees
  </li>
  
  <li>
    <c>DISTDIR</c> - Lokaler Cache der runtergeladenen Pakete
  </li>
  
  <li>
    <c>PKGDIR</c> - Ort der lokal erzeugten tbz2 Pakete
  </li>
  
  <li>
    <c>PORTAGE_TMPDIR</c> - Temporärer Platz zum Kompilieren der Pakete
  </li>
  
  <li>
    <c>PORT_LOGDIR</c> Ort der Protokolldateien von individuellen Mergen 
    speichert. Protokollierung ist deaktiviert, wenn die Variable nicht 
    gesetzt ist.
  </li>
  
  <li>
    <c>PORTDIR_OVERLAY</c> - Ort für einen angepassten lokalen Portage Baum. 
     Portage sieth hier nach, bevor in PORTDIR gesucht wird.
  </li>
</ul>

</body>
</section>
<section>
<title>Schutz der Konfigurationsdateien</title>
<body>

<p>
Portage erlaubt den Schutz aller Konfigurationsdateien in bestimmten
Verzeichnissen. Portage wird in geschützten Verzeichnissen keine Dateien
überschreiben. Wenn ein Paket versucht, bereits existierende Dateien zu
überschreiben, wird die neue Datei nach dem Muster
<path>._cfg0000_name</path> umbenannt. Dies geschieht damit der Benutzer
später die neue Datei einsehen kann, um die Unterschiede manuell
einzufügen.
</p>

<p>
Geschützte Verzeichnisse können über <c>CONFIG_PROTECT</c> entweder
in <path>/etc/make.conf</path> oder <path>/etc/make.globals</path>
definiert werden. Bestimmte Dateien und Unterverzeichnisse unterhalb
geschützter Verzeichnisse können durch <c>CONFIG_PROTECT_MASK</c> vom
Schutz ausgenommen werden.
</p>

<p>
Das Folgende ist nur ein Beispiel und sollte nicht blind kopiert
werden:
</p>

<pre caption="Beispielhafte Angabe zum Schutz von Konfigurationsdateien">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/2/share/config"
CONFIG_PROTECT_MASK="/etc/gconf /etc/init.d /etc/pam.d"
</pre>

<p>
Benutzer können mehr Informationen über den Schutz von
Konfigurationsdateien erhalten, indem sie folgendes in ihrer Shell
eingeben:
</p>

<pre caption="Hilfe zum Schutz von Konfigurationsdateien aufrufen">
# <i>emerge --help config</i>
</pre>

</body>
</section>
<section>
<title>FEATURES</title>
<body>

<p>
Portage bietet eine ganze Menge Optionen, die auf Entwickler
abzielen, welche regeln wollen wie sich Portage verhält und nach der
Installation verschiedener Paketstufen aufräumt. Diese Optionen sollten
nur für Entwickler interessant sein. Bei Benutzern könnten sie Probleme
verursachen.
</p>

<p>
Eine Liste einzuschaltender Funktionen kann unter <c>FEATURES</c>
entweder in <path>/etc/make.conf</path> oder
<path>/etc/make.globals</path> gesetzt. Hier eine Liste
der wichtigsten Optionen, siehe <path>/etc/make.conf.example</path> für Details:
</p>

<ul>
  <li><c>buildpkg</c> : Erstellt Binärpakete für jedes Paket, das Sie emergen.</li>
  <li>
    <c>ccache</c> : Aktiviert Unterstützung für Compiler Cache, wenn 
    <c>dev-util/ccache</c> installiert ist.
  </li>
  <li>
    <c>collision-protect</c> : Verursacht, das Portage fehlschlägt, wenn ein
    Paket versucht eine Datei, welche zu einem anderen Paket oder gar keinem 
    Paket gehört, zu überschreiben.
  </li>  
  <li><c>digest</c> : Erstellt automatisch einen Digest für neue Ebuilds.</li>
  <li>
    <c>distcc</c> : Verwendet die verteilte Kompilierung, welche von 
    <c>sys-devel/distcc.</c> angeboten wird.
  </li>
  <li><c>keeptemp</c> : Entfernt nicht die temporären Dateien nach dem mergen.</li>
  <li>
    <c>keepwork</c> : Entfernt nicht die Quelldateien ,welche zur Kompilierung 
    verwendet wurden.
  </li>
  <li><c>noauto</c> : Führt keine wichtigen Ebuild Schritte automatisch aus.</li>
  <li><c>noclean</c> : Portage räumt nach dem Kompilieren nicht auf.</li>
  <li><c>nostrip</c> : Binärdateien werden nicht entschlackt.</li>
  <li><c>notitles</c> : Deaktiviert Aktualisierungen der xterm Titelleiste</li>
  <li><c>sandbox</c> : Aktiviert das Sandboxverfahren.</li>
  <li><c>strict</c> : Strikt sein, wenn das Digest und Manifest überprüft werden.</li>
  <li><c>userpriv</c> : Kompiliert nicht mit root-Privilegien.</li>
  <li><c>usersandbox</c> : Benutzt eine Sandbox, wenn <c>userpriv</c> aktiviert ist.</li>
</ul>

</body>
</section>
<section>
<title>Portage SYNC Einstellungen</title>
<body>

<p>
Portage bietet die Möglichkeit den Portage Tree mittels rsync oder cvs
aufzufrischen. Das zu verwendende Protokoll sowie der Server, welcher 
kontaktiert werden soll, zur Durchführung der Synchronisation sind durch 
die <c>SYNC</c> Einstellung in <path>/etc/make.conf</path> definiert.
</p>

<p>
<b>RSYNC</b>
</p>

<p>
<c>rsync</c> ist der gewöhnliche Weg Ihren Portage Tree aktuell zu
halten.  Die rsync Methode wird wie folgt in <path>/etc/make.conf</path>
gesetzt (nur ein Eintrag ist erlaubt):
</p>

<pre caption="Setzen der SYNC Variable">
SYNC="rsync://rsync.gentoo.org/gentoo-portage"
</pre>

<note>
Die rsync-Methode überschreibt blind alle Veränderungen, die an
Ihrem lokalen Portage Tree vorgenommen wurden. Falls Sie lokale
Änderungen behalten möchten, müssen Sie
<c>PORTDIR_OVERLAY="/ein/verzeichnis/fuer/Ihre/Aenderungen"</c> setzen.
</note>

<note>
Betrachten Sie <path>/etc/make.conf.example</path> für Beispiele wie man 
<c>SYNC</c> setzt so dass eine lokalisierte rsync-Mirror-Rotation verwendet wird.~
 Dies wird Server auswählen, welche geographisch näher bei Ihnen sind, was 
 normalerweise gleichbedeutend ist mit höheren Übertragungsgeschwindigkeiten. 
 Es hilft auch dabei die Auslastung über eine Merhzahl von Servern zu verteilen. 
</note>

<p>
Es gibt mehrere Variablen die beeinflussen auf welche Art Portage 
synchronisiert und die können in <path>/etc/make.conf</path> gesetzt werden:
There are a number of variables that affect the way Portage does the sync and
that can be set in <path>/etc/make.conf</path>:
</p>

<ul>
  <li>
    <c>RSYNC_RETRIES</c> - Die Anzahl von Synchronisationsversuchen, 
    bevor aufgegeben wird.
  </li>
  <li>
    <c>RSYNC_TIMEOUT</c> - Anzahl von Sekunden die gewartet werden soll, bis 
    die Verbindung wegen Zeitüberschreitung beendet wird.
  </li>
  <li>
    <c>RSYNC_EXCLUDEFROM</c> - Spezifiziert eine Datei, welche Pfade 
    auflistet, die nicht vom Rsync Server geladen werden sollen. Seien Sie 
    vorsichtig damit, denn Sie riskieren, dass  Abhhängigkeiten 
    funktionsunfähig werden.
  </li>
</ul>
<p>
<b>Entwickler CVS</b>
</p>

<p>
Entwickler mit vollem Zugang zum CVS können auch per <c>emerge</c>
den lokalen Tree mit dem CVS abgleichen lassen, welches sie mittels SSH
erreichen können.
</p>

<p>
Laden Sie einfach den CVS Tree mittels Ihres Accounts herunter
("checkout"), verschieben Sie diesen nach <path>/usr/portage</path> und
benutzen Sie folgende <c>SYNC</c> Option:
</p>

<pre caption="Den Portage Tree mittels Entwickler-CVS aktuell halten">
SYNC="cvs://Ihr_account@cvs.gentoo.org:/var/cvsroot"
</pre>

</body>
</section>
<section>
<title>Spiegelungen (Mirrors)</title>
<body>

<p>
Das Gentoo Projekt bietet eine lokale Spiegelung von allen
Quellpaketen, die in ebuilds im Portage Tree angegeben sind. Meistens
werden Source Tar-Archive auf langsamen Servern gespeichert, die
ziemlich oft ausfallen können. Auch Entwickler entfernen regelmässig
alte Versionen Ihrer Software von FTP-Servern, wenn neue Versionen
herausgegeben werden. Um das Leben von Benutzer, die die Gentoo
Distribution nutzen, zu erleichtern, spiegeln wir diese Dateien. Das
erlaubt ein schnelleres und sicheres Herunterladen der Archivdateien von
Spiegel-Servern, die näher an Ihrem Standort liegen.
</p>

<p>
Wann auch immer Sie ein Paket mergen und dazu das Quellpaket
benötigen, versucht Portage zu allererst unsere Spiegel-Server für die
angeforderten Dateien zu erreichen. Wenn sich auf diesem Server die
benötigten Dateien nicht befinden, versucht Portage den jeweiligen HTTP-
oder FTP-Server, der im ebuild angegeben ist.
</p>

<p>
Die Spiegel, welche Portage verwendet, können durch <c>GENTOO_MIRRORS</c> 
in <path>/etc/make.conf</path> (als eine durch Leerzeichen getrennte Liste) 
angegeben werden. Das Folgende ist die Standardeinstellung:
</p>

<pre caption="Deklarieren eines Spiegels">
GENTOO_MIRRORS="http://www.ibiblio.org/gentoo"
</pre>

<p>
Für einen Gentoo-Spiegel-Server in Ihrer Nähe, besuchen Sie die
Gentoo Webseite oder fragen Sie in der lokalen Mailingliste nach einem
für Sie günstigeren Server.  Das Programm <c>mirrorselect</c> überprüft
anhand von pings, welcher der für Sie am schnellsten erreichbare Server
ist und fügt optional eine Liste von Servern in die GENTOO_MIRRORS
Option in der <path>/etc/make.conf</path> ein.  Schauen Sie in die <uri
link="gentoo-x86-install.xml">Installationsanleitung</uri> für die
Benutzung von <c>mirrorselect</c>.
</p>

</body>
</section>
<section>
<title>Download-Programm</title>
<body>

<p>
Das Programm, das Portage zum Download der benötigten Dateien
verwendet, kann durch die Optionen <c>FETCHCOMMAND</c> und
<c>RESUMECOMMAND</c> angegeben werden. Einige Beispiele werden in
<path>/etc/make.conf.examples</path> und <path>/etc/make.globals</path> 
gezeigt. Als Standardprogramm verwendet Portage <c>wget</c>, welches den 
meisten Anforderungen genügen sollte.
</p>

</body>
</section>

<section>
<title>Proxies</title>
<body>

<p>
Portage kann angewiesen werden, zum Download HTTP oder FTP Proxies zu
nutzen. Die Proxies können bei den Optionen <c>HTTP_PROXY</c> und
<c>FTP_PROXY</c> entweder in <path>/etc/make.conf</path> oder in
<path>/etc/make.globals</path> angegeben werden. Auch hier sollten die
Einstellungen vorzugsweise in <path>/etc/make.conf</path> erfolgen. Wenn
HTTP und FTP über den gleichen Proxy erfolgen soll, können Sie auch
einfach die Option <c>PROXY</c> nutzen.
</p>

<p>
Im Folgenden ein Beispiel:
</p>

<pre caption="HTTP- und FTP-Proxies setzen">
HTTP_PROXY="http://192.168.1.1:8080"
FTP_PROXY="http://192.168.1.1:8080"

oder

PROXY="http://192.168.1.1:8080"
</pre>

<p>
Portage kann zusätzlich angewiesen werden einen HTTP Proxy zur
Verwendung von rsync zu nutzen. Dies kann durch die Option
<c>RSYNC_PROXY</c> in <path>/etc/make.conf</path> oder als
Umgebungsvariable aktiviert werden.
</p>

<p>
Im Folgenden ein Beispiel:
</p>

<pre caption="RSYNC-Proxy setzen">
RSYNC_PROXY="192.168.1.1:8080"
</pre>

<note>
Sollten Sie hinter einer Firewall sitzen und rsync scheint Ihren
HTTP Proxy nicht nutzen zu können, können Sie Ihren Portage Tree durch
einen Snapshot Tar-Archiv aktualisieren.  Schauen Sie in unsere <uri
link="/doc/en/faq.xml#norsync">FAQ</uri> für weitere Informationen. 
</note>

</body>
</section>
<section>
<title>Andere Optionen</title>
<body>

<p>
Die vorangegangenen erklärten Beispiele stellen nicht die gesammte Liste 
von Dingen dar, welche Sie in  <path>/etc/make.conf</path> anpassen können. 
Dies sind einige weitere Option, die nützlich für Sie sein könnten:
</p>

<ul>
  <li>
    <c>NOCOLOR</c> : Erlaubt es dem Benutzer, das Verwenden von Farben
    bei Ausgaben von emerge zu deaktivieren.
  </li> 
  <li>
    <c>CLEAN_DELAY</c> : Dadurch verzögert Portage das Entfernen von 
    Paketen, um Nutzern die Möglichkeit zum Abbruch zu geben. Diese Zeit 
    kann hier angegeben werden. Zum Abschalten der Verzögerung setzen Sie 
    den Wert auf "0".
  </li>
  <li>
    <c>PORTAGE_NICENESS</c> : Der Wert dieser Variable wird zum Nice-Wert 
    hinzugefügt, den emerge verwendet, wenn es ausgeführt wird.
  </li>
  <li>
    <c>PORTAGE_BINHOST</c> : Diese Variable speichert einen nicht lokalen Ort 
    (http oder ftp) an dem Portage versucht vorkompilierte Binärpakete zu 
    finden. Im Moment gibt es keine offiziellen Gentoo Server die binäre 
    Pakete bereitstellen.
  </li>  
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Paketmanagement</title>
<section>
<title>Aktualisieren des Portage Trees</title>
<body>

<p>
Der Portage Tree, der in <path>/usr/portage</path> liegt, enthält die
Bibliothek der "Bauanleitungen" für verschiedene Pakete (sogenannte
<c>ebuilds</c>). Darüber hinaus enthält der Tree auch noch Profil- sowie 
MaskierungsInformationen, die wichtig sind, um das System aktuell zu halten. 
Um immer die aktuellsten Versionen und neuesten Bugfixes zu haben, 
ist es wichtig den Tree regelmäßig mit dem offiziellen Tree abzugleichen. 
Sie können den Portage Tree mittels folgendem Befehl aktualisieren:
</p>

<pre caption="Den Portage Tree aktualisieren">
# <i>emerge --sync</i>
</pre>

<p>
Die von Portage genutzte Methode, kann geändert werden.  Schauen Sie in
die <uri link="#doc_chap2_sect8">Portage SYNC Settings</uri> im
<uri link="#doc_chap2">Portage Konfigurieren</uri> Kapitel für weitere
Informationen.
</p>

</body>
</section>

<section>
<title>Pakete installieren (mergen)</title>
<body>

<p>
Der Vorgang des Kompilierens und Installierens eines Paketes durch
Portage wird als <c>mergen</c> bezeichnet. Portage kompiliert Pakete und
installiert diese temporär in ein "Abbild-Verzeichnis", in dem es die zu
installierenden Dateien aufzeichnet. Diese Dateien werden dann aus dem
"Abbild-Verzeichnis" ins Root (/) Dateisystem integriert (gemerged).
</p>

<p>
Das <c>emerge</c> Kommando dient als Front-End des Portage Systems.
Das Installieren und Entfernen von Paketen wird durch dieses Kommando
und seine diversen Argumente kontrolliert.
</p>

<p>
Um die neueste Version eines Paketes zu installieren,
geben Sie einfach den Paketnamen, wie folgt ein (Beispiel):
</p>

<pre caption="Ein Paket installieren">
# <i>emerge galeon</i>
</pre>

<p>
Dieses Kommando wird zunächst alle benötigten Abhängigkeiten (unter
Berücksichtigung der USE Flags) und dann die neueste, verfügbare 
Version von Galeon (siehe das
<uri link="#doc_chap4">Paketverfügbarkeit</uri> Kapitel weiter unten um 
herauszufinden, wann Pakete verfügbar sind). Auf Galeon hätte auch verwiesen 
werden können mit dem kompletten Namen mit Kategorie: <c>net-www/galeon</c>.
</p>

<p>
Portage erlaubt auch, dass spezifische Versionen eines Paketes installiert 
sind. Dies wird dadurch erreicht, dass ein <e>Abschnitt</e> von Versionen 
definiert wird unter denen Portage den besten Kandidaten auswählt. Abschnitte 
werden durch die Operatoren <c>=</c> (exakte Version), <c>&lt;</c> 
(weniger als), <c>&gt;</c> (grösser als), <c>&lt;=</c> 
(weniger als, oder gleich), und <c>&gt;=</c> (grösser als, oder gleich) 
angegeben.Das folgende würde die beste Version von Galeon, älter als oder 
genau Version 1.3, installieren:
</p>

<pre caption = "Einen Abschnitt von Paketen definieren">
# <i>emerge "&lt;=net-www/galeon-1.3"</i>
</pre>

<p>
Wenn Sie Abschnitte von Paketen definieren ist es wichtig, dass Sie <c>&gt;</c> 
und <c>&lt;</c> in Anführungsstriche setzen, damit Ihre Shell diese nicht 
interpretiert. Sie werden ausserdem, wie im Beispiel, die Kategorie im 
Paketnamen spezifizieren müssen. Für ein weiteres Beispiel wie Sie 
Paketabschnitte mit emerge installieren können, Betrachten Sie bitte 
<c>emerge --help</c>.
</p>

<p>
Zusätzlich zur Angabe des Paketnamen und der Version, unterstützt
<c>emerge</c> verschiedene weitere Argumente. Eines dieser Argumente ist
<c>--pretend</c>, vielleicht eines der nützlichsten. Durch dieses
Argument wird das geplante Vorgehen nicht durchgeführt.  Stattdessen
gibt Portage eine Liste aller zu installierenden Pakete aus.  Das
Folgende zeigt eine Auflistung der Pakete, die während der Installation
der neuesten Version des Kdevelop Paketes installiert würden:
</p>

<pre caption="Darstellung der zu installierenden/aufzufrischenden Pakete">
# <i>emerge --pretend kdevelop</i>

These are the packages that I would merge, in order.

Calculating dependencies ...done!
[ebuild  N   ] kde-base/kdelibs-2.2.2-r4 to /
[ebuild  N   ] dev-util/kdbg-1.2.2 to /
[ebuild   U  ] app-text/psutils-1.17 to /
[ebuild   U  ] app-text/a2ps-4.13b-r3 to /
[ebuild   U  ] app-text/jadetex-2.20 to /
[ebuild  N   ] app-text/sgmltools-lite-3.0.3-r2 to /
[ebuild  N   ] kde-base/kdoc-2.2.2-r1 to /
[ebuild  N   ] net-www/htdig-3.1.5-r2 to /
[ebuild  N   ] app-text/enscript-1.6.3-r1 to /
[ebuild  N   ] kde-base/kdebase-2.2.2-r2 to /
[ebuild  N   ] app-doc/qt-docs-2.3.1 to /
[ebuild  N   ] dev-util/kdevelop-2.0.2 to /
</pre>

<p>
Mit <c>N</c> gekennzeichnete Pakete sind noch nicht auf ihrem Rechner
installiert, würden aber durch die angegebene Aktion eingespielt werden.
Pakete, die mit einem <c>U</c> gekennzeichnet sind, befinden sich
bereits in einer älteren Version auf Ihrem System und werden durch diese
Aktion aktualisiert.
</p>

<p>
Weitere häufig verwendete Optionen sind:
</p>

<p>
<c>--update</c> : Aktualisiert Pakete mit ihren direkten Abhängigkeiten 
zu besten verfügbaren Version.
</p>

<p>
<c>--ask</c> : Bevor emerge beginnt wird aufgelistet welche Ebuilds und 
binären Pakete installiert werden. Es wird dasselbe Format verwendet wie 
für --pretend und darauf wird der Benutzer gefragt ob er fortfahren 
oder abbrechen möchte.
</p>

<p>
<c>--fetchonly</c> : Lädt alle benötigten Dateien herunter, die für
das Kompilieren notwendig sind, sowie alle Abhängigkeiten, die dadurch
entstehen.
</p>

<p>
<c>--emptytree</c> : Diese Option lässt Portage vortäuschen, dass
keine der Abhängigkeiten oder Pakete, auf denen das zu installierende
Paket beruht, installiert sind.  Dies lässt sich sehr gut mit der Option
<c>--pretend</c> verbinden, um eine komplette Liste der Abhängigkeiten
für jedes einzelne Paket anzeigen zu lassen.
</p>

<p>
<c>--nodeps</c> : Mit dieser Option versucht Portage nur die
angegebene Pakete zu "mergen" und ignoriert sämtliche Abhängigkeiten.
Bitte beachten Sie, dass diese Option zu Problemen führen kann, wenn Sie
die Pakete, von denen das jeweilige Paket abhängig ist, nicht bereits
installiert haben.
</p>

<p>
<c>--onlydeps</c> : Mit dieser Option ist es möglich, nur die
Abhängigkeiten des jeweiligen Paketes zu "mergen", jedoch <e>nicht</e>
das ausgewählte Paket selbst.
</p>

<p>
<c>--noreplace</c> : Wenn Sie Pakete zum "mergen" angeben, die
bereits installiert sind, Sie jene aber nicht durch neue ersetzen
wollen, hilft Ihnen diese Option weiter.</p>

<p>
<c>--deep</c> : Wenn dies zusammen mit <c>--update</c> verwendet 
wird, dann wird emerge gezwungen den gesamten Abhängigkeitsbaum von 
Paketen zu aktualisieren, anstatt dass nur die direkten Abhängigkeiten der 
Pakete überprüft werden.
</p>

<p>
<c>--usepkg</c> : Anstatt das angegebene Paket zu kompilieren,
versucht Portage mit dieser Option ein vorkompiliertes tbz2 Paket von
einer angegebenen Stelle zu installieren . Jene Stelle ist in der <c>PKGDIR</c> 
Variable anzugeben.
</p>

<p>
<c>--usepkgonly</c> : Wie <c>--usepkg</c>, nur erlaubt dies die Verwendung 
von binären Paketen und es wird emerge abbrechen, wenn das Paket während der 
Abhängigkeitserstellung nicht verfügbar ist.
</p>

<p>
<c>--buildpkg</c> : Teilt emerge mit, dass von allen bearbeiteten Ebuilds 
binäre Pakete erstellt werden sollen.
</p>

<p>
<c>--buildpkgonly</c> : Teilt emerge mit, dass binäre Pakete erstellt werden 
sollen ohne die Ebuilds zu installieren.
</p>

<p>
<c>--oneshot</c> : Emerge wie gewohnt, aber Pakete werde nicht in der world 
Datei eingetragen.
</p>

<p>
<c>--debug</c> : Um eine noch detailiertere Ausgabe zu bekommen, was
während der Aktion mit Portage passiert, benutzen Sie diese Option.
Normalerweise werden Ausgaben "menschlich lesbarer" dargestellt. So
haben Sie zum Beispiel als Entwickler die Möglichkeit, syntaktische
Fehler in den Bash Script basierten ebuild Dateien zu finden.
</p>

<p>
<c>--autoclean</c> : Zwingt <c>emerge</c> zum totalen Bereinigen von
paketspezifischen temporären Verzeichnissen für Kompiliervorgänge, bevor
das Paket kompiliert wird. Portage erledigt dies bei der standard
Konfiguration von selbst, dadurch ist diese Option nur für Entwickler
interessant, die dieses Verhalten abgeschaltet haben.
</p>

<p>
<c>--tree</c> : Zeigt den Abhängigkeitsbaum, wobei Einrückung die Abhängigkeit 
zeigt.
</p>

<p>
<c>--verbose</c> : Sagt <c>emerge</c>, dass es im ausführlichen Modus
laufen soll.  Zusammen mit <c>--pretend</c> werden die möglichen USE
Flags ausgegeben.
</p>

</body>
</section>
<section>
<title>"Unmergen" (Deinstallieren) von Paketen</title>
<body>

<p>
Der Vorgang des "unmergens" ist, dass die Dateien, die mit einem
installierten Paket verbunden sind, gelöscht werden. Damit ist die
Software vom System entfernt und kann nicht mehr benutzt werden, bis Sie
jenes Paket wieder "mergen".
</p>

<p>
Pakete werden mittels des <c>emerge</c> Befehls und dem Parameter
<c>--unmerge</c>, gefolgt vom Namen des Paketes entfernt. Das folgende
Beispiel beseitigt alle installierten Versionen vom <c>ltrace</c>
Paket.
</p>

<pre caption="Ein Paket deinstallieren">
# <i>emerge --unmerge ltrace</i>

<comment>oder</comment>

# <i>emerge --unmerge dev-util/ltrace</i>
</pre>

<p>
Sie können auch einen Abschnitt von Paketen spezifizieren mit demselben 
Syntax wie für die Installation. Folgendes würde alle Versionen von ltrace 
älter oder gleich Version 0.3.15 deinstallieren:
</p>

<pre caption="Bestimmte Versionen eines Pakets deinstallieren">
# <i>emerge --unmerge "&lt;=dev-utils/ltrace-0.3.15"</i>
</pre>


<warn>
Das "unmergen" von Paketen kann gefährlich sein.  Wenn Sie ein
Paket des Grundsystems entfernen, verliert Ihr System an Funktionalität
und bei entfernten Bibliotheken droht funktionsuntüchtige Software.
<b>Portage warnt Sie nicht, wenn Sie Pakete des Grundsystems oder gar
Abhängigkeiten anderer Pakete entfernen.</b>
</warn>

<p>
Denken Sie daran die <c>--pretend</c> Option zu verwenden um zu 
sehen was passieren würde, wenn Sie den Befehl tatsächlich ausführen. 
Zur weiteren Sicherheit wird Portage, wenn Sie unmerge ausführen, einige 
Sekunden warten bevor das deinstallieren beginnt. Während dieser Wartezeit 
können Sie Strg-C drücken um den Vorgang abzubrechen.
</p>

<p>
Beginnt erstmal der Vorgang des "unmergens", sehen Sie eine lange
Liste von Dateinamen, die mit dem Paket verbunden sind.  Manche dieser
Dateinamen haben ein Merkmal (flag), das an der linken Seite der Datei
angezeigt wird. Die Merkmale <c>!mtime</c>, <c>!empty</c>, und
<c>cfgpro</c> verdeutlichen, weshalb einige Dateien nicht entfernt worden
sind, als das Paket "unmerged" wurde.  Dateien ohne jegliche Merkmale
wurden erfolgreich vom System entfernt.
</p>

<p>
Das Merkmal <c>!mtime</c> sagt aus, dass die Datei nach der
Installation des Pakets geändert wurde.  Das bedeutet, dass jemand nach
dem "mergen" des Paketes diese Datei bearbeitet hat oder zu einem
späteren Zeitpunkt andere Pakete sie überschrieben haben.  Dies erlaubt
es, dass Pakete aktualisiert werden können, ohne die Gefahr, dass
wichtige Dateien entfernt werden.
</p>

<p>
Das Merkmal <c>!empty</c> weist auf Verzeichnisse hin, welche Portage
verbietet zu entfernen, da sie nicht leer sind (mehrere Pakete teilen
sich oft das selbe Verzeichnis, welches das Paket, was "unmerged" wird,
entweder selbst gehört oder ebenfalls benutzt).  Der Konfigurationsdatei
Schutz-Mechanismus tritt dann ein, wenn Sie das <c>cfgpro</c> Merkmal
sehen. Das bedeutet, ein neueres Paket, was installiert wird, übernimmt
den Besitz jener Konfigurationsdateien und Portage verweigert die
Entfernung dieser Dateien.
</p>

</body>
</section>
<section>
<title>System Update</title>
<body>

<p>
Portage unterstützt die Möglichkeit installierte Pakete mit einem
einzigen Befehl zu aktualisieren. Das System-Update-Feature ermöglicht
es Ihnen, die Kernpakete ihres Systems zu Versionen zu aktualisieren,
die von den Gentoo-Entwicklern empfohlen werden und zum einwandfreien
Betrieb von Gentoo Linux notwendig sind. Ein System-Update aktualisiert
nur Pakete, die als essentiell angesehen werden.  Also nur die Pakete,
die im Portage Profil angegeben sind, werden als absolut wichtig für den
Betrieb und die Aktualität des Systems erachtet.
</p>

<p>
Um ein System-Update zu starten, geben sie den folgenden Befehl
ein:
</p>

<pre caption="Das Kernsystem aktualisieren">
# <i>emerge --update system</i>
</pre>

<p>
Portage wird nun, abhängig von den Versionen und Paketen, welche sie
derzeit installiert haben, die Updates kompilieren und installieren, die
vom aktuellen Portage-Profil empfohlen werden. Sie haben die Möglichkeit
sich mit der Option <c>--pretend</c> eine Liste mit den Paketen die
installiert bzw. aktualisiert werden, ausgeben zu lassen, wenn das oben
gezeigte Beispiel ausgeführt würde.
</p>

<note>
Wie sie aus der Gentoo-Installationsanleitung erfahren können, ist
einer der ersten Schritte der Befehl <c>emerge system</c>, um das
Grundsystem zu installieren. Mit <c>emerge --update system</c> werden
diese Basispakete auf den aktuellsten Stand gebracht.
</note>

</body>
</section>

<section>
<title>World Update</title>
<body>

<p>
Portage unterstützt außerdem die Möglichkeit, alle nicht-essentiellen
Pakete mit einem einzigen Befehl zu aktualisieren. Das Portage-System
besitzt dafür einen gewissen Grad an "Intelligenz", die es ermöglicht,
ein System mit verschiedene Versionen von Paketen, die in Konflikt
zueinander stehen, sicher zu aktualisieren .
</p>

<p>
Wen ein World-Update durchgeführt wird versucht Portage alle in 
<path>world</path> erwähnten Pakete zur neuesten Version zu aktualisieren. 
Was auch sicherstellt, dass alle Abhängigkeiten, die in Ebuilddateien welche 
zu jenen Paketen gehören, berücksichtigt werden (was auch, falls nötig, 
Abschnitte von Versionen einschließt). Wenn Portage mit der <c>--deep</c> 
Option ausgeführt wird, dann wird es auch die Abhängigkeiten dieser 
berücksichtigen und versuchen sie zu aktualisieren. Die Auflösung der 
Abhängigkeiten zieht auch <c>SLOTS</c>, wie in einem vorigen 
Kapitel erwähnt, in Betracht.
</p>

<p>
Das Herz von Portages-World-Update ist die <path>world</path> Datei. Anders als
das System-Profil, welches nur von den Entwicklern gewartet wird und
nie vom Benutzer verändert werden sollte, wird die <path>world</path> Datei 
indirekt mit der Zeit durch Aktionen des Benutzers erstellt. Die 
<path>world</path> Dateil funktioniert in etwa wie eine "Favoriten-Liste". 
Pakete die vom Benutzer manuell mit Hilfe von <c>emerge</c> installiert werden,
werden in der Datei  <path>/var/lib/portage/world</path> aufgenommen. Portage 
nimmt an, dass wenn Sie sich die Mühe gemacht haben die Pakete zu 
installieren, dann müssten Sie auch ein Interesse daran haben diese aktuell 
zu halten.
</p>

<p>
Die <path>world</path> Datei besteht aus einem Paketnamen mit Kategorie pro
Zeile und sollte in etwa wie folgt aussehen:
</p>

<pre caption="/var/lib/portage/world Beispiel">
net-im/gaim
net-www/skipstone
net-www/galeon
app-editors/vim
app-text/ispell
net-mail/evolution
dev-util/ltrace
sys-fs/xfsprogs
sys-apps/attr
sys-apps/dmapi
sys-kernel/linux-sources
sys-apps/acl
app-office/gnucash
app-cdr/xcdroast
</pre>

<p>
Nahezu alle Einträge in diesem Beispiel wurden von Portage
automatisch hinzugefügt, als der Benutzer eines der Pakete manuell
"ein-merge-te". Diese Pakete werden aktualisiert, wenn eine neuere
Version verfügbar ist.
</p>

<note>
Um Zeit zu sparen und sicher zu stellen, dass alle Ihre
bevorzugten Pakete aktuell gehalten werden, können Sie die <c>world</c>
Datei selbst bearbeiten und so Einträge für diese Pakete hinzufügen. Sie 
können auch Einträge zur <path>world</path> Datei in Form von Abschnitten 
von Paketen hinzufügen.
</note>

<p>
World-Updates werden durch den folgenden Befehl gestartet:
</p>

<pre caption="World Update ausführen">
# <i>emerge --update world</i>
</pre>

<warn>
Portage wird keine Dateien in Verzeichnissen überschreiben, die
durch die "Configuration File Protection" (Schutz von
Konfigurationsdateien) geschützt sind. Es ist notwendig, dass Sie selbst
die Unterschiede zwischen Ihren bestehenden und den neuen Dateien, die
von Portage generiert wurden, ausgleichen. Wenn Sie Ihre
Konfigurationsdateien nicht aktualisieren, werden verschiedene Programme
nicht mehr funktionieren. Bitte schauen sie für weitere Informationen
unter "Schutz der Konfigurationsdateien" im Kapitel "Portage
konfigurieren" nach oder benutzen sie den Befehl <c>emerge --help
config</c>.
</warn>

<p>
Um eine Liste mit den Paketen zu sehen, die von einem World-Update
betroffen sind, können Sie das Argument <c>--pretend</c> verwenden, so
wie es bereits in einem vorangegangen Abschnitt in diesem Kapitel
besprochen wurde.
</p>

<note>
Durch ein World-Update wird gleichzeitig auch ein System-Update
durchgeführt.
</note>

<p>
Ein praktischer Nebeneffekt der Art wie World-Update arbeitet, ist
für Benutzer interessant, die ein komplettes neu-Kompilieren aller
installierten Pakete auf einem System wünschen. Da World-Update alle
Pakete und deren Abhängigkeiten, die in der Datei <path>world</path> stehen
aktualisiert, gibt einem die Option <c>--emptytree</c> die Möglichkeit
eine neu-Kompilierung sämtlicher Pakete und aller Abhängigkeiten
zu erzwingen. Das ist z.B. für Leute nützlich, die
ihre Compiler-Optionen oder ihre USE Variable geändert haben und
wollen, dass diese Veränderungen von der gesamten Software die sie
benutzen verwendet wird - ohne dass sie nun jedes Paket selbst erneut
"mergen" müssen. Dazu müssen sie einfach die Datei <c>world</c> mit
allen Paketen, die sie verwenden auffüllen und den folgenden Befehl
verwenden:
</p>

<pre caption="Das System komplett neu kompilieren">
# <i>emerge --emptytree world</i>
</pre>

<p>
Sie können die Option <c>--pretend</c> mit diesem Befehl verwenden,
um eine Liste mit den Paketen, welche neu-Kompiliert werden, zu
bekommen.
</p>

</body>
</section>
<section>
<title>System aufräumen</title>
<body>

<p>
Portage hat die Fähigkeit verschiedene Versionen eines Paketes
parallel zu installieren. Jedoch wenn eine neuere Version des Paketes 
installiert wird, entfernt Portage automatisch die alte Version (sofern 
sie nicht ein unterschiedliches SLOT hat.)
</p>

<p>
Dieses Verhalten kann abgestellt werden durch das Setzen von 
<c>AUTOCLEAN=no</c> in <path>/etc/make.conf</path>. Wenn Sie dies 
tun, dann können Sie Ihr System manuell von älteren Versionen säubern indem 
Sie due <c>--clean</c> Aktion mit emerge verwenden:
</p>

<pre caption="Entfernen älterer Versionen von Paketen">
# <i>emerge --clean</i>
</pre>

<p>
<c>emerge</c> wird nun eine Liste mit Paketversionen und -revisionen
ausgeben die entfernt werden und die Versionen die erhalten bleiben.
Außerdem gibt es dem Benutzer Zeit, die Aktion mit Strg+C
abzubrechen.  
</p>

<p>
Naheliegenderweise wird Portage die Aufräumaktion auf die
<path>world</path> Datei (alle installierten Pakete) anwenden. Sie können den
Umfang der Säuberung durch Optionen wie <c>world</c>, <c>system</c>,
eine Liste von Paketnamen oder eine Einschränkung auf Paketversionen,
wie es im Abschnitt "Unmerge" in diesem Kapitel besprochen wurde,
beeinflussen.
</p>

<p>
Beim Herausfinden, welche Paketversionen entfernt werden sollen,
überprüft Portage die verschiedenen Profile, die Beziehungen zu anderen
Paketen und den SLOT eines Paketes. Vorausgesetzt dass alle
Paketabhängigkeiten für alle Pakete richtig definiert sind, wird
<c>emerge clean</c> nur veraltet Pakete vom System entfernen und nicht
solche, deren Entfernung die Funktionalität des Systems beeinträchtigen
würde.
</p>

<p>
Portage liefert auch noch einen aggressiveren Weg das System zu bereinigen: 
mit der <c>--depclean</c> Aktion von emerge können Sie alle Pakete, die 
momentan installiert sind, aber nicht gebraucht werden, finden und entfernen. 
Mit anderen Worten: Portage wird Pakete entfernen die nicht in der 
<path>world</path> Datei aufgelistet sind und die keine Abhängigkeiten 
von anderen Paketen sind.
</p>

<p>
Die <c>--depclean</c> Option kann gefährlich sein, denken Sie daran immer 
<c>--pretend</c> zu verwenden und zweimal nachzusehen, was Portage 
machen wird.
</p>

<pre caption = "Auffinden nicht benötigter Pakete">
# <i>emerge --pretend --depclean</i>
</pre>

<p>
Portage bietet außerdem die Funktion ein Paket zu säubern (engl.
<c>--prune</c>). Die prune Aktion ist eine unsichere Variante von
clean. Es entfernt alle Versionen aller Pakete, ausgenommen der
zuletzt installierten Version. Es führt nur wenige Überprüfung aus, die
<c>--clean</c> durchführt und kann grundlegende Abhängigkeiten von Ihrem
System entfernen! Wenn Sie diese Option nutzen, können sie sehr schnell
ihr System unbrauchbar machen. Somit wird diese Variante nicht empfohlen
und sollte nur in wenigen Ausnahmenfällen verwendet werden.
</p>

<p>
Die Aktion <c>--prune</c> akzeptiert die selben Optionen wie die Aktion
<c>--clean</c> und kann wie folgt angewendet werden:
</p>

<pre caption="Pakete säubern">
# <i>emerge --prune</i>
</pre>

</body>
</section>
<section>
<title>Den Portage Tree durchsuchen</title>
<body>

<p>
Ein Portage Tree, wie der, welcher das Herzstück von Gentoo Linux bildet,
kann sehr groß sein. Der Befehl <c>emerge</c> bietet eine Suchfunktion
an, die Suchanfragen in Form eines regulären Ausdrucks, dieser muss
von Anführungszeichen eingeschlossen sein, akzeptiert. Reguläre
Ausdrücke sind sehr komplizierte Biester und Anwendern die sich dafür
interessieren, sei ein gutes Buch zum Thema empfohlen.
</p>

<p>
Die meisten einfachen Suchen könne ohne Wissen, wie ein regulärer
Ausdruck zu bilden ist durchgeführt werden. Das folgende ist ein
Beispiel für eine einfache Suche nach einem Paket, das "gcc" heisst oder
"gcc" im Namen hat:
</p>

<pre caption="Nach regulärem Ausdruck suchen">
# <i>emerge --search gcc</i>
</pre>

<p>
Für jeden Treffer gibt der Befehl den Paketnamen, die neuste Version,
die neuste installierte Version, seine Homepage und eine Beschreibung
über die Software im Paket aus.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Verfügbarkeit von Paketen</title>
<section>
<title>Einleitung</title>
<body>

<p>
Wie Sie wahrscheinlich schon bemerkt haben gibt es eine große Anzahl von 
Ebuilddateien im Portage Tree die zu einer Pakterversion gehören, die nicht 
erscheint, wenn Sie den <c>emerge</c> Befehl ausführen: Alle diese 
Ebuilddateien sind unerreichbar aus einem bestimmten Grund. Die 
unterschiedlichen Gründe hierfür werden im folgenden Abschnitt thematisiert. 
</p>



</body>
</section>
<section>
<title>Keywords</title>
<body>

<p>
Jede Ebuilddatei im Portage Tree enthält die Definition einer Variable namens 
<c>KEYWORDS</c>. Diese Variable speichert eine Liste von Strings, z.B.
<c>"x86 ~amd64 -ppc"</c>. Nehmen wir als Beispiel <c>x86</c> und lassen 
Sie uns erklären, was jedes Schlüsselwort bedeutet.
</p>

<ul>
  <li>
    <c>x86</c> : Wenn dieses Schlüsselwort vorhanden ist, dann ist das 
    Ebuild stabil und erhältlich (für die x86 Architektur).
  </li>
  <li>
    <c>~x86</c> : Wenn dieses Schlüsselwort vorhanden ist, dann ist das 
    Ebuild in der Testphase (für die x86 Architektur).
  </li>
  <li>
    <c>-x86</c> : Wenn dieses Schlüsselwort vorhanden ist, dann ist das 
    Ebuild bekannt dafür nicht auf x86 Architekturen zu funktionieren.
  </li>
</ul>

<p>
Wenn kein Schlüsselwort für die Architektur vorhanden ist, dann bedeutet dies, 
dass das Ebuild noch nie zuvor auf dieser Architektur getestet wurde. Das 
spezielle Schlüsselwort <c>-*</c> wird verwendet um klarzumachen, dass das 
Ebuild auf keiner Architektur funktionieren wird, außer denen, welche 
explizit zu <c>KEYWORDS</c> hinzugefügt werden.
</p>

<p>
Standardmäßig wird Portage nur Pakete in Betracht ziehen, welche als stabil 
für die Architektur des Hostrechners markiert sind und alle anderen Ebuilds 
ignorieren. Das Resultat davon ist, dass dem Benutzer Updates für neue 
Software erst präsentiert werden, nachdem die Beuilds für die Software die 
Testphase verlassen und ihnen das stable Schlüsselwort zugeordnet wird.
</p>

<p>
Um sich über dieses Verhalten hinwegzusetzen können erfahrene Benutzer 
mit der <c>ACCEPT_KEYWORDS</c> Variable in <path>/etc/make.conf</path>  
eine Liste von Schlüsselwörtern definieren, die Portage in Betracht ziehen sollte.
Mutige Benutzer auf x86 (oder amd64, ppc, ...) lassen Portage alle Ebuilds in 
Betracht ziehen, die momentan getestet werden indem Sie ~x86 (oder ~amd64, 
~ppc, ...) zu <c>ACCEPT_KEYWORDS</c> hinzufügen. 
</p>

<pre caption = "Setzen von ACCEPT_KEYWORDS">
ACCEPT_KEYWORDS="~x86"
</pre>

<p>
Auf diese Weise wird die installierte Software synchron gehalten mit den 
neuestens Updates. Der Preis dafür ist das Risiko ein noch nicht ausführlich 
getestetes Paket zu installieren, was gelegentlich zu Störungen im 
gesamten System führen kann.
</p>

<p>
Eine sichere Art und Weise auf dem laufendenl zu bleiben ist es Portage 
manuell zu sagen, dass alle Testebuilds eines bestimmten Paketes in Betracht 
gezogen werden sollen. Dies kann durch die Verwendung der
<path>/etc/portage/package.keywords</path> Datei erreicht werden: 
Zum Beispiel, wenn Sie wünschen, dass Portage Ihnen Zugriff gibt auf die ~x86 
Pakete von gimp, dann fügen wir einfach folgenden Eintrag in 
<path>/etc/portage/package.keywords</path> ein:
</p>

<pre caption = "Benutzen von /etc/portage/package.keywords">
<comment>fügen Sie diese Zeile /etc/portage/package.keywords hinzu:</comment>
media-gfx/gimp ~x86
</pre>

</body>
</section>
<section>
<title>Maskierungen (Maskings)</title>
<body>

<p>
Wenn ein Paket dafür bekannt ist Probleme zu bereiten, weil es nicht gut 
funktioniert oder wegen einer schlechten oder gefährlichen Interaktion mit 
dem System, dann sorgt eine striktere Methode dafür, dass es nicht 
vom Benutzer installiert wird. Diese Methode besteht darin das Problempaket 
(oder den Abschnitt von Paketversionen) in einer von einigen 
<e>Maskierungs</e>Dateien aufzulisten.
</p>

<p>
Neben <path>/etc/make.profile/packages</path>, welches einige Abschnitte von 
Versionen von Paketen enthält die als akzeptabel angesehen werden sollen, 
sucht Portage nach Maskierungen in 
<path>/usr/portage/profiles/package.mask</path> (welches bei jedem Sync 
erneuert wird) und in <path>/etc/portage/package.mask</path> (welche vom 
Benutzer mit eigenen Maskierungen gefüllt werden kann). Sollte Portage also 
ein Paket in einer dieser Dateien finden, dann wird es dieses auf jeden Fall 
ignorieren.
</p>

<p>
Wenn Sie eine Maskierung in <path>/usr/portage/profiles/package.mask</path> 
übergehen wollen, dann raten wir Ihnen dazu diese Datei nicht direkt zu 
modifizieren, da die Veränderung beim nächsten Sync verloren gehen würde. 
Stattdessen bietet Portage eine simple Methode Maskierungen zu ignorieren, die 
Verwendung von <path>/etc/portage/package.unmask</path>. Zum Beispiel 
wenn Sie eine experimentelle Version von Portage, die momentan maskiert ist, 
ausprobieren wollen, dann müssen Sie nur einen Eintrag in 
<path>/etc/portage/package.unmask</path> wie folgt hinzufügen:
</p>

<pre caption = "Verwenden von /etc/portage/package.unmask">
<comment>fügen Sie diese Zeile zu /etc/portage/package.unmask hinzu:</comment>
sys-apps/portage
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Ressourcen</title>
<section>
<title>Hilfe erhalten</title>
<body>

<p>
Weitere Informationen zu den vielen Optionen und Aktionen, die von 
<c>emerge</c> unterstützt werden, können durch die Eingabe von folgenden 
Befehlen erhalten werden.
</p>

<pre caption = "Hilfe erhalten">
# <i>emerge --help</i>
# <i>man emerge</i>
# <i>man make.conf</i>
</pre>

<p>
Weitere hilfreiche Informationen über Portage finden sich in der man Seite 
von Portage:
</p>

<pre caption = "Betrachten der man Seite von Portage">
# <i>man portage</i>
</pre>


</body>
</section>
<section>
<title>Nützliche Helferlein</title>
<body>

<p>
Zahlreiche Hilfsprogramme sind über die Zeit entwickelt worden um Ihnen das 
Leben einfacher zu machen. Einige von Ihnen werden mit Portage selbst 
installiert, wogegen einige andere als externe Pakete erhältlich sind.
</p>

<ul>
  <li>
    <c>etc-update</c> : Shell Skript das verwendet wird um Ihnen beim 
    Einbinden von <path>/etc</path> Dateien assistieren soll (kann gefährlich 
    sein, wenn es falsch verwendet wird).
  </li>
  <li>
    <c>dispatch-conf</c> : Ersatz für <c>etc-update</c> mit vielen Features.
  </li>
  <li>
    <c>equery</c> (in app-portage/gentoolkit): Dies ist das primäre 
    Hilfsprogramm um Informationen aus Portage zu extrahieren, z.B. welche 
    Dateien in einem Paket vorhanden sind, zu welchem Paket eine bestimmte 
    Datei gehört und vieles mehr.
  </li>  
  <li>
    <c>qpkg</c> und <c>etcat</c> (in app-portage/gentoolkit): Dies sind die 
    Vorgänger von <c>equery</c>.  Ihre Funktionalität wird momentan nach
    <c>equery</c> migriert.
  </li>
  <li>
    <c>revdep-rebuild</c> (in app-portage/gentoolkit):erstellt erneut Pakete 
    die beschädigt wurden, als Bibliotheken aktualisiert wurden, die 
    inkompatible binäre APIs haben.
  </li>
  <li>
    <c>epm</c> (app-portage/epm): Ein Paketdatenbank Abfrageprogramm mit 
    einem Syntax ähnlich dem von RPM.
  </li>
  <li>
    <c>esearch</c> (app-portage/esearch): Ersatz für 'emerge --search', 
    beinhaltet einen Suchindex.
  </li>
  <li>
    <c>ufed</c> (app-portage/ufed): graphisches Hilfsprogramm um USE 
    Einstellungen zu editieren.
  </li>
  <li>
    <c>splat</c> (app-portage/splat) und <c>genlop</c> (app-portage/genlop):
    Analyseprogramme für emerge Protokolldateien.
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
