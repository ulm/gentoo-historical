<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- English CVS Version: 1.4 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/handbook/hb-install-alpha-disk.xml,v 1.2 2004/07/26 15:38:06 dertobi123 Exp $ -->

<sections>
<section>
<title>Einführung in Block Devices</title>
<subsection>
<title>Block Devices</title>
<body>

<p>
Wir werden einen guten Einblick in die Festplatten bezogenen Aspekte von Gentoo
Linux und Linux im allgemeinen, inklusive Linux Dateisystemen, Partitionen und
Block Devices erhalten.
Dann, sobald Sie mit den Vor- und Nachteilen von Festplatten und Dateisystemen
vertraut sind, werden Sie durch den Prozess des Partitionierens und der
Dateisystemerstellung für Ihre Gentoo Linux Installation geführt.
</p>

<p>
Zu Beginn werden wir Ihnen <e>Block Devices</e> vorstellen. Das berühmteste
Block Device is warscheinlich das, welches das erste IDE Laufwerk in einem
Linux System repräsentiert, namentlich <path>/dev/hda</path>. Wenn Ihr System
SCSI Laufwerke verwendet, dann wäre Ihre erste Festplatte
<path>/dev/sda</path>.
</p>

<p>
Das obige Block Device repräsentiert ein abstraktes Interface zur Festplatte.
Benutzerprogramme können diese Block Device benutzen, um Ihre Festplatte
anzusprechen, ohne sich darum zu kümmern, ob Ihre Festplatten IDE, SCSI oder
irgendwas anderes sind. Das Programm kann den Speicherplatz auf der Festplatte
einfach als eine Anhäufung von zusammenhängenden, zufällig zugreifbaren
512-Byte Blöcken ansprechen.
</p>
</body>
</subsection>
<subsection>
<title>Partitionen und Slices</title>
<body>

<p>
Obwohl es theoretisch möglich ist eine ganze Festplatte zu nutzen, um Ihr Linux
System zu beherbergen, wird dies in der Praxis so gut wie nie gemacht.
Stattdessen werden komplette Festplatten Block Devices in kleinere, besser
verwaltbare Block Devices unterteilt. Auf den meisten Systemen werden sie
<e>Partitionen</e> genant. Andere Architekturen benutzen ähnliche Techniken,
welche <e>Slices</e> genannt werden.
</p>

</body>
</subsection>
</section>
<section>
<title>Erstellung eines Partitionsschemas</title>
<subsection>
<title>Standard Partitionsschema</title>
<body>

<p>
Als Beispiel nutzen wir das folgende Slice Layout:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root Partition</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Gesamte Festplatte (benötigt)</ti>
</tr>
</table>

<p>
Wenn Sie daran interessiert sind zu erfahren, wie groß eine Partition sein
sollte, oder auch wieviele Partitionen (oder Volumes) Sie benötigen, lesen
Sie weiter. Anderenfalls fahren Sie nun mit dem <uri link="#fdisk">Partitionieren
Ihrer Festplatte</uri> fort:
</p>


</body>
</subsection>
<subsection>
<title>Wie viele und wie groß?</title>
<body>

<p>
Die Anzahl an Partitionen hängt von Ihrer Umgebung ab.
Wenn Sie z.B. eine Menge User haben, wollen Sie
höchst wahrscheinlich Ihr <path>/home</path> separat halten, da es die
Sicherheit erhöht und Backups einfacher macht. Wenn Sie Gentoo installieren um
als Mailserver zu fungieren, sollten Sie <path>/var</path> separat halten, da
alle Mails in <path>/var</path> gespeichert werden. Eine gute Wahl des
Dateisystems maximiert dann zusätzlich die Performance. Gameserver sollten ein
separates <path>/opt</path> haben, da die meisten Game Server dort installiert
werden. Der Grund ist ähnlich wie bei <path>/home</path>:
Sicherheit und Backups.
</p>

<p>
Wie Sie sehen können, hängt es sehr stark davon ab, was Sie erreichen wollen.
Separate Partitionen oder Volumes haben folgende Vorteile:
</p>

<ul>
<li>
  Sie können das Filesystem mit der höchsten Performance für jede Partition oder
  jedes Volume auswählen
</li>
<li>
  Ihr System behält noch freien Speicherplatz, selbst wenn ein defektes Tool
  ununterbrochen Dateien auf eine Partition oder ein Volume schreibt
</li>
<li>
  Falls nötig können Dateisystem Checks zeitlich verkürzt werden, in dem
  mehrere Checks parallel durchgeführt werden können (obwohl dieser Vorteil eher
  mit mehreren Festplatten als mit mehreren Partitionen zum Tragen kommt)
</li>
<li>
  Die Sicherheit kann erhöht werden, indem Sie einige Partitionen oder Volumes
  read-only, nosuid (setuid bits werden ignoriert), noexec (executable bits
  werden ignoriert) etc mounten.
</li>
</ul>

<p>
Wie dem auch sei, mehrere Partitionen haben einen großen Nachteil: wenn sie nicht
ordentlich konfiguriert werden, könnte das Resultat ein System sein, welches viel
Speicherplatz auf der einen Partition und keinen auf einer anderen frei hat.
</p>

</body>
</subsection>
</section>
<section id="#fdisk">
<title>Benutzung von fdisk auf Alpha zur Partitionierung Ihrer Festplatte</title>
<subsection>
<body>

<p>
Die folgende Teile erklären, wie Sie das vorhin vorgestellte Slice Layout
erstellen.
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root Partition</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Gesamte Festplatte (benötigt)</ti>
</tr>
</table>

<p>
Passen Sie das Slice Layout an Ihre Vorstellungen an.
</p>


</body>
</subsection>
<subsection>
<title>Identifizierung verfügbarer Festplatten</title>
<body>

<p>
Um herauszufinden, welche Festplatten Ihnen zur Verfügung stehen, benutzen Sie
die folgenden Kommandos:
</p>

<pre caption="Identifizierung verfügbarer Festplatten">
<comment>(Für IDE Festplatten)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Für SCSI Festplatten)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Aus dieser Ausgabe sollten Sie in der Lage sein zu erkennen, welche Festplatten
erkannt wurden und deren besonderen <path>/dev</path> Eintrag abzulesen. In den
folgenden Abschnitten gehen wir von einer SCSI Festplatte auf
<path>/dev/sda</path> aus.
</p>

<p>
Starten Sie nun <c>fdisk</c>:
</p>

<pre caption="Starten von fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Löschen von allen Slices</title>
<body>

<p>
Wir beginnen mit dem Löschen von allen Slices, <c>außer</c> des 'c'-Slice.
Nachfolgend zeigen wir Ihnen, wie Sie ein Slice (im Beispiel nutzen wir 'a')
löschen können. Wiederholen Sie den Schritt für alle Slices (wieder: außer des
'c'-Slice).
</p>

<p>
Benutzen Sie <c>p</c> um alle existierenden Slices anzuzeigen. <c>d</c>
benötigen Sie zum Löschen eines Slices.
</p>

<pre caption="Löschen eines Slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Nachdem Sie den Prozess für alle anderen Slices wiederholt haben, sollte die
Auflistung folgender ähnlich sehen:
</p>

<pre caption="Ansicht einer leeren Partitionstabelle">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen des Swap Slice</title>
<body>

<p>
Auf Alpha basierten System benötigen Sie keine separate Boot Partition. Dennoch
kann der erste Zylinder nicht benutzt werden, da das <c>aboot</c> Image dort
abgelegt werden wird.
</p>

<p>
Wir werden ein Swap Slice beginnend am dritten Cylinder mit einer Größe von 1
GB erstellen. Benutzen Sie <c>n</c> um ein neues Slice zu erstellen. Nachdem Sie
das Slice erstellt haben, ändern Sie den Typ mit <c>1</c> auf Swap.
</p>

<pre caption="Erstellen der Swap Slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Nach diesen Schritten sollten Sie ein der folgenden Auflistung ähnliches Layout
sehen:
</p>

<pre caption="Slice Layout nach dem Erstellen des Swap Slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen des Root Slice</title>
<body>

<p>
Wir werden nun das Root Slice anlegen beginnend vom ersten Zylinder <e>nach</e>
der Swap Slice. Benutzen Sie das <c>p</c> Kommando um zu schauen, wo das Swap
Slice endet. In unserem Beispiel ist dies 1003, das Root Slice beginnt also
bei 1004.
</p>

<p>
Ein weiteres Problem ist, dass aktuell ein Bug in <c>fdisk</c> existiert.
Dadurch denkt <c>fdisk</c>, dass die Anzahl verfügbarer Zylinder Eins
über der realen Zahl der Zylinder liegt. In anderen Worten, wenn Sie nach dem
letzten Zylinder gefragt werden, verkleinern Sie die Zylindernummer (in diesem
Beispiel: 5290) um eins.
</p>

<p>
Wenn das Slice erstellt wurde, ändern Sie den Typ auf <c>8</c> für <e>ext2</e>.
</p>

<pre caption="Erstellen des Root Slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Ihr Slice Layout sollte nun ähnlich dem Folgenden aussehen:
</p>

<pre caption="Ansicht des Slice Layout">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Speichern des Slice Layout und Beenden von fdisk</title>
<body>

<p>
Schliessen Sie <c>fdisk</c> indem Sie <c>w</c> eingeben. Damit wird auch Ihr
Slice Layout gespeichert.
</p>

<pre caption="Speichern und Verlassen von fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Nachdem Ihre Slices nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Erstellen der Dateisysteme</title>
<subsection>
<title>Einleitung</title>
<body>

<p>
Jetzt sind Ihre Partitionen erstellt, so dass es nun an der Zeit ist
Dateisysteme anzulegen. Wenn Sie mit dem zufrieden sind, was wir Ihnen
vorschlagen, dann fahren Sie mit <uri link="#filesystems-apply">Dateisystem
auf einer Partition anlegen</uri> fort. Wenn nicht, lesen Sie weiter, um
ein wenig mehr über Dateisysteme zu lernen ...
</p>

</body>
</subsection>
<subsection>
<title>Dateisysteme?</title>
<body>

<p>
Verschiedene Dateisysteme sind verfügbar. Einige von ihnen sind auf allen
Architekturen stabil, andere nur auf einigen. Die folgende Tabelle listet die
verfügbaren Dateisysteme und die Architekturen, auf denen diese arbeiten, auf.
Wenn eine Architektur in "(...)" steht, dann sollte Dateisystem auf dieser
Archtitektzr funktionieren, ist aber nicht getestet.
</p>

<p>
<b>ext2</b> ist das erprobte und wahre Linux Dateisystem, unterstützt aber kein
Metadata Journaling, was bedeutet, dass routinemäßige Dateisystem Checks beim
Booten sehr zeitaufwändig sein können. Es gibt mittlerweile eine Auswahl an
journalisierenden Dateisystemen neuerer Generation, die die Konsistenzchecks sehr
schnell erledigen und dadurch im Vergleich mit den nicht-journalisierenden
Gegenstücken vorzuziehen sind. Jounalisierende Dateisysteme verhindern lange
Verzögerungen beim Booten, wenn sich das Dateisystem in einem inkonsistenten
Zustand befindet.
</p>

<p>
<b>ext3</b> ist die journalisierende Version des ext2 Dateisystem, die Metadata
Journaling für schnelle Wiederherstellung sowie andere verbesserte Journaling
Modi wie "full data" und "ordered data" Jornaling unterstützt. ext3 ist ein sehr
gutes und verlässliches Dateisystem. Es hat eine zusätzliche b-tree Indexing
Option die in fast allen Situationen hohe Performance ermöglicht. Kurz gesagt:
ext3 ist ein excellentes Dateisystem.
</p>

<p>
<b>ReiserFS</b> ist ein B*-tree basierendes Dateisystem mit einer guten
Performance und überholt sowohl ext2 und ext3 im Umgang mit kleinen Dateien
(Dateien kleiner als 4k) oftmals mit einem Faktor von 10x-15x. ReiserFS skaliert
extrem gut und hat Metadata Journaling. Seit Kernel 2.4.18+ ist ReiserFS
stabil und sowohl als Dateisystem für generelle Anwendungen, als auch für
extreme Fälle wie große Dateisysteme, den Gebrauch mit vielen kleinen Dateien,
den Gebrauch mit sehr großen Dateien und Verzeichnissen mit tausenden von
Dateien brauchbar.
</p>

<p>
<b>XFS</b> ist ein Dateisytem mit metadata journaling, das mit einem robusten
Feature-Set kommt und auf Skalierbarkeit ausgelegt ist. Wir empfehlen den Einsatz
dieses Dateisystems nur auf Linux Systemen mit High-End SCSI und/oder Fibre Channel
Storage und einer redundaten Stromversorgung. Da XFS agressiv vom RAM gebraucht
macht, können unsachgemäß designte Programme (solche die keine
Vorsichtsmaßnahmen treffen, wenn Sie auf die Festplatte schreiben und davon
gibt es einige) dazu führen, dass eine ganze Menge Daten verloren gehen, wenn
das System unerwartet ausfällt.
</p>

<p>
<b>JFS</b> ist IBMs Hochleistungs Journaling Dateisystem. Es ist vor kurzem
einsatzbereit geworden und es gibt noch keine ausreichende Spur, so dass seine
allgemeine Stabilität an diesem Punkt weder positiv noch negativ kommentiert
werden kann.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Eine Partition mit einem Dateisystem formatieren</title>
<body>

<p>
Um ein Dateisystem auf einer Partition oder einem Volume zu erstellen, gibt es
für jedes Dateisystem Tools:
</p>

<table>
<tr>
  <th>Dateisystem</th>
  <th>Kommando</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Um die Root Partition (<path>/dev/sdab</path> in unserem Beispiel) als ext3
zu formatieren, führen Sie folgende Kommandos aus:
</p>

<pre caption="Eine Partition mit einem Dateisystem formatieren">
# <i>mke2fs -j /dev/sdab</i>
</pre>

<p>
Erstellen Sie nun die Dateisysteme auf Ihren neu erstellten Partionen (oder
logischen Volumes).
</p>

</body>
</subsection>
<subsection>
<title>Aktivieren der Swap Partition</title>
<body>

<p>
<c>mkswap</c> ist das Kommando, mit dem Sie die Swap Partition initialisieren:
</p>

<pre caption="Erstellen der Swap Signatur">
# <i>mkswap /dev/sdaa</i>
</pre>

<p>
Um die Swap Partition zu aktivieren, benutzen Sie <c>swapon</c>:
</p>

<pre caption="Aktivieren der Swap Partition">
# <i>swapon /dev/sdaa</i>
</pre>

<p>
Erstellen und aktivieren Sie jetzt Ihre Swap Partition.
</p>

</body>
</subsection>
</section>
<section>
<title>Mounten</title>
<body>

<p>
Nachdem Ihre Partitionen nun initialisiert sind und ein Dateisystem beinhalten,
ist es an der Zeit diese Partitionen zu mounten. Benutzen Sie das <c>mount</c>
Kommando. Vergessen Sie nicht die notwendigen Mount Verzeichnisse für jede
erstellte Partition anzulegen. Als Beispiel mounten wir die root und boot
Partition:
</p>

<pre caption="Mounten von Partitionen">
# <i>mount /dev/sdab /mnt/gentoo</i>
</pre>

<note>
Wenn Sie <path>/tmp</path> auf eine separate Partition legen möchten, stellen
Sie sicher, dass Sie die Berechtigungen nach dem mounten ändern:
<c>chmod 1777 /mnt/gentoo/tmp</c>. Dies gilt auch für <path>/var/tmp</path>.
</note>

<p>
Sie müssen auch noch das proc Dateisystem (ein virtuelles Interface zum Kernel)
auf <path>/proc</path> mounten. Zunächst erstellen Sie den
<path>/mnt/gentoo/proc</path> Mountpoint und mounten dann das Dateisystem:
</p>

<pre caption="Erstellen des /mnt/gentoo/proc Mountpoint">
# <i>mkdir /mnt/gentoo/proc</i>
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Fahren Sie nun mit dem <uri link="?part=1&amp;chap=5">Installation der Gentoo
Installations Dateien </uri> fort.
</p>

</body>
</section>
</sections>
