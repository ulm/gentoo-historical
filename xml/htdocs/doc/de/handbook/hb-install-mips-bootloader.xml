<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- English CVS Version: 1.12 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/handbook/hb-install-mips-bootloader.xml,v 1.7 2006/01/22 02:14:28 grahl Exp $ -->

<sections>

<version>1.8</version>
<date>2006-01-19</date>

<section id="sgi">
<title>Silicon Graphics Maschinen -- Einrichten von Arcboot</title>
<subsection>
<title>Installieren von arcboot</title>
<body>

<p>
Bisher haben wir Ihnen in diesem Leitfaden gezeigt wie man einen Kernel 
erstellt und den dann zum Volume Header kopiert mit <c>dvhtool</c>. Es gibt 
bei diesem System zwei Makel:
</p>

<ul>
  <li>Dies wird nicht von allen SGI Maschinen unterstützt</li>
  <li>Es benötigt einen erheblich größeren Volume Header</li>
</ul>

<p>
Damit die Maschine gebootet werden kann wurde ein Bootloader mit dem Namen 
<c>arcboot</c> für diesen Zweck entwickelt. Anstatt dass wir den Kernel direkt 
in den Volume Header plazieren lassen wir ihn in <path>/boot</path> (welches auf 
einer EXT2/3 Partition residiert) und teilen <c>arcboot</c> (welches anstatt 
des Kernels im Volume Header sitzt) mit, wo dieser zu finden ist. Unser erster 
Schritt ist eine Tools mit emerge zu installieren, die wir später brauchen 
werden...
</p>

<pre caption="Installieren der benötigten Tools">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Dies sollte zwei Tools installiert haben. Einerseits <c>arcboot</c> welches 
im Volume Header sitzt und den Kernel für uns lädt, sowie <c>dvhtool</c>, das
uns hilft <c>arcboot</c> im Volume Header zu plazieren.
</p>

<p>
Die spezielle Binärdatei die wir suchen versteckt sich in 
<path>/usr/lib/arcboot</path> -- auf IP22 Systemen (Indy, Indigo 2, Challenge 
S), wird diese <path>arcboot.ip22</path> genannt. Andere Systeme sollten 
ähnlich sein. Zuerst kopieren wir die Datei in den Volume Header.
</p>

<pre caption="Installieren von arcboot im Volume Header">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Wir überprüfen nun die Präsenz der Datei im Volume Header. 
</p>

<pre caption="Überprüfen ob arcboot erfolgreich angekommen ist">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Sie werden bemerken, dass hier zwei alte Kernel, <path>linux</path> und 
<path>newlinux</path>, weiterhin dort sitzen. Diese sind noch hängengeblieben 
vom Anfang ohne <c>arcboot</c>. Deren Präsenz ist egal, solange <c>arcboot</c> 
vorhanden ist, ist alles in Ordnung.
</note>

</body>
</subsection>

<subsection>
<title>Konfigurieren von arcboot</title>

<body>

<p>
Wenn Sie jemals zuvor den Linux Loader (<c>lilo</c>) eingerichtet haben, dann 
werden Sie feststellen, dass <c>arcboot</c> eine ähnlichen Syntax für seine 
Konfigurationsdateien verwendet. Beachten Sie aber bitte, dass <c>arcboot</c> 
davon ausgeht, dass seine Konfigurationsdatei existierend auf einer EXT2/3 
Partition als <path>/etc/arcboot.conf</path> erwartet. Der einfachste Weg 
ist hier sicherzustellen, dass  <path>/boot</path> eine EXT2/3 Partition ist 
und dass eine Datei namens <path>arcboot.conf</path> im Verzeichnis 
<path>/boot/etc</path> existiert. Eine Beispielskonfiguration findet sich in 
<path>/etc/arcboot.conf.sample</path>.
</p>

<pre caption="arcboot.conf an seinen Platz bringen">
<comment>(Erstellen des /boot/etc Verzeichnisses)</comment>
# <i>mkdir /boot/etc</i>

<comment>(Die Konfiguration in das Zielverzeichnis setzen)</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(Einen symlink zurück zu /etc erstellen)</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(... und einen symlink in /boot der auf sich sich selbst verweist)</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Sie können dann <path>/etc/arcboot.conf</path> entsprechend Ihrer persönlichen 
Präferenzen anpassen. Der Autor bevorugt es zwei Kernel Images einzurichten: 
<path>new</path>, ein frisch erstelltes Image das vielleicht funktioniert, 
vielleicht aber auch nicht, sowie <path>working</path>, ein Kernel Image das 
sich als verlässlich erwiesen hat. Die <path>arcboot.conf</path> wäre dafür 
ähnlich wie diese aufgebaut.
</p>

<pre caption="Beispiels arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># Backup Version</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Sowie dies eingerichtet ist müssen nur noch einige kleine Justierungen 
innerhalb des SGI PROM vorgenommen werden, damit die ganze Sache funktioniert. 
Dies wird nicht im nächsten Abschnitt (der ist für Cobalt Server) sondern im 
darauffolgenden Abschnitt <uri link="#reboot">Neustarten des Systems</uri> 
behandelt.
</p>

</body>
</subsection>
</section>

<section id="cobalt">
<title>Cobalt MicroServer -- Einrichten von CoLo</title>
<subsection>
<title>Installieren von CoLo</title>
<body>

<p>
Cobalt Server haben auf dem Chip ein viel weniger leistungsfähiges Firmware 
installiert. Das Cobalt BOOTROM ist primitiv, verglichen mit dem SGI PROM, und 
einige größere Anzahl von erheblichen Beschränkungen.
</p>

<ul>
  <li>
    Es gibt ein 675kB Limit für Kernel. Die momentane Größe von Linux 2.4 
    macht es fast unmöglich einen Kernel dieser Größe zu erstellen. Linux 2.6 
    kommt überhaupt nicht mehr in Frage.
  </li>
  <li>
    64-bit Kernel werden nicht vom mitgelieferten Firmware unterstützt (auch 
    wenn diese momentan höchst experimentell auf Cobalt Maschinen sind)
  </li>
  <li>
    Die Shell ist bestenfalls grundlegend
  </li>
</ul>

<p>
Um diese Einschränkungen zu überwinden wurde ein alternatives Firmware mit 
dem Namen <uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri> 
(Cobalt Loader) entwickelt. Dies ist ein BOOTROM Image, welches enweder in 
den Chip innerhalb des Cobalt Servers hinein-geflasht werden oder von 
einem existierenden Firmware geladen werden kann.
</p>

<note>
Dieser Leitfaden führt Sie durch die Einrichtung von CoLo so dass es vom 
existierenden Firmware geladen wird. Dies ist der einzige wirklich sichere und 
empfohlene Weg CoLo einzurichten.
</note>

<warn>
Sie können, wenn Sie das wünschen den Server flashen und das Original 
Firmware komplett ersetzen, aber Sie sind bei diesem Unterfangen ganz sich auf 
sich allein gestellt. Sollte irgendetwas schief gehen müssen das BOOTROM 
physisch entfernen und selbst mit dem Original Firmware reprogrammieren. Wenn 
Sie nicht sicher sind wie man dies anstellt, dann flashen Sie Ihre Maschine 
<e>NICHT</e>. Wir übernehmen keine Verantwortung für was auch immer geschieht, 
wenn Sie diesen Rat ignorieren.
</warn>

<p>
Nach diesen Warnungen können wir nun mit der Installation von CoLo beginnen. 
Beginnen wir damit, dass wir das Paket emergen.
</p>

<pre caption="Emergen von colo">
# <i>emerge colo</i>
</pre>

<p>
Nachdem es nun installiert ist (wir hoffen Sie haben die Ausgaben gelesen) 
sollten Sie in der Lage sein im <path>/usr/lib/colo</path> Verzeichnis zwei 
Dateien zu finden. Dies sind <path>colo-chain.elf</path>, der "Kernel" für das
Standard Firmware zum laden und <path>colo-rom-image.bin</path>, ein ROM Image 
für das flashen in den BOOTROM. Wir beginnen damit, dass wir /boot mounten und 
und eine komprimierte Kopie von <path>colo-chain.elf</path> in 
<path>/boot</path> ablegen, dort wo das System es erwartet.
</p>

<pre caption="CoLo an seinen Platz bringen">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Konfigurieren von CoLo</title>

<body>

<p>
Nun wenn das System das erste Mal hochfährt wird es CoLo laden, welches ein 
Menü auf dem rückwärtigen Display ausspuckt. Die erste Option (und der 
Standard der nach etwa 5 Sekunden vollzogen wird) ist es von der Festplatte 
zu booten. Das System würde dann versuchen die erste Linux Partition die es 
findet zu mounten und dann das Skript <path>default.colo</path> ausführen. Die 
Syntax ist vollständig dokumentiert in der CoLo Dokumentation (werfen Sie doch 
einen Blick darauf in <path>/usr/share/doc/colo-X.YY/README.shell.gz</path> -- 
wobei X.YY die installierte Version ist), sie ist sehr einfach.
</p>

<note>
Noch ein Tipp: Bei der Kernelinstallation kann es hilfreich sein zwei Kernel 
Images zu erstellen. <path>kernel.gz.robust</path> -- als erprobten 
funktionierenden Kernel und <path>kernel.gz.neu</path> als ein Kernel der 
gerade erste kompiliert wurde. Sie können entweder symlinks verwenden um 
auf die aktuellen "neu" und "robust" Kernel zu verweisen oder Sie bennenen die 
Kernel Images einfach um.
</note>

<pre caption="Eine grundlegende default.colo">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo wird verweigern ein Skript zu laden, das nicht mit <c>#:CoLo:#</c> 
beginnt. Betrachten Sie es als Equivalent zu <c>#!/bin/sh</c> in Shell Skripten.
</note>

<p>
Es ist auch möglich eine Frage zu stellen, wie z.B. welchen &amp; welche 
Konfiguration Sie zum booten verwenden möchten, inklusive eines Standard 
Timeouts. Dies ist die Konfiguration, die der Autor auf seinem Cobalt Server 
verwendet:
</p>

<impo>
Beachten Sie bitte, dass Sie CoLo v1.12 oder v.1.13 verwenden müssen um den 
<c>menu</c> Befehl verwenden zu können. Das folgenden Beispiel wird mit 
v1.11 nicht funktionieren.
</impo>

<impo>
Der <c>menu</c> Befehl wurde ersetzt durch den <c>select</c> Befehl in CoLo 
v1.14. Wenn Sie eine späterre Version von Hand installiert haben, dann sollten 
Sie einen Blick auf <path>menu.colo</path>, im <path>examples</path> 
Unterverzeichnis der CoLo Distribution, werfen.
</impo>

<pre caption="Menü-basierende Konfiguration">
<comment>#:CoLo:#</comment>

lcd "Mounten von hda1"
mount hda1
menu "Welcher Kernel?" 50 Robust robust Neu neu
lcd "Lade Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Boote..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Das oben gezeigte Skript fragt den Benutzer welcher Kernel für den Boot 
gewünscht wird (entweder Neu oder Robust) und lädt dann 
<path>vmlinux.gz.neu</path> oder <path>vmlinux.gz.robust</path>, abhängig 
von der Wahl des Benutzers. Wenn eine Auswahl nicht innerhalb von 5 Sekunden 
geschieht (50/10tel einer Sekunde) dann bootet die erste Option.
</p>
</body>

</subsection>
</section>

<section>
<title>Einrichten per serieller Konsole</title>

<subsection>
<body>

<p>
Die Linux Installation würde, so wie es momentan aussieht, einwandfrei booten, 
aber annehmen dass Sie mit einem physischen Terminal eingeloggt sind. Bei 
Cobalt Maschinen ist dies besoders schlecht -- es gibt nichts was einem 
physischen Terminal entspricht.
</p>

<note>
Diejenigen welche das Glück eines unterstützten Framebuffers zu haben können 
diesen Abschnitt überspringen wenn Sie möchten.
</note>

<p>
Öffnen Sie zuerst einen Editor und legen Sie Hand an <path>/etc/inittab</path>. 
Weiter unten in der Datei werden Sie etwas sehen was so ähnlich wie das hier 
aussieht:
</p>

<pre caption="inittab Konfiguration">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Entkommentieren Sie die <c>c0</c> Zeile. Standardmäßig ist Sie auf eine 
Terminal Baudrate von 9600 bps gesetzt. Bei Cobalt Servern wird empfohlen die 
Baudraute auf 115200 zu ändern um sich an die Baudrate, welche vom BOOTROM 
gewählt wird, anzugleichen. Es folgen die Einstellungen die der Autor bei 
seinem Cobalt Server verwendet. Bei einer "kopflosen" Maschine (z.B. ein 
Cobalt Server) wird auch empfohlen die lokalen Terminalzeilen zu entkommentieren 
(<c>c1</c> bis <c>c6</c>), da diese die Angewohnheit haben Fehler zu 
produzieren, wenn sie <path>/dev/ttyX</path> nicht öffnen können.
</p>

<pre caption="Beispielsauszug aus inittab">
<comment># SERIAL CONSOLE</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- Diese sind nutzlos auf einem kopflosen qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Zum Schluss muss das System noch wissen, dass dem lokalen seriellen Port als 
sicheres Terminal vertraut werden darf. Die Datei die angepasst werden muss 
ist <path>/etc/securetty</path>. Sie enhält eine Liste der Terminals denen 
das System vertraut. Es werden einfach zwei weitere Zeilen hinzugefügt, welche 
es erlauben, dass die serielle Leitung für <c>root</c> Logins verwendet werden 
kann.
</p>

<pre caption="Aktivieren von root Logins an der seriellen Konsole">
<comment>(/dev/ttyS0 -- der traditionelle Name für den ersten seriellen Port)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(Neuerdings nennt Linux diesen auch /dev/tts/0 -- daher wird dieser 
auch hinzugefügt)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Rebooten des Systems</title>
<subsection>
<body>

<p>
Verlassen Sie die chroot Umgebung und unmounten Sie alle gemounteten
Partitionen. Danach tippen Sie das magische Kommando ein, auf das Sie solange
gewartet haben: <c>reboot</c>.
</p>

<pre caption="Unmounten aller Partitionen und Rebooten">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Cobalt Benutzer:</e> Der Rest dieses Abschnitts behandelt das Einrichten 
des SGI PROM, so dass <c>arcboot</c> von der Festplatte bootet und Linux lädt. 
Genauer gesagt, all Ihre Arbeit ist erledigt. Es gibt keine weitere 
Konfiguration die für das erste Booten benötigt wird. Sie können zum nächsten 
Abschnitt springen: <uri link="?part=1&amp;chap=11">Abschließen der Gentoo
Installation</uri>
</note>

</body>
</subsection>
</section>
<section>
<title>Anpassen des SGI PROM</title>
<subsection>
<body>

<p>
Wenn Sie neu gestartet haben gehen Sie in das <e>System Maintenance Menu</e> und
wählen <e>Enter Command Monitor</e> (<c>5</c>). Wenn Sie Ihre neue Gentoo
Installation kurz testen möchten können Sie einfach <c>boot -f &lt;kernel
name&gt;</c> eingeben. Um Ihrem System beizubringen immer die Gentoo
Installation zu booten müssen Sie einige Variablen im SGI PROM setzen:
</p>

<pre caption="Konfiguration des PROMs zum booten von Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

<comment>(&lt;root device&gt; = Gentoos Root Partition, z.B. /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>

<comment>(Um alle verfügbaren Kernel anzuzeigen geben Sie "ls" ein)</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>

<comment>(Deklarieren Sie die Kernel Parameter)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>

<comment>(Geben Sie den Pfad zum Volume Header an)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Automatisches Starten von Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Setzen der Zeitzone)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Nutzung der seriellen Konsole, Nutzer der Grafikoption wählen ihr "g" anstelle von "d1")</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>

<p>
Nachdem Sie in die neue Gentoo Installation gebootet haben schließen Sie die
Installation mit <uri link="?part=1&amp;chap=11">Abschließen der Gentoo
Installation</uri> ab.
</p>

</body>
</subsection>
</section>
</sections>
