<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- English CVS Version: 1.44 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/handbook/Attic/hb-install-x86-kernel.xml,v 1.11 2005/04/24 14:21:55 dertobi123 Exp $ -->

<sections>

<version>2.6</version>
<date>2005-04-21</date>

<section>
<title>Setzen der Zeitzone des Systems</title>
<body>

<p>
Zuerst müssen Sie dem System sagen, in welcher Zeitzone es sich befindet. Dazu
suchen Sie sich unter <path>/usr/share/zoneinfo</path> die entsprechende
Zeitzone aus und verlinken sie mit <c>ln</c> nach <path>/etc/localtime</path>:
</p>

<pre caption="Setzen der Zeitzone">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Beispiel: GMT)</comment>
# <i>ln -sf /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Installieren der Quellen</title>
<subsection>
<title>Auswählen eines Kernels</title>
<body>

<p>
Der Kern um den herum alle Distributionen gebaut sind ist der Linux Kernel. Es
ist die Ebene zwischen den Benutzerprogrammen und der Systemhardware. Gentoo
bietet seinen Benutzern verschiedene mögliche Kernelquellen. Eine komplette
Liste mit Beschreibungen finden Sie im <uri link="/doc/de/gentoo-kernel.xml">
Gentoo Kernel Guide</uri>.
</p>

<p>
Für x86-basierende Systeme haben wir unter den Kerneln die
<c>vanilla-sources</c> (die Standardkernelquelle wie entwickelt von den Linux
Kernelentwicklern), die <c>gentoo-sources</c> (Kernelquelle modifiziert für
Performance verbessernde Eigenschaften), ...
</p>

<p>
Wählen Sie Ihre Kernelquelle aus und installieren Sie diese mit <c>emerge</c>.
</p>

<pre caption="Installieren einer Kernelquelle">
# <i>emerge gentoo-sources</i>
</pre>

<p>
Wenn Sie einen Blick in <path>/usr/src</path> werfen, sollten Sie einen Symlink
sehen, genannt <path>linux</path>, der auf Ihre Kernelquelle verweist. Wir gehen
davon aus, dass die Kernelsourcen <c>gentoo-sources-2.6.11-r3</c> installiert
sind.
</p>

<pre caption="Anzeigen des Kernelquellen Symlinks">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux-&gt;linux-2.6.11-gentoo-r3
</pre>

<p>
Wenn das nicht der Fall ist (also der Symlink auf eine andere Kernelquelle
verweist) ändern Sie den Symlink bevor sie weitermachen. Beachten Sie, dass
<c>linux-2.6.11-gentoo-r3</c> nur ein Beispiel ist!
</p>

<pre caption="Ändern des Kernelquellen Symlinks">
# <i>rm /usr/src/linux</i>
# <i>cd /usr/src</i>
# <i>ln -s linux-2.6.11-gentoo-r3 linux</i>
</pre>

<p>
Nun ist es Zeit Ihre Kernelquelle zu konfigurieren und zu kompilieren. Alle
Architekturen können <c>genkernel</c> verwenden, welches einen generischen
Kernel erstellt, wie er von der Installations CD verwendet wird. Wir erklären die
"manuelle" Konfiguration jedoch zuerst, denn es ist der beste Weg Ihre Umgebung
zu optimieren.
</p>

<p>
Wenn Sie Ihren Kernel manuell konfigurieren wollen fahren Sie nun mit <uri
link="#doc_chap3">Standard: Manuelle Konfiguration</uri> fort. Wenn
Sie <c>genkernel</c> benutzen wollen, sollten Sie stattdessen
<uri link="#doc_chap4">Alternativ: Benutzung von Genkernel</uri> lesen.
</p>

</body>
</subsection>
</section>
<section>
<title>Standard: Manuelle Konfiguration</title>
<subsection>
<title>Einführung</title>
<body>

<p>
Einen Kernel manuell zu konfigurieren wird oft als der schwierigste Teil
gesehen, den jeder Linux Benutzer insgesamt meistern muss. Nichts ist weiter von
der Wahrheit entfernt -- nach der Konfiguration von einigen Kerneln werden Sie
sich gar nicht daran erinnern, dass es schwer war ;-)
</p>

<p>
Jedoch eine Sache <e>ist</e> wahr: Sie müssen Ihr System kennen, wenn Sie
beginnen einen Kernel manuell zu konfigurieren. Die meisten Informationen
können gesammelt werden, indem Sie sich <path>/proc/pci</path> ansehen (oder
durch <c>lspci</c> benutzen, wenn vorhanden). Sie können auch
<c>lsmod</c> ausführen um zu sehen welche Kernelmodule die LiveCD verwendet
(es kann ihnen einen netten Hinweis darauf geben was zu aktivieren ist).
</p>

<p>
Gehen Sie nun in Ihr Kernelquellverzeichnis und führen Sie <c>make menuconfig</c>
aus. Dies startet ein ncurses-basierendes Konfigurationsmenü.
</p>

<pre caption="Menuconfig starten">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Ihnen werden verschiedene Konfigurationssektionen präsentiert. Wir listen
zunächst einige Optionen auf, die sie aktivieren müssen (ansonsten wird Gentoo
nicht funktionieren, oder ohne zusätzliche Veränderungen nicht richtig
funktionieren).
</p>

</body>
</subsection>
<subsection>
<title>Aktivieren der benötigten Optionen</title>
<body>

<p>
Zunächst aktivieren Sie die Benutzung von Entwicklungs- und Experiementellem/n
Code/Treiber(n). Sie brauchen dies, denn ansonsten werden einige wichtige
Codeabschnitte/Treiber nicht erscheinen.
</p>

<pre caption="Selektieren experimenteller/n Codes/Treiber">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
Stellen Sie sicher, dass alle Treiber, die notwendig sind um Ihr System zu
booten (wie zum Beispiel Treiber für einen SCSI-Controller) <e>in</e> den Kernel
und nicht als Modul kompiliert werden, da Ihr System andernfalls nicht
vollständig booten kann.
</p>

<p>
Wählen Sie nun die korrekte Prozessor Familie:
</p>

<pre caption="Auswahl der richtigen Prozessorfamilie">
Processor type and features ---&gt;
  <comment>(Passien Sie dies an Ihr System an)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

<p>
Gehen Sie nun in <c>File Systems</c> und selektieren Sie Unterstützung für die
Dateisysteme die Sie benutzen. Kompilieren Sie diese <e>nicht</e> als Module,
ansonsten wird ihr Gentoo System nicht fähig sein, Ihre Partitionen zu mounten.
Selektieren Sie auch <c>Virtual memory</c>, <c>/proc file system</c>, <c>/dev
file system</c> + <c>Automatically mount at boot</c>:
</p>

<pre caption="Selektieren notwendiger Dateisysteme">
<comment>(Mit einem 2.4.x Kernel)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(Mit einem 2.6.x Kernel)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] /dev file system support (OBSOLETE)
    [*]   Automatically mount at boot
    [*] /dev/pts file system for Unix98 PTYs
    [*] Virtual memory file system support (former shm fs)

<comment>(Selektieren Sie eine oder mehrere der folgenden Optionen, wie benötigt von Ihrem System)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Wenn Ihr BIOS nicht von großen Festplatten booten kann und Sie die Festplatte
gejumpert haben, damit diese dem BIOS eine begrenzte Größe meldet müssen Sie die
folgenden Optionen aktivieren, um Zugriff auf die gesamte Festplatte zu
erlangen:
</p>

<pre caption="Aktivieren des Autogeometry Resizing Support">
<comment>(Nur für 2.4 Kernel)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

<p>
Vergessen Sie nicht DMA für Ihre Laufwerke zu aktivieren:
</p>

<pre caption="DMA aktivieren">
Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
    [*]   Use PCI DMA by default when available
</pre>

<p>
Wenn Sie PPPoE benutzen um sich ins Internet einzuwählen oder Sie benutzen
ein Einwahl Modem, brauchen Sie folgende Optionen im Kernel:
</p>

<pre caption="Auswählen PPPoE notwendiger Treiber">
<comment>Mit einem 2.4.x Kernel)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports
<comment>(Mit einem 2.6.x Kernel)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Die zwei Komprimierungsoptionen werden nicht schaden, aber werden auch nicht
definitiv gebraucht, ebenso die <c>PPP over Ethernet</c> Option, die vielleicht
nur von <c>rp-pppoe</c> verwendet wird, wenn der Kernelmodus PPPoE benutzt wird.
</p>

<p>
Wenn Sie es benötigen, vergessen Sie nicht Ünterstützung für Ihre Netzwerkkarte
in Ihren Kernel einzubinden.
</p>

<p>
Wenn Sie eine Intel CPU haben, die HyperThreading (tm) unterstützt, oder ein
Mehrprozessorsystem haben, sollten Sie "Symmetric multi-processing support"
aktivieren:
</p>

<pre caption="Aktivieren der SMP Unterstützung">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<p>
Wenn Sie USB Eingabegeräte wie eine Tastatur oder Maus nutzen möchten, vergessen
Sie Unterstützung für diese ebenfalls nicht:
</p>

<pre caption="Aktivieren der USB Unterstützung für Eingabegeräte">
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

<p>
Laptop Nutzer die PCMCIA Unterstützung benötigen sollten <e>nicht</e> die PCMCIA
Treiber nutzen, wenn Sie einen 2.4 Kernel konfigurieren. Aktuellere Treiber sind
durch das <c>pcmcia-cs</c> Paket verfügbar, welches Sie später installieren
können. 2.6 Kernel Benutzer sollten die PCMCIA Treiber aus dem Kernel benutzen.
</p>

<p>
Neben der PCMCIA Unterstützung in einem 2.6 Kernel sollten Sie ebenfalls nicht
die Unterstützung für die PCMCIA Card Bridge vergessen, die in Ihrem System zum
Einsatz kommt.
</p>

<pre caption="Aktivieren von PCMCIA Unterstützung für 2.6 Kernel">
Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
<comment>(Wählen Sie 16-Bit Unterstützung, wenn Sie planen ältere Karten einzusetzen.)</comment>
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
<comment>(Wählen Sie die relevanten Treiber)</comment>
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
Wenn Sie die Konfiguration des Kernel beendet haben fahren Sie mit <uri
link="#compiling">Kompilieren und Installieren</uri> fort.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilieren und Installieren</title>
<body>

<p>
Nun da Ihr Kernel konfiguriert ist, ist es Zeit ihn zu kompilieren und zu
installieren. Verlassen Sie die Konfiguration und führen Sie <c>make dep
&amp;&amp; make bzImage modules modules_install</c> aus:
</p>

<pre caption="Kompilieren des Kernels">
<comment>(Für 2.4 Kernel)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(Für 2.6 Kernel)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Wenn der Kernel fertig ist mit der Kompilierung, kopieren Sie das Kernel-Image
nach <path>/boot</path>. Im nächsten Beispiel nehmen wir an, dass Sie die
<c>gentoo-sources</c> in Version 2.6.11-r3 konfiguriert und kompiliert haben.
Benutzen Sie einen beliebigen Namen, merken Sie sich diesen jedoch, da wir ihn
später noch zur Konfiguration des Bootloader benötigen.
</p>

<pre caption="Installieren des Kernels">
# <i>cp arch/i386/boot/bzImage /boot/kernel-2.6.11-gentoo-r3</i>
# <i>cp System.map /boot/System.map-2.6.11-gentoo-r3</i>
</pre>

<p>
Es ist auch Weise Ihre Kernelkonfiguration nach <path>/boot</path> zu kopieren,
nur für alle Fälle :)
</p>

<pre caption="Erstellen eines Backups der Kernelkonfiguration ">
# <i>cp .config /boot/config-2.6.11-gentoo-r3</i>
</pre>

<p>Fahren Sie nun mit dem <uri link="#doc_chap5">Installieren separater
Kernelmodule</uri> fort.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternativ: Benutzung von Genkernel</title>
<body>

<p>
Wenn Sie diesen Abschnitt lesen, haben Sie sich entschieden unser
<c>genkernel</c> Script zu benutzen, um sich Ihren Kernel konfigurieren zu
lassen.
</p>

<p>
Nun da Ihr Kernelquellbaum installiert ist, ist es an der Zeit Ihren Kernel
automatisch durch das <c>genkernel</c> Script erstellen zu lassen. <c>genkernel</c>
arbeitet so, dass es einen Kernel konfiguriert, der fast identisch ist zu denen
auf unser Installations CD. Dies bedeutet, dass wenn Sie <c>genkernel</c> benutzen um
Ihren Kernel zu erstellen, Ihr System generell alle Hardware beim Booten erkennt,
genau wie es unsere Installations CD tut. Weil <c>genkernel</c> keine manuelle
Kernelkonfiguration erfordert ist es eine ideale Lösung für die Benutzer, denen
Unwohl bei der Kompilierung eines eigenen Kernel ist.
</p>

<p>
Nun lassen Sie uns sehen wie man Genkernel benutzt. Zuerst installieren Sie
<c>genkernel</c>:
</p>

<pre caption="Genkernel emergen">
# <i>emerge genkernel</i>
</pre>

<p>
Wenn Sie einen 2.6 Kernel konfigurieren, kopieren Sie die Kernel Konfiguration
von der Installations CD an die Stelle, an der genkernel nach der
Standardkonfiguration schaut:
</p>

<pre caption="Kopieren der Kernel Konfiguration der Installations CD">
<comment>(Nur wenn Sie einen 2.6 Kernel verwenden möchten)</comment>
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

<p>
Kompilieren Sie nun Ihre Kernelquellen durch <c>genkernel --udev all</c> (für
2.6 Kernel) oder <c>genkernel all</c> (für 2.4 Kernel).
Seien Sie sich aber bewusst, dass <c>genkernel</c> einen Kernel kompiliert,
der fast alle Hardware unterstützt, was bedeutet dass das Kompilieren durchaus
eine ganze Weile dauern kann!
</p>

<p>
Beachten Sie das, wenn Ihre Boot Partition weder ext2 noch ext3 als Dateisystem
benutzt Sie Ihren Kernel selber mit <c>genkernel --menuconfig all</c>
konfigurieren und Unterstützung für Ihr Dateisystem <c>im</c> Kernel aktivieren
müssen (<e>nicht</e> als Modul). Benutzer von EVMS2 oder LVM2 möchten vermutlich
das <c>--evms2</c> oder das <c>--lvm2</c> Argument hinzufügen.
</p>

<pre caption="Ausführen von Genkernel">
<comment>(Für 2.6 Kernel)</comment>
# <i>genkernel --udev all</i>

<comment>(Für 2.4 Kernel)</comment>
# <i>genkernel --all</i>
</pre>

<p>
Sobald <c>genkernel</c> beendet ist werden ein Kernel, ein voller Satz Module
und eine <e>initial root disk</e> (initrd) erstellt sein. Wir werden den Kernel
und initrd benutzen wenn wir später in diesem Handbuch einen Bootloader
konfigurieren. Schreiben Sie den Namen des Kernels und den Ihrer initrd auf, da
Sie diese brauchen werden, wenn Sie die den Bootloader konfigurieren.
Die initrd wird direkt nach dem Booten gestartet um die Hardware
Autoerkennung zu starten (genau wie auf der LiveCD) bevor ihr "wahres" System
startet.
</p>

<pre caption="Kontrollieren des Kernel Image Namen und der initrd">
# <i>ls /boot/kernel* /boot/initrd*</i>
</pre>

<p>
Nun lassen Sie uns einen weiteren Schritt tun, der unser System dazu bringt mehr
wie die LiveCD zu sein -- lassen Sie uns <c>hotplug</c> emergen. Während die
initrd die Hardware automatisch erkennt, die nötig ist um Ihr System zu starten,
wird <c>coldplug</c> automatisch alles andere erkennen. Um <c>coldplug</c> zu
installieren und zu aktivieren tippen Sie folgendes:
</p>

<pre caption="Emergen und aktivieren von Coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Wenn Sie möchten, dass Ihr System auf Hotplugging Events reagiert, möchten Sie
ebenfalls hotplug installieren und einrichten:
</p>

<pre caption="Installieren und aktivieren hotplug">
# <i>emerge hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

</body>
</section>
<section>
<title>Installieren separater Kernelmodule</title>
<subsection>
<title>Installation zusätzlicher Module</title>
<body>

<p>
Wenn passend sollten Sie mit emerge Ebuilds für jegliche zusätzliche Hardware,
die in Ihrem System steckt, installieren. Hier ist eine Liste von Kernel
relevanten Ebuilds die Sie emergen können:
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="4in"/>
<tcolumn width="2in"/>
<tr>
  <th>Ebuild</th>
  <th>Zweck</th>
  <th>Befehl</th>
</tr>
<tr>
  <ti>nvidia-kernel</ti>
  <ti>Beschleunigte NVIDIA Grafik für XFree86</ti>
  <ti><c>emerge nvidia-kernel</c></ti>
</tr>
<tr>
  <ti>nforce-audio</ti>
  <ti>On-board Soundkarten auf NVIDIA NForce(2) Mainboards</ti>
  <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
  <ti>e100</ti>
  <ti>Intel e100 Fast Ethernet Adapter (nur für 2.4 Kernel)</ti>
  <ti><c>emerge e100</c></ti>
</tr>
<tr>
  <ti>e1000</ti>
  <ti>Intel e1000 Gigabit Ethernet Adapter (nur für 2.4 Kernel)</ti>
  <ti><c>emerge e1000</c></ti>
</tr>
<tr>
  <ti>emu10k1</ti>
  <ti>Creative Sound Blaster Live!/Audigy Unterstützung</ti>
  <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
  <ti>ati-drivers</ti>
  <ti>Beschleunigte ATI Radeon 8500+/FireGL Grafik für XFree86</ti>
  <ti><c>emerge ati-drivers</c></ti>
</tr>
</table>

<p>
Beachten Sie jedoch, dass einige dieser Ebuilds große Abhängigkeiten (sog.
Dependencies) mit sich bringen können. Um zu erfahren, welche Pakete durch das
emerge eines Ebuilds installiert werden sollen, benutzen Sie <c>emerge --pretend</c>.
Zum Beispiel für das <c>emu10k1</c> Paket:
</p>

<pre caption="Betrachten der vollen Liste der zu installierenden Pakete">
# <i>emerge --pretend emu10k1</i>
</pre>

<p>
Wenn Sie die Pakete nicht mögen, die installiert werden sollen, benutzen Sie
<c>emerge --pretend --verbose</c> um zu sehen, welche USE-Flags Auswirkungen auf
die Abhängigkeiten haben:
</p>

<pre caption="Betrachten der USE-Flag Benutzung">
# <i>emerge --pretend --verbose emu10k1</i>
<comment>...</comment>
[ebuild  N    ] media-sound/aumix-2.8  +gpm +nls +gtk +gnome +alsa -gtk2
</pre>

<p>
Im vorigen Beispiel können Sie sehen, dass eine der Abhängigkeiten von
<c>emu10k1</c> (<c>aumix</c>) die <c>gtk</c> und <c>gnome</c> USE-Flags
beinhaltet, was dazu führt, dass gtk (was abhängig ist von XFree) mit
kompiliert wird.
</p>

<p>
Wenn Sie nicht wollen, dass all dies mitkompiliert wird, deaktivieren Sie alle
USE-Flags, die Sie nicht (oder im Moment nicht) benötigen; zum Beispiel:
</p>

<pre caption="emu10k1 mit allen USE-Flags deaktiviert">
# <i>USE="-gpm -nls -gtk -gnome -alsa" emerge --pretend emu10k1</i>
</pre>

<p>
Wenn Sie mit dem Resultat zufrieden sind, entfernen Sie das
<c>--pretend</c> um die Installation von <c>emu10k1</c> zu starten.
</p>

</body>
</subsection>
<subsection>
<title>Konfiguration der Module</title>
<body>

<p>
Sie sollten alle Module, die automatisch geladen werden sollen, in
<path>/etc/modules.autoload.d/kernel-2.4</path> (oder <path>kernel-2.6</path>)
eintragen. Wenn Sie möchten können Sie auch zusätzliche Optionen anhängen.
</p>

<p>
Um alle verfügbaren Module anzuzeigen führen Sie das folgende <c>find</c>
Kommando aus. Vergessen Sie nicht  "&lt;kernel version&gt;" mit der Version
Ihres Kernel zu ersetzen, den Sie gerade kompiliert haben:
</p>

<pre caption="Listen aller verfügbarer Module">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Um zum Beispiel das <c>3c59x.o</c> Modul automatisch zu laden editieren Sie die
entweder <path>kernel2-.4</path> oder das <path>kernel-2.6</path> Datei und
tragen das Modul ein.
</p>

<pre caption="/etc/modules.autoload.d/kernel-2.4">
<comment>(Beispiel für 2.4 kernels)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 oder kernel-2.6">
3c59x
</pre>

<p>
Fahren Sie nun mit der <uri link="?part=1&amp;chap=8">Konfiguration des
System</uri> fort.
</p>

</body>
</subsection>
</section>
</sections>
