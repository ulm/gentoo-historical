<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- English CVS Version: 1.60 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/handbook/Attic/hb-install-x86-kernel.xml,v 1.24 2006/02/14 07:06:46 grahl Exp $ -->

<sections>

<version>3.11</version>
<date>2006-01-06</date>

<section>
<title>Setzen der Zeitzone des Systems</title>
<body>

<p>
Zuerst müssen Sie Ihrem System mitteilen, in welcher Zeitzone es sich befindet.
Suchen Sie Ihre Zeitzone in <path>/usr/share/zoneinfo/</path> und kopieren Sie
diese nach <path>/etc/localtime</path>. Bitte vermeiden Sie die
<path>/usr/share/zoneinfo/Etc/GMT*</path> Zeitzonen, denn deren Namen verweisen
nicht auf die erwarteten Zonen. Zum Beispiel ist <path>GMT-8</path> in
Wirklichkeit GMT+8.
</p>

<pre caption="Setzen der Zeitzone">
# <i>ls /usr/share/zoneinfo</i>
<comment>(Beispiel: GMT)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>Installieren der Quellen</title>
<subsection>
<title>Auswählen eines Kernels</title>
<body>

<p>
Der Kern um den herum alle Distributionen gebaut sind ist der Linux-Kernel. Er
bildet die Ebene zwischen den Benutzerprogrammen und der Systemhardware. Gentoo
bietet seinen Benutzern verschiedene mögliche Kernelquellen. Eine komplette
Liste mit Beschreibungen finden Sie im <uri link="/doc/de/gentoo-kernel.xml">
Gentoo Kernel Guide</uri>.
</p>

<p>
Für x86-basierende Systeme haben wir unter den Kerneln die
<c>vanilla-sources</c> (die Standardkernelquelle der Linux Kernelentwicklern ohne 
jegliche Modifikation), die <c>gentoo-sources</c> (Kernelquelle modifiziert für
performanceverbessernde Eigenschaften), ...
</p>

<p>
Wählen Sie Ihre Kernelquelle aus und installieren Sie diese mit <c>emerge</c>.
Das <c>USE="-doc"</c> ist notwendig um zu verhindern, dass xorg-x11 oder andere
Abhängigkeiten zu diesem Zeitpunkt installiert werden. <c>USE="symlink"</c> ist
nicht zwingend bei einer Neuinstallation, stellt aber sicher, dass der
<path>/usr/src/linux</path> Symlink korrekt erstellt wird.
</p>

<pre caption="Installieren einer Kernelquelle">
# <i>USE="-doc symlink" emerge gentoo-sources</i>
</pre>

<p>
Wenn Sie einen Blick in <path>/usr/src</path> werfen, sollten Sie einen
symbolischen Link mit Namen <path>linux</path>sehen , der auf Ihre
Kernelquellen verweist. In diesem Fall verweisen die installierten
Kernelquellen auf <c>gentoo-sources-2.6.12-r10</c>. Beachten Sie, dass Ihre
Version davon abweichen kann.
</p>

<pre caption="Anzeigen des symbolischen Kernelquellen-Links">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root     root      12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.12-gentoo-r10
</pre>

<p>
Nun ist es Zeit Ihre Kernelquelle zu konfigurieren und zu kompilieren. Alle
Architekturen können <c>genkernel</c> verwenden, welches einen generischen
Kernel erstellt, wie er von der Installations-CD verwendet wird. Wir erklären die
"manuelle" Konfiguration jedoch zuerst, denn es ist der beste Weg Ihre Umgebung
zu optimieren.
</p>

<p>
Wenn Sie Ihren Kernel manuell konfigurieren wollen fahren Sie nun mit <uri
link="#doc_chap3">Standard: Manuelle Konfiguration</uri> fort. Wenn
Sie <c>genkernel</c> benutzen wollen, sollten Sie stattdessen
<uri link="#doc_chap4">Alternativ: Benutzung von Genkernel</uri> lesen.
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>Standard: Manuelle Konfiguration</title>
<subsection>
<title>Einführung</title>
<body>

<p>
Einen Kernel manuell zu konfigurieren wird oft als der schwierigste Teil
gesehen, den jeder Linux Benutzer insgesamt meistern muss. Nichts ist weiter von
der Wahrheit entfernt -- nach der Konfiguration von einigen Kerneln werden Sie
sich gar nicht daran erinnern, dass es schwer war.
</p>

<p>
Eine Sache jedoch <e>ist</e> wahr: Sie müssen Ihr System kennen, wenn Sie
beginnen einen Kernel manuell zu konfigurieren. Die meisten Informationen
über vorhandene Hardware können gesammelt werden, indem Sie sich pciutils 
installieren (<c>emerge pciutils</c>), welches <c>lspci</c> enthält. 
Sie haben nun die Möglichkeit <c>lspci</c> innerhalb der chroot-Umgebung zu 
verwenden. Sie können ohne Sorge jegliche <e>pcilib</e>-Warnungen 
(wie pcilib: cannot open /sys/bus/pci/devices), die <c>lspci</c> ausgibt, 
ignorieren. Alternativ können Sie <c>lspci</c> aus einer 
<e>nicht-chroot</e>-Umgebung ausführen. Das Resultat ist dasselbe. 
Sie können auch <c>lsmod</c> ausführen, um zu sehen 
welche Kernelmodule die Installations-CD verwendet (es kann ihnen einen guten 
Hinweis darauf geben was zu aktivieren ist).
</p>

<p>
Gehen Sie nun in Ihr Kernelquellverzeichnis und führen Sie <c>make menuconfig</c>
aus. Dies startet ein ncurses-basierentes Konfigurationsmenü.
</p>

<pre caption="Menuconfig starten">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Ihnen werden verschiedene Konfigurationssektionen präsentiert. Wir listen
zunächst einige Optionen auf, die sie aktivieren müssen (ansonsten wird Gentoo
nicht funktionieren, oder ohne zusätzliche Veränderungen nicht richtig
funktionieren).
</p>

</body>
</subsection>
<subsection>
<title>Aktivieren der benötigten Optionen</title>
<body>

<p>
Zunächst aktivieren Sie die Benutzung von Entwicklungs- und Experiementellem/n
Code/Treiber(n). Sie brauchen dies, denn ansonsten werden einige wichtige
Codeabschnitte/Treiber nicht erscheinen.
</p>

<pre caption="Selektieren experimenteller/n Codes/Treiber, Generelle Einstellungen">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
General setup  ---&gt;
  [*] Support for hot-pluggable devices
</pre>

<p>
Stellen Sie sicher, dass alle Treiber, die notwendig sind um Ihr System zu
booten (wie zum Beispiel Treiber für einen SCSI-Controller) <e>in</e> den Kernel
und nicht als Modul kompiliert werden, da Ihr System andernfalls nicht
vollständig booten kann.
</p>

<p>
Wählen Sie nun die korrekte Prozessor Familie:
</p>

<pre caption="Auswahl der richtigen Prozessorfamilie">
Processor type and features ---&gt;
  <comment>(Passen Sie dies an Ihr System an)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

<p>
Gehen Sie nun in <c>File Systems</c> und selektieren Sie Unterstützung für die
Dateisysteme die Sie benutzen. Kompilieren Sie diese <e>nicht</e> als Module,
ansonsten wird ihr Gentoo System nicht fähig sein, Ihre Partitionen beim Booten
zu mounten. Selektieren Sie auch <c>Virtual memory</c>,
<c>/proc file system</c>. Wenn sie einen 2.4 Kernel verwenden, müssen Sie auch
<c>/dev file system</c> selektieren, da 2.4 Kernel <c>udev</c> nicht
unterstützen.
</p>

<pre caption="Selektieren notwendiger Dateisysteme">
<comment>(Mit einem 2.4.x Kernel)</comment>
File systems ---&gt;
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  [ ] /dev/pts file system for Unix98 PTYs

<comment>(Mit einem 2.6.x Kernel)</comment>
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<comment>(Selektieren Sie eine oder mehrere der folgenden Optionen, wie benötigt von Ihrem System)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

<p>
Wenn Ihr BIOS nicht von großen Festplatten booten kann und Sie die Festplatte
gejumpert haben, damit diese dem BIOS eine begrenzte Größe meldet, müssen Sie 
die folgenden Optionen aktivieren, um Zugriff auf die gesamte Festplatte zu 
erlangen:
</p>

<pre caption="Aktivieren des Autogeometry Resizing Support">
<comment>(Nur für 2.4 Kernel)</comment>
ATA/IDE/MFM/RLL support ---&gt;
  IDE, ATA and ATAPI Block devices ---&gt;
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support
</pre>

<p>
Vergessen Sie nicht DMA für Ihre Laufwerke zu aktivieren:
</p>

<pre caption="DMA aktivieren">
Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
    [*]   Use PCI DMA by default when available
</pre>

<p>
Wenn Sie PPPoE oder ein Modem benutzen um sich ins Internet einzuwählen 
brauchen Sie folgende Optionen im Kernel:
</p>

<pre caption="Auswählen PPPoE notwendiger Treiber">
<comment>(Mit einem 2.4.x Kernel)</comment>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports
<comment>(Mit einem 2.6.x Kernel)</comment>
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
Die zwei Komprimierungsoptionen werden nicht schaden, aber werden auch nicht
definitiv gebraucht, ebenso die <c>PPP over Ethernet</c> Option, die vielleicht
nur von <c>rp-pppoe</c> verwendet wird, wenn der Kernelmodus PPPoE benutzt wird.
</p>

<p>
Wenn Sie diese benötigen, vergessen Sie nicht Ünterstützung für Ihre Netzwerkkarte
in Ihren Kernel einzubinden.
</p>

<p>
Wenn Sie eine Intel-CPU, die HyperThreading (tm) unterstützt, oder ein
Mehrprozessorsystem haben, sollten Sie "Symmetric multi-processing support"
aktivieren:
</p>

<pre caption="Aktivieren der SMP-Unterstützung">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<p>
Wenn Sie USB-Eingabegeräte wie eine Tastatur oder Maus nutzen möchten, vergessen
Sie Unterstützung für diese ebenfalls nicht:
</p>

<pre caption="Aktivieren der USB-Unterstützung für Eingabegeräte">
USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

<p>
Laptop-Nutzer, die PCMCIA-Unterstützung benötigen, sollten <e>nicht</e> die 
PCMCIA-Treiber nutzen, wenn Sie einen 2.4-Kernel konfigurieren. Aktuellere Treiber
sind durch das <c>pcmcia-cs</c> Paket verfügbar, welches Sie später installieren
können. Benutzer der Kernelversion 2.6 sollten die PCMCIA-Treiber aus dem Kernel
benutzen.
</p>

<p>
Neben der PCMCIA-Unterstützung in einem 2.6-Kernel sollten Sie ebenfalls nicht
die Unterstützung für die PCMCIA-Card-Bridge vergessen, die in Ihrem System zum
Einsatz kommt.
</p>

<pre caption="Aktivieren von PCMCIA-Unterstützung für 2.6-Kernel">
Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
<comment>(Wählen Sie 16-Bit Unterstützung, wenn Sie planen ältere Karten einzusetzen.)</comment>
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
<comment>(Wählen Sie die relevanten Treiber)</comment>
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
Wenn Sie die Konfiguration des Kernel beendet haben fahren Sie mit <uri
link="#compiling">Kompilieren und Installieren</uri> fort.
</p>

</body>
</subsection>
<subsection id="compiling">
<title>Kompilieren und Installieren</title>
<body>

<p>
Nun da Ihr Kernel konfiguriert ist, ist es Zeit ihn zu kompilieren und zu
installieren. Verlassen Sie die Konfiguration und führen Sie <c>make dep
&amp;&amp; make bzImage modules modules_install</c> aus:
</p>

<pre caption="Kompilieren des Kernels">
<comment>(Für 2.4 Kernel)</comment>
# <i>make dep &amp;&amp; make bzImage modules modules_install</i>

<comment>(Für 2.6 Kernel)</comment>
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
Wenn der Kernel fertig kompiliert ist, kopieren Sie das Kernel-Image nach 
<path>/boot</path>. Verwenden Sie jeglichen Namen, den Sie für Ihren Kernel
passend finden und merken Sie ihn sich, da Sie ihn später benötigen werden,
wenn Sie Ihren Bootloader konfigurieren. Denken Sie daran
<path>&lt;Kernelversion&gt;</path> durch den Namen und die Version Ihres
Kernels zu ersetzen.
</p>

<pre caption="Installieren des Kernels">
# <i>cp arch/i386/boot/bzImage /boot/&lt;Kernelversion&gt;</i>
</pre>

<p>
Fahren Sie nun mit <uri link="#kernel_modules">Kernelmodule</uri> fort.
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>Alternativ: Benutzung von Genkernel</title>
<body>

<p>
Wenn Sie diesen Abschnitt lesen, haben Sie sich entschieden unser
<c>genkernel</c>-Skript zu benutzen, um sich Ihren Kernel automatisch konfigurieren 
zu lassen.
</p>

<p>
Nun da Ihr Kernelquellbaum installiert ist, ist es an der Zeit Ihren Kernel
automatisch durch das <c>genkernel</c>-Script erstellen zu lassen. <c>genkernel</c>
arbeitet so, dass es einen Kernel konfiguriert, der fast identisch ist zu denen
auf unser Installations-CD. Dies bedeutet, dass wenn Sie <c>genkernel</c> benutzen
um Ihren Kernel zu erstellen, Ihr System generell alle Hardware beim Booten
erkennt, genau wie es unsere Installations-CD tut. Weil <c>genkernel</c> keine
manuelle Kernelkonfiguration erfordert ist es eine ideale Lösung für die 
Benutzer, denen bei der Kompilierung eines eigenen Kernels unwohl ist.
</p>

<p>
Nun lassen Sie uns sehen wie man Genkernel benutzt. Zuerst installieren Sie
<c>genkernel</c>:
</p>

<pre caption="Genkernel emergen">
# <i>emerge genkernel</i>
</pre>

<p>
Wenn Sie einen 2.6-Kernel konfigurieren, kopieren Sie die Kernel-Konfiguration
von der Installations-CD an die Stelle, an der genkernel nach der
Standardkonfiguration schaut:
</p>

<pre caption="Kopieren der Kernel Konfiguration der Installations-CD">
<comment>(Nur wenn Sie einen 2.6 Kernel verwenden möchten)</comment>
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

<p>
Kompilieren Sie nun Ihre Kernelquellen mit <c>genkernel all</c> Seien Sie sich
aber bewusst, dass <c>genkernel</c> einen Kernel kompiliert, der fast alle
Hardware unterstützt, was bedeutet dass das Kompilieren durchaus eine ganze
Weile dauern kann!
</p>

<p>
Beachten Sie das, wenn Ihre Boot-Partition weder ext2 noch ext3 als Dateisystem
benutzt Sie Ihren Kernel selber mit <c>genkernel --menuconfig all</c>
konfigurieren und Unterstützung für Ihr Dateisystem <c>im</c> Kernel aktivieren
müssen (<e>nicht</e> als Modul). Benutzer von EVMS2 oder LVM2 möchten vermutlich
das <c>--evms2</c> oder das <c>--lvm2</c> Argument hinzufügen.
</p>

<pre caption="Ausführen von Genkernel">
# <i>genkernel all</i>
</pre>

<p>
Sobald <c>genkernel</c> beendet ist werden ein Kernel, ein voller Satz Module
und eine <e>initial root disk</e> (initrd) erstellt sein. Wir werden den Kernel
und initrd benutzen wenn wir später in diesem Handbuch einen Bootloader
konfigurieren. Schreiben Sie den Namen des Kernels und den Ihrer initrd auf, da
Sie diese brauchen werden, wenn Sie die den Bootloader konfigurieren.
Die initrd wird direkt nach dem Booten gestartet um die Hardware
Autoerkennung zu starten (genau wie auf der Installations-CD) bevor ihr 
"wahres" System startet.
</p>

<pre caption="Kontrollieren des Kernel-Image-Namens und der initrd">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

<p>
Nun lassen Sie uns einen weiteren Schritt tun, der unser System dazu bringt
mehr wie die Installations-CD zu sein -- lassen Sie uns <c>coldplug</c>
emergen. Während die initrd die Hardware automatisch erkennt, die nötig ist um
Ihr System zu starten, wird <c>coldplug</c> automatisch alles andere erkennen.
Um  <c>coldplug</c> zu installieren und zu aktivieren tippen Sie folgendes:
</p>

<pre caption="Emergen und aktivieren von Coldplug">
# <i>emerge coldplug</i>
# <i>rc-update add coldplug boot</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>Kernelmodule</title>
<subsection>
<title>Konfiguration der Module</title>
<body>

<p>
Sie sollten alle Module, die automatisch geladen werden sollen, in
<path>/etc/modules.autoload.d/kernel-2.4</path> (oder <path>kernel-2.6</path>)
eintragen. Wenn Sie möchten können Sie auch zusätzliche Optionen anhängen.
</p>

<p>
Um alle verfügbaren Module anzuzeigen führen Sie das folgende <c>find</c>
Kommando aus. Vergessen Sie nicht "&lt;kernel version&gt;" mit der Version
Ihres Kernel zu ersetzen, den Sie gerade kompiliert haben:
</p>

<pre caption="Listen aller verfügbaren Module">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
Um zum Beispiel das <c>3c59x.o</c> Modul automatisch zu laden, editieren Sie
entweder <path>kernel-2.4</path> oder <path>kernel-2.6</path> und tragen das
Modul in die jeweilige Datei ein.
</p>

<pre caption="/etc/modules.autoload.d/kernel-2.4">
<comment>(Beispiel für 2.4 kernels)</comment>
# <i>nano -w /etc/modules.autoload.d/kernel-2.4</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.4 oder kernel-2.6">
3c59x
</pre>

<p>
Fahren Sie nun mit der <uri link="?part=1&amp;chap=8">Konfiguration des
System</uri> fort.
</p>

</body>
</subsection>
</section>
</sections>
