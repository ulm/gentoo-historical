<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- English CVS Version: 1.36 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/handbook/Attic/hb-install-disk.xml,v 1.9 2004/03/01 07:37:29 dertobi123 Exp $ -->

<sections>
<section>
<title>Einführung in Block Devices</title>
<subsection>
<title>Block Devices</title>
<body>

<p>
Wir werden einen guten Einblick in die Festplatten bezogenen Aspekte von Gentoo
Linux und Linux im allgemeinen, inklusive Linux Dateisystemen, Partitionen und
Block Devices erhalten.
Dann, sobald Sie mit den Vor- und Nachteilen von Festplatten und Dateisystemen
vertraut sind, werden Sie durch den Prozess des Partitionierens und der
Dateisystemerstellung für Ihre Gentoo Linux Installation geführt.
</p>

<p>
Zu Beginn werden wir Ihnen <e>Block Devices</e> vorstellen. Das berühmteste
Block Device is warscheinlich das, welches das erste IDE Laufwerk in einem
Linux System repräsentiert, namentlich <path>/dev/hda</path>. Wenn Ihr System
SCSI Laufwerke verwendet, dann wäre Ihre erste Festplatte
<path>/dev/sda</path>.
</p>

<p>
Das obige Block Device repräsentiert ein abstraktes Interface zur Festplatte.
Benutzerprogramme können diese Block Device benutzen, um Ihre Festplatte
anzusprechen, ohne sich darum zu kümmern, ob Ihre Festplatten IDE, SCSI oder
irgendwas anderes sind. Das Programm kann den Speicherplatz auf der Festplatte
einfach als eine Anhäufung von zusammenhängenden, zufällig zugreifbaren
512-Byte Blöcken ansprechen.
</p>
</body>
</subsection>
<subsection>
<title>Partitionen und Slices</title>
<body>

<p>
Obwohl es theoretisch möglich ist eine ganze Festplatte zu nutzen, um Ihr Linux
System zu beherbergen, wird dies in der Praxis so gut wie nie gemacht.
Stattdessen werden komplette Festplatten Block Devices in kleinere, besser
verwaltbare Block Devices unterteilt. Auf den meisten Systemen werden sie
<e>Partitionen</e> genant. Andere Architekturen benutzen ähnliche Techniken,
welche <e>Slices</e> genannt werden.
</p>

</body>
</subsection>
<subsection>
<title>Partitionen</title>
<body>

<p>
Es wird zwischen drei Partitionstypen unterschieden:
<e>primar</e>, <e>erweitert</e> und <e>logisch</e>.
</p>

<p>
Eine <e>primäre</e> Partition ist eine Partition, deren Informationen im MBR
(Master Boot Record) gespeichert sind. Da ein MBR sehr klein ist (512 Bytes),
können nur vier primäre Partitionen definiert werden (zum Beispiel
<path>/dev/hda1</path> bis <path>/dev/hda4</path>).
</p>

<p>
Eine <e>erweiterte</e> Partition ist eine spezielle primäre Partition (was
bedeutet, dass eine erweiterte Partition eine der vier möglichen primären
Partitionen sein muss), welche mehrere Partitionen beinhaltet. Eine solche
Partition existierte ursprünglich nicht, aber da vier Partitionen zu wenig sind,
wurden sie erfunden, um das Format zu erweitern ohne die Rückwärtskompabilität
zu verlieren.
</p>

<p>
Eine <e>logische</e> Partition ist eine Partition innerhalb einer erweiterten
Partition. Ihre Definitionen sind nicht im MBR gespeichert, sondern in der
erweiterten Partition.
</p>

</body>
</subsection>

<subsection>
<title>Advanced Storage</title>
<body>

<p>
Wenn Sie von einer Gentoo LiveCD gebootet haben, haben Sie die Möglichkeit EVMS
oder LVM2 zu benutzen, um ihr Partitionssetup flexibler zu gestalten. Während
der Installationsanleitung konzentrieren wir uns auf "normale" Partitionen, es
ist aber gut zu wissen, dass EVMS und LVM2 genauso unterstützt sind.
</p>

</body>
</subsection>

</section>
<section>
<title>Erstellung eines Partitionsschemas</title>
<subsection>
<title>Standard Partitionsschema</title>
<body>

<p>
Wenn Sie nicht daran interessiert sind ein Partitionsschema für Ihr System zu
erstellen, können Sie das (nicht LVM) Partitionsschema verwenden, welches wir
in diesem Handbuch benutzen:
</p>

<p>
Für x86 oder amd64:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Für ppc:
</p>

<table>
<tr>
  <th>Partition NewWorld</th>
  <th>Partition OldWorld</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(nicht benötigt)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Für Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Full disk</ti>
  <ti>Sun Disk Label (benötigt)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Um Gentoo von einer existierenden Distribution aus zu installieren, sollten
Sie zuerst Ihre bestehenden Partitionen verkleinern (wenn Sie keinen freien
Speicherplatz verfügbar haben). Sie können <uri
link="http://www.gnu.org/software/parted">GNU/Parted</uri> benutzen, um Ihre
Partitionen zu verkleinern.
</p>

<p>
Wenn Sie daran interessiert sind zu erfahren, wie groß eine Partition sein
sollte, oder auch wieviele Partitionen (oder Volumes) Sie benötigen, lesen
Sie weiter. Anderenfalls fahren Sie nun mit dem Partitionieren Ihrer
Festplatte fort:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Benutzung von fdisk auf x86 und amd64 zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap4">Benutzung von fdisk auf Alpha zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap5">Benutzung von fdisk auf SPARC zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap6">Benutzung von mac-fdisk auf PPC zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap7">Benutzung von fdisk auf HPPA zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap8">Benutzung von fdisk auf MIPS zur Partitionierung Ihrer
  Festplatte</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Wie viele und wie groß?</title>
<body>

<p>
Die Anzahl an Partitionen hängt von Ihrer Umgebung ab.
Wenn Sie z.B. eine Menge User haben, wollen Sie
höchst wahrscheinlich Ihr <path>/home</path> separat halten, da es die
Sicherheit erhöht und Backups einfacher macht. Wenn Sie Gentoo installieren um
als Mailserver zu fungieren, sollten Sie <path>/var</path> separat halten, da
alle Mails in <path>/var</path> gespeichert werden. Eine gute Wahl des
Dateisystems maximiert dann zusätzlich die Performance. Gameserver sollten ein
separates <path>/opt</path> haben, da die meisten Game Server dort installiert
werden. Der Grund ist ähnlich wie bei <path>/home</path>:
Sicherheit und Backups.
</p>

<p>
Wie Sie sehen können, hängt es sehr stark davon ab, was Sie erreichen wollen.
Separate Partitionen oder Volumes haben folgende Vorteile:
</p>

<ul>
<li>
  Sie können das Filesystem mit der höchsten Performance für jede Partition oder
  jedes Volume auswählen
</li>
<li>
  Ihr System behält noch freien Speicherplatz, selbst wenn ein defektes Tool
  ununterbrochen Dateien auf eine Partition oder ein Volume schreibt
</li>
<li>
  Falls nötig können Dateisystem Checks zeitlich verkürzt werden, in dem
  mehrere Checks parallel durchgeführt werden können (obwohl dieser Vorteil eher
  mit mehreren Festplatten als mit mehreren Partitionen zum Tragen kommt)
</li>
<li>
  Die Sicherheit kann erhöht werden, indem Sie einige Partitionen oder Volumes
  read-only, nosuid (setuid bits werden ignoriert), noexec (executable bits
  werden ignoriert) etc mounten.
</li>
</ul>

<p>
Wie dem auch sei, mehrere Partitionen haben einen großen Nachteil: wenn sie nicht
ordentlich konfiguriert werden, könnte das Resultat ein System sein, welches viel
Speicherplatz auf der einen Partition und keinen auf einer anderen frei hat.
</p>

<p>
Als Beispiel zeigen wir Ihnen die Partitionierung einer 20GB Festplatte, welche
in einem Notebook zu Demonstrationszwecken genutzt wird (inklusive webserver,
mailserver, gnome, ...):
</p>

<pre caption="Filesystem usage example">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Unpartitionierter Speicherplatz für zukünftige Benutzung: 2 GB)</comment>
</pre>

<p>
<path>/usr</path> ist ziemlich voll (83% used), aber sobald die ganze Software
installiert ist, tendiert <path>/usr</path> nicht mehr dazu allzuviel zu
wachsen.
Man könnte denken der zugewiesene Speicherplatz für <path>/var</path>, sei
zuviel, aber Gentoo kompiliert alle Programme in <path>/var/tmp/portage</path>,
daher sollten Sie für <path>/var</path> mindestens 1GB frei haben, wenn Sie
keine großen Programme installieren wollen; mit einer Größe von bis zu 3GB
sollten auch KDE und OpenOffice.org kein Problem mehr sein.
</p>

<p>
Jetzt partitionieren Sie Ihre Festplatte(n) mit Hilfe der Anleitungen die für
Ihre Architektur als Beispiel zur Verfügung stehen:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Benutzung von fdisk auf x86 zur Partitionierung Ihrer
  Festplatte
  </uri>
</li>
<li>
  <uri link="#doc_chap4">Benutzung von fdisk auf Alpha zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap5">Benutzung von fdisk auf SPARC zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap6">Benutzung von mac-fdisk auf PPC zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap7">Benutzung von fdisk auf HPPA zur Partitionierung Ihrer
  Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap8">Benutzung von fdisk auf MIPS zur Partitionierung Ihrer
  Festplatte</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Benutzung von fdisk auf x86 und amd64 zur Partitionierung Ihrer Festplatte</title>
<subsection>
<body>

<impo>
Nur Benutzer mit einem auf <e>x86</e> oder <e>amd64</e> basierendem System sollten 
diesen Abschnitt lesen.
</impo>

<p>
Die folgenden Teile erklären, wie das bereits beschriebene Beispiel
Partitionslayout erstellt wird:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Ändern Sie Ihr Partitionslayout nach Ihren eigenen Vorstellungen.
</p>

</body>
</subsection>
<subsection>
<title>Die derzeitige Partitionstabelle ansehen</title>
<body>

<p>
<c>fdisk</c> ist ein verbreitetes und mächtiges Tool um Ihre Festplatte in
Partitionen zu teilen. Starten Sie <c>fdisk</c> für Ihre Festplatte (in unserem
Beispiel benutzen wir <path>/dev/hda</path>):
</p>

<pre caption="Starten von fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Sobald Sie in <c>fdisk</c> sind, werden Sie mit folgendem Prompt begrüßt:
</p>

<pre caption="fdisk Prompt">
Command (m for help): 
</pre>

<p>
Drücken Sie <c>p</c> um Ihr derzeitige Partitionstabelle anzeigen zu lassen:
</p>

<pre caption="Ein Beispiel Partitionstabelle">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Diese Festplatte beherbergt sieben Linux Dateisysteme (jedes mit einer
dazugehörigen Partition, gelistet als "Linux") und auch eine Swap Partition
(gelistet als "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Löschen aller Partitionen</title>
<body>

<p>
Zuerst entfernen wir alle existierenden Partitionen von der Festplatte. Drücken
Sie <c>d</c> um eine Partition zu löschen. Zum Beispiel um ein bestehendes
<path>/dev/hda1</path> zu löschen:
</p>

<pre caption="Löschen einer Partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Die Partition wurde zum Löschen markiert und wird nicht mehr angezeigt, wenn
Sie <c>p</c> drücken, sie wird aber nicht gelöscht, bis Ihre Änderungen
gespeichert sind. Wenn Sie einen Fehler gemacht haben und ohne zu Speichern
abbrechen wollen, drücken Sie umgehend <c>q</c> und Enter; Ihre Partition wird
dann nicht gelöscht.
</p>

<p>
Angenommen, dass Sie wirklich all Ihre Partitionen auf Ihrer Festplatte löschen
wollen, drücken Sie noch einmal <c>p</c> um die Partitionstabelle anzuzeigen und
dann <c>d</c> und die Nummer der Partition die Sie löschen wollen. Irgendwann
werden Sie eine leere Partitionstabelle haben:
</p>

<pre caption="Eine leere Partitionstabelle">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Jetzt, da die Partitionstabelle im Speicher leer ist, sind wir vorbereitet, um
die Partitionen zu erstellen. Wir werden ein Standard Partitionsschema benutzen,
wie wir es zuvor angesprochen haben.
Natürlich sollten Sie die Instruktionen nicht buchstäblich ausführen, wenn Sie
ein anderes Partitions Schema verwenden wollen!
</p>

</body>
</subsection>
<subsection>
<title>Erstellung der Boot Partition</title>
<body>

<p>
Zuerst erstellen wir eine kleine Boot Partition. Drücken Sie <c>n</c> um eine
neue Partition zu erstellen, dann <c>p</c> um eine primäre Partition zu wählen,
gefolgt von <c>1</c> für die erste primäre Partition. Wenn Sie nach dem ersten
Zylinder gefragt werden, drücken Sie Enter. Für den letzten Zylinder geben Sie
<c>+32M</c> ein, um eine 32 MB Partition zu erzeugen.
</p>

<pre caption="Erstellen der Boot Partition">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Enter Taste drücken)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Wenn Sie jetzt <c>p</c> drücken, sollten Sie die folgende Partitionstabelle
sehen:
</p>

<pre caption="Erstellte Boot Partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>


<p>
Sie müssen diese Partition bootbar machen. Drücken Sie <c>a</c> um das bootable
Flag auf dieser Partition zu aktivieren. Wenn Sie wiederum <c>p</c> drücken,
werden Sie feststellen, dass in der "Boot" Spalte ein <path>*</path> platziert
ist.
</p>

</body>
</subsection>
<subsection>
<title>Erstellen der Swap Partition</title>
<body>

<p>
Nun erstellen Sie die Swap Partition. Dazu drücken Sie <c>n</c> um
eine Partition zu erstellen, dann <c>p</c> um fdisk mitzuteilen, dass Sie eine
primäre Partition anlegen möchten. Dann drücken Sie <c>2</c> um die zweite
primäre Partition, <path>dev/hda2</path> in unserem Fall, anzulegen. Wenn Sie
nach dem ersten Zylinder gefragt werden, drücken Sie Enter. Wenn Sie nach dem
letzen Zylinder gefragt werden, tippen Sie <c>+512M</c> um eine Partition mit
einer Größe von 512 MB zu erstellen. Nachdem Sie dies getan haben, müssen Sie mit
<c>t</c> den Partitionstyp festlegen, <c>2</c> um die gerade angelegte Partition
auszuwaehlen und dann <c>82</c> um den Partitionstyp als "Linux Swap"
festzulegen. Nachdem Sie diese Schritte abgeschlossen haben, drücken Sie
<c>p</c> und Sie erhalten eine Paritionstabelle, die dieser recht ähnlich
schaut:
</p>

<pre caption="Partitionstabelle nach dem Erstellen der Swap Partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen der Root Partition</title>
<body>

<p>
Zum Schluss müssen sie noch die Root Partition erstellen. Dazu drücken
Sie <c>n</c> um eine Partition zu erstellen, dann <c>p</c> um fdisk mitzuteilen,
dass Sie eine primäre Partition anlegen möchten. Dann drücken Sie <c>3</c> um die
dritte primäre Partition, <path>dev/hda3</path> in unserem Fall, anzulegen. Wenn Sie
nach dem ersten Zylinder gefragt werden, drücken Sie Enter. Wenn Sie nach dem
letzen Zylinder gefragt werden, tippen Sie Enter um eine Partition zu erstellen,
die den restlichen freien Platz belegt. Nachdem Sie diese Schritte abgeschlossen
haben, drücken Sie <c>p</c> und Sie erhalten eine Paritionstabelle, die dieser recht
ähnlich sieht:
</p>

<pre caption="Partitionstabelle nach dem Erstellen der Root Partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Speichern der Partitionstabelle</title>
<body>

<p>
Um die Partitionstablle zu speichern und <c>fdisk</c> zu verlassen, drücken Sie
<c>w</c>.
</p>

<pre caption="Speichern und verlassen von fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Nachdem Ihre Partitionen nun erstellt sind können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren.
</p>

</body>
</subsection>
</section>
<section>
<title>Benutzung von fdisk auf Alpha zur Partitionierung Ihrer Festplatte</title>
<subsection>
<body>

<impo>
Nur Benutzer von <e>Alpha</e> basierenden Systeme sollten diesen Abschnitt
lesen.
</impo>

<p>
Die folgende Teile erklären, wie Sie das vorhin vorgestellte Slice Layout
erstellen.
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap Slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root Slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Ganze Festplatte (benötigt)</ti>
</tr>
</table>

<p>
Passen Sie das Slice Layout an Ihre Vorstellungen an.
</p>


</body>
</subsection>
<subsection>
<title>Identifizierung verfügbarer Festplatten</title>
<body>

<p>
Um herauszufinden, welche Festplatten Ihnen zur Verfügung stehen, benutzen Sie
die folgenden Kommandos:
</p>

<pre caption="Identifizierung verfügbarer Festplatten">
<comment>(Für IDE Festplatten)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Für SCSI Festplatten)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Aus dieser Ausgabe sollten Sie in der Lage sein zu erkennen, welche Festplatten
erkannt wurden und deren besonderen <path>/dev</path> Eintrag abzulesen. In den
folgenden Abschnitten gehen wir von einer SCSI Festplatte auf
<path>/dev/sda</path> aus.
</p>

<p>
Starten Sie nun <c>fdisk</c>:
</p>

<pre caption="Starten von fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Löschen von allen Slices</title>
<body>

<p>
Wir beginnen mit dem Löschen von allen Slices, <c>außer</c> des 'c'-Slice.
Nachfolgend zeigen wir Ihnen, wie Sie ein Slice (im Beispiel nutzen wir 'a')
löschen können. Wiederholen Sie den Schritt für alle Slices (wieder: außer des
'c'-Slice).
</p>

<p>
Benutzen Sie <c>p</c> um alle existierenden Slices anzuzeigen. <c>d</c>
benötigen Sie zum Löschen eines Slices.
</p>

<pre caption="Löschen eines Slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Nachdem Sie den Prozess für alle anderen Slices wiederholt haben, sollte die
Auflistung folgender ähnlich sehen:
</p>

<pre caption="Ansicht einer leeren Partitionstabelle">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen des Swap Slice</title>
<body>

<p>
Auf Alpha basierten System benötigen Sie keine separate Boot Partition. Dennoch
kann der erste Zylinder nicht benutzt werden, da das <c>aboot</c> Image dort
abgelegt werden wird.
</p>

<p>
Wir werden ein Swap Slice beginnend am dritten Cylinder mit einer Größe von 1
GB erstellen. Benutzen Sie <c>n</c> um ein neues Slice zu erstellen. Nachdem Sie
das Slice erstellt haben, ändern Sie den Typ mit <c>1</c> auf Swap.
</p>

<pre caption="Erstellen der Swap Slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Nach diesen Schritten sollten Sie ein der folgenden Auflistung ähnliches Layout
sehen:
</p>

<pre caption="Slice Layout nach dem Erstellen des Swap Slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen des Root Slice</title>
<body>

<p>
Wir werden nun das Root Slice anlegen beginnend vom ersten Zylinder <e>nach</e>
der Swap Slice. Benutzen Sie das <c>p</c> Kommando um zu schauen, wo das Swap
Slice endet. In unserem Beispiel ist dies 1003, das Root Slice beginnt also
bei 1004.
</p>

<p>
Ein weiteres Problem ist, dass aktuell ein Bug in <c>fdisk</c> existiert.
Dadurch denkt <c>fdisk</c>, dass die Anzahl verfügbarer Zylinder Eins
über der realen Zahl der Zylinder liegt. In anderen Worten, wenn Sie nach dem
letzten Zylinder gefragt werden, verkleinern Sie die Zylindernummer (in diesem
Beispiel: 5290) um eins.
</p>

<p>
Wenn das Slice erstellt wurde, ändern Sie den Typ auf <c>8</c> für <e>ext2</e>.
</p>

<pre caption="Erstellen des Root Slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Ihr Slice Layout sollte nun ähnlich dem Folgenden aussehen:
</p>

<pre caption="Ansicht des Slice Layout">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Speichern des Slice Layout und Beenden von fdisk</title>
<body>

<p>
Schliessen Sie <c>fdisk</c> indem Sie <c>w</c> eingeben. Damit wird auch Ihr
Slice Layout gespeichert.
</p>

<pre caption="Speichern und Verlassen von fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Nachdem Ihre Slices nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren
</p>

</body>
</subsection>
</section>
<section>
<title>Benutzung von fdisk auf SPARC zur Partitionierung Ihrer Festplatte</title>
<subsection>
<body>

<impo>
Nur Benutzer mit <e>SPARC</e> basierten System sollten diesen Abschnitt lesen.
</impo>

<p>
Die folgenden Teile erklären, wie das bereits beschriebene
Partitionslayout Beispiel erstellt wird:</p>

<table>
<tr>
  <th>Partition</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (benötigt)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Passen Sie das Partitionslayout an Ihre Vorstellungen an.
</p>


</body>
</subsection>
<subsection>
<title>Starten von fdisk</title>
<body>

<p>
Starten Sie <c>fdisk</c> mit Ihrer Festplatte als Argument.
</p>

<pre caption="Starten von fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Sie sollten vom fdisk Prompt begrüßt werden:
</p>

<pre caption="Der fdisk Prompt">
Command (m for help):
</pre>

<p>
Um die verfügbaren Partitionen anzuzeigen, drücken Sie <c>p</c>:
</p>

<pre caption="Auflisten verfügbarer Partitionen">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Beachten Sie das <c>Sun Disk Label</c> in der Ausgabe. Wenn dieses fehlt, benutzt
die Festplatte die DOS-Partitionierung, nicht die Sun Partitionierung. In diesem
Fall benutzen Sie <c>s</c> um sicherzustellen, dass die Festplatte eine Sun
Partitionstabelle hat.
</p>

</body>
</subsection>
<subsection>
<title>Löschen existierender Partitionen</title>
<body>

<p>
Es ist nun Zeit alle existierenden Partitionen zu löschen. Dazu
geben Sie <c>d</c> ein und drücken Enter. Sie werden dann nach einer
Partitionsnummer gefragt, die Sie löschen möchten. Um eine bereits existierende
<path>/dev/hda1</path> zu löschen, würden Sie folgendes eingeben:
</p>

<pre caption="Löschen einer Partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Nachfolgend gehen wir davon aus, dass Sie alle existierenden Partitionen löschen
möchten. Drücken Sie <c>p</c> um sich alle verfügbaren Partitionen anzeigen zu
lassen und <c>d</c> um eine davon zu löschen. Wenn Sie glauben einen Fehler
gemacht zu haben, drücken Sie sofort <c>q</c>. <c>fdisk</c> ändert die
Partitionstabelle nicht sofort, behält aber die Änderungen im Speicher. Nur wenn
Sie <c>w</c> drücken werden Ihre vorgenommenen Änderungen auch gespeichert.
</p>

<p>
Nachdem Sie alle Partitionen gelöscht haben, sollte Ihre Partitionstabelle
ähnlich wie folgende aussehen:
</p>

<pre caption="Ansicht einer leeren Partitionstabelle">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Erstellen des Sun Disk Label</title>
<body>

<p>
Nun, da die Partitionstabelle leer ist, sind wir bereit die Sun Disk Label
Partition zu erstellen. Dazu drücken Sie <c>n</c> um eine neue
Partition zu erstellen, dann drücken Sie <c>3</c> um die Partition zu erstellen.
Wenn Sie nach dem ersten Zylinder gefragt werden, drücken Sie Enter. Nachdem Sie
dies getan haben, drücken Sie <c>t</c> um den Partitionstyp zu ändern und
drücken dann <c>5</c>, um den Partitiontyp auf "Whole disk" zu setzen.
</p>

<pre caption="Schritte zu Erstellung eines Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Enter Taste drücken)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Nachdem Sie diese Schritte abgeschlossen haben, drücken Sie <c>p</c> und Ihnen
sollte eine Partitionstabelle angezeigt werden, die der folgenden recht ähnlich
sieht:
</p>

<pre caption="Ansicht der Partitionstabelle">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen der Boot Partition</title>
<body>

<p>
Zuerst erstellen wir eine kleine Boot Partition. Drücken Sie <c>n</c> um eine
neue Partition zu erstellen, gefolgt von <c>1</c> um die Partition zu erstellen.
Wenn Sie nach dem ersten Zylinder gefragt werden, drücken Sie Enter. Für den
letzten Zylinder geben Sie <c>+32M</c> ein, um eine 32 MB Partition zu erzeugen.
Stellen Sie sicher, dass die gesamte Boot Partition innerhalb der ersten 2GB der
Festplatte liegt. Sie können die Ausgabe dieser Schritte hier sehen:
</p>

<pre caption="Erstellen einer Boot Partition">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Enter Taste drücken)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Wenn Sie nun <c>p</c> drücken, sollte Ihnen folgende Partitionstabelle angezeigt
werden:
</p>

<pre caption="Ansicht der Partitionstabelle">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Erstellen einer Swap Partition</title>
<body>

<p>
Nun erstellen Sie die Swap Partition. Dazu drücken Sie <c>n</c> um
eine Partition zu erstellen, dann <c>2</c> um die zweite Partition,
<path>dev/hda2</path> in unserem Fall, anzulegen. Wenn Sie nach dem ersten
Zylinder gefragt werden, drücken Sie Enter. Wenn Sie nach dem letzten Zylinder
gefragt werden, tippen Sie <c>+512M</c> um eine Partition mit
einer Größe von 512 MB zu erstellen. Nachdem Sie dies getan haben, müssen Sie mit
<c>t</c> den Partitionstyp festlegen und dann <c>82</c> um den Partitionstyp als
"Linux Swap" festzulegen. Nachdem Sie diese Schritte abgeschlossen haben, drücken
Sie <c>p</c> und Sie erhalten eine Partitionstabelle, die dieser recht ähnlich
schaut:
</p>

<pre caption="Auflistung verfügbarer Partitionen">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen der Root Partition</title>
<body>

<p>
Zum Schluss müssen sie noch die Root Partition erstellen. Dazu drücken
Sie <c>n</c> um eine Partition zu erstellen, dann drücken Sie <c>4</c> um
die dritte Partition, <path>dev/hda4</path> in unserem Fall, anzulegen. Wenn Sie
nach dem ersten Zylinder gefragt werden, drücken Sie Enter. Wenn Sie nach dem
letzten Zylinder gefragt werden, drücken Sie Enter um eine Partition zu erstellen,
die den restlichen freien Platz belegt. Nachdem Sie diese Schritte abgeschlossen
haben, drücken Sie <c>p</c> und Sie erhalten eine Partitionstabelle, die dieser recht
ähnlich sieht:
</p>

<pre caption="Auflistung der vollständigen Partitionstabelle">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Speichern und fdisk beenden</title>
<body>

<p>
Um Ihre Partitionstablle zu sichern und <c>fdisk</c> zu beenden, geben Sie
<c>w</c> ein:
</p>

<pre caption="Speichern und Beenden von fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Nachdem Ihre Partitionen nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren.
</p>

</body>
</subsection>
</section>
<section>
<title>Benutzung von mac-fdisk auf PPC zur Partitionerung der Festplatte</title>
<body>

<p>
An dieser Stelle erstellen Sie Ihre Partitionen mit <c>mac-fdisk</c>:
</p>

<pre caption="Starten von mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Löschen Sie zunächst die Partitionen, die Sie vorher geleert haben, um Platz
für Ihre Linux Partitionen zu schaffen. Benutzen Sie <c>d</c> in
<c>mac-fdisk</c> um diese Partitionen zu löschen. Es wird Sie beim Löschvorgang
nach einer Partitionsnummer fragen.
</p>

<p>
Nun erstellen Sie eine <e>Apple_Bootstrap</e> Partition mit <c>b</c>. Sie werden
nach einem Block gefragt, an dem Sie starten wollen. Wenn Sie gerade <c>3</c>
als Partitionsnummer gewählt haben, geben Sie <c>3p</c> ein.
</p>

<p>
Erstellen Sie nun eine Swap Partition indem Sie <c>c</c> drücken.
<c>mac-fdisk</c> wird Sie wieder nach einem Block fragen, an dem Sie diese
Partition beginnen lassen wollen. Nachdem wir <c>3</c> vorher für die
Apple_Bootstrap Partition gewählt haben, müssen Sie nun <c>4p</c> eingeben. Wenn
Sie nach der Größe gefragt werden geben Sie <c>512M</c> ein (oder die Größe die Sie
möchten ein, 512 ist empfholen). Wenn Sie nach einem Namen gefragt werden, geben
Sie <c>swap</c> ein. (notwending).
</p>

<p>
Um die Root Partition zu erstellen, geben Sie <c>c</c> gefolgt von <c>5p</c> ein
um auszuwählen, an welchem Block die Root Partition beginnen soll. Wenn Sie nach
der Größe gefragt werden, geben Sie wieder <c>5p</c> ein. <c>mac-fdisk</c>
interpretiert dies als "Benutze den ganzen verfügbaren Platz". Wenn Sie nach dem
Namen gefragt werden, geben Sie <c>root</c> ein. (zwingend).
</p>

<p>
Abschliessend schreiben Sie die Partitionstabelle mit <c>w</c> und beenden
<c>mac-fdisk</c> mit <c>q</c>.
</p>

<p>
Nachdem Ihre Partitionen nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren.
</p>

</body>
</section>
<section>
<title>Benutzung von fdisk auf HPPA zur Partitionerung der Festplatte</title>
<body>

<p>
Erstellen Sie die gewünschten Partitionen mit <c>fdisk</c>:
</p>

<pre caption="Partitionierung der Festplatte">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO benötigt eine spezielle Partitionierung. Sie müssen eine Partition mit
einer Größe von mindestens 16MB am Beginn der Festplatte anlegen. Der
Partitionstyp muss <e>f0</e> sein (Linux/PA-RISC boot).
</p>

<impo>
Wenn Sie dies ignorieren und ohne spezielle PALO Partition fortfahren, wird Ihr
System aufhören Sie zu lieben und nicht mehr Starten.
</impo>

<p>
Wenn Ihre Festplatte größer als 2GB ist, stellen Sie sicher, dass die Boot
Partition innerhalb der ersten 2GB Ihrer Festplatte liegt. PALO kann keinen
Kernel hinter der 2GB Grenze lesen.
</p>

<p>
Nachdem Ihre Partitionen nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren.
</p>

</body>
</section>
<section>
<title>Benutzen von fdisk auf MIPS zur Partitionierung Ihrer Festplattek</title>
<!-- This entire section is copy/pasted from Kumba's original text. It should
     probably be rewritten, but it seems a bit complicated.
     Someone donate me a MIPS? :)

       ~SwifT
-->
<subsection>
<title>Erstellen eines SGI Disk Label</title>
<body>

<p>
Alle Festplatten in einem SGI System benötigen ein <c>SGI Disk Label</c>, das
eine ähnliche Funktion zu einem Sun &amp; MS-DOS Disklabel hat. Es speichert
Informationen über die Partitionen einer Festplatte. Die Erstellung eines neuen
SGI Disk Label erstellt zwei spezielle Partitionen auf der Festplatte:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (Neunte Partition): Diese Partition ist wichtig.
    Hier wird Ihr Kernel Image abgelegt. Um hier Kernel Images ablegen zu
    können, müssen Sie das Tool <c>dvhtool</c> benutzen. Sie können Kernel von
    dieser Partition dann via SGI PROM booten.
  </li>
  <li>
    <e>SGI Volume</e> (Elfte Partition): Diese Partition hat den gleichen
    Zweck wie die dritte Partition des Sun Disklabel, "Whole Disk". Diese
    Partition umspannt die gesamte Festplatte und sollte nicht angefasst werden.
    Sie hat keinen speziellen Zweck, ausser das PROM in etwas undokumentierter
    Art und Weise zu unterstützen (oder es wird auf gewisse Weise von IRIX
    verwendet).
  </li>
</ul>

<warn>
Der SGI Volume Header <e>muss</e> bei Zylinder 0 beginnen. Wenn dies fehlschlägt
führt das dazu, dass Sie nicht von der Festplatte booten können.
</warn>

<p>
Das Folgende ist ein beispielhafter Auszug aus einer <c>fdisk</c> Sitzung. Lesen
Sie ihn, und passen ihn an Ihre Anforderungen an ...
</p>

<pre caption="Erstellen eines SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Wenn Ihre Festplatte bereits ein SGI Disklabel hat, erlaubt fdisk nicht die
Erstellung eines Neuen. Es gibt zwei Möglichkeiten dies zu umgehen: Eine ist ein
Sun oder MS-DOS Disklabel zu erstellen, die Änderungen auf die Festplatte zu
schreiben und fdisk neuzustarten. Die Zweite ist, die Partition mit dem
folgendem Kommando mit Null Data zu beschreiben:
<c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Den SGI Volume Header an die richtige Größe anpassen</title>
<body>

<p>
Nachdem Sie ein SGI Disklabel erstellt haben, können Sie Partitionen erstellen.
Im obigen Beispiel sind bereits Partitionen erstellt worden. Dies sind die
speziellen, vorhin angesprochenen Partitionen, welche im Normalfall nicht
geändert werden sollten. Um Gentoo zu installieren müssen Sie Kernel Images
direkt in den Volume Header laden, da es noch keinen unterstützten SGI Bootloader
im Portage gibt. Der Volume Header selbst kann bis zu <e>acht</e> Images jeder
Größe beinhalten, jedes Image darf einen bis zu acht Zeichen langen Namen
tragen.
</p>

<p>
Der Prozess zur Vergrößerung des Volume Header ist nicht unbedingt geradeaus, es
gehört ein kleiner Trick dazu. Sie können den Volume Header auf Grund von fdisks
Verhalten nicht einfach löschen und neu anlegen.. Im unten abgebildeten Beispiel
erstellen wir einen 50MB großen Volume Header in Verbindung mit einer 50 MB
großen /boot Partition. Das aktuelle Layout Ihrer Festplatte weicht möglicherweise
ab, dies hier dient nur zu Illustrationszwecken.
</p>

<pre caption="Die Größe des SGI Volume Header richtig ändern">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Beachten Sie, dass fdisk nur die Wiedererstellung der Partition #1 bei einem minimalen Zylinder von 5 erlaubt)</comment>
<comment>Wenn Sie versucht hätten den SGI Volume Header auf diesem Weg zu löschen &amp; neu zu erstellen,
wäre Ihnen das gleiche Problem begegnet)</comment>
<comment>(In unserem Beispiel möchten wir, dass /boot 50MB groß ist. Wir beginnen bei Zylinder 51 (der Volume Header muss bei
Zylinder 0 anfangen) und setzen den Endzylinder auf 101, damit erreichen wir etwa 50 MB (+/- 1-5 MB))</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Löschen der Partition #9 (SGI Volume Header))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
Last cylinder (0-50, default 50): <i>50</i>
<comment>(Wiedererstellen der Partition #9, diese endet direkt vor Partition #1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Abschliessendes Partitionslayout</title>
<body>

<p>
Nachdem Sie dies getan haben, können Sie die restlichen Partitonen nach Ihren
Wünschen anlegen. Wenn Sie alle Partitionen angelegt haben achten Sie darauf,
die Partition ID Ihrer Swap Partition auf <c>82</c> zu setzen. Per Standard
wird diese als <c>83</c>, Linux Native, gesetzt.
</p>

<p>
Nachdem Ihre Partitionen nun erstellt sind, können Sie mit dem
<uri link="#filesystems">Erstellen der Dateisysteme</uri> fortfahren
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Erstellen der Dateisysteme</title>
<subsection>
<title>Einleitung</title>
<body>

<p>
Jetzt sind Ihre Partitionen erstellt, so dass es nun an der Zeit ist
Dateisysteme anzulegen. Wenn Sie mit dem zufrieden sind, was wir Ihnen
vorschlagen, dann fahren Sie mit <uri link="#filesystems-apply">Dateisystem
auf einer Partition anlegen</uri> fort. Wenn nicht, lesen Sie weiter, um
ein wenig mehr über Dateisysteme zu lernen ...
</p>

</body>
</subsection>
<subsection>
<title>Dateisysteme?</title>
<body>

<p>
Verschiedene Dateisysteme sind verfügbar. Einige von ihnen sind auf allen
Architekturen stabil, andere nur auf einigen. Die folgende Tabelle listet die
verfügbaren Dateisysteme und die Architekturen, auf denen diese arbeiten, auf.
Wenn eine Architektur in "(...)" steht, dann sollte Dateisystem auf dieser
Archtitektzr funktionieren, ist aber nicht getestet.
</p>

<table>
<tr>
  <th>Dateisystemm</th>
  <th>Journalisierendes Dateisystem</th>
  <th>Architektur</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>nein</ti>
  <ti>Alle Architekturen</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>ja</ti>
  <ti>Alle Architekturen</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>ja</ti>
  <ti>x86, hppa, alpha, (mips), (ppc) (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>ja</ti>
  <ti>x86, amd64, alpha, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>ja</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> ist das erprobte und wahre Linux Dateisystem, unterstützt aber kein
Metadata Journaling, was bedeutet, dass routinemäßige Dateisystem Checks beim
Booten sehr zeitaufwändig sein können. Es gibt mittlerweile eine Auswahl an
journalisierenden Dateisystemen neuerer Generation, die die Konsistenzchecks sehr
schnell erledigen und dadurch im Vergleich mit den nicht-journalisierenden
Gegenstücken vorzuziehen sind. Jounalisierende Dateisysteme verhindern lange
Verzögerungen beim Booten, wenn sich das Dateisystem in einem inkonsistenten
Zustand befindet.
</p>

<p>
<b>ext3</b> ist die journalisierende Version des ext2 Dateisystem, die Metadata
Journaling für schnelle Wiederherstellung sowie andere verbesserte Journaling
Modi wie "full data" und "ordered data" Jornaling unterstützt. ext3 ist ein sehr
gutes und verlässliches Dateisystem. In den meisten Fällen bietet es eine
annehmbare Leistung. Da es keinen Gebrauch von "Trees" in seinem internen Design
macht, skaliert es nicht sehr gut, was bedeutet, dass es keine ideale Wahl für
große Dateisysteme, oder Situationen in denen sehr große Dateien oder große
Mengen von Dateien innerhalb eines Verzeichnis benötigt werden, ist.
</p>

<p>
<b>ReiserFS</b> ist ein B*-tree basierendes Dateisystem mit einer guten
Performance und überholt sowohl ext2 und ext3 im Umgang mit kleinen Dateien
(Dateien kleiner als 4k) oftmals mit einem Faktor von 10x-15x. ReiserFS skaliert
extrem gut und hat Metadata Journaling. Seit Kernel 2.4.18+ ist ReiserFS
stabil und sowohl als Dateisystem für generelle Anwendungen, als auch für
extreme Fälle wie große Dateisysteme, den Gebrauch mit vielen kleinen Dateien,
den Gebrauch mit sehr großen Dateien und Verzeichnissen mit tausenden von
Dateien brauchbar.
</p>

<p>
<b>XFS</b> ist ein Dateisytem mit metadata journaling, das in Gentoos
xfs-sources Kernel voll unterstützt wird. Es kommt mit einem robusten Feature-Set
und ist auf Skalierbarkeit ausgelegt. Wir empfehlen den Einsatz dieses
Dateisystems nur auf Linux Systemen mit High-End SCSI und/oder Fibre Channel
Storage und einer redundaten Stromversorgung. Da XFS agressiv vom RAM gebraucht
macht, können unsachgemäß designte Programme (solche die keine
Vorsichtsmaßnahmen treffen, wenn Sie auf die Festplatte schreiben und davon
gibt es einige) dazu führen, dass eine ganze Menge Daten verloren gehen, wenn
das System unerwartet ausfällt.
</p>

<p>
<b>JFS</b> ist IBMs Hochleistungs Journaling Dateisystem. Es ist vor kurzem
einsatzbereit geworden und es gibt noch keine ausreichende Spur, so dass seine
allgemeine Stabilität an diesem Punkt weder positiv noch negativ kommentiert
werden kann.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Eine Partition mit einem Dateisystem formatieren</title>
<body>

<p>
Um ein Dateisystem auf einer Partition oder einem Volume zu erstellen, gibt es
für jedes Dateisystem Tools:
</p>

<table>
<tr>
  <th>Dateisystem</th>
  <th>Kommando</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Um die Boot Partition (<path>/dev/hda1</path> in unserem Beispiel) als ext2 und
die Root Partition (<path>/dev/hda3</path> in unserem Beispiel) als ext3 (wie in
unserem Beispiel) zu formatieren, führen Sie folgende Kommandos aus:
</p>

<pre caption="Eine Partition mit einem Dateisystem formatieren">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Erstellen Sie nun die Dateisysteme auf Ihren neu erstellten Partionen (oder
logischen Volumes).
</p>

</body>
</subsection>
<subsection>
<title>Aktivieren der Swap Partition</title>
<body>

<p>
<c>mkswap</c> ist das Kommando, mit dem Sie die Swap Partition initialisieren:
</p>

<pre caption="Erstellen der Swap Signatur">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Um die Swap Partition zu aktivieren, benutzen Sie <c>swapon</c>:
</p>

<note>
Knoppix Benutzer, die bereits eine Swap Partition auf ihrem System haben,
können diesen Schritt überspringen, da Knoppix bestehende Swap Partitionen
automatisch aktiviert.
</note>

<pre caption="Aktivieren der Swap Partition">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Erstellen und aktivieren Sie jetzt Ihre Swap Partition.
</p>

</body>
</subsection>
</section>
<section>
<title>Mounten</title>
<body>

<p>
Nachdem Ihre Partitionen nun initialisiert sind und ein Dateisystem beinhalten,
ist es an der Zeit diese Partitionen zu mounten. Benutzen Sie das <c>mount</c>
Kommando. Vergessen Sie nicht die notwendigen Mount Verzeichnisse zu erstellen:
</p>

<pre caption="Mounten von Partitionen">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Wenn Sie <path>/tmp</path> auf eine separate Partition legen möchten, stellen
Sie sicher, dass Sie die Berechtigungen nach dem mounten ändern:
<c>chmod 1777 /mnt/gentoo/tmp</c>. Dies gilt auch für <path>/var/tmp</path>.
</note>

<p>
Sie müssen auch noch das proc Dateisystem (ein virtuelles Interface zum Kernel)
auf <path>/proc</path> mounten. Zunächst erstellen Sie den
<path>/mnt/gentoo/proc</path> Mountpoint.
</p>

<pre caption="Erstellen des /mnt/gentoo/proc Mountpoint">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
Wenn Sie Gentoo von einer LiveCD installieren, reicht es <c>proc</c> zu mounten:
</p>

<pre caption="proc mounten">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Wenn Sie Gentoo nicht von einer Gentoo LiveCD installieren, müssen Sie
<path>/proc</path>  mit der Option bind mounten:
</p>

<pre caption="proc mit der Option bind mounten">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
</pre>

<p>
Fahren Sie nun mit dem <uri link="?part=1&amp;chap=5">Installation der Gentoo
Installations Dateien </uri> fort.
</p>

</body>
</section>
</sections>
