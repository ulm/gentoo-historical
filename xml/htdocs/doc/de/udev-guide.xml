<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/udev-guide.xml,v 1.16 2006/03/27 03:01:29 grahl Exp $ -->

<!-- English CVS Version: 1.29 -->

<guide link="/doc/de/udev-guide.xml" lang="de">
<title>Gentoo udev Leitfaden</title>

<author title="Autor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Mitarbeiter">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
 </author>
<author title="Übersetzer">
    <mail link="grahl@gentoo.org">Jan Hendrik Grahl</mail>
</author>

<abstract>
Dieses Dokument erklärt was udev ist und wie Sie udev verwenden können um Ihren 
Bedürfnissen zu entsprechen
</abstract>

<license/>

<version>0.23</version>
<date>2006-03-25</date>

<chapter>
<title>Was ist udev?</title>
<section>
<title>Das /dev Verzeichnis</title>
<body>

<p>
Wenn Linuxbenutzer in der Gegenwart von Menschen, die glauben, dass Linux eine 
Art von Virus oder Kaffeesorte ist, über Hardware auf Ihrem System reden, dann 
werden Äußerungen wie "slash dev slash foo" mit Sicherheit für seltsame Blicke 
sorgen. Aber für den versierten User (und damit sind auch Sie gemeint) ist die 
Verwendung von <path>/dev/hda1</path> nur eine schnelle Art, um zu erklären, 
dass wir über die erste Partition am Primary Master IDE reden. Oder etwa nicht? 
</p>

<p>
Wir alle wissen, was eine Geräte(device)datei ist. Einige wissen auch, warum 
Gerätedateien, wenn wir einen genaueren Blick auf sie werfen (indem wir 
<c>ls -l</c> in <path>/dev</path> ausführen) besondere Nummern haben. Aber 
was wir immer für gegeben ansehen, ist, dass die Primary Master IDE Festplatte 
als <path>/dev/hda</path> bezeichnet wird. Sie mögen es nicht so sehen, aber 
das ist ein grundlegender Designfehler.
</p>

<p>
Denken sie an Hotplug Geräte wie USB, IEE1394, hot-swappable PCI... was ist 
das erste Gerät? Und für wie lange? Wie werden die anderen Geräte benannt, 
wenn das erste verschwindet? Wie wird das laufende Transaktionen beeinflussen? 
Wäre es nicht lustig, wenn der Druckauftrag plötzlich von Ihrem superneuen 
Laserdrucker auf Ihren fast toten Matrix Drucker verschoben würde, weil Ihre 
Mutter beschlossen hat den Stecker des Laserdruckers herauszuziehen, 
welcher leider der erste Drucker war? 
</p>

<p>
Geben Sie <e>udev</e> ein. Die Ziele des udev Projekts sind sowohl interessant 
als auch nötig:
</p>

<ul>
  <li>Läuft im userspace</li>
  <li>Erstellt/entfernt dynamisch Gerätedateien</li>
  <li>Liefert konsequente Benennung</li>
  <li>Liefert ein user-space API</li>
</ul>

<p>
Um diese Funktionen zu liefern wird udev in drei unterschiedlichen Projekten 
entwickelt: <e>namedev</e>, <e>libsysfs</e> und natürlich <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev erlaubt es Ihnen, Geräte separat vom udev Programm zu benennen.
Dies erlaubt flexible Benennungsrichtlinien und Namensschemata, entwickelt 
von verschiedenen Körperschaften. Dieses Subsystem zur Gerätebenennung 
liefert ein Standardinterface, das udev benutzen kann. 
</p>

<p>
Momentan wird nur ein einzelnes Benennungsschema von namedev geliefert, und 
zwar jenes, welches von LANANA geliefert wird. Dieses wird von der Mehrheit 
der Linux Systeme momentan verwendet und ist daher für die Mehrheit der 
Linuxanwender sehr brauchbar.
</p>

<p>
Namedev verwendet eine fünfstufige Prozedur um den Namen eines bestimmten 
Gerätes herauszufinden. Wenn in einem dieser Schritte der Gerätename gefunden 
wird, wird dieser Name verwendet. Diese Schritte sind: 
</p>

<ul>
  <li>Beschriftung oder Seriennummer</li>
  <li>Bus Gerätenummer</li>
  <li>Bus Topologie</li>
  <li>Statisch vergebener Name</li>
  <li>Vom Kernel gelieferter Name</li>
</ul>

<p>
Der <e>Beschriftung oder Seriennummer</e> Schritt überprüft, ob das Gerät ein 
einzigartiges Identifikationsmerkmal hat. Zum Beispiel haben USB Geräte eine 
einzigartige USB Seriennummer und SCSI Geräte eine einzigartige UUID. 
Wenn Namedev eine Übereinstimmung zwischen dieser einzigartigen Nummer und 
einer gegebenen Konfigurationsdatei findet, dann wird der von der 
Konfigurationsdatei gelieferte Name verwendet.
</p>

<p>
Der <e>Bus Gerätenummer</e> Schritt überprüft die Bus Gerätenummer. Für 
nicht-hot-swappable Umgebungen ist diese Prozedur ausreichend, um ein 
Hardwaregerät zu identifizieren. Zum Beispiel verändern sich PCI Busnummern 
selten in der Lebenszeit eines Systems. Auch hier wird, wenn namedev eine 
Übereinstimmung mit dieser Position und einer gegeben  Konfigurationsdatei 
findet, der Name verwendet, der von der Konfigurationsdatei geliefert wird. 
</p>

<p>
Genauso ist auch die <e>Bus Topologie</e> ein eher statischer Weg zur 
Definition von Geräten solange die Benutzer nicht Geräte auswechseln. 
Wenn die Position des Gerätes zu einer vom Benutzer gelieferten Einstellung 
passt wird der beiliegende Name verwendet. 
</p>

<p>
Der vierte Schritt <e>Statisch vergebener Name</e> ist ein simpler String 
Ersatz. Wenn der Kernelname (der Standardname) zu einem gegebenen 
Ersatzstring passt, wird der Ersatzname stattdessen verwendet.
</p>

<p>
Der letzte Schritt (<e>Vom Kernel gelieferter Name</e>) ist ein "Allesfänger": 
Dieser nimmt den vom Kernel gelieferten Standardnamen. In den meisten Fällen 
ist dies ausreichend, da es zu der Gerätebenennung, welche auf momentanen 
Linuxsystem verwendet wird, passt.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev interagiert mit dem Kernel durch das sysfs Pseudodateisystem. Das 
libsysfs Projekt liefert ein Standard API um auf die Informationen gegeben durch 
das sysfs Dateisystem in einem gängigen Verfahren zuzugreifen. Dies erlaubt 
eine Abfrage von aller Art von Hardware, ohne dass man Vermutungen über die 
Art der Hardware anstellen muss.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Jedes Mal, wenn der Kernel ein Update in der Gerätestruktur feststellt, ruft 
er das <path>/sbin/hotplug</path> Programm auf. Hotplug führt die Anwendung 
aus, welche im <path>/etc/hotplug.d/default</path> Verzeichnis, wo Sie auch 
einen symlink zum udef Programm finden werden, verlinkt ist. Hotplug übergibt 
die Informationen vom Kernel an das udev Programm, welches die notwendingen 
Aktionen (Erstellen oder Entfernen von Gerätedateien) an der <path>/dev</path> 
Struktur ausführt.
</p>

</body>
</section>
</chapter>

<chapter>
<title>udev unter Gentoo benutzen</title>
<section>
<title>Voraussetzungen</title>
<body>

<p>
udev sollte in Verbindung mit einem 2.6 Kernel verwendet werden (wie 
<c>vanilla-sources</c> oder <c>gentoo-sources</c> mit dem Standard 2005.0 
Profil). Wenn Sie einen solchen Kernel verwenden müssen Sie nur 
sicherstellen, dass Sie eine aktuelle  <c>sys-apps/baselayout</c> Version 
haben. Das ist alles was Sie benötigen. 
</p>

<pre caption="Installieren von udev">
 # <i>emerge udev</i>
</pre>

<p>
udev wird <c>hotplug-base</c> als eines seiner Abhängigkeiten installieren. 
Sie müssen <c>hotplug</c> nicht installieren, nur wenn Sie wünschen, dass 
Ihre Module automatisch geladen werden sobald Sie Geräte anschließen.
<c>sys-apps/hotplug</c> erledigt auch das automatische Hochfahren von 
Netzwerkgeräten, sowie den Firmware Download.
</p>

<pre caption="Installieren optionaler Hotplug Skripte">
 # <i>emerge hotplug</i>
</pre>

<p>
Für das Laden von Modulen für Geräte, die eingesteckt worden sind bevor Sie 
hochgefahren haben, verwenden Sie das coldplug Paket:
</p>

<pre caption="Installieren des coldplug Pakets">
# <i>emerge coldplug</i>
</pre>

<p>
Vergessen Sie nicht <c>coldplug</c> zum boot Runlevel hinzuzufügen:
</p>

<pre caption="coldplug zum boot Runlevel hinzufügen">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Stellen Sie sicher, dass folgende Optionen im Kernel aktiviert sind:
</p>

<pre caption="Benötigte Kerneloptionen">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Wenn Sie möchten, können Sie den <c>/dev file system support (OBSOLETE)</c> 
aktiviert lassen, aber Sie müssen sicherstellen, dass "Automatically mount at 
boot" deaktiviert ist.
</p>

<pre caption="Binden Sie nicht automatisch devfsd ein">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
     [*] /dev file system support (OBSOLETE)
       [ ]   Automatically mount at boot
</pre>

<p>
Wenn Sie <c>genkernel</c> verwenden, dann sollten Sie nicht vergessen, es mit 
der <c>--udev</c> Option auszuführen, um alle benötigten Einstellungen zur 
Kernelkonfigurationen zu aktivieren. Die Standardkonfiguration gegeben durch 
diesen <c>genkernel</c> Aufruf ist ausreichend.
</p>

</body>
</section>
<section>
<title>Konfiguration</title>
<body>

<p>
Wenn Sie, um Ihr Leben einfacher zu machen, die udev Verbesserungen, die Gentoo 
hinzugefügt hat, benutzen wollen, müssen Sie nicht weiterzulesen. 
Gentoo wird udev verwenden aber ein statisches <path>/dev</path> erhalten, 
damit Sie nie fehlende Device-Nodes haben werden. Die Gentoo init Skripte 
werden den devfsd Dämon nicht ausführen und werden devfs deaktivieren wenn Sie 
booten.
</p>

<p>
Wenn Sie aber ein zäher Kämpfer sind und ein nur-udev, nicht-optimiertes 
System verwenden wollen, so wie es von der udev Entwicklung vorgesehen wurde 
(einschließlich der Schwierigkeiten von fehlenden Device-Node-Dateien, da 
udev sie noch nicht untersützt), dann lesen Sie einfach weiter :)
</p>

<p>
Wir werden die Regeln deaktivieren, die die Device-Node-Dateien speichern: 
editieren Sie die <c>RC_DEVICE_TARBALL</c> Variable in 
<path>/etc/conf.d/rc</path> und setzen Sie diese auf <c>no</c>: 
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Wenn Sie devfs Unterstützung in Ihrem Kernel haben, können Sie es in Ihrer 
Bootloaderkonfiguration deaktivieren: Fügen Sie <c>gentoo=nodevfs</c> als 
Kernelparameter hinzu. Wenn Sie devfs verwenden wollen und udev deaktivieren 
wollen, dann fügen Sie <c>gentoo=noudev</c> als Kernelparamter hinzu.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Bekannte Probleme</title>
<section>
<title>Fehlende Device-Node-Dateien beim booten</title>
<body>

<p>
Wenn Sie nicht erfolgreich booten können, da Sie eine Fehlemeldung darüber 
erhalten, dass <path>/dev/null</path> nicht gefunden wurde oder weil die 
initiale Konsole fehlt, dann ist das Problem, dass Ihnen einige Gerätedateien 
fehlen, die verfügbar sein müssen, <e>bevor</e> <path>/dev</path> eingebunden 
ist und von udev verwaltet wird. Dies ist oft auf Gentoo Rechnern, bei 
deren Installation alte Medien verwendet wurden, der Fall.
</p>

<p>
Wenn Sie <c>sys-apps/baselayout-1.8.12</c> oder neuer laufen haben, dann ist 
dieses Problem bereits entschärft, da der Bootvorgang trotzdem komplett 
durchlaufen müsste. Um diese nervigen Warnungen loszuwerden sollten Sie 
die fehlenden Device-Nodes wie untenstehend beschrieben erstellen.
</p>

<p>
Um zu sehen, welche Device-Nodes vorhanden sind bevor das <path>/dev</path> 
Dateisystem eingebunden ist, führen Sie folgende Befehle aus:
</p>

<pre caption="Auflistung der Device-Nodes vorhanden zum Systemstart">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Die für einen erfolgreichen Boot benötigten Device-Nodes sind 
<path>/dev/null</path> und <path>/dev/console</path>. Wenn Sie im 
vorangegangenen Test nicht vorhanden waren, dann müssen Sie diese manuell 
erstellen. Führen Sie folgende Befehle im zuvor erstellten 
<path>test/dev/</path> Verzeichnis aus:
</p>

<pre caption="Erstellen notwendiger Device-Node-Dateien">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
Wenn Sie fertig sind, vergessen Sie nicht die Einbindung des 
<path>test/</path> Verzeichnisses wieder zu lösen: 
</p>

<pre caption="Lösen der Einbindung des test/ Verzeichnisses">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev und nvidia</title>
<body>

<p>
Wenn Sie auf einem nur-udev System den proprietären Treiber von nVidia 
verwenden und der X Server nicht gestartet werden kann, stellen Sie 
sicher, dass Sie Folgendes besitzen:
</p>

<ul>
  <li>
    das <c>nvidia</c> Modul aufgeführt in 
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    den <c>nvidia-kernel</c> mit der Version 
    <c>media-video/nvidia-kernel-1.0.5336-r2</c> oder neuer
  </li>
  <li>
    das Basislayout mit der Version <c>sys-apps/baselayout-1.8.12</c> 
    oder neuer
  </li>
</ul>

<p>
Wenn <c>xorg-x11</c> sich weigert zu starten, könnte es unter Umständen daran
liegen, dass die <path>/dev/nvidia</path> Gerätedatei fehlt. Wenn dies der Fall
ist, führen Sie <path>/sbin/NVmakedevices.sh</path> aus um diese (neu) zu
erstellen.
</p>

</body>
</section>
<section>
<title>LVM2 Namen verschwinden</title>
<body>

<p>
Wenn Sie <c>udev</c> und LVM2 zusammen verwenden ist Ihnen vielleicht 
aufgefallen, dass die von Ihnen erstellten Volumen verschwunden sind. Nun, sie 
sind es nicht, aber unglücklicherweise sind sie als <path>/dev/dm-#</path> 
benannt; wobei # 0,1,usw ist.
</p>

<p>
Um dies zu korrigieren editieren Sie <path>/etc/udev/rules.d/50-udev.rules</path> 
und entkommentieren Sie die folgende Zeile:
</p>

<pre caption="Entkommentieren Sie diese Zeile in /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
Installieren Sie als nächstes <c>sys-fs/multipath-tools</c>, welches die 
<c>devmap_name</c> Anwendung enhält.
</p>

<pre caption="Installation von multipath-tools">
<comment>(Zum Zeitpunkt des Verfassens ist multipath-tools nur in Testing (~) verfügbar:)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>Keine einheitliche Namensgebung zwischen DevFS und udev</title>
<body>

<p>
Obwohl es unsere Absicht ist ein einheitliches Namensschema für beide 
dynamischen Gerätemanagementlösungen zu haben, gibt es trotzdem manchmal 
Unterschiede in der Benennung.
</p> 

<p>
Ein gemeldeter Konflikt existiert mit dem HP Smart Array 5i RAID Controller 
(genauer gesagt mit dem <c>cciss</c> Kernelmodul). Mit udev werden die 
Geräte als <path>/dev/cciss/cXdYpZ</path> benannt; wobei X,Y und Z reguläre 
Nummern sind. Mit devfs sind die Geräte <path>/dev/hostX/targetY/partZ</path> 
oder symbolisch verlinkt von <path>/dev/cciss/cXdY</path>. 
</p>

<p>
Wenn dies der Fall ist, dann vergessen Sie bitte nicht <path>/etc/fstab</path> 
und die Bootloader Konfigurationsdateien entsprechend zu aktualisieren. 
</p>

<p>
Dasselbe geschieht mit universellen symbolischen Links die in 
<path>/dev</path> existierten, wie <path>/dev/mouse</path>, welches 
<c>udev</c> nicht länger erstellt. Überprüfen Sie Ihre X Konfigurationsdatei 
und stellen Sie sicher, dass die Geräteregel für Ihre Maus auf ein existierendes 
Gerät verweist.
</p>

<p>
Ein weiteres Problem ist der Unterschied in der Benennung der Terminals
zwischen devfs und udev. Während devfs die Terminals <c>tty</c> nennt, benennt
udev sie <c>vc</c>. Dies führt zu einem Problem, wenn Sie Root-Logins von der
Konsole mit <path>/etc/securetty</path> einschränken. Sie werden sicherstellen
müssen, dass <c>tty1</c> auf <c>vc/1</c> geändert wird in
<path>/etc/securetty</path> um zu garantieren, dass root sich an der Konsole
anmelden kann.
 </p>

</body>
</section>
<section>
<title>Sonstige Probleme</title>
<body>

<p>
Falls Device-Nodes nicht erstellt werden, wenn ein Modul aus 
<path>/etc/modules.autoload.d/kernel-2.6</path> geladen wird, aber erscheinen, 
wenn Sie ein Modul manuell mit modprobe laden, dann sollten Sie versuchen 
<c>sys-apps/baselayout-1.8.12</c> oder neuer zu installieren.
</p>

<p>
Unterstützung für die Framebuffer Geräte (<path>/dev/fb/*</path>)  ist im 
Kernel ab der Version 2.6.6-rc2 enthalten.
</p>

<p>
Für Kernel älter als 2.6.4 müssen Sie explizit Unterstützung für das 
<path>/dev/pts</path> Dateisystem einarbeiten.
</p>

<pre caption="Aktivieren des /dev/pts Dateisystems">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ressourcen &amp; Quellenangaben</title>
<section>
<body>

<p>
Die udev Diskussion beim Linux Symposium (Ottawa, Ontario Kanada - 2003) geführt von 
Greg Kroah-Hartman (IBM Corporation) lieferte ein solides Verständnis der udev Anwendung.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> ist ein detailliertes Dokument über udev und Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Schreiben von udev Regeln</uri> 
vom Gentoo Entwickler Daniel Drake ist ein exzellentes Dokument, um zu lernen, wie Sie 
Ihre udev Installation verändern können.
</p>

</body>
</section>
</chapter>

</guide>