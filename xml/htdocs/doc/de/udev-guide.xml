<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/udev-guide.xml,v 1.3 2005/04/04 19:03:21 dertobi123 Exp $ -->

<!-- English CVS Version: 1.10 -->

<guide link="/doc/en/udev-guide.xml">
<title>Gentoo udev Guide</title>

<author title="Autor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Mitarbeiter">
    <mail link="g.guidi@sns.it">Gregorio Guidi</mail>
 </author>
<author title="Übersetzer">
    <mail link="jhgz1@ufl.edu">Jan Hendrik Grahl</mail>
</author>

<abstract>
Dieses Dokument erklärt was udev ist und wie Sie udev verwenden können um Ihren 
Bedürfnissen zu entsprechen
</abstract>

<license/>

<version>0.8</version>
<date>26. April 2004</date>

<chapter>
<title>Was ist udev?</title>
<section>
<title>Das /dev Verzeichnis</title>
<body>

<p>
Wenn Linuxbenutzer über Hardware auf Ihrem System reden in der Gegenwart von 
Menschen die glauben, dass Linux eine Art von Virus oder Kaffeesorte ist, dann 
werden Äußerungen wie "slash dev slash foo" mit Sicherheit für seltsame Blicke 
sorgen. Aber für den versierten User (und damit sind auch Sie gemeint) ist die 
Verwendung von <path>/dev/hda1</path> nur eine schnelle Art um zu erklären, 
dass wir über die erste Partition am Primary Master IDE reden. Oder etwa nicht? 
</p>

<p>
Wir alle wissen, was eine Geräte(device)datei ist. Einige wissen auch warum 
Gerätedateien besondere Nummern haben, wenn wir einen genaueren Blick auf Sie 
werfen indem wir <c>ls -l</c> in <path>/dev</path> ausführen. Aber was wir 
immer für gegeben ansehen ist, dass die Primary Master IDE Festplatte als 
<path>/dev/hda</path> bezeichnet wird. Sie mögen es nicht so sehen, aber das 
ist ein grundlegender Designfehler.
</p>

<p>
Denken sie an Hotplug Geräte wie USB, IEE1394, hot-swappable PCI, ... Was ist 
das erste Gerät? Und für wie lange? Wie werden die anderen Geräte benannt, 
wenn das erste verschwindet? Wie wird das laufende Transaktionen beeinflussen? 
Wäre es nicht lustig, wenn der Druckauftrag plötzlich von Ihrem superneuen 
Laserdrucker auf Ihren fast toten Matrix Drucker verschoben würde, weil Ihre 
Mutter beschlossen hat den Stecker des Tintenstrahldruckers herauszuziehen, 
welcher leider der erste Drucker war? 
</p>

<p>
Geben Sie <e>udev</e> ein. Die Ziele des udev Projekts sind sowohl interessant 
als auch nötigt:
</p>

<ul>
  <li>Läuft im userspace</li>
  <li>Erstellt/entfernt dynamisch Gerätedateien</li>
  <li>Liefert konsequente Benennung</li>
  <li>Liefert ein user-space API</li>
</ul>

<p>
Um diese Funktionen zu liefern wird udev in drei unterschiedlichen Projekten 
entwickelt: <e>namedev</e>, <e>libsysfs</e> und natürlich <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev erlaubt es Ihnen Geräte seperat vom udev Programm zu benennen.
Dies erlaubt eine flexible Benennungsrichtlinie und Namensschemata entwickelt 
von verschiedenen Körperschaften. Dieses Subssystem zur Gerätebenennung 
liefert ein Standardinterface, das udev benutzen kann. 
</p>

<p>
Momentan wird nur ein einzelnes Benennungsschema von namedev geliefert. Das, 
welches von LANANA geliefert wird, welches von der Mehrheit der Linux Systeme 
momentan verwendet wird und daher sehr brauchbar ist für die Mehrheit der 
Linuxanwender.
</p>

<p>
Namedev verwendet eine fünfstufige Prozedur um den Namen eines bestimmten 
Gerätes herauszufinden. Wenn der Gerätename gefunden wird in einem dieser 
Schritte, dann wird dieser Name verwendet. Diese Schritte sind: 
</p>

<ul>
  <li>Beschriftung oder Seriennummer</li>
  <li>Bus Gerätenummer</li>
  <li>Bus Topologie</li>
  <li>Statisch vergebener Name</li>
  <li>Vom Kernel gelieferter Name</li>
</ul>

<p>
Der <e>Beschriftung oder Seriennummer</e> Schritt überprüft ob das Gerät ein 
einzigartiges Identifikationsmerkmal hat. Zum Beispiel USB Geräte haben eine 
einzigartige USB Seriennummer und SCSI Geräte haben eine einzigartige UUID. 
Wenn Namedev eine Übereinstimmung zwischen dieser einzigartigen Nummer und 
einer gegebenen Konfigurationsdatei findet, dann wird der von der 
Konfigurationsdatei gelieferte Name verwendet.
</p>

<p>
Der <e>Bus Gerätenummer</e> Schritt überprüft die Bus Gerätenummer. Für 
nicht-hot-swappable Umgebungen ist diese Prozedur ausreichend um ein 
Hardwaregerät zu identifizieren. Zum Beispiel verändern sich PCI Busnummern 
selten in der Lebenszeit eines Systems. Auch hier wird, wenn namedev eine 
Übereinstimmung mit dieser Position und einer gegeben  Konfigurationsdatei 
findet, der Name verwendet, der von der Konfigurationsdatei geliefert wird. 
</p>

<p>
Genauso ist auch die <e>Bus Topologie</e> ein eher statischer Weg zur 
Definierung von Geräten solange wie die Benutzer nicht Geräte auswechseln. 
Wenn die Position des Gerätes zu einer vom Benutzer gelieferten Einstellung 
passt wird der beiliegende Name verwendet. 
</p>

<p>
Der vierte Schritt <e>Statisch vergebener Name</e> ist ein simpler String 
Ersatz. Wenn der Kernelname (der Standardname) zu einem gegebenen 
Ersatzstring passt, wird der Ersatzname stattdessen verwendet.
</p>

<p>
Der letzte Schritt (<e>Vom Kernel gelieferter Name</e>) ist ein "Allesfänger": 
Dieser nimmt den Standardnamen geliefert vom Kernel. In den meisten Fällen 
ist dies ausreichend, da es zu der Gerätebenennung, welche auf momentanen 
Linuxsystem verwendet wird, passt.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udef interagiert mit dem Kernel durch das sysfs Pseudodateisystem. Das 
libsysfs Projekt liefert ein Standard API um auf die Informationen gegeben durch 
das sysfs Dateisystem in einem gängigen Verfahren zuzugreifen. Dies erlaubt 
eine Abfrage von aller Art von Hardware ohne dass man Vermutungen über die 
Art der Hardware anstellen muss.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Jedes Mal, wenn der Kernel ein Update in der Gerätestruktur feststellt, ruft 
er das <path>/sbin/hotplug</path> Programm auf. Hotplug führt die Anwendung 
aus, welche verlinkt ist im <path>/etc/hotplug.d/default</path> Verzeichnis, 
wo Sie auch einen symlink zum udef Programm finden werden. Hotplug übergibt 
die Informationen vom Kernel an das udev Programm welches die notwendingen 
Aktionen an der <path>/dev</path> Struktur ausführt (erstellen oder entfernen 
von Gerätedateien).
</p>

</body>
</section>
</chapter>

<chapter>
<title>udev unter Gentoo benutzen</title>
<section>
<title>Voraussetzungen</title>
<body>

<p>
udev sollte in Verbindung mit einem 2.6 Kernel verwendet werden (wie 
<c>development-sources</c> oder <c>gentoo-dev-sources</c>). Wenn Sie einen 
solchen Kernel verwenden dann müssen Sie nur sicherstellen, dass Sie eine 
aktuelle  <c>sys-apps/baselayout</c> Version haben. Das ist alles was Sie 
benötigen. 
</p>

<pre caption="Installieren von udev">
 # <i>emerge udev</i>
</pre>

<p>
Wenn es noch nicht geschehen ist, installieren Sie auch 
<c>sys-apps/hotplug</c>.
</p>

<pre caption="Installieren optionaler Hotplug Skripte">
 # <i>emerge hotplug</i>
</pre>

<p>
Wenn Sie beim Kernel den Standard von <c>genkernel</c> verwenden, 
dann ist alles bereit. Ansonsten stellen Sie sicher, dass folgende Optionen 
aktiviert sind:
</p>

<pre caption="Benötigte Kerneloptionen">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Sie können den <c>/dev file system support (OBSOLETE)</c> aktiviert lassen, 
wenn Sie möchten.
</p>

</body>
</section>
<section>
<title>Konfiguration</title>
<body>

<p>
Wenn Sie die udev Verbesserungen die Gentoo hinzugefügt hat, um Ihr Leben 
einfacher zu machen, benutzen wollen, dann lesen Sie nicht weiter. 
Sie sind fertig. Die Gentoo init Skripte werden den devfsd Dämon nicht 
ausführen und werden devfs deaktivieren wenn Sie booten.
</p>

<p>
Wenn Sie aber ein zäher Kämpfer sind und ein nur-udev, nicht-optimiertes 
System verwenden wollen so wie es von der udev Entwicklung vorgesehen wurde 
(einschliesslich der Schwierigkeiten von fehlenden Device-Node-Dateien, da 
udev sie noch nicht untersützt), dann lesen Sie einfach weiter :)
</p>

<warn>
Beschweren Sie sich <e>nicht</e> wenn etwas schiefgeht. Sie werden die harte 
Arbeit von vielen Gentoo Entwicklern entfernen, die unsere init Skripte 
gehackt haben, damit udev sich gut mit Gentoo verträgt!
</warn>

<p>
Wir werden die Regeln deaktivieren, die die Device-Node-Dateien speichern: 
editieren Sie die <c>RC_DEVICE_TARBALL</c> Variable in 
<path>/etc/conf.d/rc</path> und setzen Sie diese auf <c>no</c>: 
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
Wenn Sie devfs Unterstützung in Ihrem Kernel haben, können Sie es in Ihrer 
Bootloaderkonfiguration deaktivieren: Fügen Sie <c>devfs=nomount</c> als 
Kernelparameter hinzu.Wenn Sie devfs verwenden wollen und udev deaktiveren 
wollen, dann fügen Sie <c>gentoo=noudev</c> als Kernelparamter hinzu.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Bekannte Probleme</title>
<section>
<title>Fehlende Device-Node-Dateien beim booten</title>
<body>

<p>
Wenn Sie nicht erfolgreich booten können, da Sie einen Fehler darüber 
erhalten, dass <path>/dev/null</path> nicht gefunden wurde oder weil die 
initiale Konsole fehlt, dann ist das Problem, dass Ihnen einige Gerätedateien 
fehlen, die verfügbar sein müssen, <e>bevor</e> <path>/dev</path> eingebunden 
ist und von udev verwaltet wird. Dies ist oft der Fall auf Gentoo Rechnern bei 
deren Installation alte Medien verwendet wurden.
</p>

<p>
Wenn Sie <c>sys-apps/baselayout-1.8.12</c> oder neuer laufen haben, dann ist 
dieses Problem bereits entschärft, da der Bootvorgang trotzdem komplett 
durchlaufen müsste. Jedoch um diese nervigen Warnungen loszuwerden sollten Sie 
die fehlenden Device-Nodes wie untenstehend beschrieben erstellen.
</p>

<p>
Um zu sehen, welche Device-Nodes vorhanden sind bevor das <path>/dev</path> 
Dateisystem eingebunden ist, führen Sie folgende Befehle aus:
</p>

<pre caption="Auflistung der Device-Nodes vorhanden zum Systemstart">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
Die für einen erfolgreichen Boot benötigten Device-Nodes sind 
<path>/dev/null</path> und <path>/dev/console</path>. Wenn Sie im 
vorangegangenen Test nicht vorhanden waren, dann müssen Sie diese manuell 
erstellen. Führen Sie folgende Befehle im zuvor erstellten <path>test/</path> 
Verzeichnis aus:
</p>

<pre caption="Erstellen notwendiger Device-Node-Dateien">
# <i>mknod -m 660 dev/console c 5 1</i>
# <i>mknod -m 660 dev/null c 1 3</i>
</pre>

<p>
Wenn Sie fertig sind, vergessen Sie nicht die Einbindung des 
<path>test/</path> Verzeichnisses wieder zu lösen: 
</p>

<pre caption="Lösen der Einbindung des test/ Verzeichnisses">
# <i>umount test</i>
</pre>

</body>
</section>
<section>
<title>udev und nvidia</title>
<body>

<p>
Wenn Sie den proprietären Treiber von nVidia verwenden und der X Server 
nicht gestartet werden kann auf einem nur-udev System, dann stellen Sie 
sicher, dass Sie folgendes besitzen:
</p>

<ul>
  <li>
    das <c>nvidia</c> Modul aufgeführt in 
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    den <c>nvidia-kernel</c> mit der Version 
    <c>media-video/nvidia-kernel-1.0.5336-r2</c> oder neuer
  </li>
  <li>
    das Basislayout mit der Version <c>sys-apps/baselayout-1.8.12</c> 
    oder neuer
  </li>
</ul>

</body>
</section>
<section>
<title>Sonstige Probleme</title>
<body>

<p>
Wenn Device-Nodes nicht erstellt werden, wenn ein Modul aus 
<path>/etc/modules.autoload.d/kernel-2.6</path> geladen wird, aber erscheinen, 
wenn Sie ein Modul manuell mit modprobe laden, dann sollten Sie versuchen 
<c>sys-apps/baselayout-1.8.12</c> oder neuer zu installieren.
</p>

<p>
Unterstützung für die Framebuffer Geräte (<path>/dev/fb/*</path>)  ist im 
Kernel enthalten ab der Version 2.6.6-rc2.
</p>

<p>
Für Kernel älter als 2.6.4 müssen Sie explizit Unterstützung für das 
<path>/dev/pts</path> Dateisystem einarbeiten.
</p>

<pre caption="Aktivieren des /dev/pts Dateisystems">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Ressourcen &amp; Quellenangaben</title>
<section>
<body>

<p>
Die udev Diskussion beim Linux Symposium (Ottawa, Ontario Kanada - 2003) geführt von 
Greg Kroah-Hartman (IBM Corporation) lieferte ein solides Verständnis der udev Anwendung.
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer</uri> ist ein detailliertes Dokument über udev und Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Schreiben von udev Regeln</uri> 
vom Gentoo Entwickler Daniel Drake ist ein exzellentes Dokument um zu lernen wie Sie 
Ihre udev Installation verändern können.
</p>

</body>
</section>
</chapter>

</guide>