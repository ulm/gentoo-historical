<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- English CVS Version: 1.47 -->

<guide link="/doc/de/gentoo-howto.xml">
<title>Gentoo Ebuild/Entwickler HOWTO</title>

<author title="Autor">
  <mail link="woodchip@gentoo.org">Donny Davies</mail>
</author>
<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autor">
  <mail link="pete@gentoo.org">Peter Gavin</mail>
</author>
<author title="Autor">
  <mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail>
</author>
<author title="Autor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Autor">
  <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Bearbeiter">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Bearbeiter">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Bearbeiter">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Bearbeiter">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Bearbeiter">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Übersetzer">
	<mail link="hendrik@grahli.net">Jan Hendrik Grahl</mail>
</author>

<abstract>
Dieses Dokument beschreibt das Gentoo Portagesystem, wie man neue
Pakete für Gentoo erstellt und ist auch als ein quasi Standard für die Gentoo
Entwickler gedacht. Diese Arbeit ist noch im Verlauf und wird ständig erneuert
und verändert. Es ist unter keinen Umständen vollständig. Sie sollten es
immer in Verbindung mit den man Seiten, geliefert von Portage (besonders
ebuild(5)), und der Gentoo Development Policy verwenden.
</abstract>

<version>1.4.14</version>
<date>16. Mai 2004</date>

<chapter>
<title>Der Portagebaum</title>
<section>
<title>Einleitung</title>
<body>

<p>
Der Portagebaum findet sich normalerweise in <path>/usr/portage</path> und ist 
in einer hierarchischen Struktur organisiert, die aus Verzeichnissen der 
Kategorien gefolgt von spezifzischen Paketverzeichnissen besteht. Hier ist ein 
Beispiel: Sie können die <path>util-linux-2.11y.ebuild</path> Datei im 
<path>/usr/portage/sys-apps/util-linux</path> Verzeichnis finden. Es können 
noch weitere Versionen von <c>util-linux</c> Ebuilds neben 
<path>util-linux-2.11y.ebuild</path> vorhanden sein.  Dies liegt daran, dass 
<e>alle Ebuilds eines bestimmten Pakets (unabhängig von der Version)</e> 
dasselbe <path>meinekat/meinpkt</path> Verzeichnis in 
<path>/usr/portage</path> teilen.
</p>

</body>
</section>

<section>
<title>Den Portagebaum aus dem CVS auschecken</title>
<body>

<p>
Wenn Sie mit dem CVS System nicht vertraut sind, lesen Sie bitte das 
<uri link="/doc/de/cvs-tutorial.xml">CVS Tutorial</uri> 
für weitere Informationen.
</p>

<p>
Der Portagebaum findet sich im <c>gentoo-x86</c> Modul des Gentoo Linux Baums. 
Um das Modul auszuchecken (etwa 350 Megabytes) würden Sie zunächst CVS mit dem 
oben genannten Leitfaden einrichten und dann das <c>gentoo-x86</c> Modul 
auschecken.
</p>

</body>
</section>

<section>
<title> Was man (nicht) in den Portagebaum legt</title>
<body>

<p>
Bevor sie irgendein Ebuild schreiben, checken Sie vorher auf <uri 
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> nach, ob dort dort ein 
Ebuild vorhanden ist, das dem entspricht, das Sie schreiben wollen, aber 
welches noch nicht ins CVS übertragen wurde. 
Gehen Sie auf <uri link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> 
wählen Sie query aus, selektieren Sie als Produkt <e>Gentoo Linux</e> und als 
Komponente <e>ebuilds</e>. Geben Sie im Suchfeld den Namen des Ebuilds ein 
und geben Sie als Status NEW, ASSIGNED, REOPENED 
und RESOLVED (RESOLVED ist wichtig) an. Schicken Sie nun Ihre Anfrage ab. Die 
Faulen unter Ihnen können auch direkt 
<uri link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">hier</uri> 
klicken.
</p>

<p>
Generell sollte der Portagebaum nur dazu verwendet werden <path>.ebuild</path> 
Dateien zu speichern, sowie alle möglichen relativ kleinen begleitenden 
Dateien, wie Patches oder Beispielskonfigurationsdateien. Diese Art von 
Dateien sollten im <path>/usr/portage/meinekat/meinpkt/files</path> 
Verzeichnis plaziert werden, damit das Hauptverzeichnis 
<path>meinekat/meinpkt</path> übersichtlich bleibt. Ausnahmen von dieser Regel 
sind größere Patch-Dateien, welche auf den Gentoo Mirrors plaziert werden 
sollten, damit die Menschen nicht exzessiv Bandbreite und Festplattenspeicher 
verschwenden. Auch ist es generell keine gute Idee für Entwickler binäre 
Dateien (nicht-ASCII) zum CVS hinzuzufügen. Jedoch wenn dies notwendig ist 
(zum Beispiel, wenn sie eine kleine PNG Grafik für welchen Grund auch immer 
benötigen), stellen Sie sicher, dass Sie es auf diese Weise dem CVS mit der 
<c>-kb</c> Option hinzufügen: 
</p>

<pre caption="Hinzufügen von binären Dateien zum CVS">
# <i>cvs add -kb meinfoto.png</i>
</pre>

<p>
Die <c>-kb</c> Option sagt CVS, dass <path>meinfoto.png</path> eine binäre 
Datei ist und speziell behandelt werden soll. Zum Beispiel das Einweben von 
Unterschieden zwischen zwei verschiedenen Versionen dieser Datei sollte aus 
offensichtlichen Gründen nicht erlaubt sein. Wo wir hier über Einweben von 
Veränderungen sprechen: Jegliche Patches die Sie zu Portage hinzufügen sollten 
generell <e>nicht</e> komprimiert sein. Dies wird CVS erlauben Veränderungen 
einzuarbeiten und Entwickler korrekt über Konflikte zu informieren.
</p>

<p>
Denken Sie daran, dass das Paket, welches Sie einreichen, direkt <e>fertig</e> 
<e>aus der Box</e> funktionieren muss für Endbenutzer wenn es als stabil 
eingereicht wird. Stellen Sie sicher, dass Sie einen guten Satz von 
Standardeinstellungen haben, der die Mehrheit der Systeme und Benutzer die Ihr 
Paket verwenden zufriedenstellt. Wenn Ihr Paket kaputt ist und Sie nicht 
sicher sind, wie Sie es zum Laufen bringen können, überprüfen Sie andere 
Distributionen die ihre eigenen Versionen des Paketes erstellt haben. Sie können 
als Beispiel <uri 
link="http://cvs.mandrakesoft.com/cgi-bin/cvsweb.cgi/SPECS/">Mandrake</uri>
oder <uri link="http://www.debian.org/distrib/packages">Debian</uri> betrachten.
</p>

<p>
Kontrollieren Sie das Ebuild mehrfach und vergleichen es mit dem <uri
link="/doc/de/ebuild-mistakes.xml">Common Gentoo Ebuild Mistakes</uri> Dokument.
</p>

<p>
Beim Einreichen ins CVS sollten alle Entwickler, anstatt <c>cvs commit</c>, 
<c>repoman commit</c>  benutzen um Ebuilds zu übermitteln. Führen Sie bitte 
<c>repoman full</c> vor dem Einreichen aus um sicherzustellen, dass Sie nichts 
vergessen haben.
</p>

</body>
</section>

<section>
<title>CVS Commit Richtlinie</title>
<body>

<ul>
<li>Benutzen Sie immer <c>repoman scan</c> bevor Sie einreichen.</li>
<li>Führen Sie bitte <c>repoman full</c> aus bevor Sie einreichen.</li>
<li>Testen Sie immer ob <path>package.mask</path> in Ordnung ist indem Sie 
<c>emerge --pretend meinpkt</c> ausführen bevor Sie einreichen und überprüfen 
Sie, dass es keine Konflikte enthält.</li>
<li>Aktualisieren Sie immer das <path>ChangeLog</path> bevor Sie einreichen.</li>
<li>Reichen Sie immer die aktualisierte <path>package.mask</path> vor dem 
aktualisierten Paket ein, für den Fall, dass Konflikte auftreten sollten, während 
Sie <path>package.mask</path> einreichen.</li>
<li>Reichen Sie immer atomar ein; wenn Sie ein Paket mit einer neuen 
Lizenz einreichen oder eins das maskiert ist, dann reichen Sie immer erst die 
überarbeitete <path>package.mask</path> ein und reichen dann das Ebuild, 
<path>ChangeLog</path> und die Lizenz alles auf einmal ein, sofern Sie nicht 
die Installation der Benutzer brechen wollen. </li>
</ul>

</body>
</section>

<section>
<title>Das files Verzeichnis</title>
<body>

<p>
Wie vorhin angemerkt ist unter jedem Paketunterverzeichnis ein 
<path>files/</path> Verzeichnis. Alle Patches, Konfigurationsdateien oder 
andere Begleitdateien, die Ihr Paket benötigen könnte sollten diesem 
Verzeichnis hinzugefügt werden. Sie sollten in Betracht ziehen Patches die Sie 
erstellen nur um ihr Paket dazu zu bringen erstellt zu werden mit einem 
Versions-spezifischen Namen zu benennen wie 
<path>meinpkt-1.0-gentoo.diff</path> oder einfach <path>1.0-gentoo.diff</path>. 
Beachten Sie bitte auch, dass der <path>gentoo</path> Zusatz Benutzer darüber 
informiert, dass dieser Patch von uns erstellt wurde, den Gentoo Linux 
Entwicklern, anstatt von einer Mailingliste oder ähnlichem geholt wurde. Auch 
hier sollten Sie diese Diffs nicht komprimieren, denn CVS hat seine Probleme 
mit binären Dateien.
</p>

<p>
Ziehen Sie in Betracht jeder Datei die Sie in das <path>files/</path> 
Verzeichnis legen ein Prefix oder Suffix anzuhängen (so wie 
<path>meinpkt-1.0</path>), damit die Dateien, welche für eine bestimmte 
Version eines Ebuilds verwendet werden von einer anderen zu unterscheiden sind 
und auch dass die Veränderungen zwischen verschiedenen Revisionen sichtbar 
werden. Dies ist generell eine gute Idee :). Sie möchten vielleicht ein 
anderes Suffix verwenden, wenn Sie mit dem Patchnamen mehr aussagen wollen. 
</p>

<p>
Wenn Sie viele Dateien haben die in das <path>files/</path> Verzeichnis gehen 
sollten, ziehen Sie in Betracht Unterverzeichnisse zu erstellen wie 
<path>files/1.0/</path> und das Verschieben der relevanten Dateien in das
passende Unterverzeichnis. Wenn Sie diese Methode verwenden, dann müssen sie 
keine Versionsinformationen zu den Namen der Dateien hinzufügen, was oft 
praktischer ist.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Ebuild Skripte</title>
<section>
<title>Einleitung</title>
<body>

<p>
Ebuild Skripte sind die Grundlage für das gesamte Portage System. Sie 
enthalten alle Informationen die benötigt werden für das Herunterladen, 
Entpacken, Kompilieren und Installieren eines Satzes von Quellen. Aber auch 
optionale pre/post Installations/Entfernungs oder Konfigurationsschritte 
werden von Ihnen dürchgeführt. Während das meiste von Portage in Python 
geschrieben ist, sind die Ebuilds Skripte selbst in Bash geschrieben, denn die 
Verwendung von Bash erlaubt es uns Befehle auszuführen wie von der 
Kommandozeile aus. Eines der wichtigen Designprinzipien hinter Ebuild Skripten 
ist, die darin enthaltenen Befehle analog zu halten zu denen die man an der 
Kommandozeile verwenden würde, wenn man das Paket manuell installieren würde. 
Für diesen Zweck ist die Verwendung von Bashs Syntax eine sehr gute Sache.
</p>

<p>
Ebuild Skripte werden von den <c>ebuild</c> und <c>emerge</c> Befehlen 
interpretiert. Stellen Sie sich den <c>ebuild</c> Befehl als ein grundlegendes 
Erstellungswerkzeug vor. Es kann ein einzelnes Ebuild erstellen und 
installieren, aber mehr nicht. Es wird überprüfen ob die Abhängigkeiten 
erfüllt sind, aber es wird nicht versuchen, diese selbst zu vervollständigen. 
Hingegen ist <c>emerge</c> eine Hochleistungsengine für <c>ebuild</c> und hat 
die Fähigkeit, wenn nötig, Abhängigkeiten automatisch einzubinden. Führen 
Sie <c>emerge</c> mit <e>pretend</e> aus, so dass der Benutzer sehen kann 
welche Pakete eingebunden werden würden und mehr. Generell kann <c>ebuild</c> 
<c>emerge</c> nicht das Wasser reichen, ausser in einem Bereich. Mit 
<c>ebuild</c> können Sie eins nach dem anderen jeden Abschnitt der 
Paketinstallation (herunterladen, entpacken, kompilieren, installieren und 
einbinden) durchgehen. Für Entwickler ist dies ein Hilfsmittel von 
unschätzbarem Wert, denn es erlaubt Ihnen Probleme mit dem Ebuild auf einen 
bestimmten Teil des Ebuilds zu begrenzen.
</p>

</body>
</section>
<section>
<title>Benennen von Ebuild Dateien</title>
<body>

<p>
Ebuild Dateinamen bestehen aus vier logischen Abschnitten:
</p>

<p>
Der erste Abschnitt ist der Paketname, welcher nur Kleinbuchstaben, die Zahlen 
0-9 und eine beliebige Anzahl von einzelnen Bindestrichen ('-') oder 
Unterstrichzeichen ('_')  beinhalten sollte. Einige Beispiele sind 
<c>util-linux</c>, <c>sysklogd</c>, <c>mod_php</c> und <c>glibc</c>.
</p>

<p>
Der zweite Abschnitt ist die Version des Paketes, welche normalerweise die 
gleiche Version haben sollte wie der Haupt-Quell-Tarball. Diese Version besteht 
meistens aus zwei oder drei Zahlen getrennt von Punkten; z.B. <c>1.2</c> 
oder <c>4.5.2</c> (jedoch <e>werden</e> sehr lange, durch Punkte getrennte 
Nummersequenzen unterstützt), diese können auch einen einzelnen Buchstaben 
direkt der letzten Zahl folgend haben; z.B. <c>1.4b</c> oder <c>2.6h</c>.  Die 
Paketversion wird mit dem Paketnamen durch einen Bindestrich verbunden; z.B.: 
<c>foo-1.0</c>, <c>bar-2.4.6</c>, etc.
</p>

<impo>
Wenn Sie vorhaben einen angehängten Buchstaben in Ihrem Versionsstring zu verwenden, 
beachten Sie, dass der angehängte Buchstabe <e>nicht</e> Alpha oder Beta Status 
eines Paketes anzeigen soll, denn Alphas und Betas sind <e>prereleases</e>
(Vorveröffentlichungen) und Buchstabenrevisionen sind <e>neuere Versionen</e>. 
Dies ist eine wichtige Unterscheidung, denn Portage benutzt die Versionsnummer eines 
Ebuilds um festzustellen ob es neuer oder älter ist als andere Pakete mit derselben
Kategorie und demselben Namen. Es ist sehr wichtig, dass Versionsnummern wirklich 
die Version des Paketes repräsentieren, damit Portage seine Aufgaben zur 
Abhängigkeitsüberprüfung richtig ausführen kann.
</impo>

<p>
Der dritte (optionale) Abschnitt enthält ein spezielles Suffix. Entweder 
<c>_alpha</c>, <c>_beta</c>, <c>_pre</c> (pre-Release), <c>_rc</c> (Release 
Candidate), or <c>_p</c> (Patch).  Jedes dieser Suffixe kann sofort von einer 
Zahl gefolgt werden; z.B. <c>linux-2.4.0_pre10</c>. Geht man von identischen 
Versionsabschnitten aus ist ein <c>_alpha</c> Paket älter als ein<c>_beta</c>, 
ein <c>_beta</c> älter als ein <c>_pre</c>, ein <c>_pre</c> älter als ein 
<c>_rc</c>, ein <c>_rc</c> älter als eins ohne Suffix und eins ohne Suffix 
ist älter als ein <c>_p</c>.  Dieser Abschnitt ist nur zur Reflektierung von 
höheren Versionen gedacht.
</p>

<note>
Ein <c>_rc</c> Paket ist älter als ein Paket ohne ein Unterstrich Suffix (z.B. 
<c>linux-2.4.0</c>) und <c>linux-2.4.0</c> ist älter als ein Paket mit einem 
einzelnen Buchstaben als Suffix z.B. <c>linux-2.4.0b</c>.  Wie man erwarten 
würde wird das <c>linux-2.4.0b</c> Paket als älter betrachtet als 
<c>linux-2.4.0c</c>. Diese Versionsinformation ist wiederum wichtig, da Portage 
es intern verwendet um festzustellen ob ein Paket oder ein Ebuild neuer ist als 
ein anderes mit derselben Kategorie und demselben Namen.
</note>

<p>
Der vierte (optionale) Abschnitt des Paketnamens ist die Gentoo Linux 
spezifische <e>Revisions</e>nummer, welche durch ein <c>-r#</c> spezifiziert 
wird. wo <c>#</c> ein Integer ist, z.B. <c>package-4.5.3-r3</c>. Diese 
Revisionsnummer ist unabhängig von der Version des Quell-Tarballs und wird 
verwendet um Personen darüber zu informieren, dass eine neue und verbesserte 
Gentoo Linux Revision eines bestimmten Pakets erhältlich ist.
</p>

<p>
Wenn Sie Veränderungen an einem vorhandenen Ebuild vornehmen, die nicht trivial 
sind, sollten Sie die Ebuild Datei in eine neue Datei kopieren mit der 
Revisionsnummer um 1 erhöht. Erstveröffentlichungen haben normalerweise keine 
Revisionsnummer, z.B. <path>paket-4.5.3</path>, und werden von Portage gesehen 
mit einer Revisionsnummer von 0. Dies bedeutet, dass das Zählen wie folgt abläuft:
<c>1.0</c> (Erste Version), <c>1.0-r1</c>, <c>1.0-r2</c>, etc.  Denken 
Sie daran <e>immer</e> ihre Veränderungen im<path>ChangeLog</path> zu erwähnen. 
Sie werden schwere Probleme bekommen, wenn Sie dies nicht tun, ihr CVS Zugang 
könnte widerrufen werden. 
</p>

<p>
...und ich nehme an, dass wir eigentlich sogar einen <e>fünften</e> Abschnitt 
des Ebuildnamens haben -- die <c>.ebuild</c> Dateiendung selbst.
</p>

</body>
</section>
<section>
<title>Bestandteile einer Ebuild Datei</title>
<body>

<note>
Dieser Abschnitt ist eine Einführung in Ebuilds. Für die volle Auflistung von 
allem Möglichen in einem Ebuild gibt es die man Seite welche das interne 
Format, die Variablen und Funktionen in einem Ebuild Script thematisiert: 
<c>man 5 ebuild</c>.
</note>

<p><b>Variablen</b></p>

<p>
Der erste Teil jeder Ebuild Datei besteht aus einer Zahl von Variablen. 
Diese fallen in 3 Kategorien (und sind untenstehend mit diesen Zahlen markiert):
</p>

<ul>
<li>READ: Variablen die Sie verwenden können aber <e>nie setzen</e></li>
<li>MUST: Variablen die Sie <e>immer setzen müssen</e></li>
<li>OPT: Variables die sie setzen sollten</li>
</ul>

<table>
<tr>
  <th>Variable</th>
  <th>Benutzung</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Der Name und die Version des Paketes.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Der Name des Paketes.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>Die Version des Paketes.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>
    Enthält die Revisionsnummer oder <c>r0</c> wenn keine Revisionsnummer 
    existiert.
  </ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Enthält die Versionsnummer mit der Revision.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Enthält den vollen Paketnamen <c>${PN}-${PV}-${PR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Liste der Dateinamen ohne Leerzeichen in <c>SRC_URI</c>. Diese enthält 
    nicht die URL Pfade sondern nur den Dateinamen.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Basis des Erstellungsroot für das Ebuild. Nichts sollte außerhalb dieses 
    Verzeichnisses erstellt werden.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Enthält den Pfad zum <path>files</path> Unterverzeichnis im 
    paketspezifischen Ort im Portagebaum. Verändern Sie diese Variable nicht.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Enthält den Pfad zum <path>distfiles</path> Verzeichnis in dem alle 
    Dateien für heruntergeladene Pakete gespeichert werden. Normalerweise 
    <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Das Quellverzeichnis für Ihr Paket; normalerweise <c>${WORKDIR}/${P}</c>.
    Portage verwendet diesen Wert standardmäßig so dass Sie dies wohl nicht 
    setzen müssen.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Das temporäre Verzeichnis für Ihr Paket. Es wird als ein virtuelles 
    <path>/tmp</path> Verzeichnis verwendet, während das Ebuild 
    durchgearbeitet wird.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Das Stammverzeichnis in welches das Paket installiert wird. Behandeln Sie 
    es als das virtuelle <path>/</path>.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage organisiert verschiedene Versionen des gleichen installierten 
    Programms. Wenn Sie z.B. GCC 2.95 und GCC 3.2 zur selben Zeit installiert 
    haben wollen, würden Sie das <c>SLOT</c> in jedem Ebuild definieren. 
    Hier würden wir das <c>SLOT</c> von GCC 2.95 auf <c>2</c> setzen, welches 
    das <c>SLOT</c> von GCC 3.2 auf <c>3</c> setzen würde.
    <br />
    <b>Beachten Sie</b>: Verwendet man <c>0</c> als den Wert von <c>SLOT</c> 
    bedeutet dies, dass dieses Paket nur eine <c>SLOT</c> Einstellung hat (mit 
    anderen Worten: dieses Paket ist nicht SLOTbar). 
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Diese Variable spezifiziert unter welcher Lizenz das Programm freigegeben 
    ist, z.B. GPL-2, BSD, etc... Dieses Feld muss auf eine gültige Lizenz 
    gesetzt sein (welche irgendeine aus <path>/usr/portage/license/</path> 
    sein kann). Wenn die Lizenz dort nicht schon vorhanden ist, muss Sie 
    hinzugefügt werden, bevor das Ebuild dem Portagebaum hinzugefügt werden 
    kann.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Diese Variable unterstützt eine Zahl verschiedener Funktionen. Zunächst
    spezifziert diese Variable für welche Architektur dieses Ebuild gedacht 
    ist. Mögliche Keywords sind: <e>x86, ppc, sparc, mips, alpha, arm, hppa, 
    amd64, ia64</e>. Natürlich würden Sie dies auf die Architektur Ihres 
    Zielsystems setzen. Portage wird einer x86 Maschine nicht erlauben 
    irgendetwas anderes als x86 zu erstellen, wie angegeben in der 
    <c>KEYWORDS</c> Variable. Pakete die die gegebene Architektur nicht 
    unterstützen werden automatisch von Portage maskiert. Wenn dem 
    <c>KEYWORDS</c> Flag ein <e>~</e> Zeichen vorangeht, dann besagt dies, 
    dass das Ebuild funktioniert aber in verschiedenen Umgebungen getestet 
    werden muss, bevor es ins stable (stabile) Profil mit dem gegebenen 
    Keyword wandert. Wenn dem <c>KEYWORDS</c> Flag ein <e>-</e> Zeichen 
    vorangeht, dann funktioniert das Ebuild mit der gegebenen Architektur 
    nicht. Wenn den <c>KEYWORDS</c> nichts voransteht, dann wird das Paket als 
    stable angesehen. Sie können die Installation von diesen verschiedenen 
    Typen von Paketen durch die <c>ACCEPT_KEYWORDS</c> Variable in 
    <path>make.conf</path> erlauben.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti>Eine <e>kurze</e> einzeilige Beschreibung Ihres Paketes.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    Die URL für jede Quelldatei in Ihrem Paket getrennt durch Leerzeichen. 
    Normalerweise sieht die Erste in etwa so aus: 
    &quot;ftp://ftp.company.com/pub/einpaket/${P}.tar.bz2&quot;
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    Die Homepage des Paketes. Wenn es Ihnen nicht möglich ist eine offizielle 
    zu finden, versuchen Sie einen Link von <uri link="http://freshmeat.net/">
    freshmeat.net</uri> oder einer ähnlichen Paket-Tracking-Seite zu liefern.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Dies ist gesetzt auf jene <c>USE</c> Variablen die Ihr Paket verwendet. 
    Denken Sie daran, dass <c>KEYWORDS</c> hier nicht aufgelistet werden 
    sollen!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Die Erstellungsabhängigkeiten des Paketes werden hier aufgelistet. 
    Betrachten Sie den Abschnitt <uri link="#doc_chap5">Paketabhängigkeiten
    </uri> für weitere Details über korrekten Syntax.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Die Ausführabhängigkeiten des Paketes sind hier aufgelistet. Auch hier 
    betrachten Sie bitte <uri link="#doc_chap5">Paketabhängigkeiten</uri> für 
    weitere Details.
  </ti>
</tr>
</table>

<p><b>Funktionen</b></p>

<p>
Es gibt viele verschiedene Funktionen die Sie in Ihren Ebuild Dateien 
definieren können, welche den Erstellungs- und Installationsprozess Ihres 
Paketes kontrollieren. 
</p>

<table>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Benutzen Sie diese Funktion um jegliche vorher benötigten Aufgaben 
    durchzuführen. Dies könnte das Erstellen eines Systemaccounts oder das 
    Überprüfen ob eine Konfigurationsdatei existiert sein.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    Informieren Sie den Benutzer über notwendige Aktionen, wenn aus 
    irgendeinem Grund (wie Lizenzprobleme) die Quellen nicht direkt von 
    Portage heruntergeladen werden dürfen. Benutzen Sie dies in Verbindung mit 
    <c>RESTRICT=&quot;fetch&quot;</c>.  Sie sollten nur Nachrichten in dieser 
    Funktion darstellen, niemals <c>die</c> aufrufen.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Benutzen Sie diese Funktion um Ihre Quellen zu entpacken, Patches 
    anzuwenden und zusätzliche Programme wie die autotools auszuführen. 
    Standardmäßig entpackt diese Funktion die Pakete aufgelistet in <c>A</c>.
    Das initiale Arbeitsverzeichnis ist definiert durch <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Benutzen Sie diese Funktion um Ihr Paket zu konfigurieren und zu erstellen. 
    Das Arbeitsverzeichnis ist zunächst auf <c>S</c> gesetzt.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Benutzen Sie diese Funktion um das Paket als ein Image in <c>D</c> zu 
    installieren. Wenn Ihr Paket automake verwendet, dann können Sie dies 
    einfach mit <c>make DESTDIR=${D} install</c> tun.  <e>Stellen Sie sicher, 
    dass Ihr Paket alle Dateien installiert mit <c>D</c> als root!</e> Das 
    Arbeitsverzeichnis ist zunächst <c>S</c>.
    </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Die Befehle in dieser Funktion werden kurz <e>vor dem Einbinden</e> eines 
    Paketimages in das Dateisystem ausgeführt
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Die Befehle in dieser Funktion werden kurz <e>nach dem Einbinden</e> eines 
    Paketimages in das Dateisystem ausgeführt
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Die Befehle in dieser Funktion werden kurz <e>vor dem Entfernen</e> eines 
    Paketimages in das Dateisystem ausgeführt
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Die Befehle in dieser Funktion werden kurz <e>nach dem Entfernen</e> eines 
    Paketimages in das Dateisystem ausgeführt
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Sie verwenden diese Funktion um eine grundlegende Konfiguration für das 
    Paket zu erstellen, nachdem es installiert wurde. Allen Pfaden in dieser 
    Funktion sollte <c>ROOT</c> vorrangehen. Diese Funktion wird <e>nur</e> 
    dann ausgeführt wenn der User folgendes ausführt: 
    <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>
  </ti>
</tr>
</table>

<p><b>Hilfsfunktionen</b></p>

<p>
Sie können auch die folgenden Hilfsfunktionen in Ihren Ebuilds verwenden.
</p>

<table>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Überprüft ob eine oder mehrere gegebene USE-Flags definiert sind. Wenn 
    das so ist, wird die Funktion die Flags, welche in <c>USE</c> existieren, 
    ausgeben. Um die Existenz eines USE-Flags zu überprüfen können Sie 
    <c>[ `use foobar` ]</c> verwenden.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Gibt 0 aus, wenn das System die geforderte Version eines bestimmten 
    Paketes aufweist. Zum Beipsiel <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Gibt <path>kategorie/paket-version</path> vom angeforderten
    <path>kategorie/paket</path> aus. Zum Beipsiel <c>best_version 
    x11-libs/gtk+extra</c>.    
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Diese Funktion überprüft, ob ein USE-Flag definiert wurde und gibt 
    &quot;--with-foobar&quot; oder &quot;--without-foobar&quot; passend aus. 
    Wenn Sie nur ein Argument verwenden, dann ist dieses Argument sowohl 
    USE-Flag als auch with(out)-String. Ansonsten ist das erste Argument das 
    USE-Flag und das zweite Argument der with(out)-String. Zum Beispiel 
    <c>use_with truetype freetype</c> wird &quot;--with-freetype&quot; 
    ausgeben, wenn truetype in <c>USE</c> ist. 
    </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Dasselbe wie <c>use_with</c>, gibt aber &quot;--enable-foobar&quot; oder 
    &quot;--disable-foobar&quot; je nach Wert aus.
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Überprüft ob Portage Kernelversionen kennt. Wenn nicht, wird ein Fehler 
    ausgegeben und dann Abbruch (die). Wenn Sie die Kernelversion in Ihrem 
    Script benötigen, benutzen Sie die <c>KV</c>  Variable, welche automatisch 
    durch Portage definiert ist. Bei einem System auf dem 
    gentoo-sources-2.4.20-r6 verwendet wird hätte <c>KV</c> den Wert 
    &quot;2.4.20&quot;.
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Erstellt (wenn nötig) eine <path>.keep</path> Datei im gegebenen 
    Verzeichnis, so dass es nicht automatisch gereinigt wird. 
    Erstellen Sie <e>niemals</e> selber eine <path>.keep</path> 
    Datei.  Wenn Portage verändert wie <c>keepdir</c> arbeitet, dann wird 
    das Selbsterstellen der Datei dazu führen, dass das Paket beschädigt ist.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Führt <c>./configure</c> mit allen nötigen Pfadänderungen (prefix, host, 
    mandir, infodir, datadir, sysconfdir, localstatedir) aus. Sie können 
    optional zusätzliche Argumente an <c>./configure</c> übergeben indem Sie 
    spezifizieren, wenn Sie <c>econf</c> aufrufen und/oder Sie können die 
    Umgebungsvariable <c>EXTRA_ECONF</c> setzen. Optionen die an configure 
    übergeben werden, werden rückwärts der gegebenen Reihenfolge gültig. 
    Mit anderen Worten, das erste übergebene Argument wird immer vom letzten 
    überschrieben werden.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Führt <c>make install</c> mit den nötigen Pfadänderungen (prefix, datadir,
    mandir, infodir, datadir, sysconfdir, localstatedir) aus. Auch hier können 
    Sie zusätzliche Argumente an den make Befehl übergeben, wenn Sie 
    <c>einstall</c> aufrufen. Bitte beachten Sie, dass es der bevorzugte Weg ist
    mit dem <c>make install DESTDIR=${D}</c> Befehl ein Paket zu installieren 
    und nicht via <c>einstall</c>. Dieser Befehl ist nur ein Rückschritt um 
    kaputte make Dateien zu überwinden.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Sorgt dafür, dass der momentane Prozess abgebrochen wird. Es wird den 
    Benutzer benachrichtigen und die gegebenen Argumente als einen Grund. 
    Versäumen Sie nicht eine Nachricht an <c>die</c> weiterzuleiten, wenn 
    Sie mehr als einen Auruf davon in einer einzelnen Funktion haben. Es ist 
    schwerer einen Fehler aufzuspüren, wenn Sie nicht sicher sind <c>wo</c> 
    das Paket versagt hat.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Informiert den Benutzer über etwas wichtiges. Das an <c>einfo</c> 
    gegebene Argument ist die Nachricht, die der Benutzer sehen wird. Benutzen 
    Sie <c>einfo</c> nicht um Banner wie 
    &quot;*************************************&quot; darzustellen. Die 
    Tatsache, dass Sie <c>einfo</c> verwenden ist genug um die Aufmerksamkeit 
    des Benutzers zu erlangen.
  </ti>
</tr>
</table>

</body>
</section>
<section>
<title>Regeln für das Schreiben einer Ebuild Datei</title>
<body>

<p>
Da Ebuild Dateien eigentlich nur Shell Skripte sind, sollten Sie den Shell-
Script Modus Ihres Editors verwenden um sie zu bearbeiten. Sie sollten korrekte 
Einrückung verwenden, benutzen Sie nur Tab-Zeichen -- <e>keine Leerzeichen</e>. 
Stellen Sie sicher, dass Sie bei Ihrem Editor den Tab-Stopp auf vier 
Leerzeichen gesetzt haben. Stellen Sie sicher, dass Sie immer geschweifte 
Klammern um Ihre Umgebungsvariablen herum verwenden; z.B. <c>${P}</c> anstatt 
einfach nur <c>$P</c>.
</p>

<p>
Lange Zeilen werden mit ' \' umgebrochen und verbunden, daher:
</p>

<pre caption="Verbinden von Zeilen in Ebuilds">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Betrachten Sie für weitere Details  <path>skel.ebuild</path> (normalerweise 
vorhanden in <path>/usr/portage</path>).
</p>

<p>
Wenn Sie Vim verwenden können Sie den folgenden Auszug an das Ende Ihrer 
.vimrc hängen um sicherzugehen, dass Sie die richtigen Eintstellungen 
verwenden, wenn Sie etwas Gentoo-verwandtes bearbeiten.
</p>

<pre caption="Konfigurieren von vmirc für Ebuild Editierung">
if (getcwd() =~ 'gentoo-x86\|gentoo-src\|portage')
  set tabstop=4 shiftwidth=4 noexpandtab
endif
</pre>

<p>
Wenn Sie Emacs verwenden können Sie den folgenden Ausschnitt an das Ende Ihrer 
.emacsrc Datei (für GNU Emacs) oder init.el (für XEmacs) setzen um 
sicherzustellen, dass Sie die korrekten Einstellungen verwenden, wenn Sie 
etwas Gentoo-verwandtes bearbeiten.
</p>

<pre caption="Konfigurieren von emacsrc für Ebuild Editierung">
(defun ebuild-mode ()
  (shell-script-mode)
  (sh-set-shell "bash")
  (make-local-variable 'tab-width)
  (setq tab-width 4))
(setq auto-mode-alist (cons '("\\.ebuild\\'" . ebuild-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.eclass\\'" . ebuild-mode) auto-mode-alist))
</pre>

<p>
Wenn Sie nano verwenden, dann haben Sie Glück! Editieren Sie einfach 
<path>/etc/nanorc</path> und entkommentieren sie die Abschnitte die sich auf 
Ebuilds beziehen.
</p>

</body>
</section>
<section>
<title>USE Variablen</title>
<body>

<p>
Der Zweck von USE Variablen ist es Ihnen es zu ermöglichen Portage global 
zu konfigurieren und automatisch <e>optionale Erstellungszeit</e> Features 
zu aktivieren oder zu deaktivieren. Hier ist ein Beispiel. Sagen wir, dass Sie 
ein GNOME Fan sind und Sie möchten, dass jedes Ebuild, dass die Option hat 
optionale GNOME Unterstützung einzubauen dies auch tun soll. In diesem Fall 
fügen Sie <c>gnome</c> zur <c>USE</c> Variable in <path>/etc/make.conf</path> 
hinzu und dann wird Portage automatisch optionale GNOME Funktionalität zu 
Paketen hinzufügen, wenn möglich. Gleichermaßen, wenn Sie wünschen, dass 
optionale GNOME Funktionen ihren Ebuilds nicht hinzugefügt werden sollen 
editieren Sie einfach <path>/etc/make.conf</path> und stellen Sie sicher, dass 
<c>gnome</c> <e>nicht</e> gesetzt ist in der <c>USE</c> Variable. Gentoo Linux 
hat eine schier überwältigende Anzahl von USE Optionen, welche erlauben, dass 
Sie Ihr System genauso konfigurieren können wie Sie es gerne hätten.
</p>

<note>
Wenn Sie eine USE Variable entfernen (zum Beispiel das Entfernen von 
<c>gnome</c> aus <c>USE</c>) wird dies Portage nur dazu anweisen 
<e>optionale</e> Unterstützung für GNOME zur Erstellungszeit nicht zu 
verwenden. Jedoch wenn Sie mit <c>emerge</c> ein Ebuild installieren, das 
GNOME <e>benötigt</e>, wird das Paket, wie zu erwarten, natürlich GNOME 
Unterstützung aktiviert haben. Dies bedeutet auch, dass GNOME automatisch 
installiert wird (als eine Abhängigkeit) wenn das noch nicht geschehen ist. 
Deswegen ist es immer eine gute Idee <c>emerge --pretend</c> auszuführen 
bevor man das &quot;echte&quot; <c>emerge</c> durchführt. Auf diese Art und 
Weise werden Sie immer genau wissen, was Sie kriegen werden!
</note>

<p>
In Ihren eigenen Ebuilds können Sie überprüfen ob eine USE Variable gesetzt 
ist  durch das Verwenden des <c>use &lt;variable&gt;</c> Befehls. Der 
<c>use</c> Befehl gibt <c>&lt;variable&gt;</c> aus, wenn sie vorhanden ist in 
der <c>USE</c> des Benutzers. Sie würden diesen Befehl normalweise wie folgt 
verwenden:
</p>

<pre caption="Herausfinden ob ein USE-Flag gesetzt ist">
 if use X ; then
  commands specific to X
fi
</pre>

<p>
USE Variablen können auch verwendet werden um Abhängigkeiten zu setzen. Zum 
Beispiel möchten Sie vielleicht nur ein Paket benötigen, wenn eine bestimmte 
USE Variable gesetzt ist. Dies geschieht durch die Benutzung des Syntaxes 
<c>variable? ( meinekat/meinpaket )</c> in der <c>DEPEND</c> Variable Ihres 
Ebuilds. In diesem Beispiel wird <c>meinekat/meinpaket</c> nur benötigt, wenn  
<c>variable</c> in <c>USE</c> vorhanden ist. Es ist auch möglich vorzugeben 
welche Abhängigkeiten verwendet werden sollen, wenn ein USE-Flag gesetzt ist 
und welche wenn es <e>nicht</e> gesetzt ist:  <c>variable? ( 
meinekat/meinpaket) : ( anderekat/anderespaket )</c>.  In diesem Fall, wenn  
<c>variable</c> nicht gesetzt ist, wird statt <c>meinekat/meinpaket</c> 
<c>anderekat/anderespaket</c> verwendet. Zuletzt können Sie auch noch eine 
Abhängigkeit spezifzieren, wenn eine bestimmte Variable <e>nicht</e> gesetzt 
ist. Fügen Sie an die Variable nur das Prefix &quot;!&quot; an; z.B. 
<c>!variable? ( meinekat/meinpaket )</c>. Stellen Sie sicher, dass Ihre Ebuilds 
diesen Syntax verwendem und nicht Bash IFS. Bash Konditionale vertragen sich 
nicht mit dem Abhängigkeitscachen von Portage und die Benutzung dieser wird 
ultimativ Ihr Ebuild beschädigen. 
</p>

<p>
Hier ist ein wichtiger Tipp wie man <c>USE</c> benutzt. Die meiste Zeit hat 
ein Paket ein <c>./configure</c> Script um Konfigurationsschritte 
durchzuführen. Generell wird, wenn Ihr Ebuild <c>./configure</c> benutzt, 
jegliche optionale Erstellungszeitfunktionalität aktiviert oder deaktiviert 
indem man die passenden Argumente an den <c>./configure</c> Befehl übergibt. 
Dies ist die beste Art um dies durchzuführen:
</p>

<pre caption="Konditonale basierend auf USE-Einstellungen">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 ) : ( =net-www/apache-1.* )"

src_compile() {
  econf \
    `use_enable X x11` \
    `use_enable mysql` \
    || die "configure failed"
  emake || die "emake failed&quot;
}
</pre>

<p>
Dieser Ansatz hat ein sehr nettes Resultat. Wir müssen uns keine Sorgen darum 
machen, was die Standardeinstellung für mysql oder X (aktivieren/deaktivieren) 
ist, wir sagen <c>econf</c> explizit, was wir von ihm wollen basierend auf der 
<c>USE</c> Variable. Ganz davon abgesehen, dass es sehr sauber ist, wenn es 
um die Lesbarkeit geht :).
</p>

<p>
Um eine ständig erneuerte Tabelle von USE Variablen zu sehen, gehen Sie bitte 
<uri link="http://www.gentoo.org/dyn/use-index.xml">hierhin</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Orte des Dateisystem</title>
<section>
<title>Einführung in die FHS</title>
<body>

<p>
Die Dateisystem-Layoutstandards welche in Gentoo Linux verwendet werden, 
folgen sehr stark den FHS, was <e>File system Hierarchy Standard</e> bedeutet. 
Eine vereinfachte Beschreibung des Standards ist hier gegeben. Eine 
komplette Spezifikation finden Sie auf <uri>http://www.pathname.com/fhs/</uri>. 
</p>

<note>
Die <path>/opt</path> Hierarchie wird behandelt in Abschnitt 3.12 des FHS. 
Abschnitt 4.4 befasst sich mit dem <path>/usr/X11R6</path> Verzeichnis. KDE 
und GNOME werden nicht spezifisch angesprochen und sind in der Tat nicht einmal 
erwähnt in der momentanen Version des FHS.
</note>

</body>
</section>
<section>
<title>Wie Sie Ihr Paket ins Dateisystem einfügen</title>
<body>

<p>
Normalerweise wenn das Paket autoconf und automake verwendet, sind die 
Standardinstallationsverzeichnisse meistens korrekt. Einige Ausnahmen sind: 
</p>

<ul>
<li>
Wenn Sie ein Programm in <path>/bin</path>, <path>/sbin</path>, 
<path>/usr/bin</path> oder <path>/usr/sbin</path> installieren, dann sollte 
die korrespondierende man Seite des Programms im <path>/usr/share/man</path> 
Baum installiert werden. Dies kann oft dadurch erreicht werden, dass 
<c>./configure --mandir=/usr/share/man</c> im Ebuild spezifziert wird. 
</li>
<li>
GNU info Dateien sollten immer in <path>/usr/share/info</path> installiert 
werden, <e>auch wenn die info Dateien X11, GNOME oder KDE-spezifische 
Programme oder Werkzeuge behandeln</e>.  Machen Sie sich eine Notiz: 
<path>/usr/share/info</path> ist der <e>einzige</e> offizielle Pfad für GNU 
info Dateien. Da viele <c>./configure</c> Skripte standardmäßig in <c>/usr/info
</c> installieren ist es oft notwendig, dass <c>./configure</c> mit dem 
<c>--infodir=/usr/share/info</c> Argument aufgerufen wird.
</li>
<li>
Dokumentationsdateien werden in <path>/usr/share/doc</path> installiert, in 
einem Unterverzeichnis, das den Namen, die Version und die Revision des 
bestimmten Pakets reflektiert. Dies ist für alle Programme gültig: GNOME, 
KDE, X11 und Konsole gleichermassen. Jedoch können einige Programme 
zusätzliche Dokumentation und Support Dateien in einer <path>/usr/share</path> 
Hierarchie für eigene Zwecke unterbringen.
</li>
<li>
X11-spezifische Programme und Bibliotheken sollten immer in <path>/usr</path> 
installiert werden und nicht direkt in <path>/usr/X11R6</path>. Wir 
reservieren die <path>/usr/X11R6</path> Hierarchie für das X Window System 
Version 11 Release 6 <e>selbst</e>. Dies ist vielleicht eher eine 
Wort-für-Wort Interpretation des FHS als jene die einige andere Distributionen 
gewählt haben. 
</li>
<li>
GNOME und KDE Programme gleichermaßen sollten immer in <path>/usr</path> 
installiert werden.
</li>
</ul>

<impo>
Einige Distributionen installieren GNOME und KDE in <path>/opt</path>. Es 
existiert kein Standard für diese Desktopumgebungen auf die Frage wo ihre 
Dateien wirklich installiert werden sollten. Im Interesse von Einfachheit und 
Gängigkeit haben wir uns entschieden KDE und GNOME in die <path>/usr</path> 
Hierarchie zu installieren.
</impo>

<p>
Generell sollten Sie Ihre Ebuilds ihre Dateien im <path>/usr</path> Baum 
installieren lassen. <e>Einige</e> Programme können kompiliert und verlinkt 
werden mit oder ohne GNOME, KDE und X11 Bibliotheken, was zu Verwirrung 
führen kann. Unsere Lösung ist es alles in <path>/usr</path> zu installieren, 
welches Mehrdeutigkeit und unnötige Komplexität für den Ebuild Author 
verhindern soll. Der Ort in den die Dateien eines Programmes installiert 
werden sollen sollte <e>nicht</e> abhängig sein von der Präsenz oder dem 
Fehlen von spezifischen <c>USE</c> Variablen. Daher installieren die 
Ebuilds im Portagebaum <e>fast immer</e> exklusiv in der <path>/usr</path> 
Hierarchie.
</p>

<note>
Das <path>/opt</path> Verzeichnis ist unter Gentoo Linux für nur-binär Pakete 
reserviert. Bespiele sind: mozilla-bin, acroread, netscape und realplayer. 
Pakete die hier installiert werden erfordern in der Regel eine 
<path>/etc/env.d/foo</path> stub Datei. Dies geschieht, damit Pfade und 
zusätzliche Variablen in die Umgebung eingearbeitet werden können. Für 
weitere Informationen über <path>/etc/env.d</path>, besuchen Sie bitte <uri 
link="/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=6">dieses</uri> 
Dokument.
</note>

</body>
</section>
</chapter>
<chapter>
<title>Die Portage Skripte und Hilfsmittel</title>
<section>
<title>Öffentliche Skripte</title>
<body>

<p>
Dies sind Skripte die vom Systemadministrator verwendet werden um Pakete zu 
installieren oder zu entfernen und die Paketdatenbank zu verwalten.
</p>

<p>
<c>ebuild</c> ist der zentrale Kern des Portagesystems. Es führt alle 
Hauptaufgaben wie das Entpacken, Kompilieren, Installieren, Einbinden und 
Entfernen von Paketen durch. Es wird aufgerufen druch den Befehl: 
<c>ebuild pfad/zum/paket.ebuild Befehl</c>. Die verfügbaren Befehle sind: 
</p>

<table>
<tr>
  <th>Befehl</th>
  <th>Beschreibung</th>
  <th>Verwandte <c>ebuild</c> Funktion</th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Führt alle möglichen Befehle aus, welche benötigt werden, bevor das Ebuild 
    fortfahren kann
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>
    Zeigt die Abhängigkeiten, welche benötigt werden um das Paket zu erstellen
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Entpackt, kompiliert, installiert und bindet das Paket in Ihr Dateisystem ein
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Bindet das Paket in Ihr Dateisystem ein, vorausgesetzt, dass die 
    Entpackungs-, Kompilierungs- und Installationsabschnitte schon 
    durchgeführt wurden.
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Entpackt die Quell Tarballs im Arbeitsverzeichnis
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Kompiliert das Paket</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Erstellt ein RPM von dem Paket</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Erstellt ein Gentoo <c>tbz2</c> Paket</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Führt den pre-Entfernungsabschnitt des Paketes aus</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Führt den post-Entfernungsabschnitt des Paketes aus</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Führt den pre-Installationsabschnitt des Paketes aus</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Führt den post-Installationsabschnitt des Paketes durch</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Erstellt eine Standardkonfiguration sobald das Paket eingebunden ist</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Aktualisiert die mtimes für jedes Quellarchiv in dem Paket</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Bereinigt das Arbeitsverzeichnis für das Paket</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Lädt die Quell Tarballs herunter</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Erstellt eine digest Datei für das Paket</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Installiert das Paket im Image Verzeichnis</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Entfernt das Paket von Ihrem Dateisystem</ti>
  <ti>N/A</ti>
</tr>
</table>

<note>
Befehle mit einem Stern (*) werden normalerweise nur von Entwicklern genutzt. 
</note>

<p>
<c>emerge</c> bindet ein Paket und alle seine Abhängigkeiten rekursiv in das 
Dateisystem ein. Diser Befehl hat viele Optionen, versuchen Sie 
<c>emerge --help</c> für eine Liste dieser.
</p>

<p>
<c>env-update</c> aktualisiert die Konfigurationsdateien (inklusive, aber 
nicht begrenzt auf, <path>/etc/ld.so.conf</path> und <path>/etc/profile.env
</path>) um Veränderungen zu beinhalten, welche durch installierte Pakete 
erstellt werden.
</p>

</body>
</section>
<section>
<title>Private Skripte und Befehle</title>
<body>

<p>
Dies sind Skripte, die Sie in Ihren Ebuild Dateien benutzen können um gängige 
Aufgaben durchzuführen.
</p>

<p>
Für die Experten unter Ihnen: Betrachten Sie die Skripte selbst in 
<path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Befehl</th>
  <th>Standardwert</th>
  <th>Beschreibung</th>
  <th>Beispiel</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>
    Setzt die Optionen welche benutzt werden wenn <c>dodir</c> ausgeführt wird
  </ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifzierten Binärdateien in <path>DESTTREE/bin</path>
  </ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Setzt das relative Unterverzeichnis (<e>DOCDESTTREE</e>) verwendet von 
    <c>dodoc</c> 
  </ti>
  <ti><c>docinto Beispiele</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>N/A</ti>
  <ti>Erstellt ein Verzeichnis, behandelt ${D} transparent</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Dateien in das Dokumentationsverzeichnis 
    des Paketes (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (siehe 
    <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Datein mit dem Modus <e>EXEOPTIONS</e> 
    (siehe <c>exeopts</c>) in <path>EXEDESTTREE</path> (siehe <c>exeinto</c>)
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>N/A</ti>
  <ti>Erstellt einen festen Link, behandelt ${D} transparent</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifzierten Dateien und Verzeichnisse in 
    <path>/usr/share/doc/${PF}/html</path> 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Dateien in /usr/share/info und komprimiert 
    sie dann mit gzip
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Dateien mit dem Modus <c>INSOPTIONS</c> 
    (siehe <c>insopts</c>) in <path>INSDESTTREE</path> (siehe <c>insinto</c>)
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Bibliotheken in <path>DESTTREE/lib</path> 
    mit dem Modus 0644
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Bibliotheken in <path>DESTTREE/lib</path> 
    mit dem Modus 0644
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifizierten Bibliotheken in <path>DESTTREE/lib</path> 
    mit dem Modus 0755
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die spezifzierten Dateien, nach dem Suffix der Datei (datei.1 
    geht in <path>man1</path>), in <path>/usr/share/man/manX</path>. 
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installiert die Dateien in <path>DESTTREE/sbin</path> und stellt sicher, 
    dass sie ausführbar sind.
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>N/A</ti>
  <ti>Erstellt einen symlink, behandelt ${D} transparent</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>N/A</ti>
  <ti>   
    Führt make mit <c>MAKEOPTS</c> aus. Einige Pakete können nicht parallel 
    erstellt werden, benutzen Sie stattdessen <c>emake -j1</c>
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>
    Setzt das Stammverzeichnis (<e>EXEDESTTREE</e>)  für den <c>doexe</c> 
    Befehl
  </ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>
    Setzt die Optionen, welche verwendet werden beim Ausführen von <c>doexe</c>
  </ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>N/A</ti>
  <ti>
    Ändert den Besitzer auf den angegeben User für die spezifizierte Datei mit 
    dem chown Befehl, behandelt ${D} transparent
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>N/A</ti>
  <ti>
    Wendet die spezifizierten Berechtigungen auf die spezifizierte Datei mit 
    dem chmod Befehl an, behandelt ${D} transparent
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Setzt das Root (<e>INSDESTTREE</e>)  für den <c>doins</c> Befehl</ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>
    Setzt die Optionen, welche verwendet werden, wenn <c>doins</c> ausgeführt 
    wird
  </ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Setzt das Zielprefix (<path>DESTTREE</path>) für alle 'do' Befehle  
    (wie <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, 
    <c>domo</c>, <c>dosbin</c>)
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>
    Setzt die Optionen, welche verwendet werden, wenn <c>dolib</c> ausgeführt 
    wird
  </ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>dobin</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
    Wrapper around <c>dobin</c> which installs the specified binary 
    transparently renaming to the second argument
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>dodoc</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>doexe</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>doins</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>doman</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper um <c>dosbin</c> welcher die spezifizierte Datei installiert und
    transparent zum zweiten Argument umbenennt
 </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>N/A</ti>
  <ti>
    Führt <c>prepallman</c>, <c>prepallinfo</c> und <c>prepallstrip</c> aus. 
    Stellt ausserdem sicher, dass alle Bibliotheken in 
    <path>/opt/*/lib</path>, <path>/lib</path>, <path>/usr/lib</path> und 
    <path>/usr/X11R6/lib</path> ausführbar sind. Verschiebt ausserdem 
    jegliche herumliegenden aclocal Macros in <path>/usr/share/aclocal</path>
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>N/A</ti>
  <ti>
    Komprimiert rekursiv mit gzip alle doc Dateien in 
    <path>/usr/share/doc</path> wobei transparent jegliche symlink Pfade 
    korrigiert werden
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Komprimiert rekursiv mit gzip alle info Dateien in 
    <path>/usr/share/info</path>
    </ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>N/A</ti>
  <ti>
    Komprimiert rekursiv mit gzip alle man Seiten in <path>/opt/*/man/*</path>, 
    <path>/usr/share/man/*</path>, <path>/usr/local/man/*</path>, 
    <path>/usr/X11R6/share/man/*</path> und alle symlink Pfade werden 
    transparent behoben
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</section>
</chapter>
<chapter>
<title>Paketabhängigkeiten</title>
<section>
<title>Warum Abhängigkeiten wichtig sind</title>
<body>

<p>
Portage ist mehr als nur ein Komfort-Script, dass Ihnen eine einheitliche 
Art zur Erstellung eines jeden Projekts (Programm, Bibliothek) von Quellcode 
liefert. Auch besorgt und installiert es alle notwendigen Abhängigkeiten, 
wenn Sie sich darum kümmern diese in Ihrem Ebuild zu spezifizieren.
</p>

<p>
In den offiziellen Ebuilds wurden alle Abhängigkeiten bereits spezifiziert, 
damit, wenn Sie <c>emerge net-www/mozilla/mozilla-1.0</c> durchführen, Portage 
sicherstellt dass alle notwendigen Bibliotheken dafür dass Mozilla erstellt und 
ausgeführt werden kann ordnungsgemäß installiert sind, bevor Mozilla selbst 
erstellt wird.
</p>

<p>
Portage unterscheidet sogar zwischen Erstellungsabhängigkeiten und 
Ausführungsabhängigkeiten. (Jedoch: Momentan installiert Portage alle 
Erstellungs- und Ausführabhängigkeiten und belässt es dabei. Zu einem späteren 
Zeitpunkt wird es möglich sein die Installation so zu trimmen, dass nur die 
Ausführabhängigkeiten installiert bleiben.)
</p>

</body>
</section>
<section>
<title>
Wie Sie Abhängigkeiten in Ihren Ebuid Dateien spezifizieren (a.k.a. 
DEPEND Atome)
</title>
<body>

<p>
Die <c>DEPEND</c> Variable innerhalb Ihrer <path>foo-x.y.z.ebuild</path> sagt
Portage welche Pakete zur Erstellung von <path>foo</path> benötigt werden. Die 
<c>RDEPEND</c> Variable spezifiziert welche Pakete benötigt werden damit 
<path>foo</path> augeführt werden kann.
</p>

<pre caption="Abhängigkeitsbeispiel">
DEPEND="virtual/glibc
        sys-libs/zlib"
RDEPEND="virtual/glibc"
</pre>

<p>
Dies sagt Portage, dass um <path>foo-x.y.z</path> zu erstellen, die Pakete 
<path>virtual/glibc</path> (mehr über Virtuals in einem Moment) und 
<path>sys-libs/zlib</path> benötigt werden. Es sagt nichts darüber aus welche 
Version von glibc und zlib benötigt werden, was bedeutet das "alles geht".
</p>

<p>
Dieses "alles geht" ist natürlich ein wenig gruselig und wird im Normalfall nicht 
funktionieren. Aber für zentrale Bibliotheken wie glibc, welche sehr stark 
danach streben 100% binäre Kompatibilität die ganze Zeit zu erreichen, 
funktioniert es sogar. Für andere Bibliotheken können wir natürlich 
Versionsabhängigkeiten spezifzieren.
</p>

<pre caption="Versionsbeispiel">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= und = tun was Sie erwarten würden; sys-apps/bar Version 1.2 oder neuer 
ist in Ordnung (was bedeuted, dass sys-apps/bar-2.0 in Ordnung ist), während 
sys-apps/baz Version 1.0 die einzige Version ist die akzeptiert wird. Für 
weitere Informationen über das Versionsschema von Paketen betrachten Sie den 
obrigen Abschnitt über <uri link="#doc_chap2_sect2">Benennen von Ebuild 
Dateien</uri>. 
</p>

<p>
Andere Methoden um Versionsabhängigkeiten zu spezifizieren sind folgende:
</p>

<pre caption="Spezifizieren von Versionsanhängigkeiten">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 wird die aktuelleste Portage Revision von qux-1.0 auswählen.
</p>

<p>
=sys-apps/foo-1.2* wird das neueste Mitglied der 1.2 Serie auswählen, aber 
wird 1.3 und spätere/frühere Serien ignorieren. Was bedeuted, dass foo-1.2.3 
und foo-1.2.0 beide gültig sind aber foo-1.3.3, foo-1.3.0 und foo-1.1.0 sind 
es nicht.
</p>

<p>
!sys-libs/gdbm verhindert dass dieses Paket installiert wird solange gdbm 
installiert ist
</p>

<note>
Für die allerneuesten Details über diese DEPEND Atome, betrachten Sie bitte 
die Sektion 5 der man Seite über Ebuilds. <c>man 5 ebuild</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Testen und Einsetzen</title>
<section>
<title>ChangeLog</title>
<body>

<p>
Wann immer Sie ein Ebuild erneuern (oder ein Neues schreiben) müssen Sie auch 
sein ChangeLog erneuern (oder neu erstellen). Das <path>skel.ChangeLog</path> 
enthält ein Beispielsdatei für ChangeLog, die Sie als Basis verwenden können.
</p>

<p>
Der Zweck des ChangeLog ist die Dokumentierung davon <e>was</e> getan wird,
<e>warum</e> es getan wird und von <e>wem</e>. Dies erlaubt sowohl Entwicklern 
als auch Benutzern die gemachten Veränderungen auf eine einfache Art 
nachzuvollziehen.
</p>

<p>
Das ChangeLog zielt primär auf die Benutzer, halten Sie also Ihre Ausführungen 
knapp und vermeiden Sie ausführliche interne technische Details.
</p>

</body>
</section>

<section>
<title>Lokales Speichern Ihrer eigenen Ebuilds</title>
<body>

<p>
Damit Sie die Möglichkeit haben Ihre Ebuilds zu testen und Portage über sie 
wissen zu lassen müssen Sie diese in einem bekannten Verzeichnis plazieren. 
Portage wird die <c>PORTDIR_OVERLAY</c> Variable benutzen, welche Sie in 
<path>/etc/make.conf</path> definieren können. Sie sollten diese Variable auf 
Ihr Verzeichnis setzen (z.B. <path>/usr/local/portage</path>).
</p>

<p>
In diesem Verzeichnis müssen Sie diesselbe(n) Struktur (und Kategorien) 
verwenden wie in <path>/usr/portage</path>. 
</p>

<p>
Benutzt man dieses <c>PORTDIR_OVERLAY</c> verbleiben Ihre Ebuilds auf Ihrem 
System selbst nach einem <c>emerge sync</c> und sie sind weiterhin von 
Portage erfasst.
</p>

</body>
</section>

<section>
<title>Nützliche Testwerkzeuge</title>
<body>

<p>
Wir haben ein paar nützliche Werkzeuge die Ihnen helfen sollen mit dem 
Schreiben und der Pflege Ihrer Ebuilds.
</p>

<warn>
<c>lintool</c> ist kaputt. Bnutzen Sie stattdessen repoman. 
</warn>

<table>
<tr>
  <th>Werkzeug</th>
  <th>Paket</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Nur-Entwickler Werkzeug um bei der CVS-checkin-Prozedur zu assistieren. 
    Es führt viele gängige QA durch und versucht sicherzustellen, dass die 
    Dateien die zum CVS hinzugefügt werden den Portagebaum nicht beschädigen.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Werkzeug das zuvor abgearbeitete Dateien behält, damit eine 
    Neukompilierung <e>viel</e> schneller fertig wird. Stellen Sie sicher, dass 
    <c>ccache</c> zur <c>FEATURES</c> Variable in <path>/etc/make.conf</path> 
    hinzugefügt wird!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Startet eine Shell, die eine Sandbox Umgebung erstellt. Nützlich um dieselbe 
    Umgebung zu betreten in denen Portage Pakete erstellt um die Dinge per 
    Hand zu debuggen.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>
    Kann ein neues ChangeLog erstellen oder einen Eintrag zu einem
    Existierenden hinzufügen.
  </ti>
</tr>
<!--
<tr>
  <ti><c>gentool-bump-revision</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>
    Nur-Entwickler Werkzeug, dass die Revisionsnummer erhöht, die neue 
    Revision zum CVS hinzufügt, die alte Revision entfernt und das ChangeLog 
    entsprechend anpasst.
  </ti>
</tr>
-->
<tr>
  <ti><c>qpkg</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>
    Ein Hilfsmittel um verschiedene Informationen über installierte Pakete 
    zu sammeln.
  </ti>
</tr>
</table>

</body>
</section>
</chapter>
</guide>
