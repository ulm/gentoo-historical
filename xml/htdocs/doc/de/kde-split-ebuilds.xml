<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/de/Attic/kde-split-ebuilds.xml,v 1.1 2005/10/12 00:38:55 grahl Exp $ -->

<!-- English CVS Version: 1.7 -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/de/kde-split-ebuilds.xml" lang="de">

<title>Das KDE Split Ebuilds HOWTO</title>

<author title="Autor">
  <mail link="danarmak@gentoo.org">Dan Armak</mail>
</author>
<author title="Übersetzer">
  <mail link="mbuerger@edu.uni-klu.ac.at">Martin Bürger</mail>
</author>

<abstract>
Mit KDE 3.4 wurden die 'split' Ebuilds in Portage eingeführt. Diese Seite
erläutert den Grund für diesen Wechsel, die neuen Eigenschaften und den Weg für
eine Aktualisierung von den altbewährten 'monolithischen' Ebuilds.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.5</version>
<date>2005-07-02</date>

<chapter>
<title>Die KDE 'split' Ebuilds</title>
<section>
<title>Was sie ausmacht</title>
<body>

<p>
Bis Jannuar 2005 waren die monolithischen Ebuilds die einzigen KDE Ebuilds in
Portage. Dazu ist zu sagen, dass es damals nur 15 Ebuilds gab und jedes
einzelne installierte viele Anwendungen, die aber selbst nicht voneinander
abhängig waren. Das war offensichtlich eine suboptimale Situation und nicht
besonders Gentoo-isch, aber es wurde für eine lange Zeit toleriert.
</p>

<p>
Die neuen 'split' Ebuilds verbesserten die Situation, indem sie separate
Ebuilds für alle separaten KDE Anwendungen boten. Das gab uns eine Summe von
330 neuen Ebuilds in der kde-base Kategorie.
</p>

<p>
Wir bieten noch immer die monotlithischen Ebuilds für KDE 3.4 an, und sie
bieten alles, was auch die 'split' Ebuilds bieten. Jedoch sind die 'split'
Ebuilds nun der neue Standard, und ab KDE 4.0 wird es keine monolithischen
Ebuilds mehr geben.
</p>

<p>
Schließlich sollte noch erwähnt werden, dass es auch 'split' Ebuilds für
KOffice gibt. Diese stellen KWord, Kugar u.s.w. als separate Pakete zur
Verfügung.
</p>

</body>
</section>
<section>
<title>Wie installieren Sie die 'split' Ebuilds</title>
<body>

<p>
Das letzte KDE Release, zum Zeitpunkt der Erstellung dieses Dokuments, ist
3.4.1, kürzlich als stabil markiert. Sowohl die 'split' als auch die
monolithischen Ebuilds sind dafür in Portage vorhanden.
</p>

<ul>
  <li>
    Um ein spezielles Paket wie kmail zu installieren, reicht es, <c>emerge
    kmail</c> einzugeben.
  </li>
  <li>
    Um die KDE Basisumgebung, die es Ihnen erlaubt sich in eine minmale KDE
    Sitzung einzuloggen, zu installieren, <c>emerge kdebase-startkde</c>.
  </li>
  <li>
    Um schließlich das exakte Äquivalent eines der monolithischen Pakete zu
    installieren - zum Beispiel um alle Anwendungen, die in <c>kdebase</c>
    enthalten sind mit den 'split' Ebuilds zu installieren - können Sie
    <c>emerge kdebase-meta</c> (oder kdepim-meta, u.s.w.) ausführen.
  </li>
</ul>

</body>
</section>
<section>
<title>Wie aktualisieren Sie von monolithischen auf 'split' Ebuilds</title>
<body>

<p>
Wenn Sie KDE 3.3.x installiert haben, können Sie einfach <c>emerge kde-meta</c>
ausführen, um die 3.4.x 'split' Ebuilds zu installieren, ohne Ihre vorhandene
Installation zu beeinflussen.
</p>

<p>
Wenn Sie die KDE 3.4.x monolithischen Ebuilds installiert haben, müssen Sie sie
zuerst deinstallieren bevor Sie die 'split' Ebuilds installieren können.
Dieser Vorgang kann für jedes monolithische Ebuild wiederholt werden; Sie
müssen nicht alles von KDE auf einmal deinstallieren.
</p>

<p>
Wenn Sie sich nicht sicher sind, seien Sie sich bewußt, dass es blockierende
Abhängigkeiten zwischen den monolithischen und 'split' Ebuilds gibt. Portage
wird es Ihnen nicht erlauben, einen ungültigen Zustand zu erstellen, also
jede Installation oder Deinstallation, die erlaubt wird, ist OK.
</p>

</body>
</section>
<section>
<title>Vorteile der 'split' Ebuilds</title>
<body>

<p>
Hier ist eine kurze Liste, mit dem, was wir beim Wechsel zu den 'split' Ebuilds
gewinnen:
</p>

<ul>
  <li>
    An den meisten KDE Paketen werden zwischen kleinen KDE Releases keine
    Änderungen vorgenommen. Zum Beispiel die Aktualisierung von 3.3.1 zu 3.3.2
    änderte weniger als 100 von 320 Paketen. Die nun aufgespaltenen Pakete
    erlauben es uns, nur neue Ebuilds für die Pakete zu erstellen, die auch
    wirklich verändert wurden, was somit 2/3 (in diesem Beispiel) an
    Kompilierungszeit einspart.
  </li>
  <li>
    Patches betreffen für gewöhnlich ausgewählte Pakete. Mit den 'split'
    Ebuilds können diese schneller getestet, genehmigt und aufgenommen werden,
    und die Entwickler haben weniger zu tun; und, wie oben, der Benutzer muss
    weniger Zeit mit der Aktualisierung verbringen. Das ist im speziellen auch
    für Sicherheits-Updates relevant.
  </li>
  <li>
    Benutzer von anderen Desktopumgebungen und schlankeren Fenstermanagern
    können einige beliebte KDE Anwendungen - ohne den überflüssigen Rest, wie
    kdebase oder kdepim - installieren.
  </li>
  <li>
    Benutzer können installierte Pakete noch weiters nach Ihren Bedürfnissen
    anpassen. Gründe für dies:
    <ul>
      <li>
        Sie interessieren sich für die Kompilierungszeit. <c>emerge kdebase
        kdepim kdenetwork</c> benötigt viel zu viel Zeit, wenn Sie nur
        Konqueror, Kmail und Kopete installieren möchten. Nebenbei, CPU Zeit ist
        Geld... mancherorts.
      </li>
      <li>
        Sie interessieren sich für den Festplattenverbrauch. Jedes unbenötigte
        Paket benötigt Platz auf Ihrer Festplatte.
      </li>
      <li>
        Sie interessieren sich für die Systemsicherheit. Die gesamte
        installierte Software ist eine potentielle Quelle für
        verwundbare/angreifbare Stellen, und es gibt keine Entschuldigung für
        unbenötigte Software, die nur so herumliegt.
      </li>
      <li>
        Sie folgen treu dem <uri link="/main/de/philosophy.xml">Gentoo
        Weg</uri>, und mögen keine gebündelten, dem Benutzer aufgezwungenen
        Pakete. (Mögen auch wir nicht.)
      </li>
    </ul>
  </li>
  <li>
    Schließlich bieten die 'split' Ebuilds auch mehr Flexibilität gegenüber USE
    Flags während der Installation von Paketen.
  </li>
</ul>

</body>
</section>
<section>
<title>Interoperabilität von 'split' und monolithischen Ebuilds</title>
<body>

<p>
'Split' und monotlithische Ebuilds können miteinander frei vermischt werden.
Die einzige Einschränkung ist die, dass monolithische Ebuilds nicht installiert
werden können, wenn es bereits ein installiertes 'split' Ebuild gibt, das vom
monolithischem abgeleitet werden kann. Es gibt in den Ebuilds blockierende
Abhängigkeiten, die das erzwingen, somit können Sie alles tun, was Ihnen emerge
erlaubt.
</p>

<p>
Jedoch gibt es für gewöhnlich keinen Grund eine gemischte Konfiguration zu
verwenden. In der Tat, ausgenommen von wenigen spzielle Fällen wie sehr
langsamen Maschinen (MIPS), sollten Sie für Ihren Gebrauch die 'split' Ebuilds
verwenden.
</p>

<p>
Die 'split' Ebuilds sind auch die Standard Ebuilds. Das bedeutet, dass wenn
eine andere Anwendung von KDE Anwendungen abhängig ist, wird es die 'split'
Ebuilds installieren wollen. Jedoch wir das passende monolithische Ebuild
auch die Abhängigkeit erfüllen, somit können Sie auch das monolithische
Ebuild manuell installieren und dann das davon abhängige Ebuild installieren.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Performanzüberlegungen</title>
<section>
<title>Warum sind 'split' Ebuilds langsam</title>
<body>

<p>
Es wurde bereits <uri
link="http://bugs.gentoo.org/show_bug.cgi?id=11123">gesagt</uri>, dass die
'split' Ebuilds viel mehr Zeit für die Installation benötigen werden als die
monotlischen, wegen dem Mehr an Entpacken und Konfigurieren für jedes Paket.
Ein vollständiges <c>emerge kde-meta</c> könnte 20-30% länger dauern als
ein klassisches <c>emerge kde</c>, unakzeptabel in einem bereits langen
Kompiliervorgang.
</p>

<p>
Darüberhinaus wird zur Zeit bei den 'split' Ebuilds jedesmal <c>make -f
admin/Makefile.cvs</c> (das bedeutet autoconf, automake u.s.w. und weitere
KDE-spezifische Skripte werden ausgeführt). Das verlangsamt den Prozess um
dieselbe Größe wie ein Konfigurationslauf.
</p>

<p>
Oberflächlich betrachtet, spricht diese Analyse für sich. Es werden jedoch
mehrere Faktoren, die diese Verlangsamung ausgleichen, im nächsten Abschnitt
detailiert behandelt.
</p>

<p>
Es ist gut, nochmals hier zu erwähnen, dass mit den 'split' Ebuilds die
Kompilierungszeit einer KDE Aktualisierung um die Hälfte reduziert werden kann -
und in manchen Fällen um einen Faktor zehn oder mehr - indem einfach nur Pakete
aktualisiert werden, die auch verändert wurden. Der Vorteil von solch einem
einzelnen Update überschattet oft die überflüssigen Vorgänge während der
ursprünglichen Installation.
</p>

<p>
Schließlich macht auch die Installation von allen KDE Paketen Sinn, wenn Sie
die verfügbaren Pakete kennenlernen oder eine Mehrbenutzerumgebung aufsetzen
möchten; jedoch verwenden die meisten Leute nur einige der 300+ verfügbaren KDE
Anwendungen. Jeder, der sich für die Kompilierungszeit interessiert, wie
Benutzer von älteren PCs, kann durch selektives Installieren von Paketen mehr
Zeit gewinnen als verloren gehen würde durch die Installation aller Pakete.
</p>

</body>
</section>
<section>
<title>Wie 'split' Ebuilds schneller gemacht werden</title>
<body>

<p>
Die offensichtlichste Verbesserung wäre es, separate Tarballs für die 'split'
Ebuilds zu verteilen, anstelle einzelne Teile von den monolithischen Tarballs
(kdebase u.s.w.) zu entpacken. Das würde zwei von den drei Faktoren, die die
'split' Ebuilds verlangsamen, eliminieren: wiederholtes Entpacken von den
großen Tarballs und erneutes Generieren des makefile (die <c>make -f
admin/Makefile.cvs</c> Phase wie oben erwähnt).
</p>

<p>
Somit bleibt noch das Problem mit dem wiederholten Ausführen von configure.
Eine Lösung für das ist confcache: ein configure Cache, der unter Aufrufen
von emerge geteilt wird. Es existiert bereits eine Implementierung im
Entwicklerzweig von Portage (das Tool, nicht dem Paketbaum); eine stabile
Version mit confcache wird in einem halben Jahr oder so erwartet.
</p>

</body>
</section>
<section>
<title>Andere Faktoren, die die 'split' Ebuilds Verlangsamung wieder
ausgleichen</title>
<body>

<p>
Der vorangegangene Abschnitt zeigte Methoden, die speziell die Performanz von
'split' Ebuilds verbessern. Als nächstes werden wir kurz ein paar zukünftige
Verbesserungen, die auch auf die monolithischen Ebuilds zutreffen, erwähnen.
Solche Verbesserungen machen die 'split' Ebuilds 'schnell genug', abgesehen von
dem Vergleich mit weniger ausgereiften Lösungen wie die monolithischen Ebuilds.
</p>

<ul>
  <li>
    KDE 4.0 sollte in der Lage sein <uri
    link="http://www.kde.me.uk/index.php?page=unsermake">unsermake</uri>
    anstatt von automake zu verwenden, was die Kompilierung in einigen Szenarien
    beschleunigt; unsere KDE 3.4 Ebuilds dürften möglicherweise auch unsermake
    verwenden.
  </li>
  <li>
    Die 'split' Ebuilds unterstützen auch das kdexdeltas USE Flag, was das
    Herunterladen von binären Diffs zwischen Release Tarballs erlaubt, um
    Bandbreite zu sparen.
  </li>
  <li>
    Alle anderen Tools, die während der Installation involviert sind, werden im
    Allgemeinen mit der Zeit auch schneller oder ermöglichen verschiedene KDE
    spezifische Kompilierungsverbesserungen. Neu sind zum Beispiel auch Features
    wie visibility=hidden (GCC 3.4) und vorkompilierte Headers (GCC 4.0). Das
    sind keine direkten Erungenschaften vom Wechsel zu den 'split' Ebuilds; sie
    bedeuten nur, dass wir nun CPU intensivere Kompilierungsvorgänge verwenden
    können.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>'Split' Ebuilds FAQ</title>
<section>
<title>Können wir das nicht bereits auch mit DO_NOT_COMPILE tun?</title>
<body>

<p>
DO_NOT_COMPILE ist eine für das KDE Buildsystem interne Umgebungsvariable. Sie
erlaubt es selektiv Unterverzeichnisse vom Kompilierungsvorgang auszuschließen.
Einige Leute verwendeteten sie, um Teile des monolithischen KDE Ebuilds zu
kompilieren. Zum Beispiel würde <c>DO_NOT_COMPILE=konqueror emerge kdebase</c>
kdebase ohne die Anwendung Konqueror installieren.
</p>

<p>
Jedoch war DO_NOT_COMPILE nie dafür ausgelegt sich in den Prozess eines
automatisierten Vorgangs eines Paketmanagers einzumischen. Es funktioniert
einfach nicht, es kann das System lahm legen, und es wurde nie unterstützt.
Wir bitten jeden von der Verwendung dieses Konstrukts Abstand zu nehmen.
</p>

<p>
Here ist eine unvollständige Liste von Problemen mit DO_NOT_COMPILE:
</p>

<ul>
  <li>
    Es führt dazu, dass Portage Abhängigkeiten nicht korrekt nachvollziehen
    kann. Portage weiß nichts von DO_NOT_COMPILE und denkt, dass das ganze
    monolithische Paket installiert wurde und somit die Abhängigkeiten von
    anderen Paketen erfüllen kann. Das kann dazu führen, dass sich andere
    Pakete nicht installieren oder ausführen lassen.
  </li>
  <li>
    Es zwingt den Benutzer dazu, die Namen und Bedeutung von allen verschiedenen
    vorhandenen Unterverzeichnissen von den KDE Modulen zu kennen. Sehr wenige
    Benutzer kennen diese, wenn sie nicht gerade KDE Entwickler sind, also
    können sie DO_NOT_COMPILE nicht korrekt verwenden.
  </li>
  <li>
    Unterverzeichnisse von KDE Modulen können selbst untereinander Abhängkeiten
    haben, die eine besondere Reihenfolge der Verarbeitung verlangen, ein
    anderes Verzeichnis benötigen auch wenn es nicht installiert werden muss,
    und so weiter. Wir haben viel Arbeit in die 'split' Ebuilds gesteckt, damit
    sie in diesem Zusammenhang korrekt arbeiten. DO_NOT_COMPILE ist nicht im
    Entferntesten ein ausreichend präzises Tool, dass dieselben Ergebnisse
    erreichen läßt, auch nicht mit ausreichend gegebenen Wissen auf der
    Benutzerseite. Das einzige, was Sie damit machen können, ist ein paar
    Anwendungen vom Kompiliervorgang auszuschließen. Es ist praktisch unmöglich
    ein paar ausgewählte Anwendungen von Modulen wie kdebase oder kdepim damit
    zu installieren.
  </li>
  <li>
    Wenn ich gestern Kmail installiert habe, und heute möchte ich mit
    DO_NOT_COMPILE Korn hinzufügen, führt es dazu, dass Kmail auch nochmals
    kompiliert wird. Das bedeutet, DO_NOT_COMPILE ist immer langsamer als die
    'split' Ebuilds.
  </li>
  <li>
    DO_NOT_COMPILE kann nicht dazu verwendet werden, um vorkompilierte Pakete
    (wie die GRP), die einzelne KDE Anwendungen beinhalten, zu installieren.
  </li>
</ul>

</body>
</section>
<section>
<title>Führt das nicht zu sehr viel Arbeit für die Gentoo KDE Maintainer?</title>
<body>

<p>
Diese Frage wird überraschenderweise oft gestellt. Ich bin froh, dass sich
Benutzer so um uns Maintainer sorgen. Lassen Sie mich die Gelegenheit nutzen,
um Ihnen zu versichern, dass wir uns den 'split' Ebuilds aus unserem freien Willen
heraus angenommen haben; dass wir daran glauben, dass wir in der Lage sein
werden, diese weiterhin gut verwalten zu können; und dass es keine Chance gibt,
uns davon abzuhalten :-)
</p>

<p>
Der Vollständikeit halber sollte ich erwähnen, dass sich die Maintainer von
anderen Architekturen sehr wohl über den erhöhten Aufwand was Testen und
Keywording von so vielen separaten Ebuilds betrifft, beschwert haben. Wir
arbeiten daran, und es ist auch ein Hauptgrund warum es monolithische Ebuilds
noch immer für KDE 3.4 gibt.
</p>

</body>
</section>
<section>
<title>Werden die alten (monolithischen) Ebuilds entfernt?</title>
<body>

<p>
Wir haben vor, das früher oder später zu tun. Jedoch wird es sowohl monolithische
als auch 'split' Ebuilds für alle KDE 3.4 Releases geben.
</p>

<p>
Wenn Sie die monolithischen den 'split' Ebuilds gegenüber vorziehen, bitte
<uri link="http://bugs.gentoo.org">teilen Sie uns</uri> Ihre Gründe mit.
</p>

</body>
</section>
<section>
<title>Es gibt zuviele Ebuilds! Wie soll ich das finden, was ich
brauche?</title>
<body>

<p>
Nun gut, zu allererst wenn Sie wissen, dass das Paket nach dem Sie suchen in
kdebase enthalten war, dann können Sie immer noch <c>emerge kdebase-meta</c>
ausführen, um so ziemlich das selbe Resultat zu erhalten wie wenn Sie das
monolithische <c>kdebase</c> installieren würden. Deswegen haben sich eigentlich
die Dinge wegen der 'split' Ebuilds nicht verschlechtert.
</p>

<p>
Natürlich können Sie noch immer auf demselben Weg ihre Pakete finden. Wie
würden Sie Ihr Ebuild finden, wenn es sich um eine Gnome Anwendung handelt?
Zumindest müssen Sie wissen wie die Anwendung heißt nach der Sie suchen.
</p>

<p>
Die Situation könnte vielleicht verbessert werden, wenn mehrere -meta Ebuilds
zur Verfügung gestellt werden. Sie sind hauptsächlich eine Liste von
Abhängigkeiten, somit bereiten es für uns keine großen Umstände. Darüber wurde
aber noch nichts beschlossen. Auch wäre es nett, wenn Portage
Mengenfunktionalität bieten würde, bevore wir das ausbreiten.
</p>

</body>
</section>
<section>
<title>Wie kann ich eine alte KDE Version deinstallieren?</title>
<body>

<p>
Angenommen KDE 4.0 erscheint und Sie möchten die 'split' Ebuilds für KDE 3.4
deinstallieren. Weil diese sich in unterschiedlichen Slots befinden, wird
emerge das nicht für Sie erledigen, somit wird eine andere Lösung gebraucht.
</p>

<p>
Eine passende Lösung für dieses Problem benötigt Änderungen an Portage. Eine
solche Lösunge wird in <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>
beschrieben. Bis das implementiert ist, müssen wir uns mit Skripten wie dem
folgenden begnügen.
</p>

<p>
Glücklicherweise liegen alle KDE Ebuilds im kde-base Verzeichnis (und alle
Ebuilds in der kde-base Kategorie kommen von kde.org). Somit funktioniert der
folgende Code:
</p>

<pre caption="KDE 3.4 vom System entfernen">
# <i>for x in `ls /usr/portage/kde-base`; do</i>
> <i>if [ "$x" != "CVS" ]; then</i>
> <i>echo -n "=kde-base/$x-3.4* "</i>
> <i>fi</i>
> <i>done |xargs emerge -Cp</i>
</pre>

<p>
Das oben sieht ein wenig nach einem Hack aus, aber es ist keiner, denn alles
was wir benötigen ist eine Liste der Ebuilds aus kde-base. Das ist eine sehr
einfache Aufgabe und somit wird es immer einen einfachen Weg zur Durchführung
geben.
</p>

</body>
</section>
<section>
<title>Wie kann ich alle 'split' Ebuilds, die von einem gegebenen Paket abgeleitet werden können, auflisten/deinstallieren?</title>
<body>

<p>
Das jetzige Ziel ist es, eine Liste aller 'split' Ebuilds, die z.B. vom kdebase
monolithischem Ebuild abgeleitet werden können, zu bekommen. Wieder einmal
würde eine passenden Implementierung (wie in <uri
link="http://www.gentoo.org/proj/en/glep/glep-0021.html">GLEP 21</uri>) die
Sache sehr einfach machen. Momentan müssen Sie aber einen Einblick in die
Implementierung der KDE eclasses erlangen. Also, wenn Sie irgendeinen dieser
Ansätze in einem Skript, das nicht für den privaten Gebrauch alleine ist,
verwenden, lassen Sie uns davon wissen.
</p>

<p>
kde-functions.eclass definiert Funktionen wie get-parent-package() und
get-child-packages(), die die Übersetzung für Sie vornehmen. Diese zwei
Funktionen sind der korrekte Weg, um diese Aufgaben von einem Ebuild oder einem
externen Bashskript aus zu lösen. Hier ist ein Beispiel:
</p>

<pre caption="Beispiel der Verwendung der kde-functions Funktionen:">
$ <i>function die() { echo $@; } # um Fehler auszugeben</i>
$ <i>source /usr/portage/eclass/kde-functions.eclass</i>
$ <i>get-parent-package konqueror # wird nicht funktionieren, sie müssen einen
vollen Namen angeben</i>
<i>Package konqueror not found in KDE_DERIVATION_MAP, please report bug # Ausgabe des Fehlers</i>
$ <i>get-parent-package kde-base/konqueror # voll qualifizierter Paketname</i>
<i>kde-base/kdebase # Ausgabe des Ergebnis</i>
$ <i>get-child-packages kde-base/kdebase</i>
<i> # (Ausgabe einer langen Liste von Paketen)</i>
</pre>

<p>
Wenn Ihr Skript nicht in Bash ist, können Sie ein grep auf die
kde-functions.eclass machen, um die (mehrzeilige) Definition der Variable
KDE_DERIVATION_MAP, die die zuvor genannten Funktionen verwendet, zu erhalten.
Diese Variable enthält eine durch Leerzeichen getrennte Liste an Wörtern, und
jede zwei aufeinanderfolgenden Wörter bilden ein Paket auf ein abgeleitetes
'split' Ebuild ab.
</p>

</body>
</section>
</chapter>
</guide>
