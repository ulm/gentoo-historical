<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<guide link="/doc/ja/portage-manual.xml">
<title>Portage Manual</title>
<author title="Author and Editor">
<mail link="blocke@shivan.org">Bruce A. Locke</mail>
</author>
<author title="翻訳"><mail link="a_murata@a2-design.jp">村田顕光</mail>
</author>

<abstract>
このマニュアルは、インストールのためのエンドユーザガイド及び、Portageシステムを利用したパッケージのメンテナンスについての一般的なPortageの概要と、詳細な設定情報について書かれています。
</abstract>

<version>0.9.6</version>
<date>April 27, 2002</date>
<!-- Original revision: 1.4 -->

<chapter>
<title>Portageの概要</title>

<section>
  <title>概要</title>
  <body>
	<p>
	Portageは非常に強力な先進のパッケージ管理システムです。その柔軟性、そしてどちらかというと単純な構築エンジンに役立つかあるいは最先端Linuxディストリビューションの中心を形成する能力は、それにメタディストリビューションエンジンのタイトルをもたらします。
	GentooLinuxディストリビューションはPortageによって構築されます。
	</p>
	<p>	
	Gentoo Linuxはよく、メタディストリビューションと呼ばれます。 
	それはPortageとebuildsと呼ばれる約１，５００セットのパッケージ構築のレシピから構成されます。これらの<i>ebuilds</i>はPortageエンジンに、
	ソフトウェアパッケージをどのようにコンパイルしてインストールするか指示します。
	<i>profile</i>と<i>emerge</i>と呼ばれるコマンドラインユーティリティを使用することで、
	ユーザーと開発者はオペレーティング・システムとアプリケーションをそのシステムの上で構築するパッケージのインストールと管理のためにPortageを使用することができます。
	</p>
	<p>
	Gentoo Linuxシステムは"高速コンパイル"です。 Gentoo Linuxをインストールするという行動は、
	インターネット経由でソースコードをダウンロードし、残りのシステムの"核"、および必要とするどんなアプリケーションの構築も可能なPortageはコンパイラを動かすことと環境構築することと設定することになります。Portageは予め作成されたバイナリパッケージを使用することも可能ですが、
	あるパッケージを速く回復する必要がある開発者によって、または大変性能の低いコンピュータで使用するために素早くコンピュータでパッケージをコンパイルしたい時のためにあり、
	なるべくなら性能の低いコンピュータでインストールする時だけに留めてください。 
	</p>
	<p>
	以上のことと、実際にPortageがGentoo Linuxの非常に少量のパッケージのコンパイルとインストール作業の手順において様々に設定が可能であるということは同様です。つまり、ユーザーがGentooLinuxをインストールする時、Portageシステムは、Portageの構成、ebuildsで指定されるオプションの通りにカスタマイズされたLinuxディストリビューションを構築します。
	</p>
	<p>
	一見、Portageのアイディアは伝統的なBSDのportsシステムに似ているように見えます。
	両方ともソースからパッケージをコンパイルして、自動的に依存性を解決するシステムであり、
	ユーザは安全にソフトウェアのインストールとアンインストールが可能です。
	多くのPortageのアイディアはBSDのportsシステムから継承したものですが、
	Portageは単なる"portsの二番煎じ"ではありません。
	</p>
	<p>
	PortageシステムはPythonを核にしたBashスクリプトによる<i>Ebuilds</i>をベースにマージして構成されています。Makefilesと<i>make</i> コマンドで処理せず、PortageはPythonの能力と、あるオブジェクトの特性を生かしたシェルスクリプトの使用がPortageを全ての現在のportsシステムの頂点にのし上げたと我々は考えます。
	</p>
	<p>
	Portageが提供するいくつかの先進的な特徴は、ツリーの中の同じパッケージの多数のバージョン及び修正の持つ可用性、条件付きの依存性解決及び将来的なサポート、きめ細かいパッケージ管理、"サンドボックス"化された安全なインストール、設定ファイルの保護、profiles、そしてまだまだ多くのもの。これらの特徴の多くは、このマニュアルの後編で詳細に説明していきます。
	</p>
  </body>
</section>

<section>
<title>条件付きの依存性解決およびその支援の特徴</title>
<body>
	<p>
	Portageシステムは、それがユーザーに提供する柔軟性の量においてほかに例がありません。
	伝統的なのBSD portsシステムは、portsツリーで一度にひとつのパッケージのバージョンやリビジョンしかサポートしていません。Portageには、そのような制限がありません。
	同じパッケージの複数のバージョンは、インストールして利用可能です。
	パッケージ依存（コンパイルのために必要なそれらのパッケージともう一つのパッケージの使用）は、その名前か、バージョンを付加した名前で特定することができます。
	これは、複数のバージョンをツリーで安全に利用できるようにしています。
	</p>
	<p>
	依存性システムも、条件つきの依存をサポートします。 Portageは、<i>USE setting</i>システムと呼ばれている強力な機能を持ちます。Portage構成ファイルにおいて1つの構成変数を変えることによって、
	ユーザはコンパイル時に全てのパッケージのために特定の特徴またはライブラリに対するオプションのサポート（そして、このようにそれに依存する必要性）を無効にすることが可能です。
	これは、次の章においてより詳しく説明される非常に柔軟で強力なシステムです。
	</p>
	<p>
	さらに、Portageは<i>SLOTs</i>の機能を持ちます。 Gentoo Linuxの開発の中で、
	開発者は、我々が他のパッケージで必要なものを満たすためにインストールされる特定のパッケージ（例えばライブラリ）の複数のバージョンを持つ必要があるということにしばしば気がつきました。この問題の従来の解決方法は、わずかに異なる名前による異なるパッケージと同じパッケージの異なるバージョンを扱うことになっていました。
	</p>
	<p>
	特定のバージョンを別々のパッケージとみなすことを研究している開発者の代わりに、
	<i>SLOTs</i>の使用開発者は同じパッケージのいくつかのバージョンを取り扱って、
	メンテナンスするPortage方法を考えました。これの例は、freetypeとして知られている一般のライブラリを考慮することになっています。freetypeの1.xは2.xと共存しません、しかし、両方のバージョンはいろいろなパッケージの依存を満たすために必要です。
	ほとんどのディストリビューションとportsシステムは、2.xのためにfreetype 1.xと「freetype2」のために「freetype」パッケージを持つ傾向があります。
	我々は、この解決方法を基本的に壊れたパッケージ管理システムのサインと考えています。
	我々は、単に<i>SLOT</i>ナンバー1を第一とナンバー2を第二に割り当てました。
	それぞれの上流のブランチへの更新がなされるならば、この情報で、Portageは両方のバージョンを追跡することができて、両方のバージョンを更新が可能です。
	</p>
</body>
</section>

<section>
<title>Profiles</title>
<body>

	<p>
	Portageは、<i>profile</i>の機能があります。 profileには、Portageによって使用されるためにコマンドと一組のデフォルト構成オプションでパッケージ名とバージョンのリストを含まれています。Portageはprofileにある、それらのパッケージのどのパッケージ、どのバージョンかを有効にするか無効にするか、または必要に応じて処理するかを解釈します。ユーザーは、一つのsymlinkを変更することによってprofileを変更できます（<i>/etc/make.profile</i>）。これは単純ことのようですが、profileによりPortageがディストリビューションの核を構築でき、専門のグレード構築システムとして使用可能にします。
	</p>
	<p>
	Gentoo Linuxディストリビューションを開発に際し費やされるの努力は、結果としてPortageが使用する<i>ebuild</i>ファイルとprofileのコレクションということになります。
	このprofileは、どのパッケージがシステムのオペレーションに不可欠な「中心的な」パッケージと考えられるかについて定義しています。profileは、開発者達が一時的に不良なパッケージ等をブロックしたり、ブロックを解除させたりすることができるようになっています。
	Portageは実際にどのようにパッケージをビルド、インストールするか、有効、無効のprofileと共に<i>ebuild</i>ファイルにより解釈します。
	</p>
	
</body>
</section>
</chapter>


<chapter>
<title>Portageの設定</title>

<section>
<title>概要</title>
<body>
	<p>
	この章ではユーザーと開発者の両方にとって重要なさまざまな局面のPortageの設定を網羅します。Portageは大変柔軟なシステムで、ユーザは必要に応じて自分のシステムをチャージ及び、最適化するために、Portageを設定する方法を理解する必要があります。
	</p>
	<p>
	このドキュメントで"ユーザー"とあるのはPortageとシステム設定を変更する管理者権限を持った人を意味しているということに注意してください。
	ユーザーはPortageの設定変更とパッケージの追加と削除をするためにrootにならなければなりません。
	</p>
</body>
</section>

<section>
<title>Portage設定ファイル</title>
<body>
	<p>
	下で説明される構成オプションのほぼ全ては、<path>/etc/make.conf</path>、
	<path>/etc/make.profile/make.default</path>と<path>/etc/make.global</path>
	にあります。"Portageに使用される多数の変数は<path>/etc/make.conf</path>にあります。
	Portageはどんな設定よりもまず最初に現在の環境変数をチェックします。
	環境設定が見つからない場合、Portageは次に<path>/etc/make.conf</path>をチェックします。
	<path>/etc/make.conf</path>でも設定が見つからない場合、Portageは<path>/etc/make.profile/make.default</path>をチェックします。
	そこでも設定が見つからない場合、デフォルトの設定は<path>/etc/make.global</path>を使うことになります。すべてのユーザの設定の中で環境変数、または<path>/etc/make.conf</path>はユーザにより変更されやすいということに注意してください。"
	重要なことですが、<path>/etc/make.conf</path>で定義される設定が<path>/etc/make.global</path>のどんな設定をも、ほぼ常に上書きしてしまうということに注意してください。<path>/etc/make.conf</path>
	と<path>/etc/make.global</path>での全てはPortageに関する限り、システム全体に渡るグローバルな設定と考えることができます。
	</p>
	<p>
	既に定義されたオプションがどこにあるか確認したい場合は、まず/etc/make.confを確認し、次に/etc/make.globalsを確認することをお勧めします。特に注意しないのであれば、/etc/make.confで設定されているオプションが/etc/make.globalsのオプションを上書きします。
	</p>
</body>
</section>

<section>
  <title>USE設定</title>
  <body>
  	<p>
	USE設定システムはパッケージ構築時にさまざまな特徴を個々のパッケージに対してグローバルなレベルで有効か無効にする柔軟な方法です。
	これは管理者に、それらのパッケージのコンパイル時にオプションの特徴をどのようにパケージを構築するかのコントロールできるようにします。
	たとえば、オプションのGNOMEサポートによるパッケージは、<i>gnome</i>USE設定を無効にすることによってコンパイル時で使用不能なこの支持物を備えていることができる。<i>gnome</i> USE設定を有効にすることは、これらの同じパッケージにおいてGNOMEサポートを有効にします。
	</p>
	<p>
	パッケージ上のUSE設定の効果はソフトウェア自体とebuildがUSE設定をサポートするパッケージ・オプションの特徴の両方に依存しています。ソフトウェアにオプションの特徴のためのに対するサポートがない場合、それに対するUSE設定には全く効果はありません。
	多くのパッケージ依存もまたソフトウェアによってオプションであるとは考えられず、そして、USE設定はそれらの義務的な依存に効果がありません。特定のパッケージで使用されるUSEキーワードのリストは、どんなebuildファイルにでもおいて<i>DEPEND</i>と<i>RDEPEND</i>の行をチェックすることによって見つかります。
	</p>

	<p>Gentoo Linuxによって使われるUSE設定のリストは<i>/usr/portage/profile/use.desc</i>にあります。各々のUSE設定は、USE設定が有効にするもののダイジェストによる行につきリストされています。
	</p>

	<p>
	Portageは、USE設定が最高4つの異なる場所をチェックすることによって有効か無効にされるかどうか判断します。それが「蓄積」されて、これらのパスは、USE設定を変えます。
	Portageは、各々のパスを通して、前のパスが設定を使用可能または使用不可にしたかどうか記憶しています。変化をセットしているUSEは、各々のパスを抜けるPortageの間、蓄積されます。
	</p>
	<p>
	 パスはUSE設定でチェックされ、Portageがそれをチェックする計算や命令は/etc/make.globalsの中の<i>USE_ORDER</i>によって設定されます。
	パスを無効にする場合は、ユーザは単に<i>USE_ORDER</i>からそれを取り除くだけです。
	</p>
	<p>
	以下は、Portageの初期の構成で<i>USE_ORDER</i>によって定義される順序にリストされる各々のパスの記述です。
	</p>
	
	
	<p><b>Defaults（初期値）</b></p>
	<p>Portage profileは、一組のデフォルトUSEキーワードを定めることができます。 
	これはいかなるPortage profileででもmake.defaultsファイルにおいて設定されます。
	/etc/make.profileは現在使用されるPortage profileへのリンクとして用いられ、
	/etc/make.profile/make.defaultsがデフォルトの設定です。
	将来、profileの変更が変更事項を上書きするかもしれないので、
	このファイルを編集しないことを推奨します。
	</p>
	
	<p><b>Auto（自動）</b></p>
	<p>これらは、Portage profile（/etc/make.profile/use.defaults）で、
	use.defaultsファイルで設定されます。それぞれのエントリは、
	USE設定と対応するパッケージから成ります。USEキーワードのためにリストされるパッケージが現在インストールされるならば、そのUSE設定は有効にされて考慮されます。
	このように、<i>x11-base/xfree</i>をインストールして、後のパスではっきりとXUSE設定を無効にしなかったならば、そのパッケージがインストールされる間、
	たとえば、Xキーワードはグローバルに使用可能にされます。
	</p>

	<p><b>Conf（コンフ）</b></p>
	<p><i>USE</i>構成オプションが/etc/make.confで設定されているなら、定められる<i>USE</i>設定は含まれます。<i>USE</i>設定がmake.confにないならば、/etc/make.globalsはチェックされます。この入力は、以下のようになります。：
	</p>

	<pre>
USE="slang readline gpm berkdb gdbm tcpd pam libwww ssl gb tk
     lm_sensors lvm ldap tex bonobo sdl gtk xfs evo pda ldap
     mmx mitshm perl python guile ruby postgres dvd 3dnow tcl
     lcms gif sdl vorbis ogg oss libg++ directfb decss snmp
     gnome X opengl mozilla pdflib gpg -nls gd xface jpilot
     -kde -qt -esd -motif -alsa oggvorbis"
	</pre>

	<p>
	USE設定は、設定名をリストするだけで有効にできます。USE設定は、設定名の前に文字を置くことで無効にできます。たとえば、<i>gnome</i>はGNOMEの中の<i>-motif</i>はmotifを無効にします。
	</p>
	<p>
	/etc/make.confでの<i>USE</i>設定は、きちんと有効と無効のキーワードを置くのに推奨されたパスです。このファイルを、Portageは自動的に上書きしません。
	USEキーワードを有効にするか無効にするかの指定は、前の2つのパスで無効にするか有効にするかを指定したくない場合にもお勧めです。
	</p>
	
	<p><b>Env（環境）</b></p>
	<p>USEキーワード設定は、シェル環境により手動で上書きできます。
	</p>

	<pre>
export USE="-gnome"
emerge net-im/gaim
	</pre>

	<p>これは、一つまたはそれ以上の特定のパッケージをマージするためにUSE設定の特定の設定を使用可能にします。シェル環境でUSE設定後のいかなるemergeの呪文は、そのシェルとUSEがまだ設定されている状態からemergeが実行されるのと同様に効果があります。
	</p>
	
	<note>パッケージをマージするとき、Portageが現在使われるUSE設定の設定を記録する間、
	これらのUSE設定は持続的ではありません。パッケージが再度マージされるか、将来アップグレードされるならば、それは実質的に現在USEキーワードを使用します、そして、USE設定はそれがいつ最初にマージされるかについて設定されていない。</note>
	
  </body>
</section>

<section>
<title>コンパイラオプション</title>
<body>
	<p>パッケージをコンパイルするためにPortageによって使用されるコンパイラ・オプションは、<i>CHOST</i>、<i>CFLAGS</i>と<i>CXXFLAGS</i>の各行を編集することにより/etc/make.confで設定できます。<i>CHOST</i>設定はユーザがどのプラットホームを編集しているかについて指定します、そして、それぞれCとC++をコンパイルする間、FLAGSとCXXFLAGS設定は使われるコンパイラフラグを指定します。</p>
	<p>
	数セットの初期設定はそれらがどのプラットホームで使われるかコメントで提供されます。 
	これらの提供された初期設定は、安定していて、テストされたと考えられます。
	それらを修正することは、コンパイラとコンパイルされたソフトウェアの両方の中でコンパイルエラーとバグを見つけるかもしれません。最終的に動かないシステムで終わらないように、デフォルト設定の修正を行うのは慎重にしてください。</p>
	<p>
	マルチプロセッサ・システムをもつユーザーは、/etc/make.globalsで見つけられる<i>MAKEOPTS</i>オプションを修正することで得をするかもしれません。
	このオプションは、複数のgcc実装を可能にするためにパッケージコンパイルの間、
	<i>make</i>コマンドに渡されます。
	</p>
	
</body>
</section>

<section>
<title>ディレクトリパス</title>
<body>
	<p>Portageはビルドパッケージに使用するディレクトリと、
	さまざまなファイルを保存しておくディレクトリの設定をすることを有効にします。
	多くのユーザーはこれらの位置を変更する必要はありません。
	オプションは以下のようにセットできます。：</p>

	<ul>
	<li><i>PORTDIR</i> - Portageツリーのディレクトリ</li>
	<li><i>DISTDIR</i> - ダウンロードしたアーカイブのローカルキャッシュ</li>
	<li><i>PKGDIR</i> - ローカルで生成したtbz2パッケージのディレクトリ</li>
	<li><i>RPMDIR</i> - ローカルで生成したrpmパッケージのディレクトリ</li>
	<li><i>CURRENTFILE</i> - ???</li>
	<li><i>PORTAGE_TMPDIR</i> - パッケージのコンパイルのために使用する
	テンポラリなディレクトリ</li>
	<li><i>BUILD_PREFIX</i> - PORTAGE_TMPDIRに関連</li>
	<li><i>PKG_TMPDIR</i> - PKG_TMPDIRに関連</li>
	</ul>
</body>
</section>
	

<section>
<title>設定ファイルの保護</title>
<body>
	<p>Portageは特定のディレクトリのすべての設定ファイルの保護が可能です。
	Portageは保護されたディレクトリのファイルの上書きをしません。
	もしも既にインストールされているパッケージのインストールをしようとするならば、
	それは<i>._cfg0000_name</i>というようなファイル名にリネームします。
	これはユーザーが後から新しいファイルを探すことと、
	手動で二つのファイルの違いをマージすることを可能にするために動作します。
	</p>
	<p>
	保護されたディレクトリは/etc/make.confもしくは/etc/make.globalsの中に
	<i>CONFIG_PROTECT</i>として設定できます。保護されたディレクトリ中の特定のファイルや、
	サブディレクトリは<i>CONFIG_PROTECT_MASK</i>で設定することにより保護を
	無効にすることもできます。
	</p>
	<p>
	以下はそのサンプルです、そのままコピーして使用しないでください。：
	</p>

<pre>
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/2/share/config"
CONFIG_PROTECT_MASK="/etc/gconf /etc/init.d /etc/pam.d"
</pre>

	<p>ユーザーは、どのようにファイル保護設定が機能するか、
	次のようにタイプしてその情報を表示することができます。：
	</p>

<pre>
emerge --help config
</pre>

</body>
</section>

<section>
<title>特徴</title>
<body>
	<p>Portageは、開発者がPortageのパッケージのマージのいろいろな段階の間に動作して、
	それ自体を削除をする方法を管理する多くの進化したオプションを提供します。
	これらのオプションは、開発者にだけ重要でなければならず、
	ユーザーに問題を引き起こすかもしれません。
	</p>
	<p>
	有効にする特徴のリストは、/etc/make.confか/etc/make.globalsで
	<i>FEATURES</i>によって設定できます。
	以下は、利用できるオプションのリストです。：</p>
	<p>
	<ul>
	<li><i>digest</i> : 自動的に新しいebuildのダイジェストを作成する。</li>
	<li><i>cvs</i> : 自動的に新しいダイジェストをcvsにコミットする。</li>
	<li><i>sandbox</i> : パスに対し"サンドボックス"を前もって保護することを有効にする。</li>
	<li><i>noclean</i> : Portage動作の後、決してcleanしない。</li>
	<li><i>noauto</i> : 自動的に先のebuildステップを実行しない。</li>
	</ul>
	</p>
</body>
</section>

<section>
<title>PortageSYNC設定</title>
<body>
	<p>Portageは、rsyncまたは匿名のCVSの2つの異なる方法を使用して、
	Portage ツリーを更新できます。Portageが/etc/make.confで<i>SYNC</i>設定を
	通してどの方法を使用しなければならないかについて設定できます。
	</p>

	<p><b>RSYNC</b></p>

	<p>ユーザがユーザ自身のebuildファイルを開発する予定でない限り、
	それが非常にPortageのより少ないものを匿名のCVSをそれから使っている
	我々のサーバーに置いて、ユーザーはrsync方法を使用することをお勧めします。
	このため、rsyncメソッドは、デフォルトでは/etc/make.confで設定されます。
	このメソッドは、以下のようにして設定できます。：
</p>

<pre>
SYNC="rsync://cvs.gentoo.org/gentoo-x86-portage"
</pre>

	<note>rsyncメソッドは、盲目的にPortage ツリーのユーザのローカル・コピーへ、
	どんな修正でも上書きします。ユーザがローカルの修正を保つ必要がある場合、
	ユーザは匿名のCVS方法を使用する必要があります。</note>

	<p><b>匿名 CVS</b></p>

	<p>PortageはローカルPortage ツリーに特別な匿名CVSサーバに対しても同期できます。
	このことは自分たちの修正が公式なツリーと同期され上書きされるのを
	望まない開発者に役立ちます。このメソッドは次のコマンドでセット可能です。：</p>

<pre>
SYNC="cvs://:pserver:anonymous@gentoo.org:/home/anoncvs"
</pre>

	<note>匿名CVSは、サーバーとクライアントで遅くて強い資源です。
	我々は、ユーザがユーザのローカルPortageツリーに修正を加えてないならば、
	ユーザがどうかrsyncメソッドを使用することを尋ねます。</note>

	<p>匿名CVSの使用開始前にツリーのローカル・コピーと公式なPortageツリーを同期できます。
	cvsツールを使って次のようにツリーのコピーを"チェックアウト"しなければなりません。：
	</p>
<pre>
# backup old portage directory
cd /usr
mv portage portage.old

# "checkout" the tree
cvs -d :pserver:anonymous@gentoo.org:/home/anoncvs login
# hit enter when prompted for password
cvs -d :pserver:anonymous@gentoo.org:/home/anoncvs co gentoo-x86

# move the new tree into place
mv gentoo-x86 portage
</pre>

	<p><b>開発者 CVS</b></p>

	<p>CVSツリーにフルアクセスする開発者はまた、RSHまたはSSHを使用してアクセス可能であるCVSリポジトリに対してローカルツリーを<i>emerge</i> sync可能です。
	</p>
	<p>
	個人のアカウントを使用しCVSツリーをチェックアウトし、それを/usr/portageに移動し、そして以下の<i>SYNC</i>オプションを使用します。：
	</p>
	
<pre>
SYNC="cvs://youraccount@cvs.gentoo.org:/home/cvsroot"
</pre>

</body>
</section>

<section>
<title>Mirrors</title>
<body>
	<p>Gentooプロジェクトは、Portageツリーの中でebuildsで関連付けられた全てのアーカイブの保管ファイルのローカルミラーを保存しています。
	頻繁にアップされるソースtarballsやその他のものは、回線の遅いサーバー上に頻繁にダウンロードされ保存されるでしょう。 また、アップロードする開発者は、
	新しいバージョンが公開されたらＦＴＰサイトからソフトウェアのさらに古いバージョンを削除するかもしれません。多くの人々にGentooディストリビューションを容易に使用してもらうため（そして、ソースのアップロードによるサイトの回線使用率を減らすため）、
	我々はこれらのファイルをミラーしています。これは、多くの物理的に近いミラーサイトのひとつからこれらのアーカイブのダウンロードさせることでさらに高速に、そして信頼性を高めることになります。</p>
	<p>
	パッケージをマージしようとするときはいつでも、Portageは必要とされたアーカイブのために最初に我々のミラーサイトをチェックします。ミラーサイトには必要とされたファイルがないならば、
	PortageはパッケージebuildでHTTPまたは指定されたFTPサーバからパッケージのダウンロードを試みます。</p>
	<p>
	Portageが使うミラーサイトは、/etc/make.confで<i>GENTOO_MIRRORS</i>によって指定できます。
	以下は、現在のデフォルトの設定です。：
	</p>
<pre>
GENTOO_MIRRORS="http://www.ibiblio.org/gentoo"
</pre>
	<p>さらに近くの Gentooミラーサイトを探す為には、
	Gentooウェブサイトをチェックするか親しい国内のメーリングリストで聞いてみてください。</p>
</body>
</section>

<section>
<title>プログラムのダウンロード</title>
<body>
	<p>Portageが保管ファイルをダウンロードするのに使用するプログラムは、
	<i>FETCHCOMMAND</i>と<i>RESUMECOMMAND</i>設定をセットすることによって指定できます。いくつかの例は、/etc/make.confと/etc/make.globalsで確認できます。
	Portageは多くのユーザーの必要性に応えるのにデフォルト設定では<i>wget</i>を使用します。
	</p>

	<note>Portageは、HTTP_PROXYとFTP_PROXY環境変数を通して、プログラムをダウンロードすることにHTTPとFTPPROXYに情報を渡します。</note>
</body>
</section>

<section>
<title>プロキシ</title>
<body>
	<p>ファイルをダウンロードするとき、PortageはHTTPとFTPPROXYを使うように指定できます。PROXYは、/etc/make.confか/etc/make.globalsで<i>HTTP_PROXY</i>と<i>FTP_PROXY</i>を設定することによって指定できます。
	HTTPとFTPが同じPROXYで利用できるならば、同じように<i>PROXY</i>を設定できます。</p>
	
	<p>以下はサンプルです。:</p>

<pre>
HTTP_PROXY="http://192.168.1.1:8080"
FTP_PROXY="http://192.168.1.1:8080"

or

PROXY="http://192.168.1.1:8080"
</pre>

	<p>Portageは、また、RSYNCの用途に、HTTPROXYを使うように設定できます。
	RSYNCPROXYの使用は、<i>/etc/make.conf</i>でRSYNC_PROXYオプションを設定することによってまたは環境変数としてそれを設定することによって構成できます。</p>
	<p>
	以下はその例です:
	</p>

<pre>
RSYNC_PROXY="192.168.1.1:8080"
</pre>

	<note>WAN側からFirewallによりHTTP proxyを利用したrsyncが不可能であれば、
	スナップショットtarballを使用してPortageツリーを更新できます。
	スナップショットのtarballは<uri>http://www.ibiblio.org/gentoo/snapshots/</uri>から利用できます。
	</note>

</body>
</section>

<section>
<title>その他諸々、オプション等</title>
<body>
	<p>次はユーザには使われることはめったに無いオプションです:</p>

	<ul>
	<li><i>NOCOLOR</i> : ユーザはemergeツールからの画面への出力で色の使用を無効にできます。
	</li>
	<li><i>CLEAN_DELAY</i> : ユーザはPortageによりキャンセルできる秒数を設定し、
	パッケージの削除を延期できます。これは、待つ秒数を指定して、
	それを「0」にセットすることによって無効できます。</li>
	</ul>

</body>
</section>

</chapter>

<chapter>
<title>パッケージ管理</title>

<section>
<title>Portageツリーの更新</title>
<body>
	<p>/usr/portageにあるPortageツリーは、さまざまなパッケージのビルド手順（<i>ebuilds</i>と呼ばれる)のライブラリを含んでいます。ツリーはまた、システムを最新にしておくために不可欠であるprofileとpackage.mask情報を含んでいます。
	それは、パッケージとバグ・フィックスの最も新しいバージョンを持つためにこのツリーを更新しておくために重要で公式のPortageツリーと同期して利用できます。
	以下のようにタイプすることによってPortageツリーを更新することができます。:
	</p>
<pre>
emerge rsync
</pre>
	<p>emergeがローカルPortageツリーを更新するために使う方法に変更を加えることができます。
	詳細は<i>Portage設定</i>の章において<i>Portage SYNC設定</i>を見てください。
	</p>
</body>
</section>

<section>
<title>Merging Packages</title>
<body>
	<p>Portageを通してパッケージのコンパイルとインストールを行うことは
	<i>マージング</i>と言います。Portageはパッケージをコンパイルし、
	一時的にそれらをインストールされたファイルを保存する"image"ディレクトリにインストールします。これらのファイルはその後、imageディレクトリから移動され、本当のファイルシステムにマージされます。
	</p>
	<p>
	<i>emerge</i>コマンドはPortageシステムでフロントエンドのコマンドとして動作します。
	パッケージのインストールや削除はそのいろいろなコマンド・ライン引数を用いて操作できます。
	</p>
	<p>最新のマスクされてないバージョンのパッケージをインストールするためには単にパッケージの名前を指定し、次のようにタイプします。:
	</p>
<pre>
emerge galeon
</pre>
	<p>
	このコマンドは、いくつかの必要な依存性（どんなUSE設定も考慮に入れる）をコンパイル、
	インストールし、それから最新のマスクされてないバージョンのgaleonをコンパイル、
	インストールします。Galeonはまたカテゴリーと全部の名前を使用することもできます：
	<i>net-www/galeon</i> 
	</p>
	<p>
	この<i>emerge</i>コマンドはまた、実際のebuildファイルを参照します。
	これは旧バージョンのパッケージをマージすることと、
	サードパーティーによるebuildベースのパッケージをマージすることをユーザーに許可します。
	以下はそのサンプルです。：
	</p>
<pre>
emerge /usr/portage/net-www/galeon/galeon-1.2.0-r3.ebuild
</pre>
	<p>
	さらに、マージされるパッケージ名またはebuildファイルを指定する時、
	<i>emerge</i>は非常に便利ないくつかのコマンドライン引数をサポートします。
	これらの引数の <i>--pretend</i> はおそらくもっとも便利なものです。
	この引数が使われるとき、実際にインストールはされません。
	その代わりに、Portageはコマンドを実行する間、インストール対象か、
	更新するパッケージのリストを表示します。以下は、kdevelopパッケージの最新版のインストールの時、何のパッケージがマージされるかのリストの例です。：
	</p>

<pre>
root@kodiak blocke # emerge --pretend kdevelop             

These are the packages that I would merge, in order.

Calculating dependencies ...done!
[ebuild  N   ] kde-base/kdelibs-2.2.2-r4 to /
[ebuild  N   ] dev-util/kdbg-1.2.2 to /
[ebuild   U  ] app-text/psutils-1.17 to /
[ebuild   U  ] app-text/a2ps-4.13b-r3 to /
[ebuild   U  ] app-text/jadetex-2.20 to /
[ebuild  N   ] app-text/sgmltools-lite-3.0.3-r2 to /
[ebuild  N   ] kde-base/kdoc-2.2.2-r1 to /
[ebuild  N   ] net-www/htdig-3.1.5-r2 to /
[ebuild  N   ] app-text/enscript-1.6.3-r1 to /
[ebuild  N   ] kde-base/kdebase-2.2.2-r2 to /
[ebuild  N   ] app-doc/qt-docs-2.3.1 to /
[ebuild  N   ] dev-util/kdevelop-2.0.2 to /
</pre>
	<p>上記のリストにおいて、<i>N</i>というマークがあるパッケージは、
	まだインストールされていないパッケージで、インストールの際はインストールされます。
	<i>U</i>というマークがあるパッケージはパッケージの以前のバージョンがすでにインストールされたことを示し、そして、インストールの際はパッケージをアップグレードします。
	</p>
	<p>
	その他に利用可能な引数:
	</p>
	<p>
	<i>--fetchonly</i> : インストールされたパッケージと必要な依存ファイルをコンパイルするのに必要なアーカイブをダウンロードする。
	</p>
	<p>
	<i>--emptytree</i> : このオプションはPortageにこのパッケージの依存性は無いか、
	既にインストール済みであるように見せかける。これは<i>--pretend</i>オプションと共にどんな特別なパッケージの完全な依存性のツリーを表示するのに役立ちます。
	glibcを除くすべての依存性が表示されます。
	</p>
	<p><i>--nodeps</i> : Portageは指定のパッケージのみのmergeを試み、どんな依存性をも無視します。もし先に該当する依存ファイルをインストールしてない場合、コンパイルに失敗するかもしれません。
	</p>
	<p><i>--onlydeps</i> : 指定されたパッケージの依存するファイルのみmergeされます。
	指定したパッケージはmergeされません。
        </p>
	<p><i>--noreplace</i> :  既にインストールされている場合は指定したパッケージのmergeをスキップします。
	</p>
	<p><i>--usepkg</i> : I指定したパッケージのコンパイルをする代わりに、Portageは指定された場所から既にコンパイルされたtbz2の形式のパッケージの使用を試みます。
	その場所は<i>PKGDIR</i>で指定されシェル環境で変更できます。
	</p>
	<p><i>--debug</i> : ebuild環境は非常により話言葉に近くなるようになります。
	これはbashスクリプトベースのebuildファイルでエラーと格闘する開発者に役立ちます。
	</p>
	<p><i>--autoclean</i> : <i>emerge</i>はパッケージのコンパイルが始まる前に一時的に作成したディレクトリ、強制的に指定したパッケージをクリーンにします。
	Portageはこの動作を初期状態で行うので、このオプションは
	初期状態で無効に設定している開発者にとって役立ちます。
	</p>
	<p><i>--verbose</i> : <i>emerge</i>を冗長モードで動作させます。
	現在、これはGNU infoのエラーのみ引き起こすものが表示されます。
	これらのエラーはユーザーにより安全に無視できます。
	</p>
</body>
</section>

<section>
<title>パッケージの削除</title>
<body>
	<p>"unmerging"の行為は、ファイルシステムからインストールされたパッケージと関連するファイルを削除することです。それがremergedされるまで、
	パッケージの中のソフトウェアがシステムから取り除かれて、
	もはや使われることはありません。
	</p>
	<p>パッケージは<i>emerge</i>コマンドと<i>unmerge</i>引数に削除対象のパッケージ名を続けて指定することで削除されます。 以下の例は、
	<i>ltrace</i>の全てのインストールされたバージョンがまとめて削除されます。：
	</p>

<pre>
emerge unmerge ltrace

or

emerge unmerge dev-util/ltrace
</pre>
	<p>Portageはまたunmergeするパッケージのバージョンを指定することも可能です。
	その範囲は、<i>=</i> (正確なバージョン)、<i>&lt;</i> (より小さい)、<i>&gt;</i>
	(より大きい)、<i>&lt;=</i> (より小さいか同じ)、そして<i>&gt;=</i>(より大きいか同じ)、
	の使用によって指定します。以下の例は0.3.15と同じか、それより古いバージョンのすべてのltraceをunmergeします。
	</p>

<pre>
emerge unmerge \&lt;=dev-utils/ltrace-0.3.15
</pre>

	<p>パッケージの範囲を指定するとき、<i>&gt;</i>と<i>&lt;の文字</i>はシェルでは解釈しないために、エスケープすることが重要です。
	また、例に示すようにパッケージのカテゴリー名を指定することも必要です。
	パッケージの範囲を指定する方法の、その他の例は<i>emerge --help</i>のコマンドで知ることができます。
	</p>

	<warn>パッケージのUnmergingは危険です。ユーザがあらゆるコアパッケージを削除したならばシステムは機能停止するかもしれず、また様々なライブラリの削除もソフトウェアを機能停止にするかもしれません。Portageはコアパッケージや、
	他のパッケージのための依存性を削除することに対し警告しません。
	</warn>

	<p>もしも実際にemergeプログラムによってインストールされたパッケージを削除する場合は、
	どのパッケージが削除されるか正確に表示され、ユーザーには指定された何秒間かキャンセルする余裕があります。この待機中にControl-Cを押すことでユーザは削除が開始される前にキャンセルできます。
	</p>
	<p>
	一旦削除が開始したら、パッケージに属するファイル名の長いリストが表示されます。
	これらのファイル名のうちいくつかはファイル名の左にフラグが表示されます。
	フラグは<i>!mtime</i>、<i>!empty</i>、および特定の理由のある<i>cfgpro</i> 、
	なぜ、パッケージは削除されたときに、あるファイルが削除されなかったのか。
	ファイルシステムから正しく削除されたファイルはこれらの３つのフラグは表示されません。 
	</p>
	<p>
	<i>!mtime</i>のフラグは指定したバージョンのパッケージのインストール後に修正されたファイルを意味します。これは誰かがこのファイルをインストール後に編集したか、
	後に他のパッケージを上書きしたかを意味します。これは古いインストールされたバージョンに必要なファイルの削除を恐れることなくパッケージを新しいバージョンに更新することができます。
	</p>
	<p>
	<i>!empty</i>フラグはPortageが空でないディレクトリであるために削除することを拒否する意味します。(複数のパッケージは頻繁に同じディレクトリに対する所有権を要求します)。
	設定ファイルの保護は<i>cfgpro</i>フラグを見たときキックします。
	これは新しいインストールされたパッケージがこの特別な設定ファイルの所有権に要求することと、Portageがそれを削除するのを拒否することを意味します。
	</p>
	<warn>ファイルはインストールされた最後のパッケージによって所有されていると解釈されます。これはインストールの順序に依存していて、
	インストールされたパッケージの実際のバージョン番号かリビジョンの番号で独立しています。
	最新のインストールされたパッケージを削除することは、たとえ過去に同じファイルの古いバージョンのパッケージをインストールした場合でも、あるファイルが常にそのファイルを削除することを要求します。(ユーザが手動でそのファイルを修正しなかったと仮定します)。
	</warn>
	
</body>
</section>

<section>
<title>システム更新</title>
<body>
	<p>Portageは自動的にひとつのコマンドでインストールされたパッケージを更新できます。
	システム更新の特徴はユーザーに、いかなるGentoo Linuxシステムの操作に対して重要なものだとして、
	Gentooのコア開発者により推奨されるバージョンへのコアパッケージを更新可能なことです。
	システム更新は必要でないパッケージの更新はせず、オペレーティングとシステムの維持に不可欠であると
	Portage profileに定義されたパッケージのみ更新します。
	</p>
	<p>
	システム更新を実行するためには、以下のようにタイプしてください。：
	</p>
<pre>
emerge --update system
</pre>
	<p>Portageは、インストールされたパッケージやそのバージョンが、現在のPortage profileによって推薦される設定に従いコンパイルし、更新をインストールする。ユーザーはemerge --update systemの間に何がインストールされ、更新されるのかのリストを得るために、上記の例に対しても<i>--pretend</i>引数を使うことが可能です。
	</p>
	<note>みなさんはインストール作業でベース（または"コア"）パッケージをインストールするために<i>emerge system</i>を最初に実行したのに気がつくでしょう。<i>emerge --update system</i>はそれらのベースパッケージを最新の推奨されるバージョンに更新します。
	</note>
</body>
</section>

<section>
<title>World Update（全パッケージ更新）</title>
<body>
	<p>Portageはまた自動的に選択された必要不可欠ではないパッケージも
	ひとつのコマンドで更新できます。Portageは、複数のバージョンのパッケージのコンフリクトが起きるかもしれないことに対し、安全にシステムを更新し構築するある程度の知性を持っています。</p>

	<p>Portageの全パッケージ更新の特徴はシステムのprofileをチェックしていることです。
	ブロックされたパッケージのリスト(<i>package.mask</i>)と、world profileとパッケージの依存性(バージョンの範囲を含めた) がどのパッケージの更新が必要か決定するときworld profileに表示されます。
	パッケージはさらに新しいバージョンが存在しパッケージが world profileに表示された場合か、またはworld profileのパッケージの依存性があった場合だけ更新されます。 
	そしてパッケージまたは指定したバージョンのパッケージはsystem profileまたは<i>package.mask</i>によってブロックされません。
	</p>

	<p>どのパッケージを更新するか考慮するとき、Portageはworld profileに記述された
	最新のブロックされてない利用可能なバージョンのすべてのパッケージを更新することを試みます。
	Portageはまた、それぞれのパッケージのworld profileに記述された依存性を考慮し、
	さらに新しいバージョンが利用可能ならば更新することを試み、指定されるバージョンの範囲を照合させ、system profileまたは<i>package.mask</i>のどちらもブロックしません。
	前の章の中で言及されるように、それはまた<i>SLOTS</i>を考慮に入れます。
	</p>

	<p>他のディストリビューションや、Portageに似たパッケージングの手順に詳しいユーザーは、
	どうしてPortageは簡単に単なるバージョンナンバーに基いてパッケージの更新を隠さないのか、
	混乱するかもしれない。(Gentoo1.0以前ではそうであったように)。
	GentooのPortageツリーに含まれている多くのパッケージは多くのバージョンが利用できます。
	さらに古いまたはさらに新しいバージョンのパッケージはそれに依存したソフトウェアは
	互換性がないかもしれません。隠れたライブラリとツールを他のパッケージの必要性を考慮に
	入れることなく更新することは、すぐに多くの厳しい問題にぶつかるでしょう。
	Portageはこれを避けるために、更新と個々のパッケージのebuildsの中で公言された必要性に基いた考慮へ、
	すべてのパッケージの必要性を取るとき注意します。
	</p>
	
	<p>
	Portageの全パッケージ更新の心臓部はworld profileにあります。system profileに似ず、 
	大抵開発者に定義されてユーザーは決して触れることが無い、全パッケージ更新のprofileは間接的に一時にわたってユーザにより実行された動作によって生成されます。全パッケージ更新は"favorites list"
	のような多くを操作します。emergeコマンドを通してユーザーにより手動でインストールされたPackageは<i>/var/cache/edb/world</i>にあるworldファイルに記録されます。
	Portageは、パッケージをインストールするように作業をしたので、
	それを最新にしておくことに対するいくらかの関心を持たなければならないと考えます。 
	</p>
	<p>
	<i>world</i>ファイルは一行につきカテゴリーとひとつのパッケージ名から成り、以下のように見えます。：
	</p>
<pre>
net-im/gaim
net-www/skipstone
net-www/galeon
app-editors/vim
app-text/ispell
net-mail/evolution
dev-util/ltrace
sys-apps/xfsprogs
=net-www/mozilla-0.9.8-r3
sys-apps/attr
sys-apps/dmapi
sys-kernel/linux-sources
sys-apps/acl
app-office/gnucash
app-cdr/xcdroast
</pre>
	<p>
	ユーザーが手動で特定のパッケージをマージしたとき、このサンプルファイルの中のエントリのほぼ全てはPortageによって自動的に加えられました。
	新しいバージョンが利用できるならば、これらのパッケージはアップグレードされます。
	</p>
	
	<note>時間を節約し、確実にお気に入りのパッケージを更新される状態にするには、手動で
	<i>world</i>ファイルを編集し、それらのパッケージのためにエントリを加えなさい。
	Portageの古いバージョンから更新しているユーザーは、このファイルに慣れる必要があるかもしれない。
	GentooとPortageの最近のインストールは、かなり慣れたworld profileをインストールの間、
	作っておかなければならない。</note>
	
	<p>注意する興味深いエントリは、mozillaパッケージ（<i>=net-www/mozilla 0.9.8-r3</i>）
	のためのエントリです。 このエントリは、特定のバージョンに固定するためにユーザーによって
	手動で変更されました。パッケージを更新するとき、パッケージ範囲
	（このマニュアルの<i>Unmerge Packages</i>セクションで議論されるように）はPortageに
	特定のバージョン範囲を考慮するだけのことを強制的に使用できます。このエントリは
	mozilla-0.9.8-r3が唯一の利用できるバージョンであると考えることにPortageに特定し、そして、それは決して全パッケージ更新の間、パッケージを更新しません。
	</p>
	
	<p>下記のようにタイプすると全パッケージ更新が実行されます。:</p>
<pre>
emerge --update world
</pre>
	<p>Portageは、<i>world</i>ファイルにおいて記述される全てのパッケージの
	更新を試み、必要ならばどんな依存でも更新する。アップグレードされている
	パッケージの必要を満たす依存性は、利用可能な最新バージョンに更新される。
	<i>world</i>にリストされなくて、
	前記のパッケージの依存でないパッケージは、更新されません。 
	</p>

	<warn>Portageは、設定ファイル保護機能によって保護されているディレクトリでは
	ファイルに上書きしません。ユーザは手動で現在の構成ファイルと
	新しいバージョンPortageはユーザのために保存したファイルの違いをマージする必要があります。
	インストールされたソフトウェアの構成ファイルを更新しないならば、ソフトウェアは
	機能停止するかもしれない。<i>Portageの設定</i>の章で<i>設定ファイル保護</i>を見るか、
	<i>emerge --help config</i>をタイプして、多くの情報を見なさい。</warn> 

	<p>全パッケージ更新中にどのパッケージが更新され、インストールされるかのリストを見るためには、
	この章の前のセクションで説明した<i>--pretend</i> 引数を使うことができます。
	</p>

	<note>全パッケージ更新はまた、さらに自動的にシステム最新版を自動的に実行します。
	コアパッケージは、現在のPortage　profileがそれを常に無視するとともに<i>world</i>
	ファイル方法を使用して特定することができません。</note>

	<p>
	全パッケージ更新が効く方法の興味深い副作用は、システム上で全てのインストールされた
	ソフトウェアを再コンパイルすることを望んでいるユーザーによって利用できます。
	全パッケージ更新は<i>world</i>ファイルとそれらの依存性が記述された全てのパッケージを
	更新しようと試みるので、<i>--emptytree</i>の引数を使うことは、glibcを除いて
	これらのパッケージとあらゆる依存ファイルの再コンパイルの強制する方法である。
	これは、それらのコンパイラ・オプションまたはUSEキーワード設定を変えて、
	これらの修正にそれらがあらゆるパッケージを手動でremergingすることなく使う全ての
	ソフトウェアに使われて欲しいことを望んでいるユーザーに役立ちます。
	まず全ての一般に使用されるアプリケーションで、<i>world</i>ファイルに慣れなさい、
	そして、以下のようにタイプしなさい：
	</p>
<pre>
emerge --update world --emptytree
</pre>
	<p>
	このコマンドに<i> --pretend</i> 引数を付け加えることで
	再コンパイルされたパッケージの実行結果のリストを得ることができます。
	</p>
	
</body>
</section>

<section>
<title>システムの清掃</title>
<body>
	<p>Portageは、互いのトップの上に同じバージョンの複数のバージョンを
	インストールする機能があります。相当な数のパッケージが、この機能性
	（さらに古いアプリケーションとしての下位互換性のために
	もう一つのパッケージの新しいバージョンと相容れないかもしれなかった）
	を利用するGentooのPortageツリーにあります。
	</p>
	<p>大抵、パッケージの新しいバージョンがインストールされる時、ほぼ以前のパッケージ
	は上書きされ、そして、残るのは全てシステムの動作に重要でない、
	いくつかのドキュメンテーション・ファイル等のファイルです。
	時間の経過と共に、この「cruft」は、蓄積されて、貴重なディスク領域を圧迫していきます。
	</p>
	<p>これを処理するために、Portageはユーザーのシステムから
	以前のバージョンのパッケージを取り除く簡単な方法を提供します。 
	この機能は、emergeに<i>clean</i>のオプションを記述します。
	つまり、以下のようにタイプして使用します。：
	</p>
<pre>
emerge clean
</pre>
	<p>次に<i>emerge</i>は削除されるパッケージのリビジョンとバージョン、
	残されるバージョンを表示し、そして、ユーザにControl-Cを押すことによって
	コマンドからキャンセルする時間が与えられます。典型的システム上で
	それが削除されるか保存されるかのファイルの長いリストを表示して、
	コマンドの動作が始まります。
	</p>

	<p>特定されない限り、Portageはきれいな行動が<i>world</i>
	（全てのインストールされたパッケージ）のために
	実行されることになっていると仮定します。オプション（例えば<i>world</i>、<i>system</i>、
	パッケージ名のリスト）を用いて、きれいな行動の範囲を狭くすることができ、
	そして、この章のunmergeセクションで名前があがるように、パッケージ版は変動します。
	</p>

	<p>バージョンがどのパッケージでなければならないか考えることは移動したとき、
	Portageシステムはいろいろなprofile、他のインストールされたパッケージの必要と
	パッケージSLOTを考慮します。依存性が全てのパッケージのために正しく定められるならば、
	cleanは問題なく古いパッケージ・システムを取り除くか、
	少しの機能性も取り除いてはならないか、システムが機能するのを防ぎます。
	</p>	
</body>
</section>

<section>
<title>パッケージの除去</title>
<body>
	<p>
	Portageはまた、パッケージ<i>prune</i>の機能があります。
	<i>prune</i>の動作はcleanの安全でない形です。<i>prune</i>は、
	最後のインストールされたバージョンを除いて全てのパッケージの全てのバージョンを削除します。
	<i>prune</i>は<i>clean</i>が実行するチェックの多くを実行せず、
	そしてユーザのシステムからの本質的な依存性を削除することができます。
	このオプションのユーザが、それらのシステムを簡単に破壊することが可能なため、
	特定の専門的な状況以外の場合でない限りその使用は推奨しません。
	</p>

	<p><i>prune</i>の機能は、<i>clean</i>の機能としてのオプションと同じリストを受けて、
	以下のようにタイプします。：
	</p>
<pre>
emerge prune
</pre>
</body>
</section>


<section>
<title>Portageツリーの検索</title>
<body>
	<p>GentooLinuxディストリビューションの心臓部を形成するPortageツリーは、巨大です。 
	<i>emerge</i>コマンドは引数に含まれる正規表現の形で検索文字列を受け入れる
	機能があります。正規表現は非常に扱いにくい野獣ですが、ユーザが充分に正規表現を
	使うことに興味があるならば大変お薦めです。
	</p>
	<p>
	多くの単純な検索は正確に表現をせずにすみます。以下は"gcc"という名前か、
	もしくは"gcc"は名前の一部という両方の簡単なパッケージの検索の例です。：
	</p>
<pre>
emerge search gcc
</pre>
	<p>
	パッケージの名称、最新の利用可能バージョン、インストールされている最新版、
	そのホームページ、ソフトウェアの詳細をそれぞれ、マッチするものを検索実行し、
	リスト表示します。
	</p>
</body>
</section>

<section>
<title>ヘルプの取得</title>
<body>
	<p><i>emerge</i>が持つ多くのオプションとその動作のより多くの情報は
	以下のようにタイプすると表示されます。：</p>
<pre>
emerge --help
</pre>
</body>
</section>
	
		

<section>
<title>役立つユーティリティ</title>
<body>
	<p>Gentooユーザーズによって作成された、利用可能ないくつかのユーティリティが
	管理をさらに簡単にしてくれます。これらのユーティリティはGentoo Portageツリーの中の
	<i>app-admin/gentoolkit</i>の中にあります。 
	</p>
	<p>
	<ul>
	<li><i>etc-update</i> : vimを使用して/etcファイルのマージングを支援するシェルスクリプト 
                (正しく使わないと危険)</li>
	<li><i>qpkg</i> : パッケージ・データベース検索ツール</li>
	<li><i>epm</i> : syntaxのようなRPMと別のパッケージ・データベース検索ツール</li>
	</ul>
	</p>
</body>
</section>


</chapter>

</guide>

