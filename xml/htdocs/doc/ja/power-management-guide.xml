<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ja/power-management-guide.xml,v 1.1 2005/01/13 11:52:02 nakano Exp $ -->
<guide link="power-management-guide.xml">
<title>電力管理ガイド</title>

<author title="Author">
  <mail link="fragfred@gmx.de">Dennis Nienh&#252;ser</mail>
</author>
<author title="翻訳">
  <mail link="solidsneak@hyper.cx">小林弘樹</mail>
</author>

<abstract>
電力管理はラップトップのようなモバイルシステムのバッテリー駆動時間を延ばす鍵です。
このガイドではラップトップで電源管理を設定する方法を記述します。
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.17</version>
<date>October 10, 2004</date>

<!-- Original revision: 1.7 -->

<chapter>
<title>初めに</title>

<section>
<title>なぜ電力管理？</title>

<body>

<p>
ここ数年、ラップトップバッテリーの容量と寿命は非常に向上しました。
それにもかかわらず、近代的なプロセッサは、古いものよりはるかに多くのエネルギーを消費します。
そして、それぞれのラップトップ世代はエネルギーに飢えているより多くの装置を取り入れています。
それが電力管理がこれまで以上に重要である理由です。
バッテリー駆動時間を増加させるということは、必ずしも別のバッテリーを買うことを意味するというわけではありません。
賢い電力管理ポリシーを適用すれば多くを達成できます。
</p>

</body>
</section>

<section>
<title>簡単なあらまし</title>
<body>

<p>
このガイドでは<e>ラップトップ</e>の電力管理を説明していると言うことに注意してください。
いくらかの章は<e>サーバ</e>にも適用できるかもしれませんが、その他は適用できず障害を引き起こすことさえもあるでしょう。
もしあなたが何をしているのか本当に知らないのならこのガイドの何もかもをサーバに適用しないでください。
</p>

<p>
このガイドはかなり長いので、ここでは方針を探す手だてとなる短いあらましを説明します。
</p>

<p>
<e>必要条件</e>の章では以下の装置の個々の部分のどれかが働く前に満たされるべきであるいくつかの必要条件に関して話します。
これはユーザが所有するBIOS設定、カーネル構成、およびいくつかの簡素化を含んでいます。
その後の3つの章では、通常ほとんどのエネルギーを消費する装置（プロセッサ、ディスプレイ、ハードディスク）に焦点を合わせます。
それぞれは別々に設定できます。
<e>CPU電力管理</e>では、性能を落とし過ぎることなく、エネルギーの最大値を抑えるためにプロセッサの周波数を調整する方法を示します。
あなたのハードドライブがしばしば不必要に働くのを防ぐ、いくつかの異なったトリックが<e>ディスク電力管理</e>(良い副作用として騒音レベルの減少)で示されます。
<e>その他のデバイスの電力管理</e>では、（かなり実験的な）<e>スリープ状態</e>についての記述がある一方で、デバイスセクションの最後でWireless LANとUSBに関するいくつかの注意点があります。
最後に、<e>トラブルシューティング</e>は一般的な落とし穴を記載します。
</p>

</body>
</section>

<section>
<title>それぞれの部品の電力量</title>
<body>

<figure link="/images/energy-budget.png" short="どの部品がどれくらいエネルギーを消費するか?" caption="それぞれの部品の電力量"/>

<p>
ほとんど全ての部品が異なった状態で動作することができます。いくつか挙げるとするなら、その状態はオフ、スリープ、アイドル、アクティブがあり、それぞれエネルギー消費量が異なります。
大部分はLCDディスプレイ、CPU、チップセット、そしてハードドライブで消費されています。
しばしばこれらはBIOSでOSとは独立した電力管理が有効にできます。しかし、さまざまな状況に合わせたOSでの賢い設定により、より良い性能を達成することができます。
</p>

</body>
</section>
</chapter>

<chapter>
<title>必要条件</title>
<section>
<title>まず何をするべきか</title>
<body>

<p>
個々の装置の電力管理に関する詳細を意識する前に、確かに必要条件が満たされているか確認してください。
BIOS設定を制御した後に、いくつかのカーネルオプションを有効にします。
これらは、要するにACPIと、スリープ状態とCPU周波数調整です。
節電はたいてい性能の損失か待ち時間の増加をもたらすので、バッテリーで作動するときだけ、それらを有効にするべきです。
それには新しいランレベルである<e>battery</e>が役に立ちます。
</p>

</body>
</section>
<section>
<title>BIOS部分</title>
<body>

<p>
まずBIOSの電力管理設定を見てみましょう。
最も良いのはBIOSとOSのポリシーを組み合わせることですが、さしあたってBIOS部分の多くを無効にするのがよいでしょう。
これはあなたのポリシーを妨げないようにするためです。
全てを終えた後にもう一度BIOSの設定を確認することを忘れないでください。
</p>

</body>
</section>
<section>
<title>カーネルの設定</title>
<body>

<p>
カーネルのACPI (高度設定と電力インターフェース)サポートは未だ作業が進行中です。
最近のカーネルを使うことはそれを最大限に活用できることを意味しています。
</p>

<p>
カーネルの設定で、少なくともこれらのオプションを有効にします。
</p>

<pre caption="電力管理の最小カーネル設定(Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    &lt;M&gt;   AC Adapter
    &lt;M&gt;   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
ソフトウェアサスペンド、ディスクサスペンド、スリープ状態(以下を参照)を有効にするかはあなた自身で決めてください。
ASUS、Medion、Toshibaのラップトップを持っているなら適当な部分を有効にしてください。
</p>

<p>
カーネルをコンパイルし、正しいモジュールが起動時に読み込まれるようにし、新しいACPIが有効なカーネルで起動します。
次に<c>emerge sys-apps/acpid</c>を実行してacpiデーモンを入手します。
これはACからバッテリーに切り替えたりふたを閉じたりと言った出来事を知らせる物です。
<e>button</e>モジュールをカーネル内部にコンパイルしなかった場合には、そのモジュールがロードされていることを確認してください。また、acpidを<c>/etc/init.d/acpid start</c>で起動させてください。
<c>rc-update add acpid default</c>を実行して起動時に読み込まれるようにします。
すぐにどのようにして使われるか分かるでしょう。
</p>

<pre caption="acpidのインストール">
# <i>emerge sys-apps/acpid</i>
# <i>modprobe button</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>"battery"ランレベルの作成</title>
<body>

<p>
デフォルトポリシーは電力管理がバッテリーで実行中の時にのみ有効になります。
ACとバッテリーを切り替えるためには、電力管理の全てのスクリプトの起動と停止を受け持つ<e>battery</e>ランレベルを作成します。
</p>

<note>
他のランレベルを持つのは好きでないならこの章を飛ばしても差し支え有りません。
しかし、この章を飛ばすと設定は少し難しくなるでしょう。
次の章では<e>battery</e>ランレベルが存在すると仮定しているからです。
</note>

<pre caption="batteryランレベルの作成">
# <i>cd /etc/runlevels</i>
# <i>cp -a default battery</i>
</pre>

<p>
これでお終いです。
新しいランレベルである<e>battery</e>は<e>default</e>と同じようにすべてを含みますが、未だお互いを自動的に切り替える方法がありません。
それを変更しましょう。
</p>

</body>
</section>
<section>
<title>ACPIイベントに反応する</title>
<body>

<p>
典型的なACPIイベントはふたを閉じたり、電源供給源の変更、そしてスリープボタンを押したと言うことでしょう。
カーネルに認識される各々のacpiイベントは<path>/etc/acpi/default.sh</path>と呼ばれるacpidに取得されます。
これはランレベルの切り替えをサポートする基本的な修正です。
</p>

<pre caption="acpidを用いた、イベント駆動でのランレベル切替え">
#!/bin/sh

set $*

group=${1/\/*/}
action=${1/*\//}

<comment># ACモードで使うランレベル</comment>
RLVL_AC="default"
<comment># バッテリーモードで使うランレベル</comment>
RLVL_BATTERY="battery"

<comment># ACの状態を示すファイル。利用前にファイル名を確認</comment>
AC_STATE="/proc/acpi/ac_adapter/AC/state"
<comment># この文字はACで実行中を表す</comment>
AC_ON="on-line"
<comment># この文字はバッテリーで実行中を表す</comment>
AC_OFF="off-line"

function SwitchRunlevel() {
  if [[ "$(grep ${AC_OFF} ${AC_STATE})" != "" &amp;&amp; "$(cat /var/lib/init.d/softlevel)" != "${RLVL_BATTERY}" ]]
  then
    logger "Switching to ${RLVL_BATTERY} runlevel"
    /sbin/rc ${RLVL_BATTERY}
  elif [[ "$(grep ${AC_ON} ${AC_STATE})" != "" &amp;&amp; "$(cat /var/lib/init.d/softlevel)" != "${RLVL_AC}" ]]
  then
    logger "Switching to ${RLVL_AC} runlevel"
    /sbin/rc ${RLVL_AC}
  fi
}


case "$group" in
  battery)
    case "$action" in
      battery) 
        SwitchRunlevel
        ;;
      *) 
        logger "ACPI group battery / action $action is not defined"
        ;;
    esac
    ;;

  ac_adapter)
    case "$action" in
      ac_adapter)
        SwitchRunlevel
        ;;
      *)
        logger "ACPI group ac_adapter / action $action is not defined"
        ;;
    esac
    ;;
  *)
    logger "ACPI group $group / action $action is not defined"
    ;;
esac
</pre>

<p>
ACプラグを抜き差しして"Switching to AC mode"や"Switching to battery mode"のメッセージが表示されるかsyslogを確認してください。
</p>

<p>
イベントメカニズムの特性のために、ACまたはバッテリーの状態にかかわらず<e>default</e>ランレベルで起動するでしょう。
ブートローダーに<c>softlevel=boot</c>を含む別のエントリーを追加できますが、それを選ぶことを忘れてしまうことがありそうです。
良い方法は起動過程の最後でACPIイベントをだまし、<path>/etc/acpi/default.sh</path>スクリプトにランレベルの変更が必要か決めさせることです。
お気に入りのエディターで<path>/etc/conf.d/local.start</path>を開き、これらの行を追加します。
</p>

<pre caption="local.startを編集し起動時にランレベルを切り替える">
<comment># バッテリーで起動中にacpiイベントをだましランレベルを切り替える</comment>
/etc/acpi/default.sh "battery/battery"
</pre>

<p>
この様に準備したら個々のデバイスの電力管理ポリシーを有効にしていきます。
</p>

</body>
</section>
</chapter>

<chapter>
<title>CPU電力管理</title>
<section>
<title>周波数を手動設定</title>
<body>

<p>
CPU速度と電力の減少には２つの利点があります。
１つは少ないエネルギー消費で、もう一方がシステムが最高速で動作するほど発熱しないと言うことです。
最も大きな欠点はパフォーマンスが明らかに低下することです。
プロセッサ速度の減少はパフォーマンスと引き替えにエネルギー消費を抑えることになります。
</p>

<note>
全てのラップトップが周波数調整をサポートしているわけではありません。
もし確実でないなら、サポートされているかを<e>トラブルシューティング</e>のサポート済みプロセッサリストで確認してください。
</note>

<p>
ではCPU周波数の変更が動作するかを試してみましょう。
カーネルのインターフェースに慣れるために、まずは手動でスピードの調整をしましょう。
CPU速度を別の物に設定するには以下のようにします。
</p>

<pre caption="CPU速度を手動設定">
<comment>(現在の周波数を取得)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>

<comment>(サポートされている周波数の一覧。これは失敗するかもしれない。)</comment>
# <i>cd /sys/devices/system/cpu/cpu0/cpufreq/</i>
# <i>cat scaling_available_frequencies</i>

<comment>(周波数を1 GHz (1000000 KHz)に変更)</comment>
# <i>echo -n userspace > scaling_governor</i>
# <i>echo -n 1000000 > scaling_setspeed</i>

<comment>(周波数の変更を確認)</comment>
# <i>grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
エラーメッセージが表示されたら、このガイドの終わりにある<e>トラブルシューティング</e>を参照してください。
</p>

<p>
<path>scaling_max_freq</path>と<path>scaling_min_freq</path>を書いて周波数の限界値を定めることもできます。
</p>

<note>
いくらかのカーネルでは<path>/proc/cpuinfo</path>の更新に関するバグがあります。
これが変更されてないとしても、必ずしもCPUの周波数が変更されていないことを意味しているわけではありません。
もしこれが起きたなら、<c>emerge x86info</c>を実行し、現在の周波数を<c>x86info -mhz</c>で確認するようにカーネルを更新します。
</note>

</body>
</section>
<section>
<title>自動周波数修正</title>
<body>

<p>
上記はかなり良いですが、日常生活においては行いがたいです。
システムが適当な周波数を自動で設定するようにする方がよいでしょう。
これを行うためのいくつかのユーザースペースプログラムがあります。
以下のテーブルはどれを使うかを決める手助けとなる簡単な概要です。
</p>

<table>
<tr>
  <th>名称</th>
  <th>利点</th>
  <th>欠点</th>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>ディスクスタンバイもサポート</ti>
  <ti></ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreq</uri></ti>
  <ti>洗練されたセットアップが利用可能</ti>
  <ti>セットアップが複雑</ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>
    小さいが強力<br />
    便利なクライアント/サーバインターフェース
  </ti>
  <ti>カーネル2.6シリーズ専用</ti>
</tr>
<tr>
  <ti><uri link="http://www.deater.net/john/powernowd.html">powernowd</uri></ti>
  <ti>SMPをサポート</ti>
  <ti></ti>
</tr>
</table>

<p>
現在の負荷に応じて周波数を調整することは一見簡単に思えますが、それはそのような単純な作業ではありません。
悪いアルゴリズムは、常に二つの周波数を切替え続けることになったり、不必要に高いレベルに周波数を設定したときにはエネルギーの無駄になったります。
</p>

<p>
どれを選ぶべきでしょうか？もし何も考えがなければ、まず<c>speedfreq</c>を試してください。
</p>

<pre caption="speedfreqのインストール">
# <i>emerge speedfreq</i>
# <i>rc-update add speedfreq battery</i>
</pre>

<p>
<c>speedfreq</c>は<path>/etc/conf.d/speedfreq</path>を編集することで設定できます。
例えば、ユーザーがポリシーを変更できるようにしたいなら、<c>SPEEDFREQ_OPTS=""</c>を<c>SPEEDFREQ_OPTS="-u"</c>に修正します。
変更が完了したら、デーモンを起動します。
</p>

<pre caption="speedfreqを起動">
# <i>/etc/init.d/speedfreq start</i>
</pre>

<p>
cpufreqの設定はちょっと複雑です。
</p>

<warn>
上記のプログラムを同時に２つ以上起動しないでください。
常時２つの周波数を切り替えるといった混乱を引き起こします。
speedfreqをインストールしたのなら、今はcpufreqを飛ばしてください。
</warn>

<pre caption="cpufreqdのインストール">
# <i>emerge cpufreqd</i>
# <i>rc-update add cpufreqd battery</i>
</pre>

<p>
<c>cpufreqd</c>はデフォルト設定を<path>/etc/cpufreqd.conf</path>に置きます。
必要に応じて設定を変更します。
以下の例ではデフォルトの物よりも省電力になります。もちろんパフォーマンスはより低下しますが。
</p>

<pre caption="cpufreqd設定ファイルの例">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
<comment># ACPI代替手段(cpufreqd.conf(5)を参照)を有効にするには以下の行のコメントを解除
# acpi_workaround=1</comment>
verbosity=4 <comment>#(最小のロギングにしたい時には5に設定)</comment>

<comment># 完全なパフォーマンス</comment>
[Profile]
name=ac
minfreq=600000
maxfreq=1400000
policy=performance

<comment># 最大省電力</comment>
[Profile]
name=battery
minfreq=600000
maxfreq=900000
policy=powersave

<comment># 一定の周波数</comment>
[Profile]
name=dvd
minfreq=900000
maxfreq=1100000
policy=powersave

<comment># ACで実行中には最高パフォーマンス</comment>
[Rule]
name=ac_on
ac=on
profile=ac

<comment># バッテリー状態が大丈夫ならコンパイルをより高速に</comment>
[Rule]
name=compiling
ac=off
battery_interval=30-100
programs=emerge,make,gcc,cpp
cpu_interval=0-100
profile=ac

<comment># DVD鑑賞中は低いCPU周波数で
# ゲームなどにも利用可能</comment>
[Rule]
name=dvd_watching
ac=off
battery_interval=15-100
programs=xine,mplayer,avidemux,kaffeine,kmplayer
cpu_interval=0-100
profile=dvd

<comment># 上が当てはまらないなら、最大省電力</comment>
[Rule]
name=battery_on
ac=off
battery_interval=0-100
cpu_interval=0-100
profile=battery
</pre>

<p>
<c>cpudyn</c>と<c>powernowd</c>は<c>speedfreq</c>と同じようにインストールされます。
</p>

<p>
確認する最後のことは新しいポリシーが良く動作しているかです。
簡単な方法はラップトップで作業をしている時にCPU速度を監視することです。
</p>

<pre caption="CPU速度を監視">
# <i>watch -n 1 grep "cpu MHz" /proc/cpuinfo</i>
</pre>

<p>
もし<path>/proc/cpuinfo</path>が更新されない(上を参照)なら、以下のようにCPU周波数を監視します。
</p>

<pre caption="CPU速度監視の代替手段">
# <i>watch -n 1 x86info -mhz</i>
</pre>

<p>
設定に応じて、CPU速度は重い読み込み時には増加し、アクティブでなければ減少するはずです。
</p>

</body>
</section>
</chapter>

<chapter>
<title>LCD電力管理</title>
<section>
<title>電力消費 No. 1</title>
<body>

<p>
<uri link="#doc_chap1_fig1">図 1.1</uri>で見たように、LCDディスプレイは電力の大部分(モバイル用でないCPUでは違うかもしれません)を消費します。
したがって必要でないときにディスプレイの電気を切るだけではなく、可能ならばバックライトを減少させることもとても重要になります。
ほとんどのラップトップではバックライトの明るさを調整できます。
</p>

<p>
最初に確認することはディスプレイのスタンバイ/サスペンド/オフのタイミングです。
これはあなたのウィンドウマネージャーと深く関わっているので、自分自身で設定できるように説明していきます。
２つの一般的な方法があります: <c>setterm -blank &lt;number-of-minutesM&gt;</c>、<c>setterm -powersave on</c>、そして<c>setterm -powerdown &lt;number-of-minutesM&gt;</c>でターミナルをオフにできます。
Xorgでは、<path>/etc/X11/xorg.conf</path>を以下のように編集します。
</p>

<pre caption="XorgとXFree86でのLCDサスペンド設定">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># 5分後にスクリーンの表示をなくす (Fake)</comment>
  Option  "StandbyTime"  "10"  <comment># 10分後にスクリーンを切る (DPMS)</comment>
  Option  "SuspendTime"  "20"  <comment># 20分後に完全にサスペンドにする</comment>
  Option  "OffTime"  "30"  <comment># 30分後に電気を切る</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
XFree86と<path>/etc/X11/XF86Config</path>でも同じです。
</p>

<p>
もしかするとより重要なのはバックライトの明るさかもしれません。
ツールから明るさを調整できるのなら、バッテリーモードの時には薄暗くさせる簡単なスクリプトを書いて<e>battery</e>ランレベルに置いてください。
</p>

</body>
</section>
</chapter>

<chapter>
<title>ディスク電力管理</title>
<section>
<title>アイドル時にスリープ</title>
<body>

<p>
必要でない時には、ハードディスクをできるだけすぐにスリープさせるようにしましょう。
これを行うには２つの方法があります。
１つめは<c>cpudyn</c>がディスク電力管理をサポートしていることです。
<path>/etc/conf.d/cpudyn</path>の"Disk Options"セクションをコメント解除します。
１番目のディスクを60秒間アクティブでなければスリープさせるようにするには、以下のように編集します。
</p>

<pre caption="cpudynをディスクのスタンバイに使う">
<comment>################################################
# DISK OPTIONS
# (disabled by default)
################################################

#
# ディスクをスタンバイモードにするまでの時間(秒で)
#
</comment>
TIMEOUT=60
<comment>
#
# 回転を落とすディスクを指定 (コンマで区切る)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
２つめの方法は小さなスクリプトとhdparmを使うことです。
<path>/etc/init.d/pm.hda</path>をこの様に作成します。
</p>

<pre caption="hdparmをディスクのスタンバイに使う">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
オプションは<c>man hdparm</c>を見てください。
スクリプトができたら、batteryランレベルに追加します。
</p>

<pre caption="自動ディスクスタンバイ設定">
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
ハードディスクのスリープ/スピンダウンの設定には注意してください。
小さな値に設定するとドライブをすり減らし、保証をなくすでしょう。
</impo>

</body>
</section>
<section>
<title>アイドルタイムを増やす - laptop-mode</title>
<body>

<p>
最近のカーネル(2.6.6以上、最近の2.4の物もしくはパッチを当てたその他)にはいわゆる<e>laptop-mode</e>が含まれています。
これを有効にすると、呼び出し時や10分後(30秒の代わり)にディスクにダーティーバッファが書かれます。
これはハードディスクがスピンアップに要する時間を最小限にします。
</p>

<p>
<!-- FIXME: bug #45593 -->
laptop-modeを開始したり停止するには、/etc/init.d/laptop-modeというスクリプトを作成します。
<path>/usr/src/linux/Documentation/laptop-mode.txt</path>の中に含まれているスクリプトを使うことができます。
準備が整ったら、それが呼び出されるようにします。
</p>

<pre caption="laptop-modeの自動起動">
# <i>rc-update add laptop-mode battery</i>
</pre>

<warn>
もう一度: ハードディスクのスリープ/スピンダウンの設定には注意してください。
小さな値に設定するとドライブをすり減らし、保証をなくすでしょう。
laptop-mode.txtのドキュメントを読むようにしてください。
バッテリーが電力を使い果たし、データがディスクに書かれる前にlaptop-modeを停止するようにしてください。
さもなければ、少なくとも作業の最後10分を失うことになるでしょう。
</warn>

</body>
</section>
<section>
<title>その他の技</title>
<body>

<p>
できるだけ早くディスクをスリープ状態にすること以外に、ディスクアクセスを最小にするのは良い考えです。
頻繁にディスクに書く処理を見ていきましょう。syslogdは良い候補です。
たぶん完全にそれを止めたいと言うわけではないでしょうが、「不要な」もののログを取らないようにするために設定ファイルを変更することができます。
またその結果、ディスクへのトラフィックを引き起こさなくなります。
cupsは定期的にディスクに書くので、それを停止して、必要な時だけ手動で有効にすることも考慮してください。
</p>

<pre caption="バッテリーモードではcupsを無効に">
# <i>rc-update del cupsd battery</i>
</pre>

<p>
他の方法はバッテリーモードではスワップの利用をやめることです。
swapon/swapoffを切り替える前に、十分なRAMがありスワップがそんなに使われないことを確認してください。
そうしなければ大きな問題が起こるでしょう。
</p>

<p>
laptop-modeを使いたくなければ、あるディレクトリを<e>tmpfs</e>としてマウントすることで、ディスクアクセスを最小にすることができます。
書き込みアクセスはディスクではなくメインメモリに保管され、マウント解除時に失われます。
しばしば<path>/tmp</path>をこの様にマウントするのは有用です。
ディスクまたはRAMにマウントされたか否かに関係なく、再起動時にクリアされるので、特別な注意を払う必要はないです。
十分なRAMが搭載されていて<path>/tmp</path>を異常に消費するプログラム(ダウンロードクライアントや圧縮ユーティリティ)がないようにしてください。
これを有効にするには、カーネルがtmpfsをサポートするようにして<path>/etc/fstab</path>をこの様に編集します。
</p>

<pre caption="/tmpがより揮発性が高くなるように/etc/fstabを編集">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
サイズパラメータに注意してシステムに合うよう変更してください。
よく分からなければ、これを試さないでください。
これは簡単にパフォーマンスの障害となり得ます。
<path>/var/log</path>をこの様にマウントしたければ、マウント解除時にログファイルをmergeするようにしてください。
これらは絶対必要です。
/var/tmpをこの様にマウントしないでください。
Portageがコンパイルのために使うからです。
</warn>

</body>
</section>
</chapter>

<chapter>
<title>その他のデバイスの電力管理</title>
<section>
<title>無線電力管理</title>
<body>

<p>
無線LANカードはかなり多くの電力を消費します。
pm.hdaスクリプトの用に電力管理モードに置きましょう。
</p>

<pre caption="無線LAN電力管理の自動化">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
スクリプトを開始するとwlan0が電力管理モードに置かれ、トラフィックが3秒間無ければスリープ状態になります。
<path>/etc/init.d/pm.wlan0</path>に保存し、ディスクスクリプトと同じようにbatteryランレベルに追加します。
詳細とオプションは<c>man iwconfig</c>を参照してください。
ドライバーとアクセスポイントがビーコン時間の変更をサポートしているなら、これはより多くの電力を削減する良いきっかけです。
</p>

</body>
</section>
<section>
<title>USB電力管理</title>
<body>

<p>
電力消費に関してUSB装置に関する2つの問題があります。
まず最初に、USBマウス、デジタルカメラまたはUSBスティックのようなデバイスはプラグに差し込まれている間、電力を消費します。
これは避けることができません(それにもかかわらず、必要とない場合にはそれらを取り除いてください)。
２つめに、プラグを差し込まれたUSBデバイスがあるとき、USBホストコントローラはCPUがC3/4スリープモードに入るのを妨げるように順番にバスに定期的にアクセスします。
この問題の答えがいわゆる「USB選択サスペンド」ですが、それはカーネルでまだ実装されていません。
USB選択サスペンドはデバイスが使用中であるといけないので、バスアクセスを許可するだけです。
それが実装されるまでの次善策は次のような物です。
モジュールとしてUSBサポートと装置をコンパイルし、それらが使用中でない間(例えば、ふたを閉じるとき)、スクリプトでそれらを取り除いてください。
</p>

</body>
</section>
</chapter>

<chapter>
<title>スリープ状態: ディスクのスリープ、スタンバイ、サスペンド</title>
<section>
<title>概略</title>
<body>

<p>
ACPIは異なったスリープ状態を定義します。
最も重要な物は
</p>

<ul> 
  <li>スタンバイとして知られるS1</li>
  <li>RAMをサスペンドするS3</li>
  <li>ディスクをサスペンドするS4</li>
</ul>

<p>
これらはシステムが使用中ではない場合にはいつも呼び出されますが、シャットダウンは起動に長い時間がかかるので望ましくありません。
</p>

</body>
</section>
<section>
<title>スリープ、スタンバイそしてハイバネーション</title>
<body>

<p>
ACPIはこれらスリープ状態を実験的としてサポートしています。
APMスリープ状態はstableの様に見えますが、APMとACPIを一緒には利用できません。
</p>

<warn>
スリープ状態のサポートはより改良されていますが、それは未だ実験段階です。
swsusp2を入手しRAMをサスペンドするようにした時、警告されました。
これは、たぶん働いていませんが、あなたのデータ/システムを破損するでしょう。
</warn>

<p>
現在、S4のための3つの実装があります。
オリジナルのものがswsuspです。
そして、最も良いインタフェース(bootsplashサポートを含んでいる)を持っていますが、手動のカーネル修正を必要とするswsusp2があります。
最後に、swsuspからフォークしたSuspend-to-Diskがあります。
</p>

<p>
もし混乱したのなら、<uri link="http://softwaresuspend.berlios.de/features.html#compare">機能比較</uri>を見てください。
それでも混乱していて何を使っていいか分からなければ、まず最も見込みがあるswsusp2を使ってみてください。
</p>

<p>
カーネルのこの部分を以下のようにします。
</p>

<pre caption="様々なサスペンドタイプのためのカーネル設定">
Power Management Options ---&gt;

  <comment>(sleep and standby)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(swsuspを使ったハイバネーション)</comment>
  [*] Software Suspend (EXPERIMENTAL)
  
  <comment>(swsusp2を使ったハイバネーション)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"your-swap-here")    Default resume device name

  <comment>(Suspend-to-Diskを使ったハイバネーション)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"your-swap-here") Default resume partition
</pre>

<p>
適当なオプションを付けてカーネルをコンパイルし、2.4シリーズなら<c>cat /proc/acpi/sleep</c>を、2.6なら<c>cat /sys/power/state</c>を見て何がサポートされているかを確認してください。
後者の場合、<c>standby mem disk</c>が出力されます。
swsuspでは、カーネルパラメータに<c>resume=/dev/"your-swap-here"</c>を追加する必要があります。
イメージの破損により起動しなければ、swsuspでは<c>noresume</c>を、Suspend-to-Diskでは<c>pmdisk=off</c>を、swsusp2では<c>noresume2</c>を使います。
</p>

<p>
システムをスリープ状態にするには以下のようにします。
</p>

<pre caption="スリープ状態を有効化">
<comment>(カーネル2.4シリーズ)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>(スタンバイ)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(スリープ)</comment>

<comment>(カーネル2.6シリーズ)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>スタンバイ</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>スリープ</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>hibernate</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>hibernate</comment>

<comment>(swsusp2)</comment>
# <i>echo &gt; /proc/swsusp/activate</i>
</pre>

<warn>
これを行う前にデータをバックアップしてください。
コマンドを実行する前に、<c>sync</c>を実行し、キャッシュされているデータをディスクに書き込んでください。
まずX外で試し、その後Xを起動させますが、ログインしないでください。
</warn>
 
<p>
uhciまたは類似するものが原因でカーネルパニックを経験したなら、モジュールとしてUSBサポートをコンパイルして、あなたのラップトップをスリープモードにする前に、モジュールを解除するようにしてください。
</p>

<p>
上記はswsuspとSuspend-to-Diskの実行(私は動かないと言いましたが)には事足りますが、swsusp2には特別な配慮が必要です。
最初にすることは<uri link="http://softwaresuspend.berlios.de/">http://softwaresuspend.berlios.de/</uri>で提供されるパッチをカーネルに当てることです。
その後、同じページのハイバネーションスクリプトをインストールします。
</p>

</body>
</section>
</chapter>

<chapter>
<title>トラブルシューティング</title>
<section>
<title>もし何かがおかしければ・・・</title>
<body>

<p>
<e>Q:</e> CPU周波数を変更しようとしましたが、<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path>がありませんでした。
</p>

<p>
<e>A:</e> プロセッサがCPU周波数の調整をサポートしていて、プロセッサ用の正しいCPUFreqドライバーを選ぶようにしてください。
これがcpufreq(カーネル2.6.7)によってサポートされているプロセッサのリストです。ARM Integrator、ARM-SA1100、
ARM-SA1110、AMD Elan - SC400、SC410、AMD mobile K6-2+、AMD mobile K6-3+、AMD
mobile Duron、AMD mobile Athlon、AMD Opteron、AMD Athlon 64、Cyrix Media GXm、
同じチップセットのIntel mobile PIIIとIntel mobile PIII-M、Intel Pentium 4、
Intel Xeon、Intel Pentium M (Centrino)、National Semiconductors Geode GX、
Transmeta Crusoe、VIA Cyrix 3 / C3、UltraSPARC-III、SuperH SH-3、SH-4、
"PowerBook"や"iBook2"やACPI 2.0互換システム（"ACPI Processor Performance States"がACPI/BIOSインターフェースに存在する場合のみ）の様々なプロセッサ。
</p>

<p>
<e>Q:</e> 私のラップトップは周波数の調整をサポートしていますが、<path>/sys/devices/system/cpu/cpu0/cpufreq/</path>が空っぽです。
</p>

<p>
<e>A:</e> ACPI関連のエラーメッセージを<c>dmesg | grep ACPI</c>で見てください。
BIOSの更新を試してください（特にDSDTの破損が報告された場合）。
自分で直すこともできます。（このガイドの範囲外です）
</p>

<p>
<e>Q:</e> 私のラップトップは周波数の調整をサポートしていますが、/proc/cpuinfoによると速度は全く更新されていません。
</p>

<p>
<e>A:</e> カーネルのバグかもしれません。
<c>emerge x86info</c>を実行し、指示されたようにカーネルの更新を行ってから、現在の周波数を<c>x86info -mhz</c>で確認します。
</p>

<p>
<e>Q:</e> CPU周波数の変更はできますが、他のOSほど幅が広くありません。
</p>

<p>
<e>A:</e> 最小周波数をより下げるために、周波数調整とACPIスロットルを結合すること
ができます。
スロットルは大きな省電力を得るわけではなく主に温度管理(ラップトップを涼しく静かにする)に使われると言うことに気をつけてください。
現在のスロット状態は<c>cat /proc/acpi/processor/CPU/throttling</c>で見ることができ、<c>echo -n "0:x" > /proc/acpi/processor/CPU/limit</c>で変更できます。
xは<path>/proc/acpi/processor/CPU/throttling</path>に載っているTx状態のうちの１つです。
</p>

<p>
<e>Q:</e> バッテリーの駆動時間が前よりも悪くなったみたいです。
</p>

<p>
<e>A:</e> BIOSの設定を確認してください。
もしかするといくつかの設定を再度有効にし忘れたのかもしれません。
</p>

<p>
<e>Q:</e> バッテリーを充電しましたが、KDEは0%だと報告してすぐに終了してしまいます。
</p>

<p>
<e>A:</e> バッテリーサポートがカーネル内にコンパイルされているか確認してください。
モジュールとして使っているなら、モジュールを読み込んでください。
</p>

<p>
<e>Q:</e> Dell Inspiron 51XXを使っていますが何のACPIイベントも起きません。
</p>

<p>
<e>A:</e> カーネルのバグの様です。<uri link="http://bugme.osdl.org/show_bug.cgi?id=1752">これ</uri>を読んでください。
</p>

<p>
<e>Q:</e> 新しいバッテリーを買いましたが、数分しか持ちません！何を間違えたのでしょうか？
</p>

<p>
<e>A:</e> まずバッテリーの製造元が指示する正しい充電方法に従ってください。
</p>

<p>
<e>Q:</e> 上のは助けになりませんでした。では何をすべきでしょうか？
</p>

<p>
<e>A:</e> 「新品」として売られているうちのいくらかは実際には中古の物です。以下の通りにしてください。
</p>

<pre caption="バッテリー状態の確認">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
もし "last full capacity" が設計容量と不思議に異なっていたら、バッテリーが壊れているのかもしれません。
保証を要求してください。
</p>

</body>
</section>
</chapter>
</guide>
