<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ja/handbook/hb-net-modules.xml,v 1.2 2005/08/13 18:20:14 idani Exp $ -->

<!-- Original revision: 1.7 -->
<!-- Translator: igarashi -->

<sections>

<version>1.3</version>
<date>2005-08-02</date>

<section>
<title>ネットワークモジュール</title>
<body>

<p>
現在、モジュール構造のネットワーク接続スクリプトをサポートしています。
これにより、既存のものと互換性を保ちながら、新しいインターフェースの種類や設定モジュールのサポートを簡単に追加できます。
</p>

<p>
モジュールが必要とするパッケージがインストールされていれば、モジュールはデフォルトでロードされます。
ここでまだインストールされていないパッケージのモジュールを指定すると、インストールする必要があるパッケージがあることを示すエラーとなります。
理想は、同一サービスを提供する二つ以上のパッケージをインストール済みで、その中の一つを選ぶ必要があるときにだけモジュール設定を使用することです。
</p>

<pre caption="モジュール選択">
<comment># ifconfigではなくiproute2を選択</comment>
modules=( "iproute2" )

<comment># 特定のインターフェースに対し別のモジュールも指定できます
# ここではdhcpcdではなくudhcpcを選択しています</comment>
modules_eth0=( "udhcpc" )

<comment># 使用しないモジュールの指定もできます - 例えば無線LANの設定を制御するために、
# supplicantもしくはlinux-wlan-ngを使用しているかもしれません。
# にもかかわらず、接続するESSIDごとにネットワーク設定を指定したい場合
</comment>
modules=( "!iwconfig" )
</pre>

</body>
</section>
<section>
<title>インターフェースハンドラ</title>
<body>

<p>
現在、ifconfigとiproute2の二つのインターフェースハンドラを提供しています。
ネットワークの設定のどんなことをするのにも、これらのうちの一つが必要です。
</p>

<p>
ifconfigは、今のGentooのデフォルトであり、システムプロファイルに含まれています。iproute2は、より強力で柔軟なパッケージですが、デフォルトでは含まれていません。
</p>

<pre caption="iproute2をインストールする">
# <i>emerge sys-apps/iproute2</i>

<comment># 両方がインストールされている場合、ifconfigではなくiproute2を選択する</comment>
modules=( "iproute2" )
</pre>

<p>
ifconfigもiproute2もどちらもよく似たことをするので、基本設定を相互に動作するようにできます。
例えば、以下の抜粋コードのどちらも、どちらを使用しているかに関係なく動作します。</p>

<pre caption="ifconfigとiproute2の例">
config_eth0=( "192.168.0.2/24" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0" )

<comment># broadcastの指定も可能</comment>
config_eth0=( "192.168.0.2/24 brd 192.168.0.255" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255" )
</pre>

</body>
</section>
<section id="dhcp">
<title>DHCP</title>
<body>

<p>
DHCPは、DHCPサーバからネットワーク情報(IPアドレス、DNSサーバ、ゲートウェイ、その他)を取得する手段です。
これは、ネットワーク上で稼動中のDHCPサーバが存在する場合、DHCPを使うことを各クライアントに指示する必要があり、それが自動的にネットワークを設定するということを意味します。
もちろん、DHCPを使えるようになる前に、必要なら無線やPPPなど、他の設定をする必要はあります。
</p>

<p>
DHCPの機能は、dhclient、dhcpcd、pump、udhcpcによって提供されます。
各DHCPモジュールには、長所と短所があります。以下にざっと紹介します。
</p>

<table>
<tr>
  <th>DHCPモジュール</th>
  <th>パッケージ</th>
  <th>長所</th>
  <th>短所</th>
</tr>
<tr>
  <ti>dhclient</ti>
  <ti>net-misc/dhcp</ti>
  <ti>
    BIND DNSソフトウェアを作成している人々と同じであるISCによって作成されました。
    設定項目が豊富
  </ti>
  <ti>
    設定が極めて複雑で、ソフトウェアは非常に大きくなり過ぎており、DHCPからNTPサーバの情報を得ることはできず、デフォルト設定ではホスト名を送信しません
  </ti>
</tr>
<tr>
  <ti>dhcpcd</ti>
  <ti>net-misc/dhcpcd</ti>
  <ti>
    長い間Gentooではデフォルトであり、別のツールに依存しない
  </ti>
  <ti>
    性能向上のためには維持されておらず、時々動作が遅くなる場合があり、リース期間が永久の場合はデーモンとして動作しません
  </ti>
</tr>
<tr>
  <ti>pump</ti>
  <ti>net-misc/pump</ti>
  <ti>
    軽量、別のツールに依存しない
  </ti>
  <ti>
    性能向上のためには維持されておらず、信頼性が低く、特にモデム経由の場合に信頼性が低く、DHCPからNISサーバの情報を取得できません
  </ti>
</tr>
<tr>
  <ti>udhcpc</ti>
  <ti>net-misc/udhcp</ti>
  <ti>
    軽量 - 他に比べて最小のDHCPクライアントであり、組み込みシステム向けに作成されています
  </ti>
  <ti>
    動作実績が少ない - デフォルトでこれを使っているディストリビューションがない、3秒超のタイムアウト時間を設定できません
  </ti>
</tr>
</table>
     
<p>
二つ以上のDHCPクライアントがインストールしている場合、どれを使用するかを指定する必要があります - そうしないと可能ならdhcpcdをデフォルトにします。
</p>

<p>
dhcpモジュールに特定のオプションを与えるために、module_eth0="..."を使用してください。
<e>(使用中のDHCPモジュールにmoduleを付け替えてください - たとえばdhcpcd_eth0)</e>
</p>

<p>
DHCPの相互運用性の向上に勤めています - その一環としてdhcp_eth0変数を使用して以下のコマンドをサポートします。デフォルト設定ではこれらのどれも設定されていません。
</p>

<ul>
  <li>release - 再利用できるようにIPアドレスを解放します</li>
  <li>nodns - /etc/resolv.confを書き換えません</li>
  <li>nontp - /etc/ntp.confを書き換えません</li>
  <li>nonis - /etc/yp.confを書き換えません</li>
</ul>

<pre caption="/etc/conf.d/netでのDHCP設定の例">
<comment># 二つ以上のDHCPモジュールがインストールされている場合にだけ必要です</comment>
modules=( "dhcpcd" ) 

config_eth0=( "dhcp" )
dhcpcd_eth0="-t 10" <comment># 10秒後にタイムアウトします</comment>
dhcp_eth0="release nodns nontp nonis" <comment># アドレスのみ取得します</comment>
</pre>

<note>
dhcpcdとudhcpcとpumpは、デフォルトで現在のホスト名をDHCPサーバに送信します。
よって、これに関して何も指定する必要はありません。
</note>

</body>
</section>
<section>
<title>ADSLモデム</title>
<body>

<p>
最初に、ADSLソフトウェアをインストールする必要があります。
</p>

<pre caption="rp-pppoeパッケージのインストール">
# <i>emerge net-dialup/rp-pppoe</i>
</pre>

<warn>
baselayout-1.11.xはPPPOEだけをサポートします。きっと将来のバージョンではPPPOAもサポートされるでしょう。
</warn>

<p>
次に、eth0をADSLインターフェースにするために設定する必要があり、ユーザ名を入力します。
</p>

<pre caption="ADSL向けにeth0を設定する">
config_eth0=( "adsl" )
user_eth0="username"
</pre>

<p>
最後に、<path>/etc/ppp/pap-secrets</path>にユーザ名とパスワードを設定する必要があります。
</p>

<pre caption="/etc/ppp/pap-secretsの例">
<comment># *(アスタリスク)は重要です</comment>
"username"  *  "password"
</pre>

</body>
</section>
<section id="apipa">
<title>APIPA (Automatic Private IP Addressing)～自動プライベートIPアドレス割当て機能</title>
<body>

<p>
APIPAは、インターフェースに169.254.0.0-169.254.255.255の範囲のアドレスに無作為にARPメッセージを送信することによって、空きアドレスを探します。
応答のないものがあった場合、そのアドレスをインターフェースに割り当てます。
</p>

<p>
DHCPサーバが存在せず、かつ直接インターネットに接続せず、かつ他の全てのコンピュータがAPIPAを使用しているプライベートネットワークにだけ役に立ちます。
</p>

<p>
APIPAをサポートするために、emerge net-misc/iputilsまたは、net-analyzer/arpingをしてください。
</p>

<pre caption="/etc/conf.d/netでのAPIPA設定">
<comment># 最初にDHCPを試します - 失敗したら代替手段としてAPIPAを使用</comment>
config_eth0=( "dhcp" )
fallback_eth0=( "apipa" )

<comment># APIPAだけを使用</comment>
config_eth0=( "apipa" )
</pre>

</body>
</section>
<section>
<title>Bonding(インターフェースを束ねる)</title>
<body>

<p>
bonding/trunkingをする(インターフェースを束ねる)には、emerge net-misc/ifenslaveをします。
</p>

<p>
bondingは、ネットワーク帯域を増やすために使われます。
もし一つのネットワークにしたい二つのネットワークカードがあるなら、それらを束ねることができます。
そうすると、アプリケーションには一つのインターフェースとして見えますが、実際は両方のネットワークカードが使用されます。
</p>

<pre caption="/etc/conf.d/netでのbonding設定">
<comment>二つのインターフェースを束ねる</comment>
slaves_bond0="eth0 eth1 eth2"

<comment># 束ねられたインターフェースにIPアドレスを割り当てたくない場合もあります</comment>
config_bond0=( "null" )

<comment># 別の設定が必要かもしれないのでeth0、eth1、eth2に依存します</comment>
depend_bond0() {
  need net.eth0 net.eth1 net.eth2
}
</pre>

</body>
</section>
<section>
<title>ブリッジ (802.1dのサポート)</title>
<body>

<p>
ブリッジをサポートするには、emerge net-misc/bridge-utilsをします。
</p>

<p>
ブリッジは、異なるネットワーク同士を繋げるために使用されます。
例えば、ADSLモデム経由でインターネットに接続していて、他のコンピュータをADSLモデム経由でインターネットに接続できるようにするための無線接続カードを持っているサーバがあるとします。
この場合、二つのインターフェースを相互に繋げるために、ブリッジを作成できます。
</p>

<pre caption="/etc/conf.d/netでのブリッジ設定">
<comment># ブリッジ設定 - 詳細は"man btctl"を参照してください</comment>
brctl_br0=( "setfd 0" "sethello 0" "stp off" )

<comment># ブリッジbr0にポートを追加します</comment>
bridge_br0="eth0 eth1"

<comment># dhcpが開始しないようにするために、そのポートにはnullを設定する必要があります</comment>
config_eth0=( "null" )
config_eth1=( "null" )

<comment># 最後にブリッジにアドレスを設定します - DHCPも使用できます</comment>
config_br0=( "192.168.0.1/24" )

<comment># 別の設定が必要かもしれないのでeth0、eth1に依存します</comment>
depend_br0() {
  need net.eth0 net.eth1
}
</pre>

<impo>
複数のブリッジ設定を行う場合、<uri link="?part=4&amp;chap=2#variable_name">変数名</uri>を参照してください。
</impo>

</body>
</section>
<section>
<title>MACアドレス</title>
<body>

<p>
特定のアドレスに変更するだけなら、インターフェースのMACアドレスを変更するために何もemergeする必要はありません。
しかし、ランダムなアドレスや、指定した形式でランダムにアドレスに変更する必要があるなら、emerge net-analyzer/macchangerをする必要があります。
</p>

<pre caption="MACアドレスを変更する例">
<comment># インターフェースのMACアドレスを設定します</comment>
mac_eth0="00:11:22:33:44:55"

<comment># 最後の3バイトだけランダムに設定します</comment>
mac_eth0="random-ending"

<comment># ベンダ毎に、物理的に同じ種類別にランダムに設定します
# (例 ファイバ、銅線、無線)</comment>
mac_eth0="random-samekind"

<comment># ベンダ毎に、物理的な種類を問わずランダムに設定します
# (例 ファイバ、銅線、無線)</comment>
mac_eth0="random-anykind"

<comment># 完全にランダムに設定します - 警告: これによって生成される一部のMACアドレスには
# 期待したように動作しないものがあります</comment>
mac_eth0="random-full"
</pre>

</body>
</section>
<section>
<title>トンネリング</title>
<body>

<p>
トンネリングをするには、インターフェースハンドラで実現できるので、何もemergeする必要はありません。
</p>

<pre caption="/etc/conf.d/netでのトンネリング設定">
<comment># GREトンネリング向け</comment>
iptunnel_vpn0="mode gre remote 207.170.82.1 key 0xffffffff ttl 255"

<comment># IPIPトンネリング向け</comment>
iptunnel_vpn0="mode ipip remote 207.170.82.2 ttl 255"

<comment># 該当するインターフェースの設定</comment>
config_vpn0=( "192.168.0.2 peer 192.168.1.1" ) 
</pre>

</body>
</section>
<section>
<title>VLAN (802.1qのサポート)</title>
<body>

<p>
VLANをサポートするには、emerge net-misc/vconfigをします。
</p>

<p>
仮想LANは、たとえ別のセグメントであっても、あたかも単一のネットワークセグメントに接続されているように振舞うネットワークデバイスの集合です。
VLANに接続している機器には、たとえ物理的に同じネットワークを共有していても、同一のVLAN上の機器しか見えません。
</p>

<pre caption="/etc/conf.d/netでのVLAN設定">
<comment># 次のようにインターフェースのVLAN番号を指定します</comment>
<comment># VLANのIDは、前に0を付加しない形式です</comment>
vlans_eth0="1 2"

<comment># もちろんVLANを設定することもできます</comment>
<comment># 詳細はvconfigのmanページを参照してください</comment>
vconfig_eth0=( "set_name_type VLAN_PLUS_VID_NO_PAD" )
vconfig_vlan1=( "set_flag 1" "set_egress_map 2 6" )

<comment># 通常のようにVLANインターフェースを設定します</comment>
config_vlan1=( "172.16.3.1 netmask 255.255.254.0" )
config_vlan2=( "172.16.2.1 netmask 255.255.254.0" )
</pre>

<impo>
複数のVLAN設定を行う場合、<uri link="?part=4&amp;chap=2#variable_name">変数名</uri>を参照してください。
</impo>

</body>
</section>

</sections>
