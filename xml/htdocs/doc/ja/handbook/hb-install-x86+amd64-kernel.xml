<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ja/handbook/hb-install-x86+amd64-kernel.xml,v 1.2 2008/02/10 06:42:58 shindo Exp $ -->

<sections>

<abstract>
全てのディストリビューションで中核をなすのが、Linuxカーネルです。
本章では、カーネルのコンフィギュレーション方法について説明します。
</abstract>

<version>5.8</version>
<date>2008-01-14</date>

<!-- Original revision: 1.21 -->
<!-- Translator: Taku Murakami -->

<section>
<title>タイムゾーン</title>
<body>

<p>
システムが、どの地域に設置されているかを把握するため、
まず初めにタイムゾーンを選択しなくてはいけません。
<path>/usr/share/zoneinfo</path>でタイムゾーンを確認し、
<path>/etc/localtime</path>へコピーします。
なお、ファイル名が実際の地域を示しているわけではないので、
<path>/usr/share/zoneinfo/Etc/GMT*</path>タイムゾーンは避けて下さい。
例えば、<path>GMT-8</path>は実際にはGMT+8を示します。
</p>

<pre caption="タイムゾーン情報の設定">
# <i>ls /usr/share/zoneinfo</i>
<comment>(ここでは、GMTを使用することを想定しています)</comment>
# <i>cp /usr/share/zoneinfo/GMT /etc/localtime</i>
</pre>

</body>
</section>
<section>
<title>ソースをインストールする</title>
<subsection>
<title>カーネルを選択する</title>
<body>

<p>
全のディストリビューションで中核となるのが、Linuxカーネルです。これは、
ユーザプログラムとシステムハードウェアを仲介します。Gentooでは、
使用可能なカーネルソースをユーザに複数提供しています。説明がついた詳細な一覧表が、
<uri link="/doc/en/gentoo-kernel.xml">Gentoo Kernel
Guide</uri><uri link="/doc/ja/gentoo-kernel.xml">(日本語訳)</uri>から入手できます。

</p>

<p test="func:keyval('arch')='x86'">
x86ベースのシステムでは、
とりわけ<c>gentoo-sources</c>(追加機能のパッチを含んだカーネルソース)が提供されています。
</p>

<p test="func:keyval('arch')='AMD64'">
AMD64ベースのシステムでは、
とりわけ<c>gentoo-sources</c>(追加機能のパッチを含んだカーネルソース)が提供されています。
</p>

<p>
カーネルソースを選択し、<c>emerge</c>を使ってインストールします。
</p>

<pre caption="カーネルソースのインストール">
# <i>emerge gentoo-sources</i>
</pre>

<p>
<path>/usr/src</path>を確認すると、
カーネルソースにリンクが張られた<path>linux</path>というシンボリックリンクがあるはずです。この場合、
インストールされたカーネルソースは<c>gentoo-sources-<keyval id="kernel-version"/></c>にリンクが張られています。
なお、読者の環境によっては異なるかもしれませんので、注意して下さい。
</p>

<pre caption="カーネルソースのシンボリックリンクを確認">
# <i>ls -l /usr/src/linux</i>
lrwxrwxrwx    1 root   root    12 Oct 13 11:04 /usr/src/linux -&gt; linux-<keyval id="kernel-version"/>
</pre>

<p>
それでは、カーネルソースをコンフィギュレーションしコンパイルしていきます。なお、
<c>genkernel</c>を使用し、インストールCDで使用される標準カーネルをビルドすることもできます。
但し、ここではまず初めにに"マニュアル"コンフィギュレーションを説明します。というのも、
これは環境を最適化する上で最良の方法だからです。
</p>

<p>
マニュアルでカーネルをコンフィギュレーションするなら、<uri
link="#manual">デフォルト: マニュアルコンフィギュレーション</uri>へ進んで下さい。
<c>genkernel</c>を使用するなら、
代わりに<uri link="#genkernel">代替案: genkernelを使用する</uri>を読み進んで下さい。
</p>

</body>
</subsection>
</section>
<section id="manual">
<title>デフォルト: マニュアルコンフィギュレーション</title>
<subsection>
<title>はじめに</title>
<body>

<p>
マニュアルでカーネルをコンフィギュレーションすることは、
Linuxユーザが行うべきオペレーションの中で、最難関と見なされることがあります。
これは、それほど真実ということでもありません。カーネルのコンフィギュレーションを数回こなせば、
難しかったことを思い出すことすらないでしょう。;)
</p>

<p>
しかし、一つだけ<e>本当</e>のことがあります。
カーネルをマニュアルでコンフィギュレーションし始める際には、
システムをよく把握しておかなくてはいけないということです。ほとんどの情報は、
<c>lspci</c>を含んだpciutils(<c>emerge pciutils</c>)をemergeすることで収集できます。
そうすれば、chrootされた環境で、<c>lspci</c>を実行できます。
なお、<c>lspci</c>によって出力される<e>pcilib</e>に関する警告は、
無視して構いません(例えば、pcilib: cannot open/sys/bus/pci/devices)。あるいは、
<e>chrootされていない</e>環境から<c>lspci</c>を実行することも可能です。
実行結果は同じになります。または、<c>lsmod</c>を実行し、
インストールCDがどのカーネルモジュールを使用しているかを確認することもできます(有効にすべきモジュールを判断する上で、
良いヒントになるでしょう)。
</p>

<p>
それでは、カーネルソースのディレクトリに移動し、<c>make menuconfig</c>を実行します。
ncursesベースのコンフィギュレーションメニューが表示されます。
</p>

<pre caption="menuconfigの呼び出し">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
コンフィギュレーション項目がいくつか表示されますので、まずは、
有効にすべきオプションをピックアップしていきましょう(そうしないと、
Gentooが機能しなかったり、あるいは追加調整なしで正常に機能しません)。
</p>

</body>
</subsection>
<subsection>
<title>必須オプションを有効にする</title>
<body>

<p>
まず初めに、開発中・実験段階の機能/ドライバの使用を有効にします。
有効にしないと、重要な機能/ドライバの中には表示されないものがあります。
</p>

<pre caption="実験段階の機能/ドライバを選択">
General setup ---&gt;
  [*] Prompt for development and/or incomplete code/drivers
</pre>

<p>
システムをブートする上で必須のドライバ(例えば、SCSIコントローラ等)全てが、
モジュールとしてではなく、カーネル<e>自身</e>にコンパイルされるようにして下さい。
そうしないと、システムが完全にブートできるようになりません。
</p>

</body>
<body test="func:keyval('arch')='AMD64'">

<p>
次に、正確なプロセッサタイプを選択します。x86_64のカーネルメンテナは、
ハードウェアの問題がユーザへ通知されるように、MCE機能を有効にすることを強く推奨しています。
x86_64では、他のアーキテクチャと異なり、この種のエラーは<c>dmesg</c>ではなく、
<path>/dev/mcelog</path>へ出力されます。なお、その際には<c>app-admin/mcelog</c>パッケージが必要になります。
また、32ビットプログラムを実行可能にするなら、IA32エミュレーションを選択するようにして下さい。
Gentooでは、マルチライブラリシステム(32ビット/64ビットコンピューティングの混合)が、
デフォルトでインストールされます。そのため、おそらくこのオプションが必要になるでしょう。
</p>

<pre caption="プロセッサタイプと機能の選択">
Processor type and features  --->
   [ ] Intel MCE Features
   [ ] AMD MCE Features
  Processor family (AMD-Opteron/Athlon64)  --->
    ( ) AMD-Opteron/Athlon64
    ( ) Intel EM64T
    ( ) Generic-x86-64
Executable file formats / Emulations  --->
   [*] IA32 Emulation
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
それでは、正確なプロセッサファミリを選択します。
</p>

<pre caption="正確なプロセッサファミリの選択">
Processor type and features ---&gt;
  <comment>(システムに合わせ変更して下さい。)</comment>
  (<i>Athlon/Duron/K7</i>) Processor family
</pre>

</body>
<body>

<p>
<c>File Systems</c>に移動し、使用するファイルシステムのサポートを選択します。
但し、モジュールとしてコンパイル<e>してはいけません</e>。そうしないと、
Gentooシステムはパーティションをマウントできません。また、<c>Virtual
memory</c>と<c>/proc file system</c>を選択して下さい。
</p>

</body>
<body test="func:keyval('arch')='x86'">

<pre caption="必要なファイルシステムを選択">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<comment>(システムに合わせて下記オプションを1つ以上選択して下さい。)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

</body>
<body test="func:keyval('arch')='AMD64'">

<pre caption="必要なファイルシステムを選択">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<comment>(システムに合わせて下記オプションを1つ以上選択して下さい。)</comment>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre>

</body>
<body>

<p>
IOデバイス用にDMAを有効にして下さい。
</p>

<pre caption="DMAをアクティブ化">
Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
</pre>

<p>
PPPoEを使用してインターネット接続する、
あるいはダイアルアップモデムを使用しているのであれば、
下記のオプションがカーネルで必要になります。
</p>

<pre caption="必要なPPPoE用ドライバを選択" test="func:keyval('arch')='AMD64'">
Device Drivers ---&gt;
  Networking Support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<pre caption="必要なPPPoE用ドライバを選択" test="func:keyval('arch')='x86'">
Device Drivers ---&gt;
  Networking support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre>

<p>
2つの圧縮オプションに害はありませんが、必須というわけでもありません。
同様に、<c>PPP over Ethernet</c>オプションも必須というわけではなく、
カーネルにPPPoE機能をコンフィギュレーションする際に<c>ppp</c>で使用されるだけです。
</p>

<p>
また、必要に応じて、イーサネットカードに合わせカーネルサポートを有効にして下さい。
</p>

<p test="func:keyval('arch')='x86'">
ハイパースレッディング(tm)をサポートするインテル製CPU、あるいはマルチCPUシステムなら、
"Symmetric multi-processing support"を有効にします。
</p>

<p test="func:keyval('arch')='AMD64'">
マルチCPUのOpteron、又はマルチコア(AMD64 X2等)システムなら、
"Symmetric multi-processing support"を有効にします。
</p>

<pre caption="SMPサポートの有効化">
Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre>

<note>
マルチコアシステムでは、各コアが1つのプロセッサとしてカウントされます。
</note>

<p>
USB入力デバイス(キーボードやマウス等)を使用するなら、同様に下記も有効にして下さい。
</p>

<pre caption="入力デバイス用に、USBサポートの有効化">
Device Drivers ---&gt;
  HID Devices --->
    &lt;*&gt;   USB Human Interface Device (full HID) support
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
PCMCIAサポートがノートPCで必要なら、
システムに合わせPCMCIAカードブリッジのサポートを有効にして下さい。
</p>

<pre caption="PCMCIAサポートの有効化">
Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
<comment>(古いPCMCIAカードのサポートが必要なら、16ビットを選択します。ほとんどのシステムで必要になります。)</comment>
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
<comment>(適切なブリッジを下記から選択します。)</comment>
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre>

<p>
カーネルのコンフィギュレーションが終了したら、<uri 
link="#compiling">コンパイルとインストール</uri>へ進んで下さい。
</p>

</body>
</subsection>
<subsection id="compiling">
<title>コンパイルとインストール</title>
<body>

<p>
カーネルのコンフィギュレーションが済みましたので、コンパイル・インストールしていきます。
コンフィギュレーションメニューを終了し、コンパイルに進みます。
</p>

<pre caption="カーネルのコンパイル">
# <i>make &amp;&amp; make modules_install</i>
</pre>

<p>
カーネルのコンパイルが終了したら、カーネルイメージを<path>/boot</path>へコピーします。
選択したカーネルにふさわしいと思うファイル名であれば、どんなものでも構いませんが、
ブートローダを設定する際に後ほど必要となりますので、ファイル名は覚えておいて下さい。
<c><keyval id="kernel-name"/></c>をカーネルの名称とバージョンに置き換える必要があります。
</p>

<pre caption="カーネルのインストール">
# <i>cp arch/<keyval id="arch-sub"/>/boot/bzImage /boot/<keyval id="kernel-name"/></i>
</pre>

<p>
では、<uri link="#kernel_modules">カーネルモジュール</uri>へ進みましょう。
</p>

</body>
</subsection>
</section>
<section id="genkernel">
<title>代替案: genkernelを使用する</title>
<body>

<p>
このセクションを読んでいるなら、<c>genkernel</c>スクリプトを使用し、
カーネルのコンフィギュレーションを行うことにしたということでしょう。
</p>

<p>
カーネルツリーはインストールされていますので、<c>genkernel</c>スクリプトを使用し、
カーネルを自動でビルドします。
<c>genkernel</c>は、コンフィギュレーションがインストールCDのそれとほぼ同じになるように動作します。
つまり、<c>genkernel</c>を使用しカーネルをビルドすると、インストールCD同様、
通常であれば起動時にシステムが全ハードウェアを検出してくれるということになります。
genkernelでは、マニュアルでカーネルをコンフィギュレーションする必要がないので、
カーネルをコンパイルするのが不安なユーザにとっては理想的なソリューションです。
</p>

<p>
では、genkernelの使用方法を見ていきます。初めに、genkernelをemergeします。
</p>

<pre caption="genkernelのemerge">
# <i>emerge genkernel</i>
</pre>

</body>
<body test="func:keyval('arch')='x86'">

<p>
次に、インストールCDで使用されたカーネルコンフィギュレーションを、
genkernelがデフォルトのカーネルコンフィギュレーションを検索する場所へコピーします。
</p>

<pre caption="インストールCDのカーネルコンフィギュレーションをコピー">
# <i>zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</i>
</pre>

</body>
<body>

<p>
では、<c>genkernel all</c>を実行しカーネルソースをコンパイルして下さい。<c>genkernel</c>では、
ほとんど全てのハードウェアをサポートするカーネルをコンパイルするので、
コンパイルが終了するにはかなりの時間がかかります!
</p>

<p>
ブートパーティションが、ext2あるいはext3をファイルシステムとして使用していなければ、
マニュアルでカーネルをコンフィギュレーションしなくてはいけません。その際は、
<c>genkernel --menuconfig all</c>を実行しカーネル<e>自身</e>にファイルシステムのサポートを追加します(つまり、
モジュールとしてでは<e>ありません</e>)。同様に、EVMS2あるいはLVM2ユーザは、
<c>--evms2</c>あるいは<c>--lvm2</c>を引数に追加する必要があるかもしれません。
</p>

<pre caption="genkernelの実行">
# <i>genkernel all</i>
</pre>

<p>
<c>genkernel</c>が完了したら、カーネル -- モジュール全一式と<e>初期ルートディスク</e>(initrd)
-- が作成されます。本書では、後ほどブートローダを設定する際に、カーネルとinitrdを使用します。
ブートローダの設定ファイルを記述する際に必要となりますので、
カーネルとinitrdのファイル名を書き留めておいて下さい。電源ボタンを押し、
ハードウェアの自動検知(インストールCDで行われているように)が実行された後、
initrdはすぐに展開されます(但し、それは"実際の"システムが起動する前です)。
</p>

<pre caption="作成されたカーネルイメージとinitrdの確認">
# <i>ls /boot/kernel* /boot/initramfs*</i>
</pre>

</body>
</section>
<section id="kernel_modules">
<title>カーネルモジュール</title>
<subsection>
<title>モジュールをコンフィギュレーションする</title>
<body>

<p>
自動的にロードさせる必要があるモジュールは、
<path>/etc/modules.autoload.d/kernel-2.6</path>で記述しておく必要があります。
また必要に応じて、モジュールに対し追加オプションを加えることもできます。
</p>

<p>
利用可能なモジュールを全て確認するには、以下の<c>find</c>コマンドを実行します。なお、
コンパイルされたカーネルのバージョンに合わせ、"&lt;kernel version&gt;"を置き換える必要があります。
</p>

<pre caption="利用可能なモジュールを全て確認">
# <i>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</i>
</pre>

<p>
たとえば、<c>3c59x.ko</c>モジュールを自動的にロードさせるには、
<path>kernel-2.6</path>ファイルを編集しモジュール名を入力します。
</p>

<pre caption="/etc/modules.autoload.d/kernel-2.6の編集">
# <i>nano -w /etc/modules.autoload.d/kernel-2.6</i>
</pre>

<pre caption="/etc/modules.autoload.d/kernel-2.6">
3c59x
</pre>

<p>
それでは、<uri link="?part=1&amp;chap=8">システム設定</uri>に進み、インストールを続けて下さい。
</p>

</body>
</subsection>
</section>
</sections>
