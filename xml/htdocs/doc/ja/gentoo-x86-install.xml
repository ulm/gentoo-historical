<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/ja/gentoo-x86-install.xml">
  <title>Gentoo Linux 1.4 インストール手引書</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">Jerry Alexandratos</author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>
  <author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
  </author>
  <author title="Editor">
    <mail link="">Colin Morey</mail>
  </author>
  <author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Editor, Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
  </author>
  <author title="Editor">
    <mail link="avenj@gentoo.org">Jon Portnoy</mail>
  </author>
  <author title="Reviewer">
    <mail link="gerrynjr@gentoo.org">Gerald J. Normandin Jr.</mail>
  </author>
  <author title="Reviewer">
    <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
  </author>
  <author title="翻訳">
    <mail link="makoto@dsb.club.ne.jp">yamakura</mail>
  </author>
  <abstract>Gentoo Linux 1.4のインストール手引書です(_rcバージョンには対応しません)。
	この手引書ではゼロからGentoo Linuxを構築することはもちろん、いろいろな段階からのインストールを解説します。
	</abstract>

    <license/>
    
<version>2.6.3</version>
 <date>5th of August 2003</date>
<!-- Original revision: 1.143 -->
  <chapter>
    <title>インストールについて</title>
    <section>
      <body>
		<p>まず、初めての方へ、Gentoo Linux へようこそ!
		Gentoo Linuxはいろいろな方法でインストールすることができます。
		手早くインストールしたいなら、コンパイル済みパッケージを使う方法がありますし、
		とことん自分の好みに合わせてカスタマイズしたいなら、Gentoo Linux全体をソースコードからコンパイルすることができます。
		どうやるかはあなた次第です。</p>
		<p>正式に1.4がリリースされたのに伴なう重要な変更点は、
		2枚組のCDによるインストールセットが提供されることです。
		このCDは<uri link="http://store.gentoo.org">Gentoo Linux Store</uri>で購入できますし、
		ミラーサイトからダウンロードすることもできます。
		この2枚組CDのインストールセットはx86(486かそれ以降)、i686(Pentium Pro, Pentium II, Athlon/Duronかそれ以降)、
		Pentium III、Pentium 4、Athlon XP向けが用意されています。
		どのセットを選べばよいのかを知るには、<uri link="http://store.gentoo.org">Gentoo Linux Store</uri>でそれぞれの商品の説明を読んでください。
		このお店の説明にはCPUの互換性について詳しく書いてあります。</p>
		<p>2枚組CDについて、それぞれ説明します。
		最初のCD("CD 1")は"インストール用 LiveCD"と呼ばれ、起動可能なCD-ROMです。
		つまり"CD 1"をドライブに入れれば、Gentoo LinuxをCDから直接走らせることができます。
		この、CDバージョンのGentoo Linuxを使って、Gentoo Linux 1.4をハードディスクにインストールすることができます。
		この"CD 1"には、Gentoo Linux環境の他に、Gentoo Linuxを手早くインストールするために必要なものが全て含まれており、
		インターネット接続環境が無くてもインストール可能です。
		さらに、"CD 1"にはXFree86 Xサーバなど、いくつかのコンパイル済みパッケージも含まれています。
		"CD 1"のISOイメージは"-cd1.iso"で終わるファイル名になります。</p>
		<p>2番目のCD("CD 2")はブートはできませんが、数多くのコンパイル済みパッケージを含んでいます。
		たとえば、KDE、GNOME、OpenOffice、Mozilla、Evolutionといったものがあります。
		"CD 2"は、使うかどうかは<i>任意</i>であり、
		Gentoo Linuxをできるだけ速くインストールしたい人の利便を図るものです。
		この"CD 2"に含まれるパッケージをソースからコンパイルするしたら、
		標準的なシングルプロセッサのシステムでは36時間程度掛かります。
		"CD 2"のISOイメージは"-cd2.iso"で終わるファイル名になります。</p>
		<note>Gentoo Linuxの2枚組CDセットは、GNOME、KDE、Mozilla、OpenOfficeを含むコンパイル済みGentoo LinuxシステムGentoo Reference Platformを含んでいます。
		Gentoo Reference Platform("GRP")は、パッケージを短時間でインストールする機能を実現するために用意されました。
		Gentoo Linuxの基本である、「ソースからのコンパイル」は常に選択肢として用意されます。
		GRPの目的は、Gentooの強力な「ソースからのコンパイル」によるインストールに影響をあたえることなく、
		Gentoo Linuxをより手軽なものにすることです。</note>
		<p>2枚組CDセットの他に、とても小さい"basic" LiveCDも用意しており、こちらを使ってシステムをブートすることができます。
		ブートしたあとは、インターネットへの接続などを設定したのち、ネットワーク経由でダウンロードしながらインストールできます。
		このCDの特長はその小ささで、ISOイメージのダウンロード時間が節約できます。
		あなたが慣れたユーザで、Gentoo Linuxの最新バージョンの利用したいと考えており、
		良好なネットワーク接続環境を持っているなら、このCDは良い選択となるでしょう。
		"basic" LiveCDのISOイメージは"-basic.iso"で終わるファイル名になります。</p>
		<p>CDを使うどのインストール方法を選んだとしても、
		インストールを行なうには486以上のCPUおよび少なくとも64Mバイトのメモリが必要となります
		（Gentoo Linuxは64Mバイトのメモリと64Mバイトのスワップでビルドに成功していますが、
		このような環境下では、とても時間がかかります）。</p>
		<p>LiveCDを使ってブートしたあとにも、さらに選択肢が用意されています。
		Gentoo Linuxは３つある&quot;ステージ&quot;の圧縮ファイルのうち、どれかひとつを使ってインストールすることができます。
		どれを使うかは、システムのどの程度を自分でコンパイルして用意するかによって決まります。
		ステージ1圧縮ファイルは、ブートストラップしてシステム全体を一から組み立てるときに使います。
		ステージ2圧縮ファイルは、既にブートストラップが済んだ状態からシステムを構築する場合に使います。
		ステージ3圧縮ファイルは、標準的な設定で構築されたGentoo Linuxシステムを含んでいます。
		"GRP"を使ってインストールすることを考えているのなら、ステージ3を選択してください。</p>
		<p><b>GRPを使わずにインストールするとしたら、どのステージの圧縮ファイルを選んだらよいのでしょうか?</b>
		ここで、その手助けとなるように少し説明をします。
		ステージ1を使うと、インストール直後のシステムに対して、
		最適化オプションやコンパイル時に組込まれる機能を完全にコントロールすることができます。
		自分のしていることをきちんと把握しているパワーユーザには、ステージ1が良いでしょう。
		また、Gentoo Linuxの内部について知りたい人にとっても良い選択となります。</p>
		<p>
		ステージ2を使うと、ブートストラップを省略することができます。
		用意されたステージ2圧縮ファイルの最適化に不満がないならこれを使ってください。
		ステージ3を使うことでインストール時間がもっとも短くなりますが、
		最適化を自分でコントロールすることはできません。
		しかしGentoo Linuxのメジャーリリースでは、
		ポピュラーなプロセッサに対してそれぞれ最適化されたステージ3圧縮ファイルを用意しますので、
		どのプロセッサに対してもステージ3は、素早いインストールと充分に最適化されたシステムという最高の環境を提供します。
		<b>Gentoo Linuxをインストールするのが初めてなら、ステージ3圧縮ファイルによるインストール、もしくはステージ3とGRPの組合せを選択すると良いでしょう。</b></p>
		<note><b>上級者向け:</b>ステージ3を使ってインストールする場合は、
		make.confのCHOST設定を変えてはいけません。
		変更する必要があるならば、ステージ1圧縮ファイルを使って、
		希望するCHOST設定のシステムを構築してください。
		標準的なCHOSTは次のように設定されています:<c>i686-pc-linux-gnu</c></note>
	<impo>インストールの途中で見つけたバグをレポートする時は、
原則として<uri>http://bugs.gentoo.org</uri>を使ってください。
バグがそのソフトウェアそのものに起因するような場合、
Gentoo Linuxの開発チームがそれを判断してソフトウェアの開発チーム
(例えばKDE開発チームなど)に報告します。</impo>
	<note>補足: LiveCDに収められているインストール手引書は、
	我々のウェブサイトにある<uri link="/doc/en/gentoo-x86-install.xml">インストール手引書</uri>(<uri link="/doc/ja/gentoo-x86-install.xml">日本語訳</uri>)とは違い、
	必ずしも最新とは限りません。</note>
	<p>それではインストールの手順を簡単に見てみましょう。
まずLiveCDイメージをダウンロードし、CDを作成します。
LiveCDでブートしてプロンプトが出たら、まずパーティションを、
続いてファイルシステムを作成し、ステージ1、ステージ2、ステージ3圧縮ファイルのどれかを展開します。
ステージ1かステージ2の圧縮ファイルを使用する場合、ステージ3に進むために適切な手順を踏む必要があります。
ステージ3に進みシステムに対して各種の設定（設定ファイルの調整、
ブートローダーのインストールなど）を行ない、再起動すればGentoo Linuxの完成です。
基本的なGentoo Linuxシステムを動作させたら、2枚組CDセットの"CD 2"を使って
KDE、GNOME、OpenOffice、Mozilla他のコンパイル済みパッケージをインストールすることができます。
</p>
<p>以下に、スタートするステージ別にどのような手順が必要なのかを示します。</p>
        <table>
          <tr>
            <th>圧縮ファイル</th>
			<th>インターネットアクセス</th>
			<th>メディア</th>
            <th>手順</th>
          </tr>
          <tr>
            <ti>1</ti>
			<ti>必須</ti>
			<ti>"basic" または "CD 1"</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync、ブートストラップ、emerge system、最終調整</ti>
          </tr>
          <tr>
            <ti>2</ti>
			<ti>必須</ti>
			<ti>"basic" または "CD 1"</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync、emerge system、最終調整</ti>
          </tr>
          <tr>
            <ti>3</ti>
			<ti>"CD 1"を使うなら不要</ti>
            <ti>"basic" または "CD 1"</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync("CD 1"を使うなら不要)、
	    最終調整</ti>
          </tr>
          <tr>
		  	<ti>3+GRP</ti>
			<ti>不要</ti>
			<ti>"CD 1"と、必要に応じて"CD 2"を使用</ti>
            <ti>パーティションとファイルシステムの作成、最終調整、"CD 1"のコンパイル済パッケージのインストール(任意)、再起動、KDEやGNOMEなどのパッケージのインストール("CD 2"を使う場合)</ti>
		</tr>
		</table>
	<note>ハードウェアATA RAIDのユーザは、次に進む前にこの文書の最後にあるセクションを読んでください。</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ブート</title>
    <section>
      <body>
	<warn>先に進む前に、このセクション全体、特にブートオプションの部分をよく読んでください。
	無視して先に進むと、キーボードの設定が間違っていたり、pcmciaサービスを起動していなかったりすることがあります。</warn>

	<p>選択したLiveCDでブートするところから始めましょう。
		Gentoo Linuxロゴとともにブートスクリーンが表示されるはずです。
		この画面ではそのままブートプロセスを進めるためにEnterを押すか、
		自分のマシンに合ったカーネルとブートオプションを入力してからEnterを押してブートすることができます。
		例えば、<c>gentoo nousb nohotplug</c>などと入力します。
		Gentoo Linuxを複数のプロセッサを搭載したシステム("SMP")で使うなら、<c>gentoo</c>の代わりに、<c>smp</c>と入力してください。
		そうすることで、LiveCDが1つのプロセッサだけでなく、全てのプロセッサを使えるようになります。</p>

		<p>
		利用できるカーネルとオプションについては、以下の表かF2やF3キーを押すと表示されるヘルプを見てください。</p>

<table>
	<tr>
		<th>利用できるカーネル</th>
		<th>概要</th>
	</tr>
	
	<tr><ti>gentoo</ti><ti>標準的なgentooカーネル (デフォルト)</ti></tr>
	<tr><ti>nofb</ti><ti>フレームバッファ無効化</ti></tr>
	<tr><ti>smp</ti><ti>smpカーネルでフレームバッファ無効化</ti></tr>
	<tr><ti>acpi</ti><ti>acpi=on有効かつinit中にacpiモジュールをロード</ti></tr>
	<tr><ti>memtest</ti><ti>メモリテストプログラムを起動</ti></tr>

	</table>

	<p>
	<table>
	<tr>
		<th>利用できるブートオプション</th>
		<th>概要</th>
	</tr>

	<tr><ti>doataraid</ti>
	<ti>initrdでIDE-RAIDモジュールを読み込む</ti></tr>
	
	<tr><ti>dofirewire</ti>
	<ti>initrdでfirewireモジュールを読み込む(firewireのCD-ROMドライブ等利用者向け)</ti></tr>

	<tr><ti>dokeymap</ti>
	<ti>非USキーボード配列向けのキーマップ選択を有効にする</ti></tr>

	<tr><ti>dopcmcia</ti>
	<ti>pcmciaサービスを開始する</ti></tr>

	<tr><ti>doscsi</ti>
	<ti>SCSIデバイスをスキャンする(これにより動かなくなるイーサネットカードが存在する)</ti></tr>

	<tr><ti>noapm</ti>
	<ti>APMモジュールの読み込みを無効にする</ti></tr>

	<tr><ti>nodetect</ti>
	<ti>hwsetup/kudzuとhotplugによる検出をしない</ti></tr>

	<tr><ti>nodhcp</ti>
	<ti>ネットワークカードが検出されてもDHCPを実行しない</ti></tr>

	<tr><ti>nohotplug</ti>
	<ti>hotplugサービスの読み込みを無効にする</ti></tr>

	<tr><ti>noraid</ti>
	<ti>evmsモジュールの読み込みを無効にする</ti></tr>

	<tr><ti>nousb</ti>
	<ti>initrdでのUSBモジュールの読み込みとhotplugを無効にする</ti></tr>

	<tr><ti>ide=nodma</ti>
	<ti>DMAモードでうまく動かないIDEデバイスがある場合に、強制的にDMAを無効にする</ti></tr>

	<tr><ti>cdcache</ti>
	<ti>CDの中身をメモリにキャッシュする。メモリを40MB程度余分に使うが、umount /mnt/cdromし別のCDをマウントすることができる</ti></tr>

	</table></p>

	<p>Enterを押すと、ちょっとしゃれたブートスクリーンとプログレスバーが表示されます。</p>

	<figure link="/images/install/livecd-1.4-boot.png" caption="
	Gentoo Linuxがブートしているところ" />


	<p>ブートプロセスが完了すると、自動的に&quot;スーパーユーザ&quot;である&quot;<c>root</c>&quot;として&quot;Live&quot; Gentoo Linuxにログインします。
コンソールにはrootのプロンプト (&quot;<c>#</c>&quot;) が表示されるはずです。
ここでALT-F2、ALT-F3、ALT-F4を押すと別のコンソールに切り替えることができます。
最初のコンソールに戻るにはALT-F1を押します。
このとき画面はこんな風になっているはずです。</p>

	<figure link="/images/install/livecd-1.4-con.png" caption="The Gentoo
	Linux Live CD console" />

<note><b>上級者向け:</b>LiveCDがブートすると、LiveCD上のrootのパスワードは
ランダムな文字列に設定されます。
<c>sshd</c>を動かしてLiveCDにリモートからログインすることを考えているなら、
ここで<c>passwd</c>コマンドを使ってrootのパスワードを変更してください。
そうしないと、ネットワーク経由でログインするための正しいパスワードを知ることができません。</note>
	<p>既にお気づきかと思いますが、<c>#</c>プロンプトの上には、ネットワークの設定方法やGentoo Linuxの各ステージ圧縮ファイル、
パッケージのありかなどの説明が書かれたヘルプテキストが表示されています。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>補足的なハードウェア設定</title>
    <section>
      <body>
	<p>LiveCDは、起動すると全てのハードウェアを検出し、適切なカーネルモジュールを読み込もうとします。
	大抵の場合、これはうまく動作します。
	しかし、時には必要なモジュールが読み込まれないことがあります。
	ハードウェアの自動検知がうまくいかなかったら、適切なカーネルモジュールを手動でロードしなければなりません。
		利用可能なネットワークカードモジュールの一覧を見るには、
		<c>ls /lib/modules/`uname -r`/kernel/drivers/net/*</c>とタイプしてください。
		モジュールをロードするには、次のようにタイプします。</p>
<pre caption="PCIモジュール設定">
# <c>modprobe pcnet32</c>
<comment>(pcnet32を使っているNIC用のモジュール名に変えてください)</comment>
</pre>
	<p>同じように、PCI自動検知で検出されなかったSCSIデバイスにアクセスできるようにするには、
	もういちど<c>modprobe</c>を利用して<path>/lib/modules</path>から適切なモジュールをロードします。</p>
<pre caption="SCSIモジュールの読み込み">
# <c>modprobe aic7xxx</c>
<comment>(aic7xxxを使っているSCSIアダプタ用のモジュール名に変えてください)</comment>
# <c>modprobe sd_mod</c>
<comment>(sd_modはSCSIディスクサポートのためのモジュール)</comment>
</pre>
			<note> SCSI CD-ROMとハードディスクのサポートはカーネルに組み込まれています。</note>
			<note><b>上級者向け:</b>Gentoo LiveCDはディスクドライブのDMAを有効にするのでディスクの転送レートは最も速い状態になりますが、
			もしこれが有効にならなかったときは<c>hdparm</c>を使ってドライブにDMAを設定できます。
			<pre caption="DMA設定">
<comment>hdXを自分のシステムのディスクデバイス名に変えてください</comment>
# hdparm -d 1 /dev/hdX <comment>DMAを有効に</comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(DMAと、性能を上げる安全なオプションを有効に)</comment>
# hdparm -X66 /dev/hdX
<comment>(Ultra-DMAを有効に -- 危険! -- ドライブが壊れる恐れあり)</comment>
</pre>
 </note>

			
     </body>
    </section>
  </chapter>
  <chapter>
    <title>補足的なネットワーク設定</title>
	<section>
      <title>もう動いているかも?</title>
      <body>
		<p>あなたのシステムがイーサネットによってネットワークに接続されているならば、
		既にネットワークの設定が自動的に行なわれていることでしょう。
		その場合は、LiveCDに含まれる多くのネットワーク関連のコマンド、
		<c>ssh</c>や<c>scp</c>、<c>ping</c>、<c>irssi</c>、<c>wget</c>、<c>lynx</c>などを利用できます。</p>
	<p>ネットワーク接続できるようになっているなら、<c>/sbin/ifconfig</c>コマンドで<c>lo</c>と一緒に<c>eth0</c>などのネットワークインタフェースが表示されるはずです。</p>
<pre caption="/sbin/ifconfigでネットワークカードが動作しているか確認する">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
	<p>ISPのDNSサーバ(<path>/etc/resolv.conf</path>にアドレスが書かれているはずです)や、
	適当なWebサーバに対してpingを打ってみることで、パケットがネットワークに届くこと、
	DNSによる名前の解決がうまく機能していることなどを確かめることができます。</p>
<pre caption="ネットワークの確認">
# <c>ping -c 3 www.yahoo.com </c>
</pre>
		<p>ネットワークが使えるようになっていますか? それならば、残りは飛ばして次のセクションに進んでください。</p>
      </body>
    </section>
    <section>
      <title>PPPoE設定</title>
      <body>
	<p>インターネットへ接続するためにPPPoEが必要な場合、
	どのバージョンのLiveCDにも含まれている<c>rp-pppoe</c>を使うのが簡単です。
	<c>adsl-setup</c>スクリプトを使って接続の設定をしてください。
	adslモデムに接続しているイーサネットデバイスとユーザ名、パスワード、
	DNSサーバのIPアドレス、ファイアウォールが必要かどうか、を入力してください。</p>
<pre caption="PPPoE設定">
# <c> adsl-setup </c>
# <c> adsl-start </c>
</pre>
	<p>うまくいかないようなら、ユーザ名とパスワードを間違いなく入力しているかどうか、
	<path>/etc/ppp/pap-secrets</path>や<path>/etc/ppp/chap-secrets</path>を見てよく確認してください。
	また正しいイーサネットデバイスを指定しているかどうかも確認してください。</p>
      </body>
    </section>
    <section>
      <title>ネットワークの自動設定</title>
      <body>
       <p>自動的にネットワークが設定されなかった場合、いちばん簡単な設定方法は、<c>net-setup</c>スクリプトを実行することです。</p>
<pre caption="net-setupスクリプト">
# <c>net-setup eth0</c>
</pre>
	<p>もちろん、お好みであれば手動で設定することもできます。その方法は次で説明します。</p>
      </body>
    </section>
    <section>
      <title>手動でDHCPを使う</title>
      <body>
	<p>DHCPの設定は簡単です。ご利用のISPがDHCPをサポートしていない場合は、固定IPの設定まで進んでください。</p> 
<pre caption="DHCPを使ったネットワーク設定">
# <c>dhcpcd eth0</c>
</pre>
	<note>ISPによっては、ホスト名の入力が必要になります。
		その場合はdhcpcdコマンドの後に<c>-h myhostname</c>と書き加えてください。</note>
	<p>もし<i>dhcpConfig</i>警告を受け取ったとしても、慌てないでください。
		このエラーは重大なものではありません。ネットワークのテストまで進んでください。</p>
      </body>
    </section>
    <section>
      <title>手動で固定アドレスを設定する</title>
      <body>
	<p>システムの構築に必要なソースファイルをダウンロードすることができるようにネットワークを設定しなければなりません。
	そのために必要な情報は以下の表に示されているものです。</p>

<table>
<tr><th>項目</th><th>説明</th><th>例</th></tr>
<tr><ti>IPアドレス</ti><ti>ネットワークカードに割り当てたいIPアドレス</ti><ti>192.168.1.2</ti></tr>
<tr><ti>ブロードキャストアドレス</ti><ti>ローカルネットワークの全てのホストにパケットをブロードキャストするためのアドレス</ti><ti>192.168.1.255</ti></tr>
<tr><ti>ネットワークマスク</ti><ti>IPアドレスと一緒に使われ、アドレスのうちネットワークを識別する範囲とホストを識別する範囲を表現するために使われるマスク値</ti><ti>255.255.255.0</ti></tr>
<tr><ti>ゲートウェイ</ti><ti>ローカルネットワーク以外のアドレス(インターネット接続している場合など)にパケットを転送するためのコンピュータのアドレス</ti><ti>192.168.1.1</ti></tr>
</table>
        
		<p>システムの構築に必要なソースをダウンロードするために、ネットワークに対して適切な設定を行なう必要があります。
		下記のコマンドを入力してください。その際、$IFACEを使用するネットワークインターフェイス
		（たいていの場合<c>eth0</c>）に、$IPNUMを使用するIPアドレスに、
		$BCASTをブロードキャストアドレスに、$NMASKをネットワークマスクにそれぞれ置き換えてください。
		<c>route</c>コマンドでは、$GTWAYをデフォルトゲートウェイに置き換えてください。</p>
<pre caption="固定IPネットワーク設定">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</c>
</pre>
	<p>ここで、<path>/etc/resolv.conf</path>を作成し、
	名前解決(Webサイトや FTPサイトのIPアドレスを直接指定するのではなく名前で指定)できるようにします。
	<c>nano -w /etc/resolv.conf</c>として、<path>/etc/resolv.con</path>を作成できます。
	<c>nano</c>は小さくて操作の簡単なエディタです。</p>
	<p>以下に、/etc/resolv.conf作成の参考になるようにテンプレートを示します。</p>
<pre caption="/etc/resolv.conf テンプレート">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
	<p><c>10.0.0.1</c> と <c>10.0.0.2</c> をそれぞれプライマリDNSサーバとセカンダリDNSサーバのアドレスに書き換えてください。</p>
      </body>
    </section>
    <section>
      <title>プロクシ設定</title>
      <body>
	<p>プロクシを利用している場合は先に進む前にプロクシを利用する設定をしなければなりません。
		次のように環境変数を設定してください。</p>
<pre caption="プロキシ設定">
<codenote>プロキシがHTTPでの通信を制限している場合:</codenote>
# <c>export http_proxy=&quot;machine.company.com:1234&quot; </c>
<codenote>プロキシがFTPでの通信を制限している場合:</codenote>
# <c>export ftp_proxy=&quot;machine.company.com&quot; </c>
<codenote>プロキシがRSYNCでの通信を制限している場合:</codenote>
# <c>export RSYNC_PROXY=&quot;machine.company.com&quot; </c>
</pre>
      </body>
    </section>
        <section>
      <title>ネットワークの用意ができました!</title>
      <body>
	<p>これで、ネットワークの設定が終わって利用可能になったと思います。
		<c>ssh</c>、<c>scp</c>、<c>lynx</c>、<c>irssi</c>、<c>wget</c>コマンドを使って、LAN上のマシンやインターネットに接続することが可能です。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>システムの日付と時刻を合わせる</title>
    <section>
      <body>
	<p>ここで、システムの日付と時刻を合わせてください。
	<c>date</c>コマンドを使います。</p>
<pre caption="システム日付の調整">
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(時刻が合っていなかったら、次のようにして合わせる)</comment>
# <c>date 022709042003</c>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ファイルシステム、パーティション、そしてブロックデバイス</title>
    <section>
		<title>ブロックデバイスとは</title>
      <body>
<p>このセクションでは、Gentoo LinuxまたはLinux全般における、Linuxファイルシステム、
パーティション、ブロックデバイスなど、ディスクに関する事項を説明します。
ディスクに関する知識を得たところで、その後、
Gentoo Linuxのインストールをするためにパーティションおよびファイルシステムの作成手順を解説します。</p>
<p>まず初めに、"ブロックデバイス"を紹介しましょう。
最も馴染みのあるブロックデバイスはおそらく1番目のIDEドライブとしてLinuxに認識されているものでしょう。</p>
<pre caption="/dev/hdaはプライマリマスタIDEドライブを表すブロックデバイス">
/dev/hda
</pre>

<p>もしSCSIドライブを使っているなら、1番目のハードディスクは次のようになるかも知れません。</p>

<pre caption="/dev/sdaは1番目の論理SCSIドライブを表すブロックデバイス">
/dev/sda
</pre>

<p>上で見たようなブロックデバイスはディスクに対する<i>抽象的な</i>インタフェースを表します。
ユーザプログラムは、それがIDEなのかSCSIなのかといったことを気にすることなく、これらのデバイスを使うことができます。
プログラムは、多数の連続した、ランダムアクセス可能な512バイトブロックに単純にアドレッシングできます。</p>
</body>
</section>
<section>
<title>パーティションとfdiskコマンド</title>
<body>
<p>Linuxでは、<c>mkfs</c> (または <c>mke2fs</c>、<c>mkreiserfs</c>など)
にコマンドラインでブロックデバイスを指定して実行することで、ファイルシステムを作成します。</p>

<p>理論的には、"whole disk"ブロックデバイス(ディスク<i>全体</i>を表すもの)である、
<c>/dev/hda</c>や<c>/dev/sda</c>を使ってひとつのファイルシステムを格納することもできますが、
実際にはほとんどそのようにされることはありません。
ディスク全体を使うかわりに、もっと扱いやすい"パーティション"と呼ばれるブロックデバイスに分割します。
パーティションは<c>fdisk</c>と呼ばれる、パーティションテーブルを編集しそれぞれのディスクに書きこむツールを使って作成します。
パーティションテーブルはディスク全体がどのように分割されるのかを定義します。</p>

<p><c>fdisk</c>を使って、ディスクのパーティションテーブルを見てみます。ディスク全体を表すデバイスを指定してください:</p>

<note>パーティションテーブルを編集するには、他に<c>cfdisk</c>、<c>parted</c>、<c>partimage</c>などがあります。
最も機能豊富でUnix/Linuxの世界で良く知られている<c>fdisk</c>の利用をお勧めします。</note>

<pre caption="fdiskを起動する">
# fdisk /dev/hda 
</pre>
<p>または</p>
<pre caption="/dev/sdaのパーティションテーブルを確認するために、fdiskを起動する">
# fdisk /dev/sda
</pre>

<impo>ディスク内に使用中あるいは重要なデータを含んだパーティションがある場合は、
パーティションテーブルを保存したり変更したり<i>しない</i>ように注意してください。
このような操作でディスク内のデータが失われる恐れがあります。</impo>

<p>fdiskを実行すると、次のようなプロンプトが表示されます。</p>

<pre caption="fdiskのプロンプト">
Command (m for help): 
</pre>


<p>ディスクの現在のパーティションテーブルを表示するには<c>p</c>コマンドを使います。</p>

<pre caption="パーティション設定の一例">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>この例では、7つのLinuxファイルシステム("Linux"と表示)とスワップパーティション("Linux swap"と表示)が設定されています。</p>

<p>ここで、左側に表示されているそれぞれのパーティションの名前が、
<c>/dev/hda1</c>から始まって<c>/dev/hda9</c>まであることに注目してください。
かつては、パーティション作成ソフトウェアは最大4つのパーティション
("プライマリ"パーティションと呼ばれる)しか扱えませんでした。
これは厳しすぎる制限であったため、<i>拡張パーティション</i>と呼ばれるものが導入されました。
この拡張パーティションはプライマリパーティションとよく似ていて、同じく4つまでのパーティションを持つことができます。
しかし、拡張パーティションの中に、
論理パーティションとよばれるパーティションをいくつでも作成することができますので、
結局最大4つまでという制限を回避することができます。
</p>

<p><c>hda5</c>以降の全てのパーティションは論理パーティションです。
1から4まではプライマリまたは拡張パーティションのために予約されています。</p>

<p>つまり、この例では<c>hda1</c>から<c>hda3</c>はプライマリパーティションです。
<c>hda4</c>は拡張パーティションで、<c>hda5</c>から<c>hda9</c>を内包します。
<c>hda4</c>を直接<i>使って</i>ファイルシステムを作成することはできません。
<c>hda5</c>から<c>hda9</c>の入れ物となります。</p>

<p>それぞれのパーティションが"Id"、または"パーティションタイプ"と呼ばれるものを持っていることに気付いたでしょうか。
パーティションを作成したときには、パーティションタイプを正しく設定しているか確認してください。
'83'がLinuxファイルシステムのためのパーティションタイプです。'82'はLinuxスワップパーティションのためのパーティションタイプです。
'fd'はソフトウェアRAIDパーティションを作成するときの推奨パーティションタイプです。
<c>fdisk</c>コマンドでは<c>t</c>コマンドでパーティションタイプを設定することができます。
Linuxカーネルは、起動時にパーティションタイプの設定を使って、ファイルシステムとスワップデバイスを自動的に識別します。</p>
</body>
</section>
<section>
<title>fdiskを使ってパーティションを作成する</title>
<body>

<p>ここまで、Linuxでのパーティション作成について説明しました。
それでは自分でGentoo Linuxをインストールするためのパーティションを作成してください。
パーティションの作成が終わると、次のような表示になるでしょう。</p>

<pre caption="以下の手順を行なうと、次のようにパーティションテーブルが作成されます">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>"初心者"におすすめのパーティション設定は、3つのパーティションから成ります。
最初のパーティション(<c>/dev/hda1</c>)はディスクの先頭に作成された小さなパーティションで、ブートパーティションと呼ばれます。
ブートパーティションはブートに関係する重要なデータ、たとえばGRUBブートローダの設定やLinuxカーネルなどを保持するための領域です。
ブートパーティションはLinuxをブートさせるために必要なもの全てを安全に格納できます。
日常的な利用のときは、ブートパーティションをマウントしていない状態にしておくことで安全性を確保します。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda1</c>となるでしょう。</p>

<p>ブートパーティションは、ディスクの先頭の領域に作成することが推奨されています。
今となっては過去の制約でしかありませんが、
かつてliloブートローダがディスクの1024番目のシリンダ以降の領域にあるカーネルを読みこむことができなかった時代から続く伝統です。</p>

<p>2番目のパーティション(<c>/dev/hda2</c>)はスワップパーティションとして利用する領域です。
カーネルは物理メモリの空き容量が少なくなったとき、スワップスペースを仮想的なメモリとして使います。
このパーティションは他の領域と比較してとても大きいということはありませんが、標準的には512MB前後の大きさで作成されます。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda2</c>となるでしょう。</p>

<p>3番目のパーティション(<c>/dev/hda3</c>)は非常に大きく、ディスクの残りの領域すべてを使って作成されます。
このパーティションは"ルート"パーティションと呼ばれ、Gentoo Linuxそのものを格納するファイルシステムが入ります。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda3</c>となるでしょう。</p>


<p>パーティション作成を始める前に、Gentoo Linuxをインストールする時に推奨されている、
パーティションとファイルシステムの設定についてまとめておきます。</p>

<table>
	<tr>
	<th>パーティション</th>
	<th>サイズ</th>
	<th>タイプ</th>
	<th>例でのデバイス</th>
	</tr>
	<tr>
	<ti>ブートパーティション(カーネルとブートのために必要な情報を保持)</ti>
	<ti>32メガバイト</ti>
	<ti>ext2/3を強く推奨(最も容易なため)。ReiserFSを使うのであれば、<c>-o notail</c>を付けてマウントすること。ext3/ReiserFSを使うときは、ジャーナルのためのサイズも考慮すること。この場合は、64メガバイトが推奨となる。</ti>
	<ti>/dev/hda1</ti>
	</tr>
	<tr>
	<ti>スワップパーティション(128MBの制限はなくなり2GBまで可能)</ti>
	<ti>一般的に、システムに搭載している物理メモリの1〜2倍のサイズとする。</ti>
	<ti>Linux swap</ti>
	<ti>/dev/hda2</ti>
	</tr>
	<tr>
	<ti>ルートパーティション(/usr、/homeなど、主たるファイルシステム)</ti>
	<ti>&gt;=1.5ギガバイト</ti>
	<ti>ReiserFS/ext3を推奨。ext2でも良い。</ti>
	<ti>/dev/hda3</ti>
	</tr>
</table>

<p>それでは、先程の例と上に示した表に従ってパーティションを作成しましょう。
まず、<c>fdisk /dev/hda</c>(IDE)または<c>fdisk /dev/sda</c>(SCSI)と入力して、fdiskを起動します。
現在のパーティション設定を確認するため、<c>p</c>と入力します。
保存しておかなければならないものがこのディスクにありませんか?
もしあれば、<b>先に進まないでください。</b>
このままこの手順に従ってすすめると、ディスク上の全てのデータが消去されることになります。</p>

<impo>以下で説明する手順では、ディスク上の全てのデータが<b>削除されます</b>!
もしディスクにデータが入っているなら、失ってもかまわないものであることをよく確認してください。
また、うっかり違うドライブのデータを消してしまうことがないように、<b>正しいドライブを選択しているか</b>よく確認してください。</impo>

<p>では、すでにあるパーティションを削除します。<c>d</c>と入力してエンターキーを押してください。
すると何番のパーティションを削除するのか聞いてきます。<c>/dev/hda1</c>を削除するなら、次のようになります。</p>

<pre caption="パーティションの削除">
Command (m for help): d
Partition number (1-4): 1
</pre>

<p>パーティション削除が予定されました。
これによって<c>p</c>ではそのパーティションは表示されなくなりますが、パーティションテーブルを保存するまでは実際には削除されていません。
もし操作を間違ってしまい、変更を取り消したいときは、すぐに<c>q</c>と入力してエンターキーを押してください。</p>
<p>ディスクの全てのパーティションを削除する場合は、<c>p</c>でパーティションを確認して、
<c>d</c>で番号を指定してパーティションを削除することを繰り返してください。
最後には、全てのパーティションが削除されて、次のような表示になるでしょう。</p>

<pre caption="空のパーティションテーブル">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>これでメモリ上のパーティションテーブルは空の状態になり、ブートパーティションを作成する準備が整いました。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>1</c>と入力して1番目のプライマリパーティションを作成します。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、<c>+32M</c>と入力し、32MBのパーティションを作成します。
この手順では、次のように表示されたはずです。</p>

<note>ジャーナルを使うファイルシステムではジャーナル保持のためのスペースを必要とします。標準の設定では約33MBが必要です。
そのため、ジャーナルを使うファイルを<path>/boot</path>として使う場合は、<c>+64M</c>と入力してください。</note>

<pre caption="ブートパーティションを作成する手順">
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +32M
</pre>

<p><c>p</c>と入力してパーティションテーブルを表示してみてください。</p>

<pre caption="最初のパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

<p>次にスワップパーティションを作成します。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>2</c>と入力して2番目のプライマリパーティションを作成します。
この場合は<c>/dev/hda2</c>となります。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、<c>+512M</c>と入力し、512MBのパーティションを作成します。
さらに、パーティションタイプを設定するために<c>t</c>と入力し、
今作ったばかりの2番目のパーティションの<c>2</c>と入力し、
"Linux Swap"パーティションタイプの<c>82</c>を入力してください。
その後、<c>p</c>でパーティションテーブルを見ると次のようになるでしょう。</p>

<pre caption="スワップパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

<p>最後にルートパーティションを作成します。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>3</c>と入力して3番目のプライマリパーティションを作成します。
この場合は<c>/dev/hda3</c>となります。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、そのままエンターキーを押すことでディスクの最後を指定します。
その後、<c>p</c>でパーティションテーブルを見ると次のようになるでしょう。</p>

<pre caption="ルートパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>

<p>最後に、ブートパーティションに"ブート可能"フラグを設定し、これまで設定してきたパーティションテーブルをディスクに書きこみます。
<c>/dev/hda1</c>を"ブート可能"にするには、<c>a</c>と入力した後、ルートパーティションのパーティション番号1を入力します。
ここで<c>p</c>でパーティションテーブルを確認すると、<c>/dev/hda1</c>パーティションの"Boot"フィールドに<c>*</c>がついていることがわかるでしょう。
さて、いよいよディスクにパーティションテーブルを書き込みます。
そのためには、<c>w</c>と入力し、エンターキーを押します。
これで、Gentoo Linuxをインストールするための正しいパーティション設定ができました。</p>

<note><c>fdisk</c>や<c>cfdisk</c>から指示があったら、新しいパーティションを認識できるようにするため、コンピュータを再起動してください。</note>
</body>
</section>
<section>
<title>ファイルシステムの作成</title>
<body>
<p>パーティションを作りましたので、次にブートパーティションとルートパーティションにファイルシステムを作成し、
マウントしたりデータを保存したりできるようにします。
また、スワップパーティションを作成し、スワップ領域が使えるようにします。</p>

<p>Gentoo Linuxはいくつかのファイルシステムをサポートしています。
これらはそれぞれ、強み、弱みを持っており、性能にも特徴があります。
作成できるのは、ext2、ext3、XFS、JFSおよびReiserFSファイルシステムです。</p>

<p>ext2は枯れたLinuxファイルシステムですが、メタデータジャーナリングがありません。
そのため、システム起動時のファイルシステムチェックに長い時間がかかることがあります。
実は<i>ジャーナリング</i>を備えた、より新しいファイルシステムが存在し、
それは素早く整合性を確認できるので、ジャーナリングを備えていないext2より好まれているようです。
ジャーナリングファイルシステムではシステム起動時にファイルシステムに不整合が見つかっても、
待たされることがありません。</p>

<p>ext3はジャーナリングを備えたext2ファイルシステムで、メタデータジャーナリングによって、
素早い復旧だけでなく拡張ジャーナリングモードでfull dataとordered dataジャーナリングが可能です。
ext3は安定した信頼できるファイルシステムです。多くの場合、まずまずの性能を発揮します。
内部構造において&quot;ツリー&quot;のような仕組みを持たないため、条件によって性能が落ちることがあります。
大きなファイルシステムを作成するときや、大きなファイルを取り扱うとき、
またあるディレクトリに大量のファイルを格納するような場合には理想的な選択とは言えません。
しかし、極端な条件でなければ、ext3は優れたファイルシステムと言えます。</p>

<p>ReiserFSはB*-ツリーを基礎として作られたファイルシステムで、非常に良い性能を持っています。
小さなファイル(だいたい4kバイト未満)を扱うときは、ext2やext3よりも非常に高い性能を発揮し、
時には、10〜15倍にも達します。ReiserFSは大きなファイルシステムなどでも性能を発揮します。
メタデータジャーナリングも備えています。カーネル2.4.18以降、ReiserFSは非常に安定しており、
一般的な目的のファイルシステムはもちろん、大きなファイルや大量の小さなファイルを扱うような極端なケースにおいても推奨されます。
ReiserFSはブートパーティション以外ならいつでもお勧めします。</p>

<p>XFSはメタデータジャーナリングを備えたファイルシステムで、
Gentoo Linuxでは<path>xfs-sources</path>カーネルで完全にサポートされています。
堅牢な特徴を持ち、スケーラビリティを持つように最適化されています。
このファイルシステムはハイエンドのSCSI/fibreチャネルストレージと無停電電源装置を備えたシステムでのみ推奨します。
XFSは積極的に処理中のデータをメモリにキャッシュするため、間違った設計のプログラム
(ファイルをディスクに書き込むときに適切な予防措置を講じていない; そのようなプログラムが数多くあります)を走らせたときに、
不意のダウンによってデータが失われてしまう恐れがあります。</p>

<p>JFSはIBMのハイパフォーマンスジャーナリングファイルシステムです。
最近になって商利用に耐えるものになりましたが、充分な資料がないため、
その一般的な安定性については良いとも悪いともコメントできません。</p>

<p>もし、頑丈なジャーナリングファイルシステムが希望なら、ext3を選んでください。
汎用の高性能ファイルシステムがよければ、ReiserFSを選んでください。
ext3とReiserFSはどちらも成熟し洗練されていますのでお勧めです。</p>


<p>さきほど見た例に従うと、パーティションを初期化するコマンドは次のようになります。</p>

<pre caption="パーティションの初期化(参考例)">
# mke2fs -j /dev/hda1
# mkswap /dev/hda2
# mkreiserfs /dev/hda3
</pre>

<p>ブートパーティションの<c>/dev/hda1</c>はext3を選択しました。
堅牢なジャーナリングファイルシステムであるとともに、メジャーなブートローダがサポートしているからです。
スワップパーティションの<c>/dev/hda2</c>を初期化するには<c>mkswap</c>を使います。
これは明白ですね。
そして、メインのルートパーティションである<c>/dev/hda3</c>にはReiserFSを選びました。
頑丈なファイルシステムであり、素晴らしいパフォーマンスをもたらします。
それではパーティションを初期化しましょう。</p>

<p>参考までに、インストール中に利用可能な<c>mkfs</c>コマンドの仲間を紹介します。</p>

	<p><c>mkswap</c>はスワップパーティションを初期化するコマンドです:</p>
<pre caption="スワップの初期化">
# <c>mkswap /dev/hda2</c>
</pre>
<p><c>mke2fs</c>はext2ファイルシステムを作成します:</p>
<pre caption="ext2ファイルシステムの作成">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>ext3ファイルシステムを使うのなら、<c>mke2fs -j</c>コマンドを使います:</p>
<pre caption="ext3ファイルシステムの作成">
# <c>mke2fs -j /dev/hda3</c>
</pre>
	<note>Linux2.4でext3を使用する場合は以下のURLが参考になるでしょう。
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri></note>
        <p>ReiserFSファイルシステムの作成には<c>mkreiserfs</c>を使います:</p>
<pre caption="ReiserFSファイルシステムの作成">
# <c>mkreiserfs /dev/hda3</c>
</pre>
        <p>XFSファイルシステムには<c>mkfs.xfs</c>を使います:</p>
<pre caption="XFSファイルシステムの作成">
# <c>mkfs.xfs /dev/hda3</c>
</pre>
	<note><c>mkfs.xfs</c>コマンドに対し、<c>-d agcount=3 -l size=32m</c>オプションを付加することができます。
	<c>-d agcount=3</c>オプションはアロケーショングループの数を減らします。
	XFSは4Gバイトごとに少なくともひとつのアロケーショングループを必要とします。
	つまり、20Gバイトのパーティションがあった場合、最低でも5つのアロケーショングループが必要になります。
	<c>-l size=32m</c>オプションはジャーナルサイズを32Mバイトに増加させ、パフォーマンスを良くします。</note>

	<p>JFSファイルシステムの作成には<c>mkfs.jfs</c>を使います:</p>
<pre caption="JFSファイルシステムの作成">
# <c>mkfs.jfs /dev/hda3</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>パーティションをマウントする</title>
    <section>
      <body>
	<p>初期化が済んだスワップボリュームを有効にし、後で仮想メモリが必要になったときに使えるようにしておきます。</p>
<pre caption="スワップを有効にする">
# <c>swapon /dev/hda2</c>
</pre>

		<p>次に、<path>/mnt/gentoo</path>と<path>/mnt/gentoo/boot</path>というふたつのマウントポイントを設定し、そこにさきほど作成したパーティションをマウントします。
ブートファイルシステムとルートファイルシステムをマウントした後は、<path>/mnt/gentoo</path>の中に作成されたファイルはすべてそれらのファイルシステム内に格納されます。
もし<path>/usr</path>や<path>/var</path>などのファイルシステムを別々に作成している場合は、それぞれ、<path>/mnt/gentoo/usr</path>や<path>/mnt/gentoo/var</path>としてマウントしてください。
</p>
		<impo> <e>boot</e>パーティション(カーネルを保持しているパーティション) がReiserFSである場合、GRUBが正常にインストールされるように<c>-o notail</c>オプションを使ってマウントしてください。
		さらに<path>/etc/fstab</path>のbootパーティションに<c>notail</c>オプションを追加してください。
		これについてはまたあとで説明します。もしReiserFSでLILOを使う場合は、<c>-o notail</c>オプションは必要ありません。
		どんな場合でも<c>-o notail</c>オプションは安全です。</impo>

<pre caption="マウントポイントの作成">
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
</pre>

		<impo>もしext2のbootパーティションをマウントするときに問題が発生したら、<c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>を試してみてください。</impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ圧縮ファイルとchroot</title>
    <section>
		<title>ステージ圧縮ファイルの選択</title>
      <body>

<p>もしまだなら、ここでどのステージ圧縮ファイルを使うか決めなければなりません。
ステージ圧縮ファイルはCDの<path>/mnt/cdrom/gentoo</path>にあります。
<c>ls /mnt/cdrom/gentoo</c>とすれば、何が利用可能か確認できます。</p>

<p><b>GRPユーザ</b>は<path>stage3-xx-yy.tar.bz2</path>を使ってください。</p>
<p>もしCD上に無い圧縮ファイルを使うのならば("basic" LiveCDを使う場合などがそうです)、以下の手順に従ってダウンロードをしなければなりません。
もし圧縮ファイルを既に持っていてダウンロードの必要がなければ(ほとんどの人がそうでしょう)、&quot;ステージ圧縮ファイルの展開&quot;に進んでください。</p>

<pre caption="必要なステージの圧縮ファイルのダウンロード">
# <c>cd /mnt/gentoo</c>
<comment>lynxを使って、圧縮ファイルのURLを確認してください。</comment>
# <c>lynx http://gentoo.oregonstate.edu/releases/x86/1.4/</c>
<comment>矢印キーの<c>上</c>と<c>下</c>(あるいは<c>タブキー</c>)を使って希望する圧縮ファイルのあるディレクトリに移動してください。
カーソルをダウンロードしたいステージファイルに合わせ、<c>d</c>を押すとダウンロードが始まります。
ファイルに保存してブラウザを終了してください。

<b>あるいは</b>コマンドラインでwgetを使ってダウンロードすることもできます。</comment>
# <c>wget <comment>ここに必要な圧縮ファイルのURLを指定してください。</comment></c>
</pre>
      </body>
    </section>
    <section>
		<title>ステージ圧縮ファイルの展開</title>
      <body>

<p>ここで、選択した圧縮ファイルを<path>/mnt/gentoo</path>に展開します。
展開するのはステージ1、ステージ2、ステージ3のいずれか<b>ひとつ</b>だけです。
つまり、ステージ3からインストールするのであれば、ステージ3圧縮ファイルを展開してください。</p>
<impo><c>tar</c>する時は必ず<c>p</c>オプションを使用してください。
これを怠ると、いくつかのファイルに誤ったパーミッションを与えてしまいます。</impo>

<pre caption="圧縮ファイルの展開">
# <c>cd /mnt/gentoo</c>
<comment>選択した圧縮ファイルに合わせて、&quot;stage3&quot;を&quot;stage2&quot;や&quot;stage1&quot;に変えてください。</comment>
<comment>ダウンロードした圧縮ファイルを使うときは、パスの先頭が&quot;/mnt/cdrom/stages/&quot;ではなく&quot;/mnt/gentoo/&quot;になります。</comment>
# <c>tar -xvjpf /mnt/cdrom/stages/stage3-*.tar.bz2</c>
</pre>

<p><path>/mnt/gentoo</path>にダウンロードされた圧縮ファイルは、展開したあとで次のように入力して削除することができます: <c>rm /mnt/gentoo/stage*.tar.bz2</c></p>
</body>
</section>
<section>
<title>GRPパッケージ/スナップショットの展開</title>
<body>
<impo>以下の手順はGRPユーザ用です。</impo>
<p><b>GRPユーザ</b>: LiveCDにはPortageのスナップショットが入っています。
これを使うことで、後でこの文書で出てくる<c>emerge sync</c>(ネットワーク接続が必要)のステップを飛ばすことができます。以下のようにして展開してください。</p>
<pre caption="Portageスナップショットの展開">
<comment>yyyymmddには日付が入ります。</comment>
# <c>tar -xvjf /mnt/cdrom/snapshots/portage-yyyymmdd.tar.bz2 -C /mnt/gentoo/usr</c>
</pre>
<p>これで、Portageツリーのスナップショットを展開することができます。
<c>emerge sync</c>のためにネットワークに接続する必要はありません。
次に、distfilesとpackagesをLiveCDからコピーします。</p>

<pre caption="GRPファイルのコピー">
# <c>cp -R /mnt/cdrom/distfiles /mnt/gentoo/usr/portage/distfiles</c>
# <c>cp -a /mnt/cdrom/packages/* /mnt/gentoo/usr/portage/packages/</c>
</pre>

<p>GRPに必要なファイルをすべて所定の位置にコピーできました。
これでネットワーク接続なしでGentoo Linuxのインストールために必要なものが揃いました。</p>

</body>
</section>
<section>
<title>chrootの実行</title>
<body>
<p>次にGentoo Linuxのインストールを進めていくために、<c>chroot</c>を使ってGentoo Linuxシステムに「入り」ます。</p>

<note><c>env-update</c>を実行したときに<path>/etc/make.profile/make.defaults</path>が利用できないというメッセージが表示されますが、無視してください。
あとで<c>emerge sync</c>を実行しますが、それによってこの問題は解消します。</note>

<pre caption="下準備してchroot環境に入る">
# <c>mount -t proc proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
<comment>(上のコマンドはシェルに新しい検索パスを設定し更新されたバイナリが使えるようにする)</comment>
</pre>
	<p>このコマンドを実行すれば<path>/mnt/gentoo</path>に作成されたGentoo Linux環境の「中」に入ることができます。
		以下の手順はこのchroot環境内で進めます。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最新のPortage ツリーを取得する</title>
    <section>
      <body>

<!-- This is not yet implemented. Uncomment when it is!

<p>In order to maximize the downloadspeed, you should now select rsync- and distfiles mirrors. To simplify this task, we have a tool called <c>mirrorselect</c>. Issue the following two commands:</p>

<pre caption="Selecting a mirror">
<comment>First we have mirrorselect select 5 close mirrors for us.</comment>
# <i>mirrorselect -a -s5</i>
<comment>Now we select an rsync-mirror ourselves:</comment>
# <i>mirrorselect -i -r</i>
</pre>

-->



<impo>GRPインストールをする場合は、以下の<c>emerge sync</c>に関するセクションは飛ばしてください。</impo>

<p>ここで、<c>emerge sync</c>を実行してください。これにより、
インターネットを通じて最新のPortageツリーを取得できます。
もしPortageツリーを"CD 1"のスナップショットから展開しているなら、このステップを飛ばして次に進んでください。
Portageツリーには、Gentoo Linuxでパッケージを構築するための全てのスクリプト(ebuildと呼びます)が収められています。
現在、4000パッケージ近くのebuildスクリプトがあります。
<c>emerge sync</c>が完了すると、<path>/usr/portage</path>以下に完全なPortageツリーが格納されます。</p>

<pre caption="syncを使って更新する">
# <c>emerge sync</c>
</pre>
 
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentooシステムの最適化オプションを設定する(make.conf)</title>
    <section>
      <body>

<p>Portageツリーをコピーできたので、次に最適化とパッケージ構築の設定をします。
Portageはどんなプログラムをコンパイルするときでもこの設定を使います。
設定するには<path>/etc/make.conf</path>ファイルを編集します。
このファイルでは、パッケージに組み込みたい機能を指定するUSE変数やをセットしてください。
一般的にはデフォルト（空かセットなし）でいいでしょう。
<c>USE</c>フラグに関しては、<uri link="/doc/en/use-howto.xml">ここ</uri>(<uri link="/doc/ja/use-howto.xml">日本語訳</uri>)に詳しい説明があります。
現在の全USEフラグのリストは<uri link="http://www.gentoo.org/dyn/use-index.xml">ここ</uri>にあります。</p>
<p>ステージ1の圧縮ファイルを使って始めた方は、お使いのハードウェアに合わせて、<c>CHOST</c>、<c>CFLAGS</c>、<c>CXXFLAGS</c>変数もそれぞれセットしてください
(ファイルの下の方に設定例が載っています)。ステージ2または3を使って始めた方は、
これらの設定は既に済んでいますので、変更の必要はありません。</p>

<impo><b>上級者向け:</b> <c>CFLAGS</c>と<c>CXXFLAGS</c>の設定は、
CとC++コンパイラが生成するコードの最適化などを指定するオプションとして使われます。
例えば、Athlon XPプロセッサを使っているユーザはCFLAGSとCXXFLAGSに&quot;-march=athlon-xp&quot;を設定するのが一般的です。
これによって、そのCPUに適した命令セットを使って最適化されたパッケージを構築できます。
<path>/etc/make.conf</path>には、正しくCFLAGSとCXXFLAGSを設定するための一般的な解説が書かれています。</impo>
<!-- needs qa
<note><b>Advanced users:</b>If you are building from a stage1 and don't want
to manually configure CFLAGS and CXXFLAGS, you can use the <c>genflags</c>
utility, which will try to guess accurate flags for your CPU architecture.
Simply type <c>emerge -O genflags</c> and then execute
<c>info2flags</c>. <c>info2flags</c> will suggest CHOST, CFLAGS, and
CXXFLAGS settings, which you can then add to
<path>/etc/make.conf</path>.</note>
-->

<p>ファイアウォールが設置されている場合はここでプロクシ情報をセットできます。
<path>/etc/make.conf</path>を編集するには、<c>nano</c>というシンプルなスクリーンエディタが使えます。</p>
<pre caption="make.confを編集する">
# <c>nano -w /etc/make.conf</c>
</pre>
		<note><b>上級者向け:</b> ビルドプロセスに手を加えたいときは、<path>/etc/make.globals</path>を参照してください。
		このファイルは、Gentooで使われるデフォルト値を保持しており、書き換えないようにすべきです。
		デフォルトで不十分な場合は、新しい値を<path>/etc/make.conf</path>に書き込んでください。
		<path>make.conf</path>で指定された値は、<path>make.globals</path>の設定を<comment>上書き</comment>します。
		ここで見つけたUSE設定を無効にしたいときは、適切な<c>USE=&quot;-foo&quot;</c>(<c>foo</c>を無効にしたい場合)を/etc/make.confに追加してください。</note>
       <warn>ステージ1が終了するまでは、'<c>static</c>'を<c>USE</c>に加えないでください。</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ１から始める場合</title>
    <section>
      <body>
		<note>ステージ1から始める人以外は、このセクションを飛ばしてください。</note>
		<p>ステージ1圧縮ファイルを使うと徹底的にカスタマイズと最適化をすることができます。
		この圧縮ファイルを選択したのは、最適化された最新のシステムを求めているからだと思います。
		お楽しみください。
		ステージ1からのインストールには長い時間がかかりますが、その見返りとして特定のマシンとニーズに合わせ隅々まで最適化されたシステムを手に入れることができます。</p>
		<p>「ブートストラップ」プロセスを開始します。
		AMD Athlon 1200Mhzで約2時間かかります。
		このプロセスでは、残りのシステムをコンパイルするために、展開されたビルドイメージが準備されます。
		GNUコンパイラ一式とGNU Cライブラリが構築されます。
		これらは時間がかかる処理で、ブートストラッププロセスの大半が構成されます。
		以下のようにしてブートストラップを始めてください。</p>
<pre caption="ブートストラッピング">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
</pre>
	<p>これで「ブートストラップ」プロセスが始まります。</p>
	<note><c>bootstrap.sh</c>に<c>--fetchonly</c>オプションが追加されました。
	ダイアルアップ回線を使っている人などに便利な機能です。
	ブートストラップに関係するファイルを一度にまとめてダウンロードしてから、コンパイルを始めることができます。
	<c>bootstrap.sh -h</c>でヘルプが表示されます。</note>
	<note>デフォルトのPortageはパッケージのビルド中に一時的に<c>/var/tmp</c>を数百Mバイト使用する時があります。
		一時ファイルの場所を変更している場合は、<e>ブートストラッププロセスを始める前に</e>PORTAGE_TMPDIR変数を変更してください。</note>
<pre caption="Portageの作業ディレクトリの設定">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
</pre>
		<p><c>bootstrap.sh</c>は<c>binutils</c>、<c>gcc</c>、<c>gettext</c>、<c>glibc</c>を構築し、<c>glibc</c>が構築された後、<c>gettext</c>を再構築します。
		言うまでもなく、このプロセスには時間がかかりますので、昼寝でもしていてください。
		このプロセスが終了すると&quot;ステージ2&quot;から始めたシステムと同じ状態になります。次に進んでください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ２から始める場合、あるいはステージ１からの続き</title>
    <section>
      <body>
	  	
		<note>このセクションはステージ1かステージ2から始めた人が対象ですので、ステージ3から始める人は次のセクションに進んでください。</note>
        <warn>ステージ2から始める場合は、
        <path>/etc/make.conf</path>内のCHOSTの値を変えないでください。
	変えてしまうと、おかしな状態になったり、コンパイルに失敗したりします。
	これについて、改善するように現在作業中です。</warn>
		
		<p>ステージ2の圧縮ファイルを使うと、既にブートストラップが済んだ状態から始めることができます。
		残りのシステムのインストールを始めましょう。</p>
		<note>ステージ2から始めた場合は、ここでコンパイラ一式が最新の状態になるようにできます。
		以下のコマンド(<c>emerge</c>)に<c>-u</c>オプションを付けてください。
		これがどういう意味か判らないなら、この注釈は無視して構いません。</note>

<pre caption="残りのシステムをインストールする">
# <c>emerge -p system</c>
<comment>(インストールされるパッケージが一覧表示される)</comment>
# <c>emerge system</c>
</pre>
		<p>ベースシステム全体を構築するにはまとまった時間が必要です。
		そのかわりシステムは徹底的に最適化されます。
		もちろん暇つぶしの方法を見いださなければなりませんが。
		作者はプレイステーション2用ソフト「Star Wars - Super Bombad Racing」をおすすめします。</p>
		<p>システムの構築は終了しました。&quot;タイムゾーン設定&apos;に進んでください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ３から始める場合</title>
    <section>
      <body>
		<note>このセクションはステージ3から始める人に向けたものですので、それ以外の人は次のセクションに進んでください。GRPを使ってインストールする人も次のセクションに進んでください。</note>
        <warn>
	<path>/etc/make.conf</path>内のCHOSTの値を変えないでください。
	変えてしまうと、おかしな状態になったり、コンパイルに失敗したりします。
	</warn>
		<p>ステージ3の圧縮ファイルは完全に機能する基本的なGentoo Linuxシステムを含んでいますので、構築の手順は不要です。</p>

	 <note><b>上級者向け:</b>
		ただし、あらかじめコンパイルされたものですので、最新ではなくなっているかも知れません。
		もし気になるようなら、
		<c>export CONFIG_PROTECT="-* /etc/make.conf" emerge -u	system</c>
		(この処理を行なうにはネットワーク接続が必要になります)を実行することで、
		自動的に現在のステージ3システムを最新バージョンのパッケージで置き換えることができます。
		ステージ3圧縮ファイルが古い場合、この処理には長い時間がかかるかもしれません。
		そうでなれば、一般的には短時間で最新バージョンへのアップデートやバグフィクスされたパッケージが得られます。
		なお、これらの手順を踏まずに次のセクションに進んだとしても、なんの問題もありません。</note>
		
      </body>
    </section>
  </chapter>
  <chapter>
    <title>タイムゾーン設定</title>
    <section>
      <body>
	<p>ここではタイムゾーンの設定を行ないます。</p>
	<p><path>/usr/share/zoneinfo</path>のなかからタイムゾーン（グリニッジ標準時を使用するならGMT）を選んでシンボリックリンクを作成してください。</p>
<pre caption="タイムゾーンを設定するためにシンボリックリンクを作成する">
# <c>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>カーネルとシステムロガーのインストール</title>
    <section>
		<title>カーネルの選択</title>
      <body>
	<p>カーネルのインストールには2通りのやり方があります。
	自分でカーネルの設定をすることもできますし、<c>genkernel</c>ユーティリティを使って設定とコンパイルを自動的に実行することもできます。</p>

	<p>手動であれ、<c>genkernel</c>であれ、まずお好みのLinuxカーネルソースをemergeしなければなりません。
	Gentooはカーネルのebuildを何種類か用意しています。一覧が<uri link="/doc/en/gentoo-kernel.xml">Gentoo Linuxカーネルガイド</uri>(<uri link="/doc/ja/gentoo-kernel.xml">日本語訳</uri>)で確認できます。
	どのカーネルソースを選べばよいかわからなければ、<c>gentoo-sources</c><!--か<c>vanilla-sources</c> (2.4.21-vanilla has sound issues)-->にすると良いでしょう。
	XFSサポートが必要なら、<c>xfs-sources</c>か<c>gs-sources</c>を選んでください。
	ちなみに、GentooのLiveCDは<c>xfs-sources</c>と<c>gs-sources</c>を使っています。
	他に、ゲームをする人に適した<c>gaming-sources</c>があり、"Preemptible kernel"オプションが有効になっていれば素晴らしい応答性が得られます。
</p>
<p>カーネルを選択し、次のようにしてemergeしてください。</p>
<pre caption="カーネルソースをemergeする">
# <c>emerge -k sys-kernel/gentoo-sources</c>
</pre>

		<p>
		<path>/usr/src/linux</path>シンボリックリンクは
		新しくインストールされたソースツリーを指しています。 
		Portageは<path>/usr/src/linux</path>シンボリックリンクを特別な意味を持つファイルとして扱います。
		カーネルモジュールをインストールするようなebuildは
		<path>/usr/src/linux</path>シンボリックリンクで示されたカーネルソースツリーを使って設定されます。
		Portageは初めてカーネルソースをインストールするとき<path>/usr/src/linux</path>
		を作成しますが、既にこのシンボリックリンクが作成されているときは何もしません。</p>
</body>
</section>
<section>
	<title>genkernelを使ってカーネルを構築する</title>
<body>

		<p>カーネルソースツリーがインストールされました。続いてカーネルをコンパイルします。
		これには2種類の方法があります。一つは新しく用意された<c>genkernel</c>スクリプトを使って自動的にカーネルを構築する方法です。
		<c>genkernel</c>はLiveCDのカーネルとほぼ同じようにカーネルを設定して構築します。
		つまり、<c>genkernel</c>を使ってカーネルを構築すると、ブート時にはLiveCDと同じようにハードウェアを検出してくれます。
		<c>genkernel</c>は全自動なので、カーネルの設定に不慣れな人などにとって、最もよい解決法となるでしょう。</p>

		<p>では、<c>genkernel</c>の使いかたを説明しましょう。まずは、<c>genkernel</c>をemergeします。</p>

<pre caption="genkernelをemergeする">
# <c>emerge -k genkernel</c>
</pre>
		
		<p>では、<c>genkernel</c>と入力して、カーネルの構築を始めてください。</p>

		<note><b>上級者向け:</b> <c>genkernel --config</c> と入力すると、
		カーネルの構築を始める前にデフォルトの設定をいじることができます。</note>


<pre caption="genkernelの実行">
# <c>genkernel</c>
Gentoo Linux genkernel, version 1.4
 Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
 Distributed under the GNU General Public License version 2

Settings:
 compile optimization: 1 processor(s)
 source tree: /usr/src/linux-2.4.20-gaming-r3
 config: gentoo (customized)
 config loc: /etc/kernels/config-2.4.20-gaming-r3
 initrd config: (default) /etc/kernels/settings

 * Running "make oldconfig"...                                                                     [ ok ]
 * Logging to /var/log/genkernel.log...                                                            [ ok ]
 * Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
 * Running "make dep"...                                                                           [ ok ]
 * Running "make bzImage"...                                                                       [ ok ]
 * Running "make modules"...                                                                       [ ok ]
 * Running "make modules_install"...                                                               [ ok ]
 * Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
 * Building busybox...                                                                             [ ok ]
 * Creating initrd...                                                                              [ ok ]

 * Build completed successfully!

 * Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
 * when customizing your boot loader configuration files.

#
</pre>

		<p><c>genkernel</c>が終了すると、カーネル、モジュール一式、、<i>initial root disk</i> (initrd)ができあがります。カーネルとinitrdはブートローダの設定をするときに使います。
		initrdは"実際"のシステムが起動する前の、ブート開始直後ににハードウェアを検出するために使われます(LiveCDと同じです)。</p>

		<p>では、さらにLiveCDの動作に近づけるために、更に手順を進めましょう。hotplugのemergeです。
		initrdはブートするために必要なハードウェアを検出するものですが、hotplugはその他あらゆるものを検出します。
		hotplugをemergeするには、次のように入力してください。</p>

<pre caption="hotplugをemergeし有効にする">
# <c>emerge -k hotplug</c>
# <c>rc-update add hotplug default</c>
</pre>

		<p>最後に、あなたのシステム上のハードウェアに必要なパッケージをemergeしてください。
		カーネルに関係するebuildを一覧にして示します。</p>

		<table>
		<tr>
			<th>ebuild</th>
			<th>用途</th>
			<th>コマンド</th>
		</tr>
		<tr>
			<ti>nvidia-kernel</ti>
			<ti>XFree86用NVIDIAグラフィック高速化モジュール</ti>
			<ti><c>emerge -k nvidia-kernel</c></ti>
		</tr>
		<tr>
			<ti>nforce-net</ti>
			<ti>NVIDIA nForce(2)マザーボード上のオンボード・イーサネットコントローラ用</ti>
			<ti><c>emerge nforce-net</c></ti>
		</tr>
		<tr>
			<ti>nforce-audio</ti>
			<ti>NVIDIA nForce(2)マザーボード上のオンボード・オーディオ用</ti>
			<ti><c>emerge nforce-audio</c></ti>
		</tr>
		<tr>
			<ti>e100</ti>
			<ti>Intel e100 Fast Ethernet Adapter用</ti>
			<ti><c>emerge e100</c></ti>
		</tr>
		<tr>
			<ti>e1000</ti>
			<ti>Intel e1000 Gigabit Ethernet Adapter用</ti>
			<ti><c>emerge e1000</c></ti>
		</tr>
		<tr>
			<ti>emu10k1</ti>
			<ti>Creative Sound Blaster Live!/Audigyのサポート</ti>
			<ti><c>emerge emu10k1</c></ti>
		</tr>
		<tr>
			<ti>ati-drivers</ti>
			<ti>XFree86用ATI RADEON 8500+/FireGLグラフィック高速化モジュール</ti>
			<ti><c>emerge ati-drivers</c></ti>
		</tr>
        <tr>
            <ti>xfree-drm</ti>
            <ti>XFree86用にATI RADEON 9200以降、RAGE128、
            Matrox、Voodooなどのカードを高速化するモジュール</ti>
            <ti><c>VIDEO_CARDS="yourcard" emerge xfree-drm</c></ti>
        </tr>
</table>
		<p>nvidia-kernel、ati-drivers、xfree-drmパッケージは有効にするために更に設定が必要です。
		他のebuildはhotplugによってブート時に自動検出されます。</p>

		<p><c>genkernel</c>を使った人は、次の"手動でのカーネル設定"は飛ばしてください。</p>
</body>
</section>
<section>
<title>手動でのカーネル設定</title>
<body>

	<p><c>genkernel</c>によるカーネルの構築を選ばなかった方には、
	このセクションでカーネルを手動で設定して構築するための手順を解説します。
	<path>/usr/src/linux</path>がemergeされたカーネルソースへのシンボリックリンクになってることに注意してください。
	これはPortageによって自動的に作成されます。
	もし複数のカーネルソースをemergeしているなら、適切なカーネルソースへのリンクになっているかどうかを確認する必要があります。</p>

<warn>自分でカーネルを設定して使う場合は、<i>grsecurity</i>オプションに注意してください。
セキュリティの設定をきつくしすぎると、いくつかのプログラム(たとえばX Windowなど)が正常に動作しなくなる恐れがあります。
必要かどうかわからない場合は、無効にしておきましょう。</warn>
	<note>カーネルの設定をLiveCDと同じにしたい、あるいはLiveCDの設定を元にしたい場合は、次のようにしてください:
	<c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c> 。
	なお、<c>xfs-sources</c>以外のカーネルを使っている場合は、
	選んだカーネルと<c>xfs-sources</c>とで異なる部分に関して、いくつか質問に答える必要があるかもしれません。</note>
<pre caption="Linuxカーネルの設定">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
</pre>
	<warn>カーネルを正常に機能させるために必要なオプションが正しくカーネルに組み込まれているかどうかを確認してください。
	つまり、これらは<i>有効でかつモジュールではない状態</i>でコンパイルされねばなりません。
	ReiserFSファイルシステムを使用している場合は ReiserFSオプションを有効にします。&quot;Ext3&quot;も同様です。
	XFSファイルシステムを使用している場合は&quot;SGI XFS filesystem support&quot;オプションを有効にします。
	どのような場合でも&quot;Ext2&quot;オプションを有効にしておくと良いでしょう。
	以下に必要となるであろう、一般的なオプションの一覧を示します。</warn>
<pre caption="重要なカーネルオプション">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(下に示したオプションのうち、いくつかはこれを有効にしないと現れない)</comment>
     ...

File systems ---&gt;
  &lt;*&gt; Reiserfs support
<comment>(ReiserFSを使うときに必要)</comment>
       ... 
  &lt;*&gt; Ext3 journalling file system support
<comment>(ext3を使うときに必要)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Gentoo Linuxでは必須)</comment>
       ...
  &lt;*&gt; JFS filesystem support
<comment>(JFSを使うときに必要)</comment>
       ...
  [*] /proc file system support
<comment>(Gentoo Linuxでは必須)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot          
<comment>(Gentoo Linuxでは必須)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(不要なのでチェックを外す)</comment>
       ...
  &lt;*&gt; Second extended fs support
<comment>(ext2を使うときに必要)</comment>
       ...
  &lt;*&gt; XFS filesystem support
<comment>(XFSを使うときに必要)</comment>
</pre>
		<p>インターネット接続にPPPoEを使っているなら、以下のオプションを選択してください(ビルトインか、できればモジュール)。
		&quot;PPP (point-to-point protocol) support&quot;、 &quot;PPP support for async serial ports&quot;、&quot;PPP support for sync tty ports&quot;。
		これらの2つの圧縮に関するオプションは組込まれても害はありませんが不要です。
		&quot;PPP over Ethernet&quot;オプションも、<i>rp-pppoe</i>がカーネルモードPPPoEをで動作するときに利用されるだけです。</p>
		<p>もし、IDE CD-Rを使うならば、SCSIエミュレーションを利用できるようにしてください。
		&quot;ATA/IDE/MFM/RLL support&quot; ---> &quot;IDE, ATA and ATAPI Block devices&quot; ---> &quot;SCSI emulation support&quot;をチェックしてください（筆者はいつもモジュールとしてインストールします）。
		そして&quot;SCSI support&quot;の&quot;SCSI support&quot;、&quot;SCSI CD-ROM support&quot;と&quot;SCSI generic support&quot;をチェックしてください（これも筆者はいつもモジュールとしてインストールします）。
		モジュールとしてインストールしたならば、<c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot; >> /etc/modules.autoload</c>として、ブート時に読み込まれるようにしてください。</p>
	<p>忘れずに、必要なイーサネットカードのサポートをカーネルに組込んでください。</p>
		<note> 2.2カーネルベースのGentoo Linuxをインストールすることもできます。
		安定性と引き換えに 2.4カーネルの素晴らしい特徴（XFSファイルシステムとtmpfsファイルシステムやiptablesなど）が使えなくなります。
		ただし、 ReiserFSファイルシステムやdevfsはパッチを当てることで使えるようにできます。 
		Gentoo LinuxのブートスクリプトはtmpfsかRAMディスクのどちらかを必要としますので、2.2カーネルを使用する際にはRAMディスクサポートを組み込んでください（モジュールではなく）。
		<comment>必ず</comment><path>/boot/grub/grub.conf</path>ファイルに<e>gentoo=notmpfs</e>と記述して、RAMディスクをtmpfsのかわりにブートスクリプトにマウントしてください。
		devfsを使わないならば<e>gentoo=notmpfs,nodevfs</e>と記述してください。</note>

<pre caption = "カーネルのコンパイルとインストール">
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
</body>
</section>
<section>
<title>システムロガーのインストール</title>
<body>
		<p>これでカスタマイズされたカーネル(とモジュール)がインストールされました。
		続いて、インストールしたいシステムロガーを選んでください。
		伝統的なシステムロギングデーモンのsysklogdが利用できます。
		またmsyslog、syslog-ng、metalogも選択できます。
		パワーユーザはsysklogd(パフォーマンスがあまりよくありません)を離れ、
		より新しい別の選択肢を好むようです。
		どれにするか迷っているなら、多くの人が使っているようなのでmetalogを選んでもよいでしょう。
		次の4つのロガーからひとつを選んでください。</p>
<pre caption="システムロガーを選択しemergeする">
# <c>emerge -k app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>または</comment>
# <c>emerge -k app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>または</comment>
# <c>emerge -k app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>または</comment>
# <c>emerge -k app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
</pre>
		<impo> metalogは一括して出力をディスクに流し込みます。
		そのため、システムログが継続的に記録されるわけではありません。
		デーモンのデバッグを行なう時には、このパフォーマンス向上のための動作はかえって邪魔になるでしょう。
		Gentoo Linuxでは、一時的にメッセージバッファを止めるために（<i>tail -f <path>/var/log/everything/current</path></i>コマンドがリアルタイムで実行されることを期待して）metalogデーモンにUSR1信号を送ることができます。
		メッセージバッファを働かせるためにはUSR2信号を送ってください。
		常にバッファリングを無効にするには、<path>/etc/conf.d/metalog</path>の中のMETALOG_OPTS="-B"をMETALOG_OPTS="-B -s"に書き換えてください。</impo>
<pre caption="metalogのバッファリングを制御する">
<codenote>バッファリングを無効にする</codenote>
# <c>killall -USR1 metalog</c>
<codenote>バッファリングを有効にする</codenote>
# <c>killall -USR2 metalog</c>
</pre>
		<p>次にdcron、fcron、vcronの中から好みのcronを選んでください。
		どれを選べば分からない時はvcronをおすすめします。
		次のようにインストールしてください。</p>
<pre caption="cronデーモンを選択する">
# <c>emerge -k sys-apps/dcron</c>
# <c>rc-update add dcron default</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge -k sys-apps/fcron</c>
# <c>rc-update add fcron default</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge -k sys-apps/vcron</c>
# <c>rc-update add vcron default</c>
<comment>vcronを使う場合は、<c>crontab /etc/crontab</c>する必要はありません。</comment>
</pre>
		<p>起動時に実行されるプログラムやデーモンに関しては、<uri link="/doc/en/rc-scripts.xml">rc-script guide</uri>(<uri link="/doc/ja/rc-scripts.xml">日本語訳</uri>)を参照してください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>必要なパッケージのインストール</title>
    <section>
      <body>
	<p>もしネット接続にrp-pppoeが必要なら、まだインストールされていませんので、ここでインストールしてください。</p>
<pre caption="rp-pppoeのインストール">
# <c>USE="-X" emerge rp-pppoe</c>
<comment>GRPを使うユーザは以下のように入力してください:</comment>
# <c>USE="-X bindist" emerge -K rp-pppoe</c>
</pre>

		<note><i>USE="-X"</i>はpppoeのXインタフェースがインストールされるのを防ぎます。
		これによって、XやXが依存するパッケージまでもがemergeされてしまうことを避けることができます。
		Xサポートが必要なら、後で<i>rp-pppoe</i>をemergeしなおすことができます。</note>
		<note>rp-pppoeはインストールされましたが、まだ設定されていません。
		はじめにGentooシステムをブートしたとき、もう一度 <c>adsl-setup</c> を実行してください。</note>
		<p>もしXFSやReiserFS、LVMといったオプション機能を使うのなら、 Portageツリーの他の追加パッケージも必要となります。
		もしXFSを使うのなら、<c>xfsprogs</c>をemergeしてください。</p>
<pre caption="ファイルシステムツールのemerge">
# <c>emerge -k sys-apps/xfsprogs</c>
<comment>ReiserFSを使うときはReiserFS toolsをemergeしてください</comment>
# <c>emerge -k sys-apps/reiserfsprogs</c>
<comment>JFSを使うときはJFS toolsをemergeしてください</comment>
# <c>emerge -k jfsutils</c>
<comment>LVMを使うときは、<c>lvm-user</c>パッケージをemergeしてください</comment>
# <c>emerge -k sys-apps/lvm-user</c>
</pre>
		<p>もしラップトップを使っていて、rebootしたあともPCMCIAスロットを使いたいのなら、<i>pcmcia-cs</i>パッケージをインストールしてください。</p>
<pre caption="PCMCIA-csのemerge">
# <c>emerge -k sys-apps/pcmcia-cs</c>
</pre>
<!--
		<warn>PCMCIAを機能させるためには、インストールがすべて終わったあとで再度<i>pcmcia-cs</i>をemergeしなおす必要があるでしょう。</warn>
-->
		</body>
    </section>
  </chapter>
  <chapter>
    <title>/etc/fstabを書き換える</title>
    <section>
      <body>
      <impo>
      このファイルを編集するときは、nano -w "filename"とすることを(-wオプションを付けることを)忘れないでください。
      </impo>
		<p>ここまでの作業でGentoo Linuxシステムはほぼ完成しました。
		あとは重要なシステムファイルを作成し、GRUBブートローダーをインストールします。
		まず、<path>/etc/fstab</path>ファイルを編集します。
		ReiserFSファイルシステムを使用する場合は<c>notail</c>オプションをbootパーティションに付加するのを忘れないでください。
		<c>ext2</c>、<c>ext3</c>や<c>reiserfs</c>などのファイルシステムのタイプも指定してください。</p>
		<p>下記の<path>/etc/fstab</path>のように設定してください。
		もちろん、&quot;BOOT&quot;、&quot;ROOT&quot;、&quot;SWAP&quot;のデバイス名を実際のデバイス名（<c>hda1など</c>）に変更してください。</p>
<pre caption="fstabの編集">
<comment>
# /etc/fstab: 静的なファイルシステム設定.
#
# noatime はパフォーマンスを向上させます (atimeは通常は必要ありません)
# notail は ReiserFS のパフォーマンスを向上させます (ディスク効率が犠牲になります)
# noatimeを削っても安全です。また、notailとtailは自由に切り替えられます。

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: もしBOOTパーティションがReiserFSなら、notailオプションを加えてください。
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>
		<warn><i>/boot</i>がブート時にマウントされないことに気づいたでしょうか。
		これは/bootが破壊されることを防ぐためです。
		/bootにアクセスする必要があるときは、マウントしてください。</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ユーザ管理</title>
    <section>
      <title>rootパスワードの設定</title>
      <body>
	<p>忘れないうちに、rootのパスワードを設定しましょう。</p>
<pre caption="rootパスワード設定">
# <c>passwd</c>
</pre>
      </body>
    </section>
    <section>
      <title>日常的に使うユーザの登録</title>
      <body>
	<p>Unix/Linuxシステム上で、rootとして作業をするのは<e>危険</e>なので、なるべく避けるべきです。
	そのため、日常的に使うユーザを追加することを<e>強く</e>推奨します。</p>
        <pre caption = "ユーザの追加">
# <i>useradd your_user -m -G users,wheel,audio -s /bin/bash</i>
# <i>passwd your_user</i></pre>
	<p><c>your_user</c>を実際のユーザ名に置き換えてください。</p>
	<p>rootだけが実行できるような処理を行なう場合にも、<c>su -</c>を使ってroot権限を得るか、
	あるいは<c>sudo</c>パッケージを試してみてください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ホスト名を設定する</title>
    <section>
      <body>
        <p><path>/etc/hostname</path>を編集して、ホスト名だけを1行目に書き込んでください。</p>
<pre caption="ホスト名の設定">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>
	<p>次に<path>/etc/dnsdomainname</path>を編集して、DNSドメイン名を書き込んでください。</p>
<pre caption="ドメイン名の設定">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>
	<p>NISドメインを使っているなら、<path>/etc/nisdomainname</path>を編集してください。</p>
<pre caption="NISドメイン名の設定">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>/etc/hostsを書き換える</title>
    <section>
      <body>
	<p>このファイルにホストネームとIPアドレスを書き込んでください。
		ネームサーバに無いホストネームとIPアドレスの解決に使用されます。
		以下にこのファイルのテンプレートを示します。</p>
<pre caption="Hosts テンプレート">
127.0.0.1      localhost
<comment># 次の行にはローカルLANのIPとマシン名を記述します</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>
	<note>DHCPサーバを使ったネットワークにいるなら、あなたのマシンの名前を<i>localhost</i>の後に記述するとよいでしょう。
		GNOMEやその他の多くのプログラムが名前解決するときの助けとなります。</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ネットワークの設定</title>
    <section>
      <body>
		<p><path>/etc/modules.autoload</path>ファイルにシステムに必要なモジュールを書き込んでください（その他のオプションがあれば、ここに書き込んでください）。
		Gentoo Linuxがブートする時、これらのモジュールが自動的に読み込まれます。
		特に重要なものがモジュールとしてコンパイルした場合のイーサネットカードモジュールです。</p>
		<pre caption="/etc/modules.autoload">
<comment>ここでは3comのカードを使っていると仮定しています。
<path>/lib/modules/`uname -r`/kernel/drivers/net</path>を見て、自分のカードを探してください。</comment>
3c59x
		</pre>
		<p>ブート時にネットワークの設定を読み込ませるために<path>/etc/conf.d/net</path>スクリプトを編集してください。</p>
<pre caption="ブート時のネットワーク設定">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
</pre>
		<p>もし、複数のネットワークカードやトークンリングインタフェースを使用しているなら、それぞれに<path>net.eth<comment>x</comment></path>スクリプト（<comment>x</comment>=1,2,…）を作成してください。</p>
<pre caption="複数のネットワークインタフェース">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
</pre>
		<p>PCMCIAカードをインストールしている場合は、<path>/etc/init.d/pcmcia</path>の中を見て問題ないか確認し、<path>/etc/init.d/net.eth<comment>x</comment></path>の一番上に以下を追加してください。</p>
<pre caption="/etc/init.d/net.ethxにPCMCIAへの依存関係を記述する">
depend() {
	need pcmcia
}
</pre>
		<p>ネットワーク設定が読み込まれる際、自動的にPCMCIAドライバが読み込まれます。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最終ステップ: 基本設定を行う(キーマップの設定など)</title>
    <section>
      <body>
<pre caption="基本設定">
# <c>nano -w /etc/rc.conf</c>
</pre>
		<p>基本設定を行うには、ファイル内の指示に従ってください。
		<c>CLOCK</c>が望みどおりに設定されているか確認しましょう。
		またKEYMAP変数が合っているか見てください。
		設定できるキーマップを見つけるには<path>/usr/share/keymaps</path>の中を探してください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ブートローダを組み込む</title>
	<section>
	<title>注意事項</title>
	<body>
	<p>ブートローダも、Gentooらしく複数の中から利用するものを選択することができます。
	今のところバーチャルパッケージシステムを使うことによって、GRUBとLILOのどちらかを選べます。</p> 
		<p>気をつけて欲しいのは、両方をインストールする必要などないということです。
		むしろトラブルの原因となりますので、どちらか一方を選択するようにしてください。</p>
	<p>さらに、カーネルの構築に<c>genkernel</c>を使ったか手動で行なったかによって、
	ブートローダの設定が変ってきます。重要な違いはメモしておいてください。</p>
	<impo>NVIDIAのnForce又はnForce2チップセットと内蔵のGeForceグラフィックスカードを使ったシステムに
Gentoo Linuxをインストールするときは、GRUBではなくLILOを使わなければなりません。
オンボードビデオが有効のときメインメモリのthe low memory領域がビデオRAMとして使われます。
GRUBもthe low memory領域とブート時に使うため、&quot;out of memory&quot;(メモリ不足)となってしまいます。
そのため、nForceシステムや場合によっては他のオンボードビデオを使うときにはLILOを使ってください。
オンボードビデオを無効にしているとしても、
万一のときにオンボードビデオを有効にしてグラフィックスカードを取り外すことができるといいと思いませんか ;)</impo>
	</body>
	</section>
    <section>
	<title>GRUBを設定する</title>
      <body>
		<p>GRUBを理解するのにもっとも重要なことは、GRUBがどうやってハードディスクとパーティションを参照するかということです。
		<path>/dev/hda1</path>パーティションはGRUBでは<path>(hd0,0)</path>と呼ばれます。
		hd0,0をカッコでくくる点に注意してください。
		ハードディスクはaからではなく0から数えます。パーティションは1からではなく0から数えます。
		注意しなければならないのは、数えられるのはハードディスクだけ、という点です。
		CD-ROMプレイヤーやライターといったATAPI-IDEデバイスは数えられません。
		これはSCSIでも同じです(通常、SCSIはIDEより大きな番号が割り当てられます。
		ただし、BIOSでSCSIからブートするようになっている場合を除きます)。
		たとえば、ハードディスクが /dev/hda、CD-ROMドライブが /dev/hdb、CD-Rが /dev/hdc、二つ目のハードディスクが /dev/hddだとすると、<path>/dev/hdd7</path>は変換されて<path>(hd1,6)</path>となります。
		これはトリッキーに見えますし、実際にトリッキーなのですが、grubはtabキーによる補完の機能をもっているので、ハードディスクやパーティションがたくさんあってもgrubの番号付けで混乱することは少ないでしょう。
		感じが掴めたら、GRUBをインストールしましょう。</p>
		<p>GRUBをインストールするもっとも簡単な方法は、chrootから<c>grub</c>とタイプすることです。</p>
<pre caption="GRUBのインストール">
# <c>emerge -k grub</c>
# <c>grub</c>
</pre>
		<p><c>grub&gt;</c>というgrubのコマンドラインプロンプトが表示されているでしょうか。
		ここではハードディスクにGRUBブートローダをインストールするために正しくコマンドを入力してください。
		設定例では、GRUBブートローダをハードディスクのMBR(マスターブートレコード)にインストールするので、コンピュータを起動したとき最初に目にするものが GRUBプロンプトになります。
		この場合は、次のように入力します。</p>

<pre caption="GRUBをMBRにセットアップする">
grub&gt; <c>root (hd0,0)</c> <codenote>ブートパーティション</codenote>
grub&gt; <c>setup (hd0)</c> <codenote>ブートレコードがインストールされている場所。この例ではMBR。</codenote>
</pre>
	
<pre caption="MBR以外にセットアップする">
<comment>MBRではないところにブートローダをインストールする場合</comment>
grub&gt; <c>root (hd0,0)</c> <codenote>ブートパーティション</codenote>
grub&gt; <c>setup (hd0,4)</c> <codenote>ブートレコードがインストールされている場所。この例では/dev/hda5。</codenote>
grub&gt; <c>quit</c>
</pre>
       
		<p>このふたつのコマンドの意味を説明します。
		<c>root ( )</c>はGURBにブートパーティション（上の例で言えばGURBの<path>(hd0,0)</path>つまり<path>/dev/hda1</path>）の位置を教えます。
		<c>setup ( )</c>はGRUBに<c>root ( )</c>で指定したブートパーティションを探すためのブートレコードをどこにインストールするのかを教えます。
		上の例では、ブートレコードをハードディスクのMBRにインストールするので、単純に<path>/dev/hda</path>（GRUBでは<path>(hd0)</path>です）と指定します。
		もしほかのブートローダを使用していて、GRUBをセカンダリ・ブートローダとしたいのであれば、GRUB を特定のパーティションにインストールすることができます。
		その場合はディスク全体ではなく、特定のパーティションを指定します。
		GRUBのインストールに成功したら、<c>quit</c>とタイプしてGRUBを終了してください。</p>

		<note> GRUBのTAB補完はGRUB内で使えます。
		<c> root (</c>と書いてからTABを押すと利用可能なデバイスの一覧(ハードディスクだけではありません)が表示されます。
		<c> root (hd</c>を入力してからTABを押すと利用可能なハードディスクを一覧表示します。
		<c> root (hd0,</c>と書いてからTABを押すと最初のハードディスクのパーティションが一覧表示されます。
		補完機能を使いながら、構文のチェックをすると正しい選択をしているか確認するのに役立ちます。</note>
			
		<p>これで Gentoo Linuxがインストールされました。
		しかし、システムをリブートしたとき、感じのいいGRUBブートメニューを表示させるには、<path>/boot/grub/grub.conf</path>を作成しなければなりません。
		方法は以下のとおりです。</p>
		<impo>GRUBの下位互換性を保つため、<i>grub.conf</i> から <i>menu.lst</i>へ忘れずにリンクを作成してください。
		これは、<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>として実行します。</impo>
		<p>grub.confファイルを作成し(<c>nano -w /boot/grub/grub.conf</c> としてください)、以下の内容を書き込みます。</p>
<pre caption="grub.confの例">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

<comment>#手動でコンパイルした場合はこのようになります</comment>
title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment>#genkernelを使った場合の例はこちら</comment>
title=My example Gentoo Linux (genkernel)
root (hd0,0)
kernel (hd0,0)/boot/kernel-KV root=/dev/hda3
initrd (hd0,0)/boot/initrd-KV

<comment># デュアルブートする場合の例</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>
		<note>(hd0,0) は括弧内に空白を入れずに記述しなければなりません。</note>
		<impo> IDE CD-R用にSCSIエミュレーションを設定しているなら、カーネルの引数に&quot;hdx=ide-scsi&quot;を追加してください（hdxはCD-Rの位置に合わせてください）。</impo>
		<p>このファイルを保存すれば、Gentoo Linuxのインストールは完了します。
		第一オプションを選択しておけば、何もしなくてもGRUBはGentoo Linuxをブートします。
		grub.confファイルの2番目の部分はGRUBでWindowsをブートする方法を示したものです。</p>
		<note>上で述べた<path>(hd0,0)</path>は&quot;boot&quot;パーティション（例では<path>/dev/hda1</path>）を指しています。
		<path>/dev/hda3</path>はrootパーティションを指しています。
		<path>(hd0,5)</path>にはNTブートローダーが存在しています。</note>
		<note>カーネルイメージへのパスはbootパーティションに応じて変わります。
		もしブートパーティション<path>(hd0,0)</path>とルートパーティション<path>(hd0,1)</path>を持っているなら、
		上記のgrub.confのすべてのパスは<path>/bzImage</path>になります。</note>
		<p>カーネルに引数を与える必要があるならば、<c>kernel</c>コマンドの後に追加してください。
		上の例ではすでにひとつの引数（<c>root=/dev/hda3</c>）を与えていますが、さらに引数を与えることができます。
		<c>kernel</c>コマンドに<c>gentoo=nodevfs</c>を追加することにより、デフォルトでdevfsをオフにすることができます（意味が分からない場合は行なわないでください）。</p>
		<note>初期のGentoo Linuxには当てはまりませんが、devfsを有効にするために<c>kernel</c>コマンドに<c>devfs=mount</c>を追加する必要はありません。
		devfsはデフォルトで有効になっています。</note>
      </body>
    </section>
	<section>
    <title>LILOを設定する</title>
      <body>
		<p>GRUBは多くの人にとって新しい選択肢ですし、いつも安定しているというわけではありません。
		LILO(LInuxLOader)はその点ではLinuxブートローダとしての実績があります。
		安定性や設定が複雑すぎないことを求めるなら、LILOを試してみてください。</p>
		<p>まず、LILOをemergeしてください。</p>
<pre caption="LILOをemergeする">
# <c>emerge -k lilo</c>
</pre>
		<p>ではLILOの設定をしましょう。簡単な例を紹介し、その中身の説明をします。</p>
<pre caption="lilo.confの例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

#手動でカーネルを構築した場合はこちら
image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3

#genkernelを使った場合はこちら
image=/boot/kernel-KV
	label=gk_linux
	root=/dev/hda3
	initrd=/boot/initrd-KV
	append="root=/dev/ram0 init=/linuxrc"

	
#windowsなど他のOSとデュアルブートする場合
other=/dev/hda1
	label=dos
</pre>
		<ul>
		<li><i>boot=/dev/hda</i> はLILO自身を最初のIDEコントローラ上の最初のハードディスクにインストールするように指示します。</li>
		<li><i>map=/boot/map</i> はマップファイルを指定します。通常これを書き換えるべきではありません。</li>
		<li><i>install=/boot/boot.b</i> は新たにブートセクタに書き込むファイルを指示します。
		通常はこれを書き換えるべきではありません。
		この行がないときは、デフォルトの/boot/boot.bが使われます。</li>
		<li><i>prompt</i>があるとき、LILOは何が参照されたかをメッセージラインに出力します。
		これを削除することは推奨されませんが、消してしまった場合はマシンがブートするときに[Shift]キーを押しつづけることでプロンプトを出すことができます。</li>
		<li><i>timeout=50</i> はLILOがデフォルトの設定を使ってブートする前にユーザの入力を待つ時間の長さを指定します。
		これは1/10秒単位で、デフォルトは50です。</li>
		<li><i>message=/boot/message</i> はLILOがユーザにオペレーティングシステムやカーネルを選択してもらう時に表示する画面を指示します。</li>
		<li><i>lba32</i> はハードディスクのジオメトリをLILOに知らせます。
		よく使われるものとしては、他にlinearがあります。
		何を意味しているのか良くわからないときは変更するべきではありません。
		システムがブートできなくなってしまうことがあります。</li>
		<li><i>default=linux</i> はデフォルトでブートするオペレーティングシステムを指定します。
		linuxは、その下で定義されるブートオプションの名前です。</li>
		<li><i>image=/boot/vmlinuz-2.4.20</i> はそのブートオプションで使われるLinuxカーネルを指定します。</li>
		<li><i>label=linux</i>は、LILOの画面表示で使われるブートオプションの名前を指定します。
		この場合は、defaultの行で指定されている名前でもあります。</li>
		<li><i>initrd=/boot/initrd-2.4.20.img</i> は初期化用RAMディスクイメージを指定します。
		このイメージはブート時にデバイスを初期化・開始し、カーネルが起動できるようにします。
		初期化用RAMディスクは、カーネルを読み込むために必要な、SCSIカード、ハードディスクなどの機械依存のドライバを保持しています。
		複数のマシンで共有するようなことはしないでください。</li>
		<li><i>read-only</i> はルートパーティション(下のroot行を参照)が読み込み専用であり、起動中には書き換えることができないということを指示します。</li>
		<li><i>root=/dev/hda3</i> はLILOにルートパーティションとして使うディスクパーティションを指示します。</li>
		</ul>
		<p><i>lilo.conf</i>を編集したら、LILOを実行してMBRに情報を書き込んでください。</p>
<pre caption="LILOの実行">
# <c>/sbin/lilo</c>
</pre>
		<p>LILOが設定されました。これでGentoo Linuxを起動する準備ができました!</p>
      </body>
    </section>
    <section>
    <title>フレームバッファを使う</title>
    <body>
    <p>カーネルにフレームバッファを組み込んでいるなら、
    <c>vga=xxx</c>をブートローダの設定ファイルに書き加えるとよいでしょう。
    <c>xxx</c>は次の表から選んでください。</p>
<table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>
<p>LILOユーザは設定ファイルの先頭に<c>vga=xxx</c>を追加してください。</p>
<p>GRUBユーザは<c>kernel (hd0,0)...</c>と書かれた行に<c>vga=xxx</c>を追加してください。</p>
</body>
</section>
  </chapter>
  <chapter>
    <title>ブートディスクを作成する</title>
    <section>
      <title>GRUBブートディスク</title>
      <body>
      <impo>先に進む前に、フロッピーをフロッピードライブに入れるのを忘れないでください。</impo>
		<p>どんなLinuxディストリビューションでも、最初にインストールするときにブートディスクも作っておくとよいでしょう。
		お守りのようなものですが、一般的に作っておいて損はありません。
		利用しているハードウェアがchroot状態でブートローダをインストールすることを許さない場合は、<e>必ず</e>GRUBブートディスクを作成してください。
		そのような環境の方は、ブートディスクを作り、最初に再起動したときにGRUBをMBRにインストールします。
		ブートディスクは次のようにして作成します。</p>
<pre caption="GRUBブートディスクの作成">
# <c>cd /usr/share/grub/i386-pc/</c>
# <c>cat stage1 stage2 > /dev/fd0</c>
</pre>
		<p>ここでリブートしてフロッピーで起動してください。
		フロッピーの<c>grub&gt;</c>プロンプトが表示されたら、必要に応じて<c>root</c>や<c>setup</c>コマンドを実行できます。</p>
      </body>
    </section>
    <section>
      <title>LILOブートディスク</title>
      <body>
      <impo>先に進む前に、フロッピーをフロッピードライブに入れるのを忘れないでください。</impo>
		<p>LILOを使う場合でも、ブートディスクを作っておくと良いでしょう。</p>
<pre caption="ブートディスクの作成">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>カーネルサイズは1.4MB以下でなければならない</comment>
</pre>
      </body>
    </section>
  </chapter>

  <chapter>
    <title>GRPを使う</title>
    <section>
     <body>

	<p>GRPユーザはここでバイナリパッケージをインストールできます</p>

<pre caption="GRPからインストールする">
# <c>USE="bindist" emerge -k xfree</c> 
<codenote>XFree86を使うパッケージをインストールするときはUSE="bindist"が必要です。</codenote>
</pre>

	<p>CD 1はXFree86が動くために必要なものを含んでいます。
	さらに2枚組CDセットのCD 2にはKDE、GNOME、Mozillaといったものが含まれています。
	これらをインストールするには、まずGentooシステムを再起動する必要があります(このドキュメントの最後の方の"システムの再起動"参照)。
	初期状態のGentooシステムがハードディスクから起動して動くようになったら、CD2をマウントして次のようにコピーをしてください。</p>

     <pre caption="CD2からバイナリパッケージを読みこむ">
# <c>mount /dev/cdrom /mnt/cdrom</c>
# <c>cp -a /mnt/cdrom/packages/* /usr/portage/packages/</c>
</pre>

     <p>さまざまなアプリケーションが同じやりかたでインストールできます。たとえば、kdeなら次のようになります。</p>

     <pre caption="GRPからKDEをインストールする">
# <c>USE="bindist" emerge -k kde</c>
</pre>

     </body>
  </section>
  </chapter>
  <chapter>
    <title>インストール完了!</title>
    <section>
      <body>
	<p>これでGentoo Linuxがインストールされました。
	あとは必要な設定ファイルを更新し、chrootされたshellを終了して、パーティションを切り離したあと再起動しましょう。</p>
<warn><c>etc-update</c>は新しいバージョンの設定ファイルなどを一覧表示し、どのようにするか決めて片付けることができます。
重大な影響を持つような更新がないことを確認する(例えば <path>/etc/fstab</path>、
<path>/etc/make.conf</path>、<path>/etc/rc.conf</path>、など)、
大きな影響のないファイルをマージする、更新を破棄する、手動で差分の確認とマージをして更新する、などが可能です。
</warn>
<pre caption="システムの再起動">
# <c>etc-update</c>
# <c>exit</c> 
<comment>(chrootされたshellを終了する。<c>^D</c>とタイプしても良い。)</comment>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
<comment>忘れずにブートCDを取りのぞいてください。</comment>
</pre>
	<note>再起動したあとに<c>update-modules</c>コマンドを実行して<path>/etc/modules.conf</path>ファイルを作成するのも良いでしょう。
	一般的には、このファイルを直接修正する代わりに<path>/etc/modules.d</path>の中のファイルに変更を加えるべきです。</note>
	<p>何か疑問があったり、Gentoo Linuxの開発に携わりたい人は、gentoo-userメーリングリストやgentoo-devメーリングリストへの参加も考えてみてください
	(詳しい情報は<uri link="http://www.gentoo.org/main/en/lists.xml">メーリングリスト</uri>のページにあります)。
	また、<uri link="/doc/en/desktop.xml">Desktop configuration guide</uri>(<uri link="/doc/ja/desktop.xml">日本語訳</uri>)は
	Gentoo Linuxシステムを設定するときに役に立ちますし、<uri link="/doc/en/portage-user.xml">Portage user guide</uri>(<uri link="/doc/ja/portage-user.xml">日本語訳</uri>)はPortageの基礎知識を得るのに役立ちます。
	その他のドキュメントは<uri link = "/main/en/docs.xml">こちら</uri>を参照してください。
	インストールやその他の問題で質問したいことがあるなら、Gentoo Linux <uri link = "/main/en/faq.xml">FAQ</uri>(<uri link="/doc/ja/faq.xml">日本語訳</uri>)も見てください。
	Gentoo Linuxへようこそ！お楽しみ下さい！</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentoo利用統計</title>
    <section>
      <body>
	<p> Gentoo Linux 利用統計プログラムは、開発者にユーザの動向を把握する手段を提供することを目的に始められました。
	この gentoo-stats プログラムは Gentoo Linuxの利用状況に関する情報を収集し、開発の優先順位を決定するために使われます。
	あくまでもオプションとして提供していますが、参加してもらえるととても嬉しく思います。
	集計結果は、<uri>http://stats.gentoo.org/</uri>で見ることができます。</p>
	<p>Gentoo利用統計サーバはあなたのシステムに対してIDを割り当てます。
	これはそれぞれのシステムが間違いなく１度だけカウントされるようにするためのものです。
	IDを使ってあなたのシステムを識別したり、 IPアドレスやその他の情報とマッチングしたりすることはありません。
	あらゆる予防措置を講じて、あなたのシステムのプライバシーが守られるようにこのシステムを構築しています。
	以下が、現在&quot;gentoo-stats&quot;プログラムで監視している項目です。</p>
	<ul>
	<li>インストール済みパッケージとそのバージョン</li>
	<li>CPU情報: 速度(MHz)、ベンダ、モデル、CPUフラグ (&quot;mmx&quot;や&quot;3dnow&quot;など)</li>
	<li>メモリ情報 (物理メモリ量、スワップスペース量)</li>
	<li>PCIカードとネットワークコントローラチップ</li>
	<li>使われているprofile(/etc/make.profileがどこへリンクしているか)</li>
	</ul>
	<p>我々は、機密情報が公開されることが、多くのGentoo Linuxのユーザにとって(開発者にとってもそうですが)、脅威となることを承知しています。</p>
	<ul>
	<li>gentoo-statsプログラムを変更しない限り、次のような機密情報を通信することはありません: パスワード類、設定情報、靴のサイズ…</li>
	<li>e-mailアドレスの送信はオプションです。デフォルトでは送信されません。</li>
	<li>送信元のIPアドレスもあなたを識別できるような方法で記録されることは決してありません。
	「IPアドレスとシステムIDのペア」はどこにも記録されていません。</li>
	</ul>
	<p>インストールは簡単です。次のように入力してください。</p>
<pre caption="gentoo-statsのインストール">
# <c>emerge gentoo-stats</c>   <codenote>gentoo-statsのインストール</codenote>
# <c>gentoo-stats --new</c>    <codenote>システムIDの取得</codenote>
</pre>
	<p>上記の2番目のコマンドは新しいシステムIDをサーバに要求し、それを<path>/etc/gentoo-stats/gentoo-stats.conf</path> に自動的に記録します。
	このファイルにはさらに設定オプションを指定することができます。</p>
	<p>その後は、定期的に起動する必要があります(rootとして実行する必要はありません)。
	あなたのcrontabに次の行を追加してください。</p>
<pre caption="cronでgentoo-statsを更新する">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
</pre>
	<p><c>gentoo-stats</c>プログラムは単純なperlスクリプト(<path>/usr/sbin/gentoo-stats</path>)ですので、お好みのページャやエディタで見ることができます。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>特殊なハードウェア</title>
    <section>
       <title>ハードウェアATA RAID</title>
       <body>
	<p>ハードウェアATA RAIDのシステムにGentooをインストールしようとする方は、以下の項目をよく確認してインストールを成功させてください。</p>
       <ul>
       <li><c>doataraid</c>カーネルオプションを付けてLiveCDを起動すること。</li>
       <li><c>doataraid</c>カーネルオプションを付け忘れたり、なぜかモジュールがロードされなかったりしたときは、次のようにする。
       <pre caption = "RAIDモジュールのロード">
# <i>modprobe ataraid</i>
<comment>PromiseのRAIDコントローラの場合:</comment>
# <i>modprobe pdcraid</i> 
<comment>HighpointのRAIDコントローラの場合:</comment>
# <i>modprobe hptraid</i>
       </pre>
       </li>
       <li>ATA RAIDコントローラの中には、パーティションを作成したあと必ず再起動が必要なものがある。そうしないとフォーマットに失敗する。</li>
       <li>chrootする前に、デバイスツリーを新しい環境にマウントしておくこと。
       <pre caption = "/devを/mnt/gentoo/devにマウントする">
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
       </pre>
       </li>
       <li>カーネルの設定をするとき、必要なRAIDオプションを選択すること。
       <pre caption = "RAIDを使うためのLinux Kernel設定">
<comment>HighpointのRAIDコントローラの場合:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
  [*] HPT36X/37X chipset support 
  [*] Support for IDE Raid controllers
  [*] Highpoint 370 software RAID
<comment>PromiseのRAIDコントローラの場合:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
  [*] PROMISE PDC202{46|62|65|67} support 
  <comment>必要に応じて</comment>
  [*] PROMISE PDC202{68|69|70|71|75|76|77} support
  [*] Support for IDE Raid controllers
  [*] Support Promise software RAID (Fasttrak(tm))
       </pre></li>
       <li>GRUBを使う場合は、<c>setup</c>コマンド実行時に<c>--stage2=/boot/grub/stage2</c>を付けること。
       <pre caption = "GRUBをハードウェアRAIDシステムにインストールする">
grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
grub&gt; <i>quit</i>
       </pre>
       GRUBの設定時には、<c>root</c>が適切なRAIDデバイスを指していることを確認すること。
       <pre caption = "RAID用のgrub.conf">
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
       </pre></li>
       <li>LILOユーザは<c>root</c>オプションが適切なRAIDデバイスを指していることを確認すること。
       <pre caption = "RAID用のlilo.con">
image=/boot/bzImage
    label=linux
    read-only
    root=/dev/ataraid/dXpY
       </pre></li>
     </ul>
   </body>
 </section>
</chapter>
</guide>
