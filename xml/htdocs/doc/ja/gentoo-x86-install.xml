<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/ja/gentoo-x86-install.xml">
  <title>Gentoo Linux 1.4_rc4 インストール手引書</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">
    <mail link="">Jerry Alexandratos</mail>
  </author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>
  <author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
  </author>
  <author title="Editor">
    <mail link="">Colin Morey</mail>
  </author>
  <author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Editor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
  </author>
  <author title="翻訳">
    <mail link="makoto@dsb.club.ne.jp">yamakura</mail>
  </author>
  <abstract>Gentoo Linux 1.4_rc4のインストール手引書です。
	この手引書ではゼロからGentoo Linuxを構築することはもちろん、いろいろな段階からのインストールを解説します。
	</abstract>
<version>2.6.1</version>
 <date>22 May 2003</date>
 <!-- Original revision: 1.123 -->
  <chapter>
    <title>インストールについて</title>
    <section>
      <body>
        <p>新しいブートCDは、ドライブとBIOSのサポートがあれば、
最近のIDE CD-ROMドライブや多くのSCSI CD-ROMドライブから起動させることができます。
IDEデバイス（カーネルに組込）だけでなくすべてのSCSIデバイス（モジュールとして提供）もサポートしています。
さらに、Linuxがサポートするすべてのネットワークカードのモジュールはもちろん、
ネットワークを設定し、<c>ssh</c>による接続やファイルのダウンロードを可能にするツールをも提供します。</p>
        <p>インストールを行なうには486以上のCPUおよび少なくとも64Mバイトのメモリが必要となります
（Gentoo Linuxは64Mバイトのメモリと64Mバイトのスワップでビルドに成功していますが、
このような環境下では、とても時間がかかります）。</p>
        <p>Gentoo Linuxは３つある&quot;ステージ&quot;の圧縮ファイルのうち、どれかひとつを使ってインストールすることができます。
どれを使うかは、システムのどの程度を自分でコンパイルして用意するかによって決まります。
ステージ1圧縮ファイルは、ブートストラップしてシステム全体を一から組み立てるときに使います。
ステージ2圧縮ファイルは、既にブートストラップが済んだ状態からシステムを構築する場合に使います。
ステージ3圧縮ファイルは、標準的な設定で構築されたGentoo Linuxシステムを含んでいます。</p>
        <p><b>それでは、どのステージの圧縮ファイルを選んだらよいのでしょうか?</b>
		ステージ1を使うと、インストール直後のシステムに対して、
		最適化オプションやコンパイル時に組込まれる機能を完全にコントロールすることができます。
		自分のしていることをきちんと把握しているパワーユーザには、
		ステージ1でのインストールが良い選択となります。
		ステージ2を使うと、ブートストラップを省略することができます。
		用意されたステージ2圧縮ファイルの最適化に不満がないならこれを使ってください。
		ステージ3を使うことでインストール時間がもっとも短かくなりますが、
		最適化を自分でコントロールすることはできません。
		しかしGentoo Linuxのメジャーリリースでは、
		一般的なプロセッサに対してそれぞれ最適化されたステージ3圧縮ファイルを用意しますので、
		それで充分かもしれません。
		<b>Gentoo Linuxをインストールするのが初めてなら、ステージ3圧縮ファイルを選択すると良いでしょう。</b></p>
		
		
		<p>さて、インストールはどうやって進めたらいいでしょうか。
		まずインストールに使うLiveCDのISOイメージを
		<uri>http://www.ibiblio.org/gentoo/releases/1.4_rc4/x86/</uri>から選んでください。
		メインサーバの負荷を分散するため、ミラーサーバを使うようにしてください。
		ミラーサーバの一覧は<uri>http://www.gentoo.org/main/en/mirrors.xml</uri>にあります。</p>
	<p>LiveCDは完全なCDイメージですので、CD-RやCD-RWに書き込むことができます。
現在、LiveCDには2種類あります。ひとつは&quot;gentoo-basic&quot;(ベーシック)という名前で、
40MB程度の大きさがあり、ステージ1のみを含んでいます。
これは<path>x86/livecd/</path>ディレクトリに収められているものです。
このLiveCDは小さいのでダウンロード時間が短くてすみます。
このCDでブートすると、<path>/mnt/cdrom/gentoo/</path>にステージ1圧縮ファイルがあります。</p>
	<p>もうひとつのLiveCDは&quot;livecd-3stages&quot;(3ステージ)と名づけられています。
このCDはアーキテクチャ別に<path>arch/livecd</path>ディレクトリにあります。
このCDには、ステージ1,2,3のそれぞれの圧縮ファイルが含まれています。
このLiveCDを使うと完全に機能するGentoo Linuxシステムをとても素早く構築することができます。</p>
<p><b>i686, pentium3, athlon, athlon-mp 用のステージ圧縮ファイルやLiveCD、
GRP (Gentoo Reference Platform)はどうなったのでしょうか?</b>
Gentoo 1.4_rc4はrelease candidateですので、最小限のものしか用意されません。
1.4_finalでは一般的なx86アーキテクチャ用の圧縮ファイルとGRPが提供されます。
もしこのようなアーキテクチャ毎に最適化された圧縮ファイルやGRPを使いたいのであれば、
<uri>http://www.gentoo.org/doc/en/gentoo-x86-1.4_rc2-install.xml</uri>の
1.4_rc2用ドキュメントを参照してください。</p>
	<impo>インストールの途中で見つけたバグをレポートする時は、
原則として<uri>http://bugs.gentoo.org</uri>を使ってください。
バグがそのソフトウェアそのものに起因するような場合、
Gentoo Linuxの開発チームがそれを判断してソフトウェアの開発チーム
(例えばKDE開発チームなど)に報告します。</impo>
	<p>それではインストールの手順を簡単に見てみましょう。
まず、LiveCDイメージをダウンロードしCDを作成します。
LiveCDでブートしてプロンプトが出たら、まずパーティションを、
続いてファイルシステムを作成し、ステージ1、ステージ2、ステージ3圧縮ファイルのどれかを展開します。
ステージ1かステージ2の圧縮ファイルを使用する場合、ステージ3に進むために適切な手順を踏む必要があります。
ステージ3に進みシステムに対して各種の設定（設定ファイルの調整、
ブートローダーのインストールなど）を行ない、再起動すればGentoo Linuxの完成です。
以下に、スタートするステージ別にどのような手順が必要なのかを示します。</p>
        <table>
          <tr>
            <th>圧縮ファイル</th>
            <th>必要な手順</th>
          </tr>
          <tr>
            <ti>1</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync、ブートストラップ、emerge system、emerge kernel sources、最終調整</ti>
          </tr>
          <tr>
            <ti>2</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync、emerge system、emerge kernel sources、最終調整</ti>
          </tr>
          <tr>
            <ti>3</ti>
            <ti>パーティションとファイルシステムの作成、emerge sync、最終調整</ti>
          </tr>
        </table>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ブート</title>
    <section>
      <body>
	<p>LiveCDでブートするところから始めましょう。
		Gentoo Linuxロゴとともにブートスクリーンが表示されるはずです。
		この画面ではそのままブートプロセスを進めるためにEnterを押すか、
		自分のマシンに合ったカーネルとブートオプションを入力してからEnterを押してブートすることができます。
		例えば、<c>gentoo nousb nohotplug</c>などと入力します。
		利用できるカーネルとオプションについては、以下の表かF2キーを押すと表示されるヘルプを見てください。</p>
	
	<table>
	<tr>
		<th>利用できるカーネル</th>
		<th>概要</th>
	</tr>
	
	<tr><ti>gentoo</ti><ti>基本的なgentooカーネル (デフォルト)</ti></tr>
	<tr><ti>800</ti><ti>800x600 フレームバッファモード </ti></tr>
	<tr><ti>1024</ti><ti>1024x768 フレームバッファモード (デフォルト)</ti></tr>
	<tr><ti>1280</ti><ti>1280x1024 フレームバッファモード</ti></tr>
	<tr><ti>nofb</ti><ti>フレームバッファ無効化</ti></tr>
	<tr><ti>smp</ti><ti>smpカーネルでフレームバッファ無効化</ti></tr>
	<tr><ti>acpi</ti><ti>acpi=on有効かつinit中にacpiモジュールをロード</ti></tr>
	<tr><ti>memtest</ti><ti>メモリテストプログラムを起動</ti></tr>

	</table>
	
	<p>
	<table>
	<tr>
		<th>利用できるブートオプション</th>
		<th>概要</th>
	</tr>

	<tr><ti>doataraid</ti>
	<ti>initrdでIDE-RAIDモジュールを読み込む</ti></tr>
	
	<tr><ti>dofirewire</ti>
	<ti>initrdでfirewireモジュールを読み込む(firewireのCD-ROMドライブ等利用者向け)</ti></tr>

	<tr><ti>dokeymap</ti>
	<ti>非USキーボード配列向けのキーマップ選択を有効にする</ti></tr>

	<tr><ti>dopcmcia</ti>
	<ti>pcmciaサービスを開始する</ti></tr>

	<tr><ti>doscsi</ti>
	<ti>SCSIデバイスをスキャンする(これにより動かなくなるイーサネットカードが存在する)</ti></tr>

	<tr><ti>noapm</ti>
	<ti>APMモジュールの読み込みを無効にする</ti></tr>

	<tr><ti>nodetect</ti>
	<ti>hwsetup/kudzuとhotplugによる検出をしない</ti></tr>

	<tr><ti>nodhcp</ti>
	<ti>ネットワークカードが検出されてもDHCPを実行しない</ti></tr>

	<tr><ti>nohotplug</ti>
	<ti>hotplugサービスの読み込みを無効にする</ti></tr>

	<tr><ti>noraid</ti>
	<ti>evmsモジュールの読み込みを無効にする</ti></tr>

	<tr><ti>nousb</ti>
	<ti>initrdでのUSBモジュールの読み込みとhotplugを無効にする</ti></tr>

	<tr><ti>ide=nodma</ti>
	<ti>DMAモードでうまく動かないIDEデバイスがある場合に、強制的にDMAを無効にする</ti></tr>

	<tr><ti>cdcache</ti>
	<ti>CDの中身をメモリにキャッシュする。メモリを40MB程度余分に使うが、umount /mnt/cdromし別のCDをマウントすることができる</ti></tr>

	</table></p>

	<p>Enterを押すと、標準的なカーネルブートメッセージ、カーネルとinitrdのメッセージが表示され、
続いてGentoo Linuxのブートシーケンスが表示されます。
そのあと、自動的に&quot;root&quot;としてログインされ、安全のためランダムな文字列がrootのパスワードに設定されます。
コンソールにはrootのプロンプト (&quot;<c>#</c>&quot;) が表示されるはずです。
ここでALT-F2、ALT-F3、ALT-F4を押すと別のコンソールに切り替えることができます。
最初のコンソールに戻るにはALT-F1を押します。
ここでrootのパスワードを設定したほうが良いでしょう。
passwdと入力し指示に従ってパスワードを設定してください。</p>
	<p>既にお気づきかと思いますが、<c>#</c>プロンプトの上には、ネットワークの設定方法やGentoo Linuxの各ステージ圧縮ファイル、
パッケージのありかなどの説明が書かれたヘルプテキストが表示されています。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>カーネルモジュールの読み込み</title>
    <section>
      <body>
	<p>ハードウェアの自動検知がうまくいかなかったら、適切なカーネルモジュールを手動でロードしなければなりません。
		利用可能なネットワークカードモジュールの一覧を見るには、
		<c>ls /lib/modules/*/kernel/drivers/net/*</c>とタイプしてください。
		モジュールをロードするには、次のようにタイプします。</p>
<pre caption="PCIモジュール設定">
# <c>modprobe pcnet32</c>
<comment>(pcnet32を使っているNIC用のモジュール名に変えてください)</comment>
</pre>
	<p>同じように、PCI自動検知で検出されなかったSCSIデバイスにアクセスできるようにするには、
	もういちど<c>modprobe</c>を利用して<path>/lib/modules</path>から適切なモジュールをロードします。</p>
<pre caption="SCSIモジュールの読み込み">
# <c>modprobe aic7xxx</c>
<comment>(aic7xxxを使っているSCSIアダプタ用のモジュール名に変えてください)</comment>
# <c>modprobe sd_mod</c>
<comment>(sd_modはSCSIディスクサポートのためのモジュール)</comment>
</pre>
			<note> SCSI CD-ROMとハードディスクのサポートはカーネルに組み込まれています。</note>
	<p>ハードウェアRAIDをつかっているなら、お使いのRAIDコントローラ用のATA-RAIDモジュールをロードする必要があります。</p>
<pre caption="RAIDモジュールの読み込み">
# <c>modprobe ataraid</c>    
# <c>modprobe pdcraid</c>            
<comment>(Promise Raid Controller)</comment>    
# <c>modprobe hptraid</c>            
<comment>(Highpoint Raid Controller)</comment>    
</pre>
	<p>Gentoo LiveCDはDMAを有効にするはずですが、有効にならなかったときは<c>hdparm</c>を使ってドライブにDMAを設定できます。</p>
<pre caption="DMA設定">
<comment>hdXを自分のシステムのディスクデバイス名に変えてください</comment>
# hdparm -d 1 /dev/hdX <comment>Enables DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(DMAと、性能を上げる安全なオプションを有効に)</comment>
# hdparm -X66 /dev/hdX
<comment>(Ultra-DMAを有効に -- 危険! -- ドライブが壊れる恐れあり)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ネットワーク設定</title>
	<section>
      <title>もう動いているかも?</title>
      <body>
		<p>1.4_rc3かそれ以降のLiveCDを使っている場合は、
		可能であれば自動的にネットワーク接続できるようになっています。
		その場合は、LiveCDに含まれる多くのネットワーク関連のコマンド、
		<c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> and <c>lynx</c>などを利用できます。</p>
	<p>ネットワーク接続できるようになっているなら、<c>/sbin/ifconfig</c>コマンドで<c>lo</c>と一緒に<c>eth0</c>などのネットワークインタフェースが表示されるはずです。</p>
<pre caption="/sbin/ifconfigでネットワークカードが動作しているか確認する">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
	<p>ISPのDNSサーバ(<path>/etc/resolv.conf</path>にアドレスが書かれているはずです)や、
	適当なWebサーバに対してpingを打ってみることで、パケットがネットワークに届くこと、
	DNSによる名前の解決がうまく機能していることなどを確かめることができます。</p>
<pre caption="ネットワークの確認">
# <c>ping -c 3 www.yahoo.com </c>
</pre>
		<p>ネットワークが使えるようになっていますか? それならば、残りは飛ばして次のセクションに進んでください。</p>
      </body>
    </section>
    <section>
      <title>PPPoE設定</title>
      <body>
	<p>インターネットへ接続するためにPPPoEが必要な場合、
	どのバージョンのLiveCDにも含まれている<c>rp-pppoe</c>を使うのが簡単です。
	<c>adsl-setup</c>スクリプトを使って接続の設定をしてください。
	adslモデムに接続しているイーサネットデバイスとユーザ名、パスワード、
	DNSサーバのIPアドレス、ファイアウォールが必要かどうか、を入力してください。</p>
<pre caption="PPPoE設定">
# <c> adsl-setup </c>
# <c> adsl-start </c>
</pre>
	<p>うまくいかないようなら、ユーザ名とパスワードを間違いなく入力しているかどうか、
	<path>/etc/ppp/pap-secrets</path>や<path>/etc/ppp/chap-secrets</path>を見てよく確認してください。
	また正しいイーサネットデバイスを指定しているかどうかも確認してください。</p>
      </body>
    </section>
    <section>
      <title>ネットワークの自動設定</title>
      <body>
       <p>自動的にネットワークが設定されなかった場合、いちばん簡単な設定方法は、<c>net-setup</c>スクリプトを実行することです。</p>
<pre caption="net-setupスクリプト">
# <c>net-setup eth0</c>
</pre>
	<p>もちろん、お好みであれば手動で設定することもできます。その方法は次で説明します。</p>
      </body>
    </section>
    <section>
      <title>手動でDHCPを使う</title>
      <body>
	<p>DHCPの設定は簡単です。ご利用のISPがDHCPをサポートしていない場合は、固定IPの設定まで進んでください。</p> 
<pre caption="DHCPを使ったネットワーク設定">
# <c>dhcpcd eth0</c>
</pre>
	<note>ISPによっては、ホスト名の入力が必要になります。
		その場合はdhcpcdコマンドの後に<c>-h myhostname</c>と書き加えてください。</note>
	<p>もし<i>dhcpConfig</i>警告を受け取ったとしても、慌てないでください。
		このエラーは重大なものではありません。ネットワークのテストまで進んでください。</p>
      </body>
    </section>
    <section>
      <title>手動で固定アドレスを設定する</title>
      <body>
	<p>システムの構築に必要なソースファイルをダウンロードすることができるようにネットワークを設定しなければなりません。
	そのために必要な情報は以下の表に示されているものです。</p>

<table>
<tr><th>項目</th><th>説明</th><th>例</th></tr>
<tr><ti>IPアドレス</ti><ti>ネットワークカードに割り当てたいIPアドレス</ti><ti>192.168.1.2</ti></tr>
<tr><ti>ブロードキャストアドレス</ti><ti>ローカルネットワークの全てのホストにパケットをブロードキャストするためのアドレス</ti><ti>192.168.1.255</ti></tr>
<tr><ti>ネットワークマスク</ti><ti>IPアドレスと一緒に使われ、アドレスのうちネットワークを識別する範囲とホストを識別する範囲を表現するために使われるマスク値</ti><ti>255.255.255.0</ti></tr>
<tr><ti>ゲートウェイ</ti><ti>ローカルネットワーク以外のアドレス(インターネット接続している場合など)にパケットを転送するためのコンピュータのアドレス</ti><ti>192.168.1.1</ti></tr>
</table>
        
		<p>システムの構築に必要なソースをダウンロードするために、ネットワークに対して適切な設定を行なう必要があります。
		下記のコマンドを入力してください。その際、$IFACEを使用するネットワークインターフェイス
		（たいていの場合<c>eth0</c>）に、$IPNUMを使用するIPアドレスに、
		$BCASTをブロードキャストアドレスに、$NMASKをネットワークマスクにそれぞれ置き換えてください。
		<c>route</c>コマンドでは、$GTWAYをデフォルトゲートウェイに置き換えてください。</p>
<pre caption="固定IPネットワーク設定">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</c>
</pre>
	<p>ここで、<path>/etc/resolv.conf</path>を作成し、
	名前解決(Webサイトや FTPサイトのIPアドレスを直接指定するのではなく名前で指定)できるようにします。
	<c>nano -w /etc/resolv.conf</c>として、<path>/etc/resolv.con</path>を作成できます。
	<c>nano</c>は小さくて操作の簡単なエディタです。</p>
	<p>以下に、/etc/resolv.conf作成の参考になるようにテンプレートを示します。</p>
<pre caption="/etc/resolv.conf テンプレート">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
	<p><c>10.0.0.1</c> と <c>10.0.0.2</c> をそれぞれプライマリDNSサーバとセカンダリDNSサーバのアドレスに書き換えてください。</p>
      </body>
    </section>
    <section>
      <title>プロクシ設定</title>
      <body>
	<p>プロクシを利用している場合は先に進む前にプロクシを利用する設定をしなければなりません。
		次のように環境変数を設定してください。</p>
<pre caption="プロキシ設定">
<codenote>If the proxy restricts HTTP traffic:</codenote>
# <c>export http_proxy=&quot;machine.company.com:1234&quot; </c>
<codenote>If the proxy restricts FTP traffic:</codenote>
# <c>export ftp_proxy=&quot;machine.company.com&quot; </c>
<codenote>If the proxy restricts RSYNC traffic:</codenote>
# <c>export RSYNC_PROXY=&quot;machine.company.com&quot; </c>
</pre>
      </body>
    </section>
        <section>
      <title>ネットワークの用意ができました!</title>
      <body>
	<p>これで、ネットワークの設定が終わって利用可能になったと思います。
		<c>ssh</c>、<c>scp</c>、<c>lynx</c>、<c>irssi</c>、<c>wget</c>コマンドを使って、LAN上のマシンやインターネットに接続することが可能です。</p>
      </body>
    </section>
    <section>
    	<title>ネットワーク接続環境がありません!</title>
	<body>ネットワーク接続環境がない場合は<uri link="http://forums.gentoo.org/">Gentoo Forums</uri>が助けになるかも知れません。
		いくつかの役にたつリンクが<uri>http://forums.gentoo.org/viewtopic.php?t=43025</uri>にあります。
	</body>
  </section>
  </chapter>
  <chapter>
    <title>システムの日付と時刻を合わせる</title>
    <section>
      <body>
	<p>ここで、システムの日付と時刻を合わせてください。
	<c>date</c>コマンドを使います。</p>
<pre caption="システム日付の調整">
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(時刻が合っていなかったら、次のようにして合わせる)</comment>
# <c>date 022709042003</c>
<comment>(date MMDDhhmmCCYY)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ファイルシステム、パーティション、そしてブロックデバイス</title>
    <section>
		<title>ブロックデバイスとは</title>
      <body>
<p>このセクションでは、Gentoo LinuxまたはLinux全般における、Linuxファイルシステム、
パーティション、ブロックデバイスなど、ディスクに関する事項を説明します。
ディスクに関する知識を得たところで、その後、
Gentoo Linuxのインストールをするためにパーティションおよびファイルシステムの作成手順を解説します。</p>
<p>まず初めに、"ブロックデバイス"を紹介しましょう。
最も馴染みのあるブロックデバイスはおそらく1番目のIDEドライブとしてLinuxに認識されているものでしょう。</p>
<pre caption="/dev/hdaはプライマリマスタIDEドライブを表すブロックデバイス">
/dev/hda
</pre>

<p>もしSCSIドライブを使っているなら、1番目のハードディスクは次のようになるかも知れません。</p>

<pre caption="/dev/sdaは1番目の論理SCSIドライブを表すブロックデバイス">
/dev/sda
</pre>

<p>上で見たようなブロックデバイスはディスクに対する<i>抽象的な</i>インタフェースを表します。
ユーザプログラムは、それがIDEなのかSCSIなのかといったことを気にすることなく、これらのデバイスを使うことができます。
プログラムは、多数の連続した、ランダムアクセス可能な512バイトブロックに単純にアドレッシングできます。</p>
</body>
</section>
<section>
<title>パーティションとfdiskコマンド</title>
<body>
<p>Linuxでは、<c>mkfs</c> (または <c>mke2fs</c>, <c>mkreiserfs</c>など)
にコマンドラインでブロックデバイスを指定して実行することで、ファイルシステムを作成します。</p>

<p>理論的には、"whole disk"ブロックデバイス(ディスク<i>全体</i>を表すもの)である、
<c>/dev/hda</c>や<c>/dev/sda</c>を使ってひとつのファイルシステムを格納することもできますが、
実際にはほとんどそのようにされることはありません。
ディスク全体を使うかわりに、もっと扱いやすい"パーティション"と呼ばれるブロックデバイスに分割します。
パーティションは<c>fdisk</c>と呼ばれる、パーティションテーブルを編集しそれぞれのディスクに書きこむツールを使って作成します。
パーティションテーブルはディスク全体がどのように分割されるのかを定義します。</p>

<p><c>fdisk</c>を使って、ディスクのパーティションテーブルを見てみます。ディスク全体を表すデバイスを指定してください:</p>

<note>パーティションテーブルを編集するには、他に<c>cfdisk</c>、<c>parted</c>、<c>partimage</c>などがあります。
最も機能豊富でUnix/Linuxの世界で良く知られている<c>fdisk</c>の利用をお勧めします。</note>

<pre caption="fdiskを起動する">
# fdisk /dev/hda 
</pre>
<p>または</p>
<pre caption="/dev/sdaのパーティションテーブルを確認するために、fdiskを起動する">
# fdisk /dev/sda
</pre>

<impo>ディスク内に使用中あるいは重要なデータを含んだパーティションがある場合は、
パーティションテーブルを保存したり変更したり<i>しない</i>ように注意してください。
このような操作でディスク内のデータが失われる恐れがあります。</impo>

<p>fdiskを実行すると、次のようなプロンプトが表示されます。</p>

<pre caption="fdiskのプロンプト">
Command (m for help): 
</pre>


<p>ディスクの現在のパーティションテーブルを表示するには<c>p</c>コマンドを使います。</p>

<pre caption="パーティション設定の一例">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>この例では、7つのLinuxファイルシステム("Linux"と表示)とスワップパーティション("Linux swap"と表示)が設定されています。</p>

<p>ここで、左側に表示されているそれぞれのパーティションの名前が、
<c>/dev/hda1</c>から始まって<c>/dev/hda9</c>まであることに注目してください。
かつては、パーティション作成ソフトウェアは最大4つのパーティション
("プライマリ"パーティションと呼ばれる)しか扱えませんでした。
これは厳しすぎる制限であったため、<i>拡張パーティション</i>と呼ばれるものが導入されました。
この拡張パーティションはプライマリパーティションとよく似ていて、同じく4つまでのパーティションを持つことができます。
しかし、拡張パーティションの中に、
論理パーティションとよばれるパーティションをいくつでも作成することができますので、
結局最大4つまでという制限を回避することができます。
</p>

<p><c>hda5</c>以降の全てのパーティションは論理パーティションです。
1から4まではプライマリまたは拡張パーティションのために予約されています。</p>

<p>つまり、この例では<c>hda1</c>から<c>hda3</c>はプライマリパーティションです。
<c>hda4</c>は拡張パーティションで、<c>hda5</c>から<c>hda9</c>を内包します。
<c>hda4</c>を直接<i>使って</i>ファイルシステムを作成することはできません。
<c>hda5</c>から<c>hda9</c>の入れ物となります。</p>

<p>それぞれのパーティションが"Id"、または"パーティションタイプ"と呼ばれるものを持っていることに気付いたでしょうか。
パーティションを作成したときには、パーティションタイプを正しく設定しているか確認してください。
'83'がLinuxファイルシステムのためのパーティションタイプです。'82'はLinuxスワップパーティションのためのパーティションタイプです。
'fd'はソフトウェアRAIDパーティションを作成するときの推奨パーティションタイプです。
<c>fdisk</c>コマンドでは<c>t</c>コマンドでパーティションタイプを設定することができます。
Linuxカーネルは、起動時にパーティションタイプの設定を使って、ファイルシステムとスワップデバイスを自動的に識別します。</p>
</body>
</section>
<section>
<title>fdiskを使ってパーティションを作成する</title>
<body>

<p>ここまで、Linuxでのパーティション作成について説明しました。
それでは自分でGentoo Linuxをインストールするためのパーティションを作成してください。
パーティションの作成が終わると、次のような表示になるでしょう。</p>

<pre caption="以下の手順を行なうと、次のようにパーティションテーブルが作成されます">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>"初心者"におすすめのパーティション設定は、3つのパーティションから成ります。
最初のパーティション(<c>/dev/hda1</c>)はディスクの先頭に作成された小さなパーティションで、ブートパーティションと呼ばれます。
ブートパーティションはブートに関係する重要なデータ、たとえばGRUBブートローダの設定やLinuxカーネルなど 保持するための領域です。
ブートパーティションはLinuxをブートさせるために必要なもの全てを安全に格納できます。
日常的な利用のときは、ブートパーティションをマウントしていない状態にしておくことで安全性を確保します。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda1</c>となるでしょう。</p>

<p>ブートパーティションは、ディスクの先頭の領域に作成することが推奨されています。
今となっては過去の制約でしかありませんが、
かつてliloブートローダがディスクの1024番目のシリンダ以降の領域にあるカーネルを読みこむことができなかった時代から続く伝統です。</p>

<p>2番目のパーティション(<c>/dev/hda2</c>)はスワップパーティションとして利用する領域です。
カーネルは物理メモリの空き容量が少なくなったとき、スワップスペースを仮想的なメモリとして使います。
このパーティションは他の領域と比較してとても大きいということはありませんが、標準的には512MB前後の大きさで作成されます。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda2</c>となるでしょう。</p>

<p>3番目のパーティション(<c>/dev/hda3</c>)は非常に大きく、ディスクの残りの領域すべてを使って作成されます。
このパーティションは"ルート"パーティションと呼ばれ、Gentoo Linuxそのものを格納するファイルシステムが入ります。
もしSCSIを利用したシステムを使っているなら、このパーティションは<c>/dev/sda3</c>となるでしょう。</p>


<p>パーティション作成を始める前に、Gentoo Linuxをインストールする時に推奨されている、
パーティションとファイルシステムの設定についてまとめておきます。</p>

<table>
	<tr>
	<th>パーティション</th>
	<th>サイズ</th>
	<th>タイプ</th>
	<th>例でのデバイス</th>
	</tr>
	<tr>
	<ti>ブートパーティション(カーネルとブートのために必要な情報を保持)</ti>
	<ti>32メガバイト</ti>
	<ti>ext2/3を強く推奨(最も容易なため)。ReiserFSを使うのであれば、<c>-o notail</c>を付けてマウントすること。ext3/ReiserFSを使うときは、ジャーナルのためのサイズも考慮すること。この場合は、64メガバイトが推奨となる。</ti>
	<ti>/dev/hda1</ti>
	</tr>
	<tr>
	<ti>スワップパーティション(128MBの制限はなくなり2GBまで可能)</ti>
	<ti>一般的に、システムに搭載している物理メモリの1〜2倍のサイズとする。</ti>
	<ti>Linux swap</ti>
	<ti>/dev/hda2</ti>
	</tr>
	<tr>
	<ti>ルートパーティション(/usr、/homeなど、主たるファイルシステム)</ti>
	<ti>&gt;=1.5ギガバイト</ti>
	<ti>ReiserFS/ext3を推奨。ext2でも良い。</ti>
	<ti>/dev/hda3</ti>
	</tr>
</table>

<p>それでは、先程の例と上に示した表に従ってパーティションを作成しましょう。
まず、<c>fdisk /dev/hda</c>(IDE)または<c>fdisk /dev/sda</c>(SCSI)と入力して、fdiskを起動します。
現在のパーティション設定を確認するため、<c>p</c>と入力します。
保存しておかなければならないものがこのディスクにありませんか?
もしあれば、<b>先に進まないでください。</b>
このままこの手順に従ってすすめると、ディスク上の全てのデータが消去されることになります。</p>

<impo>以下で説明する手順では、ディスク上の全てのデータが<b>削除されます</b>!
もしディスクにデータが入っているなら、失ってもかまわないものであることをよく確認してください。
また、うっかり違うドライブのデータを消してしまうことがないように、<b>正しいドライブを選択しているか</b>よく確認してください。</impo>

<p>では、すでにあるパーティションを削除します。<c>d</c>と入力してエンターキーを押してください。
すると何番のパーティションを削除するのか聞いてきます。<c>/dev/hda1</c>を削除するなら、次のようになります。</p>

<pre caption="パーティションの削除">
Command (m for help): d
Partition number (1-4): 1
</pre>

<p>パーティション削除が予定されました。
これによって<c>p</c>ではそのパーティションは表示されなくなりますが、パーティションテーブルを保存するまでは実際には削除されていません。
もし操作を間違ってしまい、変更を取り消したいときは、すぐに<c>q</c>と入力してエンターキーを押してください。</p>
<p>ディスクの全てのパーティションを削除する場合は、<c>p</c>でパーティションを確認して、
<c>d</c>で番号を指定してパーティションを削除することを繰り返してください。
最後には、全てのパーティションが削除されて、次のような表示になるでしょう。</p>

<pre caption="空のパーティションテーブル">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>これでメモリ上のパーティションテーブルは空の状態になり、ブートパーティションを作成する準備が整いました。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>1</c>と入力して1番目のプライマリパーティションを作成します。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、<c>+32M</c>と入力し、32MBのパーティションを作成します。
この手順では、次のように表示されたはずです。</p>

<note>ジャーナルを使うファイルシステムではジャーナル保持のためのスペースを必要とします。標準の設定では約33MBが必要です。
そのため、ジャーナルを使うファイルを<path>/boot</path>として使う場合は、<c>+64M</c>と入力してください。</note>

<pre caption="ブートパーティションを作成する手順">
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +32M
</pre>

<p><c>p</c>と入力してパーティションテーブルを表示してみてください。</p>

<pre caption="最初のパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

<p>次にスワップパーティションを作成します。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>2</c>と入力して2番目のプライマリパーティションを作成します。
この場合は<c>/dev/hda2</c>となります。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、<c>+512M</c>と入力し、512MBのパーティションを作成します。
さらに、パーティションタイプを設定するために<c>t</c>と入力し、"Linux Swap"パーティションタイプの<c>82</c>を入力してください。
その後、<c>p</c>でパーティションテーブルを見ると次のようになるでしょう。</p>

<pre caption="スワップパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

<p>最後にルートパーティションを作成します。
<c>n</c>で新しいパーティションを作成し、<c>p</c>でプライマリパーティションを指定してください。
さらに<c>3</c>と入力して3番目のプライマリパーティションを作成します。
この場合は<c>/dev/hda3</c>となります。
先頭のシリンダ番号を聞かれたら、そのままエンターキーを押します。
最終のシリンダ番号を聞かれたら、そのままエンターキーを押すことでディスクの最後を指定します。
その後、<c>p</c>でパーティションテーブルを見ると次のようになるでしょう。</p>

<pre caption="ルートパーティションが作成されました">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>

<p>最後に、ブートパーティションに"ブート可能"フラグを設定し、これまで設定してきたパーティションテーブルをディスクに書きこみます。
<c>/dev/hda1</c>を"ブート可能"にするには、<c>a</c>と入力した後、ルートパーティションのパーティション番号1を入力します。
ここで<c>p</c>でパーティションテーブルを確認すると、<c>/dev/hda1</c>パーティションの"Boot"フィールドに<c>*</c>がついていることがわかるでしょう。
さて、いよいよディスクにパーティションテーブルを書き込みます。
そのためには、<c>w</c>と入力し、エンターキーを押します。
これで、Gentoo Linuxをインストールするための正しいパーティション設定ができました。</p>

<note><c>fdisk</c>や<c>cfdisk</c>から指示があったら、新しいパーティションを認識できるようにするため、コンピュータを再起動してください。</note>
</body>
</section>
<section>
<title>ファイルシステムの作成</title>
<body>
<p>パーティションを作りましたので、次にブートパーティションとルートパーティションにファイルシステムを作成し、
マウントしたりデータを保存したりできるようにします。
また、スワップパーティションを作成し、スワップ領域が使えるようにします。</p>

<p>Gentoo Linuxはいくつかのファイルシステムをサポートしています。
これらはそれぞれ、強み、弱みを持っており、性能にも特徴があります。
作成できるのは、ext2、ext3、XFS、JFSおよびReiserFSファイルシステムです。</p>

<p>ext2は枯れたLinuxファイルシステムですが、メタデータジャーナリングがありません。
そのため、システム起動時のファイルシステムチェックに長い時間がかかることがあります。
実は<i>ジャーナリング</i>を備えた、より新しいファイルシステムが存在し、
それは素早く整合性を確認できるので、ジャーナリングを備えていないext2より好まれているようです。
ジャーナリングファイルシステムではシステム起動時にファイルシステムに不整合が見つかっても、
待たされることがありません。</p>

<p>ext3はジャーナリングを備えたext2ファイルシステムで、メタデータジャーナリングによって、
素早い復旧だけでなく拡張ジャーナリングモードでfull dataとordered dataジャーナリングが可能です。
ext3は安定した信頼できるファイルシステムです。多くの場合、まずまずの性能を発揮します。
内部構造において&quot;ツリー&quot;のような仕組みを持たないため、条件によって性能が落ちることがあります。
大きなファイルシステムを作成するときや、大きなファイルを取り扱うとき、
またあるディレクトリに大量のファイルを格納するような場合には理想的な選択とは言えません。
しかし、極端な条件でなければ、ext3は優れたファイルシステムと言えます。</p>

<p>ReiserFSはB*-ツリーを基礎として作られたファイルシステムで、非常に良い性能を持っています。
小さなファイル(だいたい4kバイト未満)を扱うときは、ext2やext3よりも非常に高い性能を発揮し、
時には、10〜15倍にも達っします。ReiserFSは大きなファイルシステムなどでも性能を発揮します。
メタデータジャーナリングも備えています。カーネル2.4.18以降、ReiserFSは非常に安定しており、
一般的な目的のファイルシステムはもちろん、大きなファイルや大量の小さなファイルを扱うような極端なケースにおいても推奨されます。
ReiserFSはブートパーティション以外ならいつでもお勧めします。</p>

<p>XFSはメタデータジャーナリングを備えたファイルシステムで、
Gentoo Linuxでは<path>xfs-sources</path>カーネルで完全にサポートされています。
堅牢な特徴を持ち、スケーラビリティを持つように最適化されています。
このファイルシステムはハイエンドのSCSI/fibreチャネルストレージと無停電電源装置を備えたシステムでのみ推奨します。
XFSは積極的に処理中のデータをメモリにキャッシュするため、間違った設計のプログラム
(ファイルをディスクに書き込むときに適切な予防措置を講じていない; そのようなプログラムが数多くあります)を走らせたときに、
不意のダウンによってデータが失われてしまう恐れがあります。</p>

<p>JFSはIBM自身のハイパフォーマンスジャーナリングファイルシステムです。
最近になって商利用に耐えるものになりましたが、充分な資料がないため、
その一般的な安定性については良いとも悪いともコメントできません。</p>

<p>もし、頑丈なジャーナリングファイルシステムが希望なら、ext3を選んでください。
汎用の高性能ファイルシステムがよければ、ReiserFSを選んでください。
ext3とReiserFSはどちらも成熟し洗練されていますのでお勧めです。</p>


<p>さきほど見た例に従うと、パーティションを初期化するコマンドは次のようになります。</p>

<pre caption="パーティションの初期化(参考例)">
# mke2fs -j /dev/hda1
# mkswap /dev/hda2
# mkreiserfs /dev/hda3
</pre>

<p>ブートパーティションの<c>/dev/hda1</c>はext3を選択しました。
堅牢なジャーナリングファイルシステムであるとともに、メジャーなブートローダがサポートしているからです。
スワップパーティションの<c>/dev/hda2</c>を初期化するには<c>mkswap</c>を使います。
これは明白ですね。
そして、メインのルートパーティションである<c>/dev/hda3</c>にはReiserFSを選びました。
頑丈なファイルシステムであり、素晴らしいパフォーマンスをもたらします。
それではパーティションを初期化しましょう。</p>

<p>参考までに、インストール中に利用可能な<c>mkfs</c>コマンドの仲間を紹介します。</p>

	<p><c>mkswap</c>はスワップパーティションを初期化するコマンドです:</p>
<pre caption="スワップの初期化">
# <c>mkswap /dev/hda2</c>
</pre>
<p><c>mke2fs</c>はext2ファイルシステムを作成します:</p>
<pre caption="ext2ファイルシステムの作成">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>ext3ファイルシステムを使うのなら、<c>mke2fs -j</c>コマンドを使います:</p>
<pre caption="ext3ファイルシステムの作成">
# <c>mke2fs -j /dev/hda3</c>
</pre>
	<note>Linux2.4でext3を使用する場合は以下のURLが参考になるでしょう。
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri></note>
        <p>ReiserFSファイルシステムの作成には<c>mkreiserfs</c>を使います:</p>
<pre caption="ReiserFSファイルシステムの作成">
# <c>mkreiserfs /dev/hda3</c>
</pre>
        <p>XFSファイルシステムには<c>mkfs.xfs</c>を使います:</p>
<pre caption="XFSファイルシステムの作成">
# <c>mkfs.xfs /dev/hda3</c>
</pre>
	<note><c>mkfs.xfs</c>コマンドに対し、<c>-d agcount=3 -l size=32m</c>オプションを付加することができます。
	<c>-d agcount=3</c>オプションはアロケーショングループの数を減らします。
	XFSは4Gバイトごとに少なくともひとつのアロケーショングループを必要とします。
	つまり、20Gバイトのパーティションがあった場合、最低でも5つのアロケーショングループが必要になります。
	<c>-l size=32m</c>オプションはジャーナルサイズを32Mバイトに増加させ、パフォーマンスを良くします。</note>

	<p>JFSファイルシステムの作成には<c>mkfs.jfs</c>を使います:</p>
<pre caption="JFSファイルシステムの作成">
# <c>mkfs.jfs /dev/hda3</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>パーティションをマウントする</title>
    <section>
      <body>
	<p>初期化が済んだスワップボリュームを有効にし、後で仮想メモリが必要になったときに使えるようにしておきます。</p>
<pre caption="スワップを有効にする">
# <c>swapon /dev/hda2</c>
</pre>

		<p>次に、<path>/mnt/gentoo</path>と<path>/mnt/gentoo/boot</path>というふたつのマウントポイントを設定し、そこにさきほど作成したパーティションをマウントします。
ブートファイルシステムとルートファイルシステムをマウントした後は、<path>/mnt/gentoo</path>の中に作成されたファイルはすべてそれらのファイルシステム内に格納されます。
もし<path>/usr</path>や<path>/var</path>などのファイルシステムを別々に作成している場合は、それぞれ、<path>/mnt/gentoo/usr</path>や<path>/mnt/gentoo/var</path>としてマウントしてください。
</p>
		<impo> <e>boot</e>パーティション(カーネルを保持しているパーティション) がReiserFSである場合、GRUBが正常にインストールされるように<c>-o notail</c>オプションを使ってマウントしてください。
		さらに<path>/etc/fstab</path>のbootパーティションに<c>notail</c>オプションを追加してください。
		We will get to that in a bit. もしReiserFSでLILOを使う場合は、<c>-o notail</c>オプションは必要ありません。
		どんな場合でも<c>-o notail</c>オプションは安全です。</impo>

<pre caption="マウントポイントの作成">
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
</pre>

		<impo>もしext2のbootパーティションをマウントするときに問題が発生したら、<c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>を試してみてください。</impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ圧縮ファイルとchroot</title>
    <section>
		<title>ステージ圧縮ファイルの選択</title>
      <body>

<p>もしまだなら、ここでどのようにインストールを進めるか決めなければなりません。</p>

<p>&quot;スクラッチから全てを構築&quot;するなら、<path>stage1-x86-1.4_rc4.tar.bz2</path>を使います。
もしサイズの大きい&quot;3stages&quot;ISOのようなCDを使っているなら、stage2やstage3を使うこともできます。
これらを使えば設定の自由度と引き換えに(コンパイラの最適化オプションとUSE変数が既に決められている)、インストール時間を短縮できます。
これらのファイルはCDの<path>/mnt/cdrom/gentoo</path>にあります。
<c>ls /mnt/cdrom/gentoo</c>とすれば、何が利用可能か確認できます。</p>

<p>もしCD上に無い圧縮ファイルを使うのならば、もちろん可能なのですが、以下の手順に従ってダウンロードをしなければなりません。
もし圧縮ファイルを既に持っていてダウンロードの必要がなければ(ほとんどの人がそうでしょう)、&quot;ステージ圧縮ファイルの展開&quot;に進んでください。</p>

<pre caption="必要なステージの圧縮ファイルのダウンロード">
# <c>cd /mnt/gentoo</c>
<comment>lynxを使って、圧縮ファイルのURLを確認してください。</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc4/x86/</c>
<comment>矢印キーの<c>上</c>と<c>下</c>(あるいは<c>タブキー</c>)を使って希望する圧縮ファイルのあるディレクトリに移動してください。
カーソルをダウンロードしたいステージファイルに合わせ、<c>d</c>を押すとダウンロードが始まります。
ファイルに保存してブラウザを終了してください。

<b>あるいは</b>コマンドラインでwgetを使ってダウンロードすることもできます。</comment>
# <c>wget <comment>ここに必要な圧縮ファイルのURLを指定してください。</comment></c>
</pre>
      </body>
    </section>
    <section>
		<title>ステージ圧縮ファイルの展開</title>
      <body>

<p>ここで、選択した圧縮ファイルを<path>/mnt/gentoo</path>に展開します。
展開するのはステージ1、ステージ2、ステージ3のいずれか<b>ひとつ</b>だけです。
つまり、ステージ3からインストールするのであれば、ステージ3圧縮ファイルを展開してください。</p>
<impo><c>tar</c>する時は必ず<c>p</c>オプションを使用してください。
これを怠ると、いくつかのファイルに誤ったパーミッションを与えてしまいます。</impo>

<pre caption="圧縮ファイルの展開">
# <c>cd /mnt/gentoo</c>
<comment>選択した圧縮ファイルに合わせて、&quot;stage3&quot;を&quot;stage2&quot;や&quot;stage1&quot;に変えてください。</comment>
<comment>ダウンロードした圧縮ファイルを使うときは、パスの先頭が&quot;/mnt/cdrom/gentoo/&quot;ではなく&quot;/mnt/gentoo/&quot;になります。</comment>
# <c>tar -xvjpf /mnt/cdrom/gentoo/stage3-*.tar.bz2</c>
</pre>

<p><path>/mnt/gentoo</path>にダウンロードされた圧縮ファイルは、展開したあとで次のように入力して削除することができます: <c>rm /mnt/gentoo/stage*.tar.bz2</c></p>
</body>
</section>
<section>
<title>chrootの実行</title>
<body>
<p>次にGentoo Linuxのインストールを進めていくために、<c>chroot</c>を使ってGentoo Linuxシステムに「入り」ます。</p>

<note><c>env-update</c>を実行したときに<path>/etc/make.profile/make.defaults</path>が利用できないというメッセージが表示されますが、無視してください。
あとで<c>emerge sync</c>を実行しますが、それによってこの問題は解消します。</note>

<pre caption="下準備してchroot環境に入る">
# <c>mount -t proc proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
<comment>(上のコマンドはシェルに新しい検索パスを設定し更新されたバイナリが使えるようにする)</comment>
</pre>
	<p>このコマンドを実行すれば<path>/mnt/gentoo</path>に作成されたGentoo Linux環境の「中」に入ることができます。
		以下の手順はこのchroot環境内で進めます。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最新のPortage Treeを取得する</title>
    <section>
      <body>
	  
<p>ここで、<c>emerge sync</c>を実行してください。これにより、最新のPortageツリーを取得できます。
Portageツリーには、Gentoo Linuxでパッケージを構築するための全てのスクリプト(ebuildと呼びます)が収められています。
現在、4000パッケージ近くのebuildスクリプトがあります。
<c>emerge sync</c>が完了すると、<path>/usr/portage</path>以下に完全なPortageツリーが格納されます。</p>

<pre caption="syncを使って更新する">
# <c>emerge sync</c>
</pre>
 
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentooシステムの最適化オプションを設定する(make.conf)</title>
    <section>
      <body>

<p>Portageツリーをコピーできたので、次に最適化とパッケージ構築の設定をします。
Portageはどんなプログラムをコンパイルするときでもこの設定を使います。
設定するには<path>/etc/make.conf</path>ファイルを編集します。
このファイルでは、パッケージに組み込みたい機能を指定するUSE変数やをセットしてください。
一般的にはデフォルト（空かセットなし）でいいでしょう。
<c>USE</c>フラグに関しては、<uri link="/doc/en/use-howto.xml">ここ</uri>(<uri link="/doc/ja/use-howto.xml">日本語訳</uri>)に詳しい説明があります。
現在の全USEフラグのリストは<uri link="http://www.gentoo.org/dyn/use-index.xml">ここ</uri>にあります。</p>
<p>お使いのハードウェアに合わせて、<c>CHOST</c>、<c>CFLAGS</c>、<c>CXXFLAGS</c>変数もそれぞれセットしてください（下の方に設定例が載っています）。
これらの変数は、CとC++コンパイラが生成するコードの最適化などを指定するオプションとして使われます。
例えば、Athlon XPプロセッサを使っているユーザはCFLAGSとCXXFLAGSに&quot;-march=athlon-xp&quot;を設定します。
これによって、そのCPUに適した命令セットを使って最適化されたパッケージを構築できます。
<path>/etc/make.conf</path>には、正しくCFLAGSとCXXFLAGSを設定するための一般的な解説が書かれています。</p>
			
<p>ファイアウォールが設置されている場合はここでプロクシ情報をセットできます。
<path>/etc/make.conf</path>を編集するには、<c>nano</c>というシンプルなスクリーンエディタが使えます。</p>
<pre caption="make.confを編集する">
# <c>nano -w /etc/make.conf</c>
<comment>(CHOST, CFLAGS, CXXFLAGSとUSEフラグ、プロキシ設定を編集する)</comment>
</pre>
		<note>ビルドプロセスに手を加えたいときは、<path>/etc/make.globals</path>を参照してください。
		このファイルは、Gentooで使われるデフォルト値を保持しており、書き換えないようにすべきです。
		デフォルトで不十分な場合は、新しい値を<path>/etc/make.conf</path>に書き込んでください。
		<path>make.conf</path>で指定された値は、<path>make.globals</path>の設定を<comment>上書き</comment>します。
		ここで見つけたUSE設定を無効にしたいときは、適切な<c>USE=&quot;-foo&quot;</c>(<c>foo</c>を無効にしたい場合)を/etc/make.confに追加してください。</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ１から始める場合</title>
    <section>
      <body>
		<note>ステージ1から始める人以外は、このセクションを飛ばしてください。</note>
		<p>ステージ1圧縮ファイルを使うと徹底的にカスタマイズと最適化をすることができます。
		この圧縮ファイルを選択したのは、最適化された最新のシステムを求めているかだと思います。
		最適化こそがGentoo Linuxの本質です。お楽しみください。
		ステージ1からインストールには長い時間がかかりますが、その見返りとして特定のマシンとニーズに合わせ隅々まで最適化されたシステムを手に入れることができます。</p>
		<p>「ブートストラップ」プロセスを開始します。
		AMD Athlon 1200Mhzで約2時間かかります。
		このプロセスでは、残りのシステムをコンパイルするために、展開されたビルドイメージが準備されます。
		GNUコンパイラ一式とGNU Cライブラリが構築されます。
		これらは時間がかかる処理で、ブートストラッププロセスの大半が構成されます。
		以下のようにしてブートストラップを始めてください。</p>
<pre caption="ブートストラッピング">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
</pre>
		<p>「ブートストラップ」プロセスが開始します。</p>
		<note>デフォルトのPortageはパッケージのビルド中に一時的に<c>/var/tmp</c>を数百Mバイト使用する時があります。
		一時ファイルの場所を変更している場合は、<e>ブートストラッププロセスを始める前に</e>PORTAGE_TMPDIR変数を変更してください。</note>
<pre caption="Portageの作業ディレクトリの設定">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
</pre>
		<p><c>bootstrap.sh</c>は<c>binutils</c>、<c>gcc</c>、<c>gettext</c>、<c>glibc</c>を構築し、<c>glibc</c>が構築された後、<c>binutils</c>、<c>gcc</c>、<c>gettext</c>を再構築します。
		言うまでもなく、このプロセスには時間がかかりますので、昼寝でもしていてください。
		このプロセスが終了すると&quot;ステージ2&quot;から始めたシステムと同じ状態になります。次に進んでください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ２から始める場合、あるいはステージ１からの続き</title>
    <section>
      <body>
	  	
		<note>このセクションはステージ1かステージ2から始めた人が対象ですので、ステージ3から始める人は次のセクションに進んでください。</note>
		<p>ステージ2の圧縮ファイルを使うと、既にブートストラップが済んだ状態から始めることができます。
		残りのシステムのインストールを始めましょう。</p>
		<note>ステージ2から始めた場合は、ここでコンパイラ一式が最新の状態になるようにできます。
		以下のコマンド(<c>emerge</c>)に<c>-u</c>オプションを付けてください。
		これがどういう意味か判らないなら、この注釈は無視して構いません。</note>

<pre caption="残りのシステムをインストールする">
# <c>emerge -p system</c>
<comment>(インストールされるパッケージが一覧表示される)</comment>
# <c>emerge system</c>
</pre>
		<p>ベースシステム全体を構築するにはまとまった時間が必要です。
		そのかわりシステムは徹底的に最適化されます。
		もちろん暇つぶしの方法を見いださなければなりませんが。
		作者はプレイステーション2用ソフト「Star Wars - Super Bombad Racing」をおすすめします。</p>
		<p>システムの構築は終了しました。&quot;タイムゾーン設定&apos;に進んでください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ステージ３から始める場合</title>
    <section>
      <body>
		<note>このセクションはステージ3から始める人に向けたものですので、それ以外の人は次のセクションに進んでください。</note>
		<p>ステージ3の圧縮ファイルは完全に機能する基本的なGentoo Linuxシステムを含んでいますので、構築の手順は不要です。
		ただし、あらかじめコンパイルされたものですので、最新ではなくなっているかも知れません。
		もし気になるようなら、次の手順を踏むことで、自動的に現在のステージ3システムを最新バージョンのパッケージで置き換えることができます。
		ステージ3圧縮ファイルが古い場合、この処理には長い時間がかかるかもしれません。
		そうでなれば、一般的には短時間で最新バージョンへのアップデートやバグフィクスされたパッケージが得られます。
		なお、これらの手順を踏まずに次のセクションに進んだとしても、なんの問題もありません。</p>
		
<pre caption="最新のパッケージに更新する">
# <c>export CONFIG_PROTECT="-* /etc/make.conf"</c>
# <c>emerge -up system</c>
<comment>(インストールされるパッケージの一覧が表示される)</comment>
# <c>emerge -u system</c>
<comment>(パッケージのインストールが実行される)</comment>
# <c>unset CONFIG_PROTECT</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>タイムゾーン設定</title>
    <section>
      <body>
	<p>ここではタイムゾーンの設定を行ないます。</p>
	<p><path>/usr/share/zoneinfo</path>のなかからタイムゾーン（グリニッジ標準時を使用するならGMT）を選んでシンボリックリンクを作成してください。</p>
<pre caption="タイムゾーンを設定するためにシンボリックリンクを作成する">
# <c>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>カーネルとシステムロガーのインストール</title>
    <section>
      <body>
	<note>次に進む前に<path>/etc/make.conf</path>を自分の好みにあうように編集しておいてください。</note>
	<p>Linuxのカーネルソースをインストールします。Gentoo Linuxはたくさんのカーネルebuildを提供しています。
	一覧が<uri link="/doc/en/gentoo-kernel.xml">ここ</uri>にあります。
	どのカーネルソースを選べばよいかわからなければ、<c>gentoo-sources</c>か<c>vanilla-sources</c>にすると良いでしょう。
	XFSサポートが必要なら、<c>xfs-sources</c>を選んでください。
	ちなみに、GentooのLiveCDは<c>xfs-sources</c>を使っています。</p>
		<warn>自分でカーネルを設定して使う場合は、<i>grsecurity</i>オプションに注意してください。
		セキュリティの設定をきつくしすぎると、いくつかのプログラム(たとえばXなど)が正常に動作しなくなる恐れがあります。
		必要かどうかわからない場合は、無効にしておきましょう。</warn>
		<p>上からひとつを選び、下記のようにインストールしてください。</p>
<pre caption="カーネルソースをemergeする">
# <c>emerge sys-kernel/gentoo-sources</c>
</pre>
		<p>カーネルソースの準備ができたら、好みに応じてカスタマイズしてカーネルをコンパイルしてください。</p>
		<p><path>/usr/src/linux</path>がシンボリックリンクであることに注意してください。
		このリンクはPortageによってカーネルソースがemergeされるときに自動的に作成されるものです。
		もし複数のカーネルソースをemergeしているなら、先に進む前に<path>/usr/src/linux</path>のシンボリックリンクを適切に作り直してください。</p>
	<note>カーネルの設定をLiveCDと同じにしたい、あるいはLiveCDの設定を元にしたい場合は、次のようにしてください。
	<c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c>
	<c>xfs-sources</c>以外のカーネルを使っている場合は、
	選んだカーネルと<c>xfs-sources</c>とで異なる部分に関して、いくつか質問に答える必要があるかもしれません。</note>
<pre caption="Linuxカーネルの設定">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
</pre>
	<warn>カーネルを正常に機能させるために必要なオプションが正しくカーネルに組み込まれているかどうかを確認してください。
	つまり、これらは<i>有効でかつモジュールではない状態</i>でコンパイルされねばなりません。
	ReiserFSファイルシステムを使用している場合は ReiserFSオプションを有効にします。&quot;Ext3&quot;も同様です。
	XFSファイルシステムを使用している場合は&quot;SGI XFS filesystem support&quot;オプションを有効にします。
	どのような場合でも&quot;Ext2&quot;オプションを有効にしておくと良いでしょう。
	以下に必要となるであろう、一般的なオプションの一覧を示します。</warn>
<pre caption="重要なカーネルオプション">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(下に示したオプションのうち、いくつかはこれを有効にしないと現れない)</comment>
     ...

File systems ---&gt;
  &lt;*&gt; Reiserfs support
<comment>(ReiserFSを使うときに必要)</comment>
       ... 
  &lt;*&gt; Ext3 journalling file system support
<comment>(ext3を使うときに必要)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Gentoo Linuxでは必須)</comment>
       ...
  &lt;*&gt; JFS filesystem support
<comment>(JFSを使うときに必要)</comment>
       ...
  [*] /proc file system support
<comment>(Gentoo Linuxでは必須)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot          
<comment>(Gentoo Linuxでは必須)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(不要なのでチェックを外す)</comment>
       ...
  &lt;*&gt; Second extended fs support
<comment>(ext2を使うときに必要)</comment>
       ...
  &lt;*&gt; XFS filesystem support
<comment>(XFSを使うときに必要)</comment>
</pre>
<p>ハードウェアRAIDを使っているなら、カーネルのオプションをいくつか有効にする必要があります。
		HighpointのRAIDコントローラを使っている場合は&quot;hpt366 chipset support&quot;、&quot;support for IDE RAID controllers&quot;、&quot;Highpoint 370 software RAID&quot;を選択してください。
		PromiseのRAIDコントローラを使っている場合は、&quot;PROMISE PDC202{46|62|65|67|68|69|70} support&quot;、&quot;support for IDE RAID controllers&quot;、&quot;Support Promise software RAID (Fasttrak(tm))&quot;を選択してください。</p>
		<p>インターネット接続にPPPoEを使っているなら、以下のオプションを選択してください(ビルトインか、できればモジュール)。
		&quot;PPP (point-to-point protocol) support&quot;、 &quot;PPP support for async serial ports&quot;、&quot;PPP support for sync tty ports&quot;。
		これらの2つの圧縮に関するオプションは組込まれても害はありませんが不要です。
		&quot;PPP over Ethernet&quot;オプションも、<i>rp-pppoe</i>がカーネルモードPPPoEをで動作するときに利用されるだけです。</p>
		<p>もし、IDE CD-Rを使うならば、SCSIエミュレーションを利用できるようにしてください。
		&quot;ATA/IDE/MFM/RLL support&quot; ---> &quot;IDE, ATA and ATAPI Block devices&quot; ---> &quot;SCSI emulation support&quot;をチェックしてください（筆者はいつもモジュールとしてインストールします）。
		そして&quot;SCSI support&quot;の&quot;SCSI support&quot;、&quot;SCSI CD-ROM support&quot;と&quot;SCSI generic support&quot;をチェックしてください（これも筆者はいつもモジュールとしてインストールします）。
		モジュールとしてインストールしたならば、<c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot; >> /etc/modules.autoload</c>として、ブート時に読み込まれるようにしてください。</p>
		<note> 2.2カーネルベースのGentoo Linuxをインストールすることもできます。
		安定性と引き換えに 2.4カーネルの素晴らしい特徴（XFSファイルシステムとtmpfsファイルシステムやiptablesなど）が使えなくなります。
		ただし、 ReiserFSファイルシステムやdevfsはパッチを当てることで使えるようにできます。 
		Gentoo LinuxのブートスクリプトはtmpfsかRAMディスクのどちらかを必要としますので、2.2カーネルを使用する際にはRAMディスクサポートを組み込んでください（モジュールではなく）。
		<comment>必ず</comment><path>/boot/grub/grub.conf</path>ファイルに<e>gentoo=notmpfs</e>と記述して、RAMディスクをtmpfsのかわりにブートスクリプトにマウントしてください。
		devfsを使わないならば<e>gentoo=notmpfs,nodevfs</e>と記述してください。</note>

<pre caption = "カーネルのコンパイルとインストール">
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>

		<p>これでカスタマイズされたカーネル(とモジュール)がインストールされました。
		続いて、インストールしたいシステムロガーを選んでください。
		伝統的なシステムロギングデーモンのsysklogdが利用できます。
		またmsyslog、syslog-ng、metalogも選択できます。
		パワーユーザはsysklogd(パフォーマンスがあまりよくありません)を離れ、
		より新しい別の選択肢を好むようです。
		どれにするか迷っているなら、多くの人が使っているようなのでmetalogを選んでもよいでしょう。
		次の4つのロガーからひとつを選んでください。</p>
<pre caption="システムロガーを選択しemergeする">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>または</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>または</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>または</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
</pre>
		<impo> metalogは一括して出力をディスクに流し込みます。
		そのため、システムログが継続的に記録されるわけではありません。
		デーモンのデバッグを行なう時には、このパフォーマンス向上のための動作はかえって邪魔になるでしょう。
		Gentoo Linuxでは、一時的にメッセージバッファを止めるために（<i>tail -f <path>/var/log/everything/current</path></i>コマンドがリアルタイムで実行されることを期待して）metalogデーモンにUSR1信号を送ることができます。
		メッセージバッファを働かせるためにはUSR2信号を送ってください。
		常にバッファリングを無効にするには、<path>/etc/conf.d/metalog</path>の中のMETALOG_OPTS="-B"をMETALOG_OPTS="-B -s"に書き換えてください。</impo>
<pre caption="metalogのバッファリングを制御する">
<codenote>バッファリングを無効にする</codenote>
# <c>killall -USR1 metalog</c>
<codenote>バッファリングを有効にする</codenote>
# <c>killall -USR2 metalog</c>
</pre>
		<p>次にdcron、fcron、vcronの中から好みのcronを選んでください。
		どれを選べば分からない時はvcronをおすすめします。
		次のようにインストールしてください。</p>
<pre caption="cronデーモンを選択する">
# <c>emerge sys-apps/dcron</c>
# <c>rc-update add dcron default</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge sys-apps/fcron</c>
# <c>rc-update add fcron default</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge sys-apps/vcron</c>
# <c>rc-update add vcron default</c>
<comment>vcronを使う場合は、<c>crontab /etc/crontab</c>する必要はありません。</comment>
</pre>
		<p>起動時に実行されるプログラムやデーモンに関しては、<uri link="/doc/en/rc-scripts.xml">rc-script guide</uri>(<uri link="/doc/ja/rc-scripts.xml">日本語訳</uri>)を参照してください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>必要なパッケージのインストール</title>
    <section>
      <body>
	<p>もしネット接続にrp-pppoeが必要なら、まだインストールされていませんので、ここでインストールしてください。</p>
<pre caption="rp-pppoeのインストール">
# <c>USE="-X" emerge rp-pppoe</c>
</pre>

		<note><i>USE="-X"</i>はpppoeのXインタフェースがインストールされるのを防ぎます。
		これによって、XやXが依存するパッケージまでもがemergeされてしまうことを避けることができます。
		Xサポートが必要なら、後で<i>rp-pppoe</i>をemergeしなおすことができます。</note>
		<note>rp-pppoeはインストールされましたが、まだ設定されていません。
		はじめにGentooシステムをブートしたとき、もう一度 <c>adsl-setup</c> を実行してください。</note>
		<p>もしXFSやReiserFS、LVMといったオプション機能を使うのなら、 Portageツリーの他の追加パッケージも必要となります。
		もしXFSを使うのなら、<c>xfsprogs</c>をemergeしてください。</p>
<pre caption="ファイルシステムツールのemerge">
# <c>emerge sys-apps/xfsprogs</c>
<comment>ReiserFSを使うときはReiserFS toolsをemergeしてください</comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>JFSを使うときはJFS toolsをemergeしてください</comment>
# <c>emerge jfsutils</c>
<comment>LVMを使うときは、<c>lvm-user</c>パッケージをemergeしてください</comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>
		<p>もしラップトップを使っていて、rebootしたあともPCMCIAスロットを使いたいのなら、<i>pcmcia-cs</i>パッケージをインストールしてください。</p>
<pre caption="PCMCIA-csのemerge">
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
		<warn>PCMCIAを機能させるためには、インストールがすべて終わったあとで再度<i>pcmcia-cs</i>をemergeしなおす必要があるでしょう。</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>/etc/fstabを書き換える</title>
    <section>
      <body>
		<p>ここまでの作業でGentoo Linuxシステムはほぼ完成しました。
		あとは重要なシステムファイルを作成し、GRUBブートローダーをインストールします。
		まず、<path>/etc/fstab</path>ファイルを編集します。
		ReiserFSファイルシステムを使用する場合は<c>notail</c>オプションをbootパーティションに付加するのを忘れないでください。
		<c>ext2</c>、<c>ext3</c>や<c>reiserfs</c>などのファイルシステムのタイプも指定してください。</p>
		<p>下記の<path>/etc/fstab</path>のように設定してください。
		もちろん、&quot;BOOT&quot;、&quot;ROOT&quot;、&quot;SWAP&quot;のデバイス名を実際のデバイス名（<c>hda1など</c>）に変更してください。</p>
<pre caption="fstabの編集">
<comment>
# /etc/fstab: 静的なファイルシステム設定.
#
# noatime はパフォーマンスを向上させます (atimesは通常は必要ありません)
# notail は ReiserFS のパフォーマンスを向上させます (ディスク効率が犠牲になります)
# noatimeを削っても安全です。また、notailとtailは自由に切り替えられます。

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: もしBOOTパーティションがReiserFSなら、notailオプションを加えてください。
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>
		<warn><i>/boot</i>がブート時にマウントされないことに気づいたでしょうか。
		これは/bootが破壊されることを防ぐためです。
		/bootにアクセスする必要があるときは、マウントしてください。</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Rootのパスワードを設定する</title>
    <section>
      <body>
	<p>忘れないうちに、rootのパスワードを設定しましょう。</p>
<pre caption="rootパスワード設定">
# <c>passwd</c>
</pre>

	<p>日常的な利用のためにroot以外のユーザを追加することができます。
	<uri link="/doc/en/faq.xml">Gentoo FAQ</uri>(<uri link="/doc/ja/faq.xml">日本語訳</uri>)を参照してください。</p> 
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ホスト名を設定する</title>
    <section>
      <body>
        <p><path>/etc/hostname</path>を編集して、ホスト名だけを1行目に書き込んでください。</p>
<pre caption="ホスト名の設定">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>
	<p>次に<path>/etc/dnsdomainname</path>を編集して、DNSドメイン名を書き込んでください。</p>
<pre caption="ドメイン名の設定">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>
	<p>NISドメインを使っているなら、<path>/etc/nisdomainname</path>を編集してください。</p>
<pre caption="NISドメイン名の設定">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>/etc/hostsを書き換える</title>
    <section>
      <body>
	<p>このファイルにホストネームとIPアドレスを書き込んでください。
		ネームサーバに無いホストネームとIPアドレスの解決に使用されます。
		以下にこのファイルのテンプレートを示します。</p>
<pre caption="Hosts テンプレート">
127.0.0.1      localhost
<comment># 次の行にはローカルLANのIPとマシン名を記述します</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>
	<note>DHCPサーバを使ったネットワークにいるなら、<i>localhost</i>をあなたのマシンの名前に設定するとよいでしょう。
		GNOMEやその他の多くのプログラムが名前解決するときの助けとなります。</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ネットワークの設定</title>
    <section>
      <body>
		<p><path>/etc/modules.autoload</path>ファイルにシステムに必要なモジュールを書き込んでください（その他のオプションがあれば、ここに書き込んでください）。
		Gentoo Linuxがブートする時、これらのモジュールが自動的に読み込まれます。
		特に重要なものがモジュールとしてコンパイルした場合のイーサネットカードモジュールです。</p>
		<pre caption="/etc/modules.autoload">
<comment>ここでは3comのカードを使っていると仮定しています。
<path>/lib/modules/`uname -r`/kernel/drivers/net</path>を見て、自分のカードを探してください。</comment>
3c59x
		</pre>
		<p>ブート時にネットワークの設定を読み込ませるために<path>/etc/conf.d/net</path>スクリプトを編集してください。</p>
<pre caption="ブート時のネットワーク設定">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
</pre>
		<p>もし、複数のネットワークカードやトークンリングインタフェースを使用しているなら、それぞれに<path>net.eth<comment>x</comment></path>スクリプト（<comment>x</comment>=1,2,…）を作成してください。</p>
<pre caption="複数のネットワークインタフェース">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
</pre>
		<p>PCMCIAカードをインストールしている場合は、<path>/etc/init.d/pcmcia</path>の中を見て問題ないか確認し、<path>/etc/init.d/net.eth<comment>x</comment></path>の一番上に以下を追加してください。</p>
<pre caption="/etc/init.d/net.ethxにPCMCIAへの依存関係を記述する">
depend() {
	need pcmcia
}
</pre>
		<p>ネットワーク設定が読み込まれる際、自動的にPCMCIAドライバが読み込まれます。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最終ステップ: 基本設定を行う(キーマップの設定など)</title>
    <section>
      <body>
<pre caption="基本設定">
# <c>nano -w /etc/rc.conf</c>
</pre>
		<p>基本設定を行うには、ファイル内の指示に従ってください。
		<c>CLOCK</c>が望みどおりに設定されているか確認しましょう。
		またKEYMAP変数が合っているか見てください。
		設定できるキーマップを見つけるには<path>/usr/share/keymaps</path>の中を探してください。</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ブートローダを組み込む</title>
	<section>
	<title>注意事項</title>
	<body>
	<p>ブートローダも、Gentooらしく複数の中から利用するものを選択することができます。
	今のところバーチャルパッケージシステムを使うことによって、GRUBとLILOのどちらかを選べます。</p> 
		<p>気をつけて欲しいのは、両方をインストールする必要などないということです。
		むしろトラブルの原因となりますので、どちらか一方を選択するようにしてください。</p>
	<impo>NVIDIAのnForce又はnForce2チップセットと内蔵のGeForceグラフィックスカードを使ったシステムに
Gentoo Linuxをインストールするときは、GRUBではなくLILOを使わなければなりません。
オンボードビデオが有効のときメインメモリのthe low memory領域がビデオRAMとして使われます。
GRUBもthe low memory領域とブート時に使うため、&quot;out of memory&quot;(メモリ不足)となってしまいます。
そのため、nForceシステムや場合によっては他のオンボードビデオを使うときにはLILOを使ってください。
オンボードビデオを無効にしているとしても、
万一のときにオンボードビデオを有効にしてグラフィックスカードを取り外すことができるといいと思いませんか ;)</impo>

	<p>カーネルにフレームバッファを組み込んでいるなら、
カーネルパラメータとして<c>vga=xxx</c>をブートローダの設定ファイルに書き加えるとよいでしょう。
<c>xxx</c>は次の表から選んでください。</p>
<table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>
	</body>
	</section>
    <section>
	<title>GRUBを設定する</title>
      <body>
		<p>GRUBを理解するのにもっとも重要なことは、GRUBがどうやってハードディスクとパーティションを参照するかということです。
		<path>/dev/hda1</path>パーティションはGRUBでは<path>(hd0,0)</path>と呼ばれます。
		hd0,0をカッコでくくる点に注意してください。
		ハードディスクはaからではなく0から数えます。パーティションは1からではなく0から数えます。
		注意しなければならないのは、数えられるのはハードディスクだけ、という点です。
		CD-ROMプレイヤーやライターといったATAPI-IDEデバイスは数えられません。
		これはSCSIでも同じです(通常、SCSIはIDEより大きな番号が割り当てられます。
		ただし、BIOSでSCSIからブートするようになっている場合を除きます)。
		たとえば、ハードディスクが /dev/hda、CD-ROMドライブが /dev/hdb、CD-Rが /dev/hdc、二つ目のハードディスクが /dev/hddだとすると、<path>/dev/hdd7</path>は変換されて<path>(hd1,6)</path>となります。
		これはトリッキーに見えますし、実際にトリッキーなのですが、grubはtabキーによる補完の機能をもっているので、ハードディスクやパーティションがたくさんあってもgrubの番号付けで混乱することは少ないでしょう。
		感じが掴めたら、GRUBをインストールしましょう。</p>
		<p>GRUBをインストールするもっとも簡単な方法は、chrootから<c>grub</c>とタイプすることです。</p>
<pre caption="GRUBのインストール">
# <c>emerge grub</c>
# <c>grub</c>
</pre>
		<impo>もしハードウェアRAIDを使っているのなら、ここの記述はうまく動かないでしょう。
		次のセクションにいき、<path>grub.conf</path>を作成してください。
		その後RAIDコントローラ用のgrub設定を完了させます。</impo>
		<p><c>grub&gt;</c>というgrubのコマンドラインプロンプトが表示されているでしょうか。
		ここではハードディスクにGRUBブートローダをインストールするために正しくコマンドを入力してください。
		設定例では、GRUBブートローダをハードディスクのMBR(マスターブートレコード)にインストールするので、コンピュータを起動したとき最初に目にするものが GRUBプロンプトになります。
		この場合は、次のように入力します。</p>

<pre caption="GRUBをMBRにセットアップする">
grub&gt; <c>root (hd0,0)</c> <codenote>ブートパーティション</codenote>
grub&gt; <c>setup (hd0)</c> <codenote>ブートレコードがインストールされている場所。この例ではMBR。</codenote>
</pre>
	
<pre caption="MBR以外にセットアップする">
<comment>MBRではないところにブートローダをインストールする場合</comment>
grub&gt; <c>root (hd0,0)</c> <codenote>ブートパーティション</codenote>
grub&gt; <c>setup (hd0,4)</c> <codenote>ブートレコードがインストールされている場所。この例では/dev/hda5。</codenote>
grub&gt; <c>quit</c>
</pre>
        
		<p>このふたつのコマンドの意味を説明します。
		<c>root ( )</c>はGURBにブートパーティション（上の例で言えばGURBの<path>(hd0,0)</path>つまり<path>/dev/hda1</path>）の位置を教えます。
		<c>setup ( )</c>はGRUBに<c>root ( )</c>で指定したブートパーティションを探すためのブートレコードをどこにインストールするのかを教えます。
		上の例では、ブートレコードをハードディスクのMBRにインストールするので、単純に<path>/dev/hda</path>（GRUBでは<path>(hd0)</path>です）と指定します。
		もしほかのブートローダを使用していて、GRUBをセカンダリ・ブートローダとしたいのであれば、GRUB を特定のパーティションにインストールすることができます。
		その場合はディスク全体ではなく、特定のパーティションを指定します。
		GRUBのインストールに成功したら、<c>quit</c>とタイプしてGRUBを終了してください。</p>

		<note> grubのTAB補完はgrub内で使えます。
		<c> root (</c>と書いてからTABを押すと利用可能なデバイスの一覧(ハードディスクだけではありません)が表示されます。
		<c> root (hd</c>を入力してからTABを押すと利用可能なハードディスクを一覧表示します。
		<c> root (hd0,</c>と書いてからTABを押すと最初のハードディスクのパーティションが一覧表示されます。
		補完機能を使いながら、構文のチェックをすると正しい選択をしているか確認するのに役立ちます。</note>
			
		<p>これで Gentoo Linuxがインストールされました。
		しかし、システムをリブートしたとき、感じのいいGRUBブートメニューを表示させるには、<path>/boot/grub/grub.conf</path>を作成しなければなりません。
		方法は以下のとおりです。</p>
		<impo>GRUBの下位互換性を保つため、<i>grub.conf</i> から <i>menu.lst</i>へ忘れずにリンクを作成してください。
		これは、<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>として実行します。</impo>
		<p>grub.confファイルを作成し(<c>nano -w /boot/grub/grub.conf</c> としてください)、以下の内容を書き込みます。</p>
<pre caption="grub.confの例">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment># ハードウェアRAIDを使う場合の例</comment>
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment># デュアルブートする場合の例</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>
		<note>(hd0,0) は括弧内に空白を入れずに記述しなければなりません。</note>
		<impo> IDE CD-R用にSCSIエミュレーションを設定しているなら、カーネルの引数に&quot;hdx=ide-scsi&quot;を追加してください（hdxはCD-Rの位置に合わせてください）。</impo>
		<p>このファイルを保存すれば、Gentoo Linuxのインストールは完了します。
		第一オプションを選択しておけば、何もしなくてもGRUBはGentoo Linuxをブートします。
		grub.confファイルの2番目の部分はGRUBでWindowsをブートする方法を示したものです。</p>
		<note>上で述べた<path>(hd0,0)</path>は&quot;boot&quot;パーティション（例では<path>/dev/hda1</path>）を指しています。
		<path>/dev/hda3</path>はrootパーティションを指しています。
		<path>(hd0,5)</path>にはNTブートローダーが存在しています。</note>
		<note>カーネルイメージへのパスはbootパーティションに応じて変わります。
		もしブートパーティション<path>(hd0,0)</path>とルートパーティション<path>(hd0,1)</path>を持っているなら、
		上記のgrub.confのすべてのパスは<path>/bzImage</path>になります。</note>
		<p>カーネルに引数を与える必要があるならば、<c>kernel</c>コマンドの後に追加してください。
		上の例ではすでにひとつの引数（<c>root=/dev/hda3</c>）を与えていますが、さらに引数を与えることができます。
		<c>kernel</c>コマンドに<c>gentoo=nodevfs</c>を追加することにより、デフォルトでdevfsをオフにすることができます（意味が分からない場合は行なわないでください）。</p>
		<note>初期のGentoo Linuxには当てはまりませんが、devfsを有効にするために<c>kernel</c>コマンドに<c>devfs=mount</c>を追加する必要はありません。
		rc6ではdevfsはデフォルトで有効になっています。</note>
      </body>
    </section>
	<section>
    <title>LILOを設定する</title>
      <body>
		<p>GRUBは多くの人にとって新しい選択肢ですし、いつも安定しているというわけではありません。
		LILO(LInuxLOader)はその点ではLinuxブートローダとしての実績があります。
		安定性や設定が複雑すぎないことを求めるなら、LILOを試してみてください。</p>
		<p>まず、LILOをemergeしてください。</p>
<pre caption="LILOをemergeする">
# <c>emerge lilo</c>
</pre>
		<p>ではLILOの設定をしましょう。簡単な例を紹介し、その中身の説明をします。</p>
<pre caption="lilo.confの例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3
	
#windowsなど他のOSとデュアルブートする場合
other=/dev/hda1
	label=dos
</pre>
		<ul>
		<li><i>boot=/dev/hda</i> はLILO自身を最初のIDEコントローラ上の最初のハードディスクにインストールするように指示します。</li>
		<li><i>map=/boot/map</i> はマップファイルを指定します。通常これを書き換えるべきではありません。</li>
		<li><i>install=/boot/boot.b</i> は新たにブートセクタに書き込むファイルを指示します。
		通常はこれを書き換えるべきではありません。
		この行がないときは、デフォルトの/boot/boot.bが使われます。</li>
		<li><i>prompt</i>があるとき、LILOは何が参照されたかをメッセージラインに出力します。
		これを削除することは推奨されませんが、消してしまった場合はマシンがブートするときに[Shift]キーを押しつづけることでプロンプトを出すことができます。</li>
		<li><i>timeout=50</i> はLILOがデフォルトの設定を使ってブートする前にユーザの入力を待つ時間の長さを指定します。
		これは1/10秒単位で、デフォルトは50です。</li>
		<li><i>message=/boot/message</i> はLILOがユーザにオペレーティングシステムやカーネルを選択してもらう時に表示する画面を指示します。</li>
		<li><i>lba32</i> はハードディスクのジオメトリをLILOに知らせます。
		よく使われるものとしては、他にlinearがあります。
		何を意味しているのか良くわからないときは変更するべきではありません。
		システムがブートできなくなってしまうことがあります。</li>
		<li><i>default=linux</i> はデフォルトでブートするオペレーティングシステムを指定します。
		linuxは、その下で定義されるブートオプションの名前です。</li>
		<li><i>image=/boot/vmlinuz-2.4.20</i> はそのブートオプションで使われるLinuxカーネルを指定します。</li>
		<li><i>label=linux</i>は、LILOの画面表示で使われるブートオプションの名前を指定します。
		この場合は、defaultの行で指定されている名前でもあります。</li>
		<li><i>initrd=/boot/initrd-2.4.20.img</i> は初期化用RAMディスクイメージを指定します。
		このイメージはブート時にデバイスを初期化・開始し、カーネルが起動できるようにします。
		初期化用RAMディスクは、カーネルを読み込むために必要な、SCSIカード、ハードディスクなどの機械依存のドライバを保持しています。
		複数のマシンで共有するようなことはしないでください。</li>
		<li><i>read-only</i> はルートパーティション(下のroot行を参照)が読み込み専用であり、起動中には書き換えることができないということを指示します。</li>
		<li><i>root=/dev/hda5</i> はLILOにルートパーティションとして使うディスクパーティションを指示します。</li>
		</ul>
		<p><i>lilo.conf</i>を編集したら、LILOを実行してMBRに情報を書き込んでください。</p>
<pre caption="LILOの実行">
# <c>/sbin/lilo</c>
</pre>
		<p>LILOが設定されました。これでGentoo Linuxを起動する準備ができました!</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>ブートディスクを作成する</title>
    <section>
      <title>GRUBブートディスク</title>
      <body>
		<p>どんなLinuxディストリビューションでも、最初にインストールするときにブートディスクも作っておくとよいでしょう。
		お守りのようなものですが、一般的に作っておいて損はありません。
		ハードウェアRAIDを利用している場合は、<e>必ず</e>GRUBブートディスクを作成してください。
		grubをchroot環境からRAIDにインストールしても失敗してしまいます。
		そこで、ブートディスクを作り、最初に再起動したときにGRUBをMBRにインストールします。
		ブートディスクは次のようにして作成します。</p>
<pre caption="GRUBブートディスクの作成">
# <c>cd /usr/share/grub/i386-pc/</c>
# <c>cat stage1 stage2 > /dev/fd0</c>
</pre>
		<p>ここでリブートしてフロッピーで起動してください。
		フロッピーの<c>grub&gt;</c>プロンプトが表示されたら、必要に応じて<c>root</c>や<c>setup</c>コマンドを実行できます。</p>
      </body>
    </section>
    <section>
      <title>LILOブートディスク</title>
      <body>
		<p>LILOを使う場合でも、ブートディスクを作っておくと良いでしょう。</p>
<pre caption="LILOブートディスクの作成">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>カーネルサイズは1.4MB以下でなければならない</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>インストール完了!</title>
    <section>
      <body>
	<p>これでGentoo Linuxがインストールされました。
	あとは必要な設定ファイルを更新し、chrootされたshellを終了して、パーティションを切り離したあと再起動しましょう。</p>
<pre caption="システムの再起動">
# <c>etc-update</c>
# <c>exit</c> 
<comment>(chrootされたshellを終了する。<c>^D</c>とタイプしても良い。)</comment>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
	<note>再起動したあとに<c>update-modules</c>コマンドを実行して<path>/etc/modules.conf</path>ファイルを作成するのも良いでしょう。
	一般的には、このファイルを直接修正する代わりに<path>/etc/modules.d</path>の中のファイルに変更を加えるべきです。</note>
	<impo>もしハードウェアRAIDを使っているなら、最初のrebootにはブートディスクを使うことを忘れないで下さい。
	再起動後、grubを真っ先にinstallしてください。これで終わりです。おめでとう!</impo>
	<p>何か疑問があったり、Gentoo Linuxの開発に携わりたい人は、gentoo-userメーリングリストやgentoo-devメーリングリストへの参加も考えてみてください
	(詳しい情報は<uri link="http://www.gentoo.org/main/en/lists.xml">メーリングリスト</uri>のページにあります)。
	また、<uri link="/doc/en/desktop.xml">Desktop configuration guide</uri>(<uri link="/doc/ja/desktop.xml">日本語訳</uri>)は
	Gentoo Linuxシステムを設定するときに役に立ちますし、<uri link="/doc/en/portage-user.xml">Portage user guide</uri>(<uri link="/doc/ja/portage-user.xml">日本語訳</uri>)はPortageの基礎知識を得るのに役立ちます。
	その他のドキュメントは<uri link = "/main/en/docs.xml">こちら</uri>を参照してください。
	インストールやその他の問題で質問したいことがあるなら、Gentoo Linux <uri link = "/main/en/faq.xml">FAQ</uri>(<uri link="/doc/ja/faq.xml">日本語訳</uri>)も見てください。
	Gentoo Linuxへようこそ！お楽しみ下さい！</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentoo利用統計</title>
    <section>
      <body>
	<p> Gentoo Linux 利用統計プログラムは、開発者にユーザの動向を把握する手段を提供することを目的に始められました。
	この gentoo-stats プログラムは Gentoo Linuxの利用状況に関する情報を収集し、開発の優先順位を決定するために使われます。
	あくまでもオプションとして提供していますが、参加してもらえるととても嬉しく思います。
	集計結果は、<uri>http://stats.gentoo.org/</uri>で見ることができます。</p>
	<p>Gentoo利用統計サーバはあなたのシステムに対してIDを割り当てます。
	これはそれぞれのシステムが間違いなく１度だけカウントされるようにするためのものです。
	IDを使ってあなたのシステムを識別したり、 IPアドレスやその他の情報とマッチングしたりすることはありません。
	あらゆる予防措置を講じて、あなたのシステムのプライバシーが守られるようにこのシステムを構築しています。
	以下が、現在&quot;gentoo-stats&quot;プログラムで監視している項目です。</p>
	<ul>
	<li>インストール済みパッケージとそのバージョン</li>
	<li>CPU情報: 速度(MHz)、ベンダ、モデル、CPUフラグ (&quot;mmx&quot;や&quot;3dnow&quot;など)</li>
	<li>メモリ情報 (物理メモリ量、スワップスペース量)</li>
	<li>PCIカードとネットワークコントローラチップ</li>
	<li>使われているプロファイル(/etc/make.profileがどこへリンクしているか)</li>
	</ul>
	<p>我々は、機密情報が公開されることが、多くのGentoo Linuxのユーザにとって(開発者にとってもそうですが)、脅威となることを承知しています。</p>
	<ul>
	<li>gentoo-statsプログラムを変更しない限り、次のような機密情報を通信することはありません: パスワード類、設定情報、靴のサイズ…</li>
	<li>e-mailアドレスの送信はオプションです。デフォルトでは送信されません。</li>
	<li>送信元のIPアドレスもあなたを識別できるような方法で記録されることは決してありません。
	「IPアドレスとシステムIDのペア」はどこにも記録されていません。</li>
	</ul>
	<p>インストールは簡単です。次のように入力してください。</p>
<pre caption="gentoo-statsのインストール">
# <c>emerge gentoo-stats</c>   <codenote>gentoo-statsのインストール</codenote>
# <c>gentoo-stats --new</c>    <codenote>システムIDの取得</codenote>
</pre>
	<p>上記の2番目のコマンドは新しいシステムIDをサーバに要求し、それを<path>/etc/gentoo-stats/gentoo-stats.conf</path> に自動的に記録します。
	このファイルにはさらに設定オプションを指定することができます。</p>
	<p>その後は、定期的に起動する必要があります(rootとして実行する必要はありません)。
	あなたのcrontabに次の行を追加してください。</p>
<pre caption="cronでgentoo-statsを更新する">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
</pre>
	<p><c>gentoo-stats</c>プログラムは単純なperlスクリプト(<path>/usr/sbin/gentoo-stats</path>)ですので、お好みのページャやエディタで見ることができます。</p>
      </body>
    </section>
  </chapter>
</guide>
