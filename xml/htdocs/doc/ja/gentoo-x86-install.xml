<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ja/gentoo-x86-install.xml">
  <title>Gentoo Linux 1.4 インストール手引書</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">
    <mail link="jerry@gentoo.org">Jerry Alexandratos</mail>
  </author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="翻訳">
    <mail link="makoto@dsb.club.ne.jp">yamakura</mail>
  </author>

	<abstract>Gentoo Linux 1.4_rc1のインストール手引書です。この手引書ではゼロから
	Gentoo Linuxを構築することはもちろん、いろいろな段階からのインストール
	を解説します。
	</abstract>

	<version>2.2</version>
	<date>17 December 2002</date>
	<!-- Original revision:  1.19 -->

		<chapter>
			<title>インストールについて</title>
			<section>
			<body>

			<p>新しいブートCDは、ドライブとBIOSのサポートがあれば、最近のIDE
			CD-ROMドライブや多くのSCSI CD-ROMドライブから起動させることができます。
			IDEデバイス（カーネルに内蔵）だけで
			なくすべてのSCSIデバイス（モジュールとして利用可能）もサポートしていま
			す。さらに、Linuxがサポートするすべてのネットワークカードのモジュール
			はもちろん、ネットワークを設定し、<c>ssh</c>による接続やファイルのダウ
			ンロードを可能にするツールをも提供します。</p>

			<p>インストールを行なうには486以上のCPUおよび少なくとも64Mバイトのメモ
			リが必要となります（Gentoo Linuxは64Mバイトのメモリと64Mバイトのスワップ
			でビルドに成功していますが、このような環境下では、非常に遅くなります）。
			インストールを始めるため、まずは
			<uri>http://www.ibiblio.org/gentoo/releases/1.4_rc1/</uri> から livecd 
			のISOイメージを入手してください。3つのステージの圧縮ファイルがGentooの
			構築を助けてくれます。ステージ1を使うとシステム全体をゼロから構築しな
			くてすみます。ステージ2を使うとではシステムのいくつかの部分をゼロから
			構築しなくてすみます。ステージ3はすでに特定のシステムに対して最適化し
			てあるので多くの時間を節約できます。今のところ、ステージ1の圧縮ファイ
			ルだけがlivecdに収められていますが、あなたの環境に最適化されたステージ
			2と3の圧縮ファイルを、livecdをブートした後でダウンロードすることができ
			ます。
			</p>

			<p>何らかの事情でインストール作業を中断する場合、リブートしても再開することができます。たとえば、パーティションを作成し、stageXの圧縮ファイルを展開してchrootする用意ができていれば、インストールを再開できます。ただLiveCDを使って再起動して、通常どおりドライブ/パーティションを<path>/mnt</path>にマウントするだけです。基本的に、インストールのどの時点でもこのようにできます。ただし、パーティションを作成する前ではだめです。</p>

			<warn>もしインストールプロセスのどこかでバグに遭遇し、バグレポートをする場合は、<uri>bugs.gentoo.org</uri>に送信してください。必要と判断された場合は、開発チームがそれをパッケージメンテナー(KDEなど)に流すなどの処理をします。
			</warn>
			<p>それではインストールの手順を簡単に見てみましょう。まずパーティショ
			ンを、続いてファイルシステムを作成し、任意でステージ1、ステージ2、ステー
			ジ3の圧縮ファイルを展開します。ステージ1かステージ2の圧縮ファイルを使
			用する場合、ステージ3に進むために適切な手順を踏む必要があります。ステー
			ジ3に進みシステムに対して各種の設定（設定ファイルの微調整、ブートロー
			ダーのインストールなど）を行なえばGentoo Linuxの完成です。スタートする
			ステージごとにどのような手順が必要なのかを以下に示します。
			</p>

        <table>
          <tr>
            <th>圧縮ファイル</th>
            <th>必要な手順</th>
          </tr>
          <tr>
            <ti>1</ti>
	    <ti>パーティションとファイルシステムの作成、emerge sync、ブートストラップ、emerge system、emerge linux sources、最終調整</ti>
          </tr>
          <tr>
            <ti>2</ti>
	    <ti>パーティションとファイルシステムの作成、emerge sync、emerge system、emerge linux sources、最終調整</ti>
          </tr>
          <tr>
            <ti>3</ti>
	    <ti>パーティションとファイルシステムの作成、emerge sync、最終調整</ti>
          </tr>
        </table>
			</body>
		</section>
	</chapter>

	<chapter>
		<title>ブート</title>
			<section>
			<body>

			<p>まずlivecdでブートするところから始めます。一連のテキストのあと通常
			のGentoo Linuxのブートシーケンスが表示されます。&quot;root&quot;としてログイン
			(パスワードの入力ではただ&lt;Enter&gt;を押してください)してから、すぐ
			<c>passwd</c>コマンドでrootのパスワードを設定してください。(このrootパ
			スワードは現在のインストールセッションでのみ有効です。パスワードを変更
			する理由は、インストールを完了するためにネットワークに接続しなければな
			らないからです。インターネットにデフォルトのパスワードのままで接続して
			はいけません!) rootのプロンプト (&quot;<c>#</c>&quot;) が表示されるはずです。
			ALT-F2、ALT-F3などの後でEnterを叩くと新しいコンソールを開くことができ
			ます。</p>

			<!--
			<p>Next, you will be greeted with instructions for setting up your network,
			and optional PCI autodetection.  The PCI autodetection process will automatically
			load the appropriate kernel modules for many popular PCI SCSI and ethernet
			devices.  After this, you should have a root ("<c>#</c>") prompt on the current
			console, and can also open new consoles by typing Alt-F2, Alt-F3, etc and then
			hitting enter.
			</p>
			<p>次の画面では、このブートCDで使えるコマンドの一覧が表示されます。こ
			れには<i>vi</i>と<i>nano</i>も含まれます。ネットワークのセットアップの
			手順も表示されます。一覧の中から好みのキーマップを選択すると、PCIの自
			動検知が実行されます。PCIの自動検知はカーネルに適切なPCI SCSIドライバー
			やPCIイーサネットドライバーをモジュールとして組み込みます。この後、
			Enterキーを押せば、最小ブート環境がスタートします。このコンソールでは
			root (&quot;<c>#</c>&quot;) としてログインしています。また、ALT-F2、ALT-F3を押すことに
			よって新しいコンソールを開くこともできます。(訳注:このパラグラフは削除
			されるべきではないか?)</p> -->

			<!-- 日本語版独自の記述 ここから -->
			<p><comment>(訳注:この段落は日本語版独自の記述です)</comment>
			livecd起動直後のキーマップは us になっています。これを変更するには、
			<path>/etc/rc.conf</path>の<c>KEYMAP=&quot;us&quot;</c>を自分のキーマップにあう
			ように書き換え、設定を反映させるコマンドを実行します。有効なキーマップ
			は<path>/usr/share/keymaps</path>の中から探してください。日本語106/109キー
			ボードを使っている場合は、<c>KEYMAP=&quot;jp106&quot;</c>とすればよいでしょう。
			ただし、設定はこのインストールセッション内でのみ有効なので注意してくだ
			さい。インストール完了後のキーマップの設定はまたあとででてきます。
			</p>
			<pre caption = "キーマップの設定">
# <c>nano -w /etc/rc.conf</c>
<comment>(KEYMAPの値を書き換えてください)</comment>
# <c>/etc/init.d/keymaps restart</c>
<comment>(このコマンドを実行するとキーマップが変更されます。)</comment>
			</pre>
			<!-- 日本語版独自の記述 ここまで -->
			</body>
		</section>
	</chapter>

	<chapter>
		<title>カーネルモジュールのロード</title>
			<section>
			<body>

			<p>うまくいけば、rootのプロンプトで<c>pci-setup</c>とタイプするだけで
			システム上のデバイスが自動検知され、適切なカーネルモジュールが読み込ま
			れます。
			</p>

			<p>もしも自動検知に失敗しっぱいしたら、適切なモジュールを手動でロード
			しなければなりません。利用可能なネットワークカードモジュールの一覧を見
			るには、<c>ls /lib/modules/*/kernel/drivers/net/*</c>とタイプしてくだ
			さい。モジュールをロードするには、次のようにタイプします。
			</p>

			<pre caption = "PCIモジュール設定">
# <c>modprobe pcnet32</c>
<comment>(pcnet32をお使いのNICのモジュールに置き換えてください)</comment>
			</pre>

			<p>PCI自動検知で検出されなかったSCSIデバイスにアクセスできるようにする
			には、もういちど<c>modprobe</c>を利用して<path>/lib/modules</path>から
			適切なモジュールをロードします。</p>

			<pre caption = "SCSIモジュールのロード">
# <c>modprobe aic7xxx</c>
# <c>modprobe sd_mod</c>
			</pre>

			<p><c>aic7xxx</c>はSCSIコントローラを、
			<c>sd_mod</c>はSCSIハードディスクをサポートします。
			<note>
			SCSI CD-ROMのサポートはカーネルに組み込まれています。
			</note></p>

			<p>ハードウェアRAIDをつかっているなら、
			お使いのRAIDコントローラ用のATA-RAIDモジュールをロードしてください。
			</p>

			<pre caption = "RAIDモジュールのロード">    
# <c>insmod ataraid</c>    
# <c>insmod pdcraid</c>            
      <comment>(Promise Raid コントローラ)</comment>    
# <c>insmod hptraid</c>            
      <comment>(Highpoint Raid コントローラ)</comment>    
			</pre>

			<p>Gentoo LiveCDはDMAを有効にするはずですが、有効にならなかったときは
			<c>hdparm</c>を使ってドライブにDMAを設定できます。</p>

			<pre caption = "DMA設定"><comment>hdXをあなたの環境のディスクデバイス名に置き換えてください</comment>
# <c>hdparm -d 1 /dev/hdX </c><comment>DMAを有効にする</comment>
# <c>hdparm -X66 /dev/hdX </c><comment>Ultra-DMAを有効にする</comment></pre>

			</body>
		</section>
	</chapter>

	<chapter>
		<title>PCMCIAカーネルモジュールのロード</title>
			<section>
			<body>

			<p>PCMCIAネットワークカードを利用するには、ちょっとしたトリックが必要です。</p>

			<warn>トラブルを避けるために、<e>chrootする前に<c>cardmgr</c>を</e>実行してください。</warn>

			<pre caption = "PCMCIAモジュールのロード">
# <i>insmod pcmcia_core</i>
# <i>insmod i82365</i>
# <i>insmod ds</i>
# <i>cardmgr -f</i>
			</pre>

			<!--
			<p>As cardmgr detects which hardware is present, your speaker should emit a
			few reassuring beeps, and your PCMCIA network card should hum to life. You can
			of course insert the PCMCIA card after loading cardmgr too, if that's 
			preferable. (Technically, you need not run 
			<i>cardmgr</i> if you know exactly which module your PCMCIA card requires. 
			But if you don't, loading all PCMCIA modules and see which sticks won't work,
			as all PCMCIA modules load obligingly and hang around for a PCMCIA card to 
			drop by. <i>cardmgr</i> will also unload the module(s) for any card when you
			remove it). </p>
			-->
			<p>cardmgrがハードウェアを検知すると、ビープ音が鳴り、PCMCIAネットワー
			クカードが使用可能になります。もちろん<i>cardmgr</i>がロードされた後で、
			PCMCIAネットワークカードを挿入することもできます（技術的には、PCMCIAカー
			ドがどのモジュールを必要としているのか正確に分かっていれば、
			<i>cardmgr</i>を実行する必要はありません。しかし<i>cardmgr</i>を実行し
			ていない場合、PCMCIAカードが働くようにPCMCIAモジュールをロードしてまわ
			るので、全てのPCMCIAモジュールをロードして、どのカードが動いているか確
			認してください。<i>cardmgr</i>はカードを抜いたときにPCMCIAモジュールを
			アンロードしてくれます）。</p>

			</body>
		</section>
	</chapter>

	<chapter>
		<title>ネットワークの設定</title>
			<section>
			<title> PPPoEの設定</title>
			<body>

			<p>インターネットへ接続するためにPPPoEが必要な場合、どのバージョンのlivecd
			にも含まれている<i>rp-pppoe</i>を使うのが簡単です。
			<i>adsl-setup</i>スクリプトを使って接続の設定をしてください。adslモデ
			ムに接続しているイーサネットデバイスとユーザ名、パスワード、DNSサーバ
			のIPアドレス、ファイアウォールが必要かどうか、を入力してください。
			</p>

			<pre caption = "PPPoEの設定">
# <i> adsl-setup </i>
# <i> adsl-start </i>
			</pre>

			<p>うまくいかないようなら、ユーザ名とパスワードを間違いなく入力してい
			るかどうか、<path>/etc/ppp/pap-secrets</path>や
			<path>/etc/ppp/chap-secrets</path>を見てよく確認してください。また正し
			いイーサネットデバイスを指定しているかどうかも確認してください。
			</p>

			</body>
		</section>

		<section>
		<title>ネットワークの自動設定</title>
		<body>

		<p>インストールを始める前に、ネットワークの設定をして、<c>ssh</c>、
		<c>scp</c>、<c>wget</c>が使えるようにします。今その必要がないとしても、
		設定をするべきです。一度設定してしまえば、Gentoo Linuxをインストールす
		るために chroot環境になっていても、Portageは設定したネットワークを使う
		ことができます。いちばん簡単な設定方法は、<c>net-setup</c>スクリプトを
		実行することです。
		</p>

		<pre caption = "Net-Setup スクリプト">
# <c>net-setup eth0</c>
		</pre>

		<p>もちろん、お好みであれば手動で設定することもできます。</p>

		</body>
		</section>

		<section>
		<title>DHCPを使った設定</title>
		<body>

		<p>DHCPの設定は簡単です。ご利用のISPがDHCPをサポートしていない場合は、
		固定IPの設定まで進んでください。
		</p> 

		<pre caption="DHCPを使ったネットワーク設定">
# <c>dhcpcd eth0</c> 
		</pre>

		<note>ISPによっては、ホスト名の入力が必要になります。その場合はdhcpdコ
		マンドの後に<c>-h myhostname</c>と書き加えてください。</note>

		<p>もし<i>dhcpConfig</i>警告を受け取ったとしても、慌てないでください。
		このエラーはお飾りのようなものです。ネットワークのテストまで進んでくだ
		さい。</p>

		</body>
		</section>

		<section>
		<title>固定IP設定</title>
		<body>
		
		<p>システムの構築に必要なソースをダウンロードするために、ネットワーク
		に対して適切な設定を行なう必要があります。下記のコマンドを入力してくだ
		さい。その際、$IFACEを使用するネットワークインターフェイス（たいていの
		場合<c>eth0</c>）に、$IPNUMを使用するIPアドレスに、$BCASTをブロードキャ
		ストアドレスに、$NMASKをネットマスクにそれぞれ置き換えてください。
		<c>route</c>コマンドでは、$GTWAYをデフォルトゲートウェイに置き換えてく
		ださい。</p>

		<pre caption = "固定IPでのネットワーク設定">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</c>
		</pre>

		<p>ここで、<path>/etc/resolv.conf</path>を作成し、名前解決(Webサイトや
		FTPサイトのIPアドレスを直接指定するのではなく名前で指定)できるようにし
		ます。</p>

		<p>以下に、/etc/resolv.conf作成の参考になるようにテンプレートを示します。</p>

		<pre caption="/etc/resolv.conf テンプレート">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
		</pre>

		<p><c>10.0.0.1</c> と <c>10.0.0.2</c> をそれぞれプライマリDNSサーバと
		セカンダリDNSサーバのアドレスに書き換えてください。
		</p>
		</body>
		</section>

		<section>
		<title>プロクシ設定</title>
		<body>
		<p>
		プロクシを利用している場合は先に進む前にプロクシを利用する設定をしなければ
		なりません。次のように環境変数を設定してください。
		</p>

	<pre caption = "プロクシの設定">
# <c>export http_proxy=&quot;machine.company.com:1234&quot; </c>
# <c>export ftp_proxy=&quot;$http_proxy&quot; </c>
# <c>export RSYNC_PROXY=&quot;$http_proxy&quot; </c>
		</pre>

		</body>
		</section>

		<section>
		<title>ネットワークのテスト</title>
		<body>
		<p>これでネットワークの設定は終了です。<c>/sbin/ifconfig -a</c>コマン
		ドでネットワークカードが働いているかどうか確認してみましょう。下記の
		<e>UP</e>と<e>RUNNING</e>に注目してください。</p>

		<pre caption="/sbin/ifconfig で動作確認する">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
		</pre>

		<p>ISPのDNSサーバ(<path>/etc/resolv.conf</path>で調べてください)や適当なWebサーバに対してpingを打ち、パケットがネットワークに届くこと、DNSによる名前の解決がうまく機能していることなどを確かめることができます。
		</p>

		<pre caption = "更なるネットワークのテスト">
# <c>ping www.some_website.com </c>
		</pre>

		</body>
		</section>

		<section>
		<title>ネットワークの準備完了!</title>
		<body>
		<p>ネットワークの設定は終わりました。<c>ssh</c>、<c>scp</c>、
		<c>wget</c>コマンドを使って、LAN上のマシンやインターネットに接続するこ
		とが可能です。</p>
		</body>
	</section>
</chapter>

	<chapter>
		<title>パーティションの設定</title>
			<section>
				<body>

				<p>カーネルはネットワークカードとディスクコントローラーを利用できるよ
				うになりました。次はパーティションの設定をしましょう。</p>

				<p>簡単にGentoo Linuxの標準的なパーティションレイアウトを説明します。
				Gentoo Linuxではswapパーティション、rootパーティション（Gentoo Linuxの
				大部分を保持します）、そしてbootパーティションと、少なくとも3つのパー
				ティションを作成します。bootパーティションはGRUBブートローダの情報とカー
				ネルを保持しています。また、Linuxのブートに関するあらゆる情報を格納する
				安全な場所を提供します。通常、Gentoo Linuxを使用している間はbootパーティ
				ションを切り離しておくべきです。こうすることによって、万が一ファイルシ
				ステムの不正でシステムクラッシュが起こったとき、カーネルがGRUBから利用
				できなくなることを防ぎます。また「ニワトリと卵」の問題(
				ファイルシステムが壊れていてGRUBがkernelを読めない。
				ブートできないのでファイルシステムを正常な状態に復元できない
				)を防ぎます。
				</p>

				<p>ファイルシステムについて説明します。Gentoo LinuxではXFS、ext2、ext3
				（ジャーナリング）そしてReiserFSの四つのファイルシステムを使うことがで
				きます。ext2はLinuxで使い込まれた正式のファイルシステムですが、メタデー
				タ・ジャーナリングを持っていません。ext3はメタデータ・ジャーナリングと
				オーダーデータの記録によるデータ・ジャーナリングの両方をもつext2の後継
				バージョンです。ReiserFSはB*-treeファイルシステムがベースで、優れたパ
				フォーマンスを持っています。また、小さな（4K以下）ファイルの取り扱いで
				はext2やext3をはるかに上回り、ときには、10?15倍ほどにもなります。
				ReiserFSは規模を拡大しても良好で、メタデータ・ジャーナリングを持ってい
				ます。ReiserFSは遂に非常に安定したものになったので強く推奨されています。
				XFSはメタデータ・ジャーナリングを持つファイルシステムで、Gentoo Linux
				では<path>xfs-sources</path>カーネルで完全にサポートされます。しかし、
				現時点では非常に不安定です。
				</p>

				<p>スタンダードなファイルシステムを使いたいときはext2を選択してくださ
				い。頑丈なファイルシステムを希望するならばext3を選択してください。ジャー
				ナリングを備えた高機能なファイルシステムを希望するならばReiserFSを選択して
				ください。ext3、ReiserFSは両者とも成熟し、洗練されています。XFSを使うときは注
				意してください。ファイルシステムはシステムクラッシュや停電などでデータ
				を喪失する恐れがあります。当初は期待できるファイルシステムと思われてい
				ましたが、このデータ喪失の問題がアキレス腱となっています。以下に推奨さ
				れるファイルサイズとタイプを示します。</p>

			  <table>
			  <tr>
			  	<th>パーティション</th>
				<th>サイズ</th>
				<th>タイプ</th>
			  	<th>デバイス例</th>
			  </tr>
			  <tr>
			  	<ti>bootパーティション：カーネルとブート情報</ti>
				<ti>100Mバイト</ti>
				<ti>ext2/3を強く推奨(もっとも容易)：ReiserFSなら<c>-o notail</c>をつけてマウントしてください</ti>
			  	<ti>/dev/hda1</ti>
			  </tr>
			   <tr>
			  	<ti>swapパーティション（128Mバイト制限はありません）</ti>
				<ti>実メモリの2倍以上が推奨ですが、カーネル2.4.10以降では要求されません</ti>
				<ti>Linux swap</ti>
			  	<ti>/dev/hda2</ti>
			  </tr>
			  <tr>
			  	<ti>rootパーティション：/usr、/homeなどの主要なファイル</ti>
				<ti>1.5Gバイト以上</ti>
				<ti>ReiserFS、ext3を推奨：ext2も可</ti>
			  	<ti>/dev/hda3</ti>
			  </tr>
			 </table>

			<p>パーティションの作成に先立って、<c>dd</c>を使ってハードディスクの初期化をするとよいでしょう。
			そうすることで、前に<i>fat32</i>だったパーティションをマウントするときに問題が発生することを
			予防できます。これをするには、次のようにタイプしてください。</p>

			<pre caption = "HDの最初の1024セクタを初期化する">
# <c>dd if=/dev/zero of=/dev/hdaBOOT bs=1024 count=1024 </c>
<comment>BOOTは<path>/boot</path>を保持しているパーティションです。</comment>
			</pre>

			<p>ここで、<c>fdisk</c>を使ってパーティションを作成します。パーティショ
			ンのタイプは、swapの場合は82、通常のファイルシステム(ReiserFS<e>または
			</e>ext2/3)の場合は83です。
			</p>

			<note>インストールCDには<i>cfdisk</i>が含まれています。これは
			<i>fdisk</i>と比べて、かなり扱いやすいものです。実行するには
			<c>cfdisk</c>とタイプしてください。
			デフォルトでは、<b>/dev/hda</b>を操作対象になります。もしパーティションを作成するのが/dev/hda以外のディスクであれば、
			パラメータとして正しい値を指定してください。たとえば、<c>cfdisk /dev/hde</c>となります。
			</note>
			<note>パーティションに対する変更は即座に反映されるわけではありません。fdiskやcfdiskを使った後は再起動してください。</note>

			<note>
			RAIDを使う場合は、パーティションの名前が少し異なり、このようになります:
			<path>/dev/ataraid/discX/partY</path>。Xはアレイを表すので、1ア
			レイであれば、disk0となります。Yはパーティション番号で
			<path>/dev/hdaY</path>と同じです。</note>


			<p>
			パーティションの作成がおわったら、次はファイルシステムの初期化をしてデータを
			格納できるようにします。スワップの初期化は次のようにして実行します。
			</p>

			<pre caption= "Swapの初期化">
# <c>mkswap /dev/hda2</c>
			</pre>

			<p>ext2ファイルシステムを作成するには<c>mke2fs</c>コマンドを使用してください。</p>

			<pre caption = "ext2 Filesystemの作成">
# <i>mke2fs /dev/hda1</i>
			</pre>

			<p>XFSファイルシステムを作成するには<c>mkfs.xfs</c>コマンドを使用してください。</p>

			<pre caption = "XFS Filesystemの作成">
# <c>mkfs.xfs /dev/hda3</c>
			</pre>

			<note>
			<c>mkfs.xfs</c>コマンドに対し、<c>-d agcount=3 -l size=32m</c>オプショ
			ンを付加することができます。<c>-d agcount=3</c>オプションはアロケーショ
			ングループの数を減らします。XFSは4Gバイトごとに少なくともひとつのアロ
			ケーショングループを必要とします。つまり、20Gバイトのパーティションが
			あった場合、最低でも5つのアロケーショングループが必要になります。<c>-l
			size=32m</c>オプションはジャーナルサイズを32Mバイトに増加させ、パフォー
			マンスを良くします。</note>

			<warn>
			ReiserFSパーティションだったところにXFSパーティションを作成した場合、
			<c>mount -t xfs</c>と明示的に指定しないとマウントに失敗するかもしれま
			せん。解決方法は、XFSパーティションを作成する前に<c>dd if=/dev/zero
			of=/dev/hd<comment>x</comment> bs=1k</c>と入力してゼロアウトすることです。</warn>

			<p>ext3ファイルシステムを作成するには<c>mke2fs -j</c>コマンドを使用してください。</p>

			<pre caption = "ext3 Filesystemの作成">
# <c>mke2fs -j /dev/hda3</c>
			</pre>

			<p>ReiserFSファイルシステムを作成するには<c>mkreiserfs</c>コマンドを使用してください。</p>
			
			<pre caption = "ReiserFS Filesystemの作成">
# <c>mkreiserfs /dev/hda3</c>
			</pre>

			<note>Linux2.4でext3を使用する場合は以下のURLが参考になるでしょう。
			<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri></note>

			</body>
		</section>
	</chapter>

	<chapter>
		<title>パーティションのマウント</title>
		<section>
			<body>

			<p>後に仮想記憶が必要になるので、swapをアクティブにします。</p>

			<pre caption = "スワップをアクティブにする">
# <c>swapon /dev/hda2</c>
			</pre>

			<p>次に、<path>/mnt/gentoo</path>と<path>/mnt/gentoo/boot</path>という
			ふたつのマウントポイントを設定し、作成したパーティションをマウントしま
			す。</p>

			<pre caption = "マウントポイントの作成">
# <c>mkdir /mnt/gentoo</c>
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
			</pre>

			<p><path>/usr</path>や<path>/var</path>を別のパーティションとして設定
			している場合は、それぞれのパーティションを<path>/mnt/gentoo/usr</path>
			や<path>/mnt/gentoo/var</path>にマウントしてください。</p>
   
			<impo> <e>boot</e>パーティション(カーネルを保持しているパーティション) 
			がReiserFSである場合、GRUBが正常にインストールされるように<c>-o
			notail</c>オプションを使ってマウントしてください。さらに
			<path>/etc/fstab</path>のbootパーティションに<c>notail</c>オプションを
			追加してください。すぐ後に出てきます。</impo>

			<impo>もしext2のbootパーティションをマウントするときに問題が発生したら、
			<c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c>を試してみてください。
			</impo>
			</body>
		</section>
	</chapter>

	<chapter>
		<title>必要な'stage-x'圧縮ファイルを手に入れる</title>
		
		<section>
			<body>

			<p>もしstage1の圧縮ファイルから始めるなら、すでに用意ができています。
			<path>/cdroot/nocompress</path>に圧縮ファイルがあります。もし、最適化
			されたstage2かstage3の圧縮ファイルから始めたい場合は、Gentoo ミラーサ
			イトからダウンロードしてください。(<path>/mnt/gentoo</path>に置くのが
			いいでしょう)
			</p>

			<pre caption = "必要なステージの圧縮ファイルのダウンロード">
# <c>cd /mnt/gentoo</c>
<comment>lynxを使って、圧縮ファイルのURLを確認してください。</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc1/x86/</c>
# <c>wget <comment>insert required stage tarball here.</comment></c>
			</pre>

			</body>
		</section>
	</chapter>

	<chapter>
	<title>圧縮ファイルの展開</title>
		<section>

			<body>

			<p>ここで、圧縮ファイルを<path>/mnt/gentoo</path>に展開します。そのあ
			と、chrootして新しい Gentoo Linux のインストール環境に入っていきます。
			</p>

			<impo><c>tar</c>する時は必ず<c>p</c>オプションを使用してください。これ
			を怠ると、いくつかのファイルに誤ったパーミッションを与えてしまいます。
			</impo>

			<p>もし「全てをゼロから」インストールをするならば、
			<path>stage1-ix86-1.4_beta.tbz2</path>を使用してください。2枚目のCD
			（gentoo-i686-1.2.iso）を使用しているのであればステージ2かステージ3も
			選択してください。設定の自由と引き換えに、時間を短縮できます（コンパイ
			ラの最適化法とデフォルトのUSE変数を設定してあります）。</p>

			<pre caption = "圧縮ファイルの展開">
# <c>cd /mnt/gentoo</c>
# <c>tar -xvjpf /path/to/stage?-*.tbz2</c>
# <c>mount -o bind /proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
			</pre>

			<pre caption = "chroot 環境に入る">
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
			</pre>

			<p>このコマンドを実行すればGentoo Linuxの「中」に入ることができます。</p>

			</body>
		</section>
	</chapter>

	<chapter>
	<title>Rsyncで最新のPortageツリーを取得する</title>

		<section>
			<body>

			<p>ここで、<c>emerge sync</c>を実行してください。これにより、
			最新のPortageツリーを取得できます。
			</p>

			<pre caption = "Rsyncを使って更新する">
# <c>emerge sync</c>
			</pre>

			<p>Portageツリーは、ダウンロードされて<path>/usr/portage</path>以下に格納されます。
			圧縮ファイルを除いて、おおよそ90Mbほどあります。</p>
			
			</body>
		</section>
	</chapter>
	<chapter>
	<title>Gentooを最適化する (make.conf)</title>
		<section>
			<body>

			<p>Portageツリーのコピーが終わったら、
			ステージ1を使用している場合は、次のようにブートストラップを設定して
			ください。始めに/etc/make.confファイルを編集します。パッケージに組み込
			みたい機能を指定するUSE変数をセットしてください。一般的にはデフォルト
			（空かセットなし）でいいでしょう。<c>USE</c>フラグに関しては、<uri
			link="http://www.gentoo.org/doc/use-howto.html">ここ</uri>に詳しい説明
			があります。
			</p>

			<p><c>CHOST</c>、<c>CFLAGS</c>、<c>CXXFLAGS</c>変数もそれぞれセットし
			てください（ファイルの下の方にセット例がコメントされています）。ほかに
			どのようなオプションが<c>CFLAGS</c>や<code>CXXFLAGS</code>に追加できる
			のか調べるには、<path>man gcc</path>するとよいでしょう。'Optimization'
			の項目を見てください。
			</p>

			<p>ファイアーウォールが設置されている場合はここでプロクシ情報をセットできます。</p>

			<pre caption = "make.conf オプションを設定する">
# <c>nano -w /etc/make.conf</c> <comment>(このファイルで設定してください)</comment>
			</pre>

			<note>
			ビルドプロセスに手を加えたいときは、<path>/etc/make.globals</path>を参照して
			ください。このファイルは、gentooで使われるデフォルト値を保持しており、
			書き換えないようにすべきです。デフォルトで不十分な場合は、新しい値を
			<path>/etc/make.conf</path>に書き込んでください。<path>make.conf</path>
			で指定された値は、<path>make.globals</path>の設定を<comment>上書き</comment>します。
			ここで見つけたUSE設定を無効にしたいときは、適切な<c>USE=&quot;-foo&quot;</c>
			(<c>foo</c>を無効にしたい場合)を/etc/make.confに追加してください。
			</note>
			</body>
		</section>
	</chapter>

	

	<chapter>
    <title>Stage1から始める</title>
		<section>
			
			<body>

		<p>stage1の圧縮ファイルは基本的なtweakageです。この圧縮ファイルを選択したということは、最適化されたシステムを求めていることになるでしょう。最適化こそがGentoo Linuxの勘所です。お楽しみください。
		</p>
			<p>もし、ステージ2かステージ3の圧縮ファイルを使用しているならば、すで
			にブートストラップは組み込まれています。<c>emerge sync</c>を行なって最
			新のシステムにしたいというのでなければ、この作業を行なう必要は<i>あり
			ません</i>。高速なマシンを使っても、この作業には2時間以上かかります。
			</p>

			<p>「ブートストラップ」プロセスを開始します。AMD Athlon 1200Mhzで約2時間かかります。
			このプロセスで
			は、残りのシステムをコンパイルするために、展開されたビルドイメージが準
			備されます。GNUコンパイラ一式とGNU Cライブラリが構築されます。これらは
			時間がかかる処理で、ブートストラッププロセスの大半が構成されます。</p>

			<pre caption = "ブートストラッピング">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
			</pre>

			<p>「ブートストラップ」プロセスが開始します。</p>
			
			<note>
			デフォルトのPortageはパッケージのビルド中に一時的に<c>/var/tmp</c>を数
			百Mバイト使用する時があります。一時ファイルの場所を変更している場合は、
			<e>ブートストラッププロセスを始める前に</e>PORTAGE_TMPDIR変数を変更し
			てください。</note>

			<pre caption = "Portageの作業ディレクトリの設定">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
			</pre>

			<p><c>bootstrap.sh</c>は<c>binutils</c>、<c>gcc</c>、<c>gettext</c>、
			<c>glibc</c>を構築し、<c>glibc</c>が構築された後、<c>binutils</c>、
			<c>gcc</c>、<c>gettext</c>を再構築します。言うまでもなく、このプロセス
			には時間がかかりますので、昼寝でもしていてください。このプロセスが終了すると&quot;stage2&quot;のシステムと同じ状態になります。
			</p>

			</body>
		</section>
	</chapter>

	<chapter>
    <title>Stage2から始める</title>
		<section>
			
			<body>
        <p>stage2の圧縮ファイルを使うと、既にブートストラップが済んだ状態から始めることができます。残りのシステムのインストー
			ルを始めましょう。
			</p>

			<note>
			もしまだなら、<path>/etc/make.conf</path>を好みに応じて書き換えておいてください。
			</note>

			<pre caption = "残りのシステムをインストールする">
# <c>export CONFIG_PROTECT=&quot;&quot;</c>
# <c>emerge -p system</c>
	<comment>[インストールされるパッケージのリストが出力される]</comment>
# <c>emerge system</c>
			</pre>

			<note><c>export CONFIG_PROTECT=&quot;&quot;</c>コマンドで、コンフィグファイルの
			編集ができない（<path>sys-apps/baselayout</path>に格納された）古いスク
			リプトを新しいスクリプトに上書きして<path>/etc</path>にインストールで
			きるようにします。詳細については<c>emerge --help config</c>とタイプし
			てください。</note>

			<p>ベースシステム全体を構築するにはまとまった時間が必要です。そのかわ
			りシステムは徹底的に最適化されます。もちろん暇つぶしの方法を見いださな
			ければなりませんが。作者はプレーステーション2用ソフト「Star Wars -
			Super Bombad Racing」をおすすめします。このプロセスが終了すると&quot;stage3&quot;のシステムと同じ状態になります。
			</p>

			</body>
		</section>
	</chapter>
  <chapter>
    <title>Stage3から始める</title>
    <section>
      <body>
        <p>stage3の圧縮ファイルはすでに一般的なシステムに合わせて最適化された状態になっています。しなければならないことはほとんどありませんが、最新のパッケージに更新しておくとよいでしょう。
		</p>
		<note>
		もしまだなら、<path>/etc/make.conf</path>を好みに応じて書き換えておいてください。
		</note>
        <pre caption="最新の状態にする">
	# <c>emerge sync</c>
	# <c>emerge -up world</c>
	<comment>インストールされる [<i>packages</i>] の一覧が表示される</comment>
	# <c>emerge -u world</c>
	</pre>
      </body>
    </section>
  </chapter>
	<chapter>
	<title>タイムゾーン</title>
		<section>
			
			<body>

			<!--
			<impo>このステップを完了させるのは、どのステージの圧縮ファイルを使っているかに関わらず
			非常に重要です。正しく設定しないと時刻がおおきくずれたり、パッケージをマージするときに
			潜在的な問題を引き起こしたりします。
			</impo>
			-->

			<p>ここまでで、あとは最終設定だけになりました。設定プロセスのはじめに、まずタイムゾーンの設定を行ないます。カーネルのビルドの前にタイムゾーンを設定することで、<c>uname -a</c>コマンドで正確な情報を得ることができます。</p>

			<p><path>/usr/share/zoneinfo</path>のなかからタイムゾーン（グリニッジ
			標準時を使用するならGMT）を選んでシンボリックリンクを作成してください。</p>

			<pre caption = "タイムゾーンの設定">
# <c>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</c>
			</pre>

			<p><path>/etc/rc.conf</path>もチェックして、タイムゾーンの設定が正しいかどうか確認したほうが
			いいでしょう。</p>

			</body>
		</section>
	</chapter>

	<chapter>
	<title>最終ステップ：カーネルとシステムロガー</title>
		<section>
			<body>

			<note>
			もしまだなら、<path>/etc/make.conf</path>を好みに応じて書き換えておいてください。
			</note>

			<p>ここでは、Linuxのソースコードをマージします。現在提供しているのは次のとおりです。</p>

        <table>
          <tr>
            <th>ebuild名</th>
            <th>説明</th>
          </tr>
          <tr>
            <ti>
              <path>gentoo-sources</path>
            </ti>
            <ti>Gentoo Linux独自の高性能で実用的な-acベースのカーネル</ti>
          </tr>
          <tr>
            <ti>
              <path>xfs-sources</path>
            </ti>
            <ti>SGIのXFS CVS Linuxソースのスナップショット。XFSファイルシステムを使用する際は、このソースを使ってください。</ti>
          </tr>
          <tr>
            <ti>
              <path>openmosix-sources</path>
            </ti>
            <ti>GPL <uri link="http://www.openmosix.com">openMosix</uri>ロード・バランシング/クラスタリング技術をサポートしたLinuxソース。</ti>
          </tr>
          <tr>
            <ti>
              <path>usermode-sources</path>
            </ti>
            <ti>ユーザーモードLinux（Linux inside Linux）をサポートしたLinuxソース。</ti>
          </tr>
          <tr>
            <ti>
              <path>vanilla-sources</path>
            </ti>
            <ti>kernel.orgから得ることのできるものと同じLinuxソース。</ti>
          </tr>
        </table>

			<warn><i>gentoo-sources</i>は数多くのパッチがあたっており、安定して動
			作しないかもしれません。多くの問題に遭遇してしまったら、
			<i>vanilla-sources</i>を使うとよいかもしれません。もし
			<i>gentoo-sources</i> を使う場合、<i>grsecurity</i>に注意してください。
			<i>X</i>を使う場合は特に注意が必要です。<i>grsecurity</i>が必要かどう
			かわからない場合は、無効にしておきましょう。</warn>

			<p>上からひとつを選び、下記のようにマージしてください。</p>

			<pre caption = "カーネルソースのマージ">
# <c>emerge sys-kernel/gentoo-sources</c>
			</pre>

			<p>カーネルの準備ができたら、好みに応じてカスタマイズしてカーネルをコンパイルしてください。</p>

			<pre caption = "Linuxカーネルのコンパイル">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>mv /boot/bzImage /boot/bzImage.orig</c>
<comment>[既にbzImageが存在する場合]</comment>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
			</pre>

			<warn>カーネルが適切に機能するために必要なオプションがいくつかあります。
			これらは<i>モジュールとしてコンパイルしてはなりません</i>。&quot;Code
			maturity level options&quot;の中にある&quot;Prompt for development and/or
			incomplete code/drivers&quot;オプションをチェックしてください。&quot;File
			systems&quot;の中の<i>&quot;Device File System&quot;</i>オプションにもチェックしてく
			ださい（&quot;/dev/pts file system support&quot;オプションは<e>チェックする必要
			はありません</e>）。また、<i>&quot;Virtual Memory Filesystem&quot;</i>オプション
			にもチェックします。ReiserFSファイルシステムを使用している場合は
			ReiserFSオプションにチェックします。同様にExt3ファイルシステムを使用し
			ている場合は&quot;Ext3&quot;オプションにチェックします。XFSファイルシステムを使
			用している場合は&quot;SGI XFS filesystem support&quot;オプションにチェックします。
			いずれの場合も&quot;Ext2&quot;オプションはチェックしておいてください。IDEハード
			ディスクを使用している場合は忘れずに&quot;USE DMA by default&quot;オプションを
			チェックしてください。これを忘れてしまうと、ディスクのパフォーマンスが
			非常に貧弱になってしまいます。もちろん&quot;IDE disk&quot;オプションをチェックす
			るのを忘れずに。さもないと、カーネルがIDEディスクにアクセスできなくなっ
			てしまいます。</warn>

			<p>ハードウェアRAIDを利用する場合はさらにカーネルに組み込まなければな
			らないオプションがあります。HighpointのRAIDコントローラを使っている場
			合は&quot;hpt366 chipset support&quot;、&quot;support for IDE RAID controllers&quot;、
			&quot;Highpoint 370 software RAID&quot;を選択してください。PromiseのRAIDコントロー
			ラを使っている場合は、&quot;PROMISE PDC202{46|62|65|67|68|69|70} support&quot;、
			&quot;support for IDE RAID controllers&quot;、&quot;Support Promise software RAID
			(Fasttrak(tm))&quot;を選択してください。
			</p>

			<p>インターネット接続にPPPoEを使っているなら、以下のオプションを選択してください(ビルトインか、
			できればモジュール)。
			&quot;PPP (point-to-point protocol) support&quot;、 &quot;PPP support for async serial ports&quot;、
			&quot;PPP support for sync tty ports&quot;。ふたつの圧縮に関するオプションは害はありませんが
			全く必要ありません。&quot;PPP over Ethernet&quot;オプションも、カーネルモードPPPoEを設定したときに
			<i>rp-pppoe</i>によって利用されるだけです。
			</p>

			<p>もし、IDE CD-Rを使うならば、SCSIエミュレーションを利用できるように
			してください。&quot;ATA/IDE/MFM/RLL support&quot; ---> &quot;IDE, ATA and ATAPI Block
			devices&quot; ---> &quot;SCSI emulation support&quot;をチェックしてください（モジュー
			ルとしてインストールするのが良いでしょう）。そして&quot;SCSI support&quot;の
			&quot;SCSI support&quot;、&quot;SCSI CD-ROM support&quot;と&quot;SCSI generic support&quot;をチェッ
			クしてください（これもモジュールとしてインストールするのが良いでしょ
			う）。モジュールとしてインストールしたならば、<c>echo -e
			&quot;ide-scsi\nsg\nsr_mod&quot; >> /etc/modules.autoload</c>として、ブート時に
			読み込まれるようにしてください。</p>

			<note>
			2.2カーネルベースのGentoo Linuxをインストールすることもできます。安定性と引き換えに
			2.4カーネルの素晴らしい特徴（XFSファイルシステムとtmpfsファ
			イルシステムやiptablesなど）が使えなくなります。ただし、
			Reiserfsファイルシステムやdevfsはパッチを当てることで使えるようにできます。
			Gentoo LinuxのブートスクリプトはtmpfsかRAMディスクのどちらかを必要としますので、2.2カー
			ネルを使用する際にはRAMディスクサポートを組み込んでください（モジュー
			ルではなく）。<comment>必ず</comment><path>/boot/grub/grub.conf</path>
			ファイルに<e>gentoo=notmpfs</e>と記述して、RAMディスクをtmpfsのかわり
			にブートスクリプトにマウントしてください。devfsを使わないならば
			<e>gentoo=notmpfs,nodevfs</e>と記述してください。</note>

			<p>これで、あなたの好みに合ったカーネル(とモジュール)がインストールされました。次に
			好みのシステムロガーをインストールします。従来から使われているsysklogd
			デーモンが利用できます。yslog-ngデーモンやmetalogデーモンも用意してあ
			ります。パワーユーザーは（それほど性能のよくない）sysklogdデーモンから
			syslog-ngデーモンやmetalogデーモンに移行したいと思っているでしょう。疑
			わしくもポピュラーに見えるのでmetalogデーモンを試してみたいかもしれま
			せん。次の4つのロガーからひとつを選んでください。</p>


			<pre caption = "システムロガーの選択">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>または</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>または</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>または</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
			</pre>

			<warn>
			syslog-ngデーモンを使用する場合は
			<path>/etc/syslog-ng/syslog-ng.conf</path>ファイルを作成してください。
			<path>/etc/syslog-ng</path>に設定ファイルのサンプルが用意してあります。
			</warn>

			<impo>
			metalogは一括して出力をディスクに流し込みます。そのため、システムログ
			が継続的に記録されるわけではありません。デーモンのデバッグを行なう時に
			は、このパフォーマンス向上のための動作はかえって邪魔になるでしょう。
			Gentoo Linuxでは、一時的にメッセージバッファを止めるために（<i>tail -f
			<path>/var/log/everything/current</path></i>コマンドがリアルタイムで実
			行されることを期待して）metalogデーモンにUSR1信号を送ることができます。
			メッセージバッファを働かせるためにはUSR2信号を送ってください。</impo>

			<p>次にdcron、fcron、vcronの中から好みのcronを選んでください。どれを選
			べば分からない時はvcronをおすすめします。次のようにインストールしてく
			ださい。</p>

			<pre caption = "cronデーモンの選択">
# <c>emerge sys-apps/dcron</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge sys-apps/fcron</c>
# <c>crontab /etc/crontab</c>
<comment>または</comment>
# <c>emerge sys-apps/vcron</c>
<comment>vcronを使う場合は、<c>crontab /etc/crontab</c>を実行する必要はありません。</comment>
<comment>適切なinitレベルに *cron を忘れずに追加してください。</comment>
# <c>rc-update add *cron default </c>
			</pre>

			<p>Gentoo Linux下でのさらに詳しいcronの働きについては<uri
			link="http://lists.gentoo.org/pipermail/gentoo-announce/2002-April/000151.html">
			このアナウンス</uri>を参照してください。</p>
		
			</body>
		</section>
	</chapter>

	<chapter>
	<title>最終ステップ: 追加パッケージのインストール</title>
		<section>
			<body>

			<p>もしネット接続にrp-pppoeが必要なら、ここでインストールしてください。</p>

			<pre caption = "rp-pppoeのインストール">
# <c>emerge rp-pppoe</c>
			</pre>

			<note>rp-pppoeはインストールされましたが、設定されていません。
			はじめにGentooシステムをブートしたとき、もう一度 <c>adsl-setup</c> を実行してください。
			</note>


			<p>もしXFSやReiserFS、LVMといったオプション機能を使うのなら、
			Portageツリーの他の追加パッケージも必要となります。
			もしXFSを使うのなら、<c>xfsprogs</c>をemergeしてください。
			</p>

			<pre caption = "ファイルシステムツールのマージ">
# <c>emerge sys-apps/xfsprogs</c>
<comment>ReiserFSを使いたいなら、ReiserFSツールをマージしてください。</comment>
# <c> emerge sys-apps/reiserfsprogs</c>
<comment>LVMを使うのなら、<c>lvm-user</c>パッケージをマージしてください。</comment>
# <c>emerge --usepkg sys-apps/lvm-user</c>
			</pre>


			<p>もしラップトップを使っていて、rebootしたあともPCMCIAスロットを使いたいのなら、
			<i>pcmcia-cs</i>パッケージをインストールしてください。
			</p>

			<pre caption = "PCMCIA-csのマージ">
# <c>emerge sys-apps/pcmcia-cs</c>
			</pre>

			<warn>PCMCIAを機能させるためには、インストールがすべて終わったあとで再度<i>pcmcia-cs</i>をemergeしなおす必要があるでしょう。
			</warn>

			</body>
		</section>
	</chapter>

	<chapter>
	<title>最終ステップ: /etc/fstab</title>
		<section>
			
			<body>

			<p>ここまでの作業でGentoo Linuxシステムはほぼ完成しました。あとは重
			要なシステムファイルを作成し、GRUBブートローダーをインストールします。
			まず、<path>/etc/fstab</path>ファイルを編集します。ReiserFSファイルシ
			ステムを使用する場合は<c>notail</c>オプションをbootパーティションに付
			加するのを忘れないでください。<c>ext2</c>、<c>ext3</c>や
			<c>reiserfs</c>などのファイルシステムのタイプも指定してください。</p>

			<p>下記の<path>/etc/fstab</path>のように設定してください。もちろん、
			&quot;BOOT&quot;、&quot;ROOT&quot;、&quot;SWAP&quot;のデバイス名を実際のデバイス名（<c>hda1など</c>）
			に変更してください。</p>
			<pre caption = "fstabの編集">
<comment>
# /etc/fstab: 静的なファイルシステム設定.
#
# noatime はパフォーマンスを向上させます (atimesは通常は必要ありません)
# notail は ReiserFS のパフォーマンスを向上させます (ディスク効率が犠牲になります)
# noatimeを削っても安全です。また、notailとtailは自由に切り替えられます。

# &lt;fs&gt;           &lt;mountpoint&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: もしBOOTパーティションがReiserFSなら、notailオプションを加えてください。
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
			</pre>

			<warn>
			<i>/boot</i>がブート時にマウントされないことに気づいたでしょうか。これ
			は/bootが破壊されることを防ぐためです。/bootにアクセスする必要があると
			きは、マウントしてください。</warn>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終ステップ: Root パスワード</title>
		<section>
			<body>
				
				<p>忘れないうちに、rootのパスワードを設定しましょう。</p>

				<pre caption = "rootパスワード設定">
# <c>passwd</c>
				</pre>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終ステップ: /etc/hostname</title>
		<section>
			<body>
			<p>完全なドメイン名をファイルに書き込んでください（例：<c>mymachine.mydomain.com</c>）</p>

			<pre caption = "Hostname設定">
# <c>echo mymachine.mydomain.com > /etc/hostname</c>
			</pre>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終ステップ: /etc/hosts</title>
		<section>
			<body>
			<p>このファイルにホストネームとIPアドレスを書き込んでください。ネーム
			サーバに無いホストネームとIPアドレスの解決に使用されます。以下にこのファ
			イルのテンプレートを示します。</p>

			<pre caption = "Hosts テンプレート">
127.0.0.1      localhost
<comment># 次の行にはローカルLANのIPとマシン名を記述します</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
			</pre>

			<note>DHCPサーバを使ったネットワークにいるなら、<i>localhost</i>をあな
			たのマシンの名前に設定するとよいでしょう。GNOMEやその他の多くのプログ
			ラムが名前解決するときの助けとなります。</note>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終ネットワーク設定</title>
		<section>
			<body>

			<p><path>/etc/modules.autoload</path>ファイルにシステムに必要なモジュー
			ルを書き込んでください（その他のオプションがあれば、ここに書き込んでく
			ださい）。Gentoo Linuxがブートする時、これらのモジュールが自動的に読み
			込まれます。特に重要なものがモジュールとしてコンパイルした場合のイーサ
			ネットカードモジュールです。
			</p>

			<pre caption="/etc/modules.autoload"><comment>ここでは3comのカードを使っていると仮定しています。<path>/lib/modules/`uname -r`/kernel/drivers/net</path>を見て、自分のカードを探してください。</comment>
3c59x
			</pre>

			<p>ブート時にネットワークの設定を読み込ませるために
			<path>/etc/conf.d/net</path>スクリプトを編集してください。</p>

			<pre caption = "ブート時のネットワーク設定">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
			</pre>


			<p>もし、複数のネットワークカードを使用しているなら、それぞれに
			<path>net.eth<comment>x</comment></path>スクリプト
			（<comment>x</comment>=1,2,…）を追加してください。</p>

			<pre caption="複数のネットワークインタフェース">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
			</pre>


			<p>PCMCIAカードをインストールしている場合は、
			<path>/etc/init.d/pcmcia</path>の中を見て問題ないか確認し、
			<path>/etc/init.d/net.eth<comment>x</comment></path>の一番上に以下を追加してください。</p>

			<pre caption = "/etc/init.d/net.ethx での PCMCIA用 depend">
depend() {
	need pcmcia
}
			</pre>

			<p>ネットワーク設定が読み込まれる際、自動的にPCMCIAドライバが読み込まれます。
			</p>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終ステップ: 基本設定 (キーマップ設定など)</title>
		<section>
			<body>

			<pre caption="基本設定">
# <c>nano -w /etc/rc.conf</c>
			</pre>

			<!--
			<p>Follow the directions in the file to configure the basic settings.  
			All users will want to make sure that <c>CLOCK</c> is set to his/her
			liking.  International keyboard users will want to set the <c>KEYMAP</c>
			variable (browse <path>/usr/share/keymaps</path> to see the various
			possibilities).
			</p>
			-->
			<p>基本設定を行うには、ファイル内の指示に従ってください。
			<c>CLOCK</c>が望みどおりに設定されているか確認しましょう。
			またKEYMAP変数が合っているか見てください。設定できるキーマップを見つけるには
			<path>/usr/share/keymaps</path>の中を探してください。
			</p>

			</body>
		</section>
	</chapter>
	<chapter>
		<title>最終設定: GRUB設定</title>
		<section>
			<body>

			<!--
			<p>The most critical part of understanding GRUB is getting comfortable with how GRUB
			refers to hard drives and partitions. Your Linux partition <path>/dev/hda1</path> is called
			<path>(hd0,0)</path> under GRUB.  Notice the parenthesis around the hd0,0 - they are required.  
			Hard drives count from zero rather than &quot;a&quot;, and partitions start at zero rather than one.
			Be aware too that with the hd devices, only harddrives are counted, not atapi-ide devices such as
			cdrom players, burners, and that the same construct can be used with scsi drives.
			(Normally they get higher numbers than ide drives except when the bios is configured
			to boot from scsi devices.) Assuming you have a harddrive on /dev/hda, a cdrom player on /dev/hdb,
			a burner on /dev/hdc and a second hardrive on /dev/hdd, for example, and no scsi harddrive
			<path>/dev/hdd7</path> gets translated to <path>(hd1,6)</path>.

			It might sound tricky, and tricky it is indeed, but as we will see, grub
			offers a tab completion mechanism that comes handy for those of you having
			a lot of harddrives and partitions and who are a little lost in the
			grub numbering scheme. Having gotten the feel for that,
			it's time to install GRUB.
			</p>
			-->
			<p>GRUBを理解するのにもっとも重要なことは、GRUBがどうやってハードディ
			スクとパーティションを参照するかということです。<path>/dev/hda1</path>
			パーティションはGRUBでは<path>(hd0,0)</path>と呼ばれます。hd0,0をカッ
			コでくくる点に注意してください。ハードディスクはaからではなく0から数え
			ます。パーティションは1からではなく0から数えます。
			注意しなければならないのは、数えられるのはハードディスクだけ、という点です。
			CD-ROMプレイヤーやライターといったATAPI-IDEデバイスは数えられません。
			これはSCSIでも同じです(通常、SCSIはIDEより大きな番号が割り当てられます。
			ただし、BIOSでSCSIからブートするようになっている場合を除きます)。
			たとえば、ハードディスクが /dev/hda、CD-ROMドライブが /dev/hdb、CD-Rが /dev/hdc、
			二つ目のハードディスクが /dev/hddだとすると、<path>/dev/hdd7</path>は変換されて<path>(hd1,6)</path>
			となります。

			これはトリッキーに見えますし、実際にトリッキーなのですが、
			grubはtabキーによる補完の機能をもっているので、ハードディスクやパーティションが
			たくさんあってもgrubの番号付けで混乱することは少ないでしょう。
			感じが掴めたら、GRUBをインストールしましょう。
			</p>

			<p>GRUBをインストールするもっとも簡単な方法は、chrootから<c>grub</c>とタイプすることです。</p>

			<pre caption = "GRUBインストール">
# <c>grub</c>
			</pre>

			<!--
			<impo>If you are using hardware RAID this part will not work at
			this time.
			Skip to the section on making your <path>grub.conf</path>. After that we will complete the
			grub setup for RAID controllers
			</impo>
			-->
			<impo>もしハードウェアRAIDを使っているのなら、ここの記述はうまく動かないでしょう。
			次のセクションにいき、<path>grub.conf</path>を作成してください。
			その後RAIDコントローラ用のgrub設定を完了させます。
			</impo>

			<!--
			<p>You'll be presented with the <c>grub&gt;</c> grub
			command-line prompt.  Now, you need to type in the
			right commands to install the GRUB boot record onto your hard drive.  In my example configuration,
			I want to install the GRUB boot record on my hard drive's MBR (master boot record), so that 
			the first thing I see when I turn on the computer is the GRUB prompt.  In my case, the commands
			I want to type are:
			</p>
			-->
			<p>
			<c>grub&gt;</c>というgrubのコマンドラインプロンプトが表示されているでしょうか。
			ここではハードディスクにGRUBブートローダをインストールするために正しくコマンドを入力
			してください。
			設定例では、GRUBブートローダをハードディスクのMBR(マスターブートレコード)にインストールするので、
			コンピュータを起動したとき最初に目にするものが GRUBプロンプトになります。この場合は、
			次のように入力します。
			</p>

			<pre caption = "GRUBコマンド">
grub&gt; <c>root (hd0,0)</c>
grub&gt; <c>setup (hd0)</c>
grub&gt; <c>quit</c>
			</pre>

			<!--
			<p>Here's how the two commands work.  The first <c>root ( )</c> command tells GRUB
			the location of your boot partition (in our example, <path>/dev/hda1</path> or 
			<path>(hd0,0)</path> in GRUB terminology.  Then, the second <c>setup ( )
			</c> command tells GRUB where to install the
			boot record - it will be configured to look for its special files at the <c>root
			( )</c> location that you specified.  In my case, I want the boot record on the
			MBR of the hard drive, so I simply specify <path>/dev/hda</path> (also known as <path>(hd0)</path>). 
			If I were using another boot loader and wanted to set up GRUB as a secondary boot-loader, I
			could install GRUB to the boot record of a particular partition.  In that case,
			I'd specify a particular partition rather than the entire disk.  Once the GRUB
			boot record has been successfully installed, you can type <c>quit</c> to quit GRUB.  
			-->
			<p>このふたつのコマンドの意味を説明します。<c>root ( )</c>はGURBにブー
			トパーティション（上の例で言えばGURBの<path>(hd0,0)</path>つまり
			<path>/dev/hda1</path>）の位置を教えます。<c>setup ( )</c>はGRUBに
			<c>root ( )</c>で指定したブートパーティションを探すためのブートレコー
			ドをどこにインストールするのかを教えます。上の例では、ブートレコードを
			ハードディスクのMBRにインストールするので、単純に<path>/dev/hda</path>
			（GRUBでは<path>(hd0)</path>です）と指定します。もしほかのブートローダ
			を使用していて、GRUBをセカンダリ・ブートローダとしたいのであれば、GRUB
			を特定のパーティションにインストールすることができます。その場合はディ
			スク全体ではなく、特定のパーティションを指定します。GRUBのインストール
			に成功したら、<c>quit</c>とタイプしてGRUBを終了してください。

			<!--
			<note> The tab completion mechanism of grub can be used from within grub, 
			assuming you wrote <c> root (</c> and that you hit the TAB key, you would
			be prompted with a list of the available devices (not only harddrives), 
			hitting the TAB key having written <c> root (hd</c>, grub would print the
			available harddrives and hitting the TAB key after writing <c> root (hd0,</c>
			would make grub print the list of partitions on the first harddrive.

			Checking the syntax of the grub location with completion should really help
			to make the right choice.
			</note>
			-->
			<note>
			grubのTAB補完はgrub内で使えます。<c> root (</c>と書いてからTABを押すと
			利用可能なデバイスの一覧(ハードディスクだけではありません)が表示されます。
			<c> root (hd</c>を入力してからTABを押すと利用可能なハードディスクを
			一覧表示します。<c> root (hd0,</c>と書いてからTABを押すと最初の
			ハードディスクのパーティションが一覧表示されます。
			
			補完機能を使いながら、構文のチェックをすると正しい選択をしているか確認するのに
			役立ちます。
			</note>
			
			<!--
			Gentoo Linux is now
			installed, but we need to create the <path>/boot/grub/grub.conf</path> file so that
			we get a nice GRUB boot menu when the system reboots.  Here's how to do it.
			-->
			これで Gentoo Linuxがインストールされました。しかし、システムをリブートしたとき、
			感じのいいGRUBブートメニューを表示させるには、<path>/boot/grub/grub.conf</path>を
			作成しなければなりません。方法は以下のとおりです。
			</p>

			<!--
			<impo>To ensure backwards compatibility with GRUB, make sure to make a link from
			<i>grub.conf</i> to <i>menu.lst</i>. You can do this by doing
			<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>. </impo>
			-->
			<impo>GRUBの下位互換性を保つため、<i>grub.conf</i> から <i>menu.lst</i>へ
			忘れずにリンクを作成してください。これは、<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>
			として実行します。
			</impo>

			<p>grub.confファイルを作成し(<c>nano -w /boot/grub/grub.conf</c> としてください)、以下の内容を書き込みます。
			</p>

			<pre caption = "Grub.conf 設定">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=My example Gentoo Linux
root (hd0,0) 
kernel /boot/bzImage root=/dev/hda3 

<comment> #Below is for setup using hardware RAID</comment>
title=My Gentoo Linux on RAID
root (hd0,0)
kernel /boot/bzImage root=/dev/ataraid/discX/partY

<comment># Below needed only for people who dual-boot</comment>
title=Windows NT Workstation
root (hd0,5) 
chainloader +1
			</pre>

			<note>
			(hd0,0) は括弧内に空白を入れずに記述しなければなりません。
			</note>

			<impo>
			IDE CD-R用にSCSIエミュレーションを設定しているなら、カーネルの引数に
			&quot;hdx=ide-scsi&quot;を追加してください（hdxはCD-Rの位置に合わせてください）。
			</impo>

			<p>このファイルを保存すれば、Gentoo Linuxのインストールは完了します。
			第一オプションを選択しておけば、GRUBはGentoo Linuxをブートします。
			menu.lstファイルの2番目の部分はGRUBでWindowsをブートする方法を示したも
			のです。</p>

			<note>上で述べた<path>(hd0,0)</path>は&quot;boot&quot;パーティション（例では
			<path>/dev/hda1</path>）を指しています。<path>/dev/hda3</path>はrootパー
			ティションを指しています。<path>(hd0,5)</path>にはNTブートローダーが存
			在しています。</note>
			<!--
			<note>
			The path to the kernel image is relative to the boot partition. If for example you have separated boot partition <path>(hd0,0)</path> and root partition <path>(hd0,1)</path>, all paths in the grub.conf file above will become <path>/bzImage</path>.
			</note>
			-->
			<note>
			カーネルイメージへのパスはbootパーティションに対して相対的です。
			もしブートパーティション<path>(hd0,0)</path>とルートパーティション<path>(hd0,1)</path>を持っているなら、
			grub.confのすべてのパスは<path>/bzImage</path>になります。
			</note>

			<p>カーネルに引数を与える必要があるならば、<c>kernel</c>コマンドの後に
			追加してください。上の例ではすでにひとつの引数（<c>root=/dev/hda3</c>）
			を与えていますが、さらに引数を与えることができます。<c>kernel</c>コマ
			ンドに<c>gentoo=nodevfs</c>を追加することにより、デフォルトでdevfsをオ
			フにすることができます（意味が分からない場合は行なわないでください）。
			</p>

			<note>初期のGentoo Linuxには当てはまりませんが、devfsを有効にするため
			に<c>kernel</c>コマンドに<c>devfs=mount</c>を追加する必要はありません。
			rc6ではdevfsはデフォルトで有効になっています。</note>

      </body>
    </section>
  </chapter>
  <chapter>
    <title>最終設定: LILOの設定</title>
    <section>
      <body>
        <p>GRUBは多くの人にとって新しい選択肢ですし、いつも安定しているというわけではありません。LILO(LInuxLOader)はその点ではLinuxブートローダとしての実績があります。安定性や設定が複雑すぎないことを求めるなら、LILOを試してみてください。
	</p>
        <p>まず、LILOをマージしてください。
	</p>
        <pre caption="Emerging LILO">
# <c>emerge lilo</c>
	</pre>
        <p>ではLILOの設定をしましょう。簡単な例を紹介し、その中身の説明をします。
	</p>
        <pre caption="lilo.confの例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
message=/boot/message
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	initrd=/boot/initrd-2.4.20.img
	read-only
	root=/dev/hda5
	
#windowsなどとデュアルブートにする場合
other=/dev/hda1
	label=dos

	</pre>
        <li><i>boot=/dev/hda</i> はLILO自身を最初のIDEコントローラ上の最初のハードディスクにインストールするように指示します。</li>
        <li><i>map=/boot/map</i> はマップファイルを指定します。通常これを書き換えるべきではありません。</li>
        <li><i>install=/boot/boot.b</i> は新たにブートセクタに書き込むファイルを指示します。通常はこれを書き換えるべきではありません。この行がないときは、デフォルトの/boot/boot.bが使われます。</li>
        <li><i>prompt</i>があるとき、LILOは何が参照されたかをメッセージラインに出力します。これを削除することは推奨されませんが、消してしまった場合はマシンがブートするときに[Shift]キーを押しつづけることでプロンプトを出すことができます。</li>
        <li><i>timeout=50</i> はLILOがデフォルトの設定を使ってブートする前にユーザの入力を待つ時間の長さを指定します。これは1/10秒単位で、デフォルトは50です。</li>
        <li><i>message=/boot/message</i> はLILOがユーザにオペレーティングシステムやカーネルを選択してもらう時に表示する画面を指示します。</li>
        <li><i>lba32</i> はハードディスクのジオメトリをLILOに知らせます。よくつかわれるものとしては、他にlinearがあります。何を意味しているのか良くわからないときは変更するべきではありません。システムがブートできなくなってしまうことがあります。</li>
        <li><i>default=linux</i> はデフォルトでブートするオペレーティングシステムを指定します。linuxは、その下で定義されるブートオプションの名前です。</li>
        <li><i>image=/boot/vmlinuz-2.4.20</i> はそのブートオプションで使われるLinuxカーネルを指定します。</li>
        <li><i>label=linux</i> LILOの画面表示で使われる、ブートオプションの名前を指定します。この場合は、defaultの行で指定されている名前でもあります。</li>
        <li><i>initrd=/boot/initrd-2.4.20.img</i> は初期化用RAMディスクイメージを指定します。このイメージはブート時にデバイスを初期化・開始し、カーネルが起動できるようにします。初期化用RAMディスクは、カーネルを読み込むために必要な、SCSIカード、ハードディスクなどの機械依存のドライバを保持しています。複数のマシンで共有するようなことはしないでください。</li>
        <li><i>read-only</i> はルートパーティション(下のroot行を参照)が読み込み専用であり、起動中には書き換えることができないということを指示します。</li>
        <li><i>root=/dev/hda5</i> はLILOにルートパーティションとして使うディスクパーティションを指示します。</li>
        <note>情報を提供してくれた<uri link="http://www.redhat.com">Redhat.com</uri>に感謝します。
	</note>
        <p><i>lilo.conf</i>を編集したら、LILOを実行してMBRに情報を書き込んでください。
	</p>
        <pre caption="LILOの実行">
# <c>/sbin/lilo</c>
	</pre>
        <p>LILOが設定されました。これでGentoo Linuxを起動する準備ができました!
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最終設定: ブートディスク</title>
    <section>
      <title>GRUBブートディスク</title>
      <body>
			<p>どんなLinuxディストリビューションでも、最初にインストールするときにブートディスクも作っておくとよいでしょう。お守りのようなものですが、一般的に作っておいて損はありません。
			ハードウェアRAIDを利用している場合は、<e>必ず</e>GRUBブートディスクを作成して
			ください。grubをchroot環境からRAIDにインストールしても失敗してしまいま
			す。そこで、ブートディスクを作り、最初に再起動したときにGRUBをMBRにイ
			ンストールします。ブートディスクは次のようにして作成します。</p>

			<pre caption = "RAIDブートディスクの作成">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>

# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
			</pre>


      </body>
    </section>
    <section>
      <title>LILOブートディスク</title>
      <body>
        <p>LILOを使う場合でも、ブートディスクを作っておくと良いでしょう。
		</p>
        <pre caption="LILOブートディスクの作成">
# <c>dd if=/boot/your_kernel of=/dev/fd0 </c>
<comment>カーネルサイズは1.4MB以下でなければなりません。</comment>
		</pre>
			</body>
		</section>
	</chapter>

	<chapter>
	<title>インストール完了!</title>
		<section>
			
			<body>
			<p>これでGentoo Linuxがインストールされました。あとは必要な設定ファイ
			ルを更新し、chrootされたshellを終了して、パーティションを切り離したあ
			と再起動しましょう。
			</p>

			<pre caption = "システムの再起動">
# <c>etc-update</c>
# <c>exit</c> 
<codenote>chrootされたshellを終了する。<c>^D</c>とタイプしても良い。</codenote>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
			</pre>

			<note>
			再起動したあとに<c>update-modules</c>コマンドを実行して
			<path>/etc/modules.conf</path>ファイルを作成するのも良いでしょう。一般
			的には、このファイルを直接修正する代わりに<path>/etc/modules.d</path>
			の中のファイルに変更を加えるべきです。</note>

			<impo>もしハードウェアRAIDを使っているなら、最初のrebootにはブートディ
			スクを使うことを忘れないで下さい。再起動後、grubを真っ先にinstallして
			ください。これで終わりです。おめでとう!</impo>

			<p>何か疑問があったり、Gentoo Linuxの開発に携わりたい人は、gentoo-user
			メーリングリストやgentoo-devメーリングリストへの参加も考えてみてくださ
			い。(<uri link="http://www.gentoo.org">main page</uri>に&quot;click to
			subscribe&quot;リンクがあります)。また、
			<uri link="http://www.gentoo.org/doc/en/desktop.xml">Desktop configuration guide</uri>はGentoo
			Linuxシステムを設定するときに役に立ちますし、
			<uri link="http://www.gentoo.org/doc/en/portage-user.xml">Portage user
			guide</uri>はPortageの基礎知識を得るのに役立ちます。その他のドキュメン
			トは<uri link = "http://www.gentoo.org/main/en/docs.xml">こちら</uri>を
			参照してください。インストールやその他の問題で質問したいことがあるなら、Gentoo Linux <uri link = "http://www.gentoo.org/main/en/faq.xml">FAQ</uri>も見てください。Gentoo Linuxへようこそ！どうぞ楽しんで下さい。
			</p>
			
			</body>
		</section>
	</chapter>

	<chapter>
	<title>Gentoo利用統計</title>
		<section>

		<body>

		<p>
		Gentoo Linux 利用統計プログラムは、開発者にユーザの動向を把握する手段
		を提供することを目的に始められました。この gentoo-stats プログラムは
		Gentoo Linuxの利用状況に関する情報を収集し、開発の優先順位を決定するた
		めに使われます。あくまでもオプションとして提供していますが、参加しても
		らえるととても嬉しく思います。集計結果は、<uri>http://stats.gentoo.org/</uri>
		で見ることができます。</p>
		
		<p>
		gentoo利用統計サーバはあなたのシステムに対してIDを割り当てます。
		これはそれぞれのシステムが間違いなく１度だけカウントさ
		れるようにするためのものです。IDを使ってあなたのシステムを識別したり、
		IPアドレスやその他の情報とマッチングしたりすることはありません。あらゆ
		る予防措置を講じて、あなたのシステムのプライバシーが守られるようにこの
		システムを構築しています。以下が、現在&quot;gentoo-stats&quot;プログラムで監視し
		ている項目です。
		</p>

		<ul>
		<li>インストール済みパッケージとそのバージョン</li>
		<li>CPU情報: 速度(MHz)、ベンダ、モデル、CPUフラグ (&quot;mmx&quot;や&quot;3dnow&quot;など)</li>
		<li>メモリ情報 (物理メモリ量、スワップスペース量)</li>
		<li>PCIカードとネットワークコントローラチップ</li>
		<li>使われているプロファイル(/etc/make.profileがどこへリンクしているか)</li>
		</ul>

		<p>
		我々は、機密情報が公開されることが、多くのGentoo Linuxのユーザにとって
		(開発者にとってもそうですが)、脅威となることを承知しています。
		</p>

		<ul>
		<li>gentoo-statsプログラムを変更しない限り、次のような機密情報を通信することはありません: パスワード類、設定情報、靴のサイズ…</li>
		<li>e-mailアドレスの送信はオプションです。デフォルトでは送信されません。</li>
		<li>送信元のIPアドレスもあなたを識別できるような方法で記録されることは決してありません。
		「IPアドレスとシステムIDのペア」はどこにも記録されていません。</li>
		</ul>

		<p>インストールは簡単です。次のように入力してください。</p>

		<pre caption="gentoo-statsのインストール">
# <c>emerge gentoo-stats</c>   <codenote>gentoo-statsのインストール</codenote>
# <c>gentoo-stats --new</c>    <codenote>システムIDの取得</codenote>
		</pre>

		<p>上記の2番目のコマンドは新しいシステムIDをサーバに要求し、それを
		<path>/etc/gentoo-stats/gentoo-stats.conf</path> に自動的に記録します。
		このファイルにはさらに設定オプションを指定することができます。
		</p>

		<p>その後は、定期的に起動する必要があります(rootとして実行する必要は
		ありません)。あなたのcrontabに次の行を追加してください。</p>

		<pre caption="cronでgentoo-statsを更新する">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update > /dev/null</c>
		</pre>

		<p><c>gentoo-stats</c>プログラムは単純なperlスクリプト(<path>/usr/sbin/gentoo-stats</path>)ですので、
		お好みのページャやエディタで見ることができます。</p>

		</body>
	</section>	
</chapter>




</guide>
