<?xml version='1.0' encoding='euc-jp'?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<guide>
<title>Gentoo Linux セキュリティ・ガイド</title>
<author title="Software Developer"><mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>

<abstract>
このドキュメントでは、Gentoo Linuxのセキュリティを高める方法を順を追って説明します。
</abstract>

<version>0.2</version>
<date>10 Maj 2002</date>

-- Introduction start --

<chapter>
<title>はじめに</title>
<section>
<title>このドキュメントの対象読者</title>
<body>

<p>
Gentoo Linuxで作ったサーバを運用している人、もっとセキュリティを高めたい人、もっともっともっともっとセキュリティを高めたい人。
</p>

</body>
</section>

<section>
<title>クレジット</title>
<body>

<p>
Kim Nielsen
</p>

</body>
</section>

<section>
<title>謝辞</title>
<body>

<p>
いろんな間違いやスペルミス、わかりにくい文章を指摘してくれた人たちに感謝します。
</p>

<p>
Bjarke Sørense、Justin Lambert、Andreas Waschbuesch、Duncan Lissett、Sherman Boyd、それからSami Dalouche。
</p>

</body>
</section>

<section>
<title>このドキュメントに今後追加したいもの:</title>
<body>

<p>
バージョン0.4 (侵入検知)
</p>
<ul>
<li>AIDE</li>
<li>snort</li>
<li>arpwatch</li>
</ul>


<p>
バージョン0.6 (バックアップ)
</p>
<ul>
<li>SystemImagerを使ったシステム全体のバックアップ</li>
<li>tarを使った部分バックアップ</li>
<li>PostgreSQLのバックアップ</li>
</ul>


<p>
バージョン0.8 (侵入テスト)
</p>
<ul>
<li>リモート監査</li>
<li>ネットワークの監査</li>
<li>ホストマシンの監査</li>
<li>ソフトウエアの監査</li>
</ul>


<p>
バージョン1.0 (被害を受けた場合)
</p>
<ul>
<li>インシデントの報告方法</li>
<li>犯罪性の調査</li>
<li>証拠が消されていない状態でシステムのイメージを作成する(ddを使用)</li>
<li>パケット情報の収集(tcpdumpを使用)</li>
<li>・・・その他いろいろ・・・</li>
<li>システムの復旧</li>
</ul>

<note>
各バージョンではそれぞれひとつの話題に専念していることに注意してください。それぞれ目的に沿った内容のみを取り上げることで、混乱しないようにするためです。
</note>

</body>
</section>

</chapter>

-- Introduction end --

-- Considerations before installation start --

<chapter>
<title>インストールの前に考慮すべきこと</title>
<section>
<title>物理的なセキュリティ</title>
<body>

<p>
いくら堅牢な設定を施しても、アタッカーがあなたのマシンに物理的に触れることができるようなら、全ての防御用の設定はいとも簡単に回避されてしまいます。ハードウエアが気軽にアクセスできるような場所に設置されていませんか？　鍵がかかるサーバ・クローゼットに置かれているようなら大丈夫でしょう。鍵がかかるケースに入れておくのも良いアイデアですね。最高のセキュリティを確保しようと思うなら、ハードディスクからしか起動できないようにBIOSを設定しておくべきです。フロッピーやCD-ROMからは起動できないようにしてしまいましょう。もっとしつこいくらいちゃんとしたいなら、BIOSパスワードを設定するのも良いと思います。BIOSパスワードは、ラップトップPCを使っているユーザーにも試してもらいたいですね。
</p>

</body>
</section>

<section>
<title>どんなサービスを起動するのか考える</title>
<body>

<p>
どんなサービスが起動していなければいけないのか、どんなサービスが起動していると良いと思うのか、それぞれ文書化しましょう。こうしておくと、あなたのシステムのパーティション案を考えるときに参考になります。また、侵入検知にどういう方法を取るか考えるときにもラクになります。
</p>

<p>
もちろん、使っているコンピュータが1台、または数台で、それを使うのが自分だけなら、わざわざ文書化する必要はありません。
</p>

<p>
例:
</p>

<p>
ファイアーウォールとして動作させようと思っているコンピューターがあります。どんなサービスを起動するべきでしょうか？
</p>

<p>
<e>なにも。</e>SSHぐらいは良いですが。
</p>

<p>
SSH以外は不要だと言うことと、現在のSSHのバージョンを文書化しておきましょう。そうすれば、sshdにセキュリティホールが見付かったときにどのシステムをアップグレードすべきなのかすぐにわかります。また、誰がこのシステムにアクセスできるようにするのか決定するときにも役に立ちます。
</p>

</body>
</section>

<section>
<title>パーティション計画</title>
<body>

<p>
必勝法:
</p>

<ul>

<li>
ユーザーが書き込める全てのディレクトリ(/homeや/tmpや/var)は、それぞれ別のパーティションにした上で、quotaを有効にすべきです。portageはソースをコンパイルする際に/var/tmpを使うので、このディレクトリが含まれるパーティションは大きめにしておく必要があります。こうしておけば、ユーザーがルートパーティションをいっぱいにしてしまう心配を減らすことができます。
</li>

<li>
ディストリビューション標準以外のソフトをインストールするディレクトリは、別のパーティションにするべきです。<uri link="http://www.pathname.com/fhs/">FHS(File Hierarchy Standard)</uri>に従えば、このディレクトリは/optか/usr/localになります。これらのディレクトリを別パーティションにしておけば、システムを再インストールすることになっても、別途インストールしたソフトウエアは消されずにすみます。
</li>

<li>
変更されることのないデータはそれ用のパーティションに移動しておき、そのパーティションはリードオンリーでマウントしましょう。もっと厳密にやりたいなら、これらの変更されることのないデータはCD-ROMのような書き込みのできないメディアに保存することを検討しても良いでしょう。
</li>

</ul>
</body>
</section>

<section>
<title>'root'というアカウント</title>
<body>
<p>
'root'というアカウントはシステムの中で最も強いユーザーで、必要なとき以外はこのアカウントを使ってはいけません。アタッカーにroot権限を奪取された場合、そのシステムはもう信用できません。そうなった場合は再インストールしてください。
</p>

<p>
'root'に関する必勝法
</p>

<ul>

<li>
日々使用するアカウントを必ず作りましょう。そのユーザーがrootになれる必要があるなら、そのアカウントをwheelグループに追加しましょう。wheelグループに追加しておけば、その一般ユーザーはsuコマンドでrootになれます。
</li>

<li>
Xなどのユーザーアプリケーションをrootで起動するのは禁止です。
</li>

<li>
rootとしてログインした後は毎回絶対パスを使いましょう。rootユーザーが使っていると思っているアプリケーションが、実は別の場所に置かれた別のアプリケーションだということはありえます。たとえば誰かが勝手にPATHの設定を変えておいたとします。このときrootが<c>su -</c>を使わずにsuした場合、rootユーザーはそのユーザーのPATHの設定を引き継ぐことになります。
</li>

<li>
あるユーザーが使わなくてはいけないroot権限を必要とするコマンドがそれほど多くないようなら、sudoを利用することも検討してください。ただし、sudoの利用は慎重に！
</li>

<li>
rootとしてログインしているときは端末をそのままにして席を離れてはいけません。
</li>

</ul>

<p>
Gentooではsuしようとする一般ユーザーに対して、よく用いられる方法で制限をかけています。デフォルトのPAMの設定では、wheelグループに属していないユーザーはsuできません。
</p>

</body>
</section>

<section>
<title>ポリシーを決めること</title>
<body>
<section>
<title>なぜポリシーが必要なのか</title>
<body>

<p>それにはいくつか理由があります</p> 

<ul>

<li>
あなたが何をもってセキュアだと定義しているかわからなければ、あるネットワークについてそれがセキュアだと主張することはできません。
</li>

<li>
潜在的なアタッカーを見付けたり、ネットワーク障害を解決したり、監査を行うためには、ネットワークトラフィックの盗聴やプライベートなホームディレクトリを見ることは不可欠です。そしてほとんどの国で、ユーザーの同意なしにこれらのことを行うのは違法です。現在約60%のアタックが内部犯行であることから考えると、あなたが目を光らせておくことは重要です。
</li>

<li>
セキュリティがなぜ大事かということや、どうやってあなたのユーザーが自分自身や同僚を守るのか説明することもなしに、ユーザーがセキュリティのことを考えてくれるなどと期待することは不可能です。
</li>

<li>
良いガイドラインやネットワークに関する文書はいつだって役に立ちます。たとえどんなものであるにせよ。
</li>

<li>
あなたのネットワークの設定やあなたが提供しているサービスがわからない限り、警察や連邦法執行機関はあなたのためにアタッカーを捕まえることはできません。
</li>

<li>
アタックがあったら何をしますか？　その場合に何をするのか、誰にそのことを伝えるのか、あらかじめ決めておかないといけません。毎回毎回警察やCERTに連絡するだけですか？　たぶん相手にしてもらえないでしょうね！
</li>

</ul>

<p>
というわけで、複数のユーザーが使うシステムでポリシーを決めておくことがなぜ大事なのか、ユーザー教育がなぜ大事なのか、よくわかってもらえたと思います。
</p>

<p>
ポリシーというのは、「誰が」、「どこで」、「なぜ」、「何を」ということをQ&amp;A形式で書いた文書のことです。あなたのシステムやネットワークを使うユーザーに、読んでもらい、理解してもらい、サインしてもらう必要があります。なぜポリシーにサインが必要なのか、ポリシーに直接反するような行動を取ったらどういうことになるのか、ユーザーにポリシーを理解してもらう手助けをすることはとても重要です(ポリシーに違反したらどうなるかは、ポリシー自体に明記しておくべきです)。ユーザーへの説明は繰り返し行いましょう。少なくとも1年に1回は。それはユーザーに思い出してもらうためと言うより、ポリシーは変更できるものだからです。
</p>
<note>
ポリシーは読みやすいものを作ること。また、各話題ごとに明白で明確なものにしておくこと。
</note>

<p>
ポリシーの大部分は直接OS上で実施できますし、ファイアーウォール越しでも実施できます。しかし、一部はそうではありません。
</p>

</body>
</section>

<section>
<title>セキュリティポリシー</title>
<body>

<p>
セキュリティポリシーはあなたのネットワークやホストのセキュリティを保証するための基本的なルール集です。このルール集にはたくさんの情報が詰め込まれています。コンピュータ、ネットワーク、パスワード、メールはどのように扱うべきなのか、逆にどのように扱うべきではないのか。もちろんユーザーがすべきこと、してはいけないことさえも書いてあります。また、アタックを受けた場合どうしたら良いのか、マシン(個々のワークステーションからサーバまで)はどういう風にインストールされたのか、インフラはどのように構築されたのか、という情報もあります。
</p>

<p>
セキュリティポリシーには、少なくとも以下の項目がなくてはいけません:
</p>

<ul>

<li>利用方針</li>
<ul>
  <li>スクリーンセーバ</li>
  <li>パスワードの取り扱い</li>
  <li>ソフトウエアのダウンロード</li>
  <li>ユーザーを監視する場合、その情報</li>
  <li>アンチウイルスソフトの使用</li>
  <li>その他</li>
</ul>

<li>機密情報の取り扱い(紙であれデジタルであれ、書類すべて)</li>
<ul>
  <li>デスクを綺麗にすることと、機密情報を鍵をかけて保存すること</li>
  <li>席を立つ前はPCの電源を落とすこと</li>
  <li>暗号の使用</li>
  <li>信頼できる同僚との鍵の取り扱い</li>
  <li>旅行時の機密情報の取り扱い</li>
</ul>

<li>旅行時のコンピュータ機器の取り扱い</li>
<ul>
    <li>旅行中やホテル滞在中、ラップトップPCをどう扱ったら良いのか</li>
</ul>

</ul>

<p>
IT関連スタッフ向けのポリシーは、一般ユーザーとは少し違うものになります。
</p>

<p>
セキュリティポリシーは膨大なものになりがちで、どんどん新しくなっていくものなので、全ユーザーにとってすぐに忘れられたり使われなかったりしがちです。IT関連スタッフ向けのポリシーは、一般向けユーザー用に作られたポリシーを含むことになるでしょう。そのため、セキュリティポリシーを分割して作っておくのはうまいやり方だと思います。たとえば、「利用方針に関するポリシー」、「パスワードに関するポリシー」、「メールに関するポリシー」、「リモートアクセスに関するポリシー」などなど。
</p>

<p>
セキュリティポリシーの例は<uri link="http://www.sans.org/newlook/resources/policies/policies.htm">The SANS Security Policy Project</uri>にあります。あなたのネットワークがそれほど大きくなく、これらのポリシーではやりすぎだと思われるようなら<uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">サイトセキュリティハンドブック(RFC2196)</uri>(訳注：日本語訳が<uri link="http://www.ipa.go.jp/security/rfc/RFC2196-00JA.html">http://www.ipa.go.jp/security/rfc/RFC2196-00JA.html</uri>にあります)を見てください。
</p>

</body>
</section>
</body>
</section>
</chapter>

-- Considerations before installation end --

-- Tightening the security after/during installation start --

<chapter>
<title>インストール中、そしてインストール後にセキュリティを高める方法</title>
<section>
<title>/etc/make.conf</title>
<body>

<p>
make.confには、ebuildをビルドするときにサポートしたいオプションやライブラリの情報が記載されています。各ebuildがPAM(Pluggable Authentication Modules)やTCP Wrappers、SSL(Secure Socket Layer)などのセキュリティ関連ライブラリをサポートするようにするためには、make.confでこれらをサポートするようにしておかなくてはいけません。マシン全体で使われるUSE変数には、pam、tcpd、sslが含まれるようにすべきです。
</p>

<p>
ですから、以下のようなことをやっては<e>いけません</e>:
</p>

<pre>
USE="-tcpd -pam -ssl"
</pre>

</body>
</section>

<section>
<title>GRUBやLILOにパスワードを設定する</title>
<body>
<section>
<title>GRUB</title>
<body>

<p>
GRUBがパスワードを使うように設定ファイル(<path>/boot/grub/menu.1st</path>)を編集する場合、平文でパスワードを設定する方法と、ソルト付きのMD5でパスワードを設定する方法の、ふたつのやり方があります。
</p>

<pre caption="/boot/grub/menu.lst">
timeout 5
password changeme
</pre>

<p>
こうしておくと<e>changeme</e>というパスワードが追加され、パスワードが入力されないと単にデフォルトの設定で起動するようになります。
</p>

<p>
MD5形式のパスワードを追加したい場合は、shadowファイルと同様のフォーマットであるcryptフォーマット(cryptのマニュアルページを参考のこと)にパスワードをコンバートする必要があります。たとえば<e>changeme</e>をこのフォーマットで暗号化すると、<e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>となるでしょう。
</p>

<p>
こういう風にもできる:
</p>

<pre caption="/boot/grub/menu.lst">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<warn>
この方法を試すときは、timeoutを設定することを忘れないでください。そうしておかないと、パスワードを間違えてしまった場合システムが起動できなくなります。
</warn>

<p>
マシンが遠方にあってキーボードからの入力なしで再起動しなくてはいけない場合、timeoutを5秒に設定しておくととても便利です。GRUBのパスワードについてのもっと詳細な情報は<path>info grub</path>を実行することで見ることができます。
</p>

</body>
</section>

<section>
<title>LILO</title>
<body>

<p>
LILOにもパスワードを設定する方法がふたつあります。ただしこちらの場合は、イメージごとに設定する方法と、全イメージ共通で設定する方法のふたつで、どちらも平文でパスワードを設定することになります。
</p>

<p>
全イメージ共通の設定は、設定ファイルの先頭に記述します:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
もしくは、イメージごとに設定します。
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
restrictedオプションが指定されていないと、毎回パスワード入力のプロンプトが表示されてしまいます。
</p>

<p>
lilo.confを書き変えたあとは、<path>/sbin/lilo</path>を実行する必要があります。
</p>

</body>
</section>
</body>
</section>

<section>
<title>コンソールのセキュリティを高める</title>
<body>

<p>
<path>/etc/securetty</path>には端末の種類が列記されていますが、これを編集することでrootがログインできるTTYデバイスを指定することができます。
</p>

<p>
vc/1以外の行を全てコメントアウトしてしまうのがオススメです。こうしておけば、一度に1回、ひとつの端末でしかrootでログインできなくなります。
</p>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>

<section>
<title>いつもより多めにログを取る</title>
<body>

<p>
詳細なログを取るようにすれば、現在進行中のアタックやすでに展開中のアタックに関して警告やエラーを見つけることができます。アタッカーたちは、実際にアタックする前にネットワークをスキャンしたり調査したりするものです。
</p>

<p>
ログファイルが読みやすくて扱いやすいということも、同様に不可欠なことです。
</p>

<p>
Gentoo Linuxでは、インストール時に3種類のログ記録ソフトから選べるようになっています。
</p>

<section>
<title>syslogd</title>
<body>

<p>
syslogdは一般的に最も有名なLinux/UNIXのログ記録ソフトです。syslogdはログのローテーションを行いません。<path>/etc/logrotate.conf</path>を適切に設定した上で、cronに<path>/usr/sbin/logrotate</path>を追加することで、ログのローテートができるようになります(訳注：そのためには<c>emerge logrotate</c>としてlogrotateをインストールしておく必要があります)。どの程度の頻度でログをローテートすべきかは、システムの負荷によります。
</p>

<p>
以下にsyslogの設定例を示します
</p>

<pre caption="/etc/syslog.conf">
*.=debug                   /var/log/debug
*.err                      /var/log/syslog

#誰がログインしたときにメッセージを残すか
*.=alert                   root,<c>ここにあなたの名前を</c>
*.=emerg                   root,<c>ここにあなたの名前を</c>

mail.info,mail.notice      /var/log/maillog
kern.*                     /var/log/kern.log
daemon.info;daemon.notice  /var/log/daemon.log
cron.*                     /var/log/cron.log
mail.*                     /var/log/mail.log
user.*                     /var/log/user.log
uucp.*                     /var/log/uucp.log
*.*;auth,authpriv.none     /var/log/syslog

#同じログをふたつのファイルに記録する
authpriv.*;auth.*          /admin/auth.log
authpriv.*;auth.*          /var/log/secure

#全部コンソールに表示
*.*                        /dev/tty12

#別のサーバにログを飛ばしたいならこんな感じ
*.*                        @logserver
</pre>

<p>
アタッカーはログファイルを編集したり削除することで、自分の痕跡を消そうとします。ログを別のマシン(ひとつでも複数でも)にあるログサーバに送ることで、アタッカーに対する敷居を高くすることができます。
</p>

<p>
syslogdに関する詳細な情報はマニュアルページを見てください(<path>man syslog</path>)(訳注：<path>man syslogd</path>の方が適切だと思います)。
</p>

</body>
</section>

<section>
<title>Metalog</title>
<body>

<p>
Frank Denis氏作の<uri link="http://metalog.sourceforge.net">Metalog</uri>はログをリモートサーバに送ることはできませんが、そのパフォーマンスとログを記録する際の柔軟性において他を上回っています。
</p>

<p>
Metalogでは、プログラム名やファシリティ(syslogdと同様)でログの指定をできる他、正規表現を書いたりコマンドを実行したりすることもできます。そういう処理が必要な場合は大変重宝します。
</p> 

<pre caption="/etc/metalog.conf">
maxsize  = 1000000
maxtime  = 86400
maxfiles = 7
minimum  = 7

Kernel messages :

  facility = "kern"
  logdir   = "/var/log/kernel"

Auth messages :
  facility = "auth"
  logdir   = "/var/log/auth"

Emergencies :
  facility = "emerg"
  command  = "/usr/local/sbin/pwdfail.sh"  

Crond :

  program  = "crond"
  logdir   = "/var/log/crond"
  
Password failures :

  regex    = "(password|login|authentication)\s+(fail|invalid)"
  regex    = "(failed|invalid)\s+(password|login|authentication)"
  regex    = "ILLEGAL ROOT LOGIN"
  logdir   = "/var/log/pwdfail"
  command  = "/usr/local/sbin/pwdfail.sh"

SSH Server :

  program  = "sshd"
  logdir   = "/var/log/sshd"

Mail :

  facility = "mail"
  logdir   = "/var/log/mail"

Snort:
  program   = "snort"
  command  = "/usr/local/sbin/pwdfail.sh"

Everything important :

  facility = "*"
  logdir   = "/var/log/everything"

Everything very important :

  facility = "*"
  logdir   = "/var/log/critical"

</pre>

<p>
これは「危険度7」といったときに最低限必要なログを取るように、標準的な設定に多少の変更を加えたものです。要するに、全部ログるということですが。
</p>

<p>
Postfix用のpwdfail.shです。
</p>

<pre>
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
同じく、qmail用のpwdfail.sh。
</p>

<pre>
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri>のWebサイトに行けば、もっと詳しい情報が手に入ります。
</p>


</body>
</section>
<section>

<title>syslog-ng</title>
<body>

<p>
syslog-ngは、多少の違いはあるものの、syslogとMetalogの両方が提供する機能を備えています。レベルとcontentによってフィルタしたあとにログに落せます(Metalogのように)し、syslogのようにリモートへログを送れます。syslogdからのログ(Solarisからのログでさえ)を記録できますし、TTYへログを書き込めます。プログラムの実行ができ、ログサーバとして動作させることもできます。syslog-ngは基本的には、柔軟な設定が行え、ふたつのログ記録ソフトがミックスされた、最高のものだと思います。
</p>

<p>
基本的な設定ファイルに少しだけ変更を加えてみました。
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#どこからログを読むのか決める
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#記録先を設定する
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination mailprog { program("/usr/bin/email.sh"); };
destination xconsole { pipe("/dev/xconsole"); };

#フィルタを作る
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#フィルタと記録先を関連付ける
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#failedなログは自分にメールする
log { source(src); filter(f_failed); filter(f_denied); destination(mailprog); };

#デフォルトのログ
log { source(src); destination(console_all); };
</pre>

<p>
とても設定をしやすいものの、設定ファイルが膨大なため設定忘れもしやすいです。作者によれば、暗号化、認証、圧縮、MAC(Mandatory Access Control)を将来実装するとのことです。これらの機能があれば、ネットワーク用のログ記録ソフトとしては最高のものになります。なぜなら、アタッカーがログを盗み見ることができなくなるからです。
</p>

<p>
さらにsyslog-ngにはもうひとつ利点があります。なんと、rootとして走らせなくても良いのです！
</p>

</body>
</section>
</body>
</section>

<section>
<title>パーティションのマウント</title>
<body>

<p>
ext2やext3、ReiserFSを使用しているなら、<path>/etc/fstab</path>でいくつか設定できることがあります。以下がそのオプションです:
</p>

<ul>

<li>
nosuid - SUIDビットを無視して、通常のファイルと同様に扱います。
</li>

<li>
noexec - そのパーティションにあるファイルの実行を禁止します。
</li>

<li>
nodev - デバイスの作成をできないようにします。 
</li>
</ul>

<p>
残念ながら、パスを直接指定せずに実行すればこれらの設定を回避することができます(訳注：原文はUnfortunately these settings can easily be circumvented by executing a non-direct path.ですが、よくわかりませんでした)。とはいえ、/tmpをnoexecでマウントしておけばスクリプト・キディーたちの攻撃の99%は回避できるでしょう。彼等が使う攻撃用コードは、直接/tmpから実行するように作られているからです。
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
<path>/tmp</path>をnoexecモードでマウントしておくことで、一定のスクリプトが実行されることをちゃんと防ぐことができます。
</warn>

<note>
quotasについては別の章で言及しています。
</note>

<p>
私が、通常ファイルが実行されることがない<path>/var</path>をnoexecやnosuid付きでマウントしていないことに注意してください。qmailは<path>/var/qmail</path>にインストールされますが、ここからファイルが実行される必要があり、また、ひとつSUIDされたファイルがあります。それから私は<path>/usr</path>をリード・オンリーでマウントしています。というのも、私はGentooをアップデートするとき以外、ここに何も書き込まないからです。そういう場合は一度読み書きモードでシステムをマウントしたあと、Gentooをアップデートし、再度リードオンリーでマウントします。
</p>

<note>
qmailをインストールしない場合でも、Gentooでは<path>/var/tmp</path>にebuildを作成するため、ここに実行ファイルを置けるようにしなくてはいけません。ただ、どうしても<path>/var</path>をnoexecモードでマウントしたければ、別のパスを使うように設定することもできます。
</note>

</body>
</section>

<section>
<title>ユーザーやグループに対する制限</title>
<body>

<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
リソースの制限をすることは、ローカルユーザーのDoS攻撃を防ぎたい場合や、グループやユーザーに最大ログイン回数の制限を加えたい場合にとても有効です。
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
nprocやmaxloginsを0に設定するぐらいなら、その代わりにユーザーを削除すべきでしょう。上に載せたサンプルはdevグループの設定ですが、ここではプロセス数、コアファイルの大きさ、最大ログイン回数の制限をしています。これ以外の項目については、デフォルトのままです。
</p>
<note>
<path>/etc/security/limits.conf</path>はPAMパッケージの一部なので、PAMを使うパッケージにしか適用されません。
</note>


</body>
</section>

<section>
<title>/etc/limits</title>
<body>
<p>
limitsは、制限を行う<path>/etc/security/limits.conf</path>とよく似ています。唯一の違いはフォーマットですが、制限できる対象がユーザー、もしくはワイルドカードでの指定だけになっています。グループを制限対象にすることはできません。以下のちょっと緩めの設定を見てみてください:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
ここではデフォルトの設定と、<e>kn</e>というユーザーの設定をしています。limitsはshadowパッケージの一部で、shadowのログインプログラムにのみ適用されます。make.confでPAMを使うように指定していて、PAMが適切に設定されているなら、このファイルをいじる必要はりません。
</p>

</body>
</section>
<section>

<title>quota</title>
<body>

<p>
ファイルシステムにquotaを設定しておけば、ユーザーがディスクをあふれさせることを防げますし、また、一切書き込めないようにすることもできます。quotaはカーネルで有効に設定され、マウントポイントに対して付与されます。カーネルオプションは、設定中の<c>File systems→Quota support</c>にあります。以下の設定を行ったあとカーネルを再構築して、新しいカーネルが使われるように再起動してください。
</p>

<pre>
# <i>emerge quota</i>
</pre>

<p>
以下の例のように、<path>/etc/fstab</path>を編集してディスクの使用制限を加えたいパーティションにusrquotaやgrpquotaを加えてください。
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
quotaを有効にしたい全てのパーティションのルートディレクトリに、quota用のファイル(quota.userやquota.group)を置いてください。
</p>

<pre>
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
この作業はquotaを有効にした全てのパーティションで行う必要があります。quota用のファイルを追加して設定を行ったら、起動時に毎回quotaが有効になるように適切なランレベルに追加しないといけません。以下のスクリプトをコピー&amp;ペーストして、<path>/etc/init.d/quotas</path>として保存してください。ファイルを作成して(このファイルはデフォルトでは存在しません)、実行権限を与えれば大丈夫です。
</p>

<pre caption="/etc/init.d/quotas">
#!/sbin/runscript

depend() {
	need localmount
}

start() {
        if [ -x /sbin/quotacheck ] 
        then 
               ebegin "Checking quotas. This may take some time." 
               /sbin/quotacheck -avug 
               eend $?
        fi 
        if [ -x /sbin/quotaon ] 
        then 
               ebegin "Turning on quota." 
               /sbin/quotaon -avug 
               eend $?
        fi
}

stop() {
        if [ -x /sbin/quotaon ] 
        then 
	       ebegin "Turning off quota."
               /sbin/quotaoff
	       eend $?
        fi
}
</pre>

<p>
<c>rc-update add quotas default</c>を実行して適切なランレベルに対して追加してください。また、1週間に1度定期的なチェックを行うように、cronteb -eをしてquotacheckを追加してください。: <c>0 3 * * 0 /sbin/quotacheck -avug</c>
</p>

<p>
マシンを再起動したら、今度はユーザーとグループに対してquotaの設定をしなくてはいけません。<c>edquota -u kn</c>とすれば$EDITORで設定されたエディタ(デフォルトではnano)が起動し、knというユーザーに対してquotaの設定をできます。-gオプションを付ければ同じことをグループに対して行えます。
</p>

<pre>
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
詳細な情報は<e>man edquota</e>か<uri link="http://www.linuxdoc.org/HOWTO/mini/Quota.html">The quota mini howto</uri>で見てください(訳注：日本語訳が<uri link="http://www.linux.or.jp/JF/JFdocs/Quota/">http://www.linux.or.jp/JF/JFdocs/Quota/</uri>にあります)。
</p>

</body>
</section>

<section>
<title>/etc/login.defs</title>
<body>
	    
<p>
たとえば2週間ごとにユーザーにパスワードを変更させたいなら、PASS_MAX_DAYSを14に、PASS_WARN_AGEを7に設定すると良いでしょう。パスワードを総当たり攻撃されてしまえば、どんなパスワードでも破られるのは時間の問題なので、あなた自身も有効期限付きのパスワードを使うべきです。LOG_OK_LOGINSもyesに設定しておくべきでしょう。
</p>

</body>
</section>

<section>
<title>/etc/login.access</title>
<body>
<p>
login.accessファイルもshadowパッケージの一部で、ログインアクセスをコントロールするテーブルを提供します。このテーブルは誰がログインできて誰がログインできないかを、ユーザー名、グループ名、ホスト名で指定するのに使います。デフォルトの状態では、そのシステムのユーザーは全員ログインできるように設定されていて、このファイルにはコメントとサンプルしか入っていません。あなたがサーバやワークステーションのセキュリティを強化しようとしているかどうかに関わらず、あなた(つまり、管理者)以外の人がこのファイルにアクセスできないようにしておいてください。
</p>
<note>
このファイルでの設定はrootには適用されません。
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<warn>
これらのオプションを設定するときには注意してください。誤って設定してしまうとマシンにアクセスできなくなってしまいます。
</warn>
<note>
SSHのデフォルトの設定では/bin/loginを実行しないようになっているため、login.accessを設定してもSSHでのアクセスには適用されません。<path>/etc/ssh/sshd_config</path>でUseLogin yesと設定すれば/bin/loginが実行されるようになるため、login.accessでの設定が有効になります。
</note>

<p>
上の設定では、wheelグループのメンバーはコンソールかgentoo.orgドメイン経由でしかログインできないように設定しています。多少神経質な設定になっていますが、後で後悔するより良いと思います。
</p>

</body>
</section>

<section>
<title>ファイルのパーミッション</title>
<body>

<section>
<title>「誰でも読める」ということ</title>
<body>

<p>
設定ファイルやパスワードに一般ユーザーがアクセスできるようにすべきではあません。アタッカーはデータベースやWebサイトからパスワードを盗んだり、読めないような状態にしたり、最悪の場合削除してしまったりできます。だから、パーミッションを適切に設定することは大事なのです。もし、あるファイルを使うのがrootだけならそのファイルのパーミッションを0600に設定し、chownを使って適切なユーザーがそのファイルを所有するようにしてください。
</p>

</body>
</section>

<section>
<title>「誰でも書き込める」、「同じグループのユーザーなら書き込める」ということ</title>
<body>

<pre>
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
上のコマンドを実行すると、同じグループのユーザーが書き込めたり誰でも書き込めたりするファイルのリストが、パーミッション付きで膨大なリストになります。リストされたパーミッションをチェックし、<path>/bin/chmod o-w</path>を実行して誰でも書ける状態を除いてください。
</p>

</body>
</section>

<section>
<title>SUIDもしくはSGIDされたファイル</title>
<body>

<p>
SUIDもしくはSGIDされたファイル(つまりスーパーユーザービットがセットされたファイル)は、通常rootだけが実行できる操作を一般ユーザーが実行できるようにするために使われます。このようなファイルはroot権限で実行されるため、(もしそのファイルにセキュリティホールがあれば)ローカル環境でroot権限を乗っ取られることにもなりかねません。これらのファイルは危険なため、どんなことをしても無効にしなくてはいけません。そのファイルを使うことがないならchmod 0とするか、そのファイルが含まれるパッケージをunmergeしてしまってください(qpkg -fとするとどのパッケージにファイルが含まれるのか調べられます。qpkgコマンドがインストールされていないなら<c>emerge gentoolkit</c>としてインストールしてください)。もしくは、単純にchmod -sとやってSUIDビットを落としても良いでしょう。
</p>

<pre>
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
上のコマンドを実行すると、SUIDもしくはSGIDされたファイルがすべて表示されます。
</p>

<pre>
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
デフォルトの状態ではGentoo Linuxにはそれほど多くのSUIDされたファイルは存在しませんが(何をインストールしたかによります)、上のような感じでリスト化しておくと良いでしょう。ほとんどのコマントは一般ユーザーが使うようなものではなく、rootだけが使うべきものです。ping、mount、umount、chfn、chsh、newgrp、suidperl、pt_chown、tracerouteの各ファイルについては、<c>chmod -s</c>を実行してSUIDビットをオフにしてください。su、qmail-queue、unix_chkpwdについてはSUIDビットを落としてはいけません。これらのファイルのSUIDビットを落としてしまうとsuできなくなったりメールが受けとれなくなったりします。SUIDビットを落とすことで、一般ユーザーが(もちろんアタッカーも)これらのファイルを通じてroot権限を奪うことを防げます。
</p>

<p>
私のシステムに存在するSUIDビットの立ったファイルは、su、passwd、gpasswd、qmail-queue、unix_chkpwd、そしてpwdb_chkpwdと、たったこれだけです。もしあなたがXを使っているなら、XはSUIDビットが立ったファイルへのアクセスが必要なのでもう少しこういうファイルがあるかもしれません。
</p>

</body>
</section>


</body>
</section>


<section>
<title>PAM (Pluggable Authentication Modules)</title>
<body>

<p>
PAMはいろいろなプログラムの認証部分の機能を肩代わりしてくれる、共有ライブラリのセットです。Gentoo Linuxで用意されているPAMの設定はとてもよく出来たものですが、もちろん、いつだってこういうことは改善の余地があります。
</p>
<note>
<path>
/etc/make.conf</path>のUSEの設定でPAMを使わないようにしているなら、この章に書かれていることはあなたには関係ありません。
</note>

<p>cracklibのインストール</p>

<pre>
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth     required pam_pwdb.so shadow nullok
account  required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authok
password required pam_pwdb.so md5
session  required pam_pwdb.so
</pre>

<p>
cracklibをインストールして上のように設定しておくと、ユーザーは「最低8文字」「2文字以上の数字を含む」「2文字以上の記号を含む」「以前のパスワードと3文字以上違う文字を含む」というパスワードを設定しないといけなくなります。こうしておけばユーザーは良いパスワードを利用することを迫られます(パスワードポリシー)。詳細なオプションは<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>にあるドキュメントを参考にしてください。
</p>

<pre caption="/etc/pam.d/sshd">
auth      required pam_pwdb.so nullok 
auth      required pam_shells.so
auth      required pam_nologin.so
auth      required pam_env.so
account   required pam_pwdb.so
password  required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authok
password  required pam_pwdb.so shadow md5
session   required pam_pwdb.so
session   required pam_limits.so
</pre>

<p>
<path>/etc/pam.d</path>で個々に設定されていないサービスには「other」ルールが適用されます。デフォルトの設定では当然すべて拒否されるようになっています。ただ、私はログをたくさん溜めるのが好きなので、pam_warn.soを追加することにしています。PAMに関する最後の設定は<path>/etc/security/limits.conf</path>で制御されるpam_limitsです。これに関しては<path>/etc/security/limits.conf</path>の章を参考にしてください。
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

<p>
(訳注：上の設定ファイル中にあるuse_authokはuse_authtokの間違いです。また上記設定を実際に試したところ、正常に動作しませんでした)
</p>

</body>
</section>

<section>
<title>TCP Wrappers</title>
<body>

<p>
通常、各サービスへのアクセスをコントロールするにはinetd(Gentooには含まれていません)を使用しますが、xinetdなどを使うことで同様のことができます。
</p>
<note>
make.conf内のUSEフラグにtcpdが含まれている必要があります。また、各サービスは(xinetdの設定内で)tcpdから起動されている必要があります。詳しくはxinetdの章を見てください。
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
見てわかるとおり<path>/etc/login.access</path>のフォーマットと良く似ています。TCP Wrappersはある特定のサービスをサポートし、その全てのサービスに対して同じようなセキュリティを提供するわけではありません(訳注：原文はTcpd supports a specific service and they do not work in the same area of security.ですが、よくわかりませんでした)。これらの設定はTCP Wrappersを使用するサービスでのみ有効になります。
</p>

<p>
サービスにアクセスがあったときに特定のコマンドを起動させることも可能です(ダイアルアップユーザーの中継を有効にした場合に使えるでしょう)。ただし人間は問題を解決しようとしてそれ以上の問題を作ってしまいがちなので、そういうことはしない方が良いでしょう。たとえば。denyに設定したルールに誰かが引っかかった場合、そのたびにメールを送るスクリプトを起動するように設定したとします。この場合アタッカーはあなたのマシンにアクセスし続けることで簡単にDoS攻撃をすることができます。こうなってしまうとI/O負荷は大きくなってしまうやらメールは溜まってしまうやらで大変なので、そういう設定はしないようにしましょうね！　詳しくは<c>man 5 hosts_access</c>を参照してください。
</p>

</body>
</section>


</body>
</section>
</chapter>

-- Tightening the security after/during installation end --

-- Kernel security start --

<chapter>
<title>カーネルのセキュリティ</title>

<section>
<title>使わない機能は削る</title>
<body>

<p>
カーネル構築の基本原則は、必要としないものは全て削除することです。そうすれば小さなカーネルを構築できますし、ドライバや他の機能の中に眠っている脆弱性も削ることができます。
</p>

<p>
それからローダブルモジュールのサポートもオフにしてください。ローダブルモジュールをサポートしないようにしていてもモジュールを追加することは可能ですが(rootkitなど)、カーネルモジュールを経由してrootkitを仕込もうとする普通のアタッカーににとっては少々荷が重いでしょう。 
</p>

</body>
</section>

<section>
<title>/proc (カーネル用のフラグ)</title>
<body>

<p>
/procファイルシステムやsysctlを使用することで、多くのカーネルパラメータを変更することができます。
</p>

<p>
オン・ザ・フライで動的にカーネルのパラメータや設定を変更するためには、カーネルでCONFIG_SYSCTLが定義されている必要があります。2.4系のカーネルではデフォルトで定義されています。
</p>

<pre>
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
タイプ0のICMPパケット(pingですね)を使えないようにします。なぜならICMPにはあなたが思っているよりずっと多くの情報が含まれているからです。管理者はpingを診断ツールとして使うのでpingが通らないと文句を言ってくると思います。でも外の人がpingを打てるようにしておく理由はないですよね？　ただ、内部の人がpingを使えると有用な場合があるのも事実です。そういう場合はファイアーウォールでタイプ0のICMPパケットを無効にすれば良いです。
</p>

<pre>
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
ブロードキャスト・メッセージに応答しないようにします。
</p>

<p>
Smurf増幅機にはなりたくないでしょ？　Smurf増幅機やクリスマスツリー(訳注：XMASスキャンを受け付けるホストのことだと思います)が存在すると、アタッカーはそれほど多くのパケットを送り出さなくても攻撃対象に対してバーチャルな通信量を爆発的に増加させることができます。
</p>

<pre>
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
ソースルーティングされたパケットを使えなくします。
</p>

<p>
ソースルーティングされたパケットは受け付けないようにしましょう。ソースルーティングされたパケットを使うことで、本当は全然別のところからのトラフィックを、あたかもあなたの内部ネットワークからやってきたかのように偽装することができます。アタッカーはあなたのネットワークを乗っ取れるのです。ソースルーティングが本来あるべき形で使われることは稀です。使えないようにしておきましょう。
</p>

<pre>
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
ICMPのリダイレクト要求を拒否します。ICMPリダイレクトでルーテイングテーブルを変更することもできます。きっとイヤなところにルーティング先を変更されるんでしょう。
</p>

<pre>
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
不正なエラーメッセージに対する防御を有効にします。
</p>

<pre>
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>
IPフォーワーディングをオンにしていれば、ここでやることと同じ結果になります。
</note>

<p>
リバースパスをフィルタできるようにします。こうしておくと、送信元アドレスのルーティングテーブルエントリがそのパケットの到着したNICと合致しないようなパケットを自動的に弾くことができるので、入ってくるパケットが正当な送信元アドレスを持つパケットだと保証することができます。<c>たとえこの設定が非対称なルーティング</c>(あなたがあるホストに送るパケットが通る経路と、そのホストからあなた宛てに来るパケットの通る経路が違う)<c>を使用しているネットワークで問題を起こす可能性があるとしても</c>、またはルータではないのに複数のNICに複数のIPアドレスを差しているホストで同様に問題が起こる可能性があるとしても、IPの偽造を防ぐことができるのでセキュリティ的なアドバンテージになります。
</p>

<pre>
# <i>/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
偽造されたパケット、ソースルーティングされたパケット、そしてリダイレクトされたパケットを記録します。
</p>

<pre>
# <i>/bin/echo "0" > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
IPフォーワーディングをちゃんと無効にしておきます。マルチホームホストでないならこの機能は不要です。
</p>

<p>
これら全ての設定はマシンの再起動時にリセットされてしまいます。ですから、下記のスクリプトを必要なランレベルに追加して実行できるようにしておくことを勧めます。
</p>

<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 before *
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>

<p>
<c>rc-update add procparam default</c>を実行して、必要なランレベルで自動実行されるようにしてください。
</p>

</body>
</section>

<section>
<title>カーネルパッチ</title>
<body>
<section>
<title>Grsecurity</title>
<body>

<p>
<uri link="http://grsecurity.net">Grsecurity</uri>が提供しているパッチはGentooのカーネルの標準なのですが、デフォルトではオフになっています。以下のようにすれば使用可能です:
</p>

<p>
まず普通にカーネルの構築をします。次にGrsecurityオプションを選んでCustomizedを選択し、以下のオプションを有効にしてください:
</p>

<ul>
<li>Buffer Overflow Protection</li>
<ul>
  <li>Openwall non-executable stack</li>
  <li>Gcc trampoline support</li>
</ul>

<li>Filesystem Protections</li>
<ul>
  <li>Proc restrictions</li>
  <li>Linking restrictions</li>
  <li>Secure file descriptors</li>
  <li>Chroot jail restrictions (このオプション以下にあるオプションも全て有効に)</li>
</ul>

<li>Kernel Auditing</li>
<ul>
  <li>Log execs within chroot</li>
  <li>(Un)Mount logging</li>
  <li>Signal logging</li>
  <li>Fork failure logging</li>
  <li>Log set*ids to root</li>
  <li>Time change logging</li>
</ul>

<li>Executable Protections</li>
<ul>
  <li>Dmesg restriction</li>
  <li>Randomized PIDs</li>
  <li>Altered default IPC permissions (正常に動いているプログラムが問題を起こす可能性もあります)</li>
  <li>Restricted ptrace</li>
</ul>

<li>Network Protections</li>
<ul>
  <li>Randomized IP IDs</li>
  <li>Randomized TCP source ports</li>
  <li>Altered Ping IDs</li>
  <li>Randomized TTL</li>
</ul>
<li>Miscellaneous Features</li>
<ul>
  <li>BSD-style coredumps (core.namedのような名前のコアファイルを作ります)</li>
</ul>

</ul>

<p>
以上の設定が終わったらコンパイルして、セキュリティが高められたカーネルをインストールしてください。
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri>は既存のカーネルに暗号化機能を追加するパッチです。このパッチを適用することで、「cryptographic ciphers」、「digest algorithms」、「cryptographic loop filters」といった新しいオプションが現れます。
</p>
<warn>
Kerneliのパッチはまだ最新のカーネルに対応した安定版がありません。利用する際は注意してください。
</warn>

</body>
</section>

<section>
<title>その他のカーネルパッチ</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri> (2.4系カーネル用ではありません)</li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
ま、きっともっとあると思うんですけどね。
</p>

</body>
</section>

</body>
</section>

</chapter>

-- Kernel security end --

-- Securing Services start --

<chapter>
<title>各サービスをセキュアに</title>

<section>
<title>xinetdを使う</title>
<body>
<p>
xinetdはinetd(Gentooには入ってません)に取ってかわるもので、インターネットサービスのデーモンです。xinetdには接続元ホストのアドレスやアクセス時間に基づいてアクセス制限する機能があります。またxinetdは、「サーバがスタートした時間」、「接続元ホストのアドレス」、「接続したユーザー名」、「サーバが起動していた時間」、「要求されたアクション」など、さまざまなログを取ることができます。
</p>

<p>
他の全てのサービスと同様、デフォルトで良い設定になっていることが重要です。 しかしxinetdはroot権限で動作し、 あなたがあまり動作について詳しくないであろうプロトコルをサポートしているので、 使わない方が良いと思います。 ただ、とにかく使ってみたいという場合は以下のようにすることでセキュアにできると思います:
</p>

<pre>
# <i>emerge xinetd tcpd</i>
</pre>

<p>
で、設定ファイルを編集します:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# 以下はpserver(cvs)をxinetd経由で起動する設定です:
# 最高10インスタンス(1度に接続できるのは10接続だけ)
# pserverはTCPでのみ応答する
# cvsというユーザーでこのサービスが動作するようにする
# 1枚のNICでだけこのサービスを受け付ける
# 10.0.0.*というアドレスからのみ接続できる
# 開発者がcvsを使えるのは午前8時から午後5時の間だけ
# TCP Wrappersを使う(<path>/etc/hosts.allow</path>と
# <path>/etc/hosts.deny</path>でアクセス制限をします)
# max_load on the machine set to 1.0
# マシンのmax_load(訳注：1分間のロードアベレージ)を1.0に設定
# disableフラグはすでにデフォルトでnoになっていますが、
# 実際にdisableにしたいときのためにオプションを付けておくのが好ましいです
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
詳しくは<c>man 5 xinetd.conf</c>を参照してください。
</p>

</body>
</section>

<section>
<title>SSH</title>
<body>

<p>
OpenSSHをセキュアにするために必要な設定は、公開鍵認証を使った、より強い認証方法を使用するようにするだけです。あまりにも多くのサイト(<uri>http://www.sourceforge.net</uri>や<uri>http://www.php.net</uri>、<uri>http://www.apache.org</uri>)が、パスワードの漏洩や貧弱なパスワードのために侵入を経験しています。
</p>

<pre caption="/etc/ssh/sshd_config">
#バージョン2のプロトコルのみ有効に
Protocol 2

#直接rootでアクセスするのは禁止
PermitRootLogin no

#RSA公開鍵認証を有効に
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#.rhostファイルや通常のパスワード認証を無効に
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#wheelグループかadminグループに所属していないユーザーはアクセス禁止
AllowGroup wheel admin

#それからあとふたり
AllowUsers kn bs

#ログのレベルを指定
SyslogFacility AUTH
LogLevel INFO

#IPアドレスを割り当てる
ListenAddress 127.0.0.1
</pre>

<p>
(訳注：上の例を見ると「AllowGroupで設定したグループに属しているか、もしくは、AllowUsersで設定したユーザーである」とアクセスできるように読めますが、実際は「AllowGroupで設定したグループに属しており、かつ、AllowUsersで設定したユーザーである」必要があります)
</p>

<p>
あとはあなたのユーザーに以下のコマンドを使って(そのユーザーがサーバにログインしたいマシンで)鍵を作ってもらうだけです。
</p>

<pre>
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>

<p>
パスフレーズを入力します。
</p>

<pre>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_rsa):<c>[enterを押してください]</c>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <c>[パスフレーズを入力します]</c>
Enter same passphrase again: <c>[再度パスフレーズを入力します]</c>
Your identification has been saved in /home/kn/.ssh/id_rsa.
Your public key has been saved in /home/kn/.ssh/id_rsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
こうするとあなたの<path>~/.ssh/</path>ディレクトリ内に、id_rsaとid_rsa.pubというふたつのファイルが追加されます。id_rsaというファイルはあなたの秘密鍵なので他の人にアクセスされないようにしてください。もうひとつのid_rsa.pubはアクセスしたい各サーバに置いておきます。鍵(訳注：公開鍵(id_rsa.pub)の方です)をサーバにあるホームディレクトリの<path>~/.ssh/authorized_keys</path>に追加すれば、そのサーバにログインすることができるでしょう。
</p>

<p>
今後、あなたのユーザーはこの秘密鍵をちゃんと保管しなくてはいけません。いつも持ち歩くメディアに入れておくか自分たちのワークステーョンのみに保存しておきます(ということを<uri link="#doc_chap2">パスワード</uri>のポリシーに追加しておきましょう)。
</p>

<p>
詳細な情報は<uri link="http://www.openssh.org">OpenSSH</uri>のサイト(訳注：日本語版は<uri link="http://www.openssh.org/ja/">http://www.openssh.org/ja/</uri>)にあります。
</p>

</body>
</section>

<section>
<title>Xをセキュアに</title>
<body>

<p>
XFreeは、デフォルトではXサーバとして動作するように設定されています。Xは暗号されていないTCP接続を使用してXクライアントの接続を待っているので危険です。Xサーバの機能を必要としないなら無効にしておきましょう！　ただし、もしあなたのワークステーションをXサーバにしておく必要があるのなら、<path>/usr/X11R6/bin/xhost</path>コマンドは注意して使ってください。このコマンドを使うと、他のホスト上のXクライアントがあなたのディスプレイに接続できるようになります。他のマシンからXアプリケーションを使う必要があってネットワーク越しでしか使用できない場合、このコマンドは便利だと思います。このコマンドは<path>/usr/X11R6/bin/xhost +ホスト名</path>という風に使います。
</p>
<warn>
xhost + という機能(訳注：ホスト名なしで+のみ)は絶対に使わないようにしてください！　こうすると誰でもあなたのXをコントロールすことができるようになります。アタッカーがあなたのXへアクセスできれば、キーストロークを記録してあなたのデスクトップを操作できます。
</warn>

<p>
もっとセキュアにする方法は、<c>startx -- -nolisten</c> tcpとすることでTCPでの接続を無効にするか、もしくは以下のようにファイルを変更して、最初からこの機能を無効にしてしまうことです。
</p>

<p>これを、</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs=""
</pre>

<p>こうします。</p>
<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
グラフィカル・ログインを利用しているなら、ちょっと違うことをしないといけません。
</p>

<p>gdm(Gnome Display Manager)の場合</p>

<p>以下の部分を:</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X
</pre>
<p>
こう変更します。
</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>xdm(X Display Manager)とkdm(KDE Display Manager)の場合</p>

<p>以下を</p>
<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X 
</pre>

<p>こうします。</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>

<section>
<title>プリントサービス</title>
<body>

<section>
<title>lpd</title>
<body>
<p>

</p>
</body>
</section>

<section>
<title>pdq</title>
<body>

<p>http://pdq.sourceforge.net/</p>

<p>
TODO
</p>

</body>
</section>

</body>
</section>



<section>
<title>FTP</title>
<body>
<p>
基本的に、FTP(ファイル転送プロトコル)を使うというのはいただけません。データを暗号化しないし、待ち受けポートをふたつも使うし(通常は20番と21番)、匿名ユーザーをサポートしてるし、アタッカーが(Warez交換のために)探してるサービスだし。FTPのプロトコルにはいくつかセキュリティ上の問題があるので、こういうもろもろのことを避けたいならsftpdかhttpを代わりに使いましょう。それでもFTPを使うのなら、できるだけセキュアにしておいて備えをしておきましょう。
</p>

<section>
<title>Pure-FTPd</title>
<body>

<p>
Pure-FTPdはTrollFTPDから枝分かれしたソフトです。Frank Denis氏により、セキュリティ上の理由で変更や機能が追加されています。
</p>

<p>
AUTHオプションを有効にしてバーチャルユーザー(システムアカウントは禁止)を使用しましょう。-lpuredb:/etc/pureftpd.pdbオプションを設定し、<path>/usr/bin/pure-pw</path>にユーザーを指定しておきます。
</p>

<pre caption="/etc/conf.d/pure-ftpd">
## 全体/IPごとの同時接続数を設定 ##
MAX_CONN="-c 30"
MAX_CONN_IP="-C 10"

## 設定した値よりパーティションが使用されてるならファイルのアップを禁止する ##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## その他もろもろ ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
MISC_OTHERを設定して、匿名ユーザーを禁止したり(-E)、全員がchrootするようにしたり(-A)「.(ドット)」で始まるファイルの読み書きを禁止したり(-X)、アイドルタイムの上限を設定したり(-I)、再帰処理を制限したり(-L)、ちゃんとしたumaskを使用したりするようにしましょう。で、絶対に-wオプションと-Wオプションは使っちゃ*ダメ*です！　Warezなサイトを作りたいなら、ここでこのドキュメント読むの止めちゃてください！
</p>

<p>
詳細は<uri>http://www.pureftpd.org</uri>を見てください。
</p>

</body>
</section>

<section>
<title>ProFTPD</title>
<body>

<p>
ProFTPDにはいくつかセキュリティ上の問題がありましたが、そのほとんどは解決された模様です。いくつかセキュリティを高める設定をしておきます:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#サーバを特定できる情報は見せない
ServerIdent on "Go away"

#バーチャルユーザーの作成をやりやすく
RequireValidShell off

#システムとは別のユーザー/グループのファイルを使用する(passwdファイルはcryptフォーマットです)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# パーミッション関連
Umask 077

# タイムアウトとリソースの制限
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#全員chrootする
DefaultRoot ~

#rootとして起動しない
User  nobody
Group nogroup

#全転送を記録する
TransferLog /var/log/transferlog

#グロブの問題(訳注：DoS攻撃が可能な問題のことだと思います)に対処
DenyFilter \*.*/
</pre>

<p>
あとはあなたと、あなたの読解力(<uri>http://www.proftpd.org</uri>)次第です(訳注：少し古いですが<uri>http://www.infoscience.co.jp/technical/proftpd/</uri>に設定内容に関する日本語訳があります)。
</p>

</body>
</section>

<section>
<title>vsftpd</title>
<body>

<p>
vsftpd(とてもセキュアなftpという意味)は小さなFTPデーモンで、デフォルトの設定も良い感じです。vsftpdはシンプルで、Pure-FTPdやProFTPDが持っているような多くの機能(バーチャルユーザーなど)はありません。
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#リードオンリー
write_enable=NO

#転送ログを取れるようにする
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
見てのとおり個々にパーミッションを設定したりchrootしたりといったことはできません。が、匿名ユーザー用の設定となると、とても良い感じになります。時にはアノニマス(匿名)FTPサーバを用意するのはとても良いことですが(オープンソースなものを共有したり)、このサーバソフトはこういった用途に本当にマッチします。
</p>

</body>
</section>

</body>
</section>

<section>
<title>Apache</title>
<body>

<p>
Apache(1.3.23(訳注：このバージョンにはセキュリティホールがあります。2002.09.26時点での最新版は1.3.26と2.0.42です))はかなり親切な設定ファイルを持つようになりました。ひとつのアドレスでだけ待ち受けるようにしたり、余分な情報を漏らさないようにしたり、多少の作業を行うともっと良くなります。設定ファイルに追加するべきものは・・・:
</p>

<p>
<path>/etc/make.conf</path>にsslを追加しているなら、Apacheをインストールする前にSSLを有効にしたサーバを作れるようにしておきましょう。以下の行を追加しておけば大丈夫です。
</p>

<pre caption="/etc/conf.d/httpd">
HTTPD_OPTS="-D SSL"
</pre>

<p>
(訳注：実は大丈夫ではありません。まず、Apacheをインストールした後、<c>emerge mod_ssl</c>でmod_sslをインストールする必要があります。その後、<path>/etc/conf.d/apache</path>を編集してAPACHE_OPTS="-D SSL"を追加してください。また2002.09.26時点でのApacheのebuildは1.3.26-r4ですが、そもそもUSEにsslが含まれているか見ていないようです)
</p>

<pre caption="/etc/httpd/httpd.conf">
#特定のIPアドレスでのみ待ち受けるようにする
Listen 127.0.0.1
BindAddress 127.0.0.1
#nobodyとnogroupを使うのはよろしくありません
#他の全てのサービスはrootでは走っていませんし
#(apacheというグループに所属したapacheというユーザーを追加しましょう)
User apache
Group apache
#Apacheのバージョンがバレないようにする
ServerSignature Off
ServerTokens min
</pre>

<p>
(訳注：上記ファイルは<path>/etc/apache/conf/apache.conf</path>に移動した模様です)
</p>

<p>
Apacheは--enable-shared=maxと--enable-module=allが指定された状態でコンパイルされます。デフォルトでは全てのモジュールが使えるようになっているので、使わないモジュールは全て、LoadModuleセクション(LoadModuleとAddModule)でコメントアウトしておきましょう。<c>/etc/init.d/httpd restart</c>を実行して(訳注：<path>/etc/init.d/apache</path>に移動した模様です)サービスを再起動してください。
</p>

<p>
<uri>http://www.apache.org</uri>にドキュメントがあります(訳注：<uri>http://www.apache.jp/</uri>に日本語の情報があります)。
</p>

</body>
</section>

<section>
<title>メール</title>
<body>


<section>
<title>Postfix</title>
<body>
TODO!
</body>
</section>

<section>
<title>qmail</title>
<body>
<p>
qmailは最もセキュアなメールサーバだと見なされています。qmailはセキュリティを念頭に(ま、ちょっとやり過ぎなぐらい)書かれています。デフォルトではメールを転送しませんし、1991年以降(訳注：1996年以降の間違い)セキュリティホールは見つかっていません。さ、<c>emerge qmail</c>で設定しましょう！
</p>
</body>
</section>

</body>
</section>

<section>
<title>DNS</title>
<body>
<p>
Gentooはふたつの違ったDNSサーバをサポートしています。BINDとdjbdnsです。
</p>

<section>
<title>BIND</title>
<body>

<p>
BINDは、軽々しく扱うにはちょっと困るようなセキュリティの歴史で知られています。他の全てのサービスと同様、絶対にrootとして動作させては*ダメ*です。ですから、このサービスのデフォルト設定を変更しないでください。デフォルト状態のGentooではこのサービスに関して設定が何もされていませんから、あなたが管理するDNSゾーンについては<path>/etc/bind/named.conf</path>を編集する必要があります。ですがDNSサーバだけではなく、そのプロトコルにもセキュリティ上の問題は存在していますので、きちんとした設定をしないといけません。
</p>

<p>
よく、なぜdjbdns(D.J.Bernstein氏によるとてもセキュアなDNSサーバ)を使わないかと聞かれるんですが、答えは以下の通りです──BINDには、IPv6のサポートのように、djbdnsには無い機能があるから(とりあえず、パッチなしの状態では)。
</p>

<pre caption="/etc/bind/named.conf">
#アクセス制限用の設定
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
#mynetからのクエリのみ許可
  allow-query { "mynet"; };
#ゾーン転送は禁止
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
#再帰的な問い合わせはmynetからのみ許可
  recursion no;
  allow-recursion { mynet; };
#待ち受けるインターフェースを指定
  listen-on { 10.0.0.1; };
#バージョンはヒミツ
  version "Go away";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

#localhostからの、キーを使った制御のみ可能
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>

<p>
以上がデフォルトで使うと良い設定ファイルです。
ですが、BINDバージョン9には、なんとchroot機能があります。
これを使わない手はありません。
以下のようにすれば、chrootされたBINDを作れます。
</p>

<pre>
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>

<p>
上のようにすると<path>/chroot</path>にchrootされた環境が作られます。あとは起動スクリプトを、この新しい環境をサポートするように書き直すだけです。<path>/etc/init.d/named</path>を編集し、start関数のところに<c>-t /chroot/dns</c>を追加してください。stop関数が<path>/chroot/var/run/named/named.pid</path>にあるPIDファイルちゃんと見つけられるようにするのも良いと思います。変更が終わったらDNSサーバを再起動しましょう。
</p>
<note>
アタッカーは、運が良ければchrootされたjailを破ることができます(これを避ける方法はカーネルパッチの章を見てください)。
</note>

<p>
ドキュメントは<uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software Consortium</uri>にあります(訳注：日本語で読める情報としては<uri>http://www.linux.or.jp/JF/JFdocs/DNS-HOWTO.html</uri>が参考になると思います。chrootについては「BIND9」、「chroot」というキーワードで検索するといろいろ出てきます)。
</p>

</body>
</section>

<section>
<title>djbdns</title>
<body>

<p>
djbdnsについては、実際のところあまり言うことがありません。あえて言うなら、作者がdjbdnsがセキュアであることに関して、喜んで<uri link="http://cr.yp.to/djbdns/guarantee.html">お金</uri>をかけてるという点でしょうか。というわけなので<uri>http://www.djbdns.org/</uri>に行って試してみてください(訳注：日本語で読める情報が<uri>http://djbdns.qmail.jp/</uri>にあります)。BIND9とは随分やり方が違いますが、そのうちコツが分かると思います。
</p>

</body>
</section>

</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
SambaはマイクロソフトやNovellのネットワークとファイル共有をできるプロトコルです。ですから、インターネット上で使っては*いけません*。とはいえ、それでも、セキュアにすることは必要です。
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #待ち受けるインターフェースを指定
  interfaces = eth0 10.0.0.1/32

  #ちゃんと暗号化パスワードを使う
  encrypt passwords = yes
  directory security mask = 0700

  #10.0.0.*からの通信のみ許可
  hosts allow = 10.0.0.

  #ユーザー認証を有効に
  #(shareモードで使ってはダメです)
  security = user
  
  #特権アカウントは接続禁止
  invalid users = root @wheel

  #キロバイト単位で使用できるサイズを制限します(訳注：これは間違いです。このオプションでは制限できません)
  max disk size = 102400

  #パスワードポリシーをちゃんとする
  min password length = 8
  null passwords = no

  #PAMを使う(PAMのサポートが追加されてるなら)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
共有ごとにパーミッションがきちんと設定されていることを確認してください。また、<uri link="http://www.samba.org">ドキュメント</uri>も読んでください(訳注：<uri>http://www.samba.gr.jp/</uri>でドキュメントの翻訳が行われています)。
</p>

<p>
Sambaサーバを再起動して、このサービスにアクセスするユーザーを追加してください。<path>/usr/bin/smbpasswd</path>を-aオプション付きで実行すれば大丈夫です。
</p>

</body>
</section>

<section>
<title>chroot環境、もしくはバーチャルサーバ</title>
<body>
<p>
サービスをchrootした状態で提供すれば、アクセスされても良い情報にだけ、そしてrootアクセスにつながるようなアクセス権(や情報)の取得をできないように、サービス(やユーザー)の環境を制限することができます。サービスをroot以外のユーザー(nobody、apache、namedなど)の権限で動作させておけば、アタッカーはそのユーザーに権限があるファイルにしかアクセスできません。ということは、たとえそのサービスにセキュリティ上の問題があっても、アタッカーはroot権限を得ることはできないということです。
</p>

<p>
Pure-FTPdやBINDなどのいくつかのサービスはchrootの機能を持っていますが、そうではないサービスもあります。使おうとしているサービスがchroot機能を持っているなら使いましょう。しかし、そうではない場合は、自分でなんとかしないといけません。では、とりあえずのchrootの理解のために、どうやってchroot環境を作るのかご覧に入れましょう。bashでやってみます(わかりやすいように)。
</p>

<p>
<path>/</path>にchrootという名前のディレクトリを作ります(<c>mkdir chroot</c>)。そして、bashがどんな共有ライブラリとダイナミックリンクしてコンパイルさえているか調べます(-static付きでコンパイルされているならこのステップは不要です)。
</p>

<p>
以下のコマントでbashが使っているライブラリのリストが得られます。
</p>

<pre>
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
では、bashのための環境を作りましょう。
</p>

<pre>
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
次にbashが使用しているファイル(<path>/lib</path>の中のもの)をchrootしたlibにコピーし、bash自身を同じくchrootしたbinディレクトリにコピーします。こうすると、多少使えない機能はありますが、バッチリ同じ環境ができあがります。コピーが終わったら次のようにしてください──<c>chroot /chroot/bash</c>。<c>/</c>ディレクトリにいるというプロンプトが返ってきたら成功です！　うまくいかないときは、どのファイルが足りないか教えてくれるハズです。共有ライブラリの中にはお互いに依存しあっているものもあります。
</p>

<p>
chroot環境の中ではecho以外は何も動作しないことに気がつくと思います。これはchroot環境の外にあるコマンドを何も使えないので、bashとechoしか機能として組み込まれていないからです(訳注：この記述は間違いです。実際はbashの組み込みコマンドなら動作します。詳細は<c>man bash</c>でSHELL BUILTIN COMMANDSを参照してください)。
</p>

<p>
基本的には、こういう風にすれば他のサービスでもchroot環境を作ることができます。bashとの違いは、デバイスファイルや<path>/etc</path>内にある設定ファイルを必要とすることがままあることです。とりあえずそれらをchroot環境内にコピー(デバイスファイルはcp -aでコピーできます)して、起動スクリプトを編集してサービスが実行される前にchrootを使うように変更してください。あるサービスに関して、どのデバイスファイルや設定ファイルが必要なのか見極めるのはとても難しいことです。こういうときは<c>strace</c>コマンドが便利です。使いたいサービスを<path>/usr/bin/strace</path> bashという風に起動して、openやreadやstat、はたまたconnectしてる様を観察してください。どんなファイルをコピーすれば良いかの糸口を示してくれるでしょう。とはいいつつも、だいたいの場合は、passwdファイル(そのサービスで使わないユーザーは削除してください。もちろん編集するのはコピーです)と<path>/dev/zero</path>、<path>/dev/log</path>、そして<path>/dev/random</path>があれば大丈夫でしょう。
</p>

<p>
セキュアな環境を作るもうひとつの方法は、バーチャルサーバ環境を使うことです。これは既存のLinuxをコピーし、バーチャルモードで起動します。ということは、サーバが乗っ取られていた場合はバーチャルサーバも同じく乗っ取られているわけで、インストールしたばかりの状態にはなりません。
</p>

<p>
バーチャルサーバの例:
</p>

<ul>

<li>
<uri link="http://user-mode-linux.sourceforge.net">Usermode linux</uri>のサイトとそれに関するドキュメント<uri link="http://www.gentoo.org/doc/uml.html">user mode linux</uri>(訳注：日本語訳は<uri>http://gentoojp.sourceforge.jp/jpdoc/uml.html</uri>です)
</li>

<li>
<uri link="http://www.solucorp.qc.ca/miscprj/s_context.hc">Virtual private servers</uri>
</li>

</ul>

</body>
</section>

</chapter>

-- Securing Services end --

-- Firewalls --

<chapter>
<title>ファイアーウォール</title>

<section>
<title>ファイアーウォールというもの</title>
<body>

<p>
よく、ファイアーウォールがあればセキュリティは完璧だと思っている人がいますが、それは間違っています。ファイアーウォールの設定を間違っていると、ファイアーウォールがない場合よりもセキュリティ上の問題が大きくなる場合がほとんどです。ファイアーウォールもソフトウエアのひとつなので、ほかのサービスと同様の扱い方をする必要があります。ファイアーウォールにもバク(要するにセキュリティホール)はありえるのですから。
</p>

<p>
なので、実際に導入する前に考えましょう！　本当にファイアーウォールが必要ですか？　必要だと思うのなら、どういう風に動作すべきか、それはどんなファイアーウォールか、誰が操作をするのか、ポリシーに書き加えることを考えなくてはいけません。
</p>

<p>
ファイアーウォールにはふたつの用途があります:
</p>

<ul>
<li>ユーザー(ワームやアタッカー)入って来ないようにする</li>
<li>ユーザー(従業員や子供)が出て行かないようにする</li>
</ul>

<p>
基本的に、ファイアーウォールは3種類に分けられます:
</p>

<ul>
<li>パケットフィルタ</li>
<li>サーキットリレー</li>
<li>アプリケーションゲートウェイ</li>
</ul>

<p>
ファイアーウォールを動かすマシンでは他のサービスを動かしてはいけません(動かすとしてもSSHだけです)。マシンはこのガイドが推奨するやり方でセキュアにしてください。
</p>

</body>
</section>

<section>
<title>パケットフィルタ</title>
<body>

<p>
すべてのネットワークトラフィックはパケットの形を取ります。大きなトラフィックは扱いやすいように小さなパケットに分けられ、目的の場所に届いてから再度組み立てられます。全てのパケットには、どのように、そしてどこにパケットが届けられるべきかの情報が含まれています。これらの情報こそ、まさにファイアーウォールが利用するものです。フィルタリングは以下に基づいて行われます:
</p>

<ul>

<li>送信元/送信先IPアドレスに基づいた許可または禁止</li>
<li>送信元/送信先ポートに基づいた許可または禁止</li>
<li>使用されているプロトコルに基づいた許可または禁止</li>
<li>特定のプロトコルに含まれるフラグに基づいた許可または禁止</li>

</ul>

<p>
基本的にフィルタリングはパケットのヘッダ情報にのみ基づき行われ、パケットの中身には一切関知しません。
</p>

<p>
短所:
</p>

<ul>
<li>パケット中のアドレスの情報は虚偽のものだったり、送信元により、いわゆる「偽造されたアドレス」だったりする</li>
<li>許可されたパケットの中には、 アタッカーがサービスやファイアーウォールにある既知のバグを利用するためのデータやリクエストが含まれている可能性がある</li>
<li>「蟻の穴から堤も崩れる」ということが往々にしてある</li>
</ul>

<p>
長所:
</p>

<ul>
<li>簡単なので実装が容易</li>
<li>実際にアタックされる前に(ポートスキャンを検知することにより)その徴候に対して警告を出すことが可能</li>
<li>SYNアタックをうまく防げる</li>
</ul>

<p>
Linuxで利用されているパケットフィルタの例:
</p>

<ul>
<li><uri link="http://www.iptables.org">iptables</uri>(訳注：<uri link="http://www.linux.or.jp/JF/JFdocs/packet-filtering-HOWTO-7.html">Linux 2.4 Packet Filtering HOWTO: iptables を使う</uri>が参考になると思います)</li>
<li><uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">ipchains</uri>(訳注：日本語訳が<uri>http://www.linux.or.jp/JF/JFdocs/IPCHAINS-HOWTO.html</uri>にあります)</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri>(訳注：パケットフィルタのソフトではなく、ファイアーウォールとして簡単に使えるディストリビューション)</li>
</ul>

</body>
</section>

<section>
<title>サーキットリレー</title>
<body>

<p>
サーキットレベルゲイトウェイとも呼ばれますが、データが実際にやり取りされる前にコネクションの妥当性をチェックすることができるファイアーウォールです。これはつまり、パケットの許可/禁止の決定は単純にパットのヘッダに基づいて行うものの、そのコネクションが妥当なものかどうかは事前に設定されたルールに基づいてセッションがオープンされる前に決定され、その後、許可された送信元アドレスからの許可されたデータのみが通過できるということです。フィルタリングは以下に基づいて行われます:
</p>

<ul>
<li>送信先/送信元アドレス</li>
<li>送信先/送信元ポート</li>
<li>時刻</li>
<li>プロトコル</li>
<li>ユーザー</li>
<li>パスワード</li>
</ul>

<p>
全てのトラフィックは認可され、点検されていて、禁止になったトラフィックは存在しません。
</p>

<p>
短所:
</p>

<ul>
<li>トランスポート層で動作し、実際に通信処理を提供するためには事実上プログラムを修正する必要があることがある</li>
</ul>

</body>
</section>

<section>
<title>アプリケーションゲートウェイ</title>
<body>

<p>
アプリケーションレベルゲートウェイは、アプリケーションのプロクシであり、クライアントに代わってリモートのシステムとデータをやり取りします。アプリケーションゲートウェイを利用することで、DMZやファイアーウォールの背後から実際には外側と接続することなしに、外部とアクセスすることができます。フィルタリングは以下に基づいて行われます:
</p>

<ul>
<li>送信元/送信先に基づく許可/禁止</li>
<li>パケットの内容</li>
<li>その場でパケットの中身を変更することも可能</li>
<li>ファイルの種類や拡張子によるアクセス制限</li>
</ul>

<p>
長所:
</p>

<ul>
<li>ファイルをキャッシュできるのでネットワークのパフォーマンスを向上できる</li>
<li>全てのコネクションに対して詳細なログを取ることが可能</li>
<li>完全に拡張可能(プロクシサーバの中にはキャッシュされたデータを「共有」することが可能なものもある)</li>
<li>外側と直接には通信しない</li>
</ul>

<p>
短所:
</p>

<ul>
<li>設定が複雑</li>
</ul>

<p>
アプリケーションゲートウェイは、rootとして動作させる必要もなければインターンット上に公開する必要もないので、最もセキュアな解決法だと見なされています。
</p>

<p>
フリーなアプリケーションゲートウェイの例:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>

<section>
<title>iptables</title>
<body>

<p>
iptablesを動作させるためには、カーネルでiptablesが使えるようになっていないといけません。私はiptablesをモジュールとして追加し(iptablesのコマンドは必要なときに呼び出されます)、カーネルを再コンパイルしました。カーネルをコンパイルしたあとは(もしくはコンパイルしている最中に)iptablesのコマンドを追加してください。単に<c>emerge iptables</c>とすれば動くでしょう。
</p>

<p>
では、<c>iptables -L</c>としてiptablesが動作しているか確認してください。失敗するようなら何かが間違っているわけで、再度設定をチェックする必要があります。
</p>

<p>
iptablesはステートフルなパケットフィルタです。つまり、iptablesは(2.2系のLinuxで使われていた)ipchainsよりも詳細な制御が可能で、よりセキュリティを向上できるということです。きっと「ステートフルってどういうこと？」、「何が違うの？」と思っていることでしょう。
</p>

<p>
ご存じのとおり、TCPはパケットの集合によって成り立っています。それぞれのパケットには、送信元アドレス、送信先アドレス、そしてシーケンス番号が含まれており、このおかげでお互いにパケットをやり取りすることができるのです。それから、TCPがコネクション型でUDPはコネクションレス型だってこともご存じですよね？　つまり、データを保持する状態の話なんですが。たぶん「で？」って言いたいと思います。えー、では始めますね。
</p>

<p>
あなたがステートレスなファイアーウォール(ipchains)を使っていて、外側のコンピュータが内部のサービスにコネクションを張れないようにしたいとします。でもファイアーウォールは、どうやったらあるパケットが内向きのパケットだと判断できるのでしょうか？　ステートレスなファイアーウォールは、SYNフラグを一所懸命見たところで、すでに確立しているコネクションと新しいコネクションの一部を見分けることはできませんよね！
</p>

<p>
さて、アタッカーがSYNフラグや他のフラグを書き変えた手作りのパケット(アタッカー自身がそういう風に作ったパケット)を送りつけているとしましょう。実際、アタッカーたちはよくこの手を使います。パケットはファイアーウォールをすり抜け、ファイアーウォール上のルーティングテーブルの書き変えやサービスの乗っ取りを行いますが、そのパケットはフィルタによってすでに問題ないと判断されたパケットなのです。ステートフルなファイアーウォールはすべてのコネクションに対する情報を保存しているので、あるパケットがすでに確立したコネクションの一部なのかどうか、簡単に判断できます。あるコネクションがすでに確立したコネクションの一部ではないということがわかれば、不正なパケットだとマークされ、おそらくそのパケットは捨てられるでしょう。ということは、「ステルススキャン」の可能性も排除することができるわけです。そもそもそのコネクションは不正なのですから。
</p>

<p>
あと1ダースもの理由を見つけることはできますが、もうわかってもらえたと思います。ルールがシンプルなほどファイアーウォールの設定項目は少くなり、そうするとメンテナンスするのも簡単になるわけです。
</p>

<p>
ipchainsには他にもレートリミットのような機能もあります。この機能はSYNアタックのような特定のDoS攻撃(サービス拒否攻撃)を防ぐにはもってこいです。えーと、では、SYNアタックとは何でしょうか？
</p>

<p>
繰り返しになりますが、TCPでの接続を確立するときには、以下のように3ウェイハンドシェイクが行われます:
</p>

<fig link="http://www.ibiblio.org/pub/Linux/distributions/gentoo/images/synack.jpg" short="3ウェイハンドシェイク"/>

<p>
SYNアタックとは、SYNパケット(ヘッダにはSYNフラグのみが含まれる)のみを送り本来コネクションを確立するために必要な続くふたつのパケットを送らない攻撃です。SYNパケットにはちゃんとした送信元アドレス(IP)は必要ありません。なぜなら、そもそも返答を期待してませんから。そうすると、そのコネクションはタイムアウトするまでハングすることになります。こういう風に、アタッカーから偽の送信元IPを持った大量のSYNパケットを送りつけられると、そのコンピューターはやってくることがないレスポンスを待つことになります。あなたのシステムのタイムアウトの設定によりますが、このコネクションは30秒から60秒(もしくはもっと長く)保持されるでしょう。コネクションテーブルが満杯になってしまうと、他の誰とも通信ができなくなってしまいます。
</p>

<p>
こういうときはレートリミットを使えば簡単です。<c>-m limit --limit 1/s</c>とすると、ひとつの送信元からのSYNパケットの数を制限することができます。送信元ごとにSYNパケットをひとつに制限できるので、こちらのリソースをSYNフラッドから守れるわけです。
</p>

<p>
では、実践編に入りましょうか！
</p>

<p>
カーネルにiptablesがロードされると、5つの場所にルールを設置するフックが用意されます。それぞれ、INPUT、OUTPUT、FORWARD、PREROUTING、そしてPOSTROUTINGという名前です。これらはルールを追加されると動作し、ルールが追加された場所でルールをチェックするので、チェインと呼ばれます。あるルールにパケットが引っかかると、そのパケットは捨てられ次のチェインには辿り着きません。
</p>

<p>
ルールは上記の5つのチェインに直接追加することもできますし、新しくチェインを作成してそれを既存のチェインにルールとして追加することも可能です。では、どうやってやるのか見ていきましょう。
</p>

<table border="0">
  <tr>
    <th>オプション:</th><th>その説明:</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>追加</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>削除</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>挿入</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>置き換え</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>一覧表示</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>チェインの中にあるルール、もしくは全てのルールの削除</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>あるチェイン、もしくは全てのチェインのカウンタをゼロに</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>パケットをチェインでチェック</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>ユーザー定義チェインを作成</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>ユーザー定義チェインを削除</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>ターゲットのチェインのポリシーを変更</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>チェイン名を変更</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>プロトコル</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>送信元アドレス/ネットマスク</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>送信先アドレス/ネットマスク</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>入力の名前(インターフェース名)</ti>
  </tr>
  <tr>
    <ti>-o</ti><ti>出力の名前(インターフェース名)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>処理の内容(ルールのターゲット)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>拡張されたマッチ(拡張モジュールと共に使用)</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>アドレスやポートを数字で表示</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>適用するテーブル</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>冗長モード</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>数字を拡張(厳密な数字で表示)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>フラグメントされた2番目以降にのみマッチ</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>バージョンを表示</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>一覧表示の際に行番号を表示</ti>
  </tr>
</table>

<p>
まずはiptablesに慣れるために、こちらにやってくるICMPパケットをブロックしてみましょう。
</p>

<pre>
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
最初にどのチェインに追加するか指定します。次にプロトコルを指定し、それからルールを指定します。ルールには、ACCEPT、 DROP、 REJECT、 LOG、 QUEUE、 MASQUERADE、ロードされたモジュール、もしくはユーザー定義チェインが使用できます。ここでは、クライアントに応答を返さずにパケットを破棄するDROPを使います。
</p>

<p>
では、<c>ping localhost</c>としてみてください。マシンに入ってくる全てのICMPパケットをブロックしているので何も応答を得られないはずです。他のマシンにpingを打つこともできません。そのホストから返ってくるICMPパケットも拒否されるからです。ではチェインを初期化してICMPを使えるようにしましょう。
</p>

<pre>
# <i>iptables -F</i>
</pre>

<p>
今度はiptablesのステートフルな部分を見ていきましょう。eth0に入ってくるパケットに対してステートフルな検査をしたいなら、以下のようにしましょう:
</p>

<pre>
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
こうすると既に確立されたパケットとINPUTチェインに関係するパケットを許可することができます。またつい先程説明したように<c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c>とするとパケットの状態リストにないパケットをすべて破棄することができます。iptablesのステートフルな部分を使えるようにしているのは、state拡張モジュールをロードしているからです。外部からのコネクションをあなたのマシンへ受け付けたいなら、<c>--state NEW</c>とすれば良いでしょう。iptablesにはさまざまな用途に使えるモジュールが揃っています。いくつか例を挙げると: 
</p>

<table border="0">
  <tr>
    <th>マッチングを拡張するモジュール</th><th>説明</th><th>拡張オプション</th>
  </tr>
  <tr>
    <ti>mac</ti><ti>入力パケットのMACアドレスに対するマッチング拡張</ti><ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti><ti>ステートフルな検査を有効に</ti><ti>--state (stateに使用できるのはESTABLISHED、RELATED、INVALID、NEWです)</ti>
  </tr>
  <tr>
    <ti>limit</ti><ti>レートのリミット</ti><ti>--limit、--limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti><ti>作成されたパケットのさまざまな特性とのマッチングを試行する</ti><ti>--uid-owner ユーザーID --gid-owner グループID --pid-owner プロセスID --sid-owner セッションID</ti>
  </tr>
  <tr>
    <ti>unclean</ti><ti>パケットに対して様々な正当性チェックを行う</ti><ti/>
  </tr>
</table>

<p>
ユーザー定義チェインを作成し、既存のチェインに適用してみてください:
</p>

<pre>
<codenote>ひとつのルールを含んだ新しいチェインを作成する</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>デフォルトポリシーは、全ての出力パケットを許可し、入力パケットを破棄する</codenote>
# <i>iptables -P OUTPUT -j ACCEPT</i>
# <i>iptables -P INPUT -j DROP</i>
<codenote>作成したチェインをINPUTチェインに追加する</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
INPUTチェインにルールを追加すると、次のようなポリシーになります──出力は全て許可するが、入力はすでに接続が確立したもののみ許可。一般的にいうと、これはよくないやり方です。デフォルトポリシーは破棄(DROP)にすべきですが、まあ、例ということで。
</p>

<p>
もしもっとドキュメントが読みたいなら、<uri link="http://www.iptables.org/documentation/index.html#HOWTO">iptables documentation</uri>を見てください(訳注：リンク先の文書のうちいくつかは、<uri link="http://www.linux.or.jp/JF/">JF</uri>で日本語訳が見つかると思います)。
</p>

<p>
では、ここまでの全てが入った例を見てみましょう。ここでの私のファイアーウォール/ゲートウェイのポリシーはというと:
</p>

<ul>
  <li>ファイアーウォールへの通信はSSH(22番ポート)のみ許可</li>
  <li>ローカルネットワークはHTTP、HTTPS、それからSSHでの通信を許可する必要がある(ので、DNSも必要)</li>
  <li>特定のペイロードを持ったICMPの通信は禁止。もちろん、いくつかのICMP通信は許可する必要がある</li>
  <li>ポートスキャンを検知し、検知したらログを取る</li>
  <li>SYNアタックから身を守る</li>
  <li>これ以外の通信は破棄し、ログを取る</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#内部ネットワーク
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#外部ネットワーク
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #デフォルトルール
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMPでの通信
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #入力パケット
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  $IPTABLES -A allow-ssh-traffic-in -p tcp --sport ssh -j ACCEPT

  #出力パケット
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #ポートスキャンを検知
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  #フラッド攻撃を防衛
  einfo "Creating delay chains"
  $IPTABLES -N delay-flags
  $IPTABLES -F delay-flags
  $IPTABLES -A delay-flags -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST -j ACCEPT
  $IPTABLES -A delay-flags -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN -j ACCEPT
  $IPTABLES -A delay-flags -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN -j ACCEPT

  #INVALIDステートをINPUTチェインに追加して適用
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -j delay-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #クライアントがNAT(Network Address Translation)を通して通信できるようにする
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>
<note>
いくつかの行にバックスラッシュが付いているのは読み易くするためです。この設定を実際に追加しておくことは良い考えだと思います。<uri link="firewall">ここ</uri>からゲットしてください。
</note>

<p>
ファイアーウォール構築に関する大まかなアドバイス:
</p>

<ol>
  <li>実装する前にファイアーウォールのポリシーを作りましょう</li>
  <li>シンプルに！</li>
  <li>各プロトコルがどういう風に動作するか知りましょう(<uri link="http://www.ietf.org/">RFC (Request For Comments)</uri>を読んでください)</li>
  <li>ファイアーウォールはrootで動いているソフトのうちのひとつだということを忘れないでください</li>
  <li>作ったファイアーウォールはテストしましょう</li>
</ol>

<p>
iptablesは理解するのが難しいとか、設定に時間がかかりすぎると思ったら、<uri link="http://www.shorewall.net">Shorewall</uri>という親切なファイアーウォールを使っても良いでしょう。ファイアーウォールのルールの作成には基本的にiptablesが使われていますが、ルールの作成に特化し、特にプロトコルを問いません。
</p>

</body>
</section>

<section>
<title>Squid</title>
<body>

<p>
Squidはとても強力なプロクシサーバで、以下のようなことに基づいて接続をフィルタ、拒否、または許可することができます──時間、パスやURIの正規表現、送信元/送信先IPアドレス、ドメイン、ブラウザ、ユーザー認証、MIMEタイプ、そしてポート(プロトコル)。いくつかの機能を忘れてしまってるような気もしますが、全機能のリストを作るのは至難の技です。
</p> 

<p>
以下の例では、ポルノサイトのフィルタの代わりにバナーのフィルタを扱います。というのも、Gentoo.orgがポルノサイトとしてリストされるのは<c>ナシ</c>だからです。それに、あなたのために良いサイトをいくつか見つける時間もないわけで。
</p>

<p>
ここでは、以下のようなポリシーに従います:
</p>

<ul>
  <li>就業時間(月金の8時から17時と土曜の8時から13時)のネットサーフィン(HTTP/HTTPS)は、ネットサーフィンのためではなくて仕事のために残業しているなら許可</li>
  <li>ダウンロードは禁止(.exe、.com、.arj、.zip、.asf、.avi、.mpg、.mpegなど)</li>
  <li>バナーはキライなのでフィルタして透明なGIFファイルに変換(ここが腕の見せどころですね！)</li>
  <li>これ以外の通信やインターネットからの通信は禁止</li>
</ul>

<p>
これは「カンタン」な4つのステップで実現します。
</p>

<pre caption="/etc/squid/squid.conf">
# IPアドレスとポートを割り当てる
http_port 10.0.2.1:3128

# 基本設定
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# 基本的なアクセス制限用リスト
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# 誰がこのプロクシサーバにアクセスできるのか追加
acl localnet src 10.0.0.0/255.255.0.0

# それからポートについても
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# URLを正規表現に基づいてアクセス制限
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# 時間や曜日に基づいてアクセス制限
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# manager権限でのアクセスはローカルホストからのみ許可
http_access allow manager localhost
http_access deny manager

# PURGE(訳注：キャッシュ内のオブジェクトの削除)要求はローカルホストからのみ許可
http_access allow purge localhost
http_access deny purge

# 不明なポートへのリクエストは禁止
http_access deny !Safe_ports

# SSLとして設定したポート以外のCONNECT要求は禁止
http_access deny CONNECT !SSL_ports

# ここから、私独自の設定です

# バナーを除去した後に表示されるページを追加
deny_info NOTE_ADS_FILTERED url_ads

# で、それらを拒否
http_access deny url_ads

# すべてのアーカイブへのアクセスを禁止
http_access deny archives

# 就業時間のみしかアクセスできなくする
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# のこりは全て禁止
http_access deny all
</pre>

<p>
次にユーザーにダウンロードさせたくないファイルのリストを埋めます。私は、zip、viv、exe、mp3、rar、ace、avi、mov、mpg、mpe、au、ra、arj、tar、gz、それからzという拡張子を持つファイルをリストに入れました。
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
[]の中に各文字の大文字と小文字が入っていますよね？　これはaviファイルを要求する代わりにAvIファイルを要求されてスリ抜けられてしまう、ということを防ぐためです。
</note>

<p>
次にバナーを検知するための正規表現を追加します。あなたは私よりもっとうまくやれると思います:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
で、最後の設定です。バナーを除去したあとに表示したいファイルがこれです。基本的には、4x4の透明なGIF画像を持った途中までのHTMLファイルです。
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
&lt;HTML&gt;と&lt;BODY&gt;タグを閉じないでください。それはSquidがやってくれます。
</note>

<p>
以上のようにSquidには沢山の可能性があり、フィルタとプロクシに関して非常に有効です。他に複数のSquidプロクシを用意して大規模ネットワークに対応させることも可能です。ここで私が挙げた設定は、1から20ユーザーぐらいの小規模ネットワーク向けです。
</p>

<p>
しかし、Squidがどこか安全な場所に置かれていて、外部から誰もアクセスできないようになっているなら、パケットフィルタ(iptables)とアプリケーションゲートウェイ(Squid)の組み合わせは、恐らくベストソリューションでしょう。もちろん内部からのアタックには気を付ける必要はありますが。
</p>

<p>
では、あなたのクライアントマシンのブラウザの設定に、プロクシサーバを追加してください。ここで設定したゲートウェイは、プロクシ経由でない接続を一切禁止します。
</p>
<note>
mozillaを使っている場合は、Edit→Preferences→Advanced→Proxiesから設定できます。
</note>

<p>
iptablesを使ってすべての外向きトラフィックを透過的にSquidに向けることも可能です。ゲートウェイのFORWARD、もしくはPREROUTINGルールに以下を追加してください:
</p>

<pre>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>

<section>
<title>さて、ここまでで私たちは何を学んだんでしょうか？</title>

<body>

<p>
私たちが学んだことは:
</p>

<ol>
  <li>ファイアーウォールはそれ自体が脅威になりうる。不適切な設定をされたファイアーウォールなら無い方がマシ</li>
  <li>基本的なゲートウェイの構築方法と、透過的なプロクシの構築方法</li>
  <li>許可したいプロトコルについて知ることが良いファイアーウォールのカギ</li>
  <li>IPのトラフィックはいつも正当なデータばかりが含まれているわけではない。たとえば不正なペイロードを持ったICMPパケット</li>
  <li>SYNアタックの防ぎ方</li>
  <li>イヤな画像やウイルスのダウンロードからHTTPトラフィックをフィルタする方法</li>
  <li>パケットフィルタとアプリケーションゲートウェイを組み合わせると制御がしやすい</li>
</ol>

<p>
さあ、もし<b>本当</b>に必要なら、自分のニーズに合ったファイアーウォールを作りましょう。
</p>

</body>
</section>

</chapter>

<chapter>
<title>ひとつ前のバージョンからの変更点</title>
<section>
<title>変更点</title>
<body>

<p>
バージョン0.1 → 0.2
</p>
<ul>
  <li>いろんな人が見つけてくれたたくさんのスペルミスを修正(その多くはBjarke Sørensenによるもの)</li>
  <li>apache.confに対する修正(ServerTokens min)</li>
  <li>PREタグで80文字以上になった場合に問題があった点を修正</li>
  <li>ファイアーウォールの章を追加</li>
</ul>

</body>
</section>
</chapter>

</guide>
