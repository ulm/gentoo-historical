<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ja/udev-guide.xml,v 1.11 2006/04/26 17:19:22 idani Exp $ -->

<guide link="/doc/ja/udev-guide.xml" lang="ja">
<title>Gentoo udev ガイド</title>

<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Contributor">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="翻訳">
  <mail link="igarashi@gentoo.gr.jp">五十嵐 正尚</mail>
</author>

<abstract>
この文書では、udevとは何であるか、そして、それはユーザの要求を満たすためにどのように使用することができるかを説明します。
</abstract>

<license/>

<version>0.23</version>
<date>2006-03-25</date>

<!-- Original revision: 1.30 -->

<chapter>
<title>udevって何?</title>
<section>
<title>/devディレクトリ</title>
<body>

<p>
Linuxはウィルスの一種かコーヒーのブランドの何かかな思う人たちの中で、Linuxユーザがシステムのハードウェアについて話すとき、「スラッシュdevスラッシュ何とか」という言葉を使うと、確かに奇妙に映るでしょう。
ですが、幸運なユーザ(読者であるあなたも含む)にとって<path>/dev/hda1</path>と使うのは、プライマリマスタIDEの一番目のパーティションについて話しているということを説明するのには手っ取り早い方法ですよね?
</p>

<p>
私たちの全てがデバイスファイルとは何であるかを知っています。そのうちの幾人かは<path>/dev</path>ディレクトリで<c>ls -l</c>を実行して、その結果をより詳しく見たときに、なぜデバイスファイルが特別な数値を持っているのかさえも知っています。しかし、プライマリマスタIDEディスクが<path>/dev/hda</path>として参照されるということを、私たちは常に当然だと考えます。あなたはこのように判断しないかもしれませんが、そうであればそれは設計上の欠陥です。
</p>

<p>
USBやIEEE1394、ホットスワップ可能なPCIのようなホットプラグ可能デバイスについて考えてみてください...何が一番目のデバイスですか。
そしてそれはどれだけの期間ですか。一番目のものが外されたとき、他のデバイスは何と名前を割り当てられるでしょうか。
現在進行中のトランザクションにどう影響するでしょうか。
あなたのママが、たまたま一番目のプリンタだったレーザープリンタのプラグを引き抜くことにしたために、印刷ジョブがすごく新しいレーザプリンタから、ほとんど死んでしまっているマトリックスプリンタに突然移動されてしまうことは嬉しいですか。
</p>

<p>
udevの話題に入りましょう。udevプロジェクトの目標は、以下のように興味深くもあり必要なことでもあります。
</p>

<ul>
  <li>ユーザスペースでの実行</li>
  <li>デバイスファイルを動的に作成/削除</li>
  <li>一貫性のある命名規則の提供</li>
  <li>ユーザスペース向けAPIの提供</li>
</ul>

<p>
これらの特徴を提供するために、udevは三つに分かれたプロジェクトで開発されています。それはnamedevとlibsysfs、そしてもちろんudevです。
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
namedevは、デバイスの命名規則を、udevプログラムとは分離して定義することを可能にします。
これは、柔軟な命名規則方針や体系を独立した団体が開発することを可能にします。
デバイスネーミングサブシステム(namedev)は、udevから使用できる標準インターフェースを提供します。
</p>

<p>
現在のところnamedevによって一つの命名体系だけが提供されます。
それはLANANAによって提供され、現在のLinuxシステムの大多数によって採用されているので、ほとんどのLinuxユーザにとても馴染みやすいです。
(訳注: LANANA - Linux Assigned Name And Number Authority - http://www.lanana.org/)
</p>

<p>
namedevは、デバイスの名前を見つけるために、5つのステップを踏みます。
デバイスの名前がそのステップの一つで見つかると、その名前が使用されます。
それらのステップは、以下の通りです。
</p>

<ul>
  <li>ラベルまたはシリアルナンバー</li>
  <li>バスデバイスナンバー</li>
  <li>バストポロジ</li>
  <li>静的に与えられる名前</li>
  <li>カーネルが提供する名前</li>
</ul>

<p>
<e>ラベルまたはシリアルナンバー</e>のステップは、デバイスが固有の識別子を持つかどうかをチェックします。例えばUSBデバイスは、固有のUSBシリアルナンバーを持っています。SCSIデバイスは固有のUUIDを持っています。namedevが、指定された設定ファイルで、この固有ナンバーと一致するものを見つけた場合、設定ファイルで提供される名前を使用します。
</p>

<p>
<e>バスデバイスナンバー</e>のステップは、デバイスバスナンバーをチェックします。
ホットスワップ可能でない環境にとっては、このステップはハードウェアデバイスを識別するのに十分に機能します。例えば、PCIバスナンバーは、システムの生存期間中にめったに変わりません。この場合もやはり、namedevは、指定された設定ファイルの中でこの位置関係と一致するものを見つけたら、設定ファイルで提供される名前を使用します。
</p>

<p>
同様に<e>バストポロジ</e>のステップは、ユーザがデバイスを抜き差しして変更しない限り、定義を変更しないやや静的な方法です。ユーザによって提供される設定とデバイスの位置が一致した場合、併記されている名前が使用されます。
</p>

<p>
四つ目のステップ、<e>静的に与えられる名前</e>は、単純な文字列の置換です。カーネルの名前(デフォルトの名前)が、指定される置換文字列に一致する場合、置換した名前が使用されます。
</p>

<p>
最後のステップ(<e>カーネルが提供する名前</e>)は、あらゆる状況に対応します。
このステップは、カーネルによって提供されるデフォルトの名前を取得します。
現在のLinuxシステム上で使用されるデバイスの命名規則に一致するので、ほとんどの状況において十分機能します。
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udevは、sysfs仮想ファイルシステムを通してカーネルと情報のやりとりを行います。
libsysfsプロジェクトは、sysfsファイルシステムによって提供される情報に、共通の方法でアクセスするための、共通API層を提供します。
このAPIは、ハードウェアの種類が何であろうと、すべてのハードウェアに対して問い合わせることを可能にします。
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
カーネルは、デバイス構造の変更を検知すると、<path>/sbin/hotplug</path>プログラムを実行します。hotplugは、<path>/etc/hotplug.d/default</path>ディレクトリにリンクされたアプリケーションを実行します。そのディレクトリには、さらにudevアプリケーションへのシンボリックリンクが見つかるでしょう。
hotplugは、<path>/dev</path>に必要なアクション(デバイスファイルの作成もしくは削除)を実行するudevアプリケーションに、カーネルによって提供される情報を配送します。
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gentooでのudevの使用</title>
<section>
<title>必要条件</title>
<body>

<p>
udevは、(デフォルトの2005.0のプロファイルにある<c>vanilla-sources</c>もしくは<c>gentoo-sources</c>のような)カーネル2.6との組み合わせで使用されるように意図されています。
このようなカーネルを使用しているなら、最新の<c>sys-apps/baselayout</c>バージョンを使用しているか確認する必要があります。必要な条件はこれだけです。
</p>

<pre caption="udevのインストール">
# <i>emerge udev</i>
</pre>

<p>
udevは、依存するものの一つとして<c>hotplug-base</c>をインストールします。
デバイスの接続時に、モジュールが自動的にロードされるのを望まない場合は、<c>hotplug</c>をインストールする必要はありません。<c>hotplug</c>は、ネットワークデバイスの自動起動やファームウェアのダウンロードも処理します。
</p>

<pre caption="オプション扱いのhotplugスクリプトのインストール">
# <i>emerge hotplug</i>
</pre>

<p>
接続済みのデバイスに対するモジュールが、起動前から自動でロードされてほしいなら、coldplugパッケージを使用してください。
</p>

<pre caption="coldplugパッケージのインストール">
# <i>emerge coldplug</i>
</pre>

<p>
bootランレベルに<c>coldplug</c>を追加することを忘れないでください。
</p>

<pre caption="bootランレベルにcoldplugを追加">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
カーネルに関しては、以下のオプションを必ず有効にしてください。
</p>

<pre caption="要求されるカーネルオプション">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
以下のように、希望するなら<c>/dev file system support (OBSOLETE)</c>を有効のままにしておくことができます。ですが、"Automatically mount at boot"は、確実に無効にされなければなりません。
</p>

<pre caption="自動でdevfsdをマウントしてはいけません">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
<c>genkernel</c>を使用するなら、すべての必要なカーネル設定を有効にするために、<c>--udev</c>オプションを付けて実行することを忘れないでください。
この<c>genkernel</c>によって提供される一般的な設定は、必要なものを満たします。
</p>

</body>
</section>
<section>
<title>設定</title>
<body>

<p>
あなたのシステム環境を快適にするためにGentooが追加したudev-tweaksを使用したいなら、これ以上読まないでください。不足しているデバイスノードが少しもないように、Gentooはudevを使用しても、静的な<path>/dev</path>を維持し続けます。
Gentooのinitスクリプトは、devfsdデーモンを実行しませんし、ブート時にdevfsを停止状態にします。
</p>

<p>
しかし、あなたが頑固な人で、udev開発者によって意図される(udevがまだサポートしていないことによるデバイスノード不足の障害も含む)通りに、udev-tweaksを使用しない、udevだけのシステムを走らせたいなら、必ずこのまま読み続けてください。
</p>

<p>
デバイスファイルノードの保存機能を停止します。
<path>/etc/conf.d/rc</path>の中の<c>RC_DEVICE_TARBALL</c>変数を編集し、それに<c>no</c>を設定してください。
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
カーネルにdevfsサポートが含まれているなら、ブートローダ設定でそれを無効にできます。
カーネルパラメータに<c>gentoo=nodevfs</c>を追加してください。
devfsを使用しudevを無効にしたいなら、カーネルパラメータに<c>gentoo=noudev</c>を追加してください。
</p>

</body>
</section>
</chapter>

<chapter>
<title>既知の問題</title>
<section>
<title>ブート時のデバイスノードファイル不足</title>
<body>

<p>
<path>/dev/null</path>が見つからないというエラーが発生するか、最初のコンソールがないのが原因でうまくブートできない場合の問題は、<path>/dev</path>がマウントされてudevによって処理される<e>前に</e>利用可能でなければならない、いくつかのデバイスファイルが不足しているということです。古いメディアからインストールされるGentooマシンで共通の問題です。
</p>

<p>
<c>sys-apps/baselayout-1.8.12</c>もしくはそれ以降のバージョンで実行している場合、ブートプロセスは最低でもなんとか完走するので、この問題は多少解決されます。しかし、うるさい警告をなくすために、以下で述べられる通りにして不足しているデバイスノードを作成するべきです。
</p>

<p>
<path>/dev</path>ファイルシステムがマウントされる前に存在しているデバイスノードを確認するために、以下のコマンドを実行してください。
</p>

<pre caption="ブート時に利用可能なデバイスノードのリスト表示">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
うまくブートするために必要なデバイスは、<path>/dev/null</path>と<path>/dev/console</path>です。もし上記のテストでそれらが表示されないなら、手動で作成しなければなりません。以下のコマンドを<path>test/dev/</path>ディレクトリで実行してください。
</p>

<pre caption="必要なデバイスノードファイルの作成">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
完了したら、<path>test/</path>ディレクトリをアンマウントすることを忘れないでください。
</p>

<pre caption="test/ディレクトリのアンマウント">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udevとnvidia</title>
<body>

<p>
udevのみのシステムでnVidia社が開発したドライバを使用し、Xサーバが起動に失敗したら、以下のものを確認してください。
</p>

<ul>
  <li>
    <path>/etc/modules.autoload.d/kernel-2.6</path>に<c>nvidia</c>モジュールが記述されているか
  </li>
  <li>
    <c>nvidia-kernel</c>のバージョンが<c>media-video/nvidia-kernel-1.0.5336-r2</c>と同じかより大きいものであるか
  </li>
  <li>
    baselayoutのバージョンが<c>sys-apps/baselayout-1.8.12</c>と同じかより大きいものであるか
  </li>
</ul>

<p>
<c>xorg-x11</c>が立ち上がろうとしないなら、<path>/dev/nvidia</path>デバイスファイルがないことが原因かもしれません。
この場合、そのファイルを(再)作成するために<path>/sbin/NVmakedevices.sh</path>を実行してください。
</p>

</body>
</section>
<section>
<title>LVM2での名前の消失</title>
<body>

<p>
<c>udev</c>とLVM2を一緒に使用するときは、ユーザが作成したボリュームグループと論理ボリュームが消失してしまうことに注意してください。それらは消失していますが、不運にも<path>/dev/dm-#</path>(#は0, 1, ...である)という名前を割り当てらています。
</p>

<p>
これを修正するために、<path>/etc/udev/rules.d/50-udev.rules</path>を編集し、以下の行のコメントを外してください。
</p>

<pre caption="/etc/udev/rules.d/50-udev.rulesのこの行のコメントを外す">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k", SYMLINK="%c"
</pre>

<p>
次に、<c>devmap_name</c>アプリケーションを含む<c>sys-fs/multipath-tools</c>をインストールしてください。 
</p>

<pre caption="multipath-toolsのインストール">
<comment>(執筆時には、multipath-toolsはテストブランチでだけ利用可能になっています)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>DevFSとudevとの間で矛盾する命名規則</title>
<body>

<p>
私たちが、両方の動的デバイス管理手法間(DevFSとudev間)で矛盾しない命名体系を使用するつもりでも、ときどき命名規則の違いが発生します。
</p>

<p>
HP Smart Array 5i RAID コントローラ(より正確には<c>cciss</c>カーネルモジュール)に関して、命名規則の矛盾があることが報告されています。
udevでは、そのデバイスは、<path>/dev/cciss/cXdYpZ</path>(X, Y, Z は規則的な数値)と名前を割り当てられます。devfsでは、そのデバイスは、<path>/dev/hostX/targetY/partZ</path>であり、もしくは<path>/dev/cciss/cXdY</path>からシンボリックリンクされます。
</p>

<p>
このような場合、<path>/etc/fstab</path>とブートローダの設定ファイルを適宜変更することを忘れてはいけません。
</p>

<p>
例えば<path>/dev/mouse</path>のような、以前は<path>/dev</path>に存在していた、すべてのシンボリックリンクにも同じことが起こります。それらは、もはや<c>udev</c>は作成しません。
Xの設定ファイルを必ずチェックして、マウスのDeviceルールが、存在するデバイスファイルを指しているか確認してください。
</p>

<p> 
devfsとudevでは端末デバイスの命名方法に違いがあるという別の問題があります。
devfsは端末デバイスを<c>tty</c>と呼び、udevは<c>vc</c>と呼びます。
これは<path>/etc/securetty</path>を使用してコンソールからrootログインを
制限している場合に問題を引き起こします。
rootユーザがコンソールを使用してログインできるようにするために、
<path>/etc/securetty</path>において<c>tty1</c>が<c>vc/1</c>に変更されているこ
とをよく確かめる必要があります。
</p> 

</body>
</section>
<section>
<title>その他の問題</title>
<body>

<p>
デバイスノードが、<path>/etc/modules.autoload.d/kernel-2.6</path>からモジュールが自動でロードされるときには作成されず、modprobeで手動でモジュールをロードしたときには作成されるなら、<c>sys-apps/baselayout-1.8.12</c>かそれ以降のバージョンに更新してみるべきです。
</p>

<p>
フレームバッファデバイス(<path>/dev/fb/*</path>)のためのサポートは、2.6.6-rc2のバージョンからカーネルに備わっています。
</p>

<p>
2.6.4より古いカーネルに対しては、<path>/dev/pts</path>ファイルシステムのサポートを明示的に含めなければなりません。
</p>

<pre caption="/dev/ptsファイルシステムの有効化">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>資料と謝辞</title>
<section>
<body>

<p>
Greg Kroah-Hartman(IBM社)による、Linuxシンポジウム(カナダ、オンタリオ州、オタワ - 2003年)でのudev議論は、udevアプリケーションに関して確実な理解を広めました。
</p>

<p>
<uri link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">Decibel's 
UDEV Primer(訳注: decibelsのUDEV手引書)</uri><uri link="http://www.gentoo.gr.jp/transdocs/decibelshelp/LinuxHelp_UDEVPrimer.html">(日本語訳)</uri>は、udevとGentooについての詳細な文書です。
</p>

<p>
Gentoo開発者仲間のDaniel Drakeによる<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules(訳注: udevルールの書き方)</uri><uri link="http://www.gentoo.gr.jp/transdocs/udevrules/udevrules.html">(日本語訳)</uri>は、udevの設定をカスタマイズする方法を学ぶためのすばらしい文書です。
</p>

</body>
</section>
</chapter>

</guide>
