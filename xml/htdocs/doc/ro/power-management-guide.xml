<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/power-management-guide.xml,v 1.2 2005/09/14 04:50:22 alin Exp $ -->
<guide link="power-management-guide.xml" lang="ro">
<title>Ghid pentru Gestionarea Consumului de Energie</title>

<author title="Author">
  <mail link="fragfred@gmx.de">Dennis Nienhüser</mail>
</author>
<author title="Translator">
  <mail link="robert.datcu@gentoo.ro">Robert Datcu</mail>
</author>

<abstract>
Gestionarea consumului de energie este cheia pentru prelungirea timpului de
funcţionare al acumulatorului pe sistemele mobile cum sunt laptop-urile. Acest
ghid vă ajută la configurarea portabilului dvs.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->
<license/>

<version>1.24</version>
<date>2005-06-10</date>

<chapter>
<title>Introducere</title>
<section>
<title>De ce Gestionarea Consumului de Energie?</title>
<body>

<p>
Capacitatea şi durata de viaţă a acumulatorilor portabilelor s-a
îmbunătăţit mult în ultimii ani. La fel de adevărat, procesoarele
moderne consumă mult mai multă energie decât cele vechi şi fiecare
generaţie de laptop-uri introduce mai multe dispozitive mari consumatoare de
energie. De aceea Gestionarea Consumului de Energie este mai importantă ca
niciodată. Creşterea duratei de folosire a acumulatorului nu înseamnă
neapărat cumpărarea altuia. Multe pot fi obţinute prin utilizarea
inteligentelor metode referitoare la gestionarea consumului de energie. 
</p>

</body>
</section>

<section>
<title>O trecere în revistă</title>
<body>

<p>
Luaţi aminte că acest ghid descrie Gestionarea Consumului de Energie pentru
<e>portabile</e>. În timp ce unele secţiuni s-ar putea potrivi şi pentru
<e>server-e</e>, altele nu, şi chiar pot provoca distrugeri sistemului dvs.
Nu aplicaţi nimic din acest ghid pe un server, doar dacă ştiţi cu
adevărat ce faceţi. 
</p>

<p>
Pentru că acest ghid a devenit destul de lung, iată o scurtă trecere în
revistă care să vă ajute să-l parcurgeţi mai uşor.
</p>

<p>
Capitolul <e>Condiţii esenţiale</e> cuprinde cerinţe ce trebuie îndeplinite
înainte ca oricare informaţii din secţiunile următoare, referitoare la
dispozitive să fie aplicate. Acestea includ setări în BIOS, configurarea
kernel-ului şi unele lămuriri în partea aplicaţii utilizator.
Următoarele trei capitole se referă la dispozitive care în mod obişnuit
consumă cel mai mult din energie - procesorul, monitorul şi hard-disc-ul.
Fiecare poate fi configurat separat. <e>Gestionarea Consumului de Energie al
Procesorului</e> descrie cum să ajustaţi frecvenţa procesorului pentru a
salva maximum de energie fără a afecta prea mult performanţa. Câteva
diferite metode previn hard-disc-ul dvs. să funcţioneze atunci când nu este
cazul în <e>Gestionarea Consumului de Energie pentru disc</e> (reducerea
nivelului de zgomot ca un interesant efect secundar). Câteva cuvinte
referitoare la reţelele LAN şi USB încheie secţiunea referitoare la
dispozitive hardware în <e>Gestionarea consumului de energie pentru alte
dispozitive</e> în timp ce un alt capitol este dedicat (deşi experimental)
pentru <e>stările sleep</e>. Şi nu în ultimul rând <e>Rezolvare
Probleme</e> arată problemele comune.
</p>

</body>
</section>

<section>
<title>Consumul de energie pentru fiecare componentă</title>
<body>

<figure link="/images/energy-budget.png" short="ce componentă consumă aşa
multă energie?" caption="Consumul de energie pentru fiecare componentă"/>

<p>
Aproape fiecare componentă poate funcţiona în diferite stări - oprit,
adormit, pasiv, activ pentru a numi câteva - consumând o diferită cantitate
de energie. Mare parte este consumată de ecranele LCD, procesor, chipset şi
discuri. Deseori o componentă este capabilă de a activa Gestionarea
Consumului de Energie în BIOS, independent de sistemul de operare, dar o
configurare inteligentă în sistemul de operare adaptată unor situaţii
diferite poate aduce mult mai mult.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Condiţii esenţiale</title>
<section>
<title>Ce trebuie făcut în primul rând</title>
<body>

<p>
Înainte de a intra în detalii în pregătirea dispozitivelor individuale
pentru Gestionarea Consumului de Energie, asiguraţi-vă că sunt
îndeplinite cerinţele obligatorii. După controlul parametrilor în BIOS,
unele opţiuni din kernel trebuie activate + acestea sunt pe scurt ACPI,
"stările de adormire" şi scalarea (baleierea) frecvenţei procesorului.
Întrucât economisirea de energie de cele mai multe ori este însoţită de
pierderi de performanţă ori latenţă crescută, opţiunile ar trebui
activate în momentul funcţionării pe acumulatori. Chiar acolo intervine un
nou nivel de rulare, <e>acumulator</e>.
</p>

</body>
</section>
<section>
<title>Partea legată de BIOS</title>
<body>

<p>
Pentru început aruncaţi o privire în setările dvs. referitoare la
Gestionarea Consumului de Energie în BIOS. Cea mai bună cale este combinarea
metodelor referitoare la BIOS şi sistemul de operare, dar pentru moment este
mai bine să dezactivăm mare parte din opţiunile specifice din BIOS.
Aceasta ne asigură că nu va interfera cu metodele proprii dvs. Nu uitaţi
să reverificaţi setările BIOS după ce aţi configurat restul.
</p>

</body>
</section>
<section>
<title>Configurarea kernel-ului</title>
<body>

<p>
Munca la suportul ACPI (Configurare Avansată şi Interfaţă Energie) în
kernel este În progres. Folosind un kernel recent ne vom asigura că veţi
obţine maximum din acesta.
</p>

<p>
În configurarea kernel-ului, activaţi cel puţin aceste opţiuni:
</p>

<pre caption="Setări minime ale kernel-ului pentru Gestionarea Consumului de Energie (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend
  [ ] Suspend-to-Disk Support

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    [ ]   Debug Statements
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Decideţi dvs. dacă doriţi să activaţi Software Suspend, Suspend-to-Disk
şi Sleep States (vedeţi mai jos). Dacă deţineţi un portabil ASUS, Medion
sau Toshiba, activaţi în dreptul secţiunii corespunzătoare.
</p>

<p>
Kernel-ul trebuie să ştie cum să activeze scalarea frecvenţei
procesorului dvs. Aşa cum fiecare model de procesor are o interfaţa
diferită, trebuie să alegeţi driver-ul corespunzător pentru procesorul
dvs. Fiţi foarte atenţi aici - activând <e>Intel Pentium 4 clock
modulation</e> pe un sistem cu procesor mobile Pentium M, acesta va conduce la
rezultate ciudate, de exemplu. Citiţi documentaţia kernel-ului dacă nu
ştiţi ce opţiuni să alegeţi. 
</p>

<p>
Compilaţi kernel-ul, asiguraţi-vă că modulele corecte vor fi încărcate
la pornire şi boot-aţi cu noul dvs. kernel, cu capabilităţi ACPI. Apoi
rulaţi <c>emerge sys-power/acpid</c> pentru a obţine daemon-ul acpi. Acesta
vă informează în legătură cu evenimente cum sunt comutarea de pe
curent alternativ (priză) pe acumulator sau închiderea capacului
portabilului. Asiguraţi-vă că modulele sunt încărcate pentru pornire,
asta dacă nu au fost compilate în kernel şi porniţi acpid prin comanda
<c>/etc/init.d/acpid start</c>. Rulaţi linia <c>rc-update add acpid
default</c> pentru a încărca daemon-ul la pornire. Veţi vedea curând cum
se foloseşte.
</p>

<pre caption="Instalarea acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Crearea unui nivel de rulare "acumulator"</title>
<body>

<p>
Politica implicită va fi activarea Gestionării Consumului de Energie doar
când este necesară - când folosim acumulatori. Pentru a comuta uşor
între curent alternativ (priză) şi acumulator, creaţi un nivel de rulare
<e>acumulator</e> care să conţină toate script-urile ce pornesc şi
opresc Gestionarea Consumului de Energie.
</p>

<note>
Puteţi omite fără probleme această secţiune, dacă nu agreaţi idea
de a avea un alt nivel de rulare. Totuşi, omiterea acestui pas va face
configurarea în continuare un pic mai complicată. Următoarele secţiuni
presupun că există un nivel de rulare <e>acumulator</e>.
</note>

<pre caption="Crearea nivelului de rulare acumulator">
# <i>cd /etc/runlevels</i>
# <i>cp -a default acumulator</i>
</pre>

<p>
Gata. Noul dvs. nivel de rulare <e>acumulator</e> conţine totul ca
<e>default</e> (nivelul implicit), dar încă nu există o comutare
automată între cele două încă. Este vremea să schimbăm acest lucru.
</p>

</body>
</section>
<section>
<title>Reacţionarea la evenimente ACPI</title>
<body>

<p>
Evenimentele tipice ACPI sunt închiderea carcasei, schimbarea sursei de curent
sau apăsarea butonului 'sleep'. Un eveniment important este schimbarea sursei
de curent, care ar trebui să determine o schimbare a nivelului de rulare.
Creaţi următoarele fişiere pentru a comuta între nivelul <e>default</e>
şi <e>acumulator</e> în funcţie de sursa de putere:
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># ÎNCEPUT configuraţie</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="acumulator"
<comment># SFÂRŞIT configuraţie</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># înlocuiţi "ac_adapter" mai jos cu evenimentul generat de portabilul dvs.</comment>
<comment># Citiţi /var/log/acpid</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># înlocuiţi "acumulator" mai jos cu evenimentul generat de portabilul dvs.</comment>
<comment># Citiţi /var/log/acpid</comment>
event=acumulator.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
În plus, aveţi nevoie de pachetul sys-power/powermgmt-base ce conţine
utilitarul <c>on_ac_power</c>. Fişierul <path>pmg_switch_runlevel.sh</path>
trebuie să fie executabil.  
</p>

<pre caption="Terminarea comutării nivelului de rulare folosind acpid">
<i># emerge powermgmt-base</i>
<i># chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh</i>
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Încercaţi: conectaţi alimentarea la priză şi urmăriţi log-ul de
sistem generat de syslog la mesajele "Switching to AC mode" sau "Switching to
battery mode". Citiţi secţiunea Rezolvare Probleme atunci când script-ul nu
reuşeşte să determine corect sursa de curent.
</p>

<p>
Datorită naturii mecanismului evenimentelor, portabilul dvs. va porni în
nivelul de rulare <e>default</e> indiferent de situaţia AC/acumulator. Puteţi
adăuga încă o intrare în boot-loader cu <c>softlevel=acumulator</c>, dar
e mai bine să uitaţi folosirea acesteia. O cale mai bună este 'inventarea'
unui fals eveniment ACPI la sfârşitul procesului de boot-are şi să
lăsaţi script-ul <path>/etc/acpi/default.sh</path> să decidă
oportunitatea schimbării de nivel de rulare. Deschideţi
<path>/etc/conf.d/local.start</path> cu editorul dvs. favorit şi adăugaţi
aceste linii:
</p>

<pre caption="Schimbarea nivelului de rulare la pornire, prin editarea local.start">
<comment># Eveniment fals acpi pentru schimbarea nivelului de rulare când se foloseşte acumulatorul</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "acumulator/acumulator"
</pre>

<p>
Astfel pregătite puteţi activa metode de Gestionarea Consumului de Energie
pentru dispozitive individuale.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea Consumului de Energie pentru Procesor</title>
<section>
<title>Câţiva termeni tehnici</title>
<body>

<p>
Scalarea frecvenţei procesorului aduce în lumină câţiva termeni tehnici
care pot fi necunoscuţi dvs. Iată o scurtă introducere.
</p>

<p>
Înainte de toate, kernel-ul trebuie înzestrat cu posibilitatea schimbării
frecvenţei procesorului. <e>Driver-ul CPUfreq</e> ştie ce comenzi să
ruleze legate de procesorul dvs. De aceea este important să-l alegem pe cel
potrivit în kernel. Ar trebui să fi făcut deja asta. Odată ce kernel-ul
ştie cum să schimbe frecvenţele, trebuie să ştie şi ce frecvenţă
să seteze. Aceasta se face pe baza <e>politicii</e> care constă în
<e>politica CPUfreq</e> şi <e>decident</e>. Politica CPUfreq înseamnă doar
două numere care definesc plaja de valori în care poate varia frecvenţa -
valoarea minimă şi valoarea maximă. Decidentul alege o frecvenţă
disponibilă din plaja de valori menţionată pentru a fi folosită. De
exemplu, <e>decidentul economisire energie</e> alege întotdeauna cea mai
mică frecvenţă disponibilă, iar <e>decidentul performanţă</e> alege
cea mai mare frecvenţă disponibilă. <e>Decidentul userspace</e> nu ia nici
o decizie dar alege când utilizatorul (sau un program rulat de utilizator)
doreşte - adică citeşte frecvenţa din
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Încă nu prea sună a schimbare dinamică a frecvenţei şi de fapt nu
prea este. Dinamica, totuşi, poate fi obţinută prin diferite abordări.
De exemplu, <e>decidentul ondemand</e> ia deciziile în funcţie de gradul de
ocupare al procesorului. Acelaşi lucru este făcut de diverse programe
utilitare ca <c>cpudyn</c>, <c>cpufreqd</c>, <c>powernowd</c> şi multe
altele. Evenimentele ACPI pot fi folosite pentru a activa sau dezactiva
schimbarea dinamică a frecvenţei în funcţie de sursa de curent.
</p>

</body>
</section>
<section>
<title>Stabilirea manuală a frecvenţei</title>
<body>

<p>
Reducerea vitezei şi tensiunii procesorului are două avantaje: Pe de-o
parte mai puţină energie consumată, pe de altă parte apare un
îmbunătăţire din punct de vedere termic pentru că sistemul dvs. nu se
încălzeşte ca în cazul rulării la viteza maximă. Principalul
dezavantaj este desigur pierderea de performanţă. Reducerea vitezei
procesorului este un compromis între pierderea de performanţă şi
economisirea de energie.
</p>

<note>
Nu toate portabilele suportă scalarea frecvenţei. Dacă nu sunteţi siguri,
aruncaţi o privire pe lista procesoarelor suportate, în secţiunea
<e>Rezolvare Probleme</e> pentru a verifica dacă procesorul dvs. este
suportat.
</note>

<p>
Este timpul să verificăm dacă schimbarea frecvenţei procesorului
funcţionează. Să instalăm un alt program, care este de foarte ajutor în
scopuri de analiză/depanare: <c>sys-power/cpufrequtils</c>
</p>

<pre caption="Verificarea frecvenţei procesorului">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Iată un exemplu de rezultat:
</p>

<pre caption="Rezultat exemplu al cpufreq-info">
cpufrequtils 0.2: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz (asserted by call to hardware).
</pre>

<p>
Acum jucaţi-vă cu <c>cpufreq-set</c> pentru a vă asigura că schimbarea
frecvenţei funcţionează. Rulaţi de exemplu <c>cpufreq-set -g ondemand</c>
pentru activarea decidentului ondemand şi verificaţi schimbarea cu
<c>cpufreq-info</c>. Dacă nu funcţionează aşa cum este de aşteptat,
puteţi găsi ajutor în secţiunea Rezolvare Probleme la sfârşitul acestui
ghid.
</p>

</body>
</section>
<section>
<title>Adaptarea automată a frecvenţei</title>
<body>

<p>
Cele precizate mai sus sună destul de frumos, dar greu de realizat în viaţa
de zi cu zi. Există mai multe abordări diferite pentru a face acest lucru.
Următorul tabel oferă o scurtă descriere pentru a vă ajuta în a alege
una din ele. Este bine separat în trei categorii, <e>kernel</e> pentru
abordări ce doar au nevoie de suport kernel, <e>daemon</e> pentru programe
care rulează în fundal şi <e>graphical</e> pentru programe care oferă o
interfaţă grafică pentru uşoară configurare şi schimbări. 
</p>

<table>
<tr>
  <th>Nume</th>
  <th>Categorie</th>
  <th>Decizia comutării</th>
  <th>Decidenţi kernel</th>
  <th>Decidenţi suplimentari</th>
  <th>Comentarii</th>
</tr>
<tr>
  <ti>decident 'ondemand'</ti>
  <ti>Kernel</ti>
  <ti>Încărcare procesor</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Optimizarea în plus a fişierelor în
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Totuşi
    necesită utilitare (programe, script-uri) dacă se schimbă decidentul
    sau este dorit acelaşi.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Performanţă, economisire energie</ti>
  <ti>Dinamic</ti>
  <ti>
    Suportă de asemenea starea standby pentru disc - luaţi aminte totuşi
    că <e>laptop mode</e> în multe cazuri va face o treabă mai bună.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Daemon</ti>
  <ti>Nivel acumulator, ocupare procesor, programe care rulează</ti>
  <ti>Toate disponibile</ti>
  <ti>Nici unul</ti>
  <ti>
    Configurare Sofisticată (dar şi complicată)
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Nici unul</ti>
  <ti>Pasiv, slab, agresiv</ti>
  <ti>Suportă SMP</ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Nici unul</ti>
  <ti>Dinamic, economie energie, performanţă, viteză fixă</ti>
  <ti>
    Mică dar totuşi o interfaţă folositoare client/server. Necesită un
    kernel 2.6. Programul nu mai pare menţinut şi va fi scos din arborele
    Portage în viitorul apropiat.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Grafic</ti>
  <ti>Nici unul</ti>
  <ti>Nici unul</ti>
  <ti>Nici unul</ti>
  <ti>
    Aplicaţie Gnome, o unealtă grafică pentru a stabili manual frecvenţa
    procesorului. Nu oferă automatizare în vreun fel.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Grafic</ti>
  <ti>Nivel acumulator</ti>
  <ti>Toate disponibile</ti>
  <ti>Nici unul</ti>
  <ti>
    Doar pentru KDE, decidentul 'ondemand' cerut pentru scalarea dinamică a
    frecvenţei.
  </ti>
</tr>
</table>

<p>
În timp ce ajustarea frecvenţei la nivelul curent al ocupării pare
simplă la prima vedere, nu este o sarcină aşa de uşoară. Un algoritm
nefericit poate cauza comutarea între două frecvenţe permanent sau irosirea
energiei când este aleasă frecvenţa la un nivel înalt, care nu este
necesar.
</p>

<p>
Pe care să îl aleg? Dacă nu aveţi nici o idee, încercaţi
<c>cpufreqd</c>:
</p>

<pre caption="Instalarea cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> poate fi configurat prin editarea
<path>/etc/cpufreqd.conf</path>. Fişierul de configurare implicit poate
părea un pic confuz. Recomand înlocuirea acestuia cu unul al dezvoltatorului
Gentoo Henrik Brix Andersen (vedeţi mai jos).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=ondemand

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=performance
</pre>

<p>
Nu puteţi folosi o valoare procentuală ca mai sus pentru min_freq şi
max_freq dacă folosiţi un kernel 2.6 cu interfaţă sysfs (şi probabil
folosiţi). Înlocuiţi-le cu cea mai mică şi cea mai mare frecvenţă,
aşa cum este raportată de <c>cpufreq-info --hwlimits</c>. De exemplu, în
cazul procesorului meu Pentium M 1.4 GHz introduc 
</p>

<pre caption="Valori exemplu pentru minfreq şi maxfreq">
minfreq=600000
maxfreq=1400000
</pre>

<p>
La sfârşit, dar nu în cele din urmă, porniţi daemon-ul.
</p>

<pre caption="Pornirea cpufreqd">
# <i>rc-update add cpufreqd default acumulator</i>
# <i>rc</i>
</pre>

<warn>
Nu rulaţi concomitent mai mult de unul din programele de mai sus. Poate
conduce la confuzii cum sunt comutarea permanentă între două frecvenţe.
</warn>

</body>
</section>

<section>
<title>Verificarea rezultatului</title>

<body>

<p>
Ultimul lucru ce trebuie verificat este dacă noile dvs. metode sunt
eficiente. O simplă cale este monitorizarea frecvenţei procesorului în timp
ce lucraţi cu portabilul dvs.:
</p>

<pre caption="Monitorizarea vitezei procesorului">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Dacă <path>/proc/cpuinfo</path> nu se actualizează (consultaţi Rezolvare
Probleme), monitorizaţi frecvenţa procesorului cu:
</p>

<pre caption="Monitorizare alternativă a vitezei procesorului">
# <i>watch x86info -mhz</i>
</pre>

<p>
În funcţie de configurările dvs., viteza procesorului ar trebui să
crească la solicitare mare, să scadă în cazul lipsei de activităţi
sau să rămână la acelaşi nivel. Când folosiţi cpufreq şi verbosity
setat la 5 sau mai mult în <path>cpufreqd.conf</path> primiţi informaţii
suplimentare despre ceea ce este raportat către syslog.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea consumului de energie pentru panouri LCD</title>
<section>
<title>Consumatorul de energie nr.1</title>
<body>

<p>
Aşa cum puteţi vedea în <uri link="#doc_chap1_fig1">figura 1.1</uri>,
panourile LCD consumă cea mai mare parte a energiei (este posibil să nu fie
cazul pentru procesoare ne-mobile). De aceea este destul de important nu doar
să opriţi panoul când nu este necesar, dar de asemenea pentru reducerea
luminozităţii, dacă este posibil. Multe portabile oferă posibilitatea
controlului luminozităţii.
</p>

<p>
Primul lucru ce trebuie verificat sunt timpii standby/suspend/off ai panoului.
Întrucât depinde foarte mult de managerul de ferestre folosit, vă las să
va daţi seama pe dvs. Doar două observaţii utile: dezactivarea terminalului
poate fi făcută cu <c>setterm -blank &lt;număr-de-minuteM&gt;</c>,
<c>setterm -powersave on</c> şi <c>setterm -powerdown
&lt;număr-de-minuteM&gt;</c>. Pentru Xorg, modificaţi
<path>/etc/X11/xorg.conf</path> asemănător cu ce urmează:
</p>

<pre caption="Configurarea opţiunii suspend pentru panouri LCD în Xorg şi XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Blank the screen after 5 minutes (Fake)
			# Dezactivarea ecranului după 5 minutes (Fake)
			</comment>
  Option  "StandbyTime"  "10"  <comment># Turn off screen after 10 minutes (DPMS)
			# Oprirea ecranului după 10 minute (DPMS)
			</comment>
  Option  "SuspendTime"  "20"  <comment># Full suspend after 20 minutes
			# Suspend complet după 20 minute
			</comment>
  Option  "OffTime"  "30"  <comment># Turn off after half an hour
			# Oprire după o jumătate de oră
			</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Aceleaşi configurări pentru XFree86 şi <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probabil, cea mai importantă este luminozitatea. Dacă aveţi acces la
parametrii luminozităţii prin intermediul unui program, scrieţi un mic
script ce reduce luminozitatea în modul acumulator şi salvaţi-l în nivelul
dvs. de rulare <e>acumulator</e>. Următorul script ar trebui să
funcţioneze pe cele mai multe modele IBM Thinkpad. Necesită pachetul
<c>app-laptop/ibm-acpi</c> sau opţiunea corespunzătoare din kernel
activată.
</p>

<warn>
Suportul privind setarea luminozităţii este încă experimental în
ibm-acpi. Accesează hardware-ul direct şi poate cauza deteriorări grave
în sistemul dvs. Consultaţi <uri
link="http://ibm-acpi.sourceforge.net/">site-ul web ibm-acpi</uri>
</warn>

<p>
Pentru a fi capabil în a seta nivelul de luminozitate, modulul ibm_acpi
trebuie încărcat cu un parametru experimental.
</p>

<pre caption="încărcarea automată a modulului ibm_acpi">
<comment>(Citiţi avertismentele de mai sus înainte de a proceda!)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
Această metodă ar trebui să funcţioneze fără mesaje de eroare şi
un fişier <path>/proc/acpi/ibm/brightness</path> ar trebui creat după
încărcarea modulului. Un script de iniţializare se va ocupa de alegerea
nivelului de luminozitate, corespunzător cu sursa de energie.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Consultaţi /proc/acpi/ibm/brightness pentru valorile disponibile</comment>
<comment># Consultaţi /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># nivelul luminozităţii în modul curent AC (priză). Implicit este 7.</comment>
BRIGHTNESS_AC=7

<comment># nivelul luminozităţii în mod acumulator. Implicit este 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "Check that ibm_acpi is loaded into the kernel"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Când aţi terminat, asiguraţi-vă că luminozitatea este modificată
automat, prin adăugarea script-ului la nivelul de rulare acumulator.
</p>

<pre caption="Activarea modificării automate a luminozităţii">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Gestiunea Consumului de Energie pentru Hard-Disk</title>
<section>
<title>"Sleep" la inactivitate</title>
<body>

<p>
Să aducem hard-disc-ul pe "sleep" cât mai devreme posibil ori de câte ori
nu este folosit. Vă voi arăta două posibilităţi pentru a face acest
lucru. În prima, <c>cpudyn</c> suportă Gestiunea Consumului de Energie
pentru Hard-Disc. Decomentaţi liniile din secţiunea "Opţiuni Disc" în
<path>/etc/conf.d/cpudyn</path>. Pentru a seta primul disc în modul sleep
după 60 de secunde de neactivitate, ar trebui să modificaţi după cum
urmează:
</p>

<pre caption="Folosirea cpudyn pentru punerea pe 'aşteptare' a hard-disk-ului">
<comment>################################################
# OPŢIUNI DISC
# (dezactivate implicit)
################################################

#
# Timpul necesar punerii pe 'aşteptare' a hard-disk-ului dacă nu a fost
# nici un acces io în timpul acestei perioade (în secunde)
#
</comment>
TIMEOUT=60
<comment>
#
# Specificarea discului ce va fi oprit (pentru mai multe dispozitive, 
# separare prin virgulă)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
A doua posibilitate constă în folosirea unui mic script şi a hdparm.
Creaţi astfel <path>/etc/init.d/pm.hda</path>:
</p>

<pre caption="Folosirea hdparm pentru punerea pe 'aşteptare' a hard-disk-ului">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Citiţi <c>man hdparm</c> pentru opţiuni. Dacă script-ul dvs. este gata,
adăugaţi-l la nivelul de rulare acumulator.
</p>

<pre caption="Setări pentru punerea automată pe 'aşteptare' a hard-disk-ului">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Aveţi grijă cu setările 'sleep/spin' ale hard-disk-ului dvs. Stabilirea
unor valori prea mici accelerează uzura discului şi puteţi pierde
garanţia.
</impo>

</body>
</section>
<section>
<title>Creşterea timpului de inactivitate - modul laptop</title>
<body>

<p>
Versiunile recente de kernel (2.6.6 şi ulterioare, cele 2.4 mai recente şi
altele modificate) includ aşa-numitul <e>laptop-mode</e>. Când este activat,
zonele de memorie ocupate sunt scrise pe disc atunci când sunt apeluri la
citire sau după 10 minute (în loc de 30 secunde). Astfel se minimizează
timpul cât hard-disc-ul trebuie să fie accesat.
</p>

<pre caption="Pornire automată în modul portabil">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> are fişierul propriu de configurare în
<path>/etc/laptop-mode/laptop-mode.conf</path>. Modificaţi-l cum doriţi,
fiind şi bine documentat. Rulaţi <c>rc-update add laptop_mode acumulator</c>
pentru a-l porni automat.
</p>

</body>
</section>
<section>
<title>Alte trucuri</title>
<body>

<p>
Pe lângă punerea discului dvs. pe starea sleep cât mai devreme posibil,
este o bună idee să minimizaţi accesul la disc. Uitaţi-vă la procesele
ce scriu frecvent pe discul dvs. - daemon-ul syslog este un bun exemplu.
Probabil că nu doriţi să-l opriţi complet, dar este posibil să
modificaţi fişierul config astfel încât evenimentele care nu sunt necesare
să nu fie monitorizate şi astfel să nu creaţi trafic către disc. Cups
scrie pe disc periodic, deci luaţi în considerare oprirea lui completă şi
activarea manuală doar când este nevoie.
</p>

<pre caption="Dezactivarea cups în modul acumulator">
# <i>rc-update del cupsd acumulator</i>
</pre>

<p>
O altă posibilitate este dezactivarea swap-ului în mod acumulator. Înainte
de a scrie un script de comutare swapon/swapoff, asiguraţi-vă că aveţi
destulă memorie RAM şi swap-ul nu este utilizat foarte mult, altfel veţi
întâmpina mari probleme.
</p>

<p>
Dacă nu doriţi să folosiţi modul portabil, este încă posibil să
minimizaţi accesul la disc prin montarea unor anumite directoare ca
<e>tmpfs</e> - accesările la scriere nu sunt stocate pe un hard-disc, ci în
memoria principală, şi sunt pierdute în cazul demontării. Adesea este
folositor să montaţi aşa <path>/tmp</path> - nu trebuie să acordaţi o
atenţie specială, atâta timp cât este ştearsă la fiecare repornire,
indiferent dacă a fost montat pe disc sau pe RAM. Doar asiguraţi-vă că
aveţi destul RAM şi nici un program (ca un client descărcare sau
arhivator) nu necesită un spaţiu mare în <path>/tmp</path>. Pentru a-l
activa, kernel-ul trebuie să aibă activ suportul tmpfs şi adăugaţi o
linie în <path>/etc/fstab</path>, astfel:
</p>

<pre caption="Editarea /etc/fstab pentru a face /tmp şi mai volatil">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Acordaţi atenţie mărimii parametrului şi modificaţi-l pentru sistemul
dvs. Dacă nu sunteţi siguri, nu încercaţi deloc, pentru că poate deveni
uşor o gâtuire a performanţei. Dacă doriţi să montaţi astfel
<path>/var/log</path>, asiguraţi-vă că salvaţi fişierele log pe disk
înainte de demontare. Acestea sunt esenţiale. Nu încercaţi să montaţi
astfel /var/tmp/. Portage îl foloseşte pentru compilare...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea Consumului de Energie pentru alte dispozitive</title>
<section>
<title>Gestionarea Consumului de Energie pentru Dispozitivele Wireless</title>
<body>

<p>
Plăcile de reţea wireless consumă ceva energie. Gestionaţi consumul de
energie al acestora în analogie cu script-ul pm.hda.
</p>

<pre caption="Gestionarea automată a consumului de energie pentru dispozitive wireless">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Pornirea acestui script va pune wlan0 în modul Gestionare Consum Energie,
intrând în starea sleep după trei secunde după lipsa traficului.
Salvaţi-l ca <path>/etc/init.d/pm.wlan0</path> şi adăugaţi-l la nivelul
de rulare acumulator, asemănător script-ului disc de mai sus. Consultaţi
<c>man iwconfig</c> pentru detalii şi mai multe opţiuni. Dacă driver-ul
şi dispozitivul acces point suportă schimbarea timpului de semnalizare,
acesta e un bun punct de pornire pentru a salva chiar şi mai multă energie.
</p>

<pre caption="Gestionarea Consumului de Energie pentru reţele wireless">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>Gestionarea Consumului de Energie pentru USB</title>
<body>

<p>
Sunt două probleme cu dispozitivele USB referitor la consumul de energie:
Prima, dispozitive ca mauşii USB, camerele digitale sau dispozitive stocare
USB consumă energie cât timp sunt conectate. Nu puteţi evita acest lucru
(totuşi deconectarea lor trebuie făcută dacă nu sunt necesare). A doua,
când sunt dispozitive USB conectate, controller-ul gazdă USB accesează
periodic magistrala, care de fapt previne procesorul să intre într-un mod
C3/4 sleep. Sistemul de operare răspunde prin aşa numitul "USB selective
suspend", care încă nu a fost implementat în kernel. "USB selective
suspend" permite accesarea magistralei doar în cazul în care este folosit
dispozitivul. Modalitatea dificilă de folosire până la implementare este
următoare: Compilaţi suportul USB şi dispozitivele ca module şi
descărcaţi-le printr-un script cât timp nu sunt folosite (de ex. când
închideţi capacul).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Stările Sleep: sleep, standby, suspend to disk</title>
<section>
<title>Generalităţi</title>
<body>

<p>
ACPI defineşte stări sleep diferite. Cele mai importante sunt
</p>

<ul> 
  <li>S1 sau Standby</li>
  <li>S3 sau Suspend to RAM sau Sleep</li>
  <li>S4 sau Suspend to Disk sau Hibernate</li>
</ul>

<p>
Acestea pot fi apelate oricând sistemul nu este folosit, iar opţiunea
shutdown nu este dorită datorită unui timp mare de pornire.
</p>

</body>
</section>
<section>
<title>Sleep, Standby şi Hibernate</title>
<body>

<p>
Suportul ACPI pentru aceste stări sleep este considerat experimental din
motive îndreptăţite. Stările sleep APM par a fi mai stabile, totuşi, nu
puteţi folosi APM şi ACPI împreună.
</p>

<warn>
Deşi suportul pentru starea sleep se îmbunătăţeşte mult, este încă
experimental. Într-un sfârşit am reuşit să fac să funcţioneze
swsusp2 şi suspend to RAM, dar vă atenţionez: Cel mai probabil nu va
funcţiona şi va deteriora datele/sistemul dvs.
</warn>

<p>
Există în acest moment trei implementări pentru S4. Cea originală este
swsusp, apoi există swsusp2, care are cea mai frumoasă interfaţă
(incluzând suport bootsplash), dar care necesită un patch aplicat manual
kernel-ului. În cele din urmă dar nu ultima avem Suspend-to-Disk, o
modificare a swsusp.
</p>

<p>
Dacă v-am dezorientat, aruncaţi o privire asupra <uri
link="http://softwaresuspend.berlios.de/features.html#compare">comparaţiei
caracteristicilor</uri>. Dacă încă sunteţi dezorientaţi şi nu ştiţi
pe care să o alegeţi, încercaţi pentru început swsusp2, pentru că
arată cel mai promiţător. 
</p>

<p>
Partea legată de kernel pentru acesta este după cum urmează:
</p>

<pre caption="Configurarea kernel-ului pentru diversele tipuri suspend">
Power Management Options ---&gt;

  <comment>(sleep şi standby)</comment>
  ACPI( Advanced Configuration and Power Interface ) Support --->
    [*] ACPI Support
       [*]   Sleep States

  <comment>(hibernate cu swsusp)</comment>
  [*] Software Suspend (EXPERIMENTAL)
  
  <comment>(hibernate cu swsusp2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]    Swap Writer
    --- Page Transformers
    [*]    LZF image compression
    (/dev/"swap-ul-dvs")    Default resume device name

  <comment>(hibernate cu Suspend-to-Disk)</comment>
  [*] Suspend-to-Disk Suport
  (/dev/"swap-ul-dvs") Default resume partition
</pre>

<p>
Compilaţi-vă kernel-ul cu opţiunile corespunzătoare activate şi
urmăriţi rezultatul comenzii <c>cat /proc/acpi/sleep</c> pentru seria 2.4
respectiv <c>cat /sys/power/state</c> pentru seria 2.6 pentru a vedea ce este
suportat. Ultima comandă îmi arată <c>standby mem disk</c>. Pentru swsusp,
trebuie adăugat parametrul kernel <c>resume=/dev/"swap-ul-dvs"</c>. Dacă
pornirea sistemului nu este posibilă datorită unei imagini deteriorate,
folosiţi <c>noresume</c> pentru swsup, <c>pmdisk=off</c> pentru
Suspend-to-Disk şi <c>noresume2</c> pentru swsusp2.
</p>

<p>
Pentru a pune sistemul dvs. în una din stările sleep, folosiţi
</p>

<pre caption="Activarea stărilor sleep">
<comment>(kernel seria 2.4)</comment>
# <i>echo 1 &gt; /proc/acpi/sleep</i>          <comment>(standby)</comment>
# <i>echo 3 &gt; /proc/acpi/sleep</i>          <comment>(sleep)</comment>

<comment>(kernel seria 2.6)</comment>
# <i>echo -n standby &gt; /sys/power/state</i> <comment>(standby)</comment>
# <i>echo -n mem &gt; /sys/power/state</i>     <comment>(sleep)</comment>

<comment>(swsusp)</comment>
# <i>echo 4 &gt; /proc/acpi/sleep</i>          <comment>(hibernate)</comment>

<comment>(Suspend-to-Disk)</comment>
# <i>echo -n disk &gt; /sys/power/state</i>    <comment>(hibernate)</comment>

<comment>(swsusp2)</comment>
# <i>/usr/sbin/hibernate</i>                <comment>(hibernate, vedeţi mai jos)</comment>
</pre>

<warn>
Salvaţi-vă datele înainte de a face asta. Rulaţi <c>sync</c> înainte de
executarea uneia din comenzi pentru a avea datele din memorie scrise pe disc.
Încercaţi prima dată în afara server-ului X, apoi când rulează
server-ul X, dar neautentificat.
</warn>

<p>
Dacă apar mesaje kernel panic datorită uhci sau similar, încercaţi să
compilaţi suportul USB ca modul şi descărcaţi modulele înainte de a
trimite laptop-ul în modul sleep.
</p>

<p>
În timp ce metoda de mai sus ar trebui să fie suficientă pentru a
beneficia de rularea swsusp şi Suspend-to-Disk (nu am spus funcţionarea),
swsusp2 necesită o abordare specială. Primul lucru pe care trebuie să-l
faceţi este să aplicaţi patch-uri kernel-ului cu cele oferite la <uri
link="http://softwaresuspend.berlios.de/">http://softwaresuspend.berlios.de/</uri>.
În plus, trebuie să instalaţi <c>hibernate-script</c>. Odată instalat,
configuraţi <path>/etc/hibernate/hibernate.conf</path> şi încercaţi dacă
funcţionează:
</p>

<pre caption="Configurarea modului hibernation">
<i># emerge hibernate-script</i>
<i># $EDITOR /etc/hibernate/hibernate.conf</i>
<comment>(Ultima şansă de a vă salva orice informaţie)</comment>
<i># hibernate</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Rezolvare probleme</title>
<section>
<title>Dacă lucrurile nu merg bine...</title>
<body>

<p>
<e>Î:</e> Încerc să schimb frecvenţa procesorului, dar
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> nu există.
</p>

<p>
<e>R:</e> Asiguraţi-vă că procesorul dvs. suportă scalarea frecvenţei
şi aţi ales driver-ul CPUFreq corect pentru procesorul dvs. Aici este o
listă a procesoarelor suportate de cpufreq (kernel 2.6.7): ARM Integrator,
ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile
K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix
Media GXm, Intel mobile PIII şi Intel mobile PIII-M pe anumite chipset-uri,
Intel Pentium 4, Intel Xeon, Intel Pentium M (Centrino), National
Semiconductors Geode GX, Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III,
SuperH SH-3, SH-4, mai multe "PowerBook" şi "iBook2" şi diverse procesoare
pe unele sisteme compatibile ACPI 2.0 (doar dacă opţiunea "ACPI Processor
Performance States" este disponibilă în interfaţa ACPI/BIOS).
</p>

<p>
<e>Î:</e> Laptop-ul meu suportă scalarea frecvenţei, dar
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> este gol.
</p>

<p>
<e>R:</e> Uitaţi-vă după mesaje de eroare legate de ACPI cu <c>dmesg |
grep ACPI</c>. Încercaţi o actualizare a BIOS-ului, în special dacă este
raportată deteriorarea DSDT. Puteţi încerca de asemenea să-l reparaţi
dvs. (ceea ce este dincolo de scopul acestui ghid).
</p>

<p>
<e>Î:</e> Laptop-ul meu suportă scalarea frecvenţei, dar /proc/cpuinfo
raportează că viteza nu se schimbă niciodată.
</p>

<p>
<e>R:</e> Probabil aveţi activat în kernel suportul SMP, multiprocesare
simetrică (CONFIG_SMP). Dezactivaţi-l şi ar trebui să funcţioneze.
Unele kernel-uri mai vechi conţin o problemă ce îl cauzează. În acest
caz, rulaţi <c>emerge x86info</c>, actualizaţi-vă kernel-ul şi
verificaţi frecvenţa cu <c>x86info -mhz</c>.
</p>

<p>
<e>Î:</e> Pot schimba frecvenţa procesorului, dar intervalul nu este aşa
de larg ca în cazul altor sisteme de operare.
</p>

<p>
<e>R:</e> Puteţi combina scalarea frecvenţei cu supraîncărcarea ACPI
pentru a obţine o frecvenţă minimă mai mică. Luaţi aminte că
supraîncărcarea nu salvează multă energie şi este folosită în
principal pentru gestionarea temperaturii (păstrarea rece şi silenţioasă
a laptop-ului dvs.) Puteţi citi stadiul curent al supraîncărcării cu
<c>cat /proc/acpi/processor/CPU/throttling</c> şi să îl schimbaţi cu
<c>echo -n "0:x" > /proc/acpi/processor/CPU/limit</c>, unde x este una din
stările Tx afişate de <path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>R:</e> Când configuraţi kernel-ul, salvarea de energie, performanţa şi
decidenţii pentru programele utilizatorului apar, dar opţiunea ondemand
lipseşte. De unde o iau?
</p>

<p>
<e>R:</e> Decidentul ondemand este inclus doar în sursele recente de kernel.
Încercaţi actualizarea acestora.
</p>

<p>
<e>Î:</e> Durata de folosire a acumulatorului pare mai mică decât
înainte.
</p>

<p>
<e>R:</e> Verificaţi configurările din BIOS. Poate că aţi uitat să
reactivaţi unele opţiuni.
</p>

<p>
<e>Î:</e> Acumulatorul meu este încărcat, dar KDE raportează că ar mai
rămâne 0% şi imediat se opreşte.
</p>

<p>
<e>R:</e> Verificaţi dacă battery support este compilat în kernel-ul dvs.
Dacă îl folosiţi ca modul, asiguraţi-vă că este încărcat.
</p>

<p>
<e>Î:</e> Deţin un Dell Inspiron 51XX şi nu îmi apare nici un eveniment
ACPI.
</p>

<p>
<e>R:</e> Pare o problemă în kernel. Citiţi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">aici</uri>.
</p>

<p>
<e>Î:</e> Doar ce am cumpărat un nou acumulator, dar ţine doar câteva
minute! Ce fac greşit?
</p>

<p>
<e>R:</e> În primul rând respectaţi sfatul producătorului referitor la
modul de încărcare corect al acumulatorului.
</p>

<p>
<e>R:</e> Răspunsul de mai sus nu a ajutat. Ce ar trebui să fac atunci?
</p>

<p>
<e>R:</e> Unii acumulatori vânduţi ca "noi" sunt de fapt vechi. Încercaţi
următoarele:
</p>

<pre caption="Aflarea nivelului acumulatorului">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Dacă "last full capacity" diferă semnificativ de capacitatea proiectată,
atunci acumulatorul dvs. este probabil deteriorat. Încercaţi să
beneficiaţi de garanţie.
</p>

<p>
<e>Î:</e> Problema mea nu este arătată mai sus. Ce ar trebui să fac în
continuare?
</p>

<p>
<e>R:</e> Nu vă temeţi să mă contactaţi direct, <mail
link="fragfred@gmx.de">Dennis Nienhüser</mail>.
</p>

</body>
</section>
</chapter>
</guide>
