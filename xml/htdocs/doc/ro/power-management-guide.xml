<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/power-management-guide.xml,v 1.5 2005/10/31 20:48:32 alin Exp $ -->
<guide link="/doc/ro/power-management-guide.xml" lang="ro">
<title>Ghid pentru Gestionarea Consumului de Energie</title>

<author title="Autor">
  <mail link="fragfred@gmx.de">Dennis Nienhüser</mail>
</author>
<author title="Translator">
  <mail link="robert.datcu@gentoo.ro">Robert Datcu</mail>
</author>

<abstract>
Gestionarea consumului de energie este cheia pentru prelungirea timpului de
funcţionare al acumulatorului pe sistemele mobile cum sunt laptop-urile. Acest
ghid vă ajută la configurarea portabilului dvs.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.25</version>
<date>2005-10-02</date>

<chapter>
<title>Introducere</title>
<section>
<title>De ce Gestionarea Consumului de Energie?</title>
<body>

<p>
Capacitatea şi durata de viaţă a acumulatorilor portabilelor s-a
îmbunătăţit mult în ultimii ani. La fel de adevărat, procesoarele
moderne consumă mult mai multă energie decât cele vechi şi fiecare
generaţie de laptop-uri introduce mai multe dispozitive mari consumatoare de
energie. De aceea Gestionarea Consumului de Energie este mai importantă ca
niciodată. Creşterea duratei de folosire a acumulatorului nu înseamnă
neapărat cumpărarea altuia. Multe pot fi obţinute prin utilizarea
inteligentelor metode referitoare la gestionarea consumului de energie.
</p>

</body>
</section>

<section>
<title>O trecere în revistă</title>
<body>

<p>
Luaţi aminte că acest ghid descrie Gestionarea Consumului de Energie pentru
<e>portabile</e>. În timp ce unele secţiuni s-ar putea potrivi şi pentru
<e>server-e</e>, altele nu, şi chiar pot provoca distrugeri sistemului dvs.
Nu aplicaţi nimic din acest ghid pe un server, doar dacă ştiţi cu
adevărat ce faceţi.
</p>

<p>
Pentru că acest ghid a devenit destul de lung, iată o scurtă trecere în
revistă care să vă ajute să-l parcurgeţi mai uşor.
</p>

<p>
Capitolul <e>Condiţii esenţiale</e> cuprinde cerinţe ce trebuie îndeplinite
înainte ca oricare informaţii din secţiunile următoare, referitoare la
dispozitive să fie aplicate. Acestea includ setări în BIOS, configurarea
kernel-ului şi unele lămuriri în partea aplicaţii utilizator.
Următoarele trei capitole se referă la dispozitive care în mod obişnuit
consumă cel mai mult din energie - procesorul, monitorul şi hard-disc-ul.
Fiecare poate fi configurat separat. <e>Gestionarea Consumului de Energie al
Procesorului</e> descrie cum să ajustaţi frecvenţa procesorului pentru a
salva maximum de energie fără a afecta prea mult performanţa. Câteva
diferite metode previn hard-disc-ul dvs. să funcţioneze atunci când nu este
cazul în <e>Gestionarea Consumului de Energie pentru disc</e> (reducerea
nivelului de zgomot ca un interesant efect secundar). Câteva cuvinte
referitoare la reţelele LAN şi USB încheie secţiunea referitoare la
dispozitive hardware în <e>Gestionarea consumului de energie pentru alte
dispozitive</e> în timp ce un alt capitol este dedicat (deşi experimental)
pentru <e>stările sleep</e>. Şi nu în ultimul rând <e>Rezolvare
Probleme</e> arată problemele comune.
</p>

</body>
</section>

<section>
<title>Consumul de energie pentru fiecare componentă</title>
<body>

<figure link="/images/energy-budget.png" short="ce componentă consumă aşa
multă energie?" caption="Consumul de energie pentru fiecare componentă"/>

<p>
Aproape fiecare componentă poate funcţiona în diferite stări - oprit,
adormit, pasiv, activ pentru a numi câteva - consumând o diferită cantitate
de energie. Mare parte este consumată de ecranele LCD, procesor, chipset şi
discuri. Deseori o componentă este capabilă de a activa Gestionarea
Consumului de Energie în BIOS, independent de sistemul de operare, dar o
configurare inteligentă în sistemul de operare adaptată unor situaţii
diferite poate aduce mult mai mult.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Condiţii esenţiale</title>
<section>
<title>Ce trebuie făcut în primul rând</title>
<body>

<p>
Înainte de a intra în detalii în pregătirea dispozitivelor individuale
pentru Gestionarea Consumului de Energie, asiguraţi-vă că sunt
îndeplinite cerinţele obligatorii. După controlul parametrilor în BIOS,
unele opţiuni din kernel trebuie activate + acestea sunt pe scurt ACPI,
"stările de adormire" şi scalarea (baleierea) frecvenţei procesorului.
Întrucât economisirea de energie de cele mai multe ori este însoţită de
pierderi de performanţă ori latenţă crescută, opţiunile ar trebui
activate în momentul funcţionării pe acumulatori. Chiar acolo intervine un
nou nivel de rulare, <e>acumulator</e>.
</p>

</body>
</section>
<section>
<title>Partea legată de BIOS</title>
<body>

<p>
Pentru început aruncaţi o privire în setările dvs. referitoare la
Gestionarea Consumului de Energie în BIOS. Cea mai bună cale este combinarea
metodelor referitoare la BIOS şi sistemul de operare, dar pentru moment este
mai bine să dezactivăm mare parte din opţiunile specifice din BIOS.
Aceasta ne asigură că nu va interfera cu metodele proprii dvs. Nu uitaţi
să reverificaţi setările BIOS după ce aţi configurat restul.
</p>

</body>
</section>
<section>
<title>Configurarea kernel-ului</title>
<body>

<p>
Munca la suportul ACPI (Configurare Avansată şi Interfaţă Energie) în
kernel este În progres. Folosind un kernel recent ne vom asigura că veţi
obţine maximum din acesta.
</p>

<p>
Există diverse surse de kernel în Portage. Aş recomanda utilizarea
<c>gentoo-sources</c> sau <c>suspend2-sources</c>. Cel din urmă conţine
patch-uri pentru Software Suspend 2, pentru detalii consultaţi capitolul
despre stările sleep, pentru mai multe detalii. În configurarea
kernel-ului, activaţi cel puţin aceste opţiuni:
</p>

<pre caption="Setări minime ale kernel-ului pentru Gestionarea Consumului de Energie (Kernel 2.6)">
Power Management Options ---&gt;
  [*] Power Management Support
  [ ] Software Suspend

  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;
    [*] ACPI Support
    [ ]   Sleep States
    [ ]     /proc/acpi/sleep (deprecated)
    [*]   AC Adapter
    [*]   Battery
    &lt;M&gt;   Button
    &lt;M&gt;   Video
    [ ]   Generic Hotkey
    &lt;M&gt;   Fan
    &lt;M&gt;   Processor
    &lt;M&gt;     Thermal Zone
    &lt; &gt;   ASUS/Medion Laptop Extras
    &lt; &gt;   IBM ThinkPad Laptop Extras
    &lt; &gt;   Toshiba Laptop Extras
    (0)   Disable ACPI for systems before Jan 1st this year
    [ ]   Debug Statements
    [*]   Power Management Timer Support
    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)
    
  CPU Frequency Scaling ---&gt;
    [*] CPU Frequency scaling
    [ ]   Enable CPUfreq debugging
    &lt; &gt;   CPU frequency translation statistics
    [ ]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)
    &lt;*&gt;   'performance' governor
    &lt;*&gt;   'powersave' governor
    &lt;*&gt;   'ondemand' cpufreq policy governor
    &lt;*&gt;   'conservative' cpufreq governor
    &lt;*&gt;   CPU frequency table helpers
    &lt;M&gt; ACPI Processor P-States driver
    &lt;*&gt; <i>CPUFreq driver for your processor</i>
</pre>

<p>
Decideţi dvs. dacă doriţi să activaţi Software Suspend şi Sleep States
(vedeţi mai jos). Dacă deţineţi un portabil ASUS, Medion sau Toshiba,
activaţi în dreptul secţiunii corespunzătoare.
</p>

<p>
Kernel-ul trebuie să ştie cum să activeze scalarea frecvenţei
procesorului dvs. Aşa cum fiecare model de procesor are o interfaţa
diferită, trebuie să alegeţi driver-ul corespunzător pentru procesorul
dvs. Fiţi foarte atenţi aici - activând <e>Intel Pentium 4 clock
modulation</e> pe un sistem cu procesor mobile Pentium M, acesta va conduce la
rezultate ciudate, de exemplu. Citiţi documentaţia kernel-ului dacă nu
ştiţi ce opţiuni să alegeţi. 
</p>

<p>
Compilaţi kernel-ul, asiguraţi-vă că modulele corecte vor fi încărcate
la pornire şi boot-aţi cu noul dvs. kernel, cu capabilităţi ACPI. Apoi
rulaţi <c>emerge sys-power/acpid</c> pentru a obţine daemon-ul acpi. Acesta
vă informează în legătură cu evenimente cum sunt comutarea de pe
curent alternativ (priză) pe acumulator sau închiderea capacului
portabilului. Asiguraţi-vă că modulele sunt încărcate pentru pornire,
asta dacă nu au fost compilate în kernel şi porniţi acpid prin comanda
<c>/etc/init.d/acpid start</c>. Rulaţi linia <c>rc-update add acpid
default</c> pentru a încărca daemon-ul la pornire. Veţi vedea curând cum
se foloseşte.
</p>

<pre caption="Instalarea acpid">
# <i>emerge sys-power/acpid</i>
# <i>/etc/init.d/acpid start</i>
# <i>rc-update add acpid default</i>
</pre>

</body>
</section>
<section>
<title>Crearea unui nivel de rulare "acumulator"</title>
<body>

<p>
Politica implicită va fi activarea Gestionării Consumului de Energie doar
când este necesară - când folosim acumulatori. Pentru a comuta uşor
între curent alternativ (priză) şi acumulator, creaţi un nivel de rulare
<e>acumulator</e> care să conţină toate script-urile ce pornesc şi
opresc Gestionarea Consumului de Energie.
</p>

<note>
Puteţi omite fără probleme această secţiune, dacă nu agreaţi idea
de a avea un alt nivel de rulare. Totuşi, omiterea acestui pas va face
configurarea în continuare un pic mai complicată. Următoarele secţiuni
presupun că există un nivel de rulare <e>acumulator</e>.
</note>

<pre caption="Crearea nivelului de rulare acumulator">
# <i>cd /etc/runlevels</i>
# <i>cp -a default acumulator</i>
</pre>

<p>
Gata. Noul dvs. nivel de rulare <e>acumulator</e> conţine totul ca
<e>default</e> (nivelul implicit), dar încă nu există o comutare
automată între cele două încă. Este vremea să schimbăm acest lucru.
</p>

</body>
</section>
<section>
<title>Reacţionarea la evenimente ACPI</title>
<body>

<p>
Evenimentele tipice ACPI sunt închiderea carcasei, schimbarea sursei de curent
sau apăsarea butonului 'sleep'. Un eveniment important este schimbarea sursei
de curent, care ar trebui să determine o schimbare a nivelului de rulare.
Un mic script va avea grijă de acest lucru.
</p>

<p>
Mai întâi vă trebuie un script ce modifică nivelul de execuţie în
<c>default</c>, respectiv <c>acumulator</c>, în funcţie de sursa de putere.
Acest script utilizează comanda <c>on_ac_power</c> din pachetul
<c>sys-power/powermgmt-base</c> - asiguraţi-vă că acest script este
instalat în sistemul dvs.
</p>

<pre caption="Instalarea powermgt-base">
<i># emerge powermgmt-base</i>
</pre>

<p>
Acum puteţi să determinaţi sursa de putere prin execuţia <c>on_ac_power
&amp;&amp; echo Curent alternativ || echo Ruleaza pe baterii</c> într-o
sesiune de shell. Script-ul de mai jos este responsabil cu modificarea
nivelelor de execuţie. Salvaţi-l ca
<path>/etc/acpi/actions/pmg_switch_runlevel.sh</path>.
</p>

<pre caption="/etc/acpi/actions/pmg_switch_runlevel.sh">
#!/bin/bash

<comment># ÎNCEPUT configuraţie</comment>
RUNLEVEL_AC="default"
RUNLEVEL_BATTERY="acumulator"
<comment># SFÂRŞIT configuraţie</comment>


if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."
        exit 1
fi

if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]
then
        logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."
        exit 1
fi

if on_ac_power
then
    if [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]
  then
            logger "Switching to ${RUNLEVEL_AC} runlevel"
            /sbin/rc ${RUNLEVEL_AC}
        fi
elif [[ "$(cat /var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]
then
        logger "Switching to ${RUNLEVEL_BATTERY} runlevel"
        /sbin/rc ${RUNLEVEL_BATTERY}
fi
</pre>

<p>
Nu uitaţi să rulaţi <c>chmod +x
/etc/acpi/actions/pmg_switch_runlevel.sh</c> pentru a face script-ul
executabil. Ultimul lucru ce trebuie efectuat este să executăm script-ul
ori de câte ori sursa de putere se modifică. Aceasta poate fi efectuată
prin analizarea tuturor evenimentelor ACPI cu ajutorul <c>acpid</c>. Mai
întâi trebuie să ştiţi ce evenimente sunt generate în momentul în care
sursa de putere se modifică. Evenimentele sunt denumite <e>ac_adapter</e>
şi <e>battery</e> pe majoritatea sistemelor laptop, dar este posibil să fie
diferit pentru sistemul dvs.
</p>

<pre caption="Determinarea evenimentelor ACPI pentru modificarea sursei de putere">
<i># tail -f /var/log/acpid | grep "received event"</i>
</pre>

<p>
Rulaţi comanda de mai sus şi scoateţi cablul de putere. Ar trebui să
observaţi ceva de genul:
</p>

<pre caption="Exemplu de jurnal pentru comutarea sursei de putere">
[Tue Sep 20 17:39:06 2005] received event "ac_adapter AC 00000080 00000000"
[Tue Sep 20 17:39:06 2005] received event "battery BAT0 00000080 00000001"
</pre>

<p>
Partea interesantă este şirul de caractere între ghilimele afişat după
<e>received event</e>. Va fi extras de liniile de evenimente din fişierele pe
care urmează să le creaţi mai jos. Nu vă faceţi griji dacă sistemul
dvs. generează mai multe evenimente sau aceleaşi de mai multe ori. Atât
timp cât orice eveniment este generat, comutarea nivelelor de execuţie va
funcţiona.
</p>

<pre caption="/etc/acpi/events/pmg_ac_adapter">
<comment># înlocuiţi "ac_adapter" mai jos cu evenimentul generat de portabilul dvs.</comment>
<comment># Spre exemplu, ac_adapter.* va extrage ac_adapter AC 00000080 00000000</comment>
event=ac_adapter.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<pre caption="/etc/acpi/events/pmg_battery">
<comment># înlocuiţi "acumulator" mai jos cu evenimentul generat de portabilul dvs.</comment>
<comment># Spre exemplu, battery.* va extrage battery BAT0 00000080 00000001</comment>
event=acumulator.*
action=/etc/acpi/actions/pmg_switch_runlevel.sh %e
</pre>

<p>
La final, aplicaţia acpid trebuie reponită pentru a recunoaşte
modificările.
</p>

<pre caption="Terminarea comutării nivelului de rulare folosind acpid">
<i># /etc/init.d/acpid restart</i>
</pre>

<p>
Încercaţi: conectaţi alimentarea la priză şi urmăriţi log-ul de
sistem generat de syslog la mesajele "Switching to AC mode" sau "Switching to
battery mode". Citiţi secţiunea Rezolvare Probleme atunci când script-ul nu
reuşeşte să determine corect sursa de curent.
</p>

<p>
Datorită naturii mecanismului evenimentelor, portabilul dvs. va porni în
nivelul de rulare <e>default</e> indiferent de situaţia AC/acumulator. Acest
lucru este unul bun dacă rulaţi cu alimetare la priză, însă am dori
să rulăm în nivelul de iniţializare acumulator, în alte situaţii. O
soluţie ar fi să adăugaţi o altă intrare în aplicaţia boot-loader cu
parametrul <c>softlevel=acumulator</c>, dar e mai bine să uitaţi folosirea
acesteia. O cale mai bună este 'inventarea' unui fals eveniment ACPI la
sfârşitul procesului de boot-are şi să lăsaţi script-ul
<path>pmg_switch_runlevel.sh</path> să decidă oportunitatea schimbării de
nivel de rulare. Deschideţi <path>/etc/conf.d/local.start</path> cu editorul
dvs. favorit şi adăugaţi aceste linii:
</p>

<pre caption="Ajustarea nivelului de rulare la pornire, prin editarea local.start">
<comment># Eveniment fals acpi pentru schimbarea nivelului de rulare când se foloseşte acumulatorul</comment>
/etc/acpi/actions/pmg_switch_runlevel.sh "acumulator/acumulator"
</pre>

<p>
Astfel pregătite puteţi activa metode de Gestionarea Consumului de Energie
pentru dispozitive individuale.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea Consumului de Energie pentru Procesor</title>
<section>
<title>Câţiva termeni tehnici</title>
<body>

<p>
Scalarea frecvenţei procesorului aduce în lumină câţiva termeni tehnici
care pot fi necunoscuţi dvs. Iată o scurtă introducere.
</p>

<p>
Înainte de toate, kernel-ul trebuie înzestrat cu posibilitatea schimbării
frecvenţei procesorului. <e>Driver-ul CPUfreq</e> ştie ce comenzi să
ruleze legate de procesorul dvs. De aceea este important să-l alegem pe cel
potrivit în kernel. Ar trebui să fi făcut deja asta. Odată ce kernel-ul
ştie cum să schimbe frecvenţele, trebuie să ştie şi ce frecvenţă
să seteze. Aceasta se face pe baza <e>politicii</e> care constă în
<e>politica CPUfreq</e> şi <e>decident</e>. Politica CPUfreq înseamnă doar
două numere care definesc plaja de valori în care poate varia frecvenţa -
valoarea minimă şi valoarea maximă. Decidentul alege o frecvenţă
disponibilă din plaja de valori menţionată pentru a fi folosită. De
exemplu, <e>decidentul economisire energie</e> alege întotdeauna cea mai
mică frecvenţă disponibilă, iar <e>decidentul performanţă</e> alege
cea mai mare frecvenţă disponibilă. <e>Decidentul userspace</e> nu ia nici
o decizie dar alege când utilizatorul (sau un program rulat de utilizator)
doreşte - adică citeşte frecvenţa din
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</path>.
</p>

<p>
Încă nu prea sună a schimbare dinamică a frecvenţei şi de fapt nu
prea este. Dinamica, totuşi, poate fi obţinută prin diferite abordări.
De exemplu, <e>decidentul ondemand</e> ia deciziile în funcţie de gradul de
ocupare al procesorului. Acelaşi lucru este făcut de diverse programe
utilitare ca <c>cpudyn</c>, <c>cpufreqd</c>, <c>powernowd</c> şi multe
altele. Evenimentele ACPI pot fi folosite pentru a activa sau dezactiva
schimbarea dinamică a frecvenţei în funcţie de sursa de curent.
</p>

</body>
</section>
<section>
<title>Stabilirea manuală a frecvenţei</title>
<body>

<p>
Reducerea vitezei şi tensiunii procesorului are două avantaje: Pe de-o
parte mai puţină energie consumată, pe de altă parte apare un
îmbunătăţire din punct de vedere termic pentru că sistemul dvs. nu se
încălzeşte ca în cazul rulării la viteza maximă. Principalul
dezavantaj este desigur pierderea de performanţă. Reducerea vitezei
procesorului este un compromis între pierderea de performanţă şi
economisirea de energie.
</p>

<note>
Nu toate portabilele suportă scalarea frecvenţei. Dacă nu sunteţi siguri,
aruncaţi o privire pe lista procesoarelor suportate, în secţiunea
<e>Rezolvare Probleme</e> pentru a verifica dacă procesorul dvs. este
suportat.
</note>

<p>
Este timpul să verificăm dacă schimbarea frecvenţei procesorului
funcţionează. Să instalăm un alt program, care este de foarte ajutor în
scopuri de analiză/depanare: <c>sys-power/cpufrequtils</c>
</p>

<pre caption="Verificarea frecvenţei procesorului">
# <i>emerge cpufrequtils</i>
# <i>cpufreq-info</i>
</pre>

<p>
Iată un exemplu de rezultat:
</p>

<pre caption="Rezultat exemplu al cpufreq-info">
cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004
Report errors and bugs to linux@brodo.de, please.
analyzing CPU 0:
  driver: centrino
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 600 MHz - 1.40 GHz
  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz
  available cpufreq governors: conservative, ondemand, powersave, userspace, performance
  current policy: frequency should be within 924 MHz and 1.40 GHz.
    The governor "performance" may decide which speed to use
    within this range.
  current CPU frequency is 1.40 GHz.
</pre>

<p>
Acum jucaţi-vă cu <c>cpufreq-set</c> pentru a vă asigura că schimbarea
frecvenţei funcţionează. Rulaţi de exemplu <c>cpufreq-set -g ondemand</c>
pentru activarea decidentului ondemand şi verificaţi schimbarea cu
<c>cpufreq-info</c>. Dacă nu funcţionează aşa cum este de aşteptat,
puteţi găsi ajutor în secţiunea Rezolvare Probleme la sfârşitul acestui
ghid.
</p>

</body>
</section>
<section>
<title>Adaptarea automată a frecvenţei</title>
<body>

<p>
Cele precizate mai sus sună destul de frumos, dar greu de realizat în viaţa
de zi cu zi. Există mai multe abordări diferite pentru a face acest lucru.
Următorul tabel oferă o scurtă descriere pentru a vă ajuta în a alege
una din ele. Este bine separat în trei categorii, <e>kernel</e> pentru
abordări ce doar au nevoie de suport kernel, <e>daemon</e> pentru programe
care rulează în fundal şi <e>graphical</e> pentru programe care oferă o
interfaţă grafică pentru uşoară configurare şi schimbări. 
</p>

<table>
<tr>
  <th>Nume</th>
  <th>Categorie</th>
  <th>Decizia comutării</th>
  <th>Decidenţi kernel</th>
  <th>Decidenţi suplimentari</th>
  <th>Comentarii</th>
</tr>
<tr>
  <ti>decident 'ondemand'</ti>
  <ti>Kernel</ti>
  <ti>Încărcare procesor</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Alege frecvenţa maximă în cazul încărcării procesorului şi
    încetineşte câte puţin când procesorul nu are activitate. Optimizarea
    în plus a fişierelor în
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Totuşi
    necesită utilitare (programe, script-uri) dacă se schimbă decidentul
    sau este dorit acelaşi.
  </ti>
</tr>
<tr>
  <ti>decident 'conservativ'</ti>
  <ti>Kernel</ti>
  <ti>Încărcare procesor</ti>
  <ti>N.A.</ti>
  <ti>N.A.</ti>
  <ti>
    Spre deosebire de decidentul ondemand, cel conservativ nu sare la
    frecvenţa maximă când încărcarea procesorului este ridicată, ci
    măreşte frecvenţa pas cu pas. Optimizarea în plus a fişierelor în
    <path>/sys/devices/system/cpu/cpu0/cpufreq/ondemand/</path>. Totuşi,
    necesită utilitare în spaţiul utilizator (programe şi script-uri) în
    cazul în care comutarea decidentului sau unele acţiuni similare este
    necesară.
  </ti>
</tr>
<tr>
  <ti><uri link="http://mnm.uib.es/~gallir/cpudyn/">cpudyn</uri></ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Performanţă, economisire energie</ti>
  <ti>Dinamic</ti>
  <ti>
    Suportă de asemenea starea standby pentru disc - luaţi aminte totuşi
    că <e>laptop mode</e> în multe cazuri va face o treabă mai bună.
  </ti>
</tr>
<tr>
  <ti><uri link="http://sourceforge.net/projects/cpufreqd/">cpufreqd</uri></ti>
  <ti>Daemon</ti>
  <ti>Nivel acumulator, ocupare procesor, temperatură, programe care rulează</ti>
  <ti>Toate disponibile</ti>
  <ti>Nici unul</ti>
  <ti>
    Configurare Sofisticată (dar şi complicată)
  </ti>
</tr>
<tr>
  <ti>
    <uri link="http://www.deater.net/john/powernowd.html">powernowd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Nici unul</ti>
  <ti>Pasiv, slab, agresiv</ti>
  <ti>Suportă SMP</ti>
</tr>
<tr>
  <ti>
    <uri link="http://fatcat.ftj.agh.edu.pl/~nelchael/index.php?cat=projs&amp;subcat=ncpufreqd&amp;language=en">ncpufreqd</uri>
  </ti>
  <ti>Daemon</ti>
  <ti>Temperatură</ti>
  <ti>Nici unul</ti>
  <ti>Economisire energie, perfomanţă</ti>
  <ti>
    Comută decidentul utilizat între perfomanţă şi economisire de
    energie, depinzând de temperatura sistemului. Foarte folositor pe sisteme
    laptop cu probleme serioase de temperatură.
  </ti>
</tr>
<tr>
  <ti><uri link="http://www.goop.org/~jeremy/speedfreq/">speedfreq</uri></ti>
  <ti>Daemon</ti>
  <ti>Încărcare procesor</ti>
  <ti>Nici unul</ti>
  <ti>Dinamic, economie energie, performanţă, viteză fixă</ti>
  <ti>
    Uşor configurabil, cu o interfaţă drăguţă client/server.
    Necesită un kernel 2.6. Programul nu mai este menţinut şi va fi scos
    din arborele Portage în viitorul apropiat. Comutaţi la cpufreqd dacă
    încă îl folosiţi.
  </ti>
</tr>
<tr>
  <ti><uri link="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</uri></ti>
  <ti>Grafic</ti>
  <ti>Nici unul</ti>
  <ti>Nici unul</ti>
  <ti>Nici unul</ti>
  <ti>
    Aplicaţie Gnome, o unealtă grafică pentru a stabili manual frecvenţa
    procesorului. Nu oferă automatizare în vreun fel.
  </ti>
</tr>
<tr>
  <ti>klaptopdaemon</ti>
  <ti>Grafic</ti>
  <ti>Nivel acumulator</ti>
  <ti>Toate disponibile</ti>
  <ti>Nici unul</ti>
  <ti>
    Doar pentru KDE, decidentul 'ondemand' cerut pentru scalarea dinamică a
    frecvenţei.
  </ti>
</tr>
</table>

<p>
În timp ce ajustarea frecvenţei la nivelul curent al ocupării pare
simplă la prima vedere, nu este o sarcină aşa de uşoară. Un algoritm
nefericit poate cauza comutarea între două frecvenţe permanent sau irosirea
energiei când este aleasă frecvenţa la un nivel înalt, care nu este
necesar.
</p>

<p>
Pe care să îl aleg? Dacă nu aveţi nici o idee, încercaţi
<c>cpufreqd</c>:
</p>

<pre caption="Instalarea cpufreqd">
# <i>emerge cpufreqd</i>
</pre>

<p>
<c>cpufreqd</c> poate fi configurat prin editarea
<path>/etc/cpufreqd.conf</path>. Fişierul de configurare implicit poate
părea un pic confuz. Recomand înlocuirea acestuia cu unul al dezvoltatorului
Gentoo Henrik Brix Andersen (vedeţi mai jos).
</p>

<pre caption="/etc/cpufreqd.conf">
[General]
pidfile=/var/run/cpufreqd.pid
poll_interval=2
pm_type=acpi
verbosity=5

[Profile]
name=ondemand
minfreq=0%
maxfreq=100%
policy=ondemand

[Profile]
name=conservative
minfreq=0%
maxfreq=100%
policy=conservative

[Profile]
name=powersave
minfreq=0%
maxfreq=100%
policy=powersave

[Profile]
name=performance
minfreq=0%
maxfreq=100%
policy=performance

[Rule]
name=battery
ac=off
profile=conservative

[Rule]
name=battery_low
ac=off
battery_interval=0-10
profile=powersave

[Rule]
name=ac
ac=on
profile=ondemand
</pre>

<p>
Acum, puteţi porni şi aplicaţia daemon cpufreqd. Adăugaţi-l în
nivelurile de rulare <e>default</e> şi <e>acumulator</e>, de asemenea.
</p>

<pre caption="Pornirea cpufreqd">
# <i>rc-update add cpufreqd default acumulator</i>
# <i>rc</i>
</pre>

<warn>
Nu rulaţi concomitent mai mult de unul din programele de mai sus. Poate
conduce la confuzii cum sunt comutarea permanentă între două frecvenţe.
</warn>

</body>
</section>

<section>
<title>Verificarea rezultatului</title>

<body>

<p>
Ultimul lucru ce trebuie verificat este dacă noile dvs. metode sunt
eficiente. O simplă cale este monitorizarea frecvenţei procesorului în timp
ce lucraţi cu portabilul dvs.:
</p>

<pre caption="Monitorizarea vitezei procesorului">
# <i>watch grep \"cpu MHz\" /proc/cpuinfo</i>
</pre>

<p>
Dacă <path>/proc/cpuinfo</path> nu se actualizează (consultaţi Rezolvare
Probleme), monitorizaţi frecvenţa procesorului cu:
</p>

<pre caption="Monitorizare alternativă a vitezei procesorului">
# <i>watch x86info -mhz</i>
</pre>

<p>
În funcţie de configurările dvs., viteza procesorului ar trebui să
crească la solicitare mare, să scadă în cazul lipsei de activităţi
sau să rămână la acelaşi nivel. Când folosiţi cpufreq şi verbosity
setat la 5 sau mai mult în <path>cpufreqd.conf</path> primiţi informaţii
suplimentare despre ceea ce este raportat către syslog.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea consumului de energie pentru panouri LCD</title>
<section>
<title>Consumatorul de energie nr.1</title>
<body>

<p>
Aşa cum puteţi vedea în <uri link="#doc_chap1_fig1">figura 1.1</uri>,
panourile LCD consumă cea mai mare parte a energiei (este posibil să nu fie
cazul pentru procesoare ne-mobile). De aceea este destul de important nu doar
să opriţi panoul când nu este necesar, dar de asemenea pentru reducerea
luminozităţii, dacă este posibil. Multe portabile oferă posibilitatea
controlului luminozităţii.
</p>

<p>
Primul lucru ce trebuie verificat sunt timpii standby/suspend/off ai panoului.
Întrucât depinde foarte mult de managerul de ferestre folosit, vă las să
va daţi seama pe dvs. Doar două observaţii utile: dezactivarea terminalului
poate fi făcută cu <c>setterm -blank &lt;număr-de-minuteM&gt;</c>,
<c>setterm -powersave on</c> şi <c>setterm -powerdown
&lt;număr-de-minuteM&gt;</c>. Pentru Xorg, modificaţi
<path>/etc/X11/xorg.conf</path> asemănător cu ce urmează:
</p>

<pre caption="Configurarea opţiunii suspend pentru panouri LCD în Xorg şi XFree86">
Section "ServerLayout"
  Identifier  [...]
  [...]
  Option  "BlankTime"  "5"  <comment># Blank the screen after 5 minutes (Fake)
			# Dezactivarea ecranului după 5 minutes (Fake)
			</comment>
  Option  "StandbyTime"  "10"  <comment># Turn off screen after 10 minutes (DPMS)
			# Oprirea ecranului după 10 minute (DPMS)
			</comment>
  Option  "SuspendTime"  "20"  <comment># Full suspend after 20 minutes
			# Suspend complet după 20 minute
			</comment>
  Option  "OffTime"  "30"  <comment># Turn off after half an hour
			# Oprire după o jumătate de oră
			</comment>
  [...]
EndSection

[...]

Section "Monitor"
  Identifier  [...]
  Option  "DPMS"  "true"
  [...]
EndSection
</pre>

<p>
Aceleaşi configurări pentru XFree86 şi <path>/etc/X11/XF86Config</path>.
</p>

<p>
Probabil, cea mai importantă este luminozitatea. Dacă aveţi acces la
parametrii luminozităţii prin intermediul unui program, scrieţi un mic
script ce reduce luminozitatea în modul acumulator şi salvaţi-l în nivelul
dvs. de rulare <e>acumulator</e>. Următorul script ar trebui să
funcţioneze pe cele mai multe modele IBM Thinkpad. Necesită pachetul
<c>app-laptop/ibm-acpi</c> sau opţiunea corespunzătoare din kernel
activată.
</p>

<warn>
Suportul privind setarea luminozităţii este încă experimental în
ibm-acpi. Accesează hardware-ul direct şi poate cauza deteriorări grave
în sistemul dvs. Consultaţi <uri
link="http://ibm-acpi.sourceforge.net/">site-ul web ibm-acpi</uri>
</warn>

<p>
Pentru a fi capabil în a seta nivelul de luminozitate, modulul ibm_acpi
trebuie încărcat cu un parametru experimental.
</p>

<pre caption="încărcarea automată a modulului ibm_acpi">
<comment>(Citiţi avertismentele de mai sus înainte de a proceda!)</comment>
<i># emerge ibm-acpi</i>
<i># echo "options ibm_acpi experimental=1" >> /etc/modules.d/ibm_acpi</i>
<i># /sbin/modules-update</i>
<i># echo ibm_acpi >> /etc/modules.autoload.d/kernel-2.6</i>
<i># modprobe ibm_acpi</i>
</pre>

<p>
Această metodă ar trebui să funcţioneze fără mesaje de eroare şi
un fişier <path>/proc/acpi/ibm/brightness</path> ar trebui creat după
încărcarea modulului. Un script de iniţializare se va ocupa de alegerea
nivelului de luminozitate, corespunzător cu sursa de energie.
</p>

<pre caption="/etc/conf.d/lcd-brightness">
<comment># Consultaţi /proc/acpi/ibm/brightness pentru valorile disponibile</comment>
<comment># Consultaţi /usr/share/doc/ibm-acpi-*/README.gz</comment>

<comment># nivelul luminozităţii în modul curent AC (priză). Implicit este 7.</comment>
BRIGHTNESS_AC=7

<comment># nivelul luminozităţii în mod acumulator. Implicit este 4.</comment>
BRIGHTNESS_BATTERY=4
</pre>

<pre caption="/etc/init.d/lcd-brightness">
#!/sbin/runscript

set_brightness() {
    if on_ac_power
    then
        LEVEL=${BRIGHTNESS_AC:-7}
    else
        LEVEL=${BRIGHTNESS_BATTERY:-4}
    fi

    if [ -f /proc/acpi/ibm/brightness ]
    then
        ebegin "Setting LCD brightness"
        echo "level ${LEVEL}" > /proc/acpi/ibm/brightness
        eend $?
    else
        ewarn "Setting LCD brightness is not supported."
        ewarn "Check that ibm_acpi is loaded into the kernel"
    fi
}

start() {
    set_brightness
}

stop () {
    set_brightness
}
</pre>

<p>
Când aţi terminat, asiguraţi-vă că luminozitatea este modificată
automat, prin adăugarea script-ului la nivelul de rulare acumulator.
</p>

<pre caption="Activarea modificării automate a luminozităţii">
<i># chmod +x /etc/init.d/lcd-brightness</i>
<i># rc-update add lcd-brightness battery</i>
<i># rc</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Gestiunea Consumului de Energie pentru Hard-Disk</title>
<section>
<title>"Sleep" la inactivitate</title>
<body>

<p>
Să aducem hard-disc-ul pe "sleep" cât mai devreme posibil ori de câte ori
nu este folosit. Vă voi arăta două posibilităţi pentru a face acest
lucru. În prima, <c>cpudyn</c> suportă Gestiunea Consumului de Energie
pentru Hard-Disc. Decomentaţi liniile din secţiunea "Opţiuni Disc" în
<path>/etc/conf.d/cpudyn</path>. Pentru a seta primul disc în modul sleep
după 60 de secunde de neactivitate, ar trebui să modificaţi după cum
urmează:
</p>

<pre caption="Folosirea cpudyn pentru punerea pe 'aşteptare' a hard-disk-ului">
<comment>################################################
# OPŢIUNI DISC
# (dezactivate implicit)
################################################

#
# Timpul necesar punerii pe 'aşteptare' a hard-disk-ului dacă nu a fost
# nici un acces io în timpul acestei perioade (în secunde)
#
</comment>
TIMEOUT=60
<comment>
#
# Specificarea discului ce va fi oprit (pentru mai multe dispozitive, 
# separare prin virgulă)
#
</comment>
DISKS=/dev/hda
</pre>

<p>
A doua posibilitate constă în folosirea unui mic script şi a hdparm.
Creaţi astfel <path>/etc/init.d/pm.hda</path>:
</p>

<pre caption="Folosirea hdparm pentru punerea pe 'aşteptare' a hard-disk-ului">
#!/sbin/runscript

depend() {
  after hdparm
}

start() {
  ebegin "Activating Power Management for Hard Drives"
  hdparm -q -S12 /dev/hda
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Hard Drives"
  hdparm -q -S253 /dev/hda
  eend $?
}
</pre>

<p>
Citiţi <c>man hdparm</c> pentru opţiuni. Dacă script-ul dvs. este gata,
adăugaţi-l la nivelul de rulare acumulator.
</p>

<pre caption="Setări pentru punerea automată pe 'aşteptare' a hard-disk-ului">
# <i>chmod +x /etc/init.d/pm.hda</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.hda battery</i>
</pre>

<impo>
Aveţi grijă cu setările 'sleep/spin' ale hard-disk-ului dvs. Stabilirea
unor valori prea mici accelerează uzura discului şi puteţi pierde
garanţia.
</impo>

</body>
</section>
<section>
<title>Creşterea timpului de inactivitate - modul laptop</title>
<body>

<p>
Versiunile recente de kernel (2.6.6 şi ulterioare, cele 2.4 mai recente şi
altele modificate) includ aşa-numitul <e>laptop-mode</e>. Când este activat,
zonele de memorie ocupate sunt scrise pe disc atunci când sunt apeluri la
citire sau după 10 minute (în loc de 30 secunde). Astfel se minimizează
timpul cât hard-disc-ul trebuie să fie accesat.
</p>

<pre caption="Pornire automată în modul portabil">
# <i>emerge laptop-mode-tools</i>
</pre>

<p>
<c>laptop-mode-tools</c> are fişierul propriu de configurare în
<path>/etc/laptop-mode/laptop-mode.conf</path>. Modificaţi-l cum doriţi,
fiind şi bine documentat. Rulaţi <c>rc-update add laptop_mode acumulator</c>
pentru a-l porni automat.
</p>

</body>
</section>
<section>
<title>Alte trucuri</title>
<body>

<p>
Pe lângă punerea discului dvs. pe starea sleep cât mai devreme posibil,
este o bună idee să minimizaţi accesul la disc. Uitaţi-vă la procesele
ce scriu frecvent pe discul dvs. - daemon-ul syslog este un bun exemplu.
Probabil că nu doriţi să-l opriţi complet, dar este posibil să
modificaţi fişierul config astfel încât evenimentele care nu sunt necesare
să nu fie monitorizate şi astfel să nu creaţi trafic către disc. Cups
scrie pe disc periodic, deci luaţi în considerare oprirea lui completă şi
activarea manuală doar când este nevoie.
</p>

<pre caption="Dezactivarea cups în modul acumulator">
# <i>rc-update del cupsd acumulator</i>
</pre>

<p>
O altă posibilitate este dezactivarea swap-ului în mod acumulator. Înainte
de a scrie un script de comutare swapon/swapoff, asiguraţi-vă că aveţi
destulă memorie RAM şi swap-ul nu este utilizat foarte mult, altfel veţi
întâmpina mari probleme.
</p>

<p>
Dacă nu doriţi să folosiţi modul portabil, este încă posibil să
minimizaţi accesul la disc prin montarea unor anumite directoare ca
<e>tmpfs</e> - accesările la scriere nu sunt stocate pe un hard-disc, ci în
memoria principală, şi sunt pierdute în cazul demontării. Adesea este
folositor să montaţi aşa <path>/tmp</path> - nu trebuie să acordaţi o
atenţie specială, atâta timp cât este ştearsă la fiecare repornire,
indiferent dacă a fost montat pe disc sau pe RAM. Doar asiguraţi-vă că
aveţi destul RAM şi nici un program (ca un client descărcare sau
arhivator) nu necesită un spaţiu mare în <path>/tmp</path>. Pentru a-l
activa, kernel-ul trebuie să aibă activ suportul tmpfs şi adăugaţi o
linie în <path>/etc/fstab</path>, astfel:
</p>

<pre caption="Editarea /etc/fstab pentru a face /tmp şi mai volatil">
none  /tmp  tmpfs  size=32m  0 0
</pre>

<warn>
Acordaţi atenţie mărimii parametrului şi modificaţi-l pentru sistemul
dvs. Dacă nu sunteţi siguri, nu încercaţi deloc, pentru că poate deveni
uşor o gâtuire a performanţei. Dacă doriţi să montaţi astfel
<path>/var/log</path>, asiguraţi-vă că salvaţi fişierele log pe disk
înainte de demontare. Acestea sunt esenţiale. Nu încercaţi să montaţi
astfel /var/tmp/. Portage îl foloseşte pentru compilare...
</warn>

</body>
</section>
</chapter>

<chapter>
<title>Gestionarea Consumului de Energie pentru alte dispozitive</title>
<section>
<title>Plăci grafice</title>
<body>

<p>
În cazul în care aveţi o placă grafică ATI ce suportă PowerPlay
(scalarea automată a tactului pentru unitatea grafică de procesare GPU),
puteţi activa această facilitate în X.org. Deschideţi
<path>/etc/X11/xorg.conf</path> şi adăugaţi (sau activaţi) opţiunea
<c>DynamicClocks</c> din secţiunea Device. Vă rugăm să obsevaţi faptul
că această facilitate va conduce la apariţia erorilor pe unele sisteme.
</p>

<pre caption="Activarea suportului ATI PowerPlay în X.org">
Section "Device"
[...]
Option      "DynamicClocks" "on"
EndSection
</pre>

</body>
</section>
<section>
<title>Gestionarea Consumului de Energie pentru Dispozitivele Wireless</title>
<body>

<p>
Plăcile de reţea wireless consumă ceva energie. Gestionaţi consumul de
energie al acestora în analogie cu script-ul pm.hda.
</p>

<pre caption="Gestionarea automată a consumului de energie pentru dispozitive wireless">
#!/sbin/runscript
start() {
  ebegin "Activating Power Management for Wireless LAN"
  iwconfig wlan0 power on power max period 3
  eend $?
}

stop () {
  ebegin "Deactivating Power Management for Wireless LAN"
  iwconfig wlan0 power off
  eend $?
}
</pre>

<p>
Pornirea acestui script va pune wlan0 în modul Gestionare Consum Energie,
intrând în starea sleep după trei secunde după lipsa traficului.
Salvaţi-l ca <path>/etc/init.d/pm.wlan0</path> şi adăugaţi-l la nivelul
de rulare acumulator, asemănător script-ului disc de mai sus. Consultaţi
<c>man iwconfig</c> pentru detalii şi mai multe opţiuni. Dacă driver-ul
şi dispozitivul acces point suportă schimbarea timpului de semnalizare,
acesta e un bun punct de pornire pentru a salva chiar şi mai multă energie.
</p>

<pre caption="Gestionarea Consumului de Energie pentru reţele wireless">
# <i>chmod +x /etc/init.d/pm.wlan0</i>
# <i>/sbin/depscan.sh</i>
# <i>rc-update add pm.wlan0 battery</i>
</pre>

</body>
</section>
<section>
<title>Gestionarea Consumului de Energie pentru USB</title>
<body>

<p>
Sunt două probleme cu dispozitivele USB referitor la consumul de energie:
Prima, dispozitive ca mauşii USB, camerele digitale sau dispozitive stocare
USB consumă energie cât timp sunt conectate. Nu puteţi evita acest lucru
(totuşi deconectarea lor trebuie făcută dacă nu sunt necesare). A doua,
când sunt dispozitive USB conectate, controller-ul gazdă USB accesează
periodic magistrala, care de fapt previne procesorul să intre în modul
sleep. Kernel-ul oferă o opţiune experimentală pentru a activa suspendarea
dispozitivelor USB prin apeluri de driver sau unul din fişierele
<path>power/state</path> din <path>/sys</path>.
</p>

<pre caption="Activarea suportului pentru suspendare USB în kernel">
Device Drivers
  USB support
    [*]   Support for Host-side USB
      [*]   USB suspend/resume (EXPERIMENTAL)
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Stările Sleep: sleep, standby, suspend to disk</title>
<section>
<title>Generalităţi</title>
<body>

<p>
ACPI defineşte stări sleep diferite. Cele mai importante sunt
</p>

<ul> 
  <li>S1 sau Standby</li>
  <li>S3 sau Suspend to RAM sau Sleep</li>
  <li>S4 sau Suspend to Disk sau Hibernate</li>
</ul>

<p>
Acestea pot fi apelate oricând sistemul nu este folosit, iar opţiunea
shutdown nu este dorită datorită unui timp mare de pornire.
</p>

</body>
</section>
<section>
<title>Sleep (S3)</title>
<body>

<p>
Suportul ACPI pentru aceste stări sleep este considerat experimental din
motive îndreptăţite. Stările sleep APM par a fi mai stabile, totuşi, nu
puteţi folosi APM şi ACPI împreună.
</p>

<pre caption="Configurarea kernel-ului pentru diferite tipuri de stări suspend">
  Power Management Options ---&gt;
    [*]  Power Management support
      ACPI (Advanced Configuration and Power Interface) Support ---&gt;
        [*]  ACPI Support
          [*]   Sleep States
</pre>

<p>
Odată ce kernel-ul este pregătit ca mai sus, puteţi utiliza
<c>hibernate-script</c> pentru a activa suspendarea sau modul sleep. Să-l
instalăm, mai întâi.
</p>

<pre caption="Instalarea hibernate-script">
<i># emerge hibernate-script</i>
</pre>

<p>
Trebuie efectuată configurarea în <path>/etc/hibernate</path>. Pachetul
implicit introduce două fişiere de configurare <path>hibernate.conf</path>
şi <path>ram.conf</path>.
</p>

<p>
Pentru a configura starea sleep, editaţi <path>ram.conf</path> în
<path>/etc/hibernate</path>. <c>UseSysfsPowerState mem</c> este setată deja
corect, dar trebuie să parcurgeţi restul fişierului de configurare şi
să-l setaţi pentru sistemul dvs. Comentariile şi numele opţiunilor vă
vor ghida. Dacă utilizaţi directoare partajate samba în reţea,
asiguraţi-vă că opriţi script-urile de iniţializare corespunzătoare
pentru a evita timpi morţi.
</p>

<p>
Gata? Acum, ultima şansă pentru a efectua backup la datele pe care doriţi
să le păstraţi după executarea următoarei comenzi. Notaţi faptul
că, probabil va trebui să apăsaţi o tastă specială, cum ar fi
<e>Fn</e>, pentru e reveni din starea sleep.
</p>

<pre caption="Apelarea sleep">
<i># hibernate-ram</i>
</pre>

<p>
Dacă încă citiţi, înseamnă că se pare că funcţionează. Puteţi
seta, de asemenea, starea de standby (S1) într-un mod similar prin copierea
fişierului <path>ram.conf</path> ca <path>standby.conf</path> şi crearea
unui link simbolic <path>/usr/sbin/hibernate-standby</path> care să indice
către <path>/usr/sbin/hibernate</path>. S3 şi S4 sunt cele mai interesante
stări sleep, din cauza economisirii de energie foarte mare, totuşi.
</p>

</body>
</section>
<section>
<title>Hibernarea (S4)</title>
<body>

<p>
Această secţiune introduce hibernarea, unde o versiune snapshot a sistemului
care rulează este scrisă pe disc înainte de a opri sistemul. La revenire,
versiunea snapshot este încărcată şi puteţi să lucraţi exact din
punctul în care aţi apelat hibernarea, mai înainte.
</p>

<warn>
Nu schimbaţi componente hardware non-pluggable în timpul stării de
suspendare. Nu încercaţi să încărcaţi o versiune snapshot cu o altă
imagine de kernel decât cea cu care a fost creat. Închideţi orice
client/server NFS sau samba înainte de a intra în hibernare.
</warn>

<p>
Există în acest moment trei implementări pentru S4. Cea originală este
swsusp, apoi există suspend2, care are cea mai frumoasă interfaţă
(incluzând suport fbsplash). O <uri
link="http://suspend2.net/features.html#compare">comparaţie de
facilităţi</uri> este disponibilă pe <uri
link="http://suspend2.net">pagina oficială suspend2</uri>. A fost şi
swsusp, însă a fost integrat inapoi.
</p>

<p>
Suspend2 nu este inclus în sursele principale de kernel încă, deci, fie
trebuie să aplicaţi patch-uri surselor dvs. de kernel oferite de <uri
link="http://suspend2.net">suspend2.net</uri> sau să utilizaţi
<c>sys-kernel/suspend2-sources</c>.
</p>

<p>
Partea legată de kernel atât pentru swusp cât şi pentru suspend2 este
după cum urmează:
</p>

<pre caption="Configurarea kernel-ului pentru diversele tipuri suspend">
Power Management Options ---&gt;
  <comment>(hibernare cu swsusp)</comment>
  [*] Software Suspend
      <comment>(înlocuiţi /dev/SWAP cu partiţia dvs. swap)</comment>
      (/dev/SWAP)      Default resume partition
  
  <comment>(hibernare cu suspend2)</comment>
  Software Suspend 2
    --- Image Storage (you need at least one writer)
    [*]     File Writer
    [*]    Swap Writer
    ---   General Options
    [*]    LZF image compression
    <comment>(înlocuiţi /dev/SWAP cu partiţia dvs. swap)</comment>
    (swap:/dev/SWAP)   Default resume device name
    [ ]     Allow Keep Image Mode
</pre>

<p>
Configurarea pentru swsusp este destul de uşoară. Dacă nu aţi introdus
locaţia partiţiei dvs. de swap în configurarea de kernel, puteţi, de
asemenea, să o pasaţi ca parametru de kernel cu ajutorul directivei
<c>resume=/dev/SWAP</c>. Dacă nu este posibilă boot-area din cauza unei
imagini eronate, utilizaţi parametrul de kernel <c>noresume</c>. Script-ul de
iniţializare <c>hibernate-cleanup</c> invalidează imaginile swsusp în
timpul procesului de boot.
</p>

<pre caption="Invalidarea imaginilor swsusp în timpul procesului de boot">
<i># rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Pentru a activa hibernarea cu swsusp, utilizaţi script-ul de hibernare şi
setaţi <c>UseSysfsPowerState disk</c> in fişierul
<path>/etc/hibernate/hibernate.conf</path>.
</p>

<warn>
Salvaţi-vă datele înainte de a face asta. Rulaţi <c>sync</c> înainte de
executarea uneia din comenzi pentru a avea datele din memorie scrise pe disc.
Încercaţi prima dată în afara server-ului X, apoi când rulează
server-ul X, dar neautentificat.
</warn>

<p>
Dacă apar mesaje kernel panic datorită uhci sau similar, încercaţi să
compilaţi suportul USB ca modul şi descărcaţi modulele înainte de a
trimite laptop-ul în modul sleep. Există opţiuni de configurare pentru
aceasta în fişierul <path>hibernate.conf</path>.
</p>

<pre caption="Hibernarea cu swsusp">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Asiguraţi-vă că aveţi o copie backup pentru datele dvs.)</comment>
<i># hibernate</i>
</pre>

<p>
Următoarea secţiune tratează setarea suspend2, inclusiv suportul fbsplash
pentru afişarea unei bare de progress drăguţe în timpul suspendării
şi revenirii.
</p>

<p>
Prima parte a configuraţiei este similară cu cea de configurare a swsusp.
În cazul în care nu aţi introdus locaţia partiţiei de swap în
configurarea kernel-ului, o puteţi adăuga ca parametru de kernel cu ajutorul
directivei <c>resume2=swap:/dev/SWAP</c>. Dacă procesul de boot nu a fost
posibil din cauza unei imagini eronate, adăugaţi parametrul
<c>noresume2</c>. În plus, script-ul de iniţializare
<c>hibernate-cleanup</c> invalidează imaginile suspend2 în timpul procesului
de boot.
</p>

<pre caption="Invalidarea imaginilor suspend2 în timpul procesului de boot">
<i># rc-update add hibernate-cleanup boot</i>
</pre>

<p>
Acum, editaţi <path>/etc/hibernate/hibernate.conf</path>, activaţi
secţiunile <e>sysfs_power_state</e> şi <e>acpi_sleep</e>. Nu activaţi
partea fbsplash între opţiunile globale, încă.
</p>

<pre caption="Hibernarea cu suspend2">
<i># nano -w /etc/hibernate.conf</i>
<comment>(Asiguraţi-vă că aveţi o copie backup pentru datele dvs.)</comment>
<i># hibernate</i>
</pre>

<p>
Vă rugăm să configuraţi fbsplash acum, în cazul în care nu aţi
efectuat acest lucru, încă. Pentru a activa suportul fbsplash în timpul
hibernării, este necesar pachetul <c>sys-apps/suspend2-userui</c>. În plus,
trebuie să activăm indicatorul USE <e>fbsplash</e>.
</p>

<pre caption="Instalarea suspend2-userui">
<i># mkdir -p /etc/portage</i>
<i># echo sys-apps/suspend2-userui fbsplash >> /etc/portage/package.use</i>
<i># emerge suspend2-userui</i>
</pre>

<p>
Acest ebuild vă specifică să creaţi un link simbolic pentru tema pe care
doriţi să o utilizaţi. Spre exemplu, pentru a utiliza tema
<c>livecd-2005.1</c>, rulaţi comanda următoare:
</p>

<pre caption="Utilizarea temei livecd-2005.1 în timpul hibernării">
<i># ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2</i>
</pre>

<p>
Dacă nu doriţi un ecran gol în prima parte a procesului de resume, trebuie
să adăugaţi utilitarul <c>suspend2ui_fbsplash</c> în imaginea dvs.
initrd. Presupunând că aţi creat imaginea initrd cu
<c>splash_geninitramfs</c> şi aţi salvat-o ca
<path>/boot/fbsplash-emergence-1024x768</path>, iată cum puteţi face acest
lucru.
</p>

<pre caption="Adăugarea suspend2ui_fbsplash într-o imagine initrd">
<i># mount /boot</i>
<i># mkdir ~/initrd.d</i>
<i># cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</i>
<i># cd ~/initrd.d</i>
<i># gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</i>
<i># rm fbsplash-emergence-1024x768</i>
<i># cp /usr/sbin/suspend2ui_fbsplash sbin/</i>
<i># find . | cpio --quiet --dereference -o -H newc | gzip -9 > /boot/fbsplash-suspend2-emergence-1024x768</i>
</pre>

<p>
Apoi, ajusaţi <path>grub.conf</path> respectiv <path>lilo.conf</path> pentru
ca kernel-ul să utilizeze
<path>/boot/fbsplash-suspend2-emergence-1024x768</path> ca imagine initrd.
Puteţi testa acum o rulare fără a lua efectiv nici o acţiune pentru a
verifica dacă totul a fost setat corect.
</p>

<pre caption="Testaţi rularea pentru hibernarea cu fbsplash">
<i># suspend2ui_fbsplash -t</i>
</pre>

<p>
Apoi, deschideţi <path>/etc/hibernate/hibernate.conf</path> din nou şi
activaţi opţiunile fbsplash. Executaţi <c>hibernate</c> şi savuraţi.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Rezolvare probleme</title>
<section>
<title>Dacă lucrurile nu merg bine...</title>
<body>

<p>
<e>Î:</e> Încerc să schimb frecvenţa procesorului, dar
<path>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</path> nu există.
</p>

<p>
<e>R:</e> Asiguraţi-vă că procesorul dvs. suportă scalarea frecvenţei
şi aţi ales driver-ul CPUFreq corect pentru procesorul dvs. Aici este o
listă a procesoarelor suportate de cpufreq (kernel 2.6.7): ARM Integrator,
ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile
K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix
Media GXm, Intel mobile PIII şi Intel mobile PIII-M pe anumite chipset-uri,
Intel Pentium 4, Intel Xeon, Intel Pentium M (Centrino), National
Semiconductors Geode GX, Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III,
SuperH SH-3, SH-4, mai multe "PowerBook" şi "iBook2" şi diverse procesoare
pe unele sisteme compatibile ACPI 2.0 (doar dacă opţiunea "ACPI Processor
Performance States" este disponibilă în interfaţa ACPI/BIOS).
</p>

<p>
<e>Î:</e> Laptop-ul meu suportă scalarea frecvenţei, dar
<path>/sys/devices/system/cpu/cpu0/cpufreq/</path> este gol.
</p>

<p>
<e>R:</e> Uitaţi-vă după mesaje de eroare legate de ACPI cu <c>dmesg |
grep ACPI</c>. Încercaţi o actualizare a BIOS-ului, în special dacă este
raportată deteriorarea DSDT. Puteţi încerca de asemenea să-l reparaţi
dvs. (ceea ce este dincolo de scopul acestui ghid).
</p>

<p>
<e>Î:</e> Laptop-ul meu suportă scalarea frecvenţei, dar /proc/cpuinfo
raportează că viteza nu se schimbă niciodată.
</p>

<p>
<e>R:</e> Probabil aveţi activat în kernel suportul SMP, multiprocesare
simetrică (CONFIG_SMP). Dezactivaţi-l şi ar trebui să funcţioneze.
Unele kernel-uri mai vechi conţin o problemă ce îl cauzează. În acest
caz, rulaţi <c>emerge x86info</c>, actualizaţi-vă kernel-ul şi
verificaţi frecvenţa cu <c>x86info -mhz</c>.
</p>

<p>
<e>Î:</e> Pot schimba frecvenţa procesorului, dar intervalul nu este aşa
de larg ca în cazul altor sisteme de operare.
</p>

<p>
<e>R:</e> Puteţi combina scalarea frecvenţei cu supraîncărcarea ACPI
pentru a obţine o frecvenţă minimă mai mică. Luaţi aminte că
supraîncărcarea nu salvează multă energie şi este folosită în
principal pentru gestionarea temperaturii (păstrarea rece şi silenţioasă
a laptop-ului dvs.) Puteţi citi stadiul curent al supraîncărcării cu
<c>cat /proc/acpi/processor/CPU/throttling</c> şi să îl schimbaţi cu
<c>echo -n "0:x" > /proc/acpi/processor/CPU/limit</c>, unde x este una din
stările Tx afişate de <path>/proc/acpi/processor/CPU/throttling</path>.
</p>

<p>
<e>R:</e> Când configuraţi kernel-ul, salvarea de energie, performanţa şi
decidenţii pentru programele utilizatorului apar, dar opţiunea ondemand
lipseşte. De unde o iau?
</p>

<p>
<e>R:</e> Decidentul ondemand este inclus doar în sursele recente de kernel.
Încercaţi actualizarea acestora.
</p>

<p>
<e>Î:</e> Durata de folosire a acumulatorului pare mai mică decât
înainte.
</p>

<p>
<e>R:</e> Verificaţi configurările din BIOS. Poate că aţi uitat să
reactivaţi unele opţiuni.
</p>

<p>
<e>Î:</e> Acumulatorul meu este încărcat, dar KDE raportează că ar mai
rămâne 0% şi imediat se opreşte.
</p>

<p>
<e>R:</e> Verificaţi dacă battery support este compilat în kernel-ul dvs.
Dacă îl folosiţi ca modul, asiguraţi-vă că este încărcat.
</p>

<p>
<e>Î:</e> Deţin un Dell Inspiron 51XX şi nu îmi apare nici un eveniment
ACPI.
</p>

<p>
<e>R:</e> Pare o problemă în kernel. Citiţi <uri
link="http://bugme.osdl.org/show_bug.cgi?id=1752">aici</uri>.
</p>

<p>
<e>Q:</e> Am activat opţiunea DynamicClocks în <path>xorg.conf</path> şi
acum X.org returnează eroare / ecranul rămâne gol / sistemul meu laptop nu
se închide corespunzător.
</p>

<p>
<e>A:</e> Aceasta se întâmplă pe unele sisteme. Trebuie să dezactivaţi
DynamicClocks.
</p>

<p>
<e>Q:</e> Doresc să utilizez suspend2, dar mi se specifică faptul că
partiţia de swap este prea mică. Redimensionarea nu este o soluţie.
</p>

<p>
<e>A:</e> Dacă este destul loc pe sistemul dvs., puteţi utiliza filewriter
în locul swapwriter. <c>hibernate-script</c> îl suportă şi pe acesta. Mai
multe informaţii puteţi găsi în
<path>/usr/src/linux/Documentation/power/suspend2.txt</path>.
</p>

<p>
<e>Î:</e> Doar ce am cumpărat un nou acumulator, dar ţine doar câteva
minute! Ce fac greşit?
</p>

<p>
<e>R:</e> În primul rând respectaţi sfatul producătorului referitor la
modul de încărcare corect al acumulatorului.
</p>

<p>
<e>R:</e> Răspunsul de mai sus nu a ajutat. Ce ar trebui să fac atunci?
</p>

<p>
<e>R:</e> Unii acumulatori vânduţi ca "noi" sunt de fapt vechi. Încercaţi
următoarele:
</p>

<pre caption="Aflarea nivelului acumulatorului">
$ <i>grep capacity /proc/acpi/battery/BAT0/info</i>
design capacity:     47520 mWh
last full capacity:  41830 mWh
</pre>

<p>
Dacă "last full capacity" diferă semnificativ de capacitatea proiectată,
atunci acumulatorul dvs. este probabil deteriorat. Încercaţi să
beneficiaţi de garanţie.
</p>

<p>
<e>Î:</e> Problema mea nu este arătată mai sus. Ce ar trebui să fac în
continuare?
</p>

<p>
<e>R:</e> Nu vă temeţi să mă contactaţi direct, <mail
link="fragfred@gmx.de">Dennis Nienhüser</mail>.
</p>

</body>
</section>
</chapter>
</guide>
