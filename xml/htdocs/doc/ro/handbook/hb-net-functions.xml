<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.0 -->

<sections>

<version>1.0</version>
<date>2005-06-06</date>

<section>
<title>Funcţii standard</title>
<body>

<p>
Patru funcţii pot fi definite ce vor fi executate în jurul operaţiilor
start/stop. Funcţiile sunt denumite cu numele interfeţei la început, pentru
ca o funcţie să poată controla mai multe adaptoare.
</p>

<p>
Valorile returnate pentru funcţiile preup şi predown ar trebui să fie 0
(succes) pentru a indica că procesul de configurare sau deconfigurare poate
continua. Dacă preup returnează o valoarea non-zero, atunci configurarea
interfeţei va fi întreruptă. Dacă predown returnează o valoare
non-zero, atunci interfeţei nu i se va permite continuarea deconfigurării.
</p>

<p>
Valorile returnate de funcţiile postup şi postdown sunt ignorate deoarece nu
se poate efectua nimic dacă acestea returnează eroare.
</p>

<p>
<c>${IFACE}</c> este setată pentru interfaţa care trebuie să fie
activată/dezactivată.<br/>
<c>${IFVAR}</c> este <c>${IFACE}</c> convertit la un nume de variabilă permis
de bash.
</p>

<pre caption="exemple de funcţii pre/post de activare/dezactivare">
preup() {
	<comment># Testăm conectivitatea interfeţei înainte de a o activa.
	# Aceasta funcţionează doar pentru unele adaptoare de
	# reţea şi necesită ca pachetul mii-diag să fie instalat.</comment>
	if mii-tool ${IFACE} 2> /dev/null | grep -q 'no link'; then
		ewarn "No link on ${IFACE}, aborting configuration"
		return 1
	fi

	<comment># Testăm conectivitatea interfeţei înainte de a o activa.
	# Aceasta funcţionează doar pentru unele adaptoare de
	# reţea şi necesită ca pachetul ethtool să fie instalat.</comment>
	if ethtool ${IFACE} | grep -q 'Link detected: no'; then
		ewarn "No link on ${IFACE}, aborting configuration"
		return 1
	fi

	<comment># Amintiţi-vă să returnaţi valoarea 0 în cazul succesului</comment>
	return 0
}

predown() {
	<comment># Implicită în script este testarea directorului rădăcină
	# NFS şi interzicerea dezactivării interfeţelor în acest caz.
	# Notaţi faptul că, dacă specificaţi o funcţie predown() veţi
	# suprascrie această logică. Iat-o în cazul în care aveţi nevoie...</comment>
	if is_net_fs /; then
		eerror "root filesystem is network mounted -- can't stop ${IFACE}"
		return 1
	fi

	<comment># Amintiţi-vă să returnaţi valoarea 0 în cazul succesului</comment>
	return 0
}

postup() {
	<comment># Această funcţie poate fi utilizată, spre exemplu,
	# pentru înregistrarea unui serviciu DNS dinamic. O altă
	# posibilitate ar fi să trimiteţi/primiţi mesaje, odată
	# ce interfaţa se activează.</comment>
       return 0
}

postdown() {
	<comment># Această funcţie este prezentă, mai mult pentru completare...
	# Nu m-am gândit la nici o funcţionalitate deosebită, încă ;-)</comment>
	return 0
}
</pre>

</body>
</section>

<section>
<title>Funcţii standard pentru utilitare wireless</title>
<body>

<note>
Aceasta nu funcţiona cu WPA Supplicant - dar variabilele <c>${ESSID}</c> şi
<c>${ESSIDVAR}</c> sunt disponibile în funcţia postup()
</note>

<p>
Două funcţii pot fi definite ce vor fi invocate înainte şi după
funcţia asociată. Aceste funcţii sunt invocate având numele sufixat cu
numele interfeţei pentru ca o singură funcţie să poată controla mai
multe adaptoare.
</p>

<p>
Valorile returnate pentru funcţia preasociată ar trebui să fie 0 (succes)
pentru indicarea continuării configurării sau deconfigurării. Dacă
funcţia preasociată returnează o valoare non-zero, atunci configurarea
interfeţei va fi anulată.
</p>

<p>
Valoarea returnată pentru funcţia preasociată este ignorată deoarece nu
rămâne nici o acţiune de efectuat dacă aceasta indică eroare.
</p>

<p>
<c>${ESSID}</c> este setată exact la valoarea ESSID a dispozitivului AP la
care vă conectaţi<br/>
<c>${ESSIDVAR}</c> este <c>${ESSID}</c> convertită la un nume de variabilă
permisă de bash.
</p>

<pre caption="funcţiile de asociere pre/post">
preassociate() {
	<comment># Rândurile de mai jos adaugă două variabile de configurare leap_user_ESSID
	# şi leap_pass_ESSID. Când sunt ambele configurate pentru sesiunea ESSID la care
	# sunteţi conectaţi, atunci rulăm script-ul CISCO LEAP</comment>

	local user pass
	eval user=\"\$\{leap_user_${ESSIDVAR}\}\"
	eval pass=\"\$\{leap_pass_${ESSIDVAR}\}\"

	if [[ -n ${user} &amp;&amp; -n ${pass} ]]; then
		if [[ ! -x /opt/cisco/bin/leapscript ]]; then
			eend "For LEAP support, please emerge net-misc/cisco-aironet-client-utils"
			return 1
		fi
		einfo "Waiting for LEAP Authentication on \"${ESSID//\\\\//}\""
		if /opt/cisco/bin/leapscript ${user} ${pass} | grep -q 'Login incorrect'; then
			ewarn "Login Failed for ${user}"
			return 1
		fi
	fi

	return 0
}

postassociate() {
	<comment># Această funcţie este prezentă, mai mult pentru completare...
	# Nu m-am gândit la nici o funcţionalitate deosebită, încă ;-)</comment>

	return 0
}
</pre>

<note>
<c>${ESSID}</c> şi <c>${ESSIDVAR}</c> nu sunt disponibile în funcţiile
predown() şi postdown()
</note>

</body>
</section>

</sections>
