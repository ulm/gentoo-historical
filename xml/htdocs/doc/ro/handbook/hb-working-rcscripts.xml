<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/handbook/hb-working-rcscripts.xml,v 1.2 2004/11/10 10:46:10 neysx Exp $ -->

<sections>

<version>1.17</version>
<date>23 Octombrie 2004</date>

<section>
<title>Nivele de execuţie</title>
<subsection>
<title>Pornirea Sistemului</title>
<body>

<p>
La procesul de boot al sistemului, veţi observa mult text defilând. Dacă acordaţi o mică atenţie, veţi observa că acest text este acelaşi de fiecare dată când reporniţi sistemul. Secvenţa tuturor acestor acţiuni este denumită <e>secvenţa de boot</e> şi este (mai mult sau mai puţin) definită static.
</p>

<p>
Mai întâi, aplicaţia boot loader va încărca imaginea de kernel, definită în configurarea acesteia, în memorie după ce-i specifică CPU-ului să ruleze kernel-ul. Când kernel-ul este încărcat şi rulează, acesta iniţializează toate structurile şi sarcinile specifice kernel-ului şi rulează procesul <c>init</c>.
</p>

<p>
Apoi, acest proces se asigură că toate sistemele de fişiere (definite în <path>/etc/fstab</path>) sunt mount-ate şi gata de utilizare. Apoi, execută unele script-uri localizate în <path>/etc/init.d</path>, care vor porni serviciile necesare pentru a avea un sistem ce a trecut cu succes procesului de boot.
</p>

<p>
În final, când toate script-urile sunt executate, <c>init</c> activează terminalele (în majoritatea cazurilor doar consolele virtuale ce se ascund în spatele combinaţiilor <c>Alt-F1</c>, <c>Alt-F2</c>, etc.) ataşându-le un proces special numit <c>agetty</c>. Acest proces va asigura procesul de login prin intermediul acestor terminale prin rularea <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Script-uri de Iniţializare</title>
<body>

<p>
Acum, <c>init</c> nu doar execută script-urile din <path>/etc/init.d</path> în mod aleator. Mai mult, nu rulează toate script-urile din <path>/etc/init.d</path>, ci doar script-urile care îi sunt specificate spre execuţie. El decide ce script-uri sa execute prin analizarea <path>/etc/runlevels</path>.
</p>

<p>
Mai întâi, <c>init</c> rulează script-urile din <path>/etc/init.d</path> ce au link-uri simbolice în <path>/etc/runlevels/boot</path>. De obicei, va rula script-urile în ordine alfabetică, dar unele script-uri conţin informaţii despre dependenţe, specificând sustemului că un alt script trebuie rulat înainte ca ele să fie pornite.
</p>

<p>
Când sunt executate toate script-urile ce deţin referinţe în <path>/etc/runlevels/boot</path>, <c>init</c> va continua să ruleze script-uri ce au link-uri simbolice spre ele în <path>/etc/runlevels/default</path>. Din nou, va utiliza ordinea alfabetică pentru a decide ce script să ruleze mai întâi, doar dacă un script conţine o informaţie despre dependenţe, caz în care ordinea este schimbată pentru a oferi o secvenţă de pornire validă.
</p>

</body>
</subsection>
<subsection>
<title>Cum Funcţionează Init</title>
<body>

<p>
Bineînţeles, <c>init</c> nu decide totul singur. El necesită un fişier de configurare ce specifică ce acţiuni trebuie să întreprindă. Acest fişier de configurare este <path>/etc/inittab</path>.
</p>

<p>
Dacă vă amintiţi secvenţa de boot ce tocmai am descris-o, vă veţi aminti că prima acţiune a <c>init</c> este mount-area tuturor sistemelor de fişiere. Acest lucru este definit în următoarea linie din <path>/etc/inittab</path>:
</p>

<pre caption="Linia de iniţializare a sistemului din /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Această linie îi specifică aplicaţiei <c>init</c> faptul că trebuie să ruleze <c>/sbin/rc sysinit</c> pentru a iniţializa sistemul. Script-ul <path>/sbin/rc</path> are ca scop iniţializarea sistemului, deci aţi putea afirma că <c>init</c> nu execută prea multe acţiuni -- el delegă sarcina de iniţializare a sistemului altui proces.
</p>

<p>
Apoi, <c>init</c> execută toate script-urile ce au conţinute link-uri simbolice în <path>/etc/runlevels/boot</path>. Această acţiune este definită de următoare linie:
</p>

<pre caption="Iniţializarea sistemului, continuată">
rc::bootwait:/sbin/rc boot
</pre>

<p>
Din nou, script-ul <c>rc</c> execută sarcinile necesare. Notaţi că opţiunea tranferată lui <c>rc</c> (<e>boot</e>) este aceeaşi ca subdirectorul din <path>/etc/runlevels</path> ce este utilizat.
</p>

<p>
Acum, <c>init</c> îşi verifică fişierul de configurare pentru a analiza ce <e>nivel de execuţie</e> să ruleze. Pentru a decide această acţiune, citeşte următoarea linie din <path>/etc/inittab</path>:
</p>

<pre caption="Linia initdefault">
id:3:initdefault:
</pre>

<p>
În acest caz (pentru care majoritatea utilizatorilor Gentoo îl vor folosi), identificatorul <e>nivelului de execuţie</e> este 3. Utilizând această informaţie, <c>init</c> verifică ceea ce trebuie să ruleze pentru a porni <e>nivelul de execuţie 3</e>:
</p>

<pre caption="Definiţiile nivelului de execuţie">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
Linia ce defineşte nivelul 3, din nou, utilizează script-ul <c>rc</c> pentru a porni serviciile (acum cu argumentul <e>default</e>). Din nou, notaţi că argumentul lui <c>rc</c> este acelaşi ca subdirectorul din <path>/etc/runlevels</path>.
</p>

<p>
Când <c>rc</c> este terminat, <c>init</c> decide ce console virtuale să activeze şi ce comenzi trebuie rulate pentru fiecare consolă:
</p>

<pre caption="Definirea consolelor virtuale">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>


</body>
</subsection>
<subsection>
<title>Ce este un nivel de execuţie?</title>
<body>

<p>
Aţi observat că <c>init</c> utilizează o schemă de numerotare pentru a decide ce <e>nivel de execuţie</e> trebuie să activeze. Un <e>nivel de execuţie</e> este un stadiu în care sistemul rulează şi conţine o colecţie de script-uri (scripturi de nivele de execuţie sau <e>initscipt-uri</e>) ce trebuie executate când intraţi în sau ieşiţi dintr-un nivel de execuţie.
</p>

<p>
În Gentoo, există şapte nivele de execuţie: trei nivele de execuţie interne, şi patru nivele de execuţie definite de utilizatori. Nivelele interne sunt denumite <e>sysinit</e>, <e>shutdown</e> şi <e>reboot</e> şi execută acelaşi lucru ca numele lor: iniţializarea sistemului, oprirea sistemului, repornirea sistemului.
</p>

<p>
Nivelele de execuţie definite de utilizator sunt cele ce sunt localizate în subdirectorul <path>/etc/runlevels</path>: <path>boot</path>, <path>default</path>, <path>nonetwork</path> şi <path>single</path>. Nivelul de execuţie <path>boot</path> rulează toate serviciile necesare sistemului utilizate de toate celelalte nivele de execuţie. Cele trei nivele de execuţie diferă prin serviciile care le pornesc: <path>default</path> este pentru utilizarea zilnică, <path>nonetwork</path> este utilizat în cazul în care nu este necesară conctivitatea reţelei şi <path>single</path> este utilizat când se repară sistemul.
</p>

</body>
</subsection>
<subsection>
<title>Utilizarea Script-urilor de Iniţializare</title>
<body>

<p>
Scrip-urile pe care procesul <c>rc</c> le porneşte sunt denumite <e>scrip-uri de iniţializare</e>. Fiecare script în <path>/etc/init.d</path> poate fi executat cu argumentele <e>start</e>, <e>stop</e>, <e>restart</e>, <e>pause</e>, <e>zap</e>, <e>status</e>, <e>ineed</e>, <e>iuse</e>, <e>needsme</e>, <e>usesme</e> sau <e>broken</e>.
</p>

<p>
Pentru a porni, opri sau reporni un serviciu (şi toate serviciile dependente), trebuie utilizaţi parametrii <c>start</c>, <c>stop</c> şi <c>restart</c>:
</p>

<pre caption="Pornirea Postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Doar serviciile ce necesită serviciul dat prin declaraţia <e>need</e> sunt oprite sau repornite. Alte servicii dependente (cele care depind prin declaraţia <e>use</e> de serviciu dar nu îl necesită) nu sunt afectate.
</note>

<p>
Dacă doriţi să opriţi un serviciu, dar nu şi serviciile ce depind de el, puteţi utiliza argumentul <c>pause</c>:
</p>

<pre caption="Oprirea Postfix dar păstrarea serviciilor dependente pornite">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Dacă doriţi să analizaţi în ce stadiu se află un serviciu (in starea started, stopped, paused, ...) puteţi utiliza argumentul <c>status</c>:
</p>

<pre caption="Informaţia despre starea serviciului postfix">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Dacă informaţia de stare precizează că serviciul rulează, dar ştiţi sigur că nu rulează, puteţi reseta informaţia de stare ca "stopped" cu argumentul <c>zap</c>:
</p>

<pre caption="Resetarea informaţiei de stare pentru postfix">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Pentru a interoga în scopul vizualizării dependenţelor unui serviciu, puteţi utiliza <c>iuse</c> sau <c>ineed</c>. Cu <c>ineed</c> puteţi vizualiza serviciile ce chiar sunt necesare pentru funcţionarea corectă a serviciului. Pe de altă parte <c>iuse</c> afişează serviciile ce pot fi folosite de serviciu, dar nu sunt necesare pentru funcţionarea corectă.
</p>

<pre caption="Interogarea în scopul obţinerii unei liste de servicii de care depinde Postfix">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
În mod similar, puteţi interoga în scopul obţinerii serviciilor ce necesită serviciul (<c>needsme</c>) sau îl pot utiliza (<c>usesme</c>):
</p>

<pre caption="Interogarea în scopul vizualizării unel liste a tuturor serviciilor ce necesită Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
În final, puteţi interoga în scopul vizualizării dependenţelor lipsă a unui serviciu:
</p>

<pre caption="Interogarea în scopul obţinerii lista dependenţelor lipsă pentru Postfix">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Utilizarea rc-update</title>
<subsection>
<title>Ce este rc-update?</title>
<body>

<p>
Sistemul de iniţializare Gentoo utilizează o structură de dependenţe pentru a decide ce servicii trebuie să fie pornite mai întâi. Cum, aceasta este o sarcină plictisitoare pentru care nu am dori ca utilizatorii noştri să o seteze manual, am creat utilitare ce facilitează administrarea nivelelor de execuţie şi script-urilor de iniţializare.
</p>

<p>
Cu ajutorul <c>rc-update</c> puteţi adăuga şi scoate script-uri de iniţializare pentru un nivel de execuţie. Utilitarul <c>rc-update</c> va interoga automat script-ul <c>depscan.sh</c> pentru a reconstrui structura de dependenţe.
</p>

</body>
</subsection>
<subsection>
<title>Adăugarea şi Ştergerea de Servicii</title>
<body>

<p>
Deja aţi adăugat script-uri de iniţializare nivelului de execuţie "default" în timpul instalării Gentoo. La acea vreme, probabil că nu înţelegeaţi ce reprezintă "default", dar acum ar trebui. Script-ul <c>rc-update</c> necesită un al doilea argument ce defineşte acţiunea: <e>add</e> (adăugare), <e>del</e> (ştergere) sau <e>show</e> (vizualizare).
</p>

<p>
Pentru a adăuga sau a şterge un script de iniţializare, trebuie doar să pasaţi argumentul <c>add</c> sau <c>del</c>, urmat de script-ul de iniţializare şi de nivelul de execuţie. Spre exemplu:
</p>

<pre caption="Ştergerea Postfix din nivelul de execuţie default">
# <i>rc-update del postfix default</i>
</pre>

<p>
Comanda <c>rc-update show</c> va afişa toate script-urile de iniţializare şi în ce nivele de execuţie vor fi rulate:
</p>

<pre caption="Receiving init script information">
# <i>rc-update show</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Configurarea Serviciilor</title>
<subsection>
<title>De ce Nevoia pentru Configurări Suplimentare?</title>
<body>

<p>
Script-urile de iniţializare pot fi destul de complexe. De aceea, nu este de dorit ca utilizatorii să editeze script-ul de iniţializare direct, deoarece ar fi mai expus spre erori. Este, cu toate acestea, important să puteţi să configuraţi un asemenea serviciu. Spre exemplu, aţi putea adăuga mai multe opţiuni serviciului în sine.
</p>

<p>
Un al doilea motiv pentru a avea această configuraţie separat script-ului de iniţializare este să poată actualiza script-urile de iniţializare fără să aibă grija faptului că modificările în configuraţia dvs. vor fi refăcute.
</p>

</body>
</subsection>
<subsection>
<title>Directorul /etc/conf.d</title>
<body>

<p>
Gentoo oferă o cale uşoară de a configura un asemenea serviciu: fiecare script de iniţializare ce poate fi configurat are un fişier în <path>/etc/conf.d</path>. Spre exemplu, script-ul de iniţializare apache2 (denumit <path>/etc/init.d/apache2</path>) are un fişier de configurare denumit <path>/etc/conf.d/apache2</path>, ce poate conţine opţiunile ce doriţi să le pasaţi aplicaţiei server Apache 2 în momentul în care este pornit:
</p>

<pre caption="Variabilă definită în /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP4"
</pre>

<p>
Un asemenea fişier de configurare conţine variabile şi numai variabile (exact ca în cazul <path>/etc/make.conf</path>), facilitând configurarea serviciilor. De asemenea, permite oferirea unor informaţii mai detaliate în despre variabile (sub forma comentariilor).
</p>

</body>
</subsection>
</section>
<section>
<title>Scrierea de Script-uri de Iniţializare</title>
<subsection>
<title>Chiar Trebuie?</title>
<body>

<p>
Nu, scrierea unui script de iniţializare nu este, de obicei, necesară, deoarece Gentoo oferă script-uri de iniţializare gata-de-utilizare pentru toate serviciile oferite. În orice caz, puteţi avea instalat un serviciu fără a fi utilizat Portage, caz în care veţi dori să creaţi un script de iniţializare.
</p>

<p>
Nu utilizaţi un script de iniţializare oferit de un serviciu dacă nu este scris explicit pentru Gentoo: Script-urile de iniţializare din Gentoo nu sunt compatibile cu script-urile de iniţializare din alte distribuţii!
</p>

</body>
</subsection>
<subsection>
<title>Schema</title>
<body>

<p>
Schema de bază pentru un script de iniţializare poate fi vizualizată mai jos.
</p>

<pre caption="Schema de bază pentru un script de iniţializare">
#!/sbin/runscript

depend() {
  <comment>(Informaţia despre dependenţe)</comment>
}

start() {
  <comment>(Comenzi necesare pentru a porni serviciul)</comment>
}

stop() {
  <comment>(Comenzi necesare pentru a opri serviciul)</comment>
}

restart() {
  <comment>(Comenzi necesare pentru a reporni serviciul)</comment>
}
</pre>

<p>
Orice script de iniţializare <e>necesită</e> definirea funcţiei <e>start</e>. Toate celelalte secţiuni sunt opţionale.
</p>

</body>
</subsection>
<subsection>
<title>Dependendenţe</title>
<body>

<p>
Există două dependenţe ce le puteţi defini: <c>use</c> şi <c>need</c>. Aşa cum am menţionat anterior, dependenţa <c>need</c> este mai strictă decât dependenţa <c>use</c>. Urmărind acest tip de dependenţă puteţi manipula serviciul de care depindeţi, sau dependenţa virtuală.
</p>

<p>
O dependenţă <e>virtuală</e> este o dependenţă oferită de un serviciu, dar nu este oferită doar de acel serviciu. Script-ul dvs. de iniţializare poate depinde de o aplicaţie de tip logger de sistem, dar sunt multe aplicaţii de acest tip disponibile (metalogd, syslog-ng, sysklogd, ...). Cum, nu puteţi depinde de fiecare din acestea prin declaraţia <c>need</c> (nici un sistem nu are toate aplicaţiile de tip logger de sistem instalate si rulând), ne asigurăm că toate aceste servicii oferă prin declaraţia <c>provide</c> o dependenţă virtuală.
</p>

<p>
Să aruncăm o privire asupra informaţiilor despre dependenţe pentru serviciul postfix.
</p>

<pre caption="Informaţia despre dependenţe pentru Postfix">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
După cum observaţi, serviciul postfix:
</p>

<ul>
  <li>Necesită dependenţa (virtuală) <c>net</c> (ce este oferită, spre exemplu, de <path>/etc/init.d/net.eth0</path>)
  </li>
  <li>utilizează dependenţa (virtuală) <c>logger</c> (care este oferită, spre exemplu, de <path>/etc/init.d/syslog-ng</path>)
  </li>
  <li>utilizează dependenţa (virtuală) <c>dns</c> (care este oferită, spre exemplu, de <path>/etc/init.d/named</path>)
  </li>
  <li>oferă dependenţa (virtuală) <c>mta</c> (ce este comună pentru toate aplicaţiile de tip server de mail)
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Controlarea Ordinii</title>
<body>

<p>
În unele cazuri, nu veţi dori să cereţi rularea unui serviciu, dar veţi dori ca serviciul dvs. să fie pornit înaintea altui serviciu, prin declararea <c>before</c> (sau înaintea, prin declararea <c>after</c>) doar <e>dacă</e> este disponibil în sistem (notaţi condiţia - aceasta nu mai reprezintă dependenţă) <e>şi</e> dacă rulează în acelaşi nivel de execuţie (notaţi condiţia - pot fi invocate doar serviciile din acelaşi nivel de execuţie). Puteţi oferi această informaţie utilizând setările <c>before</c> sau <c>after</c>.
</p>

<p>
Ca exemplu, vom vizualiza setările serviciului Portmap:
</p>

<pre caption="Funcţia depend() în serviciul Portmap">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Puteţi utiliza generalizarea "*" pentru a invoca toate serviciile din acelaşi nivel de execuţie, deşi nu este indicat.
</p>

<pre caption="Rularea unui script de iniţializare ca fiind primul script din nivelul de execuţie">
depend() {
  before *
}
</pre>

</body>
</subsection>
<subsection>
<title>Funcţii Standard</title>
<body>

<p>
Alături de funcţionalitatea <c>depend()</c>, puteţi avea nevoie să definiţi funcţia <c>start()</c>. Aceasta conţine toate comenzile necesare pentru a iniţializa serviciul. Este indicat să utilizaţi funcţiile <c>ebegin</c> şi <c>eend</c> pentru a informa utilizatorul asupra a ceea ce se întâmplă:
</p>

<pre caption="Exemplu pentru funcţia start()">
start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}
</pre>

<p>
Dacă doriţi mai multe exemple ale funcţiei <c>start()</c>, vă rugăm să citiţi codul sursă disponibil în script-urile de iniţializare din directorul <path>/etc/init.d</path>. Cât despre <c>start-stop-daemon</c>, există o excelentă pagină de manual disponibilă dacă doriţi informaţii suplimentare:
</p>

<pre caption="Afişarea paginii de manual pentru start-stop-daemon">
# <i>man start-stop-daemon</i>
</pre>

<p>
Alte funcţii ce le puteţi defini sunt: <c>stop()</c> şi <c>restart()</c>. Nu sunteţi obligat să definiţi aceste funcţii! Sistemul nostru de iniţializare este destul de inteligent pentru a completa aceste funcţii singur dacă utilizaţi <c>start-stop-daemon</c>.
</p>

</body>
</subsection>
<subsection>
<title>Adăugarea de Opţiuni Personalizate</title>
<body>

<p>
Dacă doriţi ca script-urile de iniţializare să suporte mai multe funcţii decât cele deja definite, va trebui să adăugaţi variabila <c>opts</c> şi să creaţi o funcţie cu acelaşi nume ca opţiunea. Spre exemplu, pentru a suporta o opţiune numită <c>restartdelay</c>:
</p>

<pre caption="Suportarea opţiunii restartdelay">
opts="${opts} restartdelay"

restartdelay() {
  stop()
  sleep 3    <comment># Wait 3 seconds before starting again</comment>
  start()
}
</pre>

</body>
</subsection>
<subsection>
<title>Variabilele de Configurare pentru Serviciu</title>
<body>

<p>
Nu trebuie să întreprindeţi nimic pentru a suporta un fişier de configurare în <path>/etc/conf.d</path>: dacă script-ul de iniţializare este executat, următoarele fişiere sunt interpretate automat (spre ex. variabilele sunt disponibile spre utilizare):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;your init script&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
De asemenea, dacă script-ul dvs. de iniţializare oferă o dependenţă virtuală (cum ar fi <c>net</c>), fişierul asociat cu acea dependenţă (cum ar fi <path>/etc/conf.d/net</path>) va fi interpretat, de asemenea.
</p>

</body>
</subsection>
</section>
<section>
<title>Schimbarea Comportamentului Nivelului de Execuţie</title>
<subsection>
<title>Cine ar putea beneficia de această funcţionalitate?</title>
<body>

<p>
Mulţi utilizatori de laptop cunosc situaţia: acasă trebuie să ponească <c>net.eth0</c>, în timp ce în timpul călătoriei nu doresc să pornească <c>net.eth0</c> (deoarece reţeaua nu este disponibilă). Cu Gentoo, puteţi modifica comportamentul nivelului de execuţie în concordanţă cu nevoile proprii.
</p>

<p>
Spre exemplu, puteţi crea un al doilea nivel de execuţie "default" în care să porniţi şi care are atribuite alte script-uri de iniţializare. Puteţi selecta la boot ce nivel de execuţie implicit să utilizaţi.
</p>

</body>
</subsection>
<subsection>
<title>Utilizarea SOFTLEVEL</title>
<body>

<p>
Mai întâi de toate, creaţi un director corespunzător nivelului de execuţie pentru cel de-al doilea nivel de execuţie "default" al dvs. Ca un exemplu, putem crea nivelul de execuţie <path>offline</path>:
</p>

<pre caption="Crearea unui director corespunzător unui nivel de execuţie">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Adăugaţi script-urile de iniţializare noilor create nivele de execuţie. Spre exemplu, dacă doriţi să aveţi o copie exactă a nivelului de execuţie <c>default</c>, dar fără <c>net.eth0</c>:
</p>

<pre caption="Adăugarea script-urilor de iniţializare necesare">
# <i>ls /etc/runlevels/default</i>
acpid  domainname  local  net.eth0  netmount  postfix  syslog-ng  vixie-cron
# <i>rc-update add acpid offline</i>
# <i>rc-update add domainname offline</i>
# <i>rc-update add local offline</i>
# <i>rc-update add syslog-ng offline</i>
# <i>rc-update add vixie-cron offline</i>
</pre>

<p>
Acum, editaţi configurarea aplicaţiei bootloader şi adăugaţi o nouă intrare pentru nivelul de execuţie <c>offline</c>. Spre exemplu, în <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Adăugarea unei intrări pentru nivelul de execuţie offline">
title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Iată că totul este setat, acum. Dacă veţi porni sistemul şi selecta noua intrare la boot, nivelul de execuţie <c>offline</c> va fi rulat în locul celui implicit, <c>default</c>.
</p>

</body>
</subsection>
<subsection>
<title>Utilizarea BOOTLEVEL</title>
<body>

<p>
Utilizarea <c>bootlevel</c> este complet analoagă cu cea <c>softlevel</c>. Singura diferenţă este că definiţi un nou nivel de execuţie "boot" in loc să definiti un al doilea nivel "default".
</p>

</body>
</subsection>
</section>
</sections>
