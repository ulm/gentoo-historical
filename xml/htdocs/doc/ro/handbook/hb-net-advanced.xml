<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/handbook/hb-net-advanced.xml,v 1.3 2005/06/21 18:40:08 alin Exp $ -->

<sections>

<version>1.2</version>
<date>2005-06-14</date>

<section>
<title>Configurare Avansată</title>
<body>

<p>
Variabila config_eth0 reprezintă inima configuraţiei unei interfeţe. Este o
listă de instrucţiuni de nivel înalt pentru configurarea interfeţei (eth0 în
acest caz). Fiecare comandă din lista de instrucţiuni este executată
secvenţial. Interfaţa este considerată OK dacă cel puţin o comandă
funcţionează.
</p>

<p>
Iată o listă de instrucţiuni integrate:
</p>

<table>
<tr>
  <th>Commandă</th>
  <th>Descriere</th>
</tr>
<tr>
  <ti>null</ti>
  <ti>Nu face nimic</ti>
</tr>
<tr>
  <ti>noop</ti>
  <ti>
    Dacă interfaţa este activă şi există o adresă, atunci anulează
    configurarea cu succes
  </ti>
</tr>
<tr>
  <ti>o adresă IPv4 sau IPv6</ti>
  <ti>Adaugă adresa interfeţei</ti>
</tr>
<tr>
  <ti>
    dhcp, adsl sau apipa<br/>
    (sau o anumită comandă dintr-un modul extern)
  </ti>
  <ti>
    Rulează modulul ce oferă comanda. Spre exemplu, "dhcp" va rula un modul
    ce oferă dhcp, care poate fi, ori dhcpcd, udhcpc, dhclient sau pump.
  </ti>
</tr>
</table>

<p>
Dacă o comandă returnează eroare, puteţi specifica o comandă de revenire.
Aceasta trebuie să se potrivească în structura configuraţiei exact.
</p>

<p>
Puteţi înlănţui aceste comenzi împreună. Iată unele exemple din lumea reală.
</p>

<pre caption="Exemple de configurare">
<comment># Adăugarea a trei adrese IPv4</comment>
config_eth0=(
  "192.168.0.2/24"
  "192.168.0.3/24"
  "192.168.0.4/24"
)

<comment># Adăugarea unei adrese IPv4 şi a două adrese IPv6</comment>
config_eth0=(
  "192.168.0.2/24"
  "4321:0:1:2:3:4:567:89ab"
  "4321:0:1:2:3:4:567:89ac"
)

<comment># Păstraţi adresa desemnată de kernel, dacă interfaţa nu se activează
# deci desemnează o altă adresă prin DHCP. Dacă DHCP returnează eroare
# atunci adaugă o adresă statică determinată de APIPA</comment>
config_eth0=(
  "noop"
  "dhcp"
)
fallback_eth0=(
  "null"
  "apipa"
)
</pre>

<note>
Când utilizaţi modulul ifconfig şi adăugaţi una sau mai multe adrese,
aliasurile interfeţelor sunt create pentru fiecare adresă suplimentară. Deci,
cu exemplele de mai sus, veţi avea interfeţele eth0, eth0:1 şi eth0:2. Nu
puteţi face nimic special cu aceste interfeţe, deoarece kernel-ul sau alte
aplicaţii vor trata eth0:1 şi eth0:2 ca eth0.
</note>

<impo>
Ordinea comenzilor de revenire este importantă! Dacă nu am specificat opţiunea
"null", atunci comanda "apipa" va fi rulată doar în cazul în care comanda
"noop" returnează eroare.
</impo>

<note>
<uri link="?part=4&amp;chap=3#apipa">APIPA</uri> şi <uri
link="?part=4&amp;chap=3#dhcp">DHCP</uri> sunt tratate ulterior.
</note>

</body>
</section>
<section>
<title>Dependenţe de Reţea</title>
<body>

<p>
Script-urile de iniţializare din <path>/etc/init.d</path> pot depinde de o
anumită interfaţă de reţea sau doar de net. "net" poate fi definit în
<path>/etc/conf.d/rc</path> să aibă o altă însemnătate prin utilizarea
variabilei <c>RC_NET_STRICT_CHECKING</c>.
</p>

<table>
<tr>
  <th>Valoare</th>
  <th>Descriere</th>
</tr>
<tr>
  <ti>nici una</ti>
  <ti>Serviciul net este considerat întotdeauna activ</ti>
</tr>
<tr>
  <ti>no</ti>
  <ti>
    În principiu, aceasta înseamnă că cel puţin un serviciu net.* în afară de
    net.lo trebuie să fie activ. Aceasta poate fi utilizată de utilizatorii
    de sisteme notebook ce deţin o interfaţă wifi şi o interfaţă statică, şi
    doresc ca doar una să fie activă în orice moment au nevoie de o interfaţă
    activă.
  </ti>
</tr>
<tr>
  <ti>lo</ti>
  <ti>
    Aceasta este similară cu opţiunea 'no', numai că şi net.lo este luată în
    considerare. Acest lucru este folositor utilizatorilor cărora nu le pasă
    ca o anume interfaţă de reţea să fie activă la boot.
  </ti>
</tr>
<tr>
  <ti>yes</ti>
  <ti>
    Pentru aceasta, TOATE interfeţele de reţea TREBUIE să fie active pentru
    ca serviciul 'net' să fie considerat activ.
  </ti>
</tr>
</table>

<p>
Dar ce se întâmplă în situaţia în care net.br0 depinde de net.eth0 şi net.eth1?
net.eth1 poate fi un dispozitiv wireless sau ppp ce necesită configurare
înainte să fie adăugate în bridge. Aceasta nu se poate înfăptui dacă
<path>/etc/init.d/net.br0</path> este un link simbolic la net.lo
</p>

<p>
Răspunsul este crearea propriei funcţii depend() în
<path>/etc/conf.d/net</path>
</p>

<pre caption="dependenţă net.br0 în /etc/conf.d/net">
<comment># Puteţi utiliza orice dependenţă (use, after, before) ca în script-urile curente</comment>
depend_br0() {
  need net.eth0 net.eth1
}
</pre>

<p>
Pentru o discuţie mai detaliată despre dependenţă, consultaţi secţiunea <uri
link="/doc/ro/handbook/handbook-x86.xml?part=2&amp;chap=4#doc_chap4">"Scrierea
Script-urilor de Iniţializare"</uri> din Manualul Gentoo.
</p>

</body>
</section>

<section id="variable_name">
<title>Nume de variabile şi valori</title>
<body>

<p>
Numele de variabile este dinamic. Acestea urmează în mod normal, structura de
<c>variabila_${interfata|mac|essid|apmac}</c>. Spre exemplu, variabila
<c>dhcpcd_eth0</c> are ca valoare opţiunile dhcpcd pentru eth0 şi
<c>dhcpcd_essid</c> are ca valoare opţiunile dhcpcd când oricare interfaţă se
conectează la numele essid "essid".
</p>

<p>
Oricum, nu este nici o regulă principală şi rapidă ce defineşte faptul că
numele interfeţelor trebuie să fie ethx. De fapt, multe interfeţe wireless au
numele interfeţelor ca wlanx, rax cât şi ethx. De asemenea, unele interfeţe
definite de utilizator, cum ar fi sisteme bridge, li se poate desemna orice
nume, cum ar fi foo. Mai interesant, dispozitivele wireless Access Point pot
avea nume cu caractere non-alfanumerice conţinute - aceasta este important,
deoarece puteţi configura parametrii de reţea pentru fiecare nume ESSID.
</p>

<p>
Dezavantajul îl reprezintă faptul că Gentoo utilizează variabile bash pentru
reţea - iar bash nu poate utiliza altceva în afara caracterelor alfanumerice
din engleză. Pentru a trece peste această limitare, noi modificăm fiecare
caracter ce nu este unul alfanumeric englezesc, într-un caracter _.
</p>

<p>
Un alt dezavantaj al bash este conţinutul variabilelor - unele caractere
trebuie să fie reprezentate escape. Aceasta se poate efectua prin plasarea
caracterului \ în faţa caracterului ce trebuie reprezentat escape. Mai jos
aveţi o listă a caracterelor ce trebuie reprezentate escape în acest mod:
<c>"</c>, <c>'</c> şi <c>\</c>.
</p>

<p>
În acest exemplu, vom utiliza nume wireless ESSID, deoarece acestea pot conţine
cea mai mare plajă de caractere. Vom utiliza ESSID <c>My "\ NET</c>.
</p>

<pre caption="exemplu de nume de variabilă">
<comment># Aceasta funcţionează, însă domeniul este invalid</comment>
dns_domain_My____NET="My \"\\ NET"

<comment># Comanda de mai sus setează domeniul dns la valoarea My "\ NET când o placă wireless
# se conectează la un dispozitiv AP al cărui nume ESSID este My "\ NET</comment>
</pre>

</body>
</section>
</sections>
