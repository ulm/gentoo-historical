<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/handbook/hb-install-mips-bootloader.xml,v 1.5 2005/04/03 20:21:21 alin Exp $ -->

<sections>

<version>1.7</version>
<date>2005-03-30</date>

<section id="sgi">
<title>Maşinile Silicon Graphics -- Setarea Arcboot</title>
<subsection>
<title>Instalarea arcboot</title>
<body>

<p>
Anterior în acest ghid, v-am explicat modul în care puteţi crea o imagine de
kernel, apoi să o copiaţi în antetul de volum utilizând <c>dvhtool</c>. Există
două mari nereguli cu acest sistem:
</p>

<ul>
  <li>Nu este suportat de toate sistemele SGI</li>
  <li>Necesită un antet de volum semnificant mai mare</li>
</ul>

<p>
Pentru a boot-a maşina, o aplicaţie bootloader, <c>arcboot</c>, a fost
dezvoltată în acest scop. În locul plasării imaginii de kernel direct în
antetul de volum, îl vom păstra în <path>/boot</path> (ce se află pe o partiţie
EXT2/3), unde îl putem regăsi ulterior. Aşadar, primul nostru pas este să
instalăm unele utilitare pe care le vom folosi ulterior...
</p>

<pre caption="Instalarea utilitarelor necesare">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
Comanda anterioară ar trebui să vă instaleze două utilitare, <c>arcboot</c> ce
este stocat în antetul de volum şi ne încarcă imagini de kernel şi
<c>dvhtool</c> ce ne ajută să plasăm <c>arcboot</c> în antetul de volum.
</p>

<p>
Binarul magic pe care-l dorim, se află în <path>/usr/lib/arcboot</path> -- pe
sistemele IP22 (Indy, Indigo 2, Challenge S), acesta va fi denumit
<path>arcboot.ip22</path>. Pentru alte sisteme este valabil în mod similar.
Prima dată, copiem acest fişier în antetul de volum.
</p>

<pre caption="Instalarea arcboot în antetul de volum">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
Apoi, verificăm prezenţa fişierului în antetul de volum.
</p>

<pre caption="Verificarea dacă arcboot a funcţionat corect">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
Veţi putea nota faptul că, în cazul nostru, avem două imagini de kernel
stocate, <path>linux</path> şi <path>newlinux</path>.  Acesta sunt doar
rămăşiţe de pe vremea în care abia începusem să utilizăm <c>arcboot</c>.
Prezenţa acestora nu contează -- atât timp cât <c>arcboot</c> este prezent,
totul este bine.
</note>

</body>
</subsection>

<subsection>
<title>Configurarea arcboot</title>

<body>

<p>
Dacă aţi configurat vreodată Linux Loader (<c>lilo</c>), veţi observa că
<c>arcboot</c> are o sintaxă similară în fişierul de configurare. Reţineţi
totuşi; <c>arcboot</c> se aşteaptă ca fişierul propriu de configurare să se
afle pe o partiţie EXT2/3 ca <path>/etc/arcboot.conf</path>. Cea mai uşoară
soluţie este să vă asiguraţi că <path>/boot</path> este o partiţie EXT2/3 şi că
există un fişier denumit <path>arcboot.conf</path> în directorul
<path>/boot/etc</path>. Un exemplu de fişier de configurare poate fi regăsit în
<path>/etc/arcboot.conf.sample</path>
</p>

<pre caption="Plasarea arcboot.conf în locaţia normală">
<comment>(Creaţi directorul /boot/etc)</comment>
# <i>mkdir /boot/etc</i>

<comment>(Plasaţi fişierul nostru de configurare în directorul destinaţie)</comment>
# <i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(Creaţi un link simbolic înapoi în /etc)</comment>
# <i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(... şi un link simbolic în /boot indicând spre el)</comment>
# <i>(cd /boot; ln -s . boot)</i>
</pre>

<p>
Puteţi edita <path>/etc/arcboot.conf</path> în concordanţă cu preferinţele
proprii. Personal, preferăm crearea a două imagini de kernel: <path>new</path>,
o imagine de kernel proaspăt compilată ce poate sau nu să funcţioneze; şi
<path>working</path>, o imagine de kernel încercată, de încredere. Fişierul
nostru <path>arcboot.conf</path> arată ca în următorul exemplu.
</p>

<pre caption="Examplu de arcboot.conf">
<comment># arcboot.conf</comment>
<comment>#</comment>
<comment># copyright 2002 Guido Guenther &lt;agx@sigxcpu.org&gt;</comment>
<comment>#</comment>
label=working
        image=/vmlinux
        append="root=/dev/sda3"

<comment># versiune de backup</comment>
label=new
        image=/vmlinux-new
        append="root=/dev/sda3"
</pre>

<p>
Odată ce aţi terminat de configurat, mai există doar câteva ajustări pe care
trebuie să le efectuaţi în SGI PROM pentru a determina funcţionarea acestei
configuraţii. Acestea sunt explicate, nu în secţiunea următoare (aceasta este
pentru utiizatorii Cobalt), ci în secţiunea ce îi urmează acesteia, <uri
link="#reboot">Repornirea Sistemului</uri>.
</p>

</body>
</subsection>
</section>

<section id="cobalt">
<title>MicroServer-ele Cobalt -- Setarea CoLo</title>
<subsection>
<title>Instalarea CoLo</title>
<body>

<p>
Pe server-ele Cobalt, aceste maşini deţin o componentă firmware mai puţin
capabilă, instalată pe cip. Componenta BOOTROM a Cobalt este primitivă, în
comparaţie cu SGI PROM şi are unele limitări serioase.
</p>

<ul>
  <li>
    Există o limită de 675 kOceteţi pentru imaginile de kernel. Mărimea curentă
    a versiunii de kernel 2.4 face aproape imposibilă crearea unei imagini de
    kernel de această mărime. Linux 2.6 iese din discuţie în totalitate.
  </li>
  <li>
    Imaginile de kernel pe 64 de biţi nu sunt suportate de componenta firmware
    (deşi acestea sunt la un nivel foarte experimental pe maşinile Cobalt,
    momentan)
  </li>
  <li>
    Aplicatia shell este cel mult primitivă
  </li>
</ul>

<p>
Pentru a trece peste aceste limitări, o aplicaţie firmware alternativă,
denumită <uri link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri>
(Cobalt Loader), a fost dezvoltată. Aceasta este o imagine BOOTROM ce poate fi,
fie înscrisă în cipul flash din server-ul Cobalt, sau încărcată din aplicaţia
firmware existentă.
</p>

<note>
Acest document vă va ghida în configurarea CoLo pentru a fi încărcat de
aplicaţia firmware originală. Acesta este singura modalitate cu adevărat sigură
şi recomandată pentru a seta CoLo.
</note>

<warn>
Dacă doriţi, o puteţi înscrie în server şi să înlocuiţi în totalitate aplicaţia
firmware originală -- oricum, sunteţi pe cont propriu în acest efort. Dacă ceva
nu funcţionează, va trebui să îndepărtaţi fizic componenta BOOTROM şi să o
reprogramaţi singuri cu aplicaţia firmware originală. Dacă nu sunteţi siguri
cum să faceţi acest lucru, atunci <e>NU</e> rescrieţi memoria flash a maşinii.
Nu ne asumăm nici o responsabilitate pentru orice se întâmplă dacă ignoraţi
acest sfat.
</warn>

<p>
Bun, am terminat cu avertismentele, să continuăm cu instalarea CoLo. Mai întâi
începeţi cu instalarea pachetului.
</p>

<pre caption="Instalarea colo">
# <i>emerge colo</i>
</pre>

<p>
Cu acesta instalat (sperăm ca aţi citit mesajele ;-) ar trebui să puteţi să
regăsiţi în directorul <path>/usr/lib/colo</path> două fişiere,
<path>colo-chain.elf</path>: "imaginea de kernel" care va fi încărcată de
aplicaţia firmware şi <path>colo-rom-image.bin</path>: o imagine ROM pentru a o
înscrie în BOOTROM. Începem prin a mount-a /boot şi a stoca copia compresată a
<path>colo-chain.elf</path> în <path>/boot</path> unde sistemul se aşteaptă să
o găsească.
</p>

<pre caption="Plasarea CoLo în locaţia normală">
# <i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>Configurarea CoLo</title>

<body>

<p>
Acum, când sistemul boot-ează pentru prima dată, vom încărca CoLo ce va afişa
un meniu pe terminalul LCD posterior. Prima opţiune (cea considerată, de
asemenea, implicită, după 5 secunde) este să boot-eze pe disc. Sistemul va
încerca, apoi, să mount-eze prima partiţie de Linux găsită, şi să ruleze
script-ul <path>default.colo</path>. Sintaxa este documentată în totalitate în
documentaţia (puteţi arunca o privire în
<path>/usr/share/doc/colo-X.YY/README.shell.gz</path> -- unde X.YY este
versiunea instalată), şi este foarte simplă.
</p>

<note>
Doar un sfat: la instalarea kernel-ului, eu creez, de obicei, două imagini de
kernel, <path>kernel.gz.working</path> -- o imagine de kernel cunoscută ca
fiind funcţională, şi <path>kernel.gz.new</path> -- o imagine de kernel ce abia
a fost compilată. Puteţi, fie să utilizaţi link-uri simbolice care să indice
către imaginile de kernel "new" şi "working", sau pur şi simplu să redenumiţi
imaginile de kernel.
</note>

<pre caption="Un exemplu simplu de default.colo">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo va refuza să încarce un script ce nu începe cu linia <c>#:CoLo:#</c>.
Gândiţi-vă la aceasta ca un echivalent a utilizării <c>#!/bin/sh</c> în
aplicaţii script pentru shell.
</note>

<p>
Este, de asemenea, posibil să vi se pună o întrebare, cum ar fi care imagine de
kernel şi configuraţie doriţi să încărcaţi, cu un timp de expirare implicit.
Aceasta este configuraţia utilizată pe server-ele Cobalt personale:
</p>

<impo>
Notaţi faptul că trebuie să utilizaţi CoLo v1.12 sau v1.13 pentru a utiliza
comanda <c>menu</c>. Următorul exemplu nu va funcţiona cu v1.11.
</impo>

<impo>
Comanda <c>menu</c> a fost înlocuită de comanda <c>select</c> în CoLo v1.14.
Dacă aţi instalat o versiune ulterioară manual, consultaţi fişierul
<path>menu.colo</path> din subdirectorul <path>examples</path> a pachetului de
distribuţie CoLo.
</impo>

<pre caption="Configuraţie bazată pe meniuri">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
menu "Which Kernel?" 50 Working working New new
lcd "Loading Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
Script-ul de mai sus îi cere utilizatorului numele imaginii de kernel pe care
doreşte să o încarce la boot (fie New sau Working), apoi încarcă
<path>vmlinux.gz.new</path> sau <path>vmlinux.gz.working</path>, în funcţie de
selecţie. Dacă selectarea nu este efectuată în 5 secunde (50/10 unităţi de
secundă) va boot-a prima opţiune.
</p>
</body>

</subsection>
</section>

<section>
<title>Pregătirea Consolei Seriale</title>
<subsection>
<body>

<p>
Bun, instalarea Linux, în stadiul actual, va boot-a fără probleme, dar
presupune că veţi fi log-aţi pe un terminal fizic. Pe maşinile Cobalt, această
presupunere nu este una bună -- nu există terminal fizic.
</p>

<note>
Aceia ce nu deţin luxul de a suporta framebuffer, pot omite această secţiune,
dacă doresc.
</note>

<p>
Mai întâi, rulaţi un editor şi modificaţi fişierul <path>/etc/inittab</path>.
În partea de jos a fişierului, veţi regăsi ceva asemănător cu:
</p>

<pre caption="Configuraţia inittab">
<comment># CONSOLA SERIALA</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALE</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># Acţiunea în cazul "salutului cu trei degete".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
Mai întâi, decomentaţi linia <c>c0</c>. Implicit, este setat să utilizeze un
terminal cu o viteză de trasmisie de 9600 bps. Pe server-ele Cobalt ar trebui
să schimbaţi această rată la 115200 pentru a fi egală cu rata decisă de BOOT
ROM. Aşa arată această secţiune pe maşina mea. Pe o maşină mai primitivă (spre
ex. server-ele Cobalt), recomandăm, de asemenea, comentarea liniilor în
legătură cu terminalele locale (de la <c>c1</c> la <c>c6</c>), deoarece
aceastea obişnuiesc să aibă comportamente ciudate în momentul în care nu pot
accesa <path>/dev/ttyX</path>.
</p>

<pre caption="Exemplu de parte din inittab">
<comment># CONSOLA SERIALA</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALE -- Acestea sunt nefolositoare pe o maşina qube</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respawn:/sbin/agetty 38400 tty5 linux</comment>
<comment>#c6:12345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
Acum, în cele din urmă... va trebui să-i specificăm sistemului că portul serial
local poate fi considerat cu încredere un terminal securizat. Fişierul ce va
trebui modificat este <path>/etc/securetty</path>. Acesta conţine o listă de
terminale pe care sistemul de consideră de încredere. Pur şi simplu, adăugăm
încă două linii, permiţând liniei seriale să fie utilizată pentru login pentru
utilizatorul <c>root</c>.
</p>

<pre caption="Activarea posibilităţii de login pentru root pe consola serială">
<comment>(/dev/ttyS0 -- numele tradiţional pentru primul port serial)</comment>
# <i>echo 'ttyS0' >> /etc/securetty</i>

<comment>(În ultimul timp, Linux îl denumeşte, de asemenea, /dev/tts/0 -- deci îl vom
adăuga şi pe acesta)</comment>
# <i>echo 'tts/0' >> /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>Repornirea Sistemului</title>
<subsection>
<body>

<p>
Ieşiţi din mediul chroot şi demount-aţi toate partiţiile mount-ate. Apoi
tastaţi comanda magică pe care aţi aşteptat-o: <c>reboot</c>.
</p>

<pre caption="Ieşirea din chroot, demount-area tuturor partiţiilor şi repornirea">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Utilizatorii Cobalt:</e> Restul acestei secţiuni acoperă modul de
configurare a SGI PROM pentru a boot-a <c>arcboot</c> şi a încărca Linux.
Această operaţiune nu este valabilă pentru configurarea dispozitivelor server
Cobalt. De fapt, aţi terminat -- nu mai este necesară nici o configurare pentru
a efectua boot pentru prima dată, puteţi trece la secţiunea următoare: <uri
link="?part=1&amp;chap=11">Finalizarea Instalării Gentoo</uri>
</note>

</body>
</subsection>
</section>
<section>
<title>Optimizarea SGI PROM</title>
<subsection>
<body>

<p>
După ce aţi repornit, navigaţi în <e>System Maintenance Menu</e> şi selectaţi
<e>Enter Command Monitor</e> (<c>5</c>). Dacă doriţi să testaţi noua dvs.
instalare Gentoo, trebuie doar să rulaţi <c>boot -f &lt;kernel name&gt;</c>.
Pentru ca sistemul să boot-eze mereu în instalarea Gentoo, trebuie să setaţi
unele variabile în MIPS PROM: 
</p>

<pre caption="Configurarea PROM pentru a boot-a Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor

Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.

<comment>(&lt;root device&gt; = Partiţia root a Gentoo, ex. /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>

<comment>(Pentru a afişa imaginile de kernel disponibile, tastaţi "ls")</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>

<comment>(Definiţi parametrii de kernel pe care doriţi să-i utilizaţi)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>

<comment>(Introduceţi locaţia zonei Volume Header)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>

<comment>(Boot-area automată în Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>

<comment>(Setarea zonei de fus orar)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>

<comment>(Utilizaţi consola serial - utilizatorii cu adaptoare grafice ar trebui să introducă "g" în loc de "d1" (unu))</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>

<p>
Acum sunteţi pregătiţi să utilizaţi Gentoo! Boot-aţi în instalarea dvs. Gentoo
şi terminaţi cu <uri link="?part=1&amp;chap=11">Finalizarea Instalării dvs.
Gentoo</uri>.
</p>

</body>
</subsection>
</section>
</sections>
