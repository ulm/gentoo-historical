<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/devfs-guide.xml,v 1.6 2005/09/16 04:53:37 alin Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ro/devfs-guide.xml" lang="ro">
<title>Ghid Device File System</title>
<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Corector">
  <mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Translator">
  <mail link="adiroiban@gmail.com">Adi Roiban</mail>
</author>

<abstract>
În acest ghid veţi găsi informaţii despre ceea ce este devfs şi cum să lucraţi
cu el.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.6</version>
<date>2005-07-21</date>

<chapter>
<title>Ce este devfs?</title>
<section>
<title>Zilele (bune?) de demult</title>
<body>

<warn>
devfs este <e>depreciat</e> şi a fost îndepărtat din ramura stabilă 2.6 în
versiunea 2.6.13. Utilizatorii versiunilor de kernel 2.6 sunt, astfel, sfătuiţi
să comute la udev. Pentru mai multe informaţii despre udev, vă rugăm să
consultaţi <uri link="/doc/ro/udev-guide.xml">Ghidul Gentoo pentru udev</uri>.
</warn>

<p>
Implementarea tradiţională Linux oferă utilizatorilor un director abstract
denumit <path>/dev</path>. În interiorul acestui director, utilizatorul poate
găsi <e>noduri dispozitiv</e>, fişiere speciale care reprezintă dispozitivele
din interiorul sistemului. De exemplu, <path>/dev/hda</path> reprezintă primul
dispozitiv IDE din sistem. Oferind fişiere dispozitiv utilizatorilor, ei pot
crea programe care lucrează cu componentele hardware ca şi cum ar fi un fişier
obişnuit în loc de a folosi API-uri speciale.
</p>

<p>
Fişierele disozitivelor sunt împărţite în două grupe, numite dispozitive
<e>caracter</e> şi dispozitive <e>bloc</e>. În a prima grupă intră, de obicei,
dispozitivele ale căror operaţii de citire/scriere nu folosesc zone temporare
de memorie (buffers). Ambele dispozitive pot fi citite câte un caracter o dată,
sau în blocuri. Aşadar, nomenclatura ar putea suna confuz şi de fapt este
greşită.
</p>

<p>
Dacă aruncaţi o privire asupra unui fişier dispozitiv, veţi putea observa ceva
similar cu:
</p>

<pre caption="Vizualizarea informaţiilor despre un fişier dispozitiv">
# <i>ls -l /dev/hda</i>
brw-rw----    1 root     disk       3,   0 Jul  5  2000 /dev/hda
</pre>

<p>
În exemplul anterior am văzut ca <path>/dev/hda</path> este un dispozitiv bloc.
Oricum, mai important este faptul că are două numere speciale ataşate: <b>3,
0</b>. Această pereche este denumită pereche <e>major-minor</e>. Este
folosită de kernel pentru a creea o legătură între fişierul dispozitiv şi
dispozitivul real. Majorul corespunde unui dispozitiv, minorul unui
subdispozitiv. Pare confuz? Nu este.
</p>

<p>
Două exemple ar fi <path>/dev/hda4</path> şi <path>/dev/tty5</path>. Primul
dispozitiv corespunde partiţiei a patra de pe primul dispozitiv IDE. Perechea
lui major-minor este <b>3, 4</b>. Cu alte cuvinte, minorul corespunde
partiţei pe când majorul corespunde dispozitivului. Al doilea exemplu are
<b>4, 5</b> ca pereche major-minor. În aces caz majorul corespunde
dispozitivului reprezentat de terminalul în timp ce minorul corespunde
numărului terminalului (în cazul nostru al cincilea terminal).
</p>

</body>
</section>
<section>
<title>Problemele</title>
<body>

<p>
Dacă faceţi o scurtă verificare în <path>/dev</path>, veţi observa că nu doar
toate dispozitivele dumneavoastră sunt prezente, ci <e>toate</e> dispozitivele
pe care vi le-aţi putea imagina. Cu alte cuvinte, aveţi fişiere dispozitiv
pentru dispozitive pe care nu le aveţi. Gestionarea unui asemenea grup de
dispozitive este cel puţin greoaie. Imaginaţi-vă că trebuie să schimbaţi
permisiunile tuturor fişierelor dispozitiv cărora le corespune un dispozitiv
din sitemul dumneavoastră, dar lasând celelalte fişiere intacte.
</p>

<p>
Când adăugaţi o nouă componentă hardware sistemului dumneavoastră, iar această
componentă nu are creată anterior un fişier dispozitiv, va trebui să creaţi un
asemenea fişier. Utilizatori avansaţi ştiu că acest lucru se poate face cu
comanda <c>./MAKEDEV</c> din directorul <path>/dev</path>, dar dumneavoastră o
să ştiţi ce fişier dispozitiv trebuie creeat?
</p>

<p>
Când aveţi un program care interacţionează cu hardware-ul folosind fişierele
dispozitiv, nu puteţi avea partiţia de root mount-ată doar pentru citire, în
timp ce nu există nici o necesitate ca aceasta să fie mount-ată pentru citire
şi scriere. Şi nu puteţi avea <path>/dev</path> pe o partiţie separată,
deoarece <c>mount</c> are nevoie de <path>/dev</path> pentru a putea mount-a
partiţii.
</p>

</body>
</section>
<section>
<title>Soluţiile</title>
<body>

<p>
După cum vă puteţi imagina, programatorii kernel-ului au găsit o sumedenie de
soluţii pentru problemele menţionate anterior. Oricum, multe dintre ele au alte
scăpări după cum este descris în
<uri>http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why</uri>.
Nu o să vorbim despre aceste implementări, ci să ne concentrăm atenţia asupra
implemetării care a ajuns în sursele de kernel: devfs.
</p>

</body>
</section>
<section>
<title>devfs ca un câştigător absolut</title>
<body>

<p>
devfs abordează toate probleme menţionate. El oferă utilizatorului doar
dispozitivele existente, adaugă noile dispozitive când ele sunt găsite, şi face
posibilă mount-area sistemului de fişiere rădăcină doar pentru citire.
Abordează mult mai multe probleme, pe care nu le-am discutat deoarece sunt mai
puţin interesante pentru utilizatori...
</p>

<p>
De exemplu, cu devfs nu trebui să vă ingrijoraţi de perechea major/minor. Ea
este în continuare suportată (pentru compatibilitate anterioară), dar nu mai
este necesară. Aces lucru face posibil ca Linux să suportă chiar mai multe
dispozitive, din moment ce nu mai există limite (numerele întotdeauna au limite
:)
</p>

<p>
Totuşi, devfs are problemele sale; pentru utilizatorii de rând acestea nu sunt
chiar vizibile, dar pentru programatorii de kernel probleme sunt îndeajuns de
mari pentru a marca devfs ca <e>învechit</e> în favoarea lui <uri
link="udev-guide.xml">udev</uri>, pe care Gentoo îl suportă şi îl foloseşte
implicit pe majoritatea arhitecturilor începând cu versiunea 2005.0 în
momentul utilizării unui kernel 2.6.
</p>

<p>
Pentru mai multe informaţii, cum ar fi motivul pentru care devfs a fost marcat
ca învechit, puteţi citi documentul despre <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ">Întrebări
Frecvente despre udev</uri> şi <uri
link="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev_vs_devfs">documentul
udev contra devfs</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Navigarea prin directorul dispozitivelor</title>
<section>
<title>Directoarele</title>
<body>

<p>
Unul dintre primele lucruri pe care probabil le-aţi observat este faptul că
devfs foloseşte directoare pentru a grupa dispozitivele. Aces lucru uşurează
utilizarea lor, deoarece acum toate dispozitivele similare se află într-un
director comun.
</p>

<p>
De exemplu, toate dispozitivele IDE se găsesc în directorul
<path>/dev/ide/</path>, iar cele SCSI se găsesc în <path>/dev/scsi/</path>.
Discurile SCSI şi IDE sunt considerate de acelaşi tip, acest lucru însemnând că
ambele au aceeaşi structură de subdirectoare. 
</p>

<p>
Discurile IDE and SCSI sunt controlate de un adaptor (pe placa de baza sau pe o
placă separată), numită <e>gazdă</e> (host). Orice adaptor are un număr de
canale. Un canal este denumit <e>magistrală</e> (bus). Pe fiecare canal, puteţi
avea mai mulţi identificatori. Un asemenea identificator corespunde unui disc.
Acest identificator este denimit <e>ţintă</e> (target). Unele dispozitive SCSI
pot avea mai multe valori lun (<e>Logical Unit Numbers</e>), de exemplu
dispozitive care accesează mai multe medii simultan (hi-end tapedrives). De
cele mai multe ori o să aveţi o singură valoare lun, <path>lun0/</path>.
</p>

<p>
Aşa că, dacă <path>/dev/hda4</path> a fost folosit anterior, acum avem
<path>/dev/ide/host0/bus0/target0/lun0/part4</path>. Acesta este mult mai uşor
... nu, nu vă certaţi cu mine ... <e>este</e> mai uşor... ah oricum! :)
</p>

<note>
Puteţi folosi de asemenea mai multe denumiri de fişiere dipozitiv în tradiţia
Unix, cum ar fi <path>c0b0t0u0p2</path>. Ele pot fi găsite
în<path>/dev/ide/hd</path>, <path>/dev/scsi/hd</path> etc.
</note>

<p>
Pentru a vă crea o idea asupra directorelor, aceasta este o listă a
directoarelor pe care le am pe sistemul meu laptop:
</p>

<pre caption="Directoarele din /dev">
cdroms/     cpu/        discs/          floppy/
ide/        input/      loop/           misc/
netlink/    printers/   pts/            pty/
scsi/       sg/         shm/            sound/
sr/         usb/        vc/             vcc/
</pre>

</body>
</section>
<section>
<title>Compatibilităţi anterioare folosind devfsd</title>
<body>

<p>
Folosirea noii scheme pare uşoară, dar multe utilitare şi programe folosesc
vechea schemă. Pentru a vă asigura că nimic nu se va strica a fost creat
<c>devfsd</c>. Acest daemon crează legături simbolice cu numele vechi către
noile fişiere dispozitiv.
</p>

<pre caption="Legăturile simbolice create">
$ <i>ls -l /dev/hda4</i>
lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -> ide/host0/bus0/target0/lun0/part4
</pre>

<p>
Cu <c>devfsd</c>, puteţi de asemenea să atribuiţi permisiuni, să creaţi fişiere
dispozit noi, să definiţi acţiuni etc. Toate aceste lucruri sunt descrise în
capitolul următor.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Administrarea arborelui de dispozitive</title>
<section>
<title>Repornirea devfsd</title>
<body>

<p>
Când modificaţi fişierul <path>/etc/devfsd.conf</path>, nu trebuie să reporniţi
sistemul. În funcţie de ce doriţi, puteţi folosi unul dintre următoarele
semnale:
</p>

<p>
<b>SIGHUP</b> va face ca <c>devfsd</c> să recitească fişierul de configuraţie,
reîncarce obiectele partajate şi să genereze evenitemul REGISTER pentru fiecare
nod terminal din arborele fişierelor dispozitiv.
</p>

<p>
<b>SIGUSR1</b> va face acelaşi lucru, dar nu va genera evenimentele REGISTER.
</p>

<p>
Pentru a trimite un semnal, folosiţi <c>kill</c> sau <c>killall</c>:
</p>

<pre caption="Trimitrea unui semnal SIGHUP către devfsd">
# <i>kill -s SIGHUP `pidof devfsd`</i>
<comment>sau</comment>
# <i>killall -s SIGHUP devfsd</i>
</pre>

</body>
</section>
<section>
<title>Înlăturarea legăturilor simbolice de compatibilitate</title>
<body>

<warn>
Momentan, Gentoo nu poate funţiona fără legăturile simbolice de
compatibilitate.
</warn>

<p>
Dacă doriţi ca legăturile simbolice de compatibilitate care vă încarcă
<path>/dev</path> să fie înlăturate din sistemul dumneavoastră Gentoo (Gentoo
le activează implicit), modificaţi <path>/etc/devfsd.conf</path> şi înlăturaţi
următoarele doua linii:
</p>

<pre caption="/etc/devfsd.conf pentru compatibilitate anterioară">
<comment># Comentaţi următoarele două linii pentru a înlătura
legăturile simbolice</comment>
REGISTER        .*  MKOLDCOMPAT
UNREGISTER      .*  RMOLDCOMPAT
</pre>

<p>
Trebui să reporniţi calulatorul pentru ca schimbarea să aibă efect.
</p>

</body>
</section>
<section>
<title>Dezactivarea funcţiei de autoîncărcare</title>
<body>

<p>
Când încărcaţi un modul, devfs va crea automat un fişier dispozitiv. Dacă nu
doriţi acest comportament, înlăturaţi următoarea linie din
<path>/etc/devfsd.conf</path>:
</p>

<pre caption="/etc/devfsd.conf, funcţia de autoîncărcare">
LOOKUP      .*  MODLOAD
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Aspecte legate de permisiuni</title>
<section>
<title>Definirea/schimbarea permisiunilor cu devfsd</title>
<body>

<note>
Aceste instrucţiuni sunt valide atâta timp cât pam_console este dezactivat în
<path>/etc/pam.d/system-auth</path>. Dacă aţi activat pam_console în acest
fişier, atunci PAM decide asupra permisiunilor.
</note>

<p>
Daca chiar doriţi să modificaţi permisiunile folosind
<path>/etc/devfsd.conf</path>, atunci folosiţi sintaxa din următorul exemplu:
</p>

<pre caption="Permisiuni în /etc/devfsd.conf">
REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660
</pre>

<p>
Al doilea câmp este grupul dispozitivului, începînd cu <path>/dev</path>. Este
o expresiu regulată, însemnînd că puteţi selecta mai multe fişiere dispozitiv
într-o singură definiţie.
</p>

<p>
Al patrulea câmp specifică proprietarul fişierului dispozitiv iar al cincilea
conţine permisiunile fişierului dispozitiv, respectiv.
</p>

</body>
</section>
<section>
<title>Schimbarea permisiunilor manual şi folosirea devfs pentru a le salva</title>
<body>

<p>
Acesta este comportamentul implicit pentru Gentoo: dacă utilizaţi <c>chown</c>
(CHange OWNer - schimbarea proprietarului) şi <c>chmod</c> (CHange MODe -
schimbarea modului) pentru unele fişiere dispozitiv, <c>devfsd</c> va salva
informaţiile atunci când opriţi sistemul. Aces lucru de datorează faptului că
fişierul <path>/etc/devfsd.conf</path> conţine următoarele linii:
</p>

<pre caption="/etc/devfsd.conf pentru salvarea permisiunilor">
REGISTER        ^pt[sy]/.*   IGNORE
CHANGE          ^pt[sy]/.*   IGNORE
CREATE          ^pt[sy]/.*   IGNORE
DELETE          ^pt[sy]      IGNORE
REGISTER        ^log         IGNORE
CHANGE          ^log         IGNORE
CREATE          ^log         IGNORE
DELETE          ^log         IGNORE
REGISTER        .*           COPY    /lib/dev-state/$devname $devpath
CHANGE          .*           COPY    $devpath /lib/dev-state/$devname
CREATE          .*           COPY    $devpath /lib/dev-state/$devname
DELETE          .*           CFUNCTION GLOBAL unlink
/lib/dev-state/$devname
RESTORE         /lib/dev-state
</pre>

<p>
Cu alte cuvinte, fişierele dispozitiv modificate sunt copiate în
<path>/lib/dev-state</path> imediat cum se întâmplă modificarea şi sunt copiate
inapoi în <path>/dev</path> când porniţi sistemul.
</p>

<p>
O altă posibilitate ar fi să mount-aţi <path>/lib/dev-state</path> în
<path>/dev</path> în momentul pornirii sistemului. Pentru a efectua acest
lucru, trebui să vă asiguraţi că devfs nu este montat automat (acest lucru
poate însemna recompilarea kernelului) şi că  <path>/dev/console</path> există.
Apoi, undeva pe la începutul scriptului de iniţiere a sistemului adăugaţi:
</p>

<pre caption="Mount-area /lib/dev-state peste /dev">
mount --bind /dev /lib/dev-state
mount -t devfs none /dev
devfsd /dev
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Resurse</title>
<section>
<body>

<p>
Pentru mai multe informaţii despre devfs, verificaţi următoarele resurse.
</p>

<p>
Pagina man a devfsd.conf explică sintaxa fişierului
<path>/etc/devfsd.conf</path>. Pentru a o putea vedea tastaţi <c>man
devfsd.conf</c>.
</p>

<p>
Documentul <uri
link="http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html">Întrebări
Frecvente despre devfs</uri> explică totul despre devfs. De asemenea conţine
informaţii despre structura interioară a devfs şi cum aplicaţiile driver pot
comunica cu devfs.
</p>

<p>
Pe <uri link="http://www.linuxjournal.com">LinuxJournal</uri> exista un articol
interesant despre <uri
link="http://www.linuxjournal.com/article.php?sid=6035">devfs pentru Management
şi Administrare</uri>.
</p>

<p>
Daniel Robbins a scris câteva articole pentru IBM's DeveloperWorks despre
sisteme de fişiere avansate. Trei dintre ele sunt despre devfs:
</p>

<ul>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs4/">
    Introducere în devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs5/">
    Setarea sistemului devfs</uri>
  </li>
  <li>
    <uri link="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">
    Implementarea sistemului devfs</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
