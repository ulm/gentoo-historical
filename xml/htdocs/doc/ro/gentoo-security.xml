<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/gentoo-security.xml,v 1.2 2005/05/05 16:40:39 alin Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/ro/gentoo-security.xml" lang="ro">
<title>Ghid pentru Securitate în Gentoo Linux</title>
<author title="Author">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Editor">
  <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
</author>
<author title="Translator iniţial">
  <mail link="eric@dahas.ro">Laurenţiu Crăciun</mail>
</author>
<author title="Translator">
  <mail link="alin@gentoo.org">Alin Dobre</mail>
</author>

<abstract>
Acesta este un ghid pas-cu-pas pentru securizarea Gentoo Linux.
</abstract>

<license/>

<version>0.4.47</version>
<date>2005-05-03</date>

<chapter>
<title>Introduction</title>
<section>
<body>

<p>
Acest ghid este destinat utilizatorilor ce folosesc Gentoo Linux într-un mediu
server sau doar celor care doresc o securitate sporită.
</p>

<note>
Dacă sunteţi interesat pentru chiar mai multe materiale despre securitate în
Gentoo după consultarea acestui ghid, atunci trebuie să aruncaţi o privire în
documentaţie <uri link="http://www.gentoo.org/proj/en/hardened/">Proiectului
Hardened Gentoo</uri>
</note>

</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Preocupări Înainte de Instalare</title>
<section>
<title>Securitatea Fizică</title>
<body>

<p>
Nu contează câte protecţii implementaţi, pentru că acestea pot fi uşor dejucate
de un atacator ce deţine acces fizic la maşina dvs. În ciuda acestora, există
un număr de măsuri de precauţie ce pot fi aplicate pentru a oferi un grad de
securitate împotriva atacatorilor ce deţin acces fizic la maşina dvs. Plasarea
sistemelor dvs. hardware într-un loc încuiat previne ca atacatorul să îl
deconecteze şi să îl sustragă. Încuierea maşinii este, de asemenea, o idee bună
pentru a vă asigura faptul că atacatorul nu va pleca împreună cu discul dvs.
Pentru a preveni un atacator să boot-eze de pe alt disc, şi să vă modifice
permisiunile şi restricţiile de login, încercaţi să setaţi discul ca primul
dispozitiv de boot din BIOS şi să setaţi o parola pentru BIOS. Este, de
asemenea, important să setaţi o parolă de boot pentru LILO sau GRUB, pentru a
preveni un utilizator cu caracter maliţios în a-şi obţine accesul complet în
sistemul dvs. Aceasta este acoperită mai în detaliu în Capitolul 3, la <uri
link="#passwording_GRUB">Setarea unei parole pentru GRUB</uri>  şi and <uri
link="#passwording_LILO">Setarea unei parole pentru LILO</uri>.
</p>

</body>
</section>
<section>
<title>Planificarea Aplicaţiilor Daemon/Serviciilor</title>
<body>
<p>
Începeţi prin documentarea serviciilor pe care această maşină ar trebui să le
ruleze. Aceasta vă va ajuta să compuneţi o schemă de partiţionare mai bună
pentru sistemul dvs. şi să vă permită să vă planificaţi măsurile de securitate.
Bineînţeles, acest lucru nu este necesar dacă maşina serveşte unui scop simplu,
cum ar fi un desktop sau un firewall dedicat. În aceste cazuri, nu ar trebui să
rulaţi <e>nici un</e> serviciu, exceptând, poate, sshd.
</p>
<p>
Această listă poate fi utilizată pentru a ajuta administrarea sistemului. Prin
păstrarea unei liste curente a informaţiilor despre versiuni, vă va fi mult mai
uşor să păstraţi totul la zi dacă o vulnerabilitate este descoperită pentru una
din aplicaţiile dvs. daemon.
</p>

</body>
</section>
<section>
<title>Scheme de Partiţionare</title>
<body>

<p>
Reguli de partiţionare:
</p>

<ul>
<li>
  Orice structură de directoare în care un utilizator de sistem ar trebui să
  poată scrie (spre ex. <path>/home</path>, <path>/tmp</path>) ar trebui să se
  afle pe o partiţie separată şi să utilizaţi cotele de disc. Aceasta reduce
  riscul ca utilizatorul să vă umple întregul sistem de fişiere. Portage
  utilizează <path>/var/tmp</path> pentru a compila fişierele, deci acea
  partiţie trebuie să fie mare.
</li>
<li>
  Orice structură de directoare pe care plănuiţi să instalaţi aplicaţii ce nu
  aparţin distribuţiei ar trebui să se afle pe o partiţie separată. Conform
  <uri link = "http://www.pathname.com/fhs/">Standardului Ierarhiei
  Fişierelor</uri>, acesta este <path>/opt</path> sau <path>/usr/local</path>.
  Dacă acestea sunt partiţii separate, nu vor fi şterse în momentul
  reinstalării sistemului.
</li>
<li>
  Pentru o mai bună securitate, datele statice pot fi stocate pe o partiţie
  separată ce este mount-ată doar pentru citire (read-only). Pentru cei cu
  adevărat paranoici, încercaţi să utilizaţi medii doar citibile, cum ar fi
  mediile CDROM.
</li>
</ul>

</body>
</section>
<section>
<title>Utilizatorul root</title>
<body>

<p>
Utilizatorul 'root' este cel mai vital utilizator din sistem şi nu trebuie
folosit în nici un scop decât atunci când este neapărat necesar. Dacă un
atacator obţine acces root, singura modalitate prin care mai puteţi avea
încredere în sistem este reinstalarea.
</p>

<p>
Reguli de aur pentru 'root'
</p>

<ul>
<li>
  Întotdeauna creaţi un utilizator de sistem pentru întrebuinţarea zilnică şi,
  dacă acest utilizator necesită acces la root, adăugaţi utilizatorul in grupul
  'wheel'. Aceasta face posibil ca un utilizator obişnuit să efectueze
  <c>su</c> pentru root.
</li>
<li>
  Niciodată nu rulaţi X sau orice altă aplicaţie ca root. root ar trebui să fie
  utilizat doar în cazul în care absolut necesar acest lucru; dacă există o
  vulnerabilitate în aplicaţia ce rulează ca utilizator, un atacator obţine
  doar acces utilizator. Dar, dacă aplicaţie rulează ca root, atacatorul obţine
  acces root.
</li>
<li>
  Întotdeauna utilizaţi căi absolute în timp ce sunteţi autentificat ca root
  (sau întotdeauna folosiţi <c>su -</c>, ce înlocuieşte variabilele de mediu
  ale utilizatorului cu cele pentru root, în timp ce sunteţi sigur că variabila
  <c>PATH</c> pentru root conţine doar directoare protejate, cum ar fi
  <path>/bin</path> şi <path>/sbin</path>). Este posibil să fie păcălit
  utilizatorul root în rularea unei alte aplicaţii decât cea care o doreşte.
  Dacă variabila <c>PATH</c> a utilizatorului root este protejată sau acesta
  utilizează numai căi absolute, ne putem asigura că această problemă nu se va
  întâmpla.
</li>
<li>
  Dacă un utilizator doreşte să ruleze doar câteva comenzi ca root, în locul
  acţiunilor obişnuite ale utilizatorului root, luaţi în considerare utilizarea
  <c>sudo</c> în loc. Trebuie doar să fiţi atenţi cui daţi acces, de asemenea.
</li>
<li>
  Niciodată nu părăsiţi terminalul când sunteţi autentificaţi ca root.
</li>
</ul>

<p>
Gentoo are o protecţie implicită împotriva utilizatorilor de sistem obişnuiţi
ce încearcă să execute <c>su</c> către root. Setările PAM implicite necesită ca
un utilizator să fie membru al grupului "wheel" pentru a putea efectua
<c>su</c>.
</p>

</body>
</section>
<section id = "security_policies">
<title>Politici de Securitate</title>
<body>

<p>
Există mai multe motive pentru care trebuie să concepeţi o politică de
securitate pentru sistemele şi reţeaua dvs.
</p> 

<ul>
<li>
  O politică solidă vă permite să conturaţi securitatea ca un "sistem" decât
  doar un set de diferite caracteristici. Spre exemplu, fără o politică, un
  administrator poate decide să inchidă accesul telnet, pentru că transmite
  parole necriptate, dar să lase deschis accesul ftp, ce deţine aceeaşi
  slăbiciune. O politică bună de securitate vă permite să identificaţi măsurile
  ce merită aplicate şi cele care nu.
</li>
<li>
  Pentru a diagnostica problemele, conduce audituri sau depista intruşii, este
  posibil să trebuiască să interceptaţi traficul prin reţea, să inspectaţi
  istoricul autentificărilor şi comenzilor utilizatorilor şi să analizaţi
  directoarele home. Fără ca dvs. să conturaţi aceste acţiuni prin tipărire şi
  să îi înştiinţaţi pe utilizatori despre ele, acestea pot fi chiar ilegale şi
  vă pot pune pe <e>dvs.</e> în pericol.
</li>
<li>
  Conturile de utilizator compromise reprezintă unele din cele mai comune
  ameninţări securităţii unui sistem. Fără a explica utilizatorilor importanţa
  securităţii şi cum să practice o securitate solidă (spre ex. să nu-şi scrie
  parolele pe un bilet Post-It lipit pe biroul acestora), este foarte puţin
  probabil că dvs. veţi putea spera în securizarea conturilor de utilizator.
</li>
<li>
  O reţea şi structură de sisteme bine documentată vă va ajuta, alături de
  examinatorii juridici pentru aplicarea legilor, dacă sunt necesari, în
  urmărirea intruziunii şi identificarea punctelor slabe după fapt. Un afiş
  despre "probleme" pentru politica de securitate, prin care să afirmaţi că
  sistemul dvs. este o reţea privată şi orice acces neautorizat este interzis,
  vă vor ajuta să asiguraţi posibilitatea de a acţiona în judecată un intrus,
  după ce este prins.
</li>
</ul>

<p>
Nevoia unei securităţi solide este, sperăm, acum, mult mai clară.
</p>

<p>
Politica efectivă, este un document, sau mai multe documente, ce evidenţiază
caracteristicile reţelei şi ale sistemului (cum ar fi serviciile oferite),
utilizarea acceptabilă şi utilizarea interzisă, "practici solide" de
securitate, şi aşa mai departe. Toţi utilizatorii ar trebui înştiinţaţi atât de
politica dvs. de securitate, cât şi de modificările aduse acesteia în vederea
actualizării. Este important să vă acordaţi timp pentru a ajuta utilizatorii
despre politica dvs., precum şi motivul pentru care politica trebuie semnată
sau ce se întâmplă dacă acţionează împotriva politicii (politica trebuie să
precizeze şi acest aspect). Aceasta trebuie repetată o dată pe an, deoarece
politica se poate modifica (dar şi ca o reamintire a politicii utilizatorului).
</p>

<note>
Creaţi politici ce sunt uşor de citit şi foarte precise pentru fiecare subiect.
</note>

<p>
O politică de securitate ar trebui să conţină, cel puţin, următoarele subiecte:
</p>

<ul>
<li>Utilizare acceptabilă
  <ul>
  <li>Aplicaţii Screen saver</li>
  <li>Manipularea parolei</li>
  <li>Descărcarea şi instalarea aplicaţiilor</li>
  <li>Informaţii ce menţionează că utilizatorii sunt monitorizaţi</li>
  <li>Utilizarea de aplicaţii anti-virus</li>
  </ul>
</li>
<li>Manipularea informaţiei sensibile (în orice formă scrisă, hârtie sau format digital)
  <ul>
  <li>Curăţarea biroului şi încuierea informaţiilor confidenţiale</li>
  <li>Oprirea sistemului PC înainte de a părăsi spaţiul</li>
  <li>Utilizarea encripţiei</li>
  <li>Manipularea cheilor colegilor de încredere</li>
  <li>Manipularea materialului confidenţial în călătorii</li>
  </ul>
</li>
<li>Manipularea echipamentului de calculator în călătorii
  <ul>
  <li>Manipularea sistemului laptop în călătorii şi staţionările la hoteluri</li>
  </ul>
</li>
</ul>

<p>
Utilizatori diferiţi pot necesita nivele sau tipuri diferite de acces, deci
politica dvs. poate varia în acest pentru a acoperi toate aceste situaţii.
</p>

<p>
Politica de securitate poate deveni foarte mare în conţinut, iar informaţiile
vitale pot fi uşor uitate. Politica pentru personalul IT poate conţine
informaţii ce sunt confidenţiale pentru utilizatorul obişnuit, fiind vitală
împărţirea acesteia în mai multe politici mai mici; spre ex. Politica de
Utilizare Acceptabilă, Politica pentru parole, Politica pentru Mesageria
Electronică şi Politica pentru Accesul la Distanţă.
</p>

<p>
Puteţi găsi exemple de politici de securitate la <uri
link="http://www.sans.org/resources/policies/">Proiectul de Politici de
Securitate al SANS</uri>. Dacă aveţi o reţea mică şi consideraţi că aceste
politici sunt prea elaborate, ar trebui să consultaţi <uri
link="ftp://ftp.isi.edu/in-notes/rfc2196.txt">Site-ul Manualului de
Securitate</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Întărirea securităţii în timpul şi după instalare</title>
<section>
<title>Indicatori USE</title>
<body>

<p>
Fişierul <path>make.conf</path> conţine indicatori USE setaţi de utilizator şi
<path>/etc/make.profile/make.defaults</path> conţine indicatorii USE impliciţi
pentru Gentoo Linux. Relativ la scopul acestui ghid, indicatorii USE importanţi
sunt <c>pam</c> (Pluggable Authentication Modules), <c>tcpd</c> (TCP wrappers),
şi <c>ssl</c> (Secure Socket Layer). Toate acestea sunt între indicatorii USE
impliciţi.
</p>

</body>
</section>
<section id = "passwording_GRUB">
<title>Portejarea cu parolă a aplicaţiei GRUB</title>
<body>

<p>
GRUB suportă două soluţii de adăugare a protecţiei cu parolă pentru aplicaţia
bootloader. Prima utilizează textul simplu, în timp ce a doua utilizează
encripţia md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
Aceasta va adăuga parola <c>changeme</c>. Dacă nu este introdusă nici o parolă
la boot, GRUB va utiliza setarea de boot implicită.
</p>

<p>
La adăugarea unei parole md5, trebuie să convertiţi parola dvs. în formatul
crypt, care este acelaşi cu formatul utilizat în <path>/etc/shadow</path>.
Pentru mai multe informaţii consultaţi <c>man crypt</c>. Parola criptată va
arăta în felul următor: <c>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs</c>.
</p>

<p>
Vă puteţi cripta parola dvs. direct în shell-ul GRUB:
</p>

<pre caption="md5crypt în shell-ul grub">
#<i>/sbin/grub</i>

GRUB version 0.92 (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported. For the first word, TAB lists
     possible command completions. Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<comment>(Am tastat changeme la prompt)</comment> 
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
Apoi, efectuaţi cut şi paste pentru parolă în
<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5 
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Timpul de aşteptare de 5 secunde devine folositor când sistemul este la
distanţă şi trebuie să repornească fără interacţiune de la tastatură. Puteţi
afla mai multe informaţii despre parolele GRUB, executând <c>info grub</c>.
</p>

</body>
</section>
<section id = "passwording_LILO">
<title>Projarea cu parolă a aplicaţiei LILO</title>
<body>

<p>
LILO suportă, de asemenea, două metode de a manipula parolele: global şi pentru
fiecare imagine, amândouă în text clar.
</p>

<p>
Parola globală este setată în partea superioară a fişierului de configurare şi
se aplică fiecărei imagini de boot:
</p>

<pre caption="/etc/lilo.conf">
password=changeme 
restricted 
delay=3
</pre>

<p>
Parola pentru fiecare imagine este setabilă, după cum urmează:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage 
      read-only 
      password=changeme 
      restricted
</pre>

<p>
Dacă opţiunea <c>restricted</c> este introdusă, va cere parola de fiecare dată.
</p>

<p>
Pentru a stoca noua informaţie din <path>lilo.conf</path>, trebuie să rulaţi
<c>/sbin/lilo</c>.
</p>

</body>
</section>
<section>
<title>Restricţionarea Utilizării Consolei</title>
<body>

<p>
Fişierul <path>/etc/securetty</path> permite să specificaţi dispozitivele
(terminal) <c>tty</c> în care utilizatorul root are dreptul să se autentifice.
</p>

<p>
Vă sugerăm să comentaţi toate liniile, cu excepţia <c>vc/1</c>. Aceasta va
asigura ca utilizatorul root să nu poată să se autentifice decât o singură dată
şi doar pe un terminal.
</p>

<note>
Utilizatorii din grupul "wheel" încă pot să ruleze <c>su -</c> pentru a deveni
root pe alte dispozitive TTY.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Jurnalizarea suplimentară</title>
<section>
<body>

<p>
Jurnalizarea suplimentară ar trebui să fie adăugată pentru a cuprinde
avertismentele sau erorile ce pot să indice un atac în desfăşurare sau o
compromitere reuşită. Deseori, atacatorii scanează sau probează înainte de a
ataca.
</p>

<p>
Este, de asemenea, vital ca fişierele dvs. de jurnalizare să fie uşor citibile
şi manipulabile. Gentoo Linux vă permite să alegeţi între 3 nivele de
jurnalizare diferite în momentul instalării.
</p>

</body>
</section>
<section>
<title>Syslogd</title>
<body>

<p>
Syslogd este cel mai utilizat sistem de jurnalizare pentru Linux şi, în
general, pentru Unix. Acesta nu deţine un sistem de rotire a fişierelor de
jurnal. Această caracteristică este manipulată prin rularea aplicaţiei
<path>/usr/sbin/logrotate</path> prin intermediul cron (logrotate este
configurat din <path>/etc/logrotate.conf</path>). Cât de des se poate efectua
rotirea fişierelor de jurnal depinde de încărcarea sistemului.
</p>

<p>
Mai jos, aveţi un fişier <path>syslog.conf</path> standard, cu unele opţiuni
adăugate. Am decomentat liniile <c>cron</c> şi <c>tty</c> şi am adăugat un
server de jurnalizare la distanţă. Pentru îmbunătăţirea securităţii puteţi
adăuga jurnalizarea în două locuri.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf      Fişier de configurare pentru syslogd.
#
#                       Pentru mai multe informaţii consultaţi pagina
#                       de manual syslog.conf(5).
#                       Acest fişier este din Debian, îl vom utiliza şi noi de acum încolo
#                       Daniel Robbins, 5/15/99

#
# Mai întâi câteva fişere de jurnal standard. Jurnalizăm după funcţie.
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# Jurnalizarea pentru sistemul de poştă electronică. Împărţiţi-l pentru a scrie
# mai uşor script-uri de analizare a acestor fişiere.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Jurnalizarea pentru sistemul de ştiri INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Unele fişiere jurnal pentru cuprinderea tuturor informaţiilor.
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Situaţiile critice şi alertele sint trimise tuturor utilizatorilor autentificaţi.
#
*.emerg                         *
*.=alert                        *

#
# Îmi place să mi se afişeze mesaje în consolă, dar doar într-o consolă
# virtuală pe care, de obicei, o las nefolosită.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# Setarea unui server de jurnalizare la distanţă
*.*                        @logserver

# Pipa denumită /dev/xconsole este utilizată pentru utilitarul `xconsole'. Pentru a
# o folosi, trebuie să invocaţi `xconsole' cu opţiunea `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTĂ: ajustaţi lista următoare, sau veţi avea probleme în cazul în care aveţi
#      un site destul de încărcat..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                --/var/log/ppp.log
</pre>

<p>
Cel mai probabil, atacatorii vor încerca să îşi şteargă urmele prin editarea
sau ştergerea fişierelor de jurnalizare. Le puteţi îngreuna acţiunile prin
jurnalizarea într-unul sau mai multe server-e de jurnalizare pe alte maşini.
Pentru a afla mai multe informaţii despre syslogd, puteţi rula <c>man
syslog</c>.
</p>

</body>
</section>
<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> de Frank Dennis nu
poate jurnaliza pe un server la distanţă, dar este avantajos în momentul în
care sunt luate în calcul performanţa şi flexibilitatea jurnalizării. Poate
jurnaliza după numele aplicaţiei, urgenţă, funcţie (ca syslogd), şi deţine un
modul de căutare cu expresii regulate cu care puteţi lansa aplicaţii externe
când anumite combinaţii potrivite. Este foarte bun la acţionare în momentul în
care este necesar.
</p> 

<p>
Configurarea standard este, de obicei, de ajuns. Dacă doriţi să fiţi notificat
printr-un mesaj de câte ori cineva greşeşte parola, utilizaţi unul din
următoarele script-uri.
</p>

<p>
Pentru postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh pentru postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Pentru qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh pentru qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Amintiţi-vă să faceţi script-ul executabil prin executarea <c>/bin/chmod +x
/usr/local/sbin/mail_pwd_failures.sh</c>
</p>

<p>
Apoi, decomentaţi linia de sub "Password failures" din
<path>/etc/metalog/metalog.conf</path> ca:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng are aproape aceleaşi caracteristici ca syslog şi metalog cu o mică
diferenţă. Poate filtra mesajele pe baza nivelului şi conţinutului (ca
metalog), oferă jurnalizare la distanţă, ca syslog, poate manipula jurnale din
syslogd (chiar şi fluxurile de caractere - eng. streams - din Solaris), să
scrie în terminal, să execute programe, şi să se comporte ca un server de
jurnalizare. În fapt, este cel mai bun dintre cele două sisteme de jurnalizare
combinat cu o configuraţie avansată.
</p>

<p>
Aveţi mai jos un fişier de configurare clasic, puţin modificat.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#sursa de unde să citească jurnalele
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#definirea destinaţiilor
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#crearea filtrelor
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#conectarea filtrelor şi destinaţiilor
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#jurnalul implicit
log { source(src); destination(console_all); };
</pre>

<p>
Syslog-ng este foarte uşor de configurat, dar şi foarte uşor de omis ceva în
fişierul de configurare, deoarece este mare. Autorul încă promite unele
caracteristici în plus, cum ar fi encripţia, autentificarea, compresia şi
controlul MAC (Mandatory Access Control - Controlul Accesului Obligatoriu). Cu
aceste opţiuni, va fi un sistem de jurnalizare în reţea perfect, deoarece un
atacator nu poate spiona jurnalul.
</p>

<p>
Şi syslog-ng mai are un alt avantaj: nu trebuie rulat ca root!
</p>

</body>
</section>

<section>
<title>Analiza jurnalelor cu Logcheck</title>
<body>

<p>
Bineînţeles, păstrarea tuturor jurnalelor separat este doar jumătate din toată
munca. O aplicaţie precum Logcheck, poate efectua analize de jurnal regulate
mult mai uşor. Logcheck este un script însoţit de un binar denumit
<c>logtail</c>, ce rulează prin intermediul aplicaţiei dvs. cron şi verifică
jurnalele după unele reguli ce definesc activitatea supectă. Apoi, acesta
trimite ceea ce afişează prin poştă electronică utilizatorului root.
</p>
<p>
Logcheck şi logtail fac parte din pachetul <c>app-admin/logsentry</c>.
</p>
<p>
Logcheck utilizează patru fişiere pentru a filtra intrările importante din
fişiere de cele neimportante. Aceste fişiere sunt
<path>logcheck.hacking</path>, ce conţine mesaje legate de mesaje de atac
cunoscute, <path>logcheck.violations</path>, ce conţine combinaţii indicând
violări ale securităţii, <path>logcheck.violations.ignore</path>, ce conţine
cuvinte cheie ce pot fi găsite prin intermediul fişierului de violări,
permiţând intrărilor normale să fie ignorate şi <path>logcheck.ignore</path>,
care conţine modele ale acelor intrări care trebuie ignorate.
</p>

<warn>
Nu lăsaţi fişierul <path>logcheck.violations.ignore</path> gol. Logcheck
utilizează <c>grep</c> pentru a analiza jurnalele, unele versiuni ale acestuia
considerând un fişier gol ca fiind orice. Astfel, toate violările vor fi
ignorate.
</warn>
<!-- FIXME: Might want to add more details on logcheck here...I have to install
it on Gentoo to figure out how it's configured! -->
</body>
</section>

</chapter>

<chapter>
<title>Mount-area partiţiilor</title>
<section>
<body>

<p>
Când mount-aţi o partiţie <c>ext2</c>, <c>ext3</c> sau <c>reiserfs</c> aveţi
câteva opţiuni pe care le puteţi aplica în fişierul <path>/etc/fstab</path>.
Aceste opţiuni sunt:
</p>

<ul>
<li>
  <c>nosuid</c> - Va ignora bitul SUID şi îl va considera ca pe un fişier
  obişnuit
</li>
<li>
  <c>noexec</c> - Va preveni execuţia fişierelor de pe această partiţie
</li>
<li>
  <c>nodev</c> - Ignoră fişierele dispozitiv
</li>
</ul>

<p>
Din păcate, aceste setări pot fi înşelate cu uşurinţă prin execuţia unei căi
indirecte. Oricum, setarea <path>/tmp</path> ca noexec va opri majoritatea
aplicaţiilor exploit să fie executate direct din <path>/tmp</path>.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Setarea <path>/tmp</path> în modul <c>noexec</c> poate opri execuţia corectă a
unor script-uri.
</warn>

<note>
Pentru cote de disc, consultaţi <uri link="#doc_chap6_sect3">secţiunea despre
Cote</uri>.
</note>

<note>
Personal, nu setez <path>/var</path> ca <c>noexec</c> sau <c>nosuid</c>, chiar
dacă fişierele normale nu sunt executate din acest director de mount. Motivul
este faptul că qmail este instalat în <path>/var/qmail</path> şi îi trebuie
permisă execuţia şi accesarea unui fişier SUID. În schimb, setez
<path>/usr</path> doar pentru citire (eng. read-only) deoarece nu scriu
niciodată în această locaţie, decât când actualizez Gentoo. Apoi, remount-ez
sistemul de fişiere şi pentru scriere (eng. read-write), îl actualizez şi îl
remount-ez încă o dată.
</note>

<note>
Chiar dacă nu utilizaţi qmail, Gentoo tot mai necesită bitul pentru execuţie
setat pentru <path>/var/tmp</path> doarece pachetele ebuild sunt compilate în
această locaţie. În schimb, o cale alternativă poate fi setată dacă insistaţi
să aveţi <path>/var</path> mount-at în modul <c>noexec</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Limitări pentru Utilizatori/Grupuri</title>
<section id = "limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
Controlarea utilizării resurselor poate fi foarte efectivă în momenul în care
încercaţi să preveniţi un atac local de tip Denial of Service sau să
restricţionaţi numărul maxim de autentificări pentru un grup sau un utilizator
de sistem.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core 0
*    hard core 0
*    hard nproc 15
*    hard rss 10000
*    -    maxlogins 2
@dev hard core 100000
@dev soft nproc 20
@dev hard nproc 35
@dev -    maxlogins 10
</pre>

<p>
Dacă încercaţi să setaţi <c>nproc</c> sau <c>maxlogins</c> la 0, poate că ar
trebui să ştergeţi utilizatorul, în loc. Exemplul de mai sus defineşte setările
grupului <c>dev</c> relativ la procese, fişiere core şi numărul maxim de
autentificări definit de <c>maxlogins</c>. Restul este setat la o valoare
implicită.
</p>

<note>
<path>/etc/security/limits.conf</path> este componentă a pachetului PAM şi se
aplica doar pachetelor ce utilizează PAM.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> este foarte similar cu fişierul de limite
<path>/etc/security/limits.conf</path>. Singura diferenţă este formatul şi
faptul că funcţionează pentru utilizatori sau modele de potrivire a numelor de
utilizatori (nu şi de grupuri). Haideţi să aruncăm o privire la un exemplu de
configurare:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Aici definim setările implicite şi o setare specifică pentru utilizatorul kn.
Fişierul limits face parte din pachetul sys-apps/shadow. Nu este necesar să
setaţi nici o limită în acest fişier dacă aţi dezactivat <c>pam</c> în
<path>make.conf</path> sau nu aţi configurat corect PAM.
</p>

</body>
</section>
<section>
<title>Cote</title>
<body>

<warn>
Asiguraţi-vă că sistemul de fişiere pe care îl aveţi, suportă cote. Pentru a
utiliza cote pe ReiserFS, trebuie să vă modificaţi sursele de kernel cu unele
patch-uri disponibile de la <uri link =
"ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">Namesys</uri>.
Utilitare pentru utilizatori sunt disponibile la <uri link =
"http://www.sf.net/projects/linuxquota/">proiectul Linux DiskQuota</uri>. În
timp ce cotele funcţionează pe ReiserFS, este posibil să înregistraţi probleme
în timpul utilizării acestora -- aţi fost înştiintaţi!
</warn>

<p>
Aplicarea cotelor pe un sistem de fişiere, restricţionează utilizarea discului
pe baza unor utilizatori sau grupuri. Cotele sunt activate în kernel şi
adăugate într-un director de mount în <path>/etc/fstab</path>. Opţiunea este
activată în configurarea kernel-ului la <c>File systems-&gt;Quota support</c>.
Aplicaţi următoarele setări, recompilaţi kernel-ul şi reporniţi utilizând noul
kernel.
</p>

<p>
Începeţi în a instala cotele prin <c>emerge quota</c>. Apoi, modificaţi
fişierul dvs. <path>/etc/fstab</path> şi adăugaţi <c>usrquota</c> şi
<c>grpquota</c> partiţiilor cărora doriţi să le restricţionaţi utilizarea
discului, ca în exemplul de mai jos.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Pe fiecare partiţie pe care aţi activat cotele, creaţi fişierele de cotă
(<path>aquota.user</path> şi <path>aquota.group</path>) şi copiaţi-le în
rădăcina partiţiei.
</p>

<pre caption="Crearea fişierelor de cotă">
# <i>touch /tmp/aquota.user</i>
# <i>touch /tmp/aquota.group</i>
# <i>chmod 600 /tmp/aquota.user</i>
# <i>chmod 600 /tmp/aquota.group</i>
</pre>

<p>
Acest pas trebuie efectuat pe fiecare partiţie pe care sunt activate cotele.
După adăugarea şi configurarea fişierelor de cotă, trebuie să adăugăm script-ul
de <c>quota</c> în nivelul de iniţializare boot.
</p>

<pre caption="Adăugarea quota în nivelul de iniţializare boot">
# <i>rc-update add quota boot</i>
</pre>

<p>
Acum, vom configura sistemul pentru a verifica cotele odată pe săptămână prin
adăugarea următoarei linii în <path>/etc/crontab</path>:
</p>

<pre caption="Addăugarea verificării de cotă în crontab">
0 3 * * 0 /usr/sbin/quotacheck -avug.
</pre>

<p>
După repornirea maşinii, este timpul să setăm cotele pentru utilizatori şi
grupuri. <c>edquota -u kn</c> va porni editorul definit în $EDITOR (implicit
este nano) şi vă va lăsa să editaţi cotele pentru utilizatorul kn. <c>edquota
-g</c> va efectua aceeaşi acţiune pentru grupuri.
</p>

<pre caption="Setarea cotelor pentru utilizatorul kn">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Pentru mai multe detalii, consultaţi <c>man edquota</c> sau <uri
link="http://www.tldp.org/HOWTO/mini/Quota.html">Mini Ghidul pentru Cote</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>
	    
<p>
Dacă politica dvs. de securitate indică faptul că utilizatorii ar trebui să-şi
schimbe parola o dată pe săptămână, modificaţi valoarea opţiunii
<c>PASS_MAX_DAYS</c> la 14 şi pe cea a <c>PASS_WARN_AGE</c> la 7. Este
recomandat să utilizaţi invechirea parolei deoarece metodele brute force pot
găsi orice parolă, într-un anumit timp. De asemenea, vă încurajăm să setaţi
<c>LOG_OK_LOGINS</c> la yes.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Fişierul <path>login.access</path> face parte, de asemenea, din pachetul
sys-apps/shadow, ce oferă o tabelă de control al accesului pentru
autentificare. Acest tabel este utilizat pentru a controla cine are şi cine nu
are dreptul să se autentifice pe baza numeului de utilizator, grup sau sistem
gazdă. Implicit, toturor utilizatorilor din sistem li se permite să se
autentifice, deci fişierul nu conţine decât comentarii şi exemple. Fie că vă
securizaţi server-ul sau staţia de lucru, vă recomandăm să setaţi acest fişier
pentru ca nimeni altcineva decât dvs. (administratorul) să aibă acces la
consolă.
</p>

<note>
Aceste setări nu se aplică utilizatorului root.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Aveţi grijă când configuraţi aceste opţiuni, deoarece greşelile vă pot tăia
accesul la maşină dacă nu aveţi acces root.
</impo>

<note>
Aceste setări nu se aplică pentru SSH, doarece SSH nu execută <c>/bin/login</c>
implicit. Aceasta poate fi activată prin setarea <c>UseLogin yes</c> în
<path>/etc/ssh/sshd_config</path>. 
</note>

<p>
Aceasta va seta accesul pentru autentificare astfel încât utilizatorii membri
ai grupului wheel să se poată autentifica local din domeniul gentoo.org. Poate
puţin paranoic, dar mai bine să fiţi în siguranţă decât să regretaţi.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Permisiunile Fişierelor</title>
<section>
<title>Accesibil tuturor pentru citire</title>
<body>

<p>
Utilizatorii normali nu ar trebui să aibă acces la fişierele de configurare sau
parole. Un atacator poate sustrage parolele din bazele de date sau site-uri web
şi să le utilizeze pentru compromiterea -- sau chiar mai rău, pentru ştergerea
-- datelor. De aceea este important ca permisiunile fişierelor să fie corecte.
Dacă sunteţi sigur că un fişier este utilizat doar de root, atribuiţi-i
acestuia permisiunile <c>0600</c> şi utilizatorul corect cu <c>chown</c>.
</p>

</body>
</section>
<section>
<title>Accesibil pentru scriere tuturor/grupului</title>
<body>

<pre caption="Găsirea fişierelor şi directoarelor accesibile pentru scriere tuturor">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Aceasta va crea un fişier imens cu permisiunile tuturor fişierelor ce au
permisiuni de scriere setate, fie pentru grup, fie pentru oricine. Verificaţi
aceste permisiuni şi eliminaţi fişierele accesibile pentru scriere tuturor,
prin execuţia <c>/bin/chmod o-w</c> pentru fişierele respective.
</p>

</body>
</section>
<section>
<title>Fişiere SUID/SGID</title>
<body>

<p>
Fişierele cu bitul SUID sau SGID setat, execută cu privilegiile utilizatorului
sau grupului <e>proprietar</e> şi nu cu cele ale utilizatorului care execută
acel fişier. În mod normal, aceşti biţi sunt utilizaţi pe fişierele ce trebuie
să ruleze ca root pentru a îşi urma paşii de execuţie firesc. Aceste fişiere
pot conduce la compromiteri de root locale (dacă au probleme de securitate).
Aceasta este periculos şi fişierele cu biţii SUID sau SGID setaţi ar trebui să
fie evitate cu orice preţ. Dacă nu utilizaţi aceste fişiere, executaţi <c>chmod
0</c> pe ele sau dezinstalaţi pachetul care le conţine (verificaţi cărui pachet
aparţin prin utilizarea <c>equery</c>; dacă nu îl aveţi deja instalat, tastaţi
<c>emerge gentoolkit</c>). Altfel, dezactivaţi bitul SUID cu <c>chmod -s</c>.
</p>

<pre caption="Găsirea fişierelor setuid">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
   -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Aceasta va crea un fişier conţinând lista tuturor fişierelor cu bitul SUID/SGID
activ.
</p>

<pre caption="Lista cu binarele setuid">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Implicit, Gentoo Linux nu are multe fişiere SUID (deşi acest lucru depinde de
pachetele instalate), dar aţi putea să vă creaţi o listă ca cea de mai sus.
Majoritatea comenzilor nu ar trebui să fie rulate de utilizatorii normali, ci
doar de root. Dezactivaţi botul SUID pentru <c>ping</c>, <c>mount</c>,
<c>umount</c>, <c>chfn</c>, <c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>,
<c>pt_chown</c> şi <c>traceroute</c> prin execuţia comenzii <c>chmod -s</c> pe
fiecare fişier în parte. Nu dezactivaţi bitul pentru <c>su</c>,
<c>qmail-queue</c> sau <c>unix_chkpwd</c>. Dezactivarea setuid pentru aceste
fişiere vă va opri să mai puteţi rula <c>su</c> şi recepţionarea mesajelor
electronice. Prin dezactivarea bitului (în cazurile în care este sigur) opriţi
posibilitatea ca un utilizator de sitem normal (sau un atacator) să obţină
acces de root prin oricare din aceste fişiere.
</p>

<p>
Singurele fişiere SUID pe care le am pe sistemul propriu sunt <c>su</c>,
<c>passwd</c>, <c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> şi
<c>pwdb_chkpwd</c>. Dar, dacă rulaţi aplicaţia X, este posibil să aveţi mai
multe, deoarece X are nevoie de acces superior ce îl poate obţine prin
intermediul SUID.
</p>
</body>
</section>
<section>
<title>Binare şi hardlink-uri SUID/SGID</title>
<body>

<p>
Un fişier este considerat şters când nu mai există nici un link ce indică spre
acesta. Acest concept poate fi ciudat, dar luaţi în considerare un fişier ca
<path>/usr/bin/perl</path> care este, de fapt, un link către inodul unde este
stocată data. Orice număr de link-uri pot indica către acest fişier şi până
când toate acestea dispar, fişierul încă există.
</p>

<p>
Dacă utilizatorii dvs. au acces pe o partiţie ce nu este mount-ată cu
<c>nosuid</c> sau <c>noexec</c> (spre ex., dacă <path>/tmp</path>,
<path>/home</path> sau <path>/var/tmp</path> nu sunt partiţii separate) ar
trebui să vă asiguraţi că utilizatorii nu crează hardlink-uri indicând spre
binare SUID sau SGID, astfel încât, după ce Portage se actualizează, ei încă
mai au acces la vechile versiuni.
</p>

<warn>
Dacă aţi primit un avertisment de la portage despre unele hardlink-uri rămase
şi utilizatorii dvs. pot scrie pe o partiţie ce permite execuţia fişierelor
SUID/SGID, ar trebui să consultaţi această secţiune cu atenţie. Unul din
utilizatorii dvs. poate încerca să înşele procesul dvs. de actualizare prin
păstrarea unei versiuni vechi a programului. Dacă utilizatorii dvs. nu pot crea
fişierele lor proprii SUID, pot doar să execute programe utilizând modulul de
încărcare dinamică (partiţiile mount-ate <c>noexec</c>), atunci nu aveţi de ce
să vă îngrijoraţi.
</warn>

<note>
Utilizatorii nu au nevoie de acces de citire pentru un fişier pentru a crea un
link la acesta, ci doar de permisiuni de citire pentru directorul ce conţine
acel fişiere.
</note>

<p>
Pentru a verifica numărul de link-uri al unul fişier, puteţi utiliza comanda
<c>stat</c>.
</p>

<pre caption="Comanda stat">
$ stat /bin/su    
  File: `/bin/su'
  Size: 29350           Blocks: 64         IO Block: 131072 regular file
Device: 900h/2304d      Inode: 2057419     Links: 1
Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2005-02-07 01:59:35.000000000 +0000
Modify: 2004-11-04 01:46:17.000000000 +0000
Change: 2004-11-04 01:46:17.000000000 +0000
</pre>

<p>
Pentru a găsi fişierele SUID şi SGID cu mai multe link-uri, puteţi utiliza
<c>find</c>.
</p>

<pre caption="Găsirea binarelor suid/sgid cu mai multe link-uri">
$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls
</pre>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules)</title>
<section>
<body>

<p>
PAM este o suită de librării partajate ce oferă o cale alternativă de
autentificare a utilizatorilor în programe. Indicatorul USE <c>pam</c> este
activ implicit. Astfel, setările PAM din Gentoo Linux sunt destul de
acceptabile, dar este întotdeauna loc de îmbunătăţiri. Mai întâi instalaţi
cracklib.
</p>

<pre caption="Instalarea cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Aceasta va adăuga cracklib, ce va asigura că parolele utilizatorilor sunt de
minim 8 caractere şi conţin minim 2 cifre, 2 alte caractere şi mai mult de 3
caractere diferite faţă de parola anterioară. Aceasta forţează utilizatorul
să-şi aleagă o parolă bună (politica de parole). Consultaţi documentaţia <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>
pentru mai multe opţiuni.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Fiecare serviciu ce nu configurat cu un fişier PAM în <path>/etc/pam.d</path>
va utiliza regulile din <path>/etc/pam.d/other</path>. Regulile implicite sunt
să interzică prin directiva <c>deny</c>, aşa cum ar trebui să fie. Dar mie îmi
place să am multe jurnale, motiv pentru care am adăugat <c>pam_warn.so</c>.
Ultima directivă de configurare este <c>pam_limits</c>, ce este controlată de
<path>/etc/security/limits.conf</path>. Consultaţi <uri link =
"#limits_conf">secţiunea despre /etc/security/limits.conf</uri> pentru mai
multe asemenea setări.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Aplicaţii Wrapper pentru TCP</title>
<section>
<body>

<p>
Aceasta este o modalitate de a controla accesul la servicii, în mod normal
manipulat de inetd (pe care Gentoo nu îl are), dar poate fi utilizat şi de
xinetd şi alte servicii.
</p>

<note>
Serviciul ar trebui să execute tcpd între argumentele sale (în xinetd).
Consultaţi capitolul despre xinetd pentru mai multe informaţii.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Aşa cum puteţi observa, formatul este foarte similar cu cel din
<path>/etc/login.access</path>. Tcpd suportă un anumit serviciu; nu se
suprapune cu <path>/etc/login.access</path>. Aceste setări se aplică doar
serviciilor ce utilizează aplicaţii wrapper pentru tcp.
</p>

<p>
Este, de asemenea, posibil, să executaţi comenzi când un serviciu este accesat
(aceasta poate fi utlilizată când activaţi interconectarea pentru utilizatorii
dial-in) dar nu este recomandat, deoarece utilizatorii tind să creeze mai multe
probleme decât încearcă să rezolve. Un exemplu poate fi încercarea de a
configura un script să trimită un mesaj de fiecare dată când cineva se
potriveşte unei reguli de blocare, dar un atacator poate lansa un atac DoS prin
potrivirea continuă a regulii de blocare. Aceasta va crea multe operaţii de ip
I/O şi mesaje, deci nu trebuie să faceţi aşa!. Consultaţi <c>man 5
hosts_access</c> pentru mai multe informaţii.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Securitatea pentru Kernel</title>
<section>
<title>Înlăturarea funcţionalităţii</title>
<body>

<p>
Regula de bază pentru configurarea de kernel este să îndepărtaţi orice nu aveţi
nevoie. Aceasta, nu numai că vă va crea un kernel mic, dar va îndepărta şi
toate vulnerabilităţile ce pot să fie prezente în modulele driver şi în alte
funcţionalităţi.
</p>

<p>
De asemenea, luaţi în considerare dezactivarea suportului de încărcare a
modulelor. Chiar şi aşa, este posibilă introducerea de aplicaţii root kit fără
suportul acestor functionalităţi, îngreunează atacatorilor obişnuiţi instalarea
de asemenea aplicaţii prin intermediul modulelor de kernel.
</p>

</body>
</section>
<section>
<title>Sistemul de fişiere proc</title>
<body>

<p>
Mulţi parametri de kernel pot fi modificaţi prin intermediul sistemului de
fişiere <path>/proc</path> sau utilizând <c>sysctl</c>.
</p>

<p>
Pentru a modifica dinamic paramtetrii de kernel în timpul rulării, trebui să
aveţi definit în kernel <c>CONFIG_SYSCTL</c>. Această opţiune este activată
implicit într-un kernel 2.4 standard.
</p>

<pre caption="Dezactivarea IP forwarding">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Asiguraţi-vă că IP forwarding este dezactivată. Dorim această opţiune doar
pentru sistemele cu mai multe gazde conectabile. Este recomandat să activaţi
sau să dezactivaţi această opţiune înainte de toate celelalte opţiuni, deoarece
acesta activează/dezactivează la rându-i alte opţiuni, de asemenea.
</p>

<pre caption="Refuzarea pachetelor ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Aceasta va cauza kernel-ului pur şi simplu să ignore toate mesajele ping
(cunoscute şi sub numele de mesaje ICMP de tipul 0). Motivul pentru aceasta
este că un pachet IP ce are înglobat un mesaj ICMP poate conţine alte
informaţii decât credeţi. Administratorii utilizează ping ca utilitate de
diagnosticare şi sunt adeseori nemulţumiţi de faptul că este dezactivat, dar nu
există nici un motiv ca cineva din exterior să poată trimite ping. Oricum,
deoarece uneori poate fi la îndemână pentru cei din interior să poată utiliza
ping, puteţi dezactiva mesajele ICMP de tipul 0 din firewall (permiţând
administratorilor locali să continue utilizarea acestui utilitar).
</p>

<pre caption="Ignorarea pachetelor ping de difuzare">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Aceasta dezactivează răspunsul la cererile ICMP de difuzare (eng. broadcast) şi
va preveni atacurile Smurf. Atacul Smurf funcţionează prin trimiterea unui
mesaj ICMP de tip 0 (ping) adresei de difuzare a unei reţele. În mod normal,
atacatorul va utiliza o adresă sursă falsă. Toate calculatoarele din reţea vor
răspunde mesajului ping, astfel inundând cu pachete sistemul gazdă de la adresa
sursă falsă.
</p>

<pre caption="Dezactivarea pachetelor rutate ale sursei">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Nu acceptaţi pachete rutate ale sursei. Atacatorii pot utiliza rutarea sursei
pentru a genera trafic, pretinzând că acestea sunt originare din interiorul
reţelei, dar acestea sunt, de fapt rutate înapoi alături de calea de pe care a
venit, în acest fel atacatorii putându-vă compromite reţeaua. Rutarea sursei
este rar utilizată în scopuri ligitime, deci este sigur să o dezactivaţi.
</p>

<pre caption="Dezactivaţi acceptarea redirectării">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/secure_redirects</i>
</pre>

<p>
Nu acceptaţi pachete ICMP redirectate. Redirectările ICMP pot fi utilizate
pentru a vă altera tabelele de rutare, posibil către un final neplăcut.
</p>

<pre caption="Protecţia impotriva mesajelor de eroare incorecte">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Activaţi protecţia împotriva răspunsurilor de eroare incorecte.
</p>

<pre caption="Activaţi filtrarea adresei inverse">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<p>
Activaţi filtrarea adresei inverse. Aceasta vă ajută să vă asiguraţi că
pachetele utilizează adrese sursă legitime şi respingerea pachetelor primite
dacă intrarea din tabela de rutare a adresei sursa a acestora nu se potriveşte
interfeţei de reţea pe care vin. Aceasta oferă avantaje de securitate pentru că
previne falsificarea adreselor IP. Trebuie să o activăm pentru fiecare
<path>net/ipv4/conf/*</path>, altfel valdarea adreselor sursă nu va fi complet
funcţională.
</p>

<warn>
În orice caz, activarea filtrelor pentru adresa inversă poate fi o problemă
dacă utilizaţi rutarea asimetrică (pachetele de la dvs. la un sistem gazdă
urmează altă cale decât pachetele ce trimise de la acel sistem gazdă către
dvs.) sau dacă operaţi un sistem gazdă ce nu rutează şi are mai multe adrese IP
pe interfeţe diferite.
</warn>

<pre caption="Înregistrarea tuturir pachetelor false, rutate de sursă şi redirectate">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Înregistrarea în jurnal a pachetelor false, rutate de sursă şi redirectate.
</p>

<p>
Toate aceste setări vor fi refăcute în momentul în care maşina este repornită.
Vă sugerez să le adăugaţi în <path>/etc/sysctl.conf</path>, ce este interpretat
automat de script-ul de iniţializare <path>/etc/init.d/bootmisc</path>.
</p>

<p>
Sintaxa pentru <path>/etc/sysctl.conf</path> este destul de simplă. Elimininaţi
<path>/proc/sys/</path> din căile menţionate anterior şi înlocuiţi
<path>/</path> cu <path>.</path>:
</p>

<pre caption="Translatarea pentru sysctl.conf">
<comment>(Manual, utilizând echo):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automat, în sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
Patch-ul de la <uri link="http://grsecurity.net">Grsecurity</uri> este standard
în sursele de kernel Gentoo, dar este dezactivat implicit. Configuraţi-vă
kernel-ul în mod obişnuit şi apoi configuraţi opţiunile Grsecurity. O
explicaţie amănunţită despre opţiunile Grsecurity (version 1.9) disponibile se
află pe pagina proiectului <uri link="/proj/en/hardened">Gentoo Hardened</uri>.
</p>

<p>
Sursele <c>grsec-sources</c> recente, oferă versiunea 2.* a Grsecurity. Pentru
mai multe informaţii despre acest set îmbunătăţit de patch-uri Grsecurity, vă
rugăm să consultaţi documentaţia disponibilă pe <uri
link="http://www.grsecurity.net/">pagina oficială Grsecurity</uri>.
</p>

</body>
</section>
<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> este un patch ce adaugă
encripţie kernel-ului existent. Prin aplicarea acestui patch în sursele de
kernel veţi beneficia de noi opţiuni, cum ar fi cifruri criptografice,
algoritmi digest şi filtre criptografice de loop.
</p>

<warn>
Patch-ul kerneli nu este, momentan, într-o versiune stabilă pentru ultima
versiune de kernel, deci aveţi mare atenţie la utilizarea acestuia.
</warn>

</body>
</section>
<section>
<title>Alte patch-uri de kernel</title>
<body>

<ul>
<li>
  <uri link="http://www.openwall.com">Proiectul OpenWall</uri>
</li>
<li>
  <uri link="http://www.lids.org">Linux Intrusion Detection System - Sistemul
  de Detecţie a Intruziunii în Linux</uri>
</li>
<li>
  <uri link="http://www.rsbac.org">Rule Set Based Access Control - Control al
  Accesului Bazat pe Reguli</uri>
</li>
<li>
  <uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel -
  kernel-ul îmbunătăţit pentru securitate de la NSA</uri>
</li>
<li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
Şi, probabil că mai sunt şi multe altele.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Securizarea Serviciilor</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) conţine un fişier de configuraţie chiar decent dar, din nou,
trebuie să îmbunătăţim unele opţiuni, cum ar fi să determinăm apache să asculte
pe o singură adresă şi să prevenim scurgerea de informaţii de la acesta. Mai
jos sunt explicate opţiunile ce ar trebui aplicate fişierului de configurare.
</p>

<p>
Dacă nu aţi dezactivat <c>ssl</c> în fişierul dvs. <path>/etc/make.conf</path>
înainte de a instala Apache, ar trebui să aveţi acces la un server ce are
activat modul ssl. Trebuie doar să adăugaţi următoarea linie pentru a activa.
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Determinaţi-l să asculte pe adresa dvs. ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#Nu este o idee bună să utilizaţi nobody sau nogroup - 
#pentru fiecare serviciu ce nu rulează ca root
#(trebuie doar să adăugaţi utilizatorul apache cu grupul apache)
User apache
Group apache
#Va opri apache să îşi afişeze versiunea
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache este compilat cu <c>--enable-shared=max</c> şi
<c>--enable-module=all</c>. Implicit, aceasta va activa toate modulele, deci va
trebui să comentaţi toate modulel din secţiunea <c>LoadModule</c>
(<c>LoadModule</c> şi <c>AddModule</c>) pe care nu le utilizaţi. Reporniţi
serviciul prin execuţia <c>/etc/init.d/apache restart</c>.
</p>

<p>
Documentaţie este disponibilă la <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
Puteţi găsi documentaţie pe pagina <uri
link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri>. Manualu de Referinţă pentru Administrarea BIND 9 este, de
asemenea, în <path>doc/arm</path>.
</p>

<p>
Pachetele ebuild mai noi pentru BIND suportă mediul chroot în afara sistemului.
După ce instalaţi <c>bind</c>, urmaţi aceste instrucţiuni simple:
</p>

<pre caption="Mediul chroot pentru BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<comment>(Înainte de a rula comanda de mai sus, ar trebui să modificaţi directorul chroot
/etc/conf.d/named. Altfel, va fi utilizat /chroot/dns.)</comment>
<comment>(Este posibil să trebuiască să înlocuiţi numărul versiunii cu numărul celei curente)</comment>
</pre>
</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns este o implementare DNS pe a cărei securitate, autorul este dispus să
parieze pe <uri link="http://cr.yp.to/djbdns/guarantee.html">bani</uri>. Este
foarte diferit de modul de funcţionare al Bind 9, dar merită încercat. Mai
multe informaţii pot fi obţinute de la <uri>http://www.djbdns.org</uri>.
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
În general, utilizarea FTP (File Transfer Protocol - Protocolul de Transfer de
Fişiere) nu este o idee bună. Acesta utilizează date necriptate (spre ex.
parolele sunt transmise în text clar), ascultă pe două porturi (în mod normal,
porturile 20 şi 21) şi atacatorii caută frecvent autentificări anonime pentru
tranzitul warez. Deoarece protocolul FTP conţine câteva probleme de securitate,
ar trebui să utilizaţi în loc <c>sftp</c> sau HTTP. Dacă această soluţie este
posibilă, securizaţi-vă serviciile în orice mod posibil şi pregătiţi-vă.
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
Dacă doriţi ca doar aplicaţii locale să vă acceseze baza de date <c>mysql</c>,
decomentaţi următoarea linie din <path>/etc/mysql/my.cnf</path>.
</p>

<pre caption="Dezactivaţi accesul la reţea">
skip-networking
</pre>

<p>
Apoi, trebuie să dezactivăm utilizarea comenzii LOAD DATA LOCAL INFILE.
Aceasta, pentru a preveni accesul neautorizat la citirea fişierelor locale.
Aceasta este relevantă când sunt găsite noi vulenerabilităţi de tipul SQL
Injection în aplicaţiile PHP.
</p>

<pre caption="Dezactivarea LOAD DATA LOCAL INFILE în secţiunea [mysqld]">
set-variable=local-infile=0
</pre>

<p>
Apoi, trebuie să ştergem baza de date exemplu (test) şi toate conturile, cu
excepţia contului <c>root</c> local.
</p>

<pre caption="Ştergerea bazei de date exemplu şi tuturor utilizatorilor nenecesari">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Fiţi atenţi la comenzile anterioare, dacă deja aveţi configurate conturi de
utilizator.
</warn>

<note>
Dacă aţi modificat parolele din promptul MYSQL, ar trebui întotdeauna să
ştergeţi <path>~/.mysql_history</path> şi <path>/var/log/mysql/mysql.log</path>
deoarece acestea stochează comenzile SQL executate cu parolele în text clar.
</note>

</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd a avut câteva probleme de securitate, dar majoritatea se pare că au
fost rezolvate. Chiar şi aşa, este o idee bună să aplicăm unele îmbunătăţiri:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#Nu afişaţi identificarea server-ului
ServerIdent on "Go away"

#Înlesneşte crearea de utilizatori virtuali
RequireValidShell off

#Utilizaţi fişierele de parolă şi grup (passwd utilizează formatul crypt)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permisiuni
Umask 077

# Timpi de expirare şi limitări
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Toţi trebuie să efectueze chroot
DefaultRoot ~

#nu rulaţi ca root
User  nobody
Group nogroup

#înregistraţi fiecare transfer
TransferLog /var/log/transferlog

#Probleme cu globalizarea
DenyFilter \*.*/
</pre>

<p>
Puteţi găsi documentaţie la <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd este o ramură a originalului trollftpd, modificat pentru scopuri de
securitate şi funcţionalitate de Frank Dennis.
</p>

<p>
Folosiţi utilizatori virtuali (niciodată conturi de sistem) prin activarea
opţiunii <c>AUTH</c>. Setaţi-o cu valoarea <c>-lpuredb:/etc/pureftpd.pdb</c> şi
creaţi utilizatorii prin comanda <c>/usr/bin/pure-pw</c>. 
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Configuraţi setarea dvs. <c>MISC_OTHER</c> pentru a interzice autentificările
anonime (<c>-E</c>), toţi trebuie să utilizeze chroot (<c>-A</c>), preveniţi ca
utilizatorii să poată citi sau scrie în fişierele ce încep cu un . (punct)
(<c>-X</c>), timpul maxim de inactivitate (<c>-I</c>), limitaţi recursia
(<c>-L</c>), şi o mască de utilizator rezonabilă cu <c>umask</c>.
</p>

<warn>
<e>Nu</e> utilizaţi opţiunile <c>-w</c> sau <c>-W</c>! Dacă doriţi să aveţi un
site warez, încetaţi consultarea acestui ghid!
</warn>

<p>
Se poate găsi documentaţie la <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (prescurtarea de la very secure ftp - ftp foarte sercurizat) este o
aplicaţie daemon foarte mică ce conţine o configuraţie implicită rezonabilă.
Este simplă şi nu are aşa multe funcţionalităţi ca pureftp şi proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#doar pentru citire
write_enable=NO

#activarea înregistrării transferurilor
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Aşa cum puteţi observa, nu există nici o soluţie ca acest serviciu să deţină
permisiuni individuale, dar deţine unele setări pentru accsul anonim pentru
care este chiar bun. Uneori poate fi un lucru bun să avem un server ftp anonim
(pentru partajarea aplicaţiilor open source), iar vsftpd se descurcă chiar
bine.
</p>

</body>
</section>
<section>
<title>Qmail</title>
<body>

<p>
Qmail este adesea considerat ca fiind un server de poştă electronică foarte
bun. Este scris având securitatea (şi paranoia) în minte. Nu permite relay
implicit şi nu a avut nici o breşă de securitate din 1996. Pur şi simplu
instalaţi rulând <c>emerge qmail</c> şi configuraţi-l!
</p>
</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba este un protocol pentru partajarea fişierelor cu reţele Microsoft/Novell
şi <e>nu</e> ar trebui utilizat pe internet. Chiar şi aşa, mai are nevoie de
securizare.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Ascultă pe o interfaţă
  interfaces = eth0 10.0.0.1/32

  #Asiguraţi-vă că utilizaţi parole criptate
  encrypt passwords = yes
  directory security mask = 0700

  #permiteţi traficul de la 10.0.0.*
  hosts allow = 10.0.0.

  #Activează autentificarea utilizatorilor
  #(nu utilizaţi modul share)
  security = user

  #Interzice conturile privilegiate
  invalid users = root @wheel

  #Mărimea maximă afişată de smb pentru o resursă partajată (nu este o limită)
  max disk size = 102400

  #Confirmaţi politica de securitate
  min password length = 8
  null passwords = no

  #Utilizaţi PAM (dacă aţi adăugat suport)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Asiguraţi-vă că permisiunile sunt setate corect pe fiecare resursă partajată şi
amintiţi-vă să consultaţi <uri link="http://www.samba.org">documentaţia</uri>.
</p>

<p>
Acum, reporniţi server-ul şi adăugaţi utilizatorii care ar trebui să aibă acces
la acest serviciu. Aceasta poate fi efectuată prin intermediul comenzii
<path>/usr/bin/smbpasswd</path> cu parametrul <c>-a</c>.
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
Singura securizare pe care o necesită OpenSSH este activarea unei autentificări
mai puternice bazată pe encripţia cu chei publice. Prea multe site-uri (cum ar
fi <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> şi
<uri>http://www.apache.org</uri>) au suferit intruziuni neautorizate din cauza
pierderii parolei sau parolelor proaste.
</p>

<pre caption="/etc/ssh/sshd_config">
#Activaţi doar versiunea 2
Protocol 2

#Dezactivaţi autentificarea root. Utilizatorii trebuie să ruleze su pentru root
PermitRootLogin no

#Activaţi autentificarea cu chei publice
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

#Dezactivaţi .rhost şi autentificarea cu parolă normală
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

#Permiteţi doar utilizatorilor din grupul wheel sau admin să se autentifice
AllowGroups wheel admin

#În aceste grupuri, permiteţi doar următorilor utilizatori
#Opţiunea @&lt;domainname&gt; este opţională dar înlocuieşte
#vechea directivă AllowHosts
AllowUsers kn@gentoo.org bs@gentoo.org

#Înregistrarea în jurnal
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
De asemenea, verificaţi că nu aveţi <c>UsePAM yes</c> în fişierul dvs. de
configurare deoarece suprascrie mecanismul de autentificare cu chei publice.
</p>

<p>
Acum, tot ceea ce utilizatorii dvs. trebuie să facă este să-şi creeze o cheie
(pe maşina de pe care doresc să se autentifice) cu următoarea comandă:
</p>

<pre caption="Creaţi o pereche de chei DSA">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Şi tastaţi fraza de autentificare.
</p>

<pre caption="Ce afişează ssh-keygen">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Apăsaţi Enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Introduceţi fraza]</i>
Enter same passphrase again: <i>[Introduceţi fraza din nou]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Aceasta va adăuga două fişiere în directorul dvs. <path>~/.ssh/</path> denumite
<path>id_dsa</path> şi <path>id_dsa.pub</path>. Fişierul denumit
<path>id_dsa</path> reprezintă cheia dvs. privată şi ar trebui ferită de alţi
utilizatori decât dvs. Celălalt fişier <path>id_dsa.pub</path> trebuie
distribuit pe fiecare server pe care aveţi acces. Adăugaţi cheia în directorul
home al utilizatorilor în <path>~/.ssh/authorized_keys</path> şi utilizatorul
ar trebui să poată să se autentifice.
</p>

<p>
Acum, utilizatorii ar trebui să îşi păzească şi cheia lor privată. Stocaţi-o pe
un suport media pe care îl purtaţi mereu cu dvs. sau păstraţi-o pe staţia de
lucru (puneţi acest paragraf în politica pentu <uri
link="#security_policies">parole</uri>).
</p>

<p>
Pentru mai multe informaţii vizitaţi site-ul <uri
link="http://www.openssh.org">OpenSSH</uri>.
</p>

</body>
</section>
<section>
<title>Utilizarea xinetd</title>
<body>

<p>
xinetd înlocuieşte <c>inetd</c> (care nu este conţinut în Gentoo), aplicaţia
daemon pentru servicii internet. Suportă controlul accesului pe baza adresei
sistemului apelant şi timpului de acces. De asemenea, oferă capabilităţi
extinse de jurnalizare, incluzând timpul la care a pornit aplicaţia server,
adresa sistemului gazdă apelant, numele utilizatorului de la distanţă, timpul
de rulare şi acţiunile executate.
</p>

<p>
Ca şi cu celelalte servicii, este important să avem o configuraţie implicită
bună. Dar, deoarece <c>xinetd</c> este rulat ca root şi suportă protocoale ce
este posibil să nu le cunoaşteţi, vă recomandăm să nu îl utilizaţi. Totuşi,
dacă doriţi să-l utilizaţi, iată cum puteţi adăuga unele funcţionalităţi de
securitate în acesta:
</p>

<pre caption="Instalarea xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Şi apoi editaţi fişierul de configurare:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from = localhost
 instances = 10
 log_type = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps = 25 30
}

# Aceasta va rula pserver (cvs) prin xinetd cu următoarele setări:
# maxim 10 instanţe (10 conexiuni în acelaşi timp)
# limitaţi pserver doar la tcp
# folosiţi utilizatorul cvs pentru a rula acest serviciu
# ascultaţi pe o singură adresă ip
# permiteţi accesul de la 10.0.0.*
# limitaţi timpul în care dezvoltatorii pot utiliza dvs de la 8am la 5pm
# utilizaţi aplicaţii wrapper tcp (controlul accesului se poate face din
# <i>/etc/hosts.allow</i> şi <i>/etc/hosts.deny</i>)
# variabila max_load pentru maşină este setată la 1.0
# Inicatorul disable este setat implicit pe no, dar mi-ar plăcea
# cazul în care ar trebui să fie dezactivat
service cvspserver
{
 socket_type = stream
 protocol = tcp
 instances = 10
 protocol = tcp
 wait = no
 user = cvs
 bind = 10.0.0.2
 only_from = 10.0.0.0
 access_times = 8:00-17:00
 server = /usr/sbin/tcpd
 server_args = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load = 1.0
 log_on_failure += RECORD
 disable = no
}
</pre>

<p>
Pentru mai multe informaţii consultaţi <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>X</title>
<body>

<p>
Implicit, Xorg este configurat ca aplicaţie Xserver. Aceasta poate fi
periculos, deoarece X utilizează conexiuni TCP necriptate şi ascultă pentru
aplicaţiile xclients.
</p>

<impo>
Dacă nu aveţi nevoie de acest serviciu, dezactivaţi-l!
</impo>

<p>
Dar, dacă depindeţi de utilizarea staţiei dvs. de lucru ca Xserver, utilizaţi
comanda <c>/usr/X11R6/bin/xhost</c> cu atenţie. Această comandă permite
clienţilor de pe alte sisteme gazdă să se conecteze şi să utilizeze terminalul.
Aceasta poate fi la îndemână dacă aveţi nevoie de o aplicaţie X de pe altă
maşină şi singura modalitate de rulare este prin intermediul reţelei, dar poate
fi, de asemenea, exploatată de un atacator. Sintaxa acestei comenzi este
<c>/usr/X11R6/bin/xhost +hostname</c>
</p>

<warn>
Nu utilizaţi niciodată <c>xhost +</c>! Aceasta va permite oricărui client să se
conecteze şi să preia controlul asupra aplicaţiei X. Dacă un atatacator vă
poate accesa aplicaţiaX, vă poate înregistra tastele apăsate şi prelua
controlul asupra aplicaţiei dvs. desktop. Dacă trebuie să-l utilizaţi,
amintiţi-vă mereu să adăugaţi un nume de sistem gazdă.
</warn>

<p>
O soluţie mult mai securizată este să dezactivaţi această funcţionalitate
definitiv, prin pornirea X cu <c>startx -- -nolisten tcp</c> sau să o
dezactivaţi permanent din configuraţie. 
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Pentru a vă asigura că <path>startx</path> nu va fi suprascris la instalarea
unei noi versiuni de Xorg, trebuie să îi protejaţi locaţia. Adăugaţi următoarea
linie în <path>/etc/make.conf</path>:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Dacă utilizaţi un manager de login grafic, trebuie să luaţi în considerare altă
abordare.
</p>

<p>
Pentru <c>gdm</c> (Gnome Display Manager)
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Pentru <c>xdm</c> (X Display Manager) şi <c>kdm</c> (Kde Display Manager)
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Mediul chroot şi aplicaţii server virtuale</title>
<section>
<title>Mediul chroot</title>
<body>

<p>
Rularea în mediul chroot a unui serviciu este o cale de a limita mediul unui
serviciu (sau utilizator) la a accesa doar ce este necesar şi a nu obţine acces
(sau informaţii) ce pot conduce la accesul root. Prin rularea unui serviciu ca
un alt utilizator de sistem decât <c>root</c> (<c>nobody</c>, <c>apache</c>,
<c>named</c>), un atacator poate accesa doar fişierele cu permisiunile acestui
utilizator. Aceasta înseamnă că un atacator nu poate obţine acces <c>root</c>
chiar dacă serviciile au o breşă de securitate.
</p>

<p>
Unele servicii ca <c>pure-ftpd</c> şi <c>bind</c> au funcţionalităţi pentru
mediul chroot, şi altele servicii nu. Dacă un serviciu îl suportă, utilizaţi-l,
altfel trebuie să găsiţi o soluţie să vă creaţi unul propriu. Să vedem cum
creăm un mediu chroot şi, pentru o mai bună înţelegere a modului de
funcţionare, îl vom testa cu <c>bash</c> (un mod uşor de a învăţa).
</p>

<p>
Creaţi directorul <path>/chroot</path> cu <c>mkdir chroot</c>. Apoi, aflaţi cu
ce biblioteci dinamice este compilat <c>bash</c> (dacă este compilat cu
<c>-static</c>, acest pas nu este necesar):
</p>

<p>
Următoarea comandă va crea o listă de biblioteci utilizate de <c>bash</c>. 
</p>

<pre caption="Afişarea listei de biblioteci utilizate">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Acum, creaţi mediul pentru <c>bash</c>.
</p>

<pre caption="Crearea mediului chroot pentru bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Apoi, copiaţi fişierele utilizate de <c>bash</c> (<path>/lib</path>) în
directorul <path>lib</path> din chroot şi copiaţi comanda bash în directorul
<path>bin</path> din chroot. Aceasta va crea exact acelaşi mediu, doar cu mai
puţine funcţionalităţi. După copiere, încercaţi-l: <c>chroot /chroot/bash
/bin/bash</c>. Dacă vi se afişează un prompt <path>/</path>, atunci
funcţionează! Altfel, vă va specifica cu precizie ce fişier lipseşte. Unele
biblioteci dinamice depind între ele.
</p>

<p>
Veţi observa că în interiorul mediului chroot nu funcţionează nimic cu excepţia
<c>echo</c>. Aceasta se datorează faptului că nu avem nici o altă comandă
disponibilă în mediul chroot, în afară de bash, iar <c>echo</c> este o
funcţionalitate întegrată.
</p>

<p>
Aceasta este, practic, soluţia prin care puteţi să vă creaţi un serviciu în
mediul chroot. Singura diferenţă este că serviciile, uneori, se bazează pe
fişiere dispozitiv şi pe fişiere de configurare din <path>/etc</path>. Trebuie
doar să le copiaţi (fişierele dispozitiv pot fi copiate cu <c>cp -a</c>) în
mediul chroot, să editaţi script-ul de iniţializare pentru a utiliza mediul
chroot înainte de execuţie. Poate fi dificil să găsiţi fişierele dispozitiv şi
cele de configurare necesare unui serviciu. Aici devine la îndemână comanda
<c>strace</c>. Porniţi serviciul bash cu <c>/usr/bin/strace</c> şi căutaţi
comenzile open, read, stat şi, poate, conect. Aceasta vă va da un indiciu
despre ce fişiere să copiaţi. Dar, în cele mai multe cazuri, trebuie doar să
copiaţi fişierul passwd (editaţi copia şi ştergeţi toţi utilizatorii ce nu au
legătură cu serviciul), <path>/dev/zero</path>, <path>/dev/log</path> şi
<path>/dev/random</path>.
</p>

</body>
</section>
<section>
<title>User Mode Linux</title>
<body>

<p>
O altă modalitate de a crea un mediu mai securizat, este prin rularea unei
maşini virtuale. O maşină virtuală, aşa cum sugerează şi numele, este un proces
ce rulează desupra sistemului de operare real, oferind un suport hardware şi un
sistem de operare ce pare a fi o maşină unică, separată. Beneficiul de
securitate este faptul că, dacă aplicaţia server ce rulează în maşina virtuală
este compromisă, doar server-ul virtual este afectat şi nu instalarea părinte.
</p>

<p>
Pentru mai multe informaţii despre cum să setaţi User Mode Linux, consultaţi
<uri link="http://www.gentoo.org/doc/ro/uml.xml">Ghidul User-Mode Linux</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Sisteme Firewall</title>
<section>
<title>Un sistem firewall</title>
<body>

<p>
Oamenii se gândesc adesea că un sistem firewall oferă secutatea fundamentală,
dar se înşeală. În cele mai multe cazuri, un sistem firewall configurat
incorect oferă mai puţină securitate decât în cazul în care nu ar exista deloc.
Un sistem firewall este tot o aplicaţie şi ar trebui să fie tratată ca orice
altă aplicaţie, pentru că, cel mai probabil, conţine erori.
</p>

<p>
Deci, gândiţi-vă înainte de a implementa un sistem firewall! Chiar aveţi nevoie
de unul? Dacă dvs. consideraţi că aveţi nevoie, scrieţi o politică de
securitate despre cum funcţionează, ce tip de sistem firewall este şi cine ar
trebui să opereze cu acesta. Dar, mai întâi, consultaţi acest ghid.
</p>

<p>
Sistemele firewall sunt utilizate pentru două scopuri:
</p>

<ul>
<li>Pentru a ţine utilizatorii (viermii/atacatorii) în afară</li>
<li>Pentru a ţine utilizatorii (angajaţii/copiii) în înterior</li>
</ul>

<p>
În fapt, sunt trei tipuri de sisteme firewall:
</p>

<ul>
<li>Filtrare de pachete</li>
<li>Retransmitere în circuit</li>
<li>Sisteme gateway la nivelul aplicaţie</li>
</ul>

<p>
Un sistem firewall trebuie să fie o maşină dedicată ce nu rulează nici un
serviciu (sau <c>sshd</c>, ca fiind singurul) şi securizat în modul recomandat
în acest ghid.
</p>

</body>
</section>
<section>
<title>Filtrarea de pachete</title>
<body>

<p>
Tot traficul de reţea este transmis sub formă de pachete. Cantităţi însemnate
de trafic sunt împărţite în pachete mici pentru o manipulare mai uşoară şi apoi
reasamblate în momentul sosirii la destinaţie. În antet, fiecare pachet conţine
informaţii despre cum şi unde ar trebui să fie distribuit. Iar această
informaţie este exact ceea ce utilizează un sistem firewall de filtrare de
pachete. Filtrarea este bazată pe:
</p>

<ul>
<li>Permiterea sau interzicerea pachetelor pe baza adresei IP a sursei/destinaţiei</li>
<li>Permiterea sau interzicerea pachetelor pe baza portului sursei/destinaţiei</li>
<li>Permiterea sau interzicerea pachetelor pe baza protocolului</li>
<li>Permiterea sau interzicerea pachetelor pe baza unor opţiuni specifice unui anume protocol</li>
</ul>

<p>
Cu alte cuvinte, această fitrare este bazată pe toate datele conţinute în
antetul unui pachet şi nu pe baza conţinutului.
</p>

<p>
Slăbiciuni:
</p>

<ul>
<li>
  Informaţia adresei dintr-un pachet poate fi o adresă IP eronată (sau, cum se
  spune, falsă - eng. spoofed) de la trasmiţător
</li>
<li>
  Datele sau cererile dintr-un pachet permis pot conţine date nedorite pe care
  un atacator le poate utiliza pentru a exploata erori cunoscute din serviciile
  din spatele sistemului firewall
</li>
<li>De obicei, poate afecta tot sistemul</li>
</ul>

<p>
Avantaje:
</p>

<ul>
<li>Simplu şi uşor de implementat</li>
<li>
  Poate afişa avertismente despre unele posibile atacuri înainte de a se
  întâmpla (spre ex. prin detectarea scanărilor de porturi)
</li>
<li>Bun în oprirea atacurilor SYN</li>
</ul>

<p>
Exemple de fitre de pachete gratuite pentru Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>
<!--FIXME: should SmoothWall really be included, since it uses iptables?-->
<note>
Este recomandat să utilizaţi iptables. Ipchains este învechit.
</note>

</body>
</section>
<section>
<title>Retransmiterea în cicuit</title>
<body>

<p>
Un gateway la nivelul circuitului este un sistem firewall ce validează
conexiunile înainte de a permite schibul de date. Aceasta înseamnă că pur şi
simplu nu permite sau interzice pachete pe baza antetului pachetului, ci
determină dacă conexiunea între cele două capete este validă, în conformitate
cu reguli configurabile, înainte de a deschide o sesiune şi a permite datelor
să fie interchimbate. Filtrarea este bazată pe:
</p>

<ul>
<li>Adresa IP a sursei/destinaţiei</li>
<li>Portul sursei/destinaţiei</li>
<li>O perioadă de timp</li>
<li>Protocol</li>
<li>Utilizator</li>
<li>Parolă</li>
</ul>

<p>
Tot traficul este validat şi monitorizat, iar traficul nedorit este oprit.
</p>

<p>
Slăbiciuni:
</p>

<ul>
<li>
  Operează în nivelul de Transport şi poate necesita modificări substanţiale
  programelor ce oferă în mod normal funcţii de transport.
</li>
</ul>

</body>
</section>
<section>
<title>Sisteme gateway la nivelul aplicaţie</title>
<body>

<p>
Sistemul gateway la nivelul aplicaţie este un proxy pentru aplicaţii,
interschimbând datele cu sistemele la distanţă cu voia clienţilor. Este
protejat de public în mod securizat în spatele unei structuri DMZ
(De-Militarized Zone - Zonă De-Militarizată: partea dintr-o reţea privată care
este vizibilă printr-un sistem firewall) sau unui sistem firewall ce nu permite
nici o conexiune din exterior. Fitrarea se bazează pe:
</p>

<ul>
<li>Permiterea sau interzicerea pe baza adresei IP a sursei/destinaţiei</li>
<li>Pe baza conţinului pachetului</li>
<li>Limitarea accesului la fişiere pe baza tipului fişierului sau extensiei acestuia</li>
</ul>

<p>
Avantaje:
</p>

<ul>
<li>Poate reţine în memoria cache fişierele, mărind performanţele reţelei</li>
<li>Înregistrarea detaliată în jurnal a tuturor conexiunilor</li>
<li>Este foarte scalabil (unele aplicaţii proxy pot "partaja" datele reţinute în memoria cache)</li>
<li>Nu există acces direct către exterior</li>
<li>Se poate chiar modifica conţinutul pachetului în timpul procesării</li>
</ul>

<p>
Slăbiciuni:
</p>

<ul>
<li>Configurarea este complexă</li>
</ul>

<p>
Sistemele gateway la nivelul aplicaţie sunt considerate a fi cele mai sigure
soluţii deoarece nu trebuie să ruleze ca root şi sistemele gazdă din spatele
acestora nu sunt accesibile din internet.
</p>

<p>
Exemplu de sistem gateway la nivelul aplicaţie, gratuit:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
Pentru a putea utiliza iptables, trebuie să îl aveţi activat în kernel. Eu am
adăugat iptables ca module (comanda <c>iptables</c> le va încărca în funcţie de
necesitate) şi mi-am recompilat kernel-ul (dar poate aţi dori să compilaţi
iptables, dacă intenţionaţi să dezactivaţi Loadable Kernel Modules, aşa cum am
amintit anterior). Pentru mai multe informaţii despre configurarea kernel-ului
pentru iptables, vizitaţi <uri link =
"http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Tutorial
Iptables, Capitolul 2: Prepararări</uri>. După ce aţi compilat noul kernel (sau
în timp ce compilaţi kernel-ul), trebuie să adăugaţi comanda <c>iptables</c>.
Rulaţi doar <c>emerge iptables</c>, şi ar trebui să funcţioneze.
</p>

<p>
Acum, testaţi dacă funcţionează, rulând <c>iptables -L</c>. Dacă ceva
returnează eroare, atunci există o neregulă şi va trebui să verificaţi încă o
dată configuraţia.
</p>

<p>
Iptables este noul şi mult îmbunătăţitul filtru de pachete din versiunea de
kernel 2.4.x. Este succesorul filtrului de pachete anterior din versiunea de
kernel Linux 2.2.x. Una din îmbunătăţirile majore este faptul că iptables poate
efectua o filtrare dinamică, în funcţie de stare, pentru pachete. În cazul
filtrării de pachete dinamice, este posibilă păstrarea stărilor conexiunii TCP.
</p>

<p>
O conexiune TCP constă într-o serie de pachete ce conţin informaţii despre
adresa IP a sursei, adresa IP a destinaţiei, portul sursă şi un număr al
secvenţei, pentru ca pachetele să poată fi reasamblate în momentul pierderii
datelor. TCP este un protocol orientat pe conexiune, în contrast cu UDP care nu
depinde de conexiune.
</p>

<p>
Prin examinarea antetului unui pachet TCP, un filtru de pachete dinamic poate
determina dacă un pachet recepţionat face parte dintr-o conexiune deja
stabilită sau nu şi decide dacă să accepte sau să refuze pachetul.
</p>

<p>
Cu ajutorul unui filtru de pachete static, care nu determină starea conexiunii,
este posibil să se înşele acest fitru în a accepta pachete ce ar trebui să fie
refuzate, prin manipularea anteturilor TCP ale pachetelor. Aceasta se poate
efectua prin manipularea indicatorului SYN sau a altor indicatori din antetul
TCP pentru a determina un pachet cu caracter maliţios să apară ca fiind parte a
unei conexiuni deja stabilite (deoarece filtrul de pachete însuşi nu poate
determina starea conexiunii). Cu ajutorul filtrării dinamice de pachete, este
posibil refuzul acestor pachete, deoarece nu sunt parte a unei conexiuni deja
stabilite. Aceasta va opri, de asemenea, posibilitatea "scanărilor ascunse", un
tip de scanare a porturilor în care aplicaţia scanner trimite pachete cu
indicatori ce este foarte probabil să nu fie reperaţi şi înregistraţi în jurnal
de sistemul firewall decât pachetele normale SYN.
</p>

<p>
Iptables oferă mai multe funcţionalităţi precum NAT (Network Address
Translation - Translatarea Adresei de Reţea) şi limitarea ratelor de
transmisie. Limitarea ratelor de transmisie este foarte utilă în momentul
prevenirii unui anumit atac DoS (Denial of Service), precum transmiterea masivă
de pachete SYN.
</p>

<p>
O conexiune TCP este stabilită de un aşa-numit salut în trei paşi. În momentul
stabilirii unei conexiuni TCP, clientul transmite un pachet părţii server, cu
indicatorul SYN activat. Când partea server recepţionează pachetul SYN, acesta
răspunde înapoi cu un pachet SYN+ACK, clientului. Când pachetul SYN+ACK este
recepţionat de client, acest răspunde cu un al treilea pachet ACK, confirmând
conexiunea.
</p>

<p>
Un atac de tip SYN flood este efectuat prin trimiterea pachetului SYN, dar
nerăspunzând cu pachetul SYN+ACK. Clientul poate modifica un pachet cu o adresă
IP sursă falsă, pentru că nu are nevoie de răspuns. Sistemul server va adăuga o
intrare într-o coadă a conexiunilor pe-jumătate deschise când recepţionează
pachetul SYN şi va aştepta pachetul final ACK înainte de a şterge intrarea din
coadă. Coada de aşteptare are un număr limitat de intrări, şi dacă toate
intrările sunt ocupate nu mai poate deschide alte conexiuni. Dacă un pachet ACK
nu este recepţionat înainte de un timp de aşteptare, intrarea este ştearsă
automat din coadă. Timpii de aşteptare variază, de obicei, între 30-60 secunde
sau chiar mai mult. Clientul iniţiază atacul prin falsificarea multor pachet
SYN cu adrese IP sursă diferite şi le transmite către o adresă IP ţintă cât mai
repede posibil, astfel determinând umplerea cozii de conexiuni pe-jumătate
deschise şi astfel, prevenind ca alţi clienţi să stabilească o conexiune
legitimă cu server-ul.
</p>

<p>
Aici intervine limitarea ratei de transmisie la îndemână. Este posibil să
limităm rata de transmisie a pachetelor SYN acceptate prin utilizarea <c>-m
limit --limit 1/s</c>. Aceasta va limita numărul de pachete SYN acceptate la
unul pe secundă, astfel restrictionând transmiterea masivă de pachete SYN
resurselor noastre.
</p>

<note>
Altă opţiune în prevenirea atacurilor SYN sunt <uri link =
"http://cr.yp.to/syncookies.html">cookie-urile SYN</uri>, ce permit sistemului
să răspundă cu pachete SYN fără a umple spaţiul cozii de conexiuni.
Cookie-urile SYN pot fi activate în configuraţia kernel-ului Linux, dar sunt la
nivel experimental în acest moment.
</note>

<p>
Acum, câte ceva practic!
</p>

<p>
Când iptables este încărcat în kernel, el deschide 5 legături unde vă puteţi
plasa regulile. Aceastea sunt denumite <c>INPUT</c>, <c>OUTPUT</c>,
<c>FORWARD</c>, <c>PREROUTING</c> şi <c>POSTROUTING</c>. Fiecare din acestea
este denumit lanţ şi conţine o listă de reguli. Fiecare regulă specifică faptul
că, dacă antetul unui pachet are un conţinut, atunci iată ce se face cu
pachetul. Dacă regula nu se potriveşte pachetului, următoarea regulă din lanţ
este analizată.
</p>

<p>
Vă puteţi plasa regulile direct în cele 5 lanţuri, sau să creati noi lanţuri şi
să le adăugaţi ca regulă într-un lanţ deja existent. Iptables suportă
următoarele opţiuni.
</p>

<table>
<tr>
  <th>Opţiune:</th>
  <th>Descriere:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>Adăugare</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>Ştergere</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>Introducere</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>Înlocuire</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>Afişare</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>Ştergerea tuturor regulilor din lanţ sau toate lanţurile</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>Reporneşte de la zero numărătoarele din lanţ sau din toate lanţurile</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>Testarea pachetului în lanţ</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>Crearea unui lanţ nou, definit de utilizator</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>Ştergerea unui lanţ definit de utilizator</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>Modificarea politicii lanţului la o ţintă</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>Modificarea numelui lanţului</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>Protocol</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>Adresa/masca sursă</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>Adresa/masca destinaţie</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>Numele intrării (numele ethernet)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>Numele ieşirii (numele ethernet)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>Jump (ţinta pentru regulă)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>Potrivire extinsă (este posibilă utilizarea extensiilor)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>Afişarea numerică a adreselor şi porturilor</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>Tabela de manipulat</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>Modul informativ</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>Extinderea numerelor (afişarea valorilor exacte)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>Potrivirea doar a fragmentului următor sau a celor ce urmează</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>Versiunea pachetului</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>Afişează numărul de linii pe ecran</ti>
</tr>
</table>

<p>
Mai întâi, vom încerca să blocăm toate pachetele ICMP destinate maşinii
noastre, doar pentru a ne familiariza cu iptables.
</p>

<pre caption="Blocarea tuturor pachetelor ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Mai întâi specificăm lanţul în care regula noastră ar trebui să fie adăugată,
apoi protocolul pachetelor ce trebuie înregistrate şi, în final, ţinta. Ţinta
poate fi numele unui lanţ specificat sau una din ţintele noastre speciale
<c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c> sau
<c>MASQUERADE</c>. În acest caz, utilizăm <c>DROP</c>, ce va refuza pachetul
fără a-i răspunde clientului.
</p>

<note>
Ţinta <c>LOG</c> este, ceea ce se numeşte, "ne-terminală". Dacă un pachet se
potriveşte unei reguli cu ţinta <c>LOG</c>, în loc să se oprească evaluarea,
pachetul va continua să fie supus următoarelor reguli. Aceasta vă permite să
înregistraţi în jurnal pachetele şi aceasta să fie procesate normal.
</note>

<p>
Acum, încercaţi <c>ping localhost</c>. Nu veţi primi nici un răspuns, deoarece
iptables va refuza toate pachetele ICMP venite. De asemenea, nu veţi putea
transmite ping altor maşini, deoarece pachetul de răspuns ICMP va fi refuzat,
din nou. Acum, ştergeţi lanţul pentru avea fluxul ICMP din nou funcţional.
</p>

<pre caption="Ştergerea tuturor regulilor">
# <i>iptables -F</i>
</pre>

<p>
Acum, să analizăm filtrarea dinamică de pachete din iptables. Dacă am fi dorit
să activăm inspecţia dinamică a pachetelor ce sosesc pe interfaţa eth0, am fi
rulat comanda:
</p>

<pre caption="Acceptarea pachetelor originare dintr-o conexiune deja stabilită">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Aceasta va accepta orice pachet dintr-o conexiune deja stabilită sau în relaţie
cu lanţul INPUT. De asemenea, aţi putea să ştergeţi orice pachet ce nu este în
tabela de stări prin execuţia comenzii <c>iptables -A INPUT -i eth0 -m state
--state INVALID -j DROP</c> chiar înaintea comenzii anterioare. Aceasta
activează fitrarea de pachete dinamică în iptables, prin încărcarea extensiei
"state". Dacă aţi fi dorit ca alţi utilizatori să se conecteze la maşina dvs.,
aţi fi putut utiliza indicatorul <c>--state NEW</c>. Iptables conţine unele
module pentru scopuri diferite. Unele dintre acestea sunt:
</p>

<table>
<tr>
  <th>Modul/Potrivire</th>
  <th>Descriere</th>
  <th>Opţiuni extinse</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>Încarcă extensia pentru adresa mac a pachetelor ce sosesc.</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>Activează inspecţia dinamică</ti>
  <ti>--state (stările sunt ESTABLISHED ,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>Limitarea ratei de transmisie</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>Încearcă să potrivească unele caracteristici ale creatorului pachetului</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>Unele verificări aleatoare în plus pentru pachete</ti><ti></ti>
</tr>
</table>

<p>
Să încercăm să creăm un lanţ definit de utilizator şi să îl aplicăm unui lanţ
deja existent:
</p>

<pre caption="Crearea unui lanţ definit de utilizator">
<comment>(Creaţi un nou lanţ cu o singură regulă)</comment>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(Politica implicită pentru traficul spre exterior este permisivă. Traficul spre interior este interzis.)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(Şi adăugarea in lanţul INPUT)</comment>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
Prin aplicarea regulii lanţului de intrare, obţinem politica: toate pachetele
spre exterior sunt permise şi toate pachetele spre interior sunt oprite.
</p>

<p>
Se poate găsi documentaţie pe pagina de <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">documentaţie
Netfilter/iptables</uri>.
</p>

<p>
Să vedem un exemplu complet. În acest caz, politica sistemului firewall/gateway
afirmă:
</p>

<ul>
<li>Conexiunile spre sistemul firewall sunt permise doar prin SSH (portul 22)</li>
<li>
  Reţeaua locală ar trebui să aibă acces la HTTP, HTTPS şi SSH (DNS at trebui,
  de asemenea, permis)
</li>
<li>
  Traficul ICMP poate conţine informaţii nenecesare şi nu ar trebui să fie
  acceptat. Bineînţeles, trebuie să permitem o parte din traficul ICMP.
</li>
<li>Scanările de porturi ar trebui detectate şi înregistrate</li>
<li>Atacurile SYN ar trebui ocolite</li>
<li>Tot restul traficului ar trebui să fie oprit şi înregistrat</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default rule
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffic
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Incoming traffic
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #outgoing traffic
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Catch portscanners
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Apply and add invalid states to the chains
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Allow client to route through via NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<p>
Unele sfaturi la crearea unui sistem firewall:
</p>

<ol>
<li>Creaţi politica sistemul dvs. firewall înainte de a-l implementa</li>
<li>Păstraţi-l simplu</li>
<li>
  Să ştiţi cum functionează fiecare protocol (citiţi documentele <uri
  link="http://www.ietf.org/">RFC</uri>(Request For Comments) relevante)
</li>
<li>
  Aminiţi-vă că sistemul firewall este doar o aplicaţie care rulează ca root.
</li>
<li>Testaţi-vă sistemul dvs. firewall</li>
</ol>

<p>
În cazul în care consideraţi că iptables este greu de înţeles sau ia mult timp
pentru a-l înţelege ori ia mult timp pentru a seta un sistem firewall decent,
puteţi utiliza <uri link="http://www.shorewall.net">Shorewall</uri>. În
principiu acesta utilizează iptables pentru a genera reguli firewall, dar se
concentrează pe reguli şi nu pe anumite protocoale.
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid este o aplicaţie server proxy foarte puternică. Poate filtra traficul pe
baza timpului, expresiilor regulate aplicate căilor/componentelor URI,
adreselor IP ale sursei şi destinaţiei, domeniului, aplicaţiei browser,
autentificării utilizatorului, tipului componentei MIME şi numărului portului
(protocol). Probabil că am uitat unele funcţionalităţi, dar poate fi greu să
acoperim întreaga listă aici.
</p> 

<p>
În următorul exemplu am adăugat un filtru pentru spaţii publicitare, în locul
unui filtru pentru site-urile porno. Motivul pentru aceasta este că Gentoo.org
<e>nu</e> trebuie să fie afişat ca un site porno. Şi nu vreau să-mi pierd
timpul încercând să găsesc unele site-uri bune pentru dvs.
</p>

<p>
În acest caz, politica mea afirmă:
</p>

<ul>
<li>
  Navigarea (HTTP/HTTPS) este permisă în timpul orelor de lucru (luni-vineri
  8-17 şi sâmbătă 8-13), dar dacă angajaţii rămân până târziu, ar trebui să
  muncească nu să navigheze
</li>
<li>
  Descărcarea fişierelor nu este permisă (.exe, .com, .arj, .zip, .asf, .avi,
  .mpg, .mpeg, etc)
</li>
<li>
  Nu agreem spaţiile publicitare, deci acestea sunt filtrate şi înlocuite cu o
  imagine gif transparentă (aici intervine creativitate dvs.!).
</li>
<li>
  Toate celelalte conexiuni spre şi din Internet sunt interzise.
</li>
</ul>

<p>
Aceasta se implementează în 4 paşi <e>simpli</e>.
</p>

<pre caption="/etc/squid/squid.conf">
# Ascultă pe o adresă ip şi un port
http_port 10.0.2.1:3128

# Configuraţia standard
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Adăugarea unor liste de control al accesului de bază
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Adăugarea celor care pot accesa server-ul proxy
acl localnet src 10.0.0.0/255.255.0.0

# Şi a porturilor
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Adăugarea unei liste de control al accesului pe baza unor expresii
# regulate pentru componentele url
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Adăugarea unor liste de control al accesului pe baza orei şi zilei
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# permite accesul managerului de pe localhost
http_access allow manager localhost
http_access deny manager

# Permite cererile de curăţare de la localhost
http_access allow purge localhost
http_access deny purge

# Interzice cererile pentru porturile necunoscute
http_access deny !Safe_ports

# Interzice CONNECT pe alte porturi decât cele SSL
http_access deny CONNECT !SSL_ports

# Regulile mele proprii

# Adăugaţi o pagină pentru a fi afişată
# când un spaţiu publicitar este îndepărtat
deny_info NOTE_ADS_FILTERED url_ads

# Apoi interziceţi-le
http_access deny url_ads

# Interziceţi toate arhivele
http_access deny archives

# Restricţionaţi accesul doar la orele de lucru
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Interziceţi restul
http_access deny all
</pre>

<p>
Urmează completarea fişierelor ce nu dorim să fie descărcate de utilizatorii
dvs. Am adăugat fişierele zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg,
au, ra, arj, tar, gz şi z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Vă rugăm să notaţi parantezele [] ce conţin majuscule şi minuscule pentru
fiecare caracter. Aceasta se introduce pentru ca nimeni să nu păcălească
filtrul prin accesarea unui fişier denumit AvI în loc de avi.
</note>

<p>
Urmează adăugarea expresiilor regulate pentru identificarea spaţiilor
publicitare. Probabil, dvs. veţi fi mult mai creativi decât mine:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Şi ultima parte constă în afişarea următorului fişier în momentul în care un
spaţiu publicitar este îndepărtat. Practic, este o jumătate de fişier html cu o
imagine gif transparentă de dimensiunea 4x4.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
Nu închideţi tag-urile &lt;HTML&gt; şi &lt;BODY&gt;. Această operaţie va fi
efectuată de squid.
</note>

<p>
După cum puteţi observa, Squid are multe posibilităţi şi este foarte eficient,
atât la filtrare cât şi la nivelul proxy. Puteţi chiar să utilizaţi şi alte
aplicaţii proxy Squid pentru scalarea în reţele foarte mari. Configuraţi
exmplificată aici este potrivită mai degrabă pentru o reţea mică ce conţine
1-20 utilizatori.
</p>

<p>
Dar, combinarea filtrului de pachete (iptables) şi sistemul gateway de la
nivelul aplicaţie (Squid) este, probabil, cea mai bună soluţie, chiar dacă
Squid se află într-o locaţie sigură şi nimeni nu îl poate accesa din exterior.
Încă trebuie să fim atenţi la atacurile din interior.
</p>

<p>
Acum, trebuie să configuraţi aplicaţiile browser ale clienţilor pentru
utilizarea aplicaţiei server proxy. Sistemul gateway va preveni utilizatorii să
aibă orice contact cu exteriorul, decât dacă utilizează sistemul proxy.
</p>

<note>
În Mozilla, acesta se setează în Edit->Preferences->Advanced->Proxies.
</note>

<p>
Operaţia mai poate fi făcută transparent, prin utilizarea iptables să transmită
mai departe tot traficul spre exterior spre aplicaţia proxy, Squid. Aceasta se
poate face prin adăugarea unei reguli de transmitere mai departe/prerutare în
sistemul gateway:
</p>

<pre caption="Activarea retransmiterii portului spre aplicaţia noastră proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Dacă aplicaţia proxy rulează pe un sistem de fitrare de pachete -- deşi nu este
recomandat, dar poate fi necesar în cazul în care nu aveţi maşini suficiente --
utilizaţi ţinta <c>REDIRECT</c> în locul <c>DNAT</c> (<c>REDIRECT</c>
redirectează pachetele la localhost).
</note>

</body>
</section>
<section>
<title>Lecţii învăţate</title>
<body>

<p>
Am învăţat că:
</p>

<ol>
<li>
  Un sistem firewall poate reprezenta un risc. Un sistem firewall configurat
  incorect este mai rău decât a nu avea nici unul.
</li>
<li>Cum să setăm un sistem gateway de bază şi un sistem proxy transparent.</li>
<li>
  Cheia unui sistem firewall bun este să cunoaşteţi protocoalele pe care doriţi
  să le permiteţi.
</li>
<li>
  Traficul IP nu conţine întotdeauna date legitime, de ex. pachetele ICMP care
  pot avea un conţinut cu caracter maliţios.
</li>
<li>Cum să prevenim atacurile SYN.</li>
<li>
  Filtrarea traficului HTTP, prin îndepărtarea imaginilor ofensive şi
  descărcarea de viruşi.
</li>
<li>
  Combinarea filtrării pachetelor şi a sistemelor gateway, oferă un control mai
  bun.
</li>
</ol>

<p>
Acum, dacă <e>chiar</e> doriţi, mergeţi şi creaţi un sistem firewall ce se
potriveşte nevoilor dvs.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Detecţia intruziunii</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment)</title>
<body>

<p>
AIDE este un sistem Host-Based Intrusion Detection System (HIDS), o alternativă
gratuită la Tripwire (dacă deja cunoaşteţi Tripwire nu ar trebui să întâmpinaţi
dificultăţi în învăţarea configurării AIDE). Sistemele HIDS sunt utilizate în
detecţia modificărilor în fişierele de configurare generale ale sistemului şi a
binarelor, în general prin crearea unei semnături criptografice unice pentru
fişierele şi stocarea acestora într-o locaţie sigură. În mod regulat (cum ar
fi, zilnic), semnătura stocată ştiută a fi corectă este comparată cu cea
generată din copia curentă a fiecărui fişier, pentru a determina dacă fişierul
a fost modificat. Sistemele HIDS sunt o modalitate bună de a detecta
modificările nepermise sistemului dvs., dar necesită mai multă muncă pentru a
le implementa şi utiliza corect.
</p>

<p>
Fişierul de configurare este bazat pe expresii regulate, macro-uri şi reguli
pentru fişiere şi directoare. Avem următoarele macro-uri:
</p>

<table>
<tr>
  <th>Macro</th>
  <th>Descriere</th>
  <th>Sintaxă</th>
</tr>
<tr>
  <ti>ifdef</ti>
  <ti>Dacă a fost definit</ti>
  <ti>@@ifdef "nume"</ti>
</tr>
<tr>
  <ti>ifndef</ti>
  <ti>Dacă nu a fost definit</ti>
  <ti>@@ifndef "nume"</ti>
</tr>
<tr>
  <ti>define</ti>
  <ti>Defineşte o variabilă</ti>
  <ti>@@define "nume" "valoare"</ti>
</tr>
<tr>
  <ti>undef</ti>
  <ti>Indefineşte o variabilă</ti>
  <ti>@@undef "nume"</ti>
</tr>
<tr>
  <ti>ifhost</ti>
  <ti>Dacă "hostname"</ti>
  <ti>@@ifhost "hostname"</ti>
</tr>
<tr>
  <ti>ifnhost</ti>
  <ti>Dacă nu "hostname"</ti>
  <ti>@@ifnhost "hostname"</ti>
</tr>
<tr>
  <ti>endif</ti>
<ti>
  Endif trebuie utilizat după fiecare din macro-urile anterior, cu excepţia
  define şi undef
</ti>
<ti>@@endif</ti>
</tr>
</table>

<p>
Aceste macro-uri devin foarte la îndemână, dacă aveţi mai mult de un sistem
Gentoo şi doriţi să utilizaţi AIDE pe toate. Dar nu toate maşinile rulează
aceleaşi servicii şi nici măcar aceeaşi utilizatori.
</p>

<p>
Apoi, avem seturi de indicatori de verificare pentru fişiere şi directoare.
Acestea reprezintă combinaţii de permisiuni, proprietăţi ale fişierelor şi
semnături criptografice (spre ex. sume de control).
</p>

<table>
<tr>
  <th>Indicator</th>
  <th>Descriere</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>permisiuni</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>inod</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>numărul de link-uri</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>utilizator</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>grup</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>mărime</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>numărul de blocuri</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>mtime (timpul modificării)</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>atime (timpul accesului)</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>ctime (timpul creării)</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>verificarea mărimii de creştere</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>suma de control md5</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>suma de control sha1</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>suma de control rmd160</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>suma de control tiger</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>Grup gol</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>Creşterea fişierul jurnal p+u+g+i+n+S</ti>
</tr>
</table>

<p>
Iar, dacă AIDE este compilat cu suport mhash, atunci mai suportă încă unele
funcţionalităţi:
</p>

<table>
<tr>
<th>Indicator</th>
<th>Descriere</th>
</tr>
<tr>
<ti>haval</ti>
<ti>suma de control</ti>
</tr>
<tr>
<ti>gost</ti>
<ti>suma de control gost</ti>
</tr>
<tr>
<ti>crc32</ti>
<ti>suma de control crc32</ti>
</tr>
</table>

<p>
Acum, vă puteţi crea propriile dvs. reguli pe baza indicatorilor explicaţi
anterior prin combinarea lor, ca în următorul exemplu:
</p>

<pre caption="Crearea unui set de reguli pentru AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Ultimul lucru pentru crearea fişierului de configurare este să vedem cu să
adăugăm o regulă unui fişier sau director. Pentru a introduce o regulă,
combinaţi numele fişierului sau directorului şi regula. AIDE va adăuga
fişierele recursiv, dacă nu specificaţi o regulă alternativă.
</p>

<table>
<tr>
<th>Indicatori</th>
<th>Descriere</th>
</tr>
<tr>
<ti>!</ti>
<ti>Nu adaugă acest fişier sau director.</ti>
</tr>
<tr>
<ti>=</ti>
<ti>Adaugă acest director, dar nu recursiv.</ti>
</tr>
</table>

<p>
Deci, haideţi să vedem un exemplu complet:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# Locaţia bazei de date ce trebuie citită.
database=file:@@{AIDEDIR}/aide.db

# Locaţia bazei de date ce trebuie scrisă.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Definiţia regulilor
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
În exemplul de mai sus, specificăm în unele macro-uri, de unde începe
directorul superior şi unde este localizat directorul AIDE. AIDE compară
fişierul <path>/etc/aide/aide.db</path> când verifică integritatea fişierului.
Dar, când actualizează sau crează un fişier nou, acesta stochează informaţia în
<path>/etc/aide/aide.db.new</path>. Acesta pentru ca să nu suprascrie automat
fişierul db vechi. Opţiunea <c>report_URL</c> nu este implementată, încă, dar
intenţia autorului a fost să poată trimite un email sau chiar să execute
script-uri.
</p>

<p>
După editarea fişierului de configurare, ar trebui să vă creaţi fişierul dvs.
db prin execuţia <c>aide -i</c> şi apoi să copiaţi fişierul
<path>/etc/aide/aide.db.new</path> ca <path>/etc/aide/aide.db</path> şi să
adăugaţi verificarea în cron prin executarea <c>crontab -e</c> ca root.
</p>

<note>
În funcţie de procesorul dvs., viteza de acces la disc şi indicatorii pe care
i-aţi setat pe fişiere, această operaţie poate dura ceva timp.
</note>

<pre caption="Programarea aide în cron">
0 3 * * * /usr/bin/aide -u
</pre>

<note>
Aminitiţi-vă să setaţi un alias pentru a putea verifica mesajele utilizatorului
root. Altfel, nu veţi şti niciodată ce raportează AIDE.
</note>

<p>
În acest caz, este rulat o dată la 3am. Aceasta, pentru a nu deranja
utilizatorii în timp ce aceştia lucrează. Notaţi faptul că utilizez opţiunea
<c>-u</c> (Update - Actualizare) în locul opţiunii <c>-C</c> (Check -
Verificare). Deoarece <c>-u</c> verifică, de asemenea, fişierele şi nu
suprascrie fişierul db original, mai salvează timp deoarece tot ceea ce trebuie
să faceţi este să copiaţi un fişier când sunt detectate modificări. Trebuie
doar să verificaţi modificările pentru a vă asigura că dvs. le-aţi efectuat în
loc de un atacator, înainte de a le copia!
</p>

<p>
Acum, există un risc inerent când stocaţi fişierele db local, deoarece
atacatorul (dacă ştie că AIDE este instalat) mai mult ca sigur va încerca să vă
altereze fişierul db, să îl actualizeze sau să modifice
<path>/usr/bin/aide</path>. Deci, va trebui să creaţi un CD sau un alt suport
media şi să stocaţi o copie a fişierului .db şi binarele AIDE.
</p>

<p>
Se pot găsi informaţii pe pagina proiectului <uri
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort este un Network Intrusion Detection System (NIDS) - Sistem de Detecţie a
Intruziunii în Reţea. Pentru a-l instala şi configura, utilizaţi următoarele
exemple.
</p>

<pre caption="Adăugaţi utilizatorul snort în sistem">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>(Pasul 1)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(Pasul 2)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(Pasul 3)</comment>
include classification.config

<comment>(Pasul 4)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# CLASIFICĂRI NOI
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Mai multe informaţii pot fi găsite pe site-ul <uri
link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>

<section>
<title>Detecţia aplicaţiilor malware şi chkrootkit</title>

<body>

<p>
Sistemele HIDS, ca AIDE au o metodă bună de detecţie a modificărilor efectuate
în sistemul dvs., dar nu strică să mai deţinem o linie de apărare.
<c>chkrootkit</c> este un utilitar ce scanează fişierele de sistem comune
pentru prezenţa codurilor rootkit -- aplicaţii proiectate să ascundă acţiunile
unui intrus şi să îi permită să îşi meţină accesul -- şi vă scanează sistemul
pentru urme cunoscute ale aplicaţiilor de tip keylogger (ce reţin tastele
apăsate) şi a altor aplicaţii "malware" (cu caracter maliţios). În timp
<c>chkrootkit</c> (şi alte alernative, precum <c>rkhunter</c>) sunt utilitare
folositoare, atât pentru mentenanţa sistemului cât şi pentru urmărirea
intruşilor după ce a fost desfăşurat un atac, ele nu vă pot garanta că sistemul
dvs. este sigur.
</p>

<p>
Cea mai bună soluţie să utilizaţi <c>chkrootkit</c> pentru a detecta o
intruziune, este să-l rulaţi regulat prin intermediul <c>cron</c>. Pentru a
începe, instalaţi <path>app-admin/chkrootkit</path>. <c>chkrootkit</c> poate fi
rulat din linia de comandă prin comanda cu acelaşi nume, sau din <c>cron</c>
printr-o intrare simlară cu următoarea:
</p>

<pre caption="Programarea chkrootkit prin intermediul cron">
0 3 * * * /usr/sbin/chkrootkit
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Menţinerea actualizărilor</title>
<section>
<body>

<p>
Odată ce aţi instalat cu succes sistemul dvs. şi aţi asigurat un bun nivel de
securitate, nu aţi terminat. Securitatea este un proces în desfăşurare; vasta
majoritate a intruziunilor sunt rezultatul unor vulnerabilităţi cunscute în
sistemele nereparate. Menţinerea sistemului dvs. actualizat este singurul şi
cel mai valoros pas pe care puteţi să-l efectuaţi pentru o securitate mai bună.
</p>

<p>
Dacă aveţi o versiune recentă a pachetului <c>portage</c> instalată, puteţi,
mai întâi, să vă sincronizaţi structura portage cu <c>emerge --sync</c> şi apoi
să executaţi comanda <c>glsa-check --list</c> pentru a verifica dacă sistemul
este la zi la nivel de securitate. <c>glsa-check</c> este parte componentă a
pachetului <c>app-portage/gentoolkit</c>.
</p>

<pre caption="Examplu de afişare a comenzii glsa-check -l">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.

[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
Utilitarul <c>glsa-check</c> este încă experimental, deci, dacă securitatea
este prioritatea dvs. ce mai mare, ar fi indicat să verificaţi încă o dată
lista cu alte surse.
</warn>

<p>
Toate liniile ce încep cu <c>[A]</c> şi <c>[U]</c> pot fi, aproape sigur,
ignorate deoarece sistemul nu este afectat de acel GLSA.
</p>

<p>
Unii utilizatori încă preferă să utilizeze <c>emerge numepachet</c> în locul
<c>glsa-check -f</c> deci toate intrările GLSA sunt afişate ca <c>[N]</c>.
</p>

<p>
Dacă doriţi să primiţi un mesaj de oricâte ori este publicat un anunţ GLSA,
subscrieţi-vă la lista de discuţii <c>gentoo-announce</c>. Intrucţiunile pentru
a vă subscrie la aceasta precum şi la alte liste de discuţii pot fi găsite în
documentul <uri link="/main/en/lists.xml">Generalităţi despre Listele de
Discuţii Gentoo Linux</uri>.
</p>

<p>
O altă resursă bună pentru securitate este <uri
link="http://www.securityfocus.com/archive/1">lista de discuţii Bugtraq</uri>.
</p>

</body>
</section>
</chapter>
</guide>
