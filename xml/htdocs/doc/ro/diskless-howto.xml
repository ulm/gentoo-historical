<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/ro/diskless-howto.xml,v 1.14 2006/04/04 04:43:28 alin Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/ro/diskless-howto.xml" lang="ro">

<title>Ghid Gentoo pentru sistemele fără disc</title>

<author title="Autor">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Editor">
    <mail link="unsolo@sysrq.no">Kristian Jerpetjoen</mail>
</author>
<author title="Corector">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Corector">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Translator">
  <mail link="struct_bylighting@yahoo.com">Lucian Constantin</mail>
</author>

<abstract>
Acest ghid vă va ajuta să instalaţi Gentoo Linux pe sistemele fără
disc.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.21</version>
<date>2006-04-02</date>

<chapter>
<title>Introducere</title>

<section>
<title>Despre acest ghid</title>
<body>

<p>
Acest ghid vă va ajuta să instalaţi Gentoo Linux pe maşinile <e>fără
disc</e>. Intenţionăm să facem această descriere cât se poate de
clară, chiar şi pentru un începător, deoarece fiecare dintre noi a fost
aşa ceva la un moment dat :) Pentru utilizatorii Linux mai avansaţi care ar
putea cu uşurinţă să găsească toată această informaţie în
multiple ghiduri despre maşini fără disc şi reţele, sperăm că
acest document vă va uşura munca de instalare, fie utilizatori avansaţi
sau începători.
</p>

</body>
</section>
<section>
<title>Ce este un sistem fără disc?</title>
<body>

<p>
Un calculator fără disc este un sistem PC fără nici un dispozitiv de
boot cum ar fi disc, unitate floppy sau unitate CD-ROM. Calculatorul fără
disc porneşte direct din reţea şi are nevoie de un server să îi ofere
spaţiu de disc în acelaşi mod în care ar face-o un disc local. Începând
de acum, vom numi serverul <e>master</e> iar calculatorul fără disc
<e>slave</e>. Calculatorul slave are nevoie de placă de reţea care să
suporte procesul de boot PXE sau Etherboot. Încercaţi <uri
link="http://www.etherboot.org">Etherboot.org</uri> pentru suport. Majoritatea
plăcilor moderne de reţea, sau cele deja integrate în plăcile de bază
vor funcţiona.
</p>

</body>
</section>
<section>
<title>Înainte de a începe</title>
<body>

<p>
Pe calculatorul master este necesar să aveţi Gentoo instalat şi să
aveţi spaţiu suficient pentru un întreg sistem de fişiere pentru
calculatorele slave. De asemenea, aveţi nevoie de o interfaţă conectată
la internet diferită de cea folosită pentru conectarea în reţeaua
locală.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configurarea sistemelor master şi slave</title>
<section>
<title>Despre kernel</title>
<body>

<note>
Dacă doriţi să construiţi un cluster openMosix, folosiţi patch-ul
openMosix pentru kernel. Acesta poate fi găsit în portage ca
<path>sys-kernel/openmosix-sources</path>. Consultaţi <uri
link="openmosix-howto.xml">Ghidul openMosix</uri> pentru informaţii privind
compilarea kernel-ului utilizând openMosix.
</note>

<p>
Kernel-ul este aplicaţia care interfaţează componentele hardware cu toate
celelalte aplicaţii care rulează pe sistem, fiind, practic, inima
sistemului. Când sistemul este pornit aplicaţia BIOS execută
instrucţiunile găsite pe disc, într-o zonă special dedicată pentru
procesul de boot. În general, aceste instrucţiuni încarcă kernel-ul.
După încărcare, toate procesele sunt gestionate de kernel.
</p>

<p>
Pentru mai multe informaţii despre kernel şi configurarea acestuia
consultaţi <uri link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">Ghidul
pentru kernel</uri>.
</p>

</body>
</section>
<section>
<title>Configurarea kernel-ului pe maşina master</title>
<body>

<p>
Kernel-ul sistemului master poate fi cât de larg şi personalizat doriţi,
dar există un număr de opţiuni de kernel necesare pe care trebuie să le
selectaţi. Navigaţi în meniul de configurare al kernel-ului, tastând:
</p>

<pre caption="Editare configuraţie kernel pentru calculatorul master">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Pe ecran va apare un GUI cenuşiu/albastru care oferă o alternativă la
editarea manuală a fişierului <path>/usr/src/linux/.config</path>. Dacă
programul kernel curent funcţionează bine, este recomandat să salvaţi
configuraţia curentă ieşind din mediul GUI şi tastând:
</p>

<pre caption="Copia de siguranţă pentru configurarea sistemului master">
# <i>cp .config .config_working</i>
</pre>

<p>
Înapoi în GUI, intraţi în următoarele meniuri şi setaţi următoarele
module ca built-in (şi <e>NU</e> ca module). Opţiunile prezentate mai jos se
referă la versiunea 2.6.10 de program kernel. Dacă folosiţi o altă
versiune, meniurile s-ar putea să difere puţin. Trebuie neapărat să
configuraţi după cum se arată mai jos.
</p>

<pre caption="Opţiuni kernel calculator master">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Device Drivers ---&gt;
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)
  
File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support

<comment>
Dacă doriţi să aveţi acces la internet folosind calculatorul master
sau/şi folosind un firewall, trebuie să adăugaţi suport pentru iptables.
</comment>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  ---&gt;
    &lt;*&gt; Connection tracking (required for masq/NAT)
    &lt;*&gt; IP tables support (required for filtering/masq/NAT)
</pre>

<p>
Dacă doriţi să folosiţi packet filtering, îl puteţi adăuga mai
târziu ca modul. Descrierea acestei setări o puteţi găsi în <uri
link="/doc/ro/security/security-handbook.xml?part=1&amp;chap=12">Capitolul
despre Sisteme Firewall din Manualul pentru Securitate în Gentoo</uri>.
</p>

<note>
Opţiunile de configurare trebuie să fie adăugate la configurarea
specifică sistemului dumneavoastră, în nici un caz nu trebuie să
înlocuiască setarea pe care o aveţi deja.
</note>

<p>
După ce aţi reconfigurat kernel-ul sistemului master, trebuie să-l
recompilaţi:
</p>

<pre caption="Recompilare kernel şi module aferente pentru calculatorul master">
# <i>make &amp;&amp; make modules_install</i>
<comment>(Partiţia /boot trebuie să fie mount-ată înainte de a copia pe ea)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
</pre>

<p>
Apoi adăugaţi noul kernel în <path>lilo.conf</path> sau
<path>grub.conf</path> în funcţie de aplicaţia bootloader pe care o
folosiţi, şi setaţi noul kernel ca implicit. Acum, că imaginea bzImage a
fost copiată în directorul dvs. boot, tot ce trebuie să faceţi este să
reporniţi sistemul pentru a încărca noile opţiuni.
</p>

</body>
</section>
<section>
<title>Despre kernel-ul slave</title>
<body>

<p>
Se recomandă să compilaţi kernel-ul slave fără support pentru module,
deoarece încărcarea şi setarea modulelor folosind metoda de pornire din
reţea este complicată şi nu este necesară. În plus, kernel-ul slave
trebuie să fie cât se poate de mic şi compact pentru ca pornirea din
reţea să fie cât mai eficientă. Vom compila în continuare un kernel
slave, în acelaşi loc unde kernel-ul master a fost configurat.
</p>

<p>
Pentru a elimina orice confuzie, este, probabil, o idee bună să salvăm
mai întâi configurarea kernel master, tastând:
</p>

<pre caption="Copia de siguranţă pentru configurarea kernel-ului master">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Dorim să configurăm kernel-ul slave similar cu kernel-ul master. Dacă
doriţi să începeţi cu o configurare nouă, puteţi reface configurarea
implicită <path>/usr/src/linux/.config</path>, astfel:
</p>

<pre caption="Generare configurare kernel implicit">
# <i>cd /usr/src/linux</i>
# <i>cp .config_master .config</i>
</pre>

<p>
Porniţi configurarea GUI:
</p>

<pre caption="Editare configuraţie kernel slave">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Următoarele opţiuni trebuie să fie incluse în kernel şi <e>NU</e>
definite ca module:
</p>

<pre caption="Opţiuni kernel slave">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Device Drivers ---&gt;
  [*] Networking support
  Networking options ---&gt;
    &lt;*&gt; Packet socket
    &lt;*&gt; Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support (NEW)

File systems ---&gt;
  Network File Systems  ---&gt;
    &lt;*&gt; file system support 
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<note>
O metoda alternativă de dhcp este de a seta serverul BOOTP.
</note>

<impo>
Este important să adăugaţi suport pentru adaptorul de reţea în kernel
(şi nu ca module). Folosirea modulelor în general nu este o problemă
pentru un sistem fără disc.
</impo>

<p>
Apoi, trebuie să compilaţi kernel-ul slave. Trebuie să aveţi grijă să
nu distrugeţi modulele deja compilate (dacă există) pentru server:
</p>

<pre caption="Compilare kernel slave">
# <i>cd /usr/src/linux</i>
# <i>make</i>
</pre>

<p>
Apoi creaţi un nou director pe master care va fi folosit pentru fişierele
calculatoarelor slave. Noi folosim <path>/diskless</path>, însă puteţi
folosi orice altă locaţie. Copiaţi fişierul bzImage creat pentru slave
în directorul <path>/diskless</path>:
</p>

<note>
Dacă folosiţi arhitecturi diferite, trebuie să salvaţi fiecare
configurare în <path>.config_arch</path>. Acelaşi lucru se aplică şi la
imagini kernel: le salvaţi în <path>/diskless</path> sub numele de
<path>bzImage_arch</path>.
</note>

<pre caption="Copiere kernel slave">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>

</body>
</section>
<section>
<title>Configurare sistem de fişiere preliminar pentru calculatoarele slave</title>
<body>

<p>
Sistemele de fişiere de pe master şi slave pot fi modificate ulterior. În
acest moment suntem interesaţi numai în generarea unui sistem de fişiere
preliminar care să includă fişierele de configurare şi directoarele
pentru mount. Începem prin a crea un nou director <path>/diskless</path>
pentru primul slave. Fiecare slave va avea un o structură specifică de
fişiere rădăcină deoarece un singur director rădăcină va crea
probleme în ceea ce priveşte permisiile şi ar rezulta în erori. Puteţi
numi în orice fel aceste directoare, sugerăm folosirea adresei IP, care este
unică. Adresa statică de IP a primului nostru slave este de exemplu
<c>192.168.1.21</c>:
</p>

<pre caption="Creare director root la distanţă pentru maşina slave">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Diverse fişiere de configurare în <path>/etc</path> trebuie să fie
modificate pentru a funcţiona pe slave. Copiaţi master <path>/etc</path> în
noul director root slave, tastând:
</p>

<pre caption="Creare /etc pentru sistemul de fişiere al maşinii slave">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Diverse directoare pentru mount şi alte diverse directoare mai trebuie
create. Pentru a le crea, tastaţi:
</p>

<pre caption="Creare directoare de mount pentru sistemul de fişiere al maşinii slave">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/sys</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>chmod a+w /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
# <i>mkdir /diskless/192.168.1.21/var/spool</i>
# <i>mkdir /diskless/192.168.1.21/usr</i>
# <i>mkdir /diskless/192.168.1.21/opt</i>
<comment>(numai pentru openMosix)</comment>
# <i>mkdir /diskless/192.168.1.21/mfs</i>
</pre>

<p>
Majoritatea acestor "părţi" sunt uşor de recunoscut: <path>/dev</path>
<path>/proc</path> sau <path>/sys</path> vor fi populate automat când
calculatorul slave porneşte, celelalte mai târziu folosind facilitatea
mount. Trebuie de asemenea să modificaţi fişierul
<path>/diskless/192.168.1.21/etc/conf.d/hostname</path> pentru a reflecta
numele de gazdă al calculatorului slave. Fişierele binare, bibliotecile
şi toate celelalte fişiere vor fi populate mai târziu în acest ghid,
imediat înainte de a porni calculatorul slave.
</p>

<p>
Chiar dacă directorul <path>/dev</path> este populat ulterior de <c>udev</c>,
va trebui să creaţi intrarea <path>console</path>. În caz contrar, veţi
primi eroarea "unable to open initial console".
</p>

<pre caption="Crearea intrării console în directorul /dev">
# <i>mknod /diskless/192.168.1.21/dev/console c 5 1</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>Configurare server DHCP</title>
<section>
<title>Despre aplicaţia server DHCP</title>
<body>

<p>
DHCP înseamnă Dynamic Host Configuration Protocol (Protocolul de Configurare
Dinamică a Sistemelor Gazdă). Server-ul DHCP este primul calculator cu care
calculatorele slave vor comunica în timpul pornirii PXE. Bazat pe adresa MAC,
serverul DHCP atribuie adrese IP tuturor calculatoarelor din reţea. După
asignarea adresei IP, serverul DHCP va informa calculatorul slave de unde să
îşi descarce sistemul de fişiere şi kernel-ul.
</p>

</body>
</section>
<section>
<title>Înainte de a începe</title>
<body>

<p>
Înainte de a începe, există unele lucruri suplimentare de verificat. Mai
întâi verificaţi că sunteţi conectat la reţea:
</p>

<pre caption="Verificare conectare la reţea">
# <i>ifconfig eth0 multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
Va trebui să vă asiguraţi că aveţi o interfaţă <e>eth0</e>
funcţională. Ar trebui să arate ceva în genul:
</p>

<pre caption="O interfaţă eth0 funcţională">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
Este important să apară ca <e>MULTICAST</e>, în caz că nu, compilaţi
suportul pentru multicast în kernel.
</p>

</body>
</section>
<section>
<title>Instalare server DHCP</title>
<body>

<p>
Dacă reţeaua dvs. nu are un server DHCP, trebuie să instalaţi unul:
</p>

<pre caption="Instalare server DHCP">
# <i>emerge dhcp</i>
</pre>

<p>
Dacă reţeaua are deja un server DHCP instalat, trebuie să editaţi
fişierul de configurare pentru ca PXE boot să funcţioneze corect.
</p>

</body>
</section>
<section>
<title>Configurare server DHCP</title>
<body>

<p>
Există un singur fişier de configurare care trebuie editat înainte ca
serverul DHCP să fie pornit: <path>/etc/dhcp/dhcpd.conf</path>. Copiaţi şi
editaţi următorul exemplu:
</p>

<pre caption="Editare fişier de configurare server DHCP">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
Formatul fişierului este indentat, şi arată ca în următorul exemplu:
</p>

<pre caption="Formatul fişierului dhcpd.conf">
<comment># opţiunile globale</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># opţiunile despre reţeaua partajată</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # opţiunile de reţea despre subnet</comment>
    host slave{
<comment>        # opţiunile specifice sistemelor gazdă</comment>
    }
    group {
<comment>        # opţiunile specifice de grup</comment>
    }
}
}
</pre>

<p>
Blocul <c>shared-network</c> este opţional şi este folosit pentru adrese IP
care aparţin reţelei curente. Cel puţin o reţea <c>subnet</c> trebuie
declarat, iar blocul opţional <c>group</c> vă permite să grupaţi diverse
opţiuni şi să le folosiţi pentru mai multe grupuri de definiţii. Un
exemplu bun de <path>dhcpd.conf</path> este următorul:
</p>

<pre caption="Exemplu dhcpd.conf">
# DHCP configuration file for DHCP ISC 3.0
 
ddns-update-style none;
 
# Definirea opţiunilor specifice pentru PXE
# Code 1: Adresele IP Multicast ale server-ului de fişiere pentru boot
# Code 2: Portul UDP pe care clientul trebuie să monitorizeze răspunsurile MTFTP
# Code 3: Portul UDP pe care server-ele MTFTP îl utilizează pentru a asculta cererile MTFTP
# Code 4: Numărul de secunde pe care trebuie să-l aştepte un client pentru activitate
#         înainte de a începe un nou transfer MTFTP
# Code 5: Numărul de secunde pe care trebuie să-l aştepte înainte de a începe
#         un transfer MTFTP
 
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
 
subnet 192.168.1.0 netmask 255.255.255.0 {
 
  
  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    option vendor-class-identifier "PXEClient";
    vendor-option-space PXE;
 
    # Cel puţin una din opţiunile PXE specifice vendorilor trebuie setate pentru
    # ca cipurile ROM ale clienţilor să realizeze faptul că acesta este un server
    # compatibil PXE. Setăm adresa IP MCAST la 0.0.0.0 pentru a-i specifica cipului ROM
    # că nu oferim suport pentru multicast TFTP (adresa 0.0.0.0 este echivalentă cu nici
    # o adresă).
 
    option PXE.mtftp-ip 0.0.0.0;
 
    # Acesta este numele fişierului pe care cipurile ROM trebuie să-l descarce.
    filename "pxelinux.0";
    # Acesta este numele server-ului de pe care trebuie să-l descarce.
    <comment># Utilizaţi adresa IP a sistemului master</comment>
    next-server 192.168.1.1;
  }

  <comment># Dacă utilizaţi etherboot cu o imagine nespecifică </comment>
  class "etherboot" {
        if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
        filename "/diskless/vmlinuz";
        }
  }
  
  pool {
    max-lease-time 86400;
    default-lease-time 86400;
    <comment># Aceasta previne ca maşinile neafişate să-şi atribuie o adresă IP</comment>
    deny unknown-clients;
  }
 
  host slave21 {
       <comment># Utilizaţi adresa MAC a sistemului slave</comment>
       hardware ethernet                00:40:63:C2:CA:C9;
       <comment># Atribuiţi-i sistemului slave o adresă IP statică</comment>
       fixed-address                    192.168.1.21;
       server-name                      "master";
       <comment># Utilizaţi adresa dvs. IP pentru gateway, dacă este necesar</comment>
       option routers                   192.168.1.1;
       <comment># Utilizaţi adresa dvs. IP pentru DNS, dacă este necesar</comment>
       option domain-name-servers       192.168.1.1;
       option domain-name               "mydomain.com";
       <comment># Utilizaţi numele de gazdă al sistemului dvs. slave</comment>
       option host-name                 "slave21";
       
       
       <comment># Proces de boot etherboot şi pxe cu imagine mac specifică</comment>
       option root-path                 "/diskless/192.168.1.21";
       
       if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
                        filename "/vmlinuz_arch";
        } else if substring (option vendor-class-identifier, 0,9) ="PXEClient" {
                        filename "/pxelinux.0";
        }
                                                               
  }
}
</pre>

<note>
Nimic nu vă împiedică să folosiţi PXE boot şi Etherboot împreună.
Codul anterior este un simplu exemplu; dacă aveţi probleme, vă rugăm
să consultaţi documentaţia DHCPd.
</note>

<p>
Adresa de IP după <c>next-server</c> va fi interogată pentru fişierul
<c>filename</c> specificat. Această adresă IP ar trebui să fie adresa IP
serverului tftp, de obicei aceeaşi cu adresa de IP a sistemului master.
Fişierul <c>filename</c> este relativ la directorul <path>/diskless</path>
(opţiunile specifice serverului tftp vor fi descrise mai târziu). Opţiunea
<c>hardware ethernet</c> din blocul <c>host</c> specifică o adresă de MAC,
iar <c>fixed-address</c> atribuie o adresă de IP fixă acestei adrese MAC
particulare. Este bine să includeţi opţiunea <c>host-name</c>, unde
host-name este numele calculatorului slave. Exista o pagină de manual destul
de bună despre <path>dhcpd.conf</path> cu toate opţiunile; descrierea lor
în totalitate aici, depăşeşte scopul acestui ghid. O puteţi consulta
introducând:
</p>

<pre caption="Consultarea paginii de manual dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>
<section>
<title>Pornire server DHCP</title>
<body>

<p>
Înainte de a porni script-ul de iniţializare dhcp, editaţi fişierul
<path>/etc/conf.d/dhcp</path> ca în exemplul următor:
</p>

<pre caption="Exemplu fişier /etc/conf.d/dhcp">
IFACE="eth0"
<comment># adăugaţi alte opţiuni necesare</comment>
</pre>

<p>
Variabila <c>IFACE</c> este interfaţa pe care doriţi să rulaţi serverul
DHCP, în cazul nostru <c>eth0</c>. Pentru o topologie de reţea mai
complicată cu mai multe interfeţe de Ethernet, puteţi adăuga mai multe
argumente variabilei <c>IFACE</c>. Pentru a porni serverul dhcp, introduceţi:
</p>

<pre caption="Pornire server dhcp pe calculatorul master">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
Adăugaţi serverul dhcp între script-urile de pornire:
</p>

<pre caption="Adăugaţi serverul dhcp pe nivelul de iniţializare default al calculatorului master">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>
<section>
<title>Rezolvarea problemelor legate de DHCP</title>
<body>

<p>
Pentru a verifica procesul de pornire al unui calculator, analizaţi fişierul
<path>/var/log/messages</path>. Dacă nu sunt probleme, fişierul
<path>messages</path> ar trebui să aibă ceva linii undeva la sfârşit, ca
în următorul exemplu:
</p>

<pre caption="Exemplu linii de log create de dhcp">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
Acest fişier de log poate ajuta şi la aflarea adreselor MAC ale
calculatoarelor slave.
</note>

<p>
Dacă primiţi următorul mesaj, înseamnă, probabil, că există o
problemă cu fişierul de configurare, însă serverul DHCP funcţionează
corect.
</p>

<pre caption="Exemplu eroare server dhcp">
no free leases on subnet LOCAL-NET
</pre>

<p>
De fiecare dată când modificaţi fişierul de configurare, serverul DHCP
trebuie repornit. Pentru a-l reporni, introduceţi:
</p>

<pre caption="Repornire server dhcp pe calculatorul master">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configurare server TFTP şi PXE Linux Bootloader şi/sau Etherboot </title>
<section>
<title>Despre serverul TFTP</title>
<body>

<p>
Serverul TFTP (Trivial File Transfer Protocol) furnizează fişierul kernel
şi sistemul iniţial de fişiere calculatoarelor slave. Copiile fişierelor
kernel şi sistemelor iniţiale de fişiere se găsesc pe serverul TFTP,
şi este o idee bună să configurăm calculatorul master ca server TFTP.
</p>



</body>
</section>
<section>
<title>Instalare server TFTP</title>
<body>

<p>
Un server TFTP recomandat poate fi găsit în pachetul tftp-hpa. Acest server
are acelaşi autor ca şi SYSLINUX, şi funcţionează foarte bine cu
pxelinux. Pentru a îl instala, introduceţi:
</p>

<pre caption="Instalare server tftp">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>
<section>
<title>Configurare server TFTP</title>
<body>

<p>
Editaţi fişierul <path>/etc/conf.d/in.tftpd</path>. Trebuie să
specificaţi directorul tftproot cu <c>INTFTPD_PATH</c> şi fiecare opţiune
de comandă cu <c>INTFTPD_OPTS</c>. Ar trebui să arate în felul următor:
</p>

<pre caption="Exemplu /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
Opţiunea <c>-l</c> rulează aplicaţia în modul de operare "stand alone"
fără a necesita inetd. Opţiunea <c>-v</c> indică un nivel informativ
pentru mesajele de log şi mesajele de eroare. Opţiunea <c>-s /diskless</c>
specifică directorul rădăcină pentru server-ul tftp.
</p>

</body>
</section>
<section>
<title>Pornire server TFTP</title>
<body>

<p>
Pentru a porni server-ul tftp, introduceţi:
</p>

<pre caption="Pornire server tftp pe calculatorul master">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
Aceasta ar trebui să pornească server-ul de tftp cu opţiunile specificate
în <path>/etc/conf.d/in.tftpd</path>. Dacă doriţi să porniţi automat
server-ul la pornirea calculatorului introduceţi:
</p>

<pre caption="Adăugaţi serverul tftp în nivelul de execuţie default pe calculatorul master">
# <i>rc-update add in.tftpd default</i>
</pre>

</body>
</section>
<section>
<title>Despre PXELINUX</title>
<body>

<p>
Această secţiune nu este necesară dacă folosiţi Etherboot. PXELINUX
este o aplicaţie bootloader care funcţionează din reţea folosind TFTP.
Este echivalent cu LILO sau GRUB. În esenţă este un set mic de
instrucţiuni care îi specifică sistemului slave unde să găsească
programul kernel şi sistemul iniţial de fişiere. PXELINUX vă permite
să folosiţi diferite opţiuni pentru kernel.
</p>

</body>
</section>
<section>
<title>Înainte de a începe</title>
<body>

<p>
Trebuie să luaţi o copie a fişierului pxelinux.0 din pachetul SYSLINUX de
H. Pete Anvin. Puteţi instala acest pachet astfel:
</p>

<pre caption="Instalare syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>
<section>
<title>Setare PXELINUX</title>
<body>

<note>
Aceasta nu este necesară pentru Etherboot
</note>

<p>
Înainte de a porni serverul tftp, trebuie să setaţi pxelinux. Mai întâi
copiaţi fişierul binar pxelinux în <path>/diskless</path>:
</p>

<pre caption="Setarea aplicaţiei bootloader la distanţă">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
Aceasta va crea o configuraţie default pentru bootloader. Fişierul binar
<path>pxelinux.0</path> va căuta în directorul <path>pxelinux.cfg</path> un
fişier al cărui nume este adresa de IP a calculatorului slave în
hexazecimal. Dacă nu găseşte un asemenea fişier va elimina primul digit
din numele fişierului pornind din dreapta şi va încerca din nou până nu
mai rămâne nici un digit. Începând cu versiunea 2.05 a pachetului
syslinux, mai întâi efectuează o căutare adiţională pentru un fişier
numit după adresa de MAC. În cazul în care nici un fişier nu este
găsit, este utilizată modalitatea de descoperire explicată anterior.
Dacă nu este găsit nimic, este utilizat fişierul <path>default</path>.
</p>

<pre caption="Fişiere pe care PXE le căuta în pxelinux.cfg/ în ordine">
<comment>(Fişierele ce încep cu 01 desemnează o adresă Ethernet, următorii octeţi sunt adresa MAC a sistemului slave)</comment>
01-00-40-63-c2-ca-c9

<comment>(Adresă IP în hexazecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C

default
</pre>

<note>
Acestea sunt în caractere minuscule.
</note>

<p>
Să începem cu fişierul <path>default</path>:
</p>

<pre caption="Exemplu pxelinux.cfg/default">
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
<c>DEFAULT</c> specifică imaginea bzImage de kernel pe care l-am compilat
anterior. <c>APPEND</c> adaugă opţiunile de iniţializare kernel.
Întrucât am compilat un kernel cu <c>NFS_ROOT_SUPPORT</c>, vom specifica
aici nfsroot. Prima adresă de IP este adresa calculatorului master, cea de a
doua este directorul creat în <path>/diskless</path> care conţine sistemul
iniţial de fişiere.
</p>

</body>
</section>

<section>
<title>Despre Etherboot</title>
<body>

<note>
Această secţiune nu este necesară dacă folosiţi PXE.
</note>

<p>
Etherboot este o aplicaţie bootloader care funcţionează din reţea folosind
TFTP. Ca şi PXE, acesta este echivalent cu LILO sau GRUB. Programul utilitar
<c>mknbi</c> vă permite să creaţi imagini diferite folosind opţiuni
diferite.
</p>

</body>
</section>
<section>
<title>Înainte de a începe</title>
<body>

<p>
Trebuie să procuraţi o copie a programului <c>mknbi</c> pentru a crea o
imagini de kernel speciale pentru Etherboot. Acest utilitar va crea un kernel
bazat pe kernel-ul dumneavoastră original. Acesta conţine opţiunile de boot
după cum este specificat mai jos.
</p>

<pre caption="Instalare mknbi">
# <i>emerge mknbi</i>
</pre>

</body>
</section>
<section>
<title>Setare Etherboot</title>
<body>

<p>
În această secţiune vom crea o imagine simplă etherboot. Nu trebuie să
specificăm calea către directorul rădăcină pentru clienţi deoarece
aceasta este deja făcută de către serverul dhcp în "option root-path"
în dhcp.conf. Mai multe detalii pot fi găsite în manualul mknbi.
</p>

<pre caption="Manualul mknbi">
# <i>man mknbi</i>
</pre>

<p>
Următoarea comandă va crea o imagine de boot în format ELF care va pasa
dhcp şi rootpath programului kernel. De asemenea, va forţa programul kernel
să încerce să găsească un server dhcp pe reţea.
</p>

<pre caption="Creare imagine netboot">
# <i>mkelf-linux -ip=dhcp /diskless/bzImage &gt; /diskless/vmlinuz </i>
</pre>

<note>
Pentru o imagine specifică unei arhitecturi, trebuie să introduceţi
<c>bzImage_arch</c> şi <c>vmlinuz_arch</c>.
</note>

</body>
</section>
<section>
<title>Rezolvarea problemelor cauzate de procesul de boot prin reţea</title>
<body>

<p>
Există câteva modalităţi de a diagnostica o problemă de boot prin
reţea. Principalul program utilitar folosit în acest scop este
<c>tcpdump</c>. Pentru a instala <c>tcpdump</c> introduceţi:
</p>

<pre caption="Instalare tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Puteţi urmări traficul de date pe reţea pentru a vă asigura că
interacţiunile dintre server şi client au loc. Dacă ceva nu
funcţionează, puteţi verifica o serie de lucruri. Începeţi prin a
verifica conexiunea fizică dintre server şi client, dacă aveţi cabluri
bune. Dacă clientul/serverul nu primeşte date pe un port anumit,
verificaţi că nu aveţi un firewall în reţea care să împiedice acest
trafic. Pentru a monitoriza datele trimise între doua calculatoare
introduceţi:
</p>

<pre caption="Monitorizare interacţie client/server folosind tcpdump:">
# <i>tcpdump host </i><comment>client_ip</comment><i> and </i><comment>server_ip</comment>
</pre>

<p>
Puteţi folosi <c>tcpdump</c> pentru a asculta pe un port particular precum
tftp, introducând:
</p>

<pre caption="Monitorizare server tftp">
# <i>tcpdump port 69</i>
</pre>

<p>
O problemă uzuală este: "PXE_E32: TFTP open time-out". Aceasta este
probabil datorată unui firewall. Dacă folosiţi <c>TCPwrappers</c> se
recomandă să verificaţi că fişierele <path>/etc/hosts.allow</path>
şi <path>/etc.hosts.deny</path> sunt configurate corect. Calculatorului slave
ar trebui să i se permită să se conecteze la server.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configurare server NFS</title>
<section>
<title>Despre NFS server</title>
<body>

<p>
Serverul NFS (Network File System) permite calculatoarelor slave să acceseze
directoare de fişiere în reţea. Această procedură poate fi
personalizată mai târziu, vom implementa pentru început numai strictul
necesar pentru a permite pornirea calculatoarelor slave.
</p>

</body>
</section>
<section>
<title>Despre Portmapper</title>
<body>

<p>
Există o serie de servicii client/slave care nu ascultă pe un port
specific. Aceste servicii folosesc RPC (Remote Procedure Calls). La
iniţializare, serviciul ascultă pe un port aleator, iar apoi acest port este
înregistrat cu Portmapper. NFS foloseşte RPC şi deci are nevoie de
Portmapper să ruleze înainte ca serviciul să fie pornit.
</p>

</body>
</section>
<section>
<title>Înainte de a începe</title>
<body>

<p>
Suport pentru NFS Server este necesar în kernel, deci, dacă nu aveţi
configurat deja, trebuie să recompilaţi kernel-ul sistemului master. Pentru
a verifica programul kernel master introduceţi:
</p>

<pre caption="Verificare opţiuni specifice NFS">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
Dacă programul kernel a fost configurat pentru NFS, ar trebui să vi se
afişeze ceva asemănător cu:
</p>

<pre caption="Opţiuni specifice NFS în configuraţia kernel a maşinii master">
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>

</body>
</section>
<section>
<title>Instalare server NFS</title>
<body>

<p>
Pachetul NFS poate fi găsit în portage, tastând:
</p>

<pre caption="Instalare nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
Acest pachet conţine programul utilitar portmapper, un server şi un client
NFS. Toate celelalte dependenţe sunt rezolvate automat.
</p>

</body>
</section>
<section>
<title>Configurare server NFS</title>
<body>

<p>
Există trei fişiere de configurare care trebuie editate:
</p>

<pre caption="Fişiere configurare NFS">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
Fişierul <path>/etc/exports</path> specifică cum, cui şi ce va fi
exportat de către serverul NFS. Fişierul fstab de pe calculatoarele slave
va fi modificat pentru mount al sistemelor de fişiere NFS exportate de
server.
</p>

<p>
Un exemplu tipic de fişier <path>/etc/exports</path> ar trebui să fie ca
următorul:
</p>

<pre caption="Exemplu master /etc/exports">
<comment># o linie pentru fiecare calculator slave</comment>
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
<comment># comun pentru toate calculatoarele slave</comment>
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
<comment># dacă doriţi un log partajat</comment>
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>

<p>
Primul câmp indică directorul care trebuie exportat, următorul câmp
indică de cine şi cum. Acest câmp poate fi despărţit în două
părţi: cine are voie să mount acest director particular, şi ce tip de
mount poate fi efectuat: <c>ro</c> doar pentru citire, <c>rw</c> pentru
citire/scriere; <c>no_root_squash</c> şi <c>no_all_squash</c>  sunt
importante pentru clienţi fără disc care au acces la hard disc pentru
scriere şi aceşti clienţi nu sunt refuzaţi când încearcă să facă
cereri la nivel de intrare/ieşire. Fişierul fstab al calculatoarelor slave,
<path>/diskless/192.168.1.21/etc/fstab</path>, ar trebui să arate
asemănător cu:
</p>

<pre caption="Exemplu fişier fstab pentru calculatoarele slave">
<comment># these entries are essential</comment>
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># folositor dar nu neapărat necesar</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0

<comment>(numai dacă folosiţi openMosix)</comment>
none                            /mfs      mfs     dfsa=1                                       0 0
</pre>

<p>
În exemplul anterior, <e>master</e> este numele calculatorului master, însă
poate fi înlocuit cu uşurinţă cu adresa IP a acestui calculator. Primul
câmp indică directorul care trebuie mount-at, iar al doilea câmp indică
locaţia. Al treilea câmp indică tipul de sistem de fişiere, în cazul
nostru NFS. Al patrulea câmp specifică diverse opţiuni care vor fi folosite
în timpul procesului de mount (încercaţi mount(1) pentru mai multe
informaţii privind opţiunile). Unii utilizatori au probleme cu
modalităţile soft pentru mount, şi deci le-am făcut pe toate hard. Ar
trebui totuşi să analizaţi opţiunile din <path>/etc/fstab</path> pentru a
optimiza configuraţia.
</p>

<p>
Ultimul fişier de editat este <path>/etc/conf.d/nfs</path>. Acesta descrie o
serie de opţiuni de iniţializare nfs, şi arată ca în exemplul următor:
</p>

<pre caption="Exemplu master /etc/conf.d/nfs">
# Config file for /etc/init.d/nfs

# Number of servers to be started up by default
RPCNFSDCOUNT=8

# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
Ar trebui să schimbaţi <c>RPCNFSDCOUNT</c> să fie egal cu numărul de
calculatoare slave.
</p>

</body>
</section>
<section>
<title>Pornire server NFS</title>
<body>

<p>
Porniţi serverul nfs cu script-ul de iniţializare din <path>/etc/init.d</path>
introducând:
</p>

<pre caption="Pornire master nfs server">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
Dacă doriţi ca acest script să fie pornit automat când calculatorul
master porneşte, introduceţi:
</p>

<pre caption="Adăugare server nfs în nivelul de iniţializare default pe calculatorul master">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Finalizare sistem fişiere calculatoare slave</title>
<section>
<title>Copiere fişiere care lipsesc</title>
<body>

<p>
În continuare vom sincroniza sistemele de fişiere ale calculatoarelor
master şi slave şi vom adăuga o serie de fişiere executabile fără a
modifica fişierele specifice calculatoarelor slave.
</p>

<pre caption="Creare sistem de fişiere slave">
# <i>rsync -avz /bin /diskless/192.168.1.21</i>
# <i>rsync -avz /sbin /diskless/192.168.1.21</i>
# <i>rsync -avz /lib /diskless/192.168.1.21</i>
</pre>

<note>
Folosim rsync -avz în loc de cp pentru a menţine link-urile simbolice şi
permisiunile.
</note>

</body>
</section>
<section>
<title>Script-uri de iniţializare</title>
<body>

<p>
Script-urile de iniţializare vor încerca să ruleze <e>checkroot</e>, ceea
ce nu are sens pentru calculatoarele slave. O soluţie ar fi să modificaţi
manual script-ul <path>/diskless/192.168.1.21/sbin/rc</path>, aceasta este
însă dificil şi periculos şi are putea să creeze probleme când
sincronizaţi sistemul de fişiere din nou. O altă soluţie este să aveţi
un fişier <path>/fastboot</path>. Acest fişier informează
<e>checkroot</e> că nu este cazul să verifice sistemul de fişiere,
însă acest fişier este şters după ce procesul de iniţializare a luat
sfârşit. De aceea, acest fişier va trebui să fie creat din nou după
iniţializare:
</p>

<pre caption="Prevenire script de iniţializare să verifice sistemul de fişiere">
<comment>(Creaţi fişierul /fastboot pentru următoare pornire)</comment>
# <i>touch /diskless/192.168.1.21/fastboot</i>
<comment>(Creaţi fişierul /fastboot la fiecare pornire)</comment>
# <i>echo "touch /fastboot" &gt;&gt; /diskless/192.168.1.21/etc/conf.d/local.start</i>
</pre>

<p>
Deoarece procesul de umount pentru sistemele de fişiere de reţea ar trebui
să fie efectuat ultimul, va trebui să editaţi fişierul dvs.
<path>/etc/init.d/netmount</path> şi să-l consultaţi:
</p>

<pre caption="Editarea /etc/init.d/netmount">
depend() {
    <i>before *</i>
</pre>

<note>
Baselayout, versiunea 1.11.* şi cele ulterioare necesită această setare.
</note>

<p>
Dacă efectuaţi aceste operaţii de pe un sistem live, nu uitaţi să
rulaţi <c>depscan.sh</c> pentru a rezolva dependenţele între servicii.
Puteţi ignora în siguranţă avertismentele despre coliziunile cu
/etc/init.d/checkroot, deoarece veţi dezactiva acest serviciu prin intermediul
fişierului fastboot creat în paragraful anterior.
</p>

<p>
În funcţie de scopul calculatoarelor slave, aveţi nevoie de atât de multe
script-uri de iniţializare în
<path>/diskless/192.168.1.21/etc/runlevels</path> cât şi numărul de
servicii care rulează pe aceste calculatoare.
</p>

<warn>
Nu folosiţi programul <c>rc-update</c> pentru a adăuga sau înlătura
fişiere script când sunteţi logged pe calculatorul master, deoarece aceasta
va rezulta în adăugarea/înlăturarea acestor script-uri în sistemul de
iniţializare al calculatorului master. Trebuie să creaţi linuk-urile manual
sau log în calculatorul slave folosind ssh sau conectaţi un terminal şi o
tastatură.
</warn>

<pre caption="Exemplu tipic de nivele de iniţializare pe calculatoarele slave">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
 
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
 
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
 
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
 
/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
În continuare este timpul să porniţi calculatoarele slave. Dacă
funcţionează, felicitări, sunteţi deţinătorul unui sistem de noduri
fără disc :)
</p>

</body>
</section>

<!-- 

<section>
<title>O alternativă: ClusterNFS</title>
<body>

<warn>
Acestă alternativă este menţionată deoarece unul dintre revizuitorii
acestui document o foloseşte. Trebuie să luaţi în considerare faptul că
Gentoo <e>nu suportă</e> ClusterNFS. Pachetul nu este în portage şi
necesită schimbări ale unor script-uri de iniţializare. <b>Folosiţi
această alternativă pe propria dumneavoastră răspundere</b>.
</warn>

<p>
Dacă nu doriţi să aveţi un sistem de fişiere rădăcină distinct
pentru fiecare calculator slave în parte, deoarece aceasta ar necesita o
muncă adiţională în cazul unei actualizări, puteţi folosi acelaşi
sistem de fişiere root pentru toate calculatoarele din reţea, inclusiv
calculatorul master. Aceasta înseamnă că toate calculatorele trebuie să
fie compatibile, deoarece un singurul set de programe binare este disponibil.
Deasemenea, acestă setare are un număr de implicaţii privind securitatea
reţelei, deoarece sistemul de fişiere root al calculatorului master este
vizibil prin NFS.
</p>

<p>
După toate acestea, dacă tot mai doriţi să continuaţi, vizitaţi <uri
link="http://clusternfs.sourceforge.net/">pagina oficială</uri> ClusterNFS,
descărcaţi pachetul software şi citiţi documentaţia.
</p>

<p>
Pe scurt, toate fişierele sunt comune între master şi slaves, excepţiile
fiind copiate în  <path>file$$CLIENT$$</path>. Când un calculator slave cere
<path>file</path>, ClusterNFS va observa existenţa fişierului
<path>file$$CLIENT$$</path> şi îl va trimite. Fişierele care trebuie să
fie diferite pe fiecare calculator slave sunt copiate în
<path>file$$IP=192.168.1.21$$</path>. Acelaşi lucru se aplică şi la
directoare.
</p>

<p>
Diferenţele între această instalare şi cea descrisă anterior pot fi
sumarizate după cum urmează:
</p>

<ul>
  <li>
    Nu aveţi nevoie de suport pentru serverul NFS în kernel-ul sistemului
    master
  </li>

  <li>Instalaţi ClusterNFS <e>după</e> emerge nfs-utils</li>

  <li>
    Faceţi copii ale fişierelor şi directoarelor slave după cum este
    descris mai jos
  </li>

  <li>Nu creaţi un director rădăcină pentru fiecare calculator slave</li>

  <li>Exportaţi numai  / în fişierul <path>/etc/exports</path></li>

  <li>
    Mount-aţi / folosind NFS în fişierul <path>/etc/fstab$$CLIENTS$$</path>
    pentru calculatoarele slave
  </li>

  <li>Editaţi <path>/etc/init.d/nfs</path> după cum este descris mai jos</li>

  <li>
    Editaţi <path>/etc/conf.d/local.start$$CLIENT$$</path> după cum este
    descris mai jos
  </li>
</ul>

<pre caption="Fişiere care trebuie să fie diferite între calculatoarele slave şi master">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Probabil un fişier gol)</comment>
/etc/crontab$$CLIENT$$<comment> (Probabil un fişier gol, sistemul master manipulează toate acţiunile)</comment>
/etc/exports$$CLIENT$$<comment> (Fişier gol, sistemele slave nu exportă sisteme de fişiere NFS)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Numele calculatoarelor slave)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Script-urile de boot ale sistemelor master şi slave sunt separate în mod clar)</comment>
/fastboot$$CLIENT$$
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Creaţi sub-directoare ca în /var)</comment>
</pre>

<pre caption="Editare /etc/init.d/nfs">
        ebegin "Starting NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Adăugaţi opţiunea - -translate-names</comment>
                $nfsd - - - -translate-names
        eend $? "Error starting NFS daemon"
         # Check if we support NFSv3
        ebegin "Starting NFS mountd"
<comment># Comentaţi următoarele două linii (ClusterNFS foloseşte numai NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Error starting NFS mountd"
</pre>

<pre caption="Editare /etc/conf.d/local.start$$CLIENT$$">
<comment>(Adăugaţi această linie)</comment>
touch /fastboot\$\$CLIENT\$\$
</pre>

</body>
</section>
-->
</chapter>

</guide>

