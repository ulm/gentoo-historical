<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/tw/gentoo-x86-install.xml">
  <title>Gentoo Linux 文件 -- Gentoo Linux 1.4_rc4 安裝步驟</title>
  <author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
  </author>
  <author title="Author">Chris Houser</author>
  <author title="Author">
    <mail link="">Jerry Alexandratos</mail>
  </author>
  <author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
  </author>
  <author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
  </author>
  <author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
  </author>
  <author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
  </author>
  <author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
  </author>
  <author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
  </author>
  <author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
  </author>
  <author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
  </author>
  <author title="Editor">
    <mail link="">Colin Morey</mail>
  </author>
  <author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
  </author>
  <author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
  </author>
  <author title="Editor">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
  </author>
  <author title="Translator">
    <mail link="bennyc@gentoo.org">Benny Chuang</mail>
  </author>
  <abstract>以下的指令將帶你一步一步安裝 Gentoo Linux 1.4_rc3. Gentoo Linux 安裝模式支援依個人喜好的各種的安裝目標.
	從自己手動編譯的到以編譯好的.
	</abstract>
<version>2.6</version>
 <date>20 March 2003</date>
  <chapter>
    <title>關於安裝</title>
    <section>
      <body>
        <p>如果你的 BIOS 和光碟機都支援開機. 幾乎每一台 IDE 光碟機都可以使用此光碟開機, 也包括了許多 SCSI 光碟機.
此光碟不僅支援 Linux IDE (和 PCI IDE) (核心內建), 也支援所有的 SCSI 裝置 (模組型態).
因此, 我們提供幾乎每種 Linux 支援的網路卡, 也附上工具方便你設定網路和向外 (包括向內) 的 <c>ssh</c>
連線下載檔案.</p>
        <p>使用安裝光碟, 你必須要有 486 以上的處理器(CPU)和最少64 Megabytes 記憶體. (Gentoo 已經成功公地在
64MB 記憶體 加上 64MB 的 Swap 空間, 但是建立過程是相當慢的.)</p>
        <p>G裝 Gentoo Linux 可以使用任何一個 "Stage" 壓縮檔案(Tarball). 你選擇的stage將會依照他的機制進行編譯.
如果你想要從 bootstrap 開始, 請使用 Stage1 的壓縮檔案. Stage2 的壓縮檔案將會把已經編譯好的
bootstrap 載入系統,方便你開始編譯系統. Stage3 的壓縮檔案包括整個基本的 Gentoo Linux 系統.</p>
        <p><b>你會選擇哪一個.. Stage1, Stage2 還是 Stage3呢?</b>如果你想要完全掌控系統設定, 使用 Stage1 將會是一個給進階使用的選擇.
Stage2 會跳過 bootstrap 編譯, 只要你高興, 你也可以更改我們已準備好的設定. 選擇 Stage3 是安裝 Gentoo Linux 最快的方式, 但是
他也代表著, 系統的基礎是使用於 Gentoo 預設. 另外, 每個 Gentoo Linux 的版本都會有三個特別針對受歡迎的處理器(CPU)的檔案.
<b>如果這是你第一次安裝 Gentoo Linux, 請考慮使用 Stage3 的壓縮檔案</b></p>


		<p>接下來該怎麼開始安裝呢? 到
<uri>http://www.ibiblio.org/gentoo/releases/1.4_rc4/x86/x86/</uri> 選擇想要安裝的版本.請多多使用我們的對應站, 對應的名單可以在 <uri>http://www.gentoo.org/main/en/mirrors.xml</uri>
</p>
        <p>安裝光碟的映像檔是用於大部分的燒錄機(CDR或CDRW). 目前我們有兩種安裝光碟.
第一種包含著 "gentoo-basic" (基本型), 檔案大小大約是40MB. 此光碟只有包含著 Stage1的壓縮檔. 並且放在
<path>x86/livecd/</path> 的目錄下. 此光碟為基本型(minimal) 使用此光碟開機後可以到 <path>/mntcdrom/gentoo/</path>.</p>
        <p>們目前提供的第二種光碟為 "gentoo-3stages." 此CD可以在 <path>x86/livecd</path>的目錄下找到. 它包含了
Stage 1, 2 和 3 的壓縮檔案. 使用此光碟會讓你安裝更完全,及節省更多的時間.</p>
<p><b>關於 i686, pentium3, athlon, athlon-mp 的 Stages呢? 光碟和GRP(Gentoo Reference Platform)?</b>
Gentoo 1.4_rc3 只是一個小的發表版本. 1.4_rc4 將會包含著所有的常用 x86 結構和 GRP.
如果你想要自行設定, 請使用 1.4_rc2 文件. 網址為: <uri>http://www.gentoo.org/doc/en/gentoo-x86-1.4_rc2-install.xml</uri>
</p>
        <impo>你在安裝時碰到任何問題, 並且想要申報此錯誤(bug) 請到<uri>http://bugs.gentoo.org</uri>.
如果此錯誤來自作者 (例: KDE 工作組) <e>Gentoo Linux 發展人員</e>將會為你打理此問題.
</impo>
        <p>現在讓我們來複習一下安裝步驟. 首先, 我們需要下載, 燒錄光碟(LiveCD). 並且使用它開機. 開機後, 將會到 root 環境,
我們將要建立分割區(Partition), 建立檔案系統 (Filesystems), 和解開 Stage1, Stage2 或是 Stage3 的壓縮檔案.
如果我們使用 Stage1 或是 Stage2 壓縮檔案, 我們將要小心翼翼地完成每個步驟. 並且使系統達到 Stage 3. 當我們的系統到達 Stage 3時,
我們可以設定(依個人喜好 設定, 安裝開機程式 等等) 然後再重新啟動為一個完整的 Gentoo Linux 系統.
每個 Stage 將需要完成以下列表的程序 (看你想從哪裡開始)</p>
        <table>
          <tr>
            <th>stage 壓縮檔案(tarball)</th>
            <th>工作列表</th>
          </tr>
          <tr>
            <ti>1</ti>
            <ti>分割區/設定檔案系統, emerge sync(更新Portage), bootstrap(基礎系統), emerge system(系統程式), emerge kernel sources(核心), 最後設定</ti>
          </tr>
          <tr>
            <ti>2</ti>
            <ti>分割區/設定檔案系統, emerge sync(更新Portage), emerge system(系統程式), emerge kernel sources(核心), 最後設定</ti>
          </tr>
          <tr>
            <ti>3</ti>
            <ti>分割區/設定檔案系統, emerge sync(更新Portage), 最後設定</ti>
          </tr>
        </table>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>開機</title>
    <section>
      <body>
        <p>使用光碟(LiveCD)開機時, 你應該會看到一個很漂亮的 Gentoo Logo 商標
	在此, 按下 Enter 鍵開始進入開機階段. 你也可以輸入自訂的選項如:<c>gentoo opt1 opt2</c>
然後再按Enter鍵.若要查看開機選項, 請按 F2.</p>
<p>當你按了 Enter 鍵後, 你將會看到標準核心(Kernel)的輸出列表, Kernel 和 initrd 的訊息. 接著是正常的 Linux 開機機制.
你將會自動的登入為 "<c>root</c>" 和隨機的密碼出現在螢幕上(安全考量).
登入後,你應該會看見 ("<c>#</c>"). 如果要更換密碼, 輸入 passwd 再依照銀幕上的指令進行即可.
你也可以使用 Alt-F2, Alt-F3 和 Alt-F4 切換成其他操作介面(console).</p>
        <p>你是否有看見 <c>#</c> 上方有一堆說明呢? 那個說明將會教你如何設定 Linux 網路 和告訴你 Gentoo Linux 的
Stage 壓縮檔位置.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>載入核心模組</title>
    <section>
      <body>
        <p>當PCI自動偵測沒有找到你的硬體, 你必須要手動的載入核心模組. 如果查看可用的模組,
輸入 <c> ls /lib/modules/*/kernel/drivers/net/*</c>. 如果要載入特定的模組,
輸入:
			</p>
<pre caption="PCI 模組設定">
# <c>modprobe pcnet32</c>
<comment>((將 pcnet32 換成你的網路卡適用的模組)</comment>
</pre>
        <p>如果你有 SCSI 硬體沒被偵測到, 你將需要從 /lib/modules 載入正確的模組. 你可以輸入 <c>modprobe</c>:
			</p>
<pre caption="載入 SCSI 模組">
# <c>modprobe aic7xxx</c>
<comment>(將 aic7xxx 換成你的 SCSI 使用的模組)</comment>
# <c>modprobe sd_mod</c>
<comment>(你將需要 sd_mod 的模組使用 SCSI disk)</comment>
</pre>
			<note>
			CSI 光碟機和硬碟支援已經內建在核心裡了.
			</note>
        <p>如果你使用的是 容錯式獨立磁碟陣列(RAID), 你將需要為你的RAID控制卡載入 ATA-RAID 模組.
			</p>
<pre caption=" 載入 RAID 模組">
# <c>modprobe ataraid</c>    
# <c>modprobe pdcraid</c>
<comment>(Promise Raid 控制)</comment>
# <c>modprobe hptraid</c>
<comment>(Highpoint Raid 控制)</comment>
</pre>
        <p>Gentoo 光碟應該會啟用你的硬碟 DMA. 如果沒有, 你可以使用 <c>hdparm</c> 來設定硬碟的DMA.</p>
<pre caption="設定 DMA">
<comment>更換 hdX 為你的硬碟裝置.</comment>
# hdparm -d 1 /dev/hdX <comment>啟用 DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(使用安全和有效率的方式啟用 DMA)</comment>
# hdparm -X66 /dev/hdX
<comment>(強制啟用 Ultra-DMA -- 危險 -- 有可能搞亂你的硬碟)</comment>
</pre>
      </body>
    </section>
  </chapter>
<!-- THIS SECTION SHOULD BE DEPRECATED WITH HOTPLUG ENABLED IN 1.4_rc3 (drobbins)
  <chapter>
    <title>Loading PCMCIA Kernel Modules</title>
    <section>
      <body>
        <p>If you have a PCMCIA network card, you will need to perform a few extra steps.
			</p>
        <warn>To avoid problems with <c>cardmgr</c>, you <e>must</e> run it <e>before</e> you enter the chroot
			portion of the install. </warn>
<pre caption="Loading PCMCIA Modules">
# <i>modprobe pcmcia_core</i>
# <i>modprobe i82365</i>
# <i>modprobe ds</i>
# <i>cardmgr -f</i>
</pre>
        <p>As <c>cardmgr</c> detects which hardware is present, your speaker should emit a
			few reassuring beeps, and your PCMCIA network card should be active. You can
			of course insert the PCMCIA card after loading <c>cardmgr</c> too, if that is 
			preferable. (Technically, you need not run 
			<c>cardmgr</c> if you know exactly which module your PCMCIA card requires. 
			But if you don't, loading all PCMCIA modules and see which sticks won't work,
			as all PCMCIA modules load obligingly and hang around for a PCMCIA card to 
			drop by. <c>cardmgr</c> will also unload the module(s) for any card when you
			remove it). </p>
      </body>
    </section>
  </chapter>
-->
  <chapter>
    <title>設定網路</title>
	<section>
      <title>或許系統已經自動設定好了?</title>
      <body>
		<p>如果你使用的光碟是 1.4_rc3 或更新的版本, 你個網路設定應該會再開機時自動設定. 你將可以使用一些光碟上的功能 例如:
<c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>,<c>wget</c>, <c>lynx</c> 等等...</p>

        <p>如果網路已經設定好了, 你可以使用 <c>/sbin/ifconfig</c>, 查看一些除了 <c>lo</c> 的網路裝置, 例如 <c>eth0</c>:
		</p>
<pre caption="/sbin/ifconfig 查看安裝成功的網路卡">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
        <p>或許你會想要試試看網路是否設定完成. 你可以試試看 PING 網路公司的 DNS 主機 (可以在 <path>/etc/resolv.conf</path>),
或著是其他網站, 只要能確定你的網路設定無誤就可以啦.
		</p>
<pre caption="測試網路連線">
# <c>ping -c 3 www.yahoo.com </c>
</pre>
		<p>你的網路設定是否正常呢? 如果是, 請跳過以下部分.</p>
      </body>
    </section>
    <section>
      <title> PPPoE 設定</title>
      <body>
        <p>如果你是使用 PPPoE 連上網路, 任何 Gentoo 開機光碟已包含著此功能: <c>rp-pppoe</c>.
請使用 <c>adsl-setup</c> 程序幫你你設定連線. 你會被要求將你的網路卡連上 adsl 數據機,
和你的帳號,密碼, DNS 伺服器 IP, 和需不需要一個簡單的防火牆.</p>
<pre caption="PPPoE 設定E">
# <c> adsl-setup </c>
# <c> adsl-start </c>
</pre>
        <p>如果發生錯誤, 請在 <path>/etc/ppp/pap-secrets</path> 確認你的帳號及密碼. 或是
			<path>/etc/ppp/chap-secrets</path>, 確認你使用的網卡是否正確.  </p>
      </body>
    </section>
    <section>
      <title> 自動設立網路</title>
      <body>
       <p>如果系統沒有自動設定, 最簡單的方法就是使用 <c>net-setup</c>.</p>
<pre caption="網路設定程式ipt">
# <c>net-setup eth0</c>
</pre>
        <p>當然, 如果你高興, 你也可以自行設定網路. 下面將教你如何手動設定.</p>
      </body>
    </section>
    <section>
      <title>手動設定動態式IP(DHCP)</title>
      <body>
        <p>設定動態IP(DHCP) 很簡單; 如果你的IP為固定式,請跳過以下移致固定IP設定. </p>
<pre caption=" DHCP 網路設定">
# <c>dhcpcd eth0</c>
</pre>
        <note>如果你的網路公司提供主機名稱(hostname), 你可以在eth0 <c>前面加入 -h 主機名稱</c>.
		</note>
        <p>如果你從 <i>dhcpConfig</i> 收到警告, 別緊張; 請往下移置網路測試的部分</p>
      </body>
    </section>
    <section>
      <title>自行設定固定式IP</title>
      <body>
        <p>我們只需要設定簡單的網路 方便我們下載原始碼進行編譯. 輸入以下指令 並且將 $IFACE 換成你的網路卡裝置 (大部分為 <c>eth0</c>)
$IPNUM 為你的IP位置, $BCAST 為你個廣播位置, 最後, $NMASK 為網路遮罩. 關於 <c>route</c>, 更改 $GTWAY 為你的通訊閘.
		</p>
<pre caption="固定式IP設定">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1</c>
</pre>
        <p>現在我們需要建立一個 <path>/etc/resolv.conf</path>
檔案, 幫變我們尋找網路名稱(利用名子尋找 Web/FTP 站名, 取代IP地址)</p>
        <p>下面是一個簡單的 /etc/resolv.conf 檔案範例: </p>
        <p>Here is a template to follow for creating your /etc/resolv.conf file: </p>
<pre caption="/etc/resolv.conf 範例">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
        <p>將 <c>10.0.0.1</c> 和 <c>10.0.0.2</c> 取代為你的主DNS 和 附DNS伺服器的IP.</p>
      </body>
    </section>
    <section>
      <title>代理伺服器(PROXY) 設定</title>
      <body>
        <p>果你必須使用代理伺服器. 我們必須在開始下載前先匯出一些變數.
		</p>
<pre caption="設定使用代理伺服器">
<comment> // HTTP 代理伺服器: </comment>
# <c>export http_proxy=&quot;machine.company.com:1234&quot; </c>
<comment> // FTP 代理伺服器: </comment>
# <c>export ftp_proxy=&quot;$http_proxy&quot; </c>
<comment> // RSYNC 代理伺服器: </comment>
# <c>export RSYNC_PROXY=&quot;$http_proxy&quot; </c>
</pre>
      </body>
    </section>
        <section>
      <title>網路可以連了!?</title>
      <body>
        <p>你到達這邊時, 網路應該已經設定好並且可以用了. 你應該可以使用
	<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> 和 <c>wget</c> 連線到網路上</p>
      </body>
    </section>
    <section>
      <title>無法連上網路!</title>
      <p>如果你沒有網路,或是不能連接, 你可以到<uri link="http://forums.gentoo.org/">Gentoo 論壇</uri> 或是 <uri>http://forums.gentoo.org/viewtopic.php?t=43025</uri> 找一些有用的資料.</p></section>
  </chapter>
  <chapter>
    <title>設定系統日期和時間</title>
    <section>
      <body>
        <p>接下來我們必須設定系統和日期. 我們將會使用<c>date</c>.</p>
<pre caption="設定系統日期">
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(如果你的系統時間錯誤,請輸入以下指令)</comment>
# <c>date 022709042003</c>
<comment>(date 月,日,時,分,西元年)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>檔案系統, 硬碟分割和區塊裝置</title>
    <section>
		<title>介紹區塊裝置</title>
      <body>
<p>
在此,我們將仔細地看看 Gentoo Linux 和  其他 Linux 的磁碟概念. 包括了, Linux 檔案系統, 硬碟分割 和 Block devices.
一旦你熟悉了硬碟的出入,  你將會被帶入設定分割區及檔案系統的部份</p>
<p>
我將以介紹 "block devices" 作為開始. 最有名的大概就是Linux 中代表的第一個 IDE 磁碟
</p>
<pre caption="/dev/hda, 代表著系統中的第一個 IDE 磁碟">
/dev/hda
</pre>

<p>
如果你使用的是 SCSI 磁碟, 你的第一個磁碟為：
</p>

<pre caption="/dev/sda, 代表著你的系統中的第一個 Logical SCSI 磁碟">
/dev/sda
</pre>

<p>以上的 block devices 代表著磁碟機的介面. 這樣可以方便程式簡單得讀取,和寫入.</p>
</body>
</section>
<section>
<title>硬碟分割和 fdisk</title>
<body>
<p>在Linux底下,我們會用<c>mkfs</c> (或是 <c>mke2fs</c>, 還有
<c>mkreiserfs</c> 等等) 建立檔案系統.</p>

<p> 當然, 你也可以使用整個硬碟來當一個分割區. 一個分割區代表著 <i>整個</i> 硬碟.
例: <c>/dev/hda</c> 或是 <c>/dev/sda</c>. 但是從未有人這樣做過.
大部分的 Linux 都是將分割區切成小塊一點. 所設定的分割區 我們就叫他 "partitions"
你可以利用 <c>fdisk</c> 設定每個硬碟內有幾個分割區及大小  </p>

<p> 我們可以使用 <c>fdisk</c>來看硬碟的分割表. 所以我們需要提供 block device(硬碟) 給 fdisk. </p>

<note>除了 fdisk <c>cfdisk</c>以外, 你也可以使用 <c>parted</c> 和 <c>partimage</c>進行分割</note>

<pre caption="使用 fdisk">
# fdisk /dev/hda 
</pre>
<p>
or
</p>
<pre caption="使用 fdisk 在 /dev/sda">
# fdisk /dev/sda
</pre>

<impo>
<b>請注意: 如果你的硬碟中有任何資料, 當你寫入硬碟分割區時, 這些資料將會消失
</b>
</impo>

<p>
當你進入 fdisk 時,你將會看到以下的畫面:
</p>

<pre caption="fdisk 畫面">
Command (m for help): 
</pre>


<p>
輸入 <c>p</c> 查看分割區列表
</p>

<pre caption="分割區設定範例">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
這棵硬碟被分割為七個分割區（顯示為 "Linux") 也有一個 Swap (顯示為 "Linux swap")
</p>

<p>
每個分割區的名稱會出現在列表的最左邊, 從 <c>/dev/hda1</c> 到 <c>/dev/hda9</c>
在早期的時代, 分割軟體最多只能分割到4塊. 說實在的,有點限制. 因此, 新版的 fdisk
可以使用<i>extension partitioning</i>. 一個延續的分割區(Extended partitioning)可以建立更多的分割區.
我們叫他 <i>logical</i>分割區. 因此才解決了4個分割區的限制.
</p>

<p>
<c>hda5</c>之前的分割區, 我們稱它為 Primary (基本) 分割區. </p>
<p>而在後面的稱為 <c>logical</c>分割區.
</p>
<p>從以上範例來看, <c>hda1</c> 到 <c>hda3</c>為基本分割區. <c>hda4</c> 為 <c>hda5</c> 到 <c>hda9</c>的定義.
所以我們可以說<i>可以作為檔案系統的分割區</i>只有 <c>hda1</c> 到 <c>hda3</c> 和 <c>hda5</c> 到 <c>hda9</c>
</p>

<p>另外, 你是否發現了列表上有一個 "ld"? 他的意思為: "分割區種類"
當你建立了一個新的分割區, 你必須要確定你的種類社為 '83'. 83 代表著Linux 的檔案系統.
而 '82' 代表著 Linux swap 分割. 你可以使用 <c>t</c> 的選項.Linux 核心(kernel) 將
會在開機時自動發現這些分割區和 swap.
</p>
</body>
</section>
<section>
<title>使用 fdisk 設定分割區</title>
<body>

<p>你是否對Linux 分割區的設定有所了解了呢? 現在我將一步一步地帶你設定分割區.
當我們完成後, 你的分割區應該會看起來像以下列表.</p>

<pre caption="完成分割後,你的分割區列表會看起來像這樣">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>我們建議新手將硬碟分割成三部份. 第一個 (<c>/dev/hda1</c>) 將會被設定為分割區中的第一個.
我們用它來作為開機分割區 (Boot partition). 開機分割區的將儲存所有開機需要的檔案. -- GRUB 開機程式
的資料 (如果你選擇使用GRUB) 和 Linux 核心. 使用開機分割區是為了確保開機檔案不被影響. 在正常的狀況下,
開機分割區將部會被掛載. 如果你使用的是 SCSI 系統, 你的開機分割區將會看起來像 <c>/dev/sda1</c>
</p>

<p>第二個分割區 (<c>/dev/sda3</c>) 是用來當 swap 分割區. 核心會在 RAM 不夠用時把 swap 當成
虛構記憶體(Virtual Memory). 此分割需不必太大.. 大約512MB即可. 如果你使用的是 SCSI 系統,
你的分割區將會看起來像 <c>/dev/sda2</c>
</p>

<p>第三個分割區 (<c>/dev/hda3</c>) 需要蠻大的空間. 或許你可以把剩下的空間全部給它.
這個分割區我們將叫他 "根(root)" 分割區. 我們將在此放入所有的系統檔案.和 Gentoo Linux.
如果你使用的是 SCSI 系統, 你的分割區將會看起來像 <c>/dev/sda3</c>
</p>


<p>我們開始分割前,以下是一些關於分割區和檔案系統的技術性建議 .
</p>

<table>
	<tr>
	<th>分割區</th>
	<th>大小</th>
	<th>類別</th>
	<th>範例裝置</th>
	</tr>
	<tr>
	<ti>開機分割區, 包含著核心及相關開機所需程式</ti>
	<ti>100 Megabytes</ti>
	<ti>建議使用 ext2/3 (最簡單); 如果你要使用 ReiserFS, 請在掛載時加入 <c>-o notail</c></ti>
	<ti>/dev/hda1</ti>
	</tr>
	<tr>
	<ti>swap 分割區 (之前是不得大於128MB, 現在可以使用為 2GB)</ti>
	<ti>大部分來說, swap 的大小決定於 RAM. 如果你的 RAM 有128MB, 那最好給他 256MB.</ti>
	<ti>Linux swap</ti>
	<ti>/dev/hda2</ti>
	</tr>
	<tr>
	<ti>"根(root)"分割區, 包含著主要的檔案系統 (/usr, /home, 等等)</ti>
	<ti>&gt;=1.5 Gigabytes</ti>
	<ti>建議使用 ReiserFS 或 ext3; ext2 可以</ti>
	<ti>/dev/hda3</ti>
	</tr>
</table>

<p>OK, 現在我們該來建立這些分割區了. 我們可以輸入 <c>fdisk /dev/hda</c> 或是
<c>fdisk /dev/sda</c> (依你的硬碟類型 IDE 或 SCSI ). 然後按下 <c>p</c> 觀看你目前的
分割區列表. 裡面有你想留住的的嘛? 如果有, 請<b>馬上停止</b> 如果你繼續下去的話,
<b>所有分割區裡面的資料將會不見</b>
</p>

<impo>這些步驟將會把硬碟上的資料<b>全部清除</b>. 如果你沒有重要資料的話,
<b>請再次確定你選擇對的硬碟</b>
</impo>

<p>現在, 我要把們所有的分割區刪除. 你可以輸入 <c>d</c> 再按 Enter.
你將會被問要刪除那個分割區. 要刪除第一個分割區你就要輸入:</p>

<pre caption="刪除某一分割區">
Command (m for help): d
Partition number (1-4): 1
</pre>
<p>
這個分割區已被設定為刪除, 如果你按 <c>p</c> 他將不會出現在清單內. 但是請記住, 
這個分割區在你還沒儲存之前還是會存在. 如果你將分割區設定錯誤, 你可以馬上按 <c>q</c>
這樣一來分割區將不會被刪除.
</p>

<!-- NOTE: THis is not sufficient documentation to cover ATA Raid and I just
find it confusing, so I'm commenting it out (drobbins)
<note>If you are using RAID your partitions will be a little different.  You
will have the partitions like this: <path>/dev/ataraid/discX/partY</path> X are
the arrays you have made, so if you only have made 1 array, then it will be
disc0.Y is the partition number as in <path>/dev/hdaY</path> </note>
-->
<p>現在, 假設你要刪除所有的分割區, 請重複輸入 <c>p</c> 列出分割區名單,
然後 <c>d</c> 加上你要刪除的分割區. 最後你的分割區將會看起來像這樣..
</p>

<pre caption="空的分割區列表">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
接下來, 我們需要建立一個開機分割區(Boot partition). 輸入 <c>n</c> 建立一個新的分割區.
然後按 <c>1</c> 建立我們第一個分割區. 當他問你 "cylinder"時, 請按 enter.
當他問你 "last cylinder"時 輸入 <c>+100M</c> 來見力一個 100M 的分割區.
請參考以下輸出:
</p>

<pre caption="建立分割區">
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +100M
</pre>

<p>現在, 按 <c>p</c>, 就可以看到我們剛剛建立的分割區</p>

<pre caption="第一個分割區以被建立">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

<p>接下來, 我們需要建立 swap 分割區. 輸入 <c>n</c> 建立一個新的分割區. 然後 <c>p</c>
告訴 fdisk 你要一個基礎型(primary)的分割區. 接著輸入 <c>2</c>. 當 fdisk 問起 "first cylinder"時
請按 enter. 之後,當 fdisk 問起 "last cylinder" 時 請輸入 <c>+512M</c>. 當步驟完成後, 請按 <c>t</c>
設定系統類型. 你將要輸入 <c>82</c> 告訴系統這是一個 swap 分割區.
當以上步驟完成後, 輸入 <c>p</c> 你的分割區列表將會看起來像這樣...
</p>

<pre caption="Swap 分割區以建立完成">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

<p>最後讓我們來建立 "根"(root) 分割區. 輸入 <c>n</c> 建立一個新的分割.
然後輸入 <c>p</c> 告訴系統你要一個基礎型(primary)的分割. 接著輸入 <c>2</c>.
當 fdisk 問起 "first cylinder"時 請按 enter.
之後,當 fdisk 問起 "last cylinder" 時 你可以按 Enter 表示你要剩下的空間.
完成之後 輸入<c>p</c> 你的分割區列表應該會看起來像這樣...
</p>

<pre caption="&quot;根&quot;分割區以建立完成">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>

<p>
最後, 我們需要設立一個開機旗標 然後寫到分割區列表.
我們需要把 <c>/dev/hda1</c> 設為開機用分割區. 輸入 <c>a</c> 然後輸入 <c>1</c>.
你將看到 <c>/dev/hda1</c> 旁邊有一個 <c>*</c>. 接下來, 我們要將之前作好的分割區寫入硬碟.
輸入 <c>w</c> 再按 Enter. 恭喜! Gentoo Linux 的分割區已經完成了!
</p>

<note>如果 <c>fdisk</c> 或是 <c>cfdisk</c> 顯示需要重開, 請重新用光碟開機.</note>
</body>
</section>
<section>
<title>建立檔案系統</title>
<body>
<p>現在分割區已經完成了, 是時候在開機分割區和分割區根建立檔案系統方便於儲存資料.
我們也需要建立 swap 系統方便儲存 swap 資料.
</p>

<p>Gentoo Linux 支援多種檔案系統, 每種都有他的強處及壞處. 目前我們支援 ext2, ext3, XFS, JFS 和 ReiserFS 系統.</p>

<p>ext2 是一個舊的 Linux 檔案系統 但是卻不是日誌系統. 啟用的時間通常需要很久. 目前有許多 <i>日誌型態</i>的檔案系統
可以以更快的速度及更好的效率完成系統啟用和檢查.
</p>

<p>ext3 為 ext2 的日誌版. 提供了 metadata 日誌系統 並且可以快速地使用日誌系統復原.
ext3 是個相當不錯並且可靠的檔案系統. 在大部分的情況下, 他都可以表現的很好.
唯一的壞處是, 他不使用 Tree 為內部設計 所以無法很有效率的處理過大的檔案.
但是他的參數卻設計的很好. 是個不錯的檔案系統.
</p>

<p>ReiserFS 整理來說是個相當不錯的系統, 在處理小型檔案(少於4kb)時效能會比 ext2 和 ext3來的好.
他使用的是 B*-tree 為基礎的檔案系統. 另外也能很有效率地處理大型檔案.
核心版本 2.4.18 後, ReiserFS 是一個相當有值得推薦的系統, 從很少,到很多檔案. ReiserFS都可以處理的非常好.
開機分割區並不建議使用此檔案系統.

</p>

<p>XFS 是一個 metadat 日誌系統. Gentoo Linux 也完全支援此項檔案系統.
你可以使用 <path>xfs-sources</path> 核心搭配 XFS. 如果你使用高速 SCSI
或是纖維的儲存裝置, 我們才推薦你使用 XFS. 如果沒有, 請使用其他檔案系統.
</p>

<p>JFS 是 IBM 發展的高效能日誌系統. 目前雖然已經可以算是個完成品, 關於他的穩地度並沒有太多的優點及缺點.
</p>

<p>如果你想找一個最耐用的日誌型檔案系統, 請使用 ext3. 如果你想要使用
大部分都不錯的高效能檔案系統(日誌型) 請使用 ReiserFS.
ext3 和 ReiserFS 都相當成熟, 並且推薦為一般使用.
</p>

<!-- Corner case, confusing
		<p>But before creating filesystems, you may want to initialize the
			beginning of your partition using <c>dd</c> if you are using a pre-existing partition that has been used before.
			This is particularly helpful when you're going to create a new XFS filesystem on a partition that previously contained
			a ReiserFS filesystem. Doing this will ensure that your new filesystem
			will not be mis-identified by Linux's filesystem auto-detection code.
			This can be done as follows:
			</p>
<pre caption="Initializing first 1024 bytes of your partition">
# <c>dd if=/dev/zero of=/dev/hda3 bs=1k count=1</c>
<comment>(Replace /dev/hda3 with the partition you wish to &quot;clean.&quot;)</comment>
</pre>
	<warn>The command above will destroy all data from <path>/dev/hda3</path>.
	Be careful and check twice which partition you specify for zeroing.
	If you make a mistake it might result in a loss of data.
	</warn>
-->

<p>基於以上的介紹, 我們將用以下的指令來建立檔案系統</p>

<pre caption="建立檔案系統 (範例)">
# mke2fs -j /dev/hda1
# mkswap /dev/hda2
# mkreiserfs /dev/hda3
</pre>

<p>我們將選為 ext 作為 <c>/dev/hda1</c> 開機分割區 因為此檔案系統堅固並且大部分的開機程式都有支援.
我們將在 <c>/dev/hda2</c> 使用 <c>mkdswap</c> 建立 Swap 分割區. 對於根目錄, <c>/dev/hda3</c>
我們將使用 ReiserFS. 原因是因為他的建構強大並且穩定. 以下為建立那些系統檔案的指令:
</p>

	<p>我們將使用<c>mkswap</c>建立 swap</p>
<pre caption="Initializing Swap">
# <c>mkswap /dev/hda2</c>
</pre>
<p>你也可以使用 <c>mke2fs</c> 建立 ext2 的檔案系統:</p>
<pre caption="建立 ext2 檔案系統">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>如果你想使用穩定點的系統 建立 ext3 的指令為:
	<c>mke2fs -j</c>:</p>
<pre caption="建立 ext3 的檔案系統">
# <c>mke2fs -j /dev/hda3</c>
</pre>
        <note>你可以在以下的網址找到關於 Linux 2.4 的 ext3 系統
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.</note>
        <p>如果要建立 ReiserFS 系統 指令為: <c>mkreiserfs</c></p>
<pre caption="建立 ReiserFS 檔案系統">
# <c>mkreiserfs /dev/hda3</c>
</pre>
        <p>如果要建立 XFS 系統 指令為:  <c>mkfs.xfs</c></p>
<pre caption="建立 XFS 檔案系統">
# <c>mkfs.xfs /dev/hda3</c>
</pre>
        <note>使用 mkfs.xfs 時你需要加入一些參數 例: <c>mkfs.fs -d agcount=3 -l size=32m</c>
<c>-d agcount=3</c>代表著此參數將會減少配置群 (Allocation groups).
XFS 會要最少一個配置群有 4GB. 舉例來說, 你有一個 20GB 的分割區, 最少的 agcount 是 5
<c>-l size=32m</c> 將會增加日誌大小到32MB 以增加效率.
</note>

	<p>如果要建立 JFS 檔案系統 指令為: <c>mkfs.jfs</c></p>
<pre caption="建立 JFS 檔案系統">
# <c>mkfs.jfs /dev/hda3</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>掛載分割區</title>
    <section>
      <body>
        <p>現在, 我們將啟用 Swap 以便後面步驟所需.
			</p>
<pre caption="啟動 swap">
# <c>swapon /dev/hda2</c>
</pre>

        <p>接下來, 我門需要建立 <path>/mnt/gentoo</path> 和 <path>/mnt/gentoo/boot</path> 的目錄.
			我們將會把分割好的硬碟掛在這兩個目錄上. <path>/mnt/gentoo</path> 將會成為我們主要的檔案系統.
			如果你要將 Gentoo Linux 設定為 <path>/usr</path> 和 <path>/var</path> 使用自己的分割區.
			我們將要多建立幾個目錄. 如 <path>/mnt/gentoo/usr</path> 和 <path>/mnt/gentoo/var</path> 等等.
			</p>

			 <impo>如果你的開機分割區 (Boot Partition, 用來儲存 Kernel及 開機檔案) 使用的是 ReiserFS, 請確定你掛時載
			加入 <c>-o notail</c> 的參數. 這樣一來 GRUB 才可以正常的安裝.
			另外, 請確定 <path>/etc/fstab</path> 的掛載設定也有此參數 (ReiserFS 檔案系統專用)
			</impo>

<pre caption="建立掛載目錄">
# <c>mkdir /mnt/gentoo</c>
# <c>mount /dev/hda3 /mnt/gentoo</c>
# <c>mkdir /mnt/gentoo/boot</c>
# <c>mount /dev/hda1 /mnt/gentoo/boot</c>
</pre>

                      <impo>如果你在掛載分割區時(使用的是 ext2), 你可以嘗試此指令: <c>mount /dev/hXX /mnt/gentoo -t ext2</c></impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Stage 壓縮檔與 chroot</title>
    <section>
		<title>選擇一個你想安裝的 Stage 壓縮檔</title>
      <body>

<p>接下來, 如果你還沒決定要使用那個 Stage 壓縮檔案, 你現在需要選擇一個.
</p>

<p>如果你打算從&quot;最基本&quot;開始安裝, 你將需要的是 <path>stage1-x86-1.4_rc3.tar.bz2</path>.
如果你有下載 "gentoo-3stages" 光碟, 你也可以選擇 "Stage2" 或是 "Stage3" 的壓縮檔案.
這些比較省時, Stage2 和 Stage3 已經用 Gentoo 預設的 "USE" 參數編譯過了.
你也可以到 <path>/mnt/cdrom/gentoo</path> 下使用那些檔案. 你也可以輸入 <c>ls /mnt/cdrom/gentoo</c>
看看裡面有什麼.
</p>

<p>如果你想用的 Stage 壓縮檔案(tarball) 版本不在光碟裡, 你需要下載到硬碟裡.
以步驟將教你如何下載 Starge 的壓縮檔案.
</p>

<pre caption="下載你要的壓縮檔">
# <c>cd /mnt/gentoo</c>
<comment>使用 lynx 作為遊覽器:</comment>
# <c>lynx http://www.ibiblio.org/pub/Linux/distributions/gentoo/releases/1.4_rc4/x86/</c>
<comment>按 <c>上</c> 和 <c>下</c> 移動指標 (或是使用 <c>TAB</c>) 當你找到想要下載的檔案時,
按 <c>d</c> Lynx 就會開始下載
儲存然後離開 lynx.

<b>另一個方法</b> 使用wget直接下載:</comment>
# <c>wget <comment>Stage 壓縮檔網址.</comment></c>
</pre>
      </body>
    </section>
    <section>
		<title>解開壓縮檔</title>
      <body>

<p>現在我們該將 Stage 壓縮檔解開到 <c>/mnt/gentoo</c>. 記住! 你只需要解開<b>一個</b> Stage 壓縮檔.
如果你想要使用最簡單的 Stage 3, 你只需要解開 Starge3 的壓縮檔.
依照下面指令解開壓縮檔:
</p>

<impo>
一定不可以忘記要把 <c>p</c> 放入 <c>tar</c> 的參數. 如果你忘記的話, 權限問題將會讓你很頭痛.</impo>

<pre caption="Unpacking the Stages">
# <c>cd /mnt/gentoo</c>
<comment>把以下改為你要解壓縮的 Stage. 如果你要用 Stage3 就改成 stage3</comment>
<comment>把檔案複製到 "/mnt/gentoo/" 的目錄下. 如果在 "/mnt/cdrom/gentoo/" 將無法解開(因為那是一個光碟機的目錄).
.</comment>
# <c>tar -xvjpf /mnt/cdrom/gentoo/stage3-*.tar.bz2</c>
</pre>

<p>解壓縮後可以把放在<path>/mnt/gentoo</path>的壓縮檔刪掉.
<c>rm /mnt/gentoo/stage*.tar.bz2</c>.</p>
</body>
</section>
<section>
<title>進入 chroot</title>
<body>
<p>
接下來我們將使用 <c>chroot</c>&quot;進入&quot;新的 Gentoo Linux 建造環境.
</p>

<pre caption="準備和進入 chroot 環境">
# <c>mount -t proc proc /mnt/gentoo/proc</c>
# <c>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</c>
# <c>chroot /mnt/gentoo /bin/bash</c>
# <c>env-update</c>
Regenerating /etc/ld.so.cache...
# <c>source /etc/profile</c>
<comment>以上指令將帶你進入新的目錄和更新二進位的檔案(binaries))</comment>
</pre>
        <p>當你執行以上檔案時, 你將會被&quot;帶入&quot; 新的 Gentoo Linux 環境 (<path>/mnt/gentoo</path>).
		我們可以在 chroot 裡面繼續剩下的安裝環境.
		</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>使用 sync 更新 Portage tree</title>
    <section>
      <body>
	  
<p>現在, 輸入 <c>emerge sync</c>. 這個指令是告訴 Portage 下載目前最新的 Gentoo Linux Portage tree.
Portage tree 包含著所有需要安裝的程式程序 (我們叫他 ebuilds). 目前我們有接近 4000 個程式包裝.
當你的 <c>emerge sync</c> 完成後, 最新的 Portage 安裝程序(Ebuilds) 就會放在 <path>/usr/portage</path>.
</p>

<pre caption="利用 sync 更新">
# <c>emerge sync</c>
</pre>

      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定 Gentoo 自訂參數 (make.conf)</title>
    <section>
      <body>

<p>現在你個 Portage 已經更新了. 我們現在需要設定自訂的參數. Gentoo Linux 從 Portage 編譯程式時
將會使用這些參數. 你應該要依自己的系統, 想要安裝的方式自訂你的 <c>USE</c>參數.
預設的參數是<e>空的</e>,所以你必須設定以使系統達到最高的效率.
你可以到<uri link="http://www.gentoo.org/doc/en/use-howto.xml">查看USE的教學</uri>
或是<uri link="http://www.gentoo.org/dyn/use-index.xml">查看 USE 的參數</uri>.
</p>

<p>
你也應該設定 <c>CHOST</c>, <c>CFLAGS</c> 和 <c>CXXFLAGS</c>. 這些設定是告訴
C 和 C++ 編譯器如何更有效率的編譯你的系統.如果你使用的是 Athlon XP 處理器,
你就要設 "-march=althon-xp" 在 CFLAGS 和 CXXFLAGS 中.
有更多的範例在 <path>/etc/make.conf</path>
</p>

<p>如果你在防火牆後面, 你應該要 <path>/etc/make.conf</path> 設定.
你可以使用 <c>nano</c> 程式進行編輯.
</p>
<pre caption="設定 make.conf 參數">
# <c>nano -w /etc/make.conf</c>
<comment>(編輯 CHOST, CFLAGS, CXXFLAGS 和自訂的 USE 參數 或是 代理伺服器設定)</comment>
</pre>
        <note>
			需要更多自訂程式編譯的人也應該要看看 <path>/etc/make.globals</path>. 這個檔案是預設的,
			如果你覺得並不能滿足你需求, 你可以在 <path>/etc/make.conf</path> 增加一些參數.
			<path>/etc/make.conf</path>將會 <comment>蓋過</comment> <path>make.globals</path>的參數.
			如果你想要自訂參數, 看看 <path>/etc/make.profile/make.defaults</path> 裡面的設定.
			如果你想要移除某些 <c>USE</c> 裡面的參數, 你可以在 <path>/etc/make.conf</path> 找 <c>USE</c> 並改成<c>USE=&quot;-foo&quot;</c>
			這樣一來 <c>foo</c> 就會在 <path>/etc/make.conf</path>裡被關閉. 而 <path>/etc/make.globals</path> 或是 <path>/etc/make.profile/make.defaults</path>將會被略過.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>從 Stage 1 開始安裝</title>
    <section>
      <body>
	  	<note>你果你不打算從 Stage1開始, 請跳過這個部份.</note>
        <p>Stage1 可以讓你完全依自己的需要自訂系統設定. 如果你選擇這個壓縮檔, 你應該想要一個完全為自己需要的系統吧.
		請慢慢享受, 雖然這個階段將用掉你很多時間. 但是可以完全達到你對系統的需求標準.
		</p>
        <p>現在該開始我們的 &quot;bootstrap&quot; 階段. 作者使用的是 1200Mhz AMD Athlon系統 大約將花費 2 兩個小時.
在此階段我們將編譯, GNU C 編譯器和其他重要的系統程式. 請跟著以下步驟進行:
</p>
<pre caption="Bootstrapping">
# <c>cd /usr/portage</c>
# <c>scripts/bootstrap.sh</c>
</pre>
        <p>我們將開始編譯 &quot;bootstrap&quot;
			</p>
        <note>Portage 預設時將使用 <c>/var/tmp</c> 的目錄進行程式編譯. 有可能會超過 x00 MB. 如果你想要更改
			此目另 請按照以下步驟:
			</note>
<pre caption="更改 Portage's 臨時工作目錄">
# <c>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</c>
</pre>
        <p><c>bootstrap.sh</c> 將會把 <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,
			和 <c>glibc</c>, 重新編譯 而 <c>glibc</c>.需要長一點的時間.當你以上程序完成後你就會到達第二階段 (Stage 2)
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>從 Stage 2 開始, 或是繼續 Stage 1 的步驟</title>
    <section>
      <body>
	  	
		<note>這個階段是開始第二階段.或是繼續第一階段. 如果你選擇從 Stage3 開始, 請跳過這裡.
        </note>

		<p>Stage 2 的壓縮檔已經有包含著 bootstraping, 如果你是從第一階段開始, 請不要再解開Stage2的壓縮檔了.<b>請不要稿混.</b>
			</p>
<pre caption="安裝剩下的系統">
# <c>emerge -p system</c>
<comment>(使用 -p 將會顯示出有那些程式會被編譯)</comment>
# <c>emerge system</c>
</pre>
               <p>
			編譯系統需要一段時間, 筆者建議你去玩 PS2 的 &quot;Star Wars - Super Bombad Racing&quot;
			</p>
			<p>當你完成以上步驟時, 你的系統將已經等於了 Stage3. 在這個階段, 你可以繼續下去按照 Stage 3 的步驟
			這個步驟會更新你的 Portage Tree. 雖然不重要, 但是我們建議你更新.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>從 Stage 3 開始</title>
    <section>
      <body>
  		<note>這個階段是給 <b>從 stage 3 開始的</b> 並不適合從 Stage1 或是 Stage2. 如果你是從 Stage1 或是 Stage2 開始, 請移到下個部份.</note>
	 <p>Stage3 的壓縮檔提供完全的 Gentoo Linux 系統基礎. 你不需要編譯任何東西. 你只需要將系統程式更新.
	 如果你的 Stage3 壓縮檔是舊的, 有可能會花上很長一段時間編譯. 這個步驟將快速的更新你的系統到最新的狀態.
	</p>

<pre caption="更新">
# <c>export CONFIG_PROTECT="-* /etc/make.conf"</c>
# <c>emerge -up system</c>
<comment>(使用 -p 將會顯示出有那些程式會被編譯)</comment>
# <c>emerge -u system</c>
<comment>(-u 確實的更新系統)</comment>
# <c>unset CONFIG_PROTECT</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定時間區域</title>
    <section>
      <body>
        <p>現在我們需要設定時間區域</p>
        <p>查一下你的時間區域 (如果你是用 GMT 請用GTM)
	   從 <path>/usr/share/zoneinfo</path>.然後作個連接到
	   /etc/localtime 範例為:</p>
<pre caption="建立時間區域連接">
# <c>ln -sf /usr/share/zoneinfo/選擇/你的/區域檔案 /etc/localtime</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>安裝Linux 核心(kernel) 和系統記錄器</title>
    <section>
      <body>
        <note>
			如果你還沒有編譯 <path>/etc/make.conf</path> 請編譯後在進行下一步驟.
			</note>
        <p>你現在需要安裝 Linux 核心原始碼 (Kernel Sources) 我們提供:
			</p>
        <table>
          <tr>
            <th>ebuild</th>
            <th>介紹</th>
          </tr>
          <tr>
            <ti>
              <path>gentoo-sources</path>
            </ti>
            <ti>我們的高效能核心原始碼,但是不支援 XFS.</ti>
          </tr>
          <tr>
            <ti>
              <path>xfs-sources</path>
            </ti>
            <ti>使用 XFS 的高配合度的核心.</ti>
          </tr>
          <tr>
            <ti>
              <path>openmosix-sources</path>
            </ti>
            <ti>openMosix 原始核心檔特別為了支援 GPL <uri link="http://www.openmosix.com">openMosix</uri> load-balancing/clustering 技術而改過的.</ti>
          </tr>
          <tr>
            <ti>
              <path>usermode-sources</path>
            </ti>
            <ti>更改後的核心原始碼, 支援User-Mode Linux.  (&quot;Linux inside Linux&quot; technology)</ti>
          </tr>
          <tr>
            <ti>
              <path>vanilla-sources</path>
            </ti>
            <ti>基本的核心原始碼, 就像從 kerenel.org 下載的一樣</ti>
          </tr>
        </table>
        <warn>
			如果你要自行編譯系統核心, 請小心 <i>gresecurity</i> 的選項. 太過小心安全方面的設定將會影響某些程式 (如: X).
			如果你不確定, 請不要更改他.
			</warn>
        <p>選擇一個核心版本, 並按照以下方式編譯</p>
<pre caption="Emerge 核心原始碼">
# <c>emerge sys-kernel/gentoo-sources</c>
</pre>
        <p>當 emerge 完成時, 你可以開始編譯自己的核心了.
			</p>
		<p>請注意: <path>/usr/src/linux</path> 只是一個連接, 並不是真正的目錄. 每次你 emerge 一個核心原始檔時,
		他就會自動更改連接. 如果你有多個核心原始碼, 請在編譯之前先確定連接是否正確.
		</p>
<pre caption="編譯 Linux 核心">
# <c>cd /usr/src/linux</c>
# <c>make menuconfig</c>
# <c>make dep &amp;&amp; make clean bzImage modules modules_install</c>
# <c>cp /usr/src/linux/arch/i386/boot/bzImage /boot</c>
</pre>
			<warn>為了要確保你編譯的核心無誤, 你必須要確定以下提供的建議<i>有內建(而不是使用模組的方式)到</i> 核心l裡面.
			如果你有任何 &quot;ReiserFS&quot; 和 &quot;ext3&quot; 的分割區, 另外, 不論你是否使用 ext2, 請把 ext2 設為內建.
			下面是一些編譯核心時該注意的提示
			</warn>
<pre caption="make menuconfig 選擇">
Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(你必須要內建這部份的某些功能.)</comment>
     ...

File systems ---&gt;
  &lt;*&gt; Reiserfs support
<comment>(如果你有用到 ReiserFS)</comment>
       ... 
  &lt;*&gt; Ext3 journalling file system support
<comment>(如果你有用到 ext3.)</comment>
       ...
  [*] Virtual memory file system support (former shm fs)
<comment>(Gentoo Linux 必須選用此項.)</comment>
       ...
  &lt;*&gt; JFS filesystem support
<comment>(如果你有用到g JFS.)</comment>
       ...
  [*] /proc file system support
<comment>(Gentoo Linux 必須選用此項.)</comment>
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot          
<comment>(Gentoo Linux 必須選用此項.)</comment>
  [ ] /dev/pts file system for Unix98 PTYs
<comment>(不需要.)</comment>
       ...
  &lt;*&gt; Second extended fs support
<comment>(如果你有用到 ext2.)</comment>
       ...
  &lt;*&gt; XFS filesystem support
<comment>(如果你有用到 XFS.)</comment>
</pre>
        <p>如果你使用硬體 RAID, 你將需要在多選用幾個選項. Highpoint RAID 控制卡 和 Highpoint 370軟體需要選 hpt366 以便使用.
			Promise RAID 控制卡將需要選擇 PROMISE PDC202{46|62|65|67|68|69|70} 硬體和軟體支援. (Fasttrak(tm))
			</p>
        <p>如果你是使用 PPPoE 連上網路, 你將需要以下核心選項(以內建或是模組):
			&quot;PPP (point-to-point protocol) support&quot;, &quot;PPP support for async serial ports&quot;,
			&quot;PPP support for sync tty ports&quot;. The two compression options won't harm but
			are not definitely needed, neither does the &quot;PPP over Ethernet&quot;
			這些都是 <i>rp-pppoe</i> 需要的功能.
			</p>
        <p>如果你使用 IDE 燒錄機, 那你需要內建 SCSI emulation.
			你需要勾選:&quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA and ATAPI Block
			devices&quot; ---&gt; &quot;SCSI emulation support&quot; (我把他們設為模組型態).
			還有,在 &quot;SCSI support&quot; 底下, 勾選 &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; 和
			&quot;SCSI generic support&quot; 如果你也把以上那些設為模組, 你將要在編譯完成時輸入 <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot;
			&gt;&gt; /etc/modules.autoload</c>必便開機時自動啟動.
			</p>
        <note>
			給那些想要安裝 Gentoo Linux 使用 核心 2.2 的人,
			現在 Gentoo Linux 可以使用 2.2 版的核心. 但是, 這樣做是要付出代價的.
			你將會損失很多功能, 包括 XFS, iptables 等等. 雖然 2.2版的核心可以利用補釘增加 ReiserFS 和 devfs 支援.
			Gentoo Linux 開機程序需要使用到核心內建的 tmpfs 或是 ramdisk. 所以 2.2 的使用者將要確定 ramdisk 有被內建(不能勾選為模組).
			你<comment>一定要</comment> <path>/boot/grub/grub.conf</path> 或是 <path>/etc/lilo.conf</path> 加入 <e>gentoo=notmpfs</e>
			到裡面的 kernel 選項. 然後 2.2 版的核心就會使用 ramdisk 而略過 tmpfs. 如果你選擇不用 devfs, 那就加入 <e>gentoo=notmpfs,nodevfs</e>
			</note>
        <p>為電腦量身打造的核心出爐啦! 現在你將需要選一個系統紀錄器. 我們提供傳統的 sysklogd 還有 msyslog 和 syslog-ng.
			玩家級的使用者都會選擇後面兩者. (因為sysklogd和後兩者比較起來效率沒那麼好). 而且後兩者提供目前受歡迎的 metalog.
			以下將是教你安裝記錄器的步驟. 任選一即可:
			</p>
<pre caption="安裝你喜歡的系統記錄器">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>或是</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>或是</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>或是</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
</pre>
        <impo>
			Metalog 將會把紀錄以區塊(blocks)的方式塊輸出到硬碟上. 這樣的話,紀錄訊息才部會會馬上變成系統紀錄(system logs).
			如果你正在除錯一個系統服務, 那麼metalog的方式將會變成不太適用.. 當你的 Gentoo Linux 系統安裝完成後, 你可以送出一個 URSR1 的訊息給
			metalog. 這樣將會暫時性的關閉. 你可以使用 <i>tail -f <path>/va/log/,</path>任何東西/項目</i> 除錯.
			USR2 將會啟動 metalog. 如果你要永久關閉此項緩衝區的功能, 你可以到 <path>/etc/conf.d/metalog</path> 把 METALOG_OPTS="-B" 改成
			METALOG_OPTS="-B -s"
			</impo>
        <p>接下來你必須選擇一個 cron 程式. 目前我們提供 dcron, fcron 和 vcron. 如果你不知道該選那一個,
			我們建議你使用 vcron. 請按照以下步驟安裝:
			</p>
<pre caption="選擇一個 Cron 服務器">
# <c>emerge sys-apps/dcron</c>
# <c>rc-update add dcron default</c>
# <c>crontab /etc/crontab</c>
<comment>或是</comment>
# <c>emerge sys-apps/fcron</c>
# <c>rc-update add fcron default</c>
# <c>crontab /etc/crontab</c>
<comment>或是</comment>
# <c>emerge sys-apps/vcron</c>
# <c>rc-update add vcron default</c>
<comment>如果你使用 vcron 你不需要 <c>crontab /etc/crontab</c></comment>
</pre>
			 <p>如果想多了解如何啟動系統服務和程式, 請到:
			<uri link="/doc/en/rc-scripts.xml">rc-script 教學</uri>.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>安裝其他必要的軟體</title>
    <section>
      <body>
        <p>如果你需要 rp-pppoe 連上網路, 現在我們安裝 rp-pppoe.</p>
<pre caption="Installing rp-pppoe">
# <c>USE="-X" emerge rp-pppoe</c>
</pre>

		<note><i>USE="-X"</i>代表著, 在安裝時, 可以防止編譯成 XWindow 的程式.因為如果要編譯成 X 使用的程式,你必須編譯更多其他的程式.
		如果你想編譯給 X 使用, 以後可在編譯一次. (現在是系統安裝,所以費時的 X 等系統完全正常後才考慮)
		</note>
        <note>rp-pppoe 現在以安裝完成, 但是還沒設定
			你需要在第一次重新開機時鍵入  <c>adsl-setup</c>
			</note>
        <p>如果你有使用 XFS, ReiserFS 或是 LVM, 你將需要從 Portage 裡面安裝相關軟體.
			例: 如果你有用 XFS, 你就需要 emerge <c>xfsprogs</c>.
			</p>
<pre caption="Emerge 檔案系統工具">
# <c>emerge sys-apps/xfsprogs</c>
<comment>如果你有使用 ReiserFS 你將要安裝 ReiserFS工具: </comment>
# <c>emerge sys-apps/reiserfsprogs</c>
<comment>如果你有使用 JFS, 你將要安裝 JFS 工具: </comment>
# <c>emerge jfsutils</c>
<comment>如果你有使用 LVM 你將要安裝 lvm 工具: </comment>
# <c>emerge sys-apps/lvm-user</c>
</pre>
        <p>如果你使用手提電腦, 需要在開機時用到 PCMCIA, 你將需要安裝 <i>pcmcia-cs</i>.
			</p>
<pre caption="Emerging PCMCIA-cs">
# <c>emerge sys-apps/pcmcia-cs</c>
</pre>
        <warn>安裝完成後,你將需要再 emerge 一次 <i>pcmcia-cs</i>
			</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定 /etc/fstab</title>
    <section>
      <body>
        <p>你的 Gentoo Linux 系統已經快完成了! 現在我們需要為開機設定給個檔案.
			首先我們將需要更改你的 <path>/etc/fstab</path> 如果你是用 ReiserFS 你將要在選項的部份加入 <c>notail</c>
			記得要在檔案系統類型(filesystem types)中 更改成你的檔案系統. 如: <c>ext2</c>, <c>ext3</c>, <c>reiserfs</c> 等等.
			如果要更仔細的看 <path>/etc/fstab</path> 你可以使用: <c>man fstab</c>
			</p>
        <p>以下部份為 <path>/etc/fstab</path> 範例,一定要記得把 &quot;BOOT&quot;,
			&quot;ROOT&quot; 和 &quot;SWAP&quot; 改成你的分割區 (如 <c>hda1</c>, 等等.)</p>
<pre caption="Editing fstab">
<comment># /etc/fstab: static file system information.
#
# noatime turns off atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It is safe to drop the noatime options if you want and to
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>
        <warn>不要忘記 <i>/boot</i> 不會在開機時自動掛載.
			這是為了防止 <i>/boot</i> 裡面的開機資料
			如果你需要更改 <i>/boot</i>, 請使用 <c>mount</c>掛載
			</warn>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定最高權限密碼(Root)</title>
    <section>
      <body>
        <p>在你忘記之前, 請先設定密碼: </p>
<pre caption="設定 Root 的密碼">
# <c>passwd</c>
</pre>

	<p>你也需要新增一個每天使用的帳號(非 root). 請查閱 <uri link="http://www.gentoo.org/doc/en/faq.xml">Gentoo 常見問題</uri>.
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定主機名稱</title>
    <section>
      <body>
        <p>請設定一個 有效的FQDN(Fully Qualified Domain Name) 的主機名稱. 例: <c>mymachine.mydomain.com</c>.</p>
<pre caption="設定主機名稱">
# <c>echo mymachine.mydomain.com &gt; /etc/hostname</c>
</pre>
<p>編輯 /etc/dnsdomainname 裡面將需要你的主機所用的網域名稱. 例: <c>mydomain.com</c>.</p>
<pre caption="設定網域名稱">
# <c>echo mydomain.com > /etc/dnsdomainname</c>
</pre>
<p>如果你有 NIS 網域, 你將要把他寫入 /etc/nisdomainname.</p>
<pre caption="設定 NIS 網域名稱">
# <c>echo nis.mydomain.com > /etc/nisdomainname</c>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定 /etc/hosts</title>
    <section>
      <body>
        <p>這個檔案將會含著 主機需要使用到的 IP 位置 和主機名稱. 可以用來反解你的 name server 找不到的名稱(local使用).
		以下為範例:
			</p>
<pre caption="Hosts 範例">
127.0.0.1      localhost
<comment>#下一行包含著你的區網的IP 和相關的主機名稱</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>
        <note>如果你是使用 DHCP 網路, 加入 <i>localhost</i> 將會為 GNOME 和其他程式造成一些很大的幫助(反解名稱)
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最後網路設定</title>
    <section>
      <body>
        <p>你將需要在 <path>/etc/modules.autoload</path> 加入剛剛你編譯核心的模組. 這樣一來 Gentoo Linux
			啟動時, 將會自動載入. 註: 如果你將網路卡編為模組, 如果沒有載入他, 他不會自動啟用.
			</p>
<pre caption="/etc/modules.autoload"><comment>假設你使用的是 3com 網路卡
檢察 <path>/lib/modules/`uname -r`/kernel/drivers/net</path> 看是否有. </comment>
3c59x
</pre>
        <p>編輯 <path>/etc/conf.d/net</path> 以便開機時啟動網路: </p>
<pre caption="開機網路設定">
# <c>nano -w /etc/conf.d/net</c>
# <c>rc-update add net.eth0 default</c>
</pre>
        <p>如果你有多張網卡, 你將需要複製為 <path>net.eth<comment>x</comment></path>
		(<comment>x</comment> = 1, 2, ...) 請看以下範例:
		</p>
<pre caption="多張網路卡">
# <c>cd /etc/init.d</c>
# <c>cp net.eth0 net.eth<comment>x</comment></c>
# <c>rc-update add net.eth<comment>x</comment> default</c>
</pre>
        <p>如果你使用的是 PCMCIA, 請查看 <path>/etc/init.d/pcmcia</path> 是否正確.
			然後在最上面加入 <path>/etc/inid./net.ethx</path>
			</p>
<pre caption="讓 PCMCIA 依賴 /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
</pre>
        <p>這樣就可以在啟動網路時自動啟動 PCMCIA 網路卡的驅動程式.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>最後的步驟: 基本設定 (包括 國際keymap設定)</title>
    <section>
      <body>
<pre caption="基本設定">
# <c>nano -w /etc/rc.conf</c>
</pre>
        <p>按照檔案裡面的引導, 將系統的基礎設定. 請確定 <c>CLOCK</c> 有設定過.
			國際鍵盤的使用者將需要設定 <c>KEYMAP</c> (可以查閱<path>/usr/share/keymaps</path> 查看可用的選項).
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>設定開機程式</title>
	<section>
	<title>Notes</title>
	<body>
	<p>Gentoo 的精神, 大家現在有多種的開機程式可以使用. 在我們的虛擬包裝系統裡, 使用者可以選擇 GRUB 或是 LILO
	</p>
	<p>請記住, 你只需要安裝一個開機程式, 請不要安裝超過一個.
	</p>
	<impo>如果你是使用 NVIDIA nForce 或是 nForce2 結合的 GeForce 顯示卡, 你應該要使用 LILO 而不是 GRUB.
	原因是低階記憶(low memory)有可能會被使用成為 video RAM. GRUB 開機時使用的是低階記憶 所以有可能會造成記憶體不足的狀況.
	如果你使用 nForce 或是其他內建顯示卡, 請使用 LILO.
	</impo>
    <p>
有些使用者會在kernel裡面設定 framebuffer, 如果如此, 你應該在開機設定檔裡面輸入 <c>vga=xxx</c>為開機參數. <c>xxx</c> 就會是已下列表的號碼: 
    </p>
 <table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>
	</body>
	</section>
    <section>
	<title>設定 GRUB</title>
      <body>
        <p>GRUB 中最重要的就是 GRUB 如何指向硬碟和分割區. 你的 Linux 分割區 <path>/dev/hda1</path> 在 GRUB
			中間會變成 <path>(hd0,0)</path> 注意 hd0,0 的括號,他們是不可缺的. 硬碟和分割區是從 0 開始計算的.
			非 atapi-ide 的裝置 如CDROM, 燒錄機, SCSI 裝置等等 都是在 BIOS 設定時被設定為高一點的號碼.
			舉例來說, 你的硬碟是在 /dev/hda, CDROM 是 /dev/hdb, 燒錄機是在 /dev/hdc, 第二個硬碟是在 /dev/hdd.
			在 <path>/dev/hdd7</path> 將會被翻譯成 <path>(hd1,6)</path>
			看起來很複雜, 但是他的確很複雜. GRUB 有提供 Tab 的選項. 當你有很多硬碟和分割區時,
			你可以按 Tab 鍵來列出所有的硬碟或分割區
			</p>
        <p>設定 GRUB 最簡單的方法就是輸入 <c>grub</c>: </p>
<pre caption="安裝 GRUB">
# <c>emerge grub</c>
# <c>grub</c>
</pre>
        <impo>如果你使用的是硬體 RAID, 此部份將不適合你安裝. 跳過此項到設定 <path>grub.conf</path> 的部份.
			</impo>
        <p>你將會被帶入 <c>grub&gt;</c>的 grub 程式內. 現在我們將需要把 GRUB 安裝到 主引導紀錄 (MBR).
			請參考以下範例:
			</p>

<pre caption="在 MBR 上安裝 GRUB">
grub&gt; <c>root (hd0,0)</c> <codenote>開機分割區(boot partition)</codenote>
grub&gt; <c>setup (hd0)</c> <codenote>安裝 MBR 的地方</codenote>
</pre>

<pre caption="不要安裝在 MBR">
<comment>如果你想要在其他地方上安裝 GRUB</comment>
grub&gt; <c>root (hd0,0)</c> <codenote>開機分割區(boot partition)</codenote>
grub&gt; <c>setup (hd0,4)</c> <codenote>開機紀錄在此,  /dev/hda5</codenote>
grub&gt; <c>quit</c>
</pre>

	<p>接下來為以上兩個指令的解說. 第一個 <c>root ( )</c> 是告訴 GRUB 你的開機分割區的位址.
			(在我們的例子裡, <path>/dev/hda1</path> 或是 GRUB 適用的 <path>(hd0,0)</path>. 第二, <c>setup ( )</c>
			是開機紀錄(boot record) 將會在你指定的地方設定特別的檔案. 在筆者的例子中, 我想把開機紀錄 放在硬碟的 MBR上
			所以我將指定 <path>/dev/hda</path> (也是 GRUB 中的 <path>(hd0)</path>).
			如果我是使用其他的開機程式(Boot Loader), 我將需要把 GRUB 設為第二開機程式.
			我可以把 GRUB 安裝在其他的分割區上(而不是整個硬碟). 當 GRUB 以設定完成後, 你可以輸入 <c>quit</c> 離開 GRUB.
			</p>

			<note>在 GRUB 裡, TAB 的是一個很方便的工具, 當你輸入 <c>root (</c> 然後按下 TAB 鍵, 你將會看到
			所有的分割區列表. 按下 TAB 後, 就會自動幫你改為 <c> root (hd</c>. 再按一次, grub 將列出可用硬碟
			就會變成 <c> root (hd0,</c> 然後你可以自己輸入或是按下 TAB 這樣就可以讓 grub 再次列出可以使用的分割區.
			</note>

			<p>現在我們只需要設定 <path>/boot/grub/grub.conf</path> 這樣一來就可以使用 GRUB 開機了
			以下為 Grub.conf 的範例:
			</p>
        <impo>為了確保和 GRUB 的反面相容性 (backwards compatibility), 你要確定 <i>grub.conf</i> 有連接到 <i>menu.lst</i>.
		你可以輸入以下指令建立連接: <c>ln -s /boot/grub.conf /boot/grub/menu.lst </c></impo>
		<p>現在我們將要建立 grub.conf 檔案 (<c>nano -w /boot/grub/grub.conf</c>). 然後按照以下方法加入
			</p>
<pre caption="GRUB 使用的 Grub.conf">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment>#以下為硬體 RAID 的設定</comment>
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY

<comment># 以下為雙重開機的設定</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>
        <note>
			(hd0,0) 在括號內不應該有空格.
			</note>
        <impo>
			如果你要為 IDE 燒錄機設定 SCSI 虛擬, 你將需要加入 &quot;hdx=ide-scsi&quot; grub.conf 裡的
			kernel 選項裡. (&quot;hdx&quot; 應該改為你的燒錄機位置)
			</impo>
        <p>當以上步驟完成後, 恭喜你! 你的 Gentoo Linux 已經完成安裝了. 開機後第一個選將將會帶你進入 Gentoo Linux.
			第二個選擇就會帶你進入 Windows (如果你有Windows的話)
			</p>
        <note>上面的, <path>(hd0,0)</path> 應該要指向你的&quot;開機&quot;分割區
			(<path>/dev/hda1</path>範例中的) 和 <path>/dev/hda3</path> 應該要指向你的"根"(root)分割區.
			而 <path>(hd0,5)</path> 就是指向 Windows 的分割區
			loader.
			</note>
        <note>
			核心映像是放在 開機分割區內. 如果你的開機分割區 <path>(hd0,0)</path> 和根分割區 <path>(hd0,1)</path> 分開, 以上所有路徑將會在 grub.conf
			裡面成為 <path>/bzImage</path>
			</note>
        <p>如果你需要跳過任何核心內的選項, 你只要在 <c>kernel</c> 的指令後面加上就可以了.
			我們已經有給予一個加上的指令 (<c>root=/dev/hda3</c>), 你也可以加上其他的.
			你也可以關閉 devfs 使用 <c>gentoo=nodevfs</c> 的選項. 就和以上那個功能一樣, 放在kernel選項即可.
			</p>
        <note>和早一點的 Gentoo Linux 不同的是, 你現在不需要在設定檔裡面的核心選項 (<c>kernel</c>) 內加入 <c>devfs=mount</c>
			在 rc6 devfs將會被預設為自動啟用
			</note>
      </body>
    </section>
	<section>
    <title>設定 LILO</title>
      <body>
        <p>目前 GRUB 是最新的選擇, 但是並不是一直都是最好的選擇. LILO (LinuxLOader) 是真正有實力的Linux 啟動程式.
	以下是 LILO 的安裝方式:
	</p>
        <p>第一步就是利用 emerge 安裝 LILO
	</p>
<pre caption="安裝 LILO">
# <c>emerge lilo</c>
</pre>
        <p>接下來我們需要設定 <path>/etc/lilo.conf</path> 以下為設定範例
	</p>
<pre caption="lilo.conf 範例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

image=/boot/vmlinuz-2.4.20
	label=linux
	read-only
	root=/dev/hda3
	
#For dual booting windows/other OS
other=/dev/hda1
	label=dos
</pre>
	<ul>
        <li><i>boot=/dev/hda</i> 將告訴 LILO 安裝到第一個 IDE 控制卡上的硬碟</li>
        <li><i>map=/boot/map</i>LILO 的地圖檔, 你不應該編輯此項</li>
        <li><i>install=/boot/boot.b</i>將告訴 LILO 安裝到新的開機區域(Sector) 在普通的情況下, 如果沒有 install 這行, LILO 將會預設使用這個檔案.</li>
        <li><i>prompt</i> 是告訴 LILO 在開機時顯示傳統的 <i>lilo:</i> 畫面. 雖然不建議你移除掉這個, 如果你移除掉此行, 你可以在開機時按下
	[Shift] 間啟動開機畫面.
	</li>
        <li><i>timeout=50</i> 是設定 LILO 等待使用者選擇的時間,  如果設定為 50 就代表著等待時間為 5 秒.
	</li>
        <li><i>lba32</i> 是為 LILO 解釋硬碟的構造. 另一個常用的項目是 linear. 除非你真的很了解, 不然請不要改變這行.
	不然可能會造成無法開機的狀態.
	</li>
        <li><i>default=linux</i> 將告訴 LILO 這是一個預設開機的選項. 必須和以下的 label 所輸入的相同.
	</li>
        <li><i>image=/boot/vmlinuz-2.4.20</i>將告訴 LILO 開機時要選擇那一個編譯完成後的核心.</li>
        <li><i>lable=linux</i>當 LILO 啟動時, 這個選項將被用來放在清單內.如果你要將此設為預設, 一定要和上面的 default 相同.
	</li>
        <li><i>read-only</i>將告訴 LILO 你個根分割區要設定成唯獨並且在開機中不會被被更改.</li>
        <li><i>root=/dev/hda5</i> 將告訴 LILO 開機時你的根目錄在那裡. </li>
	</ul>
        <p>設定好 <i>lilo.conf</i> 後, 現在我們需要把 LILO 放到 MBR 裡面.
	</p>
<pre caption="執行 LILO">
# <c>/sbin/lilo</c>
</pre>
        <p>LILO 已經設定好了, 現在你的電腦已經可以使用 Gentoo Linux 了!
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>製作開機片</title>
    <section>
      <title>GRUB 開機片</title>
      <body>
        <p>第一次安裝任何 Linux 時, 製作一個開機片是一個不錯的主意.這是為了在錯誤發生時方便你修正.
			如果你是使用硬體 RAID, 你將 <e>需要</e> 建立一個 GRUB 開機片. 面對相當多種類的硬體 RAID,  你將無法在 chroot 裡面製作
			GRUB 開機片,如果你碰到此情況, 你將需要在第一次重開時,把 GRUB 安裝到 MBR 裡. 請按照以下步驟:
			</p>
<pre caption="製作 GRUB 開機片">
# <c>mke2fs /dev/fd0</c>
# <c>mount /dev/fd0 /mnt/floppy</c>
# <c>mkdir -p /mnt/floppy/boot/grub</c>
# <c>cp /usr/share/grub/i386-pc/stage1 /mnt/floppy/boot/grub/</c>
# <c>cp /usr/share/grub/i386-pc/stage2 /mnt/floppy/boot/grub/</c>
# <c>umount /mnt/floppy</c>
# <c>grub</c>

grub&gt; <c>root (fd0)</c>
grub&gt; <c>setup (fd0)</c>
grub&gt; <c>quit</c>
</pre>
        <p>現在你可以使用 軟碟開機.在軟碟的 <c>grub&gt;</c> 現在你可以使用 <c>root</c> 和 <c>setup</c> 的指令了.</p>
      </body>
    </section>
    <section>
      <title>LILO 開機片</title>
      <body>
        <p>如果你使用的是 LILO, 製作一個開機片也是一個不錯的主義.
		</p>
<pre caption="製作 LILO 開機片">
# <c>dd if=/boot/你的核心 of=/dev/fd0 </c>
<comment>只有在核心小於 1.4MB 的情況下才有可能</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>安裝完成!</title>
    <section>
      <body>
        <p>現在, Gentoo Linux 已經完成安裝了! 最後的步驟就是更新特定的設定檔, 離開 chroot, 解除硬碟掛載, 和重開機:
			</p>
<pre caption="最後步驟">
# <c>etc-update</c>
# <c>exit</c>
<comment>(以上指令將會離開 chroot, 你也可以輸入 <c>^D</c>)</comment>
# <c>cd / </c>
# <c>umount /mnt/gentoo/boot</c>
# <c>umount /mnt/gentoo/proc</c>
# <c>umount /mnt/gentoo</c>
# <c>reboot</c>
</pre>
        <note>
			重開後, 際得執行 <c>update-modules</c> 這樣才會建立 <path>/etc/modules.conf</path>.
			你不應該編輯此檔, 如果要更改設定, 請到 <path>/etc/modules.d</path> 這個目錄裡面去更改.
			</note>
        <impo>別忘了, 如果你使用硬體 RAID, 你一定要在第一次開機時使用開機片. 然後按照上面的方法去安裝 GRUB.
			這樣一來你就完成了 -- 恭喜!
			</impo>
        <p>如果你有任何問題, 或是想加入 Gentoo Linux 發展, 你可以加入我們的 gentoo-user 和 gentoo-dev 郵件名單.
			(更多的資料在 <uri link="http://www.gentoo.org/main/en/lists.xml">郵件名單</uri> 網頁).
			我們也有好用的 <uri link="http://www.gentoo.org/doc/en/desktop.xml">桌上型設定</uri>. 將會幫助你繼續
			設定你的 Gentoo Linux.
			此外, 還有 <uri link="http://www.gentoo.org/doc/en/portage-user.xml">Portage 手冊</uri> 幫助你了解 Portage.
			你可以到 <uri link="http://www.gentoo.org/main/en/docs.xml">找其他的文章</uri>. 如果你有任何關於安裝的問題,
			請到 <uri link="http://www.gentoo.doc/en/faq.xml">問與答</uri>.
			最後, 歡迎你使用 Gentoo Linux!
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Gentoo-Stats(統計)</title>
    <section>
      <body>
        <p>當 Gentoo Linux 開始使用統計時, 是讓開發者了解使用者的需求量. 這個程式將收集著 Gentoo Linux 使用量,
		方便我們開發. 我們並不強迫您安裝, 但是我們將會很感激你如果你選擇幫助我們. 收集到的統計將放在
		<uri>http://stats.gentoo.org</uri>.
		</p>
        <p>gentoo-stats 伺服器將會給你的系統一個唯一的號碼. 這個號碼將部會用來收集系統資訊, 或是你的 IP 位址.
		你的隱私將會被保護著. 以下是我們將收集的資料:
		</p>
        <ul>
          <li>安裝的軟體,和版本</li>
          <li>CPU 資料: 速度 (MHz), 廠牌, 類型, CPU 種類 (像是 &quot;mmx&quot; or &quot;3dnow&quot;)</li>
          <li>記憶體資料(RAM,和 SWAP空間)</li>
          <li>PCI 控制卡和網路卡</li>
          <li>你的主機使用的Gentoo Linux Profie (在 /etc/make.profile 裡面的 link).</li>
        </ul>
        <p>我們不會收集對於 Gentoo Linux 使用者相關的個人資料. 以確保資料不會暴露. (和開發者一樣)
		</p>
        <ul>
          <li>除非你有更改 gentoo-stats 程式, 不然他不會傳出你的密碼,設定檔, 鞋子尺寸...</li>
          <li>傳送你的email地址是非必要的設定, 被預設為關閉</li>
          <li>傳送時的 IP 位址將部會被紀錄, 我們可以透過給你的號碼作為認證, 所以我們不需要 &quot;IP位址&quot;.</li>
        </ul>
        <p>安裝時很簡單 - 請按照以下步驟:
		</p>
<pre caption="安裝 gentoo-stats">
# <c>emerge gentoo-stats</c>   <codenote>安裝 gentoo-stats</codenote>
# <c>gentoo-stats --new</c>    <codenote>申請新的系統號碼</codenote>
</pre>
        <p>第二個指令將申請一個系統號碼, 此號碼會被自動地放到 <path>/etc/gentoo-stats/gentoo-stats.conf</path>.
		你可以編輯此檔查看其他的設定選項.
		</p>
        <p>接下來我們將需要把統計程式(gentoo-stats) 設為自動檢察. (不需要使用 root 的權限)
		你只需要在 <path>crontab</path> 加入以下指令:
		</p>
<pre caption="使用 cron 更新 gentoo-stats">
<c>0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null</c>
</pre>
        <p><c>gentoo-stats</c>是用 perl 編寫的小程式, 你也可以用你最喜歡的文字編輯器編輯: <path>/usr/sbin/gentoo-stats</path></p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>在 Gentoo 上使用少見的硬體</title>
    <section>
       <title>硬體 ATA RAID</title>
       <body>
       <p>
       想要在 Gentoo 上使用硬體 ATA RAID 的使用者,,請注意以下步驟. 這樣才能方便幫助你完成 Gentoo 的安裝.
       </p>
       <ul>
       <li>記得在 LiveCD 開機時加入 <c>doataraid</c> 的參數</li>
       <li>如果你再開機時忘了輸入 <c>doataraid</c> 你可以自行輸入:
       <pre caption = "載入 RAID 模組">
# <i>modprobe ataraid</i>
<comment>適用於: Promise Raid 控制卡:</comment>
# <i>modprobe pdcraid</i>
<comment>適用於 Highpoint Raid 控制卡:</comment>
# <i>modprobe hptraid</i>
       </pre>
       </li>
       <li>有些 ATA RAID 控制卡椰b分割和格式化後|要求你重新開機; 不然有可能會失敗.</li>
       <li>進入 chroot 以前, 將 devicetree 載入新的環境
       <pre caption = "將 /dev 載入 /mnt/gentoo/dev">
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
       </pre>
       </li>
       <li>編譯核心時, 記得選擇你所需 RAID 的選項:
       <pre caption = "Linux 核心 RAID 設定">
<comment>Highpoint RAID 控制卡:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
  [*] HPT36X/37X chipset support
  [*] Support for IDE Raid controllers
  [*] Highpoint 370 software RAID
<comment>Promise RAID 控制卡:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
  [*] PROMISE PDC202{46|62|65|67} support
  <comment>and/or</comment>
  [*] PROMISE PDC202{68|69|70|71|75|76|77} support
  [*] Support for IDE Raid controllers
  [*] Support Promise software RAID (Fasttrak(tm))
       </pre></li>
       <li>當你在執行 <c>grub</c> 然後到達 <c>setup</c>指令時, 加入 <c>--stage2=/boot/grub/stage2</c>
       <pre caption = "為 GRUB 安裝硬體 RAID 系統s">
grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
grub&gt; <i>quit</i>
       </pre>另外, 在 GRUB 的設定中, 記得把 <c>root</c> 指向適當的 RAID 裝置:
       <pre caption = "grub.conf 和 RAID 的設定">
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
       </pre></li>
       <li>LILO 的使用者將需要將 <c>root</c> 設定到是當的 RAID 裝置: 
       <pre caption = "lilo.conf 和 RAID 的設定">
image=/boot/bzImage
    label=linux
    read-only
    root=/dev/ataraid/dXpY
       </pre></li>
     </ul>
   </body>
 </section>
</chapter>
</guide>
