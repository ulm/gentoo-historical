<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/tw/gentoo-x86-install.xml">
<title>Gentoo Linux 1.4 安裝指南</title>
<author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Author">Chris Houser</author>
<author title="Author">Jerry Alexandratos</author>
<author title="Ghost">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
</author>
<author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>
<author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
</author>
<author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
</author>
<author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
</author>
<author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
</author>
<author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
</author>
<author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
</author>
<author title="Editor">Colin Morey</author>
<author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor, Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
    <mail link="avenj@gentoo.org">Jon Portnoy</mail>
</author>
<author title="Editor">
     <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Reviewer">
    <mail link="gerrynjr@gentoo.org">Gerald J. Normandin Jr.</mail>
</author>
<author title="Reviewer">
    <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
</author>
<author title="Translator">
    <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<!-- Version 2.6.4 Synced with 1.155 2003/08/11 -->
<abstract>
以下的指南將帶你一步一步安裝 Gentoo Linux 版本 1.4(和rc版本不同). Gentoo Linux 安裝模式支援依個人喜好和各種的需求. 你將會自己從頭打造你所用的 Gentoo Linux.
</abstract>

<license/>

<version>2.6.4</version>
<date>2003年8月11日</date>

<chapter>
<title>關於安裝</title>
<section>
<body>

<p>
首先, 如果你是第一次接觸, 歡迎使用 Gentoo Linux. Gentoo Linux 有許多安裝方式. 如果你想要快速地安裝, 你可以使用已經編譯好的套件. 另外, 如果你想要完全自訂 Gentoo Linux, 這份指南將帶領你自行安裝.
</p>

<p>
官方 Gentoo 1.4 的發表版本有一個明顯的改變. 那就是兩片安裝光碟. 這份安裝光碟可以從<uri link="http://store.gentoo.org">Gentoo Linux 商店</uri>, 還有我們其他的對映站.目前我們的兩片安裝光碟有適合 x86 (486 或以上), i686 (Pentium Pro, Pentium II, Athlon/Duron 或以上), Pentium III, Pentium 4 和 Athlon XP. 這些光碟都是特別為你打造的, 請參考 <uri link="http://store.gentoo.org">商店</uri> 取得更多的詳細說明. 商店裡面的說明將包括各種處理器(CPU)的相容資料.
</p>

<p>
	關於兩片安裝光碟 -- 第一片光碟 ("CD 1") 是取名為 "Live CD 安裝". 此片光碟可以使用光碟機啟動, 意思就是你可以直接地使用 "CD 1" 來執行 Gentoo Linux. 接著你可以使用光碟裡面的版本進行硬碟安裝. 此外, CD 1 將包含著所有安裝時所需要的檔案, 所以你不一定需要網路的連線來進行安裝. CD 1 還包括了一些已經編譯好的套件 如重要的 XFree86 伺服器. 如果你有 CD 1 的 ISO 映像檔, 此光碟的尾端為 "<path>-cd1.iso</path>".
</p>

<p>
	相反的, 第二片光碟 ("CD 2") 不能用來開機. 此片光碟包含著許多已經編譯好的系統套件. 這片光碟將包含著各種自訂版本的安裝套件, 如: KDE, GNOME, OpenOffice, Mozilla, Evolution 和其他. 第二片光碟是<e>非必要</e>的, 此片光碟是針對想要快速完成 Gentoo Linux 安裝的使用者. 在一般單處理器(CPU)的系統, 第二片裡面的套件通常需要 36 小時編譯. 如果你有 CD 2 的 ISO 映像檔, 此光碟的尾端為 "<path>-cd2.iso</path>".
</p>

<note>
一份完整的 Gentoo Linux 雙光碟 包含著 Gentoo 參考平台 (Gentoo Reference Platform), 此平台有完整已編譯的 Gentoo Linux 系統, 包括 GNOME, KDE, Mozilla 和 OpenOffice. Gentoo 參考平台 ("GRP") 的主要目的是為了那些想要快速安裝 Gentoo Linux 的使用者. "原始編譯 (compile from source)" 包含著所有的安裝功能及選項. GRP 的目的是為了讓部分使用者更方便地安裝, 而不需要接觸到 Gentoo 強大的 "原始編譯" 安裝模式.
</note>

<p>
除了我們的雙光碟, 我們也有非常小的 "基本 (basic)" Live CD. 你可以使用此光碟(Basic Live CD), 開機, 安裝. 你可以設定網路連線, 和透過網路安裝 Gentoo Linux. 使用 "基本"光碟的好處是它的映像光碟很小, 讓你可以更快速地下載. 如果你是進階的使用者, 而且想要安裝最新的 Gentoo Linux 版本, 和擁有快速的網路連線, 你或許會選擇此項安裝. 如果你有我們的 "基本 (basic)" Live 光碟, 此光碟的尾端為 "<path>-basic.iso</path>".
</p>
		
<p>
使用安裝光碟, 你必須要有 486 以上的處理器(CPU)和最少64 Megabytes 記憶體. (Gentoo 已經成功的在 64MB 記憶體 加上 64MB 的 Swap 環境下執行, 但是建立過程是相當慢的.)
</p>

<p>
當你使用我們任何一個 Live 光碟開機時, 你將可以選擇安裝的方式. Gentoo Linux 可以使用 任何一個 &quot;stage&quot; 壓縮檔案. 你選擇的壓縮檔案將會是你想要自己編譯的程度. 如果你選擇使用 Stage1 壓縮檔, 你將會需要 bootstrap 和自己建立整個系統. Stage2 的壓縮檔通常是 Stage1 的半成品. Stage3 的壓縮檔已經包含著已經編譯完成的 Gentoo Linux 系統. 如果你想要進行 "GRP" 安裝, 那你就該從 Stage3 開始.
</p>

<p>
<b>如果你不是要進行 GRP 安裝, 那你該使用哪一個呢? Stage1, Stage2, 或是 Stage3 呢?</b>以下將提供你一些幫助你決定的資訊.
</p>

<p>
從 Stage1 開始將讓你可以完全自訂和設定系統. 進階的使用者使用 Stage1 安裝時會知道自己在做些什麼. 這也是一個讓想了解 Gentoo Linux 核心的安裝方法.
</p>

<p>
Stage2 安裝將跳過 Stage1 的步驟, 你將會使用我們預設的自訂設定.
</p>

<p>
選擇 Stage3 將會讓你快速地安裝 Gentoo Linux, 但是這也代表著你的系統將會是我們為你所編譯的 (老實說, 完善的設定, 增加效能及穩定度). Gentoo Linux 的重要發表版本都有為 Stage3 進行最佳設定 -- 快速地安裝及完善的系統設定.
</p>

<p>
<b>如果這是你第一次安裝 Gentoo Linux, 請考慮使用 Stage3 或是 GRP.</b>
</p>

<note>
<b>進階使用者:</b> 如果你使用 Stage3 安裝, 你將無法改變 <path>/etc/make.conf</path> 預設的的 CHOST 設定. 如果你需要更改此項設定, 你應該要從 Stage1 開始編譯你的系統以及你所要的 CHOST 設定. CHOST 設定通常會看起來像這樣: <c>i686-pc-linux-gnu</c>.
</note>

<impo>
如果你在任何安裝過程中遇到問題, 也想要申報為錯誤 (bug), 請到 <uri>http://bugs.gentoo.org</uri>. 如果這個錯誤需要送到原來的系統開發者 (例; KDE 團隊), <e>Gentoo Linux 開發者</e> 將會為你傳送.
</impo>

<note>
LiveCD 的安裝指南或許已經過時了, 請參考我們最新的網路文件 <uri>http://www.gentoo.org/doc/tw/gentoo-x86-install.xml</uri>. 如果中文版尚未更新, 請參考英文版 <uri>http://www.gentoo.org/doc/en/gentoo-x86-install.xml</uri>.
</note>

<p>
現在, 讓我們複習一次安裝過程. 首先, 我們將需要下載, 燒錄光碟和一片 LiveCD. 開機到達 root 提示(Prompt)後, 我們將要建立分割區, 建立檔案系統, 和解開 Stage1, Stage2 或是 Stage3 的壓縮檔. 如果我們使用 Stage1 或是 Stage2 壓縮檔, 我們將需要確實地按照步驟到達 Stage3. 當我們的系統到達 Stage3 的步驟時, 我們可以設定它 (自訂設定檔, 安裝開機程式, 等等.) 重開後我們將會有一個完善的 Gentoo Linux 系統. 當基本的 Gentoo Linux 系統執行時, 你可以使用 "CD 2" 安裝任何的已編譯套件. 如 KDE, GNOME, OpenOffice, Mozilla, 或者是其他你想要安裝的套件.
</p>

<p>
依照你所想要的安裝過程, 以下為安裝過程中所需要的:
</p>

<table>
<tr>
 <th>Stage 壓縮檔</th>
 <th>需要網路連線</th>
 <th>安裝媒體</th>
 <th>步驟</th>
</tr>
<tr>
 <ti>1</ti>
 <ti>是</ti>
 <ti><e>basic</e> 或是 <e>CD 1</e></ti>
 <ti>硬碟分割/設定檔案系統, emerge sync, bootstrap, emerge system, 最後設定</ti>
</tr>
<tr>
 <ti>2</ti>
 <ti>是</ti>
 <ti><e>basic</e> 或是 <e>CD 1</e></ti>
 <ti>硬碟分割/設定檔案系統, emerge sync, emerge system, 最後設定</ti>
</tr>
<tr>
 <ti>3</ti>
 <ti>如果使用 <e>CD 1</e>不需要, 其他則需要</ti>
 <ti><e>basic</e> 或是 <e>CD 1</e></ti>
 <ti>硬碟分割/設定檔案系統, emerge sync (如果使用 <e>CD 1</e>則不需要), 最後設定</ti>
</tr>
<tr>
 <ti>3+GRP</ti>
 <ti>否</ti>
 <ti><e>CD 1</e>, <e>CD 2</e> 非必須</ti>
 <ti>硬碟分割/設定檔案系統, 最後設定, 安裝 CD1 已編譯套件 (非必須), 重新啟動, 安裝其他已編譯套件 如 KDE 和 GNOME (如果有使用 "CD2")</ti>
</tr>
</table>

<note>
硬體 ATA 多磁碟機陣列的使用者將需要在開始前閱讀最下面關於 ATA 陣列的部分.
</note>

</body>
</section>
</chapter>

<chapter>
<title>開機</title>
<section>
<body>

<warn>
開始這個步驟前, 請先閱讀這個部分, 特別是開機參數. 如果你略過此項建議,
你有可能會誤設鍵盤, 無法啟動 pcmcia 服務等等..
</warn>

<p>
使用 LiveCD 開機時, 你應該會看到一個很漂亮的 Gentoo Logo 圖示. 在這邊你可以按下 Enter 開始開機程序, 或是使用 LiveCD 的自訂核心開機選項然後按下 Enter. 例: <c>gentoo nousb nohotplug</c>. 如果你的系統有超過一個處理器 ("SMP"), 你應該輸入 <c>smp</c> 而不是 <c>gentoo</c>. 如此一來 LiveCD 將會偵測到所有的處理器, 而不是只有第一個.
</p>
		
<p>
請參考以下列表關於可利用的核心和開機選項, 或是按下 F2 和 F3 查詢說明.
</p>

<table>
	<tr><th>可利用的核心</th><th>說明</th></tr>
<tr><ti>gentoo</ti><ti>標準 gentoo 核心 (預設)</ti></tr>
<tr><ti>nofb</ti><ti>關閉 framebuffer 模式</ti></tr>
<tr><ti>smp</ti><ti>在 noframebuffer 模式內載入 smp 核心</ti></tr>
<tr><ti>acpi</ti><ti>開啟 acpi=on + 啟動時載入 acpi 模組</ti></tr>
<tr><ti>memtest</ti><ti>啟動時開始記憶體測試程式</ti></tr>
</table>

<table>
<tr><th>可利用的開機選項</th><th>說明</th></tr>
<tr><ti>doataraid</ti><ti>從 initrd載入 ide raid 模組</ti></tr>
<tr><ti>dofirewire</ti><ti>從 initrd 載入 firewire 模組(適用於 firewire 光碟機, 等等.)</ti></tr>
<tr><ti>dokeymap</ti><ti>啟用 non-us 鍵盤 陳列</ti></tr>
<tr><ti>dopcmcia</ti><ti>開始 pcmcia 服務</ti></tr>
<tr><ti>doscsi</ti><ti>偵測 scsi 裝置 (破壞某些網路卡)</ti></tr>
<tr><ti>noapm</ti><ti>關閉 apm 模組</ti></tr>
<tr><ti>nodetect</ti><ti>防止 hwsetup/kudzu 和 hotplug 執行</ti></tr>
<tr><ti>nodhcp</ti><ti>將 dhcp 偵測關閉</ti></tr>
<tr><ti>nohotplug</ti><ti>關閉 hotplug 服務</ti></tr>
<tr><ti>noraid</ti><ti>停止載入 evms 模組</ti></tr>
<tr><ti>nousb</ti><ti>從 initrd 停止 usb 模組, 停止 hotplug</ti></tr>
<tr><ti>ide=nodma</ti><ti>強制停止無法使用的 ide 裝置的 dma</ti></tr>
<tr><ti>cdcache</ti><ti>
緩衝貯存光碟裡面的資料到記憶體裡面. 這將會使用 40mb 的記憶體, 但是允許你在安裝過程中從 <path>/mnt/cdrom</path>掛載其他的光碟
</ti></tr>
</table>

<p>
當你按下 Enter 時, 你將會看到一個更漂亮的開機銀幕和進度槓.
</p>

<!--
	<figure link="/images/install/livecd-1.4-boot.png" caption="The Gentoo
	Linux Live CD booting" />
-->

<p>
當開機程序完成時, 你將會自動的登入為 "<c>root</c>", 最高權限使用者. 登入後, 你應該會看見 ("<c>#</c>"). 如果要更換密碼, 輸入 passwd 再依照銀幕上的指令進行即可. 你也可以使用 Alt-F2, Alt-F3 和 Alt-F4 切換成其他操作介面(console). 回到原來的螢幕可以按下 Alt-F1.
</p>

<!--

	<figure link="/images/install/livecd-1.4-con.png" caption="The Gentoo
	Linux Live CD console" />
-->

<note>
<b>進階使用者:</b> 當 LiveCD 啟動時, LiveCD 預設的 root 密碼是隨機設定的(安全起見). 如果你計畫啟用 <c>sshd</c> 進行網路安裝, 你將需要輸入 <c>passwd</c> 自行設定密碼. 不然你將無法登入並且進行安裝.
</note>

<p>
你應該也注意到 # 上方有一些說明文字, 這些文字將告訴你如何設定你的網路和告訴你光碟裡面的 Gentoo Linux Stage 壓縮檔和套件.
</p>

</body>
</section>
</chapter>

<chapter>
<title>選擇性硬體設定</title>
<section>
<body>

<p>
當 LiveCD 啟動時, 它會嘗試自動偵測你的硬體和載入你所需要的核心模組. 在大部分的例子來說, 它做的非常好. 但是, 在其他例子來說, 它有時無法自動的載入正確的核心模組. 如果 PCI 自動偵測(auto-detection) 錯過了系統上的硬你, 你將需要手動載入.
輸入: <c>ls /lib/modules/`uname -r`/kernel/drivers/net/*</c> 查看可以載入的核心模組. 載入某個模組, 輸入:
</p>

<pre caption="PCI 模組 設定">
# <i>modprobe pcnet32</i>
<comment>(將 pcnet32 該改為你的網路卡所需要的模組)</comment>
</pre>

<p>
如果你需要使用到任何未被偵測到的 SCSI 硬體, 你將需要在 <path>/lib/modules</path> 尋找正確的模組, 同樣的載入方式使用 <c>modprobe</c>:
</p>

<pre caption="載入 SCSI 模組">
# <i>modprobe aic7xxx</i>
<comment>(將 aic7xxx 換成你的 SCSI 控制卡模組)</comment>
# <i>modprobe sd_mod</i>
<comment>(sd_mod 模組是支援 SCSI 的磁碟)</comment>
</pre>

<note>
SCSI 光碟機和磁碟通常已被編入核心內
</note>

<note>
<b>進階使用者:</b> Gentoo LiveCD 應該會自動開啟磁碟上的 DMA, 以便加強傳輸速度. 如果沒有, 請按照以下進行 <c>hdparm</c>:
<pre caption="設定 DMA">
<comment>更換 hdX 為你的硬碟裝置.</comment>
# hdparm -d 1 /dev/hdX <comment>啟用 DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(使用安全和有效率的方式啟用 DMA)</comment>
# hdparm -X66 /dev/hdX
<comment>(強制啟用 Ultra-DMA -- 危險 -- 有可能搞亂你的硬碟)</comment>
</pre>
</note>

			
</body>
</section>
</chapter>
<chapter>
<title>選擇性網路設定</title>
<section>
<title>或許系統已經自動設定好了?</title>
<body>

<p>
如果你的系統有插入一張網路卡, 很有可能你的網路設定已經自動完成了. 如果是這樣, 
你將可以使用一些光碟上的功能 例如:
<c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>,<c>wget</c>, <c>lynx</c> 等等...</p>
	  
<p>如果網路已經設定好了, 你可以使用 <c>/sbin/ifconfig</c>, 查看一些除了 lo 的網路裝置, 例如 eth0:
</p>

<pre caption="/sbin/ifconfig 查看安裝成功的網路卡">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800 
</pre>

<p>
你應該嘗試著 ping 你的網路公司的 DNS 伺服器 (可以在 <path>/etc/resov.conf</path>裡面找到) 或是你喜歡的網站, 這個動作只是為了要確認你的主機有連上網路, 和名稱伺服器設定無誤, 等等..
</p>

<pre caption="進一步的網路測試">
# <i>ping -c 3 www.yahoo.com</i>
</pre>

<p>
你的網路設定好了嗎? 如果是, 你可以跳過這段繼續下面的部分.
</p>

</body>
</section>
<section>
<title>PPPoE 設定</title>
<body>

<p>如果你是使用 PPPoE 連上網路, 任何 Gentoo 開機光碟已包含著此功能: <c>rp-pppoe</c>. 請使用 <c>adsl-setup</c> 程序幫你你設定連線. 你會被要求將你的網路卡連上 adsl 數據機, 和你的帳號,密碼, DNS 伺服器 IP, 和需不需要一個簡單的防火牆.
</p>
<pre caption="PPPoE 設定E">
# <c> adsl-setup </c>
# <c> adsl-start </c>
</pre>

<p>如果發生錯誤, 請在 <path>/etc/ppp/pap-secrets</path> 確認你的帳號及密碼. 或是<path>/etc/ppp/chap-secrets</path>, 確認你使用的網卡是否正確.
</p>

</body>
</section>

<section>
<title>自動網路設定</title>
<body>

<p>
如果系統沒有自動設定, 最簡單的方法就是使用 <c>net-setup</c> 模式.
</p>

<pre caption="網路設定程式">
# <c>net-setup eth0</c>
</pre>

<p>
當然, 如果你高興, 你也可以自行設定網路. 下面將教你如何手動設定.
</p>

</body>
</section>
<section>
<title>手動設定動態式IP(DHCP)</title>
<body>

<p>
設定動態IP(DHCP) 很簡單; 如果你的IP為固定式,請跳過以下移致固定IP設定.
</p>

<pre caption="DHCP 網路設定">
# <c>dhcpcd eth0</c>
</pre>

<note>
如果你的網路公司提供主機名稱(hostname), 你可以在eth0 前面加入 <c>-h 主機名稱</c>
</note>

<p>
如果你從 <i>dhcpConfig</i> 收到警告, 別緊張; 請往下移置網路測試的部分.
</p>

</body>
</section>
<section>
<title>自行設定固定式IP</title>
<body>

<p>
我們只需要設定到足夠我們下載原始檔, 和 localhost 介面. 以下列表為需要的資訊.
</p>

<table>
<tr><th>資訊</th><th>說明</th><th>範例值</th></tr>
<tr><ti>IP 位置</ti><ti>你將需要在你的網路卡上指定一個 IP</ti><ti>192.168.1.2</ti></tr>
<tr><ti>廣播位置(broadcast)</ti><ti>向這個網路的其他主機廣播你的IP位置</ti><ti>192.168.1.255</ti></tr>
<tr><ti>網路遮罩(netmask)</ti><ti>這個遮罩和 IP 位置使用同一個網路,以方便查看此 IP 位置是在哪個網路裡面. 這樣是為了辨認主機.</ti><ti>255.255.255.0</ti></tr>
<tr><ti>通訊閘(gateway)</ti><ti>電腦的 IP 位置將會將封包轉到本地網路以外的地方(大部分是網路連線共用)</ti><ti>192.168.1.1</ti></tr>
</table>

<p>
輸入以下指令, 並且將 $IFACE 換成你的網路卡裝置 (大部分為 <c>eth0</c>)
$IPNUM 為你的IP位置, $BCAST 為你個廣播位置, 最後, $NMASK 為網路遮罩. 關於 <c>route</c>, 更改 $GTWAY 為你的通訊閘.
</p>
<pre caption="固定式IP設定">
# <c>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</c>
# <c>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</c>
</pre>

<p>
接下來我們該建立 <path>/etc/resolv.conf</path> 方便我們尋找網路名稱(利用名子尋找 Web/FTP 站名, 取代IP地址). 你可以輸入<c>nano -w /etc/resolv.conf</c> 建立 <path>/etc/resolv.con</path>. <c>nano</c> 是一個小而好用的文字編輯器.
</p>

<p>
以下為 <path>/etc/resolv.conf</path> 的範例:
</p>

<pre caption="/etc/resolv.conf 範例">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>

<p>
將 <c>10.0.0.1</c> 和 <c>10.0.0.2</c> 取代為你的主DNS 和 附DNS伺服器的IP.
</p>

</body>
</section>

<section>
<title>Proxy Configuration</title>
<body>

<p>
如果你必須使用代理伺服器. 我們必須在開始下載前先匯出一些變數.
</p>

<pre caption="設定使用代理伺服器">
<comment> // HTTP 代理伺服器: </comment>
# <i>export http_proxy="http://machine.company.com:1234"</i>
<comment> // FTP 代理伺服器: </comment>
# <i>export ftp_proxy="ftp://machine.company.com"</i>
<comment> // RSYNC 代理伺服器: </comment>
# <i>export RSYNC_PROXY="rsync://machine.company.com"</i>
</pre>

</body>
</section>

<section>
<title>網路已設定完成</title>
<body>

<p>
到達這個步驟時, 網路應該已經設定完成了. 你可以使用內含的 <c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> 和 <c>wget</c> 連上網路.
</p>

</body>
</section>
</chapter>

<chapter>
<title>設定系統日期和時間</title>
<section>
<body>

<p>
現在我們必須設定系統和日期. 我們將會使用<c>date</c>.
</p>

<pre caption="設定系統日期">
# <c>date</c>
Thu Feb 27 09:04:42 CST 2003
<comment>(如果你的系統時間錯誤,請輸入以下指令)</comment>
# <c>date 022709042003</c>
<comment>(date 月,日,時,分,西元年)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>檔案系統, 硬碟分割和區塊裝置(Block Devices)</title>
<section>
<title>介紹區塊裝置</title>
<body>

<p>
在這個部分,我們將仔細地看看 Gentoo Linux 和大部分 Linux 的磁碟概念. 包括了, Linux 檔案系統, 硬碟分割和區塊裝置(Block Devices).
一旦你熟悉了硬碟的設定, 你將會被帶入設定分割區及檔案系統的部份
</p>

<p>
我將以介紹 "區塊裝置" 作為開始. 最有名的大概就是 Linux 中代表的第一個 IDE 磁碟:
</p>

<pre caption="/dev/hda, 代表著系統中的第一個 IDE 磁碟">
/dev/hda
</pre>

<p>
如果你的系統使用 SCSI 磁碟, 你的第一個磁碟將會是:
</p>

<pre caption="/dev/sda, 代表著系統中的第一個邏輯磁碟">
/dev/sda
</pre>

<p>
以上的區塊裝置代表著<e>連接</e>磁碟的介面.
你可以使用程式進行 IDE, SCSI 或是其他的磁碟處理. 這個程式將隨機讀取 512-byte 區塊設定進行簡單的磁碟儲存設定.
</p>

</body>
</section>
<section>
<title>硬碟分割和 fdisk</title>
<body>

<p>
在Linux底下,我們會用<c>mkfs</c> (或是 <c>mke2fs</c>, 還有
<c>mkreiserfs</c> 等等) 建立檔案系統.
</p>

<p>
當然, 你也可以使用整個硬碟來當一個分割區. 一個分割區代表著<i>整個</i>硬碟. 例: <c>/dev/hda</c> 或是 <c>/dev/sda</c>. 但是從未有人這樣做過.
大部分的 Linux 都是將分割區分割成小塊一點. 所設定的分割區 我們就叫他 "partitions". 你可以利用 <c>fdisk</c> 設定每個硬碟內有幾個分割區及大小
</p>

<p>
我們可以使用 <c>fdisk</c>來看硬碟的分割表. 所以我們需要提供區塊裝置給 fdisk: 
</p>

<note>
除了 fdisk <c>cfdisk</c>以外, 你也可以使用 <c>parted</c> 和 <c>partimage</c>進行分割. 我們建議使用 <c>fdisk</c> 因為他是 Unix/Linux 世界中有名的強大分割軟體.
</note>

<pre caption="使用 fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
or
</p>

<pre caption="在 /dev/sda 使用 fdisk ">
# <i>fdisk /dev/sda</i>
</pre>

<impo>
如果你的硬碟或是分割區有重要資料, 你 <e>不應該</e> 更改或是寫入磁碟列表, 不然這些資料將會消失
</impo>

<p>
當你進入 <c>fdisk</c> 時,你將會看到以下的畫面:
</p>

<pre caption="fdisk 畫面">
Command (m for help): 
</pre>

<p>
輸入 <c>p</c> 查看分割區列表:
</p>

<pre caption="分割區設定範例">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
這棵硬碟被分割為七個分割區（顯示為 "Linux") 也有一個 Swap (顯示為 "Linux swap")
</p>

<p>
每個分割區的名稱會出現在列表的最左邊, 從 <path>/dev/hda1</path> 到 <path>/dev/hda9</path>
在早期的時代, 分割軟體最多只能分割到4塊. 說實在的,有點限制. 因此, 新版的 fdisk
可以使用 <e>extension partitioning</e>. 一個延續的分割區(Extended partitioning)可以建立更多的分割區.
我們叫他 <e>logical</e>分割區. 因此才解決了4個分割區的限制.
</p>

<p>
<path>/dev/hda5</path> 或是以上的分割區, 我們稱它為 Logical 分割區.
號碼 1 到 4的分割區, 我們稱它為 Primary(基本) 或是 Extended(延續) 分割區. 
</p>

<p>
從以上範例來看, <path>/dev/hda1</path> 到 <path>/dev/hda3</path> 為基本分割區. <path>/dev/hda4</path> 為延續分割區,將包含著 <path>/dev/hda5</path> 到 <path>hda9</path> Logical 分割區的定義. 請注意不要<e>使用</e> <path>/dev/hda4</path> 作為儲存分割區. 所以我們可以說<i>可以作為檔案系統的分割區</i>只有 <c>hda1</c> 到 <c>hda3</c> 和 <c>hda5</c> 到 <c>hda9</c>
</p>

<p>
另外, 你是否發現了列表上有一個 "ld"? 他的意思為: "分割區種類"
當你建立了一個新的分割區, 你必須要確定你的種類社為 '83'. 83 代表著Linux 的檔案系統. 而 '82' 代表著 Linux swap 分割. 你可以使用 <c>fdisk</c> 裡面的 <c>t</c> 選項進行設定. Linux 核心(kernel) 將會在開機時自動發現這些分割區和 swap.
</p>

</body>
</section>

<section>
<title>使用 fdisk 設定分割區</title>
<body>

<p>
你是否對Linux 分割區的設定有所了解了呢? 現在我將一步一步地帶你設定分割區.
當我們完成後, 你的分割區將會看起來像以下列表:
</p>

<pre caption="完成分割後,你的分割區列表會看起來像這樣">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>
我們建議新手將硬碟分割成三部份. 第一個 (<path>/dev/hda1</path>) 將會被設定為分割區中的第一個. 我們用它來作為開機分割區 (Boot partition). 開機分割區的將儲存所有開機需要的檔案. -- GRUB 開機程式的資料 (如果你選擇使用GRUB) 和 Linux 核心. 使用開機分割區是為了確保開機檔案不被影響. 在正常的狀況下, 開機分割區將不會被掛載. 如果你使用的是 SCSI 系統, 你的開機分割區將會看起來像 <path>/dev/sda1</path>
</p> 

<p>
我們建議把開機分割區 (Boot patition) 放在磁碟的最前面. 雖然不是強制要求, 但是這是一個有用的老方法. 以前的 lilo 無法在超過 1024 的 cylinder 載入核心.
</p>

<p>
第二個分割區 (<path>/dev/hda2</path>) 是用來當 Swap 空間. 核心會在 RAM 不夠用時把 swap 當成虛構記憶體(Virtual Memory). 此分割需不必太大.. 大約512MB即可. 如果你使用的是 SCSI 系統, 你的分割區將會看起來像 <path>/dev/sda2</path>
</p>

<p>
第三個分割區 (<path>/dev/hda3</path>) 需要蠻大的空間. 或許你可以把剩下的空間全部給它. 這個分割區我們將叫他 "根(root)" 分割區. 我們將在此放入所有的系統檔案.和 Gentoo Linux. 如果你使用的是 SCSI 系統, 你的分割區將會看起來像 <path>/dev/sda3</path>
</p>

<p>
我們開始分割前,以下是一些關於分割區和檔案系統的技術性建議 .
</p>

<table>
<tr>
 <th>分割區</th>
 <th>大小</th>
 <th>類別</th>
 <th>範例裝置</th>
</tr>
<tr>
 <ti>開機分割區, 包含著核心及相關開機所需程式</ti>
 <ti>32 Megabytes</ti>
 <ti>建議使用 ext/3 (最簡單); 如果使用 ReiserFS, 你將需要加入 <c>-o notail</c>為參數. 如果你使用 ext3 或是 ReiserFS, 你一定要在分割區的大小加入日誌式的紀錄空間; 我們建議 64 Megabytes.</ti>
 <ti><path>/dev/hda1</path></ti>
</tr>
<tr>
 <ti>swap 分割區 (之前是不得大於128MB, 現在可以使用為 2GB)</ti>
 <ti>以大部分的例子來說, Swap 的大小通常為記憶體的一到兩倍.</ti>
 <ti>Linux swap</ti>
 <ti><path>/dev/hda2</path></ti>
</tr>
<tr>
 <ti>"根(root)"分割區, 包含著主要的檔案系統 (/usr, /home, 等等)</ti>
 <ti>&gt;=1.5 Gigabytes</ti>
 <ti>ReiserFS, 建議 ext3; 或是 ext2 </ti>
 <ti><path>/dev/hda3</path></ti>
</tr>
</table>

<p>
OK, 現在我們該來建立這些分割區了. 我們可以輸入 <c>fdisk /dev/hda</c> 或是
<c>fdisk /dev/sda</c> (依你的硬碟類型 IDE 或 SCSI ). 然後按下 <c>p</c> 查看你目前的分割區列表. 裡面有你想留住的的嗎? 如果有, 請 <b>馬上停止</b> 如果你繼續下去的話, <b>所有分割區裡面的資料將會不見</b>
</p>

<impo>這些步驟將會把硬碟上的資料<b>全部清除</b>. 如果你沒有重要資料的話,
<b>請再次確定你選擇對的硬碟</b>
</impo>

<p>
現在, 我要把們所有的分割區刪除. 你可以輸入 <c>d</c> 再按 Enter. 你將會被問要刪除那個分割區. 要刪除第一個分割區 <path>/dev/hda1</path>, 你將要輸入:
</p>

<pre caption="刪除某一分割區">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
這個分割去已被設定為刪除, 如果你按 <c>p</c> 他將不會出現在清單內. 但是請記住, 
這個分割區在你還沒儲存之前還是會存在. 如果你將分割區設定錯誤, 你可以馬上按 <c>q</c> 才可避免分割區不會被刪除.
</p>

<p>
現在, 假設你要刪除所有的分割區, 請重複輸入 <c>p</c> 列出分割區列表, 然後 <c>d</c> 加上你要刪除的分割區. 最後你的分割區將會看起來像這樣:
</p>

<pre caption="空的分割區列表">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
現在, 我們需要建立一個開機分割區(Boot partition). 輸入 <c>n</c> 建立一個新的分割區,然後按 <c>p</c> 告訴 fdisk 你要一個基本分割區. 接著按 <c>1</c> 建立我們第一個分割區. 當他問你 "cylinder"時, 請按 enter. 當他問你 "last cylinder"時 輸入 <c>+32M</c> 來建立一個 32M 的分割區.
請參考以下輸出:
</p>

<note>
日誌式檔案系統 (Journaled filesystems) 需要多餘的空間來放日誌資料. 預設的設定大概需要 33 Megabytes. 如果你為 <path>/boot</path> 使用日誌式檔案系統時, 你需要在他問你 "last cylinder" 時輸入 <c>+64M</c>
</note>

<pre caption="建立 boot 分割區">
Command (m for help): <i>n</i>
Command action
e   extended
p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
現在, 按 <c>p</c>, 就可以看到我們剛剛建立的分割區:
</p>

<pre caption="第一個分割區已建立">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
接下來, 我們需要建立 swap 分割區. 輸入 <c>n</c> 建立一個新的分割區. 然後 <c>p</c> 告訴 fdisk 你要一個基礎型(primary)的分割區. 以我們的例子 <path>/dev/hda3</path> 輸入 <c>2</c>. 當 fdisk 問起 "first cylinder"時, 按 enter. 之後,當 fdisk 問起 "last cylinder" 時 請輸入 <c>+512M</c>. 當步驟完成後, 請按 <c>t</c> 設定系統類型. 按 <c>2</c> 選擇我們剛才建立的分割區. 你將要輸入 <c>82</c> 告訴系統這是一個 swap 分割區. 當以上步驟完成後, 輸入 <c>p</c> 你的分割區列表將會看起來像這樣:
</p>

<pre caption="Swap 分割區以建立完成">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

<p>
最後讓我們來建立 "根"(root) 分割區. 輸入 <c>n</c> 建立一個新的分割.
然後輸入 <c>p</c> 告訴系統你要一個基礎型(primary)的分割. 接著輸入 <c>3</c>.
當 fdisk 問起 "first cylinder"時 請按 enter. 之後,當 fdisk 問起 "last cylinder" 時 你可以按 Enter 表示你要剩下的空間. 完成之後 輸入<c>p</c> 你的分割區列表應該會看起來像這樣:
</p>

<pre caption="&quot;根&quot;分割區以建立完成">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

<p>
最後, 我們需要設立一個開機旗標 然後寫到分割區列表. 我們需要把 <path>/dev/hda1</path> 設為開機用分割區. 輸入 <c>a</c> 然後輸入 <c>1</c>. 你將看到 <path>/dev/hda1</path> 旁邊有一個 <c>*</c>. 接下來, 我們要將之前做好的分割區寫入硬碟. 輸入 <c>w</c> 再按 Enter. 接下來你已經可以進行 Gentoo Linux 的安裝了.
</p>

<note>
如果 <c>fdisk</c> 或是 <c>cfdisk</c> 顯示需要重開, 請用光碟重新開機.
</note>

</body>
</section>

<section>
<title>建立檔案系統</title>
<body>

<p>
現在分割區已經完成了, 是時候在開機分割區和分割區根建立檔案系統方便於儲存資料.
我們也需要建立 swap 系統方便儲存 swap 資料.
</p>

<p>
Gentoo Linux 支援多種檔案系統, 每種都有他的強處及壞處. 目前我們支援 ext2, ext3, XFS, JFS 和 ReiserFS 系統.
</p>

<p>
ext2 是一個舊的 Linux 檔案系統, 沒有日誌功能. 啟用的時間通常需要很久. 目前有許多 <e>日誌型態</e>的檔案系統可以以更快的速度及更好的效率完成系統啟用和檢查.
</p>

<p>
ext3 為 ext2 的日誌版. 提供了 metadata 日誌系統 並且可以快速地使用日誌系統復原.
ext3 是個相當不錯並且可靠的檔案系統. 在大部分的情況下, 他都可以表現的很好.
唯一的壞處是, 他不使用 Tree 為內部設計 所以無法很有效率的處理過大的檔案.
但是他的參數卻設計的很好. 是個狠不錯的檔案系統.
</p>

<p>
ReiserFS 整體來說是個相當不錯的系統, 它處理小型檔案(少於4kb)時效能會比 ext2 和 ext3來的好. 他使用的是 B*-tree 為基礎的檔案系統. 另外也能很有效率地處理大型檔案.
核心版本 2.4.18+ 後, ReiserFS 是一個相當有值得推薦的系統, 從很少,到很多檔案. ReiserFS都可以處理的非常好. 開機分割區並不建議使用此檔案系統.
</p>

<p>
XFS 是一個 metadata 日誌系統. Gentoo Linux 也完全支援此項檔案系統.
你可以使用 <path>xfs-sources</path> 核心搭配 XFS. 如果你使用高速 SCSI
或是纖維的儲存裝置, 我們才推薦你使用 XFS. 如果沒有, 請使用其他檔案系統.
</p>  

<p>
JFS 是 IBM 發展的高效能日誌系統. 目前雖然已經可以算是個完成品, 關於他的穩地度並沒有太多的優點及缺點.
</p>

<p>
如果你想找一個最耐用的日誌型檔案系統, 請使用 ext3. 如果你想要使用大部分都不錯的高效能檔案系統(日誌型) 請使用 ReiserFS. Ext3 和 ReiserFS 都相當成熟, 並且推薦為一般使用.
</p>

<p>
基於以上的介紹, 我們將用以下的指令來建立檔案系統.
</p>

<pre caption="建立檔案系統 (範例)">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
我們將選用 ext3 為 <c>/dev/hda1</c> 開機分割區的檔案系統. 因為此檔案系統堅固並且大部分的開機程式都有支援. 我們會在 <c>/dev/hda2</c> 使用 <c>mkdswap</c> 建立 Swap 分割區. 對於根目錄, <c>/dev/hda3</c> 我們將使用 ReiserFS. 原因是因為他的建構強大並且穩定. 以下為建立那些檔案系統的指令:
</p>

<p>
在安裝過程中, 裡面有很多 <c>mkfs</c> 的指令.
</p>

<p>
我們將使用<c>mkswap</c>建立 swap:
</p>

<pre caption="建立 Swap">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
你也可以使用 <c>mke2fs</c> 建立 ext2 的檔案系統:
</p>

<pre caption="建立 ext2 檔案系統">
# <i>mke2fs /dev/hda1</i>
</pre>

<p>
如果你想使用穩定點的系統 建立 ext3 的指令為:
<c>mke2fs -j</c>:
</p>

<pre caption="建立 ext3 的檔案系統">
# <i>mke2fs -j /dev/hda3</i>
</pre>

<note>
你可以在以下的網址找到關於 Linux 2.4 的 ext3 系統.
<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
</note>

<p>
建立 ReiserFS 檔案系統, 使用: <c>mkreiserfs</c> 指令:
</p>

<pre caption="建立 ReiserFS 檔案系統">
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
建立 XFS 檔案系統, 使用 <c>mkfs.xfs</c> 指令:
</p>

<pre caption="建立 XFS 檔案系統">
# <i>mkfs.xfs /dev/hda3</i>
</pre>

<note>
使用 mkfs.xfs 時你需要加入一些參數 例: <c>mkfs.fs -d agcount=3 -l size=32m</c>
<c>-d agcount=3</c>代表著此參數將會減少配置群 (Allocation groups). XFS 會要最少一個配置群有 4GB. 舉例來說, 你有一個 20GB 的分割區, 最少的 agcount 是 5
<c>-l size=32m</c> 將會增加日誌大小到32MB 以增加效率.
</note>

<p>
建立 JFS 檔案系統, 使用 <c>mkfs.jfs</c> 指令:
</p>

<pre caption="建立 JFS 檔案系統">
# <i>mkfs.jfs /dev/hda3</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>掛載分割區</title>
<section>
<body>

<p>
現在, 我們將啟用 Swap 以便接下來的步驟所需.
</p>

<pre caption="啟動 swap">
# <i>swapon /dev/hda2</i>
</pre>

<p>
接下來, 我們需要建立 <path>/mnt/gentoo/boot</path> 的掛載點. 我們將會把分割好的硬碟掛在這目錄上. <path>/mnt/gentoo</path> 將會成為我們主要的檔案系統. 如果你要將 Gentoo Linux 裡面的 <path>/usr</path> 和 <path>/var</path> 使用自己的分割區. 我們將要多建立幾個目錄. 如 <path>/mnt/gentoo/usr</path> 和 <path>/mnt/gentoo/var</path> 等等.
</p>

<impo>
如果你的開機分割區 (Boot Partition, 用來儲存 Kernel及 開機檔案) 使用的是 ReiserFS, 請確定你掛時載加入 <c>-o notail</c> 的參數. 這樣一來 GRUB 才可以正常的安裝. 另外, 請確定 <path>/etc/fstab</path> 的掛載設定也有此參數 (ReiserFS 檔案系統專用). 如果你要使用 LILO, 那麼你就不需要 <c>-o notail</c> 的參數. 如果你不知道該怎麼做, 安全起見, 你可以放入 <c>-o notail</c>.
</impo>

<pre caption="建立掛載目錄">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<impo>
如果你在掛載分割區時(使用的是 ext2), 你可以嘗試以下指令: 
<c>mount /dev/hXX /mnt/gentoo -t ext2</c>
</impo>

</body>
</section>
</chapter>


<chapter>
<title>Stage 壓縮檔與 chroot</title>
<section>
<title>選擇一個你想安裝的 Stage 壓縮</title>
<body>

<p>
現在, 你需要決定要用哪一個 Stage 的壓縮檔. 這些 Stage 的壓縮檔都會在 LiveCD 裡面的 <path>/mnt/cdrom/stages/</path> 你可以輸入 <c>ls /mnt/cdrom/stages/</c> 查看.
</p>

<p>
<b>GRP 使用者</b> 需要使用 <path>stage3-xx-yy.tar.bz2</path> 壓縮檔.
</p>

<p>
如果你想使用的 Stage 壓縮檔<e>不在</e> 你的 CD 裡面 (或許你使用的是 "basic" Live CD"), 你將需要按照以下步驟下載你想要的 Stage 壓縮檔. 然後再到 "解開壓縮檔的部分".
</p>

<pre caption="下載你要的壓縮檔">
# <i>cd /mnt/gentoo</i>
# <i>lynx http://gentoo.oregonstate.edu/releases/x86/1.4/</i>
<comment>使用 lynx 下載你所要的 Stage 壓縮檔:</comment>
<comment>使用 <c>上</c> 或 <c>下</c> 方向鍵 (或是 <c>TAB</c> )
尋找你想下載的 Stage 壓縮檔	
按 <c>d</c> 就可以開始下載
儲存檔案,然後離開 lynx.
<b>另一個方法</b> 使用 wget:
</comment>
# <i>wget </i><comment>(Stage 壓縮檔的網址 URL)</comment>
</pre>

</body>
</section>
<section>
<title>解開壓縮檔</title>
<body>

<p>
現在我們需要將 Stage 壓縮檔解開到 <path>/mnt/gentoo</path>. 記住! 你只需要解開<b>一個</b> Stage 壓縮檔. 如果你想要使用最簡單的 Stage 3, 你只需要解開 Starge3 的壓縮檔. 依照下面指令解開壓縮檔:
</p>

<impo>
記得要在 <c>tar</c> 的參數內加入 <c>p</c>. 如果沒有加入 <c>p</c> 會導致權限錯誤.
</impo>

<pre caption="解開 Stage 壓縮檔">
# <i>cd /mnt/gentoo</i>
<comment>請依照你所想要安裝的 Stage 將 "stage3" 換成 "stage2" 或是 "stage1"</comment>
<comment>請把你要的 Stage 壓縮檔放到 "/mnt/gentoo/" 而不是 "/mnt/cdrom/stages/".</comment>
# <i>tar -xvjpf /mnt/cdrom/stages/stage3-*.tar.bz2</i>
</pre>

<p>
當你解開壓縮後, 可以把 Stage 壓縮檔刪除了. 請輸入: <c>rm /mnt/gentoo/stage*.tar.bz2</c>.
</p>

</body>
</section>

<section>
<title>GRP 套件/snapshot 步驟</title>
<body>

<impo>
以下步驟只適合 GRP 使用者
</impo>

<p>
<b>GRP 使用者:</b> Livd CD 裡面有一份 Portage 快照. 你將需要使用這個份 Portage 你跳過下面的 <c>emerge sync</c> 步驟. 因為 <c>emerge sync</c> 需要網路連接, 請按照以下解開光碟裡面的 Portage:
</p>

<pre caption="使用光碟裡的 Portage">
<comment>將 yyyymmdd 更改為檔名裡面的日期</comment>
# <i>tar -xvjf /mnt/cdrom/snapshots/portage-yyyymmdd.tar.bz2 -C /mnt/gentoo/usr</i>
</pre>

<p>
以上步驟將會將光碟裡面的 Portage 目錄複製到你的 Gentoo 安裝裡面. 現在你將不需要連到網路使用 <c>emerge sync</c>. 現在我們要將 distfiles 和套件複製到光碟上.
</p>

<pre caption="複製 GRP 檔案">
# <i>cp -R /mnt/cdrom/distfiles /mnt/gentoo/usr/portage/distfiles</i>
# <i>cp -a /mnt/cdrom/packages/ /mnt/gentoo/usr/portage/packages/</i>
</pre>

<p>
所有需要的檔案現在都會複製到硬碟裡, 現在你可以不用網路連線進行 Gentoo Linux 安裝.
</p>

</body>
</section>

<section>
<title>選擇對映站 (非必要)</title>
<body>

<p>
<c>mirroselect</c> 是一個設計來幫你自動/手動選擇最快的對映站軟體. 缺點是, <c>mirrorselect</c> 在防火牆/分享器後面無法正常作用.
</p>

<pre caption="使用 mirrorselect">
<comment>自動尋找對映站:</comment>
# <i>mirrorselect -a -s4 -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
<comment>手動尋找對映站:</comment>
# <i>mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
如果 <c>mirrorselect</c> 無法正常使用, 你還是可以繼續安裝.
</p>

</body>
</section>
<section>
<title>進入 chroot 環境</title>
<body>

<p>
接下來我們將使用 <c>chroot</c> "進入"新的 Gentoo Linux 建造環境.
</p>

<note>
你應該會在 <c>env-update</c> 時收到系統告知 <path>/etc/make.profile/make.defaults</path> 不存在: 請略過它. 晚點我們將會使用 <c>emerge sync</c> 解決此問題.
</note>

<pre caption="準備和進入 chroot 環境">
# <i>mount -t proc proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
Regenerating /etc/ld.so.cache...
# <i>source /etc/profile</i>
<comment>以上步驟將會將你的 shell 帶到新的路徑和更新二進位檔案(binaries)</comment>
</pre>

<p>
當你執行以上檔案時, 你將會被"帶入" 新的 Gentoo Linux 環境 (<path>/mnt/gentoo</path>). 我們可以在 chroot 裡面繼續剩下的安裝環境.
</p>

</body>
</section>
</chapter>

<chapter>
<title>使用 sync 更新 Portage tree</title>
<section>
<body>

<impo>
如果你正在使用 GRP 安裝, 你可以略過 <c>emerge sync</c> 的步驟.
</impo>

<p>
現在, 輸入 <c>emerge sync</c>. 這個指令是告訴 Portage 下載目前最新的 Gentoo Linux Portage tree. 如果你的 Portage tree 是從 <e>CD 1</e> 複製的, 你可以安全地跳過這個步驟. Portage tree 包含著所有需要安裝的程式程序 (我們叫它 ebuilds). 目前我們有接近 4000 個程式包裝. 當你的 <c>emerge sync</c> 完成後, 最新的 Portage 安裝程序(Ebuilds) 就會放在 <path>/usr/portage</path>:
</p>

<pre caption="使用 sync 更新">
# <i>emerge sync</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>設定 Gentoo 自訂參數 (make.conf)</title>
<section>
<body>

<p>
現在你已經擁有了一份完善的 Portage tree, 我們需要自訂編譯的參數到你的 Gentoo Linux 系統上. Portage 將會使用這些參數進行編譯. 你將需要編輯 <path>/etc/make.conf</path>. 在這個檔案裡, 你將要設定你的 USE 參數, 此項參數將告訴系統你想要編譯哪些套件. 預設的參數是<e>空的</e>,所以你必須設定以使系統達到最好的效率.
你可以到<uri link="http://www.gentoo.org/doc/tw/use-howto.xml">查看USE的教學</uri> 或是 <uri link="http://www.gentoo.org/dyn/use-index.xml">查看 USE 的參數</uri>.
</p>

<p>
如果你打算從 Stage1 開始, 你應該要設定 CHOST, CFLAGS 和 CXXFLAGS 以便再編譯時告知系統資訊. (檔案內會有註解幫助你設定). 如果你打算從 Stage2 或是 Stage3 開始, 這些設定已經預設了, 你將不需要更改那些參數.
</p>

<impo>
<b>進階使用者:</b> CFLAGS 和 CXXFLAGS 設定是告訴 C 和 C++ 編譯器如何編譯最適合你系統的軟體. 正常來說, Athlon XP 的處理器將會設定為 "-march=athlon-xp" 到 CFLAGS 和 CXXFLAGS 裡面. 使用這項編譯方式的軟體將達到最佳效能. <path>/etc/make.conf</path> 裡面的註解將交你如何設定 CFLAGS 和 CXXFLAGS.
</impo>

<!-- needs qa
<note>
<b>Advanced users:</b>If you are building from a stage1 and don't want
to manually configure CFLAGS and CXXFLAGS, you can use the <c>genflags</c>
utility, which will try to guess accurate flags for your CPU architecture.
Simply type <c>emerge -O genflags</c> and then execute
<c>info2flags</c>. <c>info2flags</c> will suggest CHOST, CFLAGS and
CXXFLAGS settings, which you can then add to
<path>/etc/make.conf</path>.
</note>
-->

<p>
	如果需要, 你也可以把代理伺服器的資料放進去. 你可以使用 <c>nano</c> 編輯 <path>/etc/make.conf</path>:
</p>

<pre caption="設定 make.conf 選項">
# <i>nano -w /etc/make.conf</i>
</pre>

<note>
<b>進階使用者:</b> 需要完全自訂的使用者可以看一下 <path>/etc/make.globals</path>. 這個檔案為 Gentoo 的預設, 但是請不要修改它. 如果預設無法滿足你, 你可以將需要新增的選項放入 <path>/etc/make.conf</path>., <path>make.conf</path> 裡面的選項將會蓋過 <path>make.globals</path>. 如果你想要自訂 USE 設定, 看一下 <path>/etc/make.profile/make.defaults</path>. 如果你想要關掉這邊任何的 USE 參數, 你可以在 <path>/etc/make.conf</path> 加入 <c>USE="-foo"</c> 關閉在 <path>/etc/make.globals</path> 或是 <path>/etc/make.profile/make.defaults</path> 預設的 <c>foo</c>.
</note>

<warn>
如果你不是從 Stage1 開始, 請確認在 USE 參數裡面沒有 '<c>static</c>' 的參數.
</warn>

</body>
</section>
</chapter>

<chapter>
<title>從 Stage1 開始安裝</title>
<section>
<body>

<note>
你果你不打算從 Stage1開始, 請跳過這個部份.
</note>

<p>
Stage1 可以讓你完全依自己的需要自訂系統設定. 如果你選擇這個壓縮檔, 你應該想要一個完全為自己需要的系統吧.請慢慢享受, 雖然這個階段將用掉你很多時間. 但是可以完全達到你對系統的需求標準.
</p>

<p>
現在該開始我們的 "bootstrap" 階段. 作者使用的是 1200Mhz AMD Athlon系統 大約將花費 2 兩個小時. 在此階段我們將編譯, GNU C 編譯器和其他重要的系統程式. 請跟著以下步驟進行:
</p>

<pre caption="Bootstrapping">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>

<p>
Bootstrap 將開始進行編譯.
</p>

<note>
<c>bootstrp.sh</c> 現在支援 <c>--fetchonly</c> 選項. 使用撥街的使用者應該會蠻喜歡這個想巷的.
它將會下載全部的 bootstrap 所需要的檔案, 以便後時編譯所需. 請查看 <c>bootstrap.sh -h</c> 關於更多說明.
</note>

<note>
Portage 預設編譯目錄為 <path>/var/tmp</path>, 所以編譯中的檔案都會放在那邊(常常會佔用幾百 megabytes 硬碟空間). 如果你想要把編譯目錄改到別的路徑, 你可以在 <e>bootstrap</e> 開始前更改 PORTAGE_TMPDIR. 如以下步驟:
<pre caption="更改 Portage 的儲存路徑">
# <i>export PORTAGE_TMPDIR="/otherdir/tmp"</i>
</pre>
</note>

<p>
<c>bootstrap.sh</c> 將會把 <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,和 <c>glibc</c>, 重新編譯 而 <c>glibc</c>.需要長一點的時間.當你以上程序完成後你就會到達第二階段 (Stage 2)
</p>

</body>
</section>
</chapter>

<chapter>
<title>從 Stage2 開始, 或是繼續 Stage 1 的步驟</title>
<section>
<body>

<note>
這個階段是開始第二階段.或是繼續第一階段. 如果你選擇從 Stage3 開始, 請跳過這裡.
</note>

<warn>
如果你是從 Stage2 進行安裝, 記住不要更改 <path>/etc/make.conf</path> 裡面的 CHOST 參數. 不然會造成系統或是編譯上的錯誤.
</warn>
		
<p>
Stage2 壓縮檔已經幫你完成了 Bootstrapping(Stage1) 的動作. 接下來你所需要做的就是安裝剩下系統:
</p>

<note>
如果你是從已經編譯好的 Stage2 開始, 請確定你的編譯器有更新. 在指令後面加上 <c>-u</c> 的選項將會更新系統軟體. 如果你不明白這是什麼意思, 你可以選擇略過下面步驟.
</note>

<pre caption="安裝其餘的系統檔案">
# <i>emerge -p system</i>
<comment>(使用 -p 將會顯示出有那些程式會被編譯)</comment>
# <i>emerge system</i>
</pre>

<p>
編譯系統需要一段時間, 筆者建議你去玩 PS2 的 "Star Wars - Super Bombad Racing"
</p>

<p>
當完成編譯時, 請跳過以下步驟, 從 "設定時區" 繼續.
</p>

</body>
</section>
</chapter>


<chapter>
<title>從 Stage3 開始</title>
<section>
<body>

<note>
這個步驟適合<b>從 Stage3 開始</b>的使用者, 而不是 Stage1 或是 Stage2. GPR 使用者也應該跳過這個步驟.
</note>

<warn>
記住, 如果你從 stage3 開始, 不要更改 <path>/etc/make.conf</path> 裡面的 CHOST 參數. 不然可能造成編譯錯誤.
</warn>

<p>
Stage3 壓縮檔將提供一個完全的 Gentoo 基礎系統, 所以不需要任何編譯動作.
</p>
	 
<note>
	<b>進階使用者:</b> Stage3 的壓縮檔是已編譯好的, 它也有可能已經過時了. 如果你想要更新到最新的軟體, 請輸入 <c>export CONFIG_PROTECT="-* /etc/make.conf" emerge -u system</c> (需要網路連線). 如果你的 Stage3 壓縮檔已經很老了, 更新時間有可能會長一點. 在任何情況下, 你可以跳過這裡, 繼續下一個步驟.
</note>
		
</body>
</section>
</chapter>


<chapter>
<title>設定時區</title>
<section>
<body>

<p>
現在我們需要設定你的時間區域.
</p>

<p>
查看一下你的時間區域 (如果你是用 GMT 請用 GMT), 從 <path>/usr/share/zoneinfo</path>.然後作個連接到 <path>/etc/localtime</path> 請輸入:
</p>

<pre caption="建立時間區域連接">
# <c>ln -sf /usr/share/zoneinfo/選擇/你的/區域檔案 /etc/localtime</c>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>設定 /etc/fstab</title>
<section>
<body>

<impo>
編輯檔案, 請記得使用 <c>nano -w "檔案"</c>.
</impo>

<p>
你的 Gentoo Linux 系統已經快完成了! 現在我們需要為開機設定給個檔案. 首先我們將需要更改你的 <path>/etc/fstab</path> 如果你是用 ReiserFS 你將要在選項的部份加入 <c>notail</c>. 記得要在檔案系統類型(filesystem types)中 更改成你的檔案系統. 如: <c>ext2</c>, <c>ext3</c>, <c>reiserfs</c> 等等.
如果要更仔細的看 <path>/etc/fstab</path> 你可以使用: <c>man fstab</c>
</p>

<p>
請按照以下範例編輯你的 <path>/etc/fstab</path>, 但是要確保將 "BOOT", "ROOT" 和 "SWAP" 更改為你的區塊裝置 (如 <c>hda</c>, 等等.):
</p>

<pre caption="編輯 fstab">
<comment># /etc/fstab: static file system information.
#
# noatime turns off atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It is safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>

<warn>
請注意 <path>/boot</path> <e>不會</e> 在啟動時自動掛載. 這是為了要保護 <path>/boot</path> 裡面的資料. 如果你需要使用到 <path>/boot</path>, 請自行掛載!
</warn>

</body>
</section>
</chapter>


<chapter>
<title>安裝Linux 核心(kernel) 和系統記錄器</title>
<section>
<title>核心選擇</title>
<body>
	
<p>
有兩種安裝核心的方式(Kernel). 你可以自己編譯, 或是使用 <c>genkernel</c> 工具自動幫你編譯核心.
</p>
	
<p>
不管你要自己編譯核心, 還是使用 <c>genkernel</c>, 你都需要安裝你想要的核心. Gentoo 提供多種核心 ebuild; 你可以到<uri link="/doc/en/gentoo-kernel.xml">這裡</uri>. 如果你不確定要使用哪種核心, 我們建議你使用 <c>gentoo-sources</c>. 如果你需要 XFS 支援, 你應該選擇 <c>xfs-sources</c> 或是 <c>gs-sources</c>. Gentoo 的 LiveCD 使用的是 <c>gs-sources</c> 和 <c>xfs-sources</c>.此外還有 <c>gaming-sources</c> 此核心是特別為了遊戲軟體所打造的(啟用 "Preemptible Kernel" 選項).
</p>

<p>
選擇一個核心, 然後按照以下安裝:
</p>

<pre caption="安裝核心">
# <i>emerge -k sys-kernel/gentoo-sources</i>
</pre>

<p>
<path>/usr/src/linux</path> 只是一個連接到你新裝的核心路徑. 任何你編譯的核心模組將會被 Portage 透過 <path>/usr/src/linux</path> 來安裝一個適合此核心的模組. <path>/usr/src/linux</path> 只會再你第一次安裝核心套件時建立, 如果它已經存在, Portage 不會更改這個連接.
</p>

</body>
</section>
<section>
<title>使用 genkernel 編譯你的核心</title>
<body>

<p>
現在你的核心原始檔已經安裝完成了, 接下來我們需要編譯你的核心. 編譯核心有兩個方法. 第一個是使用我們新的 <c>genkernel</c> 程式自動為你編譯核心. <c>genkernel</c> 使用的方式就跟我們的 LiveCD 核心差不多. 這代表著當你使用 <c>genkernel</c> 編譯核心時, 你的系統會在開機時自動偵測你的硬體, 就跟我們的 LiveCD 一樣. 因為 <c>genkernel</c> 不需要任何手動核心設定, 這是一個對於不習慣自己編譯核心的使用著的理想工具.
</p>

<p>
接著, 讓我們來看看如何使用 genkernel. 首先, 安裝 genkernel:
</p>

<pre caption="安裝 genkernel">
# <i>emerge -k genkernel</i>
</pre>
		
<p>
現在, 執行 <c>genkernel</c> 編譯你的系統核心.
</p>

<note>
<b>進階使用者:</b> 你可以輸入 <c>genkernel --config</c> 進行編譯前的調整.
</note>

<pre caption="執行 genkernel">
<comment>如果你正在使用 genkernel 1.2 (包含在 1.4-20030803 x86/i686 GPR套件) 請輸入:
</comment>
# <i>genkernel gentoo-sources</i>
<comment>如果你使用的是 genkernel 1.4 或更新, 你將不需要指定核心:
</comment>
# <i>genkernel</i>
Gentoo Linux genkernel, version 1.4
Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
Distributed under the GNU General Public License version 2

Settings:
compile optimization: 1 processor(s)
source tree: /usr/src/linux-2.4.20-gaming-r3
config: gentoo (customized)
config loc: /etc/kernels/config-2.4.20-gaming-r3
initrd config: (default) /etc/kernels/settings

* Running "make oldconfig"...                                                                     [ ok ]
* Logging to /var/log/genkernel.log...                                                            [ ok ]
* Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
* Running "make dep"...                                                                           [ ok ]
* Running "make bzImage"...                                                                       [ ok ]
* Running "make modules"...                                                                       [ ok ]
* Running "make modules_install"...                                                               [ ok ]
* Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
* Building busybox...                                                                             [ ok ]
* Creating initrd...                                                                              [ ok ]

* Build completed successfully!

* Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
* when customizing your boot loader configuration files.
</pre>

<p>
當 <c>genkernel</c> 完成時, 一個核心, 完整的模組 和 <e>可開機的根磁碟</e> (initrd) 將會被建立. 我們將在等一下設定開機程式時使用到核心和 initrd. initrd 在開機偵測硬體的動作後就會被自動啟用. (就和我們的 LiveCD 一樣)
</p>

<p>
現在, 我們只要在進行一個步驟, 就能讓我們的系統更像 LiveCD 了. 安裝 <c>hotplug</c>. 當 initrd 自動偵測到硬體時, <c>hotplug</c> 會自動偵測其他東西. 安裝及啟用 <c>hotplug</c> 請輸入:
</p>

<pre caption="安裝及啟用 hotplug">
# <i>emerge -k hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

<p>
現在你已經執行也編譯了 <c>genkernel</c>, 你可以跳過下面的自行核心設定的步驟了.
</p>

</body>
</section>
<section>
<title>自行核心設定</title>
<body>

<p>
如果你選擇不要使用 genkenrel 編譯你的核心, 這個步驟將引導你手動設定以及編譯核心.
請注意 <path>/usr/src/linux</path> 只是一個連接(symlink) 到你目前所安裝的系統核心原始檔(安裝時已經由 Portage 建立). 如果你有多個核心原始檔, 請確定你的 <path>/usr/src/linix</path> 有指定到確定的路徑.
</p>

<warn>
當你在設定自己的核心時, 請注意 <i>grsecurity</i> 這個選項. 太過於小心將會妨礙一些程式運作 (如 X). 如果你不確定該怎麼做, 請不要設定它.
</warn>

<note>
如果你想要使用和 LiveCD 一樣的設定, 你應該執行 <c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c>.
如果你不是使用 <c>xfs-sources</c>, 系統將會問你一些關於你所選的核心和 <c>xfs-sources</c>之間不同的問題. 
</note>

<pre caption="設定 Linux 核心">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<warn>
為了要確保你編譯的核心無誤, 你必須要確定以下提供的建議<i>有內建(而不是使用模組的方式)到</i> 核心裡面. 如果你有 ReiserFS 分割區; 或是 &quot;Ext3&quot;, 請確定有編入核心, 而不是編成模組. 如果你有 XFS 的分割區, 請確認你有加入 &quot;SGI XFS filesystem support&quot;. 另外, 不論你是否使用 ext2, 請把 ext2 設為內建.
</warn>

<p>
下面是一些編譯核心時需要的選項:
</p>

<pre caption="make menuconfig 選項">
Code maturity level options ---&gt;
[*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(你將需要這個以便啟用其他功能)</comment>
...

檔案系統 ---&gt;
&lt;*&gt; Reiserfs support
<comment>(如果你有用到 ReiserFS)</comment>
... 
&lt;*&gt; Ext3 journalling file system support
<comment>(如果你有用到 ext3.)</comment>
...
[*] Virtual memory file system support (former shm fs)
<comment>(Gentoo Linux 必須選用此項.)</comment>
...
&lt;*&gt; JFS filesystem support
<comment>(如果你有用到g JFS.)</comment>
...
[*] /proc file system support
<comment>(Gentoo Linux 必須選用此項.)</comment>
[*] /dev file system support (EXPERIMENTAL)
[*]   Automatically mount at boot          
<comment>(Gentoo Linux 必須選用此項.)</comment>
[ ] /dev/pts file system for Unix98 PTYs
<comment>(不需要.)</comment>
...
&lt;*&gt; Second extended fs support
<comment>(如果你有用到 ext2.)</comment>
...
&lt;*&gt; XFS filesystem support
<comment>(如果你有用到 XFS.)</comment>
</pre>

<p>
如果你是使用 PPPoE 連上網路, 你將需要以下核心選項(以內建或是模組) &quot;PPP (point-to-point protocol) support&quot;, &quot;PPP support for async serial ports&quot;, &quot;PPP support for sync tty ports&quot;. 有兩個壓縮選項並不會傷害到而且不一定需要 &quot;PPP over Ethernet&quot; 這些都是 <c>rp-pppoe</c> 需要的功能.
</p>

<p>
如果你使用 IDE 燒錄機, 那你需要內建 SCSI emulation. 你需要勾選:&quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA and ATAPI Block devices&quot; ---&gt; &quot;SCSI emulation support&quot; (我把他們設為模組型態). 還有,在 &quot;SCSI support&quot; 底下, 勾選 &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; 和 &quot;SCSI generic support&quot; 如果你把以上那些設為模組, 你將要在編譯完成時輸入 <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot; &gt;&gt; /etc/modules.autoload</c>已便開機時自動啟動.
</p>

<p>
如果你需要, 不要忘記在核心內已編入的方式設定網路卡的支援.
</p>

<note>
給那些想要在 Gentoo Linux 使用核心 2.2 的使用者, 現在 Gentoo Linux 可以使用 2.2 版的核心. 但是, 這樣做是要付出代價的. 你將會損失很多功能, 包括 XFS, iptables 等等. 雖然 2.2版的核心可以利用補釘增加 ReiserFS 和 devfs 支援. Gentoo Linux 開機程序需要使用到核心內建的 tmpfs 或是 ramdisk. 所以 2.2 的使用者將要確定 ramdisk 有被內建(不能勾選為模組). 你<comment>一定要</comment> 在 <path>/boot/grub/grub.conf</path> 或是 <path>/etc/lilo.conf</path> 加入 <e>gentoo=notmpfs</e> 到裡面的 kernel 選項. 然後 2.2 版的核心就會使用 ramdisk 而略過 tmpfs. 如果你選擇不用 devfs, 那就加入 <e>gentoo=notmpfs,nodevfs</e>
</note>

<pre caption = "編譯及安裝 Linux 核心">
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
</pre>

</body>
</section>
<section>
<title>安裝其他硬體所需要的安裝程序</title>
<body>
<p>
最後, 你將需要安裝其他硬體所需要的軟體. 以下為你或許該需要安裝的:
</p>

<table>
<tr>
<th>安裝程式</th>
<th>用途</th>
<th>指令</th>
</tr>
<tr>
 <ti>nvidia-kernel</ti>
 <ti>加速 Nividia 對於 XFree86 的支援</ti>
 <ti><c>emerge -k nvidia-kernel</c></ti>
</tr>
<tr>
 <ti>nforce-net</ti>
 <ti>NIVIDIA NForce(2) 主機板上內建的網路卡</ti>
 <ti><c>emerge nforce-net</c></ti>
</tr>
<tr>
 <ti>nforce-audio</ti>
 <ti>NVIDIA NForce(2) 主機板上內建的音效卡</ti>
 <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
 <ti>e100</ti>
 <ti>Intel e100 Fast Ethernet 網路卡</ti>
 <ti><c>emerge e100</c></ti>
</tr>
<tr>
 <ti>e1000</ti>
 <ti>Intel e1000 Gigabit Ethernet 網路卡</ti>
 <ti><c>emerge e1000</c></ti>
</tr>
<tr>
 <ti>emu10k1</ti>
 <ti>Creative Sound Blaster Live!/Audigy 支援</ti>
 <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
 <ti>ati-drivers</ti>
 <ti>XFree86 Accelerated ATI Radeon 8500+/FireGL 支援</ti>
 <ti><c>emerge ati-drivers</c></ti>
</tr>
<tr>
 <ti>xfree-drm</ti>
 <ti>ATI Radeon up to 9200, Rage128, Matrox, Voodoo 和其他 XFree86 加速支援</ti>
 <ti><c>VIDEO_CARDS="yourcard" emerge xfree-drm</c></ti>
</tr>
</table>

<p>
<c>nvidia-kernel</c>, <c>ati-drivers</c> 和 <c>xfree-drm</c> 套件將需要啟動其他設定. 所有上面列表的其他安裝程序(ebuild)將會再開機十郵 <c>hotplug</c> 自動啟用.
</p>

<p>更多關於 <c>xfree-drm</c> 的資料可以到我們的. <uri link="/doc/en/dri-howto.xml">Direct Rendering Guide</uri>教學內找到.
</p>
</body>
</section>
<section>
<title>安裝系統紀錄器</title>
<body>

<p>
為電腦量身打造的核心出爐啦! 現在你將需要選一個系統紀錄器. 我們提供傳統的 sysklogd 還有 msyslog 和 syslog-ng. 玩家級的使用者都會選擇後面兩者. (因為sysklogd和後兩者比較起來效率沒那麼好). 而且後兩者提供目前受歡迎的 metalog. 以下將是教你安裝記錄器的步驟. 任選一即可:
</p>

<pre caption="安裝你喜歡的系統記錄器">
# <c>emerge app-admin/sysklogd</c>
# <c>rc-update add sysklogd default</c>
<comment>或是</comment>
# <c>emerge app-admin/syslog-ng</c>
# <c>rc-update add syslog-ng default</c>
<comment>或是</comment>
# <c>emerge app-admin/metalog</c>
# <c>rc-update add metalog default</c>
<comment>或是</comment>
# <c>emerge app-admin/msyslog</c>
# <c>rc-update add msyslog default</c>
</pre>

<impo>
Metalog 將會把紀錄以區塊(blocks)的方式塊輸出到硬碟上. 這樣的話,紀錄訊息才部會會馬上變成系統紀錄(system logs). 如果你正在除錯一個系統服務, 那麼metalog的方式將會變成不太適用.. 當你的 Gentoo Linux 系統安裝完成後, 你可以送出一個 URSR1 的訊息給 metalog. 這樣將會暫時性的關閉. 你可以使用 <c>tail -f <path>/var/log/everything/current</path></c> 除錯. USR2 將會啟動 metalog. 如果你要永久關閉此項緩衝區的功能, 你可以到 <path>/etc/conf.d/metalog</path> 把 METALOG_OPTS="-B" 改成 METALOG_OPTS="-B -s".
<pre caption="關閉/啟用 metalog 緩衝">
<codenote>關閉緩衝:</codenote>
# <i>killall -USR1 metalog</i>
<codenote>啟用緩衝:</codenote>
# <i>killall -USR2 metalog</i>
</pre>
</impo>

<p>
接下來你必須選擇一個 cron 程式. 目前我們提供 dcron, fcron 和 vcron. 如果你不知道該選那一個, 我們建議你使用 vcron. 請按照以下步驟安裝:
</p>

<pre caption="選擇一個 Cron 服務器">
# <c>emerge sys-apps/dcron</c>
# <c>rc-update add dcron default</c>
# <c>crontab /etc/crontab</c>
<comment>或是</comment>
# <c>emerge sys-apps/fcron</c>
# <c>rc-update add fcron default</c>
# <c>crontab /etc/crontab</c>
<comment>或是</comment>
# <c>emerge sys-apps/vcron</c>
# <c>rc-update add vcron default</c>
<comment>如果你使用 vcron 你不需要 <c>crontab /etc/crontab</c></comment>
</pre>

<p>
如果想多了解如何啟動系統服務和程式, 請到:
<uri link="/doc/en/rc-scripts.xml">rc-script 教學</uri>
</p>

</body>
</section>
</chapter>

<chapter>
<title>安裝其他必要的軟體</title>
<section>
<body>

<p>
如果你需要 rp-pppoe 連上網路, 現在是個不錯的安裝時刻.
</p>

<pre caption="安裝 rp-pppoe">
# <i>USE="-X" emerge rp-pppoe</i>
<comment>GRP 使用者應該輸入:</comment>
# <i>USE="-X bindist" emerge -K rp-pppoe</i>
</pre>

<note>
<i>USE="-X"</i> 會防止 pppoe 在 X 裝安裝介面. 使用 <i>"-X"</i> 是因為 X 相依性的問題, 就會連串的安裝更多的軟體. 如果你需要 X 支援, 你可以以後重編新編譯.
</note>

<note>
Please note that the rp-pppoe is built but not configured. You will have to 
do it again using <c>adsl-setup</c> when you boot into your Gentoo system 
for the first time.
請注意 rp-pppoe 已經編譯完成, 但是尚未設定. 重開機後你將需要再一次地執行 <c>adsl-setup</c> 才能完成設定.
</note>

<p>
如果你有使用 XFS, ReiserFS 或是 LVM, 你將需要從 Portage 裡面安裝相關軟體. 如果你使用 XFS, 你將需要安裝 <c>xfsprogs</c> 套件:
</p>

<pre caption="Emerge 檔案系統工具">
# <i>emerge -k sys-apps/xfsprogs</i>
<comment>如果你有 ReiserFS 檔案系統, 你將要安裝 ReiserFS 工具: </comment>
# <i>emerge -k sys-apps/reiserfsprogs</i>
<comment>如果你有 JFS 檔案系統, 你將要安裝 JFS 工具: </comment>
# <i>emerge -k jfsutils</i>
<comment>如果你有 LVM 系統, 你將要安裝 <c>lvm-user</c> 工具: </comment>
# <i>emerge -k sys-apps/lvm-user</i>
</pre>

<p>
如果你使用手提電腦, 需要在開機時用到 PCMCIA, 你將需要安裝 <i>pcmcia-cs</i>.
</p>

<pre caption="安裝 PCMCIA-cs">
# <i>emerge -k sys-apps/pcmcia-cs</i>
</pre>

<!-- fix the bug or fix the docs, don't send the user in circles
(drobbins)
		<warn>You will have to re-emerge <i>pcmcia-cs</i> after installation to get PCMCIA
			to work.
			</warn>
	-->

</body>
</section>
</chapter>

<chapter>
<title>帳號管理</title>
<section>
<title>設定最高權限密碼(Root)</title>
<body>

<p>
在你忘記之前, 請先設定密碼: 
</p>

<pre caption="設定 Root 的密碼">
# <c>passwd</c>
</pre>

</body>
</section>
<section>
<title>新增一個平常使用的帳號</title>
<body>

<p>
在 Unix/Linux 系統下使用 root 工作是一件非常 <e>危險</e> 以及應該避免的.
我們 <e>強力</e> 建議你建立一個平常使用的帳號:
</p>

<pre caption = "新增常用帳號">
# <i>useradd your_user -m -G users,wheel,audio -s /bin/bash</i>
# <i>passwd your_user</i>
</pre>

<p>
將 <c>your_user</c> 更改為你想要的帳號名稱.
</p>

<p>
當你需要執行一些只有 root 才可以執行的工作, 你可以使用 <c>su -</c> 更改你的權限, 或是查看 <c>sudo</c> 套件.
</p>

</body>
</section>
</chapter>

<chapter>
<title>設定主機名稱</title>
<section>
<body>

<p>
編輯 <path>/etc/hostname</path>, 在裡面輸入你的主機名稱.. 例: <c>mymachine</c>
</p>

<pre caption="設定主機名稱">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>

<p>
然後編輯 <path>/etc/dnsdomainname</path>, 在裡面輸入你的網域名稱. 例: <c>mydomain.com</c>.
</p>

<pre caption="設定網域名稱">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>

<p>
如果你有 NIS 網域, 你將要把他寫入 <path>/etc/nisdomainname</path>.
</p>

<pre caption="設定 NIS 網域名稱">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>設定 /etc/hosts</title>
<section>
<body>

<p>
這個檔案將會含著 主機需要使用到的 IP 位置 和主機名稱. 可以用來反解你的 nameserver 找不到的名稱(local使用). 以下為範例:
</p>

<pre caption="Hosts 範例">
127.0.0.1      localhost
<comment>#下一行包含著你的區網的IP 和相關的主機名稱</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>

<note>
如果你是使用 DHCP 網路, 在你的主機名稱後面加入 <i>localhost</i> 將會為 GNOME 和其他程式造成一些很大的幫助(反解名稱)
</note>

</body>
</section>
</chapter>


<chapter>
<title>最後網路設定</title>
<section>
<body>

<p>
你將需要在 <path>/etc/modules.autoload</path> 加入剛剛你編譯核心的模組. 這樣一來 Gentoo Linux 啟動時, 將會自動載入. 註: 如果你將網路卡編為模組, 如果沒有載入他, 他不會自動啟用.
</p>

<pre caption="/etc/modules.autoload">
<comment>假設你使用的是 3com 網路卡.
在 <path>/lib/modules/`uname -r`/kernel/drivers/net</path> 尋找你的網路卡 </comment>
3c59x
</pre>

<p>
編輯 <path>/etc/conf.d/net</path> 以便開機時啟動網路: 
</p>

<pre caption="開機網路設定">
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
如果你有多張網卡, 你將需要複製為 <path>net.eth<comment>x</comment></path> (<comment>x</comment> = 1, 2, ...) 請看以下範例:
</p>

<pre caption="多重網路介面">
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment></i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>

<p>
如果你使用的是 PCMCIA, 請查看 <path>/etc/init.d/pcmcia</path> 是否設定正確. 然後在最上面加入 <path>/etc/inid./net.ethx</path>.
</p>

<pre caption="讓 PCMCIA 依賴 /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
</pre>

<p>
這樣就可以在啟動網路時自動啟動 PCMCIA 網路卡的驅動程式.
</p>

</body>
</section>
</chapter>

<chapter>
<title>最後步驟: 設定基本選項 (包括國際鍵盤設定)</title>
<section>
<body>

<pre caption="基本設定">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
按照檔案裡面的引導, 將系統的基礎設定. 請確定 <c>CLOCK</c> 有設定過. 國際鍵盤的使用者將需要設定 <c>KEYMAP</c> (可以查閱<path>/usr/share/keymaps</path> 查看可用的選項).
</p>

</body>
</section>
</chapter>

<chapter>
<title>設定開機程式</title>
<section>
<title>註解</title>
<body>

<p>
Gentoo 的精神, 大家現在有多種的開機程式可以使用. 在我們的虛擬包裝系統裡, 使用者可以選擇 GRUB 或是 LILO.
</p>

<p>
請記住, 你只需要安裝一個開機程式, 請不要安裝超過一個.
</p>

<p>
另外, 如果你有使用 <c>genkernel</c> (核心及 initrd) 設定的方式將會與手動編譯不同. 請特別小心.
</p>

<impo>
如果你是使用 NVIDIA nForce 或是 nForce2 結合的 GeForce 顯示卡, 你應該要使用 LILO 而不是 GRUB. 原因是低階記憶(low memory)有可能會被使用成為 video RAM. GRUB 開機時使用的是低階記憶 所以有可能會造成記憶體不足的狀況. 如果你使用 nForce 或是其他內建顯示卡, 請使用 LILO.
</impo>

</body>
</section>
<section>
<title>設定 GRUB</title>
<body>

<p>
GRUB 中最重要的就是 GRUB 如何指向硬碟和分割區. 你的 Linux 分割區 <path>/dev/hda1</path> 在 GRUB 裡面會變成 <path>(hd0,0)</path> 注意 hd0,0 的括號,他們是不可缺的. 硬碟和分割區是從 0 開始計算的. 非 atapi-ide 的裝置 如CDROM, 燒錄機, SCSI 裝置等等 都是在 BIOS 設定時被設定為高一點的號碼. 舉例來說, 你的硬碟是在 /dev/hda, CDROM 是 /dev/hdb, 燒錄機是在 /dev/hdc, 第二個硬碟是在 /dev/hdd. 在 <path>/dev/hdd7</path> 將會被翻譯成 <path>(hd1,6)</path>看起來很複雜, 但是他的確很複雜. GRUB 有提供 Tab 的選項. 當你有很多硬碟和分割區時, 你可以按 Tab 鍵來列出所有的硬碟或分割區.
</p>

<p>
設定 GRUB 最簡單的方法就是輸入 <c>grub</c>
</p>

<pre caption="安裝 GRUB">
# <i>emerge -k grub</i>
# <i>grub</i>
</pre>

<p>
接下來你將會看到 <e>grub&gt;</e> 的介面. 你現在需要輸入正確的指令才可以將 GRUB 安裝到你的開機區裡面. 在我的範例設定裡面, 我想要將 GRUB 安裝到我硬碟的 MBR (master boot record), 所以第一個我開機時會看到的就是 GRUB 的開機畫面. 在我的例子來說, 我就需要輸入: 
</p>

<pre caption="在 MBR 上安裝 GRUB">
grub&gt; <i>root (hd0,0)</i> <comment>開機分割區(boot partition)</comment>
grub&gt; <i>setup (hd0)</i> <comment>安裝 MBR 的地方)</comment>
</pre>
	
<pre caption="GRUB not on the MBR">
<comment>如果你想要在 MBR 以外的地方安裝 GRUB</comment>
grub&gt; <i>root (hd0,0)</i> <comment>開機分割區(boot partition)</comment>
grub&gt; <i>setup (hd0,4)</i> <comment>在此設定開機紀錄,  (/dev/hda5)</comment>
grub&gt; <i>quit</i>
</pre>

<p>
接下來為以上兩個指令的解說. 第一個 <c>root ( )</c> 是告訴 GRUB 你的開機分割區的位址. (在我們的例子裡, <path>/dev/hda1</path> 或是 GRUB 適用的 <path>(hd0,0)</path>. 第二, <c>setup ( )</c> 是開機紀錄(boot record) 將會在你指定的地方設定特別的檔案. 在筆者的例子中, 我想把開機紀錄 放在硬碟的 MBR 上所以我將指定 <path>/dev/hda</path> (也是 GRUB 中的 <path>(hd0)</path>). 如果我是使用其他的開機程式(Boot Loader), 我將需要把 GRUB 設為第二開機程式. 我可以把 GRUB 安裝在其他的分割區上(而不是整個硬碟). 當 GRUB 以設定完成後, 你可以輸入 <c>quit</c> 離開 GRUB.
</p>

<note>
在 GRUB 裡, TAB 的是一個很方便的工具, 當你輸入 <c>root (</c> 然後按下 TAB 鍵, 你將會看到所有的分割區列表. 按下 TAB 後, 就會自動幫你改為 <c> root (hd</c>. 再按一次, grub 將列出可用硬碟就會變成 <c> root (hd0,</c> 然後你可以自己輸入或是按下 TAB 這樣就可以讓 grub 再次列出可以使用的分割區.
</note>
			
<p>
Gentoo Linux 現在已安裝完成, 但是我們需要建立 <path>/boot/grub/grub.conf</path> 檔才有辦法在重開機時顯示出漂亮的 GRUB 開機選項. 以下為範例:
</p>

<impo>
為了確保和 GRUB 的反面相容性 (backwards compatibility), 你要確定 <i>grub.conf</i> 有連接到 <i>menu.lst</i>. 你可以輸入以下指令建立連接: <c>ln -s /boot/grub.conf /boot/grub/menu.lst </c>
</impo>

<p>
現在我們將要建立 grub.conf 檔案 (<c>nano -w /boot/grub/grub.conf</c>). 然後按照以下方法加入:
</p>

<pre caption="GRUB 使用的 Grub.conf">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

<comment># 如果你是自己編譯核心, 請參考以下範例:</comment>
title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment># 如果你是使用 genkernel, 請參考以下範例:</comment>
title=My example Gentoo Linux (genkernel)
root (hd0,0)
kernel (hd0,0)/boot/kernel-KV root=/dev/hda3
initrd (hd0,0)/boot/initrd-KV

<comment># 以下為雙重開機的設定</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>

<p>
將 <c>KV</c> 更換成你安裝的核心版本
</p>

<note>
正確的 (hd0,0) 裡面不應該有任何空格.
</note>

<impo>
如果你要為 IDE 燒錄機設定 SCSI 虛擬, 你將在需要把 &quot;hdx=ide-scsi&quot; 加到 grub.conf 裡的 kernel 選項裡. (&quot;hdx&quot; 應該改為你的燒錄機位置).
</impo>

<p>
儲存這個檔案後, Gentoo Linux 已經安裝完成. 選擇第一個選項將會告訴 GRUB 啟動 Gentoo Linux. 這個步驟應該不會有太多的問題. <path>grub.conf</path> 裡面的第二個部分只是一個告訴你如何設定第二個選項的範例.
</p>

<note>
上面的 <path>(hd0,0)</path> 應該指向你的 "開機(boot partition)" 分割區 (以我們的範例來說, <path>/dev/hda1</path>). <path>(hd0,5)</path> 將會包含著 NT 開機程式.
</note>

<note>
核心映像(kernel image) 的路徑應該要和開機分割區一樣. 如果你有將開機分割區 <path>(hd0,0)</path> 和根分割區(root partition) <path>(hd0,1)</path> 分開的話, 在 <path>grub.conf</path> 裡面將會變成 <path>/bzImage</path>.
</note>

<p>
如果你需要對核心增加任何選項, 你只要在 <c>kernel</c> 後面的指令新增. 我們已經新增了一個選項 (<c>root=/dev/hda3</c>), 你也可以新增其他選項. 以一個特別的例子來說, 你可以在 <c>kernel</c> 後面加入 <c>gentoo=nodevfs</c> 這個選項來告訴核心關閉 devfs.
</p>

<note>
與早期的 Gentoo Linux 不一樣的是, 你不再需要在 <c>kernel</c> 後面加入 <c>devfs=mount</c> 的選項了. 現在 devfs 已經被設為自動啟用.
</note>

</body>
</section>
<section>
<title>設定 LILO</title>
<body>

<p>
目前 GRUB 是最新的選擇, 但是並不是一直都是最好的選擇. LILO (LinuxLOader) 是真正有實力的Linux 啟動程式.
</p>

<p>
以下是 LILO 的安裝方式:
</p>

<pre caption="安裝 LILO">
# <i>emerge -k lilo</i>
</pre>

<p>
接下來我們需要設定 <path>/etc/lilo.conf</path> 以下為設定範例:
</p>

<pre caption="lilo.conf 範例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

<comment># 如果你是自己編譯核心的使用者, 請使用與下面四行類似的設定
</comment>
image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3

<comment># 如果你使用 genkernel, 請參考以下範例:</comment>
image=/boot/kernel-KV
	label=gk_linux
	root=/dev/hda3
	initrd=/boot/initrd-KV
	append="root=/dev/ram0 init=/linuxrc"

	
<comment># 雙重開機, 或是其他 OS</comment>
other=/dev/hda1
	label=dos
</pre>

<p>
將 <c>KV</c> 更換成你安裝的核心版本
</p>

<ul>
<li><c>boot=/dev/hda</c> 將告訴 LILO 安裝到第一個 IDE 控制卡上的硬碟.</li>
<li><c>map=/boot/map</c> LILO 的地圖檔, 你不應該編輯此項.</li>
<li><c>install=/boot/boot.b</c>將告訴 LILO 安裝到新的開機區域(Sector) 在普通的情況下, 如果沒有 install 這行, LILO 將會預設使用這個檔案.</li>
<li><c>prompt</c> 將告訴 LILO 開機時顯示經典的 <e>lilo:</e> 雖然不建議你移除掉這個, 但是你還是可以再開機時按下 [Shift] 鍵取得.</li>
<li><c>timeout=50</c> 是設定 LILO 等待使用者選擇的時間,  如果設定為 50 就代表著等待時間為 5 秒.</li>
<li><c>lba32</c>是為 LILO 解釋硬碟的構造. 另一個常用的項目是 linear. 除非你真的很了解, 不然請不要改變這行. 不然可能會造成無法開機的狀態.</li>
<li><c>default=linux</c> 將告訴 LILO 這是一個預設開機的選項. 必須和以下的 label 所輸入的相同.</li>
<li><c>image=/boot/bzImage</c> 將告訴 LILO 開機時要選擇那一個核心. </li>
<li><c>label=linux</c> 當 LILO 啟動時, 這個選項將被用來放在清單內.如果你要將此設為預設, 一定要和上面的 default 相同.</li>
<li><c>read-only</c>將告訴 LILO 你個根分割區要設定成唯讀並且在開機中不會被被更改.</li>
<li><c>root=/dev/hda3</c>將告訴 LILO 開機時你的根目錄在那裡. </li>
</ul>

<p>
當你完成編輯 <path>lilo.conf</path>, 現在是把 LILO 放到 MBR 裡面了:
</p>

<pre caption="執行 LILO">
# <i>/sbin/lilo</i>
</pre>

<p>
LILO 已經設定好了, 現在你的電腦已經可以使用 Gentoo Linux 了!
</p>

</body>
</section>

<section>
<title>使用 framebuffer</title>
<body>

<p>
有在核心裡面加入 framebuffer 的使用者應該把 <c>vga=xxx</c> 加到開機程式的設定檔裡. <c>xxx</c> 代表著以下列表的一個號碼:
</p>

<table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>

<p>
LILO 的使用者將需要把 <c>vga=xxx</c> 放到設定檔的最上端.
</p>

<p>
GRUB 的使用者將需要把 <c>vga=xxx</c> 放到 <c>kernel (hd0,0)...</c> 後面.
</p>

</body>
</section>
</chapter>

<chapter>
<title>製作開機片</title>
<section>
<title>GRUB 開機片</title>
<body>

<impo>
不要忘了在開始前放入一片磁片.
</impo>

<p>
第一次安裝任何 Linux 時, 製作一個開機片是一個不錯的主意.這是為了在錯誤發生時方便你修正. 如果你是使用硬體 RAID, 你將 <e>需要</e> 建立一個 GRUB 開機片. 面對相當多種類的硬體 RAID,  你將無法在 chroot 裡面製作 GRUB 開機片,如果你碰到此情況, 你將需要在第一次重開時,把 GRUB 安裝到 MBR 裡. 請按照以下步驟:
</p>

<pre caption="製作 GRUB 開機片">
# <i>cd /usr/share/grub/i386-pc/</i>
# <i>cat stage1 stage2 > /dev/fd0</i>
</pre>

<p>
現在重開, 然後放入磁片. 在磁片的 <c>grub&gt;</c> 介面, 你現在可以執行 <c>root</c> 和 <c>setup</c> 指令.
</p>

</body>
</section>
<section>
<title>LILO 開機片</title>
<body>

<impo>
不要忘了在開始前放入一片磁片.
</impo>

<p>
如果你使用的是 LILO, 製作一個開機片也是一個不錯的主意.
</p>

<pre caption="製作 LILO 開機片">
# <i>dd if=/boot/your_kernel of=/dev/fd0 </i>
<comment>(只有在核心小於 1.4MB 的情況下才有可能)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>使用 GRP</title>
<section>
<body>

<p>
GRP 使用者在這個階段可以安裝二進位套件 (binary packages):
</p>

<pre caption="從 GPRP 安裝">
# <i>USE="bindist" emerge -k xfree</i> 
<codenote>(使用 GRP 安裝 XFree86 相關套件的時候一定要設 USE="bindist")</codenote>
</pre>

<p>
CD 1 包含著足夠的套件讓你安裝一個有用的系統及 XFree86. 還有, 雙光碟的 GRP 的 CD2 有包括 KDE, GNOME, Mozilla 等等其他軟體. 如要安裝這些套件, 你將需要重新啟動到你安裝完成的 Gentoo 系統. (在文件底端的 "完成安裝" 部分). 當你從硬碟重新啟動到你的基本 Gentoo 系統後, 你可以掛載第二片光碟然後複製檔案:
</p>

<pre caption="從 CD2 複製二位元套件">
# <i>mount /dev/cdrom /mnt/cdrom</i>
# <i>cp -a /mnt/cdrom/packages/* /usr/portage/packages/</i>
</pre>

<p>
以下為安裝其他軟體的範例:
</p>

<pre caption="從 GRP 安裝 KDE">
# <i>USE="bindist" emerge -k kde</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>完成安裝</title>
<section>
<body>

<p>
現在 Gentoo Linux 已經安裝完畢. 所剩的步驟就是更新設定檔, 離開 chroot, 安全的移除分割區掛載, 然後重新開機:
</p>

<warn>

<c>etc-update</c> 會提供你需要更新設定檔的清單. 請確定不會影響到重要的設定檔 (如: <path>/etc/fstab</path>, <path>/etc/make.conf</path>, <path>/etc/rc.conf</path>, ...).
安裝新的檔案不會影響太大, 你可以移除更新, 或是利用 diff 自行更新設定檔.
</warn>

<pre caption="重新啟動">
# <i>etc-update</i>
# <i>exit</i> 
<comment>(以上指令將會離開 chroot, 你也可以輸入 <c>^D</c>)</comment>
# <i>cd / </i>
# <i>umount /mnt/gentoo/boot</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>umount /mnt/gentoo</i>
# <i>reboot</i>
<comment>(不要忘了把可開機光碟從光碟機拿掉)</comment>
</pre>

<note>
重新啟動後, 我們建議你執行一次 <c>update-modules</c> 建立 <path>/etc/modules.conf</path>. 你應該自行更改 <path>/etc/modules.d</path> 而不是直接更改.
</note>

<p>
如果你有任何問題或是想要加入 Gentoo Linux 開發, 請記得加入我們的 gentoo-user 和 gentoo-dev mailing list. (更多的資料在我們的 <uri link="http://www.gentoo.org/main/en/lists.xml">mailing lists</uri> 網頁). 我們也有好用的 <uri link="http://www.gentoo.org/doc/en/desktop.xml">桌面設定指南</uri> 將會引導你如何繼續設定你的 Gentoo Linux 系統. 還有有用的 <uri link="http://www.gentoo.org/doc/en/portage-user.xml">Portage 使用者指南</uri> 幫助你了解 Portage 的基礎. 你可以在<uri link="http://www.gentoo.org/main/en/docs.xml">這裡</uri>找到我們其他的文件. 如果你有其他安裝時的問題, 或者是其他事務, 請查看我們的 <uri link="http://www.gentoo.org/doc/tw/faq.xml">中文FAQ</uri> 或是英文版 <uri link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri>.
請慢慢享受. 歡迎使用 Gentoo Linux!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Gentoo-Stats(統計)</title>
<section>
<body>

<p>
當 Gentoo Linux 開始使用統計時, 是讓開發者了解使用者的需求量. 這個程式將收集著 Gentoo Linux 使用量, 方便我們開發. 我們並不強迫您安裝, 但是我們將會很感激你如果你選擇幫助我們. 收集到的統計將放在 <uri>http://stats.gentoo.org</uri>.
</p>

<p>
gentoo-stats 伺服器將會給你的系統一個唯一的號碼. 這個號碼將部會用來收集系統資訊, 或是你的 IP 位址. 你的隱私將會被保護著. 以下是我們將收集的資料:
</p>

<ul>
<li>安裝的軟體,和版本</li>
<li>CPU 資料: 速度 (MHz), 廠牌, 類型, CPU 種類 (像是 "mmx" 或是 "3dnow")</li>
<li>記憶體資料(RAM,和 SWAP空間)</li>
<li>PCI 控制卡和網路卡</li>
<li>你的主機使用的Gentoo Linux Profie (在 /etc/make.profile 裡面的 link).</li>
</ul>

<p>
我們不會收集對於 Gentoo Linux 使用者相關的個人資料. 以確保資料不會暴露. (和開發者一樣)
</p>

<ul>
<li>除非你有更改 gentoo-stats 程式, 不然他不會傳出你的密碼,設定檔, 鞋子尺寸...</li>
<li>電子郵件的傳送是非必要的, 預設將會關閉</li>
<li>傳送時的 IP 位址將不會被紀錄, 我們可以透過給你的號碼作為認證, 所以我們不需要 "IP位址/系統 ID".</li>
</ul>

<p>
安裝時很簡單 - 請按照以下步驟:
</p>

<pre caption="安裝 gentoo-stats">
# <c>emerge gentoo-stats</c>   <codenote>安裝 gentoo-stats</codenote>
# <c>gentoo-stats --new</c>    <codenote>申請新的系統號碼</codenote>
</pre>

<p>
第二個指令將申請一個系統號碼, 此號碼會被自動地放到 <path>/etc/gentoo-stats/gentoo-stats.conf</path>. 你可以編輯此檔查看其他的設定選項.
</p>

<p>
After that, the program should be run on a regular schedule (gentoo-stats does 
not have to be run as root). Add this line to your <path>crontab</path>:
接下來我們將需要把統計程式(gentoo-stats) 設為自動執行. (不需要使用 root 的權限) 你只需要在 <path>crontab</path> 加入以下指令:
</p>

<pre caption="使用 cron 更新 gentoo-stats">
0 0 * * 0,4 /usr/sbin/gentoo-stats --update &gt; /dev/null
</pre>

<p>
<c>gentoo-stats</c>是用 perl 編寫的小程式, 你也可以用你最喜歡的文字編輯器編輯: <path>/usr/sbin/gentoo-stats</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>在 Gentoo 上使用少見的硬體</title>
<section>
<title>硬體 ATA RAID</title>
<body>

<p>
想要在 Gentoo 上使用硬體 ATA RAID 的使用者,,請注意以下步驟. 這樣才能方便幫助你完成 Gentoo 的安裝:
</p>

<ul>
<li>記得在 LiveCD 開機時加入 <c>doataraid</c> 的參數</li>
<li>如果你再開機時忘了輸入 <c>doataraid</c> 你可以自行輸入:
<pre caption = "載入 RAID 模組">
# <i>modprobe ataraid</i>
<comment>適用於: Promise Raid 控制卡:</comment>
# <i>modprobe pdcraid</i> 
<comment>適用於 Highpoint Raid 控制卡:</comment>
# <i>modprobe hptraid</i>
</pre></li>
<li>有些 ATA RAID 控制卡在分割和格式化後會要求你重新開機; 不然有可能會失敗.</li>
<li>進入 chroot 以前, 將 devicetree 載入新的環境:
<pre caption = "將 /dev 載入 /mnt/gentoo/dev">
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
</pre></li>
<li>編譯核心時, 記得選擇你所需 RAID 的選項:
<pre caption = "Linux 核心 RAID 設定">
<comment>Highpoint RAID 控制卡:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] HPT36X/37X chipset support 
[*] Support for IDE Raid controllers
[*] Highpoint 370 software RAID
<comment>Promise RAID 控制卡:</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] PROMISE PDC202{46|62|65|67} support 
<comment>和/或</comment>
[*] PROMISE PDC202{68|69|70|71|75|76|77} support
[*] Support for IDE Raid controllers
[*] Support Promise software RAID (Fasttrak(tm))
</pre></li>
<li>When using GRUB add <c>--stage2=/boot/grub/stage2</c> when running <c>grub</c> to the <c>setup</c> command:
	使用 GRUB 時, 當執行 <c>grub</c> 的時候, 把 <c>--stage2=/boot/grub/stage2</c> 加到 <c>setup</c> 的指令:
<pre caption = "為 GRUB 安裝硬體 RAID 系統">
grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
grub&gt; <i>quit</i>
</pre>
另外, 在 GRUB 的設定中, 記得把 <c>root</c> 指向適當的 RAID 裝置:
<pre caption = "grub.conf 和 RAID 的設定">
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
</pre></li>
<li>LILO 的使用者將需要將 <c>root</c> 指到適當的 RAID 裝置: 
<pre caption = "lilo.conf 和 RAID 的設定">
image=/boot/bzImage
label=linux
read-only
root=/dev/ataraid/dXpY
</pre></li>
</ul>

<p>
如果你還有關於安裝 Gentoo Linux 硬體 RAID 到你的系統, 請到 <uri>http://bugs.gentoo.org</uri> 申報.
</p>

<p>
謝謝您使用 Gentoo Linux. 請享受新的安裝程序!
</p>


</body>
</section>
</chapter>
</guide>
