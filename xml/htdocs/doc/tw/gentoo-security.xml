<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="../../xsl/guide.xsl" type="text/xsl"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/tw/gentoo-security.xml">
<title>Gentoo Linux 安全指南</title>
<author title="Author"><mail link="kn@insecurity.dk">Kim Nielsen</mail></author>
<author title="Editor"><mail link="zhen@gentoo.org">John P. Davis</mail></author>
<author title="Editor"><mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail></author>
<author title="Editor"><mail link="carl@gentoo.org">Carl Anderson</mail></author>
<author title="Editor"><mail link="peesh@gentoo.org">Jorge Paulo</mail></author>
<author title="Translator"><mail link="palatis@gentoo.org.tw">【Palatis】</mail></author>
<author title="Reviewer"><mail link="bennyc@gentoo.org">BennyC</mail></author>
<!-- well, i hope there's someday that someone would relayout the code,
     and write "cleanup" in changelog. - Palatis -->

<abstract>這是篇一步一步教您怎樣把 Gentoo Linux 變硬的指南。</abstract>

<version>0.4</version>
<date>24 March 2003</date>
<!-- Translate date : 17 April 2003 -->

-- Introduction start --

<chapter>
	<title>介紹</title>
	<section>
		<title>誰應該閱讀這篇指南？</title>
		<body>
		<p>那些使用 Gentoo Linux 作為伺服環境和╱或有系統安全偏執狂的人。</p>
		</body>
	</section>

	<section>
		<title>製作</title>
		<body>
		<p>Kim Nielsen</p>
		</body>
	</section>

	<section>
		<title>特別感謝</title>
		<body>
		<p>特別感謝以下指正錯誤、檢查拼字、通順語句的人們...</p>
		<p>Bjarke Sørensen, Justin Lambert, Andreas Waschbuesch, Duncan Lissett, Sherman Boyd, Sami Dalouche and Väinö Järvelä.</p>
		</body>
	</section>

	<section>
		<title>下一個版本的指南將加上這些：</title>
		<body>
		<p>在版本 0.6 (備份) 中</p>
		<ul>
		  <li>Arpwatch</li>
		  <li>使用 Systemimager 作全系統備份</li>
		  <li>使用 tar 作部份備份</li>
		  <li>備份 postgres</li>
		</ul>
		<p>在版本 0.8 (入侵測試) 中</p>
		<ul>
		  <li>遠端稽核</li>
		  <li>網路稽核</li>
		  <li>主機稽核</li>
		  <li>軟體稽核</li>
		</ul>
		<p>在版本 1.0 (傷害之後) 中</p>
		<ul>
		  <li>如何回報事件</li>
		  <li>法律分析</li>
		  <li>在不破壞證據的前提下建立系統映像 (使用 dd)</li>
		  <li>陷阱和追蹤 (使用 tcpdump)</li>
		  <li>... 還有更多 ...</li>
		  <li>回復系統</li>
		</ul>
		<note>請注意每一版一次只專注於同一個主題。這是為了品質考量。</note>
		</body>
	</section>

</chapter>

-- Introduction end --

-- Considerations before installation start --

<chapter>
	<title>安裝前的考量</title>
	<section>
		<title>實體安全</title>
		<body>
		<p>不管您請來多少安全警衛，攻擊者都能簡單的從機器前面入侵您的系統。確認您的硬體不是隨時都可以使用。例如，您可能想將您的機器鎖進保險櫃裡面，能把鎖鎖上更好！為了更高的安全性，您可以限定系統只能從硬碟開機，避免其他人使用軟碟機或光碟機來開機。更進一步，您還可以把 BIOS 密碼鎖上。對筆記型電腦使用者來說，BIOS 密碼也是個好主意。</p>
		</body>
	</section>

	<section>
		<title>伺服程式╱服務計畫</title>
		<body>
		<p>將您系統應該執行或可能執行的服務作成文件。這可以幫助您策劃較完善的磁碟分割規劃。也可以讓您在做入侵偵測戰略規劃的時候容易些。</p>
		<p>當然，您如果您沒幾台電腦以及您是唯一會使用他們的人，則您不必理會這分文件。</p>
		<p>舉例：</p>
		<p>這台電腦應該是台防火牆，他應該執行些什麼服務？</p>
		<p><e>無</e>，除了可能執行一下 ssh。</p>
		<p>將這個以及 SSH 目前的版本記錄下來 - 這將有助於您持續追蹤那個系統有漏洞應該升級。這也可以順便幫您決定誰有資格存取這個系統。</p>
		</body>
	</section>

	<section>
		<title>分割區規劃</title>
		<body>
		<p>金科玉律：</p>
		<ul>
		  <li>所有可以讓使用者寫入的目錄 (/home、/var 以及 /tmp) 都應該在分開而且有磁碟限額的分割區上。Portage 使用 /var/tmp 作為編譯暫存區，所以這個分割區應該大一點。這將降低使用者塞爆您 "/" 掛載點的風險。</li>
		  <li>所有安裝 "外來軟體" 的目錄應該被放在分開的分割區。根據<uri link="http://www.pathname.com/fhs/">檔案分區標準</uri>，這應該是<path>/opt</path> 或 /usr/local。若這些是分開的分割區，它們不會在您重新安裝系統的時候被抹滅掉。</li>
		  <li>盡量將靜態的資料放在它自己的分割區裡，然後將那個分割區掛載成 "只能讀取"。如果您真的那麼偏執的話，您可能嘗試將靜態的資料放在真正 "只能讀取" 的媒體上，例如光碟上面...</li>
		</ul>
		</body>
	</section>

	<section>
		<title>根 (root) 使用者</title>
		<body>
		<p>"根 (root) 使用者" 對整個系統來說是個致命的角色，而且除非必要絕對不請下山的傢伙。如果某個攻擊者取得了您系統的 "根 (root) 權限"，那您就不再能相信您的系統了，重灌吧！</p>
		<p>關於根 (root) 的金科玉律：</p>
		<ul>
		  <li>永遠建立一個每天要使用的角色。如果他真的需要根 (root) 權限，把他加入 wheel 群組。這將讓他有權利使用 "su" 指令暫時提昇為根 (root) 使用者。</li>
		  <li>永遠不要用根 (root) 使用者跑 X 或其他使用者級程式。</li>
		  <li>永遠在登入成根 (root) 使用者的時候使用絕對路徑。某人可能嘗試欺騙您執行您以為您正在執行的程式。例如，某個傢伙改了您一般使用者的 PATH 環境變數，然後您又沒有使用 <c>su -</c> 來升級成根 (root) 使用者，那麼根 (root) 使用者將繼承這個環境變數。</li>
		  <li>如果某個使用者只需要使用某些 (而非全部) 根 (root) 使用者的指令，考慮使用 sudo，不過請小心使用！</li>
		  <li>永遠不要在登入成根 (root) 使用者的時候離開座位。</li>
		</ul>
		<p>Gentoo 有個一般性防護來防止那些想偷偷 su 的使用者。預設的 PAM 設定指定那些可以使用 su 指令的使用者必須是 wheel 群組的成員。</p>
		</body>
	</section>

	<section>
		<title>政策</title>
		<body>
		<section>
			<title>為何需要政策？</title>
			<body>
			<p>有幾個理由指出政策存在的價值：</p>
			<ul>
			  <li>如果您沒有為安全下個定義，您就無法判斷您的網路環境是否安全。</li>
			  <li>您幾乎不可能在沒有偵查網路通訊或搜尋私人家目錄的狀況下捕捉潛在的攻擊者、解決網路問題、或管理稽核。而未經允許作這些探查動作在大部份國家是違法的。尤其 60% 以上的攻擊者都是從內部侵入，您實在不能不把罩子擦亮點...</li>
			  <li>如果您從來不向使用者解釋該如何保護他們自己和他們的同事，以及為什麼安全那麼重要，您將無法要求他們考慮安全性。</li>
			  <li>不管怎樣，好的導覽和網路文件一定會得到報酬的～</li>
			  <li>如果警察或法律機關不知道您的網路設定以及您提供的服務，他們將無法幫助您抓住壞蛋。</li>
			  <li>在受到攻擊的時候該怎麼辦？您必須列出您該做的事情以及您該告訴誰才好。您想每次有事情發生都打電話給警察或 CERT 小組嗎？他們不會認真看待的！</li>
			</ul>
			<p>這應該清楚的能指出確立政策以及教育使用者的重要性了。</p>
			<p>"政策" 是一份 (或多份) 能夠回答類似誰 (who)、那裡 (where)、為什麼 (why) 或什麼 (what) 這些問題的文件。每位您系統或網路上的使用者都應該閱讀、了解、並在旁邊簽名。花時間幫助您的使用者了解政策的內容以及為何他們必須在旁邊簽名或當他們違反這些政策的時候將發生什麼事 (這個應該也納入文件裡面)。這個動作應該每年至少重複一次，因為這些政策有可能改變，也可以順便提醒您的使用者。</p>
			<note>在每個主題上都建立讀起來簡單而且非常清楚具體的政策。</note>
			<p>大部份的政策都能直接套用在作業系統或防火牆上，不過小部份不行。</p>
			</body>
		</section>

		<section>
			<title>安全性政策</title>
			<body>
			<p>基本上，"安全性政策" 是一套能保障您系統╱網路安全的規則。簡單來說就是一份包括電腦、網路、密碼、電子郵件、或甚至告訴使用者什麼該作什麼不該作、受到攻擊時該怎麼樣、機器 (工作站╱伺服器) 是如何安裝的、系統基礎構造... 等等資訊的文件。</p>
			<p>一份安全政策至少應該包括以下幾項主題：</p>
			<ul>
			  <li>允許的使用：</li>
			    <ul>
			      <li>螢幕保護程式</li>
			      <li>密碼管理</li>
			      <li>下載檔案</li>
			      <li>如何判斷或避免被監視的知識</li>
			      <li>使用防毒軟體</li>
			      <li>諸如此類</li>
			    </ul>
			  <li>管理敏感的資訊 (任何書面表格、寫在紙上的或磁性數據)</li>
			    <ul>
			      <li>清乾淨桌面並把分類資訊鎖進保險櫃</li>
			      <li>離開前將電腦關機</li>
			      <li>使用加密</li>
			      <li>如何將鑰匙交給信任的同事管理</li>
			      <li>出差的時候管理分類資料</li>
			    </ul>
			  <li>出差時管理電腦配備</li>
			    <ul>
			      <li>出差以及住在旅社時的筆記型電腦管理</li>
			    </ul>
			</ul>
			<p>專為 IT (資訊技術) 工作人員訂立的政策可能會根普通使用者的政策有所不同</p>
			<p>安全性政策可能會長得很大，而致命的資訊也常被忘記。IT 工作人員的政策可以包含一般使用者應該知道的資訊，所以將它們分成小部份是個聰明的好點子。例如：可接受的使用政策、密碼政策、電子郵件政策、以及遠端存取政策。</p>
			<p>一些政策的例子可以在 <uri link="http://www.sans.org/newlook/resources/policies/policies.htm">The SANS Security Policy Project</uri> 找到。如果您只有個小網路而覺得這些政策太多了，您應該參考 <uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">RFC2196</uri> - 他是一本網站安全手冊。</p>
			</body>
		</section>
		</body>
	</section>
</chapter>

-- Considerations before installation end --

-- Tightening the security after/during installation start --

<chapter>
<title>安裝前╱中繫緊安全帶</title>

<section>
<title>/etc/make.conf</title>
<body>
<p>make.conf 這個檔案包含所有您想在編譯 ebuilds 時候開啟的設定以及函式庫。您一定要確認這個 ebuild 是否支援任何安全性函式庫，例如 PAM (Pluggable Authentication Modules - 插入式認證模組)、tcp wrappers (tcp 封包包裝器)、或 SSL (Secure Socket Layer - 安全插口層級)。您應該讓您的程式支援這些協定，所以您的全域性 USE 環境變數應該包含 pam, tcpd 和 ssl。</p>
<p>應該加上類似這樣的東西：</p>
<pre caption="應該加入的 USE 設定">
USE="tcpd pam ssl"
</pre>
</body>
</section>

<section>
<title>GRUB/LILO 密碼</title>
<body>
<section>
<title>GRUB</title>
<body>
<p>Grub 提供兩種不同的方法來讓您在設定檔中 (<path>/boot/grub/menu.1st</path>) 加入密碼限制。一種是純文字密碼，另一種是 md5+salt 編碼。</p>
<pre caption="/boot/grub/menu.lst">
timeout 5
password changeme
</pre>
<p>這將加入 <e>changeme</e> 這個密碼，如果沒有輸入就使用原本的開機設定。</p>
<p>在加入 md5 密碼的時候，您必須先將密碼轉換至跟 shadow 檔案相同的 crypt 形式 (man crypt)。例如編碼後的密碼 <e>changeme</e> 會看起來像這樣 - <e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>。</p>
<p>或這樣：</p>
<pre caption="/boot/grub/menu.lst">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>
<warn>當測試這個的時候，請記得加入逾時 (timeout) 設定，不然您不小心弄錯的時候將無法啟動系統。</warn>
<p>五秒鐘的逾時 (timeout) 應該已經可以讓遠端遙控的攻擊者感到非常棘手，並且應該能在沒有鍵盤互動的狀況下重開。更多有關 Grub 密碼的資訊可以在執行 <path>info grub</path> 中找到。</p>
</body>
</section>

<section>
<title>LILO</title>
<body>
<p>LILO 也支援兩種處理密碼的方法：全域以及根據影像檔，都是純文字。</p>
<p>全域設定在設定檔的最上面：</p>
<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>
<p>不然的話直接將它加入影像檔。</p>
<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>
<p>如果沒有輸入 <e>restricted</e> 選項，那麼它每次都會要求密碼。</p>
<p>要啟用新的 lilo.conf 資訊，您必須執行 <c>/sbin/lilo</c>。</p>
</body>
</section>
</body>
</section>

<section>
<title>限制控制台用量</title>
<body>
<p><path>/etc/securetty</path> 讓您設定那個終端機可以允許根 (root) 使用者的登入。</p>
<p>我們建議您將 vc/1 以外的其他行都註解掉，這將確定根 (root) 使用者只能在一個虛擬終端機前面登入一次。</p>
<pre caption="/etc/securetty">
vc/1
</pre>
</body>
</section>

<section>
<title>更多紀錄</title>
<body>
<p>加入更多有關警告和錯誤的紀錄可以幫助您判斷正在執行或已經結束的攻擊。攻擊者多半會在行動前掃描整個網路。</p>
<p>`不過如果紀錄檔案很容易被讀取或被管理，也是非常致命的。</p>
<p>Gentoo Linux 提供三種不同的紀錄程式讓您選擇。</p>

<section>
<title>Syslogd</title>
<body>
<p>Syslogd 是在 Linux 和 Unix 上最常見的紀錄程式。它不包含紀錄循環功能，這個動作多半由 cron job 中正確設定於 <path>/etc/logrotate.conf</path> 的 <path>/usr/sbin/logrotate</path> 來執行。多久該讓紀錄檔循環則取決於您的系統負載。</p>
<p>這裡有份您可以用來設定您的 syslog 的例子：</p>
<pre caption="/etc/syslog.conf">
*.=debug /var/log/debug
*.err    /var/log/syslog

# 登入時應該看見這些訊息的使用者。
# Users who should the see message if they are logged in.
*.=alert root,<c>您的使用者名稱</c>
*.=emerg root,<c>您的使用者名稱</c>

mail.info,mail.notice      /var/log/maillog
kern.*   /var/log/kern.log
daemon.info;daemon.notice  /var/log/daemon.log
cron.*   /var/log/cron.log
mail.*   /var/log/mail.log
user.*   /var/log/user.log
uucp.*   /var/log/uucp.log
*.*;auth,authpriv.none     /var/log/syslog

# 同時將紀錄放置於兩個地方
# Place the log file in 2 places
authpriv.*;auth.*          /admin/auth.log
authpriv.*;auth.*          /var/log/secure

# 將所有東西顯示在控制台上
# Write everything on the console
*.*      /dev/tty12

# 或設置一台遠端的紀錄伺服器
# Or setup a remote logging server
*.*      @logserver
</pre>
<p>攻擊者應該會蠻想將他們入侵的資料抹滅掉的，例如編輯或刪除紀錄檔。您可以將這些紀錄送到一台或多台不同的紀錄伺服器，這將讓攻擊者想湮滅證據的時候困難些。</p>
<p>更多關於 syslogd 的資訊可以在男人 (<path>man syslog</path>) 中找到。</p>
</body>
</section>

<section>
<title>Metalog</title>
<body>
<p>由 Frank Dennis 撰寫的 <uri link="http://metalog.sourceforge.net">Metalog</uri> 無法將紀錄寫至遠端伺服器，不過在效能以及彈性上的確是有它的優點。</p>
<p>它可以根據程式或設施 (類似 syslogd) 來紀錄，而且支援照正規表示式 (Regular Expression) 和執行的指令來分類。這在有必要採取行動的時候將十分有用。</p>

<pre caption="/etc/metalog.conf">
maxsize  = 1000000
maxtime  = 86400
maxfiles = 7
minimum  = 7

Kernel messages :

  facility = "kern"
  logdir   = "/var/log/kernel"

Auth messages :
  facility = "auth"
  logdir   = "/var/log/auth"

Emergencies :
  facility = "emerg"
  command  = "/usr/local/sbin/pwdfail.sh"

Crond :

  program  = "crond"
  logdir   = "/var/log/crond"

Password failures :

  regex    = "(password|login|authentication)\s+(fail|invalid)"
  regex    = "(failed|invalid)\s+(password|login|authentication)"
  regex    = "ILLEGAL ROOT LOGIN"
  logdir   = "/var/log/pwdfail"
  command  = "/usr/local/sbin/pwdfail.sh"

SSH Server :

  program  = "sshd"
  logdir   = "/var/log/sshd"

Mail :

  facility = "mail"
  logdir   = "/var/log/mail"

Snort:
  program   = "snort"
  command  = "/usr/local/sbin/pwdfail.sh"

Everything important :

  facility = "*"
  logdir   = "/var/log/everything"

Everything very important :

  facility = "*"
  logdir   = "/var/log/critical"
</pre>
<p>這是一份稍微修改過的基本設定檔，例如最小紀錄等級為 7，表示將紀錄所有東西。</p>
<p>給 postfix 用的 pwdfail.sh</p>
<pre caption = "給 postfix 用的 pwdfail.sh">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>
<p>給 qmail 用的 pwdfail.sh</p>
<pre caption = "給 qmail 用的 pwdfail.sh">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>
<p>您可以在 <uri link="http://metalog.sourceforge.net">metalog</uri> 網站找到更多資訊。</p>
</body>
</section>
<section>

<title>Syslog-ng</title>
<body>
<p>Syslog-ng 提供某些跟 syslog 和 metalog 類似卻稍微不同的功能。它可以基於等級和內容過濾訊息 (類似 metalog)、提供類似 syslog 的遠端紀錄功能、處理 syslogd 送來的紀錄 (甚至 Solaris 送來的串流)、寫入至 TTY 的東西、執行檔案，還可以當作紀錄伺服器來使用。基本上，它是最適合需要高階設定的使用者的記錄器。</p>
<p>一份靈巧修改過的標準設定檔。</p>
<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

# 讀取紀錄的所在
# source where to read log
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

# 定義目的地
# define destinations
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination mailprog { program("/usr/bin/email.sh"); };
destination xconsole { pipe("/dev/xconsole"); };

# 建立過濾器
# create filters
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

# 將過濾器以及目的地連結在一起
# connect filter and destination
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

# 將紀錄失敗的東西郵寄給我
# mail log failed to back to me
log { source(src); filter(f_failed); filter(f_denied); destination(mailprog); };

# 預設的紀錄
# default log
log { source(src); destination(console_all); };
</pre>
<p>設定檔很容易設定，不過也很容易遺漏某些東西，因為它實在蠻臃腫的。作者還保證會在未來的版本中提供更多功能，例如加密、認證、壓縮、和 MAC (Mandatory Access Control) 控制。有了這些選項，這將會是個很完美的網路記錄器，既然攻擊者不能監視紀錄的話。</p>
<p>而且 syslog-ng 還有個好處，它不用以根 (root) 使用者權限執行！</p>
</body>
</section>
</body>
</section>

<section>
<title>分割區的掛載</title>
<body>

<p>
When mounting an ext2, ext3 or a reiserfs partition, you have several options you can apply to the . The options are:
</p>
<p>當掛載 ext2、ext3 或 reiserfs 分割區的時候，您有幾個可以套用在 <path>/etc/fstab</path> 的選項。這些選項是：</p>
<ul>
  <li>nosuid - 忽略所有檔案的 SUID bit 並將它們視為普通檔案。</li>
  <li>noexec - 防止所有程式從這個分割區執行。</li>
  <li>nodev - 忽略設備。</li>
</ul>
<p>不幸的，這些設定可以簡單的被繞過，只要不從直接路徑執行就好了。無論如何，將 /tmp 設成 noexec 可以防止約 99% 的不成熟命令稿，畢竟它們是被設計成直接從 /tmp 執行的。</p>
<pre caption="/etc/fstab">
/dev/sda1          /boot      ext2     noauto,noatime                     1 1
/dev/sda2          none       swap     sw                                 0 0
/dev/sda3          /          reiserfs notail,noatime                     0 0
/dev/sda4          /tmp       reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5          /var       reiserfs notail,noatime,nodev               0 0
/dev/sda6          /home      reiserfs notail,noatime,nodev,nosuid        0 0
/dev/sda7          /usr       reiserfs notail,noatime,nodev,ro            0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660  noauto,ro                          0 0
proc               /proc      proc     defaults                           0 0
</pre>
<warn>將 <path>/tmp</path> 設成 noexec 模式可能防止某些命令稿正常執行。</warn>
<note>磁碟限額將在另外一章中描述。</note>
<p>注意我沒有將  設成 noexec 或 nosuid 即使一般來說不會有檔案從這裡被執行。原因是 qmail 將被安裝在 <path>/var/qmail</path> 而且必須執行一個有 suid 的檔案。我將 <path>/usr</path> 設成 read-only 模式，畢竟我不會想寫任何東西進去，除非想更新 Gentoo。那我會重新將檔案系統掛載成 read-write，更新，再重新掛載一次。</p>
<note>即使您不用 qmail，Gentoo 還是需要 <path>/var/tmp</path> 的執行權限，畢竟 ebuild 會在這裡執行。不過您堅持的話，還是可以將這個路徑設到其他地方，然後把 <path>/var</path> 掛成 noexec 模式。</note>
</body>
</section>

<section>
<title>使用者╱群組限制</title>
<body>

<section>
<title>/etc/security/limits.conf</title>
<body>
<p>當防止本地端阻斷服務 (DoS) 或管理群組的登入人數上限時，資源限制顯然是個很有效率的方法。</p>
<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>
<p>如果您發現您嘗試將 nproc 或 maxlogins 設成 0，那麼您也許應該直接刪除那個使用者。上述的例子將變更 "dev" 群組的行程數、開啟檔案數、以及最大登入人數。其餘則設成預設值。</p>
<note><path>/etc/security/limits.conf</path> 是 PAM 套件的一部份，而且只會影響那些使用 PAM 的套件。</note>


</body>
</section>

<section>
<title>/etc/limits</title>
<body>
<p>limits 跟限制設定檔 <path>/etc/security/limits.conf</path> 很類似。唯一的差別是它只對使用者或全域符號 (wildcards) 而非群組作用。讓我們看看具體的設定：</p>
<pre caption="/etc/limits">
* L2 C0 U15 R10000
kn L10 C100000 U35
</pre>
<p>在這裡我們將指定預設設定以及 <e>kn</e> 使用者的個人設定。Limits 是影子套件 (shadow package) 的一部份，而且只會對影子登入程式 (shadow login program) 作用。如果您正確設定了 PAM 套件，則您不需要將上限設於這個檔案中。</p>
<p class="secthead"><a name="doc_chap3_sect3"></a></p>
</body>
</section>
<section>

<title>磁碟限額 (Quotas)</title>
<body>
<p>在檔案系統上啟動磁碟限額可以防止使用者塞爆磁碟或根本不讓他們寫入。磁碟限額在核心中被開啟並加入至掛載點。核心選項可以在核心設定的 <c>File systems->Quota support</c> 中開啟。套用下列設定，重新編譯核心，並且用新的核心重新啟動電腦。</p>

<pre caption="安裝磁碟限額">
# <i>emerge quota</i>
</pre>
<p>更新您的 <path>/etc/fstab</path> 檔案並在您想要限定磁碟使用率的分割區加入 usrquota 和 grpquota 選項，如下例所示：</p>
<pre caption="/etc/fstab">
/dev/sda1          /boot      ext2     noauto,noatime                                       1 1
/dev/sda2          none       swap     sw                                                   0 0
/dev/sda3          /          reiserfs notail,noatime                                       0 0
/dev/sda4          /tmp       reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5          /var       reiserfs notail,noatime,nodev,usrquota,grpquota               0 0
/dev/sda6          /home      reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota        0 0
/dev/sda7          /usr       reiserfs notail,noatime,nodev,ro                              0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660  noauto,ro                                            0 0
proc               /proc      proc     defaults                                             0 0
</pre>
<p>在您啟動磁碟限額的分割區上，建立磁碟限額設定檔 (quota.user 和 quota.group) 並將他們放在磁碟的最上層目錄下。</p>
<pre caption="建立磁碟限額檔案">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>
<p>您必須在所有啟動磁碟限額的分割區執行這個動作。在建立並設定了磁碟限額設定檔以後，我們必須在 run level 加入個命令稿，好在每次開機時將磁碟限額啟動。將底下的命令稿複製起來貼到 <path>/etc/init.d/quotas</path> 檔案裡。簡單的建立這個檔案 (如果它不存在) 並賦予它執行權限。</p>
<pre caption="/etc/init.d/quotas">
#!/sbin/runscript

depend() {
	need localmount
}

start() {
        if [ -x /sbin/quotacheck ] 
        then 
               ebegin "Checking quotas. This may take some time." 
               /sbin/quotacheck -avug 
               eend $?
        fi 
        if [ -x /sbin/quotaon ] 
        then 
               ebegin "Turning on quota." 
               /sbin/quotaon -avug 
               eend $?
        fi
}

stop() {
        if [ -x /sbin/quotaon ] 
        then 
	       ebegin "Turning off quota."
               /sbin/quotaoff
	       eend $?
        fi
}
</pre>
<p>使用 <c>rc-update add quotas default</c> 將它加入 run level，並建立個 quotacheck (crontab -e) 來每星期檢查磁碟限額：<c>0 3 * * 0 /sbin/quotacheck -avug</c>。</p>
<p>在重新開機之後，就可以設定使用者和群組的磁碟限額了。<c>edquota -u kn</c> 會啟動設置於 $EDITOR (預設是 nano) 中的編輯器，並且讓您編輯 kn 使用者的磁碟限額。-g 有幾乎相同的效果，只是它是針對群組。</p>
<pre caption="設定使用者 kn 的磁碟限額">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>
<p>進一步的細節請參考 <e>man edquota</e> 或 <uri link="http://www.tldp.org/HOWTO/mini/Quota.html">The quota mini howto</uri>。</p>

<section>
<title>/etc/login.defs</title>
<body>
<p>如果政策指示使用者應該每個星期變更一次密碼，將 PASS_MAX_DAYS 設成 14，PASS_WARN_AGE 設成 7。同時建議您使用密碼等待時間，畢竟暴力破解法可以找出任何密碼 (時間問題罷了)。我們同時建議您將 LOG_OK_LOGINS 設成 yes。</p>
</body>
</section>

<section>
<title>/etc/login.access</title>
<body>
<p>login.access 檔案也是影子套件 (shadow package) 的一部份，設定登入存取控制表用的。這個表基於使用者名稱、群組名稱、或主機名稱來控制誰可以或誰不行登入。在預設中，所有系統上的使用者都可以登入，所以這個檔案只有一大堆註解跟例子。不管您是在加強伺服器或工作站的安全，我們建議您設定成除了您 (系統管理員) 之外沒有人可以從控制台登入。</p>
<note>這些設定不會套用到根 (root) 使用者上。</note>
<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>
<warn>請小心的設定這些選項，畢竟一個不小心可能讓您沒有權限存取這台機器。</warn>
<note>這些設定不會套用到 SSH 上，因為 SSH 預設不會執行 /bin/login。這個可以使用在 <path>/etc/ssh/sshd_config</path> 中的 "UseLogin yes" 來啟用。它會讓 SSH 使用 login 所以這些設定會被套用。</note>
<p>這會讓 wheel 群組的成員可以在控制台前或 gentoo.org 網域中登入。可能有點極端，不過安全還是比抱歉來得好。</p>

</body>
</section>

<section>
<title>檔案權限</title>
<body>

<section>
<title>全世界都可以讀取</title>
<body>
<p>普通使用者不應該擁有設定檔或密碼檔的存取權限。攻擊者可以從網站或資料庫偷走密碼並更改網站內容甚至刪除檔案。這就是為什麼檔案權限正確很重要。如果您很確定這個檔案只會被根 (root) 使用者用到，將它的權限設成 0600 並使用 chown 指令設置正確的擁有者。</p>
</body>
</section>

<section>
<title>全世界╱群組都可以寫入</title>
<body>

<pre caption="找出全世界都可以寫入的檔案和目錄">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>
<p>這將建立一個擁有所有可以被群組或所有人寫入的檔案的巨大清單。檢察檔案的權限並排除所有人都可以寫入的檔案，對檔案執行 <path>/bin/chmod o-w</path> 可以做到。</p>
</body>
</section>

<section>
<title>SUID/SGID 檔案</title>
<body>
<p> SUID/SGID 檔案 (被設置超級使用者位元的檔案) 是個讓一般使用者作平時只有根 (root) 使用者可以作的事的方法。這些檔案可能對系統安全造成危害 (如果他們有漏洞)，因為這些檔案是以 root 權限執行的。這些檔案很危險，而且應該在任何情況下被避免。如果您不使用這個檔案，把他們 chmod 0 或直接移除安裝它的套件 (使用 qpkg -f 來找尋套件，如果您沒有他，使用 <c>emerge gentoolkit</c> 來安裝)。否則，使用 chmod -s 來將 suid bit 取消。</p>
<pre caption="找出 setuid 的檔案">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>
<p>這將建立一個包括所有 SUID/SGID 檔案的清單。</p>
<pre caption="所有 setuid 檔案的清單">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>
<p>預設上，Gentoo Linux 並沒有很多 SUID 檔案 (主要還是看你裝了什麼東西)，所以您很可能得到一個類似上面那樣的清單。大部份的指令不應該被一般使用者使用，除了根 (root) 使用者。使用 <c>chmod -s</c> 指令將 ping、mount、umount、chfn、chsh、newgrp、suidperl、pt_chown 以及 traceroute 的 suid bit 拿掉。不要移除 su, qmail-queue 或 unix_chkpwd 的 suid bit，否則您的使用者將無法 su 或接收郵件。經由移除這些檔案的 suid bit，同時排除了一般使用者 (或攻擊者) 從這些檔案奪取根 (root) 權限的可能。</p>
<p>我系統上僅存的 SUID 檔案只有 su、passwd、gpasswd、qmail-queue、unix_chkpwd 以及 pwdb_chkpwd。不過如果您有 X，您可能有更多，因為 X 需要一些其他的存取權限。</p>
</body>
</section>

</body>
</section>

<section>
<title>PAM (Pluggable Authentication Modules - 插入式認證模組)</title>
<body>
<p>PAM 是一套在程式中提供另一種認證方法的共享函式庫。在 Gentoo Linux 上的 PAM 設定其實蠻合理的，不過事情永遠有進步的空間。</p>

<note>如果您沒有在 <path>/etc/make.conf</path> 的 USE 選項中啟動 PAM 模組，則這個小節對您沒有任何影響。</note>

<p>安裝 cracklib</p>

<pre caption="安裝 cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_pwdb.so shadow nullok
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_pwdb.so md5 use_authtok
session	 required pam_pwdb.so
</pre>
<p>這將會安裝 cracklib，他會確定您的使用者使用至少八個字元以上的密碼，由至少兩個數字、兩個其他字元，而且必須有三個以上的字元與上一組相異。這可以強迫使用者選個好密碼 (密碼政策)。查閱 <uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri> 文件，他可以告訴您更多選項。</p>
<pre caption="/etc/pam.d/sshd">
auth	 required pam_pwdb.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_pwdb.so shadow md5
session	 required pam_pwdb.so
session	 required pam_limits.so
</pre>
<p>其他所有沒有在 PAM 設定資料夾 - <path>/etc/pam.d</path> 中設定的服務將會使用 "other" 這個規則。預設的設定如同您預期的 - 拒絕。不過我想要很多紀錄，所以我加上了 pam_warn.so。最後一個設定是 pam_limits，這將在 <path>/etc/security/limits.conf</path> 中設定。看這些設定的章節。</p>
<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>

<section>
<title>TCP Wrappers</title>
<body>

<p>這是個您可以用來控制一般由 inetd (不過 Gentoo 沒有) 管理的服務的方法，不過它也可以用來管理 xinetd 或其他服務。</p>
<note>在 make.conf 中的 USE 應該包含 tcpd，而且服務應該在 xinetd 中的伺服器指令裡面執行 tcpd。查閱 xinetd 的小節以獲得更多資訊。</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>
<p>如同您看到的，它的格式與 <path>/etc/login.access</path> 非常相近。Tcpd 支援特定的服務，而且他們工作在不同領域的安全上。這些設定只會套用在使用 tcp wrappers 的服務上。</p>
<p>它也可以在某個服務被存取的時候執行某個指令 (可以在為撥接使用者啟動中繼的時候使用)，不過建議您最好不要這樣做，因為人們傾向於製造比他們能解決的問題多更多的問題。舉個例子，您可能想在每次某個人觸及拒絕條款的時候寄封電子郵件到自己的信箱，可是某個攻擊者可以對您發動 DoS 攻擊，則您會收到幾億封郵件並製造一堆 I/O 問題，所以千萬別這麼做。閱讀 <c>man 5 hosts_access</c> 以獲取更多資訊。</p>
</body>
</section>


</body>
</section>

</body>
</section>
</chapter>

-- Tightening the security after/during installation end --

-- Kernel security start --

<chapter>
<title>核心安全</title>

<section>
<title>移除功能性</title>
<body>
<p>設定核心的基本規則是移除所有您不需要的東西。這會建立一個比較小的核心，同時也可以避免那些可能存在驅動程式或其他功能中的漏洞。</p>
<p>同時考慮關閉模組載入支援 (loadable module support)，雖然說還是可以用這個以外的方法加入模組 (根工具 - root kits)，不過它的確讓一般的攻擊者難以經由核心模組安裝根工具 (root kits)。</p>
</body>
</section>

<section>
<title>/proc (核心旗標)</title>
<body>
<p>許多核心參數可以從 /proc 或 sysctl 被更改。</p>
<p>想在執行時期動態變更核心參數以及變數，您的 .config 中必須有 CONFIG_SYSCTL 的支援，在 2.4 系列的核心中這是預設開啟的。</p>
<pre caption="丟棄 ping 封包">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>
<p>這將讓您忽略 icmp type 0 (也就是 ping) 的封包。因為 icmp 會包括讓您意想不到的資訊。系統管理員使用 ping 作為診斷系統的工具，而且他們可能會抱怨不能 ping。沒有理由讓個陌生人來 ping 內部的機器，不過有時候讓內部的人可以 ping 也是蠻方便的，這可以用從防火牆端將 icmp type 0 的封包取消來解決。</p>

<pre caption="忽略廣播探測">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>
<p>這會停止回應廣播封包。</p>
<p>您不想讓自己變成個垃圾增幅器 (Smurf amplifier) 或聖誕樹 (X-mass trees)，這些是可以讓攻擊者送出一堆封包來製造網路大塞車的方法。</p>
<pre caption="忽略源頭路由 (source route) 封包">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>
<p>忽略源頭路由 (source route) 封包</p>
<p>不要接受源頭路由 (source route) 的封包。攻擊者可以使用源頭路由來產生假裝本來就在您內部網路產生的封包，不過將會從他來的路徑路由回去，所以攻擊者可以危害您的網路。源頭路由很少在正當的狀況下被使用，所以關閉它。</p>
<pre caption="取消允許重新導向">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>
<p>取消允許 ICMP 重新導向。ICMP 重導向可以被用來更改您的路由表，可能轉到一條死胡同。</p>
<pre caption="防備爛錯誤訊息">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Enable protection against bad error messages.
</p>

<pre caption="啟動反轉路徑過濾">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>如果您啟動了 IP 轉送，這個也會自動被開啟。</note>
<p>啟動反轉路徑過濾。這可以幫助確認封包來自合法的源頭，經由自動捨棄那些網路位置不符合應該進入的網路介面的封包。這有安全上的優點因為它防止 IP 哄騙 (IP spoofing)，<c>但是它也可能在您使用不對稱路由</c> (封包從您的機器到另一個機器的路徑與從它來到您的路徑不同) <c>的時候造成問題</c>，或您在建設一台有多個 IP 位置來自不同介面的非路由機器。</p>
<pre caption="紀錄騙人的封包、源頭路由封包以及重新導向封包">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>
<p>紀錄騙人的封包、源頭路由封包以及重新導向封包。</p>
<pre caption="關閉 IP 轉送">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/ip_forward</i>
</pre>
<p>確認 IP 轉送是關閉的。我們只在 multi-homed 機器上需要這個東西。</p>
<p>全部這些設定都會在重新開機後被重設。所以我們建議您將下列的命令稿加入 run level 並確定它擁有執行權限。</p>
<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 before *
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>
<p>將他加入 run level - <c>rc-update add procparam default</c>。</p>
</body>
</section>

<section>
<title>核心修正檔</title>
<body>
<section>
<title>Grsecurity</title>
<body>
<p>標準的 Gentoo 核心包含從 <uri link="http://grsecurity.net">Grsecurity</uri> 取得的修正檔，不過預設不啟動。這裡告訴您怎麼啟動它：</p>
<p>如同往常一般設定您的核心，然後從 "Grsecurity option:" (選擇 customized) 並且啟動以下選項：</p>
<ul>
  <li>Buffer Overflow Protection</li>
  <ul>
    <li>Openwall non-executable stack</li>
    <li>Gcc trampoline support</li>
  </ul>
  <li>Filesystem Protections</li>
  <ul>
    <li>Proc restrictions</li>
    <li>Linking restrictions</li>
    <li>Secure file descriptors</li>
    <li>Chroot jail restrictions (enable all options below this option)</li>
  </ul>
  <li>Kernel Auditing</li>
  <ul>
    <li>Log execs within chroot</li>
    <li>(Un)Mount logging</li>
    <li>Signal logging</li>
    <li>Fork failure logging</li>
    <li>Log set*ids to root</li>
    <li>Time change logging</li>
  </ul>
  <li>Executable Protections</li>
  <ul>
    <li>Dmesg restriction</li>
    <li>Randomized PIDs</li>
    <li>Altered default IPC permissions (can prevent some program from working correct)</li>
    <li>Restricted ptrace</li>
  </ul>
  <li>Network Protections</li>
  <ul>
    <li>Randomized IP IDs</li>
    <li>Randomized TCP source ports</li>
    <li>Altered Ping IDs</li>
    <li>Randomized TTL</li>
  </ul>
  <li>Miscellaneous Features</li>
  <ul>
    <li>BSD-style coredumps (will create coredumps like core.named)</li>
  </ul>
</ul>
<p>現在編譯以及安裝您的 "安全加強核心"。</p>
</body>
</section>

<section>
<title>Kerneli</title>
<body>
<p><uri link="http://www.Kerneli.org">Kerneli</uri> 是在目前核心加入編碼功能的修正檔。更新之後，您可以得到例如：Cryptographic ciphers、digest algorithms 以及 cryptographic loop filters。</p>
<warn>目前 kerneli 修正檔並沒有被加入最新的穩定版核心，所以請小心服用。</warn>

</body>
</section>

<section>
<title>其他核心修正檔</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri> (not for 2.4 kernels)</li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>
<p>而其他地方可能還有很多...</p>
</body>
</section>

</body>
</section>

</chapter>

-- Kernel security end --

-- Securing Services start --

<chapter>
<title>加強服務的安全</title>

<section>
<title>使用 xinetd</title>
<body>
<p>xinetd 是用來取代 inetd (Gentoo 剛好沒有) 的，所謂的網際網路服務惡魔 (internet services daemon)。它支援基於遠端機器位置以及存取時間的存取控制。它同時提供了加強紀錄的能力，包括伺服器啟動時間、遠端機器位置、遠端使用者名稱、伺服器執行時間以及要求的動作。</p>
<p>如同其他所有服務一般，有個好的預設設定是很重要的。不過畢竟 xinetd 是根 (root) 使用者用來支援您說不定根本不知道的服務的，我們建議您不要使用它。但是如果您堅持想用，這裡將告訴您怎麼加強它的安全性：</p>

<pre caption="Install xinetd">
# <i>emerge xinetd tcpd</i>
</pre>
<p>然後編輯設定檔：</p>
<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# 這將會經由 xinetd 設定一個有下列設定的 pserver (cvs)：
# 最多 10 個事件 (最高同時 10 個連線)
# 限制 pserver 只用 tcp
# 使用 cvs 使用者來執行這個服務
# 將介面鎖定在一個 ip 位置
# 允許來自 10.0.0.* 的連線
# 限制開發人員能使用 cvs 的時間於早上八點至下午五點
# 使用 tpcd wrappers (存取控制設定於
# <path>/etc/hosts.allow</path> 以及 <path>/etc/hosts.deny</path>)
# 機器上的 max_load 設定成 1.0
# disable 旗標預設是設成 no，不過我喜歡將它加在這裡，
# 因為可能有時候我必須關閉它。
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>
<p>閱讀 <c>man 5 xinetd.conf</c> 以獲得更多資訊。</p>
</body>
</section>

<section>
<title>ssh</title>
<body>
<p>對於 OpenSSH，您唯一要作的只有啟動基於公開金鑰的更強健的認證模式。許多網站 (例如 <uri>http://www.sourceforge.net</uri>、<uri>http://www.php.net</uri> 以及 <uri>http://www.apache.org</uri>) 都因為密碼漏洞或爛密碼而造成的未授權入侵擔心受怕。</p>
<pre caption="/etc/ssh/sshd_config">
# 只啟動第二版
# Only enable version 2
Protocol 2

# 不讓根 (root) 使用者直接登入
# No direct root access
PermitRootLogin no

# 啟動 RHA 金鑰認證
# Turn on RSA key authentication
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# 取消 .rhost 檔案以及普通密碼認證
# Disable .rhost files and normal password auth.
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

# 沒有除了 wheel 和 admin 群組的成員之外的人可以登入
# Noone else than members of wheel or admin should have access
AllowGroups wheel admin

# 以及另外的兩個使用者
# And 2 users
AllowUsers kn bs

# 加入紀錄等級
# add logging level
SyslogFacility AUTH
LogLevel INFO

# 鎖定
# bind
ListenAddress 127.0.0.1
</pre>
<p>然後您的使用者所要作的，就是建立一組鑰匙 (在他們作為用戶端的機器上)，使用以下的指令：</p>
<pre caption="建立一組 RSA 金鑰">
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>
<p>然後輸入密碼</p>
<pre caption="原始碼列舉 5.5：ssh-keygen 的輸出">
Generating public/private rsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_rsa):<c>[按下 enter]</c>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase)：<c>[輸入密碼]</c>
Enter same passphrase again：<c>[再輸入一次密碼]</c>
Your identification has been saved in /home/kn/.ssh/id_rsa.
Your public key has been saved in /home/kn/.ssh/id_rsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>
<p>這會在您的 <path>~/.ssh/</path> 中加入 id_rsa 和 id_rsa.pub 這兩個檔案。叫做 id_rsa 是您的私密金鑰而且應該避免被別人拿到。另一個檔案 id_rsa.pub 則應該被放到您可以放的所有伺服器。將公開金鑰加入至使用者目錄下的 <path>~/.ssh/authorized_keys</path> 中，這個使用者應該就能登入了。</p>
<p>現在您的使用者應該妥善保存他們的私密金鑰。將它放在他們經常攜帶的媒體裡面或是存在他們自己的工作站上 (將這加入<uri link="#doc_chap2">密碼政策</uri>裡)。</p>
<p>在 <uri link="http://www.openssh.org">OpenSSH</uri> 網站可以找到更多資料。</p>
</body>
</section>

<section>
<title>加強 X 的安全性</title>
<body>
<p>XFree 預設上是被設定成 X 伺服器。這可能非常危險，因為 X 使用未加密的 tcp 連線以及聽取 xclient 們。如果您不需要這項服務就把它關掉！但若您必須將您的工作站當成 X 伺服器，使用被警告過的 <path>/usr/X11R6/bin/xhost</path> 指令。這個指令允許其他機器的用戶端連線並且使用您的顯示環境。這在您需要從遠端執行 X 應用程式而且只能透過網路的時候是很方便的。語法是 <path>/usr/X11R6/bin/xhost +hostname</path>。</p>

<warn>永遠不要使用 xhost + 這項功能！這將允許任何用戶端連線並取得您 X 的控制權。如果某個使用者可以得到您 X 的權限，他可以紀錄您的鍵擊並控制您的桌面。</warn>
<p>一個更安全的解決辦法是使用 <c>startx -- -nolisten tcp</c> 啟動 X 來完全關閉這項功能，或是經由修改設定檔中的這幾行指令以永遠地取消這項功能。</p>
<pre caption="/usr/X11R6/bin/startx">
defaultserverargs=""
</pre>
<p>改成</p>
<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>
<p>如果您使用圖形化登入管理員則您必須換個方法。</p>
<p>gdm (Gnome Display Manager)</p>
<p>變更：</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X
</pre>
<p>至</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>xdm (X Display Manager) 以及 kdm (Kde Display Manager)</p>

<p>變更</p>
<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X 
</pre>
<p>至</p>
<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>

<section>
<title>列印服務</title>
<body>

<section>
<title>Lpd</title>
<body>
<p>TODO</p>
</body>
</section>

<section>
<title>Pdq</title>
<body>
<p>http://pdq.sourceforge.net/</p>
<p>TODO</p>
</body>
</section>

</body>
</section>

<section>
<title>FTP</title>
<body>
<p>FTP (File Transfer Protocol - 檔案傳輸協定) 一般來說是個壞主意。它使用未編碼的資料，聽取兩個連接埠 (多半是埠號 20 以及 21)，支援匿名使用者，而且是某些攻擊者尋找的對象 (以便交換檔案)。如果您可以，請考慮改用 sftpd 或 http，因為 ftp 協定含蓋了幾個問題。如果您不能，則盡可能加強服務的安全性並且做好心理準備。</p>

<section>
<title>Pure-ftpd</title>
<body>
<p>Pure-ftpd 是原本 trollftpd 的一個分支。因為安全性的關係被 Frank Dennis 更改。</p>
<p>藉由啟動 AUTH 選項來使用虛擬使用者 (不使用系統帳戶)。將它設成 -lpuredb:/etc/pureftpd.pdb 並且使用 <path>/usr/bin/pure-pw</path> 建立您的使用者。</p>
<pre caption="/etc/conf.d/pure-ftpd">
## 全體最大同時連線數量，以及每個 IP 的 ##
## Number of simultaneous connections in total, and per ip ##
MAX_CONN="-c 30"
MAX_CONN_IP="-C 10"

## 如果分割區使用率超過以下數值則不允許上傳 ##
## Don't allow uploads if the partition is more full then this var ##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## 其他雜項 ##
## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>
<p>然後將您的 MISC_OTHER 改成不允許匿名使用者 (-E)、將所有人變更根目錄 (-A)、使用者不能讀取或寫入由 . (點) 開頭的檔案 (-X)、最大發呆時間 (-I)、限制循環 (-L)、以及一個合理的權限遮罩。並且 __不要__ 使用 -w 或 -W 選項！如果您想要有個破解工具交換中心，乾脆別份這篇文件！</p>
<p><uri>http://www.pureftpd.org</uri> 可以找到更多。</p>
</body>
</section>

<section>
<title>Proftpd</title>
<body>
<p>Proftpd 曾有過幾個安全性問題，不過大部份都已經解決了。還是作些補強：</p>
<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
# 不要顯示伺服器驗證字串
# Don't show the ident of the server
ServerIdent on "Go away"

# 讓建立虛擬使用者變比較簡單
# Makes it easier to create virtual users
RequireValidShell off

# 使用另外的密碼以及群組檔案 (passwd 使用 crypt 格式)
# Use alternative password and group file (passwd uses crypt format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# 檔案權限
# Permissions
Umask 077

# 逾時以及上限
# Timeouts and limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# 變更所有使用者的根目錄
# Chroot everyone
DefaultRoot ~

# 別用根 (root) 使用者執行
# don't run as root
User  nobody
Group nogroup

# 紀錄所有傳輸
# Log every transfer
TransferLog /var/log/transferlog

# globbing 問題
# Problems with globbing
DenyFilter \*.*/
</pre>
<p>剩下的掌握在您的手以及閱讀能力上 (<uri>http://www.proftpd.org</uri>)。</p>
</body>
</section>

<section>
<title>Vsftpd</title>
<body>
<p>Vsftpd (亦即 very secure ftp) 是個有合理的預設設定的 ftp 小惡魔 (daemon)。它很簡單，也沒有類似 pureftp 與 proftpd 的太多功能 (如虛擬使用者)。</p>
<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

# 禁止寫入
# read only
write_enable=NO

# 啟動傳輸紀錄
# enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>
<p>如您所見，沒辦法讓這項服務擁有獨立的權限，也沒有預設的變更目錄 (chroot) 動作。不過當它用來作匿名 ftp 伺服器的時候倒是蠻有用的。某些時候有個匿名 ftp 伺服器 (可以分享 Open Source 軟體) 也是不錯的，那麼這個伺服程式倒是剛好派上用場。</p>
</body>
</section>

</body>
</section>

<section>
<title>Apache</title>
<body>
<p>Apache (1.3.26) 會送您一份很得體的設定檔，不過，再一次的，我們還是要改進某些東西。例如鎖定同一位置以及避免它洩漏太多資訊。這些是您應該加在設定檔中的選項：</p>
<p>如果您有在安裝 apache 之前於 <path>/etc/make.conf</path> 中加入 ssl 支援，您應該有個支援 ssl 的伺服器。只要加入以下的設定來啟動它。</p>
<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>
<pre caption="/etc/apache/conf/apache.conf">
# 讓它聽取您的 ip
# Make it listen on your ip
Listen 127.0.0.1
BindAddress 127.0.0.1

# 在每個不用根 (root) 使用者執行的服務都使用 nobody 或 nogroup 並不是個好主意。
# (加入一位在 apache 群組的 apache 使用者)
# It is not a good idea to use nobody or nogroup for every service not running as root.
# (just add the user apache with group apache)
User apache
Group apache

# 避免 apache 透漏太多資訊
# Will keep apache from telling about the version
ServerSignature Off
ServerTokens min
</pre>
<p>Apache 是根據 --enable-shared=max 和 --enable-module=all 設定編譯的。這會預設地啟動所有模組，所以您必須自己將 LoadModule 區段 (LoadModule 和 AddModule) 中用不到的模組註解掉。執行 <c>/etc/init.d/apache restart</c> 來重新啟動您的網頁伺服器。</p>
<p>其他文件可以在 <uri>http://www.apache.org</uri> 找到。</p>
</body>
</section>

<section>
<title>電子郵件</title>
<body>


<section>
<title>Postfix</title>
<body>
TODO!
</body>
</section>

<section>
<title>Qmail</title>
<body>
<p>Qmail 是被公認為最安全的郵件伺服器。它是在 (極端的) 安全考量下寫成的。它預設不允許轉寄，而且自 1996 年以來從未有過安全性漏洞。簡單地 <c>emerge qmail</c> 然後去設定！</p>
</body>
</section>

</body>
</section>

<section>
<title>DNS</title>
<body>
<p>Gentoo 支援兩種不同的 dns 伺服器，Bind 和 djbdns。</p>

<section>
<title>Bind</title>
<body>
<p>Bind 以它的不容忽視的安全性歷史知名。如同其他所有服務，它 __永遠__ 不該以根 (root) 使用者權限執行，所以請不要變更預設的設定。Gentoo 預設是沒有任何設定，所以您必須自己在 <path>/etc/bind/named.conf</path> 加入您的區域 (zones)。畢竟安全並不只在伺服器小惡魔 (server daemon) 本身，同時也應該建立嚴格的通訊協定設定。</p>
<p>人們多半會問，為什麼不使用 djbdns (由 D.J. Bernstein 所寫非常安全的 dns)，而答案是：Bind 的確有 djbdns 沒有的功能，例如 IPv6 支援 (還是要套用修正檔啦)。</p>
<pre caption="/etc/bind/named.conf">
#setup access control
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
# 允許從 "mynet" 來的查詢
# allow "mynet" to make queries
  allow-query { "mynet"; };
# 不允許區域傳送
# don't allow zone transfers
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
# 只提供 "mynet" 遞迴服務
# Only provide recursive service to "mynet"
  recursion no;
  allow-recursion { mynet; };
# 鎖定在一個介面上
# Bind to an interface
  listen-on { 10.0.0.1; };
# 不要顯示版本
# Don't show the version
  version "Go away";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

# 有金鑰的本機才准控制
# allow only control from localhost and with a key
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>
<p>這是個預設的好設定。無論如何，Bind 第 9 版有個您該使用的 chroot 特異功能。以下告訴您怎樣建立您的 chrooted bind：</p>
<pre caption="準備假根目錄環境">
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>
<p>這會在 <path>/chroot</path> 建立一個假的根 (root) 目錄環境。現在我們所要作的只有更改起始命令稿另它支援新的環境。編輯 <path>/etc/init.d/named</path> 並在 start 函式中加入 <c>-t /chroot/dns</c>。您可能也想在 stop 函數中把正確的 pid 檔案指向 <path>/chroot/var/run/named/named.pid</path>。重新啟動您的 DNS 伺服器。</p>
<note>攻擊者可能逃出這個假的根目錄監牢，如果他夠厲害的話 (在核心修正檔小節查閱如何預防)</note>
<p>其他文件可以在 <uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software Consortium</uri> 找到。</p>
</body>
</section>

<section>
<title>Djbdns</title>
<body>
<p>關於 djbdns 實在也沒什麼好說的，除了作者甚至願意在它有多安全上<uri link="http://cr.yp.to/djbdns/guarantee.html">賭錢</uri>以外。所以試試看吧：<uri>http://www.djbdns.org/</uri>，它跟 Bind v.9 有很大的不同，不過您一定會抓到訣竅的！</p>
</body>
</section>

</body>
</section>

<section>
<title>Samba</title>
<body>
<p>Samba 是個與 Microsoft/Novell 網路共享檔案的通訊協定，並且它 __不該__ 被使用在 Internet 上。不管怎樣它也需要被提高安全性。</p>

<pre caption="/etc/samba/smb.conf">
[global]
  # 鎖定在一個介面
  # Bind to an interface
  interfaces = eth0 10.0.0.1/32

  # 確認使用編碼的密碼
  # Make sure to use encrypted password
  encrypt passwords = yes
  directory security mask = 0700

  # 允許存 10.0.0.* 來的通訊
  # allow traffic from 10.0.0.*
  hosts allow = 10.0.0.

  # 啟動使用者認證
  # (不要使用 share 模式)
  # Enables user authentication
  # (don't use the share mode)
  security = user

  # 不允許有特群的帳戶
  # Disallow privileged accounts
  invalid users = root @wheel

  # 加入磁碟使用限額
  # Add a max size of usage in kilobytes
  max disk size = 102400

  # 堅持密碼政策
  # Uphold the password policy
  min password length = 8
  null passwords = no

  # 使用 PAM (如果支援的話)
  # Use PAM (if added support)
  obey pam restrictions = yes
  pam password change = yes
</pre>
<p>確認每個分享的權限都設定正確，並仔細閱讀<uri link="http://www.samba.org">文件</uri>。</p>
<p>重新啟動伺服器，並加入應該存取這個服務的使用者。這個動作可以透過 <path>/usr/bin/smbpasswd</path> 以及 -a 參數來達成。</p>
</body>
</section>

<section>
<title>假的根目錄 (chroot) 或虛擬伺服器 (virtual servers)</title>
<body>
<p>將某個服務切換到假的跟目錄，是個將服務 (或使用者) 環境限制在他們只該存取的地方以及避免他們得到根 (root) 使用者的存取權或系統相關資料的好方法。經由以根使用者以外的使用者 (nobody、apache、named) 執行服務，攻擊者只能存取這些使用者有權存取的檔案。這表示攻擊者無法得到根 (root) 權限 - 即使這個服務程式有安全上的漏洞。</p>
<p>某些服務 (例如 pure-ftpd 以及 bind) 有變換根目錄 (chroot) 的功能，而其他的服務沒有。如果某個服務支援它，那就用吧！不然的話您可能得想個其他辦法。接下來看看該怎樣做出一個假的根目錄環境，以及初步了解它怎麼工作，我們會以 bash 來解釋 (講起來比較簡單)。</p>
<p>在 <path>/</path> 建立一個叫 chroot 的假根目錄 (<c>mkdir chroot</c>)。然後找出 bash 在編譯的時候使用的動態函式庫 (如果您以 -static 編譯則不必作這個動作)。</p>
<p>接下來的指令會建立一份有被 bash 使用到的函式庫清單。</p>
<pre caption="取得使用的函式庫清單">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>
<p>然後建立給 bash 使用的假根環境。</p>
<pre caption="建立 bash 的假根環境 (chroot-environment)">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>
<p>然後將 bash 使用到的檔案 (<path>/lib</path>) 複製至假根目錄的 lib 目錄，並將 bash 本身複製至假的 bin 目錄。這能建立一個完全一樣的環境，只不過功能少了點。在複製完後測試一下：<c>chroot /chroot/bash</c>。如果您有個寫著 <c>/</c> 的提示符號，就表示成功了！否則它應該會告訴您缺了什麼東西，某些共享函式庫也會用到其他共享函式庫的東西。</p>
<p>您會注意到，在這個假根環境中什麼事都不能作，除了 echo。這是因為我們沒有把其他指令放進這個假根環境，而 "echo" 指令剛好是 bash 的內建功能之一。</p>
<p>基本上這跟建立假根環境服務的步驟差不多，唯一的差別是有時候某些服務會使用到一些 <path>/etc</path> 下的設定或設備。簡單的把他們複製 (設備檔可以用 cp -a 複製) 到假根環境，然後編輯執行前的起始命令稿以啟用假的根目錄。找出服務使用到的設備或設定也許不簡單，這也是為什麼 <c>strace</c> 指令很方便的原因。使用 <path>/usr/bin/strace bash</path> 啟動服務，然後找出 open、read、stat、或 connect。這能給您一些關於需要複製檔案的線索。但是大部份的狀況下，只要複製 passwd 檔案 (改一下它的副本把用不到的使用者移除掉)、<path>/dev/zero</path>、<path>/dev/log</path> 和 <path>/dev/random</path>。</p>
<p>另一個建立更安全環境的方法是透過虛擬伺服環境 (virtual server environment)。這會建立一個虛擬的 Linux 環境並且將它啟動至虛擬模式 (virtual mode)。這表示如果某個伺服器被破壞了，真實的系統並不會被影響到，只會影響到虛擬的系統。</p>
<p>虛擬伺服器的例子：</p>
<ul>
  <li>
    <uri link="http://user-mode-linux.sourceforge.net">使用者模式 Linux (Usermode linux)</uri> 以及一篇關於 <a href="http://www.gentoo.org/doc/uml.html">user mode linux</a> 的 howto。
  </li>
  <li>
    <uri link="http://www.solucorp.qc.ca/miscprj/s_context.hc">虛擬私人伺服器 (Virtual private servers)</uri>
  </li>
</ul>

</body>
</section>

</chapter>

-- Securing Services end --

-- Firewalls --

<chapter>
<title>防火牆</title>

<section>
<title>一面防火牆</title>
<body>
<p>人們總是以為防火牆是終極的安全，其實他們錯了。大部份的狀況下，一面錯誤設定的防火牆還比根本沒有防火牆來得更糟。防火牆同時也是一種程式，也需要像其他服務一般對待它，因為它也跟其他程式一樣會出錯 (例如安全性漏洞)。</p>
<p>所以，蓋牆之前先考慮考慮！您真的有這個需要嗎？如果您覺得真的需要，則將它該怎麼工作以及誰應該管理它定義在政策中。</p>
<p>使用防火牆有兩種原因：</p>
<ul>
  <li>把使用者 (蟲╱攻擊者) 擋在外面</li>
  <li>把使用者 (員工╱小孩) 擋在裡面</li>
</ul>
<p>一般來說有三種基本型態的防火牆：</p>
<ul>
  <li>封包過濾 (Packet filtering)</li>
  <li>迴路轉接 (Circuit relay)</li>
  <li>應用層級閘道器 (Application gateway)</li>
</ul>
<p>防火牆應該是台專心防火的機器，沒有其他服務執行 (或者只跑一下 ssh)，並且依照這篇指南建議的方法加強安全性。</p>
</body>
</section>

<section>
<title>封包過濾 (Packet filtering)</title>
<body>
<p>所有網路的資料都是以封包 (packet) 的形式傳輸。大型的傳輸會為了處理簡單而被切割成小封包，到達目的地之後才重新被組合起來。所有的封包都內含它要去那裡以及應該怎樣送達。而這些資料也是封包過濾防火牆所使用的。過濾是基於這些資料：</p>
<ul>
  <li>基於封包的來源╱目的 IP 位置決定允許或駁回</li>
  <li>基於封包的來源╱目的埠口決定允許或駁回</li>
  <li>基於封包的通訊協定決定允許或駁回</li>
  <li>基於封包在通訊協定中的旗標決定允許或駁回</li>
</ul>
<p>基本上就是以封包的擋頭內的資料來過濾，而不是檢查封包的內容。</p>
<p>缺點：</p>
<ul>
  <li>封包中有關的位置的資訊可能是無效的，或是我們說<e>假裝</e>是傳送者 (<e>spoofed</e> to be sender)。</li>
  <li>允許通過的封包中可能包含我們不想要的資料或要求，這可能也允許攻擊者利用在防火牆上或防火牆後某項服務的已知漏洞。</li>
  <li>通常發生一點小問題就可以被攻破 (Usually single point of failure)</li>
</ul>
<p>優點：</p>
<ul>
  <li>架設簡單</li>
  <li>可以在攻擊真正發生之前給予警告 (經由埠口掃描偵測)</li>
  <li>在防止 SYN 攻擊上有很好的效果</li>
</ul>
<p>Linux 上一些免費封包過濾的例子：</p>
<ul>
  <li><uri link="http://www.iptables.org">Iptables</uri></li>
  <li><uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri></li>
  <li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>
</body>
</section>

<section>
<title>迴路轉接 (Circuit relay)</title>
<body>
<p>或稱為迴路級閘道器，是在允許交換資料之前驗證連線的防火牆。這表示它不只檢察封包的擋頭，還包括基於已設定的規則來驗證擋頭的資料是否屬實，在驗證成功之後。才會開啟連線階段並且允許資料交換。過濾是基於這些資料：</p>
<ul>
  <li>來源╱目的的位置</li>
  <li>來源╱目的的埠口</li>
  <li>一段時間</li>
  <li>通訊協定</li>
  <li>使用者</li>
  <li>密碼</li>
</ul>
<p>所有往來都會被驗證、監視，而沒被驗證或監視的往來則會被駁回。</p>
<p>缺點：</p>
<ul>
  <li>在傳輸層運作，而且需要變更提供相關傳輸功能的程式。</li>
</ul>
</body>
</section>

<section>
<title>應用層級閘道器 (Application gateway)</title>
<body>
<p>應用層級閘道器是其他程式的代理伺服器，代理它的用戶端來作資料交換。它以確認外界不會跟內部建立直接連線來確保非軍事區 (De-Militarized Zone) 或防火牆下游區域的安全。</p>
<ul>
  <li>基於來源來源╱目的決定允許或駁回</li>
  <li>基於封包的內容</li>
  <li>甚至可以在執行階段直接變更封包的內容</li>
  <li>基於檔案類型或延伸檔名限制檔案的存取。</li>
</ul>
<p>優點：</p>
<ul>
  <li>可以快取檔案，增進網路效能</li>
  <li>可以對所有連線作詳細的紀錄</li>
  <li>伸縮自如 (某些代理伺服器可以 "共享" 快取檔案)</li>
  <li>對外沒有直接連線</li>
</ul>
<p>缺點：</p>
<ul>
  <li>設定複雜</li>
</ul>
<p>應用層級閘道器是公認最安全的方案，由於它不用以跟使用者權限執行，也不用對整個網際網路公開。</p>
<p>應用層級閘道器的例子：</p>
<ul>
  <li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>
</body>
</section>

<section>
<title>Iptables</title>
<body>
<p>要讓 iptables 工作，它必須在核心被啟動。我將它加入成模組 (iptables 指令會視需要的時候載入它們) 然後重新編譯核心。在您將核心編譯完成之後 (或一邊編譯的時候)，您必須安裝 iptables 命令。簡單地 <c>emerge iptables</c> 然後應該就好了。</p>
<p>現在經由執行 <c>iptables -L</c> 來測試它是否能工作。如果失敗了，則可能有什麼東西弄錯了，而您可能得重新檢查一下設定檔。</p>
<p>Iptables 是個依照狀態過濾封包的 (stateful packet filter)，意即它比 ipchains (Linux 2.2 版) - 不是依照狀態的過濾器，提供更多的功能以及更高的安全性。您現在可能正在問 "什麼是狀態？它們有什麼不同？"</p>
<p>我們知道所有的 TCP 都是由一連串的封包組成的。每個封包都含有這些資訊：來源位置、目的位置、以及一個幫助重組資料的流水號。而我們也知道 TCP 是連線導向而 UDP 不是，對吧？這些就是它儲存的 "狀態"。現在您應該在問自己 "那又怎樣？"，別急，我正要接著說下去。</p>
<p>想像一下您有個無狀態 (stateless) 防火牆 (例如 ipchains) 而您不希望讓外部的電腦連線進入內部的伺服器，可是防火牆怎麼知道這個封包到底是不是某個已存在連線的一部份呢？無狀態防火牆 (stateless firewall) 無法從檢查 SYN 旗標來辨認封包屬於已經存在的連線或是想要建立新的連線！</p>
<p>我們假設某個攻擊者正在傳送某種手工的封包 (由攻擊者手動編輯的封包)，而他變更了 SYN 旗標或其他任何旗標。這是攻擊者常作的事情。直接傳送封包進入防火牆變更路由表，或破壞防火牆上執行的那些本來應該被保護的服務。狀態式的防火牆會持續追蹤所有連線，而且可以簡單的偵測到想要假裝成某個連線的一部份混進來的封包。當一個連線，聲稱是某個既有連線的一部份可是卻被發現是無效的，則很可能會被拋棄掉。這也可以防止 "隱密偵查" 的可能性，因為這些連線是無效的。</p>
<p>我應該還可以舉出一打其他的例子，不過我想您已經知道我在說什麼了 - 簡單的規則 => 小型防火牆 => 管理簡單！</p>
<p>Iptables 還提供一些其他的功能，例如流量限制。這個功能在防止類似 SYN 攻擊這種阻斷服務攻擊 (DoS - Denail of Service) 的時候超有用的。那麼，什麼是 SYN 攻擊？</p>
<p>再次的... 我們建立一個 TCP 連線，它使用一個三通道的確認來建立連線，就像這樣：</p>
<fig link="http://www.ibiblio.org/pub/Linux/distributions/gentoo/images/synack.jpg" short="Three-way handshake"/>
<p>所謂 SYN 攻擊，就是只傳送 SYN 封包 (檔頭只有 SYN 旗標的封包)，而不繼續理會下面兩個建立連線的封包。一個 SYN 封包並不用包含有效的傳送者位置 (IP) 因為它不需要回覆。所以這個連線會一直開起直到逾時為止。現在，某個攻擊者丟給您一拖拉庫包含無效傳送者 IP 的 SYN 封包，您的電腦將持續等待永遠等不到的回應。基於您系統的逾時設定，這個連線會持續 30-60 秒 (也許更久)。直到可以使用的連線數目全部被用完，而您的電腦將無法跟任何其他機器通訊。</p>
<p>這就是為什麼流量限制好用的原因。它可以使用 <c>-m limit --limit 1/s</c> 來限制單一來源的 SYN 封包。這將把 SYN 封包限制在一個來源只有一個，以制止大量的 SYN 封包將資源淹沒掉。</p>
<p>現在！一些實用的東西！</p>
<p>當 iptables 載入您的核心鐘之後，則有五個鉤子可以掛您的規則。它們叫做 INPUT、OUTPUT、FORWARD、PREROUTING 以及 POSTROUTING。這些清單叫做串鍵 (chains) 因為它依照您加入規則的順序檢查封包，而走到某個規則的時候，這個規則決定丟棄這個封包，則這個封包就會直接被丟棄，下面的規則也不會被執行。</p>
<p>您可以將規則加入至五個主要串鍵，或建立您自己的串鍵然後加入至主串鍵中。讓我們看看這怎麼做到的！</p>

<table border="0">
  <tr>
    <th>選項：</th><th>說明：</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>增加 (Append)</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>刪除 (Delete)</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>插入 (Insert)</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>取代 (Replace)</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>清單 (List)</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>將某串鍵或所有串鍵中的規則刪除</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>將某串鍵或所有串鍵的計數器設為零</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>在串列上測試這個封包</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>建立一個新的使用者定義的串鍵</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>移除某個使用者定義的串鍵</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>改變某串鍵的政策</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>改變串鍵名稱</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>通訊協定</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>來源位置╱遮罩</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>目的地位置╱遮罩</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>輸入裝置 (網路裝置名稱)</ti>
  <tr>
  </tr>
    <ti>-o</ti><ti>輸出裝置 (網路裝置名稱)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>跳至 (規則的目標)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>延伸比較 (可能使用附加模組)</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>以數字型態列出位置和埠口</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>指定要操縱的列表</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>吵雜模式 (Verbose mode)</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>展開數字 (顯示確切的數值)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>只符合第二或以後的片段</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>列出 iptables 的版本</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>在列出清單的時候顯示行號</ti>
  </tr>
</table>
<p>首先我們試著擋住所有來到我們機器的 ICMP 封包，熟悉一下 iptables 指令的用法。</p>

<pre caption="阻擋所有 ICMP 封包">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>
<p>一開始我們指定想要新增的串鍵，接著指定協定，再來是規則。規則可以是 ACCEPT、DROP、REJECT、LOG、QUEUE、MASQUERADE、載入的模組、或使用者定義的串鍵。在這個案例裡我們使用 DROP，它將在不回覆用戶端的狀況下丟棄這個封包。</p>
<p>現在我們試著 <c>ping localhost</c>。您將無法獲得任何回應，因為我們將所有的來到這台電腦的 ICMP 封包都阻擋起來了。它也讓您無法 ping 其他電腦，因為傳送回來的 ICMP 回應封包也會被擋住。現在清乾淨您的串鍵，讓 ICMP 再次工作。</p>
<pre caption="清空所有規則">
# <i>iptables -F</i>
</pre>
<p>現在我們看看 iptables 使用狀態的部份。如果我們想要檢查從 eth0 進入的封包狀態，我們可以這樣作：</p>
<pre caption="允許來自已經建立連線的封包">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>
<p>這將允許所有已經連線或相關於 INPUT 串鍵的封包。而您可以將不存在狀態列表的封包使用以下方法丟棄：<c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c>。這經由載入加強功能來啟動 iptables 的狀態控制部份。如果您想要外界可以連線至您的電腦，您可以使用 <c>--state NEW</c>。Iptables 包含一些不同意圖的模組，這裡列出一部份：</p>
<table border="0">
  <tr>
    <th>模組╱符合</th><th>敘述</th><th>延伸選項</th>
  </tr>
  <tr>
    <ti>mac</ti><ti>符合進入封包的硬體位置</ti><ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti><ti>啟動狀態檢查</ti><ti>--state (狀態有 ESTABLISHED、RELATED、INVALID、NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti><ti>流量限制控制</ti><ti>--limit、--limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti><ti>試圖符合多方面的封包建立者的特性</ti><ti>--uid-owner userid、--gid-owner groupid、--pid-owner processid、--sid-owner sessionid</ti>
  </tr>
  <tr>
    <ti>unclean</ti><ti>隨機的檢查</ti><ti/>
  </tr>
</table>
<p>讓我們試著建立一個使用者定義串鍵並將它套用至某個已經存在的傳鍵：</p>
<pre caption="建立使用者定義串鍵">
<codenote>建立一個只有一項規則的新串鍵</codenote>
<codenote>Create a new chain with one rule</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>預設的政策是所有出去的傳輸都許可，進來的則忽略。</codenote>
<codenote>The default policy is all outgoing traffic is allowed. Incoming is dropped.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>將它加入至 INPUT 串鍵</codenote>
<codenote>And add it to the INPUT chain</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>
<p>經由在 INPUT 串鍵套用這個規則，我們得到一個政策：所有出去的傳輸都許可，進來的除非已經建立連線否則忽略。一般來說這是個爛主意。預設的政策應該是丟棄，但是這是個只是個例子。</p>
<p>如果您想要更多文件，請參閱 <uri link="http://www.iptables.org/documentation/index.html#HOWTO">iptables documentation</uri>。</p>
<p>讓我們看一些真正的例子。在這個例子裡我的防火牆╱閘道器指示：</p>
<ul>
  <li>只允許 SSH (埠口 22) 連線至防火牆。</li>
  <li>內部網路應該有權使用 HTTP、HTTPS 以及 SSH (DNS 應該也被允許)。</li>
  <li>包含大量負載的 ICMP 傳輸會被拒絕。當然我們必須允許一些 ICMP 傳輸。</li>
  <li>應該能偵測到埠口掃描然後記錄下來。</li>
  <li>防止 SYN 攻擊。</li>
  <li>其他任何傳輸應該被忽略並記錄。</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
# 內部
# inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
# 外部
# outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # 預設規則
  # default rule
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  # ICMP 傳輸
  # ICMP traffic
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # 進來的傳輸
  # Incoming traffic
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -p tcp --dport ssh -j ACCEPT

  # 向外的傳輸
  # outgoing traffic
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # 偵測掃描埠口的傢伙
  # Catch portscanners
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # 在串鍵套用以及增加無效的狀態
  # Apply and add invalid states to the chains
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # 允許用戶端可以經由 NAT (Network Address Translation - 網路位置轉譯) 通過路由
  # Allow client to route through via NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage：$0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status"
}
</pre>
<note>為了比較好念，我將某些行分段了。在實際使用的設定鐘將這些分段的行組合回去也許是個好主意。您可以從<uri link="firewall.gz">這裡</uri>得到它。</note>
<p>一些建立防火牆的忠告：</p>
<ol>
  <li>在實際建立防火牆之前先擬定政策</li>
  <li>盡量讓它簡單</li>
  <li>了解通訊協定到底怎麼工作 (閱讀 <a href="http://www.ietf.org/">RFC (Request For Comments)</a>)</li>
  <li>永遠記得，防火牆只是另外一個以根 (root) 使用者執行的程式。</li>
  <li>測試您的防火牆</li>
</ol>
<p>如果您覺得 iptables 很難以了解或是要花太多時間設定一個得體的防火牆，您可以使用 <uri link="http://www.shorewall.net">Shorewall</uri>。它基本上使用 iptables 來建立防火牆規則，不過著重於規則而不是特定的通訊協定。</p>
</body>
</section>

<section>
<title>Squid</title>
<body>
<p>Squit 是一套非常強大的代理伺服器，它可以當過濾器，基於：時間、正規表示式的路徑╱資源位置、來源和目的 IP 位置、網域、瀏覽器、認證的使用者、資料類型以及埠口 (通訊協定) 來允許或拒絕傳輸。我很有可能忘記了一些其他功能，不過要記住整個功能列表不是件容易的事。</p>
<p>以下的例子中, 我只用了廣告過濾而不是基於色情網站過濾。原因呢，因為 Gentoo.org <c>不應該</c>被放進色情網站清單裡。而我又不想花時間幫您搜尋色情網站。</p>
<p>在這個案例，我的政策指出：</p>
<ul>
  <li>在工作時間 (星期一至星期五的八點至十七點以及星期六的八點至十三點) 上網 (HTTP/HTTPS) 是被允許的。如果他們遲到了，他們應該工作，不是上網。</li>
  <li>不准下載檔案 (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg... 諸如此類)</li>
  <li>我們不喜歡廣告，所以我們將它換成一個透明的 gif 檔案 (這裡就是您應該發揮的地方！)</li>
  <li>任何其他連進來或連出去的連線都不被允許</li>
</ul>
<p>這由四步 "簡單" 的動作就能達成</p>
<pre caption="/etc/squid/squid.conf">
# 鎖定在一個 IP 以及埠口
# Bind to a ip and port
http_port 10.0.2.1:3128

# 標準設定
# Standard configuration
hierarchy_stoplist cgi-bin ？
acl QUERY urlpath_regex cgi-bin \？
no_cache deny QUERY

# 建立基本存取控制列表
# Add basic access control lists
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# 加入可以使用這台代理伺服器的人
# Add who can access this proxy server
acl localnet src 10.0.0.0/255.255.0.0

# 以及埠口
# And ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# 建立基於網址內的正規表示式的存取控制列表
# Add access control list based on regular
# expressions within urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# 建立基於時間和日期的存取控制列表
# Add access control list based on time and day
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# 允許管理者從本機存取
# allow manager access from localhost
http_access allow manager localhost
http_access deny manager

# 只允許從本機來的清除要求
# Only allow purge requests from localhost
http_access allow purge localhost
http_access deny purge

# 不允許從不明埠口來的連線
# Deny requests to unknown ports
http_access deny !Safe_ports

# 不允許從非 SSL 埠口進來的連線
# Deny CONNECT to other than SSL ports
http_access deny CONNECT !SSL_ports

# 我自己的規則
# My own rules

# 加入用來取代廣告的網頁
# Add a page do be displayed when
# a banner is removed
deny_info NOTE_ADS_FILTERED url_ads

# 然後拒絕它們
# Then deny them
http_access deny url_ads

# 拒絕所有看起來像用來下載的檔案
# Deny all archives
http_access deny archives

# 強制工作時間存取
# Restrict access to work hours
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# 拒絕其他一切的一切
# Deny the rest
http_access deny all
</pre>
<p>接著填入您不想使用者下載的檔案。我放了加入了 zip、viv、exe、mp3、rar、ace、avi、mov、mpg、mpeg、au、ra、arj、tar、gz 和 z 檔案。</p>
<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>
<note>請記得在 [] 內填入包含大寫以及小寫的字元。這是為了確定沒有人可以用存取 AvI 而不是 avi 的方法來欺騙您的代理伺服器。</note>
<p>接下來，我們將使用正規表示式來驗證廣告。您應該比我更有創造力才是：</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>
<p>最後的一步，我希望這個檔案會在移除廣告的時候被顯示。它基本上是半個有張 4x4 透明 gif 圖案的 html。</p>
<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>
<note>不要關閉 &lt;HTML&gt; &lt;BODY&gt; 標籤。Squid 會幫你把它關上。</note>
<p>如您所見，Squid 有很大的可能性，而且在代理伺服和過濾上都很有您還可以使用可選擇的 Squid 伺服器來服務一個非常大型的網路。我在這裡列出的設定是適合 1~20 人的小型網路的。</p>
<p>可是結合封包過濾器 (iptables) 以及應用層級閘道器 (squid) 大概是最好的解決方案，即使 squid 是位於某個安全而沒有人可以從外部入侵的位置，我們還是要考慮從內部滲透的攻擊者。</p>
<p>現在您必須在用戶端的瀏覽器加入代理伺服器的位置。這個閘道器會防止使用者對外連線，除非他們透過代理伺服器。</p>
<note>在 Mozilla 中，這個選項在 Edit->Preferences->Advanced->Proxies。</note>
<p>您也可以用 iptables 來將所有對外的連線透明的轉送至 Squid 代理伺服器。在您的閘道器上加入以下規則可以做到：</p>
<pre caption="將埠口轉送至我們的代理伺服器">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>
</body>
</section>

<section>
<title>現在，我們學到了什麼？</title>
<body>
<p>我們學到了：</p>
<ol>
  <li>防火牆本身也是個風險。一面設定不良的防火牆比根本沒有防火牆來得更糟。</li>
  <li>如何建立基本的閘道器以及隱形代理伺服器。</li>
  <li>建立好防火牆的關鍵在於您了解您想要開放的通訊協定。</li>
  <li>IP 傳輸並不總是攜帶了正當的資料。舉個例，大量的 ICMP 封包。</li>
  <li>如何防止 SYN 攻擊。</li>
  <li>藉由過濾 HTTP 傳輸來防止討厭的圖片以及避免下載到病毒。</li>
  <li>混用封包過濾器以及應用層級閘道器可以更完美的控制權限。</li>
</ol>
<p>現在，如果您<b>真的</b>覺得需要，去蓋一面符合您需求的防火牆吧！</p>
</body>
</section>

</chapter>

-- Intrusion detection start --

<chapter>
<title>入侵偵測</title>

<section>
<title>Aide (進階入侵偵測環境 - Advanced Intrusion Detection Environment)</title>
<body>
<p>Aide 是主機導向 (host based) 的入侵偵測系統 (Tripwire 之外的另一個免費選擇)。如果您已經了解 Tripwire，那在了解 Aide 的設定檔上應該不會有太大的障礙。</p>
<p>設定檔是基於套用在檔案以及目錄上的標準表示式、巨集以及規則。我們有以下的巨集：</p>

<table borlder="0">
  <tr>
    <th>巨集</th><th>敘述</th><th>語法</th>
  </tr>
  <tr>
    <ti>ifdef</ti><ti>如果定義了 (If definded)</ti><ti>@@ifdef "name"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti><ti>如果沒有定義 (If not defined)</ti><ti>@@ifndef "name"</ti>
  </tr>
  <tr>
    <ti>define</ti><ti>定義一個變數</ti><ti>@@define "name" "value"</ti>
  </tr>
  <tr>
    <ti>undef</ti><ti>取消定義一個變數</ti><ti>@@undef "name"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti><ti>如果 "站台名稱"</ti><ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti><ti>如果沒有 "站台名稱"</ti><ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
    <ti>endif</ti><ti>endif 一定要在以上的巨集之後出現，除了 define 和 undef</ti><ti>@@endif</ti>
  </tr>
</table>
<p>這些巨集在您有一台以上的 Gentoo 電腦而您又希望在他們全部上面都使用 Aide 的時候會變得很方便。畢竟不是所有機器都執行同樣的服務或擁有同樣的使用者。</p>
<p>接下來我們有一套旗標，用以檢查檔案或目錄。這些是檔案權限、檔案內容、以及編碼雜湊╱校驗值。</p>
<table border="0">
  <tr>
    <th>旗標</th><th>敘述</th>
  </tr>
  <tr>
    <ti>p</ti><ti>權限 (permissions)</ti>
  </tr>
  <tr>
    <ti>i</ti><ti>inode</ti>
  </tr>
  <tr>
    <ti>n</ti><ti>連結數 (number of links)</ti>
  </tr>
  <tr>
    <ti>u</ti><ti>使用者 (user)</ti>
  </tr>
  <tr>
    <ti>g</ti><ti>群組 (group)</ti>
  </tr>
  <tr>
    <ti>s</ti><ti>大小 (size)</ti>
  </tr>
  <tr>
    <ti>b</ti><ti>block count</ti>
  </tr>
  <tr>
    <ti>m</ti><ti>mtime</ti>
  </tr>
  <tr>
    <ti>a</ti><ti>atime</ti>
  </tr>
  <tr>
    <ti>c</ti><ti>ctime</ti>
  </tr>
  <tr>
    <ti>S</ti><ti>檢查變更的大小</ti>
  </tr>
  <tr>
    <ti>md5</ti><ti>md5 雜湊</ti>
  </tr>
  <tr>
    <ti>sha1</ti><ti>sha1 雜湊</ti>
  </tr>
  <tr>
    <ti>rmd160</ti><ti>rmd160 雜湊</ti>
  </tr>
  <tr>
    <ti>tiger</ti><ti>tiger 雜湊</ti>
  </tr>
  <tr>
    <ti>R</ti><ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
    <ti>L</ti><ti>p+i+n+u+g</ti>
  </tr>
  <tr>
    <ti>E</ti><ti>清空群組</ti>
  </tr>
  <tr>
    <ti>&gt;</ti><ti>以 p+u+g+i+n+S 格式紀錄</ti>
  </tr>
</table>
<p>如果 Aide 是編譯成有 mhash 支援，那麼它還有其他幾個旗標：</p>
<table border="0">
  <tr>
    <th>旗標</th><th>敘述</th>
  </tr>
  <tr>
    <ti>haval</ti><ti>haval 雜湊</ti>
  </tr>
  <tr>
    <ti>gost</ti><ti>gost 雜湊</ti>
  </tr>
  <tr>
    <ti>crc32</ti><ti>crc32 雜湊</ti>
  </tr>
</table>
<p>接著，您可以藉由這樣混合旗標來建立您自己的規則：</p>
<pre caption="建立 AIDE 的規則集">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>
<p>建立我們自己的設定檔的最後一個步驟就是決定要怎樣在檔案或目錄上套用規則。基本上您只要用鍵盤敲進規則以及檔名或目錄名就可以了。Aide 會遞迴的加入所有的檔案，除非您指定了其他的什麼東西。</p>
<table border="0">
  <tr>
    <th>旗標</th><th>敘述</th>
  </tr>
  <tr>
    <ti>!</ti><ti>不要加入這個檔案或目錄</ti>
  </tr>
  <tr>
    <ti>=</ti><ti>加入這個目錄，不過不要遞迴處理。</ti>
  </tr>
</table>
<p>最後讓我們看看詳細的設定。</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# 要讀取的資料庫的位置
# The location of the database to be read.
database=file:@@{AIDEDIR}/aide.db

# 要寫入的資料庫的位置
# The location of the database to be written.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# 規則的定義
# Rule definition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>
<p>在以上的例子，我們使用巨集來指定最高層的目錄以及 Aide 的主目錄。Aide 在檢查檔案完整性的時候使用 <path>/etc/aide/aide.db</path> 資料庫，可是在更新或建立新檔案的時候它將資訊存入 <path>/etc/aide/aide.db.new</path> 資料庫，這是為了確保它不會自動覆蓋舊的資料庫檔案。而 report_url 這個選項是個 "未來" 的功能，現階段還沒有任何意義。不過作者的打算是要讓它可以傳送電子郵件或甚至執行命令稿。</p>
<p>在您建立您的設定檔以後您應該使用 aide -i 來建立資料庫，並且將檔案 <path>/etc/aide/aide.db.new</path> 複製到 <path>/etc/aide/aide.db</path>，然後使用 root 執行 crontab -e 再輸入以下程式碼以將檢查加入至排程好定期執行。</p>
<note>基於您的 CPU、磁碟效能以及設定的旗標，這可能會耗費一點時間。</note>

<pre caption="將 Aide 加入工作排程">
0 3   * * * /usr/bin/aide -u
</pre>
<note>請記得要設定根 (root) 使用者的郵件。不然您將永遠不知道 Aide 報告了什麼。</note>
<p>在這個例子裡它每天下午三點會執行一次，這是因為我不想在上班時間打攪我的使用者。注意我使用 -u (更新) 選項而不是 -C (檢查)。畢竟 -u 也檢查檔案並且不會覆蓋原來的資料庫檔案，這將節省一些時間，例如在它偵測到變動的時候您只需要複製一個檔案。簡單的檢查這些變更，看看是不是您更動這些檔案的，或是某些攻擊者在您之前更動了這些檔案！</p>
<p>現在把資料檔存在本機上還有個問題。某些攻擊者會 (如果他們知道您安裝了 Aide) 想辦法編輯資料庫檔案、更新資料庫檔案或編輯 <path>/usr/bin/aide</path>。所以您應該將這些資料檔的副本以及 Aide 的執行檔複製到 CD 或其他媒體上。</p>
<p>更多資訊可以在 <uri link="http://www.cs.tut.fi/~rammer/aide.html">aide's</uri> 找到。</p>
</body>
</section>

<section>
<title>Snort</title>
<body>
<pre caption="將 snort 使用者加入至系統">
# user add snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>
<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CO NF=/etc/snort/snort.Cong
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>
<pre caption="/etc/snort/snort.conf">
<codenote>第一步</codenote>
<codenote>Step 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>第二步</codenote>
<codenote>Step 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>第三步</codenote>
<codenote>Step 3</codenote>
include classification.config

<codenote>第四步</codenote>
<codenote>Step 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>
<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# 新的分類
# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>
<p>更多資訊可以在 <uri link="http://www.snort.org">Snorts</uri> 網站找到。</p>
</body>
</section>

</chapter>

-- Intrusion detection end --

<chapter>
<title>新版所作的改變</title>
<section>
<title>改變</title>
<body>

<p>
Version 0.1 -> 0.2
</p>
<ul>
  <li>更正許多由不同的人找到的錯字 (大部份是 Bjarke Sørensen)</li>
  <li>繫緊 apache.conf 的設定 (ServerTokens min)</li>
  <li>修正超過 80 字寬的預先標籤 (pre-tag)</li>
  <li>加入了關於防火牆的章節</li>
</ul>

<p>
Version 0.2 -> 0.4
</p>
<ul>
  <li>加入了關於入侵偵測的章節</li>
  <li>修正了防火牆命令稿中的一個錯誤</li>
</ul>
</body>
</section>
</chapter>

<chapter>
<title>常見問題 (FAQ)</title>

<section>
<title>問題與解答</title>
<body>

<table border="0">
  <tr>
    <th>問題</th><th>解答</th>
  </tr>
  <tr>
    <ti>我可以在那裡找到這份指南的最新版？</ti><ti>最新版應該可以在 <uri>http://gentoo.org</uri> 見到，而開發中的版本則在 <uri>http://gentoo.insecurity.dk</uri>。</ti>
  </tr>
</table>

</body>
</section>
</chapter>

</guide>
