<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/lt/handbook/hb-working-rcscripts.xml,v 1.1 2006/07/16 09:24:58 neysx Exp $ -->

<sections>

<version>1.21</version>
<date>2005-05-29</date>

<section>
<title>Paleidžiamieji lygiai (Runlevels)</title>
<subsection>
<title>Užkrauname jūsų sistemą</title>
<body>

<p>
Kai užkrausite savo sistemą, pastebėsite, kad daug teksto prabėga pro ekraną.
Jei atkreipsite dėmesį, tas tekstas yra daugmaž vienodas kiekvieną kartą
užsikraunant sistemai. Visų šitų veiksmų eilės tvarka vadinimas <e>krovimosi
tvarka</e> ir yra (mažiau daugiau) statiškai nustatyta.
</p>

<p>
Pirmiausia, jūsų sistemos paleidyklė (boot loader) užkraus branduolio atvaizdą,
kurį jūs aprašėte paleidyklės nustatymuose, į atmintį, po kurio ji praneš
procesoriui (CPU) paleisti patį branduolį. Kai branduolys yra paleistas ir
veikia, jis inicijuoja visas branduolio specifines struktūras, užduotis ir
paleidžia <c>init</c> procesą.
</p>

<p>
Šitas procesas užtikrina, kad visos rinkmenų sistemos, kurios yra apibrėžtos
rinkmenoje <path>/etc/fstab</path>, bus prijungtos ir paruoštos naudojimui.
Tada jis paleidžia keletą skriptų, kurie yra <path>/etc/init.d</path> kataloge.
Šie skriptai paleis servisus, kurie yra būtini sėkmingam sistemos užsikrovimui.
</p>

<p>
Pagaliau, kai visi skriptai yra paleisti, <c>init</c> aktyvuoja terminalus
(dažniausiai tik virtualias komandines eilutes, kurios yra paslėptos po
klavišų kombinacijomis <c>Alt-F1</c>, <c>Alt-F2</c>, ir t.t.) prijungiant
specialų procesą, pavadintą <c>agetty</c> prie jo. Šis procesas užtikrins, kad
jūs galėsite prisijungti per šiuos terminalus paleisdami <c>login</c>.
</p>

</body>
</subsection>
<subsection>
<title>Init skriptai</title>
<body>

<p>
Dabar <c>init</c> nepaleidinėja atsitiktinai skriptų iš katalogo
<path>/etc/init.d</path>. Dar daugiau, jis nepaleidžia visų skriptų, kurie yra
kataloge <path>/etc/init.d</path>, o tik tuos skriptus, kurie jam yra nurodyti,
kad būtų paleisti. Jis nusprendžia, kuriuos skriptus paleisti, žiūrėdamas į
katalogą <path>/etc/runlevels</path>.
</p>

<p>
Pirmiausia, <c>init</c> paleidžia visus skriptus iš katalogo
<path>/etc/init.d</path>, kurie turi simbolines nuorodas
<path>/etc/runlevels/boot</path> kataloge. Dažniausiai paleidinės skriptus
abėcėlės tvarka, bet kai kurie skriptai turi informaciją apie priklausomumą,
kuris pasako sistemai, kad kitas skriptas turi būti pirmiau paleistas, negu bus
pradėtas šitas.
</p>

<p>
Kai visi kataloge <path>/etc/runlevels/boot</path> nukreipiamieji skriptai yra
paleisti, <c>init</c> tęsia paleidinėdamas skriptus, kurie turi simbolines
nuorodas į save, kataloge <path>/etc/runlevels/default</path>. Vėlgi bus
paleidinėjami abėcėlės tvarka, nebent priklausomumo informacija nusakys kitokią
paleidžiamų skriptų tvarką, kad būtų užtikrintas nuoseklus sistemos
paleidimas. 
</p>

</body>
</subsection>
<subsection>
<title>Kaip init veikia</title>
<body>

<p>
Aišku, <c>init</c> nenusprendžia visko pats. Jam reikia nustatymų rinkmenos,
kuri nusakytų, kokie veiksmai turi būti atlikti. Šie nustatymai bus saugomi
rinkmenoje <path>/etc/inittab</path>.
</p>

<p>
Jeigu jūs prisimenate krovimosi tvarką, kurią mes ką tik apibūdinome, jūs
tikriausiai prisiminsite, kad <c>init</c> pirmas veiksmas yra prijungti visas
rinkmenų išdėstymo sistemas. Tai yra aprašyta šioje pateiktoje eilutėje iš
<path>/etc/inittab</path> rinkmenos:
</p>

<pre caption="Sistemos inicializavimo eilutė rinkmenoje /etc/inittab">
si::sysinit:/sbin/rc sysinit
</pre>

<p>
Ši eilutė nusako, kad <c>init</c> turi paleisti <c>/sbin/rc sysinit</c>,
norėdamas inicializuoti sistemą. Skriptas <path>/sbin/rc</path> yra atsakingas
už inicijavimą, todėl jūs galite sakyti, kad <c>init</c> nedaro daug - jis
paprasčiausiai pateikia sistemos inicijavimo užduotį kitam procesui.
</p>

<p>
Antra, <c>init</c> paleidžia visus skriptus, kurie turi simbolines nuorodas į
save, kataloge <path>/etc/runlevels/boot</path>. Tai aprašome žemiau pateiktoje
eilutėje:
</p>

<pre caption="Sistemos inicijavimas, paleidimas">
rc::bootwait:/sbin/rc boot
</pre>

<p>
Vėlgi, <c>rc</c> skriptas atlieka reikalingus veiksmus. Pastebėtina, kad
parametras nurodytas <c>rc</c> (<e>boot</e>) sutampa su naudojamo katalogo
vardu, kuris yra <path>/etc/runlevels</path>.
</p>

<p>
Dabar <c>init</c> patikrina savo nustatymų rinkmeną, kad pažiūrėtų, kurį
<e>runlevel</e> turi paleisti. Kad tai nuspręstų, jis nuskaito žemiau pateiktą
eilutę iš rinkmenos <path>/etc/inittab</path>:
</p>

<pre caption="Pagrindinė init eilutė">
id:3:initdefault:
</pre>

<p>
Šiuo atveju, kurį didžioji dalis Gentoo vartotojų naudos, <e>paleidžiamojo
lygio</e> numeris yra yra 3. Naudodamas šią informaciją, <c>init</c> patikrina,
ką turi paleisti pradėdamas pereiti į <e>trečią paleidžiamąjį lygį</e>:
</p>

<pre caption="Paleidžiamųjų lygių apibrėžimai">
l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre>

<p>
Eilutė, apibrėžianti 3 lygį, vėlgi, servisų naudoja <c>rc</c> skriptą (dabar su
parametru <e>default</e>). Pastaba, kad <c>rc</c> parametras yra toks pats kaip
ir katalogo, esančio <path>/etc/runlevels</path>, vardas.
</p>

<p>
Kai <c>rc</c> pabaigia vykdyti, <c>init</c> nusprendžia kokias virtualias
konsoles jis turi aktyvuoti ir kokias komandas paleisti kiekvienoje iš jų:
</p>

<pre caption="Virtualių konsolių apibrėžimai">
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre>


</body>
</subsection>
<subsection>
<title>Kas yra paleidžiamieji lygiai?</title>
<body>

<p>
Jūs tikriausiai pastebėjote, kad <c>init</c> naudoja numeravimą, kad žinotų,
kokį <e>paleidžiamąjį lygį</e> turėtų aktyvuoti. <e>Paleidžiamasis lygis</e>
yra toks lygis, kuriame jūsų sistema turi ir vykdo tam tikrus skriptus
(paleidžiamojo lygio skriptus, arba <e>init skriptus</e>), kurie yra
paleidžiami, kai jūs patenkate arba išeinate iš tam tikro paleidžiamojo lygio.
</p>

<p>
Gentoo sistemoje yra septyni paleidžiamieji lygiai: trys vidiniai ir keturi
vartotojo apibrėžti paleidžiamieji lygiai. Vidiniai paleidžiamieji lygiai yra
<e>sysinit</e>, <e>shutdown</e> ir <e>reboot</e>. Jie atlieka būtent
tai, ką jų pavadinimai nusako: inicijuoja sistemą, išjungia sistemą ir
perkrauna sistemą.
</p>

<p>
Vartotojo apibrėžti paleidžiamieji lygiai yra tie, kurie yra
<path>/etc/runlevels</path> kataloge: <path>boot</path>, <path>default</path>,
<path>nonetwork</path> ir <path>single</path>. <path>boot</path> paleidžiamasis
lygis paleidžia visus sistemai būtinus servisus, kuriuos naudos kiti
paleidžiamieji lygiai. Trys paleidžiamieji lygiai skiriasi tuo, kokiuose
servisuose yra paleidžiami: <path>default</path> yra naudojama kiekvienos
dienos operacijoms, <path>nonetwork</path> yra naudojama, jei nereikalinga
tinklo prieiga, ir <path>single</path> yra naudojama, kada jums reikia
pataisyti sistemą.
</p>

</body>
</subsection>
<subsection>
<title>Dirbame su Init skriptais</title>
<body>

<p>
Skriptai, kuriuose paleidžia <c>rc</c> procesas, yra vadinami <e>init
skriptais</e>. Kiekvienas skriptas kataloge <path>/etc/init.d</path> gali būti
paleistas su parametrais <e>start</e>, <e>stop</e>, <e>restart</e>,
<e>pause</e>, <e>zap</e>, <e>status</e>, <e>ineed</e>, <e>iuse</e>,
<e>needsme</e>, <e>usesme</e> arba <e>broken</e>.
</p>

<p>
Norėdami paleisti, sustabdyti arba perleisti servisą (ir visus priklausomus nuo
jo servisus), jums reikia paleisti su parametrais <c>start</c>, <c>stop</c> ir
<c>restart</c>:
</p>

<pre caption="Paleidžiame Postfix">
# <i>/etc/init.d/postfix start</i>
</pre>

<note>
Tik tai servisai, kurie yra <e>priklausomi</e> nuo pagrindinio serviso yra
sustabdomi arba perleidžiami. Kiti priklausomi servisai, kurie <e>naudoja</e>
pagrindinį servisą, bet nėra būtini, yra neliečiami.
</note>

<p>
Jeigu jūs norite sustabdyti servisą, bet ne servisus kurie priklauso nuo jo,
jūs galite naudoti parametrą <c>pause</c>:
</p>

<pre caption="Sustabdome Postfix, bet paliekame priklausomus servizus
paleistus">
# <i>/etc/init.d/postfix pause</i>
</pre>

<p>
Jeigu jūs norite pamatyti, kokioje būklėje yra servisas (paleistas, išjungtas,
sustabdytas, ...), galite naudoti parametrą <c>status</c>:
</p>

<pre caption="Informacija apie postfix būklę">
# <i>/etc/init.d/postfix status</i>
</pre>

<p>
Jeigu būklės informacija praneša, kad jūsų servisas yra paleistas, bet jūs
žinote, kad taip nėra. Jūs galite pakeisti būklės informaciją iš naujo į
"išjungtas" parametru <c>zap</c>:
</p>

<pre caption="Pakeičiame būklės informaciją apie postfix iš naujo">
# <i>/etc/init.d/postfix zap</i>
</pre>

<p>
Taip pat norėdami sužinoti, kokias priklausomybes servisas turi, jūs galite
naudoti parametrus <c>iuse</c> arba <c>ineed</c>. Parametru <c>ineed</c> jūs
galite matyti būtinus servisus, kurie užtikriną korektišką šio serviso darbą.
Parametru <c>iuse</c> pamatysite servisus, kurie gali būti naudojami, bet
nėra būtini korektiškam funkcionavimui.
</p>

<pre caption="Užklausiame sąrašo servisų, kurie yra būtini ir nuo kurių
priklauso Postfix">
# <i>/etc/init.d/postfix ineed</i>
</pre>

<p>
Panašiai jūs galite paklausti, kokie servisai reikalauja šio serviso,
(<c>needsme</c>) arba kurie naudoja šį servizą (<c>usesme</c>):
</p>

<pre caption="Užklausiame sąrašo servisų, kurie reikalauja Postfix">
# <i>/etc/init.d/postfix needsme</i>
</pre>

<p>
Pagaliau jūs galite paklausti, kokių priklausomybių trūksta servisui:
</p>

<pre caption="Užklausiame sąrašo priklausomybių, kurių trūksta Postfix">
# <i>/etc/init.d/postfix broken</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Dirbame su rc-update</title>
<subsection>
<title>Kas yra rc-update?</title>
<body>

<p>
Gentoo init sistema naudoja priklausomybių medį, kad nuspręstų kokį servisą
reikia paleisti pirmiausia. Kadangi tai sunkus uždavinys ir kad to nereikėtų
atlikinėti mūsų vartotojams patiems, mes sukūrėme įrankius, kurie lengvai
leidžia administruoti, valdyti paleidžiamuosius lygius ir init skriptus.
</p>

<p>
<c>rc-update</c> komanda jūs galite pridėti ir šalinti init skriptus į
paleidžiamąjį lygį. Įrankis <c>rc-update</c> automatiškai pats paleis skriptą
<c>depscan.sh</c>, kuris perkurs priklausomybių medį.
</p>

</body>
</subsection>
<subsection>
<title>Pridedame ir šaliname servisus</title>
<body>

<p>
Jūs jau įkėlėte init skriptą į "default" (numatytą) paleidžiamąjį lygį Gentoo
instaliavimo metu. Tada jūs galbūt nelabai supratote kam reikalingas šis lygis,
bet dabar mes išsiaiškinsime. Skriptas <c>rc-update</c> reikalauja antro 
parametro, kuris nurodo veiksmą: <e>add</e>, <e>del</e> arba <e>show</e>.
</p>

<p>
Norėdami pridėti arba pašalinti init skriptą, tiesiog paleiskite
<c>rc-update</c> su parametrais <c>add</c> arba <c>del</c>, init skripto
pavadinimu ir paleidžiamojo lygio pavadinimu. Pavyzdžiui:
</p>

<pre caption="Šaliname Postfix iš numatytojo paleidžiamojo lygio">
# <i>rc-update del postfix default</i>
</pre>

<p>
Komanda <c>rc-update show</c> parodys visus galimus init skriptus ir sąrašą,
kuriuose paleidžiamuosiuose lygiuose jie yra įvykdomi:
</p>

<pre caption="Gauname informaciją apie init skriptus">
# <i>rc-update show</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Konfigūruojame servisus</title>
<subsection>
<title>Kodėl reikia papildomų nustatymų?</title>
<body>

<p>
Init skriptai gali būti pakankamai sudėtingi. Aišku, nėra pageidautina
tiesiogiai redaguoti init skripto, nes galima padaryti jį neveiksniu. Bet tuo
pačiu yra svarbu turėti galimybę tokius servisus konfigūruoti. Pavyzdžiui, jūs
norite suteikti daugiau pasirinkčių pačiam servisui.
</p>

<p>
Kita priežastis turėti galimybę konfigūruoti init skriptus netiesiogiai yra
tai, kad būtų galima atnaujinti pačius init skriptus nesibaiminant, kad jūsų
nustatymai pasinaikins.
</p>

</body>
</subsection>
<subsection>
<title>Katalogas /etc/conf.d</title>
<body>

<p>
Gentoo suteikia patogų kelią konfigūruoti tokius servisus: kiekvienas init
skriptas, kuris gali būti konfigūruojamas, turi savo rinkmeną
<path>/etc/conf.d</path> kataloge. Pavyzdžiui, apache2 init skriptas
(pavadintas <path>/etc/init.d/apache2</path>) turi konfigūracinę rinkmeną,
pavadintą <path>/etc/conf.d/apache2</path>, kuri saugo nustatymus, kuriuos
norite perduoti Apache 2 serveriui, kai jis bus paleidžiamas:
</p>

<pre caption="Apibrėžti kintamieji faile /etc/conf.d/apache2">
APACHE2_OPTS="-D PHP4"
</pre>

<p>
Tokia konfiguracinė rinkmena laiko kintamuosius (panašius kaip ir rinkmenoje
<path>/etc/make.conf</path>), kas leidžia labai lengvai keisti servisų
nustatymus. Taip pat tokios rinkmenos suteikia daugiau informacijos apie pačius
kintamuosius (kaip komentarai).
</p>

</body>
</subsection>
</section>
<section>
<title>Rašome init skriptus</title>
<subsection>
<title>Ar tikrai tai būtina?</title>
<body>

<p>
Ne, rašyti init skirptą nėra būtina, nes Gentoo jau suteikia skaityk-naudok
tipo init skriptus visiems teikiamiems servisams. Aišku, jūs galėjote įdiegti
kokį nors servisą ne iš Portage bazės, todėl jūs greičiausiai norėsite sukurti
savo init skriptą.
</p>

<p>
Nenaudokite init skriptų pateiktų su servisais, jeigu jie nėra konkrečiai
parašyti Gentoo. Taip pat Gentoo init skriptai nėra pritaikyti naudoti kitose
distribucijose!
</p>

</body>
</subsection>
<subsection>
<title>Išdėstymas</title>
<body>

<p>
Pagrindinė sandara init skripto pateikta žemiau.
</p>

<pre caption="Init skripto sandara">
#!/sbin/runscript

depend() {
  <comment>(Priklausomybių informacija)</comment>
}

start() {
  <comment>(Komandos, būtinos paleisti servisą)</comment>
}

stop() {
  <comment>(Komandos, būtinos sustabdyti servisą)</comment>
}

restart() {
  <comment>(Komandos, būtinos perkrauti servisą)</comment>
}
</pre>

<p>
Bet kuris init skriptas <e>reikalauja</e> apibrėžti <c>start()</c> funkciją.
Visos kitos funkcijos yra pasirinktinai.
</p>

</body>
</subsection>
<subsection>
<title>Priklausomybės</title>
<body>

<p>
Yra dviejų tipų priklausomybės, kurias galite apibrėžti: <c>use</c> ir
<c>need</c>. Kaip anksčiau ir minėjome, <c>need</c> tipo priklausomybė yra
griežtesnė negu <c>use</c> tipo priklausomybė. Priklausomai nuo priklausomybės
tipo, jūs įvedate servisą, nuo kurio tiesiogiai priklausote arba priklausote
<e>virtualiai</e>.
</p>

<p>

<e>Virtuali</e> priklausomybė yra tokia priklausomybė, kuri reikalinga
servisui, bet nėra priklausoma nuo konkrečių programų. Pavyzdžiui, jūsų init
skriptas priklauso nuo sistemos žurnalų serviso, bet yra daugybė įvairių
sistemų žurnalų apdorojimo programų (metalogd, syslog-ng, sysklogd, ...).
Kadangi jūs negalite <c>reikalauti</c> kiekvieno iš jų atskirai (nėra praktiška
sistemoje turėti visas šias programas paleistas), todėl mes užtikriname, kad
nuo šių servisų priklausysime virtualiai.
</p>

<p>
Pažiūrėkime informaciją apie priklausomybes postfix serviso.
</p>

<pre caption="Postfix priklausomybių informacija">
depend() {
  need net
  use logger dns
  provide mta
}
</pre>

<p>
Kaip matote, postfix servisas:
</p>

<ul>
  <li>
    reikalauja (virtualios) <c>net</c> priklausomybės, kuri pateikiama,
    pavyzdžiui, <path>/etc/init.d/net.eth0</path> skripto.
  </li>
  <li>
    reikalauja (virtualios) <c>logger</c> priklausomybės, kuri pateikiama,
    pavyzdžiui, <path>/etc/init.d/syslog-ng</path> skripto.
  </li>
  <li>
    reikalauja (virtualios) <c>dns</c> priklausomybės, kuri pateikiama,
    pavyzdžiui, <path>/etc/init.d/named</path> skripto.
  </li>
  <li>
    pateikia (virtualią) <c>mta</c> priklausomybę, kuri yra įprasta visiems
    pašto serveriams.
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Kontroliuojame tvarką</title>
<body>

<p>
Kai kuriais atvejai jums, pavyzdžiui, nereikės pačio serviso, bet norėsite kad
jūsų servisas būtų paleistas <c>prieš</c> (arba <c>po</c>) kitą servisą,
<e>jeigu</e> jis yra sistemoje (atkreipkite dėmesį - tai nėra daugiau
priklausomybės) ir jis paleistas tame pačiame paleidžiamajame lygyje
(atkreipkite dėmesį - tai liečia tik tai servizus tame pačiame paleidžiamajame
lygyje). Jūs galite nustatyti šią informaciją naudodami <c>prieš</c> arba
<c>po</c> nustatymus.
</p>

<p>
Kaip pavyzdį paimsime Portmap serviso nustatymus:
</p>

<pre caption="Portmap serviso funkcija depend()">
depend() {
  need net
  before inetd
  before xinetd
}
</pre>

<p>
Jūs taip pat galite naudoti "*" GLOB, kad sugautumėte visus servisus tame
pačiame paleidžiamajame lygyje, bet tai nėra patartina.
</p>

<pre caption="Leidžiame init skriptą, kaip patį pirmąjį šiame paleidžiamajame
lygyje">
depend() {
  before *
}
</pre>

</body>
</subsection>
<subsection>
<title>Standartinės funkcijos</title>
<body>

<p>
Toliau po <c>depend()</c> funkcionalumo nustatymo, jums greičiausiai reikės
nustatyti <c>start()</c> funkciją. Ši funkcija laiko visas komandas reikalingas
inicijuoti servisą. Rekomenduojama naudoti <c>ebegin</c> ir <c>eend</c>
funkcijas, kad informuotumėte vartotoją, kas vyksta paleidimo metu:
</p>

<pre caption="start() funkcijos pavyzdys">
start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}
</pre>

<p>
Jeigu jums reikia daugiau pavyzdžių <c>start()</c> funkcijos, prašome
paskaityti pačius init skriptų kodus, kuriuos galite rasti kataloge
<path>/etc/init.d</path>. Kaip šiam <c>start-stop-daemon</c> tipui yra puikūs
man vadovo puslapiai, kuriuose galite rasti daugiau informacijos:
</p>

<pre caption="Gauname daugiau informacijos apie start-stop-daemon">
# <i>man start-stop-daemon</i>
</pre>

<p>
Kitos funkcijos, kurias galite apibrėžti, yra: <c>stop()</c> ir
<c>restart()</c>. Jūs nesate verčiamas apibrėžti šių funkcijų! Mūsų init
sistema yra pakankamai protinga užpildyti šias funkcijas pati, jeigu jūs
naudojate <c>start-stop-daemon</c>.
</p>

<p>
Gentoo sistemos init skriptų sintaksė remiasi Bourne Again Shell (bash)
sintakse, todėl jūs pilnai galite naudoti bash tipo kodą init skriptuose.
</p>

</body>
</subsection>
<subsection>
<title>Nustatome įvairias pasirinktis</title>
<body>

<p>
Jeigu jūs norite, kad jūsų init skriptai turėtų daugiau pasirinkčių negu dabar,
kurias aptarėme, tada jūs turite įkelti nustatymų pavadinimą į <c>opts</c> 
kintamąjį ir sukurti funkciją tokiu pačiu pavadinimu kaip ir nustatymas. 
Pavyzdžiui, jeigu norite turėti nustatymą pavadinimu <c>restartdelay</c>:
</p>

<pre caption="Nustatymo restartdelay palaikymas">
opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <comment># Laukti 3 sekundes prieš vėl startuojant</comment>
  start
}
</pre>

</body>
</subsection>
<subsection>
<title>Serviso nustatymų kintamieji</title>
<body>

<p>
Jums nereikia nieko daryti, jeigu norite turėti nustatymų rinkmeną kataloge
<path>/etc/conf.d</path>: jeigu jūsų init skriptas yra paleistas, šios
rinkmenos yra automatiškai prijungiamos (pvz: galima naudoti kintamuosius):
</p>

<ul>
  <li><path>/etc/conf.d/&lt;jūsų init skriptas&gt;</path></li>
  <li><path>/etc/conf.d/basic</path></li>
  <li><path>/etc/rc.conf</path></li>
</ul>

<p>
Taip pat, jeigu jūsų init skriptas palaiko virtualią priklausomybę (tokią kaip
<c>net</c>), tada rinkmena bus su sieta su šia priklausomybe (šiuo atveju su
rinkmena <path>/etc/conf.d/net</path>).
</p>

</body>
</subsection>
</section>
<section>
<title>Keičiame paleidžiamojo lygio elgesį</title>
<subsection>
<title>Kas gali gauti naudos iš to?</title>
<body>

<p>
Dauguma nešiojamų kompiuterių vartotojų susiduria su tokia situacija, kaip
pavyzdžiui, namie jiems reikia paleisti <c>net.eth0</c>, kai tuo tarpu dirbant
kelyje (nes nėra interneto), jūs visai nenorite, kad būtų paleistas
<c>net.eth0</c>. Su Gentoo sistema jūs lengvai galite pats keisti paleidžiamojo
lygio elgesį pagal savo norus.
</p>

<p>
Jūs galite sukurti dar viena "default" paleidžiamąjį lygį, kurį galite užkrauti
ir kuris turės jūsų priskirtus init skriptus. Taip pat jūs galite nustatyti
krovimosi laiką, kada norite naudoti numatytąjį paleidžiamąjį lygį.
</p>

</body>
</subsection>
<subsection>
<title>Naudojame minkštąjį lygį (softlevel)</title>
<body>

<p>
Pirmiausia, sukurkite paleidžiamojo lygio direktoriją antram jūsų "default"
paleidžiamajam lygiui. Kaip pavyzdį, sukurkime <path>offline</path>
paleidžiamąjį lygį:
</p>

<pre caption="Sukuriame paleidžiamojo lygio katalogą">
# <i>mkdir /etc/runlevels/offline</i>
</pre>

<p>
Pridedame norimus init skriptus į mūsų naujai sukurtą paleidžiamąjį lygį.
Pavyzdžiui, jeigu norite turėti lygiai tokį patį paleidžiamąjį lygį kaip
<c>default</c> jūsų sistemos paleidžiamasis lygis, bet be <c>net.eth0</c>:
</p>

<pre caption="Pridedame reikalingus init skriptus">
<comment>(Nukopijuojame visus servizus iš numatytojo į offline paleidžiamąjį
lygį)</comment>
# <i>cd /etc/runlevels/default</i>
# <i>for service in *; do rc-update add $service offline; done</i>
<comment>(Pašaliname nereikalingus servisus iš offline paleidžiamojo
lygio)</comment>
# <i>rc-update del net.eth0 offline</i>
<comment>(Žiūrime offline paleidžiamojo lygio aktyvius servisus)</comment>
# <i>rc-update show offline</i>
<comment>(Pavyzdys, kaip atrodo įvykdžius šią komandą)</comment>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre>

<p>
Dabar redaguokime jūsų sistemos paleidyklės (bootloader) nustatymus ir
pridėkime naują reikšmę jūsų <c>offline</c> paleidžiamajam lygiui. Pavyzdžiui,
rinkmenoje <path>/boot/grub/grub.conf</path>:
</p>

<pre caption="Pridedame naują reikšmę apie offline paleidžiamąjį lygį">
title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <i>softlevel=offline</i>
</pre>

<p>
Voilà, jūs viską jau atlikote. Jeigu jūs užkrausite savo savo sistemą,
pasirinkite naujai sukurtą reikšmę krovimosi metu, ir <c>offline</c>
paleidžiamasis lygis bus panaudotas vietoj <c>default</c>.
</p>

</body>
</subsection>
<subsection>
<title>Naudojame krovimosi lygį (bootlevel)</title>
<body>

<p>
Naudojant <c>bootlevel</c> viskas yra taip pat kaip ir su <c>softlevel</c>.
Vienintelis skirtumas yra tas, kad jūs apibrėžėte antrą "boot" paleidžiamąjį
lygį, vietoj antro "default" paleidžiamojo lygio.
</p>

</body>
</subsection>
</section>
</sections>
