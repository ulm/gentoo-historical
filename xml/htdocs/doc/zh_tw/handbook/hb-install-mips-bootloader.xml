<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/zh_tw/handbook/hb-install-mips-bootloader.xml,v 1.9 2006/01/27 01:45:55 ccpz Exp $ -->

<!-- rev 1.12 by ccpz -->

<sections>

<version>1.8</version>
<date>2006-01-19</date>

<section id="sgi">
<title>Silicon Graphics Machines -- 設定Arcboot</title>
<subsection>
<body>

<p>
在這份文件的前面，我們如何去編譯核心，然後利用<c>dvhtool</c>把他複製到volume
header。目前這個系統仍有兩個主要的缺點：
</p>

<ul>
 <li>這不支援所有的SGI系統</li>
 <li>他必需使用到大量的volume header</li>
</ul>

<p>
為了要能啟動主機，<c>arcboot</c>這工具就因此被發展出來。除了直接把kernel放
到volume header，我們則把他放在<path>/boot</path>(格式為EXT2/3磁區)，並且
告訴<c>arcboot</c>(他位於volume header 用來取代核心原本的位置)去找他，所以
我們第一步就是要先安裝一些等等會用到的工具。
</p>

<pre caption="安裝需要用的工具">
# <i>emerge dvhtool arcboot</i>
</pre>

<p>
那應該已經安裝好兩個工具，用來放在volume header並且幫我們載入核心的<c>arcboot</c>
，還有幫我們將<c>arcboot</c>放到volume header 的<c>dvhtool</c>
</p>

<p>
我們需要的神奇執行檔躲在<path>/usr/lib/arcboot</path>--在IP22系統(Indy,Indigo 2
,Challenge S)，他將會命名為<path>arcboot.ip22</path>。其他的系統應該都差不多。
我們先把這檔案複製到volume header。
</p>

<pre caption="安裝arcboot到Volume Header">
# <i>dvhtool --unix-to-vh /usr/lib/arcboot/arcboot.ip?? arcboot</i>
</pre>

<p>
然後我們來看看是否檔案都進去volume header了
</p>

<pre caption="檢查看看arcboot是否可以用了">
# <i>dvhtool --print-volume-directory</i>
----- directory entries -----
Entry #0, name "linux", start 4, bytes 3262570
Entry #1, name "newlinux", start 6377, bytes 7619627
Entry #3, name "arcboot", start 21260, bytes 51448
#
</pre>

<note>
您將會注意到在我的例子中，我已經有兩個舊的核心在裡面。<path>linux</path>
和<path>newlinux</path>。這是在我們開始使用<c>arcboot</c>之前的殘留物。
目前不需要理他--只要<c>arcboot</c>一使用，一切都會正常。
</note>

</body>
</subsection>

<subsection>
<title>設定arcboot</title>

<body>

<p>
如果您之前曾經設定過Linux Loader(<c>lilo</c>)，您將會發現<c>arcboot</c>設定檔
使用相似的語法。請記住;<c>arcboot</c>會去尋找他在EXT2/3磁區上的設定檔如：
<path>/etc/arcboot.conf</path>。最簡單的方式就是確定<path>/boot</path>是
一個EXT2/3的磁區並且在<path>/boot/etc</path>資料夾中有一個叫<path>arcboot.conf</path>
的檔案。範例設定檔可以在<path>/etc/arcboot.conf.example</path>中找到。
</p>

<pre caption="把arcboot.conf放到他該在的位置">
<comment>(建立/boot/etc資料夾)</comment>
#<i>mkdir /boot/etc</i>

<comment>(把我們的設定檔放到目的資料夾中)</comment>
#<i>cp /etc/arcboot.conf.sample /boot/etc/arcboot.conf</i>

<comment>(建立一個連結到/etc)</comment>
#<i>ln -s /boot/etc/arcboot.conf /etc/arcboot.conf</i>

<comment>(...建立一個連結連結自己)</comment>
#<i>(cd /boot;ln -s . boot)</i>
</pre>

<p>
然後您可以開始編輯適合您的<path>/etc/arcboot.conf</path>。個人建議，我比較
喜歡建立兩個kernel image：<path>new</path>一個最新的可能可以用或可能不能用的
核心。和<path>working</path>一個確定可以使用的核心。我的<path>arcboot.conf</path>
看起來像這樣
</p>

<pre caption="範例arcboot.cong">
<comment>#arcboot.conf</comment>
<comment>#</comment>
label=working
    image=/vmlinux
    append="root=/dev/sda3"

<comment>#backup version</comment>
label=new
    image=/vmlinux-new
    append="root=/dev/sda3"
</pre>

<p>
一旦這設定好後，還有一些小問題需要您解決，來讓SGI PROM可以運作。這些已經被
包含在以後的小節而非接下來的小節(那是給Cobalt server 用的)。
<uri link="#reboot">重新啟動系統</uri>。
</p>

</body>
</subsection>
</section>

<section id="cobalt">
<title>Cobalt MicroServers -- 設定CoLo</title>
<subsection>
<title>安裝CoLo</title>
<body>

<p>
在Cobalt 伺服器上，這些機器有著很少的軔體在晶片上。Cobalt BOOTROM是先佔式的
，介由與SGI PROM，Cobalt有一些限制。
</p>

<ul>
  <li>
    有675kB的kernel限制。這使得目前Linux 2.4核心的的容量幾乎不可能裝進去。
    Linux 2.6 更不可能了。
  </li>
  <li>
    64-bit的核心不被支援(雖然這是非常實驗室性質的作法)
  </li>
  <li>
    shell是最基本的
  </li>
</ul>

<p>
為了要避免這些問題，一個更改的認體，叫作<uri
link="http://www.colonel-panic.org/cobalt-mips/">CoLo</uri>(Cobalt Loader)
被發展出來。這是一個可以被更新到Cobalt server BOOTROM，或者被已經存在的軔體
所載入。
</p>

<note>
這份文件將會教您設定CoLo讓他可以被舊的軔體載入。這是最安全的方式，並且要求
設定CoLo。
</note>

<warn>
您也許會希望更新到server上，完全取代原本的軔體 -- 但是，您必需自己來做。
如果其中有些錯誤，您將需要手動移除BOOTROM並且重新編輯軔體。如果您不確定
要怎樣做--那就<e>不要</e>這樣做。如果您忽略這警告，我們將不會附任何責任。
</warn>

<p>
好啦，警告已經結束了，我們來安裝CoLo吧!第一，由安裝開始吧!
</p>

<pre caption="Emerging colo">
#<i>emerge colo</i>
</pre>

<p>
待安裝完成後(希望你能看到安裝完成的訊息:-)您應該可以看到<path>/usr/lib/colo</path>
資料夾下有兩個檔案<path>colo-chain.elf</path>：軔體要載入的"核心"和
<path>colo-rom-image.bin</path>：用來更新軔體的ROM image。我們從掛上
/boot和複製一個系統需要的壓縮的<path>colo-chain.elf</path>到<path>/boot</path>
開始。
</p>

<pre caption="把CoLo放倒適當的位置">
#<i>gzip -9vc /usr/lib/colo/colo-chain.elf &gt; /boot/vmlinux.gz</i>
</pre>

</body>
</subsection>

<subsection>
<title>設定CoLo</title>

<body>

<p>
現在，當系統第一次啟動，他將會載入CoLo，並出現一個選單在黑色的LCD上。第一個
選項(並且是預設的選項在等待五秒後)是從硬碟啟動。系統將會去掛載他所找到的第
一個磁區，並且執行<path>defult.colo</path>這個script。這些語法完全在CoLo
的說明檔文件中都有介紹(請參考<path>/usr/share/doc/colo-X.YY/README.shell.gz</path>)
-- 其中X.YY是安裝的版本名稱，這非常簡單。
</p>

<note>
小技巧：當安裝核心時，我通常會建立兩個核心影像檔，<path>kernel.gz.working</path>--已知可運作的核心，和 <path>kernel.gz.new</path>--剛編譯完成的核心。您可以使用 symlinks 來指到目前的 "new" 和 "working" 核，或直接重新命名核心影像。
</note>

<pre caption="最基本的default.colo">
<comment>#:CoLo:#</comment>
mount hda1
load /kernel.gz.working
execute root=/dev/hda3 ro console=ttyS0,115200
</pre>

<note>
CoLo將會拒絕載入不是從<c>#:CoLo:#</c>那行開始的Script。您可以把他想成是
<c>#!/bin/sh</c>在shell scripts中。
</note>

<p>
您也許會問一個問題，就像是我想要利用那一個kernel&amp;設定來啟動，當預設
時間已經到了。以下是我用在我的Cobalt server 的設定檔：
</p>

<impo>
請注意您需要使用 CoLo v1.12 或 v1.13 才能使用 <c>menu</c> 指令。下面的範例無法在 v1.11 上使用。
</impo>

<impo>
<c>menu</c> 指令在 CoLo v1.14 中將被 <c>select</c> 取代，如果您已經手動安裝了較新的版本，請查看 CoLo 的 <path>examples</path> 子目錄中的 <path>menu.colo</path>
</impo>

<pre caption="選單的設定檔">
<comment>#:CoLo:#</comment>

lcd "Mounting hda1"
mount hda1
menu "Which Kernel?" 50 Working working New new
lcd "Loading Linux" {menu-option}
load /kernel.gz.{menu-option}
lcd "Booting..."
execute root=/dev/hda5 ro console=ttyS0,115200
boot
</pre>

<p>
上述的script會問使用者想用那一個核心啟動(New或是Working)，然後載入
<path>vmlinux.gz.new</path>或是<path>vmlinux.gz.working</path>。
如果在5秒內沒有完成選擇，他將會用第一個選項來啟動。
</p>
</body>

</subsection>
</section>

<section>
<title>設定序列指令列(Serical Console)</title>

<subsection>
<body>

<p>
好啦!!Linux 的安裝已經站起來了!!可以正常啟動。但是假設您正要從終端機登入。
在Cobalt機器上，這是很難的，因為沒有終端機這種東西。
</p>

<note>
對於那些有支援frambuffer的幸運使用者可以跳過這節如果您希望的話。
</note>

<p>
第一，拉起一個編輯器並且編輯<path>/etc/inittab</path>。然後您將會看見
想下面這些東西：
</p>

<pre caption="inittab 設定">
<comment># SERIAL CONSOLE</comment>
<comment>#c0:12345:respawn:/sbin/agetty 9600 ttyS0 vt102</comment>

<comment># TERMINALS</comment>
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

<comment># What to do at the "Three Finger Salute".</comment>
ca:12345:ctrlaltdel:/sbin/shutdown -r now
</pre>

<p>
第一，把<c>c0</c>解除註解。如果是預設，他是被設定成baud rate為96000bps。
在Cobalt伺服器上，您也許想要去改變成為115200來符合由BOOTROM所選定的。
這才像在我機器上的樣子。對於headless的機器(例如：Cobalt伺服器)，我也將會
建議標記區域的終端機那行(從<c>c1</c>到<c>c6</c>)如此他就不能啟動
<path>/dev/ttyX</path>
</p>

<pre caption="從inittab來的一些片斷範例">
<comment># 序列主控台(SERIAL CONSOLE)</comment>
c0:12345:respawn:/sbin/agetty 115200 ttyS0 vt102

<comment># TERMINALS -- 對於headless 這些是沒用的</comment>
<comment>#c1:12345:respawn:/sbin/agetty 38400 tty1 linux</comment>
<comment>#c2:12345:respawn:/sbin/agetty 38400 tty2 linux</comment>
<comment>#c3:12345:respawn:/sbin/agetty 38400 tty3 linux</comment>
<comment>#c4:12345:respawn:/sbin/agetty 38400 tty4 linux</comment>
<comment>#c5:12345:respa345:respawn:/sbin/agetty 38400 tty6 linux</comment>
</pre>

<p>
接下來最後，我們必需告訴系統，區域的序列port為可以被信任的安全終端機。
我們要更改的檔案是<path>/etc/securetty</path>。他包含一系列系統信任的終
端機。我們只要簡單的插入兩行，允許<c>root</c>可以從那邊登入。
</p>

<pre caption="允許root從序列主控台登入">
<comment>(/dev/ttyS0 -- 第一個序列port的傳統名字)</comment> 
# <i>echo 'ttyS0' > /etc/securetty</i>

<comment>(後來 Linux也稱/dev/tts/0 -- 所以我們也把他加入)</comment>
# <i>echo 'tts/0' > /etc/securetty</i>
</pre>

</body>
</subsection>
</section>

<section id="reboot">
<title>重開機系統</title>
<subsection>
<body>
  	 
<p>
離開 chrooted 的環境然後卸載所有掛載的分割區。接著輸入你已經等很久的神奇指令：
<c>reboot</c>。
</p>

<pre caption="離開 chroot，卸載所有分割區然後重開機">
# <i>exit</i>
cdimage ~# <i>cd</i>
cdimage ~# <i>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</i>
cdimage ~# <i>reboot</i>
</pre>

<note>
<e>Cobalt使用者：</e>剩餘的內容包含設定SGI PROM 讓他可以啟動<c>arcboot</c>
然後載入Linux。這不是適當的設定Cobalt伺服器。事實上您要作的工作已經完成--
對於第一次啟動已經沒有任何設定需要被設定，您可以略過下一節<uri
link="?part=1&amp;chap=11">最終化您的Gentoo安裝</uri>
</note>

</body>
</subsection>
</section>
<section>
<title>調整 SGI PROM</title>
<subsection>
<body>
  	 
<p>
當你重開機以後，進入 <e>System Maintenance Menu</e> 然後選擇
<e>Enter Command Monitor</e> (<c>5</c>)。如果你想要測試剛剛安裝好的 Gentoo，你
可以執行 <c>boot -f &lt;kernel name&gt;</c>。要讓你的系統每次都執行 Gentoo，你
要設定一些 SGI PROM 的變數。
</p>
  	 
<pre caption="設定 PROM 啟動 Gentoo">
1) Start System
2) Install System Software
3) Run Diagnostics
4) Recover System
5) Enter Command Monitor
  	 
Option? <i>5</i>
Command Monitor.  Type "exit" to return to the menu.
  	 
<comment>(&lt;root device&gt; = Gentoo 的跟目錄，例如說 /dev/sda3)</comment>
&gt;&gt; <i>setenv OSLoadPartition &lt;root device&gt;</i>
  	 
<comment>(輸入 "ls" 列出可以使用的核心)</comment>
&gt;&gt; <i>setenv OSLoader &lt;kernel name&gt;</i>
&gt;&gt; <i>setenv OSLoadFilename &lt;kernel name&gt;</i>
  	 
<comment>(加入你要傳送的核心參數)</comment>
&gt;&gt; <i>setenv OSLoadOptions &lt;kernel parameters&gt;</i>
  	 
<comment>(提供 Volume Header 的位置)</comment>
&gt;&gt; <i>setenv SystemPartition scsi(0)disk(1)rdisk(0)partition(8)</i>
  	 
<comment>(自動開啟 Gentoo)</comment>
&gt;&gt; <i>setenv AutoLoad Yes</i>
  	 
<comment>(設定時區)</comment>
&gt;&gt; <i>setenv TimeZone EST5EDT</i>
  	 
<comment>(使用序列終端機 - graphic 卡的使用者應該用 "g" 取代 "d1" (一))</comment>
&gt;&gt; <i>setenv console d1</i>
</pre>
  	 
<p>
現在你已經準備好享受 Gentoo!開機到 Gentoo 然後繼續
<uri link="?part=1&amp;chap=11">最終化 Gentoo 安裝</uri>.
</p>

</body>
</subsection>
</section>
</sections>
