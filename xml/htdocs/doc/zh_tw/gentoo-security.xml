<?xml version='1.0' encoding='UTF-8'?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/zh_tw/gentoo-security.xml,v 1.8 2006/03/10 14:49:45 neysx Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- rev 1.58 by Eternity -->
<guide link = "/doc/zh_tw/gentoo-security.xml" lang="zh_tw">
<title>Gentoo Linux Security Guide</title>
<author title="Author">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
  <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Translator">
   <mail link="palatis@gentoo.tw">【Palatis】</mail>
</author>
<author title="Translator">
   <mail link="ricklan0224@hotmail.com">Rick Lan</mail>
</author>

<abstract>
這是篇一步一步教您怎樣把 Gentoo Linux 變硬的指南。
</abstract>

<license/>

<version>0.4.29</version>
<date>July 16, 2004</date>

<chapter>
<title>介紹</title>
<section>
<body>

<p>
這篇指南是為了那些以 Gentoo Linux 作為伺服環境或只是感到需要更高安全性的人撰<!--
-->寫的。
</p>

<note>
在您閱讀此文章後，若對更多 Gentoo 安全的資訊有興趣的話，請參考
<uri link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo 計畫<!--
--></uri>。
</note>

</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>安裝前的考量</title>
<section>
<title>實體安全</title>
<body>

<p>
不管您請來多少安全警衛，攻擊者都能簡單的從機器前面入侵您的系統。確認您的硬體<!--
-->不是隨意就可以被使用。例如，您可能想將您的機器鎖進保險櫃裡面，能把鎖鎖上<!--
-->更好！為了更高的安全性，您可以限定系統只能從硬碟開機，避免其他人使用軟碟<!--
-->機或光碟機來開機。更進一步，您還可以把 BIOS 密碼鎖上。對筆記型電腦使用者<!--
-->來說，BIOS 密碼也是個好主意。
</p>

</body>
</section>
<section>
<title>伺服程式╱服務計畫</title>
<body>

<p>
將您系統應該執行或可能執行的服務作成文件。這可以幫助您策劃較完善的磁碟分割規<!--
-->劃。也可以讓您在做入侵偵測戰略規劃的時候容易些。當然，您如果您沒幾台電腦<!--
-->並且您是唯一會使用他們的人，則您不必理會這分文件。例如，這台電腦只是台防<!--
-->火牆，那麼它就不應該執行 sshd 以外的 <e>任何</e> 服務。
</p>

<p>
將這台機器的用途以及 sshd 的版本記錄下來，將有助您在某個人發現了 sshd 的安全<!--
-->漏洞之後追蹤更新。這也將讓您決定誰應該有權存取這台電腦的時候容易些。
</p>

</body>
</section>
<section>
<title>分割區規劃</title>
<body>

<p>
金科玉律：
</p>

<ul>
  <li>
    所有可以讓使用者寫入的目錄 (<path>/home</path>、<path>/tmp</path> 以及
    <path>/var</path>) 都應該在分開而且有磁碟限額的分割區上。Portage 使用
    <path>/var/tmp</path> 作為編譯暫存區，所以這個分割區應該大一點。這將降低<!--
    -->使用者塞爆您 <path>/</path> 掛載點的風險。
  </li>
  <li>
    所有安裝 "外來軟體" 的目錄應該被放在分開的分割區。根據<uri 
    link="http://www.pathname.com/fhs/">檔案分區標準</uri>，這應該是 
    <path>/opt</path> 或 <path>/usr/local</path>。如此一來，它們不會在您重新<!--
    -->安裝系統的時候被抹滅掉。
  </li>
  <li>
    盡量將靜態的資料放在同一個分割區裡，然後將那個分割區掛載成 "只能讀取"。<!--
    -->如果您真的那麼偏執的話，您可以嘗試將靜態的資料放在真正 "只能讀取" 的<!--
    -->媒體上，例如光碟上面。
  </li>
</ul>

</body>
</section>
<section>
<title>根 (root) 使用者</title>
<body>

<p>
"根 (root) 使用者" 對整個系統來說是個致命的角色，而且除非必要絕對不請下山的<!--
-->傢伙。如果某個攻擊者取得了您系統的 "根 (root) 權限"，那您就不再能相信您的<!--
-->系統了，重灌吧！
</p>

<p>
關於根 (root) 的金科玉律：
</p>

<ul>
  <li>
    永遠建立一個每天要使用的角色。如果他真的需要根 (root) 權限，把他加入 wheel 
    群組。這將讓他有權利使用 "su" 指令暫時提昇為根 (root) 使用者。
  </li>
  <li>
    永遠不要用根 (root) 使用者跑 X 或其他使用者級程式。
  </li>
  <li>
    登入成根 (root) 使用者的時候永遠使用絕對路徑。某人可能嘗試欺騙您執行您以<!--
    -->為您正在執行的程式。例如，某個傢伙改了您一般使用者的 PATH 環境變數，<!--
    -->然後您又沒有使用 <c>su -</c> 來升級成根 (root) 使用者，那麼根 (root)
    使用者將繼承這個環境變數。
  </li>
  <li>
    如果某個使用者只需要使用某些 (而非全部) 根 (root) 使用者的指令，考慮使用 
    sudo，不過請小心使用！
  </li>
  <li>永遠不要在登入成根 (root) 使用者的時候離開座位。</li>
</ul>

<p>
Gentoo 有個一般性防護來防止那些想偷偷 <c>su</c> 的使用者。預設的 PAM 設定指<!--
-->定那些可以使用 <c>su</c> 指令的使用者必須是 wheel 群組的成員。
</p>

</body>
</section>
<section>
<title>安全政策</title>
<body>

<p>
有幾個理由指出政策存在的價值：
</p>

<ul>
  <li>如果您沒有為安全下個定義，您就無法判斷您的網路環境是否安全。</li>
  <li>
    您幾乎不可能在沒有偵查網路通訊或搜尋私人家目錄的狀況下捕捉潛在的攻擊者、解決
    網路問題、或管理稽核。而未經允許作這些探查動作在大部份國家是違法的。尤其 60%
    以上的攻擊者都是從內部侵入，您實在不能不把罩子擦亮點...
  </li>
  <li>
    如果您從來不向使用者解釋該如何保護他們自己和他們的同事，以及為什麼安全那麼重
    要，您將無法要求他們考慮安全性。
  </li>
  <li>
    不管怎樣，好的導覽指引和網路文件一定會得到報酬的！
  </li>
  <li>
    如果警察或法律機關不知道您的網路設定以及您提供的服務，他們將無法幫助您抓住壞
    蛋。
  </li>
  <li>
    在受到攻擊的時候該怎麼辦？您必須列出您該做的事情以及您該告訴誰才好。您想每次
    有事情發生都打電話給警察或 CERT 小組嗎？他們不會認真看待的！
  </li>
</ul>

<p>
這應該清楚的能指出確立政策以及教育使用者的重要性了。
</p>

<p>
"政策" 是一份 (或多份) 能夠回答類似誰 (who)、那裡 (where)、為什麼 (why) 或什麼 
(what) 這些問題的文件。每位您系統或網路上的使用者都應該閱讀、了解、並在旁邊簽名
。花時間幫助您的使用者了解政策的內容以及為何他們必須在旁邊簽名或當他們違反這些政
策的時候將發生什麼事 (這個應該也納入文件裡面)。這個動作應該每年至少重複一次，因
為這些政策有可能改變，也可以順便提醒您的使用者。
</p>

<note>
在每個主題上都建立讀起來簡單而且非常清楚具體的政策。
</note>

<p>
大部份的政策都能直接套用在作業系統或防火牆上，不過小部份不行。
</p>

<p>
一份安全政策至少應該包括以下幾項主題：
</p>

<ul>
  <li>允許的使用：
    <ul>
      <li>螢幕保護程式</li>
      <li>密碼管理</li>
      <li>下載檔案以及安裝</li>
      <li>如何判斷或避免被監視的知識</li>
      <li>使用防毒軟體</li>
    </ul>
  </li>
  <li>管理敏感的資訊 (任何書面表格、寫在紙上的或磁性數據)：
    <ul>
      <li>清乾淨桌面並把分類資訊鎖進保險櫃</li>
      <li>離開前將電腦關機</li>
      <li>使用加密</li>
      <li>將鑰匙交給信任的同事管理</li>
      <li>出差的時候管理分類資料</li>
    </ul>
  </li>
  <li>出差時管理電腦配備：
    <ul>
      <li>出差以及住在旅社時的筆記型電腦管理</li>
    </ul>
  </li>
</ul>

<p>
專為 IT (資訊技術) 工作人員訂立的政策可能會根普通使用者的政策有所不同
</p>

<p>
安全性政策可能會長得很大，而致命的資訊也常被忘記。IT 工作人員的政策可以包含一般
使用者應該知道的資訊，所以將它們分成小部份是個聰明的好點子。例如：可接受的使用政
策、密碼政策、電子郵件政策、以及遠端存取政策。
</p>

<p>
一些政策的例子可以在 <uri 
link="http://www.sans.org/resources/policies/">The SANS Security Policy
Project</uri> 找到。如果您只有個小網路而覺得這些政策太多了，您應該參考 <uri
link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">網站安全手冊<!--
--></uri>。
</p>

</body>
</section>
</chapter>

<chapter>
<title>安裝前╱中繫緊安全帶</title>
<section>
<title>USE 旗標</title>
<body>

<p>
<path>make.conf</path> 這個檔案包含使用者定義的 USE 旗標，以及
<path>/etc/make.profile/make.defaults</path> 包含 Gentoo Linux 預設的 USE 旗<!--
-->標。例如此篇指南中提到的 <c>pam</c> (Pluggable Authentication Modules -
插入式認證模組)、<c>tcpd</c> (TCP 封包包裝器)、以及 <c>ssl</c> (Secure Socket
Layer - 安全插口層級)。這些都是預設的 USE 旗標。
</p>

</body>
</section>
<section>
<title>GRUB 密碼</title>
<body>

<p>
Grub 提供兩種不同的方法來讓您在設定檔中 (<path>/boot/grub/menu.1st</path>) 加入
密碼限制。一種是純文字密碼，另一種是 md5+salt 編碼。
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
這將加入 <e>changeme</e> 這個密碼，如果沒有輸入就使用原本的開機設定。
</p>

<p>
在加入 md5 密碼的時候，您必須先將密碼轉換至跟 shadow 檔案相同的 crypt 形式。<!--
-->更多資訊請參考 man crypt。編碼後的密碼 <e>changeme</e> 看起來大概像這樣 - 
<e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>。
</p>

<p>
或者您可以直接在 grub 殼中轉換：
</p>

<pre caption="md5crypt in grub shell">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<comment>(輸入 changeme)</comment>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
接著，將您的密碼剪下，並貼入 <path>/boot/grub/grub.conf</path> 中。
</p>

<pre caption="/boot/grub/menu.lst">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<warn>
當測試這個的時候，請記得加入逾時 (timeout) 設定，不然您不小心弄錯的時候將無法啟
動系統。
</warn>

<p>
五秒鐘的逾時 (timeout) 應該已經不會對在遠端的管理者造成太多等待，並且應該能在<!--
-->沒有鍵盤互動的狀況下重開。更多有關 Grub 密碼的資訊可以在 <c>info grub</c>
中找到。
</p>

</body>
</section>
<section>
<title>LILO 密碼</title>
<body>

<p>
LILO 也支援兩種處理密碼的方法：全域以及根據影像檔，不過都只支援純文字。
</p>

<p>
全域設定在設定檔的最上面：
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
不然的話直接將它加入影像檔。
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
如果沒有輸入 <e>restricted</e> 選項，那麼它每次都會要求密碼。
</p>

<p>
要啟用新的 <path>lilo.conf</path> 資訊，您必須執行 <c>/sbin/lilo</c>。
</p>

</body>
</section>
<section>
<title>限制控制台用量</title>
<body>

<p>
<path>/etc/securetty</path> 讓您設定那個終端機可以允許根 (root) 使用者的登入。
</p>

<p>
我們建議您將 vc/1 以外的其他行都註解掉，這將確定根 (root) 使用者只能在一個虛<!--
-->擬終端機前面登入一次。
</p>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
<section>
<title>更多紀錄</title>
<body>

<p>
加入更多有關警告和錯誤的紀錄可以幫助您判斷正在執行或已經結束的攻擊。攻擊者多<!--
-->半會在實際攻擊之前掃描整個網路。
</p>

<p>
不過如果紀錄檔案很容易被讀取或被管理，也是非常致命的。Gentoo Linux 提供三種<!--
-->不同的紀錄程式讓您選擇。
</p>

</body>
</section>
<section>
<title>紀錄：Syslogd</title>
<body>

<p>
Syslogd 是在 Linux 和 Unix 上最常見的紀錄程式。它不包含紀錄循環功能，這個動<!--
-->作多半在定期執行工作透過正確設定 <path>/etc/logrotate.conf</path> 的
<path>/usr/sbin/logrotate</path> 來執行。循環紀錄檔的週期應該取決於您的系統<!--
-->負載。
</p>

<p>
下面是一份條校過的 <path>syslog.conf</path>。我們取消註解了 <c>cron</c> 以及
<c>tty</c> 這兩行，並加入了遠端的紀錄伺服器。要進一步增加安全性，您可以加入<!--
-->更多遠端紀錄伺服器。
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     Configuration file for syslogd.
#
#                       For more information see syslog.conf(5)
#                       manpage.
#                       This is from Debian, we are using it for now
#                       Daniel Robbins, 5/15/99

#
# 首先是標準紀錄檔。依照分類紀錄。
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# 郵件系統的紀錄。為了方便撰寫分析資料的命令稿，將這些紀錄分開存放。
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

#
# INN 新聞系統的紀錄
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# 一些 `全都錄' 的紀錄檔。
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# 緊急訊息以及警告將傳送至所有登入的使用者
#
*.emerg                         *
*.=alert                        *

#
# 我喜歡讓訊息顯示在終端機上，不過要在沒用到的虛擬終端機上顯示。
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# 設定遠端紀錄伺服器。
*.*                        @logserver

# The named pipe /dev/xconsole is for the `xconsole' utility.  To use it,
# you must invoke `xconsole' with the `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: adjust the list below, or you'll go crazy if you have a reasonably
#      busy site..
#
#daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
攻擊者應該會蠻想將他們入侵的資料抹滅掉的，例如編輯或刪除紀錄檔。您可以將這些<!--
-->紀錄送到一台或多台不同的紀錄伺服器，這將讓攻擊者想湮滅證據的時候困難些。<!--
-->更多關於 syslogd 的資訊可以在男人 (<path>man syslog</path>) 中找到。
</p>

</body>
</section>
<section>
<title>紀錄：Metalog</title>
<body>

<p>
由 Frank Dennis 撰寫的 <uri link="http://metalog.sourceforge.net">Metalog</uri> 
無法將紀錄寫至遠端伺服器，不過在效能以及彈性上的確是有它的優點。它可以根據程<!--
-->式或設施 (類似 syslogd) 來紀錄，而且支援照正規表示式 (Regular Expression)
和執行的指令來分類。這在有必要採取行動的時候將十分有用。
</p>

<p>
標準設定檔基本上已經足夠。如果您想要在每次使用者輸入密碼錯誤的時候接到 email
通知，請使用以下的命令稿。
</p>

<p>
若您使用 postfix：
</p>

<pre caption = "給 postfix 用的 /usr/local/sbin/mail_pwd_failures.sh">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
若您使用 qmail：
</p>

<pre caption="給 qmail 用的 /usr/local/sbin/mail_pwd_failures.sh">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
別忘了執行 <c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c> 將這個<!--
-->命令稿加入實行權限。
</p>

<p>
然後取消 <path>/etc/metalog/metalog.conf</path> 中 Password failures 下一行<!--
-->的註解：
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>紀錄：Syslog-ng</title>
<body>

<p>
Syslog-ng 提供某些跟 syslog 和 metalog 類似卻稍微不同的功能。它可以根據等級<!--
-->和內容來過濾訊息 (類似 metalog)、提供類似 syslog 的遠端紀錄功能、處理 syslogd
送來的紀錄 (甚至 Solaris 送來的串流)、寫入至 TTY 的東西、執行檔案，還可以當<!--
-->作紀錄伺服器來使用。基本上，它是最適合需要高階設定的使用者的記錄器。
</p>

<p>
一份靈巧修改過的標準設定檔。
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#讀取紀錄的來源
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#定義目的位置
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#建立過濾器
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#將過濾器以及目的位置連結起來
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#預設的紀錄
log { source(src); destination(console_all); };
</pre>

<p>
容易設定，但是也容易遺漏某些東西，因為它實在蠻臃腫的。作者還保證會在未來的<!--
-->版本中提供更多功能，例如加密、認證、壓縮、和 MAC (Mandatory Access Control)
控制。有了這些選項，這將會是個很完美的網路記錄器，既然攻擊者不能監視紀錄的話。
</p>

<p>
Syslog-ng 還有個好處，它不用以根 (root) 使用者權限執行！
</p>

</body>
</section>
</chapter>

<chapter>
<title>分割區的掛載</title>
<section>
<body>

<p>
當掛載 ext2、ext3 或 reiserfs 分割區的時候，您有幾個可以套用在 
<path>/etc/fstab</path> 的選項。這些選項是：
</p>

<ul>
  <li><c>nosuid</c> - 忽略所有檔案的 SUID bit 並將它們視為普通檔案。</li>
  <li><c>noexec</c> - 防止所有程式從這個分割區執行。</li>
  <li><c>nodev</c> - 忽略設備。</li>
</ul>

<p>
不幸的，這些設定可以簡單的被繞過，只要不從直接路徑執行就好了。無論如何，將 /tmp 
設成 noexec 可以防止約 99% 的不成熟命令稿，畢竟它們是被設計成直接從 /tmp 執行的
。
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
將 <path>/tmp</path> 設成 noexec 模式可能導致某些命令稿無法正常執行。(繹按：<!--
-->例如那個用 wine 安裝 Microsoft Internet Explorer 的命令稿。)
</warn>

<note>
磁碟限額將在另外一章中描述。
</note>

<note>
即使一般來說不會有檔案從這裡被執行，我也沒有將 <path>/var</path> 設成
<c>noexec</c> 或 <c>nosuid</c>。因為 qmail 將安裝在 <path>/var/qmail</path><!--
-->，而且必須執行一個有 SUID 檔案。我將 <path>/usr</path> 設成唯獨，因為我不<!--
-->想在裡面寫東西。當我想更新我的 Gentoo 系統的時候，我會重新將檔案系統掛載<!--
-->成可讀寫模式，更新系統，然後重新掛載回唯獨。
</note>

<note>
即使您不用 qmail，Gentoo 還是需要 <path>/var/tmp</path> 的執行權限，畢竟 ebuild 
會在這裡執行。不過您堅持的話，還是可以將這個路徑設到其他地方，然後把 
<path>/var</path> 掛成 <c>noexec</c> 模式。
</note>

</body>
</section>
</chapter>

<chapter>
<title>使用者╱群組限制</title>
<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
當防止本地端阻斷服務 (DoS) 或管理群組的登入人數上限時，資源限制顯然是個很有效率
的方法。
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
如果您發現您嘗試將 nproc 或 maxlogins 設成 0，那麼您也許應該直接刪除那個使用<!--
-->者。上述的例子將變更 "dev" 群組的行程數、開啟檔案數、以及最大登入人數。其<!--
-->餘則設成預設值。
</p>

<note>
<path>/etc/security/limits.conf</path> 是 PAM 套件的一部份，而且只會影響那些使用
PAM 的套件。
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> 跟限制設定檔 <path>/etc/security/limits.conf</path>
很類似。唯一的差別是它只對使用者或全域符號 (wildcards) 而非群組作用。讓我們<!--
-->看看具體的設定：
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
在這裡我們將指定預設設定以及 <e>kn</e> 使用者的個人設定。Limits 是影子套件 
(sys-apps/shadow) 的一部份，而且只會對影子登入程式 (shadow login program)
作用。若您正確設定了 PAM 套件，則您不需要將上限設於這個檔案中。
</p>

</body>
</section>
<section>
<title>磁碟限額 (Quotas)</title>
<body>

<warn>
請確認您使用的檔案系統支援磁碟限額。ReiserFS 並不支援它！
</warn>

<p>
在檔案系統上啟動磁碟限額可以防止使用者塞爆磁碟或根本不讓他們寫入。磁碟限額在<!--
-->核心中被開啟並加入至掛載點。核心選項可以在核心設定的 <c>File systems->Quota
support</c> 中開啟。套用下列設定，重新編譯核心，並且用新的核心重新啟動電腦。
</p>

<p>
首先使用 <c>emerge quota</c> 安裝磁碟限額，然後在 <path>/etc/fstab</path> 中<!--
-->在您要限制磁碟用量的分割區後面加入 <c>usrquota</c> 以及 <c>grpquota</c>。<!--
-->作法請參考以下的例子：
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
在您所有啟動磁碟限額的分割區上，建立磁碟限額設定檔 (quota.user 和 quota.group)
並將它們放在該磁碟的根目錄下。
</p>

<pre caption="建立磁碟限額設定檔">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
您必須在所有啟動磁碟限額的分割區執行這個動作。在建立並設定了磁碟限額設定檔以後，
我們必須在開機執行階段加入 <c>quota</c> 命令稿。
</p>

<pre caption="將磁碟限額加入至開機執行階段">
# <i>rc-update add quota boot</i>
</pre>

<p>
然後我們想讓系統每個禮拜檢查一次磁碟限額是否有正確套用，所以請在
<path>/etc/crontab</path> 中加入一行：
</p>

<pre caption="將磁碟限額檢查加入至 crontab">
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
重新開機之後，就可以設定使用者和群組的磁碟限額了。<c>edquota -u kn</c> 會啟<!--
-->動設置於 $EDITOR (預設 nano) 中的編輯器，並讓您編輯 kn 使用者的磁碟限額。<!--
--><c>edquota -g</c> 有幾乎相同的效果，只是它是針對群組。
</p>

<pre caption="設定使用者 kn 的磁碟限額">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
進一步的細節請參考 <e>man edquota</e> 或 <uri 
link="http://www.tldp.org/HOWTO/mini/Quota.html">The quota mini howto</uri>。
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
如果政策指示使用者應該每個星期變更一次密碼，將 <c>PASS_MAX_DAYS</c> 設成 14<!--
-->，<c>PASS_WARN_AGE</c> 設成 7。同時建議您使用密碼等待時間，畢竟暴力破解法<!--
-->可以找出任何密碼 (時間問題罷了)。我們同時建議您將 <c>LOG_OK_LOGINS</c> 設成
yes。
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
login.access 檔案也是影子套件 (sys-apps/shadow) 的一部份，設定登入存取控制表<!--
-->用的。這個表基於使用者名稱、群組名稱、或主機名稱來控制誰可以或誰不行登入<!--
-->。在預設中，所有系統上的使用者都可以登入，所以這個檔案只有一大堆註解跟例<!--
-->子。不管您是在加強伺服器或工作站的安全，我們建議您設定成除了您 (系統管理員)
之外沒有人可以從控制台登入。
</p>

<note>
這些設定不會套用到根 (root) 使用者上。
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
請小心的設定這些選項，畢竟一個不小心可能讓您沒有權限存取這台機器 (若您沒有根
(root) 使用者權限的話)。
</impo>

<note>
這些設定不會套用到 SSH 上，因為 SSH 預設不會執行 /bin/login。這個可以使用在 
<path>/etc/ssh/sshd_config</path> 中的 "UseLogin yes" 來啟用。它會讓 SSH 使用 
login，那麼這些設定將會被套用。
</note>

<p>
這會讓 wheel 群組的成員可以在控制台前或 gentoo.org 網域中登入。可能有點極端，不
過事前防範總是比事後後悔來得好。
</p>

</body>
</section>
</chapter>

<chapter>
<title>檔案權限</title>
<section>
<title>全世界都可以讀取</title>
<body>

<p>
普通使用者不應該擁有設定檔或密碼檔的存取權限。攻擊者可以從網站或資料庫偷走密<!--
-->碼並更改網站內容甚至刪除檔案。這就是為什麼檔案權限正確很重要。如果您很確<!--
-->定這個檔案只會被根 (root) 使用者用到，將它的權限設成 <c>0600</c> 並使用
<c>chown</c> 指令設置正確的擁有者。
</p>

</body>
</section>
<section>
<title>全世界╱群組可以寫入</title>
<body>

<pre caption="找出全世界都可以寫入的檔案和目錄">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
這將建立一個擁有所有可以被群組或所有人寫入的檔案的巨大清單。檢察檔案的權限並<!--
-->排除所有人都可以寫入的檔案，對該檔案執行 <path>/bin/chmod o-w</path> 可以<!--
-->做到。
</p>

</body>
</section>
<section>
<title>SUID/SGID 檔案</title>
<body>

<p>
SUID/SGID 檔案 (被設置超級使用者位元的檔案) ，因為這
些檔案是以 root 權限執行的。如果您不
使用這個檔案，把他們 chmod 0 或直接移除安裝它的套件 (使用 <c>qpkg -f</c> 來找尋套件，如
果您沒有他，使用 <c>emerge gentoolkit</c> 來安裝)。否則，使用 chmod -s 來將 
suid bit 取消。
</p>

<p>
SUID 或 SGID 被設定的檔案允許這個檔案以 <e>擁有人</e> 或 <e>擁有群組</e> 而<!--
-->不是執行檔案的使用者的權限執行。一般狀況下，這兩個設定是給那些必須以根 (root)
使用者權限執行才能做他們該做的事的檔案使用。這些檔案可能對系統安全造成危害
(如果他們有漏洞的話)。這些檔案很危險，而且應該在任何情況下被避免。把他們
<c>chmod 0</c> 或直接移除安裝它的套件 (使用 <c>qpkg -f</c> 來找尋套件，如果<!--
-->您沒有 <c>qpkg</c>，使用 <c>emerge gentoolkit</c> 來安裝)。否則，使用
<c>chmod -s</c> 來將 suid bit 取消。
</p>

<pre caption="找出 setuid 的檔案">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
這將建立一個包括所有 SUID/SGID 檔案的清單。
</p>

<pre caption="List of setuid binaries">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
預設狀況下，Gentoo Linux 並沒有很多 SUID 檔案 (主要還是看您裝了什麼東西)，所以您很可
能得到一個類似上面那樣的清單。大部份的指令不應該被一般使用者使用，除了根 (root) 
使用者。使用 <c>chmod -s</c> 指令將 <c>ping</c>、<c>mount</c>、<c>umount</c><!--
-->、<c>chfn</c>、<c>chsh</c>、<c>newgrp</c>、<c>suidperl</c>、<c>pt_chown</c>
以及 <c>traceroute</c> 的 suid bit 拿掉。不要移除 <c>su</c>、<c>qmail-queue</c>
或 <c>unix_chkpwd</c> 的 suid bit，否則您的使用者將無法 su 或接收郵件。經由移<!--
-->除這些檔案的 suid bit，同時排除了一般使用者 (或攻擊者) 從這些檔案奪取根
(root) 權限的可能。
</p>

<p>
我系統上僅存的 SUID 檔案只有 <c>su</c>、<c>passwd</c>、<c>gpasswd</c>、<!--
--><c>qmail-queue</c>、<c>unix_chkpwd</c> 以及 <c>pwdb_chkpwd</c>。不過如果您有
X，您可能有更多，因為 X 需要這些存取權限。
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules - 插入式認證模組)</title>
<section>
<body>

<p>
PAM 是套在程式中提供另一種認證方法的共享函式庫。<c>pam</c>這個 USE 旗標預設<!--
-->是打開的，所以 Gentoo Linux 上的 PAM 設定其實蠻合理的，不過事情永遠有進步<!--
-->的空間。首先安裝 cracklib：
</p>

<pre caption="Installing cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
這將安裝 cracklib，它會確定您的使用者使用至少八個字元以上的密碼，由至少兩個<!--
-->數字、兩個其他字元，而且必須有三個以上的字元與上一組相異。這可以強迫使用<!--
-->者選個好密碼 (密碼政策)。查閱 <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3"
>PAM</uri> 文件，他可以告訴您更多選項。
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
其他所有沒有在 PAM 設定資料夾 - <path>/etc/pam.d</path> 中設定的服務將會使用 
<path>/etc/pam.d/other</path> 中的規則。預設的設定如同預期的拒絕一切存取。不<!--
-->過我想要很多紀錄，所以我加上了 pam_warn.so。最後一個設定是 pam_limits，這將在
<path>/etc/security/limits.conf</path> 中設定。詳細的設定請參考相關章節。
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so 
auth     required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP Wrappers</title>
<section>
<body>

<p>
這是個您可以用來控制一般由 inetd (不過 Gentoo 沒有) 管理的服務的方法，不過它也可
以用來管理 xinetd 或其他服務。
</p>

<note>
這些服務應該在 xinetd 中的伺服器指令裡面執行 tcpd (在 xinetd 中)。查閱 xinetd
的小節以獲得更多資訊。
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
如同您看到的，它的格式與 <path>/etc/login.access</path> 非常相近。Tcpd 支援特定
的服務，而且他們工作在不同領域的安全上。這些設定只會套用在使用 tcp wrappers 的服
務上。
</p>

<p>
它也可以在某個服務被存取的時候執行某個指令 (可以在為撥接使用者啟動中繼的時候使用
)，不過建議您最好不要這樣做，因為人們傾向於製造比他們能解決的問題多更多的問題。
舉個例子，您可能想在每次某個人觸及拒絕條款的時候寄封電子郵件到自己的信箱，可是某
個攻擊者可以對您發動 DoS 攻擊，則您會收到幾億封郵件並製造一堆 I/O 問題，所以千萬
別這麼做。閱讀 <c>man 5 hosts_access</c> 以獲取更多資訊。
</p>

</body>
</section>
</chapter>

<chapter>
<title>核心安全</title>
<section>
<title>移除不必要的功能</title>
<body>

<p>
設定核心的基本規則是移除所有您不需要的東西。這會建立一個比較小的核心，同時也可以
避免那些可能存在驅動程式或其他功能中的漏洞。
</p>

<p>
同時考慮關閉模組載入支援 (loadable module support)，雖然說還是可以用這個以外的方
法加入模組 (根工具 - root kits)，不過它的確讓一般的攻擊者難以經由核心模組安裝根
工具 (root kits)。
</p>

</body>
</section>
<section>
<title>/proc (核心旗標)</title>
<body>

<p>
許多核心參數可以從 /proc 或 sysctl 被更改。
</p>

<p>
想在執行時期動態變更核心參數以及變數，您的 .config 中必須有 <c>CONFIG_SYSCTL</c>
選項。在 2.4 系列的核心中這是預設開啟的。
</p>

<pre caption="丟棄 ping 封包">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
這將讓您忽略 icmp type 0 (也就是 ping) 的封包。因為 icmp 會包括讓您意想不到的資
訊。系統管理員使用 ping 作為診斷系統的工具，而且他們可能會抱怨不能 ping。沒有理
由讓個陌生人來 ping 內部的機器，不過有時候讓內部的人可以 ping 也是蠻方便的，這可
以用從防火牆端將 icmp type 0 的封包取消來解決。
</p>

<pre caption="忽略廣播探測">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
這會停止回應廣播封包以及防止增幅攻擊。增幅攻擊的運作方法是傳送一個 ICMP type 0
(ping) 訊息至網路的廣播位置。通常攻擊者會偽裝成某個來源位置，所有網路上的電<!--
-->腦會回應這個 ping 訊息，然後被偽裝的來源就會收到一大堆 ping 訊息。
</p>

<pre caption="忽略來源路由 (source route) 封包">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
不要接受來源路由 (source route) 的封包。攻擊者可以使用源頭路由來產生假裝本來就在
您內部網路產生的封包，不過將會從他來的路徑路由回去，所以攻擊者可以危害您的網路。
源頭路由很少在正當的狀況下被使用，所以關閉它。
</p>

<pre caption="取消允許重新導向">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
取消允許 ICMP 重新導向。ICMP 重導向可以被用來更改您的路由表，可能轉到一條死<!--
-->胡同。
</p>

<pre caption="防備爛錯誤訊息">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
啟動針對無效錯誤訊息的防禦。
</p>

<pre caption="啟動反轉路徑過濾">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<note>
如果您啟動了 IP 轉送，這個也會自動被開啟。
</note>

<p>
啟動反轉路徑過濾。這可以幫助確認封包來自合法的源頭，經由自動捨棄那些網路位置不符
合應該進入的網路介面的封包。這有安全上的優點因為它防止 IP 偽造 (IP spoofing)。
</p>

<warn>
但是它也可能在您使用不對稱路由 (封包從您的機器到另一個機器的路徑與從它來到您<!--
-->的路徑不同) 的時候造成問題，或您在建設一台有多個 IP 位置來自不同介面的非<!--
-->路由機器。
</warn>

<pre caption="紀錄騙人的封包、源頭路由封包以及重新導向封包">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
紀錄騙人的封包、源頭路由封包以及重新導向封包。
</p>

<pre caption="關閉 IP 轉送">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
確認 IP 轉送是關閉的。我們只在 multi-homed 機器上需要這個東西。
</p>

<p>
全部這些設定都會在重新開機後被重設。所以我們建議您在
<path>/etc/sysctl.conf</path> 這個開機自動被 <path>/etc/init.d/bootmisc</path>
啟動稿啟用的檔案中加入它們。
</p>

<p>
<path>/etc/sysctl.conf</path> 的語法很直接，將之前提到的目錄中的
<path>/proc/sys</path> 拿掉，然後將 <path>/</path> 換成 <path>.</path>：
</p>

<pre caption="相對 sysctl.conf 的翻譯">
<comment>(使用 echo 的手動設定：)</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(自動的 sysctl.conf：)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
標準的 Gentoo 核心包含從 <uri link="http://grsecurity.net">Grsecurity</uri> 
取得的修正檔，不過預設不啟動。如同往常一般設定您的核心，然後從設定 Grsecurity
選項。有關可以使用的 Grsecurity 選項 (1.9 版) 的詳細解說可以在 <uri
link="http://www.gentoo.org/proj/en/hardened">Gentoo Hardened</uri> 計畫網頁找到。
</p>

<p>
最新的 <c>grsec-sources</c> 提供 2.* 版的 Grsecurity. 有關這個加強版 Grsecurity
的資訊可以在 <uri link="http://www.grsecurity.net/">Grsecurity 首頁</uri>
找到。
</p>

</body>
</section>
<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> 是在目前核心加入編碼功能的修正
檔。更新之後，您可以得到例如：Cryptographic ciphers、digest algorithms 以及 
cryptographic loop filters。
</p>

<warn>
目前 kerneli 修正檔在最新的核心中並不是完全穩定狀態，所以請小心服用。
</warn>

</body>
</section>
<section>
<title>其他核心修正檔</title>
<body>

<ul>
  <li>
    <uri link="http://www.openwall.com">The OpenWall Project</uri>
  </li>
  <li>
    <uri link="http://www.lids.org">Linux Intrusion Detection System</uri>
  </li>
  <li>
    <uri link="http://www.rsbac.org">Rule Set Based Access Control</uri>
  </li>
  <li>
    <uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri>
  </li>
  <li>
    <uri link="http://sourceforge.net/projects/wolk/">Wolk</uri>
  </li>
</ul>

<p>
其他地方很可能還有很多...
</p>

</body>
</section>
</chapter>

<chapter>
<title>加強服務的安全</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) 會送您一份很得體的設定檔，不過，再一次的，我們還是要改進某些<!--
-->東西。例如鎖定同一位置以及避免它洩漏太多資訊。這些是您應該加在設定檔中的<!--
-->選項：
</p>

<p>
如果您沒有在安裝 apache 之前於 <path>/etc/make.conf</path> 中取消 ssl 支援，<!--
-->您應該有個支援 ssl 的伺服器。只要加入以下的設定來啟動它：
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
# 讓它鎖定在您的 ip
Listen 127.0.0.1
BindAddress 127.0.0.1
# 在每個不用根 (root) 使用者執行的服務都使用 nobody 或 nogroup 並不是個好主意。
# (加入一位在 apache 群組的 apache 使用者)
User apache
Group apache
# 避免 apache 透漏太多資訊
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache 是根據 --enable-shared=max 和 --enable-module=all 設定編譯的。這會預設地
啟動所有模組，所以您必須自己將 LoadModule 區段 (LoadModule 和 AddModule) 中用不
到的模組註解掉。執行 <c>/etc/init.d/apache restart</c> 來重新啟動您的網頁伺服器
。
</p>

<p>
其他文件可以在 <uri>http://www.apache.org</uri> 找到。
</p>

</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
您可以在 <uri link="http://www.isc.org/products/BIND/bind9.html">Internet
Software Consortium</uri>找到 BIND 9 Administrator Reference Manual，它也被放在
<path>doc/arm</path> 下。
</p>

<p>
新的 BIMD ebuild 支援 chroot 至正常系統外。在 emerge 好 <c>bind</c> 之後，執<!--
-->行這些步驟l：
</p>

<pre caption="替換 BIND 的根目錄">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<comment>在執行上面的指令之前，您也許會想至 /etc/conf.d/named <!--
-->中變更 chroot 的資料夾，否則會使用預設的 /chroot/dns。</comment>
<comment>您可能必須將上述版本號碼換成您使用的版本號。</comment>
</pre>

</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
關於 djbdns 實在也沒什麼好說的，除了作者甚至願意在它有多安全上<uri 
link="http://cr.yp.to/djbdns/guarantee.html">賭錢</uri>以外。所以試試看吧：
<uri>http://www.djbdns.org/</uri>，它跟 Bind v.9 有很大的不同，不過您一定會抓到
訣竅的！
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
FTP (File Transfer Protocol - 檔案傳輸協定) 一般來說是個壞主意。它使用未編碼<!--
-->的資料，聽取兩個連接埠 (多半是埠號 20 以及 21)，支援匿名使用者，而且是某<!--
-->些攻擊者尋找的對象 (以便交換程式)。如果您可以，請考慮改用 <c>sftp</c> 或
HTTP，因為 ftp 協定含蓋了幾個問題 (例如，密碼以純文字傳送)。如果您非得使用
FTP，則盡可能加強服務的安全性並且做好心理準備。
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
若您只有本機應用程式要存取 <c>mysql</c> 資料庫，請將
<path>/etc/mysql/my.cnf</path> 中類似下面一行取消註解。
</p>

<pre caption="關閉網路存取">
skip-networking
</pre>

<p>
也將同一個檔案中的 <c>LOAD DATA LOCAL INFILE</c> 指令取消。
</p>

<pre caption="將 [mysqld] 中的 LOAD DATA LOCAL INFILE 取消">
set-variable=local-infile=0
</pre>

<p>
預設的 <c>mysql</c> 安裝程序會設定一個沒有密碼的 <c>root</c> 帳號。
</p>

<pre caption="設定 root 密碼">
<i>/usr/local/mysql/bin/mysql -u root</i> 
mysql> <i>SET PASSWORD FOR root@localhost=PASSWORD('new_password');</i>
</pre>

<note>
不直接從命令列變更密碼是個好主意，例如透過 <c>mysqladmin password</c> 指令。<!--
-->這個在有其他使用者的伺服器上更為重要，在這種情況下密碼會很容易被其他人知<!--
-->道，例如透過 <c>ps uax</c> 指令或查看歷史檔案 (<path>~/.history</path>、<!--
--><path>~/.bash_history</path> 等等)，若他們有這些重要權限的話。
</note>

<p>
接著，我們必須移除樣本資料庫 (test) 以及除了 <c>root</c> 帳號外的所有帳號。
</p>

<pre caption="移除樣本資料庫以及不用的使用者">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
若您已經設定了一些使用者帳號，請小心執行以上的指令。
</warn>

</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd 曾有過幾個安全性問題，不過大部份都已經解決了。我們還是作些補強：
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
# 別告訴別人我們的伺服器版本
ServerIdent on "Go away"

# 讓建立虛擬使用者容易些
RequireValidShell off

# 使用其他的密碼以及群組檔 (passwd 使用 crypt 格式)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# 權限
Umask 077

# 逾時及限制
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# 變更所有使用者的根目錄
DefaultRoot ~

# 別用根 (root) 使用者執行
User  nobody
Group nogroup

# 紀錄所有傳輸
TransferLog /var/log/transferlog

# globbing 問題
DenyFilter \*.*/
</pre>

<p>
剩下的掌握在您的閱讀能力上 (<uri>http://www.proftpd.org</uri>)。
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd 是原本 trollftpd 的一個分支。因為安全性的關係被 Frank Dennis 改寫。
</p>

<p>
藉由啟動 AUTH 選項來使用虛擬使用者 (永遠別用系統帳戶)。將它設成
<c>-lpuredb:/etc/pureftpd.pdb</c> 並且使用 <path>/usr/bin/pure-pw</path>
建立您的使用者。
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## 其他雜項 ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
將您的 <c>MISC_OTHER</c> 改成不允許匿名使用者 (<c>-E</c>)、將所有人變更根目錄 (<c>-A</c>)、使用者
不能讀取或寫入由 . (點) 開頭的檔案 (<c>-X</c>)、最大發呆時間 (<c>-I</c>)、限制循環 (<c>-L</c>)、以及
一個合理的權限遮罩。
</p>

<warn>
<e>不要</e> 使用 <c>-w</c> 或 <c>-W</c> 選項！如果您想要有個破解工具交換中心<!--
-->，別讀這份文件！
</warn>

<p>
<uri>http://www.pureftpd.org</uri> 可以找到更多資訊。
</p>

</body>
</section>
<section>
<title>Qmail</title>
<body>

<p>
Qmail 是被公認為最安全的郵件伺服器。它是在 (極端的) 安全考量下寫成的。它預設<!--
-->不允許轉寄，而且自 1996 年以來從未有過安全性漏洞。簡單地 <c>emerge qmail</c>
然後設定！
</p>

</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba 是個與 Microsoft/Novell 網路共享檔案的通訊協定，並且它 <e>不該</e> 被<!--
-->使用在 Internet 上。不管怎樣，我們還是加強它的安全。
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  # 鎖定在一個介面
  interfaces = eth0 10.0.0.1/32

  # 使用編碼的密碼
  encrypt passwords = yes
  directory security mask = 0700

  # 允許從 10.0.0.* 來的存取
  hosts allow = 10.0.0.

  # 啟動使用者認證
  # (不要使用 share 模式)
  security = user
  
  # 不允許特權帳戶
  invalid users = root @wheel

  # 加入顯示的最大磁碟空間 (非磁碟限額)
  max disk size = 102400

  # 堅持密碼政策
  min password length = 8
  null passwords = no

  # 使用 PAM (如果支援的話)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
確認每個分享的權限都設定正確，並仔細閱讀 
<uri link="http://www.samba.org">文件</uri>。
</p>

<p>
重新啟動伺服器，並加入應該存取這個服務的使用者。這個動作可以透過 
<path>/usr/bin/smbpasswd</path> 以及 -a 參數來達成。
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
對於 OpenSSH，您唯一要作的只有啟動基於公開金鑰的更強健的認證模式。許多網站 (例如
<uri>http://www.sourceforge.net</uri>、<uri>http://www.php.net</uri> 以及 
<uri>http://www.apache.org</uri>) 都因為密碼漏洞或爛密碼而造成的未授權入侵擔心受
怕。
</p>

<pre caption="/etc/ssh/sshd_config">
# 只啟動第二版
Protocol 2

# 不讓根 (root) 使用者直接登入
PermitRootLogin no

# 啟用公開金鑰認證
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# 取消 .rhost 檔案以及普通密碼認證
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

# 只接受來自 *.gentoo.org 的連線
AllowHosts *.gentoo.org

# 只準 wheel 和 admin 群組的成員登入
AllowGroups wheel admin

# 只允許上述群組中的兩個使用者
AllowUsers kn bs

# 紀錄
SyslogFacility AUTH
LogLevel INFO

# 鎖定連線位置
ListenAddress 127.0.0.1
</pre>

<p>
然後您的使用者所要作的，就是建立一組鑰匙 (在他們作為用戶端的機器上)，使用以<!--
-->下的指令：
</p>

<pre caption="建立一組 RSA 金鑰">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
然後輸入密碼
</p>

<pre caption="原始碼列舉 5.5：ssh-keygen 的輸出">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[按下確認鍵]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[輸入密碼]</i>
Enter same passphrase again: <i>[再次輸入密碼]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
這會在您的 <path>~/.ssh/</path> 目錄中加入 <path>id_dsa</path> 和
<path>id_dsa.pub</path> 兩個檔案。<path>id_dsa</path> 是您的私密金鑰而且應該<!--
-->避免被別人拿到，<path>id_dsa.pub</path> 則應該被放到您可以放的所有伺服器<!--
-->。將公開金鑰加入至使用者目錄下的 <path>~/.ssh/authorized_keys</path> 中，<!--
-->這個使用者應該就能登入了。
</p>

<p>
現在您的使用者應該妥善保存他們的私密金鑰。將它放在他們經常攜帶的媒體裡面或是存在
他們自己的工作站上 (將這加入<uri link="#doc_chap2">密碼政策</uri>裡)。
</p>

<p>
在 <uri link="http://www.openssh.org">OpenSSH</uri> 網站可以找到更多資料。
</p>

</body>
</section>
<section>
<title>使用 xinetd</title>
<body>

<p>
xinetd 是用來取代 inetd (Gentoo 剛好沒有) 的，所謂的網際網路服務惡魔 (internet 
services daemon)。它支援基於遠端機器位置以及存取時間的存取控制。它同時提供了加強
紀錄的能力，包括伺服器啟動時間、遠端機器位置、遠端使用者名稱、伺服器執行時間以及
要求的動作。
</p>

<p>
如同其他所有服務一般，有個好的預設設定是很重要的。不過畢竟 xinetd 是根 (root)
使用者用來支援您也許根本不知道的服務的，我們建議您不要使用它。但是如果您堅持<!--
-->想用，這裡將告訴您怎麼加強它的安全性：
</p>

<pre caption="安裝 xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
然後編輯設定檔：
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# 這將會經由 xinetd 設定一個有下列設定的 pserver (cvs)：
# 最多 10 個事件 (最高同時 10 個連線)
# 限制 pserver 只用 tcp
# 使用 cvs 使用者來執行這個服務
# 將介面鎖定在一個 ip 位置
# 允許來自 10.0.0.* 的連線
# 限制開發人員能使用 cvs 的時間於早上八點至下午五點
# 使用 tpcd wrappers (存取控制設定於 /etc/hosts.allow 以及 <!--
-->/etc/hosts.deny)
# 機器上的 max_load 設定成 1.0
# disable 旗標預設是設成 no，不過我喜歡將它加在這裡，
# 因為可能有時候我必須關閉它。
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
閱讀 <c>man 5 xinetd.conf</c> 以獲得更多資訊。
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (亦即 very secure ftp) 是個有合理的預設設定的 ftp 伺服器 (daemon)。它很簡
單，也沒有類似 pureftp 與 proftpd 的太多功能 (如虛擬使用者)。
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

# 禁止寫入
write_enable=NO

# 啟動傳輸紀錄
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
如您所見，沒辦法讓這項服務擁有獨立的權限，也沒有預設的變更目錄 (chroot) 動作。不
過當它用來作匿名 ftp 伺服器的時候倒是蠻有用的。某些時候有個匿名 ftp 伺服器 (可以
分享 Open Source 軟體) 也是不錯的，那麼這個伺服程式倒是剛好派上用場。
</p>

</body>
</section>
<section>
<title>X</title>
<body>

<p>
XFree 預設上是被設定成 X 伺服器。這可能非常危險，因為 X 使用未加密的 tcp 連線以
及聽取 xclient 們。
</p>

<impo>
若您不需要這項服務，把它關掉！
</impo>

<p>
若您必須將您的工作站當成 X 伺服器，小心地使用 <path>/usr/X11R6/bin/xhost</path>
指令。這個指令允許其他機器的用戶端連線並且使用您的顯示環境。這在您需要從遠端執行
X 應用程式而且只能透過網路的時候是很方便的。語法是 <c>/usr/X11R6/bin/xhost
+hostname</c>。
</p>

<warn>
永遠不要使用 xhost + 這項功能！這將允許任何用戶端連線並取得您 X 的控制權。如<!--
-->果某個使用者可以得到您 X 的權限，他可以取得您的按鍵紀錄並控制您的桌面。若<!--
-->您非得使用它，別忘了指定個主機。
</warn>

<p>
一個更安全的解決辦法是使用 <c>startx -- -nolisten tcp</c> 啟動 X 來完全關閉這項
功能，或是經由修改設定檔中的這幾行指令以永遠地取消這項功能。
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
確定 <path>startx</path> 不會在每次更新 Xfree 的時候被覆蓋，您必須保護它。將<!--
-->下面一行加入至 <path>/etc/make.conf</path>：
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
如果您使用圖形化登入管理員，則世界會有點不同。
</p>

<p>
<c>gdm</c> (Gnome Display Manager)
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
<c>xdm</c> (X Display Manager) 以及 <c>kdm</c> (Kde Display Manager)
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>
</chapter>

<chapter>
<title>假的根目錄 (chroot) 或虛擬伺服器 (virtual servers)</title>
<section>
<title>假根目錄</title>
<body>

<p>
將某個服務切換到假的跟目錄，是個將服務 (或使用者) 環境限制在他們只該存取的地<!--
-->方以及避免他們得到根 (root) 使用者的存取權或系統相關資料的好方法。經由以<!--
-->根使用者以外的使用者 (<c>nobody</c>、<c>apache</c>、<c>named</c>) 執行服<!--
-->務，攻擊者只能存取這些使用者有權存取的檔案。這表示攻擊者無法得到根 (root)
權限 - 即使這個服務程式有安全上的漏洞。
</p>

<p>
某些服務 (例如 <c>pure-ftpd</c> 以及 <c>bind</c>) 有變換根目錄 (chroot) 的功<!--
-->能，而其他的服務沒有。如果某個服務支援它，那就用吧！不然的話您可能得想個<!--
-->其他辦法。接下來看看該怎樣做出一個假的根目錄環境，以及初步了解它怎麼工作<!--
-->，我們會以 <c>bash</c> 來解釋 (講起來比較簡單)。
</p>

<p>
透過 <c>mkdir chroot</c> 建立 <path>/chroot</path> 目錄。然後找出 <c>bash</c>
在編譯的時候使用的動態函式庫 (如果您以 -static 編譯則不必作這個動作)。
</p>

<p>
接下來的指令會建立一份有被 <c>bash</c> 使用到的函式庫清單。
</p>

<pre caption="取得使用的函式庫清單">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
然後建立給 bash 使用的假根環境。
</p>

<pre caption="建立 bash 的假根環境 (chroot-environment)">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
再來將 <c>bash</c> 使用到的檔案 (<path>/lib</path>) 複製至假根目錄的 <path><!--
-->lib</path> 目錄，並將 bash 本身複製至假的 <path>bin</path> 目錄。這能建立<!--
-->一個完全一樣的環境，只不過功能少了點。在複製完後測試一下：<c>chroot
/chroot/bash</c>。如果您有個寫著 <c>/</c> 的提示符號，就表示成功了！否則它應<!--
-->該會告訴您缺了什麼東西，某些共享函式庫也會用到其他共享函式庫的東西。
</p>

<p>
您會注意到，在這個假根環境中什麼事都不能作，除了 echo。這是因為我們沒有把其<!--
-->他指令放進這個假根環境，而 "echo" 指令剛好是 bash 的內建功能之一。
</p>

<p>
基本上這跟建立假根環境服務的步驟差不多，唯一的差別是有時候某些服務會使用到一<!--
-->些  <path>/etc</path> 下的設定或設備。簡單的把他們複製 (設備檔可以用 <c>cp
-a</c> 複製) 到假根環境，然後編輯執行前的起始命令稿以啟用假的根目錄。找出服<!--
-->務使用到的設備或設定也許不簡單，這也是為什麼 <c>strace</c> 指令很方便的原<!--
-->因。使用 <path>/usr/bin/strace bash</path> 啟動服務，然後找出 open、read<!--
-->、stat、或 connect。這能給您一些關於需要複製檔案的線索。但是大部份的狀況<!--
-->下，只要複製 passwd 檔案 (改一下它的副本把用不到的使用者移除掉)、<path><!--
-->/dev/zero</path>、<path>/dev/log</path> 和 <path>/dev/random</path>。
</p>

</body>
</section>
<section>
<title>虛擬伺服器</title>
<body>

<p>
另一個建立更安全環境的方法是透過虛擬伺服環境 (virtual server environment)。<!--
-->這會建立一個虛擬的 Linux 環境並且將它啟動至虛擬模式 (virtual mode)。這表<!--
-->示如果某個伺服器被破壞了，真實的系統並不會被影響到，只會影響到虛擬的系統。
</p>

<p>
虛擬伺服器的例子：
</p>

<ul>
  <li>
    <uri link="http://user-mode-linux.sourceforge.net">使用者模式 Linux 
    (User-Mode Linux)</uri> 以及一篇關於 <uri 
    link="http://www.gentoo.org/doc/uml.html">User-Mode Linux</uri> 的 howto。
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>防火牆</title>
<section>
<title>一面防火牆</title>
<body>

<p>
人們總是以為防火牆是終極的安全，其實他們錯了。大部份的狀況下，一面錯誤設定的<!--
-->防火牆還比根本沒有防火牆來得更糟。防火牆同時也是一種程式，也需要像其他服<!--
-->務一般對待它，因為它也跟其他程式一樣會出錯 (例如安全性漏洞)。
</p>

<p>
所以，砌牆之前先考慮考慮！您真的有這個需要嗎？如果您覺得真的需要，則將它該怎<!--
-->麼工作以及誰應該管理它定義在政策中。
</p>

<p>
使用防火牆有兩個目標：
</p>

<ul>
  <li>把使用者 (蟲╱攻擊者) 擋在外面</li>
  <li>把使用者 (員工╱小孩) 擋在裡面</li>
</ul>

<p>
一般來說有三種基本型態的防火牆：
</p>

<ul>
  <li>封包過濾 (Packet filtering)</li>
  <li>迴路轉接 (Circuit relay)</li>
  <li>應用層級閘道器 (Application gateway)</li>
</ul>

<p>
防火牆應該是台專心防火的機器，沒有其他服務執行 (或者只跑一下 <c>ssh</c>)，並<!--
-->且依照這篇指南建議的方法加強安全性。
</p>

</body>
</section>
<section>
<title>封包過濾 (Packet filtering)</title>
<body>

<p>
所有網路的資料都是以封包 (packet) 的形式傳輸。大型的傳輸會為了處理簡單而被切<!--
-->割成小封包，到達目的地之後才重新被組合起來。所有的封包都內含它要去那裡以<!--
-->及應該怎樣送達。而這些資料也是封包過濾防火牆所使用的。過濾通常基於以下資料：
</p>

<ul>
  <li>基於封包的來源╱目的 IP 位置決定允許或駁回</li>
  <li>基於封包的來源╱目的埠口決定允許或駁回</li>
  <li>基於封包的通訊協定決定允許或駁回</li>
  <li>基於封包在通訊協定中的旗標決定允許或駁回</li>
</ul>

<p>
封包過濾以封包的擋頭的資訊來過濾，而不是檢查封包內的資料。
</p>

<p>
缺點：
</p>

<ul>
  <li>
    封包中有關的位置的資訊可能是無效的，例如某台機器<e>假裝</e>成另一台機器。
  </li>
  <li>
    允許通過的封包中可能包含我們不想要的資料或要求，這可能也允許攻擊者利用在<!--
    -->防火牆上或防火牆後某項服務的已知漏洞。
  </li>
  <li>通常發生一點小問題就可以被攻破 (single point of failure)</li>
</ul>

<p>
優點：
</p>

<ul>
  <li>架設簡單</li>
  <li>可以在攻擊真正發生之前給予警告 (經由埠口掃描偵測)</li>
  <li>在防止 SYN 攻擊上有很好的效果</li>
</ul>

<p>
Linux 上一些自由封包過濾的例子：
</p>

<ul>
  <li>
    <uri link="http://www.iptables.org">Iptables</uri>
  </li>
  <li>
    <uri
    link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
  </li>
  <li>
    <uri link="http://www.smoothwall.org">SmoothWall</uri>
  </li>
</ul>

</body>
</section>
<section>
<title>迴路轉接 (Circuit relay)</title>
<body>

<p>
或稱為迴路級閘道器，是在允許交換資料之前驗證連線的防火牆。這表示它不只檢察封<!--
-->包的擋頭，還包括基於已設定的規則來驗證擋頭的資料是否屬實，在驗證成功之後<!--
-->。才會開啟連線階段並且允許資料交換。基於這些資料過濾：
</p>

<ul>
  <li>來源╱目的的位置</li>
  <li>來源╱目的的埠口</li>
  <li>時段</li>
  <li>通訊協定</li>
  <li>使用者</li>
  <li>密碼</li>
</ul>

<p>
所有往來都會被驗證、監視，而沒被驗證或監視的往來則會被駁回。
</p>

<p>
缺點：
</p>

<ul>
  <li>在傳輸層運作，而且需要變更提供相關傳輸功能的程式。</li>
</ul>

</body>
</section>
<section>
<title>應用層級閘道器 (Application gateway)</title>
<body>

<p>
應用層級閘道器是其他程式的代理伺服器，代理它的用戶端來作資料交換。它以確認外<!--
-->界不會跟內部建立直接連線來確保非軍事區 (De-Militarized Zone，屬於私有網路<!--
-->內部，但是可以被外界存取的部份。) 或防火牆下游區域的安全。基於以下資料過濾：
</p>

<ul>
  <li>基於來源來源╱目的決定允許或駁回</li>
  <li>基於封包的內容</li>
  <li>基於檔案類型或延伸檔名限制檔案的存取。</li>
</ul>

<p>
優點：
</p>

<ul>
  <li>可以快取檔案，增進網路效能</li>
  <li>可以對所有連線作詳細的紀錄</li>
  <li>伸縮自如 (某些代理伺服器可以 "共享" 快取檔案)</li>
  <li>對外沒有直接連線</li>
  <li>可以即時變更封包內容</li>
</ul>

<p>
缺點：
</p>

<ul>
  <li>設定複雜</li>
</ul>

<p>
應用層級閘道器是公認最安全的方案，由於它不用以根 (root) 使用者權限執行，也不<!--
-->用對整個網際網路公開。
</p>

<p>
應用層級閘道器的例子：
</p>

<ul>
  <li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
要讓 iptables 工作，它必須在核心被啟動。我將它加入成模組 (<c>iptables</c> 指<!--
-->令會視需要的時候載入它們) 然後重新編譯核心。更多有關如何在核心中啟用 iptables
的資訊，請見 <uri
link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">
Iptables Tutorial Chapter 2: Preparations</uri>。在您將核心編譯完成之後 (或<!--
-->一邊編譯的時候)，您必須安裝 <c>iptables</c> 命令。簡單地 <c>emerge
iptables</c> 應該就可以了。
</p>

<p>
現在經由執行 <c>iptables -L</c> 來測試它是否能工作。如果失敗了，則可能有什麼東西
弄錯了，而您可能得重新檢查一下設定檔。
</p>

<p>
Iptables 是個 Linux 2.4.x 的核心中新的而且大進步的封包過濾系統。它比 Linux 2.2.x
版中的來得成功。最重要的進步就是它可以依照狀態過濾封包。透過狀態封包過濾，它<!--
-->將能追蹤每個已經建立的 TCP 連線。
</p>

<p>
我們知道所有的 TCP 都是由一連串的封包組成的。每個封包都含有這些資訊：來源位置、
目的位置、以及一個幫助重組資料的流水號。而我們也知道 TCP 是連線導向而 UDP 不是，
對吧？這些就是它儲存的 "狀態"。現在您應該在問自己 "那又怎樣？"，別急，我正要接著
說下去。
</p>

<p>
一個 TCP 連線包含一連串內有來源 IP 位置、目的 IP 位置、編號 (到了目的地之後<!--
-->才知道資料該如何重組，也才知道誰有到誰沒到) 的封包。TCP 是連線導向的通訊<!--
-->協定，剛好跟非連線導向的 UTP 相反。
</p>

<p>
藉由驗證 TCP 封包表頭，一個狀態封包過濾器可以得知剛接受的封包是不是現有連線<!--
-->的一部份，然後決定要接受還是丟棄這個封包。
</p>

<p>
怪客可以透過變更 TCP 封包檔頭來晃點非狀態封包過濾器，讓它接受那些本來應該被<!--
-->丟棄的封包。這可以透過更改 TCP 封包檔頭中的 SYN 旗標或其他旗標來達成。若<!--
-->您使用狀態導向封包過濾器，它則能夠判斷出這個封包不是使用中連線的一部份而<!--
-->拋棄它。這也能防止 "機密偵測" 的可能性，因為這些封包不是現有連線的一部份。
</p>

<p>
Iptables 也提供其他功能，譬如 NAT (Network Address Translation) 以及流量限制<!--
-->。流量限制在防止 DoS (Denial of Service) 攻擊 (例如 SYN flood) 的時候特別<!--
-->有效。
</p>

<p>
TCP 連線透過三道確認手續來建立連線。當建立 TCP 連線時，用戶端傳送一個設置了 SYN
旗標的封包至伺服器。伺服器端收到這個封包以後，會傳送一個 SYN+ACK 封包回用戶<!--
-->端。用戶端收到 SYN+ACK 封包以後，會再回覆一個 ACK 封包，表示確認連線。
</p>

<p>
所謂 SYN 攻擊，就是只傳送 SYN 封包 (檔頭只有 SYN 旗標的封包)，而不繼續理會下面兩
個建立連線的封包。一個 SYN 封包並不用包含有效的傳送者位置 (IP) 因為它不需要回覆
。所以這個連線會一直開起直到逾時為止。現在，某個攻擊者丟給您一拖拉庫包含無效傳送
者 IP 的 SYN 封包，您的電腦將持續等待永遠等不到的回應。基於您系統的逾時設定，這
個連線會持續 30-60 秒 (也許更久)。直到可以使用的連線數目全部被用完，而您的電腦將
無法跟任何其他機器通訊。
</p>

<p>
這就是為什麼流量限制好用的原因。它可以使用 <c>-m limit --limit 1/s</c> 來限制單
一來源的 SYN 封包。這將把 SYN 封包限制在一個來源只有一個，以制止大量的 SYN 封包
將資源淹沒掉。
</p>

<p>
現在！一些實用的東西！
</p>

<p>
當 iptables 載入您的核心之後，則有五個鉤子可以掛您的規則。它們叫做 <c>INPUT<!--
--></c>、<c>OUTPUT</c>、<c>FORWARD</c>、<c>PREROUTING</c> 以及 <c><!--
-->POSTROUTING</c>。這些清單叫做串鍵 (chains) 因為它依照您加入規則的順序檢查<!--
-->封包，而走到某個規則的時候，這個規則決定丟棄這個封包，則這個封包就會直接<!--
-->被丟棄，下面的規則也不會被執行。
</p>

<p>
您可以將規則加入至五個主要串鍵，或建立您自己的串鍵然後加入至主串鍵中。Iptables
支援以下指令：
</p>

<table>
<tr>
  <th>選項：</th>
  <th>說明：</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>增加 (Append)</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>刪除 (Delete)</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>插入 (Insert)</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>取代 (Replace)</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>清單 (List)</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>將某串鍵或所有串鍵中的規則刪除</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>將某串鍵或所有串鍵的計數器設為零</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>在串列上測試這個封包</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>建立一個新的使用者定義的串鍵</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>移除某個使用者定義的串鍵</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>改變某串鍵的政策</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>改變串鍵名稱</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>通訊協定</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>來源位置遮罩</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>目的地位置╱遮罩</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>輸入裝置 (網路裝置名稱)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>輸出裝置 (網路裝置名稱)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>跳至 (規則的目標)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>延伸比較 (可能使用附加模組)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>以數字型態列出位置和埠口</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>指定要操縱的列表</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>吵雜模式 (Verbose mode)</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>展開數字 (顯示確切的數值)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>只符合第二或以後的片段</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>列出 iptables 的版本</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>在列出清單的時候顯示行號</ti>
</tr>
</table>

<p>
首先我們試著擋住所有來到我們機器的 ICMP 封包，熟悉一下 iptables 指令的用法。
</p>

<pre caption="阻擋所有 ICMP 封包">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
一開始我們指定想要新增的串鍵，接著指定協定，再來是規則。規則可以是 <c>ACCEP<!--
--></c>、<c>DROP</c>、<c>REJECT</c>、<c>LOG</c>、<c>QUEUE</c>、<c>MASQUERADE<!--
--></c>。在這個案例裡我們使用 <c>DROP</c>，它將在不回覆用戶端的狀況下丟棄這<!--
-->個封包。
</p>

<p>
現在試著 <c>ping localhost</c>。您將無法獲得任何回應，因為我們將所有的來到這<!--
-->台電腦的 ICMP 封包都阻擋起來了。它也讓您無法 ping 其他電腦，因為傳送回來的
ICMP 回應封包也會被擋住。現在清乾淨您的串鍵，讓 ICMP 再次工作。
</p>

<pre caption="清空所有規則">
# <i>iptables -F</i>
</pre>

<p>
現在我們看看 iptables 中有關狀態的部份。如果我們想要檢查從 eth0 進入的封包狀<!--
-->態，我們可以這樣作：
</p>

<pre caption="允許來自已經建立連線的封包">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
這將允許所有已經連線或相關於 <c>INPUT</c> 串鍵的封包。而您可以將不存在狀態列<!--
-->表的封包使用以下方法丟棄：<c>iptables -A INPUT -i eth0 -m state --state
INVALID -j DROP</c>。這經由載入加強功能來啟動 iptables 的狀態控制部份。如果<!--
-->您想要外界可以連線至您的電腦，您可以使用 <c>--state NEW</c>。Iptables 包<!--
-->含一些不同意圖的模組，這裡列出一部份：
</p>

<table>
  <tr>
    <th>模組符合</th>
    <th>敘述</th>
    <th>延伸選項</th>
  </tr>
  <tr>
    <ti>mac</ti>
    <ti>符合進入封包的硬體位置</ti>
    <ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti>
    <ti>啟動狀態檢查</ti>
    <ti>--state (狀態有 ESTABLISHED、RELATED、INVALID、NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti>
    <ti>流量限制控制</ti>
    <ti>--limit、--limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti>
    <ti>試圖符合多方面的封包建立者的特性</ti>
    <ti>--uid-owner userid、--gid-owner groupid、--pid-owner processid、--sid-owner
    sessionid</ti>
  </tr>
  <tr>
    <ti>unclean</ti>
    <ti>隨機的檢查</ti>
    <ti></ti>
  </tr>
</table>

<p>
讓我們試著建立一個使用者定義串鍵並將它套用至某個已經存在的傳鍵：
</p>

<pre caption="建立使用者定義串鍵">
<comment>(建立一個只有一項規則的新串鍵)</comment>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(預設的政策是所有出去的傳輸都許可，進來的則忽略。)</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(將它加入至 INPUT 串鍵)</comment>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
經由在 INPUT 串鍵套用這個規則，我們得到一個政策：所有出去的傳輸都許可，進來<!--
-->的除非已經建立連線否則忽略。一般來說這是個爛主意。預設的政策應該是丟棄，<!--
-->但是這是個只是個例子。
</p>

<p>
如果您想要更多文件，請參閱 <uri 
link="http://www.iptables.org/documentation/index.html#HOWTO">iptables 
documentation</uri>。
</p>

<p>
讓我們看一些真正的例子。在這個例子裡我的防火牆╱閘道器指示：
</p>

<ul>
  <li>只允許 SSH (埠口 22) 連線至防火牆。</li>
  <li>內部網路應該有權使用 HTTP、HTTPS 以及 SSH (DNS 應該也被允許)。</li>
  <li>包含大量負載的 ICMP 傳輸會被拒絕。當然我們必須允許一些 ICMP 傳輸。</li>
  <li>應該能偵測到埠口掃描然後記錄下來。</li>
  <li>防止 SYN 攻擊。</li>
  <li>其他任何傳輸應該被忽略並記錄。</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  # 預設規則
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  # ICMP 傳輸
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  # 進來的傳輸
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  # 出去的傳輸
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  # 偵測掃描埠口的傢伙
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # 在串鍵套用以及增加無效的狀態
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  # 允許用戶端可以透過 NAT (Network Address Translation - 網路位置轉譯) 路由
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<p>
一些建立防火牆的忠告：
</p>

<ol>
  <li>在實際建立防火牆之前先擬定政策</li>
  <li>盡量讓它簡單</li>
  <li>
    了解通訊協定到底怎麼工作 (閱讀 <uri link="http://www.ietf.org/">RFC</uri>
    (Request For Comments))
  </li>
  <li>永遠記得，防火牆只是另外一個以根 (root) 使用者執行的程式。</li>
  <li>測試您的防火牆</li>
</ol>

<p>
如果您覺得 iptables 很難了解或是要花太多時間設定一個得體的防火牆，您可以使用 
<uri link="http://www.shorewall.net">Shorewall</uri>。它基本上使用 iptables 來建
立防火牆規則，不過它著重於規則而不是特定的通訊協定。
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid 是一套非常強大的代理伺服器，它可以當過濾器，基於：時間、正規表示式的路<!--
-->徑 / 資源位置、來源和目的 IP 位置、網域、瀏覽器、認證的使用者、資料類型以<!--
-->及埠口 (通訊協定) 來允許或拒絕傳輸。我很有可能忘記了一些其他功能，不過要<!--
-->記住整個功能列表不是件容易的事。
</p>

<p>
以下的例子中, 我只用了廣告過濾而不是色情網站過濾。原因呢，因為 Gentoo.org 
<e>不應該</e>被放進色情網站清單裡。而我又不想花時間幫您搜尋色情網站。
</p>

<p>
在這個案例，我的政策指出：
</p>

<ul>
  <li>
    在工作時間 (星期一至星期五的八點至十七點以及星期六的八點至十三點) 上網 (HTTP
    /HTTPS) 是被允許的。如果他們遲到了，他們應該工作，不是上網。
  </li>
  <li>
    不准下載檔案 (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg... 諸如此類)
  </li>
  <li>
    我們不喜歡廣告，所以我們將它換成一個透明的 gif 檔案 (這裡就是您可以發揮<!--
    -->創意的地方！)
  </li>
  <li>
    任何其他連進來或連出去的連線都不被允許
  </li>
</ul>

<p>
這由四步 "簡單" 的動作就能達成
</p>

<pre caption="/etc/squid/squid.conf">
# 鎖定在一個 IP 以及埠口
http_port 10.0.2.1:3128

# 標準設定
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# 建立基本存取控制列表
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

## 加入可以使用這台代理伺服器的人
acl localnet src 10.0.0.0/255.255.0.0

# 以及埠口
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# 建立基於網址內的正規表示式的存取控制列表
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# 建立基於時間和日期的存取控制列表
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

# 允許管理者從本機存取
http_access allow manager localhost
http_access deny manager

# 只允許從本機來的清除要求
http_access allow purge localhost
http_access deny purge

# 不允許從不明埠口來的連線
http_access deny !Safe_ports

# 不允許從非 SSL 埠口進來的連線
http_access deny CONNECT !SSL_ports

# 我自己的規則

# 加入用來取代廣告的網頁
deny_info NOTE_ADS_FILTERED url_ads

# 然後拒絕它們
http_access deny url_ads

# 拒絕所有看起來像用來下載的檔案
http_access deny archives

# 加強管制工作時間的存取
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# 拒絕其他一切的一切
http_access deny all
</pre>

<p>
接著填入您不想使用者下載的檔案。我放了加入了 zip、viv、exe、mp3、rar、ace、avi、
mov、mpg、mpeg、au、ra、arj、tar、gz 和 z 檔案。
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
請記得在 [] 內填入包含大寫以及小寫的字元。這是為了確定沒有人可以用存取 AvI
而不是 avi 來欺騙您的代理伺服器。
</note>

<p>
接下來，我們將使用正規表示式來驗證廣告。您應該比我更有創造力才是：
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
最後的一步，我希望這個檔案會在移除廣告的時候被顯示。它基本上是半個有張 4x4 透明 
gif 圖案的 html。
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
不要關閉 &lt;HTML&gt; 跟 &lt;BODY&gt; 標籤。Squid 會幫您把它關上。
</note>

<p>
如您所見，Squid 有很大的可能性，而且在代理伺服和過濾上都很有您還可以使用可選擇的
Squid 伺服器來服務一個非常大型的網路。我在這裡列出的設定是適合 1~20 人的小型網路
的。
</p>

<p>
可是結合封包過濾器 (iptables) 以及應用層級閘道器 (squid) 大概是最好的解決方案，
即使 squid 是位於某個安全而沒有人可以從外部入侵的位置，我們還是要考慮從內部滲透
的攻擊者。
</p>

<p>
現在您必須在用戶端的瀏覽器加入代理伺服器的位置。這個閘道器會防止使用者對外連線，
除非他們透過代理伺服器。
</p>

<note>
在 Mozilla 中，這個選項在 Edit->Preferences->Advanced->Proxies。
</note>

<p>
您也可以用 iptables 來將所有對外的連線透明的轉送至 Squid 代理伺服器。在您的閘道
器上加入以下規則可以做到：
</p>

<pre caption="將埠口轉送至我們的代理伺服器">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>
<section>
<title>現在，我們學到了什麼？</title>
<body>

<p>
我們學到了：
</p>

<ol>
  <li>防火牆本身也是個風險。一面設定不良的防火牆比根本沒有防火牆來得更糟。</li>
  <li>如何建立基本的閘道器以及隱形代理伺服器。</li>
  <li>建立好防火牆的關鍵在於您了解您想要開放的通訊協定。</li>
  <li>IP 傳輸並不總是攜帶了正當的資料。舉個例，大量的 ICMP 封包。</li>
  <li>如何防止 SYN 攻擊。</li>
  <li>藉由過濾 HTTP 傳輸來防止討厭的圖片以及避免下載到病毒。</li>
  <li>混用封包過濾器以及應用層級閘道器可以更完美的控制權限。</li>
</ol>

<p>
現在，如果您<e>真的</e>覺得需要，去砌一面符合您需求的防火牆吧！
</p>

</body>
</section>
</chapter>

<chapter>
<title>入侵偵測</title>
<section>
<title>AIDE (進階入侵偵測環境 - Advanced Intrusion Detection Environment)</title>
<body>

<p>
Aide 是主機導向 (host based) 的入侵偵測系統 (Tripwire 之外的另一個自由選擇)<!--
-->。如果您已經了解 Tripwire，那在了解 Aide 的設定檔上應該不會有太大的障礙。
</p>

<p>
設定檔是基於套用在檔案以及目錄上的標準表示式、巨集以及規則。我們有以下的巨集：
</p>

<table>
  <tr>
    <th>巨集</th>
    <th>敘述</th>
    <th>語法</th>
  </tr>
  <tr>
    <ti>ifdef</ti>
    <ti>如果定義了 (If definded)</ti>
    <ti>@@ifdef "name"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti>
    <ti>如果沒有定義 (If not defined)</ti>
    <ti>@@ifndef "name"</ti>
  </tr>
  <tr>
    <ti>define</ti>
    <ti>定義一個變數</ti>
    <ti>@@define "name" "value"</ti>
  </tr>
  <tr>
    <ti>undef</ti>
    <ti>取消定義一個變數</ti>
    <ti>@@undef "name"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti>
    <ti>如果 "站台名稱"</ti>
    <ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti>
    <ti>如果沒有 "站台名稱"</ti>
    <ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
    <ti>endif</ti>
    <ti>endif 一定要在以上的巨集之後出現，除了 define 和 undef</ti>
    <ti>@@endif</ti>
  </tr>
</table>

<p>
這些巨集在您有一台以上的 Gentoo 電腦而您又希望在他們全部上面都使用 Aide 的時候會
變得很方便。畢竟不是所有機器都執行同樣的服務或擁有同樣的使用者。
</p>

<p>
接下來我們有一套旗標，用以檢查檔案或目錄。這些是檔案權限、檔案內容、
以及編碼雜湊╱校驗值。
</p>

<table>
<tr>
  <th>旗標</th>
  <th>敘述</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>權限 (permissions)</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>inode</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>連結數 (number of links)</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>使用者 (user)</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>群組 (group)</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>大小 (size)</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>區塊數量 (block count)</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>最後變更時間 (mtime)</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>最後存取時間 (atime)</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>建立時間 (ctime)</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>檢查變更的大小</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>md5 雜湊</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>sha1 雜湊</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>rmd160 雜湊</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>tiger 雜湊</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>清空群組</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>以 p+u+g+i+n+S 格式紀錄</ti>
</tr>
</table>

<p>
如果 Aide 是編譯成有 mhash 支援，那麼它還有其他幾個旗標：
</p>

<table>
  <tr><th>旗標</th><th>敘述</th></tr>
  <tr><ti>haval</ti><ti>haval 雜湊</ti></tr>
  <tr><ti>gost</ti><ti>gost 雜湊</ti></tr>
  <tr><ti>crc32</ti><ti>crc32 雜湊</ti></tr>
</table>

<p>
接著，您可以藉由這樣混合旗標來建立您自己的規則：
</p>

<pre caption="建立 AIDE 的規則集">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
建立我們自己的設定檔的最後一個步驟就是決定要怎樣在檔案或目錄上套用規則。基本上您
只要用鍵盤敲進規則以及檔名或目錄名就可以了。Aide 會遞迴的加入所有的檔案，除非您
需要其他什麼東西。
</p>

<table>
<tr>
  <th>旗標</th>
  <th>敘述</th>
</tr>
<tr>
  <ti>!</ti>
  <ti>不要加入這個檔案或目錄</ti>
</tr>
<tr>
  <ti>=</ti>
  <ti>加入這個目錄，不過不要遞迴處理。</ti>
</tr>
</table>

<p>
最後讓我們看看詳細的設定。
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# 要讀取的資料庫的位置
database=file:@@{AIDEDIR}/aide.db

# 要寫入的資料庫的位置
database_out=file:aide.db.new

verbose=20
report_url=stdout

# 定義的規則
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
在以上的例子，我們使用巨集來指定最高層的目錄以及 Aide 的主目錄。Aide 在檢查檔案
完整性的時候使用 <path>/etc/aide/aide.db</path> 資料庫，可是在更新或建立新檔案的
時候它將資訊存入 <path>/etc/aide/aide.db.new</path> 資料庫，這是為了確保它不會自
動覆蓋舊的資料庫檔案。而 report_url 這個選項是個 "未來" 的功能，現階段還沒有任何
意義。不過作者的打算是要讓它可以傳送電子郵件或甚至執行命令稿。
</p>

<p>
在您建立您的設定檔以後您應該使用 aide -i 來建立資料庫，並且將檔案 
<path>/etc/aide/aide.db.new</path> 複製到 <path>/etc/aide/aide.db</path>，然<!--
-->後使用 root 執行 <c>crontab -e</c> 再輸入以下程式碼以將檢查加入至排程好定<!--
-->期執行。
</p>

<note>
基於您的 CPU、磁碟效能以及設定的旗標，這可能會耗費一點時間。
</note>

<pre caption="將 Aide 加入工作排程">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
請記得要設定根 (root) 使用者的郵件。不然您將永遠不知道 Aide 報告了什麼。
</note>

<p>
在這個例子裡它每天下午三點會執行一次，這是因為我不想在上班時間打攪我的使用者。注
意我使用 -u (更新) 選項而不是 -C (檢查)。畢竟 -u 也檢查檔案並且不會覆蓋原來的資
料庫檔案，這將節省一些時間，例如在它偵測到變動的時候您只需要複製一個檔案。簡單的
檢查這些變更，看看是不是您更動這些檔案的，或是某些攻擊者在您之前更動了這些檔案！
</p>

<p>
現在把資料檔存在本機上還有個問題。某些攻擊者會 (如果他們知道您安裝了 Aide) 想辦
法編輯資料庫檔案、更新資料庫檔案或編輯 <path>/usr/bin/aide</path>。所以您應該將
這些資料檔的副本以及 Aide 的執行檔複製到 CD 或其他媒體上。
</p>

<p>
更多資訊可以在 <uri link="http://www.cs.tut.fi/~rammer/aide.html">aide's</uri> 
找到。
</p>

<note>
請記得要設定根 (root) 使用者的郵件。不然您將永遠不知道 Aide 報告了什麼。
</note>

<p>
在這個例子裡它每天下午三點會執行一次，這是因為我不想在上班時間打攪我的使用者。注
意我使用 -u (更新) 選項而不是 -C (檢查)。畢竟 -u 也檢查檔案並且不會覆蓋原來的資
料庫檔案，這將節省一些時間，例如在它偵測到變動的時候您只需要複製一個檔案。簡單的
檢查這些變更，看看是不是您更動這些檔案的，或是某些攻擊者在您之前更動了這些檔案！
</p>

<p>
現在把資料檔存在本機上還有個問題。某些攻擊者會 (如果他們知道您安裝了 Aide) 想辦
法編輯資料庫檔案、更新資料庫檔案或編輯 <path>/usr/bin/aide</path>。所以您應該將
這些資料檔的副本以及 Aide 的執行檔複製到 CD 或其他媒體上。
</p>

<p>
更多資訊可以在 <uri link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>
的專案網頁找到。
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort 是個 NIDS (網路入侵偵測系統 - Network Intrusion Detection System)。使<!--
-->用以下的例子來安裝並設定它。
</p>

<pre caption="將 snort 使用者加入至系統">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>(第一步)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(第二步)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(第三步)</comment>
include classification.config

<comment>(第四步)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# 新的分類
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
更多資訊可以在 <uri link="http://www.snort.org">Snort</uri> 網站找到。
</p>

</body>
</section>
</chapter>

<chapter>
<title>保持最新狀態</title>
<section>
<body>

<p>
當您成功的安裝了系統並建立了安全的系統層集之後，其實還沒完。安全是個每天都在<!--
-->改變的程序，您必須將您的系統保持在最新的狀態，例如最新的安全更新檔。
</p>

<p>
若您安裝了最近的 <c>portage</c>，您可以先透過 <c>emerge sync</c> 指令同步
portage 目錄樹，然後使用 <c>glsa-check --list</c> 檢查您的系統上是否有舊的漏洞。
</p>

<pre caption="glsa-check -l 的輸出範例">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be 
used on production systems. It's mainly a test tool for the new GLSA release 
and distribution system, it's functionality will later be merged into emerge 
and equery. 
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml 
before using this tool AND before reporting a bug. 
 
[A] means this GLSA was already applied, 
[U] means the system is not affected and 
[N] indicates that the system might be affected. 
 
200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy ) 
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman ) 
....... 
</pre>

<warn>
<c>glsa-check</c> 是個發展中的功能，所以若系統安全對您來說非常重要，別忘了同<!--
-->時使用其他方法驗證。
</warn>

<p>
您可以放心的忽略包含 <c>[A]</c> 跟 <c>[U]</c> 的行，因為您的系統沒有這些套件<!--
-->或這些套件已經是最新版，所以沒有這些問題。
</p>

<p>
某些使用者還是喜歡使用 <c>emerge packagename</c> 而不是 <c>glsa-check -f</c>，
那麼所有 GLSA 還是會顯示 <c>[N]</c>。
</p>

<p>
若您想要在每個 GLSA 發佈的時候收到 email，請訂閱 <c>gentoo-announce</c> 郵件列表。
加入郵件列表的方法以及其他好用的郵件列表可以在 <uri
link="http://www.gentoo.org/main/en/lists.xml">Gentoo Linux Mailing List Overview</uri> 中找到。
</p>

<p>
另一個好用的安全資源是 <uri
link="http://www.securityfocus.com/archive/1">Bugtraq 郵件列表</uri>。
</p>

</body>
</section>
</chapter>
</guide>
