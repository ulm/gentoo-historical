<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/ja/hardened/selinux/Attic/hb-install-system.xml,v 1.1 2005/04/22 21:32:48 idani Exp $ -->

<!-- Original revision: 1.8 -->
<!-- Translator: kobayashi -->

<sections>
<section>
<title>chrootする</title>
<subsection>
<title>自由選択: ミラーサイトの選択</title>
<body>

<p>
Gentoo LiveCDからブートしているなら、<c>mirrorselect</c>を使って最寄りのミラーサイトの指定を<path>/etc/make.conf</path>に定義することができます。
このミラーサイトはPortageツリーとソースコードの両方で利用されます(もちろんネットワークに接続できることが前提です)。
</p>

<pre caption="高速なミラーの選択">
# <i>mirrorselect -a -s4 -o | grep 'GENTOO_MIRRORS=' &gt;&gt; /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
もし何かしらの理由で<c>mirrorselect</c>が失敗したとしても、パニックに陥らないでください。
このステップはまったくもって自由選択なので、デフォルトの値を使えば良いのです。
</p>

</body>
</subsection>
<subsection>
<title>DNS情報をコピーする</title>
<body>

<p>
新しい環境に入る前にしなければならないことが、まだ一つ残っています。
それは、新しい環境でもネットワーク環境が確実に動くようにするために、<path>/etc/resolv.conf</path>にあるDNS情報を、新しい環境にコピーすることです。
<path>/etc/resolv.conf</path>にはあなたのネットワーク環境におけるネームサーバーの情報が含まれています。
</p>

<pre caption="DNS情報をコピーする">
<comment>("-L"オプションは、シンボリックリンクをコピーしないようにするために必要です)</comment>
# <i>cp -L /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
</pre>

</body>
</subsection>
<subsection>
<title>procファイルシステムのマウント</title>
<body>

<p>
chroot後の環境でもカーネルが提供する情報を参照できるようにするために、<path>/mnt/gentoo/proc</path>に<path>/proc</path>ファイルシステムをマウントしてください。
</p>

<pre caption="/procのマウント">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

</body>
</subsection>
<subsection>
<title>SELinuxファイルシステムのマウント</title>
<body>

<p>
chroot後の環境でもカーネルが提供する情報を参照できるようにするために、<path>/mnt/gentoo/selinux</path>に<path>/selinux</path>ファイルシステムをマウントしてください。
</p>

<pre caption="/selinuxのマウント">
# <i>mount -t selinuxfs none /mnt/gentoo/selinux</i>
</pre>

</body>
</subsection>
<subsection>
<title>新しい環境に入る</title>
<body>

<p>
さて、全てのパーティションは初期化され、ベース環境はインストールされました。
ついに、あなたは<e>chroot</e>により新たにインストールされた環境に入ります。
これは、現在のインストーラの環境(LiveCDやその他のインストールメディア)から、あなたのインストールした環境(すなわち初期化されたパーティション)に移行することを意味します。
</p>

<p>
このchrootの過程は3段階のステップからなります。
まず最初に、<c>chroot</c>によって、ルートディレクトリを(インストールメディア上の)<path>/</path> から、(あなたのパーティション上にある)<path>/mnt/gentoo</path>に変更します。
次に、システムファイルの環境変数を更新する<c>env-update</c>コマンドを使って、新しい環境をつくります。
最後に、<c>source</c>コマンドでこれらの変数をメモリ上に読み込みます。
</p>

<pre caption = "新しい環境にchrootする">
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
 * Caching service dependencies...
# <i>source /etc/profile</i>
</pre>

<p>
おめでとうございます!
あなたは自分のGentoo Linux環境に入ることができました。
もちろん、まだいくつかのセクションが残っており、完了までは程遠いのですが:-)
</p>

</body>
</subsection>

<subsection>
<!--
<title>Optional: Updating the Portage tree</title>
-->
<title>Portageツリーの更新</title>
<body>

<p>
<!--
If you haven't installed a Portage snapshot in the previous chapter, you must 
-->
インターネットから最新のPortageツリーをダウンロードしなければなりません。
<c>emerge --sync</c>を実行することでこれを行うことができます。
<!-- Other users should skip this and continue with <uri 
link="#configure_USE">Configuring the USE variable</uri>. -->
</p>

<pre caption="Portageツリーの更新">
# <i>emerge sync</i>
</pre>

<p>
Portageは、Portageツリーの更新にRSYNCプロトコルを使用します。
ファイアウォールがあるために上記コマンドが失敗した場合には、標準のHTTPプロトコルを利用してPortageスナップショットをダウンロードし、インストールする<c>emerge-webrsync</c>を使用します。
</p>

<pre caption="emerge-webrsyncを使ってPortageツリーを更新する">
# <i>emerge-webrsync</i>
</pre>

<p>
Portageの新しいバージョンが利用可能で、新しいものに更新すべきであることを警告されても、無視してください。
Portageは、後々のインストール作業中にアップデートされます。
</p>

</body>
</subsection>
<subsection id="configure_USE">
<title>USE変数の設定</title>
<body>

<p>
<c>USE</c>はGentooがユーザに提供する最もパワフルな変数の一つです。
プログラムの中には、特定のフラグを設定することによって、副次的なサポートを有効にしたり無効にしたりできるものがあります。
たとえばGTKサポートもしくはQtサポートを有効にしてコンパイルすることができるプログラムがあります。
他には、SSLサポートを有効にするか無効にするか、X11サポート(X-server)の替わりにフレームバッファサポート(svgalib) を有効にするか、などがあります。
</p>

<p>
多くのディストリビューションは、パッケージをありったけのサポートを有効にしてコンパイルしているため、依存関係が膨大になってしまっていることは言うまでもなく、プログラムのサイズや起動時間までも増大させてしまっています。
Gentooならば、パッケージをコンパイルするときにつけるべきオプションを自分で定義することができます。
これには<c>USE</c>フラグが一役買っています。
</p>

<p>
<c>USE</c>変数には、コンパイルオプションに対応するキーワードを定義します。
たとえば、<e>ssl</e>はプログラムに備わるSSLサポートをコンパイルします。
<e>-X</e>はXサーバのサポートを削除します(キーワードの前にマイナス記号をつけます)。
<e>gnome gtk -kde -qt</e>は、GNOME(とGTK)サポートを有効にし、KDE(とQt)サポートを無効にしてプログラムをコンパイルすることで、システムを完全にGNOME向けに調整します。
</p>

<p>
初期の<c>USE</c>設定は、<path>/etc/make.profile/make.defaults</path>にあります。
<path>/etc/make.conf</path>に記述した内容は、これらの初期設定に反映されます。
もし<c>USE</c>設定に何かを追加した場合、それは初期設定リストに追加されます。
もし何かを(マイナス記号を頭につけることで)USE設定から取り除いた場合、それは(リストにあれば)初期設定リストから取り除かれます。
<e>決して</e>、<path>/etc/make.profile</path>ディレクトリ以下の内容を変更しないでください。
Portageをアップデートするときに、上書きされてしまいます!
</p>

<p>
Gentooハンドブックの第3部にある<uri link="?part=3&amp;chap=1">USEフラグ</uri>に、USEについての詳細な解説があります。また、システムにある<path>/usr/portage/profiles/use.desc</path>に、使用可能なUSEフラグについての詳細な解説があります。
</p>

<note>
Hardened GCCユーザは、USE設定に<c>pic</c>と<c>hardened</c>を追加しなければなりません。
</note>

<impo>
make.confに<c>-*</c>を記述しないでください。
これは、有効になっているSELinux機能を無効にします。
SELinuxプロファイルはデフォルトプロファイルよりもずっと少ないフラグを有効にするので、とにかくこれは必要ではありません。
</impo>

<pre caption="使用可能なUSEフラグの参照">
# <i>less /usr/portage/profiles/use.desc</i>
<comment>(矢印キーを使用してスクロールし、'q'キーで終了します)</comment>
</pre>

<p>
DVD、ALSA、CD-Rサポートを含むKDEベースのシステムのための<c>USE</c>フラグの例を以下に示します。
</p>

<pre caption="/etc/make.confを開く">
# <i>nano -w /etc/make.conf</i>
</pre>

<pre caption="USEフラグの設定">
USE="-gtk -gnome qt kde dvd alsa cdr"
</pre>

</body>
</subsection>
<subsection>
<title>自由選択: 分散コンパイルを使用する</title>
<body>

<p>
システムの集合を使用してシステムのコンパイル時間を短縮することに興味があるのなら、<uri link="/doc/en/distcc.xml">DistCC Guide</uri><uri link="/doc/ja/distcc.xml">(日本語訳)</uri>を読みたいかもしれません。
<c>distcc</c>を使用すると、それぞれのシステムのプロセッサ能力をインストールに向けることができます。
</p>

</body>
</subsection>
</section>
<section>
<title>stage1、stage2、stage3の違い</title>
<body>

<p>
さて、腰を落ち着けて、これまでのインストール工程について思い出してみてください。
私たちは、あなたに<e>stage1</e>、<e>stage2</e>、<e>stage3</e>から一つ選ぶようにといいました。
そしてそれは、後々のインストール工程にとって、とても重要な選択だと警告しました。
そう。今ここが、あなたの選択によって、後に続くインストール工程を決定する最初の場面です。
</p>

<ul>
<li>
  <e>stage1</e>を選択したなら、この章の<e>両方の</e>ステップに従ってください(<uri link="#doc_chap3">stage1からstage2に進む</uri>から始めます)
</li>
<li>
  <e>stage2</e>を選択したなら、最初のステップを飛ばして、すぐに2番目のステップ (<uri link="#doc_chap4">stage2からstage3へ進む</uri>)から始められます
</li>
<li>
  stage3を(GRPを使用するしないにかかわらず)選んだのなら、両方のステップを飛ばして、<uri link="?part=1&amp;chap=7">カーネルの設定</uri>に進んでください
</li>
</ul>

</body>
</section>
<section>
<title>stage1からstage2に進む</title>
<subsection>
<title>ブートストラップ概説</title>
<body>

<p>
このステップに進んできたあなたは、何もかもスクラッチからコンパイルしたいことでしょう。わかりました。:-)
</p>

<p>
このステップではあなたのGentooシステムを<e>ブートストラップ</e>します。
これは非常に長い時間がかかります。
しかしその結果、システムはあなたのマシンに特化し、あなたの要求を満たした根底からの最適化がなされます。
</p>

<p>
<e>ブートストラップ</e>とは、GNU Cライブラリや、GNUコンパイラコレクションや、いくつかの重要なシステムプログラムをビルドすることを意味します。
</p>

<p>
ブートストラップを開始する前に、実行したいか、もしくはしたくないかもしれない2、3のオプションを提示します。
もししたくなければ、<uri link="#bootstrap">システムのブートストラップ</uri>に進んでください。
</p>

</body>
</subsection>
<subsection>
<title>自由選択: 最初にソースコードをダウンロードする</title>
<body>

<p>
前にすべてのソースコードを取得していない場合、bootstrapスクリプトが必要なファイルすべてをダウンロードしてくれます。
言うまでもありませんが、動作するネットワーク接続がなければ動作しません:-)
最初にソースコードをダウンロードして、その後システムをブートストラップしたいなら(例えば、コンパイル中にインターネットに接続しっぱなしにしたくないという理由で)、 bootstrapスクリプトの<e>-f</e>オプションを使用してください。このオプションは、全てのソースコードを取ってきます(fetchしてきます:<e>f</e>オプションの由来)。
</p>

<pre caption = "必要なソースコードのダウンロード">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh -f</i>
</pre>

</body>
</subsection>
<subsection id="bootstrap">
<title>システムをブートストラップする</title>
<body>

<p>
よろしい、それでは、キーボードから次のコマンドを打ち、ブートストラップを始めてください。
このステップは終了まで非常に長い時間がかかるので、何か他のことをして楽しんでいてください。
</p>

<pre caption = "システムをブートストラップする">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>

<p>
さあ、次のステップ、<uri link="#doc_chap4">stage2からstage3へ進む</uri>に進みましょう。
</p>

</body>
</subsection>
</section>
<section>
<title>stage2からstage3へ進む</title>
<subsection>
<title>概説</title>
<body>

<p>
あなたがこの章を読んでいるということは、すでにブートストラップが完了したシステム(事前にブートストラップを行ったか、もしくは<e>stage2</e>を使った)ができあがっているのだと思います。
では、いよいよすべてのシステムのパッケージをビルドします。
</p>

<p>
本当に<e>全部の</e>システムパッケージをビルドするのでしょうか？
いいえ、正確には違います。
このステップでは、選択肢が他にないシステムパッケージをビルドします。
システムパッケージの中には、いくつか選択の幅があるパッケージ(例えばシステムロガー)がありますが、選択あってのGentooですから、あなたにどのパッケージをインストールしろというような強制はしたくありません。
</p>

</body>
</subsection>
<subsection>
<title>自由選択: あらかじめ何が行われるのかを見てみる</title>
<body>

<p>
どんなパッケージがインストールされるのかを知りたければ、<c>emerge --pretend system</c>を実行します。
これは、これからビルドされるすべてのパッケージのリストを表示します。
このリストは非常に大きいので、上下にスライドさせて見るために<c>less</c>や<c>more</c>などのページャーも使用すべきです。
</p>

<pre caption = " 'emerge system'が何をするかを見てみる">
# <i>emerge --pretend system | less</i>
</pre>

</body>
</subsection>
<subsection>
<title>自由選択: ソースコードのダウンロード</title>
<body>

<p>
このまま続ける前に、(例えば、すべてのパッケージをビルドしている間中、インターネットに接続しっぱなしにしたくないという理由で)ソースコードをダウンロードするために<c>emerge</c>したいなら、全てのソースコードを取ってくる、<c>emerge</c>の<e>--fetchonly</e>オプションを使用できます。
</p>

<pre caption = "ソースコードを取ってくる">
# <i>emerge --fetchonly system</i>
</pre>

</body>
</subsection>
<subsection>
<title>システムのビルド</title>
<body>

<p>
システムのビルドを開始するには、<c>emerge system</c>を実行します。
このステップは終了するまで大変時間がかかるので、なにか退屈しのぎでもしていてください。
</p>

<pre caption = "システムのビルド">
# <i>emerge system</i>
</pre>

<p>
更新された設定ファイル(と<c>etc-update</c>の実行)に関するすべての警告は、今のところ無視してもかまいません。
</p>

<p>
ビルドが完了したら、<uri link="?part=1&amp;chap=7">カーネルの設定</uri>へ進んでください。
</p>

</body>
</subsection>
</section>

</sections>
