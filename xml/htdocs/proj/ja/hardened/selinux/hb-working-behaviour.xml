<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/ja/hardened/selinux/Attic/hb-working-behaviour.xml,v 1.1 2005/09/28 17:57:02 idani Exp $ -->

<!-- Original revision: 1.1 -->

<sections>
<section>
<title>ファイル保護の設定</title>
<subsection>
<title>保護とは？</title>
<body>

<p>
Portageには「保護ファイル」の概念があります。
これはつまり、ソフトウェアを更新するときに、新しいバージョンのファイルをすぐには上書きせず、新しいバージョンが存在すると伝えます。
これはもちろん設定ファイル（<path>/etc</path>にあるファイル）にはとても便利です。
</p>

<p>
ファイルの上書きの代わりに、<path>._cfg0000_&lt;name&gt;</path>と言う新しいファイルを作成します。<path>&lt;name&gt;</path>はオリジナルのファイル名です。
その後ユーザの責任において現在のファイルに必要な差分を適応します。
ユーザは<c>etc-update</c>コマンドを使用することでこの操作を簡単に行うことができます。
<c>etc-update</c>については後ほど説明します。
</p>

</body>
</subsection>
<subsection>
<title>CONFIG_PROTECTの宣言</title>
<body>

<p>
Portageはファイル基礎ごとにファイルを保護することができません。
その代わり、ディレクトリ全体を保護します。
<c>CONFIG_PROTECT</c>変数は全ての保護されるディレクトリが列挙されています。
一覧にあるディレクトリのサブディレクトリも保護されます。
<c>CONFIG_PROTECT</c>変数は<path>/etc/make.globals</path>で定義されますが、変更したいのなら、<path>/etc/make.conf</path>で宣言するべきです（物事を首尾一貫するために、<path>/etc/make.conf</path>は全てのPortage設定に使用されます）。
</p>

<pre caption="CONFIG_PROTECT設定の例">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/3.1/share/config"
</pre>

<p>
あるディレクトリを保護したいが、全てのサブディレクトリを保護したくはないときには、<c>CONFIG_PROTECT_MASK</c>変数にそれら「保護されない」ディレクトリを記述することができます。
この変数は<path>/etc/make.globals</path>でデフォルト値が定義されていますが、<path>/etc/make.conf</path>で宣言し直すべきです。
</p>

<pre caption="CONFIG_PROTECT_MASK設定の例">
CONFIG_PROTECT_MASK="/etc/init.d"
</pre>

<p>
設定ファイル保護に関するより詳しい情報は<c>emerge</c>のオンラインヘルプにあります。
</p>

<pre caption="設定ファイル保護に関する情報を得る">
# <i>emerge --help config</i>
</pre>

</body>
</subsection>
<subsection>
<title>etc-update</title>
<body>

<p>
<c>etc-update</c>とは、<path>._cfg0000_&lt;name&gt;</path>ファイルのマージをお手伝いするツールです。
これは対話式マージセットアップを提供し、ちょっとした変更は自動でマージします。
</p>

<p>
<c>etc-update</c>の実行はとても簡単です。
</p>

<pre caption="etc-updateの実行">
# <i>etc-update</i>
</pre>

<p>
単純な変更をマージした後、更新待ちの保護ファイル一覧が表示されるでしょう。
一番下には利用できるオプションが表示されます。
</p>

<pre caption="etc-updateのオプション">
Please select a file to edit by entering the corresponding number.
              (-1 to exit) (-3 to auto merge all remaining files)
                           (-5 to auto-merge AND not use 'mv -i'): 
</pre>

<p>
<c>-1</c>と入力すれば、<c>etc-update</c>はどの変更も行うことなく終了します。
<c>-3</c>か<c>-5</c>と入力すれば、<e>全ての</e>表示されている設定ファイルが新しいバージョンに上書きされます。
そのため、自動更新されるべきでない設定ファイルを先に選択することがとても重要です。
これは、設定ファイルの左に表示されている数字を入力するだけという簡単な作業です。
</p>

<p>
例として、<path>/etc/pear.conf</path>と言う設定ファイルを選択します。
</p>

<pre caption="特定の設定ファイルを更新">
Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<comment>（中略）</comment>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update
2) Delete update, keeping original as is
3) Interactively merge original with update
4) Show differences again
</pre>

<p>
今あなたは2つのファイルの違いを見ています。
新しい設定ファイルが問題なく使用できると思うなら、<c>1</c>を入力します。
新しい設定ファイルが必要でない、もしくは新しい有用なものを何も提供してくれないと思うなら、<c>2</c>を入力します。
現在の設定ファイルを対話式に更新したいなら、<c>3</c>を入力します。
</p>

<p>
相互マージについてのより詳しい情報をここで記述することには意味がありません。完全にするためには、2つのファイルを相互マージしているときに利用できるコマンドのリストを提示します。2行(オリジナルと、推奨される新しいもの)と以下のコマンドのうち1つを入力することができるプロンプトが表示されています。
</p>

<pre caption="相互マージで利用可能なコマンド">
ed:     両方のバージョンをヘッダーで装飾して利用して編集
eb:     両方のバージョンを利用して編集
el:     左のバーションを利用して編集
er:     右のバーションを利用して編集
e:      新しいバージョンを編集
l:      左のバージョンを利用
r:      右のバージョンを利用
s:      結果を表示せず共通の行を含む
v:      結果を表示して共通の行を含む
q:      終了
</pre>

<p>
重量な設定ファイルの更新が終了したら、その他の設定ファイルを自動更新します。更新できる設定ファイルが見つからないときには<c>etc-update</c>は終了します。
</p>

</body>
</subsection>
</section>
<section>
<title>ネットワークオプション</title>
<subsection>
<title>グローバルミラー</title>
<body>

<p>
Gentooの人気が出てきたので、ミラーを使用することはとても良いことです。
Portageは、ミラーに関する3つの変数を使用します。
1つはrsyncミラー用（Portageツリーの同期に使用されます）、1つはdistfiles用（ソースコードのダウンロードに使用されます）、そしてもう1つはビルド済みパッケージ用です。
</p>

<p>
全ての利用可能なdistfilesミラーは<uri link="/main/en/mirrors.xml">Gentoo mirrors page</uri><uri link="/main/ja/mirrors.xml">(日本語)</uri>にあります。
システム用にミラーを簡単に設定してくれる<c>mirrorselect</c>を使用することができます。
ですが先にそれぞれの変数を確認していきましょう。
</p>

<p>
<c>SYNC</c>変数には利用したいrsyncミラーが含まれます。
例えば、<uri>rsync://rsync.namerica.gentoo.org/gentoo-portage</uri>を使用するには、これを<path>/etc/make.conf</path>で定義します。
</p>

<pre caption="SYNCを/etc/make.confで定義">
SYNC="rsync://rsync.namerica.gentoo.org/gentoo-portage"
</pre>

<p>
<c>GENTOO_MIRRORS</c>には利用したいdistfilesミラーが含まれます。
例えば、最初に<uri>ftp://ibiblio.org/pub/Linux/distributions/gentoo</uri>を選び、次に<uri>http://www.gtlib.cc.gatech.edu/pub/gentoo</uri>を選ぶには、これを<path>/etc/make.conf</path>で定義します。
</p>

<pre caption="GENTOO_MIRRORSを/etc/make.confで定義">
GENTOO_MIRRORS="ftp://ibiblio.org/pub/Linux/distributions/gentoo
                http://www.gtlib.cc.gatech.edu/pub/gentoo"
</pre>


<p>
<c>PORTAGE_BINHOST</c>変数には使用したいビルド済みパッケージのミラーが含まれます。
例えば、<uri>ftp://login:pass@grp.mirror.site/pub/grp/i686/athlon-xp</uri>を使用するには、これを<path>/etc/make.conf</path>で定義します。
</p>

<pre caption="PORTAGE_BINHOSTを/etc/make.confで定義">
PORTAGE_BINHOST="ftp://login:pass@grp.mirror.site/pub/grp/i686/athlon-xp"
</pre>

</body>
</subsection>
<subsection>
<title>パッケージミラー</title>
<body>

<p>
多くのパッケージには、'mirror://'を含むSRC変数があります。
そのようなパッケージは、それらのソースコードが多くのホスト（sourceforgeやgnuなど）にあります。
PortageがそのようなSRC変数を見つけたときにはいつでも、実際のホストを<path>/etc/portage/mirrors</path>から探し、もしこのファイルにホストがなければ、<path>/usr/portage/profiles/thirdpartymirrors</path>から探します。
</p>

<p>
<path>/etc/portage/mirrors</path>で好きなミラーを設定することができます。
例えば、パッケージがsourceforgeからダウンロードするときはいつでも<uri>http://keihanna.dl.sourceforge.net</uri>を使用するようにしたければ、以下のように入力します。
</p>

<pre caption="/etc/portage/mirrorsの例">
sourceforge http://keihanna.dl.sourceforge.net
</pre>

<p>
特別な<c>local</c>ミラーを設定することもできます。
これらのミラーは、たとえパッケージのSRC変数に'mirror://'が記述されていなかったり、ミラーされるべきではないと設定されていたとしても、<e>いつも</e>最初に確認されます。
</p>

</body>
</subsection>
<subsection>
<title>Mirrorselect</title>
<body>

<p>
もし<c>mirrorselect</c>を使用したいなら、（まだ行っていなければ）まずインストールします。
</p>

<pre caption="mirrorselectのインストール">
# <i>emerge mirrorselect</i>
</pre>

<p>
これで<c>mirrorselect</c>が自動的に最適なミラーを選択するか、リストから手動で選択するかを選べるようになりました。
<c>mirrorselect</c>の使い方に関するより詳しい情報は、<c>mirrorselect</c>をコマンドラインから起動するだけです。
<c>mirrorselect</c>に関する簡単な概要が表示されるでしょう。
</p>

<pre caption="mirrorselectの実行">
# <i>mirrorselect</i>
</pre>

</body>
</subsection>
<subsection>
<title>Fetching</title>
<body>

<p>
Portageがアーカイブをダウンロードするのに使用するプログラムは<c>FETCHCOMMAND</c>と<c>RESUMECOMMAND</c>で設定できます。
それぞれの例は<path>/etc/make.conf.example</path>と<path>/etc/make.globals</path>にあります。
Portageは初期設定では<c>wget</c>を使用します。
</p>

<pre caption="FETCHCOMMANDとRESUMECOMMANDの初期設定">
FETCHCOMMAND="/usr/bin/wget -t 5 --passive-ftp -P \${DISTDIR} \${URI}"
RESUMECOMMAND="/usr/bin/wget -c -t 5 --passive-ftp -P \${DISTDIR} \${URI}"
</pre>

<p>
<c>${DISTDIR}</c>変数はダウンロードしたファイルの保存場所（<path>/usr/portage/distfiles</path>）を表し、<c>${URI}</c>変数はPortageがダウンロードするファイルを表します。
</p>

<p>
Portageは初期設定で<c>wget</c>を使用するので、<c>http_proxy</c>と<c>ftp_proxy</c>でproxyを設定することができます。
これは<path>/etc/make.conf</path>でもできますが、<c>http_proxy</c>と<c>ftp_proxy</c>が他のツールでも使用できるように、より一般的な方法を使用すべきだとの忠告を受けたはずです（<path>/etc/make.conf</path>はPortageのみが使用します）。
システム全体の環境変数を設定する方法は、<uri link="?part=2&amp;chap=5">環境変数</uri>の章を読んでください。
</p>

</body>
</subsection>
<subsection>
<title>rsyncの設定</title>
<body>

<p>
<c>rsync</c>はPortageツリーを更新するために<c>emerge --sync</c>で使用されます。
Portageは<c>RSYNC_EXCLUDEFROM</c>、<c>RSYNC_RETRIES</c>、<c>RSYNC_TIMEOUT</c>という3つの変数で<c>rsync</c>の振る舞いを変更できます。
</p>

<p>
ebuildを<c>emerge --sync</c>の更新や削除から「保護」するためには<c>RSYNC_EXCLUDEFROM</c>変数を使用します。
これは<c>rsync</c>で特定のファイルを除外するために使用され、初期設定では<path>/etc/portage/rsync_excludes</path>となっています。
もしあなたが注意深くないのであれば、この方法は依存関係を破壊してしまうため、使用はお勧め<e>できません</e>。
より推奨されている方法である<c>PORTDIR_OVERLAY</c>について後ほど説明します。
より詳しい情報については、<c>rsync</c>のマニュアルページを参照してください。
</p>

<pre caption="RSYNC_EXCLUDEFROM変数">
RSYNC_EXCLUDEFROM="/etc/portage/rsync_excludes"
</pre>

<p>
<c>rsync</c>が失敗すると、次の利用可能なrsyncサーバに切り替える前に何度か再試行を行います。
再試行回数は<c>RSYNC_RETRIES</c>で定義されており、初期設定は<c>3</c>です。
</p>

<pre caption="RSYNC_RETRIES変数">
RSYNC_RETRIES="3"
</pre>

<p>
もし（とても）遅いrsyncサーバを使用しているなら、何もデータを受信しないうちに、<c>rsync</c>がタイムアウトしてしまうでしょう。
タイムアウトまでの待機時間は<c>RSYNC_TIMEOUT</c>で定義されており、初期設定は<c>180</c>（秒）です。
</p>

<pre caption="RSYNC_TIMEOUT変数">
RSYNC_TIMEOUT="180"
</pre>

</body>
</subsection>
</section>
<section>
<title>ディレクトリの位置</title>
<subsection>
<title>初めに</title>
<body>

<p>
Portageに関するありとあらゆる事が設定可能であり、それには様々なタスクやPortageが必要とするファイルに使用されるディレクトリが含まれています。
（<path>/etc/make.globals</path>で設定されている）初期位置を変更するには、<path>/etc/make.conf</path>で正しい変数を定義する必要があります。
</p>

<warn>
変数を違う位置に変更するなら、パスの最後は<e>決して</e><path>/</path>にしないようにしてください。
</warn>

</body>
</subsection>
<subsection>
<title>Portageツリー</title>
<body>

<p>
Portageツリーの位置は<c>PORTDIR</c>変数で定義されています。
初期位置は<path>/usr/portage</path>です。
</p>

<pre caption="PORTDIR変数">
PORTDIR="/usr/portage"
</pre>

<p>
「公式」のPortageツリーの他にローカルのPortageツリーを持ちたいのであれば、<c>PORTDIR_OVERLAY</c>変数を定義する必要があります。
この変数に記述されているディレクトリは<c>emerge --sync</c>の影響を受けません。
これらのディレクトリにあるebuildは更新や削除はされませんが、Portageツリーの一部となります。
</p>

<pre caption="PORTDIR_OVERLAY変数">
PORTDIR_OVERLAY="/usr/local/portage"
</pre>

</body>
</subsection>
<subsection>
<title>Distfiles</title>
<body>

<p>
ソースコード（distfilesと呼びます）がダウンロードされる位置は<c>DISTDIR</c>変数で定義されます。
初期位置は<path>${PORTDIR}/distfiles</path>です。
</p>

<pre caption="DISTDIR変数">
DISTDIR="${PORTDIR}/distfiles"
</pre>

</body>
</subsection>
<subsection>
<title>PackagesとRPMs</title>
<body>

<p>
ビルド済みパッケージの位置は<c>PKGDIR</c>変数で定義されます。
初期位置は<path>${PORTDIR}/packages</path>です。
</p>

<pre caption="The PKGDIR variable">
PKGDIR="${PORTDIR}/packages"
</pre>

<p>
RPMの位置（そう、いくつかのパッケージはRPMとして利用可能です）は<c>RPMDIR</c>変数で定義されます。
初期位置は<path>${PORTDIR}/rpm</path>です。
</p>

<pre caption="RPMDIR変数">
RPMDIR="${PORTDIR}/rpm"
</pre>

</body>
</subsection>
<subsection>
<title>一時的なPortageファイル</title>
<body>

<p>
Portageはebuildをビルドするために一時的な場所を使用します。
この位置は<c>PORTAGE_TMPDIR</c>変数で定義され、初期位置は<path>/var/tmp</path>です。
</p>

<pre caption="PORTAGE_TMPDIR変数">
PORTAGE_TMPDIR="/var/tmp"
</pre>

<p>
初期設定では、Portageは<c>PORTAGE_TMPDIR</c>内に<path>portage</path>ディレクトリを作成します。
これは<c>BUILD_PREFIX</c>変数で定義できます。
</p>

<pre caption="BUILD_PREFIX変数">
BUILD_PREFIX="${PORTAGE_TMPDIR}/portage"
</pre>

<p>
もしこのディレクトリの位置を変更するつもりなら、一時ディレクトリは十分な空き容量のあるパーティションにしてください。巨大なソフトウェアのコンパイル時には、ディレクトリは2Gb以上に膨れあがるでしょう。
</p>

</body>
</subsection>
<subsection>
<title>ログの記録</title>
<body>

<p>
<c>PORT_LOGDIR</c>は特別な変数で、初期設定では設定されていません。
これを設定すると、Portageはebuildごとのログをディレクトリに作成します。
</p>

<pre caption="PORT_LOGDIR変数">
PORT_LOGDIR="/var/log/portage"
</pre>

</body>
</subsection>
</section>
<section>
<title>その他のPortageオプション</title>
<subsection>
<title>Nice値</title>
<body>

<p>
Portageは異なるNice値（優先度のような値）でのビルドをサポートしています。
Portageがより高いNice値でパッケージをビルドして欲しい（ビルド中でもシステムの反応が良くなりますが、ビルド時間が延びます）のなら、<c>PORTAGE_NICENESS</c>変数に整数で設定します。
</p>

<pre caption="PORTAGE_NICENESS変数">
PORTAGE_NICENESS="3"
</pre>

</body>
</subsection>
<subsection>
<title>SLOT済みのPackageと自動クリーン</title>
<body>

<p>
いくらかの状況では、複数の異なるバージョンのパッケージ（ライブラリを含む）をシステムに共存させたいと思うかもしれません。
Portageでは、ebuildで<c>SLOT</c>変数を設定することにより、これを行うことができます。
ユーザとしては、どのようにして<c>SLOT</c>が働いているかを知る必要はありませんが、サポートされていると言うことを知っておくことが重要です。
</p>

<p>
もし新しいバージョンのパッケージをインストールしようとするなら、Portageはパッケージに<c>SLOT</c>変数が設定されているかを確認します。
もし設定されていて、お互いのパッケージ（新しい方と古い方）の<c>SLOT</c>変数が異なっているなら、Portageは古いパッケージに対して何も行いません。
</p>

<p>
しかし、<c>SLOT</c>変数が同じ（一般的な場合です）であれば、古いパッケージは削除されます。
ユーザがこの削除動作を中止できるように、Portageは何秒かカウントダウンを行います。
これは<c>CLEAN_DELAY</c>変数で設定されており、初期値は<c>5</c>秒です。
</p>

<pre caption="CLEAN_DELAY変数">
CLEAN_DELAY="5"
</pre>

<p>
Portageが自動的に古いバージョンを削除（"cleaning"と呼ばれます）して欲しくないのなら、<c>AUTOCLEAN</c>変数を<c>no</c>を設定します。
</p>

<pre caption="AUTOCLEAN変数">
AUTOCLEAN="no"
</pre>

</body>
</subsection>
<subsection>
<title>ビルド関連の変数</title>
<body>

<p>
これまでに大変多くの変数を見てきましたが、まだ全てではありません。
Gentooをインストールした人は、<c>CHOST</c>、<c>CFLAGS</c>、<c>CXXFLAGS</c>変数という、コンパイラがパッケージをコンパイルし、最適化するための変数を知っているでしょう。
</p>

<p>
これらの変数に関するより詳しい情報は、<c>gcc</c>の情報ページか、<uri link="http://gcc.gnu.org/onlinedocs/">GCC Online Manuals</uri>からオンラインで読むことができます。
</p>

<pre caption="CHOST、CFLAGS、CXXFLAGSに関する情報を得る">
# <i>info gcc</i>
<comment>("Invoking gcc"を選択)</comment>
<comment>("Optimize options"を選択)</comment>
</pre>

<p>
<c>DEBUGBUILD</c>が設定されているなら、Portageはデバッグがしやすいように、バイナリとライブラリからシンボル情報を削除しません。
これはシステム速度を低下させ、ファイルサイズが増加します。
</p>

<pre caption="DEBUGBUILD変数">
<comment># この行の削除の代わりに、"false"に設定してはいけません。</comment>
<comment># Portageは値を確認せず、変数が定義されているかのみを確認します。</comment>
DEBUGBUILD="true"
</pre>

<p>
<c>MAKEOPTS</c>変数は、パッケージのコンパイルを簡単に行うために使用される、<c>make</c>で使用されます。
これは通常<c>make</c>に様々なコンパイルを同時に行うよう指示するために使用されます（特に、マルチCPUシステムを使用しているか、前述の<c>distcc</c>を使用している時に使用します）。
</p>

<p>
<c>make</c>が3つのコンパイルを同時に行うようにするためには、<c>MAKEOPTS</c>変数に<c>-j3</c>を設定します。
</p>

<pre caption="MAKEOPTS変数">
MAKEOPTS="-j3"
</pre>

<p>
<c>ROOT</c>変数は<path>/etc/make.conf</path>で設定すべきではなく、環境変数として設定します。
Portageは、パッケージがインストールを必要とするときにこの変数を確認します。
もちろん、この初期値は<path>/</path>となっています。
例として、<c>gnumeric</c>を実行中のシステムの代わりに<path>/mnt/gentoo</path>にインストールする方法を紹介します。
</p>

<pre caption="ROOT変数">
# <i>ROOT="/mnt/gentoo" emerge gnumeric</i>
</pre>

</body>
</subsection>
<subsection>
<title>出力フォーマット</title>
<body>

<p>
初期設定では、Portageは読みやすさを高めるために出力に色を付けています。
これを行いたくないのなら、<c>NOCOLOR</c>変数を<c>true</c>に設定します。
</p>

<pre caption="NOCOLOR変数">
NOCOLOR="true"
</pre>

</body>
</subsection>
</section>
<section>
<title>資料</title>
<subsection>
<title>マニュアルページ</title>
<body>

<p>
全ての変数のクイックリファレンスが必要なら、<path>make.conf</path>のマニュアルページを参照してください。
</p>

<pre caption="make.confのマニュアルページを参照する">
# <i>man make.conf</i>
</pre>

</body>
</subsection>
<subsection>
<title>コメントが書かれた例</title>
<body>

<p>
<path>/etc/make.conf.example</path>ファイルには、興味が湧くかもしれない例を含む、多くのコメントが書かれています。
</p>

</body>
</subsection>
</section>
</sections>
