<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/base/embedded/handbook/cross-compiling-packages.xml,v 1.1 2008/04/06 15:57:55 scen Exp $ -->

<sections>

<abstract>
Usare Portage come Cross-Compilatore e Gestore di pacchetti.
</abstract>

<version>0.1</version>
<date>2007-08-12</date>

<section>
<title>Variabili</title>
<body>

<p>
Ci sono alcune importanti variabili che verranno usate in questa sezione.
</p>

<table>
 <tr>
  <th>Variabile</th>
  <th>Significato</th>
 </tr>
 <tr>
  <ti>CBUILD</ti>
  <ti>Piattaforma su cui si sta compilando</ti>
 </tr>
 <tr>
  <ti>CHOST</ti>
  <ti>Piattaforma per cui si sta compilando</ti>
 </tr>
 <tr>
  <ti>ROOT</ti>
  <ti>La / virtuale sulla quale si sta installando</ti>
 </tr>
 <tr>
  <ti>PORTAGE_CONFIGROOT</ti>
  <ti>
    La / dove portage può trovare i suoi file di configurazione (come il
    make.conf)
  </ti>
 </tr>
</table>

<p>
È possibile valorizzarle tutte a mano, ma questo ovviamente diventa presto
una scocciatura. Un'idea migliore è invece quella di specificare queste
variabili in uno script di shell così da evitare di digitarle ogni volta.
</p>

</body>
</section>
<section>
<title>Configurazione del Filesystem</title>
<body>

<p>
Il cross-compilare un sistema richiede generalmente due alberature di directory.
La prima, dove tutti i file di sviluppo sono normalmente installati. Questa è
la vostra sysroot. L'altra alberatura è invece dove verranno installati i file
che devono essere eseguiti. Una volta installati con emerge tutti i pacchetti
nella sysroot (senza aver rimosso alcun file) sarà sufficiente installare
tramite pacchetti binari o copiando a mano tutti i file desiderati
nell'alberatura di esecuzione.
</p>

<p>
È convenzione usare l'alberatura presente sotto <path>/usr/CTARGET/</path>
come sysroot, dato che il cross-compilatore è già configurato per cercare in
tale percorso le directory degli include e delle librerie. È anche possibile
usare un'altra directory, aggiungendone poi il percorso alle CPPFLAGS/LDFLAGS
tramite l'opzione -I/-L, ma questo opzione storicamente si è rivelato esser
problematica: anche se dovesse funzionare, è sconsigliata e scoraggiata. D'ora
in avanti si assumerà che si stia usando la sysroot come propria ROOT di
sviluppo.
</p>

<p>
Il sistema che poi si vorrà eseguire avrà probabilmente bisogno di un po' di
lavoro per esser alleggerito e snellito. Proprio per via dei file che si
rimuoveranno dai pacchetti installati, questo ambiente non è adatto per la
compilazione. Mentre si installa la sysroot si possono generare pacchetti binari
dei vari applicativi, dai quali, con l'aggiunta della variabile
<c>INSTALL_MASK</c> sono facilmente rimuovibili i file giudicati superflui.
Si legga la man page del make.conf(5) per ottenere maggiori informazioni.
</p>

</body>
</section>
<section>
<title>Preparazione dell'Ambiente</title>
<body>

<p>
Una volta scelto il percorso per la vostra sysroot, si dovrà configurare
l'ambiente di portage come avviene durante la prima installazione. Ciò significa
che si dovranno creare i file <path>make.conf</path> e <path>make.profile</path>
per il sistema di destinazione. Si dovrà anche predisporre il file
<path>make.globals</path>.
</p>

<pre caption="SYSROOT/etc/make.conf">
ACCEPT_KEYWORDS="ppc"
ARCH="ppc"
CHOST="powerpc-softfloat-linux-uclibc"
CFLAGS="-Os -pipe"
CXXFLAGS="${CFLAGS}"
GENTOO_MIRRORS="http://open-systems.ufl.edu/mirrors/gentoo \
    http://prometheus.cs.wmich.edu/gentoo \
    http://mirror.datapipe.net/gentoo \
    http://ftp.ucsb.edu/pub/mirrors/linux/gentoo/"
INPUT_DEVICES="keyboard"
MAKEOPTS="-j2"
USE="-* minimal"
</pre>

<p>
Il file <path>make.globals</path> contiene diverse impostazioni di default ed
è indipendente dall'architettura. Pertanto si può semplicemente creare un link
simbolico ad esso.
</p>

<pre caption="SYSROOT/etc/make.globals">
# <i>ln -s /etc/make.globals SYSROOT/etc/make.globals</i>
</pre>

<p>
Infine, per il <path>make.profile</path>, creare come al solito un link
simbolico.
</p>

<pre caption="SYSROOT/etc/make.profile">
# <i>ln -s /usr/portage/profiles/uclibc/ppc SYSROOT/etc/make.profile</i>
</pre>

<p>
Nella sysroot alcuni test degli script di configure potrebbero fallire, con
conseguente aggiunta di funzioni locali per ovviare ai presunti problemi
riscontrarti. Per ovviare a questa situazione è sufficiente forzarne il
risultato.
</p>

<pre caption="Force autoconf tests">
export ac_cv_func_malloc_0_nonnull=yes
export ac_cv_func_calloc_0_nonnull=yes
export ac_cv_func_realloc_0_nonnull=yes
</pre>

</body>
</section>
<section>
<title>Un'utile strumento: xmerge</title>
<body>

<p>
Xmerge è un semplice wrapper che valorizza le variabili d'ambiente per farle
puntare ai percorsi corretti e lancia poi <c>emerge</c>. Questo script si
aspetta che la variabile d'ambiente <c>SYSROOT</c> sia già impostata.
</p>

<pre caption="sample xmerge">
#!/bin/sh
export CBUILD=$(portageq envvar CHOST)
export PORTAGE_CONFIGROOT=${SYSROOT}
if [ "$1" = "--root" ] ; then
        export ROOT=$2
        shift 2
else
        export ROOT=${SYSROOT}
fi
exec emerge "$@"
</pre>

<p>
È possibile utilizzare xmerge sia per installare programmi nella root di
sviluppo (sysroot) sia nella root del sistema che poi si vorrà eseguire.
Per sfruttare la seconda modalità, è sufficiente aggiungere l'opzione --root .
</p>

</body>
</section>
<section>
<title>Un'utile strumento: pkg-config</title>
<body>

<p>
Numerosi pacchetti ormai installano file pkg-config (*.pc) e li usano per
ricavarne l'elenco delle librerie e degli include necessari. Per facilitare
il processo di compilazione, è consigliabile installare un wrapper di
pkg-config per l'architettura di destinazione, così da specificare a pkg-config
in quali percorsi cercare.
</p>

<p>
Questo wrapper andrebbe installato in una directory presente nel proprio PATH,
così da permettere agli script di configure di rilevarlo. Messo un CTARGET
come prefisso del nome, lo script farà tutto il resto. Per intenderci, il nome
canonico è <c>CTARGET-pkg-config</c>. Script di configure datati cercheranno
solo <c>pkg-config</c>, in tali casi sarà necessario esportare la variabile
<c>PKG_CONFIG</c> con il nome del wrapper.
</p>

<pre caption="cross-pkg-config wrapper">
#!/bin/sh
CTARGET=${0%-pkg-config}
SYSROOT="/usr/${CTARGET}"
export PKG_CONFIG_LIBDIR="${SYSROOT}/usr/lib/pkgconfig"
unset PKG_CONFIG_ALLOW_SYSTEM_CFLAGS PKG_CONFIG_ALLOW_SYSTEM_LIBS
exec pkg-config "$@"
</pre>

</body>
</section>
<section>
<title>Disintallazione</title>
<body>

<p>
Se si desidera disinstallare ed eliminare quanto fatto, sarà sufficiente
rimuovere l'alberatura presente nella sysroot, senza intaccare alcun pacchetto
nativo installato. Si legga anche la sezione relativa alla disinstallazione
nella guida relativa alla
<uri link="cross-compiler.xml">cross-compilazione</uri>.
</p>

</body>
</section>
</sections>
