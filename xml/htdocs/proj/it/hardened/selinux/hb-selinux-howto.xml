<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/hardened/selinux/Attic/hb-selinux-howto.xml,v 1.2 2008/06/04 19:34:39 scen Exp $ -->

<sections>
<version>2.0</version>
<date>2006-10-14</date>

<section>
<title>Caricare le politiche in un kernel SELinux in uso</title>
<subsection>
<body>

<p>
Questa operazione richiede di appartenere al ruolo <c>sysadm_r</c>.
</p>

<pre caption="Il comando Semodule">
# <i>semodule -B</i>
</pre>

</body>
</subsection>

</section>

<section>
<title>Cambiare ruolo</title>
<subsection>
<body>

<p>
La seguente operazione richiede che l'utente possa accedere al ruolo di
destinazione. Questo esempio descrive come elevarsi al ruolo <c>sysadm_r</c>.
</p>

<pre caption="Newrole">
# <i>newrole -r sysadm_r</i>
</pre>

</body>
</subsection>
</section>

<section>
<title>Elencare i ruoli disponibili per un utente</title>
<subsection>
<body>

<p>
Esiste una corrispondenza tra gli utenti di linux e le identità di SELinux. Le
politiche utilizzano gli utenti generici di SELinux per configurazioni rilevanti
sui ruoli; per esempio, per mettere in corrispondenza l'utente <c>pebenito</c>
all'identità di SELinux <c>staff_u</c>, eseguire:
</p>

<pre caption="Mappare pebenito a staff_u">
# <i>semanage login -a -s staff_u pebenito</i>
</pre>

<p>
Questa politica non ha bisogno di venire ricaricata: se l'utente è connesso, è
necessario che ripeta il processo di autenticazione affinchè la nuova politica
abbia effetto.
</p>

</body>
</subsection>
</section>

<section>
<title>Etichettare nuovamente il filesystem</title>
<subsection>
<body>

<p>
Questa operazione richiede di appartenere al ruolo <c>sysadm_r</c>.
</p>

<pre caption="Rietichettare">
# <i>rlpkg -a</i>
</pre>

</body>
</subsection>
</section>

<section>
<title>Etichettare nuovamente un singolo pacchetto</title>
<subsection>
<body>

<p>
Oltre alla possibilità di rietichettare l'intero filesystem, è possibile
limitare il comando solamente ad un pacchetto di portage. Questa operazione
richiede di appartenere al ruolo <c>sysadm_r</c>.
</p>

<pre caption="Esempio su rlpkg">
# <i>rlpkg shadow sash</i>
</pre>

<p>
Viene utilizzato lo script rlpkg, che può ricevere come parametro un numero
arbitrario di pacchetti.
</p>

</body>
</subsection>
</section>

<section>
<title>Ricerca di librerie con riallocazione dei testi</title>
<subsection>
<body>

<p>
SELinux fornisce diversi meccanismi di protezione per la memoria. Una funzione
supportata permette la riallocazione dei testi ELF: una libreria di questo tipo
ha una etichetta speciale, ed lo strumento <c>rlpkg</c> è dotato di una opzione
per effettuarne la ricerca.
</p>

<pre caption="Ricerca di TEXTREL">
# <i>rlpkg -t</i>
</pre>

<p>
Questa operazione verrà ripetuta automaticamente ad ogni nuova etichettatura.
</p>

</body>
</subsection>
</section>

<section>
<title>Avviare i demoni nel dominio corretto</title>
<subsection>
<body>

<p>
Controllare i demoni che vengono avviati tramite script di inizializzazione
nella cartella /etc/init.d è leggermente differente in SELinux. Per assicurarsi
che vengano avviati nel dominio corretto, occorre sempre utilizzare il comando
<c>run_init</c>. Lo script di inizializzazione può venire eseguito normalmente,
facendolo precedere dal comando <c>run_init</c>. Questo richiede di appartenere
al ruolo <c>sysadm_r</c>.
</p>

<pre caption="Esempi di run_init">
# <i>run_init /etc/init.d/ntpd start</i>
# <i>run_init /etc/init.d/apache2 restart</i>
# <i>run_init /etc/init.d/named stop</i>
</pre>

</body>
</subsection>

<subsection>
<title>L'integrazione di Gentoo con run_init</title>
<body>

<p>
Il comando <c>run_init</c> è stato integrato all'interno degli script di
inizializzazione del sistema di Gentoo. Con SELinux installato, i servizi
possono venire avviati ed interrotti normalmente, ma inoltre adesso autenticano
l'utente.
</p>

<pre caption="Esempio di run_init integrato">
# <i>/etc/init.d/sshd restart</i>
Authenticating root.
Password:
 * Stopping sshd...                       [ ok ]
 * Starting sshd...                       [ ok ]
</pre>

</body>
</subsection>
</section>

<section>
<title>Passare dal modo permissivo al modo rinforzato e viceversa</title>
<subsection>
<body>

<p>
Il passaggio tra i due modi in SELinux è molto semplice: occorre solamente 
scrivere 1 per impostare il modo rinforzato (oppure 0 per quello permissivo)
all'interno del file /selinux/enforce. Il modo in uso può venire individuato
leggendo il file sopracitato: 0 identifica il modo permissivo, 1 quello
rinforzato. Se l'opzione del kernel "NSA SELinux Development Support" non è
stata impostata, il sistema si troverà sempre nel modo rinforzato, e non sarà
possibile spostarsi nel modo permissivo.
</p>

<pre caption="">
<comment>Individuare il modo corrente</comment>
# <i>cat /selinux/enforce</i>
<comment>Passare al modo rinforzato</comment>
# <i>echo 1 > /selinux/enforce</i>
<comment>Passare al modo permissivo</comment>
# <i>echo 0 > /selinux/enforce</i>
</pre>

<p>
Una macchina con l'opzione per il supporto allo sviluppo abilitato, può venire
avviata nel modo rinforzato solamente aggiungendo <c>enforcing=1</c> alla linea
di comando del kernel all'interno del boot loader (GRUB, LiLo, etc).
</p>

</body>
</subsection>

<subsection>
<title>Politiche gestite</title>
<body>

<p>
In aggiunta alle opzioni del kernel descritte precedentemente, il modo può
venire impostato all'avvio del sistema modificando il file
<c>/etc/selinux/config</c>.
</p>

<pre caption="/etc/selinux/config">
# SELINUX can take one of these three values:
#       enforcing - SELinux security policy is enforced.
#       permissive - SELinux prints warnings instead of enforcing.
#       disabled - No SELinux policy is loaded.
SELINUX=<comment>permissive</comment>
</pre>

<p>
Le impostazioni di questo file saranno sovrascritte dalle opzioni a linea di
comando del kernel descritte precedentemente.
</p>

</body>
</subsection>
</section>

<section>
<title>Interpretare l'output di sestatus</title>
<subsection>
<body>

<p>
Per ottenere informazioni dettagliate di SELinux riguardo allo stato del sistema
si può fare riferimento all'utility <c>sestatus</c>. L'opzione <c>-v</c>
fornisce dettagli maggiori sul contesto di processi e file. Affinchè Sestatus
fornisca informazioni complete, occorre essersi autenticati come utente root
(oppure esserlo diventati tramite su/sudo), nel ruolo <c>sysadm_r</c>. Il
risultato verrà diviso in quattro sezioni:
</p>

<pre caption="Esempio di stato">
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         18
</pre>

<p>
Nella prima sezione vengono fornite informazioni riguardanti lo stato
principale: la prima linea mostra se il kernel SELinux è presente ed è
abilitato. Se risulta disabilitato, o il kernel non è stato compilato con il
supporto ad SELinux, oppure la politica non è stata caricata. La seconda voce
mostra il mount point per il filesystem di SELinux. Durante un normale utilizzo,
il filesystem dovrebbe essere montato nella cartella di default <c>/selinux</c>.
La terza linea mostra il modo di SELinux correntemente in uso, rinforzo oppure
permissivo. La quarta voce mostra la versione del database delle politiche
supportata dal kernel attualmente in uso.
</p>

<pre caption="Esempio di booleani">
Policy booleans:
secure_mode             inactive
ssh_sysadm_login        inactive
user_ping               inactive
</pre>

<p>
La seconda sezione mostra lo stato delle variabili booleane delle politiche
condizionali. Nella colonna di sinistra vengono mostrati i nomi delle variabili,
mentre in quella di destra il loro stato (attivo o inattivo). Questa sezione non
viene mostrata nei kernel con politiche di versione antecedenti alla 15, in
quanto non supportano le politiche condizionali.
</p>

<pre caption="Esempio di contesti dei processi">
Process contexts:
Current context:        pebenito:sysadm_r:sysadm_t
Init context:           system_u:system_r:init_t
/sbin/agetty            system_u:system_r:getty_t
/usr/sbin/sshd          system_u:system_r:sshd_t
</pre>

<p>
La terza sezione riguarda i contesti dei processi correnti, e le loro numerose
chiavi. Se un processo non sta venendo eseguito nel contesto corretto,
semplicemente non funzionerà correttamente.
</p>

<pre caption="Esempio di contesti dei file">
File contexts:
Controlling term:       pebenito:object_r:sysadm_devpts_t
/sbin/init              system_u:object_r:init_exec_t
/sbin/agetty            system_u:object_r:getty_exec_t
/bin/login              system_u:object_r:login_exec_t
/sbin/rc                system_u:object_r:initrc_exec_t
/sbin/runscript.sh      system_u:object_r:initrc_exec_t
/usr/sbin/sshd          system_u:object_r:sshd_exec_t
/sbin/unix_chkpwd       system_u:object_r:chkpwd_exec_t
/etc/passwd             system_u:object_r:etc_t
/etc/shadow             system_u:object_r:shadow_t
/bin/sh                 system_u:object_r:bin_t -> system_u:object_r:shell_exec_t
/bin/bash               system_u:object_r:shell_exec_t
/bin/sash               system_u:object_r:shell_exec_t
/usr/bin/newrole        system_u:object_r:newrole_exec_t
/lib/libc.so.6          system_u:object_r:lib_t -> system_u:object_r:shlib_t
/lib/ld-linux.so.2      system_u:object_r:lib_t -> system_u:object_r:shlib_t
</pre>

<p>
La quarta sezione mostra i contesti dei file controllati dai processi correnti,
e le loro numerose chiavi. Per quanto riguarda i collegamenti simbolici, viene
mostrato sia il contesto del collegamento che quello dell'oggetto riferito. Se
ad un file è stato assegnato un contesto non corretto, può risultare
inaccessibile o ottenere permessi non corretti per colpa di un particolare
processo.
</p>

</body>
</subsection>
</section>

</sections>