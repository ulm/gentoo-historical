<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/hardened/selinux/Attic/hb-selinux-overview.xml,v 1.4 2009/07/14 19:39:56 scen Exp $ -->

<sections>
<version>1.5</version>
<date>2009-07-13</date>

<section>
<title>Tipi di SELinux</title>
<subsection>
<body>

<p>
Si definisce tipo un attributo assegnato ad oggetti come file, porte di rete,
ecc. Il tipo di un processo si riferisce comunemente al suo dominio. Una
politica di SELinux è principalmente costituita da regole di applicazioni per i
tipi, che descrivono come i domini possono interagire sia con gli altri oggetti
che tra loro stessi. Il nome di un tipo termina solitamente col suffisso
&#39;_t&#39;, come <c>sysadm_t</c>. Questo risulta essere l'attributo più
importante per un processo o un oggetto, dal momento che la maggior parte delle
decisioni delle politiche sono basate sui tipi di sorgente e destinazione.
</p>

</body>
</subsection>
</section>

<section>
<title>Ruoli di SELinux</title>
<subsection>
<body>

<p>
SELinux lavora sui tipi, quindi il suo concetto di ruolo è differente da quello
di altri sistemi di controllo degli accessi basati sui ruoli. Infatti non
vengono assegnati permessi ai ruoli: un ruolo rappresenta un insieme di tipi
che un utente può utilizzare. Per esempio, un amministratore di sistema che sta
utilizzando la macchina per eseguire delle operazioni da utente normale,
dovrebbe appartenere al ruolo <c>staff_r</c>; per ottenere i privilegi di
amministratore, viene richiesto un passaggio al ruolo <c>sysadm_r</c>. Nel caso
di SELinux, il dominio al quale un utente può appartenere è determinato dal suo
ruolo. Se un ruolo non ha i permessi per accedere ad un dominio, la transizione
necessaria verrà negata, anche se le regole standard di Linux la
permetterebbero. Un ruolo solitamente possiede il suffisso &#39;_r&#39;, come
<c>system_r</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Identità di SELinux</title>
<subsection>
<title>Cos'è una identità in SELinux?</title>
<body>

<p>
Una identità di SELinux corrisponde al nome utente in Linux. Il cambio di
identità dovrebbe essere limitato ad alcuni casi molto specifici, dal momento
che i controlli di accesso basati su regole fanno affidamento sulle identità di
SELinux. Quindi, in linea di massima, l'identità di SELinux di un utente non
cambierà all'interno di una sessione. La possibilità in Linux di cambiare lo
userid tramite il comando <c>set</c>, rende assolutamente inappropriato
l'utilizzo dello userid per le identità di SELinux. L'identità assegnata ad un
utente deve essere abbinata necessariamente al nome utente in Linux: ogni
identità viene abilitata ad un insieme di ruoli.
</p>

</body>
</subsection>
<subsection>
<title>Mappare le identità di SELinux</title>
<body>

<p>
Le politiche di SELinux dispongono di numerose identità predefinite che
dovrebbero essere sufficienti per tutti gli utenti. E' necessario configurare
le corrispondenze delle identità solamente nella politica più rigorosa, ma non
nelle politiche di destinazione: nella maggior parte dei casi è sufficiente
l'identità predefinita (user_u)
</p>

<p>
Quando un utente accede al sistema, l'identità utilizzata da SELinux viene
determinata da questa corrispondenza.
</p>

<table>
<tr>
  <th>Identità di SELinux</th>
  <th>Ruoli</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>system_u</ti>
  <ti>system_r</ti>
  <ti>
    Processi di sistema (non interattivi). Non dovrebbe venire abilitata agli
    utenti.
  </ti>
</tr>
<tr>
  <ti>user_u</ti>
  <ti>user_r</ti>
  <ti>Utenti generici senza privilegi. E' l'identità predefinita.</ti>
</tr>
<tr>
  <ti>staff_u</ti>
  <ti>staff_r, sysadm_r</ti>
  <ti>
    Amministratori di sistema che accedono anche per attività da utente
    standard.
  </ti>
</tr>
<tr>
  <ti>sysadm_u</ti>
  <ti>sysadm_r</ti>
  <ti>
    Amministratori di sistema che accedono per eseguire unicamente operazioni di
    amministrazione. E' consigliabile non utilizzare questa identità.
  </ti>
</tr>
<tr>
  <ti>root</ti>
  <ti>staff_r, sysadm_r</ti>
  <ti>
    Identità speciale per l'utente root. Gli altri utenti dovrebbero invece
    utilizzare staff_u.
  </ti>
</tr>
</table>

<p>
Per ulteriori informazioni riguardo alla configurazione della corrispondenza
delle identità, vedere la relativa sezione della <uri
link="selinux-handbook.xml?part=3&amp;chap=2#doc_chap3">Guida a SELinux</uri>
</p>

</body>
</subsection>
</section>

<section>
<title>Il contesto di SELinux</title>
<subsection>
<body>

<p>
Si definisce contesto di SELinux l'uso combinato e contemporaneo dei tre modelli
di sicurezza descritti precedentemente. Un contesto quindi ha la forma
<c>identità</c>:<c>ruolo</c>:<c>tipo</c>. Il contesto di SELinux è il parametro
più importate che viene valutato per determinare un accesso.
</p>

</body>
</subsection>
<subsection>
<title>Il contesto degli oggetti</title>
<body>

<p>
Di seguito viene riportato l'esito tipico di un comando <c>ls -Z</c>:
</p>

<pre caption="Esempio: esito di ls -Z">
drwxr-xr-x  root     root     system_u:object_r:bin_t          bin
drwxr-xr-x  root     root     system_u:object_r:boot_t         boot
drwxr-xr-x  root     root     system_u:object_r:device_t       dev
drwxr-xr-x  root     root     system_u:object_r:etc_t          etc
</pre>

<p>
Le prime tre colonne mostrano i permessi, l'utente ed il gruppo standard di
linux. La quarta colonna rappresenta il contesto di sicurezza del file o della
directory. Agli oggetti viene assegnato il ruolo generico <c>object_r</c>.
Analizzando gli ultimi due campi, si può notare che i file vengono visualizzati
nell'identità di sistema e si dividono in  quattro differenti tipologie:
<c>bin_t</c>, <c>boot_t</c>, <c>device_t</c> ed <c>etc_t</c>.
</p>

</body>
</subsection>
<subsection>
<title>Il contesto dei processi</title>
<body>

<p>
Un comando <c>ps ax -Z</c> tipicamente può generare un output simile al
seguente:
</p>

<pre caption="Esempio: esito di ps ax -Z">
  PID CONTEXT                                  COMMAND
    1 system_u:system_r:init_t                 [init]
    2 system_u:system_r:kernel_t               [keventd]
    3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
    4 system_u:system_r:kernel_t               [kswapd]
    5 system_u:system_r:kernel_t               [bdflush]
    6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t              [syslog-ng]
  712 system_u:system_r:httpd_t                [apache]
  791 system_u:system_r:sshd_t                 [sshd]
  814 system_u:system_r:crond_t                [cron]
  826 system_u:system_r:getty_t                [agetty]
  827 system_u:system_r:getty_t                [agetty]
  828 system_u:system_r:getty_t                [agetty]
  829 system_u:system_r:getty_t                [agetty]
  830 system_u:system_r:getty_t                [agetty]
  831 system_u:system_r:httpd_t                [apache]
  832 system_u:system_r:httpd_t                [apache]
  833 system_u:system_r:httpd_t                [apache]
23093 system_u:system_r:sshd_t                 [sshd]
23095 user_u:user_r:user_t                     [bash]
23124 system_u:system_r:sshd_t                 [sshd]
23126 user_u:user_r:user_t                     [bash]
23198 system_u:system_r:sshd_t                 [sshd]
23204 user_u:user_r:user_t                     [bash]
23274 system_u:system_r:sshd_t                 [sshd]
23275 pebenito:staff_r:staff_t                 [bash]
23290 pebenito:staff_r:staff_t                 ps ax -Z
</pre>

<p>
Nell'esempio riportato vengono mostrate le informazioni generiche riguardanti un
processo, con l'aggiunta del contesto del processo. Come si può notare, i
processi di sistema e i demoni vengono eseguiti con identità <c>system_u</c> e
ruolo <c>system_r</c>, mentre i domini dipendono dal programma. Sono presenti
alcuni utenti connessi tramite ssh, che utilizzano l'identità generica
<c>user_u</c>. Infine si è connesso un utente con identità <c>pebenito</c> con
ruolo <c>staff_r</c> e dominio <c>staff_t</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>I file delle politiche di SELinux</title>
<subsection>
<body>

<p>
I sorgenti delle politiche di SELinux non vengono più installate sul sistema.
Nelle cartelle <c>/usr/share/selinux/{strict,targeted}</c> è presente una
collezione di pacchetti ed header di politiche per costruire i moduli
desiderati. I file delle politiche vengono processati da m4, e quindi il
compilatore di politiche <c>checkmodule</c> ne verifica la correttezza
sintattica e genera il modulo. A questo punto viene creato un pacchetto per la
politica tramite il programma <c>semodule_package</c>, utilizzando il modulo
della politica ed il file dei contesti. La politica pacchettizzata può venire
caricata all'interno di un kernel SELinux in esecuzione inserendola
nell'archivio dei moduli.
</p>

</body>
</subsection>
<subsection>
<title>*.pp</title>
<body>

<p>
Contiene i pacchetti per le politica: affinchè sia possibile richiamarli
all'interno della politica, devono venire inseriti nell'archivio dei moduli.
Ogni pacchetto contiene un modulo di politica caricabile ed opzionalmente un
file di contesto.
</p>

</body>
</subsection>
<subsection>
<title>include/</title>
<body>

<p>
Gli header per questa politica.
</p>

</body>
</subsection>
</section>

<section>
<title>Versioni dei pacchetti binari delle politiche</title>
<subsection>
<body>

<p>
In fase di compilazione, alla politica binaria risultante viene associata una
versione: la prima ad essere stata inserita nel kernel 2.6 è versione 15. Il
numero di una versione viene incrementato solamente nel momento in cui vengono
aggiunte nuove funzionalità che richiedono modifiche strutturali alla politica
compilata. Per esempio, dal kernel 2.6.5 sono state aggiunte le estensioni
condizionali delle poliche: questo ha richiesto che la versione delle politiche
venisse incrementata alla 16.
</p>

</body>
</subsection>
<subsection>
<title>Quale versione utilizza il mio kernel?</title>
<body>

<p>
La versione della politica di un kernel in uso può essere determinato
utilizzando <c>sestatus</c> o <c>policyvers</c>. I kernel attuali garantiscono
la retrocompatibilità e sono in grado di caricare anche le versioni precedenti
delle politiche (ma questa funzione potrebbe venire rimossa in futuro).
</p>

<note>
L'infrastruttura di gestione delle politiche (libsemanage) provvederà a creare e
utilizzare automaticamente la versione corretta delle politiche, senza che venga
richiesta nessun'altra operazione.
</note>

</body>
</subsection>
<subsection>
<title>Versioni delle politiche</title>
<body>

<p>
La tabella seguente contiene le versioni delle politiche presenti nei kernel
2.6.
</p>

<table>
<tr>
  <th>Versione</th>
  <th>Descrizione</th>
  <th>Versioni del kernel</th>
</tr>
<tr>
  <ti>12</ti>
  <ti>"Vecchie API" SELinux (deprecata).</ti>
</tr>
<tr>
  <ti>15</ti>
  <ti>"Nuove API" SELinux inserite all'interno del kernel 2.6.</ti>
  <ti>2.6.0 - 2.6.4</ti>
</tr>
<tr>
  <ti>16</ti>
  <ti>Aggiunte le estensioni condizionali.</ti>
  <ti>2.6.5</ti>
</tr>
<tr>
  <ti>17</ti>
  <ti>Aggiunto il supporto ad IPV6.</ti>
  <ti>2.6.6 - 2.6.7</ti>
</tr>
<tr>
  <ti>18</ti>
  <ti>Aggiunto il supporto granulare ai collegamenti di rete.</ti>
  <ti>2.6.8 - 2.6.11</ti>
</tr>
<tr>
  <ti>19</ti>
  <ti>Migliorata la sicurezza multi-livello.</ti>
  <ti>2.6.12 - 2.6.13</ti>
</tr>
<tr>
  <ti>20</ti>
  <ti>Ottimizzazioni della dimensione della tabella degli accessi.</ti>
  <ti>2.6.14 - 2.6.18</ti>
</tr>
<tr>
  <ti>21</ti>
  <ti>
    Classi di oggetti nelle transizioni di intervallo (range transitions).
  </ti>
  <ti>2.6.19 - 2.6.24</ti>
</tr>
<tr>
  <ti>22</ti>
  <ti>
    Politiche funzionali (es. permettono di implementare in modo selettivo le
    caratteristiche della politica stessa, NdT).
  </ti>
  <ti>2.6.25</ti>
</tr>
<tr>
  <ti>23</ti>
  <ti>Modalità permissive in base al dominio.</ti>
  <ti>2.6.26 - 2.6.27</ti></tr>
<tr>
  <ti>23</ti>
  <ti>Gerarchia esplicita (type bounds).</ti>
  <ti>2.6.28 - current</ti>
</tr>
</table>

</body>
</subsection>
</section>

<section>
<title>Estensioni condizionali delle politiche</title>
<subsection>
<body>

<p>
Le estensioni condizionali delle politiche permettono di abilitare o meno le
regole durante l'esecuzione, senza caricare una politica modificata. Utilizzando
operatori booleani ed espressioni all'interno delle politiche, le regole possono
essere richiamate al verificarsi di determinate situazioni.
</p>

</body>
</subsection>
<subsection>
<title>Determinare i valori booleani</title>
<body>

<p>
Lo stato di una politica booleana in quella correntemente in uso può venire
determinato in due modi. Il primo è utilizzando <c>sestatus</c>.
</p>

<pre caption="Esempio dell'output di sestatus">
# sestatus
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         17

Policy booleans:
user_ping               inactive
</pre>

<p>
Il secondo è <c>getsebool</c>: un semplice strumento che visualizza lo stato
delle politiche booleane e se dei valori stanno per cambiare.
</p>

<pre caption="Esempio di comando getsebool">
# getsebool -a
user_ping --> active: 0 pending: 0
</pre>

</body>
</subsection>
<subsection>
<title>Cambiare i valori booleani</title>
<body>

<p>
E' possibile ottenere il valore di una booleana utilizzando il comando
<c>togglesebool</c>. Possono venire specificati numerosi booleani in una linea
di comando. Verrà mostrato il nuovo valore di una booleana.
</p>

<pre caption="Esempio di comando togglesebool">
# togglesebool user_ping
user_ping: active
</pre>

<p>
Il valore di una booleana può venire impostato specificatamente utilizzando il
comando <c>setsebool</c>.
</p>

<pre caption="Esempio di comando setsebool">
# setsebool user_ping 0
</pre>

<p>
Per impostare il valore di una booleana come predefinito, si utilizza l'opzione
<c>-P</c>.
</p>

<pre caption="Cambiare il valore predefinito">
# setsebool -P user_ping 1
</pre>

</body>
</subsection>
</section>

<section>
<title>I messaggi delle politiche nel kernel</title>
<subsection>
<body>

<p>
Mentre un sistema è in funzione, è possibile che un programma cerchi col suo
comportamento di violare una politica di sicurezza. Se un sistema è protetto
dalla politica, l'accesso verrà negato e verrà registrato un messaggio
all'interno del log del kernel. In caso contrario (permessive mode), l'accesso
verrà concesso, ma verrà comunque segnalato tramite un messaggio nel log.
</p>

</body>
</subsection>
<subsection>
<title>I messaggi AVC</title>
<body>

<p>
La maggior parte dei messaggi del kernel da parte di SELinux provengono dalla
cache del vettore degli accessi (Access Vector Cache). Riconoscere i messaggi
di negazione è importante per individuare un eventuale attacco in corso oppure
se un programma richiede degli accessi inattesi. Un esempio di negazione può
apparire simile al seguente:
</p>

<pre caption="Esempio di messaggio AVC">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
Anche se la maggior parte dei messaggi AVC sono negazioni, saltuariamente può
apparire un messaggio di verifica per un accesso permesso:
</p>

<pre caption="Esempio di messaggio AVC 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>

<p>
In questo caso, è stata concessa l'abilità di caricare una politica. Questo è un
evento critico di sicurezza, e quindi viene sempre segnalato. Un altro evento
che viene sempre registrato è il passaggio tra la modalità protetta e quella
permissiva.
</p>

<p>
SELinux interromperà il salvataggio delle negazioni nel caso in cui ne venga
ricevuto un numero molto alto in un intervallo di tempo ridotto. In ogni caso,
questo non implica sempre che vi sia un attacco in corso: è possibile che un
programma possa eseguire qualcosa che provochi numerose negazioni in un arco di
tempo ridotto, come per esempio l'esecuzione di uno stat() sui nodi dei
dispositivi nella cartella /dev. Per evitare di riempire i file di log, SELinux
usa una limitazione sui suoi messaggi:
</p>

<pre caption="Esempio di messaggio AVC 3">
AVC: 12 messages suppressed.
</pre>

<p>
La politica potrebbe essere stata modificata per non mostrare gli accessi se
sono provocati dal normale comportamento del programma, ma è comunque necessario
che vengano vietati.
</p>

</body>
</subsection>
<subsection>
<title>Altri messaggi del kernel</title>
<body>

<pre caption="inode_doinit_with_dentry">
inode_doinit_with_dentry:  context_to_sid(system_u:object_r:bar_t) returned 22 for dev=hda3 ino=517610
</pre>

<p>
Questo messaggio significa che al file presente sul dispositivo /dev/hda3 con
inode numero 517610 è stato assegnato il contesto system_u:object_r:bar_t, che
non è valido. Gli oggetti sprovvisti di un contesto valido vengono trattati come
se avessero il contesto system_u:object_r:unlabeled_t assegnato.
</p>

</body>
</subsection>
</section>

<section>
<title>Sezionare una negazione</title>
<subsection>
<body>

<p>
Le negazioni contengono numerose informazioni, in funzione del tipo di accesso.
</p>

<pre caption="Esempi di Negazione">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
La negazione più comune si riferisce all'accesso ai file. Per maggiore
chiarezza, il primo messaggio di negazione può venire separato in:
</p>

<table>
<tr>
  <th>Componente</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>avc:  denied</ti>
  <ti>SELinux ha negato questo accesso.</ti>
</tr>
<tr>
  <ti>{ lock }</ti>
  <ti>L'accesso tentato è stato bloccato.</ti>
</tr>
<tr>
  <ti>pid=28341</ti>
  <ti>L'ID del processo che ha tentato l'accesso è 28341.</ti>
</tr>
<tr>
  <ti>exec=/sbin/agetty</ti>
  <ti>
    Il nome ed il percorso completo dell'eseguibile del processo è /sbin/agetty.
  </ti>
</tr>
<tr>
  <ti>path=/var/log/wtmp</ti>
  <ti>
    Il nome e percorso completo dell'oggetto richiesto è /var/log/wtmp. Nota: il
    percorso completo non è sempre disponibile.
  </ti>
</tr>
<tr>
  <ti>dev=03:03</ti>
  <ti>
    L'oggetto richiesto risiede sul device 03:03 (numeri di major:minor). Sui
    kernel 2.6 questo può venire risolto in un nome, come per esempio hda3.
  </ti>
</tr>
<tr>
  <ti>ino=475406</ti>
  <ti>Il numero dell'inode dell'oggetto richiesto è 475406.</ti>
</tr>
<tr>
  <ti>scontext=system_u:system_r:getty_t</ti>
  <ti>Il contesto del programma è system_u:system_r:getty_t.</ti>
</tr>
<tr>
  <ti>tcontext=system_u:object_r:var_log_t</ti>
  <ti>Il contesto dell'oggetto richiesto è system_u:object_r:var_log_t.</ti>
</tr>
<tr>
  <ti>tclass=file</ti>
  <ti>L'oggetto di destinazione è un file normale.</ti>
</tr>
</table>

<p>
I messaggi AVC non devono necessariamente possedere tutti i campi descritti,
come mostrato nelle altre due negazioni. La variabilità dei campi dipende dalla
classe dell'oggetto di destinazione; comunque i campi di maggiore interesse (il
tipo di accesso, i contesti di sorgente e destinazione e la classe dell'oggetto
di destinazione) sono sempre presenti in un messaggio AVC.
</p>

</body>
</subsection>
<subsection>
<title>Apprendere le negazioni</title>
<body>

<p>
Le negazioni possono risultare notevolmente confusionarie, dal momento che
possono essere dovute a molti motivi. La chiave per capire cosa sta accadendo
consiste nel conoscere il comportamento dei programmi ed interpretare
correttamente il messaggio. L'oggetto di destinazione non si limita solamente ai
file: può anche essere riferito ad apparati di rete, comunicazioni tra processi
o altro.
</p>

<p>
Nell'esempio descritto precedentemente, al programma agetty viene vietato di
bloccare un file. Siccome il file è di tipo var_log_t, risulta implicito che
il file di destinazione risieda nella cartella /var/log. Le informazioni del
campo field, confermano che si tratta del file /var/log/wtmp; nel caso in cui le
informazioni di quest'ultimo campo non fossero disponibili, è possibile ottenere
la conferma grazie all'inode. Il file wtmp contiene informazioni riguardo agli
utenti attualmente collegati, mentre agetty gestisce gli accessi sui terminali
virtuali tty: di conseguenza si può concludere che sia un accesso previsto di
agetty per aggiornare wtmp. Quindi per quale motivo questo accesso è stato
negato? E' presente un baco nella politica che non permette l'accesso?
Controllando il contesto si può notare che non risulta essere quello corretto:
dovrebbe infatti essere system_u:object_r:wtmp_t invece che
system_u:object_r:var_log_t.
</p>

<p>
Nel caso in cui questo accesso non venisse compreso, un amministratore potrebbe
erroneamente concedere a getty_t i permessi di lettura e scrittura ai file
var_log_t, che potrebbe non essere corretto, dal momento che solamente agetty
necessita di modificare /var/log/wtmp. Questo esempio sottolinea quanto sia
critico mantenere la consistenza nei
contesti dei file.
</p>

</body>
</subsection>
</section>

<section>
<title>Riferimenti</title>
<subsection>
<body>

<p>
<uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
SELinux Policy README
</p>

</body>
</subsection>
</section>
</sections>