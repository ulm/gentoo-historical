<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/hardened/selinux/Attic/hb-selinux-overview.xml,v 1.1 2007/07/12 19:06:59 scen Exp $ -->

<sections>
<version>1.5</version>
<date>2006-09-01</date>

<section>
<title>Tipi di SELinux</title>
<subsection>
<body>

<p>
Si definisce tipo un attributo assegnato ad oggetti come file, porte di rete,
ecc. Il tipo di un processo si riferisce comunemente al suo dominio. Una
politica di SELinux è principalmente costituita da regole di applicazioni per i
tipi, che descrivono come i domini possono interagire sia con gli altri oggetti
che tra loro stessi. Il nome di un tipo termina solitamente col suffisso
&#39;_t&#39;, come <c>sysadm_t</c>. Questo risulta essere l'attributo più
importante per un processo o un oggetto, dal momento che la maggior parte delle
decisioni delle politiche sono basate sui tipi di sorgente e destinazione.
</p>

</body>
</subsection>
</section>

<section>
<title>Ruoli di SELinux</title>
<subsection>
<body>

<p>
SELinux lavora sui tipi, quindi il suo concetto di ruolo è differente da quello
di altri sistemi di controllo degli accessi basati sui ruoli. Infatti non
vengono assegnati permessi ai ruoli: un ruolo rappresenta un insieme di tipi
che un utente può utilizzare. Per esempio, un amministratore di sistema che sta
utilizzando la macchina per eseguire delle operazioni da utente normale,
dovrebbe appartenere al ruolo <c>staff_r</c>; per ottenere i privilegi di
amministratore, viene richiesto un passaggio al ruolo <c>sysadm_r</c>. Nel caso
di SELinux, il dominio al quale un utente può appartenere è determinato dal suo
ruolo. Se un ruolo non ha i permessi per accedere ad un dominio, la transizione
necessaria verrà negata, anche se le regole standard di Linux la
permetterebbero. Un ruolo solitamente possiede il suffisso &#39;_r&#39;, come
<c>system_r</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Identità di SELinux</title>
<subsection>
<title>Cos'è una identità in SELinux?</title>
<body>

<p>
Una identità di SELinux corrisponde al nome utente in Linux. Il cambio di
identità dovrebbe essere limitato ad alcuni casi molto specifici, dal momento
che i controlli di accesso basati su regole fanno affidamento sulle identità di
SELinux. Quindi, in linea di massima, l'identità di SELinux di un utente non
cambierà all'interno di una sessione. La possibilità in Linux di cambiare lo
userid tramite il comando <c>set</c>, rende assolutamente inappropriato
l'utilizzo dello userid per le identità di SELinux. L'identità assegnata ad un
utente deve essere abbinata necessariamente al nome utente in Linux: ogni
identità viene abilitata ad un insieme di ruoli.
</p>

</body>
</subsection>
<subsection>
<title>Mappare le identità di SELinux (2006.1+)</title>
<body>

<p>
Le politiche di SELinux dispongono di numerose identità predefinite che
dovrebbero essere sufficienti per tutti gli utenti. E' necessario configurare
le corrispondenze delle identità solamente nella politica più rigorosa, ma non
nelle politiche di destinazione: nella maggior parte dei casi è sufficiente
l'identità di default (user_u)
</p>

<p>
Quando un utente accede al sistema, l'identità utilizzata da SELinux viene
determinata da questa corrispondenza.
</p>

<table>
<tr>
  <th>Identità di SELinux</th>
  <th>Ruoli</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>system_u</ti>
  <ti>system_r</ti>
  <ti>
    Processi di sistema (non interattivi). Non dovrebbe venire abilitata agli
    utenti.
  </ti>
</tr>
<tr>
  <ti>user_u</ti>
  <ti>user_r</ti>
  <ti>Utenti generici senza privilegi. E' l'identità predefinita.</ti>
</tr>
<tr>
  <ti>staff_u</ti>
  <ti>staff_r, sysadm_r</ti>
  <ti>
    Amministratori di sistema che accedono anche per attività da utente
    standard.
  </ti>
</tr>
<tr>
  <ti>sysadm_u</ti>
  <ti>sysadm_r</ti>
  <ti>
    Amministratori di sistema che accedono per eseguire unicamente operazioni di
    amministrazione. E' consigliabile non utilizzare questa identità.
  </ti>
</tr>
<tr>
  <ti>root</ti>
  <ti>staff_r, sysadm_r</ti>
  <ti>
    Identità speciale per l'utente root. Gli altri utenti dovrebbero invece
    utilizzare staff_u.
  </ti>
</tr>
</table>

<p>
Per ulteriori informazioni riguardo alla configurazione della corrispondenza
delle identità, vedere <uri
link="selinux-handbook.xml?part=3&amp;chap=2#doc_chap3">SELinux HOWTO</uri>
</p>

</body>
</subsection>
<subsection>
<title>Configurare le identità di SELinux (pre 2006.1)</title>
<body>

<p>
Le identità di SELinux sono contenute nel file "users" all'interno della
directory delle politiche. La sintassi utilizzata è piuttosto semplice: per
esempio, per abilitare l'utente Linux <c>pebenito</c> ai ruoli di <c>staff_r</c>
e <c>sysadm_r</c>, basta aggiungere alla fine del file una riga simile:
</p>

<pre caption="Linea di esempio per un utente">
user pebenito roles { staff_r sysadm_r };
</pre>

<p>
A questo punto è possibile caricare la politica. Nel caso in cui un utente non
abbia una corrispondente linea all'interno del file, la sua identità verrà
impostata in modo predefinito a <c>user_u</c> e sarà abilitato solamente al
ruolo <c>user_r</c>.
</p>

<impo>
Gli utenti normali ai quali è stata associata un'identità, dovrebbero essere
abilitati al ruolo <c>user_r</c>, ma non <c>staff_r</c>, che dovrebbe venire
invece concesso agli amministratori assieme a <c>sysadm_r</c>. Tutti gli utenti
dovrebbero poter utilizzare <c>user_r</c> o <c>staff_r</c>, altrimenti non
saranno in grado di effettuare un accesso remoto al sistema.
</impo>

<p>
Nel momento in cui viene associata un'identità ad un utente, la sua home
directory e il relativo intero contenuto dovrebbero venire adeguatamente
etichettati. La home directory dell'utente verrà etichettata in base al primo
ruolo associato all'utente nel file users. Riferendosi all'esempio precedente,
l'utente pebenito avrà la sua home directory etichettata come
<c>staff_home_dir_t</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Il contesto di SELinux</title>
<subsection>
<body>

<p>
Si definisce contesto di SELinux l'uso combinato e contemporaneo dei tre modelli
di sicurezza descritti precedentemente. Un contesto quindi ha la forma
<c>identità</c>:<c>ruolo</c>:<c>tipo</c>. Il contesto di SELinux è il parametro
più importate che viene valutato per determinare un accesso.
</p>

</body>
</subsection>
<subsection>
<title>Il contesto degli oggetti</title>
<body>

<p>
Di seguito viene riportato l'esito tipico di un comando <c>ls -Z</c>:
</p>

<pre caption="Esempio: esito di ls -Z">
drwxr-xr-x  root     root     system_u:object_r:bin_t          bin
drwxr-xr-x  root     root     system_u:object_r:boot_t         boot
drwxr-xr-x  root     root     system_u:object_r:device_t       dev
drwxr-xr-x  root     root     system_u:object_r:etc_t          etc
</pre>

<p>
Le prime tre colonne mostrano i permessi, l'utente ed il gruppo standard di
linux. La quarta colonna rappresenta il contesto di sicurezza del file o della
directory. Agli oggetti viene assegnato il ruolo generico <c>object_r</c>.
Analizzando gli ultimi due campi, si può notare che i file vengono visualizzati
nell'identità di sistema e si dividono in  quattro differenti tipologie:
<c>bin_t</c>, <c>boot_t</c>, <c>device_t</c> ed <c>etc_t</c>.
</p>

</body>
</subsection>
<subsection>
<title>Il contesto dei processi</title>
<body>

<p>
Un comando <c>ps ax -Z</c> tipicamente può generare un output simile al
seguente:
</p>

<pre caption="Esempio: esito di ps ax -Z">
  PID CONTEXT                                  COMMAND
    1 system_u:system_r:init_t                 [init]
    2 system_u:system_r:kernel_t               [keventd]
    3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
    4 system_u:system_r:kernel_t               [kswapd]
    5 system_u:system_r:kernel_t               [bdflush]
    6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t              [syslog-ng]
  712 system_u:system_r:httpd_t                [apache]
  791 system_u:system_r:sshd_t                 [sshd]
  814 system_u:system_r:crond_t                [cron]
  826 system_u:system_r:getty_t                [agetty]
  827 system_u:system_r:getty_t                [agetty]
  828 system_u:system_r:getty_t                [agetty]
  829 system_u:system_r:getty_t                [agetty]
  830 system_u:system_r:getty_t                [agetty]
  831 system_u:system_r:httpd_t                [apache]
  832 system_u:system_r:httpd_t                [apache]
  833 system_u:system_r:httpd_t                [apache]
23093 system_u:system_r:sshd_t                 [sshd]
23095 user_u:user_r:user_t                     [bash]
23124 system_u:system_r:sshd_t                 [sshd]
23126 user_u:user_r:user_t                     [bash]
23198 system_u:system_r:sshd_t                 [sshd]
23204 user_u:user_r:user_t                     [bash]
23274 system_u:system_r:sshd_t                 [sshd]
23275 pebenito:staff_r:staff_t                 [bash]
23290 pebenito:staff_r:staff_t                 ps ax -Z
</pre>

<p>
Nell'esempio riportato vengono mostrate le informazioni generiche riguardanti un
processo, con l'aggiunta del contesto del processo. Come si può notare, i
processi di sistema e i demoni vengono eseguiti con identità <c>system_u</c> e
ruolo <c>system_r</c>, mentre i domini dipendono dal programma. Sono presenti
alcuni utenti connessi tramite ssh, che utilizzano l'identità generica
<c>user_u</c>. Infine si è connesso un utente con identità <c>pebenito</c> con
ruolo <c>staff_r</c> e dominio <c>staff_t</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>I file delle politiche di SELinux (pre 2006.1)</title>
<subsection>
<body>

<p>
All'interno di <c>/etc/security/selinux/src/policy</c> sono contenuti i numerosi
file e cartelle necessarie a generare una politica. Per facilitare tale
operazione, per modificare le regole comuni ci si appoggia alle macro del
processore di testi m4. Dopo che i file delle politiche vengono elaborate da m4,
il compilatore di politiche <c>checkpolicy</c> ne verifica la correttezza
sintattica e crea un file binario, che può venire caricato all'interno di un
kernel SELinux.
</p>

</body>
</subsection>
<subsection>
<title>Il Makefile</title>
<body>

<p>
Il Makefile delle politiche ne gestisce la compilazione e l'installazione. E'
presente un'opzione configurabile per controllare la <uri
link="#doc_chap6">versione delle politiche</uri> che può ricevere quattro
parametri:
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>make policy</ti>
  <ti>Compila la politica corrente e genera un file binario.</ti>
</tr>
<tr>
  <ti>make install</ti>
  <ti>
    Compila la politica corrente e la installa nella cartella
    /etc/security/selinux/src.
  </ti>
</tr>
<tr>
  <ti>make load</ti>
  <ti>
    Compila, installa e carica la politica corrente nel kernel attualmente in
    uso.
  </ti>
</tr>
<tr>
  <ti>make relabel</ti>
  <ti>
    Etichetta nuovamente i filesystem utilizzando i contesti dei file della
    politica impostata.
  </ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>assert.te</title>
<body>

<p>
Le regole presenti in questo file verranno controllate nella fase finale della
compilazione. Se un permesso concesso in una politica corrisponde ad una di
queste asserzioni, il compilatore rifiuterà la politica: questo può facilitare
il lavoro garantendo che determinati accessi non saranno mai permessi.
</p>

</body>
</subsection>
<subsection>
<title>attrib.te</title>
<body>

<p>
E' possibile utilizzare un attributo per individuare un insieme di tipi con
proprietà simili. Ad ogni tipo può venire associato un numero qualsiasi di
attributi, e allo stesso modo ogni attributo può essere collegato con un numero
qualsiasi di tipi. Gli attributi devono venire esplicitamente dichiarati in
questo file, ed in seguito possono venire associati nelle dichiarazioni dei
tipi. I nomi degli attributi possono venire richiamati in seguito nella
configurazione per indicare gli insiemi di tipi che sono associati agli
attributi.
</p>

</body>
</subsection>
<subsection>
<title>constraints</title>
<body>

<p>
Questo file definisce vincoli addizionali sui permessi in forma di espressioni,
le quali devono venire soddisfatte affinchè vengano concessi i permessi
specificati. Questi vincoli sono utilizzati per raffinare le tabelle di
applicazione dei tipi e le regole permesse dai ruoli. L'uso tipico di questi
vincoli si ha nel limitare i cambiamenti di identità degli utenti o di ruoli in
determinati domini.
</p>

</body>
</subsection>
<subsection>
<title>domains/</title>
<body>

<p>
Questa cartella contiene le regole di applicazione di tipo: trovano posto i file
<c>admin.te</c>, <c>staff.te</c> e <c>user.te</c>, che contengono i vettori di
accesso per i ruoli <c>sysadm_r</c>, <c>staff_r</c> e <c>user_r</c>. Nella
cartella <c>program/</c> risiedono tutte le politiche attive per numerosi
programmi e demoni; la cartella <c>misc/</c> contiene i file per tutte le altre
politiche.
</p>

</body>
</subsection>
<subsection>
<title>file_contexts/</title>
<body>

<p>
Questa cartella contiene i file che descrivono i contesti di sicurezza per tutti
gli elementi dei filesystem persistenti. Vi si trova il file <c>types.fc</c>, il
quale elenca tutti i contesti di sicurezza per il sistema generale. Nella
cartella <c>program/</c> trovano posto i contesti di sicurezza per i demoni, in
relazione uno-a-uno con quelli descritti nella cartella <c>domains/program/</c>:
per esempio il file di politiche domains/program/syslogd.te corrisponde al file
dei contesti file_contexts/program/syslogd.fc.
</p>

</body>
</subsection>
<subsection>
<title>flask/</title>
<body>

<p>
Questa cartella contiene file di configurazione indipendenti dalle politiche. In
questi file sono presenti delle definizioni corrispondenti a quelle degli header
del kernel. Questi file <e>non dovrebbero</e> venire modificati.
</p>

</body>
</subsection>
<subsection>
<title>fs_use</title>
<body>

<p>
Questo file descrive il comportamento da adottare nell'etichettare i file sui
vari tipi di filesystem. Per esempio, ext3 utilizza un metodo di marcatura
persistente, mentre tmpfs utilizza degli identificatori transizionali. In linea
di massima questo file <e>non</e> dovrebbe aver bisogno di essere modificato.
</p>

</body>
</subsection>
<subsection>
<title>genfs_contexts</title>
<body>

<p>
Questo file tratta i contesti di sicurezza dei file su filesystem che non
supportano un etichettamento persistente, come per esempio <c>/proc</c>.
</p>

</body>
</subsection>
<subsection>
<title>initial_sid_contexts</title>
<body>

<p>
In questo file risiede il contesto iniziale di ogni identificatore di sicurezza.
In generale questo file <e>non</e> dovrebbe aver bisogno di venire modificato.
</p>

</body>
</subsection>
<subsection>
<title>macros/</title>
<body>

<p>
In questa cartella trovano posto le macro m4 utilizzate per facilitare la
creazione ed il mantenimento delle politiche. Contiene il file di macro
<c>admin_macros.te</c> che descrive i domini di amministrazione, come
<c>sysadm_t</c>. Sono presenti inoltre i file <c>user_macros.te</c> con le macro
utilizzate nei domini degli utenti (come <c>user_t</c> e <c>staff_t</c>), ed
infine il file <c>global_macros.te</c> con le macro utilizzate in tutta la
politica.
</p>

</body>
</subsection>
<subsection>
<title>mls</title>
<body>

<p>
Questo file contiene le configurazioni per la sicurezza multi-livello di
SELinux. Il concetto di sicurezza multi-livello (MLS) è sperimentale e non è
supportato da Gentoo.
</p>

</body>
</subsection>
<subsection>
<title>net_contexts</title>
<body>

<p>
Questo file definisce i contesti di sicurezza degli oggetti di rete come porte,
interfaccie e nodi. Nel caso in cui vengano eseguiti demoni su porte non
standard, si renderà necessario modificare questo file.
</p>

</body>
</subsection>
<subsection>
<title>rbac</title>
<body>

<p>
In passato questo file era l'unico posto in cui venivano dichiarati i ruoli; in
seguito le dichiarazioni sono state divise nei TE file fin qui descritti. Questo
file viene mantenuto adesso solamente per permettere ai ruoli di passare da
sysadm_r a system_r.
</p>

</body>
</subsection>
<subsection>
<title>tmp/</title>
<body>

<p>
Questa cartella viene utilizzata per salvare i file intermedi durante il
processo di compilazione della politica. Può essere tranquillamente rimossa, se
necessario.
</p>

</body>
</subsection>
<subsection>
<title>tunable.te</title>
<body>

<p>
Questo è il file di configurazione principale della politica.
</p>

</body>
</subsection>
<subsection>
<title>types/</title>
<body>

<p>
Questa cartella contiene i file per le dichiarazioni generali di tipi che non
appaiono nelle politiche individuali dei programmi.
</p>

</body>
</subsection>
<subsection>
<title>users</title>
<body>

<p>
Questo file descrive le identità di SELinux ed i ruoli ai quali possono
accedere.
</p>

</body>
</subsection>
</section>

<section>
<title>I file delle politiche di SELinux (2006.1+)</title>
<subsection>
<body>

<p>
I sorgenti delle politiche di SELinux non vengono più installate sul sistema.
Nelle cartelle <c>/usr/share/selinux/{strict,targeted}</c> è presente una
collezione di pacchetti ed header di politiche per costruire i moduli
desiderati. I file delle politiche vengono processati da m4, e quindi il
compilatore di politiche <c>checkmodule</c> ne verifica la correttezza
sintattica e genera il modulo. A questo punto viene creato un pacchetto per la
politica tramite il programma <c>semodule_package</c>, utilizzando il modulo
della politica ed il file dei contesti. La politica pacchettizzata può venire
caricata all'interno di un kernel SELinux in esecuzione inserendola
nell'archivio dei moduli.
</p>

</body>
</subsection>
<subsection>
<title>*.pp</title>
<body>

<p>
Contiene i pacchetti per le politica: affinchè sia possibile richiamarli
all'interno della politica, devono venire inseriti nell'archivio dei moduli.
Ogni pacchetto contiene un modulo di politica caricabile ed opzionalmente un
file di contesto.
</p>

</body>
</subsection>
<subsection>
<title>include/</title>
<body>

<p>
Gli header per questa politica.
</p>

</body>
</subsection>
</section>

<section>
<title>Versioni dei pacchetti binari delle politiche</title>
<subsection>
<body>

<p>
In fase di compilazione, alla politica binaria risultante viene associata una
versione: la prima ad essere stata inserita nel kernel 2.6 è versione 15. Il
numero di una versione viene incrementato solamente nel momento in cui vengono
aggiunte nuove funzionalità che richiedono modifiche strutturali alla politica
compilata. Per esempio, dal kernel 2.6.5 sono state aggiunte le estensioni
condizionali delle poliche: questo ha richiesto che la versione delle politiche
venisse incrementata alla 16.
</p>

</body>
</subsection>
<subsection>
<title>Quale versione utilizza il mio kernel?</title>
<body>

<p>
La versione della politica di un kernel in uso può essere determinato
utilizzando <c>sestatus</c> o <c>policyvers</c>. I kernel attuali garantiscono
la retrocompatibilità e sono in grado di caricare anche le versioni precedenti
delle politiche (ma questa funzione potrebbe venire rimossa in futuro).
</p>

<note>
L'infrastruttura di gestione delle politiche (libsemanage) provvederà a creare e
utilizzare automaticamente la versione corretta delle politiche, senza che venga
richiesta nessun'altra operazione (2006.1+).
</note>

</body>
</subsection>
<subsection>
<title>Compilare la versione corretta delle politiche (pre 2006.1)</title>
<body>

<p>
L'unica modifica necessaria consiste nel modificare una linea all'interno del
Makefile delle politiche. E' presente una riga simile alla seguente:
</p>

<pre caption="Contenuti del Makefile">
POLICYCOMPAT = -c 15
</pre>

<p>
Solitemente, checkpolicy genera una politica per la versione corrente. Le
versioni di una politica che checkpolicy è in grado di creare si determinano
tramite il comando <c>checkpolicy -V</c>. Decommentando l'opzione appena
descritta, viene creata una politica compatibile. Nell'esempio riportato viene
creata una politica versione 15: è possibile modificarla a 16.
</p>

</body>
</subsection>
<subsection>
<title>Versioni delle politiche</title>
<body>

<p>
La tabella seguente contiene le versioni delle politiche presenti nei kernel 2.6.
</p>

<table>
<tr>
  <th>Versione</th>
  <th>Descrizione</th>
  <th>Versioni del kernel</th>
</tr>
<tr>
  <ti>12</ti>
  <ti>"Vecchie API" SELinux (deprecata).</ti>
</tr>
<tr>
  <ti>15</ti>
  <ti>"Nuove API" SELinux inserite all'interno del kernel 2.6.</ti>
  <ti>2.6.0 - 2.6.4</ti>
</tr>
<tr>
  <ti>16</ti>
  <ti>Aggiunte le estensioni condizionali.</ti>
  <ti>2.6.5</ti>
</tr>
<tr>
  <ti>17</ti>
  <ti>Aggiunto il supporto ad IPV6.</ti>
  <ti>2.6.6 - 2.6.7</ti>
</tr>
<tr>
  <ti>18</ti>
  <ti>Aggiunto il supporto granulare ai collegamenti di rete.</ti>
  <ti>2.6.8 - 2.6.11</ti>
</tr>
<tr>
  <ti>19</ti>
  <ti>Migliorata la sicurezza multi-livello.</ti>
  <ti>2.6.12 - 2.6.13</ti>
</tr>
<tr>
  <ti>20</ti>
  <ti>Ottimizzazioni della dimensione della tabella degli accessi.</ti>
  <ti>2.6.14 - 2.6.18</ti>
</tr>
<tr>
  <ti>21</ti>
  <ti>
    Classi di oggetti nelle transizioni di intervallo (range transitions).
  </ti>
  <ti>2.6.19 - corrente</ti>
</tr>
</table>

</body>
</subsection>
</section>

<section>
<title>Estensioni condizionali delle politiche</title>
<subsection>
<body>

<p>
Le estensioni condizionali delle politiche permettono di abilitare o meno le
regole durante l'esecuzione, senza caricare una politica modificata. Utilizzando
operatori booleani ed espressioni all'interno delle politiche, le regole possono
essere richiamate al verificarsi di determinate situazioni.
</p>

</body>
</subsection>
<subsection>
<title>Determinare i valori booleani</title>
<body>

<p>
Lo stato di una politica booleana in quella correntemente in uso può venire
determinato in due modi. Il primo è utilizzando <c>sestatus</c>.
</p>

<pre caption="Esempio dell'output di sestatus">
# sestatus
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         17

Policy booleans:
user_ping               inactive
</pre>

<p>
Il secondo è <c>getsebool</c>: un semplice strumento che visualizza lo stato
delle politiche booleane e se dei valori stanno per cambiare.
</p>

<pre caption="Esempio di comando getsebool">
# getsebool -a
user_ping --> active: 0 pending: 0
</pre>

</body>
</subsection>
<subsection>
<title>Cambiare i valori booleani</title>
<body>

<p>
E' possibile ottenere il valore di una booleana utilizzando il comando
<c>togglesebool</c>. Possono venire specificati numerosi booleani in una linea
di comando. Verrà mostrato il nuovo valore di una booleana.
</p>

<pre caption="Esempio di comando togglesebool">
# togglesebool user_ping
user_ping: active
</pre>

<p>
Il valore di una booleana può venire impostato specificatamente utilizzando il
comando <c>setsebool</c>.
</p>

<pre caption="Esempio di comando setsebool">
# setsebool user_ping 0
</pre>

<p>
Per impostare il valore di una booleana come predefinito, si utilizza l'opzione
<c>-P</c>.  (2006.1+)
</p>

<pre caption="Cambiare il valore di default (2006.1+)">
# setsebool -P user_ping 1
</pre>

</body>
</subsection>
</section>

<section>
<title>I messaggi delle politiche nel kernel</title>
<subsection>
<body>

<p>
Mentre un sistema è in funzione, è possibile che un programma cerchi col suo
comportamento di violare una politica di sicurezza. Se un sistema è protetto
dalla politica, l'accesso verrà negato e verrà registrato un messaggio
all'interno del log del kernel. In caso contrario (permessive mode), l'accesso
verrà concesso, ma verrà comunque segnalato tramite un messaggio nel log.
</p>

</body>
</subsection>
<subsection>
<title>I messaggi AVC</title>
<body>

<p>
La maggior parte dei messaggi del kernel da parte di SELinux provengono dalla
cache del vettore degli accessi (Access Vector Cache). Riconoscere i messaggi
di negazione è importante per individuare un eventuale attacco in corso oppure
se un programma richiede degli accessi inattesi. Un esempio di negazione può
apparire simile al seguente:
</p>

<pre caption="Esempio di messaggio AVC">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
Anche se la maggior parte dei messaggi AVC sono negazioni, saltuariamente può
apparire un messaggio di verifica per un accesso permesso:
</p>

<pre caption="Esempio di messaggio AVC 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>

<p>
In questo caso, è stata concessa l'abilità di caricare una politica. Questo è un
evento critico di sicurezza, e quindi viene sempre segnalato. Un altro evento
che viene sempre registrato è il passaggio tra la modalità protetta e quella
permissiva.
</p>

<p>
SELinux interromperà il salvataggio delle negazioni nel caso in cui ne venga
ricevuto un numero molto alto in un intervallo di tempo ridotto. In ogni caso,
questo non implica sempre che vi sia un attacco in corso: è possibile che un
programma possa eseguire qualcosa che provochi numerose negazioni in un arco di
tempo ridotto, come per esempio l'esecuzione di uno stat() sui nodi dei
dispositivi nella cartella /dev. Per evitare di riempire i file di log, SELinux
usa una limitazione sui suoi messaggi:
</p>

<pre caption="Esempio di messaggio AVC 3">
AVC: 12 messages suppressed.
</pre>

<p>
La politica potrebbe essere stata modificata per non mostrare gli accessi se
sono provocati dal normale comportamento del programma, ma è comunque necessario
che vengano vietati.
</p>

</body>
</subsection>
<subsection>
<title>Altri messaggi del kernel</title>
<body>

<pre caption="inode_doinit_with_dentry">
inode_doinit_with_dentry:  context_to_sid(system_u:object_r:bar_t) returned 22 for dev=hda3 ino=517610
</pre>

<p>
Questo messaggio significa che al file presente sul dispositivo /dev/hda3 con
inode numero 517610 è stato assegnato il contesto system_u:object_r:bar_t, che
non è valido. Gli oggetti sprovvisti di un contesto valido vengono trattati come
se avessero il contesto system_u:object_r:unlabeled_t assegnato.
</p>

</body>
</subsection>
</section>

<section>
<title>Sezionare una negazione</title>
<subsection>
<body>

<p>
Le negazioni contengono numerose informazioni, in funzione del tipo di accesso.
</p>

<pre caption="Esempi di Negazione">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
La negazione più comune si riferisce all'accesso ai file. Per maggiore
chiarezza, il primo messaggio di negazione può venire separato in:
</p>

<table>
<tr>
  <th>Componente</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti>avc:  denied</ti>
  <ti>SELinux ha negato questo accesso.</ti>
</tr>
<tr>
  <ti>{ lock }</ti>
  <ti>L'accesso tentato è stato bloccato.</ti>
</tr>
<tr>
  <ti>pid=28341</ti>
  <ti>L'ID del processo che ha tentato l'accesso è 28341.</ti>
</tr>
<tr>
  <ti>exec=/sbin/agetty</ti>
  <ti>
    Il nome ed il percorso completo dell'eseguibile del processo è /sbin/agetty.
  </ti>
</tr>
<tr>
  <ti>path=/var/log/wtmp</ti>
  <ti>
    Il nome e percorso completo dell'oggetto richiesto è /var/log/wtmp. Nota: il
    percorso completo non è sempre disponibile.
  </ti>
</tr>
<tr>
  <ti>dev=03:03</ti>
  <ti>
    L'oggetto richiesto risiede sul device 03:03 (numeri di major:minor). Sui
    kernel 2.6 questo può venire risolto in un nome, come per esempio hda3.
  </ti>
</tr>
<tr>
  <ti>ino=475406</ti>
  <ti>Il numero dell'inode dell'oggetto richiesto è 475406.</ti>
</tr>
<tr>
  <ti>scontext=system_u:system_r:getty_t</ti>
  <ti>Il contesto del programma è system_u:system_r:getty_t.</ti>
</tr>
<tr>
  <ti>tcontext=system_u:object_r:var_log_t</ti>
  <ti>Il contesto dell'oggetto richiesto è system_u:object_r:var_log_t.</ti>
</tr>
<tr>
  <ti>tclass=file</ti>
  <ti>L'oggetto di destinazione è un file normale.</ti>
</tr>
</table>

<p>
I messaggi AVC non devono necessariamente possedere tutti i campi descritti,
come mostrato nelle altre due negazioni. La variabilità dei campi dipende dalla
classe dell'oggetto di destinazione; comunque i campi di maggiore interesse (il
tipo di accesso, i contesti di sorgente e destinazione e la classe dell'oggetto
di destinazione) sono sempre presenti in un messaggio AVC.
</p>

</body>
</subsection>
<subsection>
<title>Apprendere le negazioni</title>
<body>

<p>
Le negazioni possono risultare notevolmente confusionarie, dal momento che
possono essere dovute a molti motivi. La chiave per capire cosa sta accadendo
consiste nel conoscere il comportamento dei programmi ed interpretare
correttamente il messaggio. L'oggetto di destinazione non si limita solamente ai
file: può anche essere riferito ad apparati di rete, comunicazioni tra processi
o altro.
</p>

<p>
Nell'esempio descritto precedentemente, al programma agetty viene vietato di
bloccare un file. Siccome il file è di tipo var_log_t, risulta implicito che
il file di destinazione risieda nella cartella /var/log. Le informazioni del
campo field, confermano che si tratta del file /var/log/wtmp; nel caso in cui le
informazioni di quest'ultimo campo non fossero disponibili, è possibile ottenere
la conferma grazie all'inode. Il file wtmp contiene informazioni riguardo agli
utenti attualmente collegati, mentre agetty gestisce gli accessi sui terminali
virtuali tty: di conseguenza si può concludere che sia un accesso previsto di
agetty per aggiornare wtmp. Quindi per quale motivo questo accesso è stato
negato? E' presente un baco nella politica che non permette l'accesso?
Controllando il contesto si può notare che non risulta essere quello corretto:
dovrebbe infatti essere system_u:object_r:wtmp_t invece che
system_u:object_r:var_log_t.
</p>

<p>
Nel caso in cui questo accesso non venisse compreso, un amministratore potrebbe
erroneamente concedere a getty_t i permessi di lettura e scrittura ai file
var_log_t, che potrebbe non essere corretto, dal momento che solamente agetty
necessita di modificare /var/log/wtmp. Questo esempio sottolinea quanto sia
critico mantenere la consistenza nei
contesti dei file.
</p>

</body>
</subsection>
</section>

<section>
<title>Riferimenti</title>
<subsection>
<body>

<p>
<uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
SELinux Policy README
</p>

</body>
</subsection>
</section>
</sections>