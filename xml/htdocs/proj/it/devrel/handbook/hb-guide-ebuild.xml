<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/devrel/handbook/Attic/hb-guide-ebuild.xml,v 1.12 2008/01/20 19:24:31 scen Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/gentoo-howto.xml :: R1.50.
-->

<sections>
<version>1.0.4</version>
<date>2007-11-01</date>

<section>
<title>Il Portage tree</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Il portage tree si trova tipicamente in <path>/usr/portage</path> ed è
organizzato in una struttura gerarchica consistente in directory categorizzate,
seguite da directory specifiche per ogni pacchetto, per esempio è possibile
trovare il file <path>util-linux-2.11y.ebuild</path> nella directory
<path>/usr/portage/sys-apps/util-linux</path>.  Possono esserci anche altre
versioni di <c>util-linux</c> oltre che <path>util-linux-2.11y.ebuild</path>.
Ciò è dovuto al fatto che <e>tutti gli ebuild per un particolare pacchetto
(indipendentemente dalla versione)</e>, condividono la stessa directory
<path>miacategoria/miopacchetto</path> in <path>/usr/portage</path>.
</p>

</body>
</subsection>
<subsection>
<title>Effettuare il Check Out del Portage Tree dal CVS</title>
<body>

<p>
Se il sistema CVS non è familiare, è consigliabile leggere la <uri
link="http://www.gentoo.org/doc/it/cvs-tutorial.xml" >Guida al CVS di Gentoo
Linux</uri> per maggiori informazioni.
</p>

<p>
Il Portage tree si trova nel modulo <c>gentoo-x86</c> del Gentoo Linux tree.
Per fare il check out del modulo (circa 350 megabyte) si deve prima configurare
CVS tramite la guida precedente, poi fare il check out del modulo
<c>gentoo-x86</c>.
</p>

</body>
</subsection>
<subsection>
<title>Cosa (non) mettere nel Portage tree</title>
<body>

<p>
Prima di scrivere un nuovo ebuild, controllare <uri
link="http://bugs.gentoo.org">bugs.gentoo.org</uri> per verificare che non ci
sia già un ebuild corrispondente ma non ancora inserito nel portage tree. Andare
su <uri link="http://bugs.gentoo.org">bugs.gentoo.org</uri>, scegliere query e
selezionare "Advanced Search" (Ricerca Avanzata); scegliere <e>Gentoo Linux</e>
come prodotto e come componente <e>ebuilds</e>, nel campo ricerca mettere il
nome dell'ebuild e come status scegliere NEW, ASSIGNED, REOPENED e RESOLVED
(RESOLVED è importante), dopodiché inviare la query. Le persone pigre possono
cliccare <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">qui</uri>.
</p>

<p>
Generalmente, il Portage tree deve essere usato solo per contenere i file
<path>.ebuild</path> insieme ad altri file relativamente piccoli, come patch o
esempi di configurazione. Questi tipi di file devono essere posizionati nella
directory <path>/usr/portage/categoria/pacchetto/files</path> per tenere pulita
la directory <path>categoria/pacchetto</path>. Le eccezioni a questa regola sono
per patch di grandi dimensioni (lo si raccomanda per patch più grandi di 20KB)
che dovrebbero essere messe nei mirror Gentoo in modo che la gente non sprechi
eccessivamente la larghezza di banda e lo spazio del disco fisso. Inoltre non
si dovrebbero aggiungere al CVS del Portage Tree dei file binari (non ASCII). Se
lo si deve fare in un altro ramo del CVS, per esempio, volendo aggiungere una
piccola immagine PNG per qualsiasi ragione, assicurarsi di aggiungerla a CVS
usando l'opzione <c>-kb</c> nel modo seguente:
</p>

<pre caption="Aggiungere file binari al CVS">
# <i>cvs add -kb miafoto.png</i>
</pre>

<p>
L'opzione <c>-kb</c> dice a CVS che <path>miafoto.png</path> è un file
binario e deve essere trattato in maniera particolare. Per esempio, fondere le
differenze di due versioni diverse di questo file, non deve essere reso
possibile, per ovvie ragioni. Inoltre, riguardo alle fusioni di differenze,
tutte le patch che si aggiungono a Portage devono necessariamente <e>non</e>
essere compresse. Questo permette a CVS di fondere i cambiamenti e informare
correttamente gli sviluppatori in caso di conflitti.
</p>

<p>
È importante ricordare che i pacchetti di cui si effettua il commit devono
essere <e>predisposti</e> <e>a funzionare in modo trasparente</e> per gli utenti
finali quando vengono marcati stabili. Assicurarsi di avere un buon insieme di
impostazioni predefinite che soddisfino la maggior parte dei sistemi e degli
utenti che utilizzeranno questo pacchetto. Se il pacchetto non dovesse
funzionare, e non si è molto sicuri su come farlo funzionare, controllare altre
distribuzioni che hanno già forgiato le loro versioni del pacchetto. È possibile
controllare <uri
link="http://cvs.mandriva.com/cgi-bin/viewcv.cgi/SPECS/">Mandriva</uri> o <uri
link="http://www.debian.org/distrib/packages">Debian</uri> o <uri
link="http://cvs.fedora.redhat.com/">Fedora</uri> per qualche esempio.
</p>

<p>
Quando viene fatto il commit su CVS, tutti gli sviluppatori devono usare
<c>repoman commit</c> al posto di <c>cvs commit</c> per inviare i propri ebuild.
Prima di effettuare il commit, eseguire <c>repoman full</c> per essere sicuri di
non aver dimenticato qualcosa.
</p>

</body>
</subsection>

<subsection>
<title>Politica di Commit su CVS</title>
<body>

<ul>
  <li>Eseguire sempre <c>repoman scan</c> prima del commit.</li>
  <li>Eseguire sempre <c>repoman full</c> prima del commit.</li>
  <li>
    Controllare sempre la correttezza di <path>package.mask</path> tramite il
    comando <c>emerge --pretend miopacchetto</c> prima del commit e verificare
    che non ci siano conflitti.
  </li>
  <li>Aggiornare sempre il <path>ChangeLog</path> prima del commit.</li>
  <li>
    Fate sempre il commit del file <path>package.mask</path> prima del
    pacchetto aggiornato, in caso ci siano conflitti durante il commit di
    <path>package.mask</path>.
  </li>
  <li>
    Fare sempre dei commit in modo atomico (ovvero un pezzo alla volta, non
    tutto insieme); se si esegue il commit di un pacchetto con una nuova
    licenza, o marcato "masked" (nascosto), prima eseguire il commit del
    <path>package.mask</path> rivisto e/o della licenza, poi l'ebuild, il
    <path>ChangeLog</path>, le patch e il file <uri
    link="?part=2&amp;chap=4">metadata.xml</uri> tutto in <b>una</b> volta,
    per evitare di rovinare l'installazione degli utenti.
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>La directory Files</title>
<body>

<p>
Come indicato in precedenza, dentro ad ogni sottodirectory di ogni pacchetto c'è
una directory <path>files/</path>.  Qualunque patch, file di configurazione o
altri file ausiliari richiesta dal proprio pacchetto vanno posizionati in questa
directory; ogni file più grande di 20KB dovrebbe essere posizionato nei mirror
per diminuire la quantità di file (non necessari) che gli utenti dovranno
scaricare. Si può considerare di denominare le patch create autonomamente
solo per far compilare correttamente il pacchetto con un nome specifico in base
alla versione, per esempio <path>miopacchetto-1.0-gentoo.diff</path> o più
semplicemente <path>1.0-gentoo.diff</path>. Notare che l'estensione
<path>gentoo</path> informa gli utenti che la patch è stata creata dagli
sviluppatori Gentoo, piuttosto che recuperata da qualche mailing list o da altre
fonti. Si ricorda nuovamente di non comprimere i file diff poiché CVS non
gestisce in modo agevole i file binari.
</p>

<p>
Considerare l'aggiunta di un prefisso o suffisso come
<path>miopacchetto-1.0</path> al nome di ogni file dai posizionare in
<path>files/</path>, per far sì che i file usati per ogni versione individuale
di un ebuild siano distinguibili dagli altri, e che i cambiamenti fra le
differenti revisioni siano visibili. Questa è generalmente una buona idea :).
È possibile utilizzare suffissi diversi se si vuole dare maggior significato al
nome della patch.
</p>

<p>
Se si hanno vari file da posizionare in <path>files/</path>, considerare la
creazione di sottodirectory come ad esempio <path>files/1.0/</path> e mettere i
rispettivi file nella sottodirectory appropriata. Usando questo metodo, non c'è
più bisogno di aggiungere le informazioni di versione ai nomi dei file. e spesso
questa soluzione è più conveniente.
</p>

</body>
</subsection>
</section>
<section>
<title>Script ebuild</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Gli script ebuild sono la base dell'intero sistema di portage. Essi contengono
tutte le informazioni necessarie allo scaricamento, estrazione, compilazione e
all'installazione dei sorgenti, come anche ad eseguire qualsiasi
installazione/rimozione opzionale o passaggio di configurazione pre/post
installazione. Mentre la maggior parte di Portage è scritta in Python, gli
ebuild sono scritti in bash, poiché usando bash è possibile richiamare i comandi
come da linea di comando. Uno dei più importanti principi di progettazione su
cui si basano gli script ebuild è l'avere a disposizione gli stessi comandi che
si scriverebbero da riga di comando in un'installazione manuale del pacchetto.
Per raggiungere questo scopo, usare la sintassi bash è un'ottima cosa.
</p>

<p>
Gli script ebuild vengono interpretati dai comandi <c>ebuild</c> ed
<c>emerge</c>. Il comando <c>ebuild</c> è uno strumento di costruzione a basso
livello. Può compilare ed installare un singolo ebuild. Controlla se le
dipendenze sono soddisfatte, non tenta però di risolverle automaticamente.
Dall'altra parte, <c>emerge</c> è un motore ad alto livello per <c>ebuild</c>
ed ha l'abilità di auto-installare le dipendenze se necessarie, eseguire emerge
<e>simulati</e> in modo che che l'utente possa vedere quali ebuild verranno
installati, e molto altro. In generale, <c>emerge</c> rimpiazza totalmente
<c>ebuild</c> tranne che in una area. Con <c>ebuild</c> è possibile eseguire in
modo incrementale le varie parti dell'installazione di un pacchetto
(scaricamento, estrazione, compilazione, installazione e "merging" -
installazione vera e propria nel filesystem) una per volta. Per gli sviluppatori
questo strumento ha un valore inestimabile, perché permette di isolare i
problemi degli ebuild in una sua specifica porzione.
</p>

</body>
</subsection>
<subsection>
<title>Dare il nome ai file ebuild</title>
<body>

<p>
Il nome dei file ebuild consiste in quattro sezioni logiche:
</p>

<p>
<c>pkg-ver{_suf{#}}{-r#}.ebuild</c>
</p>

<note>
Le parentesi (<c>{}</c>) delineano campi opzionali e non compaiono nel nome
del pacchetto. <c>#</c> rappresenta un qualunque numero intero positivo diverso
da zero.
</note>

<p>
La prima sottosezione, <c>pkg</c>, è il nome del pacchetto, che dovrebbe
contenere solo lettere minuscole, cifre 0-9 e un qualsiasi numero di
questi caratteri : trattino singolo (<c>-</c>), "underscore" (<c>_</c>) o segno
più (<c>+</c>). Ad esempio: <c>util-linux</c>, <c>sysklogd</c> e <c>gtk+</c>. Ci
sono alcuni pacchetti in portage che non seguono queste regole, però i
<e>propri</e> pacchetti dovrebbero farlo.
</p>

<p>
La seconda sottosezione, <c>ver</c>, è la versione del pacchetto, che
dovrebbe essere normalmente la stessa dei sorgenti del tarball principale. La
versione è solitamente formata da 2 o 3 (o più) numeri separati da punti, come
<c>1.2</c> o <c>4.5.2</c>, e può  avere una lettera singola che segue l'ultima
cifra, esempi: <c>1.4b</c> o <c>2.6h</c>. La versione del pacchetto viene
collegata al suo nome con un trattino, ad esempio: <c>foo-1.0</c>,
<c>bar-2.4.6</c>.
</p>

<impo>
Se si sta pensando di usare una lettera nella versione del proprio pacchetto,
ricordarsi che le lettere in coda <e>non</e> si possono usare per indicare lo
status alpha o beta per un pacchetto, in quanto alpha e beta sono
<e>prerelease</e> e le revisioni sono <e>nuove versioni</e>. Questa è
un'importante distinzione perché portage usa il numero di versione dell'ebuild
per determinare se è più nuova o più vecchia degli altri pacchetti con la stessa
categoria e lo stesso nome.  È molto importante che questo numero di versione
rappresenti fedelmente la versione del pacchetto per permettere a Portage di
eseguire in modo appropriato il controllo delle dipendenze.
</impo>

<p>
La terza sottosezione <c>{_suf{#}}</c>, è opzionale e può contenere uno tra
questi suffissi predefiniti, ordinati dal meno recente al più recente:
</p>

<table>
<tr>
  <th>Suffisso</th>
  <th>Significato</th>
</tr>
<tr>
  <ti><c>_alpha</c></ti>
  <ti>Alpha release</ti>
</tr>
<tr>
  <ti><c>_beta</c></ti>
  <ti>Beta release</ti>
</tr>
<tr>
  <ti><c>_pre</c></ti>
  <ti>Prerelease</ti>
</tr>
<tr>
  <ti><c>_rc</c></ti>
  <ti>Release candidate</ti>
</tr>
<tr>
  <ti>(nessuno)</ti>
  <ti>Normale release</ti>
</tr>
<tr>
  <ti><c>_p</c></ti>
  <ti>Livello di patch (seguito da un numero intero)</ti>
</tr>
</table>

<p>
Ognuno di questi suffissi può essere seguito da un numero intero positivo
diverso da zero, per esempio <c>linux-2.4.0_pre10</c>. Assumendo che le parti
della versione siano identiche, i suffissi sono ordinati come segue (il più
basso significa il più vecchio): <c>_alpha</c> &lt; <c>_beta</c> &lt;
<c>_pre</c> &lt; <c>_rc</c> &lt; (nessun suffisso) &lt; <c>_p</c>.
</p>

<p>
Quando si comparano suffissi identici seguiti da numeri interi, quello con il
numero intero più grande sarà considerato più recente. Esempio:
<c>foo-1.0_alpha4</c> è più recente di <c>foo-1.0_alpha3</c>.
</p>

<p>
La quarta sottosezione del nome di un pacchetto è il numero di revisione
specifico di Gentoo Linux, (<c>{-r#}</c>). <c>#</c> è un numero intero positivo
diverso da zero; esempio, <c>package-4.5.3-r3</c>.
</p>

<p>
Questo numero di revisione è indipendente dalla versione del sorgente tarball
ed è usato per informare le persone che è disponibile una nuova e migliorata
revisione Gentoo Linux di un pacchetto. Le versioni iniziali degli ebuild non
devono avere nessun numero di revisione; per esempio, <c>package-4.5.3</c> viene
considerato da portage con un numero di revisione pari a zero.  Questo significa
che l'ordine è come segue: <c>1.0</c> (versione iniziale), <c>1.0-r1</c>,
<c>1.0-r2</c>, ecc.
</p>

<p>
Se si introducono miglioramenti significativi ad un ebuild esistente, copiarlo
in un nuovo file con il numero di revisione incrementato di 1. Ricordarsi
<e>sempre</e> di menzionare i cambiamenti nel <path>ChangeLog</path> quando c'è
una revisione <b>e</b> di inserire un messaggio sul CVS riguardante il proprio
commit, non farlo è contro la politica del CVS.
</p>

<p>
Ovviamente c'è la <e>quinta</e> sezione del nome di un ebuild -- l'estensione
<c>.ebuild</c> stessa.
</p>

</body>
</subsection>
<subsection>
<title>Contenuti di un file ebuild</title>
<body>

<p>
Questa sezione è una introduzione agli ebuild. Per l'elenco completo di ogni
cosa possibile riguardante gli ebuild, c'è una pagina man che spiega il formato
interno, le variabili, e le funzioni in uno script ebuild: <c>man 5 ebuild</c>.
</p>

<p><b>Header</b></p>

<p>
Quando si invia un ebuild, l'intestazione, o "header", dovrebbe essere
<e>esattamente</e> uguale a quello in <path>/usr/portage/header.txt</path>.
Ancora più importante, non modificarlo per nessun motivo e accertarsi che la
riga <c>&#36;Header: &#36;</c> sia intatta.
</p>

<p>
Le prime tre righe dovrebbe essere simile a queste:
</p>

<pre caption="Header valido">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# &#36;Header: &#36;
</pre>

<p><b>Variabili</b></p>

<p>
La prima parte di ogni ebuild è composta da un certo numero di variabili. Le
variabili ricadono in 3 categorie (riportate qui sotto):
</p>

<ul>
  <li>READ: variabili che si possono utilizzare ma <e>mai impostare</e></li>
  <li>MUST: variabili che <e>bisogna sempre impostare</e></li>
  <li>OPT: variabili che si dovrebbero impostare</li>
</ul>

<table>
<tr>
  <th>Variabile</th>
  <th>Uso</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Il nome e la versione del pacchetto.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Il nome del pacchetto.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>La versione del pacchetto.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>
    contiene il numero di revisione o <c>r0</c> se non esiste in numero di
    revisione.
  </ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Contiene il numero della versione con la revisione.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Contiene il nome completo del pacchetto <c>${PN}-${PVR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Elenco separato da spazi dei nomi dei file in <c>SRC_URI</c>. Non contiene
    il percorso dell'URL, solo il nome del file.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Contiene il percorso alla directory <path>distfiles</path>, dove sono
    memorizzati tutti i file scaricati da portage. Tipicamente equivale a
    <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Contiene il percorso alla sottodirectory  <path>files</path> nella posizione
    specifica del pacchetto nel portage tree. Non modificare questa variabile.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Base della root di compilazione per l'ebuild. Niente dovrebbe essere
    compilato al di fuori di questa directory.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    La directory sorgente per il proprio pacchetto; comunemente
    <c>${WORKDIR}/${P}</c>. Portage si stabilizzerà a questo valore per cui non
    è indispensabile impostarla!
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    La directory temporanea per il proprio pacchetto. E' usata come una
    directory virtuale <path>/tmp</path> mentre l'ebuild viene processato.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    La directory root in cui il pacchetto è installato, trattata come la
    <path>/</path> virtuale.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage gestisce diverse versioni dello stesso pacchetto installato. Volendo
    installare sia GCC 2.95 che GCC 3.2, specificare lo <c>SLOT</c> in ogni
    ebuild. Impostare lo <c>SLOT</c> di GCC 2.95 a <c>2</c> mentre quello di GCC
    3.2 a <c>3</c>.
    <br/>
    <b>Nota</b>: Usando <c>0</c> come valore di <c>SLOT</c> significa che quel
    pacchetto ha 1 solo <c>SLOT</c> configurabile (in altre parole, questo
    pacchetto non è installabile in SLOT multipli).
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Questa variabile indica da quale licenza è coperto il programma, es. GPL-2,
    BSD, eccetera. Questo campo deve essere valorizzato con una licenza valida
    (ossia ogni licenza disponibile in <path>/usr/portage/license/</path>). Se
    in questa directory la licenza non esiste ancora, essa deve essere inserita
    nel portage tree prima che l'ebuild sia aggiunto. Se la licenza non
    permette la redistribuzione, assicurarsi di mettere
    <c>RESTRICT</c>="nomirror" nell'ebuild.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Questa variabile ora supporta una serie di diverse funzioni . Prima di tutto
    specifica a quale architettura è destinato l'ebuild. Alcune keyword
    d'esempio includono: <e>x86, ppc, sparc, mips, alpha, arm, hppa, amd64,
    ia64</e>. Vedere il file profiles/arch.list nel portage tree per ulteriori
    dettagli. Ovviamente bisogna impostare questa variabile in modo che
    rispecchi l'architettura della macchina destinataria. Portage non permette
    ad una macchina x86 di compilare altro se non pacchetti x86, come
    specificato nella variabile <c>KEYWORDS</c>. I pacchetti che non supportano
    l'architettura nativa sono mascherati automaticamente da Portage. Se la flag
    <c>KEYWORDS</c> è preceduta da <e>~</e>, significa che quel particolare
    ebuild funziona, ma necessita di essere testato in diverse situazioni prima
    di essere spostato nel profilo stabile con la keyword prestabilita. Se la
    flag <c>KEYWORDS</c> è preceduta da <e>-</e>, allora il pacchetto non
    funzionerà con quella data keyword. Se la flag <c>KEYWORDS</c> non è
    preceduta da niente, il pacchetto viene considerato stabile. È possibile
    abilitare l'installazione di questi diversi tipi di pacchetti attraverso la
    variabile <c>ACCEPT_KEYWORDS</c> in <path>make.conf</path>.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti>Una <e>breve</e> descrizione di una riga del proprio pacchetto.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    Gli URL per ogni file sorgente del proprio pacchetto, separati da spazi
    bianchi. Non includere numeri di versione in SRC_URI e S. Cercare sempre di
    usare ${PV} o ${P}, e se un numero di versione non è compatibile con il nome
    del pacchetto sorgente, creare ed usare in alternativa un'apposita variabile
    ${MY_P}.
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    L'homepage del pacchetto. Se non si riesce ad individuarne una ufficiale,
    cercare di fornire un collegamento da <uri
    link="http://freshmeat.net/">freshmeat.net</uri> o da un sito di ricerca
    pacchetti simile. Mai fare riferimento al nome di una variabile nella
    stringa; includere solamente del testo vero e proprio.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Contiene qualunque variabile <c>USE</c> utilizzata dal proprio pacchetto.
    Ricordare che le <c>KEYWORDS</c> non vanno elencate qui!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Le dipendenze di compilazione del pacchetto sono elencate qui. Vedere la
    sezione <uri link="#doc_chap5">Dipendenze dei pacchetti</uri> per maggiori
    dettagli sulla sintassi appropriata.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Le dipendenze di run-time (esecuzione) del pacchetto sono elencate qui.
    Vedere di nuovo <uri link="#doc_chap5">Dipendenze dei pacchetti</uri> per
    maggiori dettagli.
  </ti>
</tr>
</table>

<p><b>Funzioni</b></p>

<p>
In un file ebuild si possono definire varie funzioni per controllare il processo
di compilazione e installazione del proprio pacchetto.
</p>

<table>
<tr>
  <th>Funzione</th>
  <th>Scopo</th>
</tr>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Usare questa funzione per eseguire delle operazioni essenziali di qualunque
    tipo. Ciò può includere il controllo di file di configurazione esistenti.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    Informa l'utente sulle azioni necessarie da eseguire se per qualche ragione
    (per esempio limitazioni della licenza) i sorgenti non possono essere
    scaricabili automaticamente. Usare questa funzione insieme a
    <c>RESTRICT="fetch"</c>. In questa funzione si devono visualizzare solamente
    dei messaggi, mai invocare <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Usare questa funzione per estrarre i sorgenti, applicare patch, ed
    eseguire programmi ausiliari come gli autotools. Il comportamento
    predefinito di questa funzione è l'estrazione dei pacchetti elencati in
    <c>A</c>. La directory di lavoro iniziale è definita da <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Usare questa funzione per configurare e compilare il pacchetto. La
    directory di lavoro iniziale è <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Usare questa funzione per installare il pacchetto in un'immagine in
    <c>D</c>. Se il proprio pacchetto usa automake, si può farlo semplicemente
    tramite <c>emake DESTDIR=${D} install</c>. <e>Assicurarsi che il pacchetto
    installi i  file utilizzando <c>D</c> come root!</e> La directory di lavoro
    iniziale è <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_test</c></ti>
  <ti>
    Eseguito solo quando <c>FEATURES="test"</c> è impostato e
    <c>RESTRICT="test"</c> non è impostato, questa funzione esegue in modo
    predefinito una funzione di testing offerto da qualsiasi Makefile nella
    directory <c>${S}</c>, eseguendo o "make test" o "make check", in base a
    cosa forniscono i Makefile. Può essere sovrascritto per generare un setup
    di test personalizzato.
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    I comandi vengono eseguiti appena <e>prima dell'installazione (merge)</e>
    dell'immagine del pacchetto nel filesystem.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    I comandi vengono eseguiti appena <e>dopo l'installazione (merge)</e>
    dell'immagine del pacchetto nel filesystem.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    I comandi vengono eseguiti appena <e>prima della rimozione (unmerge)</e>
    dell'immagine del pacchetto dal filesystem.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    I comandi vengono eseguiti appena <e>dopo la rimozione (unmerge)</e>
    dell'immagine del pacchetto dal filesystem.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    È possibile usare questa funzione per predisporre una configurazione
    iniziale del pacchetto dopo la sua installazione. Tutti i percorsi in questa
    funzione devono avere il prefisso <c>ROOT</c> che punta ad una directory
    radice specificata  dall'utente che potrebbe non essere <path>/</path>.
    Questa funzione viene eseguita <e>solo</e> e quando l'utente esegue:
    <c>emerge --config =${PF}</c>.
  </ti>
</tr>
</table>

<p>
<b>Funzioni di assistenza</b>
</p>

<p>
Negli ebuild, inoltre, si possono usare le seguenti funzioni di assistenza .
</p>

<table>
<tr>
  <th>Funzione</th>
  <th>Scopo</th>
</tr>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Controlla se una o più flag USE prestabilite sono definite. Se ciò è vero,
    la funzione restituisce "vero" alla shell. In ogni altro caso non viene
    stampato nulla sullo standard output. Per una versione verbosa, usare
    <c>usev</c>, che visualizza le flag USE eventualmente definite.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Ritorna 1 se il sistema ha la versione richiesta di un certo pacchetto. Per
    esempio <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Restituisce la <path>categoria/pacchetto-versione</path> del
    <path>categoria/pacchetto</path> richiesto. Per esempio <c>best_version
    x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Questa funzione controlla se una flag use è stata definita e di conseguenza
    restituisce "--with-foobar"; o "--without-foobar". Se viene usato un solo
    argomento, esso sarà usato sia per la flag USE sia per la stringa
    with(out)-string. Altrimenti il primo argomento sarà la flag USE e il
    secondo argomento la stringa with(out)-string. Per esempio <c>use_with
    truetype freetype</c> restituirà "--with-freetype" se truetype è nelle
    <c>USE</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Uguale a <c>use_with</c>, ma restituisce rispettivamente "--enable-foobar" o
    "--disable-foobar".
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Controlla se Portage conosce la versione del kernel. Se non la conosce,
    visualizza un errore e termina. Se si necessita della versione del kernel
    nel proprio script, usare la variabile <c>KV</c>, che viene automaticamente
    definita da Portage. In un sistema che esegue gentoo-sources-2.4.20-r6,
    <c>KV</c> avrebbe il valore "2.4.20".
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Crea (se necessario) un file <path>.keep</path> nella directory data in
    modo da non farla rimuovere automaticamente durante il processo di rimozione
    del pacchetto. Non creare <e>mai</e> autonomamente un file
    <path>.keep</path>. Se portage cambiasse la modalità di funzionamento di
    <c>keepdir</c>, creare autonomamente il file potrebbe corrompere il
    pacchetto.
  </ti> </tr> <tr>
  <ti><c>econf</c></ti>
  <ti>
    Esegue <c>./configure</c> con le opportune modifiche ai percorsi (prefix,
    host, mandir, infodir, datadir, sysconfdir, localstatedir). Facoltativamente
    è possibile passare degli argomenti extra a <c>./configure</c>
    specificandoli nella chiamata di <c>econf</c>, e gli utenti possono
    impostare la variabile di ambiente <c>EXTRA_ECONF</c>. Opzioni passate a
    configure hanno la precedenza in ordine inverso rispetto a come vengono
    fornite. In altre parole, il primo argomento sarà sempre sovrascritto
    dall'ultimo.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Esegue <c>make install</c> con le opportune modifiche ai percorsi (prefix,
    datadir, mandir, infodir, datadir, sysconfdir, localstatedir). Di nuovo,
    è possibile passare argomenti extra al comando make specificandoli nella
    chiamata di <c>einstall</c>. Notare che il modo preferito di installare un
    pacchetto è tramite il comando <c>emake install DESTDIR=${D}</c>, non
    tramite <c>einstall</c>. Questo comando è soltanto un ripiego per
    sovrapporsi al comportamento di makefile malfunzionanti.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Causa l'annullamento del processo corrente. Avviserà l'utente usando
    l'argomento fornito come motivazione. Non trascurare di passare un messaggio
    a <c>die</c>  se c'è più di una chiamata ad esso in una singola funzione. E'
    più difficile rintracciare un guasto se non si ha la certezza di <c>dove</c>
    il pacchetto fallisca.
  </ti>
</tr>
<tr>
  <ti><c>elog</c></ti>
  <ti>
    Informa l'utente su qualcosa di importante. L'argomento fornito ad
    <c>elog</c> è il messaggio che l'utente vedrà. Non usare <c>elog</c> per
    visualizzare banner come "*************************************". Il fatto
    che si stia usando <c>elog</c> è sufficiente per ottenere l'attenzione
    dell'utente. Il  messaggio viene inoltre registrato tramite il sistema ELOG
    di portage.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Visualizza messaggi informativi ma non importanti, che non richiedono la
    registrazione.
  </ti>
</tr>
</table>

<p>
<b>Funzioni di assistenza fornite da eutils.eclass</b>
</p>

<p>
Si possono usare nei propri ebuild le seguenti funzioni di assistenza fornite
dall'eclass "eutils" . Assicurarsi che <c>inherit eutils</c> sia presente
affinché queste funzioni vengano eseguite correttamente.
</p>

<table>
<tr>
  <th>Funzione</th>
  <th>Scopo</th>
</tr>
<tr>
  <ti><c>epatch</c></ti>
  <ti>
    Questa funzione agisce come alternativa semplificata del comando
    <c>patch</c> e funziona con archivi .bz2, .gz, .zip e patch di puro testo.
    Non occorre specificare una opzione "-p", ogni opzione che dev'essere
    specificata può essere dichiarata in <c>EPATCH_OPTS</c>. La funzione
    prevede come argomenti o un file o una directory - se viene specificata una
    directory, verranno applicate tutte le patch nella forma di "??_${ARCH}_..."
    : affinché una patch venga applicata, deve corrispondere all'architettura
    in esecuzione, avere "_all_" nel nome, o <c>EPATCH_FORCE</c> deve essere
    impostato a "yes".
  </ti>
</tr>
<tr>
  <ti><c>gen_usr_ldscript</c></ti>
  <ti>
    Questa funzione genera script linker in /usr/lib per librerie dinamiche
    in /lib. Questo corregge problemi di link quando un .so è in /lib mentre
    un .a è in /usr/lib.
  </ti>
</tr>
<tr>
  <ti><c>edos2unix</c></ti>
  <ti>
    Questa funzione effettua la stessa azione del binario <c>dos2unix</c>.
  </ti>
</tr>
<tr>
  <ti><c>egetent</c></ti>
  <ti>
    egetent agisce come wrapper per <c>getent</c> per Linux o <c>nidump</c> per
    Mac OS X (R).
  </ti>
</tr>
<tr>
  <ti><c>enewuser</c></ti>
  <ti>
    Crea un nuovo utente. Questa funzione si aspetta un argomento obbligatorio
    con il nome utente, e possono essere specificati molti argomenti facoltativi
    : <c>$2</c> contiene un UID, passare -1 per il successivo ID disponibile;
    <c>$3</c> contiene la shell, passare -1 per quella predefinita; <c>$4</c>
    contiene una directory home con <path>/dev/null</path> come predefinita,
    <c>$5</c> contiene  tutti i gruppi ai quali l'utente dovrebbe essere
    aggiunto, predefinito come vuoto e <c>$6</c> contiene qualsiasi altra
    opzione si voglia passare ad useradd.
  </ti>
</tr>
<tr>
  <ti><c>enewgroup</c></ti>
  <ti>
    Aggiunge un nuovo gruppo. Questa funzione si aspetta un argomento
    obbligatorio con il nome del gruppo - un secondo argomento facoltativo
    assegna al gruppo uno GID specifico.
  </ti>
</tr>
<tr>
  <ti><c>make_desktop_entry</c></ti>
  <ti>
    Crea una voce per il menù desktop: il primo argomento contiene il percorso
    al binario. Facoltativamente il secondo contiene un nome per l'icona -
    il valore predefinita è <c>${PN}</c>; il terzo può contenere un percorso
    all'icona relativo a <path>/usr/share/pixmaps</path> o un percorso completo
    - il valore predefinito è <c>${PN}</c>.png; il quarto può contenere una <uri
    link="http://standards.freedesktop.org/menu-spec/latest/apa.html">categoria
    di applicazioni</uri>, e il quinto argomento contiene facoltativamente un
    percorso di avvio per l'applicazione.
  </ti>
</tr>
<tr>
  <ti><c>check_license</c></ti>
  <ti>
    Visualizza una licenza che l'utente dovrò accettare, se l'argomento non è
    specificato allora viene usata la licensa specificata da <c>${LICENSE}</c>.
  </ti>
</tr>
<tr>
  <ti><c>unpack_pdv</c></ti>
  <ti>
    Estrae un archivio pdv generato, il primo argomento deve contenere il file
    da estrarre e il secondo dovrebbe contenere "off_t" il quale deve essere
    generato manualmente: eseguire <c>strace -elseek ${file}</c> e ottenendo
    qualcosa come "lseek(3, -4, SEEK_END)" si potrebbe passare il valore "4".
  </ti>
</tr>
<tr>
  <ti><c>unpack_makeself</c></ti>
  <ti>
    Estrae un archivio auto generato, richiede un file da estrarre come
    argomento.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_get_cds</c></ti>
  <ti>
    Tenta di recuperare dei file da un CD, specificati dagli argomenti presente
    sul sistema e montato su <c>${CDROM_ROOT}</c>.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_load_next_cd</c></ti>
  <ti>
    Carica il prossimo CD una volta finito con il primo CD. Se la funzione
    ritorna, <c>${CDROM_ROOT}</c> punterebbe al prossimo CD.
  </ti>
</tr>
<tr>
  <ti><c>strip-linguas</c></ti>
  <ti>
    Questa funzione assicura che LINGUAS contenga solo i linguaggi che un
    pacchetto può supportare specificati dagli argomenti passati alla funzione.
    Se il primo argomento è -i, viene compilata una lista di file .po nelle
    directory specificate e viene usata l'intersezione delle liste. Se il primo
    argomento è -u, viene compilata una lista di file .po nelle directory
    specificate e viene usata l'unione delle liste.
  </ti>
</tr>
</table>

<p>
<b>Funzioni di assistenza fornite da flag-o-matic.eclass</b>
</p>

<p>
È possibile usare nei propri ebuild le seguenti funzioni di assistenza fornite
dall'eclass "flag-o-matic". Assicurarsi che <c>inherit flag-o-matic</c> sia
presente affinché queste funzioni vengano eseguite correttamente. Non si
dovrebbero mai modificare direttamente le impostazioni del compilatore, usare
invece flag-o-matic per effettuare qualsiasi azioni come filtrare le flag che
causano problemi.
</p>

<table>
<tr>
  <th>Funzione</th>
  <th>Scopo</th>
</tr>
<tr>
  <ti><c>filter-flags</c></ti>
  <ti>
    Questa funzione rimuove particolari flag da <c>C[XX]FLAGS</c> - la
    corrispondenza viene verificata solo su flag complete.
  </ti>
</tr>
<tr>
  <ti><c>append-flags</c></ti>
  <ti>
    Questa funzione aggiunge flag extra alle variabili <c>C[XX]FLAGS</c>
    esistenti.
  </ti>
</tr>
<tr>
  <ti><c>replace-flags</c></ti>
  <ti>
    Sostituisce la flag specificata dal primo argomento con quella nel secondo
    argomento nelle variabili <c>C[XX]FLAGS</c> correnti.
  </ti>
</tr>
<tr>
  <ti><c>replace-cpu-flags</c></ti>
  <ti>
    Necessita di due argomenti. Sostituisce un dato valore di mtune/mcpu/march
    con quello nuovo (tipo così: replace-cpu-flags 'i686' 'i586' sostituirà
    -mtune/-march/-mcpu=i686 con -mtune/-march/-mcpu=i586).
  </ti>
</tr>
<tr>
  <ti><c>strip-flags</c></ti>
  <ti>
    Rimuove tutte le flag, tranne quelle specificate in <c>ALLOWED_FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>strip-unsupported-flags</c></ti>
  <ti>
    Rimuove da <c>C[XX]FLAGS</c> ogni flag non supportata dalla versione in uso
    di GCC.
  </ti>
</tr>
<tr>
  <ti><c>get-flag</c></ti>
  <ti>Trova una flag e stampa il suo valore.</ti>
</tr>
<tr>
  <ti><c>is-flag</c></ti>
  <ti>
    Ritorna vero se la flag è impostata nelle variabili <c>C[XX]FLAGS</c>
    correnti; vengono verificate solamente corrispondenze complete.
  </ti>
</tr>
<tr>
  <ti><c>append-ldflags</c></ti>
  <ti>
    Questa funzione aggiunge flag extra alla variabile <c>LDFLAGS</c> esistente.
  </ti>
</tr>
<tr>
  <ti><c>filter-ldflags</c></ti>
  <ti>
    Rimuove le flag specificate da <c>LDFLAGS</c>, la corrispondenza viene
    verificata solo su flag complete.
  </ti>
</tr>
<tr>
  <ti><c>fstack-flags</c></ti>
  <ti>
    Aggiunge -fno-stack-protector la quale sopprime -fstack-protector e
    -fstack-protector-all.
  </ti>
</tr>
</table>

<p><b>Funzioni di assistenza fornite da toolchain-funcs.eclass</b></p>

<p>
Si possono usare nei propri ebuild le seguenti funzioni di assistenza fornite
dall'eclass "toolchain-funcs". Assicurarsi che <c>inherit toolchain-funcs</c>
sia presente affinché queste funzioni vengano eseguite correttamente. Non si
dovrebbe mai specificare direttamente alcuna impostazione del compilatore o di
binutils, usare invece toolchain-funcs per specificare compilatori e binutils.
</p>

<p>
Lo scopo di usare queste funzioni è quello di supportare il cross-compiling e il
compilatore icc. Esse dovrebbero essere usate quando un pacchetto usa
esplicitamente gcc, g++, ld, ranlib o qualunque di questi strumenti elencati di
seguito. Generalmente i pacchetti che usano strumenti di autoconfigurazione
rilevano automaticamente il cross compiling e non necessitano di queste
funzioni.
</p>

<table>
<tr>
  <th>Funzione</th>
  <th>Scopo</th>
</tr>
<tr>
  <ti><c>tc-getAR</c></ti>
  <ti>Restituisce il nome dell'archiviatore</ti>
</tr>
<tr>
  <ti><c>tc-getAS</c></ti>
  <ti>Restituisce il nome dell'assemblatore</ti>
</tr>
<tr>
  <ti><c>tc-getCC</c></ti>
  <ti>Restituisce il nome del compilatore C</ti>
</tr>
<tr>
  <ti><c>tc-getCXX</c></ti>
  <ti>Restituisce il nome del compilatore C++</ti>
</tr>
<tr>
  <ti><c>tc-getLD</c></ti>
  <ti>Restituisce il nome del linker</ti>
</tr>
<tr>
  <ti><c>tc-getNM</c></ti>
  <ti>Restituisce il nome dello strumento d'ispezione di oggetti/simboli</ti>
</tr>
<tr>
  <ti><c>tc-getRANLIB</c></ti>
  <ti>Restituisce il nome dell'indicizzatore dell'archiviatore</ti>
</tr>
<tr>
  <ti><c>tc-getF77</c></ti>
  <ti>Restituisce il nome del compilatore fortran</ti>
</tr>
<tr>
  <ti><c>tc-getGCJ</c></ti>
  <ti>Restituisce il nome del compilatore java</ti>
</tr>
<tr>
  <ti><c>tc-getBUILD_CC</c></ti>
  <ti>Restituisce il nome del compilatore C per la compilazione</ti>
</tr>
<tr>
  <ti><c>tc-is-cross-compiler</c></ti>
  <ti>Un modo semplice per vedere se si sta usando un cross-compiler</ti>
</tr>
<tr>
  <ti><c>gcc-fullversion</c></ti>
  <ti> Ritorna la versione come da $($CC -dumpversion)</ti>
</tr>
<tr>
  <ti><c>gcc-version</c> </ti>
  <ti>Ritorna la versione, ma solo &lt;major>.&lt;minor></ti>
</tr>
<tr>
  <ti><c>gcc-major-version</c></ti>
  <ti>Ritorna la versione maggiore</ti>
</tr>
<tr>
  <ti><c>gcc-minor-version</c></ti>
  <ti>Ritorna la versione minore</ti>
</tr>
<tr>
  <ti><c>gcc-micro-version</c></ti>
  <ti>Ritorna la versione micro</ti>
</tr>
</table>

</body>
</subsection>

<subsection>
<title>Regole di scrittura di un file ebuild</title>
<body>

<p>
Poiché i file ebuild sono semplicemente degli shell script, è possibile
modificarli tramite gli usuali strumenti con cui si modificano gli script di
shell. Si deve usare una certa indentazione, usare solo caratteri di tabulazione
-- <e>non spazi</e>. Assicurarsi di configurare il proprio editor in modo da
inserire 4 spazi per ogni tabulazione. Assicurarsi ogni volta di usare le
parentesi attorno alle variabili d'ambiente; es. <c>${P}</c> invece di
<c>$P</c>.
</p>

<p>
Le linee lunghe vengono spezzate con ' \', così:
</p>

<pre caption="Spezzare le righe negli ebuild">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Per ulteriori dettagli, controllare <path>skel.ebuild</path> (di solito
residente in <path>/usr/portage</path>).
</p>

<p>
Se si utilizza Vim per la modifica di ebuild/eclass, il file vimrc predefinito
di Gentoo, <path>/etc/vim/vimrc</path>, assicura già che venga usata la
corretta indentazione e le impostazioni associate ai tipi di file per gli ebuild
e le eclass. Per ottenere risultati migliori, inclusa una speciale sintassi che
evidenzia le parole chiave degli ebuild, installare app-vim/gentoo-syntax.
</p>

<p>
Su sistemi non Gentoo, si possono ottenere risultati simili con le seguenti
righe nel proprio vimrc, o meglio ancora installando gli script gentoo-syntax,
scaricabili dai mirror Gentoo.
</p>

<pre caption="Configurare vimrc per la modifica degli ebuild">
au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh
au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab
</pre>

<p>
Se si sta usando Emacs, si dovrebbe effettuare l'emerge di
app-emacs/gentoo-syntax (per GNU EMacs) o app-xemacs/gentoo-syntax (per XEmacs).
Questi pacchetti forniscono le modalità principali per l'indentazione automatica
e l'evidenziazione della sintassi per gli ebuild e altri tipi di file specifici
di Gentoo.
</p>

<p>
Se si sta usando nano, si è fortunati! Modificare <path>/etc/nanorc</path> e
decommentare la sezione relativa agli ebuild.
</p>

</body>
</subsection>
<subsection>
<title>Variabili USE</title>
<body>

<p>
Lo scopo delle variabili USE è permettere di configurare Portage abilitando
o disabilitando globalmente e automaticamente certe caratteristiche <e>opzionali
durante la compilazione</e>.  Per esempio, ipotizzando di essere dei fan di
GNOME, potrebbe far piacere che per qualsiasi ebuild avente un'opzione di
compilazione per il supporto a GNOME venga attivata questa caratteristica. In
questo caso è necessario aggiungere <c>gnome</c> alla variabile <c>USE</c>
in <path>/etc/make.conf</path> per far sì che Portage aggiunga in automatico il
supporto opzionale GNOME ai pacchetti, se disponibile. Se invece non si vuole
il supporto a GNOME, basta modificate <path>/etc/make.conf</path> e assicurarsi
che <c>gnome</c> <e>non</e> sia indicato nella variabile <c>USE</c>. Gentoo
Linux ha un numero grandissimo di opzioni USE, per permettere di configurare il
sistema a proprio piacimento.
</p>

<note>
Se viene disattivata una variabile USE (ad esempio rimuovendo <c>gnome</c> da
<c>USE</c>), a Portage verrà solamente ordinato di disabilitare il supporto
<e>opzionale</e> in fase di compilazione per GNOME. Tuttavia, se si esegue
<c>emerge</c> su un ebuild che <e>richiede</e> GNOME, il pacchetto avrà
ovviamente il supporto per GNOME attivo, com'era prevedibile. Ciò inoltre
implica l'installazione automatica di GNOME (come dipendenza) se non è stata già
fatta in precedenza. E` sempre una buona idea eseguire un <c>emerge
--pretend</c> prima di eseguire un "reale" <c>emerge</c>; in questo modo si
saprà esattamente cosa si sta per ottenere!
</note>

<p>
Nei propri ebuild, è possibile controllare se una variabile USE è impostata
usando il comando <c>use &lt;variable&gt;</c>. Normalmente questo comando si usa
in questo modo:
</p>

<pre caption="Verificare se una flag USE è impostata">
if use X ; then
  # comandi specifici per X ...
fi
</pre>

<p>
Le variabili USE possono anche essere usate per impostare le dipendenze. Per
esempio, si potrebbe voler installare un pacchetto solo se quella determinata
variabile USE è impostata. Ciò viene fatto usando la sintassi <c>flag? (
categoria/pacchetto)</c> nella variabile <c>DEPEND</c> del proprio ebuild. In
questo esempio <c>categoria/pacchetto</c> verrà richiesto solo se <c>flag</c> è
presente in <c>USE</c>. È inoltre possibile specificare quale dipendenza usare
se una flag USE <e>è</e> impostata, e quale dipendenza usare se <e>non</e> è
impostata: <c>flag? (categoria/pacchetto)</c> e <c>!flag?
(altracategoria/altropacchetto)</c>. In questo caso, se <c>flag</c> non è
impostata, <c>altracategoria/altropacchetto</c> viene usato al posto di
<c>categoria/pacchetto</c>. Assicurarsi che i propri ebuild usino questa
sintassi e non quella di Bash. Le espressioni condizionali di Bash possono
interferire con il caching delle dipendenze di Portage, ed il loro uso può
rendere inutilizzabile l'ebuild.
</p>

<p>
Si dà un importante suggerimento su come usare <c>USE</c>. Il più delle volte un
pacchetto avrà uno script <c>./configure</c> utilizzato per eseguire i passaggi
di configurazione. Generalmente, se il proprio ebuild usa <c>./configure</c>,
ogni caratteristica opzionale abilitabile durante la compilazione dovrà essere
attivata o disattivata passando gli argomenti appropriati al comando
<c>./configure</c>. Questo è il modo migliore per farlo:
</p>

<pre caption="Espressioni conditionali basate sull'impostazione di USE">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 )
!apache2? ( =net-www/apache-1* )"

src_compile() {
  econf \
    $(use_enable X x11) \
    $(use_enable mysql) \
    || die "Error: econf failed!"
  emake || die "Error: emake failed!"
}
</pre>

<p>
Questo approccio dà dei buoni risultati. Non ci si deve preoccupare
sull'impostazione predefinita per mysql o per X (abilitato/disabilitato),viene
detto esplicitamente ad <c>econf</c> cosa fare in base alla variabile
<c>USE</c>.
Non occorre aggiungere che il codice è piuttosto chiaro in termini di
leggibilità :).
</p>

<p>
A volte, gli ebuild hanno delle caratteristiche facoltative in conflitto fra
di loro. Verificare questi conflitti e restituire un errore <e>non</e> è una
soluzione fattibile. Piuttosto bisogna favorire una di queste caratteristiche
rispetto alle altre. Riguardo a questo, consultare gli sviluppatori
originali (cosa usano generalmente come scelta predefinita), o considerare quale
opzione fornisce più funzionalità di uso comune, altrimenti tirare a sorte. Un
esempio è l'ebuild di msmtp. Il pacchetto può usare sia SSL con GnuTLS, oppure
SSL con OpenSSL, o nessun SSL. Siccome GnuTLS ha più funzionalità rispetto a
OpenSSL, esso verrà favorito:
</p>

<pre caption="Gestire funzionalità in conflitto tra di loro">
src_compile() {
    local myconf

    if use gnutls ; then
        myconf="${myconf} --enable-ssl --with-ssl=gnutls"
    elif use ssl ; then
        myconf="${myconf} --enable-ssl --with-ssl=openssl"
    else
        myconf="${myconf} --disable-ssl"
    fi

    econf \
        # Other stuff
        ${myconf} \
        || die "configure failed"

    emake || die "make failed"
}
</pre>

<p>Per vedere una tabella in continuo aggiornamento delle variabili USE, andare
<uri link="http://www.gentoo.org/dyn/use-index.xml">in questa pagina</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Locazioni nel filesystem</title>
<subsection>
<title>Introduzione a FHS</title>
<body>

<p>
Gli standard del layout del filesystem usati in Gentoo Linux seguono
scrupolosamente FHS, abbreviazione di <e>Filesystem Hierarchy Standard</e>
(Standard della Gerarchia del Filesystem). Una descrizione semplificata dello
standard viene data qui, per una descrizione specifica andare all'indirizzo:
<uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
Il percorso <path>/opt</path> viene nominato nella sezione 3.12 di FHS. La
sezione 4.4 tratta del percorso <path>/usr/X11R6</path>.  KDE e GNOME non sono
trattati in modo specifico e difatti non sono menzionati nella versione corrente
di FHS.
</note>

</body>
</subsection>
<subsection>
<title>Come adeguare i pacchetti al filesystem</title>
<body>

<p>
Abitualmente, se il pacchetto usa autoconf e automake, le
destinazioni d'installazione predefinite sono quasi sempre corrette, salvo
alcune eccezioni:
</p>

<ul>
  <li>
    Se si sta installando un programma in <path>/bin</path>, <path>/sbin</path>,
    <path>/usr/bin</path> o <path>/usr/sbin</path>, la sua pagina man deve
    essere installata in <path>/usr/share/man</path>. Ciò può essere fatto
    specificando <c>./configure --mandir=/usr/share/man</c> all'intero
    dell'ebuild.
  </li>
  <li>
    I file GNU info, devono essere sempre installati in
    <path>/usr/share/info</path>, <e>anche se sono file riguardanti X11, GNOME o
    programmi o strumenti specifici di KDE</e>. Prendete nota:
    <path>/usr/share/info</path> è la <e>sola</e> locazione ufficiale per i
    file GNU info. Siccome gli script <c>./configure</c> installano in modo
    predefinito i file info GNU in <c>/usr/info</c>, spesso è necessario
    chiamare <c>./configure</c> con l'argomento
    <c>--infodir=/usr/share/info</c>.
  </li>
  <li>
    I file di documentazione sono installati in <path>/usr/share/doc</path>, in
    una sottodirectory che riflette il nome la versione e la revisione del
    particolare programma. Questo va applicato a tutti i programmi: GNOME, KDE,
    X11 o programmi per console. Comunque, alcuni programmi possono installare
    documentazione addizionale o file di supporto in una directory
    <path>/usr/share</path> per i scopi autonomi.
  </li>
  <li>
    I programmi specifici per X11 e le librerie devono essere sempre installati
    in <path>/usr</path>, e non direttamente in <path>/usr/X11R6</path>.
    Questo percorso è riservato all'X window system, versione 11 release 6.
    Questo è per interpretare più alla lettera le istruzioni di FHS, rispetto a
    come viene fatto da altre distribuzioni.
  </li>
  <li>
    I programmi GNOME e KDE, devono essere sempre installati dentro
    <path>/usr</path>.
  </li>
</ul>

<impo>
Alcune distribuzioni scelgono di installare GNOME e KDE dentro
<path>/opt</path>. Non esiste uno standard per questi ambienti desktop
riguardo a dove installare effettivamente i loro file. Nell'interesse della
semplicità e consistenza, è stato scelto di installare tutti i pacchetti GNOME e
KDE nella directory <path>/usr</path>.
</impo>

<p>
In generale, bisogna far sì che gli ebuild installino i loro file in
<path>/usr</path>. <e>Alcuni</e> programmi possono essere compilati e linkati
con o senza le librerie GNOME, KDE e X11, cosa che può creare confusione. La
soluzione proposta è installare tutto in <path>/usr</path> per evitare ambiguità
e complessità inutili agli autori degli ebuild. La locazione nel filesystem di
un programma <e>non</e> deve dipendere dalla presenza o dalla assenza di una
variabile <c>USE</c>. Comunque, tutti gli ebuild nel portage tree <e>quasi
sempre</e> effettueranno esclusivamente l'installazione nella gerarchia
<path>/usr</path>.
</p>

<note>
In Gentoo Linux il percorso <path>/opt</path> è riservato ai pacchetti binari.
Ad esempio mozilla-bin, acroread, netscape e realplayer. I pacchetti che vengono
installati in questa posizione richiedono uno file ausiliario
<path>/etc/env.d/foo</path>, per poter includere le variabili d'ambiente e i
percorsi necessari nell'ambiente di esecuzione. Per maggiori informazioni su
<path>/etc/env.d</path>, consultare <uri
link="/doc/it/handbook/handbook-x86.xml?part=2&amp;chap=5">questo</uri>
documento.
</note>

</body>
</subsection>
</section>
<section>
<title>Gli script e le utilità di Portage</title>
<subsection>
<title>Script pubblici</title>
<body>

<p>
Questi sono gli script usati dall'amministratore di sistema per installare e
rimuovere pacchetti, e mantenere il database degli stessi.
</p>

<p>
<c>ebuild</c> è il motore principale del sistema Portage; esegue le operazioni
più importanti come l'estrazione, la compilazione, l'installazione, il merging
e l'unmerging.  Viene richiamato usando il comando: <c>ebuild
percorso/al/pacchetto.ebuild comando</c>.  I comandi disponibili sono:
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Descrizione</th>
  <th>Relativa funzione <c>ebuild</c></th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>Esegue vari comandi richiesti prima che l'ebuild possa procedere</ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Visualizza le dipendenze necessarie per la creazione del pacchetto</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Estrae, compila, installa e esegue il merge del pacchetto nel proprio file
    system
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Esegue il merge del pacchetto nel proprio filesystem, assumendo che
    l'estrazione, la compilazione e l'installazione siano già state eseguite
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>Estrae i sorgenti nella directory di lavoro</ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Compila il pacchetto</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Crea un RPM dal pacchetto</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Crea un pacchetto Gentoo <c>tbz2</c></ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Esegue lo stadio di pre-rimozione del pacchetto</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Esegue lo stadio di post-rimozione del pacchetto</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Esegue lo stadio di pre-installazione del pacchetto</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Esegue lo stadio di post-installazione del pacchetto</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>
    Imposta una configurazione predefinita una volta che è stato fatto il merge
    del pacchetto
  </ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>
    Aggiorna gli orari di modifica (mtime) per ogni archivio sorgente nel
    pacchetto
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Pulisce la directory di lavoro per il pacchetto</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Scarica i sorgenti del pacchetto</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Crea un file digest per il pacchetto</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>test</c>*</ti>
  <ti>Esegue la routine di auto-test per il pacchetto</ti>
  <ti><c>src_test</c></ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Installa il pacchetto nella directory immagine</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Esegue l'unmerge del pacchetto dal proprio filesystem</ti>
  <ti>N/A</ti>
</tr>
</table>

<note>
Nota: i comandi con l'asterisco (*) sono normalmente utilizzati solo dagli
sviluppatori.
</note>

<p>
<c>emerge</c> installa ricorsivamente il pacchetto e le sue dipendenze nel
filesystem. Questo comando ha molte opzioni, eseguire <c>emerge --help</c> per
un elenco.
</p>

<p>
<c>env-update</c> aggiorna i file di configurazione (includendo ma non
limitato a <path>/etc/ld.so.conf</path> e <path>/etc/profile.env</path>) per
includere le modifiche introdotte dai pacchetti installati.
</p>

</body>
</subsection>

<subsection>
<title>Script e comandi privati</title>
<body>

<p>
Questi sono script che si possono usare nell'ebuild per eseguire operazioni
comuni.
</p>

<p>
Gli esperti possono consultare direttamente gli script
in <path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Comando</th>
  <th>Valore predefinito</th>
  <th>Descrizione</th>
  <th>Esempio</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Imposta le opzioni usate quando si esegue <c>dodir</c></ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>N/A</ti>
  <ti>Installa i binari specificati in <path>DESTTREE/bin</path></ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>""</path></ti>
  <ti>
    Imposta la relativa sottodirectory usata da <c>dodoc</c>
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>N/A</ti> <ti>Crea una directory, gestisce trasparentemente ${D}</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati nella directory di documentazione del pacchetto
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (vedere <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati con le modalità <e>EXEOPTIONS</e> (vedere
    <c>exeopts</c>) in <path>PATH</path> definito da <e>EXEINTO</e> (vedere
    <c>exeinto</c>)
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>N/A</ti> <ti>Crea un hardlink, gestisce trasparentemente ${D}</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati e le directory in
    <path>/usr/share/doc/${PF}/html</path>
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati in /usr/share/info, e li comprime con gzip
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati con modalità <c>INSOPTIONS</c> (vedere
    <c>insopts</c>) in <path>INSDESTTREE</path> (vedere <c>insinto</c>)
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa le librerie specificate in <path>DESTTREE/lib</path> con modalità
    0644
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa le librerie specificate in <path>DESTTREE/lib</path> con modalità
    0644
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa le librerie specificate in <path>DESTTREE/lib</path> con modalità
    0755
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file specificati in <path>/usr/share/man/manX</path>, in accordo
    con il suffisso del file (file.1 andrà in <path>man1</path>
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installa i file in <path>DESTTREE/sbin</path>, assicurandosi che siano
    eseguibili
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>N/A</ti>
  <ti>Crea un symlink, gestisce trasparentemente ${D}.</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>N/A</ti>
  <ti>
    Esegue make con <c>MAKEOPTS</c>. Alcuni pacchetti non possono essere fatti
    in parallelo; usare invece <c>emake -j1</c>. Se si devono passare argomenti
    extra a make, aggiungerli nel comando emake. Gli utenti possono impostare
    la variabile di ambiente <c>EXTRA_EMAKE</c> per passare flag extra a emake.
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Imposta la root (<e>EXEDESTTREE</e>) per il comando <c>doexe</c></ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Imposta le opzioni usate quando si esegue <c>doexe</c></ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>N/A</ti>
  <ti>
    Applica la proprietà specificata ai file specificati tramite il comando
    chown, gestisce trasparentemente ${D}
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>N/A</ti>
  <ti>
    Applica i permessi specificati ai file specificati tramite il comando
    chmod, gestisce trasparentemente ${D}
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Imposta la root (<e>INSDESTTREE</e>) per il comando <c>doins</c></ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Imposta le opzioni usate quando si esegue <c>doins</c></ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Imposta il prefisso di destinazione (<path>DESTTREE</path>) per tutti i
    comandi 'do' (come <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>,
    <c>dolib.so</c>, <c>domo</c>, <c>dosbin</c>)</ti> <ti><c>into /</c>
  </ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Imposta le opzioni usate quando si esegue <c>dolib</c></ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>dobin</c> che installa il binario specificato in modo
    trasparente rinominando il secondo argomento
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>dodoc</c> che installa il file specificato in modo trasparente
    rinominando il secondo argomento
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>doexe</c> che installa il file specificato in modo trasparente
    rinominando il secondo argomento
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>doins</c> che installa il file specificato in modo trasparente
    rinominando il secondo argomento
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>doman</c> che installa il file specificato in modo trasparente
    rinominando il secondo argomento
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper di <c>dosbin</c> che installa il file specificato in modo
    trasparente rinominando il secondo argomento
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>N/A</ti>
  <ti>
    Esegue <c>prepallman</c>, <c>prepallinfo</c> e <c>prepallstrip</c>. Si
    accerta anche che tutte le librerie in <path>/opt/*/lib</path>,
    <path>/lib</path>, <path>/usr/lib</path> e <path>/usr/X11R6/lib</path> siano
    eseguibili. Sposta anche le macro aclocal in <path>/usr/share/aclocal</path>
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>N/A</ti>
  <ti>
    Comprime tramite GZip ricorsivamente tutti i file doc in
    <path>/usr/share/doc</path>, aggiustando trasparentemente ogni percorso
    symlink
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Comprime tramite GZip ricorsivamente tutti i file info in
    <path>/usr/share/info</path>
  </ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>N/A</ti>
  <ti>
    Comprime tramite GZip ricorsivamente tutte le pagine man in
    <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>,
    <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path> e
    aggiusta trasparentemente ogni percorso symlink
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</subsection>
</section>

<section>
<title>Dipendenze dei pacchetti</title>
<subsection>
<title>Perché le dipendenze sono importanti</title>
<body>

<p>
Portage non è solamente un comodo script che offre un modo unificato per
compilare qualsiasi progetto (programma, libreria) dai sorgenti. In aggiunta
permette di scaricare ed installare automaticamente tutte le dipendenze
necessaria, ovviamente specificandole nell'ebuild.
</p>

<p>
Negli ebuild ufficiali, tutte le dipendenze sono già specificate, quindi quando
si esegue <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage si assicurerà che
tutte le librerie necessarie per compilare ed eseguire Mozilla siano
correttamente installate prima che Mozilla stesso venga compilato.
</p>

<p>
Portage distingue le dipendenze build-time (in fase di compilazione) e run-time
(in fase di esecuzione). (Avvertenza: Attualmente Portage installa tutte le
dipendenze di compilazione e di esecuzione, lasciando poi tutto così com'è. In
futuro sarà possibile ripulire la propria installazione in modo che rimangano
installate solamente le dipendenze di esecuzione.).
</p>

</body>
</subsection>
<subsection>
<title>Come specificare le dipendenze nei vostri files ebuild (a.k.a. DEPEND
Atoms)</title>
<body>

<p>
La variabile <c>DEPEND</c> all'interno dell'ebuild <path>foo-x.y.z.ebuild</path>
dice a Portage quali sono i pacchetti necessari per compilare <path>foo</path>.
La variabile <c>RDEPEND</c> specifica quali pacchetti sono necessari per
eseguire <path>foo</path>. <c>RDEPEND</c> deve essere impostata esplicitamente
anche se corrisponde esattamente a DEPEND poiché in futuro è pianificata la
rimozione da Portage della sua valorizzazione predefinita a DEPEND.
</p>

<pre caption="Esempio di dipendenza">
DEPEND="virtual/opengl
    dev-libs/libxml2"
RDEPEND="${DEPEND}"
</pre>

<p>
Ciò dice a Portage che per compilare <path>foo-x.y.z</path> sono necessari i
pacchetti <path>virtual/opengl</path> (maggiori informazioni sui virtual a
breve) e <path>dev-libs/libxml2</path>. Non dice niente su quale sia la versione
richiesta di opengl o libxml2, ciò significa che "va bene qualsiasi cosa".
</p>

<p>
Il "va bene qualsiasi cosa" ovviamente è un pò inquietante, e generalmente non
funzionerà. Però per le librerie che devono sempre essere al compatibili al 100%
con i binari, attualmente funziona. Per le altre librerie, è possibile
ovviamente specificare le dipendenze con la versione.
</p>

<pre caption="Esempio di versione">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= e = fanno quello che ci si aspetta; va bene la versione 1.2 o
superiore di sys-apps/bar (ciò significa che sys-apps/bar-2.0 può andare bene),
mentre solamente la versione 1.0 di sys-apps/baz è accettata. Per
maggiori informazioni sullo schema delle versioni dei pacchetti, vedere la
precedente sezione <uri link="#doc_chap2_sect2">Dare il nome ai file
ebuild</uri>.
</p>

<p>
Questi sono altri modi di specificare le dipendenze delle versioni:
</p>

<pre caption="Specificare le dipendenze con la versione">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 selezionerà la revisione più nuova di qux-1.0
</p>

<p>
=sys-apps/foo-1.2* selezionerà il membro più nuovo della serie 1.2 e ignorerà le
serie 1.3 e quelle precedenti/successive. Ciò significa che foo-1.2.3 e
foo-1.2.0 sono valide, mentre foo-1.3.3, foo-1.3.0, e foo-1.1.0 non lo sono.
</p>

<p>
!sys-libs/gdbm impedirà l'installazione di questo pacchetto finché gdbm è già
installato.
</p>

</body>
</subsection>
<subsection>
<title>Note importanti</title>
<body>

<p>
Ci sono molte cose difficili da capire con le variabili DEPEND e RDEPEND. Ecco
alcuni punti importanti da seguire quando si scrivono le dipendenze.
</p>

<ul>
  <li>
    <e>Includere sempre la CATEGORIA.</e><br /> Per esempio, usare
    <c>&gt;=x11-libs/gtk+-2</c> e non <c>&gt;=gtk+-2</c>.
  </li>
  <li>
    <e>Non mettere un asterisco (*) per le dipendenze di tipo &gt;= .</e><br />
    Per esempio, dovrebbe essere <c>&gt;=x11-libs/gtk+-2</c> invece di
    <c>&gt;=x11-libs/gtk+-2*</c>.
  </li>
  <li>
    <e>Mai mettere come dipendenza un meta-pacchetto.</e><br /> Non mettere
    gnome-base/gnome tra le dipendenze, ma inserire sempre le librerie
    specifiche come libgnome.
  </li>
  <li>
    <e>Una dipendenza per riga.</e><br /> Non mettere dipendenze multiple su
    una stessa riga. Risultano difficili da leggere e da seguire.
  </li>
  <li><e>GTK: Usare sempre =x11-libs/gtk+-1.2* per applicazioni GTK+1.</e></li>
</ul>

<p>
Inoltre è importante assicurarsi di includere tutte le dipendenze necessarie
per il proprio pacchetto:
</p>

<ul>
  <li>
    <e>Guardare in configure.in o configure.ac</e><br /> Controllare qui le
    eventuali verifiche dei pacchetti. Le cose da guardare sono i controlli
    di pkg-config o le funzioni AM_* che controllano una specifica versione.
  </li>
  <li>
    <e>Guardare i file .spec</e><br /> Una buona indicazione è guardare nei file
    .spec inclusi per le relative dipendenze. Tuttavia non farvi completamente
    affidamento, in quanto non è detto contengano l'elenco completo e definitivo
    delle dipendenze.
  </li>
  <li>
    <e>Guardare il sito web dell'applicazione/libreria</e><br />Controllare il
    sito web dell'applicazione per possibili dipendenze elencate come
    necessarie.
  </li>
  <li>
    <e>Leggere gli eventuali file README e INSTALL del pacchetto</e><br /> Di
    solito contengono utili informazioni sulla compilazione e installazione dei
    pacchetti.
  </li>
  <li>
    <e>Ricordarsi le dipendenze non binarie come pkg-config, programmi per la
    generazione dei documenti, ecc.</e><br /> Solitamente il processo di
    compilazione richiede dipendenze come intltool, libtool, pkg-config,
    doxygen, scrollkeeper, gtk-doc, etc. Assicurarsi vengano chiaramente
    specificate.
  </li>
</ul>

<p>
Per tutti i dettagli più recenti sui DEPEND Atoms, vedere la sezione 5 della
pagina man sugli ebuild: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Testare e distribuire</title>
<subsection>
<title>ChangeLog</title>
<body>

<p>
Ogni volta che si aggiorna (o si scrive un nuovo) ebuild bisogna sempre
aggiornare il suo ChangeLog.  Il file <path>skel.ChangeLog</path> contiene un
semplice ChangeLog da usare come base.
</p>

<p>
Lo scopo del ChangeLog è documentare <e>cosa</e> è stato fatto, <e>perché</e> è
stato fatto e da <e>chi</e>. Questo permette a sviluppatori e utenti di
tracciare i cambiamenti in maniera semplice.
</p>

<p>
Il Changelog è fondamentalmente destinato agli utenti, per cui assicurarsi di
mantenerne i contenuti concisi e puntuali, evitando di essere troppo prolissi
nei dettagli tecnici.
</p>

</body>
</subsection>
<subsection>
<title>Memorizzare localmente i propri ebuild</title>
<body>

<p>
Per poter testare i propri ebuild e far sì che siano visibili da Portage,
bisogna posizionarli in una directory conosciuta. Portage userà la variabile
<c>PORTDIR_OVERLAY</c>, definibile in <path>/etc/make.conf</path>. Impostare
questa variabile alla propria directory (per esempio
<path>/usr/local/portage</path>).
</p>

<p>
In questa directory, si deve usare la stessa struttura (e le stesse categorie)
di <path>/usr/portage</path>.
</p>

<p>
Usando <c>PORTDIR_OVERLAY</c>, i propri ebuild rimangono nel sistema, anche dopo
un <c>emerge --sync</c>, e rimangono visibili da Portage.
</p>

</body>
</subsection>
<subsection>
<title>Testare i pacchetti</title>
<body>

<p>
Considerare le modalità di verifica con le quali accertarsi che il pacchetto
funzioni. A volte gli sviluppatori includono una routine <c>make test</c> o
<c>make check</c> che verificherà le funzionalità di base del pacchetto. Se ciò
è vero, eseguire <c>env FEATURES=test ebuild <path>foo-x.y.z.ebuild</path>
test</c>. Se il pacchetto risulta malfunzionante cercare di correggerlo in modo
da farlo funzionare (e proporre la patch ai sviluppatori principali).
</p>

<p>
Se questo non è il caso considerare l'aggiunta di una routine <c>src_test</c> al
proprio ebuild. Essa viene eseguita prima della routine <c>src_install</c> e può
essere molto utile per testare il funzionamento del programma nelle varie
architetture. Gli sviluppatori delle architetture apprezzeranno  l'aggiunta
di una routine di questo tipo, in quanto non sarà necessaria da parte loro la
conoscenza della funzionalità del pacchetto.
</p>

<p>
Tenere a mente i requisiti generali di un ebuild in questo caso. La routine
<c>src_test</c> non deve essere interattiva. Se il test routine dipende da altri
pacchetti usare la flag USE <c>test</c> per specificare le dipendenze
<c>DEPEND</c> per la compilazione. Inoltre le routine <c>src_test</c> non sono
raccomandate per applicazioni grafiche X poiché l'utente che esegue portage
spesso non può eseguirle con successo.
</p>

</body>
</subsection>
<subsection>
<title>Strumenti utili per i test</title>
<body>

<p>
Sono disponibili degli utili strumenti per aiutare nella scrittura e
manutenzione degli ebuild.
</p>

<table>
<tr>
  <th>Strumento</th>
  <th>Pacchetto</th>
  <th>Descrizione</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Strumento riservato agli sviluppatori che aiuta nella procedura di checkin
    al CVS. Esegue molti degli usuali controlli di qualità (QA)  e cerca di
    assicurare che i file aggiunti al cvs non pregiudichino il funzionamento del
    portage tree.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Strumento che mantiene i file pre-processati in modo che la ricompilazione
    venga eseguita <e>molto</e> più velocemente. Assicurarsi di aggiungere
    <c>ccache</c> alla variabile <c>FEATURES</c> in <path>/etc/make.conf</path>
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Lancia una shell che crea un ambiente sandbox. Utile per entrare all'interno
    dello stesso ambiente in cui portage compila i pacchetti ed effettuare il
    debug manualmente.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>
    Può creare un nuovo Changelog o aggiungere una voce in uno già esistente.
  </ti>
</tr>
</table>

</body>
</subsection>
</section>
</sections>
