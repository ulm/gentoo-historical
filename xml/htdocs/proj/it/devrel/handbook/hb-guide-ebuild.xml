<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header $ -->
<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- This document was last synched to:
cvs://gentoo/gentoo/xml/htdocs/doc/en/gentoo-howto.xml :: R1.50.  -->

<sections>

<date>2006-02-02</date>

<section>
<title>Il Portage tree</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Il portage tree si trova tipicamente in <path>/usr/portage</path> ed è
organizzato in una struttura gerarchica consistente in directory categoria,
seguite da directory specifiche per ogni pacchetto. Ecco un esempio; potete
trovare il file <path>util-linux-2.11y.ebuild</path> nella directory
<path>/usr/portage/sys-apps/util-linux</path>.  Possono esserci anche altre
versioni di <c>util-linux</c> oltre che <path>util-linux-2.11y.ebuild</path>.
Ciò è dovuto al fatto che <e>tutti gli ebuilds per un particolare pacchetto
(indipendentemente dalla versione)</e>, condividono la stessa directory
<path>miacategoria/miopacchetto</path> in <path>/usr/portage</path>.
</p>

</body>
</subsection>

<subsection>
<title>Controllare il Portage Tree dal CVS</title>
<body>

<p>
Se il sistema CVS non vi è familiare, per favore controllate il <uri
link="http://www.gentoo.org/doc/it/cvs-tutorial.xml" >CVS Tutorial</uri> per
maggiori informazioni.
</p>

<p>
Il Portage tree può essere trovato nel pacchetto <c>gentoo-x86</c> del Gentoo
Linux tree.  Per controllare il pacchetto (circa 350 megabytes) dovete prima
settare CVS tramite la guida precedente, poi controllare il tree
<c>gentoo-x86</c>.
</p>

</body>
</subsection>

<subsection>
<title>Cosa (non) mettere nel Portage tree</title>
<body>

<p>
Prima di scrivere gli ebuild, controllate <uri
link="http://bugs.gentoo.org">bugs.gentoo.org</uri> per vedere che non ci sia
già un ebuild corrispondente ma non ancora messo nel portage tree.  Andate su
<uri link="http://bugs.gentoo.org">bugs.gentoo.org</uri>, scegliete query,
scegliete <e>Gentoo Linux</e> come prodotto e come componente <e>ebuilds</e>,
nel campo ricerca mettete il nome dell'ebuild e come status scegliete NEW,
ASSIGNED REOPENED and RESOLVED (RESOLVED è importante), dopo mandate la
query.  Quelli che sono pigri, clicchino <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">qui</uri>.
</p>

<p>
Generalmente, il Portage tree deve essere usato solo per contenere i files
<path>.ebuild</path> insieme ad altri file piccoli, come patch o esempi di
configurazione. Questi tipi di files devono andare nella directory
<path>/usr/portage/categoria/pacchetto/files</path> per tenere pulita la
directory <path>categoria/pacchetto</path>. Le eccezioni a questa regola sono
per grandi patch (patch più grandi di 20KB) che dovrebbero essere messe nei
Gentoo mirrors in modo che la gente non sprechi eccessivamente la larghezza
di banda e lo spazio dell'hard drive. Non è una buona idea da parte degli
sviluppatori aggiungere file binari (non-ASCII) al CVS. Comunque, se è
necessario (ad esempio, se dovete aggiungere una piccola PNG per qualsiasi
ragione), accertatevi di aggiungerla a CVS usando l'opzione <c>-kb</c> nel
modo seguente:
</p>

<pre caption="Aggiungere file binari al CVS">
# <i>cvs add -kb miafoto.png</i>
</pre>

<p>
L'opzione <c>-kb</c> dice a CVS che <path>miafoto.png</path> è un file
binario e deve essere trattato in maniera speciale. Per esempio, fondere le
differenze di due versioni diverse di questo file, non è possibile, per ovvie
ragioni. Così parlando di fusioni, tutte le patch che aggiungete al Portage
devono necessariamente <e>non</e> essere compresse.  Questo permette a CVS di
fondere i cambiamenti e informare correttamente gli sviluppatori se
dovessero verificarsi conflitti.
</p>

<p>
Ricordate, i pacchetti che create devono essere <e>pronti</e> e <e>fuori dal
box</e> per gli utenti quando vengono marcati stabili. Assicuratevi di avere
un buon insieme di settaggi di default che soddisfino la maggior parte dei
sistemi e degli utenti che utilizzeranno il vostro pacchetto. Se il vostro
pacchetto non va, e siete poco sicuri su come farlo funzionare, controllate
altre distribuzioni che hanno già  forgiato le loro versioni del pacchetto.
Potete controllare <uri
link="http://cvs.mandriva.com/cgi-bin/cvsweb.cgi/SPECS/">Mandriva</uri> o
<uri link="http://www.debian.org/distrib/packages">Debian</uri> o <uri
link="http://cvs.fedora.redhat.com/">Fedora</uri> per qualche esempio.
</p>

<p>
Quando eseguono il commit a CVS, tutti gli sviluppatori devono usare
<c>repoman commit</c> invece di <c>cvs commit</c> per mandare i loro ebuilds.
Prima di inviare, per favore fate girare <c>repoman full</c> per essere
sicuri di non aver dimenticato qualcosa.
</p>

</body>
</subsection>

<subsection>
<title>Politica CVS Commit</title>
<body>

<ul>
  <li>Dovete sempre eseguire <c>repoman scan</c> prima del commit.</li>
  <li>Per favore eseguite <c>repoman full</c> prima del commit.</li>
	<li>
		Prima di eseguire il commit eseguite sempre il test su
		<path>package.mask</path>, deve andar bene facendo <c>emerge --pretend
		miopacchetto</c> per assicurarvi che non ci siano conflitti.
  </li>
	<li>Aggiornate il <path>ChangeLog</path> prima del commit.</li>
	<li>
		Prima del pacchetto, fate il commit del file <path>package.mask</path>,
		in caso ci siano conflitti sul file.
  </li>
	<li>
		Fate sempre atomic commit; se si esegue il commit di un pacchetto con una
		nuova licenza, o che è "masked", prima eseguite il commit del
		<path>package.mask</path> revisionato e/o la licenza, poi l'ebuild, il
		<path>ChangeLog</path>, patch e <uri
		link="?part=2&amp;chap=4">metadata.xml</uri> tutto in <b>una</b> volta,
		sempre che non vogliate rovinare l'installazione degli utenti.
	</li>
</ul>

</body>
</subsection>

<subsection>
<title>La directory Files</title>
<body>

<p>
Come indicato prima, sotto ogni subdirectory di ogni pacchetto c'è una
directory <path>files/</path>.  Ogni patch, file di configurazione o altri
files che il vostro pacchetto richiede vanno messi in questa directory; ogni
file più grande di 20KB dovrebbe andare nei mirror per abbassare la quantità
di (non necessari) file che i nostri utenti devono scaricare. Potete
considerare di nominare le patch che create solo per indurre il pacchetto a
costruirsi con un nome specifico per la versione, come
<path>miopacchetto-1.0-gentoo.diff</path> o più semplicemente
<path>1.0-gentoo.diff</path>.  Si noti che l'estensione <path>gentoo</path>
informa gli utenti che la patch è stata creata da noi, gli sviluppatori
Gentoo, non è stata assolutamente presa da mailing lists o cose simili.
Ancora, non dovete comprimere i files diff perchè CVS non supporta i file
binari.
</p>

<p>
Considerate l'aggiunta di un prefisso o suffiso come
<path>miopacchetto-1.0</path> in coda a ogni file che mettete nella directory
<path>files/</path>, così che i files usati per ogni versione individuale
degli ebuild del pacchetto siano distinguibili dagli altri, così che i
cambiamenti fra le varie revisioni siano visibili. Questa è generalmente una
buona idea :).  Potete anche usare suffissi differenti se volete maggior
precisione.
</p>

<p>
Se avete vari files che devono andare nella directory <path>files/</path>,
considerate la creazione di subdirectory come ad esempio
<path>files/1.0/</path> e mettete i file nella sua appropriata subdir.  Se
usate questo metodo, non avrete bisogno di aggiungere suffissi ai nomi dei
files nella directory files.  Questo metodo è spesso più conveniente.
</p>

</body>
</subsection>
</section>

<section>
<title>Scripts ebuild</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Gli script ebuild sono la base dell'intero sistema di portage. Essi
contengono tutte le informazioni necessarie allo scaricamento,
scompattamento, alla compilazione e all'installazione dei sorgenti, così come
servono ad eseguire funzioni di configurazione pre o post installazione o
rimozione. Mentre molto del Portage è scritto in Python, gli ebuilds sono
scritti in bash, visto che bash permette di chiamare comandi come si fa da
linea di comando.  Una delle caratteristiche più importanti degli scripts
ebuild è l'avere i comandi analoghi a quelli che si scriverebbero da riga di
comando se si installasse il pacchetto manualmente. A questo scopo, usare la
sintassi bash è un'ottima cosa.
</p>

<p>
Gli scripts ebuild vengono interpretati dai comandi <c>ebuild</c> ed
<c>emerge</c>.  Il comando <c>ebuild</c> è un tool di costruzione a basso
livello. Può costruire e installare un singolo ebuild. Controlla se le
dipendenze sono soddisfatte, non tenta però di risolverle automaticamente.
Dall'altra parte, <c>emerge</c> è un motore ad alto livello per <c>ebuild</c>
e ha l'abilità di auto-installare le dipendenze se necessarie, eseguire
<e>pretend</e> così che l'utente possa vedere quali ebuild saranno
installati, e molto di più. In generale, <c>emerge</c> salta <c>ebuild</c>
tranne che in una area. Con <c>ebuild</c>, potete eseguire le tappe di varie
parti dell'installazione di un pacchetto (scaricamento, scompattamento,
compilazione, installazione e merging) una per volta. Per gli sviluppatori
questo tool è di valore inestimabile, perchè permette di isolare i problemi
degli ebuilds a una specifica porzione di un processo ebuild.
</p>

</body>
</subsection>

<subsection>
<title>Dare il nome ai file ebuild</title>
<body>

<p>
Il nome dei file ebuild, consiste in quattro sezioni logiche:
</p>

<p>
<c>pkg-ver{_suf{#}}{-r#}.ebuild</c>
</p>

<note>
Le parentesi (<c>{}</c>) delineano campi opzionali e non compaiono nel nome
del pacchetto. <c>#</c> rappresenta un numero intero diverso da zero non
positivo.
</note>

<p>
La prima sottosezione, <c>pkg</c>, è il nome del pacchetto, che dovrebbe
contenere solo lettere minuscole, cifre 0-9 e un certo numero di caratteri
(<c>-</c>), (<c>_</c>) o (<c>+</c>).  Ad esempio: <c>util-linux</c>,
<c>sysklogd</c> e <c>gtk+</c>. Abbiamo alcuni pacchetti in portage che non
seguono queste regole, ma i <e>vostri</e> pacchetti dovrebbero seguirle.
</p>

<p>
La seconda sottosezione, <c>ver</c>, è la versione del pacchetto, che
dovrebbe essere normalmente la stessa dei sorgenti del tarball principale. La
versione viene normalmente formata da 2 o 3 (o più) numeri separati da punti,
come <c>1.2</c> o <c>4.5.2</c>, e può  avere una lettera singola che segue
l'ultima cifra, esempi: <c>1.4b</c> o <c>2.6h</c>. La versione del pacchetto
viene attaccata al suo nome con un trattino, ad esempio: <c>foo-1.0</c>,
<c>bar-2.4.6</c>.
</p>

<impo>
Se state pensando di usare una lettera nella versione del vostro pacchetto,
ricordatevi che le trailing letter <e>non</e> si possono usare per indicare
lo status alpha o beta per un pacchetto, da quando alpha e beta sono
<e>prereleases</e> e le revisioni sono <e>newer versions</e>. Questa è
un'importante distinzione perchè portage usa il numero di versione
dell'ebuild per determinare se è più nuova o più vecchia degli altri
pacchetti con la stessa categoria e lo stesso nome.  Questo numero di
versione è molto importante e rappresenta la versione del pacchetto, così
Portage può eseguire appropriatamente il controllo delle dipendenze.
</impo>

<p>
La terza (opzionale) sottosezione, <c>{_suf{#}}</c>, contiene uno speciale
suffisso, che può essere tra questi, dal meno recente al più recente:
</p>

<table> <tr><th>Suffisso</th><th>Significato</th></tr>
<tr><ti><c>_alpha</c></ti><ti>Alpha release</ti></tr>
<tr><ti><c>_beta</c></ti><ti>Beta release</ti></tr>
<tr><ti><c>_pre</c></ti><ti>Prerelease</ti></tr>
<tr><ti><c>_rc</c></ti><ti>Release candidate</ti></tr>
<tr><ti>(nessuno)</ti><ti>Normale release</ti></tr>
<tr><ti><c>_p</c></ti><ti>Livello di patch (accompagnato da un numero
intero)</ti></tr> </table>

<p>
Ognuno di questi suffissi può essere seguito da un numero intero positivo
diverso da zero, per esempio <c>linux-2.4.0_pre10</c>. Assumendo una parte della
versione identica, i suffissi sono ordinati come segue (il più basso significa
il più vecchio): <c>_alpha</c> &lt; <c>_beta</c> &lt; <c>_pre</c> &lt;
<c>_rc</c> &lt; (nessun suffisso) &lt; <c>_p</c>.
</p>

<p>
Quando si comparano identici suffissi con numeri interi, quello con il
numero interi più grande sarà considerato più recente. Esempio:
<c>foo-1.0_alpha4</c> è più recente di <c>foo-1.0_alpha3</c>.
</p>

<p>
La quarta (opzionale) sottosezione del nome di un pacchetto è lo specifico
numero di revisione Gentoo Linux, (<c>{-r#}</c>). <c>#</c> è un numero intero
positivo diverso da zero; esempio, <c>package-4.5.3-r3</c>.
</p>

<p>
Questo numero di revisione è indipendente dalla versione del sorgente tarball
e è usato per informare le persone che è disponibile una nuova e migliorata
revisione Gentoo Linux di un pacchetto. Le versioni iniziali degli ebuild non
devono avere nessun numero di revisione; esempio, <c>package-4.5.3</c> e
portage che hanno un numero di revisione pari a zero.  Questo significa che
l'ordine è come segue: <c>1.0</c> (versione iniziale), <c>1.0-r1</c>,
<c>1.0-r2</c>, etc.
</p>

<p>
Se fate miglioramenti a un ebuild esistente, potete copiarlo in un nuovo file
con il numero di revisione incrementato di 1. Le release iniziali normalmente
non hanno numero di versione, es. <path>pacchetto-4.5.3</path>, il loro
numero di revisione viene considerato da Portage come zero. Ciò significa che
il conteggio va nel modo seguente: <c>1.0</c> (versione iniziale),
<c>1.0-r1</c>, <c>1.0-r2</c> ecc. Ricordate <e>sempre</e> di menzionare i
cambiamenti nel <path>ChangeLog</path> quando c'è una revisione <b>e</b>
metti un messaggio sul CVS riguardante il tuo commit, non farlo è contro la
politia del CVS.
</p>

<p>
Ovviamente si ha la <e>quinta</e> sezione del nome di un ebuild --
l'estensione <c>.ebuild</c>.
</p>

</body>
</subsection>

<subsection>
<title>Contenuti di un file ebuild</title>
<body>

<p>
Questa sezione è una introduzione agli ebuilds. Per la lista completa di
ogni cosa possibile in un ebuild, c'è una manpage che riferisce sulla
disposizione interna, variabili, e funzioni in uno script ebuild: <c>man 5
ebuild</c>.
</p>

<p>
<b>Header</b>
</p>

<p>
Quando si sottopone un ebuild, header dovrebbe essere <e>esattamente</e> lo
stesso come quello in <path>/usr/portage/header.txt</path>. Molto importante,
non modificatelo e accertatevi che la riga <c>&#36;Header: &#36;</c> è
intatta.
</p>

<p>
Le prime tre righe dovrebbe essere qualcosa di simile a queste:
</p>

<pre caption="Header valido">
# Copyright 1999-2005 Gentoo Foundation Distributed under the terms of the GNU
# General Public License v2 &#36;Header: &#36;
</pre>

<p>
<b>Settaggi di variabili:</b>
</p>

<p>
La prima parte di ogni ebuild è formata da un certo numero di dichiarazione
di variabili. Le variabili risiedono sotto 3 categorie (riportate qui sotto):
</p>

<ul>
  <li>READ: variabili che potete utilizzare ma <e>mai settare</e></li>
  <li>MUST: variabili che <e>dovete sempre settare</e></li>
	<li>OPT: variabili che dovreste settare</li>
</ul>

<table> <tr> <th>Variabile</th> <th>Uso</th> <th>Descrizione</th> </tr> <tr>
<ti><c>P</c></ti> <ti>READ</ti> <ti>Il nome e la versione del pacchetto.</ti>
</tr>  <tr> <ti><c>PN</c></ti> <ti>READ</ti> <ti>Il nome del pacchetto.</ti>
</tr> <tr> <ti><c>PV</c></ti> <ti>READ</ti> <ti>La versione del pacchetto.</ti>
</tr> <tr> <ti><c>PR</c></ti> <ti>READ</ti> <ti> contiene il numero di revisione
o <c>r0</c> se non esiste in numero di revisione.</ti> </tr> <tr>
<ti><c>PVR</c></ti> <ti>READ</ti> <ti>Contiene il numero della versione con la
revisione.</ti> </tr> <tr> <ti><c>PF</c></ti> <ti>READ</ti> <ti>Contiene il nome
completo del pacchetto <c>${PN}-${PV}-${PR}</c>.</ti> </tr> <tr>
<ti><c>A</c></ti> <ti>READ</ti> <ti> Spazio nella lista delimitata di filenames
in <c>SRC_URI</c>. Non contiene il percorso dell'URL, solo il filename.  </ti>
</tr> <tr> <ti><c>DISTDIR</c></ti> <ti>READ</ti> <ti> Contiene il percorso alla
directory <path>distfiles</path>, dove sono messi tutti i file scaricati. Di
solito è <path>/usr/portage/distfiles</path>.  </ti> </tr> <tr>
<ti><c>FILESDIR</c></ti> <ti>READ</ti> <ti> Contiene il percorso al
<path>files</path> sub folder nella posizione specifica del pacchetto nel
portage tree. Non modificare questa variabile.  </ti> </tr> <tr>
<ti><c>WORKDIR</c></ti> <ti>READ</ti> <ti> Base del build root per l'ebuild.
Niente dovrebbe essere sviluppato fuori da questa directory.  </ti> </tr> <tr>
<ti><c>S</c></ti> <ti>OPT</ti> <ti> La directory sorgente per il vostro
pacchetto; comunemente <c>${WORKDIR}/${P}</c>. Portage si stabilizzerà a questo
valore in modo che non dobbiate regolarlo!  </ti> </tr> <tr> <ti><c>T</c></ti>
<ti>READ</ti> <ti> La directory temporanea per il vostro pacchetto. E' usata
come una directory virtuale <path>/tmp</path> mentre elaborate l'ebuild.  </ti>
</tr> <tr> <ti><c>D</c></ti> <ti>READ</ti> <ti> La directory root in cui il
pacchetto è installato, trattata come virtuale <path>/</path>.  </ti> </tr> <tr>
<ti><c>SLOT</c></ti> <ti>MUST</ti> <ti> Portage supporta le varie versioni dello
stesso pacchetto installato. Se volete, avendo installati sia GCC 2.95 che GCC
3.2, potete specificare lo <c>SLOT</c> in ogni ebuild. Qui possiamo settare lo
<c>SLOT</c> di GCC 2.95 a <c>2</c> mentre possiamo settare lo <c>SLOT</c> di GCC
3.2 a <c>3</c>.  <br/> <b>Note</b>: Usando <c>0</c> come valore di <c>SLOT</c>
significa che quel pacchetto ha 1 solo <c>SLOT</c> da settare (in altre parole,
quel pacchetto non è SLOTable).  </ti> </tr> <tr> <ti><c>LICENSE</c></ti>
<ti>MUST</ti> <ti> Questa variabile indica sotto che licenza è il programma, es.
GPL-2, BSD, eccetera. Questo campo deve essere configurato con una licenza
valida (ogni licenza si trova in <path>/usr/portage/license/</path>). Se la
licenza non esiste qua, deve essere aggiunta prima che l'ebuild sia aggiunto al
portage tree. Se la licenza non permette la redistribuzione, mettete
<c>RESTRICT</c>="nomirror" nell ebuild.  </ti> </tr> <tr>
<ti><c>KEYWORDS</c></ti> <ti>MUST</ti> <ti> Questa variabile supporta una serie
di funzioni diverse. Prima di tutto specifica l'architettura alla quale si rifà
l'ebuild. Queste keywords includono: <e>x86, ppc, sparc, mips, alpha, arm, hppa,
amd64, ia64</e>. Vedere il file profiles/arch.list nel portage tree per
ulteriori dettagli. Ovviamente dovete settare questa variabile in modo che
indichi l'architettura per la macchina destinataria. Portage non permette a una
macchina x86 di costruire altro se non pacchetti x86, come specificato nella
variabile <c>KEYWORDS</c>. I pacchetti che non sono di una architettura nativa
sono mascherati automaticamente da Portage. Se la flag <c>KEYWORDS</c> è
preceduta da <e>~</e>, significa che l'ebuild funziona, ma necessita di essere
testato in molte parti prima di essere spostato a stabile con la data keyword.
Se la flag <c>KEYWORDS</c> è preceduta da <e>-</e>, allora il pacchetto non
funzionerà con la data keyword. Se non c'è niente nella flag <c>KEYWORDS</c>, il
pacchetto viene considerato stabile. Potete eseguire l'installazione di questi
tipi diversi di pacchetti attraverso la variabile <c>ACCEPT_KEYWORDS</c> in
<path>make.conf</path>.  </ti> </tr> <tr> <ti><c>DESCRIPTION</c></ti>
<ti>MUST</ti> <ti>Una <e>breve</e> descrizione di una riga del vostro
pacchetto.</ti> </tr> <tr> <ti><c>SRC_URI</c></ti> <ti>MUST</ti> <ti> Gli URL
per ogni sorgente del vostro pacchetto, separati da spazi bianchi. Dovreste non
includere numeri di versione in SRC_URI e S. Cercate sempre di usare ${PV} o
${P}, e se un numero di versione non è consistente con il nome del pacchetto
sorgente, fate una variabile ${MY_P} e usate questa invece.  </ti> </tr> <tr>
<ti><c>HOMEPAGE</c></ti> <ti>MUST</ti> <ti> La homepage del pacchetto. Se non
siete capaci di individuarne una ufficiale, cercate di fornire un link da <uri
link="http://freshmeat.net/">freshmeat.net</uri> o da un simile sito di ricerca
pacchetti. Non fate mai riferimento a un nome della variabile nella string;
includete solo il testo.  </ti> </tr> <tr> <ti><c>IUSE</c></ti> <ti>MUST</ti>
<ti> Indica quale variabile <c>USE</c> il vostro pacchetto utilizza. Ricordare
che le <c>KEYWORDS</c> non siano elencate qui!  </ti> </tr> <tr>
<ti><c>DEPEND</c></ti> <ti>OPT</ti> <ti> Le dipendenze di costruzione del
pacchetto sono elencate qui. Vedete la sezione <uri link="#doc_chap5">Dipendenze
di pacchetti</uri> per maggiori dettagli sull'appropriata sintassi.  </ti> </tr>
<tr> <ti><c>RDEPEND</c></ti> <ti>OPT</ti> <ti> Le dipendenze di runtime del
pacchetto sono elencate qui. Di nuovo, vedete <uri link="#doc_chap5">Dipendenze
di pacchetti</uri> per maggiori dettagli.  </ti> </tr> </table>
    
<p>
<b>Funzioni ebuild</b>
</p>

<p>
C'è un numero di funzioni diverse che potete definire in un file ebuild che
controllano il processo di costruzione e installazione del vostro pacchetto.
</p>

<table> <tr> <th>Funzione</th> <th>Scopo</th> </tr> <tr>
<ti><c>pkg_setup</c></ti> <ti> Usate questa funzione per eseguire vari tasks
prerequisiti dal pacchetto. Questo include il controllo di file di
configurazione esistenti. Se è necessario aggiunger utenti, si deve fare questo
controllo in <c>pkg_preinst()</c> prima che il pacchetto sia installato.  </ti>
</tr> <tr> <ti><c>pkg_nofetch</c></ti> <ti> Informate l'utente sulle azioni
richieste se per qulache ragione (così come le licenze) i sorgenti potrebbero
non essere scaricabili automaticamente. Usate questo insieme con
<c>RESTRICT=&quot;fetch&quot;</c>. Voi soltanto visualizzerete i messaggi in
questa funzione, mai chiamare <c>die</c>.  </ti> </tr>  <tr>
<ti><c>src_unpack</c></ti> <ti> Usate questa funzione per scompattare i
sorgenti, applicare patch, ed eseguire programmi di aiuto come gli autotools. Di
default, scompatta i pacchetti elencati in <c>A</c>. La directory di partenza è
definita da <c>WORKDIR</c>.  </ti> </tr> <tr> <ti><c>src_compile</c></ti> <ti>
Usate questa funzione per configurare e costruire il pacchetto. La directory di
partenza è <c>S</c>.  </ti> </tr> <tr> <ti><c>src_install</c></ti> <ti> Usate
questa funzione per installare il pacchetto in un'immagine in <c>D</c>. Se il
vostro pacchetto usa automake, potete fare questo semplicemente con <c>make
DESTDIR=${D} install</c>. <e>Assicuratevi che il vostro pacchetto installi i
suoi file utilizzando <c>D</c> come root!</e> La directory di partenza è
<c>S</c>.  </ti> </tr> <tr> <ti><c>src_test</c></ti> <ti> Eseguito solo quando
<c>FEATURES="maketest"</c> è impostato e <c>RESTRICT="maketest"</c> non è
impostato, di default questa funzione esegue una funzione di testing disponibile
da ogni Makefiles nella directory <c>${S}</c>, eseguendo "make test" o "make
check", dipende da cosa è fornito. Può essere sovrascritto per generare un
ordinato setup test.  </ti> </tr> <tr> <ti><c>pkg_preinst</c></ti> <ti> I
comandi vengono eseguiti <e>prima di eseguire il merging</e> dell'immagine del
pacchetto nel filesystem.  </ti> </tr> <tr> <ti><c>pkg_postinst</c></ti> <ti> I
comandi vengono eseguiti <e>dopo il merge</e> dell'immagine del pacchetto nel
filesystem.  </ti> </tr> <tr> <ti><c>pkg_prerm</c></ti> <ti> I comandi vengono
eseguiti <e>prima dell'unmerge</e> dell'immagine del pacchetto dal filesystem.
</ti> </tr> <tr> <ti><c>pkg_postrm</c></ti> <ti> I comandi vengono eseguiti
<e>dopo l'unmerge</e> dell'immagine del pacchetto dal filesystem.  </ti> </tr>
<tr> <ti><c>pkg_config</c></ti> <ti> Potete usare questa funzione per
configurare inizialmente il pacchetto dopo che è stato installato. Tutti i
percorsi in questa funzione devono avere il prefisso <c>ROOT</c> che punta ad
una directory radice specificata dall'utente che potrebbe non essere
<path>/</path>. Questa
funzione viene eseguita <e>solo</e> e quando l'utente esegue: <c>emerge --config
=${PF}</c>.  
</ti> </tr> </table>

<p>
<b>Funzioni di assistenza</b>
</p>

<p>
Potete inoltre usare le seguenti funzioni di assistenza nei vostri
ebuilds.
</p>

<table><tr> 
<th>Funzione</th> <th>Scopo</th> 
</tr> 
<tr> <ti><c>use</c></ti>
<ti> Controlla se una o più flag use date sono definite. Se così, la funzione
riprenderà le flag che esistono in <c>USE</c>. Questo cambierà presto, con
<c>use</c> che non crea output, ma <c>usev</c> creerebbe ancora output. Per
controllare l'esistenza di una flag use, potete usare <c>use foobar</c>.  </ti>
</tr> 
<tr> <ti><c>has_version</c></ti> <ti> Ritorna 1 se il sistema ha la
versione richiesta di un certo pacchetto. Per esempio <c>has_version
>=sys-libs/glibc-2.3.0</c>.  </ti> 
</tr> 
<tr> <ti><c>best_version</c></ti> <ti>
>Ritorna la <path>categoria/versione-pacchetto</path> del
><path>categoria/pacchetto</path> richiesto. Per esempio <c>best_version
>x11-libs/gtk+extra</c>.  </ti> 
</tr> 
<tr> <ti><c>use_with</c></ti> <ti> Questa
>funzione controlla se una flag use è stata definita e di conseguenza ritorna
>&quot;--with-foobar&quot; o &quot;--without-foobar&quot;. Se usate un solo
>argomento, quell'argomento è sia flag use sia con/senza stringa. Altrimenti il
>primo argomento è la flag use e il secondo argomento è con/senza stringa. Per
>esempio <c>use_with truetype freetype</c> riprenderà
>&quot;--with-freetype&quot; se truetype è in <c>USE</c>.</ti> 
</tr> 
<tr>
<ti><c>use_enable</c></ti> <ti> Uguale a <c>use_with</c>, ma di conseguenza
ritorna &quot;--enable-foobar&quot; o &quot;--disable-foobar&quot;.  </ti>
</tr>
<tr> <ti><c>check_KV</c></ti> <ti> Controlla se Portage conosce la
versione del kernel. Se non la conosce, visualizza un errore e si chiude. Se
avete bisogno della versione del kernel nel vostro script, usate la variabile
<c>KV</c> che è automaticamente definita da Portage. Su un sistema che ha
gentoo-sources-2.4.20-r6, <c>KV</c> avrebbe il valore &quot;2.4.20&quot;.
</ti> </tr> <tr> <ti><c>keepdir</c></ti> <ti> Crea (se necessario) un file
<path>.keep</path> nella directory data così che non si auto-pulisca. Non
create <e>mai</e> voi stessi un file <path>.keep</path>. Se portage cambia come
<c>keepdir</c> funziona, allora la vostra creazione del file romperà il
pacchetto.  </ti> </tr> <tr> <ti><c>econf</c></ti> <ti> Mette
<c>./configure</c> con il necessario cambio di percorso (prefix, host, mandir,
infodir, datadir, sysconfdir, localstatedir). Facoltativamente potete passare
gli argomenti extra a <c>./configure</c> specificandoli quando chiamate
<c>econf</c>, e gli utenti possono regolare la variabile di ambiente
<c>EXTRA_ECONF</c>. Opzioni passate a configure hanno la precedenza in ordine
inverso rispetto a come sono state date. In altre parole, il primo argomento
sarà sempre sovrascritto dall'ultimo.  </ti> </tr> <tr>
<ti><c>einstall</c></ti> <ti> Mette <c>make install</c> con il necessario
cambio di percorso (prefix, datadir, mandir, infodir, datadir, sysconfdir,
localstatedir). Di nuovo, potete passare argomenti extra al comando make
specificandoli quando chiamate <c>einstall</c>. Per favore notate che il modo
preferito di installare un pacchetto è con il comando <c>make install
DESTDIR=${D}</c> e non con <c>einstall</c>. Questo comando è soltanto una
maniera per sovrascrivere i make file rotti.  </ti> </tr> <tr>
<ti><c>die</c></ti> <ti> Causa la chiusura del processo corrente. Avviserà
l'utente usando il dato argomento come ragione. Non trascurate di passare un
messaggio a <c>die</c> se avete più di una chiamata ad esso in una singola
funzione. E' più duro rintracciare un guasto se non siete sicuri <c>dove</c> il
pacchetto è rotto.  </ti> </tr> <tr> <ti><c>einfo</c></ti> <ti> Informa
l'utente su qualcosa di importante. L'argomento dato a <c>einfo</c> è il
messaggio che l'utente vedrà. Non usate <c>einfo</c> per visualizzare banner
come &quot;*************************************&quot;. Il fatto che state
usando <c>einfo</c> è abbastanza per ottenere l'attenzione dell'utente.  </ti>
</tr> </table>

<p>
<b>Funzioni di assistenza fornite da eutils.eclass</b>
</p>

<p>
Si possono usare le seguenti funzioni di assistenza fornite da eclass
"eutils" nei vostri ebuild. Dovete assicurarvi che <c>inherit eutils</c> sia
presente per queste funzioni affinchè esse funzionino.
</p>

<table> <tr> <th>Funzione</th> <th>Scopo</th> </tr> <tr> <ti><c>epatch</c></ti>
<ti> Questa funzione è come un rifacimento più facile del comando <c>patch</c> e
funziona con .bz2, .gz, .zip e patch plain text. Non dovete specificare una
opzione "-p", ogni opzione che deve essere specificata dovrebbe essere impostata
in <c>EPATCH_OPTS</c>. La funzione si aspetta un file o una directory come
argomento - se specificate una directory, tutte le patch nella forma di
"??_${ARCH}_..." saranno applicate: affinchè una patch sia applicata, si deve
combinare l'architettura che si esegue, avere "_all_" nel nome, o
<c>EPATCH_FORCE</c> deve essere impostato a "yes".  </ti> </tr> <tr>
<ti><c>gen_usr_ldscript</c></ti> <ti> Questa funzione genera script linker in
/usr/lib per librerie dinamiche in /lib. Questo corregge problemi di link quando
un .so è in /lib mentre un .a è in /usr/lib.  </ti> </tr> <tr>
<ti><c>have_NPTL</c></ti> <ti> Ritorna 0 se il sistema sta usando la
implementazione NPTL PThreads.  </ti> </tr> <tr>
<ti><c>get_number_of_jobs</c></ti> <ti> Questa funzione controlla quante CPU
sono presenti e poi imposta la opzione corretta -jX in <c>MAKEOPTS</c>.  </ti>
</tr> <tr> <ti><c>mymktemp</c></ti> <ti> Questa funzione agisce come wrapper a
mktemp se questo è presente, altrimenti agisce come un rimontaggio.  </ti> </tr>
<tr> <ti><c>edos2unix</c></ti> <ti> Questa funzione effettua la stessa azione
del binario <c>dos2unix</c>.  </ti> </tr> <tr> <ti><c>egetent</c></ti> <ti>
egetent agisce come wrapper per <c>getent</c> per Linux o <c>nidump</c> per Mac
OS X (R).  </ti> </tr> <tr> <ti><c>enewuser</c></ti> <ti> Crea un nuovo utente.
Questa funzione si aspetta un argomento obbligatorio con il nome utente, e molti
argomenti opzionali possono essere specificati: <c>$2</c> contiene un UID, pass
-1 per il prossimo disponibile ID; <c>$3</c> contiene una shell con
<path>/bin/false</path> di default; <c>$4</c> contiene una directory home con
<path>/dev/null</path> di default, <c>$5</c> contiene tutti i gruppi ai quali
l'utente dovrebbe essere aggiunto, vuoto di default e <c>$6</c> contiene  ogni
qualsiasi altra opzione che potresti voler passare a useradd.  </ti> </tr> <tr>
<ti><c>enewgroup</c></ti> <ti> Aggiunge un nuovo gruppo. Questa funzione si
aspetta un argomento obbligatorio con il nome del gruppo - un secondo argomento
opzionale fa avere al gruppo uno specifico GID.  </ti> </tr> <tr>
<ti><c>make_desktop_entry</c></ti> <ti> Fa una voce per il desktop: il primo
argomento contiene il percorso al binario. Opzionalmente un secondo contiene un
nome per l'icona - di default è <c>${PN}</c>; il terzo può contenere un percorso
all'icona relativo su <path>/usr/share/pixmaps</path> o un percorso intero - di
default è <c>${PN}</c>.png; il quarto può contenere una <uri
link="http://standards.freedesktop.org/menu-spec/latest/apa.html">categoria di
applicazione</uri>, e il quinto argomento contiene un percorso opzionale di
startup di una applicazione.  </ti> </tr> <tr> <ti><c>check_license</c></ti>
<ti> Visualizza una licenza da accettare per l'utente, se l'argomento non è
specificato allora è usata la licensa specificata da <c>${LICENSE}</c>.  </ti>
</tr> <tr> <ti><c>unpack_pdv</c></ti> <ti> Unpack un archivio pdv generato, il
primo argomento deve contenere il file da scompattare e il secondo dovrebbe
contenere "off_t" con il quale deve essere generato manualmente: <c>strace
-elseek ${file}</c> e per qualcosa come "lseek(3, -4, SEEK_END)" si potrebbe
passare il valore "4".  </ti> </tr> <tr> <ti><c>unpack_makeself</c></ti> <ti>
Scompatta un archivio auto generato, richiede un file da scompattare come
argomento.  </ti> </tr> <tr> <ti><c>cdrom_get_cds</c></ti> <ti> Tenta di
ottenere un CD, con i file specificati dall'argomento presente sul sistema e
montato su <c>${CDROM_ROOT}</c>.  </ti> </tr> <tr>
<ti><c>cdrom_load_next_cd</c></ti> <ti> Carica il prossimo CD una volta finito
con il primo CD. Se la funzione ritorna, <c>${CDROM_ROOT}</c> punterebbe al
prossimo CD.  </ti> </tr> <tr> <ti><c>strip-linguas</c></ti> <ti> Questa
funzione assicura che LINGUAS contiene solo il linguaggio che un pacchetto può
supportare specificato dagli argomenti alla funzione. Se il primo argomento è
-i, una lista di file .po è compilata nelle directory specificate e è usata la
intersezione delle liste. Se il primo argomento è -u, una lista di file .po è
compilata nelle directory specificate e è usata la unione delle liste.  </ti>
</tr> </table>
  
<p>
<b>Funzioni di assistenza fornite da flag-o-matic.eclass</b>
</p>

<p>
Si possono usare le seguenti funzioni di assistenza che sono fornite da
"flag-o-matic" eclass sui vostri ebuild. Dovete assicurarvi che <c>inherit
flag-o-matic</c> è presente per queste funzioni affinchè esse funzionino. Non
si dovrebbe mai modificare le impostazioni del compilatore, invece usate
flag-o-matic per effettuare tutte le azioni come filtrare le flag che causano
problemi.
</p>

<table> <tr> <th>Funzione</th> <th>Scopo</th> </tr> <tr>
<ti><c>filter-flags</c></ti> <ti> Questa funzione rimuove particolari flag da
<c>C[XX]FLAGS</c> - sono abbinate solo le flag complete.  </ti> </tr> <tr>
<ti><c>append-flags</c></ti> <ti> Questa funzione aggiunge flag extra alle
variabili presenti <c>C[XX]FLAGS</c>.  </ti> </tr> <tr>
<ti><c>replace-flags</c></ti> <ti> Rimette la flag specificata dal primo
argomento con quella nel secondo argomento nel <c>C[XX]FLAGS</c> attuale.  </ti>
</tr> <tr> <ti><c>replace-cpu-flags</c></ti> <ti> Rimette ogni flag -march=... o
-mcpu=... che contengono il secondo argomento con il primo.  </ti> </tr> <tr>
<ti><c>replace-sparc64-flags</c></ti> <ti> Imposta -mcpu=... su una v8 SPARC e
usa il valore originale come -mtune se non è già specificato.  </ti> </tr> <tr>
<ti><c>strip-flags</c></ti> <ti> Fa uno strip di tutte le flag, tranne quelle
specificate in <c>ALLOWED_FLAGS</c>.  </ti> </tr> <tr>
<ti><c>strip-unsupported-flags</c></ti> <ti> Fa uno strip a <c>C[XX]FLAGS</c> di
ogni flag non supportata dalla versione che si esegue di GCC.  </ti> </tr> <tr>
<ti><c>get-flag</c></ti> <ti> Trova una flag e ne da l'output del suo valore.
</ti> </tr> <tr> <ti><c>is-flag</c></ti> <ti> Ritorna true se la flag è
impostata nel corrente <c>C[XX]FLAGS</c>; sono effettuati solo abbinamenti
completi.  </ti> </tr> <tr> <ti><c>append-ldflags</c></ti> <ti> Questa funzione
aggiunge flag extra alla variabile presente <c>LDFLAGS</c>.  </ti> </tr> <tr>
<ti><c>filter-ldflags</c></ti> <ti> Rimuove le flag specificate da
<c>LDFLAGS</c>, solo flag complete sono abbinate.  </ti> </tr> <tr>
<ti><c>fstack-flags</c></ti> <ti> Aggiunge -fno-stack-protector con le soppresse
-fstack-protector e -fstack-protector-all.  </ti> </tr> </table>

<p>
Si possono usare le seguenti funzioni di assistenza che sono fornite da
&quot;toolchain-funcs&quot; eclass sui vostri ebuild. Dovete assicurarvi che
<c>inherit toolchain-funcs</c> è presente affinchè esse funzionino. Non si
dovrebbe mai specificare un compilatore o le impostazioni di binutils,
invece usate toolchain-funcs per specificare compilatori e binutils.
</p>

<p>
Lo scopo di usare queste funzioni è quello di supportare cross-compiling e
compilatore icc. Questi dovrebbe essere usati quando un pacchetto usa
esplicitamente gcc, g++, ld, ranlib o qualsiasi di questi tool qui sotto. In
generale i pacchetti che usano tool di autoconfigurazione rilevano cross
compiling e non hanno bisogno di queste funzioni.
</p>

<table> <tr> <th>Funzione</th> <th>Scopo</th>
</tr> <tr> <ti> <c>tc-getAR</c> </ti> <ti>Ritorna il nome dell'archiver </ti>
</tr> <tr> <ti> <c>tc-getAS</c> </ti> <ti>Ritorna il nome dell'assemblatore</ti>
</tr> <tr> <ti> <c>tc-getCC</c> </ti> <ti>Ritorna il nome del compilatore C</ti>
</tr> <tr> <ti> <c>tc-getCXX</c> </ti> <ti>Ritorna il nome del compilatore
C++</ti> </tr> <tr> <ti> <c>tc-getLD</c> </ti> <ti>Ritorna il nome del
linker</ti> </tr> <tr> <ti> <c>tc-getNM</c> </ti> <ti>Ritorna il nome del tool
symbol/object inspection</ti> </tr> <tr> <ti> <c>tc-getRANLIB</c> </ti>
<ti>Ritorna il nome del archiver indexer</ti> </tr> <tr> <ti> <c>tc-getF77</c>
</ti> <ti>Ritorna il nome del compilatore fortran </ti> </tr> <tr> <ti>
<c>tc-getLD</c> </ti> <ti>Ritorna il nome del linker</ti> </tr> <tr> <ti>
<c>tc-getGCJ</c> </ti> <ti>Ritorna il nome del compilatore java</ti> </tr> <tr>
<ti> <c>tc-getBUILD_CC</c> </ti> <ti>Ritorna il nome del compilatore C per
costruire</ti> </tr> <tr> <ti> <c>tc-is-cross-compiler</c> </ti> <ti>Un modo
semplice per vedere se si state usando un cross-compiler</ti> </tr> <tr> <ti>
<c>gcc-fullversion</c> </ti> <ti> Ritorna la versione come da $($CC
-dumpversion)</ti> </tr> <tr> <ti> <c>gcc-version</c> </ti> <ti>Ritorna la
versione, ma solo &lt;major>.&lt;minor></ti> </tr> <tr> <ti>
<c>gcc-major-version</c> </ti> <ti>Ritorna la versione maggiore</ti> </tr> <tr>
<ti> <c>gcc-minor-version</c> </ti> <ti>Ritorna la versione minore</ti> </tr>
<tr> <ti> <c>gcc-micro-version</c> </ti> <ti>Ritorna la versione micro</ti>
</tr> </table>

</body>
</subsection>

<subsection>
<title>Regole di scrittura di un file ebuild</title>
<body>

<p>
Visto che i file ebuild sono semplicemente degli shell script, potete usare
il mode shell-script nel vostro editor. Dovete usare una certa indentazione,
usare solo caratteri di tabulazione -- <e>non spazi</e>. Assicuratevi di
configurare il vostro editor in modo che metta 4 spazi per ogni tab. Ancora
assicuratevi di usare le parentesi attorno alle variabili d'ambiente; es.
<c>${P}</c> invece di <c>$P</c>.
</p>      

<p>
Le linee lunghe vengono spezzate con ' \', così:
</p>

<pre caption="Fare il wrapping alle righe in ebuild"> ./configure \
--prefix=/usr || die "configure failed" </pre>

<p>
Per altri dettagli, controllate <path>skel.ebuild</path> (abitualmente sotto
<path>/usr/portage</path>).
</p>

<p>
Se state usando Vim per editare ebuild/eclass, il file di default di Gentoo
vimrc, <path>/etc/vim/vimrc</path>, già assicura che sono usate la corretta
indentazione e le impostazioni di filetype per ebuild e eclass. Per risultati
migliori, inclusa una speciale sintassi che evidenzia le ebuild keyword,
emergere app-vim/gentoo-syntax.
</p>

<p>
Su sistemi non Gentoo, si possono ottenere risultati simili con le seguenti
righe nel vostro vimrc, o meglio con la installazione degli script <uri
link="https://developer.berlios.de/projects/gentoo-syntax/">gentoo-syntax</uri>.
</p>

<pre caption="Configurare vimrc per editare ebuild"> au BufRead,BufNewFile
*.e{build,class} let is_bash=1|setfiletype sh au BufRead,BufNewFile
*.e{build,class} set ts=4 sw=4 noexpandtab </pre>

<p>
Se state usando Emacs, potete mettere il seguente codice alla fine del
vostro .emacsrc (per GNU Emacs) o init.el (per XEmacs) per essere sicuri di
avere i settaggi giusti quando editate qualcosa di relativo a Gentoo.
</p>

<pre caption="Configurare emacsrc per editare ebuild"> (defun ebuild-mode ()
(shell-script-mode) (sh-set-shell "bash") (make-local-variable 'tab-width) (setq
tab-width 4)) (setq auto-mode-alist (cons '("\\.ebuild$" . ebuild-mode)
auto-mode-alist)) (setq auto-mode-alist (cons '("\\.eclass$" . ebuild-mode)
auto-mode-alist)) </pre>

<p>
Se state usando nano, siete fortunati! Editate <path>/etc/nanorc</path> e
scommentate la sezione riferente all'ebuild.
</p>

</body>
</subsection>

<subsection>
<title>Variabili USE</title>
<body>

<p>
Lo scopo delle variabili USE è permettervi di configurare Portage per
abilitare o disabilitare globalmente e automaticamente certe <e>opzioni in
tempo di compilazione</e>.  Eccovi un esempio. Diciamo che siete fan di
GNOME, e vi piacerebbe avere ogni ebuild con il supporto per GNOME. In questo
caso dovete aggiungere <c>gnome</c> alla variabile <c>USE</c> in
<path>/etc/make.conf</path> e allora Portage automaticamente aggiungerà ogni
supporto opzionale GNOME ai pacchetti, se disponibile. Se invece non volete
il supporto per GNOME, semplicemente modificate <path>/etc/make.conf</path> e
assicuratevi che <c>gnome</c> <e>non</e> sia indicato nella variabile
<c>USE</c>.  Gentoo Linux ha un numero grandissimo di opzioni USE, per
permettervi di configurare il sistema come meglio credete.
</p>

<note>
Se disattivate una variabile USE (ad esempio togliendo <c>gnome</c> da
<c>USE</c>), ciò istruirà solo Portage a togliere il supporto
<e>opzionale</e> per GNOME. Comunque se eseguite <c>emerge</c> su un ebuild
che <e>richiede</e> GNOME, il pacchetto avrà ovviamente il supporto per GNOME
attivo, come vi potete aspettare. Ciò significa anche che GNOME verrà
installato automaticamente (come dipendenza) se non è stato già fatto prima.
E` sempre una buona idea eseguire un <c>emerge --pretend</c> prima di fare un
&quot;reale&quot; <c>emerge</c>; così sapete a cosa andate incontro!
</note>

<p>
Nei vostri ebuild, potete controllare se una variabile USE è settata usando
il comando <c>use &lt;variable&gt;</c>. Il comando <c>use</c> stampa il nome di
ogni <c>&lt;variabile&gt;</c> presente in <c>USE</c>. Potete usarla normalmente
come segue:
</p>

<pre caption="Trovare se una flag USE è impostata"> if use X ; then commands
specific to X fi </pre>

<p> 
Le variabili USE possono anche essere usate per settare dipendenze. Per
esempio, potete voler installare un pacchetto solo se quella determinata
variabile USE è dichiarata. Ciò si fa usando la sintassi <c>flag? (
categoria/pacchetto)</c> nella variabile <c>DEPEND</c> del vostro ebuild. In
questo esempio <c>categoria/pacchetto</c> verrà richiesto solo se la
<c>flag</c> è presente in <c>USE</c>. Potete specificare quale dipendenza
dovrebbe essere usata se una flag USE <e>è</e> dichiarata, e quale dipendenza
usare se <e>non</e> è dichiarata: <c>flag? (categoria/pacchetto)</c> e
<c>!flag?  (altracategoria/pacchetto)</c>. In questo caso, se <c>flag</c> non
è dichiarata <c>altracategoria/pacchetto</c> è usato invece di
<c>categoria/pacchetto</c>.  Controllate che i vostri ebuild usino questa
sintassi e non quella di Bash. Le espressioni condizionali di Bash possono
interferire con le funzioni di Portage, e l'uso dei comandi Bash può rovinare
il vostro ebuild.
</p>

<p>
C'è qui un suggerimento importante su come usare <c>USE</c>. Per la maggior
parte delle volte, un pacchetto avrà uno script <c>./configure</c> utilizzato
per eseguire i passi di configurazione.  Generalmente, se il vostro ebuild usa
<c>./configure</c>, ogni funzionalità opzionale a tempo di compilazione dovrà
essere attivata o disattivata passando gli argomenti appropriati al comando
<c>./configure</c>.  C'è qua il modo migliore per far questo:
</p>

<pre caption="Conditionals basati su impostazioni USE"> DEPEND="X? (
&gt;=x11-base/xfree-4.3 ) mysql? ( &gt;=dev-db/mysql-3.23.49 ) apache2? (
&gt;=net-www/apache-2 ) !apache2? ( =net-www/apache-1* )"

src_compile() { econf \ $(use_enable X x11) \ $(use_enable mysql) \ || die
"Error: econf failed!" emake || die "Error: emake failed!" } </pre>

<p>
Questo approccio ha un risultato molto piacevole. Non dobbiamo spaventarci su
cosa è il setting di default per mysql o per X (abilitato/disabilitato), noi
esplicitamente diciamo a <c>econf</c> cosa vogliamo fare basandoci sulla
variabile <c>USE</c>. Non accennarlo è abbastanza chiaro in termini di
leggibilità :).
</p>

<p>
A volte, gli ebuild hanno conflitti di funzionalità con le <c>USE</c> flags.
Controlla questo, ritornare un errore <e>non</e> è una possibile soluzione.
Piuttosto, devi scegliere una <c>USE</c> da favorire. Un esempio è l'ebuild di
msmtp. Il pacchetto può usare SSL con GnuTLS, SSL con OpenSSL, o nessun SSL.
Siccome GnuTLS ha più funzionalità di OpenSSL, allora sarà quello scelto:
</p>
  	 
<pre caption="Scegliere le USE flags che creano conflitti">
   src_compile() {
       local myconf
  	 
       if use ssl &quot;&quot; use gnutls ; then
           myconf="${myconf} --enable-ssl --with-ssl=gnutls"
       elif use ssl &quot;&quot; ! use gnutls ; then
           myconf="${myconf} --enable-ssl --with-ssl=openssl"
       else
           myconf="${myconf} --disable-ssl"
       fi
  	 
       econf \
           # Other stuff
           ${myconf} \
           || die "configure failed"
	
	emake || die "make failed"
}
</pre>
  	 
<p>Per vedere una tabella in continuo aggiornamento dei settaggi USE, andate
<uri link="http://www.gentoo.org/dyn/use-index.xml">qui</uri>.
</p>

</body>
</subsection>
</section>

<section>
<title>Locazione nel
filesystem</title>
<subsection>
<title>Introduzione a FHS</title>
<body>

<p>
Gli standard del layout del filesystem usati in Gentoo Linux, seguono FHS,
abbreviazione di <e>Filesystem Hierarchy Standard</e> (Gerarchia di filesystem
standard).  Una descrizione semplificata dello standard viene data qui, per una
descrizione specifica andate all'url: <uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
Il percorso <path>/opt</path> è indirizzato nella sezione 3.12 di FHS. La
sezione 4.4 tratta del percorso <path>/usr/X11R6</path>.  KDE e GNOME non sono
indirizzati specificatamente e non sono menzionati nella versione corrente di
FHS.
</note>

</body>
</subsection>

<subsection>
<title>Come mettere i pacchetti nel
filesystem</title>
<body>

<p>
Abitualmente, se il pacchetto usa autoconf e automake, l'installazione di
default darà una destinazione quasi sempre corretta, salvo eccezioni:
</p>

<ul>
  <li>
		Se state installando un programma in <path>/bin</path>,
		<path>/sbin</path>, <path>/usr/bin</path> o <path>/usr/sbin</path>, la
		sua manpage deve essere installata in <path>/usr/share/man</path>. Ciò
		può essere eseguito specificando <c>./configure
		--mandir=/usr/share/man</c> nell'ebuild.
  </li>
	<li>
		I file GNU info, devono essere sempre installati in
		<path>/usr/share/info</path>, <e>sempre che non siano su X11, o specifici
		su GNOME o KDE </e>. Prendete nota: <path>/usr/share/info</path> è la
		<e>sola</e> locazione ufficiale per i file GNU info. Da quando gli script
		<c>./configure</c> li installano in <c>/usr/info</c> è sempre necessario
		richiamare <c>./configure</c> con l'argomento
		<c>--infodir=/usr/share/info</c>.
	</li>
	<li>
		I file di documentazione sono installati in <path>/usr/share/doc</path>,
		in una subdirectory che riflette il nome la versione e la revisione del
		particolare programma. Questo va applicato a tutti i programmi: GNOME,
		KDE, X11 o programmi per console.  Comunque, alcuni programmi possono
		installare documentazione addizionale o files di supporto in una
		directory <path>/usr/share</path> per i loro scopi.
	</li>
	<li>
		I programmi specifici per X11 e le librerie devono essere installati
		dentro <path>/usr</path>, e non direttamente in <path>/usr/X11R6</path>.
		Riserviamo questo percorso all'X window system, versione 11 release 6.
		Questo è per interpretare più alla lettera le istruzioni di FHS.
	</li>
	<li>
		I programmi GNOME e KDE, devono essere sempre installati dentro
		<path>/usr</path>.
	</li>
</ul>

<impo>
Alcune distribuzioni scelgono di installare GNOME e KDE dentro
<path>/opt</path>.  Non esiste uno standard per questi ambienti desktop in
termini di dove debbano essere installati i loro files. Nell'interesse della
semplicità e consistenza, abbiamo scelto di installare tutti i pacchetti
GNOME e KDE nella directory <path>/usr</path>.
</impo>

<p>
In generale, dovete avere gli ebuild che installino i loro files sotto
<path>/usr</path>.  <e>Alcuni</e> programmi possono essere compilati e
linkati con o senza librerie GNOME, KDE e X11 e possono causare confusione.
La nostra soluzione è installare tutto in <path>/usr</path> per evitare
ambiguità e complessità inutili per gli autori degli ebuilds. La locazione
nel filesystem di un programma <e>non</e> deve dipendere dalla presenza o
dalla assenza di una variabile <c>USE</c>.  Comunque, tutti gli ebuilds nel
portage tree <e>quasi sempre</e> vanno installati in <path>/usr</path>.
</p>

<note>
Il path <path>/opt</path> è riservato in Gentoo Linux ai pacchetti binari. Ad
esempio mozilla-bin, acroread, netscape e realplayer. I pacchetti che vengono
installati qua richiedono uno stub file in <path>/etc/env.d/foo</path>.
Questo è per includere le variabili d'ambiente e i percorsi per quei
programmi nell'ambiente di esecuzione. Per maggiori informazioni su
<path>/etc/env.d</path>, per favore visitate <uri
link="/doc/it/handbook/handbook-x86.xml?part=2&amp;chap=5">questo</uri>
documento.
</note>

</body>
</subsection>
</section>

<section>
<title>Gli script Portage e le
utility</title>
<subsection>
<title>Scripts pubblici</title>
<body>

<p>
Questi sono gli script usati dall'amministratore di sistema per installare e
cancellare pacchetti e mantenere il database dei pacchetti.
</p>

<p>
<c>ebuild</c> è il motore principale del sistema Portage; esegue i task più
importanti come lo scompattamento, la compilazione, l'installazione, il merging
e l'unmerging.  Viene richiamato nel seguente modo: <c>ebuild
percorso/al/pacchetto.ebuild comando</c>.  I comandi disponibili sono:
</p>

<table> <tr> <th>Comando</th> <th>Descrizione</th> <th>Funzione
<c>ebuild</c></th> </tr> <tr> <ti><c>setup</c>*</ti> <ti>esegue vari comandi
richiesti prima che l'ebuild possa procedere</ti> <ti><c>pkg_setup</c></ti>
</tr> <tr> <ti><c>depend</c></ti> <ti>visualizza le dipendenze necessarie a
installare il pacchetto</ti> <ti>N/A</ti> </tr> <tr> <ti><c>merge</c>*</ti>
<ti>scompatta, compila, installa e esegue il merge del pacchetto nel vostro
filesystem</ti> <ti>N/A</ti> </tr> <tr> <ti><c>qmerge</c>*</ti> <ti>esegue il
merge del pacchetto nel vostro filesystem, assumendo che lo scompattamento, la
compilazione e l'installazione siano già state eseguite</ti> <ti>N/A</ti> </tr>
<tr> <ti><c>unpack</c>*</ti> <ti>scompatta i sorgenti nella directory di
lavoro</ti> <ti><c>src_unpack</c></ti> </tr> <tr> <ti><c>compile</c>*</ti>
<ti>compila il pacchetto</ti> <ti><c>src_compile</c></ti> </tr> <tr>
<ti><c>rpm</c></ti> <ti>crea un RPM dal pacchetto</ti> <ti>N/A</ti> </tr> <tr>
<ti><c>package</c></ti> <ti>crea un pacchetto Gentoo <c>tbz2</c></ti>
<ti>N/A</ti> </tr> <tr> <ti><c>prerm</c>*</ti> <ti>esegue lo stadio di
pre-rimozione del pacchetto</ti> <ti><c>pkg_prerm</c></ti> </tr> <tr>
<ti><c>postrm</c>*</ti> <ti>esegue lo stadio di post-rimozione del
pacchetto</ti> <ti><c>pkg_postrm</c></ti> </tr> <tr> <ti><c>preinst</c>*</ti>
<ti>esegue lo stadio di pre-installazione del pacchetto</ti>
<ti><c>pkg_preinst</c></ti> </tr> <tr> <ti><c>postinst</c>*</ti> <ti>esegue lo
stadio di post-installazione del pacchetto</ti> <ti><c>pkg_postinst</c></ti>
</tr> <tr> <ti><c>config</c></ti> <ti>esegue una installazione di default quando
al pacchetto viene eseguito il merge</ti> <ti><c>pkg_config</c></ti> </tr> <tr>
<ti><c>touch</c>*</ti> <ti>aggiorna gli mtimes per ogni archivio sorgente nel
pacchetto</ti> <ti>N/A</ti> </tr> <tr> <ti><c>clean</c>*</ti> <ti>pulisce la
directory di lavoro per il pacchetto</ti> <ti>N/A</ti> </tr> <tr>
<ti><c>fetch</c>*</ti> <ti>scarica i sorgenti del pacchetto</ti> <ti>N/A</ti>
</tr> <tr> <ti><c>digest</c>*</ti> <ti>crea il file digest per il pacchetto</ti>
<ti>N/A</ti> </tr> <tr> <ti><c>test</c>*</ti> <ti>Esegue auto test routine per
il pacchetto</ti> <ti><c>src_test</c></ti> </tr> <tr> <ti><c>install</c>*</ti>
<ti>installa il pacchetto nella directory immagine</ti>
<ti><c>src_install</c></ti> </tr> <tr> <ti><c>unmerge</c></ti> <ti>esegue
l'unmerge del pacchetto dal vostro filesystem</ti> <ti>N/A</ti> </tr>  </table>

<note>
Nota: i comandi con l'asterisco (*) sono normalmente utilizzati solo
dagli sviluppatori.
</note>

<p>
<c>emerge</c> installa ricorsivamente il pacchetto e le sue dipendenze nel
filesystem.  Questo comando ha molte opzioni, provate <c>emerge --help</c> per
un elenco.
</p>

<p>
<c>env-update</c> aggiorna i file di configurazione (includendo ma non
limitando a <path>/etc/ld.so.conf</path> e <path>/etc/profile.env</path>) per
aggiornare le modifiche dei nuovi pacchetti.
</p>

</body>
</subsection>

<subsection>
<title>Script e comandi privati</title>
<body>

<p>
Questi sono script che potete usare nell'ebuild per eseguire operazioni
comuni.
</p>

<p>
Per maggiori istruzioni, guardate gli script in
<path>/usr/lib/portage/bin</path>.
</p>

<table> <tr> <th>Comando</th> <th>Valore di default</th> <th>Descrizione</th>
<th>Esempio</th> </tr> <tr> <ti><c>diropts</c></ti> <ti>-m0755</ti> <ti>Setta le
opzioni usate quando è in esecuzione <c>dodir</c></ti> <ti><c>diropts
-m0750</c></ti> </tr> <tr> <ti><c>dobin</c></ti> <ti>N/A</ti> <ti>Installa i
binari specificati in <path>DESTTREE/bin</path></ti> <ti><c>dobin
wmacpi</c></ti> </tr> <tr> <ti><c>docinto</c></ti>
<ti><path>&quot;&quot;</path></ti> <ti>Setta la relativa subdir
(<e>DOCDESTTREE</e>) usata da <c>dodoc</c></ti> <ti><c>docinto examples</c></ti>
</tr> <tr> <ti><c>dodir</c></ti> <ti>N/A</ti> <ti>Crea una directory, gestisce
trasparentemente ${D}</ti> <ti><c>dodir /usr/lib/newpackage</c></ti> </tr> <tr>
<ti><c>dodoc</c></ti> <ti>N/A</ti> <ti>Installa i files specificati nella
directory di documentazione del pacchetto
(<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (vedere <c>docinto</c>)</ti>
<ti><c>dodoc README *.txt</c></ti> </tr> <tr> <ti><c>doexe</c></ti> <ti>N/A</ti>
<ti>Installa i file specificati nella modalità <e>EXEOPTIONS</e> (vedere
<c>exeopts</c>) in <path>EXEDESTTREE</path> (vedere <c>exeinto</c>)</ti>
<ti><c>doexe ${FILESDIR}/quake3</c></ti> </tr> <tr> <ti><c>dohard</c></ti>
<ti>N/A</ti> <ti>Crea un hardlink, gestisce trasparentemente ${D}</ti>
<ti><c>dohard ls /bin/dir</c></ti> </tr> <tr> <ti><c>dohtml</c></ti>
<ti>N/A</ti> <ti>Installa i file specificati e le directory in
<path>/usr/share/doc/${PF}/html</path></ti> <ti><c>dohtml -r doc/html/*</c></ti>
</tr> <tr> <ti><c>doinfo</c></ti> <ti>N/A</ti> <ti>Installa i file specificati
in /usr/share/info, e li comprime con gzip</ti> <ti><c>doinfo
doc/*.info</c></ti> </tr> <tr> <ti><c>doins</c></ti> <ti>N/A</ti> <ti>Installa i
file specificati con modalità <c>INSOPTIONS</c> (vedere <c>insopts</c>) in
<path>INSDESTTREE</path> (vedere <c>insinto</c>)</ti> <ti><c>doins *.png
icon.xpm</c></ti> </tr> <tr> <ti><c>dolib</c></ti> <ti>N/A</ti> <ti>Installa le
librerie specificate in <path>DESTTREE/lib</path> con modalità 0644</ti>
<ti><c>dolib *.a *.so</c></ti> </tr> <tr> <ti><c>dolib.a</c></ti> <ti>N/A</ti>
<ti>Installa le librerie specificate in <path>DESTTREE/lib</path> con modalità
0644</ti> <ti><c>dolib.a *.a</c></ti> </tr> <tr> <ti><c>dolib.so</c></ti>
<ti>N/A</ti> <ti>Installa le librerie specificate in <path>DESTTREE/lib</path>
con modalità 0755</ti> <ti><c>dolib.so *.so</c></ti> </tr> <tr>
<ti><c>doman</c></ti> <ti>N/A</ti> <ti>Installa i file specificati in
<path>/usr/share/man/manX</path>, in accordo con il suffisso del file (file.1
andrà in <path>man1</path></ti> <ti><c>doman *.1 *.5</c></ti> </tr> <tr>
<ti><c>dosbin</c></ti> <ti>N/A</ti> <ti>Installa i file in
<path>DESTTREE/sbin</path>, assicurandosi che sono eseguibili</ti> <ti><c>dosbin
ksymoops</c></ti> </tr> <tr> <ti><c>dosym</c></ti> <ti>N/A</ti> <ti>Crea un
symlink, gestisce trasparentemente ${D}.</ti> <ti><c>dosym gzip
/bin/zcat</c></ti> </tr> <tr> <ti><c>emake</c></ti> <ti>N/A</ti> <ti>Esegue make
con <c>MAKEOPTS</c>. Alcuni pacchetti non possono essere fatti in parallelo;
usare invece <c>emake -j1</c>. Se si deve passare argomenti extra a make,
aggiungeteli nel comando emake. Gli utenti possono impostare la variabile di
ambiente <c>EXTRA_EMAKE</c> per passare flag extra a emake.</ti>
<ti><c>emake</c></ti> </tr> <tr> <ti><c>exeinto</c></ti> <ti><path>/</path></ti>
<ti>Setta root (<e>EXEDESTTREE</e>) per il comando <c>doexe</c></ti>
<ti><c>exeinto /usr/lib/${PN}</c></ti> </tr> <tr> <ti><c>exeopts</c></ti>
<ti>-m0755</ti> <ti>Setta le opzioni usate quando si esegue <c>doexe</c></ti>
<ti><c>exeopts -m1770</c></ti> </tr> <tr> <ti><c>fowners</c></ti> <ti>N/A</ti>
<ti>Applica la proprietà specificata ai file specificati tramite il comando
chown, gestisce trasparentemente ${D}</ti> <ti><c>fowners root:root
/sbin/functions.sh</c></ti> </tr> <tr> <ti><c>fperms</c></ti> <ti>N/A</ti>
<ti>Applica i permessi specificati ai file specificati tramite il comando chmod,
gestisce trasparentemente ${D}</ti> <ti><c>fperms 700 /var/consoles</c></ti>
</tr> <tr> <ti><c>insinto</c></ti> <ti><path>/usr</path></ti> <ti>Setta root
(<e>INSDESTTREE</e>) per il comando <c>doins</c></ti> <ti><c>insinto
/usr/include</c></ti> </tr> <tr> <ti><c>insopts</c></ti> <ti>-m0644</ti>
<ti>Setta le opzioni usate quando si esegue <c>doins</c></ti> <ti><c>insopts
-m0444</c></ti> </tr> <tr> <ti><c>into</c></ti> <ti><path>/usr</path></ti>
<ti>Setta il prefix target (<path>DESTTREE</path>) per tutti i comandi 'do'
(come <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, <c>domo</c>,
<c>dosbin</c>)</ti> <ti><c>into /</c></ti> </tr> <tr> <ti><c>libopts</c></ti>
<ti>-m0644</ti> <ti>Setta le opzioni quando si esegue <c>dolib</c></ti>
<ti><c>libopts -m0555</c></ti> </tr> <tr> <ti><c>newbin</c></ti> <ti>N/A</ti>
<ti>Wrapper di <c>dobin</c> che installa il binario specificato trasparentemente
rinominando il secondo argomento</ti> <ti><c>newbin ${FILESDIR}/vmware.sh
vmware</c></ti> </tr>  <tr> <ti><c>newdoc</c></ti> <ti>N/A</ti> <ti>Wrapper di
<c>dodoc</c> che installa il file specificato trasparentemente rinominando il
secondo argomento</ti> <ti><c>newdoc README README.opengl</c></ti> </tr> <tr>
<ti><c>newexe</c></ti> <ti>N/A</ti> <ti>Wrapper di <c>doexe</c> che installa il
file specificato trasparentemente rinominando il secondo argomento</ti>
<ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti> </tr> <tr>
<ti><c>newins</c></ti> <ti>N/A</ti> <ti>Wrapper di <c>doins</c> che installa il
file specificato trasparentemente rinominando il secondo argomento</ti>
<ti><c>newins ntp.conf.example ntp.conf</c></ti> </tr> <tr>
<ti><c>newman</c></ti> <ti>N/A</ti> <ti>Wrapper di <c>doman</c> che installa il
file specificato trasparentemente rinominando il secondo argomento</ti>
<ti><c>newman xboing.man xboing.6</c></ti> </tr> <tr> <ti><c>newsbin</c></ti>
<ti>N/A</ti> <ti>Wrapper di <c>dosbin</c> che installa il file specificato
trasparentemente rinominando il secondo argomento</ti> <ti><c>newsbin strings
strings-static</c></ti> </tr> <tr> <ti><c>prepall</c></ti> <ti>N/A</ti>
<ti>Esegue <c>prepallman</c>, <c>prepallinfo</c> e <c>prepallstrip</c>. Si
accerta anche che tutte le librerie in <path>/opt/*/lib</path>,
<path>/lib</path>, <path>/usr/lib</path> e <path>/usr/X11R6/lib</path> siano
eseguibili. Sposta anche le macro aclocal in
<path>/usr/share/aclocal</path></ti> <ti><c>prepall</c></ti> </tr> <tr>
<ti><c>prepalldocs</c></ti> <ti>N/A</ti> <ti>Gzippa ricorsivamente tutti i file
doc in <path>/usr/share/doc</path>, aggiustando trasparentemente ogni percorso
symlink</ti> <ti><c>prepalldocs</c></ti> </tr> <tr> <ti><c>prepallinfo</c></ti>
<ti>N/A</ti> <ti>Gzippa ricorsivamente tutti i file info in
<path>/usr/share/info</path></ti> <ti><c>prepallinfo</c></ti> </tr> <tr>
<ti><c>prepallman</c></ti> <ti>N/A</ti> <ti>Gzippa ricorsivamente tutte le man
pages in <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>,
<path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path> e aggiusta
trasparentemente ogni percorso symlink</ti> <ti><c>prepallman</c></ti> </tr>
</table>

</body>
</subsection>
</section>

<section>
<title>Dipendenze dei
pacchetti</title>
<subsection>
<title>Perchè le dipendenze sono
importanti</title> 
<body>

<p>
Portage è più di un semplice script conveniente che dà un modo unificato di
costruire un pacchetto (programma, libreria) dai sorgenti. E` anche un modo di
scaricare e installare le dipendenze necessarie se si sta attenti ad esse
nell'ebuild.
</p>

<p>
Negli ebuild ufficiali, tutte le dipendenze vengono specificate, quindi
quando si esegue <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage si
assicurerà che tutte le librerie necessarie a mozilla siano installate prima
di costruirlo.
</p>

<p>
Portage distingue le dipendenze build-time e run-time. (Correntemente,
Portage installa tutte le dipendenze e le lascia. In uno stage successivo può
essere possibile che siano cancellate le librerie build-time e lasciate solo le
run-time).
</p>

</body>
</subsection>

<subsection>
<title>Come specificare le dipendenze nei
vostri files ebuild (a.k.a. DEPEND Atoms)</title>
<body>

<p>
La variabile <c>DEPEND</c> nel vostro ebuild <path>foo-x.y.z.ebuild</path>
dice a Portage quali pacchetti sono necessari per costruire <path>foo</path>.
La variabile <c>RDEPEND</c> specifica quali pacchetti sono necessari a
<path>foo</path> per essere eseguito. Dovete specificare solo <c>RDEPEND</c>
se le dipendenze runtime dell'ebuild sono differenti da quelle che avete
specificato in <c>DEPEND</c>; se non specificato, <c>RDEPEND</c> avrà di
default le impostazioni del vostro <c>DEPEND</c>. Non impostate <b>mai</b>
<c>RDEPEND</c> a <c>DEPEND</c> voi stessi in un ebuild.
</p>

<pre caption="Esempio depend"> DEPEND="virtual/libc sys-libs/zlib"
RDEPEND="virtual/libc" </pre>

<p>
Ciò dice a Portage che per costruire <path>foo-x.y.z</path> i pacchetti
<path>virtual/libc</path> e <path>sys-libs/zlib</path> sono necessari. Non dice
niente su quale versione di glibc o zlib sia richiesta il che significa che non
fa niente.
</p>

<p>
Il "non fa niente" è un pò stupido e non funzionerà generalmente. Però per
librerie centrali come glibc che deve essere al 100% compatibile con i binari,
funziona.  Per le altre librerie, possiamo specificare le versioni delle
dipendenze.
</p>

<pre caption="Esempio versione"> &gt;=sys-apps/bar-1.2 =sys-apps/baz-1.0 </pre>

<p>
&gt;= e = fanno quello che vi aspettate; sys-apps/bar versione 1.2 o più
nuova va bene (ciò significa che sys-apps/bar-2.0 è okay), mentre
sys-apps/baz versione 1.0 è la sola accettata. Per maggiori informazioni
sullo schema delle versioni dei pacchetti, vedere la sezione sopra <uri
link="#doc_chap2_sect2">Dare il nome ai file ebuild</uri>.
</p>

<p>
Altri modi di specificare le dipendenze delle versioni sono i seguenti:
</p>

<pre caption="Specificare le dipendenze delle versioni"> ~sys-apps/qux-1.0
=sys-apps/foo-1.2* !sys-libs/gdbm </pre>

<p>
~sys-apps/qux-1.0 sceglierà la revisione più nuova di qux-1.0
</p>

<p>
=sys-apps/foo-1.2* sceglierà il membro più nuovo della serie 1.2 e ignorerà
le serie 1.3 e quelle più avanti/indietro. Ciò significa che foo-1.2.3 e
foo-1.2.0 sono valide, mentre foo-1.3.3, foo-1.3.0, e foo-1.1.0 non lo sono.
</p>

<p>
!sys-libs/gdbm impedirà a questo pacchetto di fare il merge poichè gdbm è
già installato.
</p>

</body>
</subsection>

<subsection>
<title>Note importanti</title>
<body>

<p>
Ci sono molte cose difficili da capire con le variabili DEPEND e RDEPEND.
Ecco alcuni punti importanti da seguire quando si scrivono le dipendenze.
</p>

<ul>
  <li>
		<e>Includere sempre la CATEGORIA.</e><br /> Per esempio, usare
		<c>&gt;=x11-libs/gtk+-2</c> e non <c>&gt;=gtk+-2</c>.
	</li>
	<li>
		<e>Non mettere un asterisco (*) per &gt;= dipendenze.</e><br /> Per
		esempio, dovrebbe essere <c>&gt;=x11-libs/gtk+-2</c> non
		<c>&gt;=x11-libs/gtk+-2*</c>.
	</li>
	<li>
		<e>Mai dipendere su un meta-pacchetto.</e><br /> Non dipendere su
		gnome-base/gnome, ma sempre dipendere sulle librerie secifiche come
		libgnome.
	</li>
	<li>
		<e>Una dipendenza per riga.</e><br /> Non mettere multiple dipendenze su
		una stessa riga. Non è facile da leggere e difficile da seguire.
	</li>
	<li>
		<e>GTK: Sempre usare =x11-libs/gtk+-1.2* per apps GTK+1.</e>
	</li>
</ul>

<p>
E' importante assicurarsi che tutte le dipendenze sono complete per il
vostro pacchetto:
</p>

<ul>
  <li>
		<e>Guardare in configure.in o configure.ac</e><br /> Controllare i
		pacchetti qui. Le cose da controllare sono pkg-config o le funzioni AM_*
		che controllano una specifica versione.
	</li>
	<li>
		<e>Guardare file .spec</e><br /> Una buona indicazione delle dipendenze è
		guardare i file .spec per le rilevanti dipendenze. Non credere che siano
		la lista delle dipendenze completa.
	</li>
	<li>
		<e>Guardare il sito web dell'applicazione/libreria</e><br /> Controllare
		il sito web della applicazione per possibili dipendenze che possono
		risultare necessarie.
	</li>
	<li>
		<e>Leggere il README e INSTALL per il pacchetto</e><br /> Di solito
		contengono utili informazioni sulla costruzione e la installazione dei
		pacchetti.
	</li>
	<li>
		<e>Ricordarsi le dipendenze non binarie come pkg-config, doc generation
		programs, etc.</e><br /> Il processo di costruzione richiede quasi sempre
		dipendenze come intltool, libtool, pkg-config, doxygen, scrollkeeper,
		gtk-doc, etc. Asicurarsi che queste sono dichiarate.
	</li>
</ul>

<p>
Per tutti gli ultimi dettagli su DEPEND Atoms, per favore vedere la sezione
5 della manpage sugli ebuilds: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Testare e distribuire</title>
<subsection>
<title>ChangeLog</title>
<body>

<p>
Quando si aggiorna (o si scrive un nuovo) ebuild bisogna sempre aggiornare
il suo ChangeLog.  Il file <path>skel.ChangeLog</path> contiene un semplice
ChangeLog da usare come base.
</p>

<p>
Lo scopo del ChangeLog è documentare <e>cosa</e> è stato fatto,
<e>perchè</e> è stato fatto e da <e>chi</e>. Questo permette a sviluppatori e
utenti di tracciare i cambiamenti in maniera semplice.
</p>

<p>
Il Changelog è primariamente destinato agli utenti, quindi siate sicuri di
scriverlo corto, puntuale ed evitare di essere troppo precisi nei dettagli
tecnici.
</p>

</body>
</subsection>

<subsection>
<title>Memorizzare i vostri ebuilds localmente</title>
<body>

<p>
Per poter testare i vostri ebuilds e lasciare che Portage li riconosca,
dovete disporli in una directory conosciuta. Portage userà la variabile
<c>PORTDIR_OVERLAY</c> che potete definire in <path>/etc/make.conf</path>.
Dovreste settare questa variabile alla vostra directory (per esempio
<path>/usr/local/portage</path>).
</p>

<p>
In questa directory, dovete usare la stessa struttura (e le stesse
categorie) di <path>/usr/portage</path>.
</p>

<p>
Usando <c>PORTDIR_OVERLAY</c>, i vostri ebuilds rimangono nel vostro
sistema, anche dopo un <c>emerge --sync</c>, e sono ancora riconosciuti da
Portage.
</p>

</body>
</subsection>

<subsection>
<title>Testare i pacchetti</title>
<body>

<p>
Si vede come si testerà se il pacchetto funziona. A volte gli sviluppatori
includono una routine <c>make test</c> o una <c>make check</c> che testeranno
le funzionalità di base del pacchetto. Se è così allora, eseguite <c>env
FEATURES=maketest ebuild <path>foo-x.y.z.ebuild</path> test</c>. Se è rotto
cercate di aggiustarlo così che funzioni (e mandare la patch ai sviluppatori
principali).
</p>

<p>
Se questo non è il caso si aggiunge una routine <c>src_test</c> al vostro
ebuild. E' eseguita prima della routine <c>src_install</c> e può essere molto
utile per testare che il programma funzioni in varie architetture. Gli
sviluppatori della architettura apprezzeranno se aggiungete una routine qui
così non richiede la conoscenza della funzionalità del pacchetto.
</p>

<p>
Tenete in mente le richieste generali di un ebuild qui. La routine
<c>src_test</c> non deve essere interattiva. Se il test routine dipende su
altri pacchetti usare la flag USE <c>maketest</c> per specificare l'opzionale
tempo di compilazione delle <c>DEPEND</c>ancies. Le routines <c>src_test</c>
non sono raccomandate per applicazioni grafiche X poichè l'utente che esegue
portage spesso non può eseguirle successivamente.
</p>

</body>
</subsection>

<subsection>
<title>Tool utili per i test</title>
<body>

<p>
Abbiamo degli utili tool per aiutarvi con la scrittura e il mantenimento dei
vostri ebuilds.
</p>

<table> <tr> <th>Tool</th> <th>Pacchetto</th> <th>Descrizione</th> </tr> <tr>
<ti><c>repoman</c></ti> <ti>sys-apps/portage</ti> <ti>Tool per sviluppatori che
aiuta nella procedura di checkin al CVS. Fa molte comuni QA e cerca di
assicurare che i file aggiunti al cvs non romperanno il portage tree.</ti> </tr>
<tr> <ti><c>ccache</c></ti> <ti>dev-util/ccache</ti> <ti>Tool che mantiene i
file già installati così che la ricompilazione si ottiene <e>molto</e> più
velocemente. Assicuratevi di aggiungere <c>ccache</c> alla variabile
<c>FEATURES</c> in <path>/etc/make.conf</path>!  </ti> </tr> <tr>
<ti><c>sandboxshell</c></ti> <ti>app-shells/sandboxshell</ti> <ti>Lancia una
shell che crea un ambiente sandbox. Utile per entrare all'interno dello stesso
ambiente in cui portage costruisce i pacchetti e mettere a punto le cose a
mano.</ti> </tr> <tr> <ti><c>echangelog</c></ti>
<ti>app-portage/gentoolkit-dev</ti> <ti>Può creare un nuovo Changelog o
aggiungere una voce in uno già esistente.</ti> </tr> </table>

</body>
</subsection>

</section>

</sections>


