<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/policy.xml :: R1.35.
-->

<sections>
<section>
<title>Linee guida generali</title>
<subsection>
<body>

<p>
Qui ci sono alcune linee guida generali da seguire per lo sviluppo:
</p>

<ul>
  <li>Controlla sempre i tuo cambiamenti con repoman; usa repoman commit al posto di cvs commit.</li>
  <li>
		Se il pacchetto è corrotto anche nella sua versione corrente o se non ha
		un buon processo di compilazione/installazione, guarda come si comportano
		altre distribuzioni:
	<ul>
  <li><uri link="http://www.debian.org/distrib/packages">Debian</uri></li>
  <li><uri link="http://cvs.mandriva.com/cgi-bin/cvsweb.cgi/SPECS/">Mandriva</uri></li>
  <li><uri link="http://cvs.fedora.redhat.com/">Fedora</uri></li>
  </ul>
  </li>   
  <li>
		Il tuo pacchetto, quando completo e unmasked, si suppone che sia pronto
		da usare per l'utente finale. La modifica del prodotto installato per
		farlo funzionare deve essere opzionale; per questo motivo dovresti
		installare il pacchetto con delle ragionevoli impostazioni predefenite.
	</li>
  <li>
		Non aver timore di consultare la nostra documentazione online e di
		guardare come sono scritti e mantenuti gli ebuild creati da sviluppatori
		più esperti. Sentiti libero di contattare direttamente sviluppatori più
		esperti per porre qualsiasi domanda tecnica o di regole.
	</li>
  <li>
		Fai attenzione a quello che cambi e rendi disponibile agli altri.
		Ricordati che i tuo cambiamenti possono potenzialmente danneggiare
		migliaia di utenti. Se i tuoi cambiamenti causano rotture nel portage
		tree, si dovranno sistemare immediatamente.
	</li>
  <li>
		Ogni pacchetto deve essere accompagnato da un file <uri
		link="?part=2&amp;chap=4">metadata.xml</uri> il quale elenca -tra le
		diverse informazioni - i cambiamenti, chi ha fatto modifiche al
		pacchetto.
	</li>
</ul>

</body>
</subsection>
</section>

<section>
<title>Linee guida specifiche</title>
<subsection>
<title>fPIC</title>
<body>

<p>
Su certe architetture, le librerie condivise devono essere compilate con
-fPIC. Nelle architetture x86 e altre, le librerie condivise verranno
compilate senza -fPIC, ma è uno spreco e potenzionalmente potrebbe causare
una diminuzione di performance. Se trovi un pacchetto che non ha compilato le
librerie condivise con -fPIC, correggi il Makefile per compilare <b>solo</b>
le librerie con -fPIC.  Ci sono maggiori informazioni disponibili su PIC su
<uri>http://www.gentoo.org/proj/en/hardened/pic-internals.xml</uri>. Se non
sei sicuro, per favore chiedi un aiuto in un forum publico di sviluppatori
(come la mailing list gentoo-dev o sul canale irc #gentoo-dev).
</p>

</body>
</subsection>

<subsection>
<title>Perl</title>
<body>

<p>
I nuovi moduli del perl saranno aggiunti al portage solo quando una delle
seguenti condizioni sarà verificata:
</p>

<ul>
  <li>I(l) modulo(i) soddisfa una dipendenza</li>
  <li>I(l) modulo(i) non possono essere gestiti da <c>g-cpan</c></li>
  <li>I(l) modulo(i) aggiunge funzionalità agli ebuild esistenti</li>
  <li>I(l) modulo(i) fornisce strumenti, applicazioni o altre funzionalità (per esempio di più di quelle che offre il loro .PM)</li>
</ul>

<p>
Per favore assicurati che almeno un membro dei capi approva la tua aggiunta.
</p>

</body>
</subsection>
</section>

<section>
<title>Regole per l'Ebuild</title>
<subsection>
<title>Regole per il nome</title>
<body>

<p>
Il nome del file dell'Ebuild deve soddisfare quattro sottosezioni logiche:
</p>

<p>
<c>pkg-ver{_suf{#}}{-r#}.ebuild</c>
</p>

<note>
Le parentesi graffe (<c>{}</c>) delimitano campi opzionali e non appariranno
nel nome letterale del pacchetto. <c>#</c> rappresenta tutti gli interi
positivi (0 escluso).
</note>

<p>
La prima sottosezione, <c>pkg</c>, il nome del pacchetto, il quale deve
contenere soltanto caratteri minuscoli, i numeri 0-9, qualsiasi numero di
trattini singoli (<c>-</c>), underscore (<c>_</c>) o caratteri più
(<c>+</c>). Esempio: <c>util-linux</c>, <c>sysklogd</c> e <c>gtk+</c>. Ci
sono alcuni pacchetti che sono nel portage tree e non seguono queste regole,
ma il <e>tuo</e> pacchetto lo dovrà fare.
</p>

<p>
La seconda sottosezione, <c>ver</c>, è la versione del pacchetto, che deve
essere normalmente la stessa della versione del suo tarball principale. La
versione è normalmente composta da due o tre (o più) numeri separati da
punti, come <c>1.2</c> o <c>4.5.2</c>, e potrebbero avere una singola lettera
alla fine dell'ultimo digits; per esempio, <c>1.4b</c> o <c>2.6h</c>. La
versione del pacchetto è correlata al pacchetto con un trattino. Esempio:
<c>foo-1.0</c>, <c>bar-2.4.6</c>.
</p>

<p>
La terza sottosezione, <c>{_suf{#}}</c>, è opzionale, può contenere uno di
questi suffissi predefiniti, elencati dal meno recente al più recente:
</p>

<table>
 <tr><th>Suffisso</th><th>Significato</th></tr>
 <tr><ti><c>_alpha</c></ti><ti>Rilascio alpha</ti></tr>
 <tr><ti><c>_beta</c></ti><ti>Rilascio beta</ti></tr>
 <tr><ti><c>_pre</c></ti><ti>Pre rilascio</ti></tr>
 <tr><ti><c>_rc</c></ti><ti>Candidato ad essere un rilascio</ti></tr>
 <tr><ti>(none)</ti><ti>Rilascio normale</ti></tr>
 <tr><ti><c>_p</c></ti><ti>Livello di correzione (normalmente seguito da un intero)</ti></tr>
</table>

<p> 
Ognuno di questi suffissi deve essere immediatamente seguito da un numero
positivo diverso da zero, per esempio, <c>linux-2.4.0_pre10</c>. Assumendo la
parte della versione identica, il suffisso è ordinato come segue (più basso
significa più vecchio): <c>_alpha</c> &lt;<c>_beta</c> &lt; <c>_pre</c> &lt;
<c>_rc</c> &lt; (no suffix) &lt; <c>_p</c>.
</p>
       
<p>
Quando si comparano suffissi identici seguiti da un intero, quello con il
numero più grande viene considerato il più recente. Esempio:
<c>foo-1.0_alpha4</c> è più recente di <c>foo-1.0_alpha3</c>.
</p>

<p>
La quarta sottosezione del nome del pacchetto è il numero specifico della
revisione Gentoo Linux (<c>{-r#}</c>). Questa sottosezione, come il suffisso,
è opzionale. <c>#</c> è un numero positivo diverso da 0 zero; esempio,
<c>package-4.5.3-r3</c>. 
</p>

<p>
Questo numero di revisione è indipendente dalla versione del suo tarball, e è
usata per informare le persone che c'è disponibile una nuova e migliorata
versione di un particolare pacchetto per Gentoo Linux. La release iniziale
degli ebuild non deve avere il numero della revisione; esempio,
<c>package-4.5.3</c> e è considerata dal portage come se avesse un numero di
revisione pari a zero. Questo significa che il conteggio va come segue:
<c>1.0</c> (versione iniziale), <c>1.0-r1</c>, <c>1.0-r2</c>, etc. 
</p>

</body>
</subsection>

<subsection>
<title>Uscite di versione e revisione</title>
<body>

<p>
Il numero della revisione di un pacchetto deve essere incrementata dagli
sviluppatori di Gentoo Linux quando l'ebuild è stato cambiato in un punto in
cui si richiedeva l'aggiornamento. Generalmente, questo è il caso in cui le
migliorie sono fatto su di un ebuild affetto da che influenza i files
installati, ma l'ebuild usa lo stesso tarball della precedente release. Se
fai un cambiamente interno, stilistico all'ebuild che non cambia nessun files
installato, allora non è necessario di pubblicare il numero della revisione.
Allo stesso modo, se fissi un problema di compilazione nell'ebuild che va ad
influenzare alcuni utenti non è necessario di aggiornare il numero della
revisione, fino a quando per tutti il pacchetto funziona perfettamente non ci
sono benefici in una nuova revisione, e quelli che hanno avuto problemi di
installazione non hanno il pacchetto (perchè la compilazione è fallita) e
così non c'è bisogno di fare una nuova revisione per forzare un
aggiornamento. La pubblicazione di una revisione non è neppure necessaria se
il problema è stato riscontrato da un numero minimo di utenti ed il pacchetto
non ha un tempo medio insignificante di compilazione; usa il tuo miglior
giudizio in queste circostanze.
</p>

<impo>
Quando crei una nuova revisione di un ebuild, assicurati di aggiornare il
file <path>ChangeLog</path> nella directory dell'ebuild. Dimenticarsi di fare
questo è considerato un grave errore nell'azione disciplinare.
</impo>

<p>
Gli ebuilds devono essere basati sulla versione precedente dell'ebuild per
assicurare che i cambiamenti non vengano accidentalmente cancellati. Le fixes
devono includere commenti appropriati nell'ebuild che spiegano cosa fanno ed
il perchè sono state necessarie. Se non sei abituato con le fixes, o non
riesci a determinare se sono veramente necessarie, devi aggiornare l'ebuild.
</p>

</body> 
</subsection> 

<subsection>
<title>Virtuali</title>
<body>

<p>
Il portage supporta il concetto di pacchetti "virtuali". L'uso di pacchetti
virtuali è possibile per avere un particolare nome categoria/pacchetto
mappato su di un altro.
</p>

<p>
Qui c'è un esempio di come si usano i pacchetti virtuali. Creiamo un nuovo
pacchetto di cron chiamato <c>foocron</c>. Gentoo Linux è correntemente
impostato ad avere bisogno di un pacchetto cron dove alcuni tipi dipendono
dal pacchetto <c>virtual/cron</c>. Questo permette agli ebuilds di
assicurarsi che c'è un tipo di pacchetto cron disponibile permettendo così
agli utenti di installare il pacchetto cron che preferiscono. Per inserire il
tuo pacchetto <path>foocron-1.0.ebuild</path> in questo sistema, devi
aggiungere una linea all'ebuild, come segue:
</p>

<pre caption="Come fornire un pachetto virtuale">
PROVIDE="virtual/cron"
</pre>

<p>
Adesso, quando <c>foocron-1.0</c> è installato, il pacchetto
<c>virtual/cron</c> verrà registrato. Se non hai nessun pacchetto cron
installato, installalo prima, questo significa che tutti i pacchetti
<e>dipendenti</e> da <c>virtual/cron</c> avranno la dipendenza completamente
soddisfatta. Nota che è possibile specificare un valore <c>PROVIDE</c> per
ogni tipo di pacchetto -- necessita di non cominciare con <c>virtual/</c>. In
ogni caso, <e>devi</e>  usare la categoria <e>virtual</e> a meno che stai
usando la funzionalità di <c>PROVIDE</c> per gestire i pacchetti che sono
stati rinominati.  
</p>

<p>
C'è un secondo componente nell'implementazione virtuale di Gentoo Linux. Cosa
succederà se non sono stai installati pacchetti che forniscono
<c>virtual/cron</c>? Come fa il portage a soddisfare la dipendenza per
<c>virtual/cron</c>? Portage si prende cura di questa situazione usando un
profilo specifico del mappaggio virtuale di file chiamato
<path>virtuals</path> il quale è memorizzato nella directory del profilo
<path>/etc/make.profile</path>. Se dai uno sguardo al tuo file
<path>virtuals</path>, vedrai che il contenuto assomiglia a qualcosa come
questo: 
</p>

<pre caption="Sample virtuals file">
virtual/lpr             net-print/cups
virtual/python          dev-lang/python
virtual/mta             net-mail/ssmtp
</pre>

<p>
La prima riga di questo file dice al Portage che se un pacchetto dipende da
<c>virtual/lpr</c> e non c'è installato alcun <c>virtual/lpr</c> disponibile
nel Portage Tree, allora <c>net-print/cups</c> soddisferà questa dipendenza.
<c>net-print/cups</c> contiene una linea che legge
<c>PROVIDE="virtual/lpr"</c> così verranno soddisfatte tutte le dipendenze
future di <c>virtual/lpr</c>.
</p>

<p>
Adesso per le linee guida degli sviluppatori. Se hai aggiunto il pacchetto
<c>foocron</c>, vorrai ovviamente assicurarti che tutti i programmi che
dipendono da <c>virtual/cron</c> saranno abilitati a lavorare correttamente
con lui. E se hai aggiunto il pacchetto chiamato <c>foobarosity</c> che
dipende da <c>virtual/cron</c>, dovrai allo stesso modo assicurarti che tutti
i pacchetti che forniscono <c>virtual/cron</c> soddisferanno le corrette
funzionalità di <c>foobarosity</c>.
</p>

<p>
Prima di creare un nuovo pacchetto virtuale, per favore comincia una
discussione nella mailing list interna a proposito di questa virtuale. Tenere
informati gli sviluppatori a proposito di nuove virtuali è essenziale per
assicurare il loro uso.
</p>

</body>
</subsection>

<subsection>
<title>Scope</title>
<body>

<p>
Quando un ebuild è fonte, le funzioni e le varibili contenute sono caricate
nella memoria dall'interprete dello script. In ogni caso, solo le variabili e
le istruzioni che non sono parte di una funzione vengono interpretate -
funzioni come <c>src_compile()</c> sono solamente eseguite dal Portage quando
l'ebuild ha raggiunto lo stage di compilazione.
</p>

<p>
Il codice contenuto in queste funzioni è considerato "local scope" fino a
quando tutto ciò che sta all'esterno delle funzioni è nel "global scope" il
che significa che sono eseguiti ogni volta che l'ebuild è la fonte.
</p>

<p>
Un'applicazione esterna (come grep, sed o awk) deve sempre essere chiamata
nello scope globale per questioni di performance, e le alternative come l'uso
di rimpiazzamenti built-in della bash devono essere usate al loro posto.
Utili alternative possono essere trovate in <uri
link="http://www.tldp.org/LDP/abs/html/">Advanced Bash Scripting
Guide</uri>.
</p>

<p>
In più, tutte le applicazioni esterne che possono essere chiamate nello scope
globale non possono garantire di esistere nel sistema. Se il comando è messo
in uno scope locale (per esempio, nella funzione <c>pkg_setup()</c>),
possiamo garantire la sua presenza mettendola nel <c>${DEPEND}</c>
dell'ebuild.
</p>

</body>
</subsection>

<subsection>
<title>Regole per i sorgenti del CVS</title>
<body>

<p>
Ci sono due modi differenti di compilare un ebuild basato su sorgenti che
provengono dal tree di sviluppo del CVS. Il primo e tradizionale metodo è di
creare un ebuild del "CVS snapshot" creando un tarball personale
dall'upstream del tree del CVS, facendo un mirroring dei sorgenti nel proprio
ripostiglio ufficiale dei distfile, e scrivendo un ebuild per l'uso speciale
di questo tarball snapshot. Questi tipi di ebuild CVS verranno referenziati
più sotto come un "Snapshot di ebuild del CVS".
</p> 

<p>
L'altro metodo per la creazione di ebuild basati sul CVS è di usare
<path>cvs.eclass</path> per creare un ebuild del CVS "live". Come un ebuild
prenderà dinamicamente l'ultimo sorgente di sviluppo dal ripostiglio del CVS
al momento del bisogno, assicurando che il sorgente è il più possibile
aggiornato. Questi tipi di ebuild del CVS saranno chiamati sotto "Ebuilds
'live'".
</p>

<p>
I seguenti paragrafi dettagliano le relazioni delle regole sull'uso di
ebuilds basati sul CVS. Nota che questi hanno delle regole molto strette
relative all'aggiunta degli ebuild al Portage tree.
</p>

<p>
Gli snapshot degli ebuild del CVS sono maggiormente preferiti dal "live"
<path>cvs.eclass</path> ebuild del cvs.
</p> 

<p>
Gli snapshot degli ebuild del CVS sono autorizzati se uno snapshot del CVS
contiente delle migliorie conosciute che sono necessarie per alcune
operazioni di un pacchetto software, o se la versione del CVS di un
particolare pacchetto software è conosciuto o è stato rilevato semplicemente
che lavora meglio della versione normale di release.
</p>

<p>
Ebuild <path>cvs.eclass</path> "Live" sono generalemente intesi per la
convenienza degli sviluppatori e devono sempre essere mascherati da una
parola chiave <c>~[arch]</c>. Non è possibile di garantire l'attendibilità di
un ebuild <path>cvs.eclass</path> "live" fino a quando è cambiato il tree del
cvs, questo è il motivo del perchè devono sempre essere mascherati.
</p> 

<p>
Per entrambi gli ebuild del CVS "live" e ebuild del CVS "snapshot", <b>sei lo
sviluppatore responsabile  di assicurare che l'ebuild funzioni
correttamente</b>. Questo è particolarmente difficile da fare con gli ebuild
del CVS "live" per ovvie ragioni.
</p>

<p>
Se gli ebuild (di ogni tipo) non funzionano correttamente o sono fallate,
essi devono essere sistemati o rimossi dal Portage tree. Se sono ebuild del
CVS "live", essi dovranno essere mascherati dalla parola chiave
<c>~[arch]</c> per tutti il loro ciclo di vita (questa speciale eccezione è
spiegata sotto). 
</p>

<p>
Se un utente o gli utenti chiedono specificatamente un ebuild del CVS "live",
puoi aggiungerne uno per loro. Esso dovrà avere la parola chiave
<c>~[arch]</c> in modo che altri utenti non potranno emergere il pacchetto
senza sospetti. 
</p>

<p>
In questo modo, gli utenti che richiedono l'ebuild (come gli sviluppatori)
possono installare l'ebuild ma altri utenti saranno protetti dall'emersione
dello stesso accidentalmente.Questo è però solamente applicabile a situazioni
in cui un utente o degli utenti chiedono specificatamente un ebuild del CVS
"live" <path>cvs.eclass</path>. Gli snapshot sono stabili e forniscono
funzionalità migliori della normale versione di release del software in
questione.
</p>

<impo>
Gli ebuilds degli snapshot delle <e>pre-release</e> dei sorgenti del CVS
devono essere chiamati come segue: <path>foo-x.y_preYYYYMMDD.ebuild</path>.
<c>foo</c> è il nome del pacchetto, <c>x.y</c> è il numero della versione
dell' <e>upcoming</e> release, <c>_pre</c> è una stringa letterale, e
<c>YYYYMMDD</c> è un timestamp del giorno di quando è stato preso lo
snapshot. Usa questa convenzione del nome per assicurare che una versione
della release <c>x.y.1</c> non sia considerata più vecchia dello snapshotp
<c>x.y</c>, questo perchè allo stesso tempo siamo sicuri che la versione
ufficiale della release <c>x.y</c> sarà considerata <e>più nuova</e> della
versione del tuo snapshot del CVS. Per gli snapshot del CVS dei sorgenti del
CVS <e>già rilasciati</e>, usa il formato
<path>foo-x.y_pYYYYMMDD.ebuild</path> (nota la <c>_p</c> per il
"patchlevel.") Questo assicurerà che il tuo ebuild del CVS sarà considerato
<e>più nuovo</e> della versione di release standard <c>x.y</c> release.
</impo>

<impo>
Al momento, la regola per la nominazione degli ebuild del CVS "live" serve
per assicurare che il nome del pacchetto finisca con <c>-cvs</c>. In futuro
il suffisso per la versione <c>_cvs</c> verrà aggiunta al Portage e questa
regola verrà aggiornata.
</impo>

</body>
</subsection>

<subsection>
<title>Ebuild inviati dagli utenti</title>
<body>

<p>
GLi ebuild inviati dagli utenti devono sempre essere nascosti, e devono
sempre essere ben testati e verificati prima di essere aggiunti al CVS. <b>Se
un ebuild inviato da un utente ha problemi, sarà ritenuto il
responsabile.</b> Inviandolo al CVS, assicuri che l'ebuild soddisfa tutti gli
standards dello sviluppo di Gentoo Linux.
</p>

<p>
Assicurarsi che l'ebuild dell'utente non contiene headers personali come
questo:
</p>

<pre caption="Un header personale che deve essere trasferito sul ChangeLog">
# Ebuild updated by: me &lt;me@me.com&gt;
</pre>

<p>
Questa informazione deve essere aggiunta al <path>ChangeLog</path>
utilizzando in modo corretto la sintassi per i commenti del ChangeLog.
<b>Assicurati sempre che il ChangeLog da i crediti corretti all'utente che ha
inviato l'ebuild. Questa informazione deve apparire nella prima riga del
ChangeLog.</b>
</p>

<p>
Assicurati anche che tutti i nuovi ebuild che invii contengono la riga
seguente:
</p>

<pre caption="Header di un ebuild">
# &#36;Header: &#36;
</pre>

<p>
Quasi tutti gli ebuild inviati dagli utenti sono basati da files dell'rsync,
i quali possono contenere headers incorretti.
</p>

<p>
Incoraggia gli utenti a inviare i diffs agli ebuild esistenti se sono stati
inviati come aggiornamento. Facendo questo, possiamo aiutare la
re-introduzione dei bugs già sistemati negli ebuild "nuovi". Se non stai
lavorando su di un diff di un ebuild inviato da un utente ma su di un ebuild
completo, allora usa il comando <c>diff</c> per vedere cosa è stato cambiato,
mantenendo un'occhio aperto per tutto ciò che c'è nel tuo corrente e build e
che dovrà apparire nel nuovo ebuild, o per tutto quanto c'è nel nuovo ebuild
che deve essere fissato o rimosso.
</p>

<p>
In generale, lascia che l'utente fa il suo lavoro per aggiornare il suo
ebuild, a meno che <e>vuoi</e> pulire l'ebuild a suo vantaggio. Anche se, è
spesso meglio lascia fare il lavoro all'utente in modo da dargli la
possibilità di imparare dai propri errori e inviare ebuild puliti nel futuro.
Assicurati di essere riconoscente per qualsiasi invio, anche se il lavoro non
è molto buono. Si educato ma onesto -- se un ebuild non è usabile, l'utente
può essere avvisato in un modo che non insulta la sua possibilità corrente di
scrivere ebuild. Ricordati che l'utente che invia questo ebuild corrotti
potrebbe essere in futuro un membro responsabile e produttivo del nostro
progetto -- e questo succederà se riceverà la giusta quantità di
incoraggiamenti e supporto per continuare a migliorare le sue abilità .
</p>

</body>
</subsection>


</section> 

<section>
<title>Regole per il QA (Quality assicurance)</title>
<subsection>
<title>Regole per le release del Portage/Baselayout</title>
<body>

<p>
Solo i membri del team dil Portage (che si sa chi sono) hanno il diritto per
passare ad una nuova release del Portage. <b>Nessun</b> altro è abilitato a
passare a nuove release del portage. 
</p>

<p>
Solo i membri del team del baselayout (che si sa chi sono) hanno i permessi
di passare ad una nuova release del baselayout. <b>Nessun</b> altro è
abilitato a passare a nuove release del baselayout. 
</p>

</body>
</subsection>

<subsection>
<title>Pacchetti mascherati</title>
<body>

<p>
<path>/usr/portage/profiles/package.mask</path> contiene una lista di
pacchetti che non devono essere emersi dagli utenti e commenti che spiegano
dettagliatamente la ragione del perchè. Packege.mask è usato per prevenire
l'emersione di pacchetti che sono rotti, rompono qualcosa d'altro o
necessitano di test prima di essere aggiunti nel ~ARCH KEYWORDS del Portage
tree. Quando aggiungi al package.mask, invia sempre il package.mask prima di
inviare l'ebuild mascherato. Questo previene che l'ebuild sia preso dagli
utenti prima che venga fatto l'aggiornamento del package.mask.
</p>

<p>
Deve essere presa una sicurezza ancora maggiore ogni volta che un pacchetto
viene rimosso da <path>package.mask</path>. Tieni a mente che se un ebuild è
in <path>package.mask</path>, è li perchè c'è un motivo. Se non mascheri
l'ebuild, contatta sempre  lo sviluppatore elencato nei commenti
del<path>package.mask</path> prima di prendere una dipendenza di un pacchetto
core, o se il fatto di togliere il pacchetto dai pacchetti mascherati possa
avere effetti inversi, il cambiamento deve essere discusso internamente nella
mailing list degli sviluppatori.
</p>

</body>
</subsection>

<subsection>
<title>~ARCH in KEYWORDS</title>
<body>
<p>
Lo scopo di ~arch è per testare nuovi pacchetti aggiunti al Portage.
</p>

<p>
C'è una differenza tra l'uso di <path>package.mask</path> e ~arch per gli
<b>ebuilds</b>. L'uso di <path>package.mask</path> denota il fatto che
l'applicazione o la libreria è valutata come instabile. Per esempio, se
<c>gimp-1.2.0</c> è la versione stabile per gli sviluppatori di Gimp,
l'aggiunta di una nuova bug fix è disponibile come 1.2.1, quindi uno
sviluppatore deve marcare l'ebuild come ~arch per testarlo nel portage perchè
la release è valutata come stabile. In un altro caso, se Gimp decide di
rilasciare una versione della serie instabile o di sviluppo marcata come
1.3.0, allora questi ebuilds dovranno essere messi in
<path>package.mask</path> perchè il software in stesso è di una qualità di
sviluppo e non è raccomandata dagli sviluppatori per la distribuzione.
</p>

<p>
Tutti i nuovi pacchetti che entrano a fare parte del Portage devono essere
marcati come ~arch per la(e) architettura(e) supportate dalla versione. Lo
sviluppatore che fa il commit dell'ebuild deve verificare che funziona
correttamente e che le KEYWORDS sono corrette.
</p>

</body>
</subsection>

<subsection>
<title>Spostamento delle versioni dei pacchetti da ~ARCH a ARCH</title>
<body>

<p>
Quando una nuove versione di un pacchetto è stata dichiarata stabile per un
numero sufficiente di volte ed il mantenitore dei pacchetti di Gentoo crede
che l'aggiornamento non creerà problemi alla macchina Gentoo degli utenti,
allora può esere spostato da ~ARCH a ARCH. L'indicazione della stabilità del
pacchetto ed i report dei bug non verranno verificati per un mese dopo
l'introduzione della nuova versione.
</p>

<p>
E' compito del mantenitore del paccehtto di dire quali versioni sono stabili
o se la versione di sviluppo deve essere in <path>package.mask</path> o
lasciata come ~arch.
</p>

<p>
Tu devi solo assicurare che tutte le dipendenze di questa versione del
pacchetto sono anche in ARCH.
</p>

<warn>
Il processo ~ARCH può essere ignorato <e>solo e solo se</e> la versione del
pacchetto in questione contiene una fix per la sicurezza o necessita di
sistemare un importante bug nel sistema Gentoo. 
</warn>

</body>
</subsection>
</section>

<section>
<title>Variabili</title>

<subsection>
<title>Variabili necessarie</title>
<body>

<p>
Le regole di Gentoo Linux necessitano che tutti gli ebuild contengono le
varibili <c>KEYWORDS</c>, <c>LICENSE</c>, e<c>SLOT</c>. <c>HOMEPAGE</c>,
<c>SRC_URI</c> e <c>DESCRIPTION</c> devono essere anche incluse eccetto per
alcune circostanze.<c>DEPEND</c> (e se necessario, <c>RDEPEND</c>) devono
essere incluse se il tuo pacchetto ha dipendenze su di un ebuild o
rispettivamente delle dipendenze di runtime.
</p>

</body>
</subsection>

<subsection>
<title>DEPEND e RDEPEND</title>
<body>

<p>
Usa <c>DEPEND</c> per definire le dipendenze richieste per la compilazione di
un paccehtto particolare, e imposta <c>RDEPEND</c> sulla dipendenza richiesta
per <e>eseguire</e> un particolare pacchetto. Necessiti soltanto di
specificare <c>RDEPEND</c> se le dipendenze di runtime dell'ebuild sono
differenti da quelle che hai specificato in <c>DEPEND</c>; se non
specificato, <c>RDEPEND</c> imposterà default alle tue impostazioni
<c>DEPEND</c>. <b>Mai</b> impostare <c>RDEPEND</c> a <c>DEPEND</c> da solo in
un ebuild.
</p>

<pre caption="RDEPENDs corretti e invalidi">
# Accettabile:
RDEPEND="${DEPEND}
	net-ftp/curl
	virtual/libc"
# Non accettabile:
RDEPEND="${DEPEND}"
</pre>

<p>
E' anche importante notare che soltanto le dipendenze di <c>RDEPEND</c> sono
soddisfatte quando un pacchetto binario <c>.tbz2</c> viene installato; usa
questa informazione per aiutarti a scegliere le corrette dipendenze per
<c>RDEPEND</c>. Se indefinite, le impostazioni per <c>RDEPEND</c> dell'ebuild
saranno messe predefinitivamente a <c>DEPEND</c>.
</p>

<p> 
Un paccehtto deve dipendere dalle versioni più vecchie che soddisfano le
dipedenze. Se esso funziona con <c>libfoo-1.2.x</c>, non dipende da
<c>libfoo-2.x</c> solo perchè questo è quello che hai installato tu.
</p>

<p>
In generale, i pacchetti devono dipendere da <c>=libfoo-1.2*</c> invece che
da <c>&gt;=libfoo-1.2</c>. Altrimenti, le cose potrebbero cominciare a non
funzionare più quando viene introdotto <c>libfoo-2.0</c>.
</p>

<p>
La dipendenza da un pacchetto virtuale come <c>virtual/foo</c> funzionerà
soltanto con i diversi pacchetti forniti da <c>virtual/foo</c> che hanno
delle interfacce identiche. Considera <c>virtual/jdk-1.3</c> come esempio.
Alcuni pacchetti non funzionano con <c>ibm-jdk-1.3</c>  fino a quando non
funzionano con <c>sun-jdk-1.3</c>. Per questa ragione, assicurati che il tuo
pacchetto è testato con tutte le virtuali fornite prima di toglierlo dai
pacchetti mascherati. Potrebbe essere possibile fare dipendere soltanto una
parte di questi pacchetti nella virtuale piuttosto che la stessa virtuale.
</p>

</body>
</subsection>

</section>

</sections>

