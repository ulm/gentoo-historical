<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/devrel/handbook/Attic/hb-guide-eclass.xml,v 1.6 2009/01/21 23:31:42 scen Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- This document was last synched to:
cvs://gentoo/gentoo/xml/htdocs/doc/en/eclass-howto.xml :: R1.17.  -->

<sections>
<version>1.0.2</version>
<date>2006-02-02</date>

<section>
<title>Introduzione alle eclass</title>
<subsection>
<title>L'idea che sta dietro le eclass</title>
<body>

<p>
Le eclass sono moduli di codice condiviso. Sono scritte in bash, hanno la stessa
sintassi dei normali ebuild e vengono derivate ('ereditate') dagli ebuild e
altre eclass, in modo da fornire impostazioni e funzionalità predefinite
attraverso molti ebuild simili tra loro.
</p>

<p>
Questo serve per assicurare il massimo riutilizzo del codice tra ebuild simili.
</p>

<p>
Questo capitolo mostra brevemente come scrivere una eclass incorporando i
trucchi standard e le tecniche usate nelle eclass esistenti. Il secondo è una
panoramica dell'eclass di kde. Il terzo spiega come scrivere un ebuild KDE
usando il gruppo di eclass di kde.
</p>

</body>
</subsection>
<subsection>
<title>Esempio di una semplice eclass</title>
<body>

<p>
Questa è una eclass fittizia sourceforge.eclass, progettata per fornire
l'homepage e l'ubicazione dei download per i progetti presenti su
sourceforge.net:
</p>

<pre caption="Esempio: sourceforge.eclass">
# Copyright 2009 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later
# Author Dan Armak
# &lt;danarmak@gentoo.org&gt; &#36;Header: &#36;

# questa eclass imposta ${HOMEPAGE} e ${SRC_URI} ai valori standard per
# sourceforge.net - progetti ospitati.

HOMEPAGE="http://${PN}.sourceforge.net/"
SRC_URI="http://download.sourceforge.net/${PN}/${P}.tar.gz"
</pre>

<p>
Le prime quattro linee sono intestazioni (headers) proprio come quelle presenti
in ogni ebuild. Le seguenti due linee sono una breve descrizione dell'eclass. Il
resto del codice fa il lavoro effettivo - impostando SRC_URI e HOMEPAGE.
</p>

<p>
la maggior parte delle eclass va oltre l'impostare variabili e fornire funzioni
d'aiuto; esse contengono delle versioni predefinite di funzioni speciali degli
ebuild (src_unpack, src_compile e così via). Prima di scrivere una funzione
predefinita in una eclass, bisogna essere a conoscenza delle funzioni
predefinite già contenute in ebuild.sh, che saranno quelle che verranno eseguite
se non viene messa alcuna funzione nel proprio ebuild (non sempre tramite una
eclass); è usata spesso la predefinita src_unpack(). Se non è ancora fatto,
guardare le implementazioni predefinite in ebuild.sh.
</p>

<p>
Questo è tutto quello che serve sapere per scrivere delle eclass. Posizionare la
propria nuova eclass in <path>${PORTDIR}/eclass/</path>, e inserire questa linea
all'inizio del proprio ebuild:
</p>

<pre caption="Come ereditare le eclass">
inherit sourceforge
</pre>

<p>
A questo punto il contenuto delle eclass verrà derivato. Ricordarsi che tutte le
variabili o funzioni definite nella eclass possono essere sovrascritte
nell'ebuild, il cui codice viene eseguito dopo qualsiasi eclass. Pertanto,
bisogna cercare di mettere nelle proprie eclass il maggior numero possibile di
impostazioni predefinite e codice comune. Qualsiasi impostazione non standard o
modifica può quindi essere messa negli ebuild.
</p>

<p>
Si possono ereditare più eclass contemporaneamente tramite la sintassi:
</p>

<pre caption="Ereditare eclass multiple">
inherit eclass1 eclass2 [...]
</pre>

<p>
...ma guardare bene il loro ordine! Ricordarsi che le eclass possono ereditarsi
una dall'altra e sovrascriversi a vicenda le relative impostazione, per questo
bisogna fare molta attenzione quando si ha a che fare con eclass multiple, le
quali potrebbero influenzarsi l'una con l'altra.
</p>

<p>
Ora verranno spiegati tutti i trucchi nella scrittura delle eclass, prima di
passare alle attuali eclass in portage.
</p>

</body>
</subsection>
<subsection>
<title>inherit()</title>
<body>

<p>
Questa funzione risiede in ebuild.sh e gestisce l'ereditarietà (derivazione)
delle eclass. Viene invocata con una lista di nomi di eclass da ereditare:
inherit &lt;eclass1&gt; [eclass2 eclass3...].
</p>

<p>
Oltre all'effettiva derivazione dei file delle eclass, questa funziona imposta
le variabili ECLASS e INHERITED che vengono usate da portage per memorizzare i
gli orari (timestamp) di modifica delle eclass. La variabile INHERITED potrebbe
essere d'aiuto nella scrittura delle eclass: essa contiene una lista di tutte le
eclass ereditate (derivate) fino a quel punto, in ordine. In questo modo una
eclass può usare questa variabile per determinare se essa stessa viene chiamata
o meno da un'altra eclass.
</p>

</body>
</subsection>
<subsection>
<title>EXPORT_FUNCTIONS</title>
<body>

<p>
Delle buone funzioni predefinite di un'eclass possono essere spesso usate così
come sono; in questo modo l'ebuild conterrà pochissimo codice (che è una buona
cosa). Qualche volta, ciononostante, l'eclass non fa esattamente quello di cui
si ha bisogno. In questo caso si può scrivere una nuova funzione nel proprio
ebuild, sovrascrivendo la funzione definita nell'eclass. tuttavia questo
minimizzerà i benefici del riutilizzo del codice. Per cui si proverà ad
'estendere' la funzione dell'eclass.
</p>

<p>
Si supponga di voler estendere src_compile(). Si può scrivere una definizione
per src_compile() nel proprio ebuild, che includerà solo le parti mancanti della
funzione src_compile() presente nell'eclass. A questo punto si invocherà la
funzione src_compile() dell'eclass dall'interno del codice della propria
funzione personalizzata.
</p>

<p>
Tuttavia, se si crea una nuova funzione chiamata src_compile(), bash si
dimenticherà quella vecchia e non sarà più capace di chiamarla! Qui entra in
gioco la macro EXPORT_FUNCTIONS.
</p>

<p>
Ora verrà analizzato momentaneamente un altro problema. Si supponga che entrambe
le eclass foo.eclass e bar.eclass definiscano src_compile(). Ereditando sia foo
che bar si otterrà una diversa funzione src_compile() in base all'ordine in cui
esse vengono ereditate. Questo è normale, in quanto si suppone di tener conto
dell'ordine dell'ereditarietà. Ma si potrebbe voler invocare entrambe le
dichiarazioni di src_compile() esplicitamente.
</p>

<p>
Così, ogni eclass aggiunge un prefisso alle funzioni che definisce . Per
esempio, foo.eclass definirà una funzione chiamata foo_src_compile(), e
rispettivamente bar.eclass definirà bar-src_compile(). In questo modo, l'ebuild
può chiamare entrambe le funzioni sapendo cosa otterrà.
</p>

<p>
Tuttavia, si può voler disporre di una qualche funzione predefinita chiamata
semplicemente src_compile(), altrimenti l'ebuild dovrà definirne una. La macro
EXPORT_FUCTIONS risolve sia questo problema che quello presentato prima.
</p>

<pre caption="EXPORT_FUNCTIONS() (da ebuild.sh)">
EXPORT_FUNCTIONS() {
    while [ "$1" ]; do
        eval "$1() { ${ECLASS}_$1 ; }" &gt; /dev/null
        shift
    done
}
</pre>

<p>
La funzione inherit() imposta ${ECLASS} con il nome dell'eclass prima di
derivarla. Alla fine l'eclass chiama EXPORT_FUNCTIONS(), passando come parametri
la lista delle funzioni predefinite che fornisce. Per esempio, se si chiama
</p>

<pre caption="Esempio di chiamata a EXPORT_FUNCTIONS">
EXPORT_FUNCTIONS src_compile src_install
</pre>

<p>
allora EXPORT_FUNCTIONS chiamerà eval() sulla seguente stringa:
</p>

<pre caption="Risultato di EXPORT_FUNCTIONS">
src_compile() { foo_src_compile ; }
src_install() { foo_src_install ; }
</pre>

<p>
Ora, qualsivoglia eclass venga ereditato per ultimo, definirà la funzione
predefinita src_compile(), ma, se necessario, entrambe le funzioni potranno
essere chiamate direttamente dall'ebuild.
</p>

<p>
È possibile anche estendere la funzione predefinita src_compile() chiamando la
funzione dell'eclass dall'interno della propria funzione. In questo modo si
dovrà usare il nome completo della funzione predefinita foo_src_compile. Un
esempio:
</p>

<pre caption="Estendere le funzioni predefinite dell'eclass nel proprio build">
#in foo.eclass:
foo_src_compile() {
        [qui codice predefinito]
}

EXPORT_FUNCTIONS src_compile

#fine codice eclass

#in un ebuild:

inherit foo

src_compile() {
        [qui codice personalizzato]
        foo_src_compile
        [altro codice personalizzato]
}
</pre>

</body>
</subsection>
<subsection>
<title>Sezioni delle funzioni</title>
<body>

<p>
A volte, estendere le funzioni predefinite eseguendo il codice prima e dopo non
è abbastanza flessibile. Quando  si ha a che fare con funzioni lunghe e
complesse, spesso ci sarà la necessità di voler eseguire il proprio codice
personalizzato all'interno di queste funzioni.
</p>

<p>
Le sezioni delle funzioni provvedono a fornire una maggiore flessibilità,
richiesta in questo caso. Esse suddividono le funzioni in sezioni e permettono
di eseguire il codice tra due sezioni qualsiasi.
</p>

<p>
L'implementazione è semplice. Viene presa come esempio la funzione src_compile()
da base.eclass. (Nota: non esiste più, ma è un buon esempio :-) Essa è fatta
così:
</p>

<pre caption="Esempio da base.eclass di origine">
base_src_compile() {
    econf || die
    emake || die
}
</pre>

<p>
Qui c'è la stessa funzione, divisa in sezioni:
</p>

<pre caption="La stessa funzione divisa in sezioni.">
base_src_compile() {

    [ -z "$1" ] &amp;&amp; base_src_compile all

    while [ "$1" ]; do
        case $1 in
            configure)
                econf || die;;
            make)
                emake || die;;
            all)
                base_src_compile configure make;;
        esac
    shift
    done

}
</pre>

<p>
Il codice è stato suddiviso in due sezioni: <c>configure</c> e <c>make</c>.
In questo semplice esempio, esse corrispondono ai due comandi presenti nella
funzione originale.
</p>

<p>
Nel centro della nuova funzione c'è un blocco while;case...esac;shift;done.
Questo blocco esegue un controllo di corrispondenza dei parametri della funzione
con i nomi di sezioni definiti ed esegue le corrispondenti linee di codice.
</p>

<p>
Il caso speciale <c>all</c> chiama la stessa funzione ricorsivamente con una
lista ordinata di sezioni. È compito dello sviluppatore mantenere questa lista.
</p>

<p>
La prima linea del blocco dice che una chiamata senza parametri dovrà essere
trattata come una chiamata con il singolo parametro <c>all</c>. Come si può
notare, questa funzione è molto ricorsiva.  Notare, però, che anche la chiamata
<c>base_src_compile configure all make</c> è legale; essa eseguirà
<c>base_src_compile configure configure make make</c>.
</p>

<p>
A questo punto nel proprio ebuild (o eclass) che eredita da base.eclass, si avrà
la funzione fittizia src_compile, la quale chiamerà base_src_compile senza
parametri. Questo fa eseguire base_src_compile <e>all</e>, che significa
eseguire ogni sezione. Si può lasciarla così com'è. Se si vuole estenderla, è
possibile definire una nuova funzione src_compile e chiamare base_src_compile
una sezione alla volta:
</p>

<pre caption="Usare la funzione src_compile() sezionata">
src_compile() {
    esegui_mio_codice1
    base_src_compile configure
    esegui_mio_codice2
    base_src_compile make
    esegui_mio_codice3
}
</pre>

<p>
Come si può vedere, le sezioni aggiungono flessibilità in quanto ora è possibile
inserire codice tra le due sezioni, come anche poterle eseguire in un ordine
diverso oppure eseguire solo alcune delle sezioni fornite. Questo permette un
maggiore riutilizzo complessivo del codice.
</p>

</body>
</subsection>
<subsection>
<title>Le funzioni debug-print-*</title>
<body>

<p>
Ci sono molte altre funzioni fornite da ebuild.sh. Esse aggiungono alle eclass
un output prolisso in fase di debug, per permettere di seguire più facilmente la
loro esecuzione senza dover leggere i lunghi messaggi forniti dal metodo di
debug di bash. Tutte le eclass dell'autore di questa guida usano molto spesso
queste funzioni.
</p>

<p>
debug-print() stampa semplicemente tutti i suoi parametri con il prefisso
'debug:'. Viene chiamata ogni volta che c'è qualcosa di interessante da mettere
nel log del debug.
</p>

<p>
debug-print-function() stampa 'debug: entering function $1, parameters: $2
[$3 ....]. Viene chiamata all'inizio di una funzione.
</p>

<p>
debug-print-section() mostra 'debug: now in section $1'. Viene chiamata
all'inizio di una sezione di funzione.
</p>

<p>
L'output di debug, normalmente va in ${T}/eclass-debug.log. È possibile
impostare la variabile d'ambiente ECLASS_DEBUG_OUTPUT (in make.globals/conf o
nell'ambiente) e l'output sarà inviato pure lì. Si può anche impostarla con lo
speciale valore 'on', in modo da mostrare l'output insieme a tutti gli altri
messaggi di emerge.
</p>

<p>
Ecco come aggiungere delle tipiche dichiarazioni di output di debug alla
precedente funzione di esempio:
</p>

<pre caption="Aggiungere dichiarazioni di debug">
base_src_compile() {

    debug-print function
    [ -z "$1" ] &amp;&amp; base_src_compile all

    while [ "$1" ]; do
        case $1 in
            configure)
                debug-print-section configure
                ./configure || die;;
            make)
                debug-print-section make
                make || die;;
            all)
                debug-print-section all
                base_src_compile configure make;;
        esac
    shift
    done

    debug-print "${FUNCNAME}: il risultato è ${RESULT}"
}
</pre>

<p>
${FUNCNAME} è una varibile incorporata in bash che restituisce il nome corrente
delle funzione.
</p>

</body>
</subsection>
<!-- <subsection>
<title>newdepend()</title>
<body>

<p>This ebuild.sh function simply adds all its parameters to both DEPEND and
RDEPEND, saving you the trouble of writing and maintaining two lists of
dependencies.
</p>

<p>
If called with a special parameter, it adds predefined dependencies. I don't
think this is very elegant (anymore), I rather prefer explicit dependancies now;
so you can consider this slightly deprecated ;-)
</p>

<p>
These special parameters exist as of now:
</p>
<p>newdepend /autotools: add sys-devel/autoconf sys-devel/automake
sys-devel/make to DEPEND (but not RDEPEND).
</p>

<p>
newdepend /c: add virtual/glibc sys-devel/ld.so to both DEPEND and RDEPEND.
Also, add sys-devel/gcc to DEPEND.
</p>

</body>
</subsection> -->
</section>
<section>
<title>Eclass esistenti</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Molte eclass sono semplici, basta leggerle e dare un'occhiata ad un paio di
ebuild che la usano per capire il loro funzionamento. Inoltre, molte eclass sono
anche ben commentate, per cui la cosa migliore è leggerle.
</p>

<p>
Questo capitolo documenta l'insieme delle relazioni tra le eclass kde*.
</p>

</body>
</subsection>
<subsection>
<title>base.eclass</title>
<body>

<p>
Questa eclass definisce alcune variabili e funzioni predefinite, simili a quelle
presenti nativamente in un ebuild che non eredita nessuna eclass (e quindi
definite in ebuild.sh). Probabilmente, non verrà usata direttamente, ma
piuttosto attraverso una eclass di kde, che la eredita.
</p>

<p>
Un piccola parte interessante delle funzionalità che essa fornisce è la capacità
di autopatch. Se nel proprio ebuild, che utilizza base_src_unpack() (o
kde_src_unpack()), il contenuto della variabile PATCHES viene impostato con una
lista di file, i sorgenti verranno patchati con questi stessi file. Le patch
hanno bisogno di funzionare con -p0 quando vengono eseguite da ${S}.
</p>

<p>
Notare che è possibile impostare PATCHES senza definire una funzione personale
src_unpack() nel proprio ebuild!
</p>

<p>
La nuova funzione epatch() da eutils.eclass è ancora più potente - essa supporta
patch compresse, directory e serie di patch, e individua automaticamente il
livello delle patch - e un giorno gli sviluppatori hanno intenzione di far usare
ad autopatch questa comoda funzione.
</p>

<p>
Notare che la sezione <c>patch</c> in base_src_unpack() è deprecata e sarà
rimossa a breve. Se viene trovato un ebuild che la utilizza, esso necessiterà di
essere convertito al metodo di <c>autopatch.</c>
</p>

</body>
</subsection>
<subsection>
<title>cvs.eclass</title>
<body>

<p>
Questa eclass fornisce la funzionalità necessaria per creare ebuild cvs 'live'.
Gli ebuild vanno a prendere i sorgenti da uno specifico server cvs nel momento
dell'estrazione, di conseguenza ottenendo sempre i bug e le correzioni più
recenti dal ramo di sviluppo originale.
</p>

<p>
Tuttavia il supporto necessario (es. gestione delle versioni) per gli ebuild cvs
live non è ancora stato aggiunto al portage. Essi possono lavorare con questa
eclass, ma non è conveniente in molti casi. Pensarci bene prima di creare un
ebuild cvs live; probabilmente un normale snapshot cvs è la soluzione migliore.
Se si intende aggiungere un ebuild di questo tipo a portage, informarsi sulle
guide linea degli ebuild del cvs nella guida per gli sviluppatori.
</p>

<p>
Prima di ereditare cvs.eclass, impostare qualunque variabile non predefinita
necessaria (almeno l'indirizzo del server e il nome del modulo). Guardare la
lista delle impostazioni configurabili e dei valori predefiniti all'inizio di
cvs.eclass, marcati come ebuild-configurable settings'.
</p>

<p>
Dopo di ciò, le cose sono più o meno automatiche. Viene fornito un
cvs_src_unpack() (senza sezioni). Per saperne di più, leggere il contenuto
stesso dell'eclass.
</p>

</body>
</subsection>
<subsection>
<title>kde-functions.eclass</title>
<body>

<p>
Questa eclass contiene tutte le funzioni di aiuto inerenti a KDE. Alcune di loro
non verranno mai usate direttamente in un ebuild; pertanto non verranno
menzionate qui, e comunque sono essere ben commentate nei sorgenti.
</p>

<p>
Notare che con 'funzioni d'aiuto' s'intende qualsiasi funzione che non sia una
funzione speciale degli ebuild (src_unpack(),...). Tutte le eclass di kde
contengono queste funzioni 'speciali' ereditate da kde-functions.
</p>

<p>
Il solo codice esterno a qualsiasi funzione in kde-functions.eclass (che viene
quindi eseguito in fase di derivazione) è un blocco che determina se l'ebuild
corrente fa parte di kde-base o meno. Se lo è, sarà impostata KDEBASE=true.
Questa variabile, è usata in diversi test logici altrove ed è ovviamente comodo
avere un test centralizzato per essa.
</p>

<p>
<b>Lo schema corrente di multi-kdedir</b>
</p>

<p>
Una breve spiegazione su come Gentoo gestisce più versioni di KDE:
</p>

<p>
Un'installazione di KDE (per l'esattezza cose provenienti da kde-base) si trova
in /usr/kde/${versione-maggiore}.${versione-minore}. Così, per esempio, KDE
3.1.x si trova in /usr/kde/3.1. Tuttavia, questo schema è stato stabilito dopo
il rilascio di KDE 3.0, e così le vecchie versioni si trovano in una posizione
non standard: KDE 3.0.x si trova in /usr/kde/3 (e non /usr/kde/3.0) e KDE 2.2.2
(la sola versione 2.x che c'è) si trova in /usr/kde/2. L'ebuild del cvs viene
mantenuto installato in /usr/kde/cvs.
</p>

<p>
Ogni numero di KDE con diverse versioni minori possono quindi coesistere. I
pacchetti kde-base hanno diversi SLOT di maggiore.minore (per esempio 3.0, 3.1).
</p>

<p>
Da quando si presume che le versioni di QT siano completamente retrocompatibili
tra versioni minori, ci sarà solamente unìinstallazione per ciascuna delle
versioni maggiori e con uno slot differente, residenti in
/usr/qt/$versione_maggiore.
</p>

<p>
Un ebuild che non fa parte di kde-base è sempre installato in /usr. Il pacchetto
kde-env mette KDEDIRS=/usr in env.d, permettendo a queste applicazioni di essere
eseguite correttamente. L'applicazione viene compilata e collegata all'ultima
versione trovata delle librerie di KDE; l'eclass controlla la posizione standard
in ordine discendente - /usr/kde/cvs, poi /usr/kde/3.1, poi /usr/kde/3. (Gli
ebuild di kde-base sono sempre collegati alle kdelibs della propria versione).
Questo dipende sicuramente anche dal parametro dato da need-kde() (vedi sotto).
</p>

<p>
Ci sono molte variabili speciali che si possono impostare per cambiare le
impostazioni predefinite del sistema. Il loro primo uso è per compilare un
ebuild con una versione specifica di KDE installata per test, ma è anche
possibile usare queste variabili per installare KDE in una posizione non
standard, così si avranno, per esempio, entrambi KDE 3.0.1 e 3.0.2 installati
fianco a fianco. Questo, inoltre, è molto più utile per il test e lo sviluppo.
</p>

<p>
Tutte le applicazioni di KDE (base e non base) saranno installate in
${KDEPREFIX}, se impostato. Esso sovrascrive tutta l'altra logica nelle eclass.
</p>

<p>
Un'applicazione di KDE (sia facente parte di kde-base, sia non) proverà ad
essere collegata alle kdelibs installate in ${KDELIBSDIR}, se impostata. Se
questo fallisce, essa ripiegherà sulla logica standard di ricercare la posizione
delle kdelibs più recenti (o all'appropriata versione di kde-base).
</p>

<p>
<b>need-kde(), need-qt(), set-kdedir(), set-qtdir()</b>
</p>

<p>
kde-functions.eclass forniscono due paia di funzioni: need-kde(), need-qt() e
set-kdedir(), set-qtdir(). Queste funzioni gestiscono i dettagli di diverse
installazioni di KDE e QT.
</p>

<p>
La funzione need-kde() è chiamata con un parametro che è il numero minimo di
versione di kdelibs richiesta. Essa aggiunge le dipendenze opportune a DEPEND,
RDEPEND e chiama la funzione set-kdedir(). Se non vengono passati parametri,
verrà usata una versione di numero 0 (zero), il che significa che qualsiasi
versione soddisferà la dipendenza. need-kde() chiama anche need-autoconf() e
need-automake() con i parametri corretti per questa versione di KDE.
</p>

<p>
Poi la funzione set-kdedir() determina il prefisso dell'installazione e la
posizione di kdelibs che il proprio ebuild dovrebbe usare. Questi valori vengono
passati all'utente rispettivamente in ${PREFIX} e ${KDEDIR}, (e sono
automaticamente gestiti in kde.eclass). Notare che nessun ebuild dovrebbe mai
impostare direttamente ${KDEPREFIX} o ${KDELIBSDIR}!
</p>

<p>
need-kde() inoltre recupera da una tabella la versione minima richiesta di QT
per questa versione di kdelibs. Quindi chiama need-qt() con questa versione. Un
ebuild di un'applicazione dipendente solo da qt (per esempio non-kde)
generalmente chiama direttamente need-qt, scavalcando need-kde.
</p>

<p>
La funzione need-qt() aggiunge le versioni richieste di QT a DEPEND, RDEPEND e
chiama set-qtdir() con esse. La funzione set-qtdir() imposta QTDIR come
posizione predefinita di questa versione delle QT. Diversamente da set-kdedir(),
set-qtdir() non controlla effettivamente se c'è installata una versione di QT.
</p>

<p>
need-kde() (o need-qt()) necessita di essere chiamata dalla sezione principale
dell'ebuild (per esempio, non da una funzione), cosicché ogni cambiamento a
DEPEND e RDEPEND influenzi emerge.
</p>

<p>
<b>need-autoconf(), need-automake()</b>
</p>

<p>
Queste funzioni impostano l'ambiente necessario per fare funzionare le versioni
richieste di autoconf o automake. Esse inoltre deallocano tutte le variabili
di questo tipo impostate precedentemente. Per esempio, chiamando
'need-automake 1.4' verrà impostato NEED_AUTOMAKE_1_4=1 e deallocate tutte le
altre variabili WANT_AUTOMAKE*. Per maggiori informazioni, guardare il codice
delle funzioni e i commenti all'inizio di /usr/bin/auto{conf,male} (su sistemi
Gentoo).
</p>

<p>
<b>kde_sandbox_patch()</b>
</p>

<p>
Alcuni makefile di KDE sono malfunzionanti. Essi eseguono un chmod o un chown
sui file in PREFIX al momento dell'installazione, ma non rispettano DESTDIR
(${D}). Per esempio, durante l'installazione, copiano correttamente un file in
${DESTDIR}/${PREFIX}/path/foo, ma poi tentano di effettuare il comando chmod+x
sul file ${PREFIX}/path/foo sul filesystem reale che potrebbe anche non
esistere. Se questo tentativo si dovesse verificare, la sandbox previene questa
operazione.
</p>

<p>
Questa funzione esegue un sed generico sui makefile per sistemare tutti i casi
conosciuti del problema. Viene chiamata passando come parametri le directory che
devono essere processate e processa i Makefile, Makefile.in e Makefile.am in
queste directory. Per esempio:
</p>

<pre caption = "Processo">
src_unpack() {
    base_src_unpack
    kde_sandbox_patch ${S}/dir1 ${S}/dir2/dir3
}
</pre>

<p>
<b>kde_remove_flag()</b>
</p>

<p>
Questa funzione è usata per eliminare le flag di compilazione conosciute
come causa di malfunzionante del pacchetto. Si chiama questa funzione dopo
l'estrazione passando come parametri la sottodirectory di ${S} nella quale
lavorare e il nome del flag da rimuovere. Notare che la funzione non è
ricorsiva. Esempio: "kde_remove_flag foodir/barfoo -fomit-frame-pointer".
</p>

<p>
<b>kde_remove_dir() e ${KDE_REMOVE_DIR}</b>
</p>

<p>
Questa funzione rimuove la specifica sottodirectory dalla compilazione. Essa la
rimuove e rimuove tutte le sue referenze dai file delle sottodirectory,da
 configure e dai makefile. Notare che al momento funziona soltanto nelle
sottodirectory di ${S}, non funziona nel secondo livello di sottodirectory. La
si può invocare con una lista di sottodirectory da eliminare; essa lavora a
turno con ogni parametro.
</p>

<p>
È possibile chiamarla direttamente ma per evitare di definire una funzione
src_unpack() personalizzata è possibile impostare KDE_REMOVE_DIR con una lista
di sottodirectory da eliminare. kde_src_unpack() chiamerà 'kde_remove_dir
${KDE_REMOVE_DIR}' dopo l'estrazione. Come si può vedere, ci si è spinti molto
avanti per permettere di definire una funzione extra in un ebuild, questo per
rendere gli ebuild più puliti e leggibili.
</p>

</body>
</subsection>
<subsection>
<title>kde.eclass</title>
<body>

<p>
Questa è l'eclass principale e centrale di KDE. Contiene la maggior parte del
codice relativo a KDE. Tutti gli ebuild di KDE, in un modo o nell'altro la
ereditano. L'eclass di kde eredita le funzioni di base e kde-functions.
</p>

<p>
Come con le altre eclass, leggerla per vedere cosa fa. La maggior parte del
codice è molto chiaro. Qui c'è un breve riepilogo:
</p>

<p>
La sezione globale dell'eclass (per esempio, quella che viene eseguita quando la
si eredita) aggiunge le corrette dipendenze su kde-env, automake, autoconf, male
e perl (quest'ultimo è usato dalle configurazioni standard degli script per la
generazione veloce dei makefile). Imposta inoltre in modo predefinito SLOT="0".
</p>

<p>
kde_src_unpack() di base chiama solamente base_src_unpack(), passando tutti i
parametri (per esempio sezioni da eseguire). Dopo questo, aggiunge elementi
specifici di kde. "Tocca" (cambiando la data e ora di modifica) tutti i file
.ui nel codice estratto per rigenerare tutti i vecchi file .cpp e .h. Chiama
anche kde_remove_dir() con ${KDE_REMOVE_DIR} se questa varibile è impostata
(guardare più sopra nella sezione su kde-functions).
</p>

<p>
Anche kde_src_compile() possiede molte correzioni. Una di esse esporta
kde_widgetdir="${KDEDIR}/lib/kde3/plugins/designer" per raggirare un bug
presente in vecchi acinclude.m4.in. Un altro è quello di impostare
HOME="${T}/fakehome", così facendo gli accessi a ${HOME}/.kde e $HOME/.qt non
verranno interrotti dalla sandbox, e non toccheranno l'home directory
dell'utente. Questo è un bug (o mancanza) di uic, che tenta sempre di accedere
ai file di configurazione di queste directory.
</p>

<p>
kde_src_compile() possiede diverse sezioni. <c>myconf</c> aggiunge a ${myconf} i
parametri predefiniti dello script di configurazione di kde, come
--prefix=${PREFIX} (ricordarsi che ${PREFIX} è impostato da set-kdedir()). È
possibile aggiungere i propri valori personali a ${myconf} sia prima che dopo
questa sezione; ricordarsi solo di non sovrascrivere i vecchi valori, perchè gli
utenti possono pensare di impostare $myconf nella shell e in questo modo
aggiungere qualcosa ai parametri configurati usati dall'ebuild.
</p>

<p>
La sezione <c>configure</c> esegue lo script di configurazione in ${S},
passandole ${myconf}. Se lo script di configurazione non esiste, proverà a
generarlo eseguendo male -f Makefile.cvs o male -f admin/Makefile.common. In
questo modo, questo passo della compilazione (che è necessario per gli snapshot
del cvs, o per gli ebuild che applicano patch a file come configure.in) viene
anche eseguito automaticamente.
</p>

<p>
La sezione <c>male</c> esegue semplicemente emake || die. Per finire, c'è una
sezione <c>all</c> che esegue tutto quando appena spiegato.
</p>

<p>
Infine, kde_src_install() possiede una sezione <c>male</c> che esegue male
install, e una sezione <c>dodoc</c> che esegue dodoc su alcuni nomi standard di
documenti in ${S}, come README e COPYING.
</p>

</body>
</subsection>
<subsection>
<title>kde-base.eclass</title>
<body>

<p>
Questa eclass è ora deprecata, l'ebuild deve usare al suo posto "inherit kde".
</p>

</body>
</subsection>
<subsection>
<title>kde-dist.eclass</title>
<body>

<p>
Questa eclass è per il cuore dei pacchetti di distribuzione di kde in
kde-base/*. Eredita kde.
</p>

<p>
Imposta correttamente DESCRIPTION e HOMEPAGE e chiama need-kde ${PV}. Il più
semplice, piccolo pacchetto kde-base/ (per esempio kdetoys) non necessita di
fare nessun cambiamento ad essa, la maggior parte di essi aggiunge soltanto
dipendenze e patch.
</p>

</body>
</subsection>
<subsection>
<title>kde-i18n.eclass</title>
<body>

<p>
Questa eclass è per i pacchetti kde-i18n-*. Infatti, tutti gli ebuild di
kde-i18n sono completamente identici per cui tutto quello che devono
fare è ereditare da questa eclass. Le loro variabili ${P}, ${P}, ${PV} fanno il
resto.
</p>

</body>
</subsection>
<subsection>
<title>kde.org.eclass</title>
<body>

<p>
Questa eclass è anch'essa deprecata, e tutto il codice è stato spostato in
kde-dist.eclass.
</p>

</body>
</subsection>
<subsection>
<title>koffice-i18n.eclass</title>
<body>

<p>
Questa eclass è pensata per i pacchetti koffice-i18n-* ed è molto simile a
kde-i18n.eclass. Anche qui, tutti gli ebuild di kde-i18n sono completamente
identici per cui tutto quello che devono fare è ereditare da questa eclass.
</p>

</body>
</subsection>
<subsection>
<title>kde-source.eclass</title>
<body>

<p>
Questa eclass lavora al di sopra di cvs.eclass, aggiungendo alcune funzionalità
specifiche di kde. Per esempio, recupera automaticamente la directoy admin/ dal
modulo kde-common del cvs di kde. Per saperne di più, incluse le impostazioni
specifiche per il cvs di kde che si possono passare, leggere l'eclass.
</p>

</body>
</subsection>
</section>
<section>
<title>Scrittura di ebuild per KDE</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Questo capitolo spiega come scrivere ebuild standard per KDE. Tutto quanto è
detto qui è un ripasso di tutte le informazioni sulle eclass spiegate in
precedenza. Se si è in dubbio, guardare gli altri ebuild, le altre eclass,
oppure chiedere.
</p>

</body>
</subsection>
<subsection>
<title>Un tipico ebuild di KDE</title>
<body>

<p>
Il codice sottostante dovrebbe essere chiaro dopo avere letto questa guida:
</p>

<pre caption = "Un semplice ebuild di KDE, #1">
&lt;L'intestazione va qui...&gt;
inherit kde
</pre>

<p>
Alcuni ebuild terminano proprio qui. Altri necessitano di alcune
personalizzazioni.
</p>

<p>
Il prossimo passo serve per aggiungere delle dipendenze extra. Ricordarsi di
estendere *sempre* le variabili, non sovrascriverle mai!
</p>

<p>
Siccome lo scopo è quello di evitare la definizione di funzioni ebuild
personalizzate a meno che non ci sia altra scelta, vengono usate tutte le
impostazioni possibili e chiamate tutte le possibili funzioni d'aiuto,
direttamente dalla sezione principale dell'ebuild. Ricordarsi però che ci sono
limitazioni sul codice nella sezione principale; per esempio, essa non deve
produrre nessun output (l'output di debug-print() probabilmente non conta).
</p>

<pre caption="Un semplice ebuild di KDE, #2: aggiungere dipendenze extra">
DEPEND="foo/bar"
RDEPEND="bar/foo"
</pre>

<p>
Si vogliono anche aggiungere alcuni argomenti extra a myconf, che vengono
passati allo script configure (assumendo di usare la sezione di configurazione
kde_src_compile):
</p>

<pre caption="Un semplice ebuild di KDE, #4: passare argomenti alla
configurazione" >
myconf="$myconf --with-foobar"
</pre>

<p>
C'è anche una patch da aggiungere. Se può essere applicata usando -p0 in ${S},
si può usare la sezione <c>autopatch</c> di base_src_unpack. Ricordarsi che
kde_src_unpack() chiama base_src_unpack() passando tutti i parametri che gli
vengono dati.
</p>

<pre caption="Un semplice ebuild di KDE, #5: autopatching">
PATCHES="$FILESDIR/$P-myfix.diff"
</pre>

<p>
Infine si vuole estendere src_install() per installare della documentazione:
</p>

<pre caption="Un semplice ebuild di KDE, #6: estendere src_install()">
src_unpack() {
    kde_src_install
    dodoc $S/doc/*
}
</pre>

<p>
Questo è l'ebuild creato in questo esempio:
</p>

<pre caption="Un semplice ebuild di KDE - codice completo">
&lt;L'intestazione va qui...&gt;
inherit kde

# aggiungere le dipendenze
DEPEND="foo/bar"
RDEPEND="bar/foo"

# abilitare sempre foobar
myconf="${myconf} --with-foobar"

# correzione di un terribile bug
PATCHES="${FILESDIR}/${P}-myfix.diff"

src_unpack() {
    kde_src_install
    # installare alcuna documentazione extra non inclusa nel target di male
    # install
    dodoc ${S}/doc/*
}
</pre>

</body>
</subsection>
<subsection>
<title>Un tipico ebuild con funzionalità KDE opzionali</title>
<body>

<p>
Quando si aggiungono funzionalità (eclass) kde ad un ebuild esistente, basta
anteporre <c>use kde &amp;&amp;</c> ad ogni linea specifica per kde, oppure
creare interi blocchi <c>if [ -n "`use kde`" ]; then; fi</c>.
</p>

<p>
Alla sezione generale, aggiungere il codice seguente (solo se la USE kde è
impostata, chiaramente):
</p>

<pre caption="Supporto opzionale per KDE - sezione principale dell'ebuild">
inherit kde-functions

# Questo aggiungerà kdelibs, kde-env alla stringa delle dipendenze e imposta
# ${KDEDIR} con il valore corretto:

need-kde ${version} # versione minima di kde richiesta dalla propria applicazione

# Aggiunge tutto il resto di cui hai bisogno per il supporto di kde:
use kde &amp;&amp; myconf="${myconf} --with-my-parameter"
</pre>

<p>
A questo punto chiedere alla propria applicazione di cercare KDE nelle
impostazioni di ${KDEDIR} che sarà disponibile dopo aver chiamato need-kde(). Se
non si vuole che la dipendenza a kdelibs sia aggiunta, chiamare set-kdedir() al
posto di need-kde().
</p>

</body>
</subsection>
</section>
</sections>
