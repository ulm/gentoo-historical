<?xml version='1.0' encoding='UTF-8'?> <!DOCTYPE sections SYSTEM
"/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- This document was last synched to:
cvs://gentoo/gentoo/xml/htdocs/doc/en/eclass-howto.xml :: R1.17.  -->

<sections>
<section>
<title>Introduzione alle eclasses</title>
<subsection>
<title>L'idea che sta dietro le eclasses</title> <body>

<p>
Le eclasses sono moduli di codice condiviso. Sono scritte in bash, hanno la
stessa sintassi dei normali ebuild e prendono origine ('ereditano') dagli
ebuild e altre eclasses, in modo da fornire impostazioni predefinite e
funzionalità attraverso gli ebuild simili.
</p>

<p>
Questo è usato per assicurare al massimo il riutilizzo del codice tra i
diversi ebuilds.
</p>

<p>
Questo capitolo mostra brevemente come scrivere una eclass incorporando i
trucchi standard e le tecniche usate nelle eclass già esistenti. Il secondo è
una panoramica dell'eclass di kde. Il terzo spiega come scrivere un ebuild
KDE usando il gruppo di eclasses di kde.
</p>

</body>
</subsection>

<subsection>
<title>Un esempio di una semplice eclass</title>
<body>

<p>
Questa è una fittizia sourceforge.eclass, designata per fornire le location
dell'homepage e download dei progetti presenti su sourceforge.net:
</p>

<pre caption = "Esempi: sourceforge.eclass">
# Copyright 2004 Gentoo Foundation Distributed under the terms of the GNU
# General Public License, v2 or later Author Dan Armak
# &lt;danarmak@gentoo.org&gt; &#36;Header: &#36;
# This eclass sets ${HOMEPAGE} and ${SRC_URI} to the standard vaules for
# sourceforge.net - hosted projects.

HOMEPAGE=&quot;http://${PN}.sourceforge.net/&quot;
SRC_URI=&quot;http://download.sourceforge.net/${PN}/${P}.tar.gz&quot;
</pre>

<p>
Le prime linee sono intestazioni (headers) proprio come quelle presenti in
ogni ebuild. Le seguenti due linee sono una breve descrizione dell'eclass. Il
resto del codice fa il lavoro effettivo - impostando SRC_URI e HOMEPAGE.
</p>

<p>
la maggior parte delle eclasses va oltre il settaggio delle variabili e
fornisce funzioni d'aiuto; contengono delle versioni predefinite di speciali
funzioni di ebuild (src_unpack, src_compile e così via). Prima di scrivere
una funzione predefinita in una eclass, devi essere a conoscenza delle
funzioni predefinite già contenute in ebuild.sh. Loro saranno quello che
verrà eseguito se non metti nessuna funzione nel tuo ebuild (non sempre
tramite una eclass); è usata spesso la predefinita src_unpack(). Se non lo
hai ancora fatto, vai a guardare le implementazioni predefinite in
ebuild.sh.
</p>

<p>
Questo è tutto quello che devi veramente conoscere per scrivere eclasses.
Metti nella tua nuova eclass in <path>${PORTDIR}/eclass/</path>, e metti
questa linea all'inizio del tuo ebuilds:
</p>

<pre caption ="Come ereditare eclasses">
inherit sourceforge
</pre>

<p>
Il contenuto delle eclasses verrà fornito a questo punto. Ricordati che tutte
le variabili o funzioni definite nella eclass potranno essere sovrascritte
nell'ebuild. Per questo, devi provare a mettere nelle tue eclasses il maggior
numero possibile di impostazioni predefinie e codice comune.  Qualsiasi
impostazione non standard o modifica potrà essere messa negli ebuild.
</p>

<p>
Oh, e puoi ereditare più eclasses allo stesso momento aggiungendo:
</p>

<pre caption = "Ereditare multiple eclasses">
inherit eclass1 eclass2 [...]
</pre>

<p>
...ma guarda il loro ordine! Ricordati, le eclasses possono ereditare e
sovrascrivere qualsiasi altra impostazione a loro volta, per questo devi fare
molta attenzione quando gestisci eclass multiple che potrebbero influenzarne
un'altre.
</p>

<p>
Ora spiegheremo tutti i trucchi della scrittura delle eclasses, prima di
mettere le eclasses nel portage.
</p>

</body>
</subsection>

<subsection>
<title>inherit()</title>
<body>

<p>
Questa funzione sta in ebuild.sh e gestisce l'ereditarietà (fonte) delle
eclasses. È chiamata con una lista di nomi di eclasses da ereditare: inherit
&lt;eclass1&gt; [eclass2 eclass3...].
</p>

<p>
Oltre al vero e proprio codice il file dell'eclass imposta le variabili
ECLASS e INHERITED che vengono usate dal portage per memorizzare i tempi
(timestamps) delle modifiche. La variabile INHERITED potrebbe essere usata
nelle scrittura delle eclasses: contiene una lista di tutte le eclasses
ereditarie (fonti) da questo punto, in ordine. In questo modo una eclass può
usarla per determinare se viene chiamata o meno da un'altra classe.
</p>

</body>
</subsection>

<subsection>
<title>EXPORT_FUNCTIONS</title>
<body>

<p>
Una buona funzione predefinita di eclass può essere spesso usata così com'è;
l'ebuild conterrà così un codice veramente breve (cosa buona). A volte,
invece, l'eclass non fa esattamente quello di cui hai bisogno. In questo caso
puoi scrivere una nuova funzione nel tuo ebuild, sovrascrivendo la funzione
che hai scritto nella tua eclass, anche se, questo minimizzerà i benefici del
riutilizzo del codice. Così, invece proviamo a 'estendere' la funzione
dell'eclass.
</p>

<p>
Supponi di voler estendere src_compile(). Puoi scrivere una definizione per
src_compile() nel tuo ebuild, il quale conterrà solo la parte mancante della
funzione src_compile() presente nell'eclass. Dovrai così chiamare la
funzione src_compile() dell'eclass dall'interno del codice della tua funzione
personale.
</p>

<p>
Quindi, se crei una nuova funzione chiamata src_compile(), bash si
dimenticherà la vecchia e non sarà più capace di chiamarla! Qui entra in
gioco la macro EXPORT_FUNCTIONS.
</p>

<p>
Ora diamo per un attimo uno sguardo ad un altro problema. Supponi che
foo.eclass e bar.eclass definiscono entrambi src_compile(). Se erediti foo e
bar avrai due differenti funzioni src_compile() a dipendenza dell'ordine in
cui le erediti. QUesto è ok; supponiamo che tieni conto dell'ordine
dell'ereditarietà. Ma potresti voler chiamare entrambi delle due funzioni
src_compile() esplicitamente.
</p>

<p>
Così, ogni eclass aggiunge alle funzioni che definisce un prefisso. Per
esempio, foo.eclass definirà una funzione chiamata foo_src_compile(), e
rispettivamente bar.eclass definirà bar-src_compile(). In questo modo,
l'ebuild può chiamare entrambi le funzioni e sapere cosa otterrà.
</p>

<p>
Tuttavia, vogliamo anche avere delle funzioni predefinite chiamate soltanto
src_compile(), altrimenti l'ebuild deve definirne una. La macro
EXPORT_FUCTIONS  risolve il problema appena spiegato e quello precedente.
</p>

<pre caption = "EXPORT_FUNCTIONS() (da ebuild.sh)"> EXPORT_FUNCTIONS() {
	while [ &quot;$1&quot; ]; do eval &quot;$1() { ${ECLASS}_$1 ; }&quot;
	&gt; /dev/null shift done }</pre>

<p>
La funzione inherit() imposta ${ECLASS} con il nome dell'eclass prima di
riferirsi a lei. Alla fine l'eclass, chiama EXPORT_FUNCTIONS(), passando come
parametri la lista delle funzioni predefinite che fornisce. Per esempio, se
chiami
</p>

<pre caption="esempio di chiamata a EXPORT_FUNCTIONS"> EXPORT_FUNCTIONS src_compile
	src_install</pre>
	
<p>
allora EXPORT_FUNCTIONS chiamerà eval() sulla seguente stringa:
</p>

<pre caption="risultato di EXPORT_FUNCTIONS"> src_compile() {
	foo_src_compile() ; } src_install() {
	foo_src_install() ; }</pre>

<p>
Ora, qualsiasi eclass eredita l'ultima, definerà la funzione predefinita
src_compile(), ma, se necessario, entrambe le funzioni potranno essere
chiamate direttamente dall'ebuild.
</p>

<p>
Puoi anche estendere la funzione predefinita src_compile() chiamando la
funzione dell'eclass dall'interno della tua funzione personale. In questo
modo dovrai usare la funzione predefinita con il nome completo
foo_src_compile. Un esempio:
</p>

<pre caption="Estendere le funzioni predefinite dell'eclass nel tuo
	ebuild"> #in foo.eclass: foo_src_compile() { [default code here] }

EXPORT_FUNCTIONS src_compile #end eclass code

#in an ebuild: inherit foo

src_compile() { [custom code here] foo_src_compile [more custom code] }</pre>

</body>
</subsection>

<subsection>
<title>Sezione delle funzioni</title>
<body>

<p>
A volte, l'estensione delle funzioni predefinite tramite il codice eseguito
all'inizio e alla fine non è sufficiente. Quando utilizzi lunghe e complesse
funzioni vorrai spesso avere il tuo codice personalizzato all'interno di
queste funzioni.
</p>

<p>
Le sezioni delle funzioni permettono una maggiore flessibilità. Esse,
suddividono le funzioni in sezioni e ti permettono di eseguire il codice tra
ogni sezione.
</p>

<p>
L'implementazione è semplice. Prendiamo come esempio la funzione
src_compile() presa da base.eclass. (Nota: non esiste più, ma è un buon
esempio :-) Essa è fatta così:
</p>

<pre caption = "Esempio dall'originale base.eclass"> base_src_compile()
	{ ./configure || die emake || die }</pre>

<p>
Qui c'è la stessa funzione, divisa in sezioni:
</p>

<pre caption =
	"The same function divided into sections."> base_src_compile() {
 
    [ -z &quot;$1&quot; ] &amp;&amp; base_src_compile all
 
    while [ &quot;$1&quot; ]; do case $1 in configure) ./configure || die;;
    make) emake || die;; all) base_src_compile configure make;; esac shift done
 
}</pre>

<p>
Il codice è stato suddiviso in due sezioni: <c>configure</c> and <c>make</c>.
Nel nostro semplice esempio, esse corrispondono ai due comandi presenti nella
funzione originale.
</p>

<p>
Nel centro della nuova funzione c'è un blocco while;case...esac;shift;done
block. Questo blocco, combina i parametri alla funzione con i nomi di sezioni
definiti ed esegue le corrispondenti linee di codice.
</p>

<p>
Il caso speciale <c>all</c> chiama la stessa funzione ricorsivamente con una
lista ordinata di sezioni. È compito dello sviluppatore di mantenere questa
lista.
</p>

<p>
La linea prima del blocco dice che una chiamata senza parametri dovrà essere
trattata come una chiamata con un singolo parametro <c>all</c>. Come vedi,
questa funzione fa diversi cicli.  Nota,però che è anche usabile la chiamata
a <c>base_src_compile configure all make</c> ; essa eseguirà
<c>base_src_compile configure configure make make</c>.
</p>

<p>
Ora, nel tuo ebuild (o eclass) che eredita da base.eclass, avrai la funzione
radice src_compile, la quale chiamerà base_src_compile senza parametri.
Questo fa eseguire base_src_compile <e>all</e>, che significa ogni sezione.
Se vuoi estenderla, puoi definire una nuova src_compile e chiamare
base_src_compile una sezione alla volta:
</p>

<pre caption =
	"Usare la funzione src_compile() sezionata"> src_compile() {
	run_my_code1 base_src_compile configure run_my_code2 base_src_compile
	make run_my_code3 }</pre>

<p>
Come puoi vedere, le sezioni aggiungono flessibilità, in modo da poter
inserire codice tra le due sezioni, e da poterle eseguire in un ordine
diverso oppure eseguire solo alcune delle sezioni. Questo permette un
maggiore riutilizzo del codice.
</p>

</body>
</subsection>

<subsection>
<title>Le funzioni debug-print-*</title>
<body>

<p>
Queste, sono diverse funzioni fornite da ebuild.sh. Esse aggiungono un output
prolisso in fase di debug, per permetterti di seguire la loro esecuzione più
facilmente senza dover leggere lunghi messaggi forniti dal metodo di debug
della bash. Tutte le mie eclass usano molto spesso queste funzioni.
</p>

<p>
debug-print() mostra semplicemente tutti i suoi parametri con il prefisso
'debug:'. Essa è chiamata ogni volta che c'è qualcosa di interessante da
mettere nel log del debug.
</p>

<p>
debug-print-function() mostra 'debug: entering function $1, parameters: $2
[$3 ....].Essa è chiamata all'inizio di una funzione.
</p>

<p>
debug-print-section() mostra 'debug: now in section $1'. Essa è chiamata
all'inizio di una sezione di funzione.
</p>

<p>
L'output del debug, normalmente va in ${T}/eclass-debug.log. Puoi impostare
la variabile d'ambiente ECLASS_DEBUG_OUTPUT (in make.globals/conf o
nell'ambiente) e l'oputput sarà inviato pure li.  Puoi anche impostare la
variabile con lo speciale valore 'on', il quale mostra l'output con tutti gli
altri messaggi di emerge.
</p>

<p>
Ora aggiungiamo dei tipici rapporti di output alla nostra funzione:
</p>

<pre caption = "Aggiungere rapporti di debug">
	base_src_compile() {
 
    debug-print function $FUNCNAME $* [ -z &quot;$1&quot; ] &amp;&amp;
    base_src_compile all
 
    while [ &quot;$1&quot; ]; do case $1 in configure) debug-print-section
    configure ./configure || die;; make) debug-print-section make make || die;;
    all) debug-print-section all base_src_compile configure make;; esac shift
    done
 
    debug-print &quot;${FUNCNAME}: result is ${RESULT}&quot; }</pre>

<p>
${FUNCNAME} è una varibile incorporata nella bash che ritorna il nome
corrente delle funzione.
</p>

</body>
</subsection> <!-- <subsection> <title>newdepend()</title> <body>

	<p>This ebuild.sh function simply adds all its parameters to both DEPEND
	and RDEPEND, saving you the trouble of writing and maintaining two lists
	of dependencies.</p>

	<p>If called with a special parameter, it adds predefined dependencies.
	I don't think this is very elegant (anymore), I rather prefer explicit
	dependancies now; so you can consider this slightly deprecated ;-)</p>
	<p>These special parameters exist as of now:</p> <p>newdepend
	/autotools: add sys-devel/autoconf sys-devel/automake sys-devel/make to
	DEPEND (but not RDEPEND).</p> <p>newdepend /c: add virtual/glibc
	sys-devel/ld.so to both DEPEND and RDEPEND. Also, add sys-devel/gcc to
	DEPEND.</p>

      </body> </subsection> -->
			
</section>
<section>
<title>Eclasses esistenti</title>

<subsection>
<title>Introduzione</title>
<body>

<p>
Molte eclasses sono semplici, e devi semplicemente leggerle e dare
un'occhiata ad un paio di ebuild che la usano per capire come lavora.
Inoltre, molte eclasses sono anche ben commentate, questo è molto meglio per
leggerle.
</p>

<p>
QUesto capitolo documenta complessivamente le relazioni tra le eclasses di
kde*.
</p>

</body>
</subsection>
<subsection>
<title>base.eclass</title>
<body>

<p>
Questa eclass definisce alcune variabili e funzioni predefinite, simili a
quelle presenti predefinitivamente in un ebuild che non eredita (che sono
definite in ebuild.sh). Probabilmente, non sei interessato ad usare
direttamente, ma piuttosto attraverso una eclass di kde, che la eredita.
</p>

<p>
Un pezzetto interessante delle funzionalità che essa fornisce è la capacità
di autopath. Se importi il contenuto della variabile PATCHES con una lista di
file nel tuo ebuild che usa base_src_unpack() (o kde_src_unpack()), il codice
sarà patchato da questi files. Le patches necessitano di lavorare con -p0
quando vengono eseguite da ${S}.
</p>

<p>
Nota che puoi impostare PATCHES senza definire una tua personale src_unpack()
nel tuo ebuild! Questo è quello che fa.
</p>

<p>
La nuova funzione epatch() da eutils-eclass è ancora più potente - essa
supporta patches compresse, percorsi di directory e serie e trova
automaticamente il livello delle patch - e un giorno intendo farle usare
autopath.
</p>

<p>
Nota che la sezione <c>patch</c> nella base_src_unpack() è deprecata e sarà
presto rimossa. Se usi un ebuild che la utilizza, essa necessiterà di essere
convertita con il metodo di <c>autopath.</c>
</p>

</body>
</subsection>

<subsection>
<title>cvs.eclass</title>
<body>

<p>
Questa eclass fornisce la funzionalità necessaria per creare ebuild cvs
'live'. Gli ebuilds vanno a prendere i sorgenti da uno specifico server cvs
nel momento dello spacchettamento, in questo modo si hanno sempre le ultime
versioni che ci sono a monte.
</p>

<p>
In ogni modo, il supporto necessario per gli ebuild cvs live non è ancora
stato aggiunto al portage. Esse possono lavorare con questa eclass, ma non è
conveniente in molti casi. Pensaci bene prima di creare un ebuild cvs live;
probabilmente un normale snapshot è meglio. Se intendi aggiungere un ebuild
al portage, assicurati sulle guide linea degli ebuild del cvs nella guida per
sviluppatori.
</p>

<p>
Prima di ereditare la cvs.eclass, devi impostare ogni varibile non
predefinita che desideri (almeno il nome del server e il nome del modulo).
Guarda la lista delle impostazioni configurabili e dei valori predefiniti
all'inizio della cvs.eclass, marcati come ebuild-configurable settings'.
</p>

<p>
Dopo di ciò, le cose sono più o meno automatiche. Viene fornito un
cvs_src_unpack() (senza sezioni). Se vuoi saperne di più, leggi la stessa
eclass.
</p>

</body>
</subsection>

<subsection>
<title>kde-functions.eclass</title>
<body>

<p>
Questa eclass contiene tutte le funzioni di aiuto inerenti a KDE.  Alcune di
loro non le puoi usare direttamente dall'ebuild; queste non sono menzionate
qui, e devono essere ben commentate nel sorgente.
</p>

<p>
Nota che con 'funzioni d'aiuto' intendo qualsiasi funzione che non è una
funzione speciale di ebuild (src_unpack(),...). Tutte le eclasses di kde
contengono queste funzioni 'speciali' ereditate da kde-functions.
</p>

<p>
Il solo codice fuori dalle funzioni in kde-functions.eclass (che viene
eseguito dal codice) è un blocco che determina se il corrente ebuild è uno di
kde-base o meno. Se lo è, sarà impostata KDEBASE=true. Questa variabile, è
usata in diversi test logici in diversi posti ed è comodo avere un test
centralizzato per essa.
</p>

<p>
<b>Il corrente schema di multi-kdedir</b>
</p>

<p>
Una breve spiegazione su come Gentoo gestisce più versioni di KDE:
</p>

<p>
Un KDE (che è qualcosa da kde-base) si trova in
/usr/kde/${major-version}.${minore-version}. Così, per esempio, KDE 3.1.x si
trova in /usr/kde/3.1. Tuttavia, questo schema è stato stabilito dopo la
release KDE 3.0, e così le vecchie versioni si trovano in un una posizione
non stadard: KDE 3.0.x si trova in /usr/kde/3 (e non /usr/kde/3.0) e KDE
2.2.2 (la sola versione 2.x che c'è) si trova in /usr/kde/2. L'ebuild del cvs
lo mantengono installato in /usr/kde/cvs.
</p>

<p>
Ogni numero di KDE con diverse versioni minori possono così coesistere. I
pacchetti kde-base hanno diversi SLOT di maggiore.minore (per esempio 3.0,
3.1).
</p>

<p>
Da quando si suppone che le QT sono completamente compatibili tra versioni
precedenti, abbiamo installato soltanto una di queste versioni maggiori su di
uno slot differente: esse sono in /usr/QT/$major.
</p>

<p>
Un ebuild che non fa parte di kde-base è sempre installato in /usr. Il
pacchetto kde-env mette KDEDIRS=/usr in env.d, permettendo a queste apps di
essere eseguite correttamente. L'applicazione compila e collega all'ultima
versione della libreria di KDE trovata; l'eclass controlla la posizione
standard in ordine discendente - /usr/kde/cvs, poi /usr/kde/3.1, poi
/usr/kde/3. (l'ebuild del kde-base è sempre collegato alle kdelibs della
propria versione). Questo dipende sicuramente dal parametro dato da
need-kde() (vedi sotto).
</p>

<p>
Ci sono molte variabili speciali che puoi impostare per cambiare le
impostazioni predefinite del sistema. Il loro primo uso è per compilare un
ebuild con una versione specifica di KDE che hai installato per test, ma puoi
anche usare queste varibili per installare KDE in una posizione non standard,
e così avremo, per esempio, entrambe le KDE 3.0.1 e 3.0.2 installate fianco a
fianco.  Questo, inoltre, è la cosa più comoda per testare e sviluppare.
</p>

<p>
Tutte le applicazioni di KDE (base e non base) saranno installate in
${KDEPREFIX}, se impostato. Esso sovrascrive tutta la logica nelle eclasses.
</p>

<p>
Un'applicazione di KDE (anhce se fa parte delle kde-base) proverà ad essere
linkata alle kdelibs installata in ${KDELIBSDIR}, se impostata. Se questo
fallisce, essa ritornerà indietro alla posizione dell'ultima kdelibs (o
all'appropriata versione di kde-base).
</p>

<p>
<b>need-kde(), need-qt(), set-kdedir(), set-qtdir()</b>
</p>

<p>
kde-functions.eclass forniscono due paia di funzioni: need-kde(), need-qt()
and set-kdedir(), set-qtdir(). Queste funzioni gestiscono i dettagli di
diverse installazioni di KDE e QT.
</p>

<p>
La funzione need-kde() è chiamata con un paramentro che è il numero minimo di
versioni di kdelibs richieste. Questo aggiunge le dipendenze opportune a
DEPEND, RDEPEND e chiama la funzione set-kdedir(). Se non vengono passati
parametri, verrà usata una versione di numero 0 (zero), il ciò significa che
nessuna versione soddisferà la dipendenza. need-kde() chiama anche
need-autoconf() e need-automake() con il corretto parametro per questa
versione di KDE.
</p>

<p>
La funzione set-kdedir(), così, determina il prefisso dell'installazione e la
posizione di kdeplibs che il tuo ebuild deve usare. Questi sono passati da te
rispettivamente tramite ${PREFIX} e ${KDEDIR}, (e sono automaticamente
gestite in kde.eclass). Nota che nessun ebuild deve mai essere direttamente
indirizzato a ${KDEPREFIX} o ${KDELIBSDIR}!
</p>

<p>
need-kde() cerca anche, da una tabella, la versione minima richiesta di QT
per questa versione delle kdelibs. Quindi esso chiama need-qt() con questa
versione. Un solo ebuild di un'applicazione qt (per esempio non-kde)
generalmente chiama direttamente need-qt, bypassando need-kde.
</p>

<p>
La funzione need-qt() aggiunge le versioni richieste di QT a	DEPEND, RDEPEND
e chiama set-qtdir() con esse. La funzione set-qtdir() imposta QTDIR per
essere la posizione predefinita di questa versione delle QT. Diversamente
set-kdedir(), set-qtdir() non controllano assolutamente se c'è installata una
versione delle QT.
</p>

<p>
need-kde() (o need-qt()) necessita di essere chiamata dalla parte principale
del''ebuild (per esempio, non da una funzione), così ogni cambiamento a
DEPEND e RDEPEND influenzerà emerge.
</p>

<p>
<b>need-autoconf(), need-automake()</b>
</p>

<p>
Queste funzioni impostano l'ambiente necessario per fare funzionare le
versioni richieste di autoconf o automake. Esse, ripristinano anche, tutte le
variabili di questo genere settate precedentemente. Per esempio, chiamando
'need-automake 1.4' verrà impostato NEED_AUTOMAKE_1_4=1 e ripristinate tutte
le altre variabili WANT_AUTOMAKE*. Per maggiori informazioni, guarda il
codice delle funzioni e i commenti all'inizio di /usr/bin/auto{conf,make} (su
sistemi Gentoo).
</p>

<p>
<b>kde_sandbox_patch()</b>
</p>

<p>
Alcuni makefiles di KDE sono corrotti. Essi eseguono un chmod o un chown sui
files PREFIX quando si vengono installati, ma non rispettano DESTDIR (${D}).
Per esempio, quando si installano, copiano correttamente un file in
${DESTDIR}/${PREFIX}/path/foo, ma poi tentano di fare un chmod+x sul file
${PREFIX}/path/foo sul filesystem che non è una corretta operazione. Se
questo tentativo si dovesse verificare, la sandbox previene l'operazione.
</p>

<p>
Questa funzione esegue un sed generico sui makefiles che sistemano tutte le
cause conosciute del problema. Essa è chiamata passando come parametri le
directories che devono essere procesate e i processi Makefile, Makefile.in e
Makefile.am in questo ordine. Per esempio:
</p>

<pre caption = "Processamento"> src_unpack() {
	base_src_unpack kde_sandbox_patch ${S}/dir1 ${S}/dir2/dir3 }</pre>

<p>
<b>kde_remove_flag()</b>
</p>

<p>
Questa è usata per eliminare le flag di compilazione che sono conosciute dal
pacchetto corrotto. Si chiama questa funzione dopo lo spacchettamento
passando come parametri la subdirectory di ${S} nella quale si lavora e il
nome del flag da rimuovere. Nota che non è recursiva. Esempio:
"kde_remove_flag foodir/barfoo -fomit-frame-pointer".
</p>

<p>
<b>kde_remove_dir() e ${KDE_REMOVE_DIR}</b>
</p>

<p>
Questa funzione rimuove la specifica sottodirectory dalla compilazione. Essa
la rimuove e rimuove tutte le sue referenze dai files delle sottodirectories,
da configure e da makefiles. Nota che questo, per adesso, funziona soltanto
nell subdirs di ${S}, non funziona al secondo livello delle sottodirectories.
Puoi chiamarla con una lista di sottodirectory da eliminare; essa lavora a
turno con ogni paramentro.
</p>

<p>
Puoi chiamarla direttamente ma per evitare di definire una src_unpack()
personalizzata, fai così, puoi impostare KDE_REMOVE_DIR con una lista di
sotto cartelle da eliminare. kde_src_unpack() chiamerà 'kde_remove_dir
${KDE_REMOVE_DIR}' dopo lo spacchettamento. Come pui vedere, sono andato
molto avanti per permettere di definire una funzione extra in un ebuild,
questo perchè rende l'ebuild più pulito e leggibile.
</p>

</body>
</subsection>

<subsection>
<title>kde.eclass</title>
<body>

<p>
Questa è la principale, centrale eclass di KDE. Essa contiene la maggior
parte del codice relativo a KDE. Tutti gli ebuild di KDE, in un modo o
nell'altro la ereditano. L'eclass di kde eredita le funzioni di base e
kde-functions.
</p>

<p>
Come con le altre eclasses, leggila per vedere cosa fa. La maggior parte di
essa è molto chiara. Qui c'è un breve riepilogo:
</p>

<p>
La sezione globale dell'eclass (per esempio, quella che viene eseguita quando
la erediti) aggiunge le corrette dipendenze su kde-env, automake, autoconf,
make and perl (l'ultimo è usato dalle configurazioni standard degli scripts
per la generazione veloce di makefiles). Essa imposta anche SLOT="0" come
predefinito.
</p>

<p>
kde_src_unpack() di base chiama solamente base_src_unpack(), passando tutti i
parametri (per esempio sezioni da eseguire). Dopo questo, essa aggiunge
elementi specifici di kde. Essa toccherà tutti i files .ui nel codice
spacchettato per rigenerare tutti i vecchi files .cpp e .h. Essa chiama anche
kde_remove_dir() con ${KDE_REMOVE_DIR} se questa varibile è settata (guarda
più sopra nella sezione su kde-functions).
</p>

<p>
kde_src_compile() possiede anche molte fixes. Una di esse esporta
kde_widgetdir="${KDEDIR}/lib/kde3/plugins/designer" per raggirare un bug
presente in vecchi acinclude.m4.in. Un altro è quello di impostare
HOME="${T}/fakehome", così facendo gli accessi a ${HOME}/.kde e $HOME/.qt non
verranno stoppati dalla sandbox, e non toccheranno l'home directory
dell'utente. Questo è un bug (o mancanza) di uic, che tenta sempre di
accedere ai files di configurazione di queste directories.
</p>

<p>
kde_src_compile() possiede diverse sezioni. <c>myconf</c> aggiunge a
${myconf} i paramentri predefiniti dello script di configurazione di kde,
come --prefix=${PREFIX} (ricorda, ${PREFIX} è impostato da set-kdedir()).
Puoi aggiungere i tuoi valori personali a ${myconf} sia prima che dopo di
questa sezione; ricordati solo di non sovrascrivere vecchi valori, perchè gli
utenti possono pensare di impostare $myconf nella shell e in questo modo
aggiungere qualcosa ai parametri configurati usando l'ebuild.
</p>

<p>
La sezione <c>configure</c> esegue lo script di configurazione in ${S},
passandole ${myconf}. Se lo script di configurazione non esiste, proverà a
generarlo eseguendo make -f Makefile.cvs o make -f admin/Makefile.common. In
questo modo, questo passo della compilazione (che è necessario per gli
snapshots del cvs, o per fare l'ebuilds di questi files come configure.in) è
anche eseguito automaticamente.
</p>

<p>
La sezione <c>make</c> esegue semplicemente emake || die. Per finire, c'è una
sezione <c>all</c> che esegue tutto quando spiegato sopra.
</p>

<p>
Concludendo, kde_src_install() possiede una sezione <c>make</c> che esegue
make install, e una sezione <c>dodoc</c> che esegue dodoc e alcuni nomi
standard di doc in ${S}, come README e COPYNG.
</p>

</body>
</subsection>

<subsection>
<title>kde-base.eclass</title>
<body>

<p>
Questa eclass è ora deprecata, l'ebuild deve usare al suo posto "inherit
kde".
</p>

</body>
</subsection>

<subsection>
<title>kde-dist.eclass</title>
<body>

<p>
Questa eclass è per il cuore dei pacchetti di distribuzione di kde in
kde-base/*. Essa eredita kde.
</p>

<p>
Essa imposta correttamente DESCRIPTION e HOMEPAGE e chiama need-kde ${PV}. Il
più semplice, piccolo pacchetto kde-base/ (per esempio kdetoys) non necessita
di fare nessun cambiamento ad essa, la maggior parte di essi aggiunge
soltanto dipendeze e patch.
</p>

</body>
</subsection>

<subsection>
<title>kde-i18n.eclass</title>
<body>

<p>
Questa eclass è per i paccehtti kde-i18n-*. Infatti, tutti gli ebuilds di
kde-i18n sono completamente identici e così tutti devono ereditare da questa
eclass. Le loro varibili ${P}, ${P}, ${PV} fanno il resto.
</p>

</body>
</subsection>

<subsection>
<title>kde.org.eclass</title>
<body>

<p>
Questa eclass è anch'essa deprecata, e tutto il codice è stato spostato a
kde-dist.eclass.
</p>

</body>
</subsection>

<subsection>
<title>koffice-i18n.eclass</title>
<body>

<p>
Questa eclass è significante per i paccehtti koffice-i18n-* e è molto simile
a kde-i18n.eclass. Inoltre, tutti gli ebuilds di kde-i18n sono completamente
identici e così tutti loro devono ereditare da questa eclass.
</p>

</body>
</subsection>

<subsection>
<title>kde-source.eclass</title>
<body>

<p>
Questa eclass lavora alla cima di cvs.eclass, aggiungendo alcune funzionalità
specifiche a kde. Per esempio, esso aggiunge automaticamente associazioni
alla directoy admin/ dal modulo kde-common del cvs di kde. Leggi l'eclass per
saperne di più, includendo le impostazioni di kde-cvs-specific che le puoi
passare.
</p>

</body>
</subsection>
</section>

<section>
<title>Scrittura di ebuilds per KDE</title>
<subsection>
<title>Introduzione</title>
<body>

<p>
Questo capitolo spiega come scrivere ebuild standard per KDE. Tutto quanto è
detto qui è un ripasso di tutte le informazioni sulle eclasses spiegate
sopra. Se sei in dubbio, guarda gli altri ebuilds, le altre eclasses oppure
chiedi.
</p>

</body>
</subsection>

<subsection>
<title>Un tipico ebuild di KDE</title>
<body>

<p>
Il codice sottostante dovrebbe essere chiaro dopo avere letto questa guida:
	</p>

<pre caption = "Un semplice ebuild di KDE, #1">
	&lt;L'intestazione va qui...&gt; inherit kde</pre>

<p>
ALcuni ebuild terminano giusto qui. Altri necessitano di alcune
personalizzazioni.
</p>

<p>
Il prossimo passo serve per aggiungere delle dipendenze extra.  Ricordati:
estendi *sempre* le variabili, non sovrascriverle mai!
</p>

<p>
Siccome il nostro scopo è quello di definire il maggior numero possibile di
personalizzazioni delle funzioni dell'ebuild, usiamo tutte le impostazioni
che possiamo, e chiamiamo pure tutte le possibili funzioni d'aiuto,
direttamente dalla sezione principale dell'ebuild.  Ricordati però che ci
sono limitazioni sul codice nella sezione principale; per esempio, essa non
deve produrre nessun output (l'output di debug-print() però non conta).
</p>

<pre caption = "Un semplice ebuild
	di KDE, #2: aggiungere dipendenze extra" > DEPEND=&quot;foo/bar&quot;
	RDEPEND=&quot;bar/foo&quot;</pre>

<p>
Vogliamo anche aggiungere alcuni argomenti extra a myconf, che sono passati
per la configurazione (assumiamo che usiamo la sezione di configurazione
kde_src_compile):
</p>

<pre caption = "Un semplice ebuild
	di KDE, #4: passare argomenti alla configurazione" >
	myconf=&quot;$myconf --with-foobar&quot;</pre>

<p>
Abbiamo anche una patch da aggiungere. Se può essere applicata usando -p0 in
${S}, possiamo usare la sezione <c>autopatch</c> di base_src_unpack.
Ricordati, kde_src_unpack() chiama base_src_unpack() passando tutti i
parametri che gli dai.
</p>

<pre caption = "Un seplice ebuild di KDE, #5:
	autopatching" > PATCHES=&quot;$FILESDIR/$P-myfix.diff&quot;</pre>

<p>
Per concludere, vogliamo estendere src_install() per mettere a posto alcuna
documentazione:
</p>

<pre caption = "Un semplice ebuild di KDE,
	#6: estendere src_install()" > src_unpack() { kde_src_install dodoc
	$S/doc/* }</pre>

<p>
Ora guarda l'ebuild che abbiamo creato in questo esempio:
</p>

<pre caption = "Un semplice ebuild di KDE - codice completo" >
	&lt;L'intestazione va qui...&gt; inherit kde

# aggiunge le dipendenze
DEPEND=&quot;foo/bar&quot; RDEPEND=&quot;bar/foo&quot;

# abilitare sempre foobar
myconf=&quot;${myconf} --with-foobar&quot;

# fix di un terribile bug
PATCHES=&quot;${FILESDIR}/${P}-myfix.diff&quot;

src_unpack() { kde_src_install
	# installa alcuna documentazione extra non inclusa nel target di make
	# install
    dodoc ${S}/doc/* }</pre>

</body>
</subsection>

<subsection>
<title>Un tipico qbuild con funzionalità aggiuntive per KDE</title>
<body>

<p>
Quando si aggiungono funzionalità per kde (eclasses) ad un ebuild esistente,
devi semplicemente iniziare ogni linea specifica di kde con <c>use kde
&amp;&amp;</c> , oppure creare un blocco intero <c>if [ -n "`use kde`" ];
then; fi</c>.
</p>

<p>
Alla sezione generale, aggiungi il codice seguente (solo se USE kde è
impostato, chiaramente):
</p>

<pre caption = "Supporto opzionale per KDE - sezione principale
	dell'ebuild" > inherit kde-functions

# Questo aggiungerà kdelibs, kde-env alla stringa delle dipendenze e imposta
# ${KDEDIR} con il valore corretto:

need-kde ${version} # versione minina di kde che necessità la tua applicazione

# Aggiunge tutto il resto di cui hai bisogno per il supporto di kde:
use kde &amp;&amp; myconf=&quot;${myconf} --with-my-parameter&quot;</pre>

<p>
Ora, chiedi alla tua applicazione di cercare KDE nelle impostazioni di
${KDEDIR} che sarà disponibile dopo aver chiamato need-kde(). Se non vuoi che
sia aggiunta la dipendeza a kdelibs, chiama set-kdedir() al posto di
need-kde().
</p>

</body>
</subsection>

</section>
</sections>

