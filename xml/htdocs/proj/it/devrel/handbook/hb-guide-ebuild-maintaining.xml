<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/devrel/handbook/Attic/hb-guide-ebuild-maintaining.xml,v 1.9 2012/05/28 14:34:46 ago Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>
<version>1.0.9</version>
<date>2011-12-10</date>

<section>
<title>Introduzione</title>
<body>

<p>
Questa guida ha lo scopo di spiegare le routine più frequenti di manutenzione
giornaliera per gli ebuild, così come altre manutenzioni meno frequenti che
potrebbero non essere note agli sviluppatori.
</p>

</body>
</section>
<section>
<title>Aggiungere un nuovo ebuild</title>
<body>

<p>
Quando viene aggiunto un nuovo ebuild, bisogna includere solo le <c>KEYWORDS</c>
per le architetture su cui è stato veramente testato l'ebuild, confermando che
funziona come deve e che le flag <c>USE</c> siano propriamente rispettare nel
pacchetto risultante che verrà installato. Se possibile, testare l'attuale
applicazione o libreria nel modo più completo possibile, in quanto si sarà
responsabili per qualsiasi danneggiamento nella(e) propria(e) architettura(e).
Dei test basilari come il controllo dell'avvio senza errori dell'applicazione
dovrebbero essere sempre effettuati.
</p>

<p>
Se si sta aggiungendo un ebuild sottoposto da un utente, non presupporre che
l'utente abbia fatto il test nelle varie architetture: spesso, le variabili
<c>KEYWORDS</c> vengono clonate tra i diversi pacchetti o generate dalla
documentazione contenuta nei sorgenti del pacchetti, il che non significa che il
pacchetto funzioni davvero su queste architetture.
</p>

</body>
</section>
<section>
<title>Stabilizzare gli ebuild</title>
<body>

<p>
Solo i mantenitori delle architetture per una data architettura devono marcare i
pacchetti stabili per quella architettura. Il mantenitore del pacchetto dovrebbe
essere sempre contattato solo in caso ci siano ragioni per non farlo.
Un'eccezione a questo è se si fa parte di un team per un'architettura, in questo
caso si può marcare un pacchetto come stabile per tale architettura. Se non si
fa parte di un team per un'architettura, consultare le linee guida riportate in
seguito; se l'architettura che si sta cercando non risulta elencata si prega di
consultare il relativo responsabile.
</p>

<p>
Non bisogna <e>mai</e> stabilizzare i pacchetti per le architetture che non si
possono testare personalmente, mandare invece un bug al team della relativa
architettura, come <mail>sparc@gentoo.org</mail>, chiedendo di stabilizzare
l'ebuild. Alternativamente, è possibile trovare diversi sviluppatori Gentoo in
IRC che possono dare una mano a risolvere le proprie richieste.
</p>

<p>
E' meglio non usare <mail>arch-maintainers@gentoo.org</mail>, ma piuttosto
aggiungere individualmente i team dell'architettura nella lista CC del bug. In
questo modo i team possono rimuoversi autonomamente dalla lista una volta che
hanno terminato il proprio lavoro, dando una chiara indicazione su quali team
devono ancora stabilizzare un pacchetto.
</p>

</body>
</section>
<section>
<title>Regole per la stabilizzazione</title>
<body>

<p>
SPARC: bisogna avere prima l'autorizzazione del responsabile dell'architettura.
Generalmente si prevede di essere inseriti nell'alias di sparc per ragione di QA
(ndT: Quality Assurance - garanzia di qualità), sebbene possano essere presi
altri accordi nel caso in cui si voglia lavorare soltanto con un piccolo gruppo
di pacchetti.
</p>

<p>
ALPHA: i mantenitori devono contrassegnare i propri pacchetti personali ma
devono anche informare il team Alpha se possono aiutare con i test e la
marcatura delle KEYWORDS in modo che il team possa tenere d'occhio i possibili
errori.
</p>

<p>
MIPS: bisogna avere prima l'autorizzazione da uno dei sviluppatori senior di
MIPS. Vista la moltitudine di hardware coinvolto, è in genere richiesto di
essere inseriti in un alias mips e avere accesso a vari sistemi MIPS.
</p>

</body>
</section>
<section>
<title>Aggiornare gli ebuild</title>
<body>

<p>
Nuovi ebuild vengono inseriti raramente con keywords "<c>arch</c>" e anche se
così non fosse, il pacchetto <e>deve</e> essere testato su qualsiasi
architettura elencata nella variabile <c>KEYWORDS</c> del nuovo pacchetto.
</p>

<p>
Eccezioni alla regola dell'"<c>arch</c>" sono la correzione di bug
significativi, o correzioni di sicurezza. Se la versione precedente dell'ebuild
contiene <c>KEYWORDS</c> che non si possono testare, allora bisogna fare il
'downgrade': modificare tutte le keyword "<c>arch</c>" in "<c>~arch</c>". Se si
pensa che il pacchetto non funzionerà nemmeno su "<c>~arch</c>" allora è meglio
lasciare le cose come sono e chiedere al team in questione di effettuare il test
sul pacchetto, tramite l'inserimento di un bug per il team della relativa
architettura.
</p>

<p>
Se una nuova versione introduce nuove dipendenze che non sono disponibili su
alcune architetture, allora bisogna compilare un bug o chiedere in IRC prima di
fare l'aggiornamento del pacchetto. Se c'è urgenza di aggiungere il pacchetto,
per esempio per questioni di sicurezza, allora bisogna rimuovere tutte le
<c>KEYWORDS</c> che causano problemi e mettere nella lista CC del bug i team
delle architetture in questione. Aprire un nuovo bug all'architettura in
questione se non ci sono già bug disponibili.
</p>

<p>
Se non ci sono nuove dipendenze, non rimuovere le keyword se il proprio commit
fallisce con repoman - provare un <c>cvs update</c> completo e se il problema
persiste, fare un commit con <c>repoman -I</c> e inviare un bug all'architettura
che ha dato problemi riportando il messaggio del commit sul CVS.
</p>

<warn>
Quando si fa il commit, assicurarsi di citare tutti i bug nel ChangeLog e di
fare altrettanto nel messaggio sul CVS. Questa mancanza è considerata di
cattivo gusto e potrebbe portare a dei provvedimenti disciplinari.
</warn>

</body>
</section>
<section>
<title>Spostare gli ebuild</title>
<body>

<p>
Lo spostamento di ebuild è un processo in due fasi:
</p>

<p>
Per prima cosa, inserire l'ebuild nel CVS, copiandolo nella sua nuova locazione
e facendo in commit così come spiegato in <uri
link="?part=2&amp;chap=5#doc_chap2">Aggiungere un nuovo ebuild</uri>.
</p>

<p>
Dopodiché cambiare tutti gli ebuild che dipendono (<c>DEPEND</c>) dal vecchio
ebuild in modo di farli dipendere dal nuovo. Dopodiché aggiungere una voce
al file più recente presente in <path>profiles/updates/</path> nel Portage tree
seguendo questo formato:
</p>

<pre caption="Aggiungere una voce al file updates">
move net-misc/fwbuilder net-firewall/fwbuilder
</pre>

<p>
Una volta spostato, aggiungere una voce nel file più recente, contenuto in
<path>profiles/updates/</path> nel tree di Portage, usando il seguente formato:
</p>

<pre caption="Aggiungere una voce per gli aggiornamenti">
move net-misc/fwbuilder net-firewall/fwbuilder
</pre>

<p>
Questo esempio sposta in modo trasparente <path>net-misc/fwbuilder</path> in
<path>net-firewall/fwbuilder</path> se gli utenti lo hanno installato. In questo
modo gli utenti riceveranno automaticamente gli aggiornamenti per
<path>net-firewall/fwbuilder</path> quando saranno disponibili.
</p>

<p>
Una volta che questa operazione è conclusa. sarà possibile rimuovere il vecchio
pacchetto. Basta eseguire un semplice <c>cvs remove -Rf $PN</c> nella categoria
del pacchetto ed effettuare il commit dei cambiamenti con un messaggio di commit
significativo. Non dimenticare di aggiornare le voci corrispondenti in file come
profiles/package.mask per tener conto della nuova categoria. Infine, ricordare
di cambaire il titolo ai bug aperti che riguardano questo pacchetto, se ce ne
sono.
</p>

<pre caption="Rimuovere un pacchetto">
net-misc # cvs rm -Rf fwbuilder
cvs remove: use `cvs commit' to remove these files permanently
net-misc # cvs ci -m "Moving net-misc/fwbuilder to net-firewall/fwbuilder."
</pre>

<note>
CVS non può distruggere le directory: semplicemente non le ricrea se sono vuote,
utilizzando il comando insieme al parametro <c>-P</c>.
</note>

</body>
</section>

<section>
<title>Cambiare lo SLOT di un ebuild</title>
<body>
<p>
Il processo per cambiare lo SLOT di un ebuild è molto simile al processo
precedente. Oltre a cambiare lo SLOT nel file dell'ebuild, occorre anche creare
una nuova voce in <path>profiles/updates/</path> nell'albero del Portage con il
formato seguente:
</p>

<pre caption="Aggiungere una voce agli aggiornamenti">
slotmove app-text/gtkspell 0 2
</pre>

<p>
Assicurarsi di aver risolto tutte le dipendenze inverse e di aver aggiornato
ogni file nella directory <path>profiles/</path> che contiene una voce che può
essere influenzata da questo cambiamento.
</p>

</body>
</section>

<section>
<title>Rimuovere gli ebuild</title>
<body>

<p>
Quando si rimuovono i pacchetti seguire questi passaggi:
</p>

<ol>
  <li>
    Assicurarsi che in Portage non vengano spezzate dipendenze a seguito della
    rimozione del pacchetto
  </li>
  <li>
    Inviare il messaggio di ultimi riti nella mailing list gentoo-dev-announce
    e gentoo-dev
  </li>
  <li>Mascherare il pacchetto</li>
  <li>Attendere 30 giorni (o oltre)</li>
  <li>
    Rimuoverlo da CVS a meno la motivazione della rimozione non sia più valida
  </li>
  <li>Rimuovere la voce in package.mask</li>
  <li>Chiudere i bug aperti con il tipo di soluzione WONTFIX</li>
</ol>

<p>
Per rimuovere completamente un pacchetto da CVS, eliminare qualsiasi file dalla
directory e effettuarne il commit, CVS si arrangerà ad eliminare da sé le
directory vuote.
</p>

<pre caption="Rimuovere un pacchetto da CVS">
<comment>#</comment>
<keyword>cd</keyword> app-admin
<comment>#</comment> <keyword>cvs</keyword> rm -Rf scotty
<comment>#</comment> <keyword>cvs</keyword> ci -m "app-admin/scotty removal (pending 21st July 2006), see #77501 for reference." scotty
</pre>

</body>
</section>
<section>
<title>File che creano conflitti</title>
<body>

<p>
Quando s'incontra un pacchetto che tenta di installare alcuni file che sono
già forniti da un altro pacchetto (rintracciabili tramite
<c>FEATURES=collision-protect</c> per esempio) bisogna sistemare questa
situazione prima di poter fare il commit dell'ebuild o, se si riscontra questo
problema con un pacchetto esistente, compilare un bug per il pacchetto (vedere
in seguito alcune eccezioni). Le ragioni per i conflitti dei file sono critiche
perché se "foo" fornisce il file <path>/usr/bin/example</path>, "bar" glielo
sovrascrive, ed in seguito viene fatto l'unmerge di "bar", Portage rimuoverà
<path>/usr/bin/example</path> corrompendo di conseguenza "foo".
</p>

<p>
Il sistema migliore per ovviare al problema è di aggiungere una dipendenza
bloccante ad entrambi i pacchetti che vogliono installare questo file, in modo
tale da non poterli installare contemporaneamente. A meno che non ci siano anche
altre ragioni per le quali quei pacchetti si blocchino l'uno con l'altro, è
meglio evitare questo approccio, piuttosto propendere per una correzione del
pacchetto, che può includere uno o più di questi passaggi:
</p>

<ul>
  <li>Rendere "foo" dipendente ((R)DEPEND) da "bar".</li>
  <li>
    Rimuovere i file in conflitto da "foo" in <c>src_install</c> o
    <c>pkg_preinst</c>.
  </li>
  <li>
    Spostare i file in conflitto in un nuovo sottopacchetto e rendere "foo" e
    "bar" entrambi dipendenti ((R)DEPEND) da questo pacchetto.
  </li>
  <li>
    Cambiare la locazione in cui "foo" o "bar" installano i file in conflitto.
  </li>
</ul>

<p>
In alcuni casi i file che creano conflitti non possono veramente essere
sistemati o non sono critici, al momento delle eccezioni conosciute sono le
pagine man dei moduli Perl (che sovrascrivono quelle installate direttamenta da
Perl) e i file gestiti da <c>CONFIG_PROTECT</c> (che devono ancora essere
sistemati ma non sono critici perché Portage non li sovrascrive).
</p>

</body>
</section>
</sections>