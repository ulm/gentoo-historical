<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/it/devrel/handbook/Attic/hb-guide-ebuild-maintaining.xml,v 1.4 2007/04/27 14:18:14 scen Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>
<version>1.0.4</version>
<date>2007-02-28</date>

<section>
<title>Introduzione</title>
<body>

<p>
Questa guida ha lo scopo di spiegare le routine più frequenti di manutenzione
giornaliera per gli ebuild, così come altre manutenzioni meno frequenti che
potrebbero non essere note agli sviluppatori.
</p>

</body>
</section>
<section>
<title>Aggiungere un nuovo ebuild</title>
<body>

<p>
Quando viene aggiunto un nuovo ebuild, bisogna includere solo le <c>KEYWORDS</c>
per le architetture su cui è stato veramente testato l'ebuild, confermando che
funziona come deve e che le flag <c>USE</c> siano propriamente rispettare nel
pacchetto risultante che verrà installato. Se possibile, testare l'attuale
applicazione o libreria nel modo più completo possibile, in quanto si sarà
responsabili per qualsiasi danneggiamento nella(e) propria(e) architettura(e).
Dei test basilari come il controllo dell'avvio senza errori dell'applicazione
dovrebbero essere sempre effettuati.
</p>

<p>
Se si sta aggiungendo un ebuild sottoposto da un utente, non presuporre che
l'utente abbia fatto il test nelle varie architetture: spesso, le variabili
<c>KEYWORDS</c> vengono clonate tra i diversi pacchetti o generate dalla
documentazione contenuta nei sorgenti del pacchetti, il che non significa che il
pacchetto funzioni davvero su queste architetture.
</p>

</body>
</section>
<section>
<title>Stabilizzare gli ebuild</title>
<body>

<p>
Solo i mantenitori delle architetture per una data architettura devono marcare i
pacchetti stabili per quella architettura. Il mantenitore del pacchetto dovrebbe
essere sempre contattato solo in caso ci siano ragioni per non farlo.
Un'eccezione a questo è se si fa parte di un team per un'architettura, in questo
caso si può marcare un pacchetto come stabile per tale architettura. Se non si
fa parte di un team per un'architettura, consultare le linee guida riportate in
seguito; se l'architettura che si sta cercando non risulta elencata si prega di
consultare il relativo responsabile.
</p>

<p>
Non bisogna <e>mai</e> stabilizzare i pacchetti per le architetture che non si
possono testare personalmente, mandare invece un bug al team della relativa
architettura, come <mail link="sparc@gentoo.org">sparc@gentoo.org</mail>,
chiedendo di stabilizzare l'ebuild. Alternativamente, è possibile trovare
diversi sviluppatori Gentoo in IRC che possono dare una mano a risolvere le
proprie richieste.
</p>

<p>
E' meglio non usare <mail
link="arch-maintainers@gentoo.org">arch-maintainers@gentoo.org</mail>, ma
piuttosto aggiungere individualmente i team dell'architettura nella lista CC del
bug. In questo modo i team possono rimuoversi autonomamente dalla lista una
volta che hanno terminato il proprio lavoro, dando una chiara indicazione su
quali team devono ancora stabilizzare un pacchetto.
</p>

</body>
</section>
<section>
<title>Regole per la stabilizzazione</title>
<body>

<p>
SPARC: bisogna avere prima l'autorizzazione del responsabile dell'architettura
(al momento Weeve). Generalmente si prevede di essere inseriti nell'alias di
sparc per ragione di QA (ndT: Quality Assurance - garanzia di qualità), sebbene
possano essere presi altri accordi nel caso in cui si voglia lavorare soltanto
con un piccolo gruppo di pacchetti.
</p>

<p>
ALPHA: i mantenitori devono contrassegnare i propri pacchetti personali ma
devono anche informare il team Alpha se possono aiutare con i test e la
marcatura delle KEYWORDS in modo che il team possa tenere d'occhio i possibili
errori.
</p>

<p>
MIPS: bisogna avere prima l'autorizzazione da uno dei sviluppatori senior di
MIPS. Vista la moltitudine di hardware coinvolto, è in genere richiesto di
essere inseriti in un alias mips e avere accesso a vari sistemi MIPS.
</p>

</body>
</section>
<section>
<title>Aggiornare gli ebuild</title>
<body>

<p>
Nuovi ebuild vengono inseriti raramente con keywords "<c>arch</c>" e anche se
così non fosse, il pacchetto <e>deve</e> essere testato su qualsiasi
architettura elencata nella variabile <c>KEYWORDS</c> del nuovo pacchetto.
</p>

<p>
Eccezioni alla regola dell'"<c>arch</c>" sono la correzione di bug
significativi, o correzioni di sicurezza. Se la versione precedente dell'ebuild
contiene <c>KEYWORDS</c> che non si possono testare, allora bisogna fare il
'downgrade': modificare tutte le keyword "<c>arch</c>" in "<c>~arch</c>". Se si
pensa che il pacchetto non funzionerà nemmeno su "<c>~arch</c>" allora è meglio
lasciare le cose come sono e chiedere al team in questione di effettuare il test
sul pacchetto, tramite l'inserimento di un bug per il team della relativa
architettura.
</p>

<p>
Se una nuova versione introduce nuove dipendenze che non sono disponibili su
alcune architetture, allora bisogna compilare un bug o chiedere in IRC prima di
fare l'aggiornamento del pacchetto. Se c'è urgenza di aggiungere il pacchetto,
per esempio per questioni di sicurezza, allora bisogna rimuovere tutte le
<c>KEYWORDS</c> che causano problemi e mettere nella lista CC del bug i team
delle architetture in questione. Aprire un nuovo bug all'architettura in
questione se non ci sono già bug disponibili.
</p>

<p>
Se non ci sono nuove dipendenze, non rimuovere le keyword se il proprio commit
fallisce con repoman - provare un <c>cvs update</c> completo e se il problema
persiste, fare un commit con <c>repoman -I</c> e inviare un bug all'architettura
che ha dato problemi riportando il messaggio del commit sul CVS.
</p>

<warn>
Quando si fa il commit, assicurarsi di citare tutti i bug nel ChangeLog e di
fare altrettanto nel messaggio sul CVS. Questa mancanza è considerata di
cattivo gusto e potrebbe portare a dei provvedimenti disciplinari.
</warn>

</body>
</section>
<section>
<title>Spostare gli ebuild</title>
<body>

<p>
Lo spostamento di ebuild è un processo in due fasi:
</p>

<p>
Per prima cosa, inserire l'ebuild nel CVS, copiandolo nella sua nuova locazione
e facendo in commit così come spiegato in <uri
link="?part=2&amp;chap=5#doc_chap2">Aggiungere un nuovo ebuild</uri>.
</p>

<p>
Dopodichè cambiare tutti gli ebuild che dipendono (<c>DEPEND</c>) dal vecchio
ebuild in modo di farli dipendere dal nuovo. Solo dopo di ciò, rimuovere nella
vecchia locazione ogni files con <c>cvs remove</c>, effettuando anche il commit
dei cambiamenti.
</p>

<note>
CVS non può distruggere le directory: semplicemente non le ricrea se sono vuote,
utilizzando il comando insieme al parametro <c>-P</c>.
</note>

<p>
Una volta spostato, aggiungere una voce nel file più recente, contenuto in
<path>profiles/updates/</path> nel tree di Portage, usando il seguente formato:
</p>

<pre caption="Aggiungere una voce per gli aggiornamenti">
move net-misc/fwbuilder net-firewall/fwbuilder
</pre>

<p>
Questo esempio sposta in modo trasparente <path>net-misc/fwbuilder</path> in
<path>net-firewall/fwbuilder</path> se gli utenti lo hanno installato. In questo
modo gli utenti riceveranno automaticamente gli aggiornamenti per
<path>net-firewall/fwbuilder</path> quando saranno disponibili.
</p>

</body>
</section>
<section>
<title>Rimuovere gli ebuild</title>
<body>

<p>
Quando viene rimosso un ebuild assicurarsi che im Portage non si creino
dipendenze corrotte a seguito della rimozione -  in più, il messaggio di commit
sul CVS deve spiegare chiaramente perchè l'ebuild è stato rimosso.
</p>

<p>
Per rimuovere completamente un pacchetto da CVS, eliminare qualsiasi file dalla
directory e effettuarne il commit, CVS si arrangerà ad eliminare da sè le
directory vuote.
</p>

<pre caption="Rimuovere un pacchetto da CVS">
<comment>#</comment>
<keyword>cd</keyword> app-admin
<comment>#</comment> <keyword>cvs</keyword> rm -Rf scotty
<comment>#</comment> <keyword>cvs</keyword> ci -m "app-admin/scotty removal (pending 21st July 2006), see #77501 for reference." scotty
</pre>

</body>
</section>
<section>
<title>File che creano conflitti</title>
<body>

<p>
Quando s'incontra un pacchetto che tenta di installare alcuni file che sono
già forniti da un altro pacchetto (rintracciabili tramite
<c>FEATURES=collision-protect</c> per esempio) bisogna sistemare questa
situazione prima di poter fare il commit dell'ebuild o, se si riscontra questo
problema con un pacchetto esistente, compilare un bug per il pacchetto (vedere
in seguito alcune eccezioni). Le ragioni per i conflitti dei file sono critiche
perchè se "foo" fornisce il file <path>/usr/bin/example</path>, "bar" glielo
sovrascrive, ed in seguito viene fatto l'unmerge di "bar", Portage rimuoverà
<path>/usr/bin/example</path> corrompendo di conseguenza "foo".
</p>

<p>
Il sistema migliore per ovviare al problema è di aggiungere una dipendenza
bloccante ad entrambi i pacchetti che vogliono installare questo file, in modo
tale da non poterli installare contemporaneamente. A meno che non ci siano anche
altre ragioni per le quali quei pacchetti si blocchino l'uno con l'altro, è
meglio evitare questo approccio, piuttosto propendere per una correzione del
pacchetto, che può includere uno o più di questi passaggi:
</p>

<ul>
  <li>Rendere "foo" dipendente ((R)DEPEND) da "bar".</li>
  <li>
    Rimuovere i file in conflitto da "foo" in <c>src_install</c> o
    <c>pkg_preinst</c>.
  </li>
  <li>
    Spostare i file in conflitto in un nuovo sottopacchetto e rendere "foo" e
    "bar" entrambi dipendenti ((R)DEPEND) da questo pacchetto.
  </li>
  <li>
    Cambiare la locazione in cui "foo" o "bar" installano i files in conflitto.
  </li>
</ul>

<p>
In alcuni casi i file che creano conflitti non possono veramente essere
sistemati o non sono critici, al momento delle eccezioni conosciute sono le
pagine man dei moduli Perl (che sovrascrivono quelle installate direttamenta da
Perl) e i file gestiti da <c>CONFIG_PROTECT</c> (che devono ancora essere
sistemati ma non sono critici perchè Portage non li sovrascrive).
</p>

</body>
</section>
</sections>
