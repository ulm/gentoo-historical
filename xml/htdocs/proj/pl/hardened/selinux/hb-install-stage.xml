<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/pl/hardened/selinux/Attic/hb-install-stage.xml,v 1.1 2006/04/07 21:35:54 shadoww Exp $ -->

<sections>
<section>
<title>Instalowanie tarballa stage</title>
<subsection>
<title>Ustawienie poprawnej daty i czasu</title>
<body>

<p>
Na samym początku całego procesu instalacji należy sprawdzić datę oraz czas
systemowy i ewentualnie je zaktualizować. Niezsychronizowany zegar może być
przyczyną dziwnych błędów w przyszłości!
</p>

<p>
Aby zweryfikować aktualną datę/czas, używamy polecenia <c>date</c>:
</p>

<pre caption="Sprawdzanie daty/czasu">
# <i>date</i>
Sun Apr 25 16:21:18 CEST 2004
</pre>

<p>
Jeżeli wyświetlone informacje są błędne, musimy je zaktualizować poleceniem
<c>date MMDDggmmWWRR</c> (<b>M</b>iesiąc, <b>D</b>zień, <b>g</b>odzina,
<b>m</b>inuta, <b>W</b>iek pomniejszony o jeden i <b>R</b>ok). Na przykład, aby
ustawić datę 25 kwietnia 2004 roku i godzinę 16:21, wykonujemy polecenie:
</p>

<pre caption="Ustawianie daty/czasu">
# <i>date 042516212004</i>
</pre>

</body>
</subsection>
<subsection>
<title>Podejmowanie decyzji</title>
<body>

<p>
W następnym kroku wykonamy instalację tarballa <e>stage</e>, który uprzednio
należy pobrać z internetu.
<!--
Można go pobrać z internetu lub przekopiować z płyty instalacyjnej, jeśli
znajduje się na niej ten, którego chcemy użyć. Ściąganie tarballa z
internetu byłoby w tej sytuacji niepotrzebną stratą czasu, gdyż pliki stage są
takie same.
-->
</p>

<table>
<tr>
  <th>Tarball stage SELinux</th>
  <th>Tarball stage SELinux do wykorzystania z GCC w wersji hardened</th>
</tr>
<tr>
  <ti>stage1-x86-selinux</ti>
  <ti>stage1-x86-selinux-pie-ssp</ti>

</tr>
<tr>
  <ti>stage2-x86-selinux</ti>
  <ti>stage2-x86-selinux-pie-ssp</ti>
</tr>
<tr>
  <ti>stage3-x86-selinux</ti>
  <ti>stage3-x86-selinux-pie-ssp</ti>
</tr>
</table>

<p>
Podczas instalacji Gentoo SELinux konieczne jest wykorzystanie tarballa stage
SELinux. Jeśli zamierzamy używać GCC w wersji hardened, powinniśmy skorzystać z
tarballi <c>pie_ssp</c>.
</p>

<ul>
<li><uri link="#doc_chap2">Domyślnie: Użycie stage z Internetu</uri></li>
<!--
<li><uri link="#doc_chap3">Alternative: Using a Stage from the LiveCD</uri></li>
-->
</ul>

</body>
</subsection>
</section>
<section>
<title>Domyślnie: Użycie stage z Internetu</title>
<subsection>
<title>Pobieranie tarballa stage</title>
<body>

<p>
Na początku przechodzimy do punktu montowania systemu plików Gentoo
(zwykle jest to <path>/mnt/gentoo</path>):
</p>

<pre caption="Przechodzenie do punktu montowania systemu plików Gentoo">
# <i>cd /mnt/gentoo</i>
</pre>

<p>
Mamy do dyspozycji kilka narzędzi, za pomocą których możemy pobrać plik
stage. Jeżeli mamy program <c>links</c>, możemy wejść bezpośrednio na <uri
link="/main/en/mirrors.xml">listę serwerów lustrzanych Gentoo</uri> i wybrać
serwer, który znajduje się najbliżej. Następnie wybieramy katalog
<path>experimental/</path>, potem katalog odpowiadający naszej architekturze (na
przykład <path>x86/</path>) i przechodzimy do
<path>hardened/stages</path>. Zobaczymy tam wszystkie dostępne pliki stage dla
naszej architektury. Wybieramy jeden i pobieramy go, wciskając klawisz
<c>D</c>. Gdy pobieranie dobiegnie końca, opuszczamy przeglądarkę przy pomocy
klawisza <c>Q</c>.
</p>

<pre caption="Przeglądanie listy serwerów lustrzanych za pomocą links">
<comment>(Bez proxy)</comment>   
# <i>links http://www.gentoo.org/main/en/mirrors.xml</i>
<comment>(Przy użyciu proxy)</comment>      
# <i>links -http-proxy proxy.server.com:8080 http://www.gentoo.org/main/en/mirrors.xml</i>
</pre>

<p>
Jeśli chcemy zweryfikować poprawność pobranych archiwów stage, musimy porównać
wynik polecenia <c>md5sum</c> z sumami MD5 udostępnionymi na
serwerze. Przykładowo, aby sprawdzić poprawność tarballa stage dla architektury
x86, wykonujemy polecenie:
</p>

<pre caption="Sprawdzanie integralności tarballa stage">
# <i>md5sum -c stage1-x86-selinux-2004.2.tar.bz2.md5</i>
stage1-x86-selinux-2004.2.tar.bz2: OK
</pre>

</body>
</subsection>
<subsection>
<title>Rozpakowywanie tarballa stage</title>
<body>

<p>
Wypakowujemy pobrany plik stage przy pomocy GNU <c>tar</c>:
</p>

<pre caption="Wypakowywanie stage">
# <i>tar -xvjpf stage?-*.tar.bz2</i>
</pre>

<p>
Należy użyć dokładnie tych samych przełączników (<c>-xvjpf</c>). Opcja <c>x</c>
oznacza <e>wypakuj</e>, <c>v</c> to <e>wyświetl</e>, aby widzieć co się dzieje
podczas wypakowywania (ok, to jest opcjonalne), <c>j</c> służy do
<e>dekompresji archiwum bzip2</e>, <c>p</c> to <e>zachowuj uprawnienia</e>,
natomiast <c>f</c> podkreśla, że chcemy rozpakować to, co czytamy z pliku, a nie
ze standardowego wejścia.
</p>

<!--
<p>
Now that the stage is installed, continue with <uri
link="#installing_portage">Installing Portage</uri>.
</p>
-->
</body>
</subsection>
</section>
<!--
<section>
<title>Alternative: Using a Stage from the LiveCD</title>
<subsection>
<title>Extracting the Stage Tarball</title>
<body>

<p>
The stages on the CD reside in the <path>/mnt/cdrom/stages</path> directory. To
see a listing of available stages, use <c>ls</c>:
</p>

<pre caption="List all available stages">
# <i>ls /mnt/cdrom/stages</i>
</pre>

<p>
If the system replies with an error, you may need to mount the CD-ROM first:
</p>

<pre caption="Mounting the CD-ROM">
# <i>ls /mnt/cdrom/stages</i>
ls: /mnt/cdrom/stages: No such file or directory
# <i>mount /dev/cdroms/cdrom0 /mnt/cdrom</i>
# <i>ls /mnt/cdrom/stages</i>
</pre>

<p>
Now go into your Gentoo mountpoint (usually <path>/mnt/gentoo</path>):
</p>

<pre caption="Changing directory to /mnt/gentoo">
# <i>cd /mnt/gentoo</i>
</pre>

<p>
We will now extract the stage tarball of your choice. We will do this with the
GNU <c>tar</c> tool. Make sure you use the same options (<c>-xvjpf</c>)! In the
next example, we extract the stage tarball 
<path>stage3-&lt;subarch&gt;-2004.2.tar.bz2</path>.
Be sure to substitute the tarball filename with your stage.
</p>

<pre caption="Extracting the stage tarball">
# <i>tar -xvjpf /mnt/cdrom/stages/stage3-&lt;subarch&gt;-2004.2.tar.bz2</i>
</pre>

<p>
Now that the stage is installed, continue with <uri
link="#installing_portage">Installing Portage</uri>.
</p>

</body>
</subsection>
</section>
-->
<!--
<section id="installing_portage">
<title>Installing Portage</title>
<subsection>
<title>Network or No Network?</title>
<body>

<p>
If you don't have a working network connection, you have to install a portage 
snapshot provided by one of our LiveCDs. This automatically assumes that you are
installing from a <e>stage3</e> tarball (as it is the only tarball supported for
networkless installations). If you want to use prebuilt packages
later on to speed up the installation, you <e>must</e> use a portage snapshot
from the LiveCD. Other users will download a fully updated Portage tree using 
<c>emerge</c> in the next chapter.
</p>

<p>
Continue with the appropriate part:
</p>

<ul>
  <li>
    <uri link="#installing_from_LiveCD">Installing a Portage Snapshot and
    Source Code from LiveCD</uri> (for networkless installations or GRP
    installations)
  </li>
  <li>
    <uri link="#compile_options">Configuring the Compile Options</uri> (all 
    other installation methods)
  </li>
</ul>

</body>
</subsection>
<subsection id="installing_from_LiveCD">
<title>Installing a Portage Snapshot and Source Code from LiveCD</title>
<body>

<p>
There is a Portage snapshot available on the Universal LiveCDs. Since you are 
reading this, we can safely assume you are using such a LiveCD. To install this
snapshot, take a look inside <path>/mnt/cdrom/snapshots/</path> to see what
snapshot we have available:
</p>

<pre caption="Checking the /mnt/cdrom/snapshots content">
# <i>ls /mnt/cdrom/snapshots</i>
</pre>

<p>
Now extract the snapshot using the following construct. Again,
make sure you use the correct options to <c>tar</c>. Also, the <c>-C</c> is with
a capital <c>C</c>, not <c>c</c>. In the next example we use
<path>portage-20040710.tar.bz2</path> as the snapshot filename. Be sure to
substitute with your snapshot.
</p>

<pre caption="Extracting a Portage snapshot">
# <i>tar -xvjf /mnt/cdrom/snapshots/portage-20040710.tar.bz2 -C /mnt/gentoo/usr</i>
</pre>

<p>
You also need to copy over all source code from the CD:
</p>

<pre caption="Copy over source code">
# <i>mkdir /mnt/gentoo/usr/portage/distfiles</i>
# <i>cp /mnt/cdrom/distfiles/* /mnt/gentoo/usr/portage/distfiles/</i>
</pre>

<p>
Now that your Portage snapshot is installed, continue with <uri
link="#compile_options">Configuring the Compile Options</uri>.
</p>

</body>
</subsection>
</section>
-->

<section id="compile_options">
<title>Konfigurowanie opcji kompilacji</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Jest wiele możliwych do skonfigurowania zmiennych wpływających na zachowanie
Gentoo. Możemy je wprowadzać jako zmienne środowiskowe (poprzez <c>export</c>),
ale wtedy nie zostaną zapisane na stałe. Zamiast tego Portage do utrzymywania
konfiguracji używa pliku <path>/etc/make.conf</path>. Pora zająć się jego
edycją.
</p>

<note>
Opatrzona komentarzami lista wszystkich możliwych zmiennych znajduje się w pliku
<path>/mnt/gentoo/etc/make.conf.example</path>. Do prawidłowego ukończenia
instalacji wystarczy wyedytować tylko kilka z nich - te, które przedstawiamy
poniżej.
</note>

<p>
Uruchamiamy ulubiony edytor (w przykładach używamy <c>nano</c>), który posłuży
nam do wprowadzenia omawianych opcji optymalizacji.
</p>

<pre caption="Otwieranie /etc/make.conf">
# <i>nano -w /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
Plik <path>make.conf.example</path> ma charakterystyczną strukturę: linie z
komentarzami rozpoczynają się od znaku "#", linie zawierające zmienne używają
składni <c>ZMIENNA="zawartość"</c>. Takiej samej składni używa także plik
<path>/etc/make.conf</path>. Omówimy teraz kilka ważnych zmiennych.
</p>

</body>
</subsection>
<subsection>
<title>CHOST</title>
<body>

<warn>
Mimo, że może to kusić tych, którzy nie korzystają ze stage1, <e>nie</e> należy
zmieniać ustawienia <c>CHOST</c> w pliku <path>make.conf</path>. Dokonanie tego
może zepsuć cały system. Powtarzamy: tę zmienną możemy zmodyfikować tylko
podczas instalacji przy użyciu <e>stage1</e>.
</warn>

<p>
Zmienna <c>CHOST</c> definiuje architekturę, pod którą będą kompilowane programy
przy pomocy <c>gcc</c>. Możliwe są następujące wartości:
</p>

<table>
<tr>
  <th>Architektura</th>
  <th>Podarchitektura</th>
  <th>Ustawienia CHOST</th>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i386</ti>
  <ti>i386-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i486</ti>
  <ti>i486-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i586</ti>
  <ti>i586-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>x86</ti>
  <ti>i686 i wyższe (także athlon)</ti>
  <ti>i686-pc-linux-gnu</ti>
</tr>
<tr>
  <ti>alpha</ti>
  <ti></ti>
  <ti>alpha-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>ppc</ti>
  <ti></ti>
  <ti>powerpc-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>ppc64</ti>
  <ti></ti>
  <ti>powerpc64-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>sparc</ti>
  <ti></ti>
  <ti>sparc-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>hppa</ti>
  <ti>(uniwersalne)</ti>
  <ti>hppa-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>hppa</ti>
  <ti>pa7000</ti>
  <ti>hppa1.1-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>hppa</ti>
  <ti>pa8000 and above</ti>
  <ti>hppa2.0-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>mips</ti>
  <ti></ti>
  <ti>mips-unknown-linux-gnu</ti>
</tr>
<tr>
  <ti>amd64</ti>
  <ti></ti>
  <ti>x86_64-pc-linux-gnu</ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>CFLAGS i CXXFLAGS</title>
<body>

<p>
Zmienne <c>CFLAGS</c> i <c>CXXFLAGS</c> definiują flagi optymalizujące używane
przez kompilator <c>gcc</c> odpowiednio dla C i C++. Choć generalnie określamy
ich wartości tutaj, maksimum wydajności osiągniemy dopasowując je do każdego
programu z osobna. Jest tak, ponieważ programy znacząco różnią się między
sobą.
</p>

<p>
W plik <path>make.conf</path> należy zdefiniować flagi optymalizacji, co do
których jesteśmy przekonani, że <e>w głównej mierze</e> poprawią czas reakcji
systemu. Nie przypisujmy tutaj ustawień eksperymentalnych - przesada w
optymalizacji może spowodować, że programy zaczną źle funkcjonować (nagle
przerywać działanie lub nawet wcale nie działać).
</p>

<p>
Nie będziemy opisywać znaczenia wszystkich możliwych opcji optymalizacji.
Wszystkie są omówione w <uri link="http://gcc.gnu.org/onlinedocs/">Internetowym
Podręczniku GNU</uri>. Ponadto warto zajrzeć na stronę info <c>gcc</c> (przy
pomocy komendy <c>info gcc</c> - działa tylko na systemach linuksowych). Plik
<path>make.conf.example</path> również zawiera dużo informacji i przykładów -
należy go uważnie przeczytać.
</p>

<p>
Pierwszym ustawieniem, jakim się zajmiemy, jest flaga <c>-march=</c>, która
określa docelową architekturę. Możliwe dla niej wartości są opisane w postaci
komentarzy w pliku <path>make.conf.example</path>. Na przykład dla architektury
x86 Athlon XP będzie to:
</p>

<pre caption="Ustawienie flagi march">
<comment># Użytkownicy AMD64, którzy chcą korzystać z macierzystego 64-bitowego
środowiska, nie powinni używać wartość athlon-xp dla flagi march</comment>
-march=athlon-xp
</pre>

<p>
Kolejną flagą, na którą warto zwrócić uwagę, jest <c>-O</c> (jest to duże O, nie
zero). Określa ona klasę optymalizacji używaną przez <c>gcc</c>. Dostępne klasy
to <c>s</c> (optymalizacja rozmiaru), <c>0</c> (brak optymalizacji), <c>1</c>,
<c>2</c> lub <c>3</c> - coraz silniej optymalizujące (każda z nich używa tych
samych flag, co poprzednia oraz dodaje własne). Jako przykład posłuży nam klasa
optymalizacji 2:
</p>

<pre caption="Ustawienia optymalizacji dla GCC">
-O2
</pre>

<p>
Inne popularne flagi optymalizujące to <c>-pipe</c> (gcc używa potoków zamiast
plików tymczasowych w komunikacji między różnymi etapami kompilacji) oraz
<c>-fomit-frame-pointer</c> (w rejestrach nie będą przechowywane wskaźniki
ramki dla funkcji, które ich nie wymagają).
</p>

<p>
Podczas definiowania <c>CFLAGS</c> i <c>CXXFLAGS</c> można łączyć kilka
flag optymalizacji, na przykład w ten sposób:
</p>

<pre caption="Definiowanie zmiennych CFLAGS i CXXFLAGS">
<comment># Użytkownicy AMD64 nie powinni używać athlon-xp</comment>
CFLAGS="-march=athlon-xp -pipe -O2"   
<comment># Użycie tych samych ustawień dla obu zmiennych</comment>
CXXFLAGS="${CFLAGS}"                 
</pre>

</body>
</subsection>
<subsection>
<title>MAKEOPTS</title>
<body>

<p>
Za pomocą <c>MAKEOPTS</c> definiujemy jak wiele równoległych kompilacji będzie
przeprowadzanych podczas instalowania programów. Sugerowaną liczbą jest ilość
procesorów w systemie powiększona o jeden.
</p>

<pre caption="MAKEOPTS dla przeciętnego systemu jednoprocesorowego">
MAKEOPTS="-j2"
</pre>

</body>
</subsection>
<subsection>
<title>Gotowi, do biegu, start!</title>
<body>

<p>
Wprowadzamy zmiany w pliku <path>/mnt/gentoo/etc/make.conf</path> tak, aby
odpowiadał on naszym preferencjom, a następnie zapisujemy jego zawartość
(użytkownicy <c>nano</c> powinni użyć kombinacji klawiszy
<c>Ctrl-X</c>). Jesteśmy teraz przygotowani do  <uri
link="?part=1&amp;chap=6">Instalacji systemu podstawowego</uri>.
</p>

</body>
</subsection>
</section>
</sections>
