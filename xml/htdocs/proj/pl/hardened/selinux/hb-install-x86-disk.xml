<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/pl/hardened/selinux/Attic/hb-install-x86-disk.xml,v 1.1 2006/04/07 21:35:54 shadoww Exp $ -->

<sections>
<section>
<title>Wprowadzenie do urządzeń blokowych</title>
<subsection>
<title>Urządzenia blokowe</title>
<body>

<p>
W tym rozdziale przyjrzymy się aspektom Gentoo - oraz ogólnie Linuksa -
związanym z dyskami. Omówimy systemy plików, partycje oraz urządzenia
blokowe. Następnie dokonamy podziału twardego dysku, aby jak najlepiej
wykorzystać dostępne miejsce.
</p>

<p> 
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path> reprezentujący w Linuksie pierwszy
napęd IDE. Jeśli posiadamy urządzenia SCSI, pierwszym takim
dyskiem jest <path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy użytkownika
mogą z nich korzystać nie martwiąc się, czy napędy są typu IDE, SCSI, lub
jeszcze innego. Przechowywane dane adresuje się jako ciąg 512-bajtowych bloków.
</p>

</body>
</subsection>
<subsection>
<title>Partycje</title>
<body>

<p>
Teoretycznie możliwe jest przeznaczenie całego dysku na system, jednak zazwyczaj
nie jest to rozwiązanie praktyczne. Zamiast tego dzielimy napęd na mniejsze i
dużo łatwiejsze w zarządzaniu urządzenia blokowe. W systemach na platformie x86
nazywane są one <e>partycjami</e>.
</p>

<p>
Partycje dzielą się na trzy typy: <e>podstawowe</e>, <e>rozszerzone</e> i
<e>logiczne</e>.
</p>

<p>
Informacje o partycjach <e>podstawowych</e> przechowywane są w MBR (Master Boot
Record). Jako że jest on bardzo mały (512 bajtów), mieszczą się w nim dane
maksymalnie czterech takich partycji (na przykład, od <path>/dev/hda1</path> do
<path>/dev/hda4</path>).
</p>

<p>
Specjalną odmianą partycji podstawowych są partycje <e>rozszerzone</e> (również
obowiązuje je powyższy limit). Przechowują one kolejne partycje. W ten sposób
można ominąć niewygodną granicę i lepiej zagospodarować przestrzeń dyskową bez
utraty kompatybilności wstecz.
</p>

<p>
<e>Logiczna</e> partycja to taka, która znajduje się w obrębie partycji
rozszerzonej. Dane o tych partycja nie są umieszczane w MBR, ale na rozszerzonej
partycji.
</p>

</body>
</subsection>
<subsection>
<title>Zaawansowane metody przechowywania danych</title>
<body>

<p>
Płyta LiveCD dla architektury x86 obsługuje również EVMS oraz LVM2. Dzięki nim
możemy manipulować partycjami w sposób bardziej elastyczny. W dalszej
części podręcznika skupimy się na tradycyjnych partycjach, jednak dobrze jest
wiedzieć, że EVMS i LVM2 także są obsługiwane.
</p>

</body>
</subsection>
</section>
<section>
<title>Projektowanie schematu podziału</title>
<subsection>
<title>Domyślny schemat podziału</title>
<body>

<p>
Jeśli nie chcemy tworzyć własnego schematu podziału, możemy wykorzystać ten,
który używany jest w przykładach w tym Podręczniku:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja wymiany</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Pozostała część dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Jeśli jesteśmy zainteresowani, jak wiele partycji należy stworzyć projektując
swój schemat podziału i jaki nadać im rozmiar, warto zapoznać się z kolejnym
paragrafem. W innym przypadku kontynuujemy instalację zgodnie z paragrafem
<uri link="#fdisk">Podział dysku przy pomocy programu fdisk</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Jak dużo jak wielkich?</title>
<body>

<p>
Ilość partycji ściśle zależy od przeznaczenia danego systemu. Na przykład jeśli
administrujemy systemem, w którym występuje wielu użytkowników, warto
przeznaczyć oddzielną partycję na katalog <path>/home</path>. Poprawi to
bezpieczeństwo i uprości tworzenie kopii zapasowych. Jeżeli docelowym
zastosowaniem naszego Gentoo będzie praca w roli serwera poczty, na osobnej
partycji powinniśmy umieścić <path>/var</path>, gdzie przechowywane są
listy. Ponadto wybór odpowiedniego systemu plików może w tym przypadku znacznie
zwiększyć wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem na
serwerach gier, gdyż większość używanego oprogramowania zostanie tam
zainstalowana. Powód jest podobny jak w przypadku katalogu <path>/home</path>:
bezpieczeństwo i łatwość tworzenia kopii zapasowych.
</p>

<p>
Jak widać, schemat podziału w dużej mierze zależy od tego, co chcemy osiągnąć
instalując system. Podział dysku na partycje lub woluminy ma następujące zalety:
</p>

<ul>
<li>
  Możemy wybrać najbardziej wydajny system plików dla każdej partycji lub
  woluminu.
</li>
<li>
  Zapełnienie całego wolnego miejsca na jednej partycji przez wadliwie
  działający program nie ma szkodliwego wpływu na resztę systemu.
</li>
<li>
  Testy systemów plików są krótsze, ponieważ mogą być wykonywane równolegle
  (pamiętajmy jednak, że zaleta ta uwidacznia się bardziej w przypadku
  posiadania kilku dysków, niż wielu partycji).
</li>
<li>
  Montując część partycji lub woluminów z opcjami read-only (tylko do odczytu),
  nosuid (ignorowane są bity setuid), noexec (ignorowane są bity wykonywalności)
  itd., można znacznie poprawić bezpieczeństwo.
</li>
</ul>

<p>
Niemniej jednak podział dysku na wiele partycji posiada jedną dużą wadę: jeśli
nie zrobimy tego dobrze, możemy uzyskać system z dużą ilością wolnego miejsca na
pewnych partycjach i jego brakiem na innych.
</p>

<p>
Poniżej przedstawiamy przykładowy podział dysku o rozmiarze 20GB, zastosowany w
laptopie z zainstalowanymi serwerami poczty oraz WWW, a także środowiskiem GNOME
i wieloma innymi programami:
</p>

<pre caption="Przykładowy podział dysku">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Zostało nam 2GB wolnej przestrzeni, którą będziemy mogli wykorzystać w przyszłości)</comment>
</pre>

<p>
Partycja zawierająca katalog <path>/usr</path> jest niemal w pełni zajęta
(wykorzystane 83%), ale po instalacji wszystkich potrzebnych pakietów katalog
ten nie będzie się zbytnio rozrastał. Część czytelników może pomyśleć, iż zbyt
wiele miejsca przeznaczyliśmy na <path>/var</path>. Należy jednak pamiętać, że
Gentoo kompiluje wszystkie pakiety w katalogu <path>/var/tmp/portage</path>.
Powinien on mieć wobec tego przynajmniej 1GB wolnej przestrzeni, jeśli nie
zamierzamy kompilować większych programów, lub nawet 3GB - jeśli będziemy
chcieli skompilować KDE i OpenOffice.org.
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Podział dysku przy pomocy programu fdisk</title>
<subsection>
<body>

<p>
W kolejnych paragrafach zaprezentujemy w jaki sposób utworzyć partycje zgodnie
ze schematem, który przedstawiliśmy na początku:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja wymiany</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Schemat ten modyfikujemy stosownie do swoich potrzeb.
</p>

</body>
</subsection>
<subsection>
<title>Wyświetlanie aktualnego podziału dysku</title>
<body>

<p>
<c>fdisk</c> to popularne i wygodne narzędzie do partycjonowania dysków.
Zacznijmy od uruchomienia go dla naszego dysku (pokażemy to na przykładzie
<path>/dev/hda</path>):
</p>

<pre caption="Uruchamianie programu fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Naszym oczom ukaże się taki znak zachęty:
</p>

<pre caption="Znak zachęty programu fdisk">
Command (m for help): 
</pre>

<p>
Aby wyświetlić obecną konfigurację partycji, wpisujemy <c>p</c>:
</p>

<pre caption="Przykładowa konfiguracja partycji">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Powyższy podział obejmuje siedem linuksowych systemów plików (każdy na osobnej
partycji, oznaczonej jako "Linux") oraz partycję wymiany (oznaczoną jako "Linux
swap").
</p>

</body>
</subsection>
<subsection>
<title>Usuwanie wszystkich partycji</title>
<body>

<p>
Zacznijmy od usunięcia partycji. Służy do tego polecenie <c>d</c> z odpowiednim
parametrem. Na przykład, aby pozbyć się <path>/dev/hda1</path>:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Partycja została zaznaczona do usunięcia. Nie będzie się ona więcej pojawiać po
wydaniu polecenia <c>p</c>, ale pozostanie nienaruszony dopóki zmiany nie zostaną
fizycznie zapisane. Jeśli popełnimy błąd i będziemy chcieli anulować wszystkie
wprowadzone zmiany, wpiszmy natychmiast <c>q</c> i potwierdźmy klawiszem
Enter. Wszystkie zmiany zostaną anulowane.
</p>

<p>
Zakładając, że chcemy pozbyć się wszystkich istniejących partycji, na przemian
wpisujemy <c>p</c>, aby wyświetlić ich listę i po kolei kasujemy je poleceniem
<c>d</c> z odpowiednim numerem. Po ukończeniu, polecenie <c>p</c> powinno dać
następujący rezultat:
</p>

<pre caption="Pusta tablica partycji">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Kiedy nasza tymczasowa kopia tablicy partycji będzie pusta, możemy rozpocząć
tworzenie nowego podziału. Pokażemy to na przykładzie znanego nam już
domyślnego schematu. Oczywiście jeśli nam on nie odpowiada, wprowadzamy
odpowiednie zmiany.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji boot</title>
<body>

<p>
Rozpoczniemy od utworzenia niewielkiej partycji boot. Wpisujemy <c>n</c>, aby ją
założyć, następnie <c>p</c> - aby nadać jej typ podstawowy - oraz <c>1</c>,
ponieważ będzie to pierwsza taka partycja. Na pytanie o pierwszy cylinder
odpowiadamy wciskając Enter, natomiast zapytani o ostatni, wpisujemy
<c>+32M</c>, żeby nadać partycji rozmiar 32MB.
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Teraz polecenie <c>p</c> powinno pokazać następujący listing:
</p>

<pre caption="Utworzona partycja boot">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Musimy oznaczyć naszą partycję jako bootowalną. W tym celu skorzystamy z
polecenia <c>a</c>. Na kolejnych wydrukach podziału, w kolumnie "Boot" pokazywać
się będzie <c>*</c> obok tej partycji.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji wymiany</title>
<body>

<p>
Nadszedł czas na utworzenie partycji wymiany. Ponownie korzystamy z polecenia
<c>n</c>, następnie wpisujemy <c>p</c>, gdyż ma to być partycja podstawowa i
<c>2</c>, ponieważ będzie ona drugą tego typu. Zapytani o pierwszy cylinder
wciskamy Enter, natomiast na pytanie o ostatni odpowiadamy, wpisując
<c>+512M</c>, żeby nadać partycji rozmiar 512MB. Następnie wpisujemy polecenie
<c>t</c>, aby zmienić typ naszej nowej partycji, podajemy <c>2</c>, aby wybrać
tę, którą właśnie stworzyliśmy i <c>82</c>, dzięki czemu oznaczymy ją jako
"Linux Swap". Teraz polecenie <c>p</c> powinno dać następujący listing:
</p>

<pre caption="Wydruk podziału po utworzeniu partycji wymiany">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji root</title>
<body>

<p>
Na koniec, utworzymy partycję root. Aby tego dokonać jeszcze raz posłużymy się
poleceniem <c>n</c>. Zapytani o rodzaj wpisujemy <c>p</c>, aby była to partycja
podstawowa, następnie <c>3</c>, gdyż będzie już trzecią tego typu, czyli w
naszym przypadku <path>/dev/hda3</path>. Na pytanie o pierwszy i ostatni
cylinder odpowiadamy wciskając Enter - dzięki temu zajmie ona całą pozostałą
wolną przestrzeń. Teraz polecenie <c>p</c> powinno pokazać następujący wydruk:
</p>

<pre caption="Wydruk podziału po utworzeniu partycji root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Zapisywanie podziału partycji</title>
<body>

<p>
Aby zachować ustalony podział i opuścić <c>fdisk</c>, wpisujemy <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie programu fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Gdy partycje są już przygotowane, możemy przejść do <uri
link="#filesystems">Zakładania systemów plików</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Zakładanie systemów plików</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Po utworzeniu partycji nadszedł czas na założenie na nich systemów plików.
Jeśli jest nam obojętne jakie systemy plików wykorzystamy lub chcemy zdać się na
domyślne ustawienia prezentowane w tym Podręczniku, możemy od razu przejść do
paragrafu <uri link="#filesystems-apply">Zakładanie systemów plików na
partycjach</uri>. W przeciwnym wypadku przyjrzyjmy się systemom plików w
następnym paragrafie.
</p>

</body>
</subsection>
<subsection>
<title>Systemy plików?</title>
<body>

<p>
Jądro Linux może współpracować z wieloma różnymi systemami plików. W Podręczniku
omówimy te najczęściej używane, czyli ext2, ext3, ReiserFS, XFS i JFS.
</p>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików, którego główną
wadą jest to, że nie posiada księgowania. W wyniku tego jego regularne
sprawdzanie przy starcie systemu bywa czasochłonne. Obecnie istnieją nowoczesne
systemy plików z księgowaniem, które można szybko sprawdzić i właśnie te
polecamy naszym użytkownikom. Księgowanie zapobiega długotrwałym kontrolom
podczas uruchamiania systemu oraz ewentualnym błędom spójności danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach full oraz
ordered, dzięki czemu w razie awarii dane odzyskiwane są błyskawicznie. Jest on
bardzo dobrym i niezawodnym rozwiązaniem. Posiada ukrytą opcję korzystania z
drzewa b, co znacznie poprawia wydajność niemal we wszystkich sytuacjach. Krótko
mówiąc, ext3 jest świetnym systemem plików.
</p>

<!--
<p>
<b>ReiserFS</b> to system plików oparty na drzewie B*, oferujący dużą
wydajność. Przy wielu małych plikach (poniżej 4k) może być szybszy od ext3 nawet
piętnastokrotnie. ReiserFS jest wysoce skalowalny i posiada księgowanie, a
począwszy od jądra 2.4.18, charakteryzuje go niezawodność i użyteczność zarówno
na partycjach ogólnego przeznaczenia jak i w ekstremalnych przypadkach, takich
jak ogromne partycje, operacje na wielu bardzo małych, lub bardzo dużych plikach
czy też operacje na katalogach zawierających dziesiątki tysięcy plików.
</p>
-->

<p>
<b>XFS</b> to system plików z księgowaniem. Jest bardzo funkcjonalny i
zoptymalizowany pod względem skalowalności. Zalecamy go wyłącznie do systemów z
nowoczesnymi dyskami SCSI i/lub ciągłego zapisu danych z nieprzerwanym dostępem
zasilania. Ponieważ XFS przechowuje dużo danych w pamięci RAM, źle
zaprojektowane programy - które nie zachowują odpowiednich środków ostrożności
podczas zapisywania plików na dysku, a tych niestety jest sporo - mogą
doprowadzić w razie awarii zasilania do utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików firmy IBM wyposażony w księgowanie.
Jest dość nowy i jeszcze za wcześnie by oceniać jego stabilność.
</p>

<warn>
ReiserFS nie jest poprawnie obsługiwany ze względu na brak wymaganych
rozszerzonych atrybutów.
</warn>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie systemów plików na partycjach</title>
<body>

<p>
Kolejnym etapem jest założenie na partycjach systemów plików przy pomocy
odpowiednich narzędzi:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Program</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<!--
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
-->
<tr>
  <ti>XFS</ti>
  <ti><c>mkfs.xfs -i size=512</c></ti>
</tr>
<tr>
  <ti>JFS</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć system plików ext2 na partycji boot (w naszym przypadku
<path>/dev/hda1</path>) oraz ext3 na partycji root (w naszym przypadku
<path>/dev/hda3</path>) należy wykonać następujące polecenia:
</p>

<pre caption="Zakładanie systemów plików na partycjach">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Teraz tworzymy systemy plików na wszystkich naszych partycjach.
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja partycji wymiany</title>
<body>

<p>
Do tworzenia partycji wymiany, służy program <c>mkswap</c>:
</p>

<pre caption="Tworzenie partycji wymiany">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Aby aktywować partycję wymiany, należy użyć programu <c>swapon</c>:
</p>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/hda2</i>
</pre>

<!--
<p>
Teraz wykonujemy powyższe czynności.
</p>
-->

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu na nich systemów plików nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Pamiętajmy o utworzeniu
odpowiednich katalogów dla montowanych partycji. W przykładzie zamontujemy
partycje boot i root:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Jeżeli na katalog <path>/tmp</path> przeznaczyliśmy osobną partycję, należy po
jej zamontowaniu odpowiednio zmienić prawa dostępu: <c>chmod 1777
/mnt/gentoo/tmp</c>. Dotyczy to również <path>/var/tmp</path>.
</note>

<p>
Musimy także zamontować system plików proc (wirtualny interfejs jądra) w
katalogu <path>/proc</path>. Najpierw jednak konieczne jest umieszczenie
odpowiednich plików na partycjach.
</p>

<p>
Kontynuujemy instalację zgodnie z rozdziałem <uri
link="?part=1&amp;chap=5">Wypakowywanie plików instalacyjnych Gentoo</uri>.
</p>

</body>
</section>
</sections>
