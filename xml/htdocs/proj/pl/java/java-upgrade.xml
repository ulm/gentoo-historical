<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/pl/java/java-upgrade.xml,v 1.1 2006/07/19 16:35:30 shadoww Exp $ -->

<guide link="/proj/pl/java/java-upgrade.xml" lang="pl">
<title>Przewodnik po aktualizacji systemu maszyn wirtualnych Java w Gentoo</title>

<author title="Autor">
  <mail link="nichoj@gentoo.org">Joshua Nichols</mail>
</author>
<author title="Autor">
  <mail link="kartk@gentoo.org">Karl Trygve Kalleberg</mail>
</author>
<author title="Redaktor">
  <mail link="nightmorph@gentoo.org">Josh Saddler</mail>
</author>
<author title="Tłumacz">
  <mail link="astralstorm@gmail.com">Radosław Szkodziński</mail>
</author>

<abstract>
Ten przewodnik przedstawia sposób aktualizacji wsparcia dla języka programowania
Java w Gentoo do nowej generacji, jak również związane z tym pojęcia i
narzędzia.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0.7</version>
<date>2006-07-16</date>

<chapter>
<title>Zanim zaczniesz</title>
<section>
<body>

<p>
Oto lista terminów, które mogą okazać się przydatne.
</p>

<dl>
  <dt>Generacja</dt>
  <dd>
    <ul>
      <li>
        Nowa koncepcja. Generacja to zestaw programów i eklas
        wykorzystywanych do tworzenia pakietów w języku Java. W pewnym momencie
        zamierzamy przejść z obecnej generacji do nowszej. W międzyczasie obie
        generacje mogą współistnieć. Na przykład, można mieć zainstalowaną
        systemową maszynę wirtualną generacji X <e>jednocześnie</e> z maszyną
        wirtualną generacji X+1. W ten sposób pakiety korzystające z generacji
        X i generacji X+1 mogą występować razem podczas przejścia na nowszą
        generację.
      </li>
    </ul>
  </dd>
  <dt>Pierwsza generacja</dt>
  <dd>
    <ul>
      <li>
        Składa się z obecnych wersji pakietów i eklas Javy oraz programu
        <c>java-config-1.x</c>
      </li>
    </ul>
  </dd>
  <dt>Druga generacja</dt>
  <dd>
    <ul>
      <li>
        Nowa wersja, która była opracowywana przez prawie rok.
      </li>
    </ul>
  </dd>
</dl>

<dl>
  <dt>Systemowa maszyna wirtualna pierwszej generacji</dt>
  <dd>
    <ul>
      <li>
        Ta maszyna wirtualna służy do instalacji pakietów w języku Java
        korzystających z eklas pierwszej generacji. Wybiera się ją za pomocą
        polecenia <c>java-config-1 --set-system-vm &lt;wybrana maszyna&gt;</c>.
      </li>
    </ul>
  </dd>
  <dt>Systemowa maszyna wirtualna drugiej generacji</dt>
  <dd>
    <ul>
      <li>
        Maszyna wirtualna, z której korzystają tylko root i użytkownicy, którzy
        nie wybrali własnej maszyny wirtualnej.
      </li>
    </ul>
  </dd>
  <dt>Instalacyjna maszyna wirtualna drugiej generacji</dt>
  <dd>
    <ul>
      <li>
        W drugiej generacji wprowadzono nowy rodzaj maszyny wirtualnej.
        Służy ona do budowania pakietów korzystających z Javy. Standardowo
        pakiety będą próbowały korzystać z maszyny wirtualnej o najniższym
        numerze wersji. To, którego dostawcy maszyna wirtualna będzie
        zastosowana, zależy od architektury. Wartości domyślne są ustawione w
        pliku
        <path>/usr/share/java-config-2/config/jdk-defaults.conf</path>.
        Dodatkowo, instalacyjną maszynę wirtualną można wybrać w pliku
        <path>/etc/java-config-2/build/jdk.conf</path>.
      </li>
    </ul>
  </dd>
</dl>

</body>
</section>
</chapter>

<chapter>
<title>Słowa kluczowe</title>
<section>
<body>

<p>
Jeżeli korzystamy ze stabilnej gałęzi, n.p. x86, ppc, lub amd64, a nie ~x86,
~ppc, czy ~amd64, trzeba będzie dodać pewne wpisy do pliku
<path>/etc/portage/package.keywords</path>.
</p>

<pre caption="package.keywords">
dev-java/ant-core
dev-java/ant-tasks
dev-java/ant
dev-java/blackdown-jdk
dev-java/blackdown-jre
dev-java/eclipse-ecj
dev-java/ibm-jdk-bin
dev-java/ibm-jre-bin
dev-java/java-config
dev-java/java-config-wrapper
dev-java/javatoolkit
dev-java/jikes
dev-java/jrockit-jdk-bin
dev-java/kaffe
dev-java/sun-jdk
dev-java/sun-jre-bin
virtual/jdk
virtual/jre
</pre>

<impo>
Koniecznie trzeba dodać wpisy dla WSZYSTKICH pakietów należących do nowego
systemu Java, w innym razie wystąpią problemy przy wykonywaniu dalszych kroków
przewodnika.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Aktualizacja java-config</title>
<section>
<body>

<p>
Nowy pakiet, <c>java-config-wrapper</c>, jest blokowany przez starsze wersje
<c>java-config</c>, należy więc je usunąć:
</p>

<pre caption="Usuwanie starej wersji java-config">
# <i>emerge -C java-config</i>
</pre>

<p>
Teraz trzeba zainstalować nowy <c>java-config</c>:
</p>

<pre caption="Instalacja nowego java-config">
# <i>emerge -1 =java-config-1* =java-config-2*</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Sprawdzenie środowiska Java</title>
<section>
<body>

<p>
Dostarczamy nowy skrypt <c>/usr/bin/java-check-environment</c>, służący do
sprawdzenia środowiska Java. Przekazuje on informacje na temat kroków, które
należy podjąć aby zlikwidować znalezione problemy. Zatem uruchom:
</p>

<pre caption="Sprawdzanie środowiska">
# <i>/usr/bin/java-check-environment</i>
</pre>

<note>
Można go uruchomić jako użytkownik inny niż root, lecz tylko root potrzebuje
maszyny wirtualnej pierwszej generacji. Skrypt powiadomi o jej braku, jeśli
będzie uruchomiony na koncie użytkownika. Jest to normalne i można to
zignorować.
</note>

<p>
Kolejny punkt to...
</p>

</body>
</section>
<section>
<title>Aktualizacja maszyn wirtualnych</title>
<body>

<p>
W pierwszej sekcji uruchomiliśmy skrypt wyszujkujący pliki starej wersji
<c>java-config</c> w <path>/etc/env.d/java</path>. Instrukcje napisane przez
skrypt powinny być oczywiste. Po prostu należy skasować pliki, a następnie
przeinstalować pakiety, które zostały wymienione.
</p>

</body>
</section>
<section>
<title>Kasowanie starych plików konfiguracyjnych z kont użytkowników</title>
<body>

<p>
Skrypt <c>java-check-environment</c> powiadamia również o plikach
konfiguracyjnych pierwszej generacji w katalogach domowych użytkowników.
Te pliki nie są już wspierane. Jeżeli
<c>java-check-environment</c> wykryje takie pliki, należy uruchomić zgodnie z
zaleceniami:
</p>

<note>Dotyczy to tylko użytkowników innych niż root.</note>

<pre caption="Kasowanie starych plików konfiguracyjnych">
# <i>java-config-2 --list-available-vms</i>
# <i>java-config-2 --set-user-vm &lt;wybrana maszyna&gt;</i>
</pre>

</body>
</section>
<section>
<title>
Sprawdzenie, czy ustawiono systemawą maszynę wirtualną pierwszej
generacji
</title>
<body>

<p>
Kolejnym możliwym problemem jest brak ustawionej systemowej maszyny wirtualnej
pierwszej generacji.
</p>

<pre caption="Ustawienie systemowej maszyny wirtualnej pierwzej generacji">
# <i>java-config-1 -L</i>
# <i>java-config-1 -S &lt;wyrana maszyna&gt;</i>
</pre>

<impo>
Systemowa maszyna pierwszej generacji <b>MUSI</b> być w wersji 1.4 i musi to
być JDK. Musismy ją zainstalować, jeśli jeszcze jej nie posiadamy.
</impo>

<note>
MUSISZ zawsze mieć zainstalowaną maszynę wirtualną w wersji 1.4 JDK.
Jest ona wymagana do instalacji pakietów korzystających z pierwszej generacji
jak i dla pakietów, które nie działają z Javą 1.5.
</note>

<p>
Teraz należy uruchomić:
</p>

<pre caption="Aktualizacja środowiska">
# <i>env-update &amp;&amp; source /etc/profile</i>
</pre>

<p>
Aby mieć pewność, że środowisko jest poprawnie ustawione.
</p>

</body>
</section>
<section>
<title>1.5 JDK jako maszyna wirtualna pierwszej generacji</title>
<body>

<p>
Teraz trzeba sprawdzić, czy przypadkiem maszyna wirtualna wersji 1.5 nie jest
wybrana jako systemowa maszyna wirtualna pierwszej generacji. Powinno się do
tego korzystać z maszyny wirtualnej w wersji 1.4 JDK. Jeśli postępowaliśmy
zgodnie z tym przewodnikiem, wystarczy jedynie skorzystać z instrukcji
ustawiania systemowej maszyny wirtualnej pierwszej generacji, zamieszczonych
powyżej.
</p>

<p>
Istnieje możliwość, że w systemie występuje kod prekompilowany dla Javy 1.5.
Może to prowadzić do ostrzeżeń "UnsupportedClassVersionError". Aby to naprawić,
należy uruchomić:
</p>


<pre caption="Uruchomienie skryptu naprawczego Javy 1.5">
# <i>/usr/bin/java-1.5-fixer</i>
</pre>

<impo>
Jeśli kiedykolwiek korzystaliśmy z Javy w wersji 1.5, powinniśmy uruchomić
java-1.5-fixer. Dzięki temu stary kod prekompilowany dla Javy 1.5 zostanie
usunięty i uniknie się późniejszych problemów.
</impo>

<impo>
java-1.5-fixer jest tylko wygodnym skryptem do
przekompilowania pakietów wcześniej przygotowanych dla Javy 1.5 przez Javę 1.4.
Nie jest idealny i może nie być w stanie naprawić wszystkich pakietów na każdym
systemie. W przypadku gdy zawiedzie, z reguły należy zreinstalować źle
działający pakiet korzystający z Javy.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Zaktualizowana dokumentacja</title>
<section>
<body>
<p>
Dokumentacja została zaktualizowana, aby uzględnić zmiany w sposobie instalacji
Javy.
</p>

<ul>
  <li><uri link="/doc/pl/java.xml">Podręcznik użytkownika</uri></li>
  <li><uri link="/proj/en/java/java-devel.xml">Developer guide</uri></li>
</ul>
</body>

</section>
</chapter>

<chapter>
<title>Częste problemy i pytania</title>

<section>
<title>
java-check-environment wypisuje ciągle problemy z tymi samymi maszynami
wirtualnymi lub java-config-1 -L nic nie wypisuje.
</title>
<body>

<p>
Prawdopodobnie przyczyną jest pomyłka w ustawianiu architektury dla pakietów
lub przy odmaskowywaniu. Musisz odmaskować lub podać w pliku
package.keywords wszystkie pakiety należące do nowego systemu Java.
</p>

<p>
W szczególności jest to spowodowane nie podaniem lub nie odmaskowaniem
wszystkich obecnie zainstalowanych maszyn wirtualnych.
</p>

</body>
</section>

<section>
<title>
Dlaczego nie mogę skorzystać z Javy 1.5 JDK jako systemowej maszyny
wirtualnej pierwszej generacji?
</title>
<body>

<p>
Wybierając Javę 1.5 JDK jako systemową maszynę wirtualną pierwszej generacji,
natrafi się na problemy, które normalnie powodowane są przez zamaskowanie
pakietu.
</p>

<p>
Mimo, że niektórzy używali wersji 1.5 jako systemowej maszyny wirtualnej bez
problemów, część pakietów nie działa z nowszą wersją. Zasadniczo wymagamy wersji
1.4, gdyż będzie działać z pakietami Javy jeszcze nie dostosowanymi do nowego
systemu.
</p>

</body>
</section>

<section>
<title>
Aplikacje próbują korzystać ze zmiennej JAVA_HOME, która prowadzi do
maszyny wirtualnej pierwszej generacji
</title>
<body>

<p>
Niektóre aplikacje korzystają z JAVA_HOME, aby wywoływać maszynę wirtualną
Java. Ta zmienna jest ustawiona w <path>/etc/env.d/20java</path>. Będzie
powodowało to błąd dopóki aplikacja nie zostanie zmuszona do użycia nowych
eklas.
</p>

<p>
Jednym z możliwych rozwiązań jest wykorzystanie poniższego skryptu do
ustawienia JAVA_HOME:
</p>

<pre caption="Sprawdzanie środowiska">
if [[ -L $HOME/.gentoo/java-config-2/current-user-vm ]]; then
  export JAVA_HOME=$HOME/.gentoo/java-config-2/current-user-vm
elif [[ -L /etc/java-config-2/current-system-vm ]]; then
  export JAVA_HOME=/etc/java-config-2/current-system-vm
fi
</pre>

<p>
Ten skrypt można włączyć w swój <path>.bash_profile</path>, ale nie jest to
zalecane. Nowy system ma wyeliminować konieczność modyfikacji środowiska.
Korzystając z powyższego skryptu będziesz musiał aktualizować środowisko przez
<c>source ~/.bash_profile</c>, gdy ustawimy nową maszynę wirtualną użytkownika,
by uzyskać poprawną zmienną JAVA_HOME.
</p>

<warn>
Nie należy dodawać tego do <path>bash_profile</path> użytkownika root!
Spowoduje to problemy z pakietami korzystającymi z pierwszej generacji, jeśli
mamy maszynę wirtualną wersji 1.5 ustawioną jako systemową drugiej generacji.
</warn>

<p>
Znacznie lepszym wyjściem jest zaktualizowanie pakietu, aby stosował nowy
system Java. Jeśli natrafimy na aplikację korzystającą z JAVA_HOME, należy
skontaktować się z <mail link="nichoj@gentoo.org">nichoj</mail> na kanale IRC
#gentoo-java lub wyśłać e-mail na listę mailingową gentoo-java.
</p>

</body>
</section>
</chapter>
</guide>
