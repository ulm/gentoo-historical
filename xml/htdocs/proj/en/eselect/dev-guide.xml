<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/eselect-dev-guide.xml">
<title>eselect Developer Reference</title>

<author title="Author">
	<mail link="ciaranm@gentoo.org">Ciaran McCreesh</mail>
</author>
<author title="Author">
	<mail link="kugelfang@gentoo.org">Danny van Dyk</mail>
</author>
<author title="Editor">
	<mail link="fox2mike@gentoo.org">Shyam Mani</mail>
</author>

<abstract>
This document is a reference for people who want to develop the eselect tool.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.9.4.133</version>
<date>2005-06-15</date>

<chapter>
<title>Introduction</title>
<section>
<title>About eselect</title>
<body>

<p>
eselect is a framework for simplyfying and introducing consistency to the
various <c>foo-config</c> and <c>blah-update</c> tools. It is an option for
developers who don't like reinventing the wheel, not a mandatory tool.
</p>

<note>
This document assumes some basic familiarity with eselect. Please read the <uri
link="/proj/en/eselect/user-guide.xml">eselect User Guide</uri> in case you
do not know the basics of eselect.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Getting Started</title>
<section>
<title>Introduction</title>
<body>

<p>
When porting your application to use the eselect framework, you will generally
need to create a module. Often this can be heavily based upon an existing
module, so check to see whether there is something that does almost what you
need first (symlink handling is a good example of something that can be copied
rather than reinvented).
</p>

</body>
</section>
<section>
<title>A Simple Module</title>
<body>

<p>
It's easiest to illustrate by example. Here's a simple module, named 
<c>cow.eselect</c>. It has two actions, <c>moo</c> and <c>think</c>, plus the 
standard <c>help</c>, <c>usage</c> and <c>version</c> actions, and is 
installed to <path>$(datadir)/eselect/modules/</path>.
</p>

<pre caption="cow.eselect code">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/eselect/dev-guide.xml,v 1.1 2005/06/15 17:58:36 fox2mike Exp $

DESCRIPTION="Do things to a cow"
VERSION="1.0"

### moo action

describe_moo() {
	echo "Say moo"
}

do_moo() {
	echo "${@:-I am a cow}" | cowsay
}

### think action

describe_think() {
	echo "Show a pensive cow"
}

do_think() {
	echo "${@:-Am I a cow?}" | cowthink
}
</pre>

<p>
As you can see, the format is fairly similar to that of an ebuild -- it is a
bash script which is run in a special environment. This is intentional. There
are DESCRIPTION and VERSION variables globally which are used by 
<c>eselect</c> and some of the default action handlers, and a series of 
functions.
</p>

<warn>
In ebuilds, global scope code can cause problems. In eselect modules, global 
scope code is <e>absolutely forbidden</e>. Your module <e>will</e> be sourced 
for tasks other than running your actions. For example, if 
<c>eselect list-modules</c> is executed, your module will be sourced to obtain 
the description. Any code being run here would be a very bad thing.
</warn>

<p>
Unlike ebuilds, the function names are not fixed. Any function whose name 
starts with <c>do_</c> is considered to be an action implementation. It is 
conventional to have a <c>describe_</c> function for every <c>do_</c> function 
that gives a short description of the function -- this is used for 
<c>eselect modulename help</c>, for example.
</p>

<note>
If eselect is invoked as <c>cow-config</c> or <c>cow-update</c> (for example, 
via a symlink), it will automatically select the cow module.
</note>

</body>
</section>
<section>
<title>Standard Action Names</title>
<body>

<p>
The following list contains suggested allowed names for actions. If there is no
suitable name on the list for your task, it is best to ask for the list to be
updated -- for consistency, it would be nice to have a standardised list of
action names. (The cow module, being a silly demonstration module, is exempt.)
</p>

<ul>
	<li>
	<c>help</c> - Display a help message. Automatic.
	</li>
	<li>
	<c>usage</c> - Display a usage message. Automatic.
	</li>
	<li>
	<c>version</c> - Display the current version. Automatic.
	</li>
	<li>
	<c>show</c> - Used to display the current provider of a symlink, or the 
	currently installed module, or the current status.
	</li>
	<li>
	<c>list</c> - Used to display all available providers of a symlink, or all 
	available modules.
	</li>
	<li>
	<c>set</c> - Used to set a new provider or a symlink.
	</li>
	<li>
	<c>enable</c> - Used to enable an optional feature.
	</li>
	<li>
	<c>disable</c> - Used to disable an optional feature.
	</li>
	<li>
	<c>scan</c> - Read information off the current filesystem.
	</li>
	<li>
	<c>update</c> - Used to automatically select a new provider for a symlink 
	(as opposed to <c>set</c>, which generally takes a parameter manually 
	selecting the provider) or to gather system information that is vital to 
	further actions.
	</li>
</ul>

<note>
You can override the <c>help</c>, <c>usage</c> and <c>version</c> actions. 
They are provided by default by <path>lib/default.eselect</path>. You should 
only do this with a good reason. Removing them is not a good idea, 
<c>eselect</c> assumes that they exist.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Utility Functions</title>
<section>
<title>Introduction</title>
<body>

<p>
eselect provides many utility functions. These are useful for standardised
output formatting. Where possible, these should be used, especially for output.
If a standard function is not available for the output format required, consider
implementing one.
</p>

</body>
</section>
<section>
<title>General Utility Functions</title>
<body>

<p>
These are implemented in <path>libs/core.bash</path>.
</p>

<p>
<b>The die Function</b>
</p>

<p>
The <c>die</c> function (which, unlike its ebuild counterpart, <e>can</e> be 
called from within subshells) is used to exit with a fatal error. It should 
be invoked as <c>die -q "Message to display"</c>. If the <c>-q</c> is not 
provided, a stacktrace will be displayed -- this should never happen because 
of user input error, only abnormal conditions.
</p>

<p>
<b>The is_function Function</b>
</p>

<p>
The <c>is_function</c> utility function returns true if and only if its 
parameter exists and is a function. This is mostly used internally, but may 
have some use for modules.
</p>

<p>
<b>The check_do Function</b>
</p>

<p>
The <c>check_do</c> utility function checks that the first parameter is a 
function, and then calls it with any additional parameters as its arguments. 
If the function does not exist, <c>die</c> is called. Again, this is mostly 
internal.
</p>

<p>
<b>The do_action Function</b>
</p>

<p>
The <c>do_action</c> utility function is the correct way to call a utility 
function which is defined in another module. The first parameter is the action,
additional parameters are passed as arguments.
</p>

<p>
<b>The has Function</b>
</p>

<p>
The <c>has</c> utility function is like portage's <c>hasq</c>. It returns true 
if and only if the first parameter is equal to any of the remaining parameters.
</p>

</body>
</section>
<section>
<title>Output Utility Functions</title>
<body>

<p>
These are implemented in <path>libs/output.bash</path>
</p>

<p>
<b>The write_error_msg Function</b>
</p>

<p>
The <c>write_error_msg</c> function displays an error message in the standard
format. It is similar to <c>eerror</c>.
</p>

<p>
<b>The write_list_ Function</b>
</p>

<p>
To display a list, the <c>write_list_</c> family of functions should be used. 
Lists should always start with a header, which can be displayed using
<c>write_list_start The Header</c>.
</p>

<p>
To display a numbered list, the <c>write_numbered_list_entry</c> function 
should be used for each item. The first parameter is the list item number, the 
second is the list item text (remember to quote this).
</p>

<p>
To display a keyword/value list, the <c>write_kv_list_entry</c> function should
be used. The first parameter is the key, the second the value.
</p>

<p>
The <c>write_numbered_list</c> function is a wrapper around 
<c>write_numbered_list_entry</c> that handles the numbering automatically. Each
parameter passed is displayed as a numbered list item, the first with index 1,
the second with index 2 and so on.
</p>

<p>
<b>The highlight Function</b>
</p>

<p>
The <c>highlight</c> utility function can be used to emphasise some text which
is to be displayed by any of the above functions. A typical invocation might
look like the code listing shown below.
</p>

<pre caption="highlight example">
write_list_start "This is $(highlight list) example"
write_kv_list_entry "First" "This is the first"
write_kv_list_entry "$(highlight Second)" "This is the $(highlight second) entry"
write_kv_list_entry "Third" "$(highlight The end)"
</pre>

<p>
<b>The highlight_warning Function</b>
</p>

<p>
The <c>highlight_warning</c> function is like <c>highlight</c>, but for 
warnings. It displays the text in question in red.
</p>

<p>
<b>The space Function</b>
</p>

<p>
The <c>space</c> utility function takes a single integer parameter. It displays
that many space characters.
</p>

</body>
</section>
<section>
<title>Test Functions</title>
<body>

<p>
These are implemented in <path>libs/tests.bash</path>.
</p>

<p>
<b>The is_number Function</b>
</p>

<p>
Returns true if and only if the parameter is a positive whole number.
</p>

</body>
</section>
<section>
<title>Manipulation Functions</title>
<body>

<p>
These are implemented in <path>libs/manip.bash</path>.
</p>

<p>
<b>The svn_date_to_version Function</b>
</p>

<p>
The <c>svn_date_to_version</c> function can be used instead of manually keeping
track of VERSION. It is safe to use in global scope. The canonical usage is
as shown below.
</p>

<pre caption="svn_date_to_version usage">
SVN_DATE='$Date: 2005/06/15 17:58:36 $'
VERSION=$(svn_date_to_version "${SVN_DATE}" )
<comment>(Now turn on the SVN keyword expansion for the module)</comment>
svn propset svn:keywords "Date" modules/foo.eselect
</pre>

</body>
</section>
<section>
<title>Configuration Functions</title>
<body>

<p>
These are implemented in <path>libs/config.bash</path>.
</p>

<p>
<b>The store_config Function</b>
</p>

<p>
The <c>store_config</c> function saves a key/value pair in a given
configuration file which is passed as first argument. This file
is a bash script consisting only of key/value pairs and should not be altered
manually. Comments in the file will be deleted each time <c>store_config</c> is
called. The function is invoked as <c>store_config filename key value</c>.
</p>

<p>
<b>The load_config Function</b>
</p>

<p>
The <c>load_config</c> function loads a stored value from the module's
configuration file. It is invoked as <c>load_config filename key</c>
and prints the associated value.
</p>

<p>
<b>The add_config Function</b>
</p>

<p>
The <c>add_config</c> function adds an item to an already stored value in the
modules configuration file. It uses <c>load_config</c>/<c>store_config</c>
internally and should be invoked as <c>add_config filename key item</c>.
</p>

</body>
</section>
<section>
<title>Multilib Functions</title>
<body>

<p>
These are implemented in <path>libs/multilib.bash</path>.
</p>

<p>
<b>The list_libdirs Function</b>
</p>

<p>
The <c>list_libdirs</c> function returns a set of valid libdirs for the used
architecture. It uses <c>uname</c> to determine the architecture.
</p>

</body>
</section>
</chapter>
</guide>
