<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux-development.xml,v 1.2 2011/09/04 19:55:28 swift Exp $ -->

<guide link="/proj/en/hardened/selinux-development.xml" lang="en">
<title>Gentoo Hardened SELinux Development</title>
<author title="Author">
  <mail link="sven.vermeulen@siphos.be">Sven Vermeulen</mail>
</author>

<abstract>
When planning to help Gentoo Hardened in the development of SELinux policies,
or when trying to debug existing policies, this document should help you get
acquainted with the necessary resources, trips and tricks to get along.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>2</version>
<date>2011-09-04</date>

<chapter>
<title>Introduction</title>
<section>
<title>About this document...</title>
<body>

<p>
Dealing with Mandatory Access Control is never easy. SELinux might be available
by default with Linux, enabling it can provide serious headaches - let alone
developing policies for it. Within Gentoo Hardened, we strive to offer a default
policy that is flexible enough to match the requirements of most of you (our 
users) yet remain manageable by the limited number of developers that we have.
To ensure that the policy we offer is up to date, we definitely need help from
end users and other developers, because developing policies requires intimate 
knowledge of the products they are written for. With over several thousand 
packages, this is just not feasible for a handful of us. Hence, this Gentoo
Hardened SELinux Development guide.
</p>

<p>
Within this document, we will try to explain how to set up an environment ready
to build policies yourself and provide patches to Gentoo Hardened. We also cover
how to deal with malfunctioning domains and even how to create your own, new 
domains from scratch (if we need to). Further down, we give an overview of the 
guidelines that we try to follow during the policy developments and finally
talk about how to properly create patches and submit them to our <uri 
link="https://bugs.gentoo.org">bugzilla</uri> service.
</p>

<p>
For those who want to run Gentoo Hardened with their own policies, we've also
added a chapter on just that. We know that our policy does not match everyone's
requirements, so we definitely want to help you run your own too.
</p>

</body>
</section>
<section>
<title>Intended audience</title>
<body>

<p>
This document is a must-read for everyone willing to provide patches or develop
the Gentoo Hardened SELinux policies.
</p>

<p>
Other SELinux advanced users might find this document interesting as well.
</p>

</body>
</section>
<section>
<title>What you need to know</title>
<body>

<p>
This document does assume prior knowledge on SELinux policies and the way the
reference policy works. For those that need a quick recap, here are the
highlights...
</p>

<ul>
  <li>
    SELinux uses <e>domains</e> and <e>types</e> to differentiate its various
    security objects. A domain is usually referred to as the security context
    of a process (or group of processes) whereas a type is usually referred to
    as the label given to a particular resource (file, directory, network
    interface, socket, network port, ...).
  </li>
  <li>
    <e>SELinux policies</e> describe what interaction is allowed between a
    domain and the other domains and types it needs to work with. If no policy
    allows for a particular activity, then the activity is denied.
  </li>
  <li>
    The structure in which policies are written are called <e>SELinux policy
    modules</e> which contain three parts: a <e>type enforcement file</e> (with
    suffix <path>.te</path>) that contains the intra-module permissions, an
    <e>interface file</e> (with suffix <path>.if</path>) that contains the
    inter-module permissions and a <e>file contexts file</e> (with suffix
    <path>.fc</path>) that contains the file context definitions for all file
    resources that are labeled with the type or types defined in the module
  </li>
  <li>
    Inter-domain privileges must be declared through functions in the
    <e>interface file</e> which can then be called by other modules. This
    includes the necessary permissions to allow domain transitions
  </li>
  <li>
    SELinux uses attributes to make multiple domains manageable. Domains can
    have certain permissions against all domains or types that are given a
    particular attribute. Be aware of this when you start assigning attributes
    to your own types or domains.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Setting Up Your Environment</title>
<section>
<title>Patching the reference policy</title>
<body>

<p>
Gentoo Hardened builds its policy upon the <uri 
link="http://oss.tresys.com/projects/refpolicy">reference policy</uri> as
provided by <uri link="http://www.tresys.com">Tresys</uri> and managed through
an active <uri
link="http://oss.tresys.com/projects/refpolicy/wiki/HowToContribute">community</uri>.
I suggest to use two workspaces when dealing with SELinux policies for Gentoo
Hardened: the <path>hardened</path> one for the Gentoo patched policy, and a 
<path>local</path> one in which you work and make your patches in.
</p>

<p>
Of course, using a source control system like git can be helpful too. For now,
Gentoo Hardened doesn't have a git repository where its policies are based from
(yet). That might sound a bit dull, but it forces the developers to remain as
close to upstream as possible (and contribute the changes upstream too so that
newer releases include them automatically). You can definitely use a source
control system yourself - the only reason we do not use it in this document is
that it is easier to document without ;-)
</p>

<p>
Let's create the first workspace:
</p>

<pre caption="Creating the SELinux policy workspace">
~$ <i>mkdir dev/hardened</i>
~$ <i>cd dev/hardened</i>
~$ <i>ebuild /usr/portage/sec-policy/selinux-base-policy/selinux-base-policy-2.20110726-r3.ebuild prepare</i>
~$ <i>cp -r /var/tmp/portage/sec-policy/selinux-base-policy-2.20110726-r3/work/refpolicy .</i>
~$ <i>rm -rf /var/tmp/portage/sec-policy/selinux-base-policy-2.20110726-r3</i>
</pre>

<p>
As result, you now have a subdirectory called <path>refpolicy</path> inside
<path>dev/hardened</path>. This directory contains all the SELinux policy rules
available. Now the <path>dev/hardened</path> workspace is patched with the
Gentoo Hardened SELinux patches applicable to the policy. Gentoo Hardened has
two "flavors" of patches:
</p>

<ol>
  <li>
    patches in the <e>patchbundle</e> contain the majority of patches
  </li>
  <li>
    <e>module patches</e> that contain the permissions affecting the
    domains and types that are defined in a single module (for instance, all
    interaction between <path>portage_t</path> and <path>portage_exec_t</path>
    or even <path>portage_t</path> and <path>portage_fetch_t</path>)
  </li>
</ol>

<p>
When we develop changes on the SELinux policy, we currently try to put those
changes in the patchbundle as soon as possible. Currently, the
<c>selinux-base-policy</c> package is updated fast enough to hold off module
patches and wait for a new release of <c>selinux-base-policy</c> (after which
the SELinux modules themselves can just refer to the new base policy to get
their patches).
</p>

<p>
However, when the <c>selinux-base-policy</c> is more stable, then patches might
be made part of the modules themselves. In that case, a <e>module patch</e> is
made.
</p>

<note>
Every time a new revision comes out, you'll need to clean the
<path>dev/hardened</path> workspace and rebuild it.
</note>

</body>
</section>
<section>
<title>Add specific module files</title>
<body>

<p>
To update your policy workspace, use the same tactic as describes
earlier, but now for the specific SELinux policy module package (like
<path>selinux-postfix</path>).
</p>

<pre caption="Updating the dev/hardened workspace">
~$ <i>ls dev/hardened/refpolicy/policy/modules/*/postfix.te</i>
dev/hardened/refpolicy/policy/modules/services/postfix.te
<comment>                                      ^^^^^^^^</comment>
~$ <i>ebuild /usr/portage/sec-policy/selinux-postfix/selinux-postfix-2.20110726-r1.ebuild prepare</i>

<comment># Next, we copy the postfix.te and postfix.fc files.
# Do NOT copy the postfix.if file (as the one available there is a stub)</comment>
~$ <i>cp /var/tmp/portage/sec-policy/selinux-postfix-2.20110726-r1/work/strict/postfix.te \
  dev/hardened/refpolicy/policy/modules/services/</i>
<comment>                                        ^^^^^^^^</comment>
~$ <i>cp /var/tmp/portage/sec-policy/selinux-postfix-2.20110726-r1/work/strict/postfix.fc \
  dev/hardened/refpolicy/policy/modules/services/</i>
<comment>                                        ^^^^^^^^</comment>
~$ <i>rm -rf /var/tmp/portage/sec-policy/selinux-postfix-2.20110726-r1</i>
</pre>

</body>
</section>
<section>
<title>Setting up a local workspace</title>
<body>

<p>
Setting up a local workspace (where we will create changes and generate patches
out of later) is easy: just copy the <path>dev/hardened</path> one:
</p>

<pre caption="Setting up a local workspace">
~$ <i>cd dev/hardened</i>
~$ <i>cp -r refpolicy refpolicy.local/</i>
</pre>

</body>
</section>
<section>
<title>Navigating the policy workspace</title>
<body>

<p>
The main location you will work with is
<path>dev/hardened/refpolicy.local/policy/modules</path>. This location is subdivided in
categories:
</p>

<dl>
  <dt>admin</dt>
  <dd>Administrative SELinux policy modules (portage, logrotate, sudo, ...)</dd>
  <dt>apps</dt>
  <dd>Application SELinux policy modules (evolution, mozilla, screen, ...)</dd>
  <dt>kernel</dt>
  <dd>Kernel specific SELinux policy domains (corenetwork, kernel, ...)</dd>
  <dt>roles</dt>
  <dd>Domains specific to SELinux roles (sysadm, user, staff, ...)</dd>
  <dt>services</dt>
  <dd>Daemon SELinux policy modules (postfix, apache, squid, ...)</dd>
  <dt>system</dt>
  <dd>Core SELinux policy modules (selinuxutil, mount, iptables, ...)</dd>
</dl>

<p>
The categorization is arbitrary and serves no purpose other than keeping the
modules a but separated. Each module must have a unique name, regardless of the
category!
</p>

<p>
Inside the categories, the modules are available using their three files
</p>

<pre caption="Listing the available sudo files">
~$ <i>cd dev/hardened/refpolicy.local/policy/modules/admin</i>
~$ <i>ls sudo.*</i>
sudo.fc    sudo.if     sudo.te
</pre>

</body>
</section>
<section>
<title>Building a module</title>
<body>

<p>
To build a module, go to the location where the module code is. Then, run
<c>make</c> with the development Makefile as provided by the reference policy.
</p>

<note>
You can ignore warnings about duplicate interface definitions and such. That is
because the Makefile will include both the existing interfaces as well as the
current working directory - which of course contains the same interfaces.
</note>

<pre caption="Building the portage module">
~$ <i>cd dev/hardened/refpolicy.local/policy/modules/admin</i>
~$ <i>make -f /usr/share/selinux/strict/include/Makefile portage.pp</i>
</pre>

<p>
You now have a <path>portage.pp</path> file available which you can load (using
<c>semodule -i portage.pp</c>).
</p>

</body>
</section>
<section>
<title>Building the base policy</title>
<body>

<p>
If you want to build the base policy, run <c>make base</c>.
</p>

<pre caption="Building the base policy">
~$ <i>cd dev/hardened/refpolicy.local</i>
~$ <i>make base</i>
</pre>

<p>
The result should be a <path>base.pp</path> file that you can load using
<c>semodule -b base.pp</c>. However, if you intend to do a bit more than just
test this base policy quickly, it is seriously recommended to create your own
Gentoo overlay for your own <path>selinux-base-policy</path> and install that
one as installing a base policy is not only about the policy module itself, but
also about the include files that will then be stored in
<path>/usr/share/selinux/strict/include</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>A Domain Does Not Function Properly</title>
<section>
<title>Introduction</title>
<body>

<p>
The most likely problem that you are hitting is that a domain does exist in
Gentoo Hardened SELinux, but that it isn't functioning as it should. To solve
this problem, it is adviseable to use the following sequence of investigations:
</p>

<ol>
  <li>
    Is it really SELinux that is restraining your system?
  </li>
  <li>
    Is the problem related to wrong resource labels / security contexts?
  </li>
  <li>
    Is the problem related to intra-module permissions?
  </li>
  <li>
    Is the problem related to inter-module permissions?
  </li>
</ol>

</body>
</section>
<section>
<title>Check if SELinux is to blame</title>
<body>

<p>
Make sure that the problem you are seeing is a SELinux-triggered problem. An
easy way to find out is to run SELinux in permissive mode and try again:
</p>

<pre caption="Switching to permissive mode">
~# <i>setenforce 0</i>
</pre>

<p>
This only works if the problem is <e>not</e> to do with a SELinux-aware
application (unlike <c>init</c> or <c>sudo</c> which are linked to the
libselinux library). SELinux-aware applications might alter their behavior if
SELinux is set on the system regardless of it running in permissive mode or not.
A prime example is <c>vixie-cron</c> (as can be seen in <uri
link="https://bugs.gentoo.org/show_bug.cgi?id=257111">bug #257111</uri>). But
for applications that are not SELinux aware, this is the easiest method to find
out if SELinux is to blame or not.
</p>

<p>
If running your system in permissive mode works around the problem, read on. If
it doesn't, check the regular permissions (<c>strace</c>'ing the application
might be a good idea too).
</p>

</body>
</section>
<section>
<title>Get the proper AVC denials</title>
<body>

<p>
Assuming that we now know that SELinux is to blame, we need to make sure that we
get the proper AVC denials. Either locate the proper denials in
<path>/var/log/avc.log</path> (or <path>audit.log</path>) around the time that
you encountered the issue, or run <c>tail -f /var/log/avc.log</c> and reproduce
the problem.
</p>

<pre caption="Example denials">
~# <i>tail -f /var/log/avc.log</i>
Apr 22 15:03:33 www1 kernel: [16053.303739] type=1400 audit(1303477413.188:283):
avc:  denied  { dac_read_search } for  pid=21758 comm="rm" capability=2
scontext=root:sysadm_r:portage_t tcontext=root:sysadm_r:portage_t
tclass=capability
</pre>

<p>
Analyzing the meaning of the AVC denial is covered by <uri 
link="/proj/en/hardened/selinux/selinux-handbook.xml?part=2&amp;chap=3#avclog">Looking
at the AVC Log</uri> in the Gentoo Hardened SELinux handbook. The denial should
give you a pointer where to look for. However, it is possible that no denial is
occurring, or at least no relevant ones.
</p>

<p>
A first step to get potentially more denials is to switch the
<c>gentoo_try_dontaudit</c> boolean off. This boolean is used by the Gentoo
Hardened SELinux developers to hide denials which they assume are cosmetic. As
these developers are known to have a human side (as well), they are known to
make mistakes ;-)
</p>

<pre caption="Disabling gentoo's dontaudit statements">
~# <i>setsebool gentoo_try_dontaudit off</i>
</pre>

<p>
Retry getting the proper AVC denials.
</p>

<p>
If it still doesn't work, you can disable all <e>dontaudit</e> statements:
</p>

<pre caption="Disabling all dontaudit statements">
~# <i>semodule -R -D -B</i>
</pre>

<p>
Retry getting the proper AVC denials.
</p>

<p>
The moment you get the denials you are looking for, isolate them and then undo
the changes you made earlier:
</p>

<pre caption="Resetting the auditing defaults">
~# <i>setsebool gentoo_try_dontaudit on</i>
~# <i>semodule -R -B</i>
</pre>

<p>
If you still do not see any denials, then check out the <c>dmesg</c> output for
other problems. It is possible that SELinux is not even getting to the point of
the policy, which you will not notice by looking at the AVC denials alone.
However, the chance of this to happen is very slim - most of the time, you'll
find the AVC denials you are looking for.
</p>

</body>
</section>
<section>
<title>Deducing the correct security contexts</title>
<body>

<p>
The next step is to see if we are dealing with the right security contexts. This
does require a bit of insight in how both the application (that is failing) and
the policy relate to each other. In essence, you want to make sure that the
process is running in the right domain and is trying to work on the right target
type.
</p>

<p>
Say you are having issues with SELinux (re)labeling and you notice the following
AVC denial:
</p>

<pre caption="AVC denial for setfiles">
Apr 16 14:39:57 testsys kernel: [  115.778484] type=1400
audit(1302957597.827:224): avc:  denied  { create } for  pid=3584
comm="setfiles" scontext=root:sysadm_r:<comment>sysadm_t</comment> tcontext=root:sysadm_r:sysadm_t
tclass=netlink_audit_socket
</pre>

<p>
In this case, <c>setfiles</c> is running in the <path>sysadm_t</path> domain
even though it should run in <path>setfiles_t</path>. So check the security
context of the <c>setfiles</c> binary as well as the transition rules:
</p>

<pre caption="Checking setfiles context and rules">
~# <i>ls -lZ /sbin/setfiles</i>
-rwxr-xr-x. 1 root root <comment>system_u:object_r:bin_t</comment> 26464 Apr  9 22:22 /sbin/setfiles
~# <i>sesearch -s sysadm_t -t setfiles_t -c process -p transition -A -d</i>
Found 1 semantic av rules:
    allow sysadm_t setfiles_t : process transition ;
~# <i>sesearch -s sysadm_t -t setfiles_exec_t -c file -p execute -A -d</i>
...
~# <i>sesearch -s setfiles_t -t setfiles_exec_t -c file -p entrypoint -A -d</i>
...
</pre>

<p>
In the above (forced) situation, the problem is with the security context of the
binary - it should have been <path>setfiles_exec_t</path> instead of
<path>bin_t</path>. Usually, entry points are named similarly (like
<path>portage_exec_t</path> or <path>sudo_exec_t</path>). If you are not certain
about which domain it should be, use <c>sesearch</c>
</p>

<pre caption="Using sesearch to find the entrypoint type for a domain">
~# <i>sesearch -s setfiles_t -c file -p entrypoint -A -d</i>
Found 1 semantic av rules:
   allow setfiles_t setfiles_exec_t : file { ioctl ... execute entrypoint open } ;
</pre>

<p>
The <c>sesearch</c> utility is extremely powerful to query the SELinux policy
(which is currently in memory). I also advise you to use the <c>-C</c> switch to
see which rules are trigged by certain SELinux booleans:
</p>

<pre caption="Looking for boolean-triggered settings">
~# <i>sesearch -s named_t -t named_zone_t -c file -A -d -C</i>
Found 2 semantic av rules:
   allow named_t named_zone_t : file { ioctl read getattr lock open } ; 
DT allow named_t named_zone_t : file { ioctl read write create getattr setattr lock append unlink link rename open } ; [ named_write_master_zones ]
</pre>

<p>
In the above example, the <path>named_t</path> domain only has write privileges
on files labeled <path>named_zone_t</path> if the
<path>named_write_master_zones</path> boolean is set (which it currently isn't,
otherwise the line would stat with ET instead of DT).
</p>

<p>
To gain a bit of insight in the various, available domains, use <c>seinfo</c>:
</p>

<pre caption="Getting a list of available domains">
~# <i>seinfo -t | grep named</i>
   named_var_run_t
   named_checkconf_exec_t
   named_conf_t
   named_initrc_exec_t
   named_log_t
   named_exec_t
   named_zone_t
   named_t
   named_cache_t
   named_tmp_t
</pre>

<p>
To gain a bit of insight in the (current) file context rules, use
<c>semanage</c>:
</p>

<pre caption="Getting the list of current file context rules">
~# <i>semanage fcontext -l | grep named</i>
/etc/bind(/.*)?                                    all files        system_u:object_r:named_zone_t 
/etc/bind/named\.conf                              regular file     system_u:object_r:named_conf_t 
/etc/rc\.d/init\.d/named                           regular file     system_u:object_r:named_initrc_exec_t 
/etc/rc\.d/init\.d/unbound                         regular file     system_u:object_r:named_initrc_exec_t 
/etc/rndc.*                                        regular file     system_u:object_r:named_conf_t 
/etc/unbound(/.*)?                                 all files        system_u:object_r:named_conf_t 
/usr/sbin/lwresd                                   regular file     system_u:object_r:named_exec_t 
/usr/sbin/named                                    regular file     system_u:object_r:named_exec_t 
/usr/sbin/named-checkconf                          regular file     system_u:object_r:named_checkconf_exec_t 
/usr/sbin/unbound                                  regular file     system_u:object_r:named_exec_t 
/var/bind(/.*)?                                    all files        system_u:object_r:named_cache_t 
/var/bind/pri(/.*)?                                all files        system_u:object_r:named_zone_t 
/var/log/named.*                                   regular file     system_u:object_r:named_log_t 
/var/run/bind(/.*)?                                all files        system_u:object_r:named_var_run_t 
/var/run/named(/.*)?                               all files        system_u:object_r:named_var_run_t 
/var/run/ndc                                       socket           system_u:object_r:named_var_run_t 
/var/run/unbound(/.*)?                             all files        system_u:object_r:named_var_run_t 
</pre>

<p>
Most of the time, fixing domain issues is a matter of relabeling files (or
updating the configuration to match the contexts already defined - both work).
</p>

</body>
</section>
<section>
<title>Intra-module permissions are missing</title>
<body>

<p>
It is possible that you get a denial between correct security contexts, but
that the permission is just never granted. In this case, you can choose between
two things:
</p>

<ol>
  <li>
    Enhance the module so that the particular permission is granted, or
  </li>
  <li>
    Enhance the module with an additional type where the permission is granted,
    and assign this type/label to the related resources
  </li>
</ol>

<p>
In both cases you will need to edit the module files (most likely the
<path>.te</path> file), build the module, load it, perhaps even relabel the
files or the package and retry. It is also a good idea to take a look at
upstream (latest refpolicy repository or the repositories of Fedora and co) and
see if they have already solved this problem or not.
</p>

<p>
Granting additional permissions between existing domains is the easiest, but
might introduce additional problems: if this permission is only needed in a
particular case yet you grant it for all files and resources related to those
domains, then you are opening up the policy beyond what is necessary. Often,
creating an additional domain or type can be beneficial.
</p>

<p>
A noticeable example is Portage' support for CVS/SVN/GIT ebuilds (the so-called
live ebuilds). These ebuilds get their repository and store it in the
<path>distfiles/svn+src</path> location, which was by default labeled
<path>portage_ebuild_t</path> with only read-access for the
<path>portage_sandbox_t</path> domain. However, with those live ebuilds, the
<path>portage_sandbox_t</path> domain also needs write privileges to this
location. Rather than allowing <path>portage_sandbox_t</path> write privileges
to <path>portage_ebuild_t</path>, a new type was created called
<path>portage_svnsrc_t</path> for just this location and the rights are
transferred towards type.
</p>

</body>
</section>
<section>
<title>Inter-module permissions are needed</title>
<body>

<p>
If the solution for the problem requires permissions between modules, then you
need to create the proper interface functions in the target domain and call
these functions from the source domain.
</p>

<p>
Interface functions are the APIs that a module provides towards other SELinux
modules when they need to interact with the domains. For instance, the
<path>mysql</path> module provides, amongst other functions, the
<c>mysql_stream_connect</c> interface:
</p>

<pre caption="mysql_stream_connect interface">
########################################
## &lt;summary&gt;
##      Connect to MySQL using a unix domain stream socket.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      &lt;summary&gt;
##      Domain allowed access.
##      &lt;/summary&gt;
## &lt;/param&gt;
## &lt;rolecap/&gt;
#
interface(`mysql_stream_connect',`
        gen_require(`
                type mysqld_t, mysqld_var_run_t, mysqld_db_t;
        ')

        stream_connect_pattern($1, mysqld_var_run_t, mysqld_var_run_t, mysqld_t)
        stream_connect_pattern($1, mysqld_db_t, mysqld_var_run_t, mysqld_t)
')
</pre>

<p>
The interface declares that the domain passed on as its first (and only)
argument gets the rights offered by <c>stream_connect_pattern</c>, which is a
macro (defined in <path>policy/support/ipc_patterns.spt</path> that looks like
so:
</p>

<pre caption="stream_connect_pattern">
define(`stream_connect_pattern',`
        allow $1 $2:dir search_dir_perms;
        allow $1 $3:sock_file write_sock_file_perms;
        allow $1 $4:unix_stream_socket connectto;
')
</pre>

<p>
Modules that need to interact with MySQL through a Unix domain stream socket
(<path>/var/run/mysqld/mysqld.sock</path>) will need the proper permissions to
work with the target type (<path>mysqld_var_run_t</path>). Modules cannot just
set <e>allow</e> statements towards <path>mysqld_var_run_t</path> as they do not
know this type. Instead, they call the <c>mysql_stream_connect</c> interface,
like the <path>postfix.te</path> file does:
</p>

<pre caption="Postfix module calling mysql_stream_connect">
optional_policy(`
        mysql_stream_connect(postfix_master_t)
        mysql_stream_connect(postfix_cleanup_t)
        mysql_stream_connect(postfix_local_t)
')
</pre>

<p>
If the change you need is adding existing interface calls to the module (in 
the <path>.te</path> file) then you should be able to test it easily by building
the changed module and loading it. However, if you need to change the interface
of your module itself (in the <path>.if</path> file) you will eventually need
to rebuild the base policy and even provide and install a new
<path>sec-policy/selinux-base-policy</path> package as the interfaces are placed
in <path>/usr/share/selinux/strict/include</path>. This is one of the reasons
why the <path>sec-policy/selinux-base-policy</path> package in Gentoo Hardened
has a high revision number (and many updates).
</p>

</body>
</section>
</chapter>

<chapter>
<title>No Domain Exists (Yet)</title>
<section>
<title>Reuse existing domains</title>
<body>

<p>
If you are facing problems because you run an application which has no domain
itself (and hence is probably running in the <path>user_t</path>,
<path>staff_t</path> or <path>sysadm_t</path> domains - or even tries to run in
the <path>initrc_t</path> domain), you will need to create one. But before we do
that, it might be possible that the application can work within the domain
definition of a different application.
</p>

<p>
One example here is lighttpd. This lightweight HTTPd service "uses" the
definitions offered by the <path>apache</path> module. By marking its executable
file <path>httpd_exec_t</path> it runs in the <path>httpd_t</path> domain and
uses the same policy like Apache. By labeling the files according to the
<path>apache.fc</path> definitions (but now for lighttpd) it might Just Work
&trade;
</p>

<p>
Reusing existing domains requires that you at least consider the following
aspects:
</p>

<ul>
  <li>
    Will the application run on the same system as the application for which the
    domain is originally intended? If so, then both might run in the same domain
    (and as such have more privileges towards each other than intended) which
    might not be what you want.
  </li>
  <li>
    Do you need to enhance (read: add additional privileges) the master domain?
    If so, make sure that you don't add more privileges than the original domain
    would ever need to the extend that these privileges become a security risk.
  </li>
</ul>

</body>
</section>
<section>
<title>(Do Not) Copy from existing domains</title>
<body>

<p>
If reusing existing domains introduces too many risks, you'll need to create a
new domain for the application. Many people would be inclined to copy the domain
definition of a similar application and work from there. Although this is a
viable approach, it is considered a bad practice because you start by providing
privileges to the domain that are never needed, and removing privileges from a
domain later is very difficult. Even more, if you are not the author of the
modules, most developers will not even try to remove them as they assume that
the author of the domain had a good reason to add it in the first place. This is
one of the reasons why upstream takes great care in accepting patches - they
must be properly documented before they are accepted.
</p>

<p>
Instead, create a domain from scratch but take a close eye on the domain you
belief is very similar. Issues that arise during the module development might be
quickly resolved by looking at how the original domain is defined.
</p>

</body>
</section>
<section>
<title>Starting from scratch</title>
<body>

<p>
To start the development of a new module from scratch, first identify the
domain(s) you want to have. An application that, in its entire lifespan only
constitutes of a single process, will most likely only have one domain. For
instance, the Skype client will have just <path>skype_t</path>. However,
applications that have multiple processes running might need multiple domains
too. For instance, the Postfix application runs a master
(<path>postfix_master_t</path>), queue manager (<path>postfix_qmgr_t</path>) and
pickup service (<path>postfix_pickup_t</path>), but depending on the commands
you execute, it will also have (short-lived) processes running as
<path>postfix_cleanup_t</path>, <path>postfix_bounce_t</path>, etc.) It is
considered a best practice to start with a fine-grained model for domains
and only later decide if merging multiple domains into one is beneficial.
Splitting domains later is more difficult. Don't forget to look at the
client-side aspect too!
</p>

<p>
Next, define the types that each domain interacts with. This of course includes
the binary (like <path>skype_exec_t</path>) but do not forget resources like
</p>

<ul>
  <li>
    The configuration file(s) in <path>/etc</path> (f.i.
    <path>postfix_etc_t</path>)
  </li>
  <li>
    PID files (f.i. <path>sshd_var_run_t</path>)
  </li>
  <li>
    Spool files (f.i. <path>postfix_spool_t</path>)
  </li>
  <li>
    Variable data files (f.i. <path>snmpd_var_lib_t</path>)
  </li>
  <li>
    Log files (f.i. <path>zebra_log_t</path>)
  </li>
  <li>
    Cache files (f.i. <path>squid_cache_t</path>)
  </li>
  <li>
    (User) content files (f.i. <path>httpd_sys_content_t</path> and
    <path>httpd_user_content_t</path>)
  </li>
</ul>

<p>
Also, try to separate types that are used by other domains as well. This way,
the other domains can only interact with those files or resources that are
labeled accordingly, rather than interact with a broad spectrum of files. The
distinction that the <path>apache</path> module makes between system-provided
content (like phpmyadmin files) and user-provided content (in the
<path>public_html</path> directory in the users' home directories) seems (and
is) very logical, but one could wrongly say that for Apache itself, the access
controls are the same. Although that might be true, both types are clearly used
in different ways so this mandates the use of different domains.
</p>

<p>
Once you have defined those types too, start writing down the intra-domain
permissions. Right now is a good time to look at other modules to see how they
do things. Start with defining the accesses towards the domains.
</p>

<pre caption="Snippet from the spamassassin module">
type spamassassin_t;
type spamassassin_exec_t;
application_domain(spamassassin_t, spamassassin_exec_t)
ubac_constrained(spamassassin_t)
</pre>

<p>
This small snippet defines many things. The first two lines just mention the new
types (the <path>spamassassin_t</path> domain and
<path>spamassassin_exec_t</path> type). The <c>application_domain</c> interface
marks <path>spamassassin_t</path> as an application domain type (it gets the
<path>application_domain_type</path> and <path>domain</path> attributes and a
few default permissions (like allowing that it sends SIGCHLD and SIGNULL to
init). It also marks <path>spamassassin_exec_t</path> as an applications'
executable type (<path>application_exec_type</path> and <path>exec_type</path>
attributes) so that it can be executed by regular users (these domains have
execute rights against all resources that have the
<path>application_exec_type</path> attribute set. Finally, it marks the
<path>spamassassin_t</path> domain as a constrained domain for user-based access
controls. In other words, if SELinux users <path>user_u</path> and
<path>staff_u</path> launch the application in <path>spamassassin_t</path>
domains, then the domains are segregated from each other (the intra-domain rules
inside <path>spamassassin_t</path> are only valid for communication within the
same SELinux user, not between SELinux users).
</p>

<p>
Attributes are an important aspect in SELinux policy development. They make
managing the domains easier, but you should always consider the implications
when you add an attribute to one of your types. It usually means that a whole
lot of permissions are suddenly granted between other domains and yours.
</p>

<p>
Next, set the proper intra-domain permissions. For instance, allow your domain
to read its configuration files as well as more access inside its own
<path>/var/lib</path> location:
</p>

<pre caption="Snippet from openca module">
allow openca_ca_t openca_etc_t:file read_file_perms;
allow openca_ca_t openca_etc_t:dir list_dir_perms;

manage_dirs_pattern(openca_ca_t, openca_var_lib_t, openca_var_lib_t)
manage_files_pattern(openca_ca_t, openca_var_lib_t, openca_var_lib_t)
</pre>

<p>
The majority of work in developing SELinux policy modules is using and choosing
the right interfaces. Having a few functions available to browse through all the
available information is always interesting, so you might want to use the
following function definitions (definitely not mandatory - this is only to help
people skim through the policy definitions):
</p>

<pre caption="SELinux policy development function definitions">
POLICY_LOCATION="/path/to/your/refpolicy";

# sefindif - Find interface definitions that have a string that matches the
# given regular expression
sefindif() {
  REGEXP="$1";
  cd ${POLICY_LOCATION}/policy/modules;
  for FILE in */*.if;
  do
    awk "/(interface\(|template\()/ { NAME=\$NF; P=0 }; /${REGEXP}/ { if (P==0) {P=1; print NAME}; print };" ${FILE} | sed -e "s:^:${FILE}\: :g";
  done
}

# seshowif - Show the interface definition
seshowif() {
  INTERFACE="$1";
  cd ${POLICY_LOCATION}/policy/modules;
  for FILE in */*.if;
  do
    grep -A 9999 "\(interface(\`${INTERFACE}'\|template(\`${INTERFACE}'\)" ${FILE} | grep -B 9999 -m 1 "^')";
  done
}

# sefinddef - Find macro definitions that have a string that matches the given
# regular expression
sefinddef() {
  REGEXP="$1";
  grep -H "define(\`.*${REGEXP}.*" ${POLICY_LOCATION}/policy/support/* | sed -e 's:.*\/\([^(]*\):\1:g'
}

# seshowdef - Show the macro definition
seshowdef() {
  MACRONAME="$1";
  cd ${POLICY_LOCATION}/policy/support;
  for FILE in *.spt;
  do
    grep -A 9999 "define(\`${MACRONAME}'" ${FILE} | grep -B 999 -m 1 "')";
  done
}
</pre>

<p>
These functions can then be used to find the information / interfaces you are
looking for. For instance, you need the application to read the postfix
configuration files:
</p>

<pre caption="Looking for the interface(s) needed">
~$ <i>sefindif postfix_etc_t</i>
services/postfix.if: template(`postfix_domain_template',`
services/postfix.if:    allow postfix_$1_t postfix_etc_t:dir list_dir_perms;
services/postfix.if:    read_files_pattern(postfix_$1_t, postfix_etc_t, postfix_etc_t)
services/postfix.if:    read_lnk_files_pattern(postfix_$1_t, postfix_etc_t, postfix_etc_t)
<comment>services/postfix.if: interface(`postfix_read_config',`
services/postfix.if:            type postfix_etc_t;
services/postfix.if:    read_files_pattern($1, postfix_etc_t, postfix_etc_t)
services/postfix.if:    read_lnk_files_pattern($1, postfix_etc_t, postfix_etc_t)</comment>
services/postfix.if: interface(`postfix_config_filetrans',`
services/postfix.if:            type postfix_etc_t;
services/postfix.if:    filetrans_pattern($1, postfix_etc_t, $2, $3)

~$ <i>seshowif postfix_read_config</i>
interface(`postfix_read_config',`
        gen_require(`
                type postfix_etc_t;
        ')

        read_files_pattern($1, postfix_etc_t, postfix_etc_t)
        read_lnk_files_pattern($1, postfix_etc_t, postfix_etc_t)
        files_search_etc($1)
')
</pre>

<p>
Same thing if you want to look for the correct macro definition (usually, if you
notice something but you cannot find it as an interface, then it is most likely
a macro):
</p>

<pre caption="Looking for the right macros">
<comment># Suppose you need to read, write, connect, ... to a socket</comment>
~$ <i>sefinddef connect</i>
ipc_patterns.spt:define(`stream_connect_pattern',`
<comment>obj_perm_sets.spt:define(`rw_socket_perms', `{ ioctl read getattr write setattr append bind connect getopt setopt shutdown }')</comment>
obj_perm_sets.spt:define(`connected_socket_perms', `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }')
obj_perm_sets.spt:define(`connected_stream_socket_perms', `{ connected_socket_perms listen accept }')

<comment># To see what the ps_process_pattern is about</comment>
~$ <i>seshowdef ps_process_pattern</i>
define(`ps_process_pattern',`
        allow $1 $2:dir list_dir_perms;
        allow $1 $2:file read_file_perms;
        allow $1 $2:lnk_file read_lnk_file_perms;
        allow $1 $2:process getattr;
')
</pre>

<p>
As we strive to bring most of our patches upstream, please do consider the <uri
link="http://oss.tresys.com/projects/refpolicy/wiki/HowToContribute">contribution
guidelines</uri> of the reference policy project. The project has a documented
style guide, naming convention and an online API reference (for the various
interfaces).
</p>

<p>
Note that, the moment you create a new module, you'll need to create the proper
role interfaces (if it is an application that is directly called from a user
domain). Take a look at <c>tvtime_role</c> and how it is used in the
<path>staff.te</path> and <path>sysadm.te</path> role definitions.
</p>

</body>
</section>
<section>
<title>Testing new modules</title>
<body>

<p>
When you test your application, test it in as many ways as possible. If your
application is a command-line application, run it both from a regular terminal
(tty) as well as a virtual one (in an xterm). See if it still works if you run
it in a screen session. Try out all functions and features that the application
supports.
</p>

<p>
This rigorous testing is necessary because SELinux denies everything that isn't
explicitly allowed. If you do not test certain features, chances are that the
module does not provide the necessary permissions and as such, users will be
impacted.
</p>

<p>
To test out a new module, load it (<c>semodule -i modulename.pp</c>) and relabel
the files affiliated with the application (either through <c>rlpkg</c> or using
<c>restorecon</c>). Consider the following testing activities if applicable (not
all domains are interactive domains, so please read the activities with your
domain definition in mind):
</p>

<ul>
  <li>
    Sending signals to the application (if you need to be able to kill it, try
    killing it)
  </li>
  <li>
    Run it both as a regular user (<path>user_u</path>) as well as
    administrative users (if applicable). If your domain needs to support
    unconfined domains/users, run it from an unconfined user domain too.
  </li>
  <li>
    Run it from a terminal, console, screen, sudo, ...
  </li>
  <li>
    Change the applications' configuration file (including rendering it useless
    with syntax errors) and look at the applications' behavior. Especially
    syntax failures as that might trigger the application to log things at
    places that you haven't discovered earlier.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Policy Guidelines</title>
<section>
<title>Cosmetic denials</title>
<body>

<p>
When working on policy modules, you'll notice that the application is trying to
do things which are denied, but have no obvious effect on the applications
functionality. This is to be expected: many applications do not handle file
descriptors properly (file descriptor leaks are common) or applications read
attributes of files but don't do anything with it. You'll notice that you learn
a lot from the application while writing its policy ;-)
</p>

<p>
Gentoo Hardened's idea here is to only allow what is actually needed by the
application. Cosmetic denials are to be <c>dontaudit</c>'ed. Gentoo Hardened
uses the <c>gentoo_try_dontaudit</c> boolean for this:
</p>

<pre caption="Example usage of gentoo_try_dontaudit">
<comment># Hide sshd_t calling module_request from the kernel_t domain</comment>
tunable_policy(`gentoo_try_dontaudit',`
        kernel_dontaudit_request_load_module(sshd_t)
')
</pre>

</body>
</section>
<section>
<title>Gentoo Hardened SELinux policy</title>
<body>

<p>
To streamline the policy development efforts, Gentoo Hardened as a <uri
link="selinux-policy.xml">SELinux Policy</uri> document explaining the
principles used during policy development and the implementation guidelines we
strive to follow during development.
</p>

<p>
Such a policy is important because we want to have a consistent security policy
that users and developers can relate to. By following the policy, we hope that
other developers can quickly jump in and work on it further.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Submitting Patches</title>
<section>
<title>File context patches</title>
<body>

<p>
If you are able to fix a problem by adding the proper file contexts (using
<c>semanage fcontext -a</c>), please consider the following:
</p>

<ul>
  <li>
    If the location for which you set the context deviates from the standard
    location as either intended by the project or Gentoo itself, it might be
    best to document it in the forums or elsewhere. We will not change file
    contexts to match every ones configuration, unless the file context change
    is apparent for each installation.
  </li>
  <li>
    Developers might not immediately push file context changes in new policy
    module packages to keep the amount of policy module changes low. Instead,
    these changes can be stacked and pushed when other changes occur as well.
  </li>
</ul>

<p>
If you believe that the change is needed for everyone using Gentoo Hardened with
SELinux, create a <uri link="https://bugs.gentoo.org">bugreport</uri> and assign
it to <c>selinux@gentoo.org</c>. In the bugreport, mention the file context you
think is necessary and why.
</p>

</body>
</section>
<section>
<title>Module patches</title>
<body>

<p>
Module patches with changes that are intra-module (and have no effect outside)
are best generated from the <path>policy/modules</path> location:
</p>

<pre caption="Example generating patch for modular changes">
~$ <i>cd dev/hardened/refpolicy.local/policy/modules</i>
~$ <i>diff -ut ../../../refpolicy/policy/modules/services/openct.te services/openct.te</i>
--- ../../../../refpolicy/policy/modules/services/openct.te   2011-04-22 23:28:17.932918002 +0200
+++ services/openct.te  2011-04-23 09:55:08.156918002 +0200
@@ -47,6 +47,10 @@
 
 miscfiles_read_localization(openct_t)
 
+tunable_policy(`gentoo_try_dontaudit',`
+        kernel_dontaudit_read_system_state(openct_t)
+')
+
 userdom_dontaudit_use_unpriv_user_fds(openct_t)
 userdom_dontaudit_search_user_home_dirs(openct_t)
</pre>

<p>
Attach this patch to the <uri link="https://bugs.gentoo.org">bugreport</uri>
explaining why it is needed. If you think the patch itself is not obvious, make
sure that the necessary comments are in place <e>inside the patch</e> for future
reference.
</p>

<p>
Please have a separate patch file per module (do not combine multiple modules in
a single patch).
</p>

</body>
</section>
<section>
<title>Base policy patches</title>
<body>

<p>
If a patch extends a single module, or it includes interface changes on a
module, you'll need to create a patch for the base policy. In this case, the
patch is best made from the upper location.
</p>

<pre caption="Generating a base policy patch">
~$ <i>cd dev/hardened/refpolicy.local</i>
~$ <i>diff -ut ../refpolicy/policy/modules/services/openct.if policy/modules/services/openct.if</i>
--- ../strict/policy/modules/services/openct.if    2011-04-22 23:28:17.918918002 +0200
+++ policy/modules/services/openct.if       2011-04-23 10:01:38.753918001 +0200
@@ -15,7 +15,7 @@
                 type openct_t;
         ')
 
-        allow $1 openct_t:process signull;
+        allow $1 openct_t:process { signull sigchld };
 ')
 
 ########################################
</pre>

<p>
Attach this patch to the <uri link="https://bugs.gentoo.org">bugreport</uri>
explaining why it is needed. If you think the patch itself is not obvious, make
sure that the necessary comments are in place <e>inside the patch</e> for future
reference.
</p>

<p>
Please have a separate patch file per major change (do not combine multiple
unrelated changes in a single patch).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Running Your Own Policy</title>
<section>
<title>Creating a local overlay</title>
<body>

<p>
If you want to use your own policy rather than Gentoo's, we seriously recommend
to use a local overlay which uses the same package names and constructs. This
allows your policy to integrate properly with the other Gentoo packages (which
might depend on the SELinux packages). For instance, when you install openldap,
it will still properly depend on the <path>sec-policy/selinux-ldap</path>
package even if you provide it completely.
</p>

<p>
To do so, first create a local overlay and copy the content of the
<path>sec-policy</path> category inside it.
</p>

<pre caption="Creating a local overlay">
~$ <i>mkdir dev/overlay</i>
~$ <i>cp -r /usr/portage/sec-policy dev/overlay</i>
</pre>

<p>
Next, tell Portage to not synchronise the <path>sec-policy</path> category of
the main tree anymore. To do so, create the file
<path>/etc/portage/rsync_excludes</path> with the following content:
</p>

<pre caption="Rsync exclusion information">
sec-policy/
</pre>

<p>
Finally, add your current overlay by editing <path>/etc/make.conf</path>:
</p>

<pre caption="Editing make.conf">
PORTDIR_OVERLAY="${PORTDIR_OVERLAY} /home/user/dev/overlay"
</pre>

<p>
From now onwards, Gentoo Portage will only use your local overlay (you can
remove <path>/usr/portage/sec-policy</path> if you don't want Portage to even
reuse the current set of packages.
</p>

</body>
</section>
<section>
<title>Updating module packages</title>
<body>

<p>
To create or update a module package, you can use the following skeleton for the
ebuilds:
</p>

<pre caption="Skeleton for ebuilds, example for postfix">
# Copyright 1999-2011 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
EAPI="4"

IUSE=""
<comment># Set the MODS variable to the refpolicy name used, so services/postfix.te gives "postfix"</comment>
MODS="postfix"
<comment># BASEPOL is optional, set it to the selinux-base-policy version which
# includes the latest patch (or interface you use in the policy)</comment>
BASEPOL="2.20110726-r3"

inherit selinux-policy-2

DESCRIPTION="SELinux policy for postfix"
KEYWORDS="~amd64 ~x86"

<comment># POLICY_PATCH is optional (only when you have a module patch)</comment>
POLICY_PATCH="${FILESDIR}/fix-services-postfix-r3.patch"
</pre>

<p>
The patch(es) that you can put in the <path>files/</path> location (and referred to
in the <c>POLICY_PATCH</c>) should be made as defined earlier in this document.
You can put multiple patches in this variable if you want.
</p>

<p>
Don't forget to run <c>repoman manifest</c> with every change, and run
<c>repoman scan</c> to check for potential mistakes.
</p>

</body>
</section>
<section>
<title>Updating base package</title>
<body>

<p>
To provide updates on the base policy, it is recommended to keep all patches you
made centrally in a directory (say <path>dev/hardened/base-patches</path>). When
you want to create a new <path>sec-policy/selinux-base-policy</path> release,
create a patchbundle from your patch directory, put the bundle in the
<path>files</path> location, create the updated ebuild and try it out.
</p>

<pre caption="Building a base policy package">
<comment># Go to the location where all patches are currently extracted</comment>
~$ <i>cd dev/hardened/base-patches</i>

<comment># Add the patches you want to include, cfr Submitting Patches</comment>
<comment># Then, create a new patch bundle</comment>
~$ <i>tar cjvf ../overlay/sec-policy/selinux-base-policy/files/patchbundle-selinux-base-policy-2.20110726-r3.tar.bz2 *</i>

<comment># Finally, bump the revision of the ebuild in the overlay</comment>
~$ <i>cd ../overlay/sec-policy/selinux-base-policy</i>
~$ <i>cp selinux-base-policy-2.20110726-r3.ebuild selinux-base-policy-2.20110726-r4.ebuild</i>
</pre>

<p>
Don't forget to run <c>repoman manifest</c> and <c>repoman scan</c>. You can
then install <path>sec-policy/selinux-base-policy-2.20110726-r4</path> and test
it out.
</p>

</body>
</section>
</chapter>

</guide>
