<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux-development.xml,v 1.5 2012/08/24 15:50:10 swift Exp $ -->

<guide link="/proj/en/hardened/selinux-development.xml" lang="en">
<title>Gentoo Hardened SELinux Development</title>
<author title="Author">
  <mail link="sven.vermeulen@siphos.be">Sven Vermeulen</mail>
</author>

<abstract>
When planning to help Gentoo Hardened in the development of SELinux policies,
or when trying to debug existing policies, this document should help you get
acquainted with the necessary resources, trips and tricks to get along.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>5</version>
<date>2012-08-24</date>

<chapter>
<title>Introduction</title>
<section>
<title>About this document...</title>
<body>

<p>
Dealing with Mandatory Access Control is never easy. SELinux might be available
by default with Linux, enabling it can provide serious headaches - let alone
developing policies for it. Within Gentoo Hardened, we strive to offer a default
policy that is flexible enough to match the requirements of most of you (our 
users) yet remain manageable by the limited number of developers that we have.
To ensure that the policy we offer is up to date, we definitely need help from
end users and other developers, because developing policies requires intimate 
knowledge of the products they are written for. With over several thousand 
packages, this is just not feasible for a handful of us. Hence, this Gentoo
Hardened SELinux Development guide.
</p>

<p>
Within this document, we will try to explain how to set up an environment ready
to build policies yourself and provide patches to Gentoo Hardened. We also cover
how to deal with malfunctioning domains and even how to create your own, new 
domains from scratch (if we need to). Further down, we give an overview of the 
guidelines that we try to follow during the policy developments and finally
talk about how to properly create patches and submit them to our <uri 
link="https://bugs.gentoo.org">bugzilla</uri> service.
</p>

<p>
For those who want to run Gentoo Hardened with their own policies, we've also
added a chapter on just that. We know that our policy does not match everyone's
requirements, so we definitely want to help you run your own too.
</p>

</body>
</section>
<section>
<title>Intended audience</title>
<body>

<p>
This document is a must-read for everyone willing to provide patches or develop
the Gentoo Hardened SELinux policies.
</p>

<p>
Other SELinux advanced users might find this document interesting as well.
</p>

</body>
</section>
<section>
<title>What you need to know</title>
<body>

<p>
This document does assume prior knowledge on SELinux policies and the way the
reference policy works. For those that need a quick recap, here are the
highlights...
</p>

<ul>
  <li>
    SELinux uses <e>domains</e> and <e>types</e> to differentiate its various
    security objects. A domain is usually referred to as the security context
    of a process (or group of processes) whereas a type is usually referred to
    as the label given to a particular resource (file, directory, network
    interface, socket, network port, ...).
  </li>
  <li>
    <e>SELinux policies</e> describe what interaction is allowed between a
    domain and the other domains and types it needs to work with. If no policy
    allows for a particular activity, then the activity is denied.
  </li>
  <li>
    The structure in which policies are written are called <e>SELinux policy
    modules</e> which contain three parts: a <e>type enforcement file</e> (with
    suffix <path>.te</path>) that contains the intra-module permissions, an
    <e>interface file</e> (with suffix <path>.if</path>) that contains the
    inter-module permissions and a <e>file contexts file</e> (with suffix
    <path>.fc</path>) that contains the file context definitions for all file
    resources that are labeled with the type or types defined in the module
  </li>
  <li>
    Inter-domain privileges must be declared through functions in the
    <e>interface file</e> which can then be called by other modules. This
    includes the necessary permissions to allow domain transitions
  </li>
  <li>
    SELinux uses attributes to make multiple domains manageable. Domains can
    have certain permissions against all domains or types that are given a
    particular attribute. Be aware of this when you start assigning attributes
    to your own types or domains.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Setting Up Your Environment</title>
<section>
<title>Patching the reference policy</title>
<body>

<p>
Gentoo Hardened builds its policy upon the <uri 
link="http://oss.tresys.com/projects/refpolicy">reference policy</uri> as
provided by <uri link="http://www.tresys.com">Tresys</uri> and managed through
a reasonably active <uri
link="http://oss.tresys.com/projects/refpolicy/wiki/HowToContribute">community</uri>.
For Gentoo, the policy is based on a <uri
link="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git">git
repository</uri> which you can clone and work on. This repository is started
with a fresh reference policy snapshot and then updated accordingly. When the
reference policy makes a new release, we will rebuild the changes on top of the
new release. Although this might be resource intensive, it gives us reasonable
assurance that our repository doesn't deviate too much from the reference
policy, and it also urges developers to send patches upstream as soon as
possible.
</p>

<p>
Let's create the workplace in which you can develop policies:
</p>

<pre caption="Creating the SELinux policy workspace">
~$ <i>git clone http://git.overlays.gentoo.org/gitroot/proj/hardened-refpolicy.git</i>
</pre>

<p>
As result, you now have a directory called <path>hardened-refpolicy</path> in
which you'll find the policies (<path>policy/modules</path>) currently in use by
Gentoo Hardened. Changes in this repository are reflected in patches loaded into
a <path>patchbundle-selinux-base-policy-&lt;version&gt;</path>. We currently
generate (support) two types of patches:
</p>

<ol>
  <li>
    The majority of patches are directly loaded into an archive (called
    <path>patchbundle-selinux-base-policy-&lt;version&gt;</path>). This archive
    of patches is applied to the reference policy download (used by our ebuilds)
    to get it to the state of Gentoo's policy repository.
  </li>
  <li>
    When a patch is needed on the permissions inside a <path>.te</path> file, or
    on the context inside a <path>.fc</path> file, but no immediate release of a
    new patchbundle is scheduled, the patch might be applied to a single ebuild.
    Unlike the patches for the patchbundle, which are relative to the root of
    the repository, patches on a single module are taken inside the
    <path>policy/modules</path> location.
  </li>
</ol>

<p>
You don't need to do anything specific for these - the Gentoo developers will
update any diffs or patches they receive to be compliant to the above. But at
least you now know why some developmers might have edited your patch before
committing ;-)
</p>

</body>
</section>
<section>
<title>Navigating the policy workspace</title>
<body>

<p>
The main location you will work with is
<path>hardened-refpolicy/policy/modules</path>. This location is subdivided in
categories:
</p>

<dl>
  <dt>admin</dt>
  <dd>Core administrative SELinux policy modules (sudo, bootloader, usermanage, ...)</dd>
  <dt>contrib</dt>
  <dd>Non-core (most often application) SELinux policy modules (evolution, mozilla, screen, ...)</dd>
  <dt>kernel</dt>
  <dd>Kernel specific SELinux policy domains (corenetwork, kernel, ...)</dd>
  <dt>roles</dt>
  <dd>Domains specific to SELinux roles (sysadm, user, staff, ...)</dd>
  <dt>services</dt>
  <dd>Core daemon SELinux policy modules (postgresql, ssh, xserver, ...)</dd>
  <dt>system</dt>
  <dd>Core SELinux system policy modules (selinuxutil, mount, iptables, ...)</dd>
</dl>

<p>
The categorization is arbitrary and serves little purpose other than keeping the
modules a bit separated. Each module must have a unique name, regardless of the
category! The <path>contrib/</path> location has a specific meaning when
committing patches to the reference policy as it is a subrepository. However,
for Gentoo's <path>hardened-refpolicy</path> this isn't the case.
</p>

<p>
Inside the categories, the modules are available using their three files
</p>

<pre caption="Listing the available sudo files">
~$ <i>cd hardened-refpolicy/policy/modules/admin</i>
~$ <i>ls sudo.*</i>
sudo.fc    sudo.if     sudo.te
</pre>

</body>
</section>
<section>
<title>Building a module</title>
<body>

<p>
To build a module, go to the location where the module code is. You might want
to make a copy and work in the copy as the following step will add files and
perhaps even directories in the work location. If you don't, then using
<path>.gitignore</path> can help you not commit any unneeded files.
</p>

<p>
Next, run <c>make</c> with the development Makefile offered by your
installation.
</p>

<note>
You can ignore warnings about duplicate interface definitions and such. That is
because the Makefile will include both the existing interfaces as well as the
current working directory - which of course contains the same interfaces.
</note>

<pre caption="Building the portage module">
~$ <i>cd hardened-refpolicy/policy/modules/admin</i>
~$ <i>make -f /usr/share/selinux/strict/include/Makefile sudo.pp</i>
</pre>

<p>
You now have a <path>sudo.pp</path> file available which you can load (using
<c>semodule -i sudo.pp</c>).
</p>

<note>
In the above case, we used the Makefile as provided by our own installation.
This Makefile is the same as in hardened-refpolicy/support/Makefile.devel.
</note>

</body>
</section>
<section>
<title>Building the base policy</title>
<body>

<p>
If you want to build the base policy, run <c>make base</c>.
</p>

<pre caption="Building the base policy">
~$ <i>cd dev/hardened/refpolicy.local</i>
~$ <i>make base</i>
</pre>

<p>
The result should be a <path>base.pp</path> file that you can load using
<c>semodule -b base.pp</c>. However, if you intend to do a bit more than just
test this base policy quickly, it is seriously recommended to create your own
Gentoo overlay for your own <path>selinux-base-policy</path> and install that
one as installing a base policy is not only about the policy module itself, but
also about the include files that will then be stored in
<path>/usr/share/selinux/strict/include</path>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>A Domain Does Not Function Properly</title>
<section>
<title>Introduction</title>
<body>

<p>
The most likely problem that you are hitting is that a domain does exist in
Gentoo Hardened SELinux, but that it isn't functioning as it should. To solve
this problem, it is adviseable to use the following sequence of investigations:
</p>

<ol>
  <li>
    Is it really SELinux that is restraining your system?
  </li>
  <li>
    Is the problem related to wrong resource labels / security contexts?
  </li>
  <li>
    Is the problem related to intra-module permissions?
  </li>
  <li>
    Is the problem related to inter-module permissions?
  </li>
</ol>

</body>
</section>
<section>
<title>Check if SELinux is to blame</title>
<body>

<p>
Make sure that the problem you are seeing is a SELinux-triggered problem. An
easy way to find out is to run SELinux in permissive mode and try again:
</p>

<pre caption="Switching to permissive mode">
~# <i>setenforce 0</i>
</pre>

<p>
This only works if the problem is <e>not</e> to do with a SELinux-aware
application (unlike <c>init</c> or <c>sudo</c> which are linked to the
libselinux library). SELinux-aware applications might alter their behavior if
SELinux is set on the system regardless of it running in permissive mode or not.
A prime example is <c>vixie-cron</c> (as can be seen in <uri
link="https://bugs.gentoo.org/show_bug.cgi?id=257111">bug #257111</uri>). But
for applications that are not SELinux aware, this is the easiest method to find
out if SELinux is to blame or not.
</p>

<p>
If running your system in permissive mode works around the problem, read on. If
it doesn't, check the regular permissions (<c>strace</c>'ing the application
might be a good idea too) as the problem is most likely not SELinux related.
</p>

</body>
</section>
<section>
<title>Get the proper AVC denials</title>
<body>

<p>
Assuming that we now know that SELinux is to blame, we need to make sure that we
get the proper AVC denials. Either locate the proper denials in
<path>/var/log/avc.log</path> (or <path>audit.log</path>) around the time that
you encountered the issue, or run <c>tail -f /var/log/avc.log</c> and reproduce
the problem.
</p>

<pre caption="Example denials">
~# <i>tail -f /var/log/avc.log</i>
Apr 22 15:03:33 www1 kernel: [16053.303739] type=1400 audit(1303477413.188:283):
avc:  denied  { dac_read_search } for  pid=21758 comm="rm" capability=2
scontext=root:sysadm_r:portage_t tcontext=root:sysadm_r:portage_t
tclass=capability
</pre>

<p>
Analyzing the meaning of the AVC denial is covered by <uri 
link="/proj/en/hardened/selinux/selinux-handbook.xml?part=2&amp;chap=2#doc_chap2">Reading
Audit Logs</uri> in the Gentoo Hardened SELinux handbook. The denial should
give you a pointer where to look for. However, it is possible that no denial is
occurring, or at least no relevant ones.
</p>

<p>
SELinux supports a <e>dontaudit</e> statement, which tells the policy not to log
a denial if it occurs. These statements are used by SELinux policy developers
when they believe a privilege is attempted by software which isn't needed. To
make sure users aren't confused, these denials are hidden from regular sight.
</p>

<p>
You can disable all <e>dontaudit</e> statements easily though:
</p>

<pre caption="Disabling all dontaudit statements">
~# <i>semodule -D -B</i>
</pre>

<p>
Retry getting the proper AVC denials.
</p>

<p>
The moment you get the denials you are looking for, isolate them and then undo
the changes you made earlier (to ensure that your audit or avc log isn't filled
with these cosmetic denials):
</p>

<pre caption="Resetting the auditing defaults">
~# <i>semodule -B</i>
</pre>

<p>
If you still do not see any denials, then check out the <c>dmesg</c> output for
other problems. It is possible that SELinux is not even getting to the point of
the policy, which you will not notice by looking at the AVC denials alone.
However, the chance of this to happen is very slim - most of the time, you'll
find the AVC denials you are looking for.
</p>

</body>
</section>
<section>
<title>Deducing the correct security contexts</title>
<body>

<p>
The next step is to see if we are dealing with the right security contexts. This
does require a bit of insight in how both the application (that is failing) and
the policy relate to each other. In essence, you want to make sure that the
process is running in the right domain and is trying to work on the right target
type.
</p>

<p>
Say you are having issues with SELinux (re)labeling and you notice the following
AVC denial:
</p>

<pre caption="AVC denial for setfiles">
Apr 16 14:39:57 testsys kernel: [  115.778484] type=1400
audit(1302957597.827:224): avc:  denied  { create } for  pid=3584
comm="setfiles" scontext=root:sysadm_r:<comment>sysadm_t</comment> tcontext=root:sysadm_r:sysadm_t
tclass=netlink_audit_socket
</pre>

<p>
In this case, <c>setfiles</c> is running in the <path>sysadm_t</path> domain
even though it should run in <path>setfiles_t</path>. So check the security
context of the <c>setfiles</c> binary as well as the transition rules:
</p>

<pre caption="Checking setfiles context and rules">
~# <i>ls -lZ /sbin/setfiles</i>
-rwxr-xr-x. 1 root root <comment>system_u:object_r:bin_t</comment> 26464 Apr  9 22:22 /sbin/setfiles
~# <i>sesearch -s sysadm_t -t setfiles_t -c process -p transition -A -d</i>
Found 1 semantic av rules:
    allow sysadm_t setfiles_t : process transition ;
~# <i>sesearch -s sysadm_t -t setfiles_exec_t -c file -p execute -A -d</i>
...
~# <i>sesearch -s setfiles_t -t setfiles_exec_t -c file -p entrypoint -A -d</i>
...
</pre>

<p>
In the above (forced) situation, the problem is with the security context of the
binary - it should have been <path>setfiles_exec_t</path> instead of
<path>bin_t</path>. Usually, entry points are named similarly (like
<path>portage_exec_t</path> or <path>sudo_exec_t</path>). If you are not certain
about which domain it should be, use <c>sesearch</c>
</p>

<pre caption="Using sesearch to find the entrypoint type for a domain">
~# <i>sesearch -s setfiles_t -c file -p entrypoint -A -d</i>
Found 1 semantic av rules:
   allow setfiles_t setfiles_exec_t : file { ioctl ... execute entrypoint open } ;
</pre>

<p>
The <c>sesearch</c> utility is extremely powerful to query the SELinux policy
(which is currently in memory). I also advise you to use the <c>-C</c> switch to
see which rules are trigged by certain SELinux booleans:
</p>

<pre caption="Looking for boolean-triggered settings">
~# <i>sesearch -s named_t -t named_zone_t -c file -A -d -C</i>
Found 2 semantic av rules:
   allow named_t named_zone_t : file { ioctl read getattr lock open } ; 
DT allow named_t named_zone_t : file { ioctl read write create getattr setattr lock append unlink link rename open } ; [ named_write_master_zones ]
</pre>

<p>
In the above example, the <path>named_t</path> domain only has write privileges
on files labeled <path>named_zone_t</path> if the
<path>named_write_master_zones</path> boolean is set (which it currently isn't,
otherwise the line would stat with ET instead of DT).
</p>

<p>
To gain a bit of insight in the various, available domains, use <c>seinfo</c>:
</p>

<pre caption="Getting a list of available domains">
~# <i>seinfo -t | grep named</i>
   named_var_run_t
   named_checkconf_exec_t
   named_conf_t
   named_initrc_exec_t
   named_log_t
   named_exec_t
   named_zone_t
   named_t
   named_cache_t
   named_tmp_t
</pre>

<p>
To gain a bit of insight in the (current) file context rules, use
<c>semanage</c>:
</p>

<pre caption="Getting the list of current file context rules">
~# <i>semanage fcontext -l | grep named</i>
/etc/bind(/.*)?                                    all files        system_u:object_r:named_zone_t 
/etc/bind/named\.conf                              regular file     system_u:object_r:named_conf_t 
/etc/rc\.d/init\.d/named                           regular file     system_u:object_r:named_initrc_exec_t 
/etc/rc\.d/init\.d/unbound                         regular file     system_u:object_r:named_initrc_exec_t 
/etc/rndc.*                                        regular file     system_u:object_r:named_conf_t 
/etc/unbound(/.*)?                                 all files        system_u:object_r:named_conf_t 
/usr/sbin/lwresd                                   regular file     system_u:object_r:named_exec_t 
/usr/sbin/named                                    regular file     system_u:object_r:named_exec_t 
/usr/sbin/named-checkconf                          regular file     system_u:object_r:named_checkconf_exec_t 
/usr/sbin/unbound                                  regular file     system_u:object_r:named_exec_t 
/var/bind(/.*)?                                    all files        system_u:object_r:named_cache_t 
/var/bind/pri(/.*)?                                all files        system_u:object_r:named_zone_t 
/var/log/named.*                                   regular file     system_u:object_r:named_log_t 
/var/run/bind(/.*)?                                all files        system_u:object_r:named_var_run_t 
/var/run/named(/.*)?                               all files        system_u:object_r:named_var_run_t 
/var/run/ndc                                       socket           system_u:object_r:named_var_run_t 
/var/run/unbound(/.*)?                             all files        system_u:object_r:named_var_run_t 
</pre>

<p>
Most of the time, fixing domain issues is a matter of relabeling files (or
updating the configuration to match the contexts already defined - both work).
</p>

</body>
</section>
<section>
<title>Intra-module permissions are missing</title>
<body>

<p>
It is possible that you get a denial between correct security contexts, but
that the permission is just never granted. In this case, you can choose between
two things:
</p>

<ol>
  <li>
    Enhance the module so that the particular permission is granted, or
  </li>
  <li>
    Enhance the module with an additional type where the permission is granted,
    and assign this type/label to the related resources
  </li>
</ol>

<p>
In both cases you will need to edit the module files (most likely the
<path>.te</path> file), build the module, load it, perhaps even relabel the
files or the package and retry. It is also a good idea to take a look at
upstream (latest refpolicy repository or the repositories of Fedora and co) and
see if they have already solved this problem or not.
</p>

<p>
Granting additional permissions between existing domains is the easiest, but
might introduce additional problems: if this permission is only needed in a
particular case yet you grant it for all files and resources related to those
domains, then you are opening up the policy beyond what is necessary. Often,
creating an additional domain or type can be beneficial.
</p>

<p>
A noticeable example is Portage' support for CVS/SVN/GIT ebuilds (the so-called
live ebuilds). These ebuilds get their repository and store it in the
<path>distfiles/svn+src</path> location, which was by default labeled
<path>portage_ebuild_t</path> with only read-access for the
<path>portage_sandbox_t</path> domain. However, with those live ebuilds, the
<path>portage_sandbox_t</path> domain also needs write privileges to this
location. Rather than allowing <path>portage_sandbox_t</path> write privileges
to <path>portage_ebuild_t</path>, a new type was created called
<path>portage_svnsrc_t</path> for just this location and the rights are
copied and enhanced on this additional type.
</p>

</body>
</section>
<section>
<title>Inter-module permissions are needed</title>
<body>

<p>
If the solution for the problem requires permissions between modules, then you
need to create the proper interface functions in the target domain and call
these functions from the source domain.
</p>

<p>
Interface functions are the APIs that a module provides towards other SELinux
modules when they need to interact with the domains. For instance, the
<path>mysql</path> module provides, amongst other functions, the
<c>mysql_stream_connect</c> interface:
</p>

<pre caption="mysql_stream_connect interface">
########################################
## &lt;summary&gt;
##      Connect to MySQL using a unix domain stream socket.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      &lt;summary&gt;
##      Domain allowed access.
##      &lt;/summary&gt;
## &lt;/param&gt;
## &lt;rolecap/&gt;
#
interface(`mysql_stream_connect',`
        gen_require(`
                type mysqld_t, mysqld_var_run_t, mysqld_db_t;
        ')

        stream_connect_pattern($1, mysqld_var_run_t, mysqld_var_run_t, mysqld_t)
        stream_connect_pattern($1, mysqld_db_t, mysqld_var_run_t, mysqld_t)
')
</pre>

<p>
The interface declares that the domain passed on as its first (and only)
argument gets the rights offered by <c>stream_connect_pattern</c>, which is a
macro (defined in <path>policy/support/ipc_patterns.spt</path>) that looks like
so:
</p>

<pre caption="stream_connect_pattern">
define(`stream_connect_pattern',`
        allow $1 $2:dir search_dir_perms;
        allow $1 $3:sock_file write_sock_file_perms;
        allow $1 $4:unix_stream_socket connectto;
')
</pre>

<p>
Modules that need to interact with MySQL through a Unix domain stream socket
(<path>/var/run/mysqld/mysqld.sock</path>) will need the proper permissions to
work with the target type (<path>mysqld_var_run_t</path>). Modules cannot just
set <e>allow</e> statements towards <path>mysqld_var_run_t</path> as they do not
know this type. Instead, they call the <c>mysql_stream_connect</c> interface,
like the <path>postfix.te</path> file does:
</p>

<pre caption="Postfix module calling mysql_stream_connect">
optional_policy(`
        mysql_stream_connect(postfix_master_t)
        mysql_stream_connect(postfix_cleanup_t)
        mysql_stream_connect(postfix_local_t)
')
</pre>

<p>
If the change you need is adding statements (towards existing interface calls) in 
the <path>.te</path> file, then you should be able to test it easily by building
the changed module and loading it. However, if you need to change the interface
of your (or another) module itself (in the <path>.if</path> file) you will eventually
need to rebuild the base policy and even provide and install a new
<path>sec-policy/selinux-base-policy</path> package as this package is
responsible for placing the interfaces in <path>/usr/share/selinux/strict/include</path>.
</p>

<p>
This is one of the reasons why the <path>sec-policy/selinux-base-policy</path> package
in Gentoo Hardened is often updated. Updates on existing interface files (i.e.
for already existing modules) always need to go through this package.
</p>

</body>
</section>
</chapter>

<chapter>
<title>No Domain Exists (Yet)</title>
<section>
<title>Reuse existing domains</title>
<body>

<p>
If you are facing problems because you run an application which has no domain
itself (and hence is probably running in the <path>user_t</path>,
<path>staff_t</path> or <path>sysadm_t</path> domains - or even tries to run in
the <path>initrc_t</path> domain), you will need to create one. But before we do
that, it might be possible that the application can work within the domain
definition of a different application.
</p>

<p>
One example here is lighttpd. This lightweight HTTPd service "uses" the
definitions offered by the <path>apache</path> module. By marking its executable
file <path>httpd_exec_t</path> it runs in the <path>httpd_t</path> domain and
uses the same policy like Apache. By labeling the files according to the
<path>apache.fc</path> definitions (but now for lighttpd) it might Just Work
(TM).
</p>

<p>
Reusing existing domains requires that you at least consider the following
aspects:
</p>

<ul>
  <li>
    Will the application run on the same system as the application for which the
    domain is originally intended? If so, then both might run in the same domain
    (and as such have more privileges towards each other than intended) which
    might not be what you want.
  </li>
  <li>
    Do you need to enhance (read: add additional privileges) the master domain?
    If so, make sure that you don't add more privileges than the original domain
    would ever need to the extend that these privileges become a security risk.
  </li>
</ul>

</body>
</section>
<section>
<title>(Do Not) Copy from existing domains</title>
<body>

<p>
If reusing existing domains introduces too many risks, you'll need to create a
new domain for the application. Many people would be inclined to copy the domain
definition of a similar application and work from there. Although this is a
viable approach, it is considered a bad practice because you start by providing
privileges to the domain that are never needed, and removing privileges from a
domain later is very difficult. Even more, if you are not the author of the
modules, most developers will not even try to remove them as they assume that
the author of the domain had a good reason to add it in the first place. This is
one of the reasons why upstream takes great care in accepting patches - they
must be properly documented before they are accepted.
</p>

<p>
Instead, create a domain from scratch but take a close eye on the domain you
belief is very similar. Issues that arise during the module development might be
quickly resolved by looking at how the original domain is defined.
</p>

</body>
</section>
<section>
<title>Starting from scratch</title>
<body>

<p>
To start the development of a new module from scratch, first identify the
domain(s) you want to have. An application that, in its entire lifespan only
constitutes of a single process, will most likely only have one domain. For
instance, the Skype client will have just <path>skype_t</path>. However,
applications that have multiple processes running might need multiple domains
too. For instance, the Postfix application runs a master
(<path>postfix_master_t</path>), queue manager (<path>postfix_qmgr_t</path>) and
pickup service (<path>postfix_pickup_t</path>), but depending on the commands
you execute, it will also have (short-lived) processes running as
<path>postfix_cleanup_t</path>, <path>postfix_bounce_t</path>, etc.) It is
considered a best practice to start with a fine-grained model for domains
and only later decide if merging multiple domains into one is beneficial.
Splitting domains later is more difficult. Don't forget to look at the
client-side aspect too!
</p>

<p>
Next, define the types that each domain interacts with. This of course includes
the binary (like <path>skype_exec_t</path>) but do not forget resources like
</p>

<ul>
  <li>
    The configuration file(s) in <path>/etc</path> (f.i.
    <path>postfix_etc_t</path>)
  </li>
  <li>
    PID files (f.i. <path>sshd_var_run_t</path>)
  </li>
  <li>
    Spool files (f.i. <path>postfix_spool_t</path>)
  </li>
  <li>
    Variable data files (f.i. <path>snmpd_var_lib_t</path>)
  </li>
  <li>
    Log files (f.i. <path>zebra_log_t</path>)
  </li>
  <li>
    Cache files (f.i. <path>squid_cache_t</path>)
  </li>
  <li>
    (User) content files (f.i. <path>httpd_sys_content_t</path> and
    <path>httpd_user_content_t</path>)
  </li>
</ul>

<p>
Also, try to separate types that are used by other domains as well. This way,
the other domains can only interact with those files or resources that are
labeled accordingly, rather than interact with a broad spectrum of files. The
distinction that the <path>apache</path> module makes between system-provided
content (like phpmyadmin files) and user-provided content (in the
<path>public_html</path> directory in the users' home directories) seems (and
is) very logical, but one could wrongly say that for Apache itself, the access
controls are the same. Although that might be true, both types are clearly used
in different ways so this mandates the use of different domains.
</p>

<p>
Once you have defined those types too, start writing down the intra-domain
permissions. Right now is a good time to look at other modules to see how they
do things. Start with defining the accesses towards the domains.
</p>

<pre caption="Snippet from the spamassassin module">
type spamassassin_t;
type spamassassin_exec_t;
application_domain(spamassassin_t, spamassassin_exec_t)
ubac_constrained(spamassassin_t)
</pre>

<p>
This small snippet defines many things. The first two lines just mention the new
types (the <path>spamassassin_t</path> domain and
<path>spamassassin_exec_t</path> type). The <c>application_domain</c> interface
marks <path>spamassassin_t</path> as an application domain type (it gets the
<path>application_domain_type</path> and <path>domain</path> attributes and a
few default permissions (like allowing that it sends SIGCHLD and SIGNULL to
init). It also marks <path>spamassassin_exec_t</path> as an applications'
executable type (<path>application_exec_type</path> and <path>exec_type</path>
attributes) so that it can be executed by regular users (these domains have
execute rights against all resources that have the
<path>application_exec_type</path> attribute set. Finally, it marks the
<path>spamassassin_t</path> domain as a constrained domain for user-based access
controls. In other words, if SELinux users <path>user_u</path> and
<path>staff_u</path> launch the application in <path>spamassassin_t</path>
domains, then the domains are segregated from each other (the intra-domain rules
inside <path>spamassassin_t</path> are only valid for communication within the
same SELinux user, not between SELinux users).
</p>

<p>
Attributes are an important aspect in SELinux policy development. They make
managing the domains easier, but you should always consider the implications
when you add an attribute to one of your types. It usually means that a whole
lot of permissions are suddenly granted between other domains and yours.
</p>

<p>
Next, set the proper intra-domain permissions. For instance, allow your domain
to read its configuration files as well as more access inside its own
<path>/var/lib</path> location:
</p>

<pre caption="Snippet from openca module">
allow openca_ca_t openca_etc_t:file read_file_perms;
allow openca_ca_t openca_etc_t:dir list_dir_perms;

manage_dirs_pattern(openca_ca_t, openca_var_lib_t, openca_var_lib_t)
manage_files_pattern(openca_ca_t, openca_var_lib_t, openca_var_lib_t)
</pre>

<p>
The majority of work in developing SELinux policy modules is using and choosing
the right interfaces. Having a few functions available to browse through all the
available information is always interesting, so you might want to use the
following function definitions (definitely not mandatory - this is only to help
people skim through the policy definitions):
</p>

<pre caption="SELinux policy development function definitions">
POLICY_LOCATION="/path/to/your/refpolicy";

# sefindif - Find interface definitions that have a string that matches the
# given regular expression
sefindif() {
  REGEXP="$1";
  cd ${POLICY_LOCATION}/policy/modules;
  for FILE in */*.if;
  do
    awk "/(interface\(|template\()/ { NAME=\$NF; P=0 }; /${REGEXP}/ { if (P==0) {P=1; print NAME}; print };" ${FILE} | sed -e "s:^:${FILE}\: :g";
  done
}

# seshowif - Show the interface definition
seshowif() {
  INTERFACE="$1";
  cd ${POLICY_LOCATION}/policy/modules;
  for FILE in */*.if;
  do
    grep -A 9999 "\(interface(\`${INTERFACE}'\|template(\`${INTERFACE}'\)" ${FILE} | grep -B 9999 -m 1 "^')";
  done
}

# sefinddef - Find macro definitions that have a string that matches the given
# regular expression
sefinddef() {
  REGEXP="$1";
  grep -H "define(\`.*${REGEXP}.*" ${POLICY_LOCATION}/policy/support/* | sed -e 's:.*\/\([^(]*\):\1:g'
}

# seshowdef - Show the macro definition
seshowdef() {
  MACRONAME="$1";
  cd ${POLICY_LOCATION}/policy/support;
  for FILE in *.spt;
  do
    grep -A 9999 "define(\`${MACRONAME}'" ${FILE} | grep -B 999 -m 1 "')";
  done
}
</pre>

<p>
These functions can then be used to find the information / interfaces you are
looking for. Perhaps you need the application to read the postfix
configuration files, so look for potential interfaces that use the
<e>postfix_etc_t</e> type:
</p>

<pre caption="Looking for the interface(s) needed">
~$ <i>sefindif postfix_etc_t</i>
services/postfix.if: template(`postfix_domain_template',`
services/postfix.if:    allow postfix_$1_t postfix_etc_t:dir list_dir_perms;
services/postfix.if:    read_files_pattern(postfix_$1_t, postfix_etc_t, postfix_etc_t)
services/postfix.if:    read_lnk_files_pattern(postfix_$1_t, postfix_etc_t, postfix_etc_t)
<comment>services/postfix.if: interface(`postfix_read_config',`
services/postfix.if:            type postfix_etc_t;
services/postfix.if:    read_files_pattern($1, postfix_etc_t, postfix_etc_t)
services/postfix.if:    read_lnk_files_pattern($1, postfix_etc_t, postfix_etc_t)</comment>
services/postfix.if: interface(`postfix_config_filetrans',`
services/postfix.if:            type postfix_etc_t;
services/postfix.if:    filetrans_pattern($1, postfix_etc_t, $2, $3)

~$ <i>seshowif postfix_read_config</i>
interface(`postfix_read_config',`
        gen_require(`
                type postfix_etc_t;
        ')

        read_files_pattern($1, postfix_etc_t, postfix_etc_t)
        read_lnk_files_pattern($1, postfix_etc_t, postfix_etc_t)
        files_search_etc($1)
')
</pre>

<p>
Same thing if you want to look for the correct macro definition (usually, if you
notice something but you cannot find it as an interface, then it is most likely
a macro):
</p>

<pre caption="Looking for the right macros">
<comment># Suppose you need to read, write, connect, ... to a socket</comment>
~$ <i>sefinddef connect</i>
ipc_patterns.spt:define(`stream_connect_pattern',`
<comment>obj_perm_sets.spt:define(`rw_socket_perms', `{ ioctl read getattr write setattr append bind connect getopt setopt shutdown }')</comment>
obj_perm_sets.spt:define(`connected_socket_perms', `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }')
obj_perm_sets.spt:define(`connected_stream_socket_perms', `{ connected_socket_perms listen accept }')

<comment># To see what the ps_process_pattern is about</comment>
~$ <i>seshowdef ps_process_pattern</i>
define(`ps_process_pattern',`
        allow $1 $2:dir list_dir_perms;
        allow $1 $2:file read_file_perms;
        allow $1 $2:lnk_file read_lnk_file_perms;
        allow $1 $2:process getattr;
')
</pre>

<p>
As we strive to bring most of our patches upstream, please do consider the <uri
link="http://oss.tresys.com/projects/refpolicy/wiki/HowToContribute">contribution
guidelines</uri> of the reference policy project. The project has a documented
style guide, naming convention and an online API reference (for the various
interfaces).
</p>

<p>
Note that, the moment you create a new module, you'll need to create the proper
role interfaces (if it is an application that is directly called from a user
domain). Take a look at <c>tvtime_role</c> and how it is used in the
<path>staff.te</path> and <path>sysadm.te</path> role definitions.
</p>

</body>
</section>
<section>
<title>Testing new modules</title>
<body>

<p>
When you test your application, test it in as many ways as possible. If your
application is a command-line application, run it both from a regular terminal
(tty) as well as a virtual one (in an xterm). See if it still works if you run
it in a screen session. Try out all functions and features that the application
supports.
</p>

<p>
This rigorous testing is necessary because SELinux denies everything that isn't
explicitly allowed. If you do not test certain features, chances are that the
module does not provide the necessary permissions and as such, users will be
impacted.
</p>

<p>
To test out a new module, load it (<c>semodule -i modulename.pp</c>) and relabel
the files affiliated with the application (either through <c>rlpkg</c> or using
<c>restorecon</c>). Consider the following testing activities if applicable (not
all domains are interactive domains, so please read the activities with your
domain definition in mind):
</p>

<ul>
  <li>
    Sending signals to the application (if you need to be able to kill it, try
    killing it)
  </li>
  <li>
    Run it both as a regular user (<path>user_u</path>) as well as
    administrative users (if applicable). If your domain needs to support
    unconfined domains/users, run it from an unconfined user domain too.
  </li>
  <li>
    Run it from a terminal, console, screen, sudo, ...
  </li>
  <li>
    Change the applications' configuration file (including rendering it useless
    with syntax errors) and look at the applications' behavior. Especially
    syntax failures as that might trigger the application to log things at
    places that you haven't discovered earlier.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Policy Guidelines</title>
<section>
<title>Gentoo Hardened SELinux policy</title>
<body>

<p>
To streamline the policy development efforts, Gentoo Hardened as a <uri
link="selinux-policy.xml">SELinux Policy</uri> document explaining the
principles used during policy development and the implementation guidelines we
strive to follow during development.
</p>

<p>
Such a policy is important because we want to have a consistent security policy
that users and developers can relate to. By following the policy, we hope that
other developers can quickly jump in and work on it further.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Submitting Patches</title>
<section>
<title>File context patches</title>
<body>

<p>
If you are able to fix a problem by adding the proper file contexts (using
<c>semanage fcontext -a</c>), please consider the following:
</p>

<ul>
  <li>
    If the location for which you set the context deviates from the standard
    location as either intended by the project or Gentoo itself, it might be
    best to document it in the forums or elsewhere. We will not change file
    contexts to match every ones configuration, unless the file context change
    is apparent for each installation.
  </li>
  <li>
    Developers might not immediately push file context changes in new policy
    module packages to keep the amount of policy module changes low. Instead,
    these changes can be stacked and pushed when other changes occur as well.
  </li>
</ul>

<p>
If you believe that the change is needed for everyone using Gentoo Hardened with
SELinux, create a <uri link="https://bugs.gentoo.org">bugreport</uri> and assign
it to <c>selinux@gentoo.org</c>. In the bugreport, mention the file context you
think is necessary and why.
</p>

</body>
</section>
<section>
<title>Policy patches</title>
<body>

<p>
Policy patches are best generated through the <c>git format-patch</c> approach.
</p>

<pre caption="Example generating patch for modular changes">
~$ <i>cd hardened-refpolicy/policy/modules</i>
<comment># Edit the file(s), like openct.te</comment>
~$ <i>git add openct.te</i>
~$ <i>git commit -m 'Openct does not need to read /proc'</i>
~$ <i>git format-patch -n -s master</i>
0001-openct-does-not-need-to-read-proc.patch
</pre>

<p>
Attach this patch to the <uri link="https://bugs.gentoo.org">bugreport</uri>
explaining why it is needed. If you think the patch itself is not obvious, make
sure that the necessary comments are in place <e>inside the patch</e> for future
reference. If your patch contains many steps, it might be best to use separate
commits in the repository so that the logic of the patch can be easily followed.
</p>

<p>
Please have a separate patch file per module (do not combine multiple modules in
a single patch).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Fully Running Your Own Policy</title>
<section>
<title>Creating a local overlay</title>
<body>

<p>
If you want to use your own policy rather than Gentoo's, we seriously recommend
to use a local overlay which uses the same package names and constructs. This
allows your policy to integrate properly with the other Gentoo packages (which
might depend on the SELinux packages). For instance, when you install openldap,
it will still properly depend on the <path>sec-policy/selinux-ldap</path>
package even if you provide it completely.
</p>

<p>
To do so, first create a local overlay and copy the content of the
<path>sec-policy</path> category inside it.
</p>

<pre caption="Creating a local overlay">
~$ <i>mkdir dev/overlay</i>
~$ <i>cp -r /usr/portage/sec-policy dev/overlay</i>
</pre>

<p>
Next, tell Portage to not synchronise the <path>sec-policy</path> category of
the main tree anymore. To do so, create the file
<path>/etc/portage/rsync_excludes</path> with the following content:
</p>

<pre caption="Rsync exclusion information">
sec-policy/
</pre>

<p>
Finally, add your current overlay by editing <path>/etc/make.conf</path>:
</p>

<pre caption="Editing make.conf">
PORTDIR_OVERLAY="${PORTDIR_OVERLAY} /home/user/dev/overlay"
</pre>

<p>
From now onwards, Gentoo Portage will only use your local overlay (you can
remove <path>/usr/portage/sec-policy</path> if you don't want Portage to even
reuse the current set of packages.
</p>

</body>
</section>
<section>
<title>Updating module packages</title>
<body>

<p>
To create or update a module package, you can use the following skeleton for the
ebuilds:
</p>

<pre caption="Skeleton for ebuilds, example for postfix">
# Copyright 1999-2012 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux-development.xml,v 1.5 2012/08/24 15:50:10 swift Exp $
EAPI="4"

IUSE=""
<comment># Set the MODS variable to the refpolicy name used, so services/postfix.te gives "postfix"</comment>
MODS="postfix"
<comment># BASEPOL is optional, set it to the selinux-base-policy version which
# includes the latest patch (or interface you use in the policy)</comment>
BASEPOL="2.20120215-r9"

inherit selinux-policy-2

DESCRIPTION="SELinux policy for postfix"
KEYWORDS="~amd64 ~x86"

<comment># POLICY_PATCH is optional (only when you have a module patch which is not included</comment>
<comment># in the patchbundle of the base policy you referred to in BASEPOL.</comment>
POLICY_PATCH="${FILESDIR}/fix-services-postfix-r3.patch"
</pre>

<p>
The patch(es) that you can put in the <path>files/</path> location (and referred to
in the <c>POLICY_PATCH</c>) should be made as defined earlier in this document.
You can put multiple patches in this variable if you want.
</p>

<p>
Don't forget to run <c>repoman manifest</c> with every change, and run
<c>repoman scan</c> to check for potential mistakes.
</p>

</body>
</section>
<section>
<title>Updating base package</title>
<body>

<p>
To provide updates on the base policy, it is recommended to keep all patches you
made centrally in a directory (say <path>dev/hardened/base-patches</path>). When
you want to create a new <path>sec-policy/selinux-base-policy</path> and
<path>sec-policy/selinux-base</path> release, create a patchbundle from your patch
directory, put the bundle online somewhere, create the updated ebuild and try it out.
</p>

<p>
However, the moment you modify the base package(s), you will also need to change
the <path>selinux-policy-2.eclass</path> file and the base policy ebuild. This
is because, by default, the ebuilds will look for their files in the Gentoo
download locations instead of wherever you would like to store the patches and
sources.
</p>

<p>
Put a copy of the eclass inside your overlay and edit the <c>SRC_URI</c>
definition to point to your new location. Then edit the
<path>selinux-base</path> and <path>selinux-base-policy</path> ebuilds (inside
your overlay again) and change their <c>SRC_URI</c> too.
</p>

<p>
Once this is done, you can go onwards with building a new base policy package.
</p>

<pre caption="Building a base policy package">
<comment># Go to the location where all patches are currently extracted</comment>
~$ <i>cd dev/hardened/base-patches</i>

<comment># Add the patches you want to include, cfr Submitting Patches</comment>
<comment># Then, create a new patch bundle</comment>
~$ <i>tar cjvf ../overlay/sec-policy/selinux-base-policy/files/patchbundle-selinux-base-policy-2.20120215-r10.tar.bz2 *</i>

<comment># Finally, bump the revision of the ebuilds in the overlay</comment>
~$ <i>cd ../overlay/sec-policy/selinux-base-policy</i>
~$ <i>cp selinux-base-policy-2.20120215-r9.ebuild selinux-base-policy-2.20120215-r10.ebuild</i>
~$ <i>vim selinux-base-policy-2.20120215-r10.ebuild</i>
<comment># Update references to the patchbundle and dependencies (like BASEPOL)</comment>
~$ <i>cd ../selinux-base</i>
~$ <i>cp selinux-base-2.20120215-r9.ebuild selinux-base-2.20120215-r10.ebuild</i>
</pre>

<p>
Don't forget to run <c>repoman manifest</c> and <c>repoman scan</c>. You can
then install <path>sec-policy/selinux-base-policy-2.20120215-r10</path> and test
it out.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Adding Third Party Policies</title>
<section>
<title>What is a Third Party Policy?</title>
<body>

<p>
Most users who are responsible for handling the SELinux policies on one or more
systems will most likely be writing their own policies too. Be it because the
policy offered by Gentoo doesn't provide a policy for the package yet, or
because the policy is needed for a local, non-Gentoo-provided package, it is
still important for the administrator to easily manage these added policies on
the systems.
</p>

<p>
An administrator can perfectly build and load the policy once and then let it
be. After all, once a SELinux policy is loaded, it will be reloaded after every
(re)boot. But within Gentoo, we support simple ebuilds that install the policy
on the system for you.
</p>

</body>
</section>
<section>
<title>Creating an Ebuild</title>
<body>

<p>
Assuming you already have an overlay, all you need to do is create a package for
your third party policy. For instance, a policy for an Oracle database might be
called <path>oracledb.pp</path> so you would then create a package
<path>sec-policy/selinux-oracledb</path>.
</p>

<p>
Then create the following ebuild:
</p>

<pre caption="Third party policy ebuild">
# Copyright 1999-2012 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux-development.xml,v 1.5 2012/08/24 15:50:10 swift Exp $
EAPI="4"

IUSE=""
MODS="oracledb"
BASEPOL="2.20120215-r10"
POLICY_FILES="oracledb.te oracledb.if oracledb.fc"

inherit selinux-policy-2

DESCRIPTION="SELinux policy for Oracle DB"

KEYWORDS="~amd64 ~x86"
</pre>

<p>
Finally, put the three policy-related files (assuming you have three) in the
<path>files</path> directory of the package.
</p>

<p>
With this in place, you can now install the package and it will install the
SELinux policy module. If the package provided an interface, it will also be
added to the <path>/usr/share/selinux/strict/include</path> location (or
<path>targeted</path> or whatever your SELINUXTYPE is).
</p>

</body>
</section>
</chapter>

</guide>
