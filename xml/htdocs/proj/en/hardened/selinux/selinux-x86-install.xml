<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/proj/en/hardened/selinux/selinux-x86-install.xml">
  <title>Gentoo x86 SELinux Installation Guide</title>
  <author title="Author">
	<mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
  </author>
  <author title="Editor">
	<mail link="pebenito@gentoo.org">Chris PeBenito</mail>
  </author>
  <abstract>
    This guide will walk you through the steps to installing Gentoo SELinux from scratch. 
  </abstract>
<license/>
<version>2.1</version>
<date>22 June 2004</date>
<chapter>
  <title>Part One</title>
  <section>
    <title>About the Install</title>
    <body>
	<warn>
	  SELinux is only supported on servers.  Workstation support
	  may happen in the future.
	</warn>
	<impo>
	  SELinux stages and LiveCD are required.
	</impo>
      <p>
This new boot CD will boot from nearly any modern IDE CD-ROM drive, as well
as many SCSI CD-ROM drives, assuming that your CD-ROM and BIOS both support booting.
Included on the CD-ROM is Linux support for IDE (and PCI IDE) (built-in to the
kernel) as well as support for all SCSI devices (available as modules.) In
addition, we provide modules for literally every kind of network card that
Linux supports, as well as tools to allow you to configure your network and
establish outbound (as well as inbound) <c>ssh</c> connections and to download
files.  </p>
<!--        <p>To install from the build CD, you will need to have a 486+ processor and
ideally at least 64 Megabytes of RAM. (Gentoo Linux has been successfully
built with 64MB of RAM + 64MB of swap space, but the build process is awfully
slow under those conditions.)</p>-->
		<p> So, how does one begin the install process? First, you need a SELinux LiveCD ISO image from
<uri>http://gentoo.oregonstate.edu/experimental/x86/livecd/x86</uri>.  SELinux LiveCDs have "selinux" in the filename.
		Please consider using one of our mirrors to alleviate the heavy load from
		the main server.  A list of servers can be found at <uri>http://www.gentoo.org/main/en/mirrors.xml</uri>.
</p>
        <p> The LiveCDs are full CD images that should be burned to a CDR or CD-RW
using CD burning software.<!-- Currently, we have two types of LiveCDs. The first
carries the &quot;gentoo-basic&quot; label, and is approximately 40MB in size, contains only the stage 1 tarball and lives
in the <path>x86/livecd/</path> directory.  This LiveCD is of minimal size to
allow for a initial quick download and contains a stage1 tarball that can be
found in <path>/mnt/cdrom/gentoo/</path> after the CD has booted.</p>
        <p>The second flavor of LiveCD we currently offer is labeled &quot;gentoo-3stages.&quot;
This CD is also found in <path>x86/livecd</path>. It
contains stage 1, 2 and 3 tarballs.  However, since we are only going to cover how to install with a stage1 tarball, this download is somewhat excessive.
--></p>
        <impo>If you encounter a problem with any part of the install and wish to
report it as a bug, report it to <uri>http://bugs.gentoo.org</uri>. If the bug
needs to be sent upstream to the original software developers (eg the KDE team) the
<e>Gentoo Linux developers</e> will take care of that for you.
</impo>
	<note>The installation instructions in the LiveCD may not be the most up-to-date.  Always refer to
	<uri>http://www.gentoo.org/proj/en/hardened/selinux/selinux-x86-install.xml</uri> for the most up-to-date
	installation instructions.
	</note>
        <p>Now, let us quickly review the install process. First, we will download, burn
and boot a LiveCD. After getting a root prompt, we will create partitions, create
our filesystems and extract the stage tarball.  Once we have done thus, we will progress our system through the separate stages of the install: bootstrapping, <c>emerge system</c>, and configuring.  After that, we will be able to boot a fully-functional SELinux Gentoo system.
 Here is what is required for installation: </p>
        <table>
          <tr>
            <th>SELinux Stage Tarball</th>
            <th>SELinux with Hardened GCC Stage Tarball</th>
            <th>Requirements for Installation</th>
          </tr>
          <tr>
            <ti>stage1-x86-selinux</ti>
            <ti>stage1-x86-selinux-pie-ssp</ti>
            <ti>partition/filesystem setup, emerge sync, bootstrap, emerge system, emerge kernel sources, final configuration</ti>
          </tr>
          <tr>
            <ti>stage2-x86-selinux</ti>
            <ti>stage2-x86-selinux-pie-ssp</ti>
            <ti>partition/filesystem setup, emerge sync, emerge system, emerge kernel sources, final configuration</ti>
          </tr>
          <tr>
            <ti>stage3-x86-selinux</ti>
            <ti>stage3-x86-selinux-pie-ssp</ti>
            <ti>partition/filesystem setup, emerge sync, emerge kernel sources, final configuration</ti>
          </tr>
        </table>
        <p>SELinux should be installed with standard SELinux stages, or if you
           intend to use Hardened GCC with SELinux, the pie-ssp stages should
           be used.
        </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Booting</title>
    <section>
      <body>
        <p>Start by booting the LiveCD. You should see a fancy boot screen
		with the Gentoo Linux logo on it. At this screen, you can hit Enter to begin the boot process,
		or boot the LiveCD with custom boot options by specifying a kernel followed by boot options and then hitting Enter. For example <c>gentoo nousb nohotplug</c>. Consult the following table for a list of available kernels and options or press F2 to view the help screen.</p>
	
	<table>
	<tr>
		<th>Available kernels.</th>
		<th>description</th>
	</tr>
	
	<tr><ti>permissive</ti><ti>SELinux in permissive mode (default)</ti></tr>
	<tr><ti>enforcing</ti><ti>SELinux in enforcing mode</ti></tr>
	<tr><ti>seoff</ti><ti>SELinux disabled</ti></tr>
	<tr><ti>permissive-nofb</ti><ti>SELinux in permissive mode, disabled framebuffer</ti></tr>
	<tr><ti>enforcing-nofb</ti><ti>SELinux in enforcing mode, disabled framebuffer</ti></tr>
	<tr><ti>seoff-nofb</ti><ti>SELinux disabled, disabled framebuffer</ti></tr>

	</table>
	
	<p>
<!--
	<table>
	<tr>
		<th>Available boot options.</th>
		<th>description</th>
	</tr>

	<tr><ti>doataraid</ti>
	<ti>loads ide raid modules from initrd</ti></tr>
	
	<tr><ti>dofirewire</ti>
	<ti>modprobes firewire modules in initrd (for firewire cdroms,etc)</ti></tr>

	<tr><ti>dokeymap</ti>
	<ti>enable keymap selection for non-us keyboard layouts</ti></tr>

	<tr><ti>dopcmcia</ti>
	<ti>starts pcmcia service</ti></tr>

	<tr><ti>doscsi</ti>
	<ti>scan for scsi devices (breaks some ethernet cards)</ti></tr>

	<tr><ti>noapm</ti>
	<ti>disables apm module load</ti></tr>

	<tr><ti>nodetect</ti>
	<ti>causes hwsetup/kudzu and hotplug not to run</ti></tr>

	<tr><ti>nodhcp</ti>
	<ti>dhcp does not automatically start if nic detected</ti></tr>

	<tr><ti>nohotplug</ti>
	<ti>disables loading hotplug service</ti></tr>

	<tr><ti>noraid</ti>
	<ti>disables loading of evms modules</ti></tr>

	<tr><ti>nousb</ti>
	<ti>disables usb module load from initrd, disables hotplug</ti></tr>

	<tr><ti>ide=nodma</ti>
	<ti>Force disabling of dma for malfunctioning ide devices</ti></tr>

	<tr><ti>cdcache</ti>
	<ti>Cache the entire runtime portion of cd in ram, This uses 40mb of RAM , but allows you to umount /mnt/cdrom and mount another cdrom.</ti></tr>

	</table> --> </p>

	<p> Once you hit Enter, you will be greeted with the standard kernel
booting output, kernel and initrd messages, followed by the normal Gentoo
Linux boot sequence. You will be automatically logged in as
&quot;<c>root</c>&quot; <!-- and the root password will be set to a random string
for security purposes-->. You should have a root (&quot;<c>#</c>&quot;) prompt
on the current console, and can also switch to other consoles by pressing
Alt-F2, Alt-F3 and Alt-F4. Get back to the one you started on by pressing
Alt-F1. <!-- At this point you should set the root password, type <c>passwd</c> and
follow the prompts.-->
			</p>
        <p>You have probably also noticed that above your <c>#</c> prompt is a bunch of help text
			that explains how to do things like configure your Linux networking and telling you where you can find
			the Gentoo Linux stage tarballs and packages on your CD.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Load Kernel Modules</title>
    <section>
      <body>
        <p>If the PCI autodetection missed some of your hardware, you 
			will have to load the appropriate kernel modules manually.
			To view a list of all available network card modules, type <c>ls
			/lib/modules/*/kernel/drivers/net/*</c>.  To load a particular module,
			type:
			</p>
<pre caption="PCI Modules Configuration">
# <i>modprobe pcnet32</i>
<comment>(replace pcnet32 with your NIC module)</comment>
</pre>
        <p>Likewise, if you want to be able to access any SCSI hardware that was not detected
			during the initial boot autodetection process, you will need to load the appropriate
			modules from /lib/modules, again using <c>modprobe</c>:
			</p>
<pre caption="Loading SCSI Modules">
# <i>modprobe aic7xxx</i>
<comment>(replace aic7xxx with your SCSI adapter module)</comment>
# <i>modprobe sd_mod</i>
<comment>(sd_mod is the module for SCSI disk support)</comment>
</pre>
			<note>
			Support for a SCSI CD-ROMs and disks are built-in in the kernel.
			</note>
<!--
        <p>If you are using hardware RAID, you will need to load the 
			ATA-RAID modules for your RAID controller.
			</p>
<pre caption="Loading RAID Modules">
# <c>modprobe ataraid</c>    
# <c>modprobe pdcraid</c>            
<comment>(Promise Raid Controller)</comment>    
# <c>modprobe hptraid</c>            
<comment>(Highpoint Raid Controller)</comment>    
</pre>
-->
<note>The LiveCD uses the 2.6 kernel which does not have ATA-RAID support
yet.  These controllers may or may not work with regular IDE support.</note>
        <p>The Gentoo LiveCD should have enabled DMA on your disks, but if it did not,
			<c>hdparm</c> can be used to set DMA on your drives. </p>
<pre caption="Setting DMA">
<comment>Replace hdX with your disk device.</comment>
# hdparm -d 1 /dev/hdX <comment>Enables DMA </comment>
# hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX
<comment>(Enables DMA and other safe performance-enhancing options)</comment>
# hdparm -X66 /dev/hdX
<comment>(Force-enables Ultra-DMA -- dangerous -- may cause some drives to mess up)</comment>
</pre>
      </body>
    </section>
  </chapter>
<!-- THIS SECTION SHOULD BE DEPRECATED WITH HOTPLUG ENABLED IN 1.4_rc3 (drobbins)
  <chapter>
    <title>Loading PCMCIA Kernel Modules</title>
    <section>
      <body>
        <p>If you have a PCMCIA network card, you will need to perform a few extra steps.
			</p>
        <warn>To avoid problems with <c>cardmgr</c>, you <e>must</e> run it <e>before</e> you enter the chroot
			portion of the install. </warn>
<pre caption="Loading PCMCIA Modules">
# <i>modprobe pcmcia_core</i>
# <i>modprobe i82365</i>
# <i>modprobe ds</i>
# <i>cardmgr -f</i>
</pre>
        <p>As <c>cardmgr</c> detects which hardware is present, your speaker should emit a
			few reassuring beeps, and your PCMCIA network card should be active. You can
			of course insert the PCMCIA card after loading <c>cardmgr</c> too, if that is 
			preferable. (Technically, you need not run 
			<c>cardmgr</c> if you know exactly which module your PCMCIA card requires. 
			But if you do not, loading all PCMCIA modules and see which sticks will not work,
			as all PCMCIA modules load obligingly and hang around for a PCMCIA card to 
			drop by. <c>cardmgr</c> will also unload the module(s) for any card when you
			remove it). </p>
      </body>
    </section>
  </chapter>
-->
  <chapter>
    <title>Configuring Networking</title>
	<section>
      <title>Maybe it just works?</title>
      <body>
		<p>If you are using a 1.4_rc3 or later LiveCD, it is possible that your networking has already been
		configured automatically for you. If so, you should be able to take advantage of the many included
		network-aware commands on the LiveCD such as <c>ssh</c>, <c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> and <c>lynx</c>,
		among others.</p>
	  
        <p>If networking has been configured for you, the <c>/sbin/ifconfig</c> command should 
		list some internet interfaces besides <c>lo</c>, such as <c>eth0</c>:
		</p>
<pre caption="/sbin/ifconfig for a working network card">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11
</pre>
        <p>You may want to also try pinging your ISPs DNS server (found in <path>/etc/resolv.conf</path>),
		and a Web site of choice, just to make sure that your packets are reaching the net, DNS name
		resolution is working correctly, etc.
		</p>
<pre caption="Further Network Testing">
# <i>ping -c 3 www.yahoo.com </i>
</pre>
		<p>Are you able to use your network? If so, you can skip the rest of this section.</p>
      </body>
    </section>
    <section>
      <title> PPPoE configuration</title>
      <body>
        <p>Assuming you need PPPoE to connect to the internet, the LiveCD (any version) has
			made things easy for you by including <c>rp-pppoe</c>. Use the provided <c>adsl-setup</c>
			script to configure your connection. You will be prompted for the ethernet
			device that is connected to your adsl modem, your username and password,
			the IPs of your DNS servers, and if you need a basic firewall or not. </p>
<pre caption="Configuring PPPoE">
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>
        <p>If something goes wrong, double-check that you correctly typed
			your username and password by looking at <path>/etc/ppp/pap-secrets</path> or
			<path>/etc/ppp/chap-secrets</path>, and make sure you are using the right ethernet device. </p>
      </body>
    </section>
    <section>
      <title> Automatic Network Configuration </title>
      <body>
       <p>The simplest way to set up networking if it did not get configured automatically is to run the <c>net-setup</c> script.</p>
<pre caption="Net-Setup Script">
# <i>net-setup eth0</i>
</pre>
        <p>Of course, if you prefer, you may still set up networking manually. This is covered next.</p>
      </body>
    </section>
    <section>
      <title>Manual DHCP Configuration</title>
      <body>
        <p>Network configuration is simple with DHCP; If your ISP is not using
		DHCP, skip down to the static configuration section below. </p>
<pre caption="Network configuration with DHCP">
# <i>dhcpcd eth0</i>
</pre>
        <note>Some ISPs require you to provide a hostname.  To do that,
		add a <c>-h &lt;myhostname&gt;</c> flag to the dhcpcd command line above; whereas <c>&lt;myhostname&gt;</c> is your ISP-provided hostname.
		</note>
        <p>If you receive <c>dhcpConfig</c> warnings, do not panic; the errors
		are most likely cosmetic.  Skip down to Network testing below.</p>
      </body>
    </section>
    <section>
      <title>Manual Static Configuration</title>
      <body>
        <p>We need to setup just enough networking so that we can download
		sources for the system build, as well as the required localhost interface. The needed information is explained in the next table.  You do not need to do manual static configuration if you have already configured your network interfaces with DHCP.</p>

<table>
<tr><th>Information</th><th>Description</th><th>Example value</th></tr>
<tr><ti>IP address</ti><ti>The IP-address you want to assign to your network card</ti><ti>192.168.1.2</ti></tr>
<tr><ti>Broadcast address</ti><ti>The IP-address which will broadcast the packets to all the hosts in the network.</ti><ti>192.168.1.255</ti></tr>
<tr><ti>Network mask</ti><ti>The mask which is used together with the IP address to see what part of the address is for network-identification and host-identification</ti><ti>255.255.255.0</ti></tr>
<tr><ti>Gateway</ti><ti>The IP-address of the computer which will forward the packets that are not meant for the local network (most of the time the computer which shares the internet connection)</ti><ti>192.168.1.1</ti></tr>
</table>
        
		<p>Type in the following commands, replacing
		$IFACE with your network interface (typically <c>eth0</c>), $IPNUM
		with your IP address, $BCAST with your broadcast address, and $NMASK
		with your network mask.  For the <c>route</c> command, replace 
		$GTWAY with your default gateway.
		</p>
<pre caption="Static IP Network Configuration">
# <i>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>/sbin/route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</i>
</pre>
        <p>Now it is time to create the <path>/etc/resolv.conf</path>
		file so that name resolution (finding Web/FTP sites by name, rather 
        than just by IP address) will work. You can use <c>nano -w 
        /etc/resolv.conf</c> to create <path>/etc/resolv.conf</path>. 
        <c>nano</c> is a small and easy-to-use editor.</p>
        <p>Here is a template to follow for creating your /etc/resolv.conf file: </p>
<pre caption="/etc/resolv.conf template">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>
        <p>Replace <c>10.0.0.1</c> and <c>10.0.0.2</c> with the IP addresses of your
		primary and secondary DNS servers respectively.</p>
      </body>
    </section>
    <section>
      <title>Proxy Configuration</title>
      <body>
        <p>If you are behind a proxy, it could be necessary to configure your proxy before
		you continue. We will export some variables to set up the proxy accordingly.
		</p>
<pre caption="Setting a Proxy">
<codenote>If the proxy restricts HTTP traffic:</codenote>
# <i>export http_proxy=&quot;machine.company.com:1234&quot; </i>
<codenote>If the proxy restricts FTP traffic:</codenote>
# <i>export ftp_proxy=&quot;machine.company.com&quot; </i>
<codenote>If the proxy restricts RSYNC traffic:</codenote>
# <i>export RSYNC_PROXY=&quot;machine.company.com&quot; </i>
</pre>
      </body>
    </section>
    <section>
      <title>Networking is a go!</title>
      <body>
        <p>Networking should now be configured and usable.  You should be able to use the included
		<c>ssh</c>, <c>scp</c>, <c>lynx</c>, <c>irssi</c> and <c>wget</c> commands to connect to other machines on your LAN or the Internet.</p>
      </body>
    </section>
    <section>
    	<title>I do not have networking!</title>
	<body><p>If you do not have networking there is some help in the
		<uri link="http://forums.gentoo.org/">Gentoo Forums</uri>.
		Some useful links can be found at <uri>http://forums.gentoo.org/viewtopic.php?t=43025</uri>.</p>
	</body>
    </section>
  </chapter>
  <chapter>
    <title>Setting your system's date and time</title>
    <section>
      <body>
        <p>Now you need to set your system's date and time.
	   You can do this using the <c>date</c> command.</p>
<pre caption="Setting your system's date">
# <i>date</i>
Thu Feb 27 09:04:42 CST 2003
<comment>(If your date is wrong, set your date with this next command)</comment>
# <i>date 022709042003</i>
<comment> (date MMDDhhmmCCYY)</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Filesystems, partitions and block devices</title>
    <section>
		<title>Introduction to block devices</title>
      <body>
<p>
In this section, we will take a good look at disk-oriented aspects of Gentoo Linux and Linux in general, including
Linux filesystems, partitions and block devices. Then, once you are familiar with the ins and outs of disks and
filesystems, you will be guided through the process of setting up partitions and filesystems for your Gentoo Linux
install.
</p>
<p>
To begin, I will introduce "block devices".  The most famous block device is
probably the one that represents the first IDE drive in a Linux system: <path>/dev/hda</path>.
</p>
<p>
If your system uses SCSI drives, then your first hard drive will be <path>/dev/sda</path>.
</p>
<p>The block devices above represent an <c>abstract</c> interface to the disk.
User programs can use these block devices to interact with your disk without
worrying about whether your drivers are IDE, SCSI or something else.  The
program can simply address the storage on the disk as a bunch of contiguous,
randomly-accessible 512-byte blocks.  </p>
</body>
</section>
<section>
<title>Partitions and fdisk</title>
<body>
<p> Under Linux, we create filesystems by using a special command called
<c>mkfs</c> (or <c>mke2fs</c>, etc,) specifying a particular
block device as a command-line argument.  </p>

<p> However, although it is theoretically possible to use a "whole disk" block
device (one that represents the <c>entire</c> disk) like <c>/dev/hda</c> or
<c>/dev/sda</c> to house a single filesystem, this is almost never done in
practice.  Instead, full disk block devices are split up into smaller, more
manageable block devices called "partitions".  Partitions are created using a
tool called <c>fdisk</c>, which is used to create and edit the partition table
that is stored on each disk.  The partition table defines exactly how to split
up the full disk.  </p>

<p> We can take a look at a disk's partition table by running <c>fdisk</c>,
specifying a block device that represents a full disk as an argument: </p>

<note>Alternate interfaces to the disk's partition table include <c>cfdisk</c>,
<c>parted</c> and <c>partimage</c>. We recommend <c>fdisk</c> becuase it is
more powerfull and well known in the Unix/Linux world.</note>

<pre caption="Starting up fdisk">
# <i>fdisk /dev/hda</i>
<comment>or</comment>
# <i>fdisk /dev/sda</i>
</pre>

<impo>
<b>Note that you should <c>not</c> save or make any changes to a disk's
partition table if any of its partitions contain filesystems that are in use or
contain important data.  Doing so will generally cause data on the disk to be
lost.</b>
</impo>

<p>
Once in fdisk, you will be greeted with a prompt that looks like this:
</p>

<pre caption="The fdisk prompt">
Command (m for help): 
</pre>


<p>
Type <c>p</c> to display your disk's current partition configuration:
</p>

<pre caption="An example partition configuration">
Command (m for help): p

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p> This particular disk is configured to house seven Linux filesystems (each
with a corresponding partition listed as "Linux") as well as a swap partition
(listed as "Linux swap").  </p>

<p>
Notice the name of the corresponding partition block
devices on the left hand side, starting with <c>/dev/hda1</c> and going up to
<c>/dev/hda9</c>. In the early days of the PC, partitioning software only
allowed a maximum of four partitions (called "primary" partitions).  This was
too limiting, so a workaround called an <c>extended partitioning</c> was
created.  An extended partition is very similar to a primary partition, and
counts towards the primary partition limit of four.  However, extended
partitions can hold any number of so-called <c>logical</c> partitions inside
them, providing an effective means of working around the four partition limit.
</p>

<p>
All partitions <c>hda5</c> and higher are logical partitions. The numbers 1
through 4 are reserved for primary or extended partitions.  </p>

<p> So, In our example, <c>hda1</c> through <c>hda3</c> are primary partitions.
<c>hda4</c> is an extended partition that contains logical partitions
<c>hda5</c> through <c>hda9</c>. You would never actually
<c>use</c> <c>/dev/hda4</c> for storing any filesystems directly -- it simply
acts as a container for partitions <c>hda5</c> through <c>hda9</c>.  </p>

<p> Also, notice that each partition has an "Id", also called a "partition
type".  Whenever you create a new partition, you should ensure that the
partition type is set correctly. '83' is the correct partition type for
partitions that will be housing Linux filesystems, '82' is the correct
partition type for Linux swap partitions and 'fd' is the recommended partition
type for Software RAID partitions. You set the partition type using the
<c>t</c> option in <c>fdisk</c>.  The Linux kernel uses the partition type
setting to auto-detect filesystems and swap devices on the disk at boot-time.
</p>
</body>
</section>
<section>
<title>Using fdisk to set up partitions</title>
<body>

<p>Now that you have had your introduction to the way disk partitioning is
done under Linux, it is time to walk you through the process of setting up disk
partitions for your Gentoo Linux installation. After we walk you through the
process of creating partitions on your disk, your partition configuration will
look like this: </p>

<pre caption="The partition configuration that you will have after following these steps">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>In our suggested "newbie" partition configuration, we have three partitions.
The first one (<c>/dev/hda1</c>) at the beginning of the disk is a small
partition called a boot partition.  The boot partition's purpose is to hold all
the critical data related to booting -- GRUB boot loader information (if you
will be using GRUB) as well as your Linux kernel(s).  The boot partition gives
us a safe place to store everything related to booting Linux. During normal
day-to-day Gentoo Linux use, your boot partition should remain <e>unmounted</e>
for safety. If you are setting up a SCSI system, your boot partition will
likely end up being <c>/dev/sda1</c>.</p> 

<p>It is recommended to have boot partitions (containing everything necessary for
the boot loader to work) at the beginning of the disk.  While not necessarily
required anymore, it is a useful tradition from the days when the lilo boot
loader was not able to load kernels from filesystems that extended beyond disk
cylinder 1024. 
</p>

<p>The second partition (<c>/dev/hda2</c>) is used to for swap space. The
kernel uses swap space as virtual memory when RAM becomes low. This partition,
relatively speaking, is not very big either, typically somewhere around 512MB.
If you are setting up a SCSI system, this partition will likely end up
being called <c>/dev/sda2</c>.  </p>

<p>The third partition (<c>/dev/hda3</c>) is quite large and takes up the rest
of the disk. This partition is called our "root" partition and will be used to
store your main filesystem that houses Gentoo Linux itself. On a SCSI system,
this partition would likely end up being <c>/dev/sda3</c>.</p>


<p>Before we partition the disk, here is a quick technical overview of the
suggested partition and filesystem configuration to use when installing Gentoo
Linux:</p>

<table>
	<tr>
	<th>Partition</th>
	<th>Size</th>
	<th>Type</th>
	<th>example device</th>
	</tr>
	<tr>
	<ti>boot partition, containing kernel(s) and boot information</ti>
	<ti>32 Megabytes</ti>
	<ti>ext2/3 highly recommended.</ti>
	<ti>/dev/hda1</ti>
	</tr>
	<tr>
	<ti>swap partition (no longer a 128 Megabyte limit, now 2GB)</ti>
	<ti>Generally, configure a swap area that is between one to two times the size of the physical RAM
	in your system.</ti>
	<ti>Linux swap</ti>
	<ti>/dev/hda2</ti>
	</tr>
	<tr>
	<ti>root partition, containing main filesystem (/usr, /home, etc)</ti>
	<ti>&gt;=1.5 Gigabytes</ti>
	<ti>ext3 recommended; ext2 ok</ti>
	<ti>/dev/hda3</ti>
	</tr>
</table>

<p>OK, now to create the partitions as in the example and table above. First,
enter fdisk by typing <c>fdisk /dev/hda</c> or <c>fdisk /dev/sda</c>,
depending on whether you are using IDE or SCSI. Then, type <c>p</c> to view your
current partition configuration.  Is there anything on the disk that you need
to keep? If so, <b>stop now</b>.  If you continue with these directions, <b>all
existing data on your disk will be erased.</b></p>

<impo>Following these instructions below will cause all prior data on your disk
to <b>be erased</b>! If there is anything on your drive, please be sure that it
is non-critical information that you do not mind losing. Also make sure that you
<b>have selected the correct drive</b> so that you do not mistakenly wipe data
from the wrong drive.</impo>

<p>Now, it is time to delete any existing partitions. To do this, type <c>d</c>
and hit Enter. You will then be prompted for the partition number you would like
to delete. To delete a pre-existing <c>/dev/hda1</c>, you would type:</p>

<pre caption="Deleting a partition">
Command (m for help): d
Partition number (1-4): 1
</pre>

<p>The partition has been scheduled for deletion. It will no longer show up if
you type <c>p</c>, but it will not be erased until your changes have been
saved.  If you made a mistake and want to abort without saving your changes,
type <c>q</c> immediately and hit enter and your partition will not be
deleted.</p>
<!-- NOTE: THis is not sufficient documentation to cover ATA Raid and I just
find it confusing, so Im commenting it out (drobbins)
<note>If you are using RAID your partitions will be a little different.  You
will have the partitions like this: <path>/dev/ataraid/discX/partY</path> X are
the arrays you have made, so if you only have made 1 array, then it will be
disc0.Y is the partition number as in <path>/dev/hdaY</path> </note>
-->
<p>Now, assuming that you do indeed want to wipe out all the partitions on your
system, repeatedly type <c>p</c> to print out a partition listing and then type
<c>d</c> and the number of the partition to delete it. Eventually, you will end up
with a partition table with nothing in it:</p>

<pre caption="An empty partition table">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>Now that the in-memory partition table is empty, we are ready to create a
boot partition. To do this, type <c>n</c> to create a new partition, then
<c>p</c> to tell fdisk you want a primary partition. Then type <c>1</c> to
create the first primary partition. When prompted for the first cylinder, hit
enter. When prompted for the last cylinder, type <c>+32M</c> to create a
partition 32MB in size. You can see output from these steps below:</p>

<note>
Journaled filesystems require extra space for their journal. Default settings 
require about 33 Megabytes of space. Therefore, if you are using a journaled 
filesystem for <path>/boot</path>, you should type <c>+64M</c> when prompted
for the last cylinder.
</note>

<pre caption="Steps to create our boot partition">
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +32M
</pre>

<p>Now, when you type <c>p</c>, you should see the following partition printout:</p>

<pre caption="Our first partition has been created">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
</pre>

<p>Next, let us create the swap partition. To do this, type <c>n</c> to create a
new partition, then <c>p</c> to tell fdisk that you want a primary partition. Then
type <c>2</c> to create the second primary partition, <c>/dev/hda2</c> in our case.
When prompted for the first cylinder, hit enter. When prompted for the last cylinder,
type <c>+512M</c> to create a partition 512MB in size. After you have done this, type
<c>t</c> to set the partition type, <c>2</c> to select the partition you just
created, and then type in <c>82</c> to set the partition
type to "Linux Swap". After completing these steps, typing <c>p</c> should display
a partition table that looks similar to this:</p>

<pre caption="Our swap partition has been created">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
</pre>

<p>Finally, let us create the root partition. To do this, type <c>n</c> to
create a new partition, then <c>p</c> to tell fdisk that you want a primary
partition. Then type <c>3</c> to create the third primary partition,
<c>/dev/hda3</c> in our case.  When prompted for the first cylinder, hit enter.
When prompted for the last cylinder, hit enter to create a partition that takes
up the rest of the remaining space on your disk.  After completing these steps,
typing <c>p</c> should display a partition table that looks similar to
this:</p>

<pre caption="Our root partition has been created">
Command (m for help): p

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux
</pre>

<p>
Finally, we need to set the "bootable" flag on our boot partition and then write
our changes to disk. To tag <c>/dev/hda1</c> as a "bootable" partition, type
<c>a</c> at the menu and then type in <c>1</c> for the partition number. If you
type <c>p</c> now, you will now see that <c>/dev/hda1</c> has a <c>*</c> in the "Boot"
column. Now, let us write our changes to disk. To do this, type <c>w</c> and hit
enter. Your disk partitions are now properly configured for a Gentoo Linux
install. 
</p>

<note>If <c>fdisk</c> or <c>cfdisk</c> instruct you to do so, please reboot to
allow your system to detect the new partition configuration.</note>
</body>
</section>
<section>
<title>Creating filesystems</title>
<body>
<p>Now that the partitions have been created, it is time to set up filesystems on
the boot and root partitions so that they can be mounted and used to store data. 
We will also configure the swap partition to serve as swap storage.
</p>

<p>Gentoo Linux supports a variety of different types of filesystems; each type has
its strengths and weaknesses and its own set of performance characteristics. Currently,
we support the creation of ext2 and ext3 filesystems.</p>

<warn>ReiserFS and JFS are not supported in SELinux.</warn>

<p><b>Ext2</b> is the tried and true Linux filesystem but does not have
journaling, which means that routine ext2 filesystem checks at startup time can
be quite time-consuming. There is now quite a selection of newer-generation
<c>journaled</c> filesystems that can be checked for consistency very quickly
and are thus generally preferred over their non-journaled counterparts.
Journaled filesystems prevent long delays when you boot your system and your
filesystem happens to be in an <c>inconsistent</c> state.</p>

<p><b>Ext3</b> is the journaled version of the ext2 filesystem, providing metadata
journaling for fast recovery in addition to other enhanced journaling modes
like full data and ordered data journaling. ext3 is a very good and reliable
filesystem. It offers generally decent performance under most conditions.
Because it does not extensively employ the use of "trees" in its internal
design, it does not scale very well, meaning that it is not an ideal choice for
very large filesystems, or situations where you will be handling very large
files or large quantities of files in a single directory. But when used within
its design parameters, ext3 is an excellent filesystem.</p>
<!-- removing till these get xattrs
<p><b>ReiserFS</b> is a B*-tree based filesystem that has very good overall
performance and greatly outperforms both ext2 and ext3 when dealing with small
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales
extremely well and has metadata journaling.  As of kernel 2.4.18+, ReiserFS is
now rock-solid and highly recommended for use both as a general-purpose
filesystem and for extreme cases such as the creation of large filesystems, the
use of many small files, very large files, and directories containing tens of
thousands of files. ReiserFS is the filesystem we recommend by default for all
non-boot partitions.</p>

<p><b>JFS</b> is IBM's own high performance journaling filesystem.  It has recently
become production-ready, and there has not been a sufficient track record to
comment either positively nor negatively on its general stability at this
point.</p> -->

<p><b>XFS</b> is a filesystem with metadata journaling from SGI. It comes with a robust feature-set
and is optimized for scalability. We only recommend using this filesystem on
Linux systems with high-end SCSI and/or fibre channel storage and a
uninterruptible power supply. Because XFS aggressively caches in-transit data
in RAM, improperly designed programs (those that do not take proper precautions
when writing files to disk) can lose data if the system goes down unexpectedly.</p>

<!--
<p>If you are looking for the most rugged journaling filesystem, use ext3.  If
you are looking for a good general-purpose high-performance filesystem with
journaling support, use ReiserFS;  both ext3 and ReiserFS are mature,
refined and recommended for general use.</p>
-->
<p>It is suggested that ext3 is used.</p>
<!-- Corner case, confusing
		<p>But before creating filesystems, you may want to initialize the
			beginning of your partition using <c>dd</c> if you are using a pre-existing partition that has been used before. 
			This is particularly helpful when you're going to create a new XFS filesystem on a partition that previously contained
			a ReiserFS filesystem. Doing this will ensure that your new filesystem
			will not be mis-identified by Linux's filesystem auto-detection code.
			This can be done as follows:	
			</p>
<pre caption="Initializing first 1024 bytes of your partition">
# <c>dd if=/dev/zero of=/dev/hda3 bs=1k count=1</c>
<comment>(Replace /dev/hda3 with the partition you wish to &quot;clean.&quot;)</comment>
</pre>
	<warn>The command above will destroy all data from <path>/dev/hda3</path>. 
	Be careful and check twice which partition you specify for zeroing.
	If you make a mistake it might result in a loss of data.
	</warn>
-->

<p>Based on our example above, we will use the following commands to initialize
all our partitions for use:</p>

<pre caption="Initializing our partitions (example)">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>We choose ext3 for our <c>/dev/hda1</c> boot partition because it is a
robust journaling filesystem supported by all major boot loaders. We used
<c>mkswap</c> for our <c>/dev/hda2 </c> swap partition -- the choice is obvious
here. And for our main root filesystem on <c>/dev/hda3</c> we choose ext3,
since it is a solid journaling filesystem. Now,
go ahead and initialize your partitions.</p>

<p>For your reference, here are the various <c>mkfs</c>-like commands available
during the installation process:</p>

	<p><c>mkswap</c> is the command that is used to initialize swap partitions:</p>
<pre caption="Initializing Swap">
# <i>mkswap /dev/hda2</i>
</pre>
<p>You can use the <c>mke2fs</c> command to create ext2 filesystems:</p>
<pre caption="Creating an ext2 Filesystem">
# <i>mke2fs /dev/hda1</i>
</pre>
<p>If you would like to use ext3, you can create ext3 filesystems using
	<c>mke2fs -j</c>:</p>
<pre caption="Creating an ext3 Filesystem">
# <i>mke2fs -j /dev/hda3</i>
</pre>
        <note>You can find out more about using ext3 under Linux 2.4 at
	<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.</note>
<pre caption="Creating an XFS Filesystem">
# <i>mkfs.xfs -i size=512 /dev/hda3</i>
</pre>
	<impo>A larger inode size is needed for XFS filesystems, because the SELinux
		security label does not fit in the default size inode (256).
		If a larger inode size is not used, it leads to lower
		performance and a large amount of wasted space.  The inode size
		is set by using the <c>-i size=512</c> option to mkfs.xfs.</impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Mount Partitions</title>
    <section>
      <body>
        <p>Now, we will activate our newly-initialized swap volume, since we may need the additional virtual memory that it
			provides later:
			</p>
<pre caption="Activating Swap">
# <i>swapon /dev/hda2</i>
</pre>

        <p>Next, we will create the <path>/mnt/gentoo</path> and <path>/mnt/gentoo/boot</path> mount points,
			and we will mount our filesystems to these mount points. Once our boot and root filesystems are
		mounted, any files we copy or create inside <path>/mnt/gentoo</path> will be placed on our new filesystems.
			Note that if you are setting up Gentoo
   			Linux with separate <path>/usr</path> or <path>/var</path> filesystems, these would get mounted to
   			<path>/mnt/gentoo/usr</path> and <path>/mnt/gentoo/var</path> respectively.
			</p>
<!-- Reiser isn't supported. 
			 <impo>If your <e>boot</e> partition (the one holding the kernel) is ReiserFS, be sure to mount it
			with the <c>-o notail</c> option so GRUB gets properly installed. Make sure
			that <c>notail</c> ends up in your new <path>/etc/fstab</path> boot partition entry, too.
			We will get to that in a bit. If you are going to use LILO with ReiserFS, then the <c>-o notail</c>
			is not needed. It is always safe to specify the <c>-o notail</c> option with ReiserFS if you are
			not sure what to do.
			</impo>
-->

<pre caption="Creating Mount Points">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

                      <impo>If you are having problems mounting your boot partition with ext2, try using
		   	<c>mount /dev/hXX /mnt/gentoo/boot -t ext2 </c> </impo>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Stage tarballs and chroot</title>
    <section>
		<title>Selecting the desired stage tarball</title>
      <body>

<p>
Now, you need to decide which one you would like to use as a
basis for the install if you have not already.</p>

<p>Since we are compiling everything &quot;from-scratch&quot;, as is currently required by the Gentoo SELinux install, we will want to use the <path>stage1-x86-1.4_rc4.tar.bz2</path> image.
 The stage on the CD is
accessible at <path>/mnt/cdrom/gentoo</path>, and you can type <c>ls /mnt/cdrom/gentoo</c>
to see what is available on your CD.</p>

<p>If you would like to perform an install using a stage tarball that is
<c>not</c> on your CD , this is still possible, but you will need to download the
stage you want using the following instructions. If you already have the stage
tarball you want to use (most users), then proceed to the "Extracting the stage
tarball" section.  (This is most useful if you plan on using an experimental stage tarball.  Please note that these may, and likely do, contain bugs.)</p>

<pre caption="Downloading Required Stage">
# <i>cd /mnt/gentoo</i>
<comment>Use lynx to get the URL for your tarball:</comment>
# <i>lynx http://gentoo.oregonstate.edu/experimental/x86/stages/</i>
<comment>Use <i>Up</i> and <i>Down</i> arrows keys (or the <i>TAB</i> key) to go to the right directory
Highlight the appropriate stage you want to download
Press <i>d</i> which will initiate the download
Save the file and quit the browser

OR use wget from the command line:</comment>
# <i>wget <comment>insert URL to the required stage tarball here.</comment></i>
</pre>
      </body>
    </section>
    <section>
		<title>Extracting the stage tarball</title>
      <body>

<p>Now it is time to extract the compressed stage tarball of your choice to
<path>/mnt/gentoo/</path>.
Unpack the stage tarball as follows:</p>

<impo>Be sure to use the <c>p</c> option with <c>tar</c>.  Forgetting to do this will
cause certain files to have incorrect permissions.</impo>

<pre caption="Unpacking the Stages">
# <i>cd /mnt/gentoo</i>
<comment>If you downloaded your stage tarball, change the path below to begin with "/mnt/gentoo/"
instead of "/mnt/cdrom/gentoo/".</comment>
# <i>tar -xvjpf /mnt/cdrom/gentoo/stage1-*.tar.bz2</i>
</pre>

<p>If you downloaded your stage tarball to <path>/mnt/gentoo</path>, you can now delete it by typing
<c>rm /mnt/gentoo/stage*.tar.bz2</c>.</p>
</body>
</section>
<section>
<title>Entering the chroot</title>
<body>
<p>
Next, we will <c>chroot</c> over to the new Gentoo Linux build installation to &quot;enter&quot; the new
Gentoo Linux system.
</p>

<note>
You may receive a notice during <c>env-update</c> telling you that 
<path>/etc/make.profile/make.defaults</path> is not available: ignore it. We are 
going to issue <c>emerge sync</c> later on in this document which will resolve 
the problem.
</note>

<pre caption="Prepping and entering the chroot environment">
# <i>mount -t proc proc /mnt/gentoo/proc</i>
# <i>mount -t selinuxfs none /mnt/gentoo/selinux</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
Regenerating /etc/ld.so.cache...
# <i>source /etc/profile</i>
<comment>(The above points your shell to the new paths and updated binaries.)</comment>
</pre>
        <p>After you execute these commands, you will be &quot;inside&quot; your new Gentoo Linux environment in <path>/mnt/gentoo</path>.
		We can perform the rest of the installation process inside the chroot.
		</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Getting the Current Portage Tree using sync</title>
    <section>
      <body>

<!-- This is not yet implemented. Uncomment when it is!

<p>In order to maximize the downloadspeed, you should now select rsync- and distfiles mirrors. To simplify this task, we have a tool called <c>mirrorselect</c>. Issue the following two commands:</p>

<pre caption="Selecting a mirror">
<comment>First we have mirrorselect select 5 close mirrors for us.</comment>
# <i>mirrorselect -a -s5</i>
<comment>Now we select an rsync-mirror ourselves:</comment>
# <i>mirrorselect -i -r</i>
</pre>

-->

<p>Now, you will need to run <c>emerge sync</c>. This command tells Portage to download
the most recent copy of the Gentoo Linux Portage tree.
The Portage tree
contains all the scripts (called ebuilds) used to build every package
under Gentoo Linux. Currently, we have ebuild scripts for close to 4000 packages. Once <c>emerge sync</c>
completes, you will have a complete Portage tree in <path>/usr/portage</path>.</p>

<pre caption="Updating Using sync">
# <i>emerge sync</i>
</pre>
 
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Setting Gentoo optimizations (make.conf)</title>
    <section>
      <body>
<p>Now that you have a working copy of the Portage tree, it is time to
customize the optimization and optional build-time settings to use on your
Gentoo Linux system. Portage will use these settings when compiling any
programs for you. To do this, edit the file <path>/etc/make.conf</path>.  In
this file, you should set your <c>USE</c> flags, which specify optional
functionality that you would like to be built into packages if available;
generally, the defaults (an <e>empty</e> or unset <c>USE</c> variable) are
fine.  More information on <c>USE</c> flags can be found <uri
link="http://www.gentoo.org/doc/en/use-howto.xml">here</uri>.  A complete list
of current USE flags can be found <uri
link="http://www.gentoo.org/dyn/use-index.xml">here</uri>.  </p>

<note>It is not necessary to add selinux to your USE flags in make.conf
the SELinux profile already does this for you.
</note>

<impo>If you are using selinux-pie-ssp (SELinux with Hardened GCC)
stages, <c>hardened</c>, <c>pic</c>, and <c>pie</c> must be added to USE in
make.conf.</impo>

<p>You also should set appropriate <c>CHOST</c>, <c>CFLAGS</c> and 
<c>CXXFLAGS</c> settings for the kind of system that you are creating 
(commented examples can be found further down in the file.)  These settings
will be used to tell the C and C++ compiler how to optimize the code that
is generated on your system. It is common for users with Athlon XP processors
to specify a "-march=athlon-xp" setting in their CFLAGS and CXXFLAGS settings
so that all packages built will be optimized for the instruction set and
performance characteristics of their CPU, for example. The <path>/etc/make.conf</path>
file contains a general guide for the proper settings of CFLAGS and CXXFLAGS.</p>
			
<p>If necessary, you can also set proxy information here if you are behind a 
firewall. Use the following command to edit <path>/etc/make.conf</path> using <c>nano</c>,
a simple visual editor.
</p>
<pre caption="Setting make.conf Options">
# <i>nano -w /etc/make.conf</i>
</pre>
        <note>
			People who need to substantially customize the build process should take a look at
			the <path>/etc/make.globals</path> file.  This file comprises gentoo defaults and
			should never be touched. If the defaults do not suffice, then new values should
			be put in <path>/etc/make.conf</path>, as entries in <path>make.conf</path>
			<e>override</e> the entries in <path>make.globals</path>.  If you are
			interested in customizing USE settings, look in <path>/etc/make.profile/make.defaults</path>.
			If you want to turn off any USE settings found here, add an appropriate <c>USE=&quot;-foo&quot;</c>
			in <path>/etc/make.conf</path> to turn off any <c>foo</c> USE setting enabled by default
			in <path>/etc/make.globals</path> or <path>/etc/make.profile/make.defaults</path>.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Bootstrapping</title>
    <section>
      <body>
        <p>Now, it is time to start the &quot;bootstrap&quot; process.  This process can take serveral hours on a
			1200MHz AMD Athlon system.
During this time, the GNU C library, compiler suite, and other key system programs will be built. Start the bootstrap
as follows:</p>
<pre caption="Starting the bootstrap">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap-cascade.sh</i>
</pre>
        <p>The &quot;bootstrap&quot; process will now begin.</p>
	<note><c>bootstrap-cascade.sh</c> now supports the <c>--fetchonly</c> option. Dial-up users will find this especially handy. It will download all bootstrap related files in one go for later compilation. <c>bootstrap-cascade.sh -h</c> for more information.</note>
        <note>
			Portage by default uses <c>/var/tmp</c> during package building, often
			using several hundred megabytes of temporary storage. If you would like to
			change where Portage stores these temporary files, set a new PORTAGE_TMPDIR <e>before</e>
			starting the bootstrap process, as follows:
			</note>
<pre caption="Changing Portage's Storage Path">
# <i>export PORTAGE_TMPDIR=&quot;/otherdir/tmp&quot;</i>
</pre>
        <p><c>bootstrap-cascade.sh</c> will build <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,
			and <c>glibc</c>, rebuilding <c>gettext</c>
			after <c>glibc</c>. Needless to say, this process takes a while.
			Once this process completes, your system will be ready to <c>emerge system</c>
	  </p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Emerging the Rest of the System</title>
    <section>
      <body>
	<p>
	  We can now move on to emerge the rest of the system.
	</p>
<pre caption="Emerging system">
# <i>emerge -p system</i>
<comment>(lists the packages to be installed)</comment>
# <i>emerge system</i>
</pre>
        <p>It is going to take a while
	  to finish building the entire base system.  Your reward is that it will be
	  thoroughly optimized for your system, with the SELinux packages installed. 
	  way to keep yourself occupied for some time to come.  The author suggests talking, or listening, in <path>#gentoo-hardened</path> on the <path>irc.freenode.net</path> network.  That way, you can wait for your system to compile <e>and</e> learn a thing or two. ;-)
	</p>
	<p>
	  Once the <c>emerge system</c> completes, we are ready to set our timezone.
	</p>
      </body>
    </section>
  </chapter>
    <chapter>
    <title>Setting your time zone</title>
    <section>
      <body>
        <p>Now you need to set your time zone.</p>
        <p>Look for your time zone (or GMT if you are using Greenwich Mean Time)
	   in <path>/usr/share/zoneinfo</path>. Then, make a symbolic link to
	   /etc/localtime by typing:</p>
<pre caption="Creating a symbolic link for time zone">
# <i>ln -sf /usr/share/zoneinfo/path/to/timezonefile /etc/localtime</i>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
<title>Installing the kernel and system logger</title>
<section>
<title>Kernel selections</title>
<body>
<p>
Choose one of the following lines according to which kernel you would like to
use.  Any 2.6 kernel is usable. Selinux-sources or hardened-sources are the
only 2.4 kernels with SELinux support. The suggested kernel is hardened-dev-sources.
</p>

<pre caption="Merging Kernel Sources">
<comment>Any 2.6 kernel</comment>
# <i>emerge hardened-dev-sources</i>

<comment>Or 2.4 kernels:</comment>
# <i>emerge selinux-sources</i>
<comment>Or</comment>
# <i>emerge hardened-sources</i>
</pre>
<p>
The <path>/usr/src/linux</path> symbolic link will point to your
newly-installed kernel source tree. Portage uses the 
<path>/usr/src/linux</path> symbolic link for a special purpose. Any ebuilds 
you install that contain kernel modules will be configured to work with the 
kernel source tree pointed to by <path>/usr/src/linux</path>. 
<path>/usr/src/linux</path> is created when you emerge your first kernel 
source package, but after it exists, Portage does not modify this symbolic 
link.
</p>

</body>
</section>
<!--
<section>
<title>Using genkernel to compile your kernel</title>
<body>

<p>
Now that your kernel source tree is installed, it's now time to compile your 
kernel. There are two ways to do this. The first way is to use our new 
<c>genkernel</c> script to automatically build a kernel for you. 
<c>genkernel</c> works by configuring a kernel nearly identically to the way 
our LiveCD kernel is configured. This means that when you use <c>genkernel</c> 
to build your kernel, your system will generally detect all your hardware at 
boot-time, just like our Live CD does. Because genkernel doesn't require any 
manual kernel configuration, it is an ideal solution for those users who may 
not be comfortable compiling their own kernels.
</p>

<p>
Now, let's see how to use genkernel. First, emerge the genkernel ebuild:
</p>

<pre caption="Emerging genkernel">
# <i>emerge -k genkernel</i>
</pre>

<p>
Now, compile your kernel sources by running <c>genkernel</c>:
</p>

<note>
<b>Advanced users:</b> you can type <c>genkernel config</c> instead,
which will cause genkernel to allow you to tweak the default kernel 
configuration before building begins.
</note>

<pre caption="Running genkernel">
<comment>If you're using genkernel 1.2 (included in the 1.4-20030803 x86/i686 GRP set), use the following:</comment>
# <i>genkernel gentoo-sources</i>
<comment>If you're using genkernel 1.4 or newer, there's no need to specify a kernel:</comment>
# <i>genkernel</i>
Gentoo Linux genkernel, version 1.4
Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
Distributed under the GNU General Public License version 2

Settings:
compile optimization: 1 processor(s)
source tree: /usr/src/linux-2.4.20-gaming-r3
config: gentoo (customized)
config loc: /etc/kernels/config-2.4.20-gaming-r3
initrd config: (default) /etc/kernels/settings

* Running "make oldconfig"...                                                                     [ ok ]
* Logging to /var/log/genkernel.log...                                                            [ ok ]
* Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
* Running "make dep"...                                                                           [ ok ]
* Running "make bzImage"...                                                                       [ ok ]
* Running "make modules"...                                                                       [ ok ]
* Running "make modules_install"...                                                               [ ok ]
* Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
* Building busybox...                                                                             [ ok ]
* Creating initrd...                                                                              [ ok ]

* Build completed successfully!

* Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
* when customizing your boot loader configuration files.
</pre>

<p>
Once <c>genkernel</c> completes, a kernel, full set of modules and 
<e>initial root disk</e> (initrd) will be created. We will use the kernel 
and initrd when configuring a boot loader later in this document. Write
down the names of the kernel and initrd as you will need it when writing
the bootloader configuration file. The initrd will be started immediately after 
booting to perform hardware autodetection (just like on the Live CD) before 
your "real" system starts up.
</p>

<p>
Now, let's perform one more step to get our system to be more like the Live 
CD  let's emerge <c>hotplug</c>. While the initrd autodetects hardware that 
is needed to boot your system, <c>hotplug</c> autodetects everything else.
To emerge and enable <c>hotplug</c>, type the following:
</p>

<pre caption="Emerging and enabling hotplug">
# <i>emerge -k hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

<p>
Now that you've run and configured your system to use <c>genkernel</c>, you 
can skip the "manual kernel configuration" section below.
</p>

</body>
</section>
-->
<section>
<title>Manual kernel configuration</title>
<body>

<p>
This section
will guide you through the process of configuring and compiling a kernel by
hand.	Please note that <path>/usr/src/linux</path> is a symlink to your
current emerged kernel source package and is set automatically by Portage at
emerge time.  If you have multiple kernel source packages, it is necessary to
set the <path>/usr/src/linux</path> symlink to the correct one before
proceeding.
</p>

<!-- GrSec + SELinux?  I think not!
<warn>
If you are configuring your own kernel, be careful with the <i>grsecurity</i> 
option. Being too aggressive with your security settings can cause certain 
programs (such as X) to not run properly. If in doubt, leave it out.
</warn>
-->

<note>
If you want to use the same configuration as the LiveCD kernel or base
your configuration on it, you should execute <c>cd /usr/src/linux &amp;&amp; zcat /proc/config.gz > .config &amp;&amp; make oldconfig</c>. 
If you are not using <c>gentoo-dev-sources</c>, this will ask some questions 
about differences between your kernelchoice and <c>gentoo-dev-sources</c>.
</note>

<pre caption="Configuring the Linux Kernel">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<!-- Not necessary.
<warn>
For your kernel to function properly, there are several options that you will
need to ensure are in the kernel proper - that is, they should <e>be enabled 
and not compiled as modules</e>. Be sure to enable &quot;ReiserFS&quot; if you 
have any ReiserFS partitions; the same goes for &quot;Ext3&quot;.  If you're 
using XFS, enable the &quot;SGI XFS filesystem support&quot; option.  It's 
always a good idea to leave ext2 enabled whether you are using it or not.
</warn>
-->

<p>
Below are some common options that you will need.
</p>

<pre caption="Location and required options under menuconfig">
<comment>Under "Code maturity level options"</comment>
[*] Prompt for development and/or incomplete code/drivers

<comment>Under "General setup"</comment>
[*] Auditing support
[*]   Enable system-call auditing support

<comment>Under "File systems"</comment>
&lt;*&gt; Second extended fs support <comment>(If using ext2)</comment>
[*]   Ext2 extended attributes
[ ]     Ext2 POSIX Access Control Lists
[*]     Ext2 Security Labels
&lt;*&gt; Ext3 journalling file system support <comment>(If using ext3)</comment>
[*]   Ext3 extended attributes
[ ]     Ext3 POSIX Access Control Lists
[*]     Ext3 security labels    
&lt;*&gt; XFS filesystem support <comment>(If using XFS)</comment>
[ ]   Realtime support (EXPERIMENTAL)
[ ]   Quota support
[ ]   ACL support
[*]   Security Labels

[ ] /dev file system support (EXPERIMENTAL)
[*] /dev/pts file system for Unix98 PTYs
[*]   /dev/pts Extended Attributes
[*]     /dev/pts Security Labels    

<comment>Under "Security options"</comment>
[*] Enable different security models
[ ] Socket and Networking Security Hooks
&lt;*&gt; Capabilities Support
[*] NSA SELinux Support
[ ]   NSA SELinux boot parameter
[ ]   NSA SELinux runtime disable
[*]   NSA SELinux Development Support
[ ]   NSA SELinux MLS policy (EXPERIMENTAL)
</pre>
<p>
  The extended attribute security labels must be turned on for devpts and
  your filesystem(s).  Devfs is no longer usable in SELinux, and should be
  turned off.  Not all options exist on 2.4 kernels, and older 2.6 kernels,
  such as Auditing support, and runtime disable.
</p>
<p>
If you use PPPoE to connect to Internet, you will need the following
options in the kernel (built-in or as preferably as modules) : &quot;PPP 
(point-to-point protocol) support&quot;, &quot;PPP support for async serial 
ports&quot;, &quot;PPP support for sync tty ports&quot;. The two compression 
options won't harm but are not definitely needed, neither does the &quot;PPP 
over Ethernet&quot; option, that might only be used by <c>rp-pppoe</c> when 
configured to do kernel mode PPPoE.
</p>

<p>
If you have an IDE cd burner, then you need to enable SCSI emulation in the
kernel.  Turn on &quot;ATA/IDE/MFM/RLL support&quot; ---&gt; &quot;IDE, ATA 
and ATAPI Block devices&quot; ---&gt; &quot;SCSI emulation support&quot; 
(I usually make it a module), then under &quot;SCSI support&quot; enable 
&quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; and &quot;SCSI 
generic support&quot; (again, I usually compile them as modules).  If you
also choose to use modules, then <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot;
&gt;&gt; /etc/modules.autoload.d/kernel-2.4</c> to have them automatically 
added at boot time. 
</p>

<p>
If you require it, don't forget to include support in the kernel for your 
ethernet card.
</p>

<!-- Not possible with SELinux.
<note>
For those who prefer it, it is possible to install Gentoo Linux with a 2.2 
kernel.	However, doing this comes at a price: you will lose many of the nifty 
features that are new to the 2.4 series kernels (such as XFS and tmpfs
filesystems, iptables and more), although the 2.2 kernel sources can be
patched with ReiserFS and devfs support.  
Gentoo linux boot scripts require either tmpfs or ramdisk support in the 
kernel, so 2.2 kernel users need to make sure that ramdisk support is compiled 
in (ie, not a module). It is <comment>vital</comment> that a 
<e>gentoo=notmpfs</e> flag be added to the kernel line in 
<path>/boot/grub/grub.conf</path> or to the append line in 
<path>/etc/lilo.conf</path> for the 2.2 kernel so that a ramdisk is mounted 
for the boot scripts instead of tmpfs.  If you choose not to use devfs, then
<e>gentoo=notmpfs,nodevfs</e> should be used instead.
</note>
-->

<pre caption = "Compiling and Installing the kernel">
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
</pre>

</body>
</section>
<section>
<title>Installing additional hardware-specific ebuilds</title>
<body>

<p>
Finally, you should emerge ebuilds for any additional hardware that is on 
your system. Here is a list of kernel-related ebuilds that you could emerge:
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="4in"/>
<tcolumn width="2in"/>
<tr>
  <th>Ebuild</th>
  <th>Purpose</th>
  <th>Command</th>
</tr>
<!-- xfree doesn't work in SELinux.  The following is pointless.
<tr>
  <ti>nvidia-kernel</ti>
  <ti>Accelerated NVIDIA graphics for XFree86</ti>
  <ti><c>emerge -k nvidia-kernel</c></ti>
</tr>
<tr>
  <ti>nforce-net</ti>
  <ti>On-board ethernet controller on NVIDIA NForce(2) motherboards</ti>
  <ti><c>emerge nforce-net</c></ti>
</tr>
<tr>
  <ti>nforce-audio</ti>
  <ti>On-board audio on NVIDIA NForce(2) motherboards</ti>
  <ti><c>emerge nforce-audio</c></ti>
</tr>
-->
<tr>
  <ti>e100</ti>
  <ti>Intel e100 Fast Ethernet Adapters</ti>
  <ti><c>emerge e100</c></ti>
</tr>
<tr>
  <ti>e1000</ti>
  <ti>Intel e1000 Gigabit Ethernet Adapters</ti>
  <ti><c>emerge e1000</c></ti>
</tr>
<tr>
  <ti>emu10k1</ti>
  <ti>Creative Sound Blaster Live!/Audigy support</ti>
  <ti><c>emerge emu10k1</c></ti>
</tr>
<!-- More graphics stuff unnecessary for SELinux
<tr>
  <ti>ati-drivers</ti>
  <ti>Accelerated ATI Radeon 8500+/FireGL graphics for XFree86</ti>
  <ti><c>emerge ati-drivers</c></ti>
</tr>
<tr>
  <ti>xfree-drm</ti>
  <ti>
    Accelerated graphics for ATI Radeon up to 9200, Rage128, Matrox, Voodoo and
    other cards for XFree86
  </ti>
  <ti><c>VIDEO_CARDS="yourcard" emerge xfree-drm</c></ti>
</tr>
-->
</table>

<!-- SELinux commenting
<p>
The <c>nvidia-kernel</c>, <c>ati-drivers</c> and <c>xfree-drm</c> packages 
will require additional configuration to be enabled. All other ebuilds listed 
above should be auto-detected at boot-time by the <c>hotplug</c> package. If 
you are not using hotplug, be sure to add the appropriate modules to
<path>/etc/modules.autoload.d/kernel-2.4</path>.
</p>

<p>
More information on <c>xfree-drm</c> can be found in our <uri
link="/doc/en/dri-howto.xml">Direct Rendering Guide</uri>.
</p>
-->


</body>
</section>
<section>
<title>Installing a system logger</title>
<body>

<p>
Your new custom kernel (and modules) are now installed.  Now you need to choose
a system logger that you would like to install.  We offer sysklogd, which is 
the traditional set of system logging daemons.  We also have msyslog and 
syslog-ng as well as metalog.  If in doubt, you may want to try
syslog-ng, since it is very flexible and feature-rich. To merge your logger of
choice, type <e>one</e> of the next four command sets:
</p>

<note>
	Only <path>metalog</path> and <path>syslog-ng</path> have been fully tested and proven to work with the current SELinux policies, though you are welcome to try other loggers.
</note>

<pre caption="Emerging System Logger of Choice">
# <i>emerge -k app-admin/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>or</comment>
# <i>emerge -k app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>or</comment>
# <i>emerge -k app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>or</comment>
# <i>emerge -k app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>

<impo>
If you chose <c>metalog</c>, please read <uri
link="faq.xml#doc_chap6_sect3">Chapter 6, Section 3 of the Gentoo Linux
FAQ</uri> on metalog buffering.
</impo>

<p>
Now, you may optionally choose a cron package that you would like to use.
Right now, we offer dcron, fcron and vixie-cron. However, only vixie-cron works under SELinux at the moment.
</p>

<pre caption="Choosing a CRON Daemon">
# <i>emerge -k sys-apps/vixie-cron</i>
# <i>rc-update add vixie-cron default</i> <!--
<comment>You do not need to run <i>crontab /etc/crontab</i> if using vixi-cron.</comment> -->
</pre>

<p>
For more information on starting programs and daemons at startup, see the
<uri link="/doc/en/rc-scripts.xml">Gentoo Linux Init System</uri> Guide.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Modifying /etc/fstab for your machine</title>
<section>
<body>

<impo>
To edit files, remember to use <c>nano -w "filename"</c>.
</impo>

<p>
Your Gentoo Linux system is almost ready for use.  All we need to do now is
configure a few important system files and install the boot loader.
The first file we need to configure is <path>/etc/fstab</path>. Remember to specify
<c>ext2</c>, <c>ext3</c> or <c>xfs</c> filesystem types as appropriate.
</p>

<warn>
Use something like the <path>/etc/fstab</path> listed below, but of course be
sure to replace "BOOT", "ROOT" and "SWAP" with the actual block devices (such
as <c>hda1</c>, etc.) and "ext2" and "ext3" with the actual filesystems you
are using:
</warn>

<pre caption="Editing fstab">
<comment># /etc/fstab: static file system information.
#
# noatime turns off atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It is safe to drop the noatime options if you want and to
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

</comment>
/dev/BOOT           /boot       ext3        noauto,noatime  1 2
/dev/ROOT           /           ext3	    noatime         0 1
/dev/SWAP           none        swap        sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660     noauto,ro,user  0 0
none                /proc       proc        defaults        0 0

none                /selinux    selinuxfs   defaults        0 0
none                /dev/pts    devpts      defaults        0 0
</pre>

<impo>
SELinux requires /selinux to be mounted when the policy is loaded. If your
policy does not load correctly be sure that /selinux is in fstab.
</impo>

<impo>
SELinux also requires /dev/pts to be loaded to log in correctly, ensure that it
is also added to fstab.
</impo>

<warn>
Please notice that <path>/boot</path> is <e>not</e> mounted at boot time. This
is to protect the data in <path>/boot</path> from corruption. If you need to
access <path>/boot</path>, please mount it!
</warn>

</body>
</section>
</chapter>

  <chapter>
    <title>Setting the Root Password</title>
    <section>
      <body>
        <p>Before you forget, set the root password by typing: </p>
<pre caption="Setting the root Password">
# <i>passwd</i>
</pre>

	<p>In this day and age, a non-root user is essential for running your SELinux box.  It is rather likely that you will want to add several non-root users so that you can test your policies out afterwards.  I can not stress the importance of a non-root user, especially if you plan on doing net-related tasks such as <c>irssi</c>, a command line interface IRC client.  For instructions on how to add the said user(s), please consult the. <uri link="http://www.gentoo.org/doc/en/faq.xml">Gentoo FAQ</uri>.
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Setting your Hostname</title>
    <section>
      <body>
        <p>
        Edit <path>/etc/hostname</path> so that it contains your hostname 
        on a single line, i.e. <c>mymachine</c>. 
        </p>
<pre caption="Configuring Hostname">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>
        <p>
        Then edit <path>/etc/dnsdomainname</path> so that it contains your DNS 
        domainname, i.e. <c>mydomain.com</c>.
        </p>
<pre caption="Configuring Domainname">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>
        <p>
        If you have a NIS domain, you should set it in 
        <path>/etc/nisdomainname</path>.
        </p>
<pre caption="Configuring NIS Domainname">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Modifying /etc/hosts</title>
    <section>
      <body>
        <p>This file contains a list of IP addresses and their associated hostnames.
			It is used by the system to resolve the IP addresses
			of any hostnames that may not be in your nameservers.  Here is a template for this file:
			</p>
<pre caption="Hosts Template">
127.0.0.1      localhost
<comment># the next line contains your IP for your local LAN, and your associated machine name</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>
        <note>If you are on a DHCP network, it might be helpful to set <c>localhost</c> to your machine's
			actual hostname. This will help GNOME and many other programs in name resolution.
			</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Final Network Configuration</title>
    <section>
      <body>
        <p>Add the names of any modules that are necessary for the proper functioning of your system to 
			<path>/etc/modules.autoload</path> file (you can also add any options you
			need to the same line.) When Gentoo Linux boots, these modules will be automatically
			loaded.  Of particular importance is your ethernet card module, if you happened to compile
			it as a module:
			</p>
<pre caption="/etc/modules.autoload"><comment>This is assuming that you are using a 3com card. 
Check /lib/modules/`uname -r`/kernel/drivers/net for your card. </comment>
3c59x
</pre>
        <p>Edit the <path>/etc/conf.d/net</path> script to get your network configured for your
			first boot: </p>
<pre caption="Boot time Network Configuration">
# <i>nano -w /etc/conf.d/net</i>
# <i>rc-update add net.eth0 default</i>
</pre>
        <p>If you have multiple network cards or tokenring interfaces, you need to create additional <path>net.eth<c>x</c></path> or <path>net.tr<c>x</c></path> 
			scripts respectively for each one (<c>x</c> = 1, 2, ...): </p>
<pre caption="Multiple Network Interfaces">
# <i>cd /etc/init.d</i>
# <i>cp net.eth0 net.eth<comment>x</comment></i>
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>
        <p>If you have a PCMCIA card installed, have a quick look into 
			<path>/etc/init.d/pcmcia</path> to verify that things seem all right for your setup,
			then add this line to the top of <path>/etc/init.d/net.ethx</path>:
			</p>
<pre caption="PCMCIA depend in /etc/init.d/net.ethx">
depend() {
	need pcmcia
}
</pre>
        <p>This makes sure that the PCMCIA drivers are autoloaded whenever your network is loaded.
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Final steps: Configure Basic Settings (including the international keymap setting)</title>
    <section>
      <body>
<pre caption="Basic Configuration">
# <i>nano -w /etc/rc.conf</i>
</pre>
        <p>Follow the directions in the file to configure the basic settings.  
			All users will want to make sure that <c>CLOCK</c> is set to his/her
			liking.  International keyboard users will want to set the <c>KEYMAP</c>
			variable (browse <path>/usr/share/keymaps</path> to see the various
			possibilities).
			</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Configure a Bootloader</title>
	<section>
	<title>Notes</title>
	<body>
	<p> In the spirit of Gentoo, users now have more than one bootloader to choose from.
	Using our virtual package system, users are now able to choose between both GRUB and
	LILO as their bootloaders.
	</p>
	<p> Please keep in mind that having both bootloaders installed is not necessary.
	In fact, it can be a hindrance, so please only choose one.
	</p>
    <p>
    People who have selected framebuffer in their kernel should add <c>vga=xxx</c> to their bootloader configuration file as a kernel parameter. <c>xxx</c> is one of the values in the following table:
    </p>
<table>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>
	</body>
	</section>
    <section>
	<title>Configuring GRUB</title>
      <body>
        <p>The most critical part of understanding GRUB is getting comfortable with how GRUB
			refers to hard drives and partitions. Your Linux partition <path>/dev/hda1</path> is called
			<path>(hd0,0)</path> under GRUB.  Notice the parenthesis around the hd0,0 - they are required.  
			Hard drives count from zero rather than &quot;a&quot;, and partitions start at zero rather than one.
			Be aware too that with the hd devices, only harddrives are counted, not atapi-ide devices such as
			cdrom players, burners, and that the same construct can be used with scsi drives.
			(Normally they get higher numbers than ide drives except when the bios is configured
			to boot from scsi devices.) Assuming you have a harddrive on /dev/hda, a cdrom player on /dev/hdb,
			a burner on /dev/hdc, a second hard drive on /dev/hdd and no scsi harddrive,
			<path>/dev/hdd7</path> gets translated to <path>(hd1,6)</path>.

			It might sound tricky, and tricky it is indeed, but as we will see, grub
			offers a tab completion mechanism that comes handy for those of you having
			a lot of harddrives and partitions and who are a little lost in the
			grub numbering scheme. Having gotten the feel for that,
			it is time to install GRUB.
			</p>
        <p>The easiest way to install GRUB is to simply type <c>grub</c> at your chrooted shell prompt: </p>
<pre caption="Installing GRUB">
# <i>emerge grub</i>
# <i>grub</i>
</pre>
        <impo>If you are using hardware RAID this part will not work at
			this time.
			Skip to the section on making your <path>grub.conf</path>. After that we will complete the
			grub setup for RAID controllers
			</impo>
        <p>You will be presented with the <c>grub&gt;</c> grub
			command-line prompt.  Now, you need to type in the
			right commands to install the GRUB boot record onto your hard drive.  In my example configuration,
			I want to install the GRUB boot record on my hard drive MBR (master boot record), so that 
			the first thing I see when I turn on the computer is the GRUB prompt.  In my case, the commands
			I want to type are:
			</p>

<pre caption="GRUB on the MBR">
grub&gt; <i>root (hd0,0)</i> <codenote>Your boot partition</codenote>
grub&gt; <i>setup (hd0)</i> <codenote>Where the boot record is installed, here, it is the MBR</codenote>
</pre>
	
<pre caption="GRUB not on the MBR">
<comment>Alternatively, if you wanted to install the bootloader somewhere other than the MBR</comment>
grub&gt; <i>root (hd0,0)</i> <codenote>Your boot partition</codenote>
grub&gt; <i>setup (hd0,4)</i> <codenote>Where the boot record is installed, here it is /dev/hda5</codenote>
grub&gt; <i>quit</i>
</pre>
        
	<p>Here is how the two commands work.  The first <c>root ( )</c> command tells GRUB
			the location of your boot partition (in our example, <path>/dev/hda1</path> or 
			<path>(hd0,0)</path> in GRUB terminology.  Then, the second <c>setup ( )
			</c> command tells GRUB where to install the
			boot record - it will be configured to look for its special files at the <c>root
			( )</c> location that you specified.  In my case, I want the boot record on the
			MBR of the hard drive, so I simply specify <path>/dev/hda</path> (also known as <path>(hd0)</path>). 
			If I were using another boot loader and wanted to set up GRUB as a secondary boot-loader, I
			could install GRUB to the boot record of a particular partition.  In that case,
			I would specify a particular partition rather than the entire disk.  Once the GRUB
			boot record has been successfully installed, you can type <c>quit</c> to quit GRUB.  
			</p>

			<note> The tab completion mechanism of grub can be used from within grub, 
			assuming you wrote <c> root (</c> and that you hit the TAB key, you would
			be prompted with a list of the available devices (not only harddrives), 
			hitting the TAB key having written <c> root (hd</c>, grub would print the
			available harddrives and hitting the TAB key after writing <c> root (hd0,</c>
			would make grub print the list of partitions on the first harddrive.

			Checking the syntax of the grub location with completion should really help
			to make the right choice.
			</note>
			
			<p>
			Gentoo Linux is now
			installed, but we need to create the <path>/boot/grub/grub.conf</path> file so that
			we get a nice GRUB boot menu when the system reboots.  Here is how to do it.
			</p>
        <impo>To ensure backwards compatibility with GRUB, make sure to make a link from
			<c>grub.conf</c> to <c>menu.lst</c>. You can do this by doing
			<c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst </c>. </impo>
        <p>Now, create the grub.conf file (<c>nano -w /boot/grub/grub.conf</c>), and add the following to it:
			</p>
<pre caption="Grub.conf for GRUB">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 gentoo=nodevfs

<comment># Below is for setup using hardware RAID</comment>
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY gentoo=nodevfs

<comment># Below needed only for people who dual-boot</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>
        <note>
			(hd0,0) should be written without any spaces inside the parentheses.
			</note>
        <impo>
			If you set up scsi emulation for an IDE cd burner earlier, then to get it to
			actually work you need to add an &quot;hdx=ide-scsi&quot; fragment to the kernel
			line in grub.conf (where &quot;hdx&quot; should be the device for your cd burner).
			</impo>
        <p>After saving this file, Gentoo Linux installation is complete.  Selecting the first option will
			tell GRUB to boot Gentoo Linux without a fuss.  The second part of the grub.conf file is optional,
			and shows you how to use GRUB to boot a bootable Windows partition.
			</p>
        <note>Above, <path>(hd0,0)</path> should point to your &quot;boot&quot; partition
			(<path>/dev/hda1</path> in our example config) and <path>/dev/hda3</path> should point to
			your root filesystem.  <path>(hd0,5)</path> contains the NT boot
			loader.
			</note>
        <note>
			The path to the kernel image is relative to the boot partition. If for example you have separated boot partition <path>(hd0,0)</path> and root partition <path>(hd0,1)</path>, all paths in the grub.conf file above will become <path>/bzImage</path>.
			</note>
        <p>If you need to pass any additional options to the kernel, simply
			add them to the end of the <c>kernel</c> command.  We are already passing one option
			(<c>root=/dev/hda3</c>), but you can pass others as well.
			</p>
	<impo><c>gentoo=nodevfs</c> must be added to the kernel command, since SELinux cannot use devfs.</impo>
      </body>
    </section>
	<section>
    <title>Configuring LILO</title>
      <body>
        <p>While GRUB may be the new alternative for most people, it is not always the best choice.
	LILO, the LInuxLOader, is the tried and true workhorse of Linux bootloaders. Here is how to install
	LILO if you would like to use it instead of GRUB:
	</p>
        <p>The first step is to emerge LILO: 
	</p>
<pre caption="Emerging LILO">
# <i>emerge lilo</i>
</pre>
        <p>Now it is time to configure LILO. Here is a sample configuration file <path>/etc/lilo.conf</path>
	</p>
<pre caption="Example lilo.conf">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3
	append="gentoo=nodevfs"
	
#For dual booting windows/other OS
other=/dev/hda1
	label=dos
</pre>
	<ul>
        <li><c>boot=/dev/hda</c> tells LILO to install itself on the first hard disk on the first IDE controller. </li>
        <li><c>map=/boot/map</c> states the map file. In normal use, this should not be modified. </li>
        <li><c>install=/boot/boot.b</c> tells LILO to install the specified file as the new boot sector.
	In normal use, this should not be altered. If the install line is missing, LILO will
	assume a default of /boot/boot.b as the file to be used. </li>
        <li>The existence of <c>prompt</c> tells LILO to display the classic <c>lilo:</c> prompt at bootup.
	While it is not recommended that you remove the prompt line, if you do remove it, you can still
	get a prompt by holding down the [Shift] key while your machine starts to boot. </li>
        <li><c>timeout=50</c> sets the amount of time that LILO will wait for user input before proceeding 
	with booting the default line entry. This is measured in tenths of a second, with 50 as the default. </li>
        <li><c>lba32</c> describes the hard disk geometry to LILO. Another common entry here is linear. You should
	not change this line unless you are very aware of what you are doing. Otherwise, you could put
	your system in an unbootable state. </li>
        <li><c>default=linux</c> refers to the default operating system for LILO to boot from the
	options listed below this line. The name linux refers to the label line below in each of the boot options. </li>
        <li><c>image=/boot/bzImage</c> specifies the linux kernel to boot with this particular boot option. </li>
        <li><c>label=linux</c> names the operating system option in the LILO screen. In this case,
	it is also the name referred to by the default line. </li>
        <li><c>read-only</c> specifies that the root partition (see the root line below) is read-only and cannot be
	altered during the boot process. </li>
        <li><c>root=/dev/hda3</c> tells LILO what disk partition to use as the root partition. </li>
	</ul>
	<impo><c>append="gentoo=nodevfs"</c> must be used, since SELinux cannot use devfs.</impo>
        <p>After you have edited your <c>lilo.conf</c> file, it is time to run LILO to load the information
	into the MBR:
	</p>
<pre caption="Running LILO">
# <i>/sbin/lilo</i>
</pre>
        <p>LILO is configured, and now your machine is ready to boot into Gentoo Linux!
	</p>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Creating Bootdisks</title>
    <section>
      <title>GRUB Bootdisks</title>
      <body>
        <p>It is always a good idea to make a boot disk the first
	time you install any Linux distribution. This is a security
	blanket, and generally not a bad thing to do. If you are using some kinds of hardware RAID, or your hardware does not let you install a working bootloader from the chrooted environment, you may <e>need</e> to make a GRUB boot
			disk. With these types of hardware RAID or systems,
			if you try to install grub from your chrooted shell it will fail. If you are in this camp,
			make a GRUB
			boot disk, and when you reboot the first time you can install GRUB
			to the MBR. Make your
			bootdisks like this:
			</p>
<pre caption="Creating a GRUB Bootdisk">
# <i>cd /usr/share/grub/i386-pc/</i>
# <i>cat stage1 stage2 > /dev/fd0</i>
</pre>
        <p>Now reboot and load the floppy. At the floppys <c>grub&gt;</c> prompt, you can now execute the necessary <c>root</c>
		and <c>setup</c> commands.</p>
      </body>
    </section>
    <section>
      <title>LILO Bootdisks</title>
      <body>
        <p>If you are using LILO, it is also a good idea to make a bootdisk:
		</p>
<pre caption="Making a Bootdisk">
# <i>dd if=/boot/your_kernel of=/dev/fd0 </i>
<comment>This will only work if your kernel is smaller than 1.4MB</comment>
</pre>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Pre-Reboot Preparations</title>
      <section>
	<body>
	  <p>
	    We will now install the default policy for SELinux.  Do not worry about altering the policy for your use just yet, as your machine will not enforce the policy upon boot.  We will also be relabeling our filesystem.</p>
	    <pre caption="Installing the Policy and Relabeling">
# <i>cd /etc/security/selinux/src/policy/</i>
# <i>make load</i>
# <i>make chroot_relabel</i>
</pre>

</body>
</section>
</chapter>
<chapter>
    <title>Installation Complete!</title>
    <section>
      <body>
        <p>Now, Gentoo Linux is installed.  The only remaining step is to 			update necessary configuration files, exit the chrooted shell, 
		safely unmount your partitions and reboot the system:
	</p>
<pre caption="Rebooting the System">
# <i>etc-update</i>
# <i>exit</i> 
<comment>(This exits the chrooted shell; you can also type <i>^D</i>)</comment>
# <i>cd /</i>
# <i>umount /mnt/gentoo/boot</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>umount /mnt/gentoo/selinux</i>
# <i>umount /mnt/gentoo</i>
# <i>reboot</i>
</pre>

<impo>It is almost a certainty that some files will be changed between the above relabeling and the reboot.  To ensure that all daemons and all processes run in their correct contexts, you must relabel your filesystem again, then reboot again.</impo>
<note>The process of relabeling, rebooting, relabeling again, then rebooting again is a one-time-event.  This is only necessary to do after your first install.  Unfortunately, there is no way around this, yet.</note>
<pre caption="Relabeling the Filesystem for the Second Time">
# <i>cd /etc/security/selinux/src/policy</i>
# <i>make relabel</i>
# <i>reboot</i>
</pre>
        <impo>Remember if you are running hardware RAID, you must
			use the bootdisk for the first reboot.
			then go back and install grub the way everyone else did the first
			time. You are done --  congratulations!</impo>
        <p>If you have any questions or would like to get involved with Gentoo Linux development, 
	  consider joining our gentoo-user and gentoo-dev mailing lists
	  (more information on our <uri link="http://www.gentoo.org/main/en/lists.xml">mailing lists</uri> page).
	  We also have a handy <uri link="http://www.gentoo.org/doc/en/desktop.xml">Desktop configuration guide</uri>
	  that will help you to continue configuring your new Gentoo Linux system, and a useful
	  <uri link="http://www.gentoo.org/doc/en/portage-user.xml">Portage user guide</uri>
	  to help familiarize you with Portage basics. You can find the rest of the Gentoo Documentation
	  <uri link="http://www.gentoo.org/main/en/docs.xml">here</uri>. If you have any other questions
	  involving installation or anything for that matter, please check the Gentoo Linux
	  <uri link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri>.
	  Enjoy and welcome to Gentoo Linux!
	</p>
	<note>
		It is strongly suggested to subscribe to the gentoo-hardened mail list.  It is generally a low traffic list, and SELinux announcements are made there.
	</note>
      </body>
    </section>
  </chapter>
  <chapter>
    <title>Credits</title>
    <section>
      <title>Works Cited</title>
      <body>
	<ul>
	  <li><mail link="pebenito@gentoo.org">PeBenito, Chris</mail>.  Gentoo Linux SELinux Quickstart Guide.</li>
	  <li><mail link="drobbins@gentoo.org">Robbins, Daniel</mail>.  Gentoo Linux Install Guide.</li>
	</ul>
      </body>
    </section>
  </chapter>
</guide>
