<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/Attic/hb-selinux-libsemanage.xml,v 1.1 2006/10/15 20:32:39 pebenito Exp $ -->

<sections>
<version>1.0</version>
<date>2006-10-15</date>

<section><title>SELinux Management Infrastructure</title>
<subsection><body>
<p>
  The SElinux management infrastructure manages several aspects of SELinux
  policy.  These management tools are based on the core library libsemanage.
  There are several management programs to to various tasks, including
  <c>semanage</c> and <c>semodule</c>.  They allow you to configure aspects
  of the policy without requiring the policy sources.
</p>
</body></subsection>
</section>

<section><title>SELinux Policy Module Management</title>
<subsection><title>What is a policy module?</title><body>
<p>
  SELinux supports a modular policy.  This means several pieces of policy
  are brought together to form one complete policy to be loaded in the
  kernel.  This is a similar structure as the kernel itself and kernel modules.
  There is a main kernel image that is loaded, and various kernel modules can
  be added (assuming their dependencies are met) and removed on a running
  system without restarting.  Similarly each policy has a base module and
  zero or more policy modules, all used to create a policy.
  Modules are built by compiling a piece of policy, and creating a policy
  package (*.pp) with that compiled policy, and optionally file contexts.
</p>
<p>
  The base module policy package (base.pp) contains the basic requirements of
  the policy.  All modular policies must have a base module at minimum.
  In Gentoo we have these plus policies for all parts of the system profile.
  This is contained in the selinux-base-policy ebuild.  The other policy ebuilds
  in portage have one or more policy modules.
</p>
<p>
  For more information on writing a policy module, in particular for managing
  your local customizations to the policy, please see the
  <uri link="selinux-handbook.xml?part=3&amp;chap=5">policy module guide</uri>.
</p>
</body></subsection>

<subsection><title>The SELinux module store</title><body>
<p>
  When a policy module is inserted or removed, modules are copied into or
  removed from the module store.  This repository has a copy of the
  modules that were used to create the current policy, in addition to several
  auxilliary files.  This repository is stored in the
  /etc/selinux/{strict,targeted}/modules.  You should never need to directly
  access the contents of the module store.  A libsemanage-based tool should be
  used instead.
</p>
<p>
  Libsemanage handles the module store transactionally.  This means that if
  a set of operations (a transaction) is performed on the store and one part
  fails, the entire transaction is aborted.  This keeps the store in a
  consistent state.
</p>
<p>
  Managing the module store is accomplished with the <c>semodule</c> command.
  Listing the contents of the module store is done with the <c>-l</c> option.
</p>
<pre caption="">
# semodule -l
distcc  1.1.1
</pre>
<p>
  Since the base module is required in all cases, and is not versioned, it will
  not be shown in the list.  All other modules will be listed, along with their
  versions.
</p>
</body></subsection>

<subsection><title>Inserting a policy module</title><body>
<p>
  The module should be referenced by its file name.
</p>
<pre caption="">
# <i>semodule -i module.pp</i>
</pre>
<p>
  This will insert the module into module store for the currently configured
  policy as specified in /etc/selinux/config.  If the insert succeeds, the
  policy will be loaded, unless the <c>-n</c> option is used.  To insert the
  module into an alternate module store, the <c>-s</c> option.
</p>
<pre caption="">
# <i>semodule -s targeted -i module.pp</i>
</pre>
<p>
  Since this refers to an alternate module store, the policy will not be loaded.
</p>
</body></subsection>

<subsection><title>Removing a policy module</title><body>
<p>
  The module is referenced by its name in the module store.
</p>
<pre caption="">
# <i>semodule -r module</i>
</pre>
<p>
  This will remove the module into module store for the currently configured
  policy as specified in /etc/selinux/config.  If the remove succeeds, the
  policy will be loaded, unless the <c>-n</c> option is used.  The remove
  command also respects the <c>-s</c> option.
</p>
</body></subsection>
</section>

<section><title>Configuring User Login Mappings</title>
<subsection><body>
<p>
  The current method of assigning sets of roles to a user is by setting
  up a mapping between linux users and SELinux identities.  When a user
  logs in, the login program will set the SELinux identity based on the
  this map.  If there is no explicit map, the <c>__default__</c> map is
  used.
</p>
<p>
  Managing the SELinux user login map is accomplished with the <c>semanage</c>
  tool.
</p>
<pre caption="SELinux login user map">
# <i>semanage login -l</i>
Login Name                SELinux User

__default__               user_u
root                      root
</pre>
</body></subsection>

<subsection><title>Add a user login mapping</title><body>
<p>
  To map the linux user <c>pebenito</c> to the SELinux identity <c>staff_u</c>:
</p>
<pre caption="">
# <i>semanage login -a -s staff_u pebenito</i>
</pre>
<p>
  For descriptions on the available SELinux identities, see the
  <uri link="selinux-handbook.xml?part=3&amp;chap=1#doc_chap3">SELinux Overview</uri>.
</p>
</body></subsection>

<subsection><title>Remove a user login mapping</title><body>
<p>
  To remove a login map for the linux user <c>pebenito</c>:
</p>
<pre caption="">
# <i>semanage login -d pebenito</i>
</pre>
<note>
  User login maps specified by the policy (not by the management infrastructure)
  cannot be removed.
</note>
</body></subsection>
</section>

<section><title>Configuring Initial Boolean States</title>
<subsection><body>
<p>
  The <c>setsebool</c> program is now a libsemanage tool.  This tool's basic
  function is to set the state of a Boolean.  However, if the machine is
  restarted, the Booelans will be set using the initial state as specified in
  the policy.  To set the Boolean state, and make that the new initial state
  in the policy, the <c>-P</c> option of <c>setsebool</c> is used.
</p>
<pre caption="Set Boolean default state">
# <i>setsebool -P fcron_crond 1</i>
</pre>
<p>
  This will set the fcron_crond Boolean to true and also make the initial state
  for the Boolean true.
</p>
</body></subsection>
</section>

<section><title>Configuring SELinux Identities</title>
<subsection><body>
<p>
  Generally SELinux identities need not be added to the policy, as user
  login mappings are sufficient.  However, one reason to add them is for
  improved auditing, since the SELinux identity is part of the scontext of a
  denial message.
</p>
<p>
  Managing the SELinux identities is accomplished with the <c>semanage</c> tool.
</p>
<pre caption="SELinux identity list">
# <i>semanage user -l</i>
SELinux User    SELinux Roles

root            sysadm_r staff_r
staff_u         sysadm_r staff_r
sysadm_u        sysadm_r
system_u        system_r
user_u          user_r
</pre>
</body></subsection>

<subsection><title>Add a SELinux identity</title><body>
<p>
  In addition to specifying the roles for an identity, a prefix must
  also be specified.  This prefix should match a role, for example
  <c>staff</c> or <c>sysadm</c>, and it is used for home directory
  entries.  So if <c>staff</c> is used for the prefix, linux users that
  are mapped to this identity will have their home directory labeled
  <c>staff_home_dir_t</c>.
</p>
<p>
  To add the <c>test_u</c> identity with the roles <c>staff_r</c> and
  <c>sysadm_r</c> with the prefix <c>staff</c>:
</p>
<pre caption="">
# <i>semanage user -a -R 'staff_r sysadm_r' -P staff test_u</i>
</pre>
<note>
  To use the SELinux identity, a user login map still must be added.
</note>
</body></subsection>

<subsection><title>Remove a SELinux user identity</title><body>
<p>
  To remove the test_u SELinux identity:
</p>
<pre caption="">
# <i>semanage user -d test_u</i>
</pre>
<note>
  SELinux identities specified by the policy (not by the management
  infrastructure) cannot be removed.
</note>
</body></subsection>
</section>

</sections>
