<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/Attic/hb-selinux-overview.xml,v 1.8 2008/05/20 15:45:43 pebenito Exp $ -->

<sections>
<version>1.5</version>
<date>2008-05-16</date>

<!--
<section><title>Mandatory Access Control</title>
<subsection><body>
<p>
   Security Enhanced Linux is an implementation of mandatory access control
   (MAC) using type enforcement.  In Linux, the regular security permissions
   are a discretionary access control system (DAC).  In DAC, the permissions
   for a particular object, such as a file, are set at the discrection of the
   owner and can be changed at any time by the owner.  In MAC, the access a
   process or user has to an object is defined by the operating system
   security policy, and cannot be bypassed.
!!! still need to update other links in the handbook
</p>
</body></subsection>
</section>
-->   
<section><title>SELinux Types</title>
<subsection><body>
<p>
   A type is a security attribute given to objects such as files, and network
   ports, etc.  The type of a process is commonly referred to as its domain.
   The SELinux policy is primarily composed of type enforcement rules, which
   describe how domains are allowed to interact with objects, and how domains
   are allowed to interact with other domains.  A type is generally suffixed
   with a &#39;_t&#39;, such as <c>sysadm_t</c>.  This is the most important
   attribute for a process or object, as most policy decisions are based on
   the source and target types.
</p>
</body></subsection>
</section>

<section><title>SELinux Roles</title>
<subsection><body>
<p>
   SELinux is type enforcement, so the SELinux role is not the same as those
   in a role-based access control system.  Permissions are not given to roles.
   A role describes the set of types a user can use.  For example, a system
   administrator that is using the system for regular user tasks should  be
   in the <c>staff_r</c> role.  If they need to administrate the system, then
   a role change to <c>sysadm_r</c> is required.  In SELinux terms, the
   domains that a user can be in is determined by their role.  If a role is not
   allowed to have a certain domain, a transition to that domain will be denied,
   even if the type enforcement rules allow the domain transition.  A role is
   generally suffixed with a &#39;_r&#39;, such as <c>system_r</c>.
</p>
</body></subsection>
</section>

<section><title>SELinux Identities</title>
<subsection><title>What is a SELinux Identity?</title><body>
<p>
   The SELinux identity is similar to a Linux username.  The change of identity
   should be limited to very specific cases, since the role-based access control
   relies on the SELinux identity.  Therfore, in general, a user&#8217;s SELinux
   identity will not change during a session.  The user ID in Linux can be
   changed by set(e)uid, making it inappropriate for a SELinux identity.
   If a user is given a SELinux identity, it must match the Linux username.  Each
   SELinux identity is allowed a set of roles.
</p>
</body></subsection>

<subsection><title>Configure SELinux Identity Mapping</title><body>
<p>
   The SELinux policy has several generic SELinux identities that should
   be sufficient for all users.  This mapping only needs to be configured
   on the strict policy.  The identity mapping for the targeted policy
   need not be configured, as the default identity (user_u) is sufficient
   in all cases.
</p>
<p>
   When a user logs in, the SELinux identity used is determined by this mapping.
</p>
<table>
<tr><th>SELinux Identity</th>
    <th>Roles</th>
    <th>Description</th></tr>
<tr><ti>system_u</ti>
    <ti>system_r</ti>
    <ti>System (non-interactive) processes.  Should not be used on users.</ti></tr>
<tr><ti>user_u</ti>
    <ti>user_r</ti>
    <ti>Generic unprivileged users.  The default identity mapping.</ti></tr>
<tr><ti>staff_u</ti>
    <ti>staff_r, sysadm_r</ti>
    <ti>System administrators that also log in to do regular user activties.</ti></tr>
<tr><ti>sysadm_u</ti>
    <ti>sysadm_r</ti>
    <ti>System administrators that only log in to do administrative tasks.  It is not suggested that this identity is used.</ti></tr>
<tr><ti>root</ti>
    <ti>staff_r, sysadm_r</ti>
    <ti>Special identity for root.  Other users should use staff_u instead.</ti></tr>
</table>
<p>
   See the <uri link="selinux-handbook.xml?part=3&amp;chap=2#doc_chap3">SELinux HOWTO</uri>
   for semanage syntax for configuring SELinux identity mappings.
</p>
</body></subsection>

</section>

<section><title>SELinux Contexts</title>
<subsection><body>
<p>
   Using the above three security models together is called a SELinux
   context.  A context takes the form <c>identity</c>:<c>role</c>:<c>type</c>.
   The SELinux context is the most important value for determining access.
</p>
</body></subsection>

<subsection><title>Object Contexts</title><body>
<p>
   A typical <c>ls -Z</c> may have an output similar to this:
</p>
<pre caption="Example ls -Z output">
drwxr-xr-x  root     root     system_u:object_r:bin_t          bin
drwxr-xr-x  root     root     system_u:object_r:boot_t         boot
drwxr-xr-x  root     root     system_u:object_r:device_t       dev
drwxr-xr-x  root     root     system_u:object_r:etc_t          etc
</pre>
<p>
   The first three columns are the typical linux permissions, user and group.
   The fourth column is the file or directory&#39;s security context.  Objects
   are given the generic <c>object_r</c> role.  From the other two fields of
   the context, it can be seen that the files are in the system identity,
   and have four different types, <c>bin_t</c>, <c>boot_t</c>, <c>device_t</c>,
   and <c>etc_t</c>.
</p>
</body></subsection>

<subsection><title>Process Contexts</title><body>
<p>
   A typical <c>ps ax -Z</c> may have an output similar to this:
</p>
<pre caption="Example ps ax -Z output">
  PID CONTEXT                                  COMMAND
    1 system_u:system_r:init_t                 [init]
    2 system_u:system_r:kernel_t               [keventd]
    3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
    4 system_u:system_r:kernel_t               [kswapd]
    5 system_u:system_r:kernel_t               [bdflush]
    6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t              [syslog-ng]
  712 system_u:system_r:httpd_t                [apache]
  791 system_u:system_r:sshd_t                 [sshd]
  814 system_u:system_r:crond_t                [cron]
  826 system_u:system_r:getty_t                [agetty]
  827 system_u:system_r:getty_t                [agetty]
  828 system_u:system_r:getty_t                [agetty]
  829 system_u:system_r:getty_t                [agetty]
  830 system_u:system_r:getty_t                [agetty]
  831 system_u:system_r:httpd_t                [apache]
  832 system_u:system_r:httpd_t                [apache]
  833 system_u:system_r:httpd_t                [apache]
23093 system_u:system_r:sshd_t                 [sshd]
23095 user_u:user_r:user_t                     [bash]
23124 system_u:system_r:sshd_t                 [sshd]
23126 user_u:user_r:user_t                     [bash]
23198 system_u:system_r:sshd_t                 [sshd]
23204 user_u:user_r:user_t                     [bash]
23274 system_u:system_r:sshd_t                 [sshd]
23275 pebenito:staff_r:staff_t                 [bash]
23290 pebenito:staff_r:staff_t                 ps ax -Z
</pre>
<p>
   In this example, the typical process information is displayed, in addition
   to the process&#39;s context.  By inspection, all of the system&#39;s kernel
   processes and daemons run under the <c>system_u</c> identity, and
   <c>system_r</c> role.  The individual domains depend on the program.
   There are a few users logged in over ssh, using the generic <c>user_u</c>
   identity.  Finally there is a user with the identity <c>pebenito</c> logged in
   with the <c>staff_r</c> role, running in the <c>staff_t</c> domain.
</p>
</body></subsection>

</section>

<section>
<title>SELinux Policy Files</title>
<subsection><body>
<p>
   The SELinux policy source files are no longer installed onto the system.
   In the <c>/usr/share/selinux/{strict,targeted}</c> directory there are a
   collection of policy packages and headers for building local modules.
   The policy files are processed by m4, and then the policy compiler <c>checkmodule</c>
   verifies that there are no syntactic errors, and a policy module is created.
   Then a policy package is created with with the <c>semodule_package</c>
   program, using the policy module and the module file contexts.
   The policy packaged then can be loaded into a running SELinux kernel
   by inserting it into the module store.
</p>
</body></subsection>

<subsection><title>*.pp</title><body>
<p>
   Policy packages for this policy.  These must be inserted into the module
   store so they can be loaded into the policy.  Inside the package
   there is a loadable policy module, and optionally a file context file.
</p>
</body></subsection>

<subsection><title>include/</title><body>
<p>
   Policy headers for this policy.
</p>
</body></subsection>

</section>

<section>
<title>Binary Policy Versions</title>
<subsection><body>
<p>
   When compiling the policy, the resultant binary policy is versioned.
   The first version that was merged into 2.6 was version 15.
   The version number is only incremented generally when new features are added that require changes to the structure of the compiled policy.
   For example, in 2.6.5, conditional policy extensions were added.
   This required the policy version to be incremented to version 16.
</p>
</body></subsection>
<subsection><title>What Policy Version Does My Kernel Use?</title>
<body>
<p>
   The policy version of a running kernel can be determined by executing
   <c>sestatus</c> or <c>policyvers</c>.  Current kernels can load
   the previous version policy for compatibility.  For example a version 17
   kernel can also load a version 16 policy.  However, this compatibility
   code may be removed in the future.
</p>
<note>
  The policy management infrastructure (libsemanage) will automatically
  create and use the correct version policies.  No extra steps need be taken.
</note>
</body></subsection>
<subsection><title>Policy Versions</title>
<body>
<p>
   The following table contains the policy versions in 2.6 kernels.
</p>
<table>
<tr><th>Version</th>
    <th>Description</th>
    <th>Kernel Versions</th></tr>
<tr><ti>12</ti>
    <ti>"Old API" SELinux (deprecated).</ti></tr>
<tr><ti>15</ti>
    <ti>"New API" SELinux merged into 2.6.</ti>
    <ti>2.6.0 - 2.6.4</ti></tr>
<tr><ti>16</ti>
    <ti>Conditional policy extensions added.</ti>
    <ti>2.6.5</ti></tr>
<tr><ti>17</ti>
    <ti>IPV6 support added.</ti>
    <ti>2.6.6 - 2.6.7</ti></tr>
<tr><ti>18</ti>
    <ti>Fine-grained netlink socket support added.</ti>
    <ti>2.6.8 - 2.6.11</ti></tr>
<tr><ti>19</ti>
    <ti>Enhanced multi-level security.</ti>
    <ti>2.6.12 - 2.6.13</ti></tr>
<tr><ti>20</ti>
    <ti>Access vector table size optimizations.</ti>
    <ti>2.6.14 - 2.6.18</ti></tr>
<tr><ti>21</ti>
    <ti>Object classes in range transitions.</ti>
    <ti>2.6.19 - 2.6.24</ti></tr>
<tr><ti>22</ti>
    <ti>Policy capabilities (features).</ti>
    <ti>2.6.25 - current</ti></tr>
</table>
</body></subsection>
</section>

<section>
<title>Conditional Policy Extensions</title>
<subsection><body>
<p>
  The conditional policy extensions allow the enabling and disabling of policy
  rules at runtime, without loading a modified policy.  Using policy booleans
  and expressions, policy rules can be conditionally applied.
</p>
</body></subsection>

<subsection><title>Determine Boolean Values</title>
<body>
<p>
  The status of policy booleans in the current running policy can be determined
  two ways.  The first is by using <c>sestatus</c>.
</p>
<pre caption="Example sestatus output">
# sestatus
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         17
 
Policy booleans:
user_ping               inactive
</pre>
<p>
  The second is <c>getsebool</c> which is a simple tool that displays
  the status of policy booleans, and if a value change is pending.
</p>
<pre caption="Example getsebool command">
# getsebool -a
user_ping --> active: 0 pending: 0
</pre>
</body></subsection>

<subsection><title>Changing Boolean Values</title>
<body>
<p>
  The value of a boolean can be toggled by using the <c>togglesebool</c>
  command.  Multiple booleans can be specified on the command line.  The
  new value of the boolean will be displayed.
</p>
<pre caption="Example togglesebool command">
# togglesebool user_ping
user_ping: active
</pre>
<p>
  The value of a boolean can be set specifically by using the <c>setsebool</c>
  command.
</p>
<pre caption="Example setsebool command">
# setsebool user_ping 0
</pre>
<p>
  To set the value of a boolean, and make it the devault value, use the <c>-P</c> option.
</p>
<pre caption="Change default value">
# setsebool -P user_ping 1
</pre>
</body></subsection>
</section>

<section>
<title>Policy Kernel Messages</title>
<subsection><body>
<p>
   While a system is running, a program or user may attempt to do something
   that violates the security policy.  If the system is enforcing the policy,
   the access will be denied, and there will be a message in the kernel log.
   If the system is not enforcing (permissive mode), the access will be allowed,
   but there will still be a kernel message.
</p>
</body></subsection>

<subsection><title>AVC Messages</title><body>
<p>
   Most kernel messages from SELinux come from the access vector cache (AVC).
   Understanding denials is important to understand if an attack is happening,
   or if the program is requiring unexpected accesses.  An example denial
   may look like this:
</p>

<pre caption="Example AVC Message">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
   While most AVC messages are denials, occasionally there might be an audit
   message for an access that was granted:
</p>
<pre caption="Example AVC Message 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>
<p>
   In this case, the ability to load the policy was granted.  This is a critical
   security event, and thus is always audited.  Another event that is always
   audited is switching between enforcing and permissive modes.
</p>

<p>
   SELinux will supress logging of denials if many are received in a short
   amount of time.  However, This does not always imply there is an attack
   in progress.  A program may be doing something that could cause
   many denials in a short time, such as doing a stat() on device nodes in
   /dev.  To protect from filling up the system logs, SELinux has rate limiting
   for its messages:
</p>

<pre caption="Example AVC Message 3">
AVC: 12 messages suppressed.
</pre>

<p>
   The policy would have to be modified to not audit these accesses if they
   are normal program behavior, but still need to be denied.
</p>

</body></subsection>

<subsection><title>Other kernel messages</title>
<body>
<pre caption="inode_doinit_with_dentry">
inode_doinit_with_dentry:  context_to_sid(system_u:object_r:bar_t) returned 22 for dev=hda3 ino=517610
</pre>
<p>
   This means that the file on /dev/hda3 with inode number 517610 has the context
   system_u:object_r:bar_t, which is invalid.  Objects with an invalid context
   are treated as if they had the system_u:object_r:unlabeled_t context.
</p>
</body></subsection>

</section>

<section><title>Dissecting a Denial</title>
<subsection><body>
<p>
   Denials contain varying amounts of information, depending on the access type.
</p>

<pre caption="Example Denials">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
   The most common denial relates to access of files.  For better understanding,
   the first denial message will be broken down:
</p>
<table>
<tr><th>Component</th><th>Description</th></tr>
<tr><ti>avc:  denied</ti>
    <ti>SELinux has denied this access.</ti></tr>
<tr><ti>{ lock }</ti>
    <ti>The attempted access is a lock.</ti></tr>
<tr><ti>pid=28341</ti>
    <ti>The process ID performing this access is 28341.</ti></tr>
<tr><ti>exec=/sbin/agetty</ti>
    <ti>The full path and name of the process&#39;s executable is /sbin/agetty.</ti></tr>
<tr><ti>path=/var/log/wtmp</ti>
    <ti>The path and name of the target object is /var/log/wtmp.  Note: a complete
        path is not always available.</ti></tr>
<tr><ti>dev=03:03</ti>
    <ti>The target object resides on device 03:03 (major:minor number).
        On 2.6 kernels this may resolve to a name, hda3 in this example.</ti></tr>
<tr><ti>ino=475406</ti>
    <ti>The inode number of the target object is 475406.</ti></tr>
<tr><ti>scontext=system_u:system_r:getty_t</ti>
    <ti>The context of the program is system_u:system_r:getty_t.</ti></tr>
<tr><ti>tcontext=system_u:object_r:var_log_t</ti>
    <ti>The context of the target object is system_u:object_r:var_log_t.</ti></tr>
<tr><ti>tclass=file</ti>
    <ti>The target object is a normal file.</ti></tr>
</table>

<p>
   Not all AVC messages will have all of these fields, as shown in the other
   two denials.  The fields vary depending on the target object&#39;s class.
   However, the most important fields: access type, source and target contexts,
   and the target object&#39;s class will always be in an AVC message.
</p>
</body></subsection>

<subsection><title>Understanding the Denial</title><body>
<p>
   Denials can be very confusing since they can be triggered for several reasons.
   The key to understanding what is happening is to know the behavior of the
   program, and to correctly interpret the denial message.  The target is not
   limited to files; it could also be related to network sockets,
   interprocess communications, or others.
</p>
<p>
   In the above example, the agetty is denied locking of a file.  The file&#39;s type
   is var_log_t, therefore it is implied that the target file is in /var/log.
   With the extra information from the path= field in the denial message, it is
   confirmed to be the file /var/log/wtmp.  If path information was unavailable,
   this could be further confirmed by searching for the inode.  Wtmp is a file that has
   information about users currently logged in, and agetty handles logins on
   ttys.  It can be concluded that this is an expected access of agetty, for
   updating wtmp.  However, why is this access being denied?  Is there a flaw
   in the policy by not allowing agetty to update wtmp?  It turns out that wtmp
   has the incorrect context.  It should be system_u:object_r:wtmp_t, rather
   than system_u:object_r:var_log_t.
</p>
<p>
   If this access was not understood, an administrator might mistakenly allow getty_t
   read/write access to var_log_t files, which would be incorrect, since agetty
   only needs to modify /var/log/wtmp.  This underscores how critical keeping
   file contexts consistent is.
</p>
</body></subsection>
</section>

<section><title>References</title>
<subsection><body>
<p>
   <uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
   SELinux Policy README
</p>
</body></subsection>
</section>
</sections>
