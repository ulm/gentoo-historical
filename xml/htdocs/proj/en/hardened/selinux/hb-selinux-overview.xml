<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/Attic/hb-selinux-overview.xml,v 1.4 2006/05/01 01:41:15 pebenito Exp $ -->

<sections>
<!--
<section><title>Mandatory Access Control</title>
<subsection><body>
<p>
   Security Enhanced Linux is an implementation of mandatory access control
   (MAC) using type enforcement.  In Linux, the regular security permissions
   are a discretionary access control system (DAC).  In DAC, the permissions
   for a particular object, such as a file, are set at the discrection of the
   owner and can be changed at any time by the owner.  In MAC, the access a
   process or user has to an object is defined by the operating system
   security policy, and cannot be bypassed.
!!! still need to update other links in the handbook
</p>
</body></subsection>
</section>
-->   
<section><title>SELinux Types</title>
<subsection><body>
<p>
   A type is a security attribute given to objects such as files, and network
   ports, etc.  The type of a process is commonly referred to as its domain.
   The SELinux policy is primarily composed of type enforcement rules, which
   describe how domains are allowed to interact with objects, and how domains
   are allowed to interact with other domains.  A type is generally suffixed
   with a &#39;_t&#39;, such as <c>sysadm_t</c>.  This is the most important
   attribute for a process or object, as most policy decisions are based on
   the source and target types.
</p>
</body></subsection>
</section>

<section><title>SELinux Roles</title>
<subsection><body>
<p>
   SELinux is type enforcement, so the SELinux role is not the same as those
   in a role-based access control system.  Permissions are not given to roles.
   A role describes the set of types a user can use.  For example, a system
   administrator that is using the system for regular user tasks should  be
   in the <c>staff_r</c> role.  If they need to administrate the system, then
   a role change to <c>sysadm_r</c> is required.  In SELinux terms, the
   domains that a user can be in is determined by their role.  If a role is not
   allowed to have a certain domain, a transition to that domain will be denied,
   even if the type enforcement rules allow the domain transition.  A role is
   generally suffixed with a &#39;_r&#39;, such as <c>portage_r</c>.
</p>
</body></subsection>
</section>

<section><title>SELinux Identities</title>
<subsection><title>What is a SELinux Identity?</title><body>
<p>
   The SELinux identity is similar to a Linux username.  The change of identity
   should be limited to very specific cases, since the role-based access control
   relies on the SELinux identity.  Therfore, in general, a user&#8217;s SELinux
   identity will not change during a session.  The user ID in Linux can be
   changed by set(e)uid, making it inappropriate for a SELinux identity.
   If a user is given a SELinux identity, it must match the Linux username.  Each
   SELinux identity is allowed a set of roles.
</p>
</body></subsection>

<subsection><title>Configuring SELinux Identities</title><body>
<p>
   SELinux identities are contained in the users file in the policy directory.
   The syntax for the file is simple.  For example, to allow the user
   <c>pebenito</c> the roles <c>staff_r</c> and <c>sysadm_r</c>, add to the end
   of the file something like:
</p>
<pre caption="Example user line">user pebenito roles { staff_r sysadm_r };</pre>
<p>
   Then load the policy.  There must also be a Linux username <c>pebenito</c>.
   If a user does not have a <c>user</c> line in the file, their identity will
   be <c>user_u</c>, and only be allowed the <c>user_r</c> role.
</p>

<impo>
   Normal users that have identities should be allowed <c>user_r</c>, not
   <c>staff_r</c>. Administrators should be allowed <c>staff_r</c> and 
   <c>sysadm_r</c>.  All users must be allowed <c>user_r</c> or
   <c>staff_r</c> otherwise they will be unable to log in remotely.
</impo>
<p>
   When giving a user an identity their home directory and contents should also be
   appropriately labeled.  The user's home directory will be labeled based on
   the first role listed for the user, in the users file.  For the above example,
   the user pebenito will have his home directory labeled as <c>staff_home_dir_t</c>.
</p>
</body></subsection>
</section>

<section><title>SELinux Contexts</title>
<subsection><body>
<p>
   Using the above three security models together is called a SELinux
   context.  A context takes the form <c>identity</c>:<c>role</c>:<c>type</c>.
   The SELinux context is the most important value for determining access.
</p>
</body></subsection>

<subsection><title>Object Contexts</title><body>
<p>
   A typical <c>ls -Z</c> may have an output similar to this:
</p>
<pre caption="Example ls -Z output">
drwxr-xr-x  root     root     system_u:object_r:bin_t          bin
drwxr-xr-x  root     root     system_u:object_r:boot_t         boot
drwxr-xr-x  root     root     system_u:object_r:device_t       dev
drwxr-xr-x  root     root     system_u:object_r:etc_t          etc
</pre>
<p>
   The first three columns are the typical linux permissions, user and group.
   The fourth column is the file or directory&#39;s security context.  Objects
   are given the generic <c>object_r</c> role.  From the other two fields of
   the context, it can be seen that the files are in the system identity,
   and have four different types, <c>bin_t</c>, <c>boot_t</c>, <c>device_t</c>,
   and <c>etc_t</c>.
</p>
</body></subsection>

<subsection><title>Process Contexts</title><body>
<p>
   A typical <c>ps ax -Z</c> may have an output similar to this:
</p>
<pre caption="Example ps ax -Z output">
  PID CONTEXT                                  COMMAND
    1 system_u:system_r:init_t                 [init]
    2 system_u:system_r:kernel_t               [keventd]
    3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
    4 system_u:system_r:kernel_t               [kswapd]
    5 system_u:system_r:kernel_t               [bdflush]
    6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t              [syslog-ng]
  712 system_u:system_r:httpd_t                [apache]
  791 system_u:system_r:sshd_t                 [sshd]
  814 system_u:system_r:crond_t                [cron]
  826 system_u:system_r:getty_t                [agetty]
  827 system_u:system_r:getty_t                [agetty]
  828 system_u:system_r:getty_t                [agetty]
  829 system_u:system_r:getty_t                [agetty]
  830 system_u:system_r:getty_t                [agetty]
  831 system_u:system_r:httpd_t                [apache]
  832 system_u:system_r:httpd_t                [apache]
  833 system_u:system_r:httpd_t                [apache]
23093 system_u:system_r:sshd_t                 [sshd]
23095 user_u:user_r:user_t                     [bash]
23124 system_u:system_r:sshd_t                 [sshd]
23126 user_u:user_r:user_t                     [bash]
23198 system_u:system_r:sshd_t                 [sshd]
23204 user_u:user_r:user_t                     [bash]
23274 system_u:system_r:sshd_t                 [sshd]
23275 pebenito:staff_r:staff_t                 [bash]
23290 pebenito:staff_r:staff_t                 ps ax -Z
</pre>
<p>
   In this example, the typical process information is displayed, in addition
   to the process&#39;s context.  By inspection, all of the system&#39;s kernel
   processes and daemons run under the <c>system_u</c> identity, and
   <c>system_r</c> role.  The individual domains depend on the program.
   There are a few users logged in over ssh, using the generic <c>user_u</c>
   identity.  Finally there is a user with the identity <c>pebenito</c> logged in
   with the <c>staff_r</c> role, running in the <c>staff_t</c> domain.
</p>
</body></subsection>

</section>

<section>
<title>SELinux Policy Files</title>
<subsection><body>
<p>
   The SELinux policy usually resides in <c>/etc/security/selinux/src/policy</c>.
   It is comprised of several files and directories for generating the policy.
   For easing the creation of the policy, macros from the m4 text processor
   are used to reuse common rules.  The policy files are processed
   by m4, and then the policy compiler <c>checkpolicy</c> verifies that
   there are no syntactic errors, and creates a binary policy file.  The binary
   policy then can be loaded into a running SELinux kernel.
</p>
</body></subsection>
<subsection><title>Makefile</title><body>
<p>
   The policy Makefile handles the compiling and installation of policy.  It
   has one configurable option for controlling the <uri link="#doc_chap6">policy version</uri>,
   and has four targets.
</p>
<table>
<tr><th>Command</th><th>Description</th></tr>
<tr><ti>make policy</ti>
    <ti>Compiles the current policy into the binary policy file.</ti></tr>
<tr><ti>make install</ti>
    <ti>Compiles and installs the current policy into the /etc/security/selinux/src directory.</ti></tr>
<tr><ti>make load</ti>
    <ti>Compile, install, and load the current policy into the current running kernel.</ti></tr>
<tr><ti>make relabel</ti>
    <ti>Relabels the filesystems using the file contexts in the policy.</ti></tr>
</table>
</body></subsection>

<subsection><title>assert.te</title><body>
<p>
   The rules in this file will be checked in the final phase of
   compilation.  If a permission granted in the policy matches one of
   these assertions, the policy compiler will reject the policy.  This can
   aid in ensuring certain accesses are never allowed.
</p>
</body></subsection>

<subsection><title>attrib.te</title><body>
<p>
   A type attribute can be used to identify a set of types with a similar
   property.  Each type can have any number of attributes, and each
   attribute can be associated with any number of types.  Attributes are
   explicitly declared in this file, and can then be associated with particular
   types in type declarations.  Attribute names can then be used throughout
   the configuration to express the set of types that are associated with
   the attribute.
</p>
</body></subsection>

<subsection><title>constraints</title><body>
<p>
   This file defines additional constraints on permissions
   in the form of expressions that must be satisfied in order
   for specified permissions to be granted.  These constraints
   are used to further refine the type enforcement tables and
   the role allow rules.  Typically, these constraints are used
   to restrict changes in user identity or role to certain domains.
</p>
</body></subsection>

<subsection><title>domains/</title><body>
<p>
   This directory contains the type enforcement rules.  This directory contains
   the files <c>admin.te</c>, <c>staff.te</c>, and <c>user.te</c>, which
   contain the access vectors for the <c>sysadm_r</c>, <c>staff_r</c>, and 
   <c>user_r</c> roles.  The <c>program/</c> directory consists of all of the
   active policies for various programs and daemons.  The <c>misc/</c> directory
   contains all other policy files.
</p>
</body></subsection>

<subsection><title>file_contexts/</title><body>
<p>
   This directory contains the files that describe the security contexts
   for all files on persistent filesystems.  It contains the file <c>types.fc</c>
   which has all of the security contexts for the general system.  The
   directory <c>program/</c> contains the security contexts for the daemons
   in the <c>domains/program/</c> directory.  These are one-to-one mapped;
   for example, the domains/program/syslogd.te policy file corresponds to the
   file_contexts/program/syslogd.fc security contexts file.
</p>
</body></subsection>

<subsection><title>flask/</title><body>
<p>
   This directory contains contains configuration files independent of the
   policy.  These files contain definitions corresponding to definitions
   in the kernel headers.  These files <e>should not</e> be modified.
</p>
</body></subsection>

<subsection><title>fs_use</title><body>
<p>
   This file describes the labelling behavior for files on various filesystem
   types.  For example, ext3 uses persistent labelling, while tmpfs uses
   transitional security IDs.  In general, this file should <e>not</e>
   need to be modified.
</p>
</body></subsection>

<subsection><title>genfs_contexts</title><body>
<p>
   This file contains the security contexts for files in a filesystem that
   do not support persistent file labels, such as <c>/proc</c>.
</p>
</body></subsection>

<subsection><title>initial_sid_contexts</title><body>
<p>
   This file contains the initial context for each security ID.  In general,
   this file should <e>not</e> need to be modified.
</p>
</body></subsection>

<subsection><title>macros/</title><body>
<p>
   This directory contains the m4 macros used to ease creation and maintenance
   of the policy.  It contains the macro file <c>admin_macros.te</c> for
   describing administration domains, such as <c>sysadm_t</c>.  The
   <c>user_macros.te</c> contains macros used in user domains such as <c>user_t</c>
   and <c>staff_t</c>.  The <c>global_macros.te</c> contains macros used throughout
   the entire policy.
</p>
</body></subsection>

<subsection><title>mls</title><body>
<p>
   This file contains the configuration for SELinux multi-level security.
   Multi-level Security is experimental, and is not supported by Gentoo.
</p>
</body></subsection>

<subsection><title>net_contexts</title><body>
<p>
   This file defines the security contexts of network objects such as ports,
   interfaces, and nodes.  This will need to be modified if daemons run on
   nonstandard ports.
</p>
</body></subsection>

<subsection><title>rbac</title><body>
<p>
   The name of the file is misleading, as SELinux does not have
   role-based access control.  This file contains role transition
   rules for the base system.  Additional transitions are allowed
   in the type enforcement files, especially <c>user.te</c> and
   <c>staff.te</c>.
</p>
</body></subsection>

<subsection><title>tmp/</title><body>
<p>
   This directory is used for holding intermediate files when compiling the
   policy.  It can be safely removed, if needed.
</p>
</body></subsection>

<subsection><title>tunable.te</title><body>
<p>
   This is the main configuration file of the policy.
</p>
</body></subsection>

<subsection><title>types/</title><body>
<p>
   This directory contains files for declaring general types of the system
   which do not appear in the individual program policies.
</p>
</body></subsection>

<subsection><title>users</title><body>
<p>
   This file describes the SELinux identities, and the roles they can enter.
</p>
</body></subsection>
</section>

<section>
<title>Policy Database Versions</title>
<subsection><body>
<p>
   When compiling the policy, the resultant binary policy is versioned.  The
   first version that was merged into 2.6, and also is in the 2.4 backports is
   version 15.  The version number is only incremented generally when new
   features are added that require changes to the structure of the compiled
   policy.  For example, in 2.6.5, conditional policy extensions were added.
   This required the policy version to be incremented to version 16.
</p>
</body></subsection>
<subsection><title>What Policy Version Does My Kernel Use?</title>
<body>
<p>
   The policy version of a running kernel can be determined by executing
   <c>sestatus</c> or <c>policyvers</c>.  Current kernels can load
   the previous version policy for compatibility.  For example a version 17
   kernel can also load a version 16 policy.  However, this compatibility
   code may be removed in the future.
</p>
</body></subsection>
<subsection><title>Compiling the Right Version Policy</title>
<body>
<p>
   The only adjustment needed is in the policy Makefile.  There is a line
   near the top that looks like this:
</p>
<pre caption="Makefile contents">
POLICYCOMPAT = -c 15
</pre>
<p>
   Normally, checkpolicy will create a policy for the current version.  The
   policy versions that checkpolicy can create can be determined by running
   <c>checkpolicy -V</c>.  With the above option uncommented, a compatibility
   policy can be created.  The above statement will create a version 15 policy;
   it can be changed to 16.
</p>
</body></subsection>
<subsection><title>Policy Versions</title>
<body>
<p>
   The following table contains the policy versions in vanilla 2.6.
   Other 2.6 kernels, such as gentoo-sources,
   will have the SELinux version of the vanilla kernel version
   it is based on.
</p>
<table>
<tr><th>Version</th>
    <th>Description</th>
    <th>Kernel Versions</th></tr>
<tr><ti>12</ti>
    <ti>"Old API" SELinux (deprecated).</ti></tr>
<tr><ti>15</ti>
    <ti>"New API" SELinux merged into 2.6.</ti>
    <ti>2.6.0 - 2.6.4</ti></tr>
<tr><ti>16</ti>
    <ti>Conditional policy extensions added.</ti>
    <ti>2.6.5</ti></tr>
<tr><ti>17</ti>
    <ti>IPV6 support added.</ti>
    <ti>2.6.6 - 2.6.7</ti></tr>
<tr><ti>18</ti>
    <ti>Fine-grained netlink socket support added.</ti>
    <ti>2.6.8 - 2.6.11</ti></tr>
<tr><ti>19</ti>
    <ti>Policy-enabled Multi-level security.</ti>
    <ti>2.6.12 - 2.6.13</ti></tr>
<tr><ti>20</ti>
    <ti>Access vector table size optimizations.</ti>
    <ti>2.6.14 - current</ti></tr>
</table>
</body></subsection>
</section>

<section>
<title>Conditional Policy Extensions</title>
<subsection><body>
<p>
  The conditional policy extensions allow the enabling and disabling of policy
  rules at runtime, without loading a modified policy.  Using policy booleans
  and expressions, policy rules can be conditionally applied.
</p>
</body></subsection>

<subsection><title>Determine Boolean Values</title>
<body>
<p>
  The status of policy booleans in the current running policy can be determined
  two ways.  The first is by using <c>sestatus</c>.
</p>
<pre caption="Example sestatus output">
# sestatus
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         17
 
Policy booleans:
user_ping               inactive
</pre>
<p>
  The second is <c>getsebool</c> which is a simple tool that displays
  the status of policy booleans, and if a value change is pending.
</p>
<pre caption="Example getsebool command">
# getsebool -a
user_ping --> active: 0 pending: 0
</pre>
</body></subsection>

<subsection><title>Changing Boolean Values</title>
<body>
<p>
  The value of a boolean can be toggled by using the <c>togglesebool</c>
  command.  Multiple booleans can be specified on the command line.  The
  new value of the boolean will be displayed.
</p>
<pre caption="Example togglesebool command">
# togglesebool user_ping
user_ping: active
</pre>
<p>
  The value of a boolean can be set specifically by using the <c>setsebool</c>
  command.
</p>
<pre caption="Example setsebool command">
# setsebool user_ping 0
</pre>
</body></subsection>
</section>

<section>
<title>Policy Kernel Messages</title>
<subsection><body>
<p>
   While a system is running, a program or user may attempt to do something
   that violates the security policy.  If the system is enforcing the policy,
   the access will be denied, and there will be a message in the kernel log.
   If the system is not enforcing (permissive mode), the access will be allowed,
   but there will still be a kernel message.
</p>
</body></subsection>

<subsection><title>AVC Messages</title><body>
<p>
   Most kernel messages from SELinux come from the access vector cache (AVC).
   Understanding denials is important to understand if an attack is happening,
   or if the program is requiring unexpected accesses.  An example denial
   may look like this:
</p>

<pre caption="Example AVC Message">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
   While most AVC messages are denials, occasionally there might be an audit
   message for an access that was granted:
</p>
<pre caption="Example AVC Message 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>
<p>
   In this case, the ability to load the policy was granted.  This is a critical
   security event, and thus is always audited.  Another event that is always
   audited is switching between enforcing and permissive modes.
</p>

<p>
   SELinux will supress logging of denials if many are received in a short
   amount of time.  However, This does not always imply there is an attack
   in progress.  A program may be doing something that could cause
   many denials in a short time, such as doing a stat() on device nodes in
   /dev.  To protect from filling up the system logs, SELinux has rate limiting
   for its messages:
</p>

<pre caption="Example AVC Message 3">
AVC: 12 messages suppressed.
</pre>

<p>
   The policy would have to be modified to not audit these accesses if they
   are normal program behavior, but still need to be denied.
</p>

</body></subsection>
</section>

<section><title>Dissecting a Denial</title>
<subsection><body>
<p>
   Denials contain varying amounts of information, depending on the access type.
</p>

<pre caption="Example Denials">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
   The most common denial relates to access of files.  For better understanding,
   the first denial message will be broken down:
</p>
<table>
<tr><th>Component</th><th>Description</th></tr>
<tr><ti>avc:  denied</ti>
    <ti>SELinux has denied this access.</ti></tr>
<tr><ti>{ lock }</ti>
    <ti>The attempted access is a lock.</ti></tr>
<tr><ti>pid=28341</ti>
    <ti>The process ID performing this access is 28341.</ti></tr>
<tr><ti>exec=/sbin/agetty</ti>
    <ti>The full path and name of the process&#39;s executable is /sbin/agetty.</ti></tr>
<tr><ti>path=/var/log/wtmp</ti>
    <ti>The path and name of the target object is /var/log/wtmp.  Note: a complete
        path is not always available.</ti></tr>
<tr><ti>dev=03:03</ti>
    <ti>The target object resides on device 03:03 (major:minor number).
        On 2.6 kernels this may resolve to a name, hda3 in this example.</ti></tr>
<tr><ti>ino=475406</ti>
    <ti>The inode number of the target object is 475406.</ti></tr>
<tr><ti>scontext=system_u:system_r:getty_t</ti>
    <ti>The context of the program is system_u:system_r:getty_t.</ti></tr>
<tr><ti>tcontext=system_u:object_r:var_log_t</ti>
    <ti>The context of the target object is system_u:object_r:var_log_t.</ti></tr>
<tr><ti>tclass=file</ti>
    <ti>The target object is a normal file.</ti></tr>
</table>

<p>
   Not all AVC messages will have all of these fields, as shown in the other
   two denials.  The fields vary depending on the target object&#39;s class.
   However, the most important fields: access type, source and target contexts,
   and the target object&#39;s class will always be in an AVC message.
</p>
</body></subsection>

<subsection><title>Understanding the Denial</title><body>
<p>
   Denials can be very confusing since they can be triggered for several reasons.
   The key to understanding what is happening is to know the behavior of the
   program, and to correctly interpret the denial message.  The target is not
   limited to files; it could also be related to network sockets,
   interprocess communications, or others.
</p>
<p>
   In the above example, the agetty is denied locking of a file.  The file&#39;s type
   is var_log_t, therefore it is implied that the target file is in /var/log.
   With the extra information from the path= field in the denial message, it is
   confirmed to be the file /var/log/wtmp.  If path information was unavailable,
   this could be further confirmed by searching for the inode.  Wtmp is a file that has
   information about users currently logged in, and agetty handles logins on
   ttys.  It can be concluded that this is an expected access of agetty, for
   updating wtmp.  However, why is this access being denied?  Is there a flaw
   in the policy by not allowing agetty to update wtmp?  It turns out that wtmp
   has the incorrect context.  It should be system_u:object_r:wtmp_t, rather
   than system_u:object_r:var_log_t.
</p>
<p>
   If this access was not understood, an administrator might mistakenly allow getty_t
   read/write access to var_log_t files, which would be incorrect, since agetty
   only needs to modify /var/log/wtmp.  This underscores how critical keeping
   file contexts consistent is.
</p>
</body></subsection>
</section>

<section><title>References</title>
<subsection><body>
<p>
   <uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
   SELinux Policy README
</p>
</body></subsection>
</section>
</sections>
