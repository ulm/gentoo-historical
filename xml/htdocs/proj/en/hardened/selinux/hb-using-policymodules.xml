<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/Attic/hb-using-policymodules.xml,v 1.2 2011/04/25 20:12:59 zorry Exp $ -->

<sections>
<version>1</version>
<date>2011-03-02</date>

<section>
<title>Writing Simple Policies</title>
<subsection>
<title>Writing a TE File</title>
<body>

<p>
Let us summarize our previous experiences with writing simple policies. We have
already covered how to write a <path>.te</path> file and convert it to a
loadable SELinux module. Let's go over this once again with a simple example:
allowing execmem for the mozilla_t domain.
</p>

<p>
When using the <path>selinux-mozilla</path> provided SELinux module, you might
still get a failure if you are using the 32-bit binary firefox package
(<path>www-client/firefox-bin</path>) and if you do not allow memexec (see the
<c>allow_memexec</c> boolean). You will probably find an AVC denial telling you
this exact same thing. If you want to allow just mozilla_t to run execmem, you
can write the following <path>fixmozilla.te</path> module:
</p>

<pre caption="Content of fixmozilla.te">
module fixmozilla 1.0.0;

require {
  type mozilla_t;
  class process execmem;
}

allow mozilla_t self:process { execmem };
</pre>

<p>
This simple policy sais that the module is called <e>fixmozilla</e> with module
version <e>1.0.0</e> (it is wise to update this version every time you update
the content of the module so that you can quickly verify with <c>semodule -l</c>
if the new version is loaded or not). It requires the <e>mozilla_t</e> domain
(if <path>sec-policy/selinux-mozilla</path> isn't installed, loading of this
policy will fail as it will not find the mozilla_t domain) and the
<e>process</e> class with the <e>execmem</e> operation. The policy itself 
(the AVC statement) is to allow the mozilla_t domain to use execmem on its 
own processes.
</p>

<p>
To convert this source into a loadable policy, we first convert it into a
<path>.mod</path> file:
</p>

<pre caption="Converting a .te file to a .mod file">
~$ <i>checkmodule -m -o fixmozilla.mod fixmozilla.te</i>
</pre>

<p>
In this particular command, we create a non-base (<c>-m</c>) module file
(<path>fixmozilla.mod</path>) which contains the statements offered by the
<path>fixmozilla.te</path> file. If you are running an MLS/MCS system you will
need to add the <c>-M</c> option.
</p>

<p>
Next we package this module into a loadable SELinux module:
</p>

<pre caption="Packaging the .mod file to a loadable SELinux module">
~$ <i>semodule_package -o fixmozilla.pp -m fixmozilla.mod</i>
</pre>

<p>
This final module file (<path>fixmozilla.pp</path>) can then be loaded into the
SELinux policy store using <c>semodule -i fixmozilla.pp</c>.
</p>

<p>
Using this relatively simple method, you can create all the policy rules you
want. However, you most likely want to add information on file labeling as
well...
</p>

</body>
</subsection>
<subsection>
<title>Writing an FC File</title>
<body>

<p>
An FC file (<e>File Context</e>) contains the file labels (security contexts)
that should be assigned to particular files. If you structure your modules
correctly, you most likely have policies for particular programs, and you would
like to label the program files and binaries accordingly. This is what the
<path>.fc</path> files are for.
</p>

<p>
Let's take a look at a sample .fc file which contains the various types of
context definitions that are supported:
</p>

<pre caption="Sample .fc file">
/var/.*                   gen_context(system_u:object_r:var_t)
/dev/.*tty[^/]*     -c    gen_context(system_u:object_r:tty_device_t)
/dev/p[fg][0-3]     -b    gen_context(system_u:object_r:removable_device_t)
/vmlinuz.*          -l    gen_context(system_u:object_r:boot_t)
/usr/bin/firefox    --    gen_context(system_u:object_r:mozilla_exec_t)
/tmp/\.ICE-unix/.*  -s    &lt;&lt;none&gt;&gt;
/dev/initctl        -p    gen_context(system_u:object_r:initctl_t)
/mnt(/[^/]*)?       -d    gen_context(system_u:object_r:mnt_t)
</pre>

<p>
The first column (in every line) starts with a regular expression to match
against a file's path. This is usually sufficient to match any possible file.
SELinux does support some special variables like ROLE, HOME_DIR, HOME_ROOT and
USER which are substituted with their corresponding values when the file context
is (re)compiled (for instance when you add or delete SELinux users or rebuild
the policy using <c>semodule</c>).
</p>

<p>
The second column, if available, starts with a dash followed by the file type:
<c>c</c>haracter device, <c>b</c>lock device, symbolic <c>l</c>ink,
<c>s</c>ocket, <c>d</c>irectory, named <c>p</c>ipe or a regular file (<c>-</c>).
</p>

<p>
The last column gives the security context (label) that should be assigned to
the resource(s) that match the regular expression. You should always see the
"standard three" (user, role, domain), but you might also see the security level
and even category if MLS/MCS is used or supported by the module.
</p>

<pre caption="Sample file context with MLS/MCS support">
/usr/tmp    -d  gen_context(system_u:object_r:tmp_t,s0-s15,c0.c255)
</pre>

<p>
You can write your own FC file. For instance, Gentoo adds the following
definition to the <path>sec-policy/selinux-mozilla</path> package to support the
binary firefox package:
</p>

<pre caption="Example .fc content">
/usr/bin/firefox-bin           -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/libxul\.so        -- gen_context(system_u:object_r:textrel_shlib_t,s0)
/opt/firefox/firefox           -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/run-mozilla.sh    -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/firefox-bin       -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/plugin-container  -- gen_context(system_u:object_r:mozilla_exec_t,s0)
</pre>

<p>
If you want to add such a file to your policy, add it during the
<c>semodule_package</c> phase:
</p>

<pre caption="Adding file context information to a policy">
~$ <i>semodule_package -o fixmozilla.pp -m fixmozilla.mod -f fixmozilla.fc</i>
</pre>

<p>
Once this policy is loaded, you can use tools like <c>matchpathcon</c>,
<c>restorecon</c> and more as they now know how to deal with the files you have
mentioned in your file context file.
</p>

</body>
</subsection>
</section>
<section>
<title>Building a Reference Policy Module</title>
<subsection>
<title>Introduction to the Reference Policy</title>
<body>

<p>
Initially we have already covered the fact that Gentoo Hardened bases its
policies on the reference policy maintained by Tresys. This reference policy
offers an important additional functionality during module development:
interfaces.
</p>

<p>
By creating an interface, you actually create a function of some sort which can
be used in other modules. Such interfaces allow module writers to generate rules
to interact with the domain of their module without knowing what the other
domains are. For instance, the mozilla module has an interface definition like
so:
</p>

<pre caption="Example interface definition">
interface(`mozilla_read_user_home_files',`
  gen_require(`
    type mozilla_home_t;
  ')

  allow $1 mozilla_home_t:dir list_dir_perms;
  allow $1 mozilla_home_t:file read_file_perms;
  allow $1 mozilla_home_t:lnk_file read_lnk_file_perms;
  userdom_search_user_home_dirs($1)
')
</pre>

<p>
This interface allows other modules to use the
<c>mozilla_read_user_home_files</c> function if they want their domain to be
able to (in this case) read the files in the mozilla_home_t domain. Of course,
they can add all statements inside their own definition, but then they would
have to require that the mozilla module is loaded, which might be a wrong
assumption, and duplicate the same allow statements for each application.
The use of interfaces makes policy development easier.
</p>

<p>
Also, the reference policy allows the use of <e>optional</e> statements:
a module can call an interface of another module, but this may not fail if
the other module is not available on a users' system.
</p>

<p>
For instance, in the evolution policy:
</p>

<pre caption="Extract from evolution.te">
optional_policy(`
  mozilla_read_user_home_files(evolution_t)
  mozilla_domtrans(evolution_t)
')
</pre>

<p>
In this extract we see that the previously defined interface is called with
argument evolution_t (the Evolution domain) within an <c>optional_policy</c>
clause. As a result, building this policy will attempt to call this interface,
but if the interface is missing (because the mozilla module isn't installed) it
will not fail the build of the evolution module.
</p>

<p>
Using the interfaces allows for a clean separation of the various modules.
Within the reference policy, the following guidelines are used:
</p>

<ul>
  <li>
    Inside a <path>.te</path> file, the only domains that are allowed to be
    mentioned are those defined in the same <path>.te</path> file. Any
    interaction with other domains need to happen through interfaces offered by
    that domain.
  </li>
  <li>
    Inside an <path>.if</path> file, where the interfaces are defined, an XML
    like syntax is used to document each interface, allowing for developers to
    read easily what an interface is meant to do (because honestly, there are
    far more complex interfaces than the one we have previously shown)
  </li>
  <li>
    Distribution-specific aspects of modules should be enclosed within a
    <c>ifdef(`distro_gentoo',`...')</c> statement (example for Gentoo). This
    statement is supported in all three files (<path>.te</path>,
    <path>.if</path> and <path>.fc</path>).
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Building the Reference Policy Module</title>
<body>

<p>
If you want to build a module using the reference policy interfaces, you first
need to create the <path>.te</path> file and, optionally (but most likely
needed) <path>.if</path> and <path>.fc</path> file. It is wise to start from an
example set of files for a similar application. If you want to or need to use
interfaces of different modules, you can find the interfaces that are valid on
your system inside <path>/usr/share/selinux/strict/include</path>.
</p>

<p>
Once you want to build the module, copy the
<path>/usr/share/selinux/strict/include/Makefile</path> file inside the
directory where your policy definition(s) are stored. Then, call the <c>make</c>
command to build the policy modules. 
</p>

<p>
The result should be one (or more) loadable SELinux modules.
</p>

</body>
</subsection>
</section>
<section>
<title>Example: Start Building the Skype Policy</title>
<subsection>
<title>Labelling</title>
<body>

<p>
Let's start to create a sample reference policy based SELinux module for the <c>skype</c>
application. This application is a well-known application used to perform voice-
and video chats across the Internet. We will not finish the module in this
chapter (as the exercise will become a repetitive try-and-correct cycle which
isn't the purpose to document here) but rather show an approach on how to deal
with such policy building exercises.
</p>

<p>
First get acquainted with the application.
</p>

<p>
The usual way of interacting with <c>skype</c> is from an end-user point (not
administrator). From interacting with it in permissive mode (or from a
non-SELinux system) we know it creates a <path>~/.Skype</path> folder for its
configuration, chat history and more.
</p>

<p>
Given this above information, let's take a look at the content of the
<path>net-im/skype</path> package:
</p>

<pre caption="Content of the skype package">
~$ <i>qlist skype</i>
<comment>(Output shortened for clarity)</comment>
/usr/bin/skype
/usr/share/... <comment># Unrelated to the application but used by distribution</comment>
/opt/skype/skype
/opt/skype/sounds/...
/opt/skype/lang/...
/opt/skype/avatars/...
</pre>

<p>
Given this information, we could create the following file context definition:
</p>

<pre caption="Sample file context for skype">
/usr/bin/skype         -- gen_context(system_u:object_r:skype_exec_t,s0)
/opt/skype/skype       -- gen_context(system_u:object_r:skype_exec_t,s0)
HOME_DIR/\.Skype(/.*)?    gen_context(system_u:object_r:skype_home_t,s0)
</pre>

<p>
We will not give the various skype files a specific label - they are all
read-only files so can keep the default label assigned to them.
</p>

<p>
Within the <path>skype.te</path> file, we define the necessary domains and 
also use the first interfaces which are often associated with this kind of
domains (for reasoning you can read the sources for the apache module or 
other services). A sample module to base our definition from could be
telepathy...
</p>

<pre caption="Initial skype module definition">
policy_module(skype, 1.0.0)

type skype_t;
type skype_exec_t;
application_domain(skype_t, skype_exec_t)

type skype_home_t;
userdom_user_home_content(skype_home_t)

# Allow skype_t to put files in the skype_home_t location(s)
manage_dirs_pattern(skype_t, skype_home_t, skype_home_t)
manage_files_pattern(skype_t, skype_home_t, skype_home_t)
userdom_user_home_dir_filetrans(skype_t, skype_home_t, { dir file })
userdom_search_user_home_dirs(skype_t)
</pre>

<p>
Again, we're not going to cover the various interfaces and explain them. They
are documented and available on the system, and there are plenty of examples to
use.
</p>

<p>
Finally, we are going to create an interface to allow users to transition to the
skype_t domain. The idea here is that you add <c>skype_role(role, domain)</c> in
the <path>.te</path> definition of the users' domain or within your own policy.
</p>

<pre caption="Defining the skype_role interface">
interface(`skype_role',`
  gen_require(`
    type skype_t, skype_exec_t;
  ')

  role $1 types skype_t;

  domain_auto_trans($2, skype_exec_t, skype_t)
')
</pre>

<p>
Build the module and load it in the SELinux module store. Next, create a small
policy to allow users (user_r, user_t) to access skype:
</p>

<pre caption="Adding access to skype for users">
~$ <i>cat skypeusers.te</i>
policy_module(skypeusers, 1.0.0)

gen_require(`
  type user_t;
  role user_r;
  type staff_t;
  role staff_r;
')

optional_policy(`
  skype_role(user_r, user_t)
  skype_role(staff_r, staff_t)
')
</pre>

<p>
Build that module as well and load it. A regular SELinux user should now have
the ability to execute skype_exec_t and transition to the skype_t domain.
</p>

</body>
</subsection>
<subsection>
<title>Dry Run</title>
<body>

<p>
With the policy loaded, do a dry run. Relabel the files of the
<path>net-im/skype</path> package (and if you have previously ran skype yourself,
relabel the <path>~/.Skype</path> folder as well), then start <c>skype</c> and both 
watch skype's output as well as the AVC denials.
</p>

<p>
We notice that the binary (skype) hangs and cannot be killed. In the AVC denial
logs, we notice the following denials:
</p>

<pre caption="Shown denials while running skype">
Jan  6 22:01:56 hpl kernel: [18418.420427] type=1400 audit(1294347716.358:2221):
avc:  denied  { read write } for  pid=25540 comm="skype" name="1" dev=devpts
ino=4 scontext=staff_u:staff_r:skype_t tcontext=staff_u:object_r:user_devpts_t
tclass=chr_file
Jan  6 22:01:56 hpl kernel: [18418.420455] type=1400 audit(1294347716.358:2222):
avc:  denied  { use } for  pid=25540 comm="skype" path="/dev/pts/1" dev=devpts
ino=4 scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:staff_t
tclass=fd
Jan  6 22:01:56 hpl kernel: [18418.420563] type=1400 audit(1294347716.358:2225):
avc:  denied  { sigchld } for  pid=6532 comm="bash"
scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:staff_t tclass=process
</pre>

<p>
Note that the attempt is done in enforcing mode - running in permissive mode
will yield more AVC denials and is also a plausible way to create the necessary
rules.
</p>

<p>
From the denials, we see that skype attempts to use the pts in which the command
is ran (notice that this fails because we didn't explicitly allow it) and also
fails to exit properly (a sigchld signal isn't allowed to be submitted).
</p>

<p>
By looking into the example policies already around, we notice that they have
interfaces in use such as <c>userdom_use_user_terminals</c> as well as generic
allowances such as <c>ps_process_pattern</c> (to allow users to view a process
and kill it). This is a nice example of how a type enforcement MAC system works:
nothing is assumed by default.
</p>

</body>
</subsection>
<subsection>
<title>Next Dry Run</title>
<body>

<p>
So after adding some interfaces to allow the use of the user terminals, file
descriptors and also allow process signals to be sent, we try to run the
application again. Now, we get:
</p>

<pre caption="Output of running the skype command">
~$ <i>skype</i>
Killed

~$ <i>cat /var/log/avc.log</i>
Jan  6 22:27:41 hpl kernel: [19961.313321] type=1400
audit(1294349261.991:9089017): avc:  denied  { execmem } for  pid=27256
comm="skype" scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:skype_t
tclass=process
</pre>

<p>
At least <c>skype</c> now exits. From the AVC log, we see that it wants to call
execmem (which isn't something we like, but have seen in the past for mozilla as
well). Okay, let's allow this, rebuild the modules and retry.
</p>

<pre caption="Output of running the skype command again">
~$ <i>skype</i>
./skype: error while loading shared libraries: libasound.so.2: cannot open
shared object file: Permission denied

~$ <i>cat /var/log/avc.log</i>
Jan  6 22:33:41 hpl kernel: [20319.960127] type=1400
audit(1294349621.275:9089042): avc:  denied  { read } for  pid=27536
comm="skype" name="libasound.so.2" dev=dm-1 ino=525098
scontext=staff_u:staff_r:skype_t tcontext=system_u:object_r:usr_t
tclass=lnk_file
</pre>

<p>
Okay, we need to grant it read rights to links within the usr_t domain (and most
likely then load libraries from the lib_t domain, so we need to add
<c>files_read_usr_symlinks</c> and <c>libs_use_ld_so</c>, etc.
</p>

</body>
</subsection>
<subsection>
<title>Finishing Up</title>
<body>

<p>
After running into the standard "can't start" issues, you'll notice that the
application then wants to bind and connect to ports - which are also protected
by SELinux and can be manipulated by various interfaces. It wants to access your
soundcard and webcam, etc.
</p>

<p>
As you can see from the above information, writing policies correctly isn't
easy. You need to constantly keep in mind what you are allowing - aren't you
granting too much? Are you forgetting something? Also, the first time(s) you
create policies it will take lots of time, but over time you will grow better in
it. You'll start realizing what all those standard things are that you need to
allow and what not.
</p>

<p>
Writing SELinux policies isn't hard, but it's far more difficult than setting
the standard Linux permissions on files and directories. It requires a decent
knowledge of how the application behaves and what the SELinux reference policy
interfaces grant when you select them.
</p>

<p>
If you ever feel like writing these policies, don't hesitate to read up on the
various resources at the end of this book.
</p>

</body>
</subsection>
</section>
</sections>
