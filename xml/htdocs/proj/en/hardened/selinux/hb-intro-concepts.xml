<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/hb-intro-concepts.xml,v 1.3 2011/06/07 19:40:20 klondike Exp $ -->

<sections>
<version>4</version>
<date>2011-05-03</date>

<section>
<title>Introduction</title>
<subsection>
<title>SELinux Concepts</title>
<body>

<p>
Since SELinux is a MAC system, you should already figure out that managing
SELinux-based permissions and rights might be a bit more challenging than 
managing the discretionary access control rights generally used on a Linux
system. What is more is that SELinux works <b>on top of</b> the DAC system
everybody is used from Linux. As a system administrator, you will need to be
acquainted with some of the concepts and structures that SELinux has put in
place in order to manage the access on the SELinux system.
</p>

<p>
Describing those concepts is the purpose of this particular chapter. We will
give examples on the various concepts from a SELinux enabled Gentoo Hardened
system. However, do not fear if the use of particular commands is not explained
sufficiently. They are currently meant as examples (their output is more
important) and will be discussed further in this document.
</p>

</body>
</subsection>
</section>
<section>
<title>Security Contexts</title>
<subsection>
<title>Users, Roles and Domains</title>
<body>

<p>
One of the first concepts you will need to be acquainted with is the concept of
a <e>security context</e>. This is a state given to a resource that uniquely
identifies which grants (permissions) are applicable to the resource. This
context is extremely important for SELinux as it is the definition on which it
bases its permissions (grants or denials). When a resource has no security
context assigned, SELinux will try to give it a default security context which -
in the spirit of lowest privilege - has little permissions to perform any actions.
</p>

<p>
Within SELinux, such a security context is displayed using three definitions:
</p>

<dl>
  <dt>user</dt>
  <dd>
    This is the <e>SELinux user</e> (which is not the same as the Linux/Unix
    technical user) assigned to the resource
  </dd>
  <dt>role</dt>
  <dd>
    This is the SELinux role in which the resource currently works
  </dd>
  <dt>type</dt>
  <dd>
    This is the type assigned to the resource and is the key to SELinux'
    enforcement rules
  </dd>
</dl>

<p>
More information on these particular definitions is given throughout the
remainder of this chapter. 
</p>


<p>
As an example let's take a look at the security context of a logged on user:
</p>

<pre caption="Getting the security context of a logged on user">
~$ <i>id -Z</i>
staff_u:staff_r:staff_t
</pre>

<p>
In this case, the user is identified as the SELinux user <e>staff_u</e>,
currently in the <e>staff_r</e> role and assigned to the <e>staff_t</e>
type. The actions the user is allowed to do are based upon this security
context. 
</p>

</body>
</subsection>
<subsection>
<title>Access Control Policy</title>
<body>

<p>
As mentioned before, these security contexts are used as the base for the
permission rules. What SELinux does is check the security context of the source
(for instance a process) and the destination (for instance a file that that
process wants to read). It then checks if the requested operation (read) is
allowed between those two contexts. Keep in mind though that SELinux works on
top of the standard permission system used by Linux. If a process is not able to
read a file to begin with, SELinux is not even consulted.
</p>

<p>
Now, where the security context defines the state of a resource, we have not
spoken about the resources themselves. Within SELinux, the resource types are
defined as <e>object classes</e>. Common examples are <e>file</e> or <e>dir</e>,
but SELinux also manages classes such as <e>filesystem</e>, <e>tcp_socket</e>,
<e>process</e>, <e>sem</e> (semaphores) and more.
</p>

<p>
On each object class, a set of <e>permissions</e> is declared which are possible
against a resource within this object class. For instance, the <e>process</e>
object class supports at least the following permissions:
</p>

<pre caption="Supported permissions against a 'process' resource">
~# <i>ls /selinux/class/process/perms</i>
dyntransition  getcap      rlimitinh     setpgid        siginh
execheap       getpgid     setcap        setrlimit      sigkill
execmem        getsched    setcurrent    setsched       signal
execstack      getsession  setexec       setsockcreate  signull
fork           noatsecure  setfscreate   share          sigstop
getattr        ptrace      setkeycreate  sigchld        transition
</pre>

<p>
Let's take a look at a small example to explain the permission rules and how 
SELinux uses them. The example user is in the <e>staff_u:staff_r:staff_t</e>
context and wants to write to its own home directory. As we can expect, this
should be allowed. Don't worry about the commands here, we'll discuss them more
properly further in this document.
</p>

<pre caption="Seeing if a user can write to its own home directory">
<comment>(Show the security context for the users' home directory)</comment>
~$ <i>ls -dZ ${HOME}</i>
staff_u:object_r:user_home_dir_t  /home/swift

<comment>(Find the allow-rule which allows the staff_t type to write into a 
 directory with the user_home_dir_t type)</comment>
~$ <i>sesearch -s staff_t -t user_home_dir_t -c dir -p write -A</i>
Found 1 semantic av rules:
  allow staff_t user_home_dir_t : dir { ioctl read write create ... };
</pre>

<p>
As expected, the security context of the user (to be more specific, the domain
in which it resides) has write access to the domain of the target's directories.
The notion of <e>domain</e> is frequently used in SELinux documentation and
refers to the type assigned to a process. BTW, as files do not have roles, 
they are given the default <e>object_r</e> role by SELinux.
</p>

<p>
Now take a look at the following example. Our user, who is inside the portage
group, wants to write to the <path>/var/tmp/portage</path> directory:
</p>

<pre caption="Seeing if a user can write to the /var/tmp/portage directory">
~$ <i>id -a</i>
uid=1001(swift) gid=100(users) groups=100(users),...,250(portage),...
~$ <i>ls -ldZ /var/tmp/portage</i>
drwxrwxr-x. 3 portage portage  system_u:object_r:portage_tmp_t 4096 Dec  6 21:08 /var/tmp/portage
</pre>

<p>
From the standard Linux permissions, the user has write access. But does SELinux
also grant it?
</p>

<pre caption="Trying to write into /var/tmp/portage">
~$ <i>sesearch -s staff_t -t portage_tmp_t -c dir -p write -A</i>
~$ 
<comment>(Notice that there is no output given here)</comment>
~$ <i>touch /var/tmp/portage/foo</i>
touch: cannot touch '/var/tmp/portage/foo': Permission denied
</pre>

<p>
As SELinux could not find a rule that allows the staff_t domain to write to any 
directory labeled with the portage_tmp_t type, the permission was denied.
</p>

</body>
</subsection>
</section>
<section>
<title>Type Enforcements / Domain Types</title>
<subsection>
<title>Types and Domains</title>
<body>

<p>
To explain how the permission rules work and how this is enforced through the
security contexts, let's start from the last definition in the context (the
<e>type</e>) and work our way forward through the roles and users.
</p>

<ul>
  <li>
    A <e>SELinux type</e> is a particular label assigned to a resource. The
    <c>passwd</c> command for instance is labeled with the passwd_exec_t type.
  </li>
  <li>
    A <e>SELinux domain</e> is the security state of a process and identifies the rights 
    and permissions it has. It is most often referred to by its type declaration.
    For instance, for a running <c>passwd</c> command, its domain is passwd_t.
  </li>
</ul>

<p>
The rules that identify the allowed actions for a domain have the following
syntax:
</p>

<pre caption="Standard SELinux policy rules">
allow &lt;src_domain&gt; &lt;dst_type&gt; : &lt;class&gt; { permission [ permission [ ... ] ] } ;
</pre>

<p>
An example for the <e>passwd_t</e> domain would be the permissions granted
between the <e>passwd_t</e> domain and the <e>shadow_t</e> type (used by the
<path>/etc/shadow</path> file).
</p>

<pre caption="Grants between passwd_t and shadow_t">
allow passwd_t shadow_t : file { ioctl read write create ... } ;
</pre>

<p>
This permission syntax is very powerful, but also difficult. To have a secure
system where normal behavior is allowed, you need to seriously fine-tune these
rules for each and every application (and thus domain) that your system wants to
host. Giving too broad permissions to a domain on a particular type might result
in unauthorized activity being granted. Giving too few permissions might result 
in loss of efficiency or even effectiveness.
</p>

<p>
To support easier grant rules, SELinux allows grouping of types using type
attributes. For instance, the attribute <e>exec_type</e> bundles all types 
that are assigned to executable files (such as <e>bin_t</e>, <e>ssh_exec_t</e>,
...), whereas the <e>file_type</e> attribute bundles all types that are
assigned to regular files. Although this can simplify rule management, it makes
it easier to grant too many permissions.
</p>

</body>
</subsection>
<subsection>
<title>Domain Transitions</title>
<body>

<p>
So far for types, domain definitions and their permissions. We have stated before
that permissions are based on the domain in which a process resides. But how
does a process become part of the domain? You might think that this happens by
default (starting the <c>passwd</c> command would automatically bring the
process in the <e>passwd_t</e> domain), but this is in fact a combination of
three specific privileges that need to be granted:
</p>

<ol>
  <li>
    The current domain must be allowed to transition to a domain
  </li>
  <li>
    The target domain should have an <e>entry point</e>, which is an executable
    that is allowed to start in the domain
  </li>
  <li>
    The source domain should have <e>execute</e> rights on (the domain of) that 
    executable
  </li>
</ol>

<impo>
Not being allowed to transition does not mean that you cannot
execute the binary. The binary can still be executed, but will not run inside
the target domain. Instead, it will inherit the domain of the executor and hence
the rights and permissions of this domain.
</impo>

<p>
Through these rules, the security administrator of a system can more
specifically control who and under which conditions particular actions can be
taken.
</p>

</body>
</subsection>
</section>
<section>
<title>Roles and Rights</title>
<subsection>
<title>The Role of a Role</title>
<body>

<p>
The previously discussed domains and domain rules is quite powerful. However,
this is not where SELinux stops. After all, you want to be able to deny access
towards particular domains from unauthorized users. One requirement is of course
not to allow transitions from the user domain to that restricted domain, but how
can you enforce one set of users to be allowed and another to be denied?
</p>

<p>
Enter the roles. By using roles, you can tell SELinux which domains are allowed
for a role and which aren't. An example would be the <e>ifconfig_t</e> domain.
This domain has the rights to change the networking interface definitions - not
something you want to allow your users. And in fact, if you would verify,
SELinux does not allow the user role <e>user_r</e> to be assigned with the
<e>ifconfig_t</e> domain.
</p>

<pre caption="ifconfig_t domain and user_r versus sysadm_r">
~$ <i>seinfo -ruser_r -x</i>
  user_r
    Dominated Roles:
      user_r
    Types:
      ...
~$ <i>seinfo -rsysadm_r -x</i>
  sysadm_r
    Dominated Roles:
      sysadm_r
    Types:
      ...
      ifconfig_t
      ...
</pre>

<impo>
Again, not being able to be associated with a domain does not mean that the
<e>user_r</e> role cannot <e>execute</e> the <c>ifconfig</c> binary. It can, but
it will execute the binary within its own domain (<e>user_t</e>) and as such
will not have the rights to manipulate the networking interface (but will still
be able to read the interface information albeit with limited output).
</impo>

<p>
Roles are often used in access control systems to group permissions to a single
functional set (the role) which can then be assigned to individuals (accounts). 
For instance, such access control systems create roles for accountants, 
operators, managers, ... and grant the appropriate privileges to these roles.
Then, their users are assigned one (or sometimes multiple) roles and the users
inherit the permissions assigned to these roles.
</p>

<p>
With SELinux, the idea remains the same (use roles to functionally differentiate
privileges) but is implemented differently: roles are assigned target domains
in which a role is allowed to "be in". The permissions remain assigned to the
domains.
</p>

</body>
</subsection>
<subsection>
<title>Role Transitions</title>
<body>

<p>
Users (and processes) have the ability to switch roles. This is allowed by
SELinux, but of course only when the switch itself is granted. By default,
the SELinux policy used by Gentoo Hardened offers five roles on a SELinux 
system:
</p>

<dl>
  <dt>object_r</dt>
  <dd>
    The <e>object_r</e> role is the only role by default available through
    SELinux. It is usually only assigned to resources where roles have no
    benefit or value (such as files and directories).
  </dd>
  <dt>system_r</dt>
  <dd>
    The <e>system_r</e> role is used for highly privileged system services. 
    The <e>system_r</e> role is allowed to switch to any other "default" role. 
    No role exception <e>sysadm_r</e> can switch to the <e>system_r</e> role.
  </dd>
  <dt>sysadm_r</dt>
  <dd>
    The <e>sysadm_r</e> role is used for system administration activities. The
    <e>sysadm_r</e> role is allowed to switch to any other "default" role. Only
    the <e>system_r</e> and <e>staff_r</e> roles are allowed to switch to the
    <e>sysadm_r</e> role.
  </dd>
  <dt>staff_r</dt>
  <dd>
    The <e>staff_r</e> role is used for system operators who might have the
    rights to perform system administration tasks. The <e>staff_r</e> role is
    only allowed to switch to the <e>sysadm_r</e> role. Only <e>sysadm_r</e> and
    <e>system_r</e> can switch to the <e>staff_r</e> role.
  </dd>
  <dt>user_r</dt>
  <dd>
    The <e>user_r</e> role is used for standard, unprivileged users. It is not
    allowed to transition towards any other role; only <e>sysadm_r</e> and
    <e>system_r</e> roles are allowed to switch to the <e>user_r</e> role.
  </dd>
</dl>

<note>
A "default" role is any of <e>user_r</e>, <e>staff_r</e>, <e>sysadm_r</e> or
<e>system_r</e>. If you create additional roles yourself, they are not part of
the "default" roles.
</note>

<p>
Using these definitions, a user inside the <e>user_r</e> role will never be able
to execute <c>ifconfig</c> within the <e>ifconfig_t</e> domain. The use of the
word <e>never</e> here is important: not even if the user is able to become
root using <c>sudo</c> or any other command will he be able to run the
<c>ifconfig</c> command in the <e>ifconfig_t</e> domain because, even after
running <c>sudo</c>, he is still inside the <e>user_r</e> role.
</p>

</body>
</subsection>
<subsection>
<title>SELinux Users</title>
<body>

<p>
A SELinux user is not the same as the Linux user. Whereas standard Linux user
accounts can be switched using commands such as <c>su</c> or <c>sudo</c>, a
SELinux user can not be changed. Even when you successfully execute <c>sudo</c>,
your SELinux user will remain the same.
</p>

<p>
When you look at a SELinux powered system, you might notice that that system
doesn't use many SELinux users. For instance, Gentoo Hardened's default setup
defines the users <e>root</e>, <e>user_u</e>, <e>staff_u</e>, <e>sysadm_u</e> and
<e>system_u</e> and some systems never introduce any other SELinux user. But if
that is the case, is the above advantage of SELinux users (once a user is logged
on, he cannot change his SELinux user) the only one?
</p>

<p>
Well, no. SELinux users are also used to categorize accounts which have the 
permission to use a particular role.
</p>

<pre caption="SELinux users and their associated roles">
~# <i>semanage user -l</i>
SELinux User    SELinux Roles

root            staff_r sysadm_r
staff_u         staff_r sysadm_r
sysadm_u        sysadm_r
system_u        system_r
user_u          user_r
</pre>

<p>
Standard Linux users are mapped to these SELinux users:
</p>

<pre caption="Linux users and their SELinux user mappings">
~# <i>semanage login -l</i>
Login Name          SELinux User

__default__         user_u
root                root
swift               staff_u
</pre>

<p>
In this example, only logins of the Linux user <e>swift</e> (through 
<e>staff_u</e>) and <e>root</e> (through the <e>root</e> SELinux user) 
will be able to eventually run inside the <e>sysadm_r</e> role. All other
Linux accounts will be by default mapped to the <e>user_u</e> user (and 
this <e>user_r</e> role).
</p>

<p>
This is <e>only</e> applicable for interactive logins. Processes that are
launched through an init script or otherwise do not automatically become part of
the SELinux user <e>user_u</e>: depending on the security context of whatever
process is starting them, they can become anything. Of course, if the security
context of the process that is starting them is <e>user_u:user_r:user_t</e> then
they will not be able to transform into anything other than
<e>user_u:user_r:*</e> with <e>*</e> a domain supported by the <e>user_r</e>
role.
</p>

<p>
SELinux users are also used to implement <e>User Based Access Control</e> or
<e>UBAC</e>. This SELinux functionality allows for domains to be SELinux user
aware: a process running in the context of a particular SELinux user can then -
for instance - only work with files of the same SELinux user. This offers a
finer grained access method, because that process might run within a domain
which has write access to the domain of the file, but can still not write to the
file because the SELinux users' differ.
</p>

<p>
At this moment, Gentoo Hardened SELinux' supports both policies with and
without UBAC. This is controlled through the <c>ubac</c> USE flag.
</p>

</body>
</subsection>
</section>
<section>
<title>Multi Level Security / Multi Category Security</title>
<subsection>
<title>Introduction</title>
<body>

<p>
Next to the type enforcement feature, SELinux also offers MLS and MCS support.
This allows administrators to define a hierarchical confidentiality policy.
For instance, you can ensure that a user or process within a certain
security domain and level can write to files with the same level (or higher), or
read files with the same level (or lower), but not write files to a lower level.
This allows administrators to implement some sort of 
public/internal/confidential/strictly confidential hierarchical security level
for files.
</p>

<p>
Although implementation of MLS is possible with the type enforcement rules we
have previously explained, it would lead to an unmanageable collection of types
and permissions. The MLS implementation simplifies this.
</p>

<p>
At this moment, the Gentoo Hardened SELinux handbook does not cover MLS/MCS, but
this might (and probably will) change in the future.
</p>

</body>
</subsection>
</section>
<section>
<title>Next Steps</title>
<subsection>
<title>What Next</title>
<body>

<p>
It might be difficult to understand now, but the concepts are important because,
if something fails on your system when SELinux is enabled, but it doesn't fail
when SELinux is disabled, then you will need to dive into the security contexts,
rules, types and domain transitions to find out why.
</p>

<p>
The next chapter in line will discuss how distributions such as Gentoo Hardened
manage the various permission rules and how they use a macro language to
generate the permissions instead of creating the allow-rules one by one.
</p>

</body>
</subsection>
</section>
</sections>
