<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/proj/en/hardened/index.xml">
<title>Hardened Gentoo</title>
<subtitle>SELinux Policy Overview</subtitle>
<author title="Author">
   <mail link="pebenito@gentoo.org">Chris PeBenito</mail>
</author>
<abstract>
The SELinux policy describes the access permissions for the entire system.
</abstract>

<version>1.1</version>
<date>19 September 2003</date>

<chapter><title>SELinux Types</title>
<section><body>
<p>
   A type is a security attribute given to objects such as files, and network
   ports, etc.  The type of a process is commonly referred to as its domain.
   The SELinux policy is primarily composed of type enforcement rules, which
   describe how domains are allowed to interact with objects, and how domains
   are allowed to interact with other domains.  A type is generally suffixed
   with a &#39;_t&#39;, such as <i>sysadm_t</i>.  This is the most important
   attribute for a process or object, as most policy decisions are based on
   the source and target types.
</p>
</body></section>

</chapter>

<chapter><title>SELinux Roles</title>

<section><body>
<p>
   A role describes the set of functions a user can use.  In SELinux terms,
   the domains that a user can directly access is determined by their role.
   For example, a system administrator that is using the system for regular
   user tasks should not be running in the <i>sysadm_r</i> role, but in the
   <i>user_r</i> role.  If they need to administrate the system, then a role
   change to <i>sysadm_r</i> is required.  A role is generally suffixed with
   a &#39;_r&#39;, such as <i>portage_r</i>.
</p>
</body></section>

</chapter>

<chapter><title>SELinux Identities</title>

<section><title>What is a SELinux Identity?</title><body>
<p>
   The SELinux identity is similar to a Linux username.  The change of identity
   should be limited to very specific cases, since the role-based access control
   relies on the SELinux identity.  Therfore, in general, a user&#8217;s SELinux
   identity will not change during a session.  The user ID in Linux can be
   changed by set(e)uid, making it inappropriate for a SELinux identity.
   If a user is given a SELinux identity, it must match the Linux username.  If a user
   has no specifed SELinux identity, they will be given the generic 
   <i>user_u</i> identity.  Each SELinux identity is allowed a set of roles.
</p>
</body></section>

<section><title>Configuring up SELinux Identities</title><body>
<p>
   SELinux identities are contained in the users file in the policy directory.
   The syntax for the file is simple.  For example, to allow the user
   <i>pebenito</i> the roles <i>staff_r</i> and <i>sysadm_r</i>, add to the end of
   the file something like:
</p>
<pre>user pebenito roles { staff_r sysadm_r };</pre>
<p>
   Then load the policy.  There must also be a Linux username <i>pebenito</i>.
   If a user does not have a <i>user</i> line in the file, their identity will
   be <i>user_u</i>, and only be allowed the <i>user_r</i> role.
</p>

<impo>
   Normal users that have identities should be allowed <i>user_r</i>, not
   <i>staff_r</i>. Administrators should be allowed <i>staff_r</i> and 
   <i>sysadm_r</i>.  All users must be allowed <i>user_r</i> or
   <i>staff_r</i> otherwise they will be unable to log in remotely.
</impo>

<p>
   When giving a user an identity their home directory and contents should also be
   appropriately labeled.  The file <i>users.fc</i> in the file_contexts directory
   should be modified.  For example, the normal user <i>method</i> and the
   administrator <i>pebenito</i> would be labeled:
</p>

<pre>
/home/method           -d      method:object_r:user_home_dir_t
/home/method/.*                method:object_r:user_home_t
/home/method/\.ssh(/.*)?       method:object_r:user_home_ssh_t
 
/home/pebenito         -d      pebenito:object_r:staff_home_dir_t
/home/pebenito/.*              pebenito:object_r:staff_home_t
/home/pebenito/\.ssh(/.*)?     pebenito:object_r:staff_home_ssh_t
</pre>

</body></section>

</chapter>

<chapter><title>SELinux Contexts</title>
<section><body>
<p>
   Using the above three security models together is called a SELinux
   context.  A context takes the form <i>identity</i>:<i>role</i>:<i>type</i>.
   Each context in the system is represented in the kernel by a security
   ID (SID).  The SELinux context is the most important value for determining
   access.
</p>
</body></section>

<section><title>Object Contexts</title><body>
<p>
   A typical <i>ls --context</i> may have an output similar to this:
</p>
<pre>
drwxr-xr-x  root     root     system_u:object_r:bin_t          bin
drwxr-xr-x  root     root     system_u:object_r:boot_t         boot
drwxr-xr-x  root     root     system_u:object_r:device_t       dev
drwxr-xr-x  root     root     system_u:object_r:etc_t          etc
</pre>
<p>
   The first three columns are the typical linux permissions, user and group.
   The fourth column is the file or directory&#39;s security context.  Objects
   are given the generic <i>object_r</i> role.  From the other two fields of
   the context, it can be seen that the files are in the system identity,
   and have four different types, <i>bin_t</i>, <i>boot_t</i>, <i>device_t</i>,
   and <i>etc_t</i>.
</p>
</body></section>

<section><title>Process Contexts</title><body>
<p>
   A typical <i>ps ax --context</i> may have an output similar to this:
</p>
<pre>
  PID CONTEXT                                  COMMAND
    1 system_u:system_r:init_t                 [init]
    2 system_u:system_r:kernel_t               [keventd]
    3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
    4 system_u:system_r:kernel_t               [kswapd]
    5 system_u:system_r:kernel_t               [bdflush]
    6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t              [syslog-ng]
  712 system_u:system_r:httpd_t                [apache]
  791 system_u:system_r:sshd_t                 [sshd]
  814 system_u:system_r:crond_t                [cron]
  826 system_u:system_r:getty_t                [agetty]
  827 system_u:system_r:getty_t                [agetty]
  828 system_u:system_r:getty_t                [agetty]
  829 system_u:system_r:getty_t                [agetty]
  830 system_u:system_r:getty_t                [agetty]
  831 system_u:system_r:httpd_t                [apache]
  832 system_u:system_r:httpd_t                [apache]
  833 system_u:system_r:httpd_t                [apache]
23093 system_u:system_r:sshd_t                 [sshd]
23095 user_u:user_r:user_t                     [bash]
23124 system_u:system_r:sshd_t                 [sshd]
23126 user_u:user_r:user_t                     [bash]
23198 system_u:system_r:sshd_t                 [sshd]
23204 user_u:user_r:user_t                     [bash]
23274 system_u:system_r:sshd_t                 [sshd]
23275 pebenito:staff_r:staff_t                 [bash]
23290 pebenito:staff_r:staff_t                 ps ax --context
</pre>
<p>
   In this example, the typical process information is displayed, in addition
   to the process&#39;s context.  By inspection, all of the system&#39;s kernel
   processes and daemons run under the <i>system_u</i> identity, and
   <i>system_r</i> role.  The individual domains depend on the program.
   There are a few users logged in over ssh, using the generic <i>user_u</i>
   identity.  Finally there is a user with the identity <i>pebenito</i> logged in
   with the <i>staff_r</i> role, running in the <i>staff_t</i> domain.
</p>
</body></section>

</chapter>

<chapter>
<title>SELinux Policy Files</title>
<section><body>
<p>
   The SELinux policy usually resides in <i>/etc/security/selinux/src/policy</i>.
   It is comprised of several files and directories for generating the policy.
   For easing the creation of the policy, macros from the m4 text processor
   are used to reuse common rules.  The policy files are processed
   by m4, and then the policy compiler <i>checkpolicy</i> verifies that
   there are no syntactic errors, and creates a binary policy file.  The binary
   policy then can be loaded into a running SELinux kernel.
</p>
</body></section>
<section><title>Makefile</title><body>
<p>
   The policy Makefile handles the compiling and installation of policy.  It
   has five targets of interest.
</p>
<table>
<tr><th>Command</th><th>Description</th></tr>
<tr><ti>make policy</ti>
    <ti>Compiles the current policy into the binary policy file.</ti></tr>
<tr><ti>make install</ti>
    <ti>Compiles and installs the current policy into the /etc/security/selinux/src directory.</ti></tr>
<tr><ti>make load</ti>
    <ti>Compile, install, and load the current policy into the current running kernel.</ti></tr>
<tr><ti>make initrd</ti>
    <ti>Compile, install, and create an initial ramdisk for the initial policy load.</ti></tr>
<tr><ti>make relabel</ti>
    <ti>Relabels the filesystems using the file contexts in the policy.</ti></tr>
</table>
</body></section>

<section><title>assert.te</title><body>
<p>
   The rules in this file will be checked in the final phase of
   compilation.  If a permission granted in the policy matches one of
   these assertions, the policy compiler will reject the policy.  This can
   aid in ensuring certain accesses are never allowed.
</p>
</body></section>

<section><title>attrib.te</title><body>
<p>
   A type attribute can be used to identify a set of types with a similar
   property.  Each type can have any number of attributes, and each
   attribute can be associated with any number of types.  Attributes are
   explicitly declared in this file, and can then be associated with particular
   types in type declarations.  Attribute names can then be used throughout
   the configuration to express the set of types that are associated with
   the attribute.
</p>
</body></section>

<section><title>constraints</title><body>
<p>
   This file defines additional constraints on permissions
   in the form of expressions that must be satisfied in order
   for specified permissions to be granted.  These constraints
   are used to further refine the type enforcement tables and
   the role allow rules.  Typically, these constraints are used
   to restrict changes in user identity or role to certain domains.
</p>
</body></section>

<section><title>domains/</title><body>
<p>
   This directory contains the type enforcement rules.  This directory contains
   the files <i>admin.te</i>, <i>staff.te</i>, and <i>user.te</i>, which
   contain the access vectors for the <i>sysadm_r</i>, <i>staff_r</i>, and 
   <i>user_r</i> roles.  The <i>program/</i> directory consists of all of the
   active policies for various programs and daemons.  The <i>misc/</i> directory
   contains all other policy files.
</p>
</body></section>

<section><title>file_contexts/</title><body>
<p>
   This directory contains the files that describe the security contexts
   for all files on persistent filesystems.  It contains the file <i>types.fc</i>
   which has all of the security contexts for the general system, and the
   file <i>users.fc</i> which has the security contexts for home directories
   of users that have SELinux identities.  The directory <i>program/</i>
   contains the security contexts for the daemons in the <i>domains/program/</i>
   directory.  These are one-to-one mapped; for example, the
   domains/program/syslogd.te policy file corresponds to the
   file_contexts/program/syslogd.fc security contexts file.
</p>
</body></section>

<section><title>flask/</title><body>
<p>
   This directory contains contains configuration files independent of the
   policy.  These files contain definitions corresponding to definitions
   in the kernel headers.  These files <e>should not</e> be modified.
</p>
</body></section>

<section><title>fs_use</title><body>
<p>
   This file describes the labelling behavior for files on various filesystem
   types.  For example, ext3 uses persistent labelling, while tmpfs uses
   transitional security IDs.  In general, this file should <e>not</e>
   need to be modified.
</p>
</body></section>

<section><title>genfs_contexts</title><body>
<p>
   This file contains the security contexts for files in a filesystem that
   do not support persistent file labels, such as <i>/proc</i>.
</p>
</body></section>

<section><title>initial_sid_contexts</title><body>
<p>
   This file contains the initial context for each security ID.  In general,
   this file should <e>not</e> need to be modified.
</p>
</body></section>

<section><title>macros/</title><body>
<p>
   This directory contains the m4 macros used to ease creation and maintenance
   of the policy.  It contains the macro file <i>admin_macros.te</i> for
   describing administration domains, such as <i>sysadm_t</i>.  The
   <i>user_macros.te</i> contains macros used in user domains such as <i>user_t</i>
   and <i>staff_t</i>.  The <i>global_macros.te</i> contains macros used throughout
   the entire policy.
</p>
</body></section>

<section><title>mls</title><body>
<p>
   This file contains the configuration for SELinux multi-level security.
   Multi-level Security is experimental, and is not supported by Gentoo.
</p>
</body></section>

<section><title>net_contexts</title><body>
<p>
   This file defines the security contexts of network objects such as ports,
   interfaces, and nodes.  This will need to be modified if daemons run on
   nonstandard ports.
</p>
</body></section>

<section><title>rbac</title><body>
<p>
   This file contains the role-based access control rules.  It describes
   the base allowed role transitions.  Additional transitions are allowed
   in the type enforcement files, especially <i>user.te</i> and <i>staff.te</i>.
</p>
</body></section>

<section><title>tmp/</title><body>
<p>
   This directory is used for holding intermediate files when compiling the
   policy.  It can be safely removed, if needed.
</p>
</body></section>

<section><title>types/</title><body>
<p>
   This directory contains files for declaring general types of the system
   which do not appear in the individual program policies.
</p>
</body></section>

<section><title>users</title><body>
<p>
   This file describes the SELinux identities, and the roles they can enter.
</p>
</body></section>
</chapter>

<chapter>
<title>Policy Kernel Messages</title>
<section><body>
<p>
   While a system is running, a program or user may attempt to do something
   that violates the security policy.  If the system is enforcing the policy,
   the access will be denied, and there will be a message in the kernel log.
   If the system is not enforcing (permissive mode), the access will be allowed,
   but there will still be a kernel message.
</p>
</body></section>

<section><title>AVC Messages</title><body>
<p>
   Most kernel messages from SELinux come from the access vector cache (AVC).
   Understanding denials is important to understand if an attack is happening,
   or if the program is requiring unexpected accesses.  An example denial
   may look like this:
</p>

<pre caption="Example AVC Message">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
   While most AVC messages are denials, occasionally there might be an audit
   message for an access that was granted:
</p>
<pre caption="Example AVC Message 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>
<p>
   In this case, the ability to load the policy was granted.  This is a critical
   security event, and thus is always audited.  Another event that is always
   audited is switching between enforcing and permissive modes.
</p>

<p>
   SELinux will supress logging of denials if many are received in a short
   amount of time.  However, This does not always imply there is an attack
   in progress.  A program may be doing something that could cause
   many denials in a short time, such as doing a stat() on device nodes in
   /dev.  To protect from filling up the system logs, SELinux has rate limiting
   for its messages:
</p>

<pre caption="Example AVC Message 3">
AVC: 12 messages suppressed.
</pre>

<p>
   The policy would have to be modified to not audit these accesses if they
   are normal program behavior, but still need to be denied.
</p>

</body></section>
</chapter>

<chapter><title>Dissecting a Denial</title>
<section><body>
<p>
   Denials contain varying amounts of information, depending on the access type.
</p>

<pre caption="Example Denials">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
   The most common denial relates to access of files.  For better understanding,
   the first denial message will be broken down:
</p>
<table>
<tr><th>Component</th><th>Description</th></tr>
<tr><ti>avc:  denied</ti>
    <ti>SELinux has denied this access.</ti></tr>
<tr><ti>{ lock }</ti>
    <ti>The attempted access is a lock.</ti></tr>
<tr><ti>pid=28341</ti>
    <ti>The process ID performing this access is 28341.</ti></tr>
<tr><ti>exec=/sbin/agetty</ti>
    <ti>The full path and name of the process&#39;s executable is /sbin/agetty.</ti></tr>
<tr><ti>path=/var/log/wtmp</ti>
    <ti>The path and name of the target object is /var/log/wtmp.  Note: a complete
        path is not always available.</ti></tr>
<tr><ti>dev=03:03</ti>
    <ti>The target object resides on device 03:03 (major:minor number).
        On 2.6 kernels this may resolve to a name, hda3 in this example.</ti></tr>
<tr><ti>ino=475406</ti>
    <ti>The inode number of the target object is 475406.</ti></tr>
<tr><ti>scontext=system_u:system_r:getty_t</ti>
    <ti>The context of the program is system_u:system_r:getty_t.</ti></tr>
<tr><ti>tcontext=system_u:object_r:var_log_t</ti>
    <ti>The context of the target object is system_u:object_r:var_log_t.</ti></tr>
<tr><ti>tclass=file</ti>
    <ti>The target object is a normal file.</ti></tr>
</table>

<p>
   Not all AVC messages will have all of these fields, as shown in the other
   two denials.  The fields vary depending on the target object&#39;s class.
   However, the most important fields: access type, source and target contexts,
   and the target object&#39;s class will always be in an AVC message.
</p>
</body></section>

<section><title>Understanding the Denial</title><body>
<p>
   Denials can be very confusing since they can be triggered for several reasons.
   The key to understanding what is happening is to know the behavior of the
   program, and to correctly interpret the denial message.  The target is not
   limited to files; it could also be related to network sockets,
   interprocess communications, or others.
</p>
<p>
   In the above example, the agetty is denied locking of a file.  The file&#39;s type
   is var_log_t, therefore it is implied that the target file is in /var/log.
   With the extra information from the path= field in the denial message, it is
   confirmed to be the file /var/log/wtmp.  If path information was unavailable,
   this could be further confirmed by searching for the inode.  Wtmp is a file that has
   information about users currently logged in, and agetty handles logins on
   ttys.  It can be concluded that this is an expected access of agetty, for
   updating wtmp.  However, why is this access being denied?  Is there a flaw
   in the policy by not allowing agetty to update wtmp?  It turns out that wtmp
   has the incorrect context.  It should be system_u:object_r:wtmp_t, rather
   than system_u:object_r:var_log_t.
</p>
<p>
   If this access was not understood, an administrator might mistakenly allow getty_t
   read/write access to var_log_t files, which would be incorrect, since agetty
   only needs to modify /var/log/wtmp.  This underscores how critical keeping
   file contexts consistent is.
</p>
</body></section>
</chapter>

<chapter><title>References</title>
<section><body>
<p>
   <uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
   SELinux Policy README
</p>
</body></section>
</chapter>

</guide>
