<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/java/Attic/java-upgrade.xml,v 1.16 2006/07/24 22:42:18 nichoj Exp $ -->

<guide link="/proj/en/java/java-upgrade.xml" lang="en">
<title>Gentoo Java Upgrade Guide</title>

<author title="Author">
  <mail link="nichoj@gentoo.org">Joshua Nichols</mail>
</author>
<author title="Author">
  <mail link="kartk@gentoo.org">Karl Trygve Kalleberg</mail>
</author>
<author title="Editor">
  <mail link="nightmorph@gentoo.org">Josh Saddler</mail>
</author>

<abstract>
This guide shows you how to upgrade Java to the new generation of Java on
Gentoo, along with related concepts and tools.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0.8</version>
<date>2006-07-24</date>

<chapter>
<title>Before you start</title>
<section>
<body>

<p>
Here are some terms you might find useful before starting.
</p>

<dl>
  <dt>Generation</dt>
  <dd>
    <ul>
      <li>
	This is a new concept. The idea is that a generation is a set of tools
	and eclasses for building Java packages. So at some point, we begin
	migrating from the existing generation to a new one. During this time,
	both generations coexist. So, for example, you would have a system vm
	set for Generation X <e>and</e> a system vm for Generation X+1. By
	doing this, packages that use Generation X and Generation X+1 can
	coexist while migrating to the new generation.
      </li>
    </ul>
  </dd>
  <dt>Generation 1</dt>
  <dd>
    <ul>
      <li>
	This generation consists of the existing java-pkg and java eclasses and
	<c>java-config-1.x</c>
      </li>
    </ul>
  </dd>
  <dt>Generation 2</dt>
  <dd>
    <ul>
      <li>
	This is the new generation that has been in development for nearly a
	year. 
      </li>
    </ul>
  </dd>
</dl>

<dl>
  <dt>Generation 1 System VM</dt>
  <dd>
    <ul>
      <li>
	This is the VM that is used to emerge Java packages using the eclasses
	from Generation 1. It is set using <c>java-config-1 --set-system-vm &lt;choice of
	vm&gt;</c>.
      </li>
    </ul>
  </dd>
  <dt>Generation 2 System VM</dt>
  <dd>
    <ul>
      <li>
	With Generation 2, the system VM is only used for root and for users
	that haven't set a user VM.
      </li>
    </ul>
  </dd>
  <dt>Generation 2 Build VM</dt>
  <dd>
    <ul>
      <li>
	Generation 2 introduces a new class of VM. The Build VM is used at
	build time to build Java packages. By default, packages will attempt to
	use the lowest VM possible. The vendor used depends on the platform.
	These defaults are defined at
	<path>/usr/share/java-config-2/config/jdk-defaults.conf</path>.
	Additionally, the Build VM can be configured by
	<path>/etc/java-config-2/build/jdk.conf</path>. 
      </li>
    </ul>
  </dd>
</dl>

</body>
</section>
</chapter>

<chapter>
<title>Keywords</title>
<section>
<body>

<p>
If you are using the stable tree, i.e. x86, ppc, or amd64 as opposed to ~x86,
~ppc, or ~amd64, you will need to add some entries to your
<path>/etc/portage/package.keywords</path>:
</p>

<pre caption="package.keywords">
# Core Java Packages
dev-java/ant-core
dev-java/ant-tasks
dev-java/ant
dev-java/java-config
dev-java/java-config-wrapper
dev-java/javatoolkit
# JDKs
dev-java/sun-jdk
dev-java/ibm-jdk-bin
dev-java/jrockit-jdk-bin
dev-java/blackdown-jdk
dev-java/kaffe
# JREs
dev-java/sun-jre-bin
dev-java/ibm-jre-bin
dev-java/blackdown-jre
# Virtuals
virtual/jdk
virtual/jre
# Compilers
dev-java/eclipse-ecj
dev-java/jikes
# Documentation
dev-java/java-sdk-docs
# Misc packages that have been updated to generation-2,
# where the generation-1 won't build and/or run properly 
dev-java/lucene
</pre>

<impo>
It is crucial that you keyword ALL packages related to the new Java system,
otherwise you will have problems in the later steps of this guide.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Update java-config</title>
<section>
<body>

<p>
A new package, <c>java-config-wrapper</c>, is blocked by old versions of
<c>java-config</c>, so we should remove that first:
</p>

<pre caption="Remove old java-config">
# <i>emerge -C java-config</i>
</pre>

<p>
Now we should install the new versions of <c>java-config</c>:
</p>

<pre caption="Install new java-config">
# <i>emerge -1 =java-config-1* =java-config-2*</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Check your environment</title>
<section>
<body>

<p>
We now provide a new script, <c>/usr/bin/java-check-environment</c>.  This, as
the name may imply, checks the java environment. It then suggests what actions
that you should take to fix any problems found. So now run:
</p>

<pre caption="Check your environment">
# <i>/usr/bin/java-check-environment</i>
</pre>

<note>
This can be run under a user other than root. However only root or the system needs a
generation 1 vm. The script will complain about the lack of one, when run under a users
account. That is normal, and just ignore that part.
</note>

<p>
which leads us to...
</p>

</body>
</section>
<section>
<title>Update virtual machines</title>
<body>

<p>
The first section checks for old <c>java-config</c> files in
<path>/etc/env.d/java</path>. The instructions should be self-explanatory. Just
remove the files it indicates. After that, re-merge the packages that it
indicates.
</p>

</body>
</section>
<section>
<title>Delete old user configuration</title>
<body>

<p>
The next section that <c>java-check-environment</c> will politely warn you
about is that you have Generation-1 configurations in your home directory.
These files are no longer supported in their current form. If 
<c>java-check-environment</c> detects a problem, as advised, you should run:
</p>

<note>This applies only to non-root users.</note>

<pre caption="Delete old user configs">
# <i>java-config-2 --list-available-vms</i>
# <i>java-config-2 --set-user-vm &lt;Choice of VM&gt;</i>
</pre>

</body>
</section>
<section>
<title>Make sure you have a Generation-1 system-vm set</title>
<body>

<p>
The next possible set of errors is that you don't have a Generation-1 system
VM.
</p>

<pre caption="Set generation 1 vm">
# <i>java-config-1 -L</i>
# <i>java-config-1 -S &lt;system-vm-of-choice-here&gt;</i>
</pre>

<impo>
The Generation-1 system VM <b>MUST</b> be a 1.4 JDK. If you do not already 
have one, then you must emerge one.
</impo>

<note>
You MUST have a generation-1 1.4 JDK in every case.
This is required to build generation-1 packages, and for
generation-2 packages that do not compile with Java 1.5.
</note>

<p>
Of course, as per usual, you will need to run:
</p>

<pre caption="Update environment variables">
# <i>env-update &amp;&amp; source /etc/profile</i>
</pre>

<p>
To make sure you get the right environment.
</p>

</body>
</section>
<section>
<title>1.5 JDK set as your Generation-1 VM</title>
<body>

<p>
The next check is if you have a 1.5 JDK for a system vm for Generation-1. You
should be using a 1.4 JDK instead. If you have been following this guide to
this point, simply follow the instructions above for setting a new system vm
for Generation-1.
</p>

<p>
Chances are good that you have some bytecode compiled for 1.5. This can lead to
"UnsupportedClassVersionError" warnings. To attempt to fix this, try running: 
</p>


<pre caption="Run 1.5 fixer script">
<comment>Emerge tools needed for java-1.5-fixer, if you don't already have them</comment>
# <i>emerge --noreplace javatoolkit portage-utils</i>
<comment>Run java-1.5-fixer</comment>
# <i>/usr/bin/java-1.5-fixer</i>
</pre>

<impo>
If you have ever used a 1.5 JDK at any point, you really should run
java-1.5-fixer. This will make sure you don't have any stray 1.5 bytecode
kicking around.
</impo>

<impo>
java-1.5-fixer is really only provided as a convienence to rebuilding 
packages that were compiled with 1.5 with 1.4. It is not perfect, and may
not be able to fix every single package on every system. In cases where it
fails, it mostly requires unmerging the packages which fail, and remerging
the offending package.
</impo>

</body>
</section>
</chapter>

<chapter>
<title>Updated Documentation</title>
<section>
<body>
<p>
Documentation has been updated to reflect these changes:
</p>

<ul>
 <li><uri link="/doc/en/java.xml">User Guide</uri></li>
 <li><uri link="java-devel.xml">Developer Guide</uri></li>
</ul>
</body>

</section>
</chapter>

<chapter>
<title>Common Issues and Questions</title>

<section>
<title>
java-check-environment tells has the problem with the same VMs over and
over. Or, java-config-1 -L doesn't list anything
</title>
<body>

<p>
This is likely due to a mismatch in keywording / unmasking. To put it another way, you need to unmask and keyword everything related to the new Java system.
</p>

<p>
Specifically, this is usually caused by not keywording / unmasking all 
the VMs that you have installed on your system.
</p>

</body>
</section>

<section>
<title>Why can't I use a 1.5 JDK for the generation-1 system VM?</title>
<body>

<p>
By having a 1.5 JDK as the generation-1 system VM, we will encounter all 
the problems that caused the package.mask in the first place.
</p>

<p>
While some people may have been using 1.5 as their system VM without issue, 
there are still issues with a number of packages with issues. Essentially, 
we're requiring a 1.4 JDK because that is sure to work with every Java package 
that haven't been switched over to the new system.
</p>

</body>
</section>

<section>
<title>Applications try to use JAVA_HOME, which is set to the Generation-1 VM</title>
<body>

<p>
Some applications figure out how to call java from JAVA_HOME. As is, JAVA_HOME
will be what your system-vm for Generation-1 is set to (i.e.
<path>/etc/env.d/20java</path>). This will be an issue until the particular
application is converted to use the new eclasses.
</p>

<p>
One workaround is to do the following to set JAVA_HOME:
</p>

<pre caption="Check your environment">
if [[ -L $HOME/.gentoo/java-config-2/current-user-vm ]]; then
  export JAVA_HOME=$HOME/.gentoo/java-config-2/current-user-vm
elif [[ -L /etc/java-config-2/current-system-vm ]]; then
  export JAVA_HOME=/etc/java-config-2/current-system-vm
fi
</pre>

<p>
You could include this in your <path>.bash_profile</path>, but it isn't
recommended. This is because you remain tethered to your environment, which the
new system helps eliminate. For example, if you don't have a user-vm set,
you'll get the system-vm.  If you later set a user-vm, you'll need to source
<path>~/.bash_profile</path> to get the right JAVA_HOME.
</p>
      
<warn>
Do not use this in your root user's <path>bash_profile</path>! It will likely break
generation-1 packages if you have a 1.5 VM as the generation-2 system vm.
</warn>

<p>
The better approach would be to migrate the application to the new build
system, and ensure that it works properly. If you do run into any particular
applications that suffer from this problem, please contact <mail
link="nichoj@gentoo.org">nichoj</mail> in #gentoo-java or drop a message to the
gentoo-java mailing list. 
</p>

</body>
</section>
</chapter>
</guide>
