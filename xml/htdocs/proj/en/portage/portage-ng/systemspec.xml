<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header:
/home/cvsroot/gentoo/xml/htdocs/proj/en/portage/portage-ng/systemspec.xml,v 
1.3 2003/12/13 18:54:45 genone Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/proj/en/portage/portage-ng/systemspec.xml">
<title>Portage-ng Requirements/Design Goals document</title>
<author title="Author"><mail link="drobbins@gentoo.org">
Daniel Robbins</mail>
</author>

<abstract>
	This document contains the initial specification for the
architecture and design of portage-ng,
	the successor to portage. Portage-ng is a community-developed
project, and this document is open
	to community feedback.
</abstract>

<version>1.0</version>

<date>01 Dec 2003</date>

<chapter>
<title>Introduction</title>
<section>
<body>
<p>This is the specification for portage-ng, a package
manager/&quot;ports&quot; system that
is intended to be a successor to the current portage package manager.
The goal
of this project isn't simply to rewrite portage, but to also
significantly
expand the potential of this type of tool.</p>

<p>The development of portage-ng is open to community feedback and
involvement.
You can get involved by joining the <e>gentoo-portage-dev</e> <uri
link="/main/en/lists.xml">mailing list</uri>.</p>

<p>Portage-ng will be developed by first creating a comprehensive set of
architectural and functional requirements for the tool, as well as a set
of
design goals. Various possible technologies and implementations will
then be
considered, and the one that is best able to fulfill the requirements
and
design goals will be selected. Once an official implementation plan is
selected, official &quot;coding&quot; will begin.</p>

<p>In addition, there is work underway on a portage-ng exploratory
prototype
written in prolog.  The purpose of this prototype isn't to officially
begin
portage-ng development, but to explore the potential benefits of viewing
portage as a contraint satisfaction problem. We hope that this effort
will help
us to craft appropriate requirements and goals for the official
portage-ng
development effort.</p>

</body>
</section>
</chapter>
<chapter>
<title>Portage-ng architectural requirements</title>

<section>
<title>1. Facilitate parallel, community development</title>
<body>
<p>Portage-ng's internal architecture should allow for true community
development
by multiple teams. Approaches such as modularity, consistent
well-defined APIs,
and modern programming practices could be used to make the development
of code
more manageable, scalable and accessible.
</p>
</body>
</section>

<section>
<title>2. Allow for easy extensibility and new feature additions over
time</title>
<body>
<p>
Building on the previous requirement, the internal architecture of
portage-ng
should allow seamless addition of new functionalities and capabilities.
This
could be implemented using paradigms such as inheritance,
&quot;plugin&quot;

functionality, a component model or combination, or possibly others.
</p>
</body>
</section>
<section>
<title>3. Provide a coherent model for (meta)data representation and
storage</title>
<body>
<p>
In the current portage code, there is support for various types of data
repositories, including ebuilds, <path>/var/db/pkg</path> (installed)
package data, and
others. Multiple approaches are used to store this data.</p>

<p>
portage-ng should have a coherent (defined as <e>&quot;an orderly,
logical, and
aesthetically consistent relation of parts&quot;</e>) data model. The
intended goal is
to reduce code complexity, increase internal code re-use, reduce the
amount of
code dedicated to &quot;load/store&quot; operations, and allow
re-targeting of the
data-store for all aspects of portage-ng in one fell swoop. This will
also 
allow efforts to be focused on providing a single method for storing
data on
disk that is both efficient and well-designed.

</p>

<p>
This also implies that careful consideration is made in representing the
various namespaces within portage-ng, so that issues like
&quot;slots&quot; and future
extensions can be supported by the portage-ng data model.
</p>
</body>
</section>
<section>
<title>4. Will run on a wide variety of systems</title>
<body>

<p>Portage was initially designed as a Linux-based application. We are
now
looking at ways to integrate BSD, MacOS, and other platform support into
portage. portage-ng should be designed support multiple
platforms from its inception. In addition, portage-ng should be able to
support a large number
of CPU architectures, such as x86, ppc, amd64, ia64, sparc, alpha and
others.
</p>

</body>
</section>
<section>
<title>5. In as much as possible, encourage and/or enforce the
development of
high-quality, versatile and maintainable code</title>
<body>
<p>
To meet this requirement, we will need to successfully meet requirements
1 and
2. Beyond this, portage-ng development and package handling should use
modern
practices to avoid unwanted side-effects that can cause unpredictable
behavior.
</p>

<p>
Concepts that should be explored should include (but not be limited to)
the use
of logic and functional programming concepts, as well as immutable data
types,
both in portage-ng development as well as the day-to-day addition of new
packages to portage-ng.</p>

<p>Satisfaction of this requirement should also address how portage-ng
functionality could address the types of problems that eclasses
currently 
address in portage.
</p>
</body>

</section>

<section>
<title>
6. Encourage/enforce separation of package metadata from specific build
steps
and algorithms</title>
<body>
<p>
In portage, ebuilds generally have two types of metadata -- the first
contains
specific steps to build, unpack, or compile the package and is
inherently
procedural in nature. This metadata can be called &quot;stepwise
metadata.&quot; The
second type of metadata is more abstract and does not contain specific
steps
to perform. For example, DEPEND, RDEPEND and SRC_URI are of this type,
and
this allows Portage to use this metadata for a variety of (rather than a 
single) purpose. Due to the abstract nature of the metadata, algorithms
such
as dependency resolution can be changed without causing ebuilds to
break.
</p><p>
Portage-ng should be designed to provide a clear separation between
stepwise
and abstract metadata, and encourage or enforce metadata to be
represented in
an abstract form when possible, so it is of more use to portage-ng. This
will
allow internal portage-ng algorithms to be changed without causing
package
building and installation to break, and allow the system as a whole to
be much
more flexible.
</p><p>
An example of a type of metadata that should be avoided would be a
REBUILD
variable which tells portage-ng what packages should be rebuilt after a
particular package is installed. Such a REBUILD variable would need to
be
treated as a stepwise procedure by portage-ng (a list of &quot;things to
do&quot;,) which would limit its
usefulness. Instead, this metadata should be represented abstractly (as
a set of constraints/requirements) so that
portage-ng can understand the finer levels of underlying dependencies
and
resolve these constraints optimally and efficiently.

</p>
<p>
In addition, the ability to track what abstract metadata is used by the 
stepwise metadata should be carefully considered. This would allow for
the
elimination of the equivalent of the IUSE variable in portage-ng, since
portage-ng would already be aware of what metadata was being used by the
various parts of the stepwise build scripts.
</p>
</body>
</section>
<section>
<title>7. Delivery a feature set that addresses the needs of
user community</title>
<body>
<p>Careful attention should be paid to the needs of our user community.
What
features are our users looking for in portage-ng? What kinds of problems
are they
interested in having portage-ng solve? These needs should be taken into
account
in the design.</p>
</body>
</section>

<section>
<title>8. Will run efficiently even on modest hardware, and take full
advantage of
the resources of modern hardware.</title>
<body>
<p>Portage-ng should be able to run efficiently on modest hardware. On
more modern
hardware, portage-ng should be able to take full advantage of current
execution
of multiple parallizable steps in order to improve performance. This may
include multiple simultaneous fetching of source files, or the
parallelization
of any other type of parallizable step. This implies, of course, that
portage-ng must be capable of recognizing which steps can be run in
parallel
and which can't.</p>
</body>
</section>

<section>
<title>9. Security as a priority</title>
<body>
<p>Special care should be taken to ensure that a fully trusted path is
available throughout package installation: technologies used might be
GPG-signed packages.</p>
</body>
</section>

</chapter>

<chapter>
<title>Design goals</title>
<section>
<title>1. Reflect the sensibilities of &quot;ports&quot; system designs,
as well as Portage</title>
<body>
<p>
Portage and ports-based systems have been well-received by the public
due to
several design sensibilities they embody. These sensibilities include
ease of use, ease of addition of new packages, ease
of learning and ease of accessing and modifying data. Plain text seems
to be
preferred as a default data store. New design possibilities can be
explored as long
as the design as a whole addresses the general preference towards the
plaintext
approach and for &quot;ports-flavored&quot; designs.
</p>
</body>

</section>
<section>
<title>2. Provide an easy-to-understand, well-documented developer
API</title>
<body>
<p>
This includes self-documenting API calls, good documentation, as well as
possibly other aspects of design.
</p>
</body>
</section>
<section>
<title>3. Malleability: provide an open, transparent architecture that
reflects UNIX design
philosophy</title>
<body>
<p>
This is related to design goal 1. The words &quot;open&quot; and
&quot;transparent&quot; reflect
the fact that the portage-ng architecture should allow developers to
dive in to the portage-ng
code and extend it, or use a subsection of it for their own specific
needs.
</p>
</body>
</section>

<section>
<title>4. In every way possible, program should be malleable to allow
conformation to
user needs and expectations, both interface as well as the specific
actions
performed by the program.</title>
<body>
<p>Portage-ng should be created to be a multi-faceted toolkit that can
be used
in any number of ways, dependent upon the intention of the user.
It's our hope that portage-ng will
be used in a variety of innovative ways not originally anticipated by
its
designers.</p>
</body>
</section>
</chapter>

<chapter>
<title>Portage-ng functional requirements</title>

<section>
<title>1. Rich support of package metadata</title>
<body>
<p>Portage-ng should be aware of an arbitrarily large number of package
metadata, and should be capable of being extended to use any data as a
constraint or installation option.
</p>
</body>
</section>

<section>
<title>2. Fully parallel approach to package installation</title>
<body>
<p>For the sake of efficiency, portage-ng should parallelize as many
tasks as possible, i.e. simultaneous download and compilation.</p>
</body>
</section>

<section>
<title>3. Ability to manage multiple package installation
databases</title>
<body>
<p>A common request is for portage-ng to be able to install packages in
a users directory, but with the knowledge of the system packages to
build the dependency information. A more abtruse use might be to install
software on an nfs-exported directory to allow many machines to take
advantage of it; it would be ideal if portage-ng was aware of any
locally-installed software on the client machines.</p>
</body>
</section>


</chapter>

</guide>
