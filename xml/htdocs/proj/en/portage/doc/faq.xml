<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/portage/doc/faq.xml,v 1.23 2006/04/05 22:32:33 antarus Exp $ -->

<guide link="/doc/en/eapi.xml" lang="en" disclaimer="draft">
<title>Portage Frequently Asked Questions (FAQ)</title>

<author title="Author">
	<mail link="antarus@gentoo.org">Alec Warner</mail>
</author>
<author title="GuideXML">
  <mail link="chriswhite@gentoo.org">Chris White</mail>
</author>

<abstract>
FAQ Frequently Asked Questions about Portage.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2006-04-04</date>
<chapter>
<title>Frequently Asked Questions</title>
<section>
<title>Why don't we have USE-based DEPEND atoms yet?</title>
<body>

<p>
USE-based DEPEND atoms, ie DEPEND=”app-foo/bar[baz]” where baz is in IUSE of app-foo/bar are tricky to implement properly. Imagine a package with DEPEND=”app-foo/bar[baz] app-foo/coolpkg” Then in app-foo/coolpkg... DEPEND=”app-foo/bar[-baz]”. Here we have a depgraph with -baz and baz, how do we satisfy the depgraph? Also when automagically flipping flags on ( for instance, an app deps on app-foo/bar[baz] so we set USE=”baz” ) causes other fun depgraph issues and cycles. All of these must be accounted for in the code. Not to mention the depgraph code must process dependencies in a sane timeframe.
</p>

</body>
</section>
<section>
<title>Why is portage so slow? / Why don't you rewrite portage in $RANDOM_LANGUAGE</title>
<body>

<p>
Portage's speed (or lack thereof) has very little to do with Python the 
language. The 2.0 codebase is old and was not well designed. The 
developers have been talking of a redesigned codebase that attempts to 
achieve many goals; being faster is one of them. For a current example 
try in a shell:</p>
<pre caption="Pre Portage Timing">time python -c 'import portage'</pre>
<p>
On many systems this can take up to and above 10 seconds, because portage needs to scan the tree for virtual providers and initialize all it’s configuration data. This is just one place where older coding habits and conventions render the 2.0 codebase difficult to work with.  Zac Medico has patched the 2.1 series in a late revision to implement
lazy loading of virtuals that should speed up import times.
</p>

</body>
</section>
<section>
<title>Can I mount the portage tree ( /usr/portage ) via NFS?</title>
<body>

<p>
Mounting /usr/portage over NFS is possible.  However you must be careful to run emerge --metadata on all clients
who are mounting the tree over NFS.  Otherwise their Portage cache's will be stable and Portage will run rather slowly.
You need not run emerge --sync on every client.  If you encounter problems with an NFS setup it is important that you
ensure you have the proper locking daemons on both the NFS client machines and the NFS server machine.  Portage uses
hardlinks over NFS in an attempt to lock files; if the locking daemon fails to lock files Portage may complain about
failed or stale locks.  There is a script <path>/usr/lib/portage/bin/clean_locks</path> that can be used to clean out
old lockfiles.
</p>
</body>
</section>
</chapter>
</guide>
