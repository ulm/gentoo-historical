<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/gentoo-alt/prefix/techdocs.xml,v 1.3 2006/10/04 20:26:43 grobian Exp $ -->

<guide link="/proj/en/gentoo-alt/prefix/techdocs.xml" lang="en">
  <title>Gentoo Prefixed Portage Techdocs</title>

  <author title="Author">
    <mail link="grobian@gentoo.org">Fabian Groffen</mail>
  </author>

  <abstract>
    Technical documentation on Prefixed Portage
  </abstract>


  <!-- The content of this document is licensed under the CC-BY-SA license -->
  <!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
  <license/>

  <version>1.0</version>
  <date>2006-10-04</date>

  <chapter>
    <title>Changes to Portage</title>

    <section><!-- {{{ Global -->
      <title>Global</title>
      <body>

        <p>
          What does Prefixed Portage do more?  For short, it allows to
          install packages into an offset, without root privileges.  The
          longer answer includes how this is done, and why.  To start
          with the latter one, let's see how the land of the package
          manager (Portage) looks like.
        </p>
        <p>
          A package manager can be primary, or secondary.  In the first
          case, the package manager is responsible for building the
          (core) system, while in the latter case, the package manager
          builds on top of an existing system to enhance it.  Please
          note that this is by no means meant as a formal definition of
          the general concept "package manager".  Within this document
          it is used as entity that is natively responsible for managing
          software packages on the OS it works on.  Effectively, this
          means that Gentoo Portage is not the primary package manager
          on Apple Mac OS X, Sun Solaris, Debian, Ubuntu, etc.  Gentoo
          Portage is the primary package manager on its Gentoo GNU/Linux
          distribution, and as such, the Gentoo Portage tree matches
          this goal.
        </p>
        <p>
          Gentoo Prefix Portage is meant to be a secondary package
          manager.  Therefore it doesn't require root privileges, and
          has to install into another place than <path>/</path>, because
          there the primary package manager is already in charge.
        </p>

      </body>
    </section><!-- }}} -->

    <section><!-- {{{ Technical state -->
      <title>Technical state</title>
      <body>

        <p>
          on what the portage code actually is like (what branch it is
          based on, etc.)
        </p>
        <p>
          Gentoo Prefixed Portage started as a set of patches by Michael
          Haubenwallner, that were finally applied to a new branch of
          portage development: prefix.  In this branch, initially
          managed by Brian Harring, then later by Kito Dietrich, lots of
          development made prefix portage into what it is currently.
        </p>

      </body>
    </section><!-- }}} -->

    <section><!-- {{{ Tree state -->
      <title>Tree state</title>
      <body>

        <p>
          how far are we, what do we have, what don't we have?  what
          will come, what won't ever work?
        </p>
        <p>
          Since the Gentoo Portage tree is not usable with Gentoo
          Prefixed Portage, an overlay has been created, which is
          currently hosted on
          <uri>http://overlays.gentoo.org/proj/alt/browser/trunk/prefix-overlay</uri>.
          This has the disadvantage of not inheriting all packages from
          the main tree automatically.  Instead each package has to be
          converted to be prefix compatible.  Luckily for most packages
          these changes are trivial, and can be automatically performed
          by a script.
        </p>

      </body>
    </section><!-- }}} -->

  </chapter>

  <chapter>
    <title>Ebuild modifications</title>

    <section><!-- {{{ EAPI -->
      <title>Introduction of EAPI</title>
      <body>
        <p>
          The variable <c>EAPI</c> is currently not used in the main
          tree.  While normal Gentoo Portage is aware of it, no ebuilds
          use it yet.  <c>EAPI</c> identifies the API portage has to
          support in order to process an ebuild.  The <c>EAPI</c> chosen
          to indicate an ebuild is ported to prefix, is "prefix".
          Hence, each ebuild that wants to be used with Gentoo Prefixed
          Portage has to declare <c>EAPI="prefix"</c>.  Typically, this
          declaration is done first thing in the ebuild after the (CVS)
          header.
        </p>
      </body>
    </section><!-- }}} -->

    <section><!-- {{{ EPREFIX -->
      <title>EPREFIX variable</title>
      <body>
        <p>
          Since portage will install in an offset, called a prefix, in
          some cases it might be necessary to directly handle with this
          offset.  Some configure scripts for example require paths to
          be given next to <c>--prefix</c>, <c>--libdir</c>, etc. (all
          what <c>econf</c> covers), or some packages can't use
          <c>econf</c> at all.  For those occasions the variable
          <c>${EPREFIX}</c> is available in ebuilds and eclasses,
          pointing to the root of the offset.  For an offset
          <path>/Library/Gentoo</path> for example, the variable
          <c>${EPREFIX}</c> would contain <path>/Library/Gentoo</path>.
          This allows to easily use it for example like <c>econf
            --with-some-app="${EPREFIX}"/usr/bin/some-app</c>.
        </p>
      </body>
    </section><!-- }}} -->

    <section><!-- {{{ D and EDEST -->
      <title>The variables D and EDEST</title>
      <body>
        <p>
          In normal ebuilds, <c>${D}</c> refers to the destination
          directory in a temporary location before all files are
          actually merged into the live filesystem.  Since in prefix
          portage configure is run with <c>--prefix=${EPREFIX}/usr</c>
          this would not require any changes to <c>${D}</c>.  However,
          for all modifications to the build image, as is common
          practise in many ebuilds, <c>${D}/${EPREFIX}</c> should be
          used.  While this is a clean and logical result of using an
          offset, it increases the burden of converting ebuilds, and the
          differences between prefixed and normal versions of the same
          ebuild.  For this particular purpose, it was chosen to assign
          the value of <c>${D}/${EPREFIX}</c> to <c>${D}</c> in the
          prefix.  However, with this <c>${D}</c>, <c>emake
            DESTDIR="${D}" install</c> ends up in twice
          <c>${EPREFIX}</c>; one from <c>${D}</c> itself, and one from
          the configure call.  For this, the variable <c>${EDEST}</c>
          was introduced, which holds the old value of <c>${D}</c>, thus
          the build image root without <c>${EPREFIX}</c>.
        </p>
        <p>
          The net effect of this change is that each <c>emake
            DESTDIR="${D}" install</c> or similar has to be turned into
          <c>emake DESTDIR="${EDEST}" install</c>.  In most cases this
          change can be performed by a simple script.
        </p>
        
      </body>
    </section><!-- }}} -->

  </chapter>

</guide>

<!-- vim: set expandtab ts=2 sw=2 foldmethod=marker foldenable: -->
<!-- kate: space-indent on; indent-width 2; replace-tabs on; -->
