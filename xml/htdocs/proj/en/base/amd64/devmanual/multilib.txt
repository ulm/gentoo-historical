Multilib on AMD64
=================

The current AMD64 processors are able to natively run 32bit code on a 64bit
kernel. Therefore, you can run programs compiled for x86 in a amd64 environment.
However, 32bit applications need to be linked against 32bit libraries. Mixing
them won't work. For this reason the libraries are sorted, 32bit libraries go to
``/lib32`` respectively ``/usr/lib32``, the 64bit ones to ``/lib64`` or
``/usr/lib64``. In a perfect world, you wouldn't have to read on. Unfortunately,
that's not the case, and so it's a bit more complicated.

Multilib on Toolchain TODO: Better title
----------------------------------------

GCC
'''

To generate 32bit code, we need a multilib-capable GCC. On other architectures,
this functionality is enabled with the use flag ``multilib``. This is also true
for amd64 with the *pre*-2005.0 profiles. From 2005.0 on, you have to choose
whether you want multilib support or not by selecting the profile. Choose
``2005.0/no-multilib`` if you don't want it, all other profiles have the
``multilib`` use flag masked, you're forced to it. With these profiles, GCC will
produce x86-code whenever you add ``-m32`` to your ``CFLAGS``. Adding ``-m64``
or not touching it will result in getting 64bit code.

glibc
'''''

If you've chosen a multilib profile, glibc will be built twice, once 64bit and
once 32bit. This is because nearly every application links against glibc. 
To understand how this is done in the ebuild, read `The \`\`ABI\`\` Variable`_.

The ``emul-linux-x86-*`` packages
---------------------------------

As you read above, 32bit applications must be linked against 32bit libraries.
For that, we've put together the most used libraries and stuck them into the
so-called ``emul-linux-x86`` packages, which are located in the
``app-emulation`` category.

emul-linux-x86-baselibs
	Contains very basic libraries like zlib, pam, ncurses

emul-linux-x86-compat
	contains very old libraries for compatibility with binary-only programs

emul-linux-x86-glibc
	Only used for compatibility reasons. This package is blocked by all
	2005.0 profiles.

emul-linux-x86-gtklibs
	The name says it -- GTK and its engines belong herein.

emul-linux-x86-nvidia
	Obsolete, ``media-video/nvidia-kernel`` builds natively.

emul-linux-x86-qtlibs
	QT goes here.

emul-linux-x86-sdl
	libsdl and friends are here.

emul-linux-soundlibs
	alsa, libogg, just everything that is needed to get sound is located here.

emul-linux-x86-xlibs
	Contains the basic X libraries

These packages only provide pre-compiled libraries. Currently, the
archives are assembled manually, which is the main reason to keep the packages
as tidy as possible. Do not include libraries that aren't commonly used.

.. Note:: The emul-packages might conflict with their native images, but only in
uncritical locations like ``/usr/share`` which are arch-independend anyway.

The ``multilib-strict`` Feature
-------------------------------

Many Makefiles assume that their libraries should go to ``/usr/lib``, or
``$(prefix)/lib``. This assumption can cause a serious mess if ``/usr/lib``
isn't a symlink to ``/usr/lib64``, which is at least true for the
2005.0/no-symlinks profile. To find the bad packages, we have a portage feature
called **multilib-strict**. It will prevent emerge from putting 64bit libraries
into anything other than ``(/usr)/lib64``.

``multilib-strict`` currently doesn't check perl5, gcc, gcc-lib and eclipse-3,
this behaviour is controlled by the ``MULTILIB_STRICT_EXEMPT`` variable in
``make.profile``.

How to fix ebuilds properly
'''''''''''''''''''''''''''

In most cases, it's sufficient to use the ``$(get_libdir)`` function from
``multilib.eclass``: ::

	inherit multlib.eclass

	src_compile() {
		econf \
			--libdir=/usr/$(get_libdir)

		emake || die
	}

	src_install() {
		make DESTDIR=${D} install || die
	}

``$(get_libdir)`` decides to return ``lib64``, ``lib32`` or ``lib`` depending on
the architecture and the ``ABI`` variable.

Some packages provide really bad Makefiles that hard-code ``/usr/lib``. Those
should be ``sed``ed or patched. Don't forget to let upstream know about your
modifications!

Headers and Multilib
--------------------

Most C/C++ programs need standard header files like ``types.h``. Some of them
depend on architecture specific facts, e.g. ``types.h`` on the length
of machine words. To ensure that we can compile both 32bit and 64bit
applications and libraries, we treat ``/usr/include/asm`` a bit special.

This is what ``/usr/include/asm/types.h`` looks like on a AMD64 box: ::

	/* Common header file autogenerated by create_ml_includes in multilib.eclass */
	#ifdef __i386__
	#include <asm-i386/types.h>
	#endif /* __i386__ */
	
	#ifdef __x86_64__
	#include <asm-x86_64/types.h>
	#endif /* __x86_64__ */

TODO: Are the /**/ handled by RST? If yes, fix this

As you can see, this is just a wrapper that decides which file you need
depending on the the parameter ``-D`` given to gcc. You'll probably run into
some troubles if you try to compile something by hand and forget to append
``-D__x86_64__`` to your ``CFLAGS``. Of course, this is **not necessary** when
using portage. For an explanatation, see the `The \`\`ABI\`\` Variable`_ section.

The ``ABI`` Variable
--------------------

Whenever portage builds something on amd64, it has to decide whether it should
be 32bit or 64bit. As stated in `Headers and Multilib`_, the ``__i386__`` or
``__x86_64__`` respectively, is needed in ``CDEFINE``. Also, gcc has to know
what code it should produce, therefore ``-m32`` or ``-m64`` must be appended to
CFLAGS. This is done via ``profile.bashrc``. All you need to do if you want to
build a package 32bit is to set ``ABI=x86``.

The details are shown in ``make.defaults``: ::

	MULTILIB_ABIS="x86 amd64"
	DEFAULT_ABI="amd64"

	CFLAGS_amd64="-m64"
	LDFLAGS_amd64="-m elf_x86_64"
	CHOST_amd64="x86_64-pc-linux-gnu"
	CDEFINE_amd64="__x86_64__"
	LIBDIR_amd64="lib64"

	CFLAGS_x86="-m32 -L/emul/linux/x86/lib -L/emul/linux/x86/usr/lib"
	LDFLAGS_x86="-m elf_i386 -L/emul/linux/x86/lib -L/emul/linux/x86/usr/lib"
	CHOST_x86="i686-pc-linux-gnu"
	CDEFINE_x86="__i386__"
	LIBDIR_x86="lib32"
