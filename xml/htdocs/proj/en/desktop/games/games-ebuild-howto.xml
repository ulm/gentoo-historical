<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/desktop/games/games-ebuild-howto.xml,v 1.6 2005/06/08 18:49:35 wolf31o2 Exp $ -->
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="games-ebuild-howto.xml">
<title>Gentoo Games Ebuild HOWTO</title>

<author title="Author">
	<mail link="egore@gmx.de">Christoph Brill</mail>
</author>

<author title="Editor">
	<mail link="wolf31o2@gentoo.org">Chris Gianelloni</mail>
</author>

<abstract>
	This guide outlines the best practices for creating ebuilds for games on Gentoo.
</abstract>

<license/>

<version>0.1</version>
<date>6 June 2005</date>

<chapter>
	<title>Introduction</title>
	<section>
		<body><p>This guide is intended to give an overview of how to write good games ebuilds.  Writing games ebulds using the best possible style allows for your submission to be added to Gentoo quickly and with no issues.  There are several simple steps that you can follow to achieve this goal, starting from games ebuilds basics to some really nice tricks to work around the broken state of some upstream packages.  This guide also tries to point out common mistakes made when contributing an ebuild.</p>
		</body>
	</section>
</chapter>

<chapter>
	<title>Prerequisites</title>
	<section>
		<body><p>First and foremost, this document will show you the proper way to write an ebuild, starting with the file naming and placement.</p>
		</body>
	</section>
	<section>
		<title>Installing vim</title>
		<body><p>This ebuild guide recommends using "vim" for creating ebuilds.  Together with "gentoo-syntax" you can create ebuilds quite simply.</p>
			<pre caption="Installing vim and gentoo-syntax"># emerge app-editors/vim app-vim/gentoo-syntax</pre>
			<p>Now vim will have proper syntax highlighting for ebuilds.  It also has a default template for ebuilds.  If you are unfamiliar with vim, I recommend reading the <uri link="http://www.gentoo.org/doc/en/vi-guide.xml">Learning vi</uri> guide to familiarize yourself with it.</p>
		</body>
	</section>
	<section>
		<title>Creating a games ebuild in your overlay</title>
		<body><p>We are going to create a game ebuild in your portage overlay.  The first thing you will need to do, is to decide which game you would like to write as an ebuild.  Next, you will want to decide which category your game best fits.</p>
			<ul>
				<li>games-action</li>
				<li>games-arcade</li>
				<li>games-board</li>
				<li>games-emulation</li>
				<li>games-engines</li>
				<li>games-fps</li>
				<li>games-kids</li>
				<li>games-misc</li>
				<li>games-mud</li>
				<li>games-puzzle</li>
				<li>games-roguelike</li>
				<li>games-rpg</li>
				<li>games-server</li>
				<li>games-simulation</li>
				<li>games-sports</li>
				<li>games-strategy</li>
				<li>games-util</li>
			</ul>
			<p>If, for example, your game is a soccer game named "kickball", you would create a directory in your local overlay like follows.</p>
			<pre caption="Creating your overlay direcory">
# mkdir -p /usr/local/portage/games-sports/kickball
			</pre>
			<p>If the package is a binary package, and does not support compilation, then append a "-bin" to the end of the package name to make up the portage package name.  If the package is a demo version of a commercial, or otherwise full-version game, please name the package with "-demo" appended to the end of the package name.  This is not a requirement, but in most cases is a good idea.  Next, you will need to know the version number of the package.  It might be needed to convert this number into a format suitable to portage.  The ebuild naming policy can be found in the <uri link="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2">developer handbook</uri> online.  After deciding on the category and naming of your new ebuild, we will want to start editing on it.</p>
			<pre caption="Using vi to edit your ebuild">
# cd /usr/local/portage/games-sports/kickball
# vi kickball-1.0.ebuild
			</pre>
			<p>At this point, vim will populate out a skeleton ebuild for you.  It should look like the following.</p>
			<pre caption="Skeleton ebuild example">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# Header: $

DESCRIPTION=""
HOMEPAGE=""
SRC_URI=""

LICENSE=""
SLOT="0"
KEYWORDS="~x86"
IUSE=""

DEPEND=""
RDEPEND=""
			</pre>
			<p>This actually is a fully functional ebuild, but we will definitely need to do some more editing to get it in a usable state.</p>
		</body>
	</section>
</chapter>

<chapter>
	<title>Writing the ebuild</title>
	<section>
		<body><p>Writing the ebuild is the meat of this document.  We start by describing the elements above and add elements to our ebuild to create a fully working ebuild for our new game.</p>
		</body>
	</section>
	<section>
		<title>inherit games</title>
		<body><p>The first thing we will do is add <c>inherit games</c> to the ebuild.  The games team prefers this to be located between the header and the description lines, surrounded by a blank line.  This is where you inherit eclasses.  If you use a function from an eclass, you must inherit it.  Also, always list the games eclass last, unless using another games eclass to override the default games functionality.  More on this will be explained later.  The games eclass, which will be explained below, is full of functions common to all games ebuilds, and also sets up new defaults for certain ebuild functions, such as pkg_preinst, pkg_postinst, src_compile, and pkg_setup.  It also contains some variables that we will use across all games ebuilds, to maintain consistency.</p>
		</body>
	</section>
	<section>
		<title>DESCRIPTION</title>
		<body><p>This is the description of the package.  The description should be no more than a single line, and should give a quick overview of the game.  Try to make it descriptive, yet succinct.  A good example for our kickball game would be "a fast-paced SDL soccer game with network play".</p>
			<note>Please do not add something like "kickball is" to the beginning of the description.  It is redundant and unwanted by the games team.</note>
		</body>
	</section>
	<section>
		<title>HOMEPAGE</title>
		<body><p>This is the location of this package's homepage.  This should always be linked to the English version of the page, if available.  This should also <b>never</b> contain any variables.</p>
		</body>
	</section>
	<section>
		<title>SRC_URI (and friends)</title>
		<body><p>This is the first real interesting thing in our ebuild, and also the first place for potential problems.  Most upstream packagers use very strange names for their packages.  Let's say kickball uses sourceforge.net's distribution system.  The file is named "kick-ball-src-v1.0.tar.gz".  As you can see, this does not fit the package name in portage.  There are a few portage variables which can be used here.  The two that I will be discussing are ${P} and ${PV}, which refer to the package name and version, and package version, respectively.  If you need to make changes to these, it is recommended to use MY_P or MY_PV, as needed.  Proper games team coding style places these variables above DESCRITION, but in the same block.  In this example, we are going to set MY_P to "kick-ball-src" and MY_PV to "v${PV}".  We want to use the ${PV} variable within MY_PV so that future upgrades are easier.</p>
			<note>Never hard-code package versions within an ebuild unless there is absolutely no other choice.</note>
			<p>This makes our SRC_URI look like the following.</p>
			<pre caption="SRC_URI example 1">
SRC_URI="mirror://sourceforge/${PN}/${MY_P}-${MY_PV}.tar.bz2"
			</pre>
			<p>This would cause portage to search the sourceforge mirrors for kickball/kick-ball-src-v1.0.tar.bz2, which is exactly what we are looking to find.  If the package sources are named to match the package, then the SRC_URI line is much simpler.</p>
			<pre caption="SRC_URI example 2">
SRC_URI="mirror://sourceforge/${PN}/${P}.tar.bz2"
			</pre>
		</body>
	</section>
	<section>
		<title>LICENSE</title>
		<body><p>The license is an important point in your ebuild.  It is also a common place for making mistakes.  Try to check the license on any ebuild that you submit.  Often times, the license will be in a COPYING file, distributed in the package's tarball.  If the license is not readily apparent, try contacting the authors of the package for clarification.  For a list of available licenses, look at /usr/portage/licenses.  Also, if the license requires the user to accept the license before installation, then you will need to use the check_license function of eutils.eclass in pkg_setup.</p>
		</body>
	</section>
	<section>
		<title>SLOT</title>
		<body><p>Leave SLOT="0" unless you know what you are doing.  The slot is designed to allow two different version packages, that are not compatible and not conflicting, to exist on the system simultaneously.  A good example of this is gtk+ 1.x and gtk+ 2.x packages.  So far, there have been no games where this is the case, so most likely you will never need to change this.</p>
		</body>
	</section>
	<section>
		<title>KEYWORDS</title>
		<body><p>This should state the architectures on which you have tested the game.  Since every package should start in a testing state, prefix all architectures with a "~" to show this state.  Also, do not list any architecture which you cannot personally test.</p>
		</body>
	</section>
	<section>
		<title>IUSE</title>
		<body><p>Does this package have additional features that can be toggled on and off?  IUSE lists all the USE flags that this package is capable of using.  Do not list any USE flags here which are not used by the package, and also, do not forget to list any USE flags here that you use within the package ebuild.  For the meaning of each global USE flag, please check /usr/portage/profiles/use.desc and /usr/portage/profiles/use.local.desc for more information.  A local USE flag is used for any additional feature that does not fall under the scope of the already-defined global USE flags.</p>
		</body>
	</section>
	<section>
		<title>DEPEND</title>
		<body><p>This variable is used to build the dependency tree for packages that are required to build this package.  You should list all packages that are used not only by the game build itself, but also in the ebuild, so if you use "sed" in your ebuild, you must also add it to DEPEND.  These packages are only used at build time.</p>
		</body>
	</section>
	<section>
		<title>RDEPEND</title>
		<body><p>This variable is used fro run-time dependencies.  If left blank, portage assumes RDEPEND to be equal to DEPEND.  These are dependencies required by the package to run.  If you have packages listed here, you should also refer to this in DEPEND as follows, otherwise, remove RDEPEND completely.</p>
			<pre caption="DEPEND with RDEPEND example">
RDEPEND="virtual/opengl"
DEPEND=">=sys-apps/sed-4
	${RDEPEND}"
			</pre>
		</body>
	</section>
	<section>
		<title>S and upstream packaging</title>
		<body><p>The S variable is used to store the starting location that the ebuild should use for performing work.  By default, this is S="${WORKDIR}/${P}".  If the upstream packager did not use a subfolder when packing their package, which is common with zip file distribution, then you would set S as follows.</p>
			<pre caption="S with no folder example">
S="${WORKDIR}"
			</pre>
			<p>If the upstream packager did not include a version number, but did use the package name, then S would be set as follows.</p>
			<pre caption="S with no version example">
S="${WORKDIR}/${PN}"
			</pre>
			<p>If you do not need special handling, leave S out of the ebuild.  Also, be sure to always quote the variables on the right hand side, as they could potentially contain spaces.</p>
		</body>
	</section>
	<section>
		<title>pkg_setup</title>
		<body><p>In most cases, you will not need to edit pkg_setup.  One common reason for needing to create a pkg_setup in your ebuild would be for using the check_license function in eutils.eclass, such as in the quake3 ebuilds.</p>
			<pre caption="Example pkg_setup">
pkg_setup() {
	check_license || die "license check failed"
	games_pkg_setup
}
			</pre>
			<p>As you can see, you must always call games_pkg_setup if you specify your own pkg_setup function.  This is to ensure that the system is properly configured for games under Gentoo.</p>
		</body>
	</section>
	<section>
		<title>src_unpack</title>
		<body><p>The default src_unpack from portage tends to be all you need for most ebuilds.  This function is used to unpack the sources for a particular package.  A few examples of when you would want a src_unpack function are below.</p>
			<pre caption="Makeself archive example">
src_unpack() {
	unpack_makeself || die "unpacking files"
}
			</pre>
			<p>By default, both unpack and unpack_makeself use ${A} as the target to unpack.  You can also specify the target, if you need to only unpack a single download, rather than them all.  A good example of this comes from the ut2003 ebuild.</p>
			<pre caption="unpack and unpack_makeself example">
src_unpack() {
	unpack_makeself ${PN}lnx_2107to${PV}.sh.bin \
		|| die "unpacking patch"
	unpack UT2003CrashFix.zip
}
			</pre>
			<p>As you can see, each function specifically calls a certain file to be unpacked.  If you need additional steps before compilation, such as making changes to a Makefile, then you will need add it into a src_unpack function.  Now, in this final example, let's pretend that our fictional package, kickball, has both a broken Makefile, and also a binary that must be removed for compilation to complete.</p>
			<pre caption="kickball example src_unpack">
src_unpack() {
	unpack ${A}
	cd "${S}"
	sed -i \
		-e "/TARGET/s:/usr/bin/:${GAMES_BINDIR}:" Makefile \
		|| die "sed Makefile failed"
	rm -f kickball
}
			</pre>
			<p>This function shows us several important things that we need to know about games ebuilds.  First, when making your own src_unpack, you must always include your own unpacking methods, or use the built-in functions.  Next, you see that we cd to our unpacked location, ${S}, which must be quoted.</p>
			<p>Now, imagine a line like "TARGET=/usr/bin/" in the game's Makefile.  This is wrong for Gentoo, since by default games binaries go into "/usr/games/bin", which is defined by "${GAMES_BINDIR}" in games.eclass.  Always use the variable to refer to the games binary location, as this allows users to specify for themselves where they want the games to install their binaries by overriding this variable.  There are several other games-specific variables available for you to use, which will be explained further in the document.</p>
			<p>You will also notice that we have added "|| die" after each required external command.  This is necessary, since it stops the emerge process if that command failed.  Never omit these as all important external commands need it.  All die messages should be short and to the point.  Good examples are above.  There is no die after unpack, as it does its own checking and aborts the emerge process on its own.</p>
			<p>We did not add a die after the rm above.  The reason for this is the presence of kickball will cause the build to fail, but the lack of the file will not hurt us in any way.  Remove only items that stop the ebuild from working when present.  If there are, for example, Makefiles for 25 different systems,  plus a bunch of crap for MSVC, just ignore them.  They will not be installed unless we specifically ask for them to be during src_install, and they will be deleted by portage at the end of the completed emerge.</p>
		</body>
	</section>
	<section>
		<title>src_compile</title>
		<body><p>This function is where both the configuration and compilation steps take place.  By default, this function is slightly different for games ebuilds than for non-games ebuilds.  The default function looks as follows.</p>
			<pre caption="Default src_compile for games.eclass">
src_compile() {
	egamesconf || die "egamesconf failed"
	emake || die "emake failed"
}
			</pre>
			<p>As you can see, we use the egamesconf function, rather than econf.  The egamesconf function is a wrapper function that calls "./configure" with the proper paths for a Gentoo games ebuild.  If the package does not use autotools, then using egamesconf is still preferred over calling "./configure" directly.  You can still fix the Makefile afterwards, or, even better, fix the configure script itself.</p>
		</body>
	</section>

</chapter>

</guide>
