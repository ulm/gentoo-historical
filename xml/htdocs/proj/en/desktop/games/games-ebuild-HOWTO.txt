1. Introduction
===============
This guide intends to give an overview about how to write an ebuild for a game. So if you are reading this you really want to get the game into portage without getting the games herd angry. There are several simple steps that you can follow to achieve this goal. Starting from games ebuild basics to some really nice tricks to work around brokenness of some packages. This guide tries also to point out common mistakes when contributing an ebuild.

2. Prequisits
=============
First of all you got to know how to use a keyboard to write text. Next thing is that you know how to label the text file and where to store it that you can use it with emerge. You also got to know the basic methods used in ebuilds.

2.1. Installing vim
-------------------
This ebuild guide recommends using "vim" for creating ebuild. Together with "gentoo-syntax" you can simply create ebuilds. So let's do

'emerge app-editors/vim app-vim/gentoo-syntax'

You should now have vim running, which you can try with typing 'vi' in a term. That should bring up the editorwhich, in case you didn't know, you can quit with ':q'. In case you didn't know, I recommend to read a vim guide first.

2.2. Creating a games ebuild in your overlay.
---------------------------------------------
Next you need to look at the game you want to write an ebuild for. Try to find out which category it fits in
- games-action
- games-arcade
- games-board
- games-emulation
- games-engines
- games-fps
- games-kids
- games-misc
- games-mud
- games-puzzle
- games-roguelike
- games-rpg
- games-server
- games-simulation
- games-sports
- games-strategy
- games-util

For example your game is a soccer game named "kickball". So go to you local portage overlay (like /usr/local/portage) and create a directory in the sports category and enter that directory.

'mkdir -p games-sports/kickball; cd games-sports/kickball'

If you have a binary package, which does not support compilation (maybe closed source), add a "-bin" behind that name to clearly state it is a binary. After that you need to find out the version number of the game. If it is "1.0" for example, you will need to use kickball-1.0.ebuild as name for it. So just type:

'vi kickball-1.0.ebuild'

and let take vim the job for creating an empty ebuild for you. The empty ebuild will look something like this:

'# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/desktop/games/Attic/games-ebuild-HOWTO.txt,v 1.1 2005/06/06 18:29:14 wolf31o2 Exp $

inherit games

DESCRIPTION=""
HOMEPAGE=""
SRC_URI=""

LICENSE=""
SLOT="0"
KEYWORDS="~x86"
IUSE=""

DEPEND=""
RDEPEND=""'

So, you just set up your first ebuild for a game. This does not work yet, but it contains the basics.

3. Writing the ebuild
=====================
This will tell you the most common used things during ebuild creation. We start by describing the things already listed in the ebuild and adding the methods to really work.

3.1 The already listed stuff
----------------------------

3.1.1 inherit games
This is necessary for all games ebuilds. The games.eclass provides variables and methods especially for games. You want a variable for the games data location? Use this eclass. You need a method to run configure with the necessary parameter for games? This eclass is your friend. Unless for some good reason, you should really leave it in there. We will discuss the features of that eclass later.

3.1.2 DESCRIPTION
This is (surprise, surprise) the description of a package. If you want to describe it, use something like

'a soccer game for kids created using SDL'

Please don't add

'kickball is '

in front of this statement. This is really unnecessary and not wanted by the games herd.

3.1.3 HOMEPAGE
I guess you know what to type in here? Right. The homepage of the game your ebuild is for. In our kickball example this could be "http://kickball.sourceforge.net/". If a homepage is multilingual and the default language is different than english, please use a link to the english homepage.

3.1.4 SRC_URI
This is the first real interesting thing in our ebuild. Most packagers use very strange names for their packages. Let's say kickball uses sourceforge.net's distribution system. The file is named "kick-ball-src-v1.0.tar.gz". As you can see, this is a really ugly name, but such things are common. So you need to set

'SRC_URI="mirror://sourceforge/kickball/kick-ball-src-v${PV}.tar.gz"'

See that ${PV} in there? This is the version number of the game. Please NEVER hardcode it, since using that variable eases the pain of upgrading a package. And if someone was intelligent enough to add a variable for the version, so why not use it?

If the package is named better, like "kickball-1.0.tar.gz", you can simply use

'SRC_URI="mirror://sourceforge/${PN}/${P}.tar.gz"'

This works since ${P} is the variable for the name of the ebuild it's version number and ${PN} is the name of the ebuild.

3.1.5 LICENSE
This is an important point in your ebuild. Look what license the game uses (for example there could be a COPYING file in the package) or even ask the author. Make sure the license is correct. For a valid list of available licenses look at /usr/portage/licenses/

3.1.6 SLOT="0"
This is the first version of an ebuild for a game? Then just forget about that variable. Just don't think about what it does.

3.1.7 KEYWORDS
This should state which architectures you tested the game on. Most common is you tested it on x86. Since every new package starts in unstable state, it should list a "~" infront if the architecture. In most cases you can leave it as vim did it for you. Don't add all the arches to KEYWORDS, only the ones you've tested.

3.1.8 IUSE
The package has additional features that can be toggeled on and off? Like extra documentation? Simply mention all useflags you access in this list. For example if you can install addition docs and have addition support for x11, use something like:

IUSR="doc X"

For the meaning of useflags look at /usr/portage/profiles/use.desc

3.1.9 DEPEND
This variable is used to build the dependecy tree. If your game needs SDL, OpenGL, OpenAL, whatever for compilation ... add it as dependecy. These are the dependecies to build the game. So if you use "sed" in your ebuild, you must also add it.

3.1.10 RDEPEND
In most cases, RDEPEND should be the same as DEPEND. If you don't have any specialties for compilation (like sed), remove this line. If you have, you add your real depedencies here and refer in DEPEND to this. Like:

RDEPEND="virtual/opengl"
DEPEND=">=sys-apps/sed-4
	${RDEPEND}"

3.1.11 S=${WORKDIR}/${P}
From time to time a packager disliked the idea of using folders in his package. Therefore the variable ${S} must be changed, since it tries to access a directory by default. So if a packages don't use a folder for it's toplevel, change it to

'S=${WORKDIR}'

So your methods in the ebuild will find the package content. Or sometimes the foldername does not contain the version number, then you need to use

'S=${WORKDIR}/${PN}'

If you don't need any special handling of the directory, remove that line since 'S=${WORKDIR}/${P}' is default.

3.2 Methods within an ebuild
----------------------------
There are several methods that get called during the emerge process of an ebuild. We will bring some light to the most important ones and how they will be used for games ebuilds.

3.2.1 src_unpack()
This method is used to unpack the package (as the name might suggest). The default method looks like this

'src_unpack() {
	unpack ${A}
}'

The ${A} is the variable for the downloaded file in /usr/portage/distfiles taken from SRC_URI. If you need additional steps before compilation, like fixig up a "Makefile" or removing stuff, you need to enhance it. If you don't need to fix up things, just don't add src_unpack to your ebuild and the default method will be used. Let's image kickball brings a broken Makefile and a binary with it. So we got to fix that.

'src_unpack() {
        unpack ${A}
	cd "${S}"
	sed -i \
		-e "/TARGET/s:/usr/bin/:${GAMES_BINDIR}:" Makefile
		|| die "sed Makefile failed"
	rm kickball
}'

This already shows several important things.

3.2.2.1 Directory change
You have to quote "${S}" here. Quoting cannot be harmfull, but omitting it can.

3.2.2.2 sed
We imagine a line like "TARGET=/usr/bin/" in the games Makefile. This is wrong, since game binaries go into "/usr/games/bin" in Gentoo Linux. Since we don't want to type this every time, there is a variable for that named "${GAMES_BINDIR}". Always use that variable if you refer to that directory. There are several others of this variables which will be explained later.
You can also use sed to fix up more thing is one file with a single call. It would look like this
'sed -i \
	-e "sed stuff here" \
	-e "more sed stuff" Makefile \
	|| die "sed Makefile failed"'
For more details look at the manpage for sed or try looking on the internet.

3.2.2.3
Also notice, that we add "|| die" behind such an important external command. This is necessary, since it stops the emerge process if that command failed. Never omit these. All important external command need it! Also don't use die without a reasonable message. Something like

'|| die "failed"'

or

'|| die'

is just stupid. It does not help anyone. Choose a wise description the shortly(!) describes what just failed. For example

'|| die "Whooha .... wow, sed went wrong. Totally wrong. See? I recommend turning of your computer and buying a new one."

or

'|| die "sed failed changing the Makefile from /usr/bin to /usr/games/bin. This happens in most cases because of bad regular expressions. Try do find out what went wrong, and report it. Since it worked fine for me."'

are just bad ideas. This is to long and noone is interested in it. Just use something like

'|| die "sed Makefile failed"'

to state, that sed tried to fix something in the Makefile, but for any reason it went wrong.

3.2.2.4 rm
This just removes the binary of the game. Remove only items that stop the ebuild from working when present. If there are for example Makefiles for 25 different system, plus a bunch of crap for MSVC, just ignore that. It won't be installed and deleted after the emerge process has finished. Also this rm does not have a "|| die" behind it. Let's imagine that compilation works even if that command fails, it just removes some warnings.

3.2.3 src_compile()
This method does the main compilation. If the game uses a nice configure script which produces a nice Makefile or even comes with a nice Makefile, you don't need to add this method. If you need to do additional steps, you need to add this method. By default it should look like this.

'src_compile() {
	egamesconf || die "egamesconf failed"
	emake || die "emake failed"
}'

See those two essential calls? Good. Let's think about what they do.

3.2.3.1 egamesconf
egamesconf is a nice wrapper around calling "./configure". If the game uses autotools, the wrapper is able to set all pathes according to the Gentoo Filesystem Specification. If it does not use autotools, calling egamesconf is still much better than calling "./configure" directly. You still can fix up the Makefile later or, even better, fix the configure script (Note: If you are to lame to fix the configure script and prefer fixing the Makefile, you should think of getting a motivation trainer).

3.2.3.2 emake
emake is a wrapper around calling make. Don't care what the real difference is, just call it to start compilation.

3.2.3.3 || die
Both of these commands are essential! You need to stop the emerge process if one failes.

3.2.4 src_install()
After compilation we compiled the game, we need to install it. By default, the game is not installed, so you need to write this method. If "emake install" does not work (since the Makefile simply has no rule to install data), you can do something like that:

'src_install() {
	dogamesbin "${PN}" || die "installing the binary failed"

	dodir "${GAMES_DATADIR}/${PN}" || die "creating data dir failed"
	cp -r data/* "${D}/${GAMES_DATADIR}/${PN}" || die "installing data failed"

	# optional
	doicon ${PN}.xpm
	make_desktop_entry ${PN} "KickBall" /usr/share/pixmaps/${PN}.xpm || die "failed creating desktop entry"

	prepgamesdirs
}'

This is quite a simple src_install, but already contains most interesting stuff. We won't explain "emake install" further, you should really know what it does if you read such a guide. Note that we have many "|| die" in here. This is necessary. Use these wisely in src_install.

3.2.4.1 dogamesbin
This command will install the binary of a game. It will more or less do the same as this

'dodir "${GAMES_BINDIR}" || die "creating binary dir failed"
insinto "${GAMES_BINDIR}"
doins "${PN}" || die "installing the binary failed"'

but looks nicer. Who wants to write 3 lines of code that could be done in 1 line?

3.2.4.2 dodir and "cp -r"
These calls take care that the data will get installed to a path like /usr/share/games/kickball. See that you need ${D} in the cp call, since that is not a ebuild specific call that adds it automatically. This is necessary since everything is built within a sandbox (a virtual file system).

3.2.4.3 prepgamesdirs
This is the last call within src_install. Don't care about what it does, but take care it's there! (Though I think it should go to pkg_postinst ... but not sure if that might work or might be usefull ... it's just the most forgotten call when I'm writing an ebuild)

3.2.4.4 egamesinstall
This script is provided by the eclass for installation with broken Makefiles. Try to avoid it's usage, but if "emake install" does not work and this one does, use it.

3.2.4.5 additional docs
Many packages come with a README, ChangeLog, TODO or something. If a package has such things, add

'dodoc "README ChangeLog TODO" || die "dodoc failed"'

to your ebuild. It is nice  having such small docs around. If you have docs (like comlpete manuals or something), add the dodoc call in an if case that checks the useflag. It might look like that:

'if use doc; then
	cd help
	dodoc manual
fi'

Take care to have the "doc" useflag in ISUE then.

3.2.5 Calling methods of the eclass
-- PICKED THAT UP ON IRC, NOT SURE IF INTERPRETED CORRECT, THEREFORE LEFT ALONE HERE --
If you add any other then then above methods (src_unpack, src_compile and src_install), take care you simply call the games.eclass equivalent to achieve there functionaly. For example you NEED to call "games_pkg_setup" in "pkg_setup"

3.3 games.eclass
----------------
The eclass is a masterpiece for everything game related. If you write an ebuild for a modification of the big ego shooters, there are seperate eclasses for achieving your goals, but I won't discuss these here. We focus on games.eclass.

3.3.1 Variables
As stated before many times the eclass provies variables especially for target directories.

GAMES_PREFIX: This variable is used as prefix for games. It's value is "/usr/games"
GAMES_PREFIX_OPT: This variable is used as prefix for binary games. It's value is "/opt" (Though I disagree with that, it should be /opt/games, imo)
GAMES_DATADIR: This variable tells where the data of game ends. So levels, sounds, images and so on will end in "/usr/share/games"
GAMES_DATADIR_BASE: This variable has the same prupose as GAMES_DATADIR, but some games add "games" themselves, so the value is "/usr/share"
GAMES_SYSCONFDIR: If a game really needs so global configuration, it will end in "/etc/games"
GAMES_STATEDIR: The game might need a storage during runtime, this will be "/var/games"
GAMES_LOGDIR: If the game logs data (like a dedicated server should do), this has to be in "/var/log/games"
GAMES_BINDIR: The binary of a game is not stored like other binaries, but in "/usr/games/bin"

As you can see, there are a bunch of variables. Take care the game works according to them. Some games want to write configuration to "/usr", that's wrong. Fix that or make upstream (the developers of the game) fix that.

3.3.2 Methods
FIXME

3.4 Patching
------------
If a game is broken and won't build or work unless you change bits in the source, you can add a patch for that. Just put it into the files directory of your ebuild directory and use 

'epatch ${FILESDIR}/${P}-gcc4.patch'

The prefered naming scheme is, as you can see, the name AND the version number of the game plus what the patch fixes.


4. Tips and Tricks
==================
4.1 Addion an icon
The call "doicon" will add a given icon to /usr/share/pixmaps. If a game provies an icon, just call

'doicon data/icon/${PN}.xpm'

If you added an icon within you files directory call

'doicon ${FILESDIR}/${PN}.png'

4.2 Adding an entry to the menu
If you are a really nice ebuild writer and a game does not have a desktop entry, you can add it! Just call "make_desktop_entry" with a usefull amount of parameters. Simple example for this

'make_desktop_entry ${PN} "KickBall" /usr/share/pixmaps/${PN}.xpm || die "failed creating desktop entry"'

This will create a .desktop file that executes ${PN}. The name of the .desktop file is "KickBall" and the icon it uses is /usr/share/pixmaps/${PN}.xpm. Simple, isn't it? For more parameters see /usr/portage/eclass/eutils.eclass.

4.3 Wrapper for binaries
If a game does not support that binary and data are in seperate directories, you can add a wrapper for that. If you do it by hand you add something like

'echo "#!/bin/sh
cd ${GAMES_DATADIR}/${PN}
./start-${PN}" > ${PN}
dogamesbin ${PN}'

Nice idea, but why write that every time? Use "games_make_wrapper"

'games_make_wrapper ${PN} start-${PN} ${GAMES_DATADIR}/${PN}'

This will exactly do the same.

4.4 Writing to /usr
You don't! No application is allowed to write to things in "/usr". State files need to go in "/var" (use GAMES_STATEDIR to find the right place)

4.5 The "-bin"
Call binary games with a postfix "-bin" and install them to "/opt" (GAMES_PREFIX_OPT)

4.6 Digest warnings
You just hack on an ebuild and every time it changes "emerge kickball" fails. You ran every time "build kickball-1.0.ebuild digest"? You no longer have to. Just run "emerge --digest kickball".


