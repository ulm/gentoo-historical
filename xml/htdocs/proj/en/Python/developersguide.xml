<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/Python/developersguide.xml,v 1.4 2007/07/11 01:54:28 hawking Exp $ -->

<guide link="/proj/en/Python/developersguide.xml" lang="en">
<title>Gentoo Python Developers Guide</title>

<author title="Author">
  <mail link="dev-zero@gentoo.org">Tiziano MÃ¼ller</mail>
</author>
<author title="Author">
  <mail link="hawking@gentoo.org">Ali Polatel</mail>
</author>

<abstract>
This guide is supposed to be a help for (new) Python developers.  Besides
valuable hints and tricks, there are guidelines for version bumps and drops,
stabilization, correct eclass usage, correct dependencies and tests.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.2</version>
<date>2007-07-03</date>

<chapter>
<title>Bumps, Drops, Stabilization</title>
<section>
<title>Version Bumps and Fixing Bugs</title>
<body>

<p>
Never bump one of the following packages yourself if permission to do so is not
explicitly granted by a (Co-)Lead:
</p>

<ul>
  <li>dev-lang/python</li>
  <li>dev-python/pycrypto</li>
</ul>

<p>
While doing version bumps is surely appreciated, don't do it blindly. There were
many bugs in the past which had been carried from version to version without
being noticed. Make also sure that you check bugzilla <b>before</b> the bump to
see whether there are open bugs for the package. Reading the ChangeLog of a
package is also a good idea to catch new, changed or optional dependencies.
</p>

<p>
Not all existing ebuilds in the tree use the eclasses properly (see below), so
please fix bugs on sight.  Build the packages you're bumping or fixing even on
small changes. Not all ebuilds have been written carefully while others might
have been perfect when they have been committed. But over time, practice and
rules change.
</p>

<p>
The same goes for fixing bugs in the ebuilds. Please check whether there is a
new version of the package out and do a version bump accordingly. Closing bugs
is good, but not enough. Your primary objective should not be to close bugs but
to maintain the packages in the herd.
</p>

<p>
Ask for and do peer reviews. With such a practice, ebuild quality increases and
it is a good way to transfer knowledge.
</p>
</body>
</section>
<section>
<title>Dropping old versions and Stabilization</title>
<body>
	
<p>
Every team member should try to keep the package folders clean and uncluttered.
Besides the obvious checks (last stable for an arch, last not p.masked, other
packages depend on an exact version of this package), there are some other
things which you should consider before dropping an old version:
</p>

<ul>
  <li>
    When dropping an unstable version in the presence of a stable one: Does the
    version you are going to drop have serious bugs which avoid stabilization?
    Otherwise you might keep it and open a stabilization bug.
  </li>
  <li>
    The same consideration also applies if there is no stable version yet: Are
    there users who might want a stable version? Is this package mature enough
    to go stable? If you decide to stabilize it, also think about how arch team
    members could test it.
  </li>
  <li>
    Do not stabilize alpha and beta versions nor release candidates wherever
    possible. There are exceptions to this (if upstream just produces beta-ware
    or the package is desperately needed for another app). If unsure, talk to
    the Lead first.
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>Correct eclass usage</title>
<section>	
<body>
	
<p>
There are currently 3 python related eclasses: <b>python</b>, <b>distutils</b>
and <b>twisted</b>.
</p>

</body>
</section>
<section>
<title>python.eclass</title>
<body>
	
<p>
Here are some important things to remember when using this eclass:
</p>

<ul>
  <li>Call python_version before using PYVER, PYVER_MINOR or PYVER_MAJOR.</li>
  <li>
    Insert a line "NEED_PYTHON=MY_VERSION" before the inherit to depend on
    python.  If you don't need a specific version, put <c>virtual/python</c> in
    DEPEND/RDEPEND.
  </li>
  <li>
    If you don't use <b>distutils</b> (and/or your package installs
    <path>.py</path> files somewhere else than site-packages), you have to call
    python_mod_optimize and python_mod_cleanup yourself. If your package doesn't
    install itself into a subdir, omit "/YOURPACKAGE". You can pass any path you
    want to python_mod_optimize/cleanup. python_mod_cleanup will also remove
    empty directories after the cleanup. If you call python as root,
    <path>.py</path> files will get byte-compiled to <path>.pyc</path> but not
    recorded in the package's CONTENTS. They therefore won't get removed on
    update/removal of the package.
  </li>
</ul>

<pre caption="Optimize/cleanup idiom">
<keyword>inherit</keyword> python multilib

[...]

<stmt>pkg_postinst()</stmt> {
	<keyword>python_version</keyword>
	<keyword>python_mod_optimize</keyword> <var>${ROOT}</var>usr/$(get_libdir)/python<var>${PYVER}</var>/site-packages/YOURPACKAGE
}

<stmt>pkg_postinst()</stmt> {
	<keyword>python_mod_cleanup</keyword>
}
</pre>

<impo>
If the package's setup byte-compiles installed <path>.py</path> files, it's a
good idea to disable this and use python_mod_optimize to prevent unexpected
problems.
</impo>

<warn>
python_mod_optimize is only _partially_ ROOT-aware; you have to specify $ROOT if
you want a different package while python_mod_cleanup adds $ROOT automatically.
To prevent any kind of problems don't use $ROOT if you have to call
python_mod_cleanup with a path argument!
</warn>

</body>
</section>
<section>
<title>distutils.eclass</title>
<body>
	
<ul>
  <li>
    To depend on a specific version of python, put NEED_PYTHON=MY_VERSION before
    the inherit (rather than DEPEND/RDEPEND on
    <c>dev-lang/python-MY_VERSION</c>) or leave it away to implicitly depend on
    <c>virtual/python</c> through the <b>distutils</b> eclass.
  </li>
  <li>
    If the ebuild name (in ${PN}) differs from the folder created by the package
    in <path>site-packages/</path>, you have to define a variable PYTHON_MODNAME
    to tell <b>distutils</b> where to look for the module.
  </li>
  <li>
    Set the DOCS variable to install additional (pure-text) docs. If you write
    the src_install-function, you can put the definition of the DOCS var in the
    function but before calling distutils_src_install.
  </li>
</ul>

<pre caption="PYTHON_MODNAME usage (example from ipython-0.7.3.ebuild)">
<comment># Copyright 1999-2007 Gentoo Foundation</comment>
<comment># Distributed under the terms of the GNU General Public License v2</comment>
<comment># $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/Python/developersguide.xml,v 1.4 2007/07/11 01:54:28 hawking Exp $</comment>

<ident>NEED_PYTHON</ident>=2.3

<keyword>inherit</keyword> distutils

<ident>DESCRIPTION</ident>="An advanced interactive shell for Python."
<ident>HOMEPAGE</ident>="http://ipython.scipy.org/"
<ident>SRC_URI</ident>="http://ipython.scipy.org/dist/${P}.tar.gz"

<ident>LICENSE</ident>="BSD"
<ident>SLOT</ident>="0"
<ident>KEYWORDS</ident>="~amd64 ~ia64 ~ppc ~s390 ~x86"
<ident>IUSE</ident>="doc examples emacs gnuplot test"

<ident>DEPEND</ident>="test? ( dev-python/pexpect )"
<ident>RDEPEND</ident>="gnuplot? ( dev-python/gnuplot-py )"

<ident>PYTHON_MODNAME</ident>="IPython"

[...]
</pre>

<pre caption="DOCS idiom">
<stmt>src_install()</stmt> {
	<ident>DOCS</ident>="foo.txt bar.txt"
	<keyword>distutils_src_install</keyword>
	<keyword>dohtml</keyword> foo.html bar.png
}
</pre>

<note>
distutils.eclass defines the DDOCS variable with common doc file names and they
are installed by default as docs. If the name of the doc file you want to
install is there you don't have to specify a DOCS variable.
</note>

<pre caption="DDOCS variable in distutils.eclass">
<ident>DDOCS</ident>="CHANGELOG KNOWN_BUGS MAINTAINERS PKG-INFO CONTRIBUTORS TODO NEWS"
<ident>DDOCS</ident>="<var>${DDOCS}</var> Change* MANIFEST* README*"
</pre>

</body>
</section>
<section>
<title>twisted.eclass</title>
<body>
	
<p>
TBD
</p>

</body>
</section>
</chapter>

<chapter>
<title>Ebuild writing</title>
<section>
<body>
	
<p>
Here are some important things to keep in mind when writing ebuilds for python
packages.
</p>

</body>
</section>
<section>
<title>Calling python in ebuilds</title>
<body>
	
<p>
To call python in one of your ebuilds, use "${python}" to do it (defined in
distutils.eclass).
</p>

</body>
</section>
<section>
<title>Checking for tkinter support</title>
<body>
	
<p>
To check whether python has tkinter support you can use one of
python_tkinter_exists (from python.eclass) or distutils_tkinter_exists (from
distutils.eclass) in pkg_setup. These two functions are identical.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Common Problems and Mistakes</title>
<section>
<body>
	
<p>	
Below are common problems you may face and common mistakes made when writing
ebuilds for python packages.
</p>

</body>
</section>
<section>
<title>setuptools: *_require and use_setuptools()</title>
<body>
	
<impo>
For setuptools-0.6a9 and newer you no longer have to remove _require options
other than tests_require because starting with this version
--single-version-externally-managed is made automatic when --root is used which
solves the problem. The new distutils_src_unpack function handles
use_setuptools() problems. The methods explained in this section - i.e. removing
_requires and use_setuptools() with sed - shouldn't be used anymore.
</impo>

<p>
Packages that use setuptools to install use _require options like
tests_require,install_require,setup_requires in setup.py. These are nice to
learn about dependencies but you don't want them in setup.py when you're
installing the package. The following is from the <uri
link="http://peak.telecommunity.com/DevCenter/setuptools">setuptools
homepage</uri> section on <b>setup_requires</b>:
</p>

<p by="setuptools developer's guide">
A string or list of strings specifying what other distributions need to be
present in order for the setup script to run. setuptools will attempt to obtain
these (<b>even going so far as to download them using EasyInstall</b>) before
processing the rest of the setup script or commands.
</p>

<p>
We have lovely package managers which can download stuff for us and verify their
digests thus we don't want to download any packages using EasyInstall. There are
other options like tests_require, install_requires that behave the same way.
</p>

<p>
Some packages have a ez_setup.py along with the usual setup.py. This is a python
script to download and install appropriate setuptools. To do this
use_setuptools() is called from ez_setup.py before importing setuptools.
</p>

<pre caption="use_setuptools() from ez_setup.py">
<keyword>def</keyword> <stmt>use_setuptools</stmt>(
    version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=os.curdir,
    download_delay=15
):
    """Automatically find/download setuptools and make it available on sys.path
    [...]
</pre>

<p>
Just like the _require options, if a setup.py script calls use_setuptools() from
ez_setup.py you should remove it. Below is an example which illustrates how to
do it.
</p>

<pre caption="setup.py of dev-python/myghty-1.1">
<keyword>from</keyword> ez_setup <keyword>import</keyword> use_setuptools
<stmt>use_setuptools</stmt>()
<keyword>from</keyword> setuptools <keyword>import</keyword> setup, find_packages

[...]

<ident>install_requires</ident>=["Routes >= 1.0", "Paste", "PasteDeploy", "PasteScript"],

[...]
</pre>

<pre caption="myghty-1.1.ebuild">
<stmt>src_unpack</stmt>() {
	<keyword>unpack</keyword> <var>${A}</var>
	<keyword>cd</keyword> "<var>${S}</var>"
	<keyword>sed</keyword> -i \
		-e '/use_setuptools/d' \
		-e '/install_requires=\[.*\],/d' \
		setup.py || <keyword>die</keyword> "sed failed"
}
</pre>

</body>
</section>
<section>
<title>src_test and PYTHONPATH</title>
<body>
	
<p>
When testing python packages it's important to make sure we're actually testing
the package that is going to be merged not the already installed package. We can
solve the problem by setting the PYTHONPATH environment variable which augments
the default search path for module files. Here are two examples:
</p>

<pre caption="src_test of dev-python/mechanize-0.1.7b -- a pure python module">
<stmt>src_test()</stmt> {
	<ident>PYTHONPATH</ident>=build/lib/ "<var>${python}</var>" test.py || <keyword>die</keyword> "tests failed"
}
</pre>

<pre caption="src_test of dev-python/pyme-0.6.0-r1 -- a python module written in C">
<stmt>src_test()</stmt> {
	<ident>PYTHONPATH</ident>="<var>$(ls -d build/lib.*)</var>" "<var>${python}</var>" examples/genkey.py || <keyword>die</keyword> "genkey test failed"
}
</pre>

<p>
As you may have noticed if the module is written in languages like C, C++, etc.
the name of the directory in build varies between architectures but it always
starts with <path>lib</path>.
</p>

</body>
</section>
</chapter>
</guide>
