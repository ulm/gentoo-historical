<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "http://www.gentoo.org/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/qa/backtraces.xml,v 1.1 2006/04/28 20:04:14 flameeyes Exp $ -->

<guide link="/proj/en/qa/backtraces.xml" lang="en">
<title>How to get meaningful backtraces in Gentoo</title>

<author title="Author">
  <mail link="flameeyes@gentoo.org">Diego Petten√≤</mail>
</author>

<author title="Hardened toolchain information">
  <mail link="solar@gentoo.org">Ned Ludd</mail>
</author>

<author title="Hardened toolchain and x86 architecture information">
  <mail link="kevquinn@gentoo.org">Kevin Quinn</mail>
</author>

<abstract>
This guide is meant to provide users with a simple explanation of why a default
Gentoo installation does not provide meaningful backtraces and how to set it up
to get them.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.5</version>
<date>2006-04-28</date>

<chapter> <!-- Introduction -->
<title>Backtraces with Gentoo</title>

<section>
<title>What are backtraces?</title>

<body>

<p>
A <e>backtrace</e> (sometimes also called bt, trace, or stack trace) is a human
readable report of the calling stack of a program. It tells you in which point
of a program you are and how you reached that point through all the functions
up to <path>main()</path> (at least in theory).
Backtraces are usually analyzed when error conditions such as segmentation
faults or aborts are reached using debuggers like <c>gdb</c> (GNU debugger), to
find the originating cause of the error.
</p>

<p>
A meaningul backtrace contains not only the shared objects where the call was
generated, but also the name of the function, the filename and the line where
it stopped. Unfortunately on a bare system optimised for performance and to
avoid waste of disk space, the backtraces are useless, and show only the
pointers on the stack and a series of ?? instead of the functions' names and
position.
</p>

<p>
This guide will try to show how it's possible to get useful, meaningful
backtraces in Gentoo, by using the features that Portage makes available to
users.
</p>

</body>
</section>

<section> <!-- Compiler flags -->
<title>Compiler flags</title>

<body>

<p>
By default <c>gcc</c> does not build debug information inside the objects
(libraries and programs) that it builds, as they make bigger results. Also,
many optimisations mess up the way the debug information is saved. For these
reasons, the first thing to pay attention to is to set the CFLAGS so that they
generate useful debug information.
</p>

<p>
The basic flag to add in this case is <c>-g</c>, that tells the compiler to
include in the objects extra information such as filenames and line numbers.
This is usually enough to have basic backtraces, but more information can be
added with the flags <c>-g2</c> and <c>-ggdb</c>. There is actually another flag
(<c>-g3</c>), but its usage is not recommended as it seems to break binary
interface and might lead to extra crashes, for instance <path>glibc</path>
itself breaks when built with that flag. If you want to provide as much
information as possible, you should use <c>-ggdb</c> flag.
</p>

<pre caption="Example of CFLAGS with debug information">
CFLAGS="-march=k8 -O2 -ggdb"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Optimisations also have to be moderated, for instance the <c>-O</c> flag, used
to set one of the predefined optimisations levels, should be used with caution.
If you really need a precise backtrace you should use <c>-O1</c> (using the
optimisations of level 0 is not recommended as there are known issues with gcc
building invalid code), but for generic backtraces <c>-O2</c> and <c>-Os</c> are
fine, too. Instead <c>-O3</c> is unwise to use while trying to debug something
as it enables extra optimisations that will probably screw up the information
needed for debugging purposes.
</p>

<p>
Note for x86 architecture users: x86 users frequently have
<c>-fomit-frame-pointer</c> in their CFLAGS - x86 has a limited set of general
registers and this can make an extra register available which improves
performance. However there is a cost, and that cost is to make it impossible for
gdb to "walk the stack", in other words to generate a backtrace reliably.
Therefore, remove this flag from CFLAGS in order to build something that is
easier for <e>gdb</e> to understand. Most other platforms do not have to worry;
either they generally don't set -fomit-framepointer anyway, or the code
generated by <c>gcc</c> does not confuse <c>gdb</c> (in which case the flag is
already enabled by <c>-O2</c> optimisation level).
</p>

<p>
For hardened users, there are other things to worry about. The
<uri link="http://www.gentoo.org/proj/en/hardened/hardenedfaq.xml#hardeneddebug">hardened
FAQ</uri> provides the hextra hints and tips you need to knnow.
</p>

</body>
</section>

<section> <!-- Stripping -->
<title>Stripping</title>

<body>
<p>
Just changing your CFLAGS and re-emerging world won't give you meaningful
backtraces anyway, as you have to solve the stripping problem. By default
Portage strips binaries, in other words it removes the sections that are not
needed to run them to reduce the size of the installed files. This is a good
thing for an average user not needing useful backtraces, but removes all the
debug information generated by <c>-g*</c> flags, and also the symbol tables
that are used to find the base information to show a backtrace in human readable
form.
</p>

<p>
There are two ways to stop stripping interfering with debug and useful
backtraces. The first is to tell Portage to not strip binaries at all, by adding
<e>nostrip</e> to FEATURES. This leave the installed files exactly as <c>gcc</c>
created them, with all the debug information and symbols' tables, which
increases the disk space occupied by executables and libraries. To avoid this
problem, in Portage version 2.0.54-r1 and 2.1 series it's possible to use the
<e>splitdebug</e> FEATURE instead.
</p>

<p>
With <e>splitdebug</e> enabled, Portage will still strip the binaries installed
in the system, but before doing that all the useful debug information is copied
to a ".debug" file, that is then installed inside <path>/usr/lib/debug</path>
(the complete name of the file would be given by appending to that the path 
where the file is actually installed); the path to that file is then saved
in the original file inside an ELF section called ".gnu_debuglink", so that
<c>gdb</c> knows which file to load the symbols from.
</p>

<impo>
If you enable both <e>nostrip</e> and <e>splitdebug</e> features, Portage won't
strip binaries at all, so you have to pay attention to what you want.
</impo>

<p>
Another advantage of <e>splitdebug</e> is that it doesn't require you to rebuild
the package to get rid of the debug information in case you built some of them
with debug enabled to be able to get a backtrace of a single error. Once it's
fixed, you just need to remove the <path>/usr/lib/debug</path> directory.
</p>

<p>
To be sure not to strip binaries, you have also to be sure that you don't have
the <c>-s</c> flag set in your LDFLAGS, as that tells the linker to strip the
resulting binaries in the link phase. Also note that using that flag might lead
to further problems as it won't respect the strip restrinctions imposed by some
packages which stop working when stripped entirely.
</p>

<note>
Some packages unfortunately handle stripping by themselves, inside the upstream
provided makefiles. This is an error and should be reported, as all packages
should leave Portage the task of the stripping or simply restrict stripping
entirely. The main exception to this are binary packages, that are usually
already stripped by upstream, thus outside of Portage control.
</note>

</body>

</section>

<section> <!-- Introducing gdb -->
<title>Introducing gdb</title>

<body>

<p>
Once your packages are built with debug information and are not stripped, you
just need to get the backtrace. To do so you need the <path>sys-devel/gdb</path>
package that contains the GNU debugger (<c>gdb</c>). After installing that, you
can proceed with getting the backtrace. The simplest way to get one is to run
the program from inside <c>gdb</c>. To do so, you need to point gdb to the path
of the program to run, give it the it will need, and then run it:
</p>

<pre caption="Running ls through gdb">
$ <i>gdb /bin/ls</i>
GNU gdb 6.4
[...]

(gdb) <i>set args /usr/share/fonts</i>
(gdb) <i>run</i>
Starting program: /bin/ls /usr/share/fonts
[Thread debugging using libthread_db enabled]
[New Thread 47467411020832 (LWP 11100)]
100dpi  aquafont     baekmuk-fonts  cyrillic  dejavu     fonts.cache-1  kochi-substitute  misc  xdtv
75dpi   arphicfonts  CID            default   encodings  fonts.dir      mikachan-font     util

Program exited normally.
(gdb)
</pre>

<p>
The message "Program exited normally" means that the program exited with the
code 0, that means that no errors were reached. You shouldn't trust that too
much as there are programs that exits with status 0 also when they reach error
conditions. Another common message is "Program exited with code <e>nn</e>", that
simply tells you which non-zero status code they returned. That might imply a
handled or expected error condition. For segmentation faults and aborts you get
instead a "Program received signal SIGsomething" message.
</p>

<p>
When a program receives a signal it might be for many different reasons. In case
of SIGSEGV and SIGABRT (respectively Segmentation Fault and Abort), it usually
means that the code is doing something wrong, like doing a wrong syscall or
trying to access memory through a broken pointer. Other common signals are
SIGTERM, SIGQUIT and SIGINT (the latter is received when CTRL-C is sent to the
program, and usually gets caught by <c>gdb</c> and ignored by the program).
</p>

<p>
Finally there is the series of "Real-Time events", that are named SIG<e>nn</e>
with <e>nn</e> being a number greater than 31. These are usually used by the
pthread implementation to syncronise the different threads of the program, and
thus don't represent error conditions of any sort. It's easy to provide
meaningless backtraces when confusing the Real-Time signals with error
conditions. To prevent this you can tell gdb to not stop the program when they
are received, and instead pass them directly to the program, like in the
following example.
</p>

<pre caption="Running xine-ui through gdb ignoring real-time signals.">
$ <i>gdb /usr/bin/xine</i>
GNU gdb 6.4
[...]

(gdb) <i>run</i>
Starting program: /usr/bin/xine
[...]

Program received signal SIG33, Real-time event 33.
[Switching to Thread 1182845264 (LWP 11543)]
0x00002b661d87d536 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
(gdb) <i>handle SIG33 nostop noprint noignore pass</i>
Signal        Stop      Print   Pass to program Description
SIG33         No        No      Yes             Real-time event 33
(gdb) <i>kill</i>
Kill the program being debugged? (y or n) <i>y</i>
(gdb) <i>run</i>
</pre>

<p>
The <c>handle</c> command tells gdb what it should do when the given signal is
sent to the command; in this case the flags are <c>nostop</c> (don't stop the
program returning the command to the debugger), <c>noprint</c> (don't bother
printing the receiving of such signal), <c>noignore</c> (don't ignore the signal,
ignoring signal is dangerous, as it means discarding them without passing them
to the program), <c>pass</c> (pass the signal to the debugged program).
</p>

<p>
After the eventual Real-Time events are being ignored by <c>gdb</c>, you should
try to reproduce the crash that you want to report, if you can reproduce it
systematically it's quite easy. When <c>gdb</c> tells you that the program
received the SIGSEGV or SIGABRT signal (or whatever else signal might represent
the error condition for the program), you'll have to actually ask for the 
backtrace, possibly saving it somewhere. The basic command to do that is
<c>bt</c>, a short for <c>backtrace</c>, which will show you the backtrace of
the current thread (if the program is single-thread there's only one thread).
</p>

<p>
An alternative command to get a more detailed backtrace is <c>bt full</c>, that
gives you also the information about parameters and local variables to the
function where calls are being made (when they are available and are not being
removed by optimisations). This makes the trace longer, but also more useful
when trying to find, for example, why a pointer is uninitialised.
</p>

<p>
Lately it's not rare that also simple programs are written with multiple threads,
making the use of a simple <c>bt</c> output, albeit meaningful, quite useless,
as it might represente the status of a thread different from the one the signal
is thrown, or from the one where the error condition manifested (in case there's
another thread responsible for throwing signals). For this reason, you should
rather get the trace with the longer command <c>thread apply all bt full</c>,
that tells the debug to print the full tracing of all the threads currently
running.
</p>

</body>
</section>

<section> <!-- Core dumps -->
<title>Core dumps</title>

<body>

<p>
Sometimes the crashes are difficult to reproduce, the program is vastly threaded,
it's too slow to run in <c>gdb</c> or it's messed up when run through that
(shouldn't surprise anybody that running inside the debugger there are more bugs
than are reproduceable without the debugger itself). In these cases there is one
tool that comes useful and it's the core dump.
</p>

<p>
A core dump is a file that contains the whole memory area of a program when it
has crashed, using that file, it's possible to extract the stack backtrace also
if the program has crashed outside <c>gdb</c>, of course if core dumps are
enabled. By default core dumps are not enabled on Gentoo Linux (they are,
however, enabled by default on
<uri link="http://www.gentoo.org/proj/en/gentoo-alt/bsd/fbsd/">Gentoo/FreeBSD</uri>)
so you have to enable them.
</p>

<p>
Core dumps can be enabled on either system level or shell session level. In the
first case, everything in the system that crashes and does not have already a
crash handler (see later for more notes about KDE's crash handler), while when
enabled at shell session level only the programs started from that session will
leave behind them the dump.
</p>

<p>
To enable core dumps on system level you have to edit either the file
<path>/etc/security/limits.conf</path> (if you're using PAM as is the default)
or <path>/etc/limits.conf</path>. In the first case you have to define a limit
(whether hard or -most commonly- soft for core files, that might be 0 to not have
a limit), in the latter you just need to set the variable C to the size limit
of a core file (here there's no "unlimited").
</p>

<pre caption="Example of rule to get unlimited core files when using PAM">
# /etc/security/limits.conf
*             soft      core       0
</pre>

<pre caption="Example of rule to get core files up to 20MB when not using PAM">
# /etc/limits.conf
*       C20480
</pre>

<p>
To enable core files on a single shell session you can use the <c>ulimit</c>
command with the <c>-c</c> option. 0 means disabled, any other positive number
is the size in KB of the generated core file, while <e>unlimited</e> simply
removes the limit on core file dimension. From that point on all the programs
that exits because of a signal like SIGABRT or SIGSEGV will leave behind them a
core file that might be called either "core" or "core.<e>pid</e>" (where pid is
replaced with the actual pid of the program that died).
</p>

<pre caption="Example of ulimit usage">
$ <i>ulimit -c unlimited</i>
$ <i>crashing-program</i>
[...]
Abort (Core Dumped)
$ 
</pre>

<note>
The <c>ulimit</c> command is an internal command in bash and zsh, on other
shells it might be called in other ways or might even not be available at all.
</note>

<p>
After you get a core dump you can run gdb on it specifying both the path to the
file that generated the core dump (it has to be the same exact binary, so if you
recompile the core dump is useless) and the path to the core file. Once you have
gdb open on it you can follow the same instructions given above as it had just
received the signal killing it.
</p>

<pre caption="Starting gdb on a core file">
$ <i>gdb $(which crashing-program) --core core</i>
</pre>

<p>
As an alternative, you can use <c>gdb</c>'s commandline capabilities to get the
backtrace without entering the interactive mode, which makes also easier to save
the backtrace on a file or to send it to a pipe of any kind. The trick lies on
the <c>--batch</c> and <c>-ex</c> options that are accepted by <c>gdb</c>
command. You can use the following bash function to get the full backtrace of a
core dump (including all threads) on the standard output stream.
</p>

<pre caption="Function to get the whole backtrace out of a core dump">
gdb_get_backtrace() {
    local exe=$1
    local core=$2

    gdb ${exe} \
        --core ${core} \
        --batch \
        --quiet \
        -ex "thread apply all bt full" \
        -ex "quit"
}
</pre>

</body>

</section>

<section> <!-- KDE crash handler's notes -->
<title>KDE crash handler's notes</title>

<body>

<p>
KDE-based applications runs by default with their own crash handler, that is
presented by the user by the means of "Dr. Konqi" if it's installed (the
package is either <path>kde-base/kdebase</path> or <path>kde-base/drkonqi</path>
(included in <path>kdebase-meta</path>). This crash handler shows to the user
an informative dialog telling him that the program has crashed. On this dialog
there is a "Backtrace" tab that, when loaded, calls gdb and makes it load the
data and generate the full backtrace on the behalf of the user, showing it in
the main text box and allowing to save it directly to file. That backtrace is
usually good enough for reporing a problem.
</p>

<p>
When drkonqi is not installed, the crashes won't generate a core dump anyway,
and the user will remain without no information by default. To avoid this, it's
possible to use the <c>--nocrashhandler</c> commandline on all the KDE-based
applications, that disables the crash handler entirely and leaves the signals
to be handled by the operating system as usual. This is useful to geenerate core
files when drkonqi is not available or when wanting to inspect stack frames by
hand.
</p>

</body>

</section>

<!-- TODO
     - add notes about GNOME's crash handler
     - add notes about renaming core dump files
-->

</chapter>

</guide>

<!-- kate: space-indent on; indent-width 2; replace-tabs on; indent-mode normal; -->
