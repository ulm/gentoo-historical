<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/es/hardened/selinux/hb-using-configuring.xml,v 1.6 2013/01/02 18:28:08 nimiux Exp $ -->

<sections>

<version>4</version>
<date>2012-12-29</date>

<section>
<title>Administrando usuarios</title>
<subsection>
<title>Introducción</title>
<body>

<p>
A lo largo de la instalación, hemos hablado de como mapear un usuario
Linux a uno SELinux. En el ejemplo, hemos utilizado un usuario
hipotético llamado "juan" y lo hemos mapeado al usuario SELinux
"staff_u". Si está corriendo un sistema multiusuario, la gestión de los
mapeos de derechos es importante. Un usuario que se mapea al usuario
"user_u" no obtendrá ningún derecho adicional. Incluso si le concediera
derechos adicionales a través de órdenes como <c>sudo</c>, la
directriz de SELinux no le permitiría a este usuario hacer nada que esté
relacionado con la administración.
</p>

<p>
Por esta razón, es importante tratar los mapeos de usuarios en SELinux y
los usuarios Linux de su sistema.
</p>

</body>
</subsection>
<subsection>
<title>Mapeos de usuario</title>
<body>

<p>
Ejecute <c>semanage login -l</c> para mostrar los mapeos actuales entre
las cuentas de usuario Linux y los usuarios SELinux.
</p>

<pre caption="Ejecutar semanage login -l">
# <i>semanage login -l</i>

Login Name                SELinux User

__default__               user_u
root                      root
juan                      staff_u
system_u                  system_u
</pre>

<p>
El usuario SELinux "user_u" se utiliza para las cuentas normales. De esta
forma, el mapeo especial <e>__default__</e> se define en SELinux para
notar que esa cuenta no está definida de otra forma. Esto nos asegura
que una cuenta nueva nos obtiene privilegios elevados por defecto.
</p>

<p>
La siguiente tabla ofrece una vista rápida de los usuarios estándar
SELinux disponibles después de la instalación.
</p>

<table>
<tr>
  <th>Usuario SELinux</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti>user_u</ti>
  <ti>
    Usuario normal por defecto de SELinux, el cual se debe utilizar
    para las cuentas de usuario final que no van a ser empleadas para
    administrar ningún servicio del sistema.
  </ti>
</tr>
<tr>
  <ti>staff_u</ti>
  <ti>
    Usuario SELinux para administradores. Este usuario tiene derechos para
    conmutar roles y así ganar privilegios elevados.
  </ti>
</tr>
<tr>
  <ti>root</ti>
  <ti>
    Usuario SELinux para la cuenta root. Se diferencia ligeramente de la
    cuenta staff_u aparte de tener un identificador diferente. Esto
    nos asegura que los ficheros protegidos por el control de acceso
    basado en usuario para root no puede ser gestionado por los usuarios
    staff_u (y otros).
  </ti>
</tr>
<tr>
  <ti>sysadm_u</ti>
  <ti>
    Usuario SELinux para la administración del sistema. Por defecto,
    esta cuenta no se utiliza inmediatamente ya que este usuario obtiene
    de forma inmediata el rol administrativo (por lo que staff_u y root
    todavía necesitarán conmutar roles).
  </ti>
</tr>
<tr>
  <ti>system_u</ti>
  <ti>
    Usuario SELinux para administrar servicios. Nunca se debe utilizar
    para usuarios finales ya que ofrece acceso directo al rol del sistema
    (y sus privilegios).
  </ti>
</tr>
<tr>
  <ti>unconfined_u</ti>
  <ti>
    Usado cuando la directriz es <e>targeted</e>, este usuario SELinux
    tiene muchos privilegios (esencialmente no está limitado en sus
    acciones, aunque todavía se gestiona través de SELinux con una
    directriz "muy abierta").
  </ti>
</tr>
</table>

<p>
Para mapear una cuenta a un usuario especifico de SELinux, utilice la
orden <c>semanage login -a</c>:
</p>

<pre caption="Mapera la cuenta 'sofia' al usuario staff_u">
# <i>semanage login -a -s staff_u sofia</i>
</pre>

<p>
Sin embargo, cuando se actualiza este mapeo, los ficheros en el directorio
de inicio (home) del usuario serán propiedad de un usuario SELinux
incorrecto. Por ello, es importante etiquetar de nuevo los ficheros de
ese usuario:
</p>

<pre caption="Etiquetar de nuevo los ficheros de sofia">
# <i>restorecon -R -F /home/sofia</i>
</pre>

</body>
</subsection>
<subsection>
<title>Cuentas adicionales de SELinux</title>
<body>

<p>
Es perfectamente posible crear usuarios SELinux adicionales, y mapear
las cuentas Linux a esos nuevos usuarios. Esto se puede necesitar
cuando desee una auditoría más profunda (al nivel del usuario final) o
cuando esté mejorando la directriz con roles adicionales. También, si
quiere utilizar la característica de Control de Acceso Basada en
Usuario (UBAC), el hecho de usar diferentes usuarios SELinux es
importante para reforzar el control de los distintos usuarios (si
todos ellos utilizan el mismo usuario SELinux, el UBAC tendrá poco
efecto).
</p>

<p>
La gestión de los usuarios SELinux se realiza usando <c>semanage user</c>:
</p>

<pre caption="Crear un usuario SELinux">
# <i>semanage user -a -R "staff_r sysadm_r" sofia</i>
</pre>

<p>
Verifiquemos como los usuarios SELinux están configurados actualmente:
</p>

<pre caption="Comprobar las identidades de los usuarios SELinux">
# <i>semanage user -l</i>
SELinux User    SELinux Roles

root            staff_r sysadm_r
sofia           staff_r sysadm_r
staff_u         staff_r sysadm_r
sysadm_u        sysadm_r
system_u        system_r
unconfined_u    unconfined_r
user_u          user_r

# <i>semanage login -l</i>
Login Name                SELinux User

__default__               user_u
root                      root
sofia                     staff_u
swift                     staff_u
system_u                  system_u
</pre>

<p>
Ahora que hemos creado un nuevo usuario llamado "sofia", podemos
actualizar el mapeo de la cuenta Linux "sofia" hacia el nuevo usuario
SELinux "sofia":
</p>

<pre caption="Actualizar el mapeo del usuario Linux">
# <i>semanage login -m -s sofia sofia</i>
# <i>semanage login -l</i>
Login Name                SELinux User

__default__               user_u
root                      root
sofia                     sofia
swift                     staff_u
system_u                  system_u
</pre>

<p>
No olvide etiquetar de nuevo los ficheros de este usuario.
</p>

<p>
Como puede ver, la gestión de los usuarios SELinux implica definer el
rol al cual tiene acceso cada usuario. Hemos dado una introducción de
alto nivel a los roles por defecto en
<uri link="?part=1&amp;chap=2">Conceptos detrás de SELinux</uri>, sin
embargo ya que los roles son importantes cuando usamos un sistema
de Control de Acceso Obligatorio, refresquémos la memoria de nuevo:
</p>

<table>
<tr>
  <th>Rol SELinux</th>
  <th>Descripción</th>
</tr>
<tr>
  <ti>user_r</ti>
  <ti>
    Rol por defecto para el usuario final. Este rol ofrece acceso a las
    aplicaciones y actividades comunes, sin embargo, no permite la
    administración del sistema ni de ningún servicio más allá de lo
    esperado para un usuario normal.
  </ti>
</tr>
<tr>
  <ti>staff_r</ti>
  <ti>
    Rol de administración por defecto para las actividades diarias. Este
    rol posee privilegios adicionales más allá de los ofrecidos a
    user_r, sin embargo, no es un rol de administración del sistema
    completo. Está pensado para las actividades que no sean de
    administración realizadas por operadores y administradores.
  </ti>
</tr>
<tr>
  <ti>sysadm_r</ti>
  <ti>
    Rol de administración del sistema. Este role tiene privilegios muy
    elevados (ya que contiene aquellos privilegios necesarios para
    actualizar la directriz) y debería asignarse únicamente a
    administradores en los que se confíe plenamente. En casi ninguna
    situación es asignado a usuarios de forma inmediata (deben en
    primer lugar conmutar entre roles) excepto para el acceso directo
    de root (por ejemplo a través de la consola).
  </ti>
</tr>
<tr>
  <ti>system_r</ti>
  <ti>
    Rol de servicio del sistema, el cual se utiliza para los servicios
    que están corriendo (procesos). Se asigna únicamente a los usuarios
    cuando estos obtienen derechos específicos y limitados de
    administración (por ejemplo, derechos de administración sobre
    un único dominio de un demonio).
  </ti>
</tr>
<tr>
  <ti>unconfined_r</ti>
  <ti>
    El rol no confinado se utiliza cuando la directriz <e>targeted</e>
    está soportada. Este rol se asigna a usuarios no confinados (por
    ejemplo el usuario SELinux unconfined_u) los cuales tienen muchos
    privilegios (éstos trabajan prácticamente sin limitaciones).
  </ti>
</tr>
</table>

<p>
Se debe observar que estos roles son los que existen por defecto, sin
embargo, el administrador de seguridad puede crear roles adicionales
y añadir privilegios particulares. Hablaremos sobre esto más adelante
en este manual ya que implica que se debe actualizar la directriz
SELinux de Gentoo Hardened.
</p>

</body>
</subsection>
</section>

<section>
<title>Leyendo el registro de auditoría</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Cuando trabaje con un sistema que tiene habilitado SELinux, se dará
cuenta de que las cosas se comportan de forma diferente pero sin
indicar ningún mensaje de error con sentido. Normalmente, cuando
SELinux "deniega" un acceso en particular, lo almacena en el registro
de auditoría del sistema, aunque para la aplicación en si misma, es
perfectamente posible que muera de forma silenciosa. En caso contrario,
lo más seguro es que obtenga un mensaje de error <e>permiso denegado</e>.
</p>

<p>
Inicialmente, SELinux se ejecuta en modo <c>permisivo</c>, lo cual
significa que SELinux registrará lo que <e>denegaría</e> aunque nos
deje continuar. Este modo es perfecto para poner al sistema en forma
sin tener demasiados problemas mientras se hace esto. Una vez que
crea que sus ajustes de seguridad son correctos, se puede cambiar el
modo de <c>permisivo</c> a <c>forzado</c>. Hablaremos de esto más
adelante.
</p>

<p>
En primer lugar, echemos un vistazo al registro de auditoría y
veamos lo que se dice allí...
</p>

</body>
</subsection>
<subsection>
<title>Ubicación(es) del registro de auditoría</title>
<body>

<p>
El código del núcleo SELinux escribe las denegaciones de acceso (y
en alguna ocasión incluso las actividades que se permiten pero que
están siendo auditadas) en el registro de auditoría. Si está corriendo
una instalación Gentoo Hardened con el registrador del sistema
<c>syslog-ng</c>, entonces, el registrador ya está configurado para
colocar las líneas de auditoría en <path>/var/log/avc.log</path>.
Sin embargo, otros registradores de sistema podrían colocar estas
entradas en una ubicación diferente (por ejemplo
<path>/var/log/audit.log</path>).
</p>

<p>
Abajo encontrará las líneas para la configuración apropiada del
registrador del sistema syslog-ng de modo que escriba los eventos
en el fichero <path>/var/log/avc.log</path>.
</p>

<pre caption="Extracto de syslog-ng.conf para las entradas AVC de SELinux">
<comment># ¡Las siguientes líneas son solo una parte del fichero de configuración!</comment>
source kernsrc  { file("/proc/kmsg");       };
destination avc { file("/var/log/avc.log"); };
filter f_avc    { message(".*avc: .*");     };

log {
  source(kernsrc);
  filter(f_avc);
  destination(avc);
};
</pre>

</body>
</subsection>
<subsection>
<title>¿Qué es AVC?</title>
<body>

<p>
Como ya hemos mencionado, SELinux escribe sus entradas en el registro de
auditoría. Estas entradas se llaman <e>mensajes avc</e> o
<e>entradas de registro avc</e>. El acrónimo AVC significa
<e>Access Vector Cache</e> (Caché de Acceso Vectorial), tal y como indica
su nombre, se trata de un sistema caché.
</p>

<p>
Utilizar un sistema cache de acceso vectorial mejora el rendimiento
cuando se trata con (y se fuerzan) actividades y privilegios. Ya que
SELinux ofrece un enfoque muy detallado sobre privilegios y permisos,
sería tremendamente penoso (en lo que se refiere a rendimiento) si
cada llamada supusiera buscar el dominio, el recurso destino, el
privilegio y si está permitido o no, esto una y otra vez. En lugar
de esto, SELinux utiliza la Caché de Acceso Vectorial para almacenar
las solicitudes y respuestas pasadas. Es es sistema AVC el responsable
de comprobar los accesos y (si es necesario) registrarlos.
</p>

</body>
</subsection>
<subsection>
<title>Leyendo un mensaje de denegación en la AVC</title>
<body>

<p>
Abajo encontrará un mensaje típico de denegación en la AVC.
</p>

<pre caption="Ejemplo de mensaje de denegación en la AVC">
Oct 15 13:04:54 hpl kernel: [963185.177043] type=1400 audit(1318676694.660:2472):
  avc:  denied  { module_request } for  pid=14561 comm="firefox" kmod="net-pf-10"
  scontext=staff_u:staff_r:mozilla_t tcontext=system_u:system_r:kernel_t tclass=system
</pre>

<p>
Analicemos cada una de las partes de este mensaje una a una.
</p>

<pre caption="Denegación AVC: Fecha, hora e información de la ubicación">
<i>Oct 15 13:04:54 hpl kernel: [963185.177043]</i> type=1400 audit(1318676694.660:2472):
  avc:  denied  { module_request } for  pid=14561 comm="firefox" kmod="net-pf-10"
  scontext=staff_u:staff_r:mozilla_t tcontext=system_u:system_r:kernel_t tclass=system
</pre>

<p>
La primera parte del mensaje le informa del momento en el que se escribió
el mensaje (Oct 15 13:04:54), en qué equipo (hpl) y cuántos segundos
transcurrieron desde que se inició el sistema (963185.177043).
</p>

<pre caption="Denegación AVC: información fuente">
Oct 15 13:04:54 hpl kernel: [963185.177043] type=1400 audit(1318676694.660:2472):
  avc:  denied  { module_request } for  <i>pid=14561 comm="firefox"</i> kmod="net-pf-10"
  <i>scontext=staff_u:staff_r:mozilla_t</i> tcontext=system_u:system_r:kernel_t tclass=system
</pre>

<p>
La información que aparece después es el origen de la denegación, es decir,
qué proceso está intentando hacer qué cosa. En este caso, el proceso es
firefox, con identificador de proceso (PID) 14561, el cual está corriendo
en el dominio fuente staff_u:staff_r:mozilla_t.
</p>

<pre caption="Denegación AVC: recurso destino">
Oct 15 13:04:54 hpl kernel: [963185.177043] type=1400 audit(1318676694.660:2472):
  avc:  denied  { module_request } for  pid=14561 comm="firefox" <i>kmod="net-pf-10"</i>
  scontext=staff_u:staff_r:mozilla_t <i>tcontext=system_u:system_r:kernel_t</i> tclass=system
</pre>

<p>
El destino de la actividad es un módulo del núcleo (net-pf-10, el cual
es el nombre interno que se le da a IPv6), etiquetado
system_u:system_r:kernel_t
</p>

<pre caption="Denegación AVC: acción denegada">
Oct 15 13:04:54 hpl kernel: [963185.177043] type=1400 audit(1318676694.660:2472):
  avc:  denied  { <i>module_request</i> } for  pid=14561 comm="firefox" kmod="net-pf-10"
  scontext=staff_u:staff_r:mozilla_t tcontext=system_u:system_r:kernel_t <i>tclass=system</i>
</pre>

<p>
Por último, aparece la acción que ha sido denegada (module_request) y
su clase (system). Estas clases le ayudan a identificar qué es lo
que se ha denegado, ya que leer un fichero no el lo mismo que leer un
directorio.
</p>

<p>
Por ejemplo, en el siguiente caso, un proceso <c>gorg</c> con identificador
(PID) 13935 está intentando leer un fichero llamado
<path>localtime</path> con inodo 130867 el cual se encuentra en el
dispositivo <path>/dev/md3</path>:
</p>

<pre caption="Ejemplo de denegación AVC">
Oct 15 14:40:30 hpl kernel: [968909.807802] type=1400 audit(1318682430.323:2614):
  avc:  denied  { read } for  pid=13935 comm="gorg" name="localtime" dev=md3 ino=130867
  scontext=staff_u:sysadm_r:gorg_t tcontext=system_u:object_r:locale_t tclass=file
</pre>

<p>
En este caso debería ser obvio que el fichero es <path>/etc/localtime</path>,
sin embargo, cuando este no es el caso, las dos órdenes siguiente pueden
ser útiles:
</p>

<pre caption="Encontrar el recurso destino basándose en el inodo y dispositivo">
<comment>(Encontrar el dispositivo /dev/md3)</comment>
# <i>mount | grep /dev/md3</i>
/dev/md3 on / type ext4 (rw,seclabel,noatime,barrier=1,nodelalloc,data=journal)

<comment>(Encontrar qué fichero tiene el inodo 130867)</comment>
# <i>find / -xdev -inum 130867</i>
/etc/localtime
</pre>

</body>
</subsection>
<subsection>
<title>Gestionar las denegaciones AVC</title>
<body>

<p>
La mayor parte del trabajo para configurar SELinux es la lectura de las
denegaciones y encontrar lo que debe ser corregido (o ignorado),
corregirlo y repetir el proceso. Con un poco de suerte, el resto de
este manual le ayudará a averiguar lo que está causando la denegación.
</p>

<p>
Las denegaciones pueden ser cosméticas (una actividad que se deniega
pero que no tiene impacto en el comportamiento funcional de la aplicación).
Si este es el caso, se puede marcar la denegación como <e>dontaudit</e>,
(no auditar) indicando que, por defecto, la denegación ya no será
registrada. Si cree que se está denegando algo pero no lo ve en el
registro, intente deshabilitar las reglas <e>dontaudit</e>:
</p>

<pre caption="Deshabilitar dontaudit">
<comment>(Esta orden también se puede abreviar como "semodule -DB")</comment>
# <i>semodule --build --disable_dontaudit</i>
</pre>

<p>
En la mayoría de los casos, se debe actuar sobre las denegaciones. Las
acciones que entonces necesitará realizar son:
</p>

<ul>
  <li>
    Etiquetar de nuevo el recurso destino (las etiquetas erróneas pueden
    causar que acciones legítimas sean denegadas)
  </li>
  <li>
    Etiquetar de nuevo el origen (el fichero binario del proceso) ya que
    una etiqueta errónea puede causar que la aplicación se ejecute en
    el dominio incorrecto.
  </li>
  <li>
    Cargar el módulo SELinux necesario, ya que los módulos contienen
    reglas para permitir (y etiquetar) recursos. Sin el módulo
    correcto cargado, observará algunas denegaciones ya que no hay
    ningún módulo que realice las concesiones necesarios (sentencias
    para permitir las acciones).
  </li>
  <li>
    Conceder el rol adecuado al usuario que ejecuta la aplicación. Hemos
    cubierto los usuarios y sus roles inicialmente, sin embargo,
    profundizaremos en esto más adelante en este manual.
  </li>
  <li>
    Añadir sus propias sentencias de directriz SELinux, principalmente
    porque no existen módulos de directriz SELinux para la aplicación
    que está intentando ejecutar.
  </li>
</ul>

</body>
</subsection>
</section>

<section>
<title>Utilizar etiquetas (de fichero)</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Dentro de SELinux, los privilegios de acceso se basan en la etiqueta que
se da a la parte original (llamada <e>domain</e>) y a su recurso
destino. Por ejemplo, un proceso que corre en el dominio passwd_t quiere
leer (tener privilegio) el fichero <path>/etc/shadow</path> que está
marcado shadow_t (el recurso destino). No es sorprendente que la
mayoría de la administración de SELinux consiste en (re)etiquetar los
recursos de forma adecuada (y asegurarse que su etiqueta permanece
correcta).
</p>

</body>
</subsection>
<subsection>
<title>Obtener etiqueta(s) de fichero</title>
<body>

<p>
Existen varias formas de etiquetar de nuevo las órdenes y muchas de ellas
son iguales. Pero, antes de explicar esto más en detalle, echaremos un
vistazo a algunas etiquetas de fichero (y a cómo puede consultarlas).
</p>

<p>
En SELinux, las etiquetas se asignan al nivel del fichero a través de la
capacidad del sistema de mantener <e>atributos extendidos</e>.
Para SELinux, los atributos se llaman <c>security.selinux</c> y se
pueden obtener usando <c>getfattr</c>:
</p>

<pre caption="Obtener el atributo extendido de un fichero en SELinux">
$ <i>getfattr -n security.selinux /etc/hosts</i>
# file: etc/hosts
security.selinux="system_u:object_r:net_conf_t"
</pre>

<p>
Desde luego, obtener el atributo del fichero de esta forma, requiere
mucho tiempo y no es flexible. Para este propósito, la aplicaciones
más importante (incluyendo <c>coreutils</c>) se hacen compatibles con
SELinux. Estas aplicaciones en la mayoría de las ocasiones utilizan
la opción <c>-Z</c> para mostrar la información de contexto de SELinux.
En el caso de ficheros, esto implica el contenido de los atributos
extendidos.
</p>

<pre caption="Obtener el contexto de un fichero">
$ <i>ls -Z /etc/hosts</i>
system_u:object_r:net_conf_t   /etc/hosts
</pre>

<p>
Existen otras órdenes como <c>matchpathcon</c> que muestran el
contexto tal como debería ser. Sin embargo, su propósito es
consultar la directriz SELinux en su sistema para averiguar la
directriz que debería usarse, no la que se utiliza:
</p>

<pre caption="Diferencia entre resultados de contexto y resultados de matchpathcon">
$ <i>ls -Z /etc/make.conf</i>
staff_u:object_r:etc_t    /etc/make.conf
$ <i>matchpathcon /etc/make.conf</i>
/etc/make.conf            system_u:object_r:portage_conf_t
</pre>

</body>
</subsection>
<subsection>
<title>Ajustando la(s) etiqueta(s) de fichero</title>
<body>

<p>
Y ahora, ¿Cómo podemos manipular las etiquetas de fichero?. Bien, en
primer lugar: no se le permitirá cambiar las etiquetas de un fichero
(incluso si es el propietario del mismo) a menos que la directriz
SELinux se lo permita. Estas reglas de concesión se realizan sobre
dos tipos de privilegios: Las etiquetas que puede cambiar
(<c>relabelfrom</c>) y a qué etiquetas puede cambiar (<c>relabelto</c>).
Puede consultar estar regals usando <c>sesearch</c>:
</p>

<pre caption="Consultar los tipos relabelto y relabelfrom">
<comment># Desde qué etiqueta en los ficheros (-c) se permite (-A) a user_t (-s) etiquetar de nuevo (-p)?</comment>
$ <i>sesearch -s user_t -c file -p relabelfrom -A</i>
<comment>[...]</comment>
allow user_t mozilla_home_t : file { <comment>...</comment> relabelfrom relabelto } ;
</pre>

<p>
Si tiene permiso, entonces puede utilizar <c>chcon</c> para cambiar
(<e>ch</e>) el <e>con</e>texto de un fichero:
</p>

<pre caption="Cambiar el contexto de un fichero">
$ <i>ls -Z strace.log</i>
staff_u:object_r:user_home_t  strace.log
$ <i>chcon -t mutt_home_t strace.log</i>
$ <i>ls -Z strace.log</i>
staff_u:object_r:mutt_home_t  strace.log
</pre>

<p>
Si no posee los privilegios adecuados, obtendrá un mensaje de error
descriptivo:
</p>

<pre caption="Intentar cambiar el contexto de un fichero">
$ <i>chcon -t shadow_t strace.log</i>
chcon: failed to change context of `strace.log' to `staff_u:object_r:shadow_t': Permission denied
</pre>

<p>
Ahora, si cree que todo lo que necesita es la orden <c>chcon</c>, no está
en lo cierto. La orden <c>chcon</c> no hace nada más que lo que dice:
cambiar el contexto. Cuando el sistema etiqueta de nuevo los ficheros,
los cambios se van. El reetiquetado de los ficheros se realiza a menudo
para asegurarse de que las etiquetas son las correctas (es decir, las
etiquetas concuerdan con lo que la directriz SELinux dice que debería ser).
La directriz SELinux contiene, para cada módulo de directriz, la lista
de ficheros, directorios, zócalos (sockets), ... y sus contextos de
fichero apropiados (etiqueta).
</p>

<p>
Echaremos un vistazo a los módulos de directriz de SELinux más adelante.
Abajo puede encontrar un extracto de esta definición para el módulo
<c>mozilla</c>:
</p>

<pre caption="Extracto de los contextos de fichero del módulo mozilla">
/usr/bin/firefox-bin                            -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/bin/mozilla-[0-9].*                        -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/bin/mozilla-bin-[0-9].*                    -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/lib(64)?/galeon/galeon                     -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/lib(64)?/netscape/.+/communicator/communicator-smotif\.real -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/lib(64)?/netscape/base-4/wrapper           -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/usr/lib/[^/]*firefox[^/]*/plugin-container     -- gen_context(system_u:object_r:mozilla_plugin_exec_t,s0)
/usr/lib64/[^/]*firefox[^/]*/plugin-container   -- gen_context(system_u:object_r:mozilla_plugin_exec_t,s0)
</pre>

<p>
Para poner la etiqueta adecuada a un fichero, puede utilizar las órdenes
<c>setfiles</c> o <c>restorecon</c>. Debido a que ambas son la misma
orden (pero con una forma ligeramente diferente de utilización), ahora
hablaremos solo de <c>restorecon</c>. Se puede encontrar más información
acerca de la orden <c>setfiles</c> en su página del manual.
</p>

<p>
Cuando utilice <c>restorecon</c>, la aplicación consultará la directriz
SELinux para averiguar qué etiqueta debería ser la correcta para el
fichero. Si ésta es diferente, cambiará la etiqueta para que sea la
adecuada. Esto significa que no necesita ofrecer la etiqueta a un
fichero para que funcione la orden correspondiente. También,
<c>restorecon</c> soporta recursión, por lo que no necesita etiquetar
de nuevo los ficheros uno a uno.
</p>

<pre caption="Usar restorecon">
$ <i>ls -Z /etc/make.conf</i>
staff_u:object_r:etc_t            /etc/make.conf
$ <i>restorecon /etc/make.conf</i>
$ <i>ls -Z /etc/make.conf</i>
system_u:object_r:portage_conf_t  /etc/make.conf
</pre>

<p>
Por último, Gentoo también ofrece una aplicación muy útil: <c>rlpkg</c>.
Este guión etiqueta de nuevo los ficheros de un paquete Gentoo package
(<c>rlpkg &lt;nombredepaquete&gt;</c>) o, dando los argumentos adecuados,
todos los ficheros del sistema.
</p>

<pre caption="Usar rlpkg">
<comment># Etiquetar de nuevo los ficheros del paquete firefox-bin:</comment>
# <i>rlpkg firefox</i>

<comment># Etiquetar de nuevo todos los ficheros del sistema:</comment>
# <i>rlpkg -a -r</i>
</pre>

</body>
</subsection>
<subsection>
<title>Saltándose las etiquetas de fichero de la directriz de SELinux</title>
<body>

<p>
Puede que no esté siempre de acuerdo con la etiqueta que la directriz
de SELinux fuerza a los ficheros: puede que tenga sus ficheros ubicados
en otro lugar (una localización diferente de su árbol Portage es un buen
ejemplo) o quizá necesite etiquetarlos de forma diferente para que
funcionen otras aplicaciones. Para no tener que <c>chcon</c> estos
ficheros una y otra vez, puede mejorar la directriz SELinux en su
sistema con reglas adicionales de contextos de fichero. Estas reglas
también se utilizan cuando llama a <c>restorecon</c> y se salta las
reglas ofrecidas por la directriz SELinux.
</p>

<p>
Para añadir reglas de contexto de fichero adicionales, necesitará
usar la orden <c>semanage</c>. Esta orden se utiliza para manipular
y actualizar la directriz local de SELinux en su sistema. En este caso
en particular, utilizaremos la orden <c>semanage fcontext</c>:
</p>

<pre caption="Usar semanage para añadir una regla de contexto de fichero">
<comment># Marcar /mnt/gentoo/etc/make.conf como un tipo portage_conf_t</comment>
# <i>semanage fcontext -a -t portage_conf_t /mnt/gentoo/etc/make.conf</i>

<comment># Marcar /mnt/gentoo/usr/portage como portage_ebuild_t</comment>
# <i>semanage fcontext -a -t portage_ebuild_t "/mnt/gentoo/usr/portage(/.*)?"</i>
</pre>

<p>
Como puede observar en el ejemplo, puede utilizar caracteres comodín:
cuando una regla tiene caracteres comodín, tiene menor prioridad que
una regla que no los tiene. La prioridad de las reglas con caracteres
comodín se basa en lo "bajo" que está la cadena con la primera
ocurrencia del carácter comodín. Para más información, por favor,
consulte nuestras
<uri link="/proj/es/hardened/selinux-faq.xml#matchcontext">Preguntas
Frecuentes: ¿Cómo averiguo qué regla de contexto de fichero se está
utilizando para un fichero en particular?</uri>.
</p>

<p>
Si quiere eliminar una definición de contexto de fichero, puede utilizar
<c>semanage fcontext -d</c>:
</p>

<pre caption="Eliminar una definición de contexto de fichero">
# <i>semanage fcontext -d -t portage_ebuild_t /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
Por último, para ver todas las definiciones de contexto de fichero
(tanto las definidas por el usuario como las ofrecidas por la directriz
SELinux), puede utilizar <c>semanage fcontext -l</c>. Para ver únicamente
el conjunto local, añada <c>-C</c>:
</p>

<pre caption="Ver las mejoras en el contexto de ficheros definidas por el usuario">
# <i>semanage fcontext -C -l</i>
SELinux fcontext                          type             Context
/opt/xxe/bin/.*\.jar                      all files        system_u:object_r:lib_t
/srv/virt/gentoo(/.*)?                    all files        system_u:object_r:qemu_image_t
</pre>

</body>
</subsection>
<subsection>
<title>Tipos personalizables</title>
<body>

<p>
No es muy difícil comprender cómo funcionan las etiquetas sobre los
ficheros, sin embargo, puede encontrarse alguna sorpresa si no conoce
los tipos personalizables.
</p>

<p>
Un <e>tipo personalizable</e> es un tipo específico que por defecto
no es modificado por las herramientas de administración de SELinux.
Si quiere etiquetar de nuevo un fichero que actualmente posee un tipo
personalizable, necesitará forzarlo usando algunas órdenes (por ejemplo
<c>restorecon -F</c>).
</p>

<p>
No existe muchos tipos personalizables por defecto. La lista de tipos
que SELinux considera personalizables se indican en el fichero
<path>customizable_types</path> en la ubicación
<path>/etc/selinux/*/contexts</path>:
</p>

<pre caption="Listar los tipos personalizables">
# <i>cat /etc/selinux/strict/contexts/customizable_types</i>
mount_loopback_t
public_content_rw_t
public_content_t
swapfile_t
textrel_shlib_t
</pre>

<p>
Estos tipos existen porque se utilizan para los ficheros cuya ubicación
no es fija (y por lo tanto, la directriz de SELinux no puede asegurar
si la etiqueta de los ficheros es correcta o no). El tipo
<c>public_content_t</c>, que se utiliza para ficheros que se van a
leer por varios servicios (por ejemplo, FTP, servidor web, ...) debería
darle una idea de este tipo de ficheros.
</p>

<p>
Si mira en la página del manual de <c>restorecon</c>, se mencionan tanto
los tipos personalizables como la sección de usuario. Esta última es para
las reglas que se identifican en la directriz de SELinux para ficheros
de un usuario final, como las siguientes definiciones en el módulo de
directriz <c>mozilla</c>:
</p>

<pre caption="Definición de sección de usuario dentro del módulo mozilla">
HOME_DIR/\.mozilla(/.*)?      gen_context(system_u:object_r:mozilla_home_t,s0)
HOME_DIR/\.netscape(/.*)?     gen_context(system_u:object_r:mozilla_home_t,s0)
HOME_DIR/\.phoenix(/.*)?      gen_context(system_u:object_r:mozilla_home_t,s0)
</pre>

<p>
Aunque en el ejemplo de arriba, forzar <c>restorecon</c> en los ficheros
es probablemente correcto, se pueden dar ejemplos en los que ésto no
se desea. Por ejemplo, la directriz firefox por defecto únicamente
permite a la aplicación escribir en los directorios etiquetados con
<c>mozilla_home_t</c>. Si se quiere descargar algo, esto es imposible
(a menos que lo haga en <path>~/.mozilla</path>). La solución para
esto es etiquetar un directorio (digamos <path>~/Descargas</path>) con
<c>mozilla_home_t</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Directriz SELinux y Booleanos</title>
<subsection>
<title>Introducción</title>
<body>

<p>
Hemos tratado con usuarios y etiquetas, pero todavía tenemos que tratar
con un tercer aspecto que no hemos tocado: La propia directriz SELinux.
</p>

<p>
La directriz SELinux tal y como se ofrece en Gentoo Hardened es una
directriz cuidadosamente ajustada y basada en la directriz de referencia
(una directriz SELinux independiente de toda distribución) con cambios
menores. Con suerte, no necesitará escribir de nuevo la directriz para
adaptarla a sus necesidades, sin embargo, de vez en cuando son necesarios
algunos cambios.
</p>

</body>
</subsection>
<subsection>
<title>Cambiar el comportamiento de la directriz SELinux: Booleanos</title>
<body>

<p>
Una forma común y agradable de ajustar la directriz SELinux es mediante
el uso de un booleano. Un <e>booleano SELinux</e>, también llamado
condicional, modifica el comportamiento de la directriz SELinux
basándose en los ajustes que realiza el usuario. Para clarificar esto un
poco, echemos un vistazo a algunos de los booleanos disponibles:
</p>

<pre caption="Obtener los booleanos SELinux">
# <i>getsebool -a | grep ^user</i>
user_direct_mouse --> off
user_dmesg --> off
user_ping --> on
user_rw_noexattrfile --> off
user_tcp_server --> off
user_ttyfile_stat --> off
</pre>

<p>
Aunque parece que no hay mucho que decir a primera vista, estos booleanos
alteran el modo en que la directriz SELinux fuerza la actividad de los
usuarios (de ahí que los booleanos comiencen con <path>user_</path>).
Por ejemplo, <c>user_ping</c> esta definido a <c>on</c>, por lo que
se permite al usuario utilizar la orden <c>ping</c>. Si se define a
<c>off</c>, la directriz SELinux no permitiría al usuario utilizar
<c>ping</c>.
</p>

<p>
Se puede cambiar el valor de un booleanos entre on y off utilizando
<c>setsebool</c> o <c>togglesebool</c>. Con <c>setsebool</c> necesitará
indicar el valor (on u off), mientras que <c>togglesebool</c> conmuta
el valor.
</p>

<pre caption="Deshabilitar el uso de ping por parte de los usuarios">
# <i>setsebool user_ping off</i>
</pre>

<p>
Por defecto, <c>setsebool</c> no almacena los valores booleanos, por lo
que después de un reinicio los antiguos valores se cargarán. Para hacer
estos cambios persistentes, necesitará añadir la opción <c>-P</c>:
</p>

<pre caption="Permitir a los usuarios ejecutar dmesg de forma persistente">
# <i>setsebool -P user_dmesg on</i>
</pre>

<p>
Los booleanos permiten a los administradores ajustar la directriz, y a
los administradores de seguridad escribir directrices que sean los
suficientemente flexibles para que su uso se extienda. En términos de
la flexibilidad de Gentoo, estos booleanos no deberían usarse demasiado
(sería deseable asociar estos booleanos con ajustes USE, de modo que un
servidor instalado con USE="ldap" obtenga la directriz SELinux para
utilizar, mientras que USE="-ldap" la deshabilita). Aún así, el uso
de booleanos es una forma popular para hacer más flexible una directriz
SELinux.
</p>

</body>
</subsection>
<subsection>
<title>Gestionar los módulos de directriz SELinux</title>
<body>

<p>
En esta última parte, cubriremos los módulos de reglas de la directriz
SELinux. Mencionamos anteriormente que la directriz SELinux que usa
Gentoo Hardened se basa en la directriz de referencia, la cual ofrece
un enfoque modular a las directrices de SELinux. Existe una directriz
base que es obligatoria en todos los sistemas y se trata de que sea
lo más pequeña posible. El resto son módulos de la directriz SELinux,
que normalmente ofrecen las declaraciones, reglas y los contextos de
ficheros para una sola aplicación (o tipo de aplicación).
</p>

<p>
Con <c>semodule -l</c> puede ver la lista de módulos de directriz
SELinux que están cargados:
</p>

<pre caption="Listar los módulos cargados por SELinux">
# <i>semodule -l</i>
alsa       1.11.0
apache     2.3.0
entropyd   1.6.0
dbus       1.15.0
dnsmasq    1.9.0
<comment>(...)</comment>
</pre>

<p>
En Gentoo Hardened, cada módulo se ofrece mediante el paquete
<path>sec-policy/selinux-&lt;nombredemódulo&gt;</path>. Por ejemplo,
el primer módulo que vemos en el ejemplo de arriba lo ofrece
el paquete <path>selinux-alsa</path>:
</p>

<pre caption="Paquete de módulo de directriz SELinux en Gentoo">
$ <i>emerge --search selinux-alsa</i>
Searching...
[ Results for search key : selinux-alsa ]
[ Applications found : 1]

* sec-policy/selinux-alsa
    Latest version available: 2.20110726
    Latest version installed: 2.20110726
    Size of files: 574 kB
    Homepage:      http://www.gentoo.org/proj/en/hardened/selinux/
    Description:   SELinux policy for alsa
    License:       GPL-2
</pre>

<p>
Cuando se necesita un módulo que no está instalado en su sistema, se
considera un fallo (los paquetes que lo necesitan deben depender del
paquete de la directriz SELinux si se ha definido el ajuste USE
selinux). Por esto, una vez que instale el paquete, el módulo se
cargará automáticamente:
</p>

<pre caption="Instalar un paquete de directriz SELinux">
# <i>emerge selinux-screen</i>
</pre>

<p>
Si necesita eliminar un módulo de su sistema, desinstalar el paquete no
será suficiente: el propio módulo directriz SELinux se copia antes al
almacén de directrices (como parte del proceso de instalación) y
Portage no lo eliminará de este almacén. Por lo tanto, deberá eliminarlo
manualmente:
</p>

<pre caption="Desinstalar un módulo de directriz SELinux">
# <i>emerge -C selinux-screen</i>
# <i>semodule -r screen</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>Siguientes pasos</title>
<subsection>
<title>¿Qué hacer ahora?</title>
<body>

<p>
Hasta ahora, su sistema ha estado corriendo en <e>modo permisivo</e>.
Necesitará habilitar el modo <e>forzado</e> antes de estar protegido
adecuadamente mediante SELinux. Discutiremos cómo cambiar al modo forzado
en <uri link="?part=2&amp;chap=4">Permisivo, no confinado, deshabilitado o
lo que no...</uri>, pero antes de eso, necesitará tener en cuenta algunas
cosas...
</p>

</body>
</subsection>
<subsection>
<title>Usuarios de Initramfs</title>
<body>

<p>
Si su sistema utiliza un initramfs para arrancar, <e>no</e> podrá iniciar
el sistema directamente en modo forzado (debido a la <uri
link="https://bugs.gentoo.org/397567">incidencia #397597</uri>). Para
evitar esta cuestión, puede crear el siguiente guión de inicio que
cambiará de modo permisivo a modo forzado de una forma razonablemente
rápida dentro del proceso de inicio (y antes de arrancar los servicios
de red):
</p>

<pre caption="Contenido de /etc/init.d/selinux_enforce">
#!/sbin/runscript
# Copyright 1999-2012 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/es/hardened/selinux/hb-using-configuring.xml,v 1.6 2013/01/02 18:28:08 nimiux Exp $

description="Switch into SELinux enforcing mode"

depend() {
        need sysfs
}

start() {
       if get_bootparam "norestorecon" ; then
               ewarn "Skipping restoring file contexts in /dev as requested"
       else
               ebegin "Restoring file contexts in /dev"
                       restorecon -R /dev
               eend 0
       fi


       if get_bootparam "nosetenforce" ; then
               ewarn "Skipping switching to enforcing mode as requested by kernel cmdline"
       else
               . /etc/selinux/config
               CURRENTMODE=$(cat /sys/fs/selinux/enforce)

               if [ "${SELINUX}" = "enforcing" ] &amp;&amp; [ "${CURRENTMODE}" = "0" ];
               then
                       ebegin "Switching to enforcing mode"
                       echo 1 &gt; /sys/fs/selinux/enforce
                       eend $?
                else
                       ewarn "Not switching to enforcing mode, or enforcing mode already enabled"
                fi
        fi
}
</pre>

<p>
Añada el guión de inicio al nivel de ejecución boot, y edite la
configuración de su gestor de arranque para arrancar siempre con la
definición <c>enforcing=0</c>. El guión de inicio actualizará los
contextos de fichero en <path>/dev</path> y a continuación, si su
sistema está configurado para arrancar en modo forzado, cambiará a
ese modo.
</p>

<p>
Si necesita permanecer en modo permisivo de forma temporal, puede añadir
<c>nosetenforce</c> como parámetro de inicio (después de <c>enforcing=0</c>)
lo cual evitará el paso <c>setenforce</c>).
</p>

</body>
</subsection>
<subsection>
<title>Usuarios de entornos gráficos</title>
<body>

<p>
Si arranca en un entorno gráfico (es decir, si utiliza GDM, KDM u otro
gestor gráfico de acceso al sistema), necesitará actualizar el(los)
fichero(s) de configuración PAM de los gestores mediante las siguientes
indicaciones:
</p>

<pre caption="Ejemplo de actualización del fichero de configuración LXDM PAM">
<comment># /etc/pam.d/lxdm</comment>
<comment># [...]</comment>
session    required     pam_loginuid.so
session    optional     pam_gnome_keyring.so auto_start
<i>session optional     pam_selinux.so</i>
</pre>

<p>
Esto asegurará que el contexto de seguridad en el que ha accedido al
sistema está definido correctamente. Actualizaremos los paquetes que
definen esos ficheros PAM de forma adecuada, pero esto nos llevará algún
tiempo.
</p>

</body>
</subsection>
</section>
</sections>
