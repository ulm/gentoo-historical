<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/es/hardened/selinux/Attic/hb-using-policymodules.xml,v 1.1 2011/06/07 18:05:53 nimiux Exp $ -->

<sections>
<version>1</version>
<date>2011-03-02</date>

<section>
<title>Escribiendo directrices sencillas</title>
<subsection>
<title>Escribiendo un fichero TE</title>
<body>

<p>
Haremos un resumen de las experiencias previas escribiendo directrices
sencillas. Hemos visto brevemente como trabajar con un fichero
<path>.te</path> y convertirlo a un módulo SELinux cargable. Volvamos
a ello de nuevo con un sencillo ejemplo: permitir execmem al dominio
mozilla_t.
</p>

<p>
Cuando usamos el módulo <path>selinux-mozilla</path> ofrecido por SELinux,
se puede provocar un fallo si se está usando el paquete binario de firefox
de 32 bits (<path>www-client/firefox-bin</path>) y no se permite memexec
(consulte el booleano <c>allow_memexec</c>). Probablemnte encontrará
una denegación AVC indicándole esta situación. Si quiere permitir que
solo mozilla_t pueda ejecutar execmem, puede escribir el siguiente módulo
<path>fixmozilla.te</path>:
</p>

<pre caption="Contenido de fixmozilla.te">
module fixmozilla 1.0.0;

require {
  type mozilla_t;
  class process execmem;
}

allow mozilla_t self:process { execmem };
</pre>

<p>
Esta sencilla directriz indica que el módulo se llama <e>fixmozilla</e>
y que su versión es la <e>1.0.0</e> (es prudente actualizar este número
de versión cada vez que se actualiza el módulo, de modo que se puede
verificar de rápidamente si la nueva versión se ha cargado o no con
la orden <c>semodule -l</c>). Se requiere el dominio <e>mozilla_t</e>
(si <path>sec-policy/selinux-mozilla</path> no está instalado, fallará
la carga de esta directriz ya que no se puede encontrar el dominio
mozilla_t domain), también se necesita la clase <e>process</e> con la
operación <e>execmem</e>. La directriz propiamente dicha (la sentencia
AVC) permite al dominio mozilla_t domain usar execmem en sus propios
procesos.
</p>

<p>
Para convertir este fichero fuente en una directriz que se pueda cargar,
la convertiremos primero en un fichero <path>.mod</path>:
</p>

<pre caption="Convertir un fichero .te a un fichero .mod">
~$ <i>checkmodule -m -o fixmozilla.mod fixmozilla.te</i>
</pre>

<p>
Con esta orden en particular, creamos un fichero de módulo
(<path>fixmozilla.mod</path>) que no es de base (<c>-m</c>), el cual
contiene las sentencias indicadas en el fichero <path>fixmozilla.te</path>.
Si esta corriendo un sistema MLS/MCS necesitará añadir la opción <c>-M</c>.
</p>

<p>
A continuación empaquetamos este módulo en un módulo SELinux cargable.
</p>

<pre caption="Empaquetar el fichero .mod en un módulo cargable SELinux">
~$ <i>semodule_package -o fixmozilla.pp -m fixmozilla.mod</i>
</pre>

<p>
Este fichero de módulo final (<path>fixmozilla.pp</path>) se puede cargar
en el almacén de directrices de SELinux usando
<c>semodule -i fixmozilla.pp</c>.
</p>

<p>
Usando este método relativamente sencillo, puede crear todas las reglas de
directriz que quiera. Sin embargo, seguramente también quiera añadir
información de etiquetado del fichero...
</p>

</body>
</subsection>
<subsection>
<title>Escribiendo un fichero FC</title>
<body>

<p>
Un fichero FC (<e>Fichero de Contexto</e>) contiene las etiquetas de fichero
(contexto de seguridad) que se deben asignar a algunos ficheros en
particular. Si estructura sus módulos de forma adecuada, probablemente tenga
directrices para algunos programas en particular, e igualmente querrá
etiquetar los ficheros y binarios adecuadamente. Para esto se utilizan los
ficheros <path>.fc</path>.
</p>

<p>
Echemos un vistazo a un ejemplo de fichero .fc el cual contiene los
distintos tipos de definiciones de contexto soportados:
</p>

<pre caption="Ejemplo de fichero .fc">
/var/.*                   gen_context(system_u:object_r:var_t)
/dev/.*tty[^/]*     -c    gen_context(system_u:object_r:tty_device_t)
/dev/p[fg][0-3]     -b    gen_context(system_u:object_r:removable_device_t)
/vmlinuz.*          -l    gen_context(system_u:object_r:boot_t)
/usr/bin/firefox    --    gen_context(system_u:object_r:mozilla_exec_t)
/tmp/\.ICE-unix/.*  -s    &lt;&lt;none&gt;&gt;
/dev/initctl        -p    gen_context(system_u:object_r:initctl_t)
/mnt(/[^/]*)?       -d    gen_context(system_u:object_r:mnt_t)
</pre>

<p>
La primera columna (de cada línea) comienza con una expresión regular para
que concuerde con la ruta del fichero. Esto normalmente es suficiente para
que concuerden la mayoría de ficheros posible. SELinux no soporta algunas
variabes como ROLE, HOME_DIR, HOME_ROOT y USER que son sustituidas por sus
valores correspondientes cuando el fichero de contexto es (re)compilado
(por ejemplo cuando se añaden o eliminan usuarios o se reconstruye la
directriz usando <c>semodule</c>).
</p>

<p>
La segunda columna, si está presente, comienza con un guión seguido del
tipo de fichero: dispositivo de <c>c</c>arácter, dispositivo de
<c>b</c>loque, en<c>l</c>ace simbólico, zócalo (<c>s</c>ocket),
<c>d</c>irectorio, tubería nombrada (named <c>p</c>ipe) o un
fichero regular (<c>-</c>).
</p>

<p>
La última columna indica el contexto de seguridad (etiqueta) que debe
ser asignado a el(los) recurso(s) que concuerda con la expresión regular.
Deberá siempre indicarse los "tres estándar" (usuario, rol y dominio),
sin embargo, puede incluirse también el nivel de seguridad e incluso
la categoría si se usa MLS/MCS o están soportados por el módulo.
</p>

<pre caption="Ejemplo de fichero de contexto con soporte MLS/MCS">
/usr/tmp    -d  gen_context(system_u:object_r:tmp_t,s0-s15,c0.c255)
</pre>

<p>
Puede escribir su propio fichero FC. Por ejemplo, Gentoo añade la siguiente
definición al paquete <path>sec-policy/selinux-mozilla</path> para dar
soporte al paquete binario de firefox:
</p>

<pre caption="Ejemplo de contenido .fc">
/usr/bin/firefox-bin           -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/libxul\.so        -- gen_context(system_u:object_r:textrel_shlib_t,s0)
/opt/firefox/firefox           -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/run-mozilla.sh    -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/firefox-bin       -- gen_context(system_u:object_r:mozilla_exec_t,s0)
/opt/firefox/plugin-container  -- gen_context(system_u:object_r:mozilla_exec_t,s0)
</pre>

<p>
Si quiere añadir este fichero a su directriz, hágalo durante la fase
<c>semodule_package</c>:
</p>

<pre caption="Añadir información de contexto a una directriz">
~$ <i>semodule_package -o fixmozilla.pp -m fixmozilla.mod -f fixmozilla.fc</i>
</pre>

<p>
Una vez que se ha cargado la directriz, puede usar herramientas como
<c>matchpathcon</c>, <c>restorecon</c> y algunas más ya que saben cómo
tratar los ficheros indicados en su fichero de contexto.
</p>

</body>
</subsection>
</section>
<section>
<title>Construyendo un módulo de directriz de referencia</title>
<subsection>
<title>Introducción a la directriz de referencia</title>
<body>

<p>
Anteriormente hemos hablado del hecho de que Gentoo Hardened basa sus
directrices en la directriz de referencia que mantiene Tresys. Esta
directriz de referencia ofrece una funcionalidad importante añadida
durente el desarrollo de los módulos: las interfaces.
</p>

<p>
Al crear una interfaz, realmente se crea una función de algún tipo
que puede ser usada en otros módulos. Estas interfaces permiten a los
desarrolladores generar reglas para interactuar con el dominio de su
módulo sin conocer cuáles son los otros módulos. Por ejemplo, el módulo
de mozilla tiene una definición de interfaz como la siguiente:
</p>

<pre caption="Ejemplo de definición de interfaz">
interface(`mozilla_read_user_home_files',`
  gen_require(`
    type mozilla_home_t;
  ')

  allow $1 mozilla_home_t:dir list_dir_perms;
  allow $1 mozilla_home_t:file read_file_perms;
  allow $1 mozilla_home_t:lnk_file read_lnk_file_perms;
  userdom_search_user_home_dirs($1)
')
</pre>

<p>
Esta interfaz permite a otros módulos usar la función
<c>mozilla_read_user_home_files</c> si se quiere que sus dominios
puedan (en este caso) leer los ficheros en el dominio
mozilla_home_t domain. Desde luego, se pueden añadir todas las
sentencias dentro de su propia definición, pero entonces necesitarían
que se haya cargado el módulo mozilla, lo que sería una presunción
inapropiada y duplicaría las mismas sentencias de concesión para
cada aplicación. El uso de interfaces hace más fácil el desarrollo
de directrices.
</p>

<p>
También, la directriz de referencia permite el uso de sentencias
<e>optional</e>: un módulo puede llamar a una interfaz en otro
módulo y la directriz no fallará aún en el caso en que el otro
módulo no esté en un sistema de usuario.
</p>

<p>
Por ejemplo, en la directriz evolution:
</p>

<pre caption="Extracto de evolution.te">
optional_policy(`
  mozilla_read_user_home_files(evolution_t)
  mozilla_domtrans(evolution_t)
')
</pre>

<p>
En este extracto vemos que se llama a la interfaz definida
previamente con el argumento evolution_t (el dominio Evolution) dentro
de una claúsula <c>optional_policy</c>. Como resultado, la construcción
de esta directriz intentará llamar a esta interfaz y la construcción
del módulo no fallará aunque la interfaz no se encuentre (porque el
módulo mozilla no está instalado).
</p>

<p>
El uso de interfaces permite una separación limpia de los distintos
módulos. Dentro de la directriz de referencia se pueden en cuenta
las siguientes cuestiones:
</p>

<ul>
  <li>
    Dentro de un fichero <path>.te</path>, los únicos dominios que se
    permiten mencionar son aquellos definidos en el fichero
    <path>.te</path>. Cualquier interacción con otros dominios se debe
    realizar en las interfaces ofrecidas por ese dominio.
  </li>
  <li>
    Dentro de un fichero <path>.if</path>, en los que se definen las
    interfaces, se usa una sintaxis de tipo XML para documentar cada
    interfaz, permitiendo a los desarrolladores leer de forma fácil lo
    que se supone debe hacer la interfaz (ya que, honestamente, hay
    interfaces mucho más complejas que la que acabamos de ver).
  </li>
  <li>
    Aspectos específicos de la distribución de módulos deben
    incluirse en una sentencia <c>ifdef(`distro_gentoo',`...')</c>
    (ejemplo para Gentoo). Se soporta esta sentencia en los tres tipos
    de fichero (<path>.te</path>, <path>.if</path> y <path>.fc</path>).
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Constriuir el módulo de directriz de referencia</title>
<body>

<p>
Si quiere construir un módulo usando las interfaces de directriz de
referencia, necesitará en primer lugar crear el fichero <path>.te</path>
y, opcionalmente, (y necesario en la mayoría de los casos) los ficheros
<path>.if</path> y <path>.fc</path>. Es prudente comenzar con un conjunto
ejemplo de ficheros para una aplicación similar. Si quiere o necesita
usar interfaces de módulos diferentes, puede encontrarlas en su
sistema dentro de <path>/usr/share/selinux/strict/include</path>.
</p>

<p>
Cuando quiera construir el módulo, copie el fichero
<path>/usr/share/selinux/strict/include/Makefile</path> dentro del
directorio donde almacene su(s) definición(es). Entonces, ejecute
<c>make</c> para construir los módulos de directriz.
</p>

<p>
El resultado debería consistir en uno (o más) módulos de SELinux.
</p>

</body>
</subsection>
</section>
<section>
<title>Ejemplo: Comenzar construyendo la directriz para Skype</title>
<subsection>
<title>Etiquetar</title>
<body>

<p>
Comencemos creando un módulo de directriz de referencia sencilla de
SELinux para la aplicación <c>skype</c>. Esta aplicación es bien
conocida y se usa para realizar charlas de voz y vídeo a través de
Internet. No terminaremos el módulo en este capítulo (ya que este
ejercicio se convertirá en un ciclo repetitivo de pruebas y errores
que no procede comentar en este momento), en lugar de esto mostraremos
un enfoque acerca de como trabajar con estos ejercicios de construcción
de directrices.
</p>

<p>
En primer lugar, nos familiarizaremos con la aplicación.
</p>

<p>
La forma normal de interactuar con <c>skype</c> es desde un punto de
acceso como usuario (no como administrador). Al interactuar con la
aplicación en modo permisivo (o desde un sistema en el que no se ha
habilitado SELinux), comprobamos que crea un directorio
<path>~/.Skype</path> que se utiliza para almacenar su configuración,
historia de las charlas que se han mantenido y algunas cosas más.
</p>

<p>
Sabiendo lo de arriba, echemos un vistazo al contenido del paquete
<path>net-im/skype</path>:
</p>

<pre caption="Contenido del paquete skype">
~$ <i>qlist skype</i>
<comment>(Salida ordenada por claridad)</comment>
/usr/bin/skype
/usr/share/... <comment># No relacionado con la aplicación pero usado por la distribución</comment>
/opt/skype/skype
/opt/skype/sounds/...
/opt/skype/lang/...
/opt/skype/avatars/...
</pre>

<p>
Con esta información, podríamos crear la siguiente definición de contexto
del fichero:
</p>

<pre caption="Ejemplo de fichero de contexto para skype">
/usr/bin/skype         -- gen_context(system_u:object_r:skype_exec_t,s0)
/opt/skype/skype       -- gen_context(system_u:object_r:skype_exec_t,s0)
HOME_DIR/\.Skype(/.*)?    gen_context(system_u:object_r:skype_home_t,s0)
</pre>

<p>
No le daremos a los distintos ficheros de la aplicación skype una etiqueta
específica, son todos ficheros de solo lectura, por lo que pueden
conservar asignada la etiqueta por defecto.
</p>

<p>
Dentro del fichero <path>skype.te</path>, definimos los dominios
necesarios y también utilizamos las primeras interfaces que normalmente
están asociadas a este tipo de dominios (para ver estas razones, puede
leer los fuentes para el módulo apache u otros servicios). Un sencillo
módulo para basar nuestra definición podría ser telepathy...
</p>

<pre caption="Definición inicial del módulo de skype">
policy_module(skype, 1.0.0)

type skype_t;
type skype_exec_t;
application_domain(skype_t, skype_exec_t)

type skype_home_t;
userdom_user_home_content(skype_home_t)

# Allow skype_t to put files in the skype_home_t location(s)
manage_dirs_pattern(skype_t, skype_home_t, skype_home_t)
manage_files_pattern(skype_t, skype_home_t, skype_home_t)
userdom_user_home_dir_filetrans(skype_t, skype_home_t, { dir file })
userdom_search_user_home_dirs(skype_t)
</pre>

<p>
De nuevo, no vamos a explicar las distintas interfaces. Están documentadas
y disponibles en el sistema y existen multitud de ejemplos de uso.
</p>

<p>
Finalmente, vamos a crear una interfaz para permitir a los usuarios
cambiar al dominio skype_t. La idea es añadir
<c>skype_role(role, domain)</c> en la definición <path>.te</path>
del dominio de usuario o dentro de su propia directriz.
</p>

<pre caption="Definir la interfaz skype_role">
interface(`skype_role',`
  gen_require(`
    type skype_t, skype_exec_t;
  ')

  role $1 types skype_t;

  domain_auto_trans($2, skype_exec_t, skype_t)
')
</pre>

<p>
Construya el módulo y cárguelo en el almacén de SELinux. A
continuación cree una directriz sencilla para permitir a los
usuarios (user_r, user_t) acceder a skype:
</p>

<pre caption="Añádir acceso a skype para los usuarios">
~$ <i>cat skypeusers.te</i>
policy_module(skypeusers, 1.0.0)

gen_require(`
  type user_t;
  role user_r;
  type staff_t;
  role staff_r;
')

optional_policy(`
  skype_role(user_r, user_t)
  skype_role(staff_r, staff_t)
')
</pre>

<p>
Construya también este módulo y cárguelo. Un usuario regular de SELinux
debería ahora poder ejecutar skype_exec_t y cambiar al dominio skype_t.
</p>

</body>
</subsection>
<subsection>
<title>Ensayo general</title>
<body>

<p>
Una vez cargada la directriz, haga un ensayo general. Etiquete de nuevo
los ficheros del paquete <path>net-im/skype</path> (y si ha ejecutado
previamente skype, etiquete de nuevo el directorio <path>~/.Skype</path>),
entonces ejecute <c>skype</c> y compruebe tanto la salida de la aplicación
como las denegaciones AVC.
</p>

<p>
Enseguida notamos que el binario (skype) se cuelga y no se puede matar.
En los registros de denegación AVC encontramos las siguientes
denegaciones:
</p>

<pre caption="Denegaciones que se muestran durante la ejecución de skype">
Jan  6 22:01:56 hpl kernel: [18418.420427] type=1400 audit(1294347716.358:2221):
avc:  denied  { read write } for  pid=25540 comm="skype" name="1" dev=devpts
ino=4 scontext=staff_u:staff_r:skype_t tcontext=staff_u:object_r:user_devpts_t
tclass=chr_file
Jan  6 22:01:56 hpl kernel: [18418.420455] type=1400 audit(1294347716.358:2222):
avc:  denied  { use } for  pid=25540 comm="skype" path="/dev/pts/1" dev=devpts
ino=4 scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:staff_t
tclass=fd
Jan  6 22:01:56 hpl kernel: [18418.420563] type=1400 audit(1294347716.358:2225):
avc:  denied  { sigchld } for  pid=6532 comm="bash"
scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:staff_t tclass=process
</pre>

<p>
Observe que el intento se realiza en modo forzado (enforcing), si se
realiza en modo permisivo, se generarían más denegaciones AVC y también es
una forma correcta de crear las reglas necesarias.
</p>

<p>
De estas denegaciones, extraemos que skype intenta usa el pts en el que
se ha ejecutado la orden (observe que esto falla debido a que no lo
permitimos explícitamente) y también falla cuando se le envía una señal
de salida (no se puede enviar una señal sigchld).
</p>

<p>
Mirando las directrices ejemplo que hemos visto, nos damos cuenta de que
tienen interfaces en uso como <c>userdom_use_user_terminals</c> así como
concesiones genéricas como <c>ps_process_pattern</c> (para permitir a los
usuarios ver un proceso y matarlo). Esto es un buen ejemplo de cómo
funciona un sistema MAC de forzado de tipos: por defecto no se asume nada.
</p>

</body>
</subsection>
<subsection>
<title>Siguiente ensayo</title>
<body>

<p>
Después de añadir algunas interfaces para permitir el usao de terminales
de usuario, los descriptores de fichero y también permitir el envío de
señales a los procesos, intentamos ejectuar la aplicación de nuevo.
Obtenemos ahora:
</p>

<pre caption="Salida de la orden skype en ejecución">
~$ <i>skype</i>
Killed

~$ <i>cat /var/log/avc.log</i>
Jan  6 22:27:41 hpl kernel: [19961.313321] type=1400
audit(1294349261.991:9089017): avc:  denied  { execmem } for  pid=27256
comm="skype" scontext=staff_u:staff_r:skype_t tcontext=staff_u:staff_r:skype_t
tclass=process
</pre>

<p>
Por lo menos ahora existe <c>skype</c>. En el registro AVC, vemos que quiere
llamar a execmem (que es algo que no deseamos, pero que también hemos visto
anteriormente con mozilla). De acuerdo, permitámoslo, reconstruyamos los
módulos e intentémoslo otra vez.
</p>

<pre caption="Otra vez la salida de la orden skype">
~$ <i>skype</i>
./skype: error while loading shared libraries: libasound.so.2: cannot open
shared object file: Permission denied

~$ <i>cat /var/log/avc.log</i>
Jan  6 22:33:41 hpl kernel: [20319.960127] type=1400
audit(1294349621.275:9089042): avc:  denied  { read } for  pid=27536
comm="skype" name="libasound.so.2" dev=dm-1 ino=525098
scontext=staff_u:staff_r:skype_t tcontext=system_u:object_r:usr_t
tclass=lnk_file
</pre>

<p>
Bien, necesitamos conceder permisos de lectura a enlaces en el
dominio usr_t domain (y seguramente cargar las librerías desde el
dominio lib_t domain, por lo que necesitamos añadir
<c>files_read_usr_symlinks</c> y <c>libs_use_ld_so</c>, etc.
</p>

</body>
</subsection>
<subsection>
<title>Terminando</title>
<body>

<p>
Después de caer en las cuestiones "no puedo arrancar", observará
que la aplicación necesita asociar y conectarse a puertos, los cuales
están también protegidos por SELinux y se pueden manipular por
varias interfaces. También querrá acceder a su tarjeta de sonido,
cámara Web, etc.
</p>

<p>
Como puede ver leyendo la información de arriba, escribir directrices
de forma correcta no es fácil. Necesita constantemente recordar los que
está concediendo. ¿No estará conceciendo demasiados privilegios?.
¿Está olvidando algo?. También es importante saber que le llevará bastante
rato crear sus primeras directrices, pero con el paso del tiempo lo irá
haciendo mejor. Comenzará a darse cuenta de qué cuestiones que son
estándar necesita conceder y cuáles no.
</p>

<p>
Escribir directrices SELinux no es duro pero es bastante más difícil que
ajustar los permisos estándar de Linux en ficheros y directorios.
Requiere un conocimiento importante del comportamiento de la aplicación y
qué interfaces de directriz de referencia SELinux se conceden cuando las
seleccione.
</p>

<p>
Si alguna vez quiere escribir estas directrices, no dude en leer los
diferentes recursos que hemos preparado al final de este libro.
</p>

</body>
</subsection>
</section>
</sections>
