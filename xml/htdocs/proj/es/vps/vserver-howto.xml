<?xml version = '1.0' encoding = 'UTF-8' ?>
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/es/vps/vserver-howto.xml,v 1.2 2007/03/03 16:35:21 chiguire Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/proj/es/vps/vserver-howto.xml" lang="es">
<title>Cómo Gentoo Linux-VServer</title>

<author title="Author" >
  <mail link="hollow@gentoo.org" >Benedikt Boehm</mail>
</author>
<author title="Editor" >
  <mail link="fox2mike@gentoo.org" >Shyam Mani</mail>
</author>
<author title="Traductor" >
  <mail link="chiguire@gentoo.org" >John Christian Stoddart</mail>
</author>
<author title="Traductor" >
  <mail link="yoswink@gentoo.org" >José Luis Rivero</mail>
</author>
<author title="Traductor" >
  <mail link="carles@carles.no-ip.info" >Carles Ferrer Peris</mail>
</author>


<abstract>
En este Cómo aprenderemos a poner en marcha un servidor virtual básico
usando la Tecnología Linux-VServer
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.9</version>
<date>2007-02-10</date>

<chapter>
<title>Introducción</title>
<section>
<title>El concepto Linux-VServer</title>
<body>

<p>
El concepto básico de una solución Linux-VServer es dividir el entorno
de espacio de usuario en unidades separadas (llamadas a veces
Servidores Virtuales Privados, &quot;Virtual Private Servers&quot; en
inglés) de tal forma que cada VPS parece y se comporta como un
servidor verdadero de cara a los procesos contenidos dentro.
</p>
</body>
</section>

<section>
<title>Terminología usada en este Cómo</title>
<body>

<table>
<tr>
  <th>Término</th>
  <th>Descripción</th>
</tr>
<tr>
  <th>Linux-VServer, VServer</th>
  <ti>
    Linux-VServer es el nombre oficial del proyecto y es usado en este
    documento de la misma manera
  </ti>
</tr>
<tr>
  <th>servidor virtual, vserver, sistema huésped, guest</th>
  <ti>
    Son todos términos intercambiables y se refieren a una instancia
    de un servidor (es decir, un servidor virtual)
  </ti>
</tr>
<tr>
  <th>sistema anfitrión, host</th>
  <ti>
    La máquina física que ejecuta Gentoo Linux y albergará todos los
    servidores virtuales
  </ti>
</tr>
<tr>
  <th>util-vserver</th>
  <ti>
    El paquete <c>util-vserver</c> contiene todos los programas
    necesarios para mantener los servidores virtuales
  </ti>
</tr>
</table>
</body>
</section>
</chapter>

<chapter>
<title>Configuración del anfitrión</title>
<section>
<title>Instalación del núcleo VServer</title>
<body>

<pre caption="Instalación de vserver-sources" >
# <i>emerge vserver-sources</i>
</pre>

<p>
Después de que las vserver-sources se hayan instalado es el momento de
configurarlas usando <c>make menuconfig</c>. A continuación se muestra
una configuración común para versiones 2.1.1 y posteriores. Si usa
2.0.x algunas opciones de configuración pude que no estén presentes.
</p>

<pre caption="Configuración de vserver-sources" >
# <i>cd /usr/src/linux-&lt;KERNELVERSION>-vserver-&lt;VSERVERVERSION></i>
# <i>make menuconfig</i>

Linux VServer ---&gt;
<comment>(No habilite las opciones "legacy")</comment>
  [ ] Enable Legacy Kernel API
  [ ] Enable Legacy Networking Kernel API
<comment>(Lea la ayuda)</comment>
  [ ] Remap Source IP Address
  [*] Enable COW Immutable Link Breaking
  [ ] Enable Virtualized Guest Time
  [*] Enable Proc Security
  [*] Enable Hard CPU Limits
  [*]   Avoid idle CPUs by skipping Time
  [*]   Limit the IDLE tas
      Persistent Inode Context Tagging (UID24/GID24)  ---&gt;
  [ ] Tag NFSD User Auth and Files
  [*] Enable Inode Tag Propagation
  [*] Honor Privacy Aspects of Guests
  [ ] VServer Debugging Code
</pre>

<note>
Si utilizamos reiserfs como sistema de ficheros en la partición donde
se almacenan las imágenes de loa huéspedes, deberemos habilitar los
atributos extendidos de reiserfs en la configuración del núcleo y
adicionalmente añadir la opción <c>attrs</c> en
<path>/etc/fstab</path>.
</note>

<pre caption="Configurar las opciones de reiserfs">
File systems  --->
  &lt;*&gt; Reiserfs support
  [*]   ReiserFS extended attributes
</pre>

<pre caption="Ejemplo de fstab con atributos extendidos">
/dev/hdb1 /vservers reiserfs noatime,attrs 0 0
</pre>

<p>
Después de haber compilado e instalado el núcleo, hay que actualizar
el gestor de arranque y finalmente reiniciar para ver si el núcleo
arranca correctamente.
</p>

<pre caption="Instalación del kernel" >
<comment>(Compilar el núcleo)</comment>
# <i>make</i>
<comment>(Instalación)</comment>
# <i>make modules_install</i>
# <i>cp arch/&lt;arch&gt;/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
<comment>(Editar el fichero de configuración del gestor de arranque como se necesite y)</comment>
# <i>reboot</i>
</pre>
</body>
</section>

<section>
<title>Configuración del entorno del anfitrión</title>
<body>

<p>
Para mantener los servidores virtuales se necesita el paquete
util-vserver que contiene todos los programas necesarios y algunas
utilidades prácticas.
</p>

<pre caption="Instalar util-vserver" >
# <i>emerge >=sys-cluster/util-vserver-0.30.212</i>
</pre>

<p>
Se debe ejecutar el comando <c>vprocunhide</c> después de cada
reinicio para establecer los permisos adecuados en <path>/proc</path>
para los huéspedes vserver. util-vserver instala un guión de inicio
que puede añadir al nivel de ejecución por defecto:
</p>

<pre caption="Guíon de inicio de vprocunhide" >
# <i>rc-update add vprocunhide default</i>
# <i>/etc/init.d/vprocunhide start</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Creación de un huésped</title>
<section>
<title>Uso de un vserver con un stage3/4</title>
<body>

<p>
Necesitaremos descargar un stage3/4 preparado para vserver desde uno
de <uri link="/main/en/mirrors.xml">los mirrors de Gentoo</uri>. Estos
stages están situados en el directorio
<path>experimental/&lt;arch&gt;/vserver/</path>. Puesto que un
stage3/4 contiene un sistema de ficheros root completo, puede usar el
método de creación por plantilla de util-vserver. Sin embargo, este
métod sólo está disponible desde util-vserver-0.30.211, por tanto
asegúrese de tener instalada la versión correcta.
</p>

<p>
Hay que elegir un ID de contexto para el vserver (no se aconsejan los
IDs de contexto dinámicos) así como la información necesaria para el
dispositivo de red (en este ejemplo eth0 se configura con
192.168.1.253/24 y el ID de contexto es igual a las dos últimas partes
de la IP de los servidores virtuales).
</p>

<note>
El ID de contexto debe ser 1 &lt; ID &lt; 49152.
</note>

<pre caption="Inicio de la instalación de un stage3" >
# <i>vserver myguest build \</i>
  <i>--context 1253 \</i>
  <i>--hostname gentoo \</i>
  <i>--interface eth0:192.168.1.253/24 \</i>
  <i>--initstyle plain \</i>
  <i>-m template -- \</i>
  <i>  -d gentoo \</i>
  <i>  -t /path/to/stage4-&lt;arch&gt;-&lt;version&gt;.tar.bz2</i>
</pre>

<note>
Para reflejar la configuración de red se deben cambiar dentro del
huésped <path>/etc/conf.d/hostname</path>,
<path>/etc/conf.d/domainname</path> y <path>/etc/hosts</path> tal como
se necesite. Se puede consultar el
<uri link="/doc/es/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect1" >
capítulo 8.b.1</uri> y el
<uri link="/doc/es/handbook/handbook-x86.xml?part=1&amp;chap=8#doc_chap2_sect4" >
capítulo 8.b.4</uri>. El resto de la configuración de red del servidor
virtual se hará en el anfitrión.
</note>

<p>
Deberíamos ser capaces de iniciar y entrar en el servidor virtual
usando los siguientes comandos. Si echamos a faltar algunos como
<c>mount</c> o <c>dmesg</c> deberemos hacer <c>emerge util-linux</c>
dentro del servidor virtual puesto que el perfil del vserver no
contiene este paquete por defecto.
</p>

<pre caption="Probar el servidor virtual" >
# <i>vserver myguest start</i>
# <i>vserver-stat</i>
CTX   PROC    VSZ    RSS  userTIME   sysTIME    UPTIME NAME
0       90   1.4G 153.4K  14m00s11   6m45s17   2h59m59 root server
1252     2     3M   286    0m00s45   0m00s42   0m02s91 myguest
# <i>vserver myguest enter</i>
# <i>ps ax</i>
PID   TTY      STAT   TIME COMMAND
    1 ?        S      0:00 init [3]
22887 ?        Ss     0:00 /usr/sbin/syslog-ng
20496 pts/0    S      0:00 /bin/bash -login
20508 pts/0    R+     0:00 ps ax
# <i>logout</i>
</pre>
</body>
</section>
</chapter>

<chapter>
<title>Mantenimiento sencillo</title>
<section>
<title>Arrancar huéspedes durante el inicio</title>
<body>

<p>
Se pueden arrancar algunos huéspedes durante el inicio. Cada
<c>guest</c> puede tener asignada una MARCA (MARK). Entonces, todo lo
que hay que hacer es configurar esas MARCAs en la configuración de los
huéspedes y añadir los guiones de inicio apropiados al nivel de
ejecución default.
</p>

<pre caption="Configurar las MARCAs en cada huésped">
<comment>(Hay que hacer esto en cada huésped que se quiera
iniciar)</comment>
# <i>mkdir -p /etc/vservers/myguest/apps/init</i>
# <i>echo "default" > /etc/vservers/myguest/apps/init/mark</i>
</pre>

<pre caption="Añadir el guión de inicio al nivel de ejecución default">
# <i>rc-update add vservers.default default</i>
</pre>
</body>
</section>

<section>
<title>Mantener portage sincronizado</title>
<body>

<p>
El guión <c>vesync</c> nos ayudará a mantener la memoria temporal de
metadatos y recubrimiento sincronizada. <c>vemerge</c> es un simple
envoltorio para <c>emerge</c> en los huéspedes.
</p>

<pre caption="Ejemplos">
<comment>(Sincronizar los metadatos en 'myguest')</comment>
# <i>vesync myguest</i>
<comment>(Sincronizar los metadatos en todos los huéspedes)</comment>
# <i>vesync -all</i>
<comment>(Sincronizar 'myoverlay' en todos los huéspedes)</comment>
# <i>vesync -all \</i>
  <i>--overlay /usr/local/overlays/myoverlay \</i>
  <i>--overlay-host rsync://rsync.myhost.com/myoverlay \</i>
  <i>--overlay-only</i>
<comment>(emerge app-editors/vim en 'myguest')</comment>
# <i>vemerge myguest -- app-editors/vim -va</i>
</pre>
</body>
</section>

<section>
<title>Actualizar huéspedes</title>
<body>

<p>
Los huéspedes Gentoo pueden compartir paquetes para ahorrar tiempo de
compilación. Para usar paquetes compartidos, deberemos crear un
directorio centralizado para los paquetes en el anfitrión. Usaremos
<path>/var/cache/vpackages</path> en el anfitrión y lo montaremos en
cada huésped en <path>/usr/portage/packages</path>.
</p>

<pre caption="Enlazar la configuración del huésped">
# <i>mkdir -p /var/cache/vpackages</i>
# <i>$EDITOR /etc/vservers/myguest/fstab</i>
<comment>(Añadiremos esta línea al final)</comment>
/var/cache/vpackages /usr/portage/packages none bind,rw 0 0
</pre>

<p>
Ahora utilizaremos <c>vupdateworld</c> para actualizar cada
huésped. El comando es equivalente a algo como <c>emerge --deep
--update --newuse world</c>.
</p>

<pre caption="Ejemplos de vupdateworld">
<comment>(Prueba de actualización para 'myguest')</comment>
# <i>vupdateworld myguest -- -vp</i>
<comment>(Actualización de 'myguest' usando paquetes binarios)</comment>
# <i>vupdateworld myguest -- -k</i>
<comment>(Actualización de todos los huéspedes usando paquetes binarios)</comment>
# <i>vupdateworld --all -- -k</i>
</pre>

<note>
Para obtener paquetes binarios podemos usar, tanto PORTAGE_BINHOST
(ver <c>man make.conf</c>) o establecer FEATURES="buildpkg" en uno o
más huéspedes.
</note>

<p>
Después de haber actualizado con éxito, podemos actualizar fácilmente
todos los archivos de configuración con <c>vdispatch-conf</c>, que es
un simple envoltorio para <c>dispatch-conf</c>, comportándose de la
misma forma.
</p>

<pre caption="Ejemplos de vdispatch-conf">
<comment>(Actualizar los ficheros de configuración de 'myguest')</comment>
# <i>vdispatch-conf myguest</i>
<comment>(Actualizar los ficheros de configuración de todos los huéspedes)</comment>
# <i>vdispatch-conf --all</i>
</pre>
</body>
</section>

<section>
<title>Contacto</title>
<body>

<p>
No dude en contactar con el <mail
link="hollow@gentoo.org">autor</mail> o crear un bug en <uri
link="http://bugs.gentoo.org" >Bugzilla</uri> en caso de cualquier
problema.
</p>
</body>
</section>
</chapter>
</guide>
