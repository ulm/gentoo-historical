#!/bin/ash

#KV=`uname -r`
#KMAJOR=`echo ${KV} | cut -d. -f1`
#KMINOR=`echo ${KV} | cut -d. -f2`
#INSMOD="insmod.static"

#if [ "${KMINOR}" -gt "4" ]
#then
#	KEXT=".ko"
#else
#	KEXT=".o"
#fi

. /etc/initrd.defaults

usage()
{
	echo "modprobe gentoo script v1.0"
	echo "Usage:"
	echo "  modprobe moduleprefix"
	echo ""
	echo "Ex:"
	echo "  modprobe eepro100"
	echo ""
	echo "Note: Do not pass the suffix to modprobe"
	exit 1
}

# Pass module name to this function
modules_dep_list()
{
	if [ "$#" != "1" ]
	then
		echo "modules_dep_list(): improper usage"
		exit 1
	fi
	cat /lib/modules/${KV}/modules.dep | grep ${1}${KSUFF}\: | cut -d\:  -f2
}


# Pass module deps list
strip_mod_paths()
{
	local x
	local ret
	local myret

	[ "$#" -lt "1" ] && return

	for x in ${*}
	do
		ret=`basename ${x} | cut -d. -f1`
		myret="${myret} ${ret}"
	done
	echo "${myret}"
}

LOADED_MODULES=""

is_module_already_loaded()
{
	local x
	if [ "$#" != "1" ]
	then
		echo "is_module_already_loaded(): improper usage"
	fi

	for x in ${LOADED_MODULES}
	do
		if [ "${x}" = "${1}" ]
		then
			# Yep, module is loaded
			return 0
		fi
	done
	return 1
}

real_mod_path()
{
	# find doesn't work like we expect, let's add a grep to it
	find /lib/modules | grep "${1}${KSUFF}"
}

modprobe2()
{
	local x
	local deps
	local real_path
	local modlist
	local ret

	if [ "$#" != "1" ]
	then
		echo "modprobe(): improper usage"
		exit 1
	fi
	real_path=`real_mod_path ${1}`
	if [ "${real_path}" = "" -o "${real_path}" = " " ]
	then
		echo "no such module found"
		exit 1
	fi
	modlist=`modules_dep_list ${1}`
	if [ "${modlist}" != "" -a "${modlist}" != " " ]
	then
		deps=`strip_mod_paths ${modlist}`
	else
		deps=""
	fi
#	echo "$1 -- DEPS='${deps}'"
	# Make sure we don't do any endless loops!

	LOADED_MODULES="${LOADED_MODULES} ${1}"
	for x in ${deps}
	do
		if ! is_module_already_loaded ${x}
		then
			if [ "${x}" != "" -a "${x}" != " " ]
			then
#				echo "loading dep: ${x}"
				modprobe2 "${x}"
			fi
		else
			filler=1
#			echo "skipping ${x}, module already loaded by us"
		fi
	done
#	echo "running insmod on '${real_path}'"
	${INSMOD} ${real_path} > /dev/null 2>&1
	ret=$?
	if [ "$ret" -eq "0" ]
	then
		echo "module ${real_path} loaded"
	fi
	return $ret
}


if [ "$#" != "1" ]
then
	usage
fi

for x in `cat /modules.cache`
do
	LOADED_MODULES="${LOADED_MODULES} ${x}"
done

modprobe2 ${1}

[ -f "/modules.cache" ] && rm -f /modules.cache > /dev/null 2>&1
for x in ${LOADED_MODULES}
do
	echo $x >> /modules.cache
done

exit $?

