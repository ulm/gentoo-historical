#!/bin/bash
# -*- mode: sh -*-
#
# /usr/sbin/webapp-config
#		Shell script for managing the deployment of web-based
#		applications
#
#		Originally written for the Gentoo Linux distribution
#
# Copyright	(c) 1999-2004 Gentoo Technologies, Inc
#		Released under v2 of the GNU GPL
#
# Author(s)	Stuart Herbert <stuart@gentoo.org>
#
# ========================================================================

# ========================================================================
# Some configuration variables
# ------------------------------------------------------------------------

MY_DOTCONFIG=".webapp"
MY_ETCCONFIG="/etc/conf.d/webapp-config"
MY_LIBROOT="/usr/lib/webapp-config"
MY_SERVERSDIR="${MY_LIBROOT}/servers"
MY_VERSION="0.2"

# ========================================================================
# load the library of shell functions
# ------------------------------------------------------------------------

function fn_source () 
{
	. "$1" && return
	echo "$1 missing; installation error" >&2
	exit 1
}

fn_source "$MY_LIBROOT/libsh.sh"

# ========================================================================
# load the system defaults config file
#
# NOTE:
#	We will have to load this file again later when we know what
#	package we are working with
#
# ------------------------------------------------------------------------

fn_source "$MY_ETCCONFIG"

# ========================================================================
# Some default values
#
# Do not change these!
# ------------------------------------------------------------------------

# These are just basic data that is used by the three main operations -
# install, upgrade, and clean.

G_MYNAME="$0"
G_INSTALLDIR="`pwd`"
G_SERVER="$VHOST_SERVER"
G_WORK="fn_help"
G_PN=
G_PVR=
G_HOSTNAME="${VHOST_HOSTNAME:-localhost}"
G_CONFIG_UID="${VHOST_CONFIG_UID:-root}"
G_CONFIG_GID="${VHOST_CONFIG_GID:-root}"
G_VIRTUAL_DIRS="${VHOST_CONFIG_VIRTUAL_DIRS:-virtual}"
G_VIRTUAL_FILES="${VHOST_CONFIG_VIRTUAL_FILES:-virtual}"
G_FORCE_VIRTUAL=0
G_CONFIGPREFIX="._cfg"
G_PROTECTEDFILES=0

# these two will probably end up in the config file or overridable with
# command-line options at some point

G_DIRPERMS="755"
G_FILEPERMS="644"

# changing these variables changes the behaviour of this script
# you have been warned!!

G_BUGREPORT=0
G_NEEDSERVER=0
G_NEEDVERIFY=0
G_UPGRADING=0

# some variables for caching that are used later

CACHE_DIRTYPE_CONFIGOWNED=""
CACHE_DIRTYPE_ROOTOWNED=""
CACHE_DIRTYPE_SERVEROWNED=""
CACHE_DIRTYPE_VIRTUAL=""

CACHE_FILETYPE_CONFIGOWNED=""
CACHE_FILETYPE_SERVEROWNED=""

# ========================================================================
# Shell functions
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# fn_add_contents ()
#
# Add an entry to the contents file.
#
# Just like Gentoo's Portage, when we install an app, we create a contents
# file to say what we installed and when.  We use this contents file to
# help us safely remove & upgrade apps.
#
# CONTENTS file format:
#
# <what> <rel> <type> <filename> <timestamp> <sum> [<optional>]
#
# where
#
#	<what>		is one of dir|link|file
#	<rel>		is 1 for relative filenames, 0 for absolute filenames
#	<type>		is one of server-owned|root-owned|config-owned|virtual
#	<timestamp>	is the timestamp when the file was installed
#	<sum>		is the md5sum of the file
#			(this is 0 for directories)
#	<filename>	is the actual name of the file we have installed
#
#	<optional>	is additional data that depends upon <what>
#
# NOTE:
#	Filenames used to be on the end of the line.  This made the grep in
#	our fn_getcontentsline() more complicated, and prone to failure.
#	So I've moved the filename into the middle of the line.
#
# Portage uses absolute names for its files, dirs, and symlinks.  We do not.  
# In theory, you can move a directory containing a web-based app, and 
#
#	a) the app itself won't break, and
#	b) webapp-config will still work on that directory 
#	   for upgrades and cleans.
#
# Position-independence *is* a design constraint that all future changes
# to this script need to honour.
#
# Inputs:
#	$1	- contents file to use
#	$2	- type to add (one of dir|link|file)
#	$3	- internal webapp-config type
#		- (server-owned | config-owned | virtual)
#	$4	- install dir (normally $G_INSTALLDIR)
#	$5	- filename inside $2
#	$6	- 1 for storing a relative filename, 0 otherwise
#
# Outputs:
#	None
#
# Globals used:
#	$MY_CONTENTS	- filename of the contents file to add to

fn_add_contents ()
{
	local my_rel="$6"

	if [ -z "$my_rel" ]; then
		my_rel=0
	fi

	# handle relative vs absolute

	local my_fn="$5"

	if [ "$6" = "0" ]; then
		my_fn="$4/$5"
	fi

	# okay, just what exactly *have* we done? ;-)

	case "$2" in
		dir)
			# real, honest to goodness directories on disk
			# no trickery involved

			echo "dir $my_rel $3 $my_fn `libsh_file_timestamp $4/$5` 0"  >> "$1"
			libsh_enotice ">>> dir  $my_fn"
			;;
		link)
			# symbolic links
			# usually because we're up to some devilish work ;-)

			echo "sym $my_rel $3 $my_fn `libsh_file_timestamp $4/$5` 0 `libsh_file_source $4/$5`" >> "$1"
			libsh_enotice ">>> sym  $my_fn"
			;;
		file)
			# real, honest to goodness files on disk
			# very rare, very precious

			echo "file $my_rel $3 $my_fn `libsh_file_timestamp $4/$5` `libsh_file_sum $4/$5`" >> "$1"
			libsh_enotice ">>> file $my_fn"
			;;
		*)
			# no idea what you are
			# time to bail ;-(

			libsh_edie "Unknown CONTENTS type $2"
			;;
	esac
}

# ------------------------------------------------------------------------

fn_checkversionset ()
{
	if [ -z "$G_PVR" ] ; then
		libsh_ewarn "You haven't said which version to install"
		libsh_edie "Use '$G_MYNAME --help' for usage"
	fi
}

# ------------------------------------------------------------------------
# fn_clean ()
#
# This is where we get the enviable job of removing the specified
# web-based application *without* hosing the user's o/s in the process
#
# As usual, the real work is done in fn_ws_clean() - we're just a lowly
# wrapper around the per-server functionality
#
# No inputs
# No outputs

fn_clean ()
{
	fn_clean_setup

	# do the server-specific cleaning

	fn_ws_clean 

	# okay, let's finish off
	# 
	# we don't need the contents file anymore

	rm -f "$MY_REMOVECONTENTS"

	# do we need the dotconfig file?
	#
	# if the .webapp file is the only one in the dir, we believe
	# that we can remove it

	fn_determine_canremove_dotconfig && rm -f "$G_INSTALLDIR/$MY_DOTCONFIG"

	# is the installation directory empty?

	fn_determine_canremove_dir "$G_INSTALLDIR" "$G_INSTALLDIR" && fn_remove_dir "$G_INSTALLDIR" "$G_INSTALLDIR"
}

# ------------------------------------------------------------------------
# fn_clean_verify ()
#
# This function's job is to perform *all* checks necessary to ensure
# that we can successfully remove an installed application.
#
# If any tests fail, this function should abort by calling libsh_die().
#
# This function is called from fn_verify(), and runs after the command-
# line parameters have been parsed.
#
# No inputs.
# If this function returns, you can assume it's okay to proceed with
# the uninstall.

fn_clean_verify ()
{
	# special case
	#
	# if a package has been specified, then chances are that they forgot
	# to add the '-d' switch

	if [ -n "$G_PN" -a "$G_UPGRADING" != "1" ]; then
		libsh_edie "Did you forget to use the -d switch?"
	fi

	if ! fn_hasdotconfig ; then
		libsh_edie "No package installed in $G_INSTALLDIR"
	fi

	# okay - what do we have?

	if [ "$G_UPGRADING" != "1" ]; then
		libsh_einfo "Removing $WEB_PN-$WEB_PVR from $G_INSTALLDIR"
		libsh_einfo "  Installed by $WEB_INSTALLEDBY on $WEB_INSTALLEDDATE"
		libsh_einfo "  Config files owned by $WEB_INSTALLEDFOR"
		libsh_enotice
	fi

	# what does the server-specific code think?
	
	libsh_einfo "Checking specific requirements for $G_SERVER"

	fn_ws_clean_verify
}

fn_clean_setup ()
{
	# if we get to here, then all common clean tests have passed
	# and it is time to create the clean environment

	D=
	PN="$WEB_PN"
	PVR="$WEB_PVR"
	REMOVE_PN="$WEB_PN"
	REMOVE_PVR="$WEB_PVR"

	fn_source "$MY_ETCCONFIG"
	fn_ws_clean_setup
}

# ------------------------------------------------------------------------
# fn_determine_canremove ()
#
# You can use this function to workout whether a named file/dir/link can
# be removed or not.
#
# At the moment, we don't actually use this (we make direct calls to the
# fn_determine_canremove_* functions directly) but it's here for future
# use.
#
# Inputs:
#	$1	- the contents file we are using
#	$2	- the install directory to look at
#	$3	- the name of the dir or file to test
#
# Outputs:
#	0	- go ahead, remove it
#	1	- directory not empty
#	2	- timestamp changed
#	3	- file checksum changed
#	4	- link points somewhere else
#	6	- file not found
#	7	- does not exist
#	8	- not a directory
#	9	- not a file
#	10	- not a link

fn_determine_canremove ()
{
	local my_line="`fn_getcontentsline $1 $2`"

	fn_determine_installedwhat_fromline $my_line
	local my_what="$my_return"

	# special case - $my_what is empty or invalid
	#
	# when this happens, it's usually because there's a bug inside
	# this script

	if [ -z "$my_what" ]; then
		libsh_edie "fn_determine_canremove: I don't know what $2 is"
	fi

	fn_determine_installedtype_fromline $my_line
	local my_type="$my_return"

	fn_determine_installedtimestamp_fromline $my_line
	local my_time="$my_return"

	fn_determine_installedsum_fromline $my_line
	local my_sum="$my_return"

	fn_determine_installedname_fromline $my_line
	local my_name="$my_return"

	fn_determine_installedopt_fromline $my_line
	local my_opt="$my_return"

	fn_determine_installedrel_fromline $my_line
	local my_rel="$my_return"

	fn_determine_canremove_$my_what "$my_name" "$my_type" "$my_time" "$my_sum" "$my_opt"
	return $?
}

# ------------------------------------------------------------------------
# fn_determine_canremove_dir ()
#
# Outputs:
#	0	- go ahead, remove it
#	1	- directory not empty
#	6	- file does not exist
#	8	- not a directory

fn_determine_canremove_dir ()
{
	if [ ! -e "$1" ]; then
		libsh_enotice "--- !found $2"
		return 6
	fi

	if [ ! -d "$1" ]; then
		libsh_enotice "--- !dir $2"
		return 8
	fi

	# the rules are simple
	#
	# if the directory is empty, it can go
	# if the directory is not empty, it cannot go

	# get a directory listing

	local my_list="`ls -1a $1`"

	# okay, let's turn that into another list

	local x
	local my_reallist

	for x in $my_list ; do
		if [ "$x" != "." -a "$x" != ".." ] ; then
			my_reallist="$my_reallist $x"
		fi
	done

	# is our second list empty?

	if [ -n "$my_reallist" ]; then
		libsh_enotice "--- !empty $2"
		return 1
	fi

	# if we get to here, the directory's cards are marked

	return 0
}

# ------------------------------------------------------------------------
# fn_determine_canremove_dotconfig ()
#
# Outputs:
#	0	- go ahead, remove it
#	6	- directory does not exist
#	7	- content files exist in the same directory

fn_determine_canremove_dotconfig ()
{
	if [ ! -d "$G_INSTALLDIR" ]; then
		libsh_enotice "--- !dir $G_INSTALLDIR"
		return 6
	fi

	# get a directory listing

	local my_list="`cd $G_INSTALLDIR && ls -1a $MY_DOTCONFIG*`"

	# okay, let's turn that into another list

	local x
	local my_reallist

	for x in $my_list ; do
		if [ "$x" != "$MY_DOTCONFIG" ] ; then
			my_reallist="$my_reallist $x"
		fi
	done

	# is our second list empty?

	if [ -n "$my_reallist" ]; then
		libsh_enotice "--- !morecontents $G_INSTALLDIR"
		return 7
	fi

	# if we get to here, the file's cards are marked

	return 0
}

# ------------------------------------------------------------------------
# fn_determine_canremove_file ()
#
# Inputs
#	$1	- filename
#	$2	- filename that appears in the contents list
#	$3	- type
#	$4	- timestamp
#	$5	- checksum
#	$6	- link target
#
# Outputs:
#	0	- go ahead, remove it
#	1	- directory not empty
#	2	- timestamp changed
#	3	- file checksum changed
#	4	- link points somewhere else
#	5	- file is a config file
#	6	- file does not exist
#	9	- $1 is not a file

fn_determine_canremove_file ()
{
	if [ ! -e "$1" ]; then
		libsh_enotice "--- !found $2"
		return 6
	fi

	if [ ! -f "$1" ]; then
		libsh_enotice "--- !file $2"
		return 9
	fi

	if [ "$3" == "config-owned" -a "$G_UPGRADING" = 1 ]; then
		libsh_enotice "--- cfgpro $2"
		return 5
	fi

	local my_time="`libsh_file_timestamp $1`"

	if [ "$4" != "$my_time" ]; then
		libsh_enotice "--- !time $2"
		return 2
	fi

	local my_sum="`libsh_file_sum $1`"
	if [ "$my_sum" != "$5" ]; then
		libsh_enotice "--- !sum $2"
		return 3
	fi

	return 0
}

# ------------------------------------------------------------------------
# fn_determine_canremove_sym ()
#
# Inputs
#	$1	- link to remove
#	$2	- the filename that appears in the contents list
#	$3	- type
#	$4	- timestamp
#	$5	- checksum
#	$6	- link target
#
# Outputs:
#	0	- go ahead, remove it
#	1	- directory not empty
#	2	- timestamp changed
#	3	- file checksum changed
#	4	- link points somewhere else
#	5	- file is a config file
#	6	- file does not exist
#	10	- $1 is not a symlink

fn_determine_canremove_sym ()
{
	if [ ! -e "$1" ]; then
		libsh_enotice "--- !found $2"
		return 6
	fi

	if [ ! -h "$1" ]; then
		libsh_enotice "--- !symlink $2"
		return 10
	fi

	local my_target="`libsh_file_source $1`"

	if [ "$my_target" != "$6" ]; then
		libsh_enotice "--- !target $2"
		return 4
	fi

	return 0
}

# ------------------------------------------------------------------------
# fn_determine_dirisvirtual()
#
# "Virtual" directories are great.  Instead of us having to create a link
# for every single file in the master copy of the web-based app, we just
# chuck in a link to one of its sub-directories instead.  Makes life very
# simple indeed.
# 
# Except for one small problem.  We have to make sure that we don't try
# to create a link if one of our directories is virtual.
#
# Inputs:
#	$1	- source directory in the image
#	$2	- name of the directory we are interested in
#
# Outputs:
#	1	- directory isn't virtual, everything is fine
#	0	- directory (or a parent) *is* virtual

fn_determine_dirisvirtual ()
{
	my_dir="$2"
	while [ "$my_dir" != "." -a -n "$my_dir" ]; do
		fn_determine_dirtype "$1/$my_dir"
		if [ "$my_return" = "virtual" ]; then
			return 0
		fi

		my_dir="`dirname $my_dir`"
	done

	return 1
}

# ------------------------------------------------------------------------
# fn_determine_dirtype()
#
# Inputs:
# 	$1 - the dir that we need a decision about
#
# Sets $my_return to one of these:
#
#	server-owned	- dir needs to be owned by the webserver user
#	config-owned	- dir needs to be owned by $G_CONFIG_UID:
#			  $G_CONFIG_GID
#	virtual		- we don't need a local copy of the dir
#	root-owned	- we need a local copy, owned by root
#
# NOTE:
#	Use fn_determine_filetype() for files
#
# NOTE:
#	the user can use --virtual-dirs on the command-line to change
#	what type virtual directories are actually reported as
#
# NOTE:
#	the user can use --force-virtual on the command-line to force
#	all directories to be virtual directories
#
# NOTE:
#	we cache directories that we've already seen in the global
#	$CACHE_DIRTYPE_* arrays variable.  ANY other functions that
#	rely on these arrays should be considered broken
#
#	we use $CACHE_DIRTYPE_*_MAX to hold the max subscript of the
#	$CACHE_DIRTYPE_* array.  Boy, do I miss PHP's arrays right now

fn_determine_dirtype ()
{
	# special case

	if [ $G_FORCE_VIRTUAL = 1 ]; then
		my_return="$G_VIRTUAL_DIRS"
		return
	fi
	
	# optimisation - check the cache
	#
	# most of the time, the cache will produce a match

	local x
	for x in $CACHE_DIRTYPE_ROOTOWNED ; do
		if [ "$x" = "$1" ]; then
			my_return="root-owned"
			return
		fi
	done
	for x in $CACHE_DIRTYPE_VIRTUAL ; do
		if [ "$x" = "$1" ]; then
			my_return="$G_VIRTUAL_DIRS"
			return
		fi
	done
	for x in $CACHE_DIRTYPE_SERVEROWNED ; do
		if [ "$x" = "$1" ]; then
			my_return="server-owned"
			return
		fi
	done
	for x in $CACHE_DIRTYPE_CONFIGOWNED ; do
		if [ "$x" = "$1" ]; then
			my_return="config-owned"
			return
		fi
	done

	# yes, this is horrible, and slow, but it *greatly* simplifies 
	# the work that has to be done to support the individual web
	# servers - which is justification enough
	#
	# I wonder how we can make this test perform much faster?

	if egrep "^$1\$" "$WA_CONFIGLIST" > /dev/null 2>&1 ; then
		my_return="config-owned"
		CACHE_DIRTYPE_CONFIGOWNED="$CACHE_DIRTYPE_CONFIGOWNED $1"
	elif egrep "^$1\$" "$WA_SOLIST" > /dev/null 2>&1 ; then
		my_return="server-owned"
		CACHE_DIRTYPE_SERVEROWNED="$CACHE_DIRTYPE_SERVEROWNED $1"
	elif egrep "^$1\$" "$WA_VIRTUALLIST" > /dev/null 2>&1 ; then
		my_return="$G_VIRTUAL_DIRS"
		CACHE_DIRTYPE_VIRTUAL="$CACHE_DIRTYPE_VIRTUAL $1"
	else
		my_return="root-owned"
		CACHE_DIRTYPE_ROOTOWNED="$CACHE_DIRTYPE_ROOTOWNED $1"
	fi
}

# ------------------------------------------------------------------------
# fn_determine_filetype()
#
# Inputs:
# 	$1 - the file that we need a decision about
#
# prints one of these on stdout:
#
#	server-owned	- file needs to be owned by the webserver user
#			  (and needs to be a local copy)
#	config-owned	- file needs to be owned by $G_CONFIG_UID:
#			  $G_CONFIG_GID (and needs to be a local copy)
#	virtual		- we don't need a local copy of the file
#
# NOTE:
#	Use fn_determine_dirtype() for directories
#
# NOTE:
#	the user can use --virtual-files on the command-line to change
#	what type virtual files are really reported as
#
# NOTE:
#	the user can use --force-virtual on the command-line to force
#	all files to be reported as virtual

fn_determine_filetype ()
{
	# special case - --force-virtual support

	if [ $G_FORCE_VIRTUAL = 1 ]; then
		my_return="$G_VIRTUAL_FILES"
		return
	fi

	# look for the file in our cache
	#
	# this is still horribly slow, but it's much faster than the
	# calls to egrep that I used to do
	#
	# really, the best way to deal with this is to use a language
	# that supports associative arrays, such as PHP

	local x
	if [ -n "$CACHE_FILETYPE_SERVEROWNED" ]; then
		for x in $CACHE_FILETYPE_SERVEROWNED ; do
			if [ "$x" = "$1" ]; then
				my_return="server-owned"
				return
			fi
		done
	fi
	if [ -n "$CACHE_FILETYPE_CONFIGOWNED" ] ; then
		for x in $CACHE_FILETYPE_CONFIGOWNED ; do
			if [ "$x" = "$1" ]; then
				my_return="config-owned"
				return
			fi
		done
	fi

	my_return="$G_VIRTUAL_FILES"
}

# ------------------------------------------------------------------------
# fn_determine_installedtype ()
#
# When (if!) we installed a file or dir, what "type" did we decide it
# needed to be?
#
# Inputs:
#	$1	- name of the contents file to look in
#	$2	- name of the file or dir that we are looking for

fn_determine_installedtype ()
{
	fn_getcontentsline "$1" "$2"
	[ -z "$my_return" ] && return

	# NOTE:
	#	it is important that $my_match is *not* surrounded
	#	by quotes - this doesn't work otherwise

	fn_determine_installedtype_fromline $my_return
}

# ------------------------------------------------------------------------
# a set of functions for decoding a line retrieved from a contents file
#
# all of these functions work the same way:
#
# Input:
#	$*	- the line retrieved from the contents file
#
# Output:
#	$my_return is set to the required information

fn_determine_installedwhat_fromline ()
{
	my_return="$1"
}

fn_determine_installedrel_fromline ()
{
	my_return="$2"
}

fn_determine_installedtype_fromline ()
{
	my_return="$3"
}

fn_determine_installedname_fromline ()
{
	my_return="$4"
}

fn_determine_installedsum_fromline ()
{
	my_return="$6"
}

fn_determine_installedtimestamp_fromline ()
{
	my_return="$5"
}

fn_determine_installedopt_fromline ()
{
	my_return="$7"
}

# Inputs:
#	$1	- what type of file did we want to install into a vdir?
#	$2	- name of the file we wanted to install
#	$3	- installation directory (normally $G_INSTALLDIR)
#
# Outputs
#	0	- always

fn_determine_vdir_file ()
{
	case "$1" in
		server-owned)
			libsh_enotice
			libsh_eerror "Directory $3/$2 (or one of its parents)"
			libsh_eerror "is marked as 'virtual'"
			libsh_eerror "Cannot install server-owned file $2"
			libsh_eerror "into a virtual directory"
			libsh_eerror "Please file a bug report on $MY_BUGS"
			libsh_edie "Exiting"
			;;
		config-owned) 
			libsh_enotice
			libsh_eerror "Directory $3/$2 (or one of its parents)"
			libsh_eerror "is marked as 'virtual'"
			libsh_eerror "Cannot install config-owned file $2"
			libsh_eerror "into a virtual directory"
			libsh_eerror "Please file a bug report on $MY_BUGS"
			libsh_edie "Exiting"
			;;
		*)
			libsh_enotice "!!! virtparent $2"
			return 0
			;;
	esac
}

# ------------------------------------------------------------------------

fn_dirisconfigprotected ()
{
	local my_master="`/usr/lib/portage/bin/portageq config_protect`"

	# is the directory relative, or absolute?

	local my_dir="$1"
	if [ "`printf \"%1.1s\" $1`" != "/" ]; then
		my_dir="`cd $1 && pwd`"
	fi
	
	local x
	while [ "$my_dir" != "." -a -n "$my_dir" ]; do
		for x in $my_master ; do
			if [ "$my_dir" = "$x" ]; then
				return 0
			fi
		done

		my_dir="`dirname $my_dir`"
	done

	# nope, the directory isn't config-protected at this time

	return 1
}

# ------------------------------------------------------------------------
# fn_getcontentsline ()
#
# Inputs:
#	$1	- contents file to use
#	$2	- filename that we want
#
# Outputs
#	the matching contents line, sent to stdout

fn_getcontentsline ()
{
	[ -f "$1" ] || libsh_edie "Cannot find contents file $1"

	egrep " $2 " "$1" 2>/dev/null
}

# ------------------------------------------------------------------------
# fn_getinstalleddirs ()
#
# Inputs:
#	$1	- the name of the contents file to look in
#
# Outputs:
#	a list of the dirs echoed to stdout

fn_getinstalleddirs ()
{
	egrep "^dir" "$1" | awk '{ print $4 }'
}

# ------------------------------------------------------------------------
# fn_getinstalledfiles ()
#
# Inputs:
#	$1	- name of the contents file to look in
#
# Outputs:
#	a list of the files echoed to stdout

fn_getinstalledfiles ()
{
	egrep "^file|^sym" "$1" | awk '{ print $4 }'
}

# ------------------------------------------------------------------------
# fn_getprotectedname ()
#
# Woh.  Somewhere, we've decided that we're trying to overwrite a file
# that we really want to save.  So, we need a new name for the file that
# we want to install - which is where we come in.
#
# NOTE:
#	The filename that we produce is compatible with Gentoo's
#	etc-update tool.  This is deliberate.
#
# Inputs:
#	$1	- the directory that the file is being installed into
#		  (normally $G_INSTALLDIR)
#	$2	- the original name of the file
#
# Outputs:
#	$my_return = the new mangled name (that you can use instead of
#		     $2)

fn_getprotectedname ()
{
	local my_file="`basename $2`"
	local my_number="0"

	# step 1 - find the actual directory we are going to put this
	# new file into

	local my_filedir="`dirname $2`"

	# step 2 - find the highest numbered protected file that already
	# exists, in case there are any

	local my_prot="`echo $1/${my_filedir}/${G_CONFIGPREFIX}????_${my_file} 2>&1 | sort | tail -n 1`"
	if [ -n "$my_prot" ] ; then
		# extract the number
		my_number="`echo $my_prot | sed -i 's/^[^0-9]+\([0-9]+\).*/\1/g;'`"
	fi

	# step 3 - we have our number
	# increment by one, and build our name

	(( my_number = $my_number + 1 ))
	my_return="`printf \"${my_filedir}/${G_CONFIGPREFIX}%04.4d_${my_file}\" \"$my_number\"`"
}

# ------------------------------------------------------------------------
# fn_hasdotconfig()
#
# NOTE:
#	A deliberate side effect of calling this function is that the
#	file $G_INSTALLDIR/$MY_DOTCONFIG is source'd into this script
#	*if* the file exists

fn_hasdotconfig ()
{
	[ -f $G_INSTALLDIR/$MY_DOTCONFIG ] || return 1
	[ -r $G_INSTALLDIR/$MY_DOTCONFIG ] || libsh_edie "No read permissions on file $G_INSTALLDIR/$MY_DOTCONFIG"

	. "$G_INSTALLDIR/$MY_DOTCONFIG"

	# not strictly required, but I prefer to make it explicit

	return 0
}

# ------------------------------------------------------------------------
# fn_header()
#
# utility function - prints out the copyright header
#
# No inputs
# No outputs

fn_header ()
{
	libsh_enotice
	libsh_enotice "${GREEN}webapp-config $MY_VERSION: ${BLUE}http://dev.gentoo.org/~stuart/webapp-config/"
	libsh_enotice "Copyright (c) 1999-2004 Gentoo Technologies, Inc"
	libsh_enotice "Released under v2 of the GNU General Public License"
	libsh_enotice
}

# ------------------------------------------------------------------------
# fn_help ()
#
# Outputs usage help
#
# No inputs
# No outputs

fn_help ()
{
	# we import /etc/conf.d/webapp-config so that we can snag the
	# defaults to embed in this output

	. ${MY_ETCCONFIG}

	fn_header
	cat <<EOF
usage: webapp-config [-ICU] [-dghus] <application>

    webapp-config -I :: install a web application
    webapp-config -C :: remove a web application
    webapp-config -U :: upgrade a web application

    you can also use the long options:

    webapp-config --install :: install a web application
    webapp-config --clean   :: remove a web application
    webapp-config --upgrade :: upgrade a web application

    <application>
        the name and version number of the web application to install

	e.g. phpmyadmin 2.5.4

        <application> must have already been installed into the 
        $MY_APPROOT directory tree using emerge

    other options:

    -s <server>
    --server <server>
        specify which web server to install the application to run under
	use webapp-config --list-servers to see supported web servers
	
	default is -s $VHOST_SERVER

	to change the default, change the value of VHOST_SERVER 
	in $MY_ETCCONFIG

    -u <user>
    --user <user>
        install config files so that they can be edited by <user>.
        <user> can be a username.  numerical user ids are NOT supported.

        default is <user> = $VHOST_CONFIG_UID

	to change the default, change the value of VHOST_CONFIG_UID
	in $MY_ETCCONFIG

    -g <group>
    --group <group>
    	install config files so that they can be edited by <group>.
	<group> can be a group name.  numerical group ids are NOT
	supported.

	default is <group> = $VHOST_CONFIG_GID

	to change the default, change the value of VHOST_CONFIG_GID
	in $MY_ETCCONFIG

    -d <directory>
    --dir <directory>
        install <application> into <directory>.

        default is \`pwd\`

    -h <host>
    --host <host>
        the hostname to configure this application to serve.  Also affects
	where some files go.  If you get this setting wrong, you may need
	to re-install the application to correct the problem!

	default is <host> = $VHOST_HOSTNAME

	to change the default, change the value of VHOST_HOSTNAME
	in $MY_ETCCONFIG

	NOTE:
		if the default value is currently 'localhost', that
		probably means that this computer's /etc/hosts file
		is not correctly configured

    --virtual-dirs <type>
    --virtual-files <type>
    	decide what happens when we're installing a directory or a file that
	could be shared (ie, one we wouldn't normally create a local copy of)

	<type> must be one of:

		server-owned
		  dirs and files are owned by the user and group that the 
		  web-server runs under

		config-owned
		  dirs and files are owned by the user and group specified
		  by the -u and -g switches to this script

		virtual
		  dirs and files are shared; a local copy is not created

	for --virtual-dirs,  default is $VHOST_CONFIG_VIRTUAL_DIRS
	for --virtual-files, default is $VHOST_CONFIG_VIRTUAL_FILES

	to change these defaults, change the value of VHOST_CONFIG_VIRTUAL_DIRS
	and/or VHOST_CONFIG_VIRTUAL_FILES in $MY_ETCCONFIG

	NOTE:
		some -s <server> options may not support all <type>'s
		and will report an error

    --force-virtual
        force webapp-config to make *all* directories and files virtual,
	even if you would normally get a unique copy of the file

	NOTE:
		you *can* combine this switch with --virtual-dirs and
		--virtual-files if you wish
	
	NOTE:
		using this switch could produce strange behaviours

		feel free to report bugs, but do *not* expect us to be
		able to provide fixes for every problem caused by using
		this switch

    --list-servers
        list all web servers currently supported by webapp-config

    -? | --help
        show this help

    -v | --version
    	show version information

    REPORTING BUGS:

    To report bugs about webapp-config, please go to http://bugs.gentoo.org/
    Include the output of
    
    	webapp-config --bug-report <your parameters here>

    to help us to help you

EOF
}

# ------------------------------------------------------------------------
# fn_install()
#
# This function's job is to perform *all* common activities for creating
# a new installation of a web-based application
#
# This function hands off some of the work to the fn_ws_install() function,
# which is provided by the per-server script that lives in $MY_SERVERSDIR.
#
# If fn_ws_install() returns at all, we assume that it is safe to conclude
# the installation work.
#
# All verification should have already been handled by an earlier call
# to fn_install_verify().  It shouldn't be necessary to verify anything
# else in this function.
#
# No inputs
# No outputs

fn_install ()
{
	fn_install_setup

	# call the server-specific function
	fn_ws_install

	# if we get to here, then the application was successfully
	# installed
	#
	# we can now update our records

	[ "$G_UPGRADING" = "0" ] && fn_writedotconfig

	# and we're done

	libsh_einfo "Install completed - success"
}

# ------------------------------------------------------------------------
# fn_install_verify()
#
# This function's job is to perform *all* checks necessary to ensure that
# we can go ahead and install the application.
#
# If any of the tests fail, this function should abort by calling libsh_die()
#
# If this function returns, the caller can assume it is safe to proceed
# with the installation attempt
#
# This function is called from fn_verifyparams, *after* the command-line
# parameters have been parsed, and assigned to the $G_... variables.
#
# No inputs
# No outputs

fn_install_verify ()
{
	fn_checkversionset
	fn_reportpackageavail "$G_PN" "$G_PVR"

	if [ "$G_UPGRADING" = "0" ]; then
		libsh_einfo "Is there already a package installed in $G_INSTALLDIR?"

		if fn_hasdotconfig ; then
			libsh_ewarn "Package $WEB_PN-$WEB_PVR is already installed here"
			libsh_ewarn "Use webapp-config -C to uninstall it first"
			libsh_edie "Install directory already contains a web application"
		fi
	fi

	# make sure that the user and group are setup and working
	#
	# using 'id' means that we can only accept usernames and
	# group names.  UIDs and GIDs aren't supported by id(1)

	libsh_einfo "Checking that the username:group '$G_CONFIG_UID:$G_CONFIG_GID' is valid"

	if ! id -u "$G_CONFIG_UID" > /dev/null 2>&1 ; then
		libsh_edie "'$G_CONFIG_UID' is not a valid username"
	fi
	if ! id -g "$G_CONFIG_GID" > /dev/null 2>&1 ; then
		libsh_edie "'$G_CONFIG_GID' is not a valid group name"
	fi

	# let the server-specific code check things out too
	#
	# we deliberately leave it to fn_ws_install_verify() to check
	# whether $G_INSTALLDIR exists or not - in case a future install
	# scheme doesn't need a real directory to install into
	# (for example, using apache aliases for web-based apps that
	# have no config files to install)
	#
	# however, if the user is installing into a directory called
	# 'htdocs', we output a warning in case it isn't what they
	# meant to do

	if [ "$( cd $G_INSTALLDIR 2>/dev/null && basename `pwd` )" = "htdocs" ] ; then
		libsh_ewarn
		libsh_ewarn "You may be installing into the website's root directory"
		libsh_ewarn "Is this what you meant to do?"
		libsh_ewarn
	fi

	libsh_einfo "Checking specific requirements for $G_SERVER"
	fn_source "$MY_SERVERSDIR/$G_SERVER.sh"

	fn_ws_install_verify
}

# ------------------------------------------------------------------------
#
#

fn_install_setup ()
{
	D=
	PN="$G_PN"
	PVR="$G_PVR"

	fn_source "$MY_ETCCONFIG"

	CACHE_FILETYPE_CONFIGOWNED="`cat $WA_CONFIGLIST 2>/dev/null`"
	CACHE_FILETYPE_SERVEROWNED="`cat $WA_SOLIST 2>/dev/null`"

	MY_INSTALLCONTENTS="`fn_ws_echocontents $G_INSTALLDIR $G_PN $G_PVR`"

	INSTALL_PN="$G_PN"
	INSTALL_PVR="$G_PVR"
	INSTALL_INSTALLEDBY="`id -nu`"
	INSTALL_INSTALLEDDATE="`date +%Y-%m-%d` `date +%H:%M:%S`"
	INSTALL_INSTALLEDFOR="$G_CONFIG_UID:$G_CONFIG_GID"

	fn_ws_install_setup
}

# ------------------------------------------------------------------------
# fn_listservers()
#
# Outputs a list of the servers that the webapp-config script knows how
# to install / remove / upgrade for
#
# Inputs:
#	None
#
# Outputs:
#	None

fn_listservers ()
{
	local x="`ls -1 \"${MY_SERVERSDIR}/*.sh\" 2> /dev/null`"
	if [ -z "$x" ]; then
		libsh_edie "No supported servers found"
	fi

	for y in $x ; do
		echo basename $x .sh
	done
}

# ------------------------------------------------------------------------
# fn_mkdir ()
#
# Create a directory with the correct ownership and permissions
#
# Inputs:
#	$1	- source directory in the image (image-htdocs normally)
#	$2	- name of the directory
#	$3	- destination directory (normally $G_INSTALLDIR)
#	$4	- do we log contents as relative or absolute?
#
# Outputs:
#	None

fn_mkdir ()
{
	# some special cases
	#
	# these should be triggered only if we are trying to install
	# a webapp into a directory that already has files and dirs
	# inside it

	if [ -d "$3/$2" -o -h "$3/$2" ]; then
		# directory already exists
		# skip

		libsh_ewarn "    $3/$2 already exists as a real directory;"
		libsh_ewarn "      skipping $3/$2"
		return
	fi

	if [ -e "$3/$2" ]; then
		# something already exists with the same name

		libsh_edie "    $3/$2 already exists - aborting for safety"
	fi

	# are we looking to create a directory inside one that isn't real?

	if fn_determine_dirisvirtual "`dirname $2`" ; then
		libsh_einfo "    Skipping $2; parent is virtual"
		return
	fi

	fn_determine_dirtype "$1/$2"
	local l_szType="$my_return"
	
	case "$l_szType" in
		server-owned)
			libsh_erun mkdir -p "$3/$2"
			libsh_erun chown "$G_SERVER_UID:$G_SERVER_GID" "$3/$2"
			libsh_erun chmod "$G_DIRPERMS" "$3/$2"
			fn_add_contents "$MY_INSTALLCONTENTS" "dir" "$l_szType" "$3" "$2" "$4"
			;;
		config-owned)
			libsh_erun mkdir -p "$3/$2"
			libsh_erun chown "$G_CONFIG_UID:$G_SERVER_GID" "$3/$2"
			libsh_erun chmod "$G_DIRPERMS" "$3/$2"
			fn_add_contents "$MY_INSTALLCONTENTS" "dir" "$l_szType" "$3" "$2" "$4"
			;;
		virtual)
			libsh_erun ln -s "$MY_APPDIR/$1/$2" "$3/$2"
			fn_add_contents "$MY_INSTALLCONTENTS" "link" "$l_szType" "$3" "$2" "$4"
			;;
		root-owned)
			libsh_erun mkdir -p "$3/$2"
			libsh_erun chown "root:root" "$3/$2"
			libsh_erun chmod "$G_DIRPERMS" "$3/$2"
			fn_add_contents "$MY_INSTALLCONTENTS" "dir" "$l_szType" "$3" "$2" "$4"
			;;
		*)
			libsh_edie "Unreachable code in fn_mkdir() - report a bug"
			;;
	esac
}

# ------------------------------------------------------------------------
# fn_mkdirs ()
#
# Create a set of directories
#
# Inputs
#	$1	- where to start searching for directories
#		  (normally $MY_HTDOCSDIR)
#	$2	- the directory to create the new directories in
#	$3	- are we storing relative (1) or absolute (0) filenames
#		  in the contents file?

fn_mkdirs ()
{
	if [ ! -d "$1" ] ; then
		libsh_ewarn "    $G_PN-$G_PVR does not install from"
		libsh_ewarn "      $1; skipping"
		return
	fi
	local my_files="`cd $1 && find . -type d -print`"
	local x

	for x in $my_files ; do
		x="`echo \"$x\" | sed -e 's|^./||g;'`"
		fn_mkdir "$1" "$x" "$2" "$3"
	done
}

# ------------------------------------------------------------------------
# fn_mkfile()
#
# This is what we're all about.  No more games - let's take a file from
# the master image of the web-based app, and make it available inside
# the install directory.
#
# Inputs:
#	$1	- source directory in the image
#	$2	- name of the file
#	$3	- destination directory on disk (normally $G_INSTALLDIR)
#	$4	- relative (1) or absolute (0)?
#
# Outputs:
#	None

fn_mkfile ()
{
	local my_file="$2"

	fn_determine_filetype "$1/$2"
	local my_type="$my_return"

	# special case - installing files into virtual directories

	fn_determine_dirisvirtual "$1" "`dirname $2`" && fn_determine_vdir_file "$my_type" "$2" "$3" && return

	# are we overwriting an existing file?

	if [ -e "$3/$2" ]; then
		# o-oh - we're going to be overwriting something that already
		# exists

		# are we performing an upgrade?

		if [ "$G_UPGRADING" = 1 ]; then
			fn_remove "$MY_REMOVECONTENTS" "$3" "$2"
			if [ $? = 5 ]; then
				# file is config-protected

				fn_getprotectedname "$3" "$2"
				my_file="$my_return"
				libsh_enotice "^o^ hiding $my_file"
				G_PROTECTEDFILES=1
			fi
		else
			# no we are not
			#
			# only safe thing to do is to bail out for now

			libsh_edie "Install would overwrite existing file $3/$2"
		fi
	fi

	# if we get here, we can get on with the business of making the file
	# available

	case "$my_type" in
		server-owned)
			# server-owned files are copied in, and then are
			# owned by $G_SERVER_UID:$G_SERVER_GID

			libsh_erun cp "$MY_APPDIR/$1/$2" "$3/$my_file"
			libsh_erun chown "$G_SERVER_UID:$G_SERVER_GID" "$3/$my_file"
			libsh_erun chmod 644 "$3/$my_file"
			fn_add_contents "$MY_INSTALLCONTENTS" "file" "$my_type" "$3" "$2" "$4"
			;;
		config-owned)
			# config-owned files are copied in, and then are
			# owned by $G_CONFIG_UID:$G_CONFIG_GID

			libsh_erun cp "$MY_APPDIR/$1/$2" "$3/$my_file"
			libsh_erun chown "$G_CONFIG_UID:$G_CONFIG_GID" "$3/$my_file"
			libsh_erun chmod 644 "$3/$my_file"
			fn_add_contents "$MY_INSTALLCONTENTS" "file" "$my_type" "$3" "$2" "$4"
			;;
		virtual)
			# this is our default file type
			# we just symlink these files in

			libsh_erun ln -s "$MY_APPDIR/$1/$2" "$3/$my_file"
			fn_add_contents "$MY_INSTALLCONTENTS" "link" "$my_type" "$3" "$2" "$4"
			;;
		*)
			# this code should always be unreachable
			#
			# if this code *is* ever reached, it probably means
			# that we've added a new type of file, but haven't
			# added the correct support in this function

			libsh_edie "Unreachable code reached - report this as a bug"
			;;
	esac
}

# ------------------------------------------------------------------------
# fn_packageavail()
#
# Check to see whether the given package has been installed or not.
#
# These checks are carried out by using the qpkg tool, part of the
# gentoolkit package.
#
# Inputs:
#       $1      - name of the package to check for
#	$2	- the package version to check for
#
# Outputs:
#       0       - on success
#       1       - package not found
#       2       - no package to find
#	3	- package isn't webapp-config compatible

fn_packageavail ()
{
        local l_szOutput

        if [ -z "$1" ]; then
                return 2
        fi

	if [ -z "$2" ] ; then
		return 2
	fi

        l_szOutput="`qpkg -I -l -nc $1-$2`"
        if [ "$l_szOutput+" == "+" ]; then
                return 1
        fi

        # unfortunately, just because a package has been emerge'd, it doesn't
        # mean that the package itself is webapp-compatible
        #
        # we need to check that the package has an entry in /usr/share

        PN="$1"
	PVR="$2"
	D=

        . /etc/conf.d/webapp-config

        if [ ! -d "$MY_APPDIR" ]; then
                return 3
        fi

        return 0
}

# ------------------------------------------------------------------------
# fn_parseparams()
#
# Parse the command-line parameters, ready to verify them
#
# Inputs:
#	$*	- the command-line the script was called with
#
# Outputs
#	None

fn_parseparams ()
{
	while [ "$1+" != "+" ]; do
		case "$1" in
			-I|--install) 
				G_WORK="install"
				G_NEEDVERIFY=1
				G_NEEDSERVER=1
				;;
			-C|--clean) 
				G_WORK="clean"
				G_NEEDVERIFY=1
				G_NEEDSERVER=1
				;;
			-U|--upgrade)
				G_WORK="upgrade"
				G_NEEDVERIFY=1
				G_NEEDSERVER=1
				;;
			-d|--dir) 
				G_INSTALLDIR="$2" ; shift ;;
			-s|--server) 
				G_INSTALLSERVER="$2" ; shift ;;
			-u|--user) 
				G_CONFIG_UID="$2" ; shift ;;
			-g|--group) 
				G_CONFIG_GID="$2" ; shift ;;
			--virtual-files)
				G_VIRTUAL_FILES="$2" ; shift ;;
			--virtual-dirs)
				G_VIRTUAL_DIRS="$2" ; shift ;;
			--force-virtual)
				G_FORCE_VIRTUAL=1 ;;
			--bug-report)
				G_BUGREPORT=1 ;;
			--list-servers) 
				G_WORK="listservers" ;;
			-h|--host) 
				G_HOSTNAME="$2" ; shift ;;
			-\?|--help)
				G_WORK="help" ;;
			-v|--version)
				G_WORK="version" ;;
			*) 
				if [ -z "$G_PN" ] ; then
					G_PN="$1" 
				else
					G_PVR="$1"
				fi
				;;
		esac

                shift
	done
}

# ----------------------------------------------------------------------------
# fn_reportpackageavail ()
#
# This is a simple wrapper around fn_packageavail(), that outputs user-friendly
# error messages if an error occurs
#
# Inputs:
#       $1      Name of the package to check for
#	$2	Version ($PVR) of the package to check for
#
# Outputs:
#       returns at all  - the package is emerge'd, and compatible

fn_reportpackageavail ()
{
        [ -n "$1" ] || libsh_edie "No package specified; use --help for summary of options"

	libsh_einfo "Do we have $1-$2 available?"
        fn_packageavail "$1" "$2"
        case $? in
		0) libsh_einfo "  Yes, we do" ;;
                1) libsh_edie "  Please emerge $1-$2 first" ;;
                2) libsh_edie "  No package specified; use --help for summary of options" ;;
                3) libsh_eerror "  $1-$2 is not compatible with webapp-config"
                   libsh_edie "  If it should be, report this at http://bugs.gentoo.org/" ;;
        esac

}

# ----------------------------------------------------------------------------
# fn_reportpackagestillavail ()
#
# This is a simple wrapper around fn_packageavail(), that outputs user-friendly
# error messages if an error occurs
#
# Inputs:
#       $1      Name of the package to check for
#	$2	Version ($PVR) of the package to check for
#
# Outputs:
#       returns at all  - the package is emerge'd, and compatible

fn_reportpackagestillavail ()
{
        [ -n "$1" ] || libsh_edie "No package specified; use --help for summary of options"

	libsh_einfo "Is the master copy of $1-$2 still installed?"
        fn_packageavail "$1" "$2"
        case $? in
		0) libsh_einfo "  Yes, it is" ;;
                1) libsh_edie "  $1-$2 has been removed by emerge -C" ;;
                2) libsh_edie "  No package specified; use --help for summary of options" ;;
                3) libsh_eerror "  $1-$2 is not compatible with webapp-config"
                   libsh_edie "  If it should be, report this at http://bugs.gentoo.org/" ;;
        esac
}

# ------------------------------------------------------------------------
# fn_remove ()
#
# Decide whether to delete something - and then go ahead and do so
#
# Just like Gentoo's portage, we only remove files that haven't changed
# from when we installed them.  If the timestamp or checksum is different,
# we leave the file in place.
#
# Inputs
#	$1	- the contents file to use
#	$2	- the install dir
#	$3	- file/dir/sym to remove

fn_remove ()
{
	local my_line
	local my_rel
	local my_what
	local my_type
	local my_time
	local my_sum
	local my_opt
	local my_file

	# we need the contents line for this file - and then
	# we need to break it down

	local my_line="`fn_getcontentsline $1 $3`"

	fn_determine_installedrel_fromline $my_line
	my_rel="$my_return"

	fn_determine_installedwhat_fromline $my_line
	my_what="$my_return"

	if [ -z "$my_what" ]; then
		libsh_edie "fn_remove(): I don't know what $3 is"
	fi

	fn_determine_installedtype_fromline $my_line
	my_type="$my_return"

	fn_determine_installedtimestamp_fromline $my_line
	my_time="$my_return"

	fn_determine_installedsum_fromline $my_line
	my_sum="$my_return"

	fn_determine_installedopt_fromline $my_line
	my_opt="$my_return"

	# is the filename relative, or absolute?
	#
	# relative filenames are relative against the installdir

	my_file="$3"
	if [ "$my_rel" = 1 ]; then
		my_file="$2/$3"
	fi
	
	# okay, deal with the file | directory | symlink

	fn_determine_canremove_${my_what} "$my_file" "$3" "$my_type" "$my_time" "$my_sum" "$my_opt" && fn_remove_${my_what} "$my_file" "$3" && fn_remove_contents "$1" "$3" 
}

# ------------------------------------------------------------------------
# fn_remove_contents ()
#
# Remove an entry from the contents file.  If we remove something from
# disk, we really should remove it from the contents file too!
#
# Inputs
#	$1	- contents file to use
#	$2	- entry to remove (filename plz!)

fn_remove_contents ()
{
	# remove the entry from the contents file
	
	local my_line="`fn_getcontentsline $1 $2`"

	if [ -z "$my_line" ]; then
		libsh_ewarn "No contents line found for $2"
		return
	fi

	fn_remove_contents_byline "$1" "$my_line"
}

# ------------------------------------------------------------------------
# fn_remove_contents_byline ()
#
# Okay, so we already know the contents line that we want to remove
# Let's have a go at removing it once and for all
#
# Inputs
#	$1	- contents file to use
#	$2	- contents line to remove

fn_remove_contents_byline ()
{
	sed -i "s|^$2\$||g;" "$1"
}

# ------------------------------------------------------------------------
# fn_remove_contents_emptylines ()
#
# If we've been taking entries out of the contents file, it will have
# one or more empty lines in it.  We *could* take these empty lines out
# every time we take a line out, but it's more efficient to do it later
# on when we're done.
#
# Of course, it would be better if we could get the sed statement in
# fn_remove_contents_byline() to take the whole line out ;-)
#
# Inputs
#	$1	- the contents file

fn_remove_contents_emptylines ()
{
	egrep -v '^$' "$1" > /tmp/$$
	cat /tmp/$$ > "$1"
	rm -f /tmp/$$
}

# ------------------------------------------------------------------------
# fn_remove_dir ()
#
# Inputs
#	$1	- directory to remove
#	$2	- entry as it appears in the contents file

fn_remove_dir ()
{
	rm -rf "$1" && libsh_enotice "<<< dir $2" && return
	libsh_enotice "!!!     $2"
}

# ------------------------------------------------------------------------
# fn_remove_file ()
#
# Inputs
#	$1	- file to remove
#	$2	- entry as it appears in the contents file

fn_remove_file ()
{
	rm -f "$1" && libsh_enotice "<<< file $2" && return
	libsh_enotice "!!!      $2"
}

# ------------------------------------------------------------------------
# fn_remove_sym ()
#
# Inputs
#	$1	- link to remove
#	$2	- entry as it appears in the contents file

fn_remove_sym ()
{
	rm -f "$1" && libsh_enotice "<<< sym  $2" && return
	libsh_enotice "!!!      $2"
}

# ------------------------------------------------------------------------
# fn_remove_dirs ()
#
# It's time to remove the dirs that we installed back beyond the dawn
# of time itself.
#
# Inputs:
#	$1	- the contents file to use
#	$2	- the install dir

fn_remove_dirs ()
{
	# step 1 : get a list of all the files & links from the contents
	# file
	#
	# we reverse the list of directories, so that they are removed
	# in the opposite order to the order they were added in
	#
	# this should maximise our chances of correctly determining
	# whether a directory is empty or not

	local my_dirs="`fn_getinstalleddirs $1 | sort -r`"

	# step 2 : loop over the list, and remove what we can

	local x

	for x in $my_dirs ; do
		fn_remove "$1" "$2" "$x"
	done
}

# ------------------------------------------------------------------------
# fn_remove_files ()
#
# It's time to remove the files that we installed back beyond the dawn
# of time itself.
#
# Inputs:
#	$1	- the contents file to use
#	$2	- the install dir

fn_remove_files ()
{
	# step 1 : get a list of all the files & links from the contents
	# file

	local my_files="`fn_getinstalledfiles $1`"

	# step 2 : loop over the list, and remove what we can

	local x

	for x in $my_files ; do
		fn_remove "$1" "$2" "$x"
	done
}

# ------------------------------------------------------------------------
# looking for fn_upgrade()? it's pulled in from the scripts that you'll
# find in /usr/lib/webapp-config.

fn_upgrade ()
{
	# okay, we do upgrades like this
	#
	# a) install the new app
	# b) remove the old app

	# to keep things simple, we rely on fn_install_verify() to setup
	# whatever variables we need to perform the installation

	fn_install_verify
	fn_install

	# now, we need to remove the older app

	libsh_einfo "Removing old version $my_old_pn-$my_old_pvr"

	fn_clean_verify
	fn_clean

	# we need to write out the new dotconfig file

	fn_writedotconfig

	# to finish, we need to tell the user if they need to run
	# etc-update or not

	if [ "$G_PROTECTEDFILES" = "1" ]; then
		
		local my_command="etc_update"

		# work out whether this directory is part of the
		# CONFIG_PROTECT list or not

		fn_dirisconfigprotected "$G_INSTALLDIR" || my_command="CONFIG_PROTECT=\"$G_INSTALLDIR\" etc-update"

		# tell the user what to do

		libsh_enotice
		libsh_ewarn "One or more files have been config protected"
		libsh_ewarn "To complete your install, you need to run this command:"
		libsh_ewarn
		libsh_ewarn "  $my_command"
	fi
}

# ------------------------------------------------------------------------
# fn_upgrade_verify ()
#
# This function's job is to perform *all* the checks necessary before
# we go off and upgrade an installed application
#
# If any of the tests fail, this function should abort the script by
# calling the libsh_die() function
#
# If this function returns to the caller, the caller should assume it's
# safe to start the upgrade :-)
#
# No inputs
# No outputs

fn_upgrade_verify ()
{
	G_UPGRADING=1

	libsh_einfo "Is there already a package installed in $G_INSTALLDIR?"
	if ! fn_hasdotconfig ; then
		libsh_edie "Install directory does not contain a web application"
	fi

	# special case
	#
	# are we trying to upgrade to the same package?
	# if so, we don't allow that

	if [ "$G_PN" = "$WEB_PN" -a "$G_PVR" = "$WEB_PVR" ]; then
		libsh_edie "  Cannot upgrade to the same package"
	fi

	# okay, what do we have?

	libsh_einfo "Upgrading $WEB_PN-$WEB_PVR to $G_PN-$G_PVR"
	libsh_einfo "  Installed by $WEB_INSTALLEDBY on $WEB_INSTALLEDDATE"
	libsh_einfo "  Config files owned by $WEB_INSTALLEDFOR"
	libsh_enotice

	my_old_pn="$WEB_PN"
	my_old_pvr="$WEB_PVR"
	
	MY_REMOVECONTENTS="`fn_ws_echocontents $G_INSTALLDIR $WEB_PN $WEB_PVR`"
}

# ------------------------------------------------------------------------
# fn_verifyparams()
#
# Ensure that all conditions are met before we actually *do* the work

# This function exits the entire script if an error is found, so if
# this function returns to the caller, you can be sure it's safe to
# go ahead and do the work ;-)
#
# No inputs
# No outputs

fn_verifyparams ()
{
	# here, we output some useful information that might make a 
	# difference when dealing with a bug report

	libsh_enotice
	libsh_einfo "Running with these settings:"
	if [ "$G_FORCE_VIRTUAL" = 1 ] ; then
		libsh_einfo "  --force-virtual is ON"
	else
		libsh_einfo "  --force-virtual is OFF"
	fi
	libsh_einfo "  --virtual-dirs  is $G_VIRTUAL_DIRS"
	libsh_einfo "  --virtual-files is $G_VIRTUAL_FILES"
	libsh_einfo "  --user          is $G_CONFIG_UID"
	libsh_einfo "  --group         is $G_CONFIG_GID"
	libsh_einfo "  --hostname      is $G_HOSTNAME"
	libsh_einfo "  --server        is $G_SERVER"
	libsh_einfo "  --directory     is $G_INSTALLDIR"
	libsh_einfo "  package         is $G_PN"
	libsh_einfo "  version         is $G_PVR"
	libsh_einfo "  action          is $G_WORK"
	libsh_enotice

	# make sure that our VIRTUAL settings make sense
	#
	# we have to test the defaults in the config file, as well as
	# what has been specified on the command-line

	fn_verifyparams_vdirs "$VHOST_CONFIG_VIRTUAL_DIRS" 1
	fn_verifyparams_vfiles "$VHOST_CONFIG_VIRTUAL_FILES" 1

	fn_verifyparams_vdirs "$G_VIRTUAL_DIRS" 0
	fn_verifyparams_vfiles "$G_VIRTUAL_FILES" 0
	
	# load the server-specific code

	[ -f ${MY_SERVERSDIR}/$G_SERVER.sh ] || libsh_edie "I don't support the '$G_SERVER' web server."
	fn_source "$MY_SERVERSDIR/$G_SERVER.sh"

	# call the function-specific verify code
	fn_${G_WORK}_verify

	# general tests go here
}

# ------------------------------------------------------------------------
# fn_verifyparams_dirs ()
#
# Check the virtual dirs settings
#
# Inputs:
#	$1	- the settings to test
#	$2	- 1 if the setting came from the config file

fn_verifyparams_vdirs ()
{
	case "$1" in
		server-owned|config-owned|virtual)
			return
			;;
	esac

	if [ "$2" = 1 ]; then
		libsh_eerror "VHOST_CONFIG_VIRTUAL_DIRS in $MY_ETCCONFIG is invalid"
		libsh_eerror "Please correct this before continuing"
		libsh_edie "Bad virtual directory setting"
	else
		libsh_edie "Invalid value '$1' for --virtual-dirs"
	fi
}

# ------------------------------------------------------------------------
# fn_verifyparams_vfiles ()
#
# Check the virtual files settings
#
# Inputs:
#	$1	- the settings to test
#	$2	- 1 if the setting came from the config file

fn_verifyparams_vfiles ()
{
	case "$1" in
		server-owned|config-owned|virtual)
			return
			;;
	esac

	if [ "$2" = 1 ]; then
		libsh_eerror "VHOST_CONFIG_VIRTUAL_FILES in $MY_ETCCONFIG is invalid"
		libsh_eerror "Please correct this before continuing"
		libsh_edie "Bad virtual directory setting"
	else
		libsh_edie "Invalid value '$1' for --virtual-files"
	fi
}

# ------------------------------------------------------------------------
# fn_version()
#
# Echo the current version string

# No inputs
# No outputs

fn_version ()
{
	echo "${MY_VERSION}"
}

# ------------------------------------------------------------------------
# fn_writedotconfig ()
#
# Output the .webapp file, that tells us in future what has been installed
# into this directory
#
# No parameters

fn_writedotconfig ()
{
	( cat <<EOF > ${G_INSTALLDIR}/$MY_DOTCONFIG
# $MY_DOTCONFIG
#	config file for this copy of $INSTALL_PN/$INSTALL_PVR
#	
#	automatically created by Gentoo's webapp-config
#	do NOT edit this file by hand

WEB_PN="$INSTALL_PN"
WEB_PVR="$INSTALL_PVR"
WEB_INSTALLEDBY="$INSTALL_INSTALLEDBY"
WEB_INSTALLEDDATE="$INSTALL_INSTALLEDDATE"
WEB_INSTALLEDFOR="$INSTALL_INSTALLEDFOR"
EOF
	) || libsh_edie "Unable to write to $G_INSTALLDIR/$MY_DOTCONFIG"
}

# ------------------------------------------------------------------------
# main() - it all happens here
#
# Inputs:
#	$* 	- the command-line as passed to the script
#
# Outputs:
#	return code (document new return codes here)
#
#	0	- success

main ()
{
	fn_parseparams "$@"
	if [ ${G_NEEDVERIFY} = 1 ] ; then
		fn_verifyparams
	fi

	# the actual functions to do the work are stored in
	# seperate scripts
	#
	# this allows us to use different schemes for different
	# types of webserver if we wish

	if [ ${G_NEEDSERVER} = 1 ] ; then
		. ${MY_SERVERSDIR}/$G_SERVER.sh
	fi

#        echo $G_WORK
	fn_${G_WORK}
}

main "$@"
