diff -urN linux-2.6.4/fs/Kconfig linux-2.6.4-gentoo/fs/Kconfig
--- linux-2.6.4/fs/Kconfig	2004-03-10 20:55:29.000000000 -0600
+++ linux-2.6.4-gentoo/fs/Kconfig	2004-04-10 19:43:07.000000000 -0500
@@ -885,6 +885,28 @@
 	  To compile this as a module, choose M here: the module will be called
 	  ramfs.
 
+config RAMFS_XATTR
+	bool "Ramfs Extended Attributes"
+	depends on RAMFS
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page, or visit
+	  <http://acl.bestbits.at/> for details).
+
+	  If unsure, say N.
+
+config RAMFS_SECURITY
+	bool "Ramfs Security Labels"
+	depends on RAMFS_XATTR
+	help
+	  Security labels support alternative access control models
+	  implemented by security modules like SELinux.  This option
+	  enables an extended attribute handler for file security
+	  labels on ramfs filesystems.
+
+	  If you are not using a security module that requires using
+	  extended attributes for file security labels, say N.
+
 endmenu
 
 menu "Miscellaneous filesystems"
diff -urN linux-2.6.4/fs/ramfs/Makefile linux-2.6.4-gentoo/fs/ramfs/Makefile
--- linux-2.6.4/fs/ramfs/Makefile	2004-03-10 20:55:54.000000000 -0600
+++ linux-2.6.4-gentoo/fs/ramfs/Makefile	2004-04-10 19:34:48.000000000 -0500
@@ -5,3 +5,5 @@
 obj-$(CONFIG_RAMFS) += ramfs.o
 
 ramfs-objs := inode.o
+ramfs-$(CONFIG_RAMFS_XATTR)        += xattr.o
+ramfs-$(CONFIG_RAMFS_SECURITY)     += xattr_security.o
diff -urN linux-2.6.4/fs/ramfs/inode.c linux-2.6.4-gentoo/fs/ramfs/inode.c
--- linux-2.6.4/fs/ramfs/inode.c	2004-03-10 20:55:25.000000000 -0600
+++ linux-2.6.4-gentoo/fs/ramfs/inode.c	2004-04-10 18:59:14.000000000 -0500
@@ -33,6 +33,7 @@
 #include <linux/backing-dev.h>
 
 #include <asm/uaccess.h>
+#include "xattr.h"
 
 /* some random number */
 #define RAMFS_MAGIC	0x858458f6
@@ -42,6 +43,8 @@
 static struct file_operations ramfs_file_operations;
 static struct inode_operations ramfs_file_inode_operations;
 static struct inode_operations ramfs_dir_inode_operations;
+static struct inode_operations ramfs_symlink_inode_operations;
+static struct inode_operations ramfs_special_inode_operations;
 
 static struct backing_dev_info ramfs_backing_dev_info = {
 	.ra_pages	= 0,	/* No readahead */
@@ -63,6 +66,7 @@
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 		switch (mode & S_IFMT) {
 		default:
+			inode->i_op = &ramfs_special_inode_operations;
 			init_special_inode(inode, mode, dev);
 			break;
 		case S_IFREG:
@@ -77,7 +81,7 @@
 			inode->i_nlink++;
 			break;
 		case S_IFLNK:
-			inode->i_op = &page_symlink_inode_operations;
+			inode->i_op = &ramfs_symlink_inode_operations;
 			break;
 		}
 	}
@@ -157,6 +161,10 @@
 
 static struct inode_operations ramfs_file_inode_operations = {
 	.getattr	= simple_getattr,
+	.setxattr	= ramfs_setxattr,
+	.getxattr	= ramfs_getxattr,
+	.listxattr	= ramfs_listxattr,
+	.removexattr	= ramfs_removexattr,
 };
 
 static struct inode_operations ramfs_dir_inode_operations = {
@@ -169,6 +177,26 @@
 	.rmdir		= simple_rmdir,
 	.mknod		= ramfs_mknod,
 	.rename		= simple_rename,
+	.setxattr	= ramfs_setxattr,
+	.getxattr	= ramfs_getxattr,
+	.listxattr	= ramfs_listxattr,
+	.removexattr	= ramfs_removexattr,
+};
+
+static struct inode_operations ramfs_symlink_inode_operations = {
+	.readlink	= page_readlink,
+	.follow_link	= page_follow_link,
+	.setxattr	= ramfs_setxattr,
+	.getxattr	= ramfs_getxattr,
+	.listxattr	= ramfs_listxattr,
+	.removexattr	= ramfs_removexattr,
+};
+
+static struct inode_operations ramfs_special_inode_operations = {
+	.setxattr	= ramfs_setxattr,
+	.getxattr	= ramfs_getxattr,
+	.listxattr	= ramfs_listxattr,
+	.removexattr	= ramfs_removexattr,
 };
 
 static struct super_operations ramfs_ops = {
@@ -223,6 +251,10 @@
 
 static int __init init_ramfs_fs(void)
 {
+	int err = init_ramfs_xattr();
+	if (err)
+		return err;
+                                
 	return register_filesystem(&ramfs_fs_type);
 }
 
diff -urN linux-2.6.4/fs/ramfs/xattr.c linux-2.6.4-gentoo/fs/ramfs/xattr.c
--- linux-2.6.4/fs/ramfs/xattr.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.4-gentoo/fs/ramfs/xattr.c	2004-04-10 19:34:53.000000000 -0500
@@ -0,0 +1,214 @@
+/*
+  File: fs/ramfs/xattr.c
+ 
+  Derived from fs/ext3/xattr.c, changed in the following ways:
+      drop everything related to persistent storage of EAs
+      pass dentry rather than inode to internal methods
+      only presently define a handler for security modules
+*/
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <asm/semaphore.h>
+#include "xattr.h"
+
+static struct ramfs_xattr_handler *ramfs_xattr_handlers[RAMFS_XATTR_INDEX_MAX];
+static rwlock_t ramfs_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+ramfs_xattr_register(int name_index, struct ramfs_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= RAMFS_XATTR_INDEX_MAX) {
+		write_lock(&ramfs_handler_lock);
+		if (!ramfs_xattr_handlers[name_index-1]) {
+			ramfs_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&ramfs_handler_lock);
+	}
+	return error;
+}
+
+void
+ramfs_xattr_unregister(int name_index, struct ramfs_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= RAMFS_XATTR_INDEX_MAX) {
+		write_lock(&ramfs_handler_lock);
+		ramfs_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&ramfs_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static inline struct ramfs_xattr_handler *
+ramfs_xattr_resolve_name(const char **name)
+{
+	struct ramfs_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&ramfs_handler_lock);
+	for (i=0; i<RAMFS_XATTR_INDEX_MAX; i++) {
+		if (ramfs_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				ramfs_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = ramfs_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&ramfs_handler_lock);
+	return handler;
+}
+
+static inline struct ramfs_xattr_handler *
+ramfs_xattr_handler(int name_index)
+{
+	struct ramfs_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= RAMFS_XATTR_INDEX_MAX) {
+		read_lock(&ramfs_handler_lock);
+		handler = ramfs_xattr_handlers[name_index-1];
+		read_unlock(&ramfs_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+ssize_t
+ramfs_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct ramfs_xattr_handler *handler;
+
+	handler = ramfs_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->get(dentry, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+ssize_t
+ramfs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
+{
+	struct ramfs_xattr_handler *handler = NULL;
+	int i, error = 0;
+	unsigned int size = 0;
+	char *buf;
+
+	read_lock(&ramfs_handler_lock);
+
+	for (i=0; i<RAMFS_XATTR_INDEX_MAX; i++) {
+		handler = ramfs_xattr_handlers[i];
+		if (handler)
+			size += handler->list(dentry, NULL);
+	}
+
+	if (!buffer) {
+		error = size;
+		goto out;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto out;
+	}
+
+	buf = buffer;
+	for (i=0; i<RAMFS_XATTR_INDEX_MAX; i++) {
+		handler = ramfs_xattr_handlers[i];
+		if (handler)
+			buf += handler->list(dentry, buf);
+	}
+	error = size;
+
+out:
+	read_unlock(&ramfs_handler_lock);
+	return size;
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+ramfs_setxattr(struct dentry *dentry, const char *name,
+	      const void *value, size_t size, int flags)
+{
+	struct ramfs_xattr_handler *handler;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = ramfs_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->set(dentry, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+ramfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct ramfs_xattr_handler *handler;
+
+	handler = ramfs_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE);
+}
+
+int __init
+init_ramfs_xattr(void)
+{
+#ifdef CONFIG_RAMFS_SECURITY	
+	int	err;
+
+	err = ramfs_xattr_register(RAMFS_XATTR_INDEX_SECURITY,
+				    &ramfs_xattr_security_handler);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+
+void
+exit_ramfs_xattr(void)
+{
+#ifdef CONFIG_RAMFS_SECURITY	
+	ramfs_xattr_unregister(RAMFS_XATTR_INDEX_SECURITY,
+				&ramfs_xattr_security_handler);
+#endif
+
+}
diff -urN linux-2.6.4/fs/ramfs/xattr.h linux-2.6.4-gentoo/fs/ramfs/xattr.h
--- linux-2.6.4/fs/ramfs/xattr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.4-gentoo/fs/ramfs/xattr.h	2004-04-10 19:34:55.000000000 -0500
@@ -0,0 +1,59 @@
+/*
+  File: fs/ramfs/xattr.h
+ 
+  Derived from fs/ext3/xattr.h, changed in the following ways:
+      drop everything related to persistent storage of EAs
+      pass dentry rather than inode to internal methods
+      only presently define a handler for security modules
+*/
+
+#include <linux/config.h>
+#include <linux/xattr.h>
+
+/* Name indexes */
+#define RAMFS_XATTR_INDEX_MAX			10
+#define RAMFS_XATTR_INDEX_SECURITY	        1
+
+# ifdef CONFIG_RAMFS_XATTR
+
+struct ramfs_xattr_handler {
+	char *prefix;
+	size_t (*list)(struct dentry *dentry, char *buffer);
+	int (*get)(struct dentry *dentry, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct dentry *dentry, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int ramfs_xattr_register(int, struct ramfs_xattr_handler *);
+extern void ramfs_xattr_unregister(int, struct ramfs_xattr_handler *);
+
+extern int ramfs_setxattr(struct dentry *, const char *, const void *, size_t, int);
+extern ssize_t ramfs_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t ramfs_listxattr(struct dentry *, char *, size_t);
+extern int ramfs_removexattr(struct dentry *, const char *);
+
+extern int init_ramfs_xattr(void);
+extern void exit_ramfs_xattr(void);
+
+# else  /* CONFIG_RAMFS_XATTR */
+#  define ramfs_setxattr		NULL
+#  define ramfs_getxattr		NULL
+#  define ramfs_listxattr	NULL
+#  define ramfs_removexattr	NULL
+
+static inline int
+init_ramfs_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ramfs_xattr(void)
+{
+}
+
+# endif  /* CONFIG_RAMFS_XATTR */
+
+extern struct ramfs_xattr_handler ramfs_xattr_security_handler;
+
diff -urN linux-2.6.4/fs/ramfs/xattr_security.c linux-2.6.4-gentoo/fs/ramfs/xattr_security.c
--- linux-2.6.4/fs/ramfs/xattr_security.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.4-gentoo/fs/ramfs/xattr_security.c	2004-04-10 16:38:08.000000000 -0500
@@ -0,0 +1,40 @@
+/*
+ * File: fs/ramfs/xattr_security.c
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/security.h>
+#include "xattr.h"
+
+static size_t
+ramfs_xattr_security_list(struct dentry *dentry, char *buffer)
+{
+	return security_inode_listsecurity(dentry, buffer);
+}
+
+static int
+ramfs_xattr_security_get(struct dentry *dentry, const char *name,
+			  void *buffer, size_t size)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	return security_inode_getsecurity(dentry, name, buffer, size);
+}
+
+static int
+ramfs_xattr_security_set(struct dentry *dentry, const char *name,
+			  const void *value, size_t size, int flags)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	return security_inode_setsecurity(dentry, name, value, size, flags);
+}
+
+struct ramfs_xattr_handler ramfs_xattr_security_handler = {
+	.prefix	= XATTR_SECURITY_PREFIX,
+	.list	= ramfs_xattr_security_list,
+	.get	= ramfs_xattr_security_get,
+	.set	= ramfs_xattr_security_set,
+};
