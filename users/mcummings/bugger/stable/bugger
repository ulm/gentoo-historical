#!/usr/bin/perl
use Getopt::Long;
use Config::General;
my $configfile = "$ENV{'HOME'}/.bugger-config";

unless ( -f $configfile ) {
    my $conf = new Config::General(
        -AutoTrue          => 1,
        -AllowMultiOptions => "yes",
        -ExtendedAccess    => 1,
    );
    print "Generating config file. This will reside at $configfile\n";
    print "\n";
    print "Bugzilla Server: (Default: bugs.gentoo.org) ";
    my $bugz = <STDIN>;
    chomp($bugz);
    unless ( $bugz =~ m/\w+/ ) { $bugz = "bugs.gentoo.org" }
    print "Login: (Usually your email address) ";
    my $login = <STDIN>;
    chomp($login);
    print "Password: ";
    my $pass = <STDIN>;
    chomp($pass);
    print "Rows to display per page: ";
    my $rows = <STDIN>;
    chomp($rows);
    if ( $rows < 1 ) { $rows = 20 }
    my %contents;
    $contents{'server'}   = "$bugz";
    $contents{'login'}    = "$login";
    $contents{'password'} = "$pass";
    $contents{'rows'}     = "$rows";
    $conf->save_file( "$configfile", \%contents )
      or die "Can't save configfile! $!\n";
    my $mode  = '0600';
    my @files = $configfile;
    chmod oct($mode), @files;
    print "\nConfiguration saved.\n\nPress Enter to continue ";
    my $junk = <STDIN>;
}
my $conf = new Config::General(
    -AutoTrue          => 1,
    -AllowMultiOptions => "yes",
    -ExtendedAccess    => 1,
    -ConfigFile        => "$configfile",
    -IncludeRelative   => 1,
);
my %config   = $conf->getall;
my $login    = $config{'login'};
my $password = $config{'password'};
my $server   = $config{'server'};
my $rows     = $config{'rows'};

my $help     = '';
my $show = '';
my $add      = '';
my $selfname = $0;
my $list     = '';
my $update   = '';
my $change   = '';
my $attach   = '';
GetOptions(
    'help'     => \$help,
    'list=s'   => \$list,
    'add'      => \$add,
    'update=s' => \$update,
    'change=s' => \$change,
    'attach=s' => \$attach,
    'show=s'   => \$show,
);

if    ($help)   { helpme() }
elsif ($list)   { list_bugs($list) }
elsif ($show)   { show_bug($show) }
elsif ($add)    { add_bug() }
elsif ($update) { update_bug($update) }
elsif ($change) { change_status($change) }
elsif ($attach) { add_attach($attach) }
else { helpme() }

sub helpme {
    print "Usage: $selfname\n";
    print "\t\t--list=loginID\tList bugs assigned to given loginID\n";
    print "\t\t--add\tAdd a new bug\n";
    print "\t\t--update=BugID\tUpdate (comment on) given bug\n";
    print "\t\t--change=BugID\tChange bug status (fixed,invalid,etc)\n";
    print "\t\t--attach=BugID\tAdd an attachment to a bug\n";
    print "\t\t--show=BugID\tShow the contents of bug BugID\n";
    print "\t\t--help\tPrint this sad usage info\n";
    print "\n\nStill need to add nice die messages...\n\n";
}

sub list_bugs {

    # Unfortunately, I can't find a simple method for retrieving this list
    require LWP::UserAgent;
    my $bugfor = shift;
    $bugfor =~ s/\@/\%40/m;

    my $ua = LWP::UserAgent->new(
        env_proxy  => 1,
        keep_alive => 1,
        timeout    => 30,
    );
    my $request = HTTP::Request->new( 'GET',
"http://bugs.gentoo.org/buglist.cgi?query_format=&short_desc_type=allwordssubstr&short_desc=&long_desc_type=allwordssubstr&long_desc=&bug_file_loc_type=allwordssubstr&bug_file_loc=&keywords_type=allwords&keywords=&bug_status=UNCONFIRMED&bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&emailassigned_to1=1&emailtype1=substring&email1=$bugfor&emailassigned_to2=1&emailreporter2=1&emailcc2=1&emailtype2=substring&email2=$bugfor&bugidtype=include&bug_id=&changedin=&chfieldfrom=&chfieldto=Now&chfieldvalue=&cmdtype=doit&order=Reuse+same+sort+as+last+time&field0-0-0=noop&type0-0-0=noop&value0-0-0=&ctype=csv"
    );
    my $response = $ua->request($request);
    die "Error while getting ", $response->request->uri, " -- ",
      $response->status_line, "\nAborting"
      unless $response->is_success;

    my $content = $response->content;
    my @baseline = split( /\n/, $content );
    my $rowcount;
    foreach my $line ( sort @baseline ) {
        $line =~ s/\"//mg;
        my @rowline = split( /,/, $line );
        next if ( $rowline[0] =~ m/bug_id/ );
	next if ($rowline[0] eq "" );
	next if ($rowline[0] =~ /^\n$/);
        $rowcount = $rowcount + 4;
        print "Bug ID $rowline[0]\nPriority $rowline[1]\n$rowline[7]\n\n";
        if ( $rowcount >= $rows ) {
            print "Press Enter to Continue";
            my $junk = <STDIN>;
            $rowcount = 0;
        }
    }
    exit();

}

sub add_bug {
    use WWW::Bugzilla;

    # Recreating the form is just fun
    my $bugz = WWW::Bugzilla->new(
        server   => $server,
        email    => $login,
        product  => "Gentoo Linux",
        password => $password,
    );
    clearscreen();
    my @versions = $bugz->available('version');
    foreach my $vers (@versions) {
        print "$vers\n";
    }
    print "Version: ";
    my $version = <STDIN>;
    chomp($version);
    unless ($version) { $version = "unspecified" }
    $bugz->version($version);
    clearscreen();
    my @components = $bugz->available('component');

    foreach my $comp (@components) {
        print "$comp\n";
    }
    print "Component: ";
    my $component = <STDIN>;
    chomp($component);
    unless ($component) { $component = "Ebuilds" }
    $bugz->component($component);
    clearscreen();
    print "Assigned to: ";
    my $assigned = <STDIN>;
    chomp($assigned);
    $bugz->assigned_to($assigned);
    clearscreen();
    print "Summary: ";
    my $summary = <STDIN>;
    chomp($summary);
    $bugz->summary($summary);
    clearscreen();
    print "Long Description: (CTL-D to end)\n";
    my @description = <STDIN>;
    my $longd       = "@description";
    $bugz->description($longd);

    clearscreen();
    print "Adding bug...\n";
    my $bugnumber = $bugz->commit;
    print "Bug $bugnumber added.";
}

sub update_bug {
    my $BUG  = shift;
    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();
    print "Comment: (CTRL-D to end)\n";
    my @comments = <STDIN>;
    my $longc    = "@comments";
    $bugz->additional_comments($longc);
    print "\nBug $BUG updated\n" if $bugz->commit;

}

sub change_status {
    my $BUG  = shift;
    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();
    # What I would like to do here is offer a short menu of change status, add cc, mark as dup, reassign, depends_on, blocks
    print "Change Options\n";
    print "Status\nAdd cc:\nMark as Dup\nReassign\nDepends On...\nBlocks\n";
    print "Change: ";
    my $choice = <STDIN>;
    chomp($choice);
    clearscreen();
    if ($choice =~ /^sta/i){    
    my @status =
      qw(assigned fixed invalid wontfix later remind worksforme reopen verified closed);
    foreach my $change (@status) {
        print "$change\n";
    }
    print "Status Change: ";
    my $status = <STDIN>;
    chomp($status);
    $bugz->change_status($status);
    clearscreen();
    print "Comment: (CTRL-D to end)\n";
    my @comment = <STDIN>;
    my $longc   = "@comment";
    $bugz->additional_comments($longc);
    }
    elsif ($choice =~ /^ad/i) {
    print "Add CC: ";
    my $addcc = <STDIN>;
    chomp($addcc);
    $bugz->add_cc($addcc);
    # add cc code
    }
    elsif ($choice =~ /^ma/i) {
    #Mark as dup code
    print "Mark as duplicate of bug number: ";
    my $dupid = <STDIN>;
    chomp($dupid);
    $bugz->mark_as_duplicate("$dupid");
    }
    elsif ($choice =~ /^re/i) {
    # Reassign
    print "Reassign bug to :";
    my $newstuckee = <STDIN>;
    chomp($newstuckee);
    $bugz->reassign($newstuckee);
    }
    elsif ($choice =~ /^de/i) {
    # Depend block
    print "Bug depends on bug id: ";
    my $depper = <STDIN>;
    chomp($depper);
    $bugz->depends_on($depper);
    }
    elsif ($choice =~ /^bl/i) {
    # Blocks
    print "$BUG is a blocker of: ";
    my $blocker = <STDIN>;
    chomp($blocker);
    $bugz->blocks($blocker);
    }
    else { 
    clearscreen();
    print "Unable to proceed without a valid choice.\n";
    exit();
    }
    print "\nBug $BUG changed\n" if $bugz->commit;

}

sub add_attach {
    my $BUG = shift;

    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();
    print "Attachment with path (ex. /home/me/file.txt) :";
    my $attachment = <STDIN>;
    chomp($attachment);
    clearscreen();
    print "Description: ";
    my $descr = <STDIN>;
    chomp($descr);
    clearscreen();
    print "Is this a patch? (y/n) ";
    my $patch = <STDIN>;
    chomp($patch);
    if ( $patch =~ /y/i ) { $patch = 1 }
    else { $patch = 0 }
    clearscreen();
    print "Comment: (CTRL-D to end)\n";
    my @comment = <STDIN>;
    my $longc   = "@comment";
    clearscreen();
    $bugz->add_attachment(
        filepath    => $attachment,
        description => $descr,
        is_patch    => $patch,
        comment     => $longc
    );
    clearscreen();
    print "Attachment added to bug $BUG\n" if $bugz->commit;
}

# The following is a horrid hack, but I'm trying to keep the number of dependancies
# to a minimum in this package. So...

sub show_bug {
    require LWP::UserAgent;
my $BUG = shift;
    my $ua = LWP::UserAgent->new(
        env_proxy  => 1,
        keep_alive => 1,
        timeout    => 30,
    );
    my $request = HTTP::Request->new( 'GET',"http://bugs.gentoo.org/long_list.cgi?buglist=$BUG");
    my $response = $ua->request($request);
    die "Error while getting ", $response->request->uri, " -- ",
      $response->status_line, "\nAborting"
      unless $response->is_success;

    my $contents = $response->content;
    my $content = join(' ',$contents);
	 
    my @baseline = split( /\n/, $content );
    my $rowcount;
    my $bugzcount;
    foreach my $line ( @baseline ) {
	$bugzcount++ if ($line =~ /bugzilla\.org/);
	next unless ($bugzcount >=3);
	next if ($line =~ /bugzilla\.org/);
	last if ($bugzcount >=4);
	$line =~ s/^\s+//;
	$line =~ s#<\s*([^>]*)\s*>##ig;
	$line =~ s/\&quot;/\"/gm;
	$line =~ s/\&amp;/\&/gm;
	$line =~ s/\&gt;/\>/gm;
	$line =~ s/\&lt;/\</gm;
	next if ($line =~ /^\n$/);
	next if ($line eq "");
	print "$line\n";
	$rowcount++;
        if ( $rowcount >= $rows ) {
            print "Press Enter to Continue";
            my $junk = <STDIN>;
            $rowcount = 0;
        }

}
}

sub clearscreen {

    my $clear_string = `clear`;
    print $clear_string;
}
