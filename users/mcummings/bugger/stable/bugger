#!/usr/bin/perl
use Getopt::Long;
use Config::General;
my $configfile = "$ENV{'HOME'}/.bugger-config";

unless ( ( -f $configfile ) && ( -s $configfile ) ) {
    my $conf = new Config::General(
        -AutoTrue          => 1,
        -AllowMultiOptions => "yes",
        -ExtendedAccess    => 1,
    );
    print "Generating config file. This will reside at $configfile\n";
    print "\n";
    print "Bugzilla Server: (Default: bugs.gentoo.org) ";
    my $bugz = <STDIN>;
    chomp($bugz);
    unless ( $bugz =~ m/\w+/ ) { $bugz = "bugs.gentoo.org" }
    print "Login: (Usually your email address) ";
    my $login = <STDIN>;
    chomp($login);
    print "Password: ";
    my $pass = <STDIN>;
    chomp($pass);
    print "Rows to display per page: ";
    my $rows = <STDIN>;
    chomp($rows);
    if ( $rows < 1 ) { $rows = 20 }
    print "Download Directory for attachments: ";
    my $downd = <STDIN>;
    chomp($downd);
    my %contents;
    $contents{'server'}   = "$bugz";
    $contents{'login'}    = "$login";
    $contents{'password'} = "$pass";
    $contents{'rows'}     = "$rows";
    $contents{'downdir'}  = "$downd";
    $contents{'mode'}     = "flatmode";
    $conf->save_file( "$configfile", \%contents )
      or die "Can't save configfile! $!\n";
    my $mode  = '0600';
    my @files = $configfile;
    chmod oct($mode), @files;
    print "\nConfiguration saved.\n\nPress Enter to continue ";
    my $junk = <STDIN>;
}
my $conf = new Config::General(
    -AutoTrue          => 1,
    -AllowMultiOptions => "yes",
    -ExtendedAccess    => 1,
    -ConfigFile        => "$configfile",
    -IncludeRelative   => 1,
);
my %config   = $conf->getall;
my $login    = $config{'login'};
my $password = $config{'password'};
my $server   = $config{'server'};
my $rows     = $config{'rows'};

my $help       = '';
my $show       = '';
my $add        = '';
my $newdev     = '';
my $selfname   = $0;
my $cclist     = '';
my $list       = '';
my $update     = '';
my $change     = '';
my $attach     = '';
my $grab       = '';
my $devrel     = '';
my $reporter   = '';
my $closed     = '';
my $closedwith = '';
GetOptions(
    'help'         => \$help,
    'cclist=s'     => \$cclist,
    'list=s'       => \$list,
    'reporter=s'   => \$reporter,
    'closedby=s'   => \$closed,
    'closedwith=s' => \$closedwith,
    'add'          => \$add,
    'newdev'       => \$newdev,
    'devrel'       => \$devrel,
    'update=s'     => \$update,
    'change=s'     => \$change,
    'attach=s'     => \$attach,
    'grab=s'       => \$grab,
    'show=s'       => \$show,
);

if    ($help)       { helpme() }
elsif ($cclist)     { cclist_bugs($cclist) }
elsif ($list)       { list_bugs($list) }
elsif ($reporter)   { reporter($reporter) }
elsif ($closed)     { closed_by($closed) }
elsif ($closedwith) { closed_with($closedwith) }
elsif ($show)       { show_bug($show) }
elsif ($add)        { add_bug() }
elsif ($newdev)     { new_dev() }
elsif ($update)     { update_bug($update) }
elsif ($change)     { change_status($change) }
elsif ($attach)     { add_attach($attach) }
elsif ($grab)       { download_attach($grab) }
elsif ($devrel)     { dev_rel() }
else { helpme() }

sub helpme {
    print "Usage: $selfname\n";
    print "\t\t--list=loginID\tList bugs assigned to given loginID\n";
    print "\t\t--cclist=loginID\tList bugs with loginID as a CC\n";
    print "\t\t--reporter=loginID\tList bugs reported by loginID\n";
    print "\t\t--closedby=loginID\tList bugs closed with bugowner loginID\n";
    print
"\t\t--closedwith=loginID\tList bugs closed with bugowner or cc of loginID\n";
    print "\t\t--add\tAdd a new bug\n";
    print "\t\t--newdev\tAdd a new developer\n";
    print "\t\t--devrel\tAdd Developer Relations report\n";
    print "\t\t--update=BugID\tUpdate (comment on) given bug\n";
    print "\t\t--change=BugID\tChange bug status (fixed,invalid,etc)\n";
    print "\t\t--attach=BugID\tAdd an attachment to a bug\n";
    print "\t\t--grab=BugID\tGrab attachment from a bug\n";
    print "\t\t--show=BugID\tShow the contents of bug BugID\n";
    print "\t\t--help\tPrint this sad usage info\n";
    print "\n\nStill need to add nice die messages...\n\n";
}

sub list_bugs {
    my $bugfor = shift;
    chomp($bugfor);
    my $mech = connect_bugz();
    $mech->form_number(1);
    $mech->field( 'email1', $bugfor );
    $mech->field( 'email2', "" );
    $mech->untick( 'emailreporter2', '1' );
    $mech->select( 'order',      'Bug Number' );
    $mech->select( 'emailtype1', 'exact' );
    $mech->submit();

    $mech->follow_link( text_regex => qr/CSV/ );

    my $content = $mech->content();
    display_csv($content);

}

sub cclist_bugs {
    my $bugfor = shift;
    chomp($bugfor);
    my $mech = connect_bugz();
    $mech->form_number(1);
    $mech->field( 'email1', $bugfor );
    $mech->field( 'email2', "" );
    $mech->untick( 'emailassigned_to1', '1' );
    $mech->tick( 'emailcc1', '1' );
    $mech->untick( 'emailreporter2', '1' );
    $mech->select( 'order',      'Bug Number' );
    $mech->select( 'emailtype1', 'exact' );
    $mech->submit();

    $mech->follow_link( text_regex => qr/CSV/ );

    my $content = $mech->content();
    display_csv($content);

}

sub add_bug {
    use WWW::Bugzilla;

    # Recreating the form is just fun
    my $bugz = WWW::Bugzilla->new(
        server   => $server,
        email    => $login,
        product  => "Gentoo Linux",
        password => $password,
    );
    clearscreen();
    my @versions = $bugz->available('version');
    foreach my $vers (@versions) {
        print "$vers\n";
    }
    print "Version: ";
    my $version = <STDIN>;
    chomp($version);
    unless ($version) { $version = "unspecified" }
    $bugz->version($version);
    clearscreen();
    my @components = $bugz->available('component');

    foreach my $comp (@components) {
        print "$comp\n";
    }
    print "Component: ";
    my $component = <STDIN>;
    chomp($component);
    unless ($component) { $component = "Ebuilds" }
    $bugz->component($component);
    clearscreen();
    print "Assigned to: ";
    my $assigned = <STDIN>;
    chomp($assigned);
    $bugz->assigned_to($assigned);
    clearscreen();
    print "Summary: ";
    my $summary = <STDIN>;
    chomp($summary);
    $bugz->summary($summary);
    clearscreen();
    print "Long Description: (CTL-D to end)\n";
    my @description = <STDIN>;
    my $longd       = "@description";
    $bugz->description($longd);

    clearscreen();
    print "Adding bug...\n";
    my $bugnumber = $bugz->commit;
    print "Bug $bugnumber added.\n\n";
}

sub update_bug {
    my $BUG  = shift;
    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();
    print "Comment: (CTRL-D to end)\n";
    my @comments = <STDIN>;
    my $longc    = "@comments";
    $bugz->additional_comments($longc);
    print "\nBug $BUG updated\n" if $bugz->commit;

}

sub change_status {
    my $BUG  = shift;
    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();

# What I would like to do here is offer a short menu of change status, add cc, mark as dup, reassign, depends_on, blocks
    print "Change Options\n";
    print "Status\nAdd cc:\nMark as Dup\nReassign\nDepends On...\nBlocks\n";
    print "Change: ";
    my $choice = <STDIN>;
    chomp($choice);
    clearscreen();
    if ( $choice =~ /^sta/i ) {
        my @status =
          qw(assigned fixed invalid wontfix later remind worksforme reopen verified closed);
        foreach my $change (@status) {
            print "$change\n";
        }
        print "Status Change: ";
        my $status = <STDIN>;
        chomp($status);
        $bugz->change_status($status);
        clearscreen();
        print "Comment: (CTRL-D to end)\n";
        my @comment = <STDIN>;
        my $longc   = "@comment";
        $bugz->additional_comments($longc);
    }
    elsif ( $choice =~ /^ad/i ) {
        print "Add CC: ";
        my $addcc = <STDIN>;
        chomp($addcc);
        $bugz->add_cc($addcc);

        # add cc code
    }
    elsif ( $choice =~ /^ma/i ) {

        #Mark as dup code
        print "Mark as duplicate of bug number: ";
        my $dupid = <STDIN>;
        chomp($dupid);
        $bugz->mark_as_duplicate("$dupid");
    }
    elsif ( $choice =~ /^re/i ) {

        # Reassign
        print "Reassign bug to :";
        my $newstuckee = <STDIN>;
        clearscreen();
        print "Comment: (OPTIONAL. CTRL-D to end)\n";
        my @comment = <STDIN>;
        my $longc   = "@comment";
        if ( $longc =~ m/\w/ ) { $bugz->additional_comments($longc) }
        chomp($newstuckee);
        $bugz->reassign($newstuckee);
    }
    elsif ( $choice =~ /^de/i ) {

        # Depend block
        print "Bug depends on bug id: ";
        my $depper = <STDIN>;
        chomp($depper);
        $bugz->depends_on($depper);
    }
    elsif ( $choice =~ /^bl/i ) {

        # Blocks
        print "$BUG is a blocker of: ";
        my $blocker = <STDIN>;
        chomp($blocker);
        $bugz->blocks($blocker);
    }
    else {
        clearscreen();
        print "Unable to proceed without a valid choice.\n";
        exit();
    }
    print "\nBug $BUG changed\n" if $bugz->commit;

}

sub add_attach {
    my $BUG = shift;

    my $bugz = WWW::Bugzilla->new(
        server     => $server,
        email      => $login,
        password   => $password,
        bug_number => $BUG,
    );
    clearscreen();
    print "Attachment with path (ex. /home/me/file.txt) :";
    my $attachment = <STDIN>;
    chomp($attachment);
    clearscreen();
    print "Description: ";
    my $descr = <STDIN>;
    chomp($descr);
    clearscreen();
    print "Is this a patch? (y/n) ";
    my $patch = <STDIN>;
    chomp($patch);
    if ( $patch =~ /y/i ) { $patch = 1 }
    else { $patch = 0 }
    clearscreen();
    print "Comment: (CTRL-D to end)\n";
    my @comment = <STDIN>;
    my $longc   = "@comment";
    clearscreen();
    $bugz->add_attachment(
        filepath    => $attachment,
        description => $descr,
        is_patch    => $patch,
        comment     => $longc
    );
    clearscreen();
    print "Attachment added to bug $BUG\n" if $bugz->commit;
}

# The following is a horrid hack, but I'm trying to keep the number of dependancies
# to a minimum in this package. So...

sub show_bug {

    my $BUG = shift;
    chomp($BUG);
    my $mech = connect_bugz();

    $mech->submit_form(
        form_number => 2,
        fields      => { id => "$BUG", }
    );
    $mech->follow_link( text_regex => qr/format for printing/i );
    use HTML::Strip;

    my $TextBody = $mech->content();
    our $hs = HTML::Strip->new();
    my $hrcount;

    my $intext = $hs->parse("$TextBody");
    my @sintext = split( /\n/, $intext );
    for ( my $lcount = 58 ; $lcount <= @sintext ; $lcount++ ) {
        chomp( $sintext[$lcount] );
        $sintext[$lcount] =~ s/\s+/ /mg;
        next if ( $sintext[$lcount] =~ m/^\s+$/ );
        next if ( $sintext[$lcount] =~ m/^\n/ );
        next if ( $sintext[$lcount] =~ m/^\s{0,}\n$/ );
        last if ( $sintext[$lcount] =~ m/Bugzilla Version/ );
        print "$sintext[$lcount]\n";
        $rowcount++;

        if ( $rowcount >= $rows ) {
            print "Press Enter to Continue";
            my $junk = <STDIN>;
            $rowcount = 0;
        }
    }
}

sub download_attach {
    my $BUG = shift;
    use WWW::Mechanize;
    my $downdir = $config{'downdir'} || "/tmp";
    my $agent = WWW::Mechanize->new();
    $agent->get("http://bugs.gentoo.org/show_bug.cgi?id=$BUG");
    my $TextBody = $agent->content();
    my @TextBody = split( /\n/, $TextBody );
    my %grabbed  = ();
    foreach my $line (@TextBody) {

        if ( my ($download_url) = $line =~ m{(attachment\.cgi\?id=.*view)} ) {
            my $down = "http://bugs.gentoo.org/$download_url";
            my ($id) = $download_url =~ m{id=(\d+)\&amp};
            unless ( $grabbed{$id} == "1" ) {
                $grabbed{$id} = 1;

                print "  Downloading $down...\n ";
                my $response =
                  $agent->mirror( $down, "$downdir/$BUG-attachment-$id" );
            }
        }

    }

}

sub clean_line {
    my $line = shift;
    if ( $line =~ /\<input/i ) {
        $line =~ m/value\=\"(.*)\" size\=\"\d+\"\>/;
        $value = $1;
        $line =~ s/value\=\"(.*)\" size\=\"\d+\"\>/\>$1/;
    }
    if ( $line =~ / selected\>/i ) {
        my $tmpline = $line;
        $tmpline =~ / selected\>(\S+).*\<\/option/i;
        my $option = $1;
        if    ( $line =~ /iority/i )  { $line = "Priority : $option" }
        elsif ( $line =~ /everity/i ) { $line = "Severity : $option" }
        return ($line);
    }
    my $cleaned = $hs->parse("$line");
    $hs->eof;
    $cleaned =~ s/\t//gm;
    $cleaned =~ s/\s+/ /gm;
    $cleaned =~ s/ valign\=\"top\"//;
    $cleaned =~ s/^\>\s+//;
    if ( $cleaned =~ /^\w\s\w+\s\:/ ) { $cleaned =~ s/ // }
    return ($cleaned);

}

sub clearscreen {

    my $clear_string = `clear`;
    print $clear_string;
}

sub new_dev {
    use WWW::Bugzilla;

    # Recreating the form is just fun
    my $bugz = WWW::Bugzilla->new(
        server   => $server,
        email    => $login,
        product  => "New Gentoo Developers",
        password => $password,
    );
    $bugz->version("All");
    $bugz->component("New Developers");
    my $rep_platform = $bugz->available('rep_platform');
    clearscreen();
    my @platforms = $bugz->available('platform');
    foreach my $platf (@platforms) { print "$platf\n"; }
    print "Platform: ";
    my $arch = <STDIN>;
    chomp($arch);
    $bugz->platform($arch);
    clearscreen();

    print "Assigned to: ";
    my $assigned = <STDIN>;
    chomp($assigned);
    $bugz->assigned_to($assigned);
    clearscreen();
    print "Summary: ";
    my $summary = <STDIN>;
    chomp($summary);
    $bugz->summary($summary);
    clearscreen();
    print "Long Description: (CTL-D to end)\n";
    my @description = <STDIN>;
    my $longd       = "@description";
    $bugz->description($longd);

    clearscreen();
    print "Adding dev...\n";
    my $bugnumber = $bugz->commit;
    print "Bug $bugnumber added.\n\n";
}

sub dev_rel {
    use WWW::Bugzilla;

    # Recreating the form is just fun
    my $bugz = WWW::Bugzilla->new(
        server   => $server,
        email    => $login,
        product  => "Developer Relations",
        password => $password,
    );
    $bugz->version("unspecified");
    $bugz->component("Default");
    my $rep_platform = $bugz->available('rep_platform');
    clearscreen();
    my @platforms = $bugz->available('platform');
    foreach my $platf (@platforms) { print "$platf\n"; }
    print "Platform: ";
    my $arch = <STDIN>;
    chomp($arch);
    $bugz->platform($arch);
    clearscreen();

    print "Assigned to: ";
    my $assigned = <STDIN>;
    chomp($assigned);
    $bugz->assigned_to($assigned);
    clearscreen();
    print "Summary: ";
    my $summary = <STDIN>;
    chomp($summary);
    $bugz->summary($summary);
    clearscreen();
    print "Long Description: (CTL-D to end)\n";
    my @description = <STDIN>;
    my $longd       = "@description";
    $bugz->description($longd);

    clearscreen();
    print "Adding developer relations report...\n";
    my $bugnumber = $bugz->commit;
    print "Bug $bugnumber added.\n\n";
}

sub reporter {

    my $bugfor = shift;
    my $mech   = connect_bugz();

    $mech->form_number(1);
    $mech->field( 'email1', $bugfor );
    $mech->field( 'email2', "" );
    $mech->untick( 'emailassigned_to1', '1' );
    $mech->tick( 'emailreporter1', '1' );
    $mech->untick( 'emailreporter2', '1' );
    $mech->select( 'order',      'Bug Number' );
    $mech->select( 'emailtype1', 'exact' );
    $mech->submit();

    $mech->follow_link( text_regex => qr/CSV/ );

    my $content = $mech->content();
    display_csv($content);
}

sub closed_by {
    my $owner = shift;
    chomp($owner);
    my $mech = connect_bugz();

    $mech->form_number(1);
    my @status = ( RESOLVED, VERIFIED, CLOSED );
    my @resolution = ( FIXED, INVALID, WONTFIX, CANTFIX,
        NEEDINFO,  TEST-REQUEST, LATER, REMIND,
        DUPLICATE, WORKSFORME,   MOVED, UPSTREAM
    );
    $mech->select( 'bug_status', \@status );
    $mech->select( 'resolution', \@resoltion );
    $mech->field( 'email1', $owner );
    $mech->field( 'email2', "" );
    $mech->tick( 'emailassigned_to1', '1' );
    $mech->untick( 'emailreporter2', '1' );
    $mech->select( 'order',      'Bug Number' );
    $mech->select( 'emailtype1', 'exact' );
    $mech->submit();

    $mech->follow_link( text_regex => qr/CSV/ );

    my $content = $mech->content();
    display_csv($content);

}

sub closed_with {
    my $owner = shift;
    chomp($owner);
    my $mech = connect_bugz();

    $mech->form_number(1);
    my @status = ( RESOLVED, VERIFIED, CLOSED );
    my @resolution = ( FIXED, INVALID, WONTFIX, CANTFIX,
        NEEDINFO,  TEST-REQUEST, LATER, REMIND,
        DUPLICATE, WORKSFORME,   MOVED, UPSTREAM
    );
    $mech->select( 'bug_status', \@status );
    $mech->select( 'resolution', \@resoltion );
    $mech->field( 'email1', $owner );
    $mech->field( 'email2', "" );
    $mech->tick( 'emailassigned_to1', '1' );
    $mech->tick( 'emailcc1',          '1' );
    $mech->untick( 'emailreporter2', '1' );
    $mech->select( 'order',      'Bug Number' );
    $mech->select( 'emailtype1', 'substring' );
    $mech->submit();

    $mech->follow_link( text_regex => qr/CSV/ );

    my $content = $mech->content();
    display_csv($content);
}

sub connect_bugz {
    use WWW::Mechanize;
    my $mechver = $WWW::Mechanize::VERSION;
    if ( $mechver <= 1.01 ) {
        print
"\n\nbugger requires that you have at least version 1.02 of WWW::Mechanize\nPlease emerge -U WWW-Mechanize before using bugger.\n\n";
        exit();
    }
    my $agent = WWW::Mechanize->new();
    $agent->get("http://bugs.gentoo.org/query.cgi?GoAheadAndLogIn=1");
    $agent->submit_form(
        fields => {
            Bugzilla_login    => $login,
            Bugzilla_password => $password,
        }
    );
    return ($agent);
}

sub display_csv {
    my $content = shift;
    chomp($content);

    my @baseline = split( /\n/, $content );
    my $returncount = @baseline;
    $returncount--;
    print "$returncount items returned\n";
    my $rowcount = 1;
    foreach my $line ( sort @baseline ) {
        $line =~ s/\"//mg;
        my @rowline = split( /,/, $line );
        next if ( $rowline[0] =~ m/bug_id/ );
        next if ( $rowline[0] eq "" );
        next if ( $rowline[0] =~ /^\n$/ );
        $rowcount = $rowcount + 4;
        print "Bug ID $rowline[0]\nPriority $rowline[1]\n$rowline[7]\n\n";
        if ( $rowcount >= $rows ) {
            print "Press Enter to Continue";
            my $junk = <STDIN>;
            $rowcount = 0;
        }
    }
}
