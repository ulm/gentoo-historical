#!/bin/bash
INGEN_DATA=/.ingen
SYSROOT=/mnt/gentoo
INGEN_PKG=sys-apps/ingen

 debug() { [  $DEBUG ] && echo DEBUG: "$@"; }
sdebug() { [ $SDEBUG ] && echo DEBUG: "$@"; }
pushvar() {	eval "$1_stack=\"\$$1:\$$1_stack\""; }
popvar() {
	var="$1"	svar="$1_stack"
	eval "$var=\"\`echo \"\$$svar\" | sed 's%:.*\$%%'\`\""
	eval "$svar=\"\`echo \"\$$svar\"| egrep -o ':.*\$' | cut -b 2-\`\""
	eval "if test \"\$$svar\" == \"\"; then unset \$$svar; fi"
}
outnull() {
	"$@" >/dev/null 2>&1
}
debugoutput() {
	# This function uses 'sdebug' on stdout, and then (after completed) uses
	# 'debug "WARNING: $stderr_output'
	# It should, however, intermix the stdout and stderr as it comes from the
	# eval line. If anyone knows how, please let me know.

	# Process stderr first:
	#{ { writer | stdout-reader >&3 2>&4; } 2>&1 | stderr-reader; } 4>&2 3>&1
	# Process stdout first:
	#{ { { writer >&3; } 2>&1 | stderr-reader >&4; } 3>&1 | stdout-reader; } 4>&2

	{ { { { eval "$@"; } >&3; } 2>&1 | while read a; do debug "WARNING: $a"; done >&4; } 3>&1 | while read a; do sdebug "$a"; done; } 4>&2
}

