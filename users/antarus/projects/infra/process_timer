#!/usr/bin/python
# $Header: /var/cvsroot/gentoo/users/antarus/projects/infra/process_timer,v 1.10 2008/07/06 19:11:06 robbat2 Exp $
# Copyright Alec Warner 2008
# Released in the public domain.

"""Find tasks that have been running over X time.

Look in /proc, match on some regexes, offer to print pids that match
options given by the user.

TODO: cmdline is an 'array' of null terminated strings and we don't handle that
correctly right now.
"""


__author__ = """Alec Warner <antarus@gentoo.org>"""

import logging
import optparse
import os
import re

PROC_PATH='/proc'

TIME_KEYS = ['walltime', 'utime', 'stime', 'cutime', 'cstime', 'starttime', 'cpu', 'ccpu']

def GetOpts():
  """Parse the options."""

  parser = optparse.OptionParser()
  parser.add_option('-p', '--prog', help='program to search for')
  parser.add_option('-t', '--time', help='max time prog can run (in format: 3h30m10s)',
                    default='10s')
  parser.add_option('-m', '--match', type='choice',
                    default='walltime', choices=TIME_KEYS, 
                    help='match time against a given choice')
  parser.add_option('-v', '--verbose', help='increase loglevel', action='store_true')
  opts, args = parser.parse_args()

  if opts.time:
    opts.time = StringToEpochTime(opts.time)

  if not opts.prog:
    parser.error('--prog is required')

  if opts.verbose:
    map(logging.getLogger().setLevel(
        logging.getLogger().getEffectiveLevel() - 10),
        xrange(int(opts.verbose)))

  logging.info('opts are %s' % opts)

  return opts, args

time_atom_re = re.compile(r'(\d)+(\w)')

def StringToEpochTime(str_time):
  """Return time in Epoch time given a string identifier.

  To support strings such as '3h30m' this function recursively calls itself
  with substrings as a argument (first call parses '3h', second call parses '30m'
  results are summed.)

  Args:
    str_time: a string representing a time interval, eg. '3h5m' or '52w'
  Returns:
    Unix timestamp of the amount of time specified.
  """
  
  # Shortcut
  try:
    result = int(str_time)
    if str_time == str(result):
      return result
  except ValueError:
    None
  
  result = 0
  match = time_atom_re.match(str_time)
  if not match:
    raise ValueError('argument not in valid format ((\d)+(\w))+: %s' % str_time)
  else:
    value, identifier = match.groups()
    value = int(value)
    if identifier == 's':
      result += value
    elif identifier == 'm':
      result += value * 60
    elif identifier == 'h':
      result += value * 3600
    elif identifier == 'd':
      result += value * 86400
    elif identifier == 'w':
      result += value * 604800
    else:
      raise ValueError('Time identifier not one of "smhdw"')

    s = ''.join(match.groups())
    str_time = str_time[str_time.find(s) + len(s):]
    if len(str_time):
      result += StringToEpochTime(str_time)
    else:
      return result


def FindPids(search_str):
  """Return PIDS for all processes that have match search_str.
  Args:
    search_str: match /proc/*/cmdline to this string.
  Returns:
    (pid, cmdline), PIDS of processes that match search_str
  """
  matches = set()

  pid_re = re.compile(r'[0-9]+')

  files = os.listdir(PROC_PATH)
  files = [f for f in files if pid_re.match(f)]

  # we shouldn't output ourselves
  my_pid = str(os.getpid())
  if my_pid in files:
    files.remove(my_pid)

  logging.debug('pids avaialble: %s' % files)

  for pid in files:
    PID_DIR_PATH = os.path.join(PROC_PATH, pid)
    CMDLINE_FILE = os.path.join(PID_DIR_PATH, 'cmdline')
    try:
      cmdline = open(CMDLINE_FILE).read().split('\0')
      logging.debug('cmdline: %s' % cmdline)
      match = filter(None, [search_str in command for command in cmdline])
      if match:
        logging.debug('matched %s' % pid)
        matches.add((pid, str(cmdline)))
    except IOError:
        continue

  logging.info('pids matched: %s' % matches)

  return matches


def CalculateTime(pid):
  """Calculate walltime, runtime, and other random time bits for PID.
  Args:
    pid: pid to make time calculations for.
  Returns:
    A dict of random times.

  These times are in 'jiffies' or as far as I can tell USER_HZ or 1/100ths
  of a second slices on recent linux kernels.
  """

  # Initialize to zero, because the /proc files CAN go away while we are running
  utime = stime = cutime = cstime = wall = starttime = 0

  PID_DIR_PATH = os.path.join(PROC_PATH, pid)
  # Yup, the file can go away very fast.
  try:
    data = open(os.path.join(PID_DIR_PATH, 'stat')).read().split(' ')
    utime, stime, cutime, cstime = map(int, data[13:17])
    starttime = int(data[21])
  except IOError:
    _
  # If this one goes away, we're in shit anyway
  uptime = open(os.path.join(PROC_PATH, 'uptime')).read().split(' ')[0] 

  wall = int(float(uptime)*100 - float(starttime))

  d = { 'utime' : utime,
        'stime' : stime,
        'cutime' : cutime,
        'cstime' : cstime,
        'cpu' : utime + stime,
        'ccpu' : cutime + cstime,
        'walltime' : wall,
        'starttime' : starttime }

  return d


def Main():
  """Main Driver function."""

  opts, args = GetOpts()
  pids = FindPids(opts.prog)
  for pid in pids:
    times = CalculateTime(pid[0])
    logging.info("Times: %s: %s" % (pid[1], times))
    if opts.match:
      if opts.match in times:
        if times[opts.match] / 100 > opts.time: 
          print pid[0]

if __name__ == "__main__":
  Main()
